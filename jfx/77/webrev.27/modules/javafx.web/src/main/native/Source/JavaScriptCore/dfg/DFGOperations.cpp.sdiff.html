<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGObjectAllocationSinkingPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  79 #include &quot;VMInlines.h&quot;
  80 #include &lt;wtf/InlineASM.h&gt;
  81 #include &lt;wtf/Variant.h&gt;
  82 
  83 #if ENABLE(JIT)
  84 #if ENABLE(DFG_JIT)
  85 
  86 namespace JSC { namespace DFG {
  87 
  88 template&lt;bool strict, bool direct&gt;
  89 static inline void putByVal(ExecState* exec, VM&amp; vm, JSValue baseValue, uint32_t index, JSValue value)
  90 {
  91     ASSERT(isIndex(index));
  92     if (direct) {
  93         RELEASE_ASSERT(baseValue.isObject());
  94         asObject(baseValue)-&gt;putDirectIndex(exec, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
  95         return;
  96     }
  97     if (baseValue.isObject()) {
  98         JSObject* object = asObject(baseValue);
<span class="line-modified">  99         if (object-&gt;canSetIndexQuickly(index)) {</span>
 100             object-&gt;setIndexQuickly(vm, index, value);
 101             return;
 102         }
 103 
 104         object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, index, value, strict);
 105         return;
 106     }
 107 
 108     baseValue.putByIndex(exec, index, value, strict);
 109 }
 110 
 111 template&lt;bool strict, bool direct&gt;
 112 ALWAYS_INLINE static void putByValInternal(ExecState* exec, VM&amp; vm, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 113 {
 114     auto scope = DECLARE_THROW_SCOPE(vm);
 115 
 116     JSValue baseValue = JSValue::decode(encodedBase);
 117     JSValue property = JSValue::decode(encodedProperty);
 118     JSValue value = JSValue::decode(encodedValue);
 119 
</pre>
<hr />
<pre>
 172     }
 173     base-&gt;putInline(exec, propertyName, value, slot);
 174 }
 175 
 176 template&lt;bool strict, bool direct&gt;
 177 ALWAYS_INLINE static void putByValCellStringInternal(ExecState* exec, VM&amp; vm, JSCell* base, JSString* property, JSValue value)
 178 {
 179     auto scope = DECLARE_THROW_SCOPE(vm);
 180 
 181     auto propertyName = property-&gt;toIdentifier(exec);
 182     RETURN_IF_EXCEPTION(scope, void());
 183 
 184     scope.release();
 185     putByValCellInternal&lt;strict, direct&gt;(exec, vm, base, propertyName, value);
 186 }
 187 
 188 template&lt;typename ViewClass&gt;
 189 char* newTypedArrayWithSize(ExecState* exec, Structure* structure, int32_t size, char* vector)
 190 {
 191     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 192     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 193     auto scope = DECLARE_THROW_SCOPE(vm);
 194 
 195     if (size &lt; 0) {
 196         throwException(exec, scope, createRangeError(exec, &quot;Requested length is negative&quot;_s));
 197         return 0;
 198     }
 199 
 200     if (vector)
<span class="line-modified"> 201         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(exec, structure, size, vector));</span>
 202 
 203     RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(exec, structure, size)));
 204 }
 205 
 206 template &lt;bool strict&gt;
 207 static ALWAYS_INLINE void putWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, const Identifier&amp; ident)
 208 {
 209     JSValue baseValue = JSValue::decode(encodedBase);
 210     JSValue thisVal = JSValue::decode(encodedThis);
 211     JSValue putValue = JSValue::decode(encodedValue);
 212     PutPropertySlot slot(thisVal, strict);
 213     baseValue.putInline(exec, ident, putValue, slot);
 214 }
 215 






















































 216 static ALWAYS_INLINE EncodedJSValue parseIntResult(double input)
 217 {
 218     int asInt = static_cast&lt;int&gt;(input);
 219     if (static_cast&lt;double&gt;(asInt) == input)
 220         return JSValue::encode(jsNumber(asInt));
 221     return JSValue::encode(jsNumber(input));
 222 }
 223 
 224 ALWAYS_INLINE static JSValue getByValObject(ExecState* exec, VM&amp; vm, JSObject* base, PropertyName propertyName)
 225 {
 226     Structure&amp; structure = *base-&gt;structure(vm);
 227     if (JSCell::canUseFastGetOwnProperty(structure)) {
 228         if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, propertyName))
 229             return result;
 230     }
 231     return base-&gt;get(exec, propertyName);
 232 }
 233 
 234 extern &quot;C&quot; {
 235 
 236 EncodedJSValue JIT_OPERATION operationToThis(ExecState* exec, EncodedJSValue encodedOp)
 237 {
<span class="line-modified"> 238     VM* vm = &amp;exec-&gt;vm();</span>
 239     NativeCallFrameTracer tracer(vm, exec);
 240 
 241     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, NotStrictMode));
 242 }
 243 
 244 EncodedJSValue JIT_OPERATION operationToThisStrict(ExecState* exec, EncodedJSValue encodedOp)
 245 {
<span class="line-modified"> 246     VM* vm = &amp;exec-&gt;vm();</span>
 247     NativeCallFrameTracer tracer(vm, exec);
 248 
 249     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, StrictMode));
 250 }
 251 
 252 JSArray* JIT_OPERATION operationObjectKeys(ExecState* exec, EncodedJSValue encodedObject)
 253 {
 254     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 255     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 256     auto scope = DECLARE_THROW_SCOPE(vm);
 257 
 258     JSObject* object = JSValue::decode(encodedObject).toObject(exec);
 259     RETURN_IF_EXCEPTION(scope, nullptr);
 260     scope.release();
 261     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
 262 }
 263 
 264 JSArray* JIT_OPERATION operationObjectKeysObject(ExecState* exec, JSObject* object)
 265 {
 266     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 267     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 268     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
 269 }
 270 
 271 JSCell* JIT_OPERATION operationObjectCreate(ExecState* exec, EncodedJSValue encodedPrototype)
 272 {
 273     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 274     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 275     auto scope = DECLARE_THROW_SCOPE(vm);
 276 
 277     JSValue prototype = JSValue::decode(encodedPrototype);
 278 
 279     if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
 280         throwVMTypeError(exec, scope, &quot;Object prototype may only be an Object or null.&quot;_s);
 281         return nullptr;
 282     }
 283 
 284     if (prototype.isObject())
 285         RELEASE_AND_RETURN(scope, constructEmptyObject(exec, asObject(prototype)));
 286     RELEASE_AND_RETURN(scope, constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure()));
 287 }
 288 
 289 JSCell* JIT_OPERATION operationObjectCreateObject(ExecState* exec, JSObject* prototype)
 290 {
 291     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 292     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 293     return constructEmptyObject(exec, prototype);
 294 }
 295 
 296 JSCell* JIT_OPERATION operationCreateThis(ExecState* exec, JSObject* constructor, uint32_t inlineCapacity)
 297 {
 298     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 299     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 300     auto scope = DECLARE_THROW_SCOPE(vm);
 301     if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
 302         auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity);
 303         scope.releaseAssertNoException();
<span class="line-modified"> 304         ObjectAllocationProfile* allocationProfile = rareData-&gt;objectAllocationProfile();</span>
 305         Structure* structure = allocationProfile-&gt;structure();
 306         JSObject* result = constructEmptyObject(exec, structure);
 307         if (structure-&gt;hasPolyProto()) {
 308             JSObject* prototype = allocationProfile-&gt;prototype();
 309             ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, exec));
 310             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 311             prototype-&gt;didBecomePrototype();
 312             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 313         }
 314         return result;
 315     }
 316 
 317     JSValue proto = constructor-&gt;get(exec, vm.propertyNames-&gt;prototype);
 318     RETURN_IF_EXCEPTION(scope, nullptr);
 319     if (proto.isObject())
 320         return constructEmptyObject(exec, asObject(proto));
 321     return constructEmptyObject(exec);
 322 }
 323 
 324 JSCell* JIT_OPERATION operationCallObjectConstructor(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget)
 325 {
<span class="line-modified"> 326     VM* vm = &amp;exec-&gt;vm();</span>
 327     NativeCallFrameTracer tracer(vm, exec);
 328 
 329     JSValue value = JSValue::decode(encodedTarget);
 330     ASSERT(!value.isObject());
 331 
 332     if (value.isUndefinedOrNull())
 333         return constructEmptyObject(exec, globalObject-&gt;objectPrototype());
 334     return value.toObject(exec, globalObject);
 335 }
 336 
 337 JSCell* JIT_OPERATION operationToObject(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)
 338 {
<span class="line-modified"> 339     VM* vm = &amp;exec-&gt;vm();</span>
 340     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 341     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 342 
 343     JSValue value = JSValue::decode(encodedTarget);
 344     ASSERT(!value.isObject());
 345 
 346     if (UNLIKELY(value.isUndefinedOrNull())) {
 347         if (errorMessage-&gt;length()) {
 348             throwVMTypeError(exec, scope, errorMessage);
 349             return nullptr;
 350         }
 351     }
 352 
 353     RELEASE_AND_RETURN(scope, value.toObject(exec, globalObject));
 354 }
 355 
<span class="line-modified"> 356 EncodedJSValue JIT_OPERATION operationValueBitNot(ExecState* exec, EncodedJSValue encodedOp1)</span>
 357 {
<span class="line-modified"> 358     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 359     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 360     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 361 
<span class="line-modified"> 362     JSValue op1 = JSValue::decode(encodedOp1);</span>


 363 
<span class="line-modified"> 364     int32_t operandValue = op1.toInt32(exec);</span>
<span class="line-removed"> 365     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 366 </span>
<span class="line-removed"> 367     return JSValue::encode(jsNumber(~operandValue));</span>
 368 }
 369 
<span class="line-modified"> 370 EncodedJSValue JIT_OPERATION operationValueBitAnd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 371 {
<span class="line-modified"> 372     VM* vm = &amp;exec-&gt;vm();</span>
 373     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 374     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 375 
 376     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-removed"> 377     JSValue op2 = JSValue::decode(encodedOp2);</span>
 378 
<span class="line-modified"> 379     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-removed"> 380     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 381     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
 382     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 383 
<span class="line-modified"> 384     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified"> 385         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed"> 386             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-removed"> 387             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 388             return JSValue::encode(result);</span>
<span class="line-removed"> 389         }</span>
<span class="line-removed"> 390 </span>
<span class="line-removed"> 391         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;);</span>
<span class="line-removed"> 392     }</span>
 393 
<span class="line-modified"> 394     return JSValue::encode(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));</span>
 395 }
 396 
<span class="line-modified"> 397 EncodedJSValue JIT_OPERATION operationValueBitOr(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 398 {
<span class="line-modified"> 399     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 400     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 401     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 402 
<span class="line-modified"> 403     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-modified"> 404     JSValue op2 = JSValue::decode(encodedOp2);</span>

 405 
<span class="line-modified"> 406     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-modified"> 407     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 408     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
<span class="line-removed"> 409     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
 410 
<span class="line-modified"> 411     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified"> 412         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified"> 413             JSBigInt* result = JSBigInt::bitwiseOr(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-modified"> 414             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-modified"> 415             return JSValue::encode(result);</span>
<span class="line-removed"> 416         }</span>
 417 
<span class="line-modified"> 418         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;);</span>
<span class="line-modified"> 419     }</span>

 420 
<span class="line-modified"> 421     return JSValue::encode(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));</span>
 422 }
 423 
 424 EncodedJSValue JIT_OPERATION operationValueBitXor(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 425 {
<span class="line-modified"> 426     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 427     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 428     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="line-removed"> 429 </span>
<span class="line-removed"> 430     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-removed"> 431     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-removed"> 432 </span>
<span class="line-removed"> 433     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-removed"> 434     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 435     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
<span class="line-removed"> 436     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 437 </span>
<span class="line-removed"> 438     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed"> 439         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed"> 440             JSBigInt* result = JSBigInt::bitwiseXor(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-removed"> 441             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 442             return JSValue::encode(result);</span>
<span class="line-removed"> 443         }</span>
 444 
<span class="line-modified"> 445         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;);</span>
<span class="line-modified"> 446     }</span>

 447 
<span class="line-modified"> 448     return JSValue::encode(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));</span>
 449 }
 450 
 451 EncodedJSValue JIT_OPERATION operationValueBitLShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 452 {
<span class="line-modified"> 453     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 454     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 455     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 456 
<span class="line-modified"> 457     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-modified"> 458     JSValue op2 = JSValue::decode(encodedOp2);</span>

 459 
<span class="line-modified"> 460     int32_t a = op1.toInt32(exec);</span>
<span class="line-removed"> 461     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 462     scope.release();</span>
<span class="line-removed"> 463     uint32_t b = op2.toUInt32(exec);</span>
<span class="line-removed"> 464     return JSValue::encode(jsNumber(a &lt;&lt; (b &amp; 0x1f)));</span>
 465 }
 466 
 467 EncodedJSValue JIT_OPERATION operationValueBitRShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 468 {
<span class="line-modified"> 469     VM* vm = &amp;exec-&gt;vm();</span>
 470     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 471     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 472 
 473     JSValue op1 = JSValue::decode(encodedOp1);
 474     JSValue op2 = JSValue::decode(encodedOp2);
 475 
 476     int32_t a = op1.toInt32(exec);
 477     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 478     scope.release();
 479     uint32_t b = op2.toUInt32(exec);
 480     return JSValue::encode(jsNumber(a &gt;&gt; (b &amp; 0x1f)));
 481 }
 482 
 483 EncodedJSValue JIT_OPERATION operationValueBitURShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 484 {
<span class="line-modified"> 485     VM* vm = &amp;exec-&gt;vm();</span>
 486     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 487     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 488 
 489     JSValue op1 = JSValue::decode(encodedOp1);
 490     JSValue op2 = JSValue::decode(encodedOp2);
 491 
 492     uint32_t a = op1.toUInt32(exec);
 493     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 494     scope.release();
 495     uint32_t b = op2.toUInt32(exec);
 496     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
 497 }
 498 
 499 EncodedJSValue JIT_OPERATION operationValueAddNotNumber(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 500 {
<span class="line-modified"> 501     VM* vm = &amp;exec-&gt;vm();</span>
 502     NativeCallFrameTracer tracer(vm, exec);
 503 
 504     JSValue op1 = JSValue::decode(encodedOp1);
 505     JSValue op2 = JSValue::decode(encodedOp2);
 506 
 507     return JSValue::encode(jsAddNonNumber(exec, op1, op2));
 508 }
 509 
 510 EncodedJSValue JIT_OPERATION operationValueDiv(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 511 {
<span class="line-modified"> 512     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 513     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 514     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-removed"> 517     JSValue op2 = JSValue::decode(encodedOp2);</span>
 518 
<span class="line-modified"> 519     auto leftNumeric = op1.toNumeric(exec);</span>
<span class="line-modified"> 520     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-modified"> 521     auto rightNumeric = op2.toNumeric(exec);</span>
<span class="line-removed"> 522     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
 523 
<span class="line-modified"> 524     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified"> 525         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed"> 526             JSBigInt* result = JSBigInt::divide(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-removed"> 527             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 528             return JSValue::encode(result);</span>
<span class="line-removed"> 529         }</span>
 530 
<span class="line-modified"> 531         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
<span class="line-modified"> 532     }</span>



 533 
<span class="line-modified"> 534     scope.release();</span>


 535 
<span class="line-modified"> 536     double a = WTF::get&lt;double&gt;(leftNumeric);</span>
<span class="line-removed"> 537     double b = WTF::get&lt;double&gt;(rightNumeric);</span>
<span class="line-removed"> 538     return JSValue::encode(jsNumber(a / b));</span>
 539 }
 540 
 541 double JIT_OPERATION operationArithAbs(ExecState* exec, EncodedJSValue encodedOp1)
 542 {
<span class="line-modified"> 543     VM* vm = &amp;exec-&gt;vm();</span>
 544     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 545     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 546 
 547     JSValue op1 = JSValue::decode(encodedOp1);
 548     double a = op1.toNumber(exec);
 549     RETURN_IF_EXCEPTION(scope, PNaN);
 550     return fabs(a);
 551 }
 552 
 553 uint32_t JIT_OPERATION operationArithClz32(ExecState* exec, EncodedJSValue encodedOp1)
 554 {
<span class="line-modified"> 555     VM* vm = &amp;exec-&gt;vm();</span>
 556     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 557     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 558 
 559     JSValue op1 = JSValue::decode(encodedOp1);
 560     uint32_t value = op1.toUInt32(exec);
 561     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified"> 562     return clz32(value);</span>
 563 }
 564 
 565 double JIT_OPERATION operationArithFRound(ExecState* exec, EncodedJSValue encodedOp1)
 566 {
<span class="line-modified"> 567     VM* vm = &amp;exec-&gt;vm();</span>
 568     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 569     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 570 
 571     JSValue op1 = JSValue::decode(encodedOp1);
 572     double a = op1.toNumber(exec);
 573     RETURN_IF_EXCEPTION(scope, PNaN);
 574     return static_cast&lt;float&gt;(a);
 575 }
 576 
 577 #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
 578 double JIT_OPERATION operationArith##capitalizedName(ExecState* exec, EncodedJSValue encodedOp1) \
 579 { \
<span class="line-modified"> 580     VM* vm = &amp;exec-&gt;vm(); \</span>
 581     NativeCallFrameTracer tracer(vm, exec); \
<span class="line-modified"> 582     auto scope = DECLARE_THROW_SCOPE(*vm); \</span>
 583     JSValue op1 = JSValue::decode(encodedOp1); \
 584     double result = op1.toNumber(exec); \
 585     RETURN_IF_EXCEPTION(scope, PNaN); \
 586     return JSC::Math::lowerName(result); \
 587 }
 588     FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
 589 #undef DFG_ARITH_UNARY
 590 
 591 double JIT_OPERATION operationArithSqrt(ExecState* exec, EncodedJSValue encodedOp1)
 592 {
<span class="line-modified"> 593     VM* vm = &amp;exec-&gt;vm();</span>
 594     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 595     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 596 
 597     JSValue op1 = JSValue::decode(encodedOp1);
 598     double a = op1.toNumber(exec);
 599     RETURN_IF_EXCEPTION(scope, PNaN);
 600     return sqrt(a);
 601 }
 602 
 603 EncodedJSValue JIT_OPERATION operationArithRound(ExecState* exec, EncodedJSValue encodedArgument)
 604 {
<span class="line-modified"> 605     VM* vm = &amp;exec-&gt;vm();</span>
 606     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 607     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 608 
 609     JSValue argument = JSValue::decode(encodedArgument);
 610     double valueOfArgument = argument.toNumber(exec);
 611     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 612     return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
 613 }
 614 
 615 EncodedJSValue JIT_OPERATION operationArithFloor(ExecState* exec, EncodedJSValue encodedArgument)
 616 {
<span class="line-modified"> 617     VM* vm = &amp;exec-&gt;vm();</span>
 618     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 619     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 620 
 621     JSValue argument = JSValue::decode(encodedArgument);
 622     double valueOfArgument = argument.toNumber(exec);
 623     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 624     return JSValue::encode(jsNumber(floor(valueOfArgument)));
 625 }
 626 
 627 EncodedJSValue JIT_OPERATION operationArithCeil(ExecState* exec, EncodedJSValue encodedArgument)
 628 {
<span class="line-modified"> 629     VM* vm = &amp;exec-&gt;vm();</span>
 630     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 631     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 632 
 633     JSValue argument = JSValue::decode(encodedArgument);
 634     double valueOfArgument = argument.toNumber(exec);
 635     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 636     return JSValue::encode(jsNumber(ceil(valueOfArgument)));
 637 }
 638 
 639 EncodedJSValue JIT_OPERATION operationArithTrunc(ExecState* exec, EncodedJSValue encodedArgument)
 640 {
<span class="line-modified"> 641     VM* vm = &amp;exec-&gt;vm();</span>
 642     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 643     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 644 
 645     JSValue argument = JSValue::decode(encodedArgument);
 646     double truncatedValueOfArgument = argument.toIntegerPreserveNaN(exec);
 647     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 648     return JSValue::encode(jsNumber(truncatedValueOfArgument));
 649 }
 650 
 651 static ALWAYS_INLINE EncodedJSValue getByVal(ExecState* exec, JSCell* base, uint32_t index)
 652 {
 653     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 654     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 655 
 656     if (base-&gt;isObject()) {
 657         JSObject* object = asObject(base);
 658         if (object-&gt;canGetIndexQuickly(index))
 659             return JSValue::encode(object-&gt;getIndexQuickly(index));
 660     }
 661 
 662     if (isJSString(base) &amp;&amp; asString(base)-&gt;canGetIndex(index))
 663         return JSValue::encode(asString(base)-&gt;getIndex(exec, index));
 664 
 665     return JSValue::encode(JSValue(base).get(exec, index));
 666 }
 667 
 668 EncodedJSValue JIT_OPERATION operationGetByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty)
 669 {
 670     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 671     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 672     auto scope = DECLARE_THROW_SCOPE(vm);
 673 
 674     JSValue baseValue = JSValue::decode(encodedBase);
 675     JSValue property = JSValue::decode(encodedProperty);
 676 
 677     if (LIKELY(baseValue.isCell())) {
 678         JSCell* base = baseValue.asCell();
 679 
 680         if (property.isUInt32())
 681             RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));
 682 
 683         if (property.isDouble()) {
 684             double propertyAsDouble = property.asDouble();
 685             uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 686             if (propertyAsUInt32 == propertyAsDouble &amp;&amp; isIndex(propertyAsUInt32))
 687                 RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
 688 
 689         } else if (property.isString()) {
 690             Structure&amp; structure = *base-&gt;structure(vm);
 691             if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 692                 if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(property)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified"> 693                     if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>


 694                         return JSValue::encode(result);
 695                 }
 696             }
 697         }
 698     }
 699 
 700     baseValue.requireObjectCoercible(exec);
 701     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 702     auto propertyName = property.toPropertyKey(exec);
 703     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 704     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, propertyName)));
 705 }
 706 
 707 EncodedJSValue JIT_OPERATION operationGetByValCell(ExecState* exec, JSCell* base, EncodedJSValue encodedProperty)
 708 {
 709     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 710     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 711     auto scope = DECLARE_THROW_SCOPE(vm);
 712 
 713     JSValue property = JSValue::decode(encodedProperty);
 714 
 715     if (property.isUInt32())
 716         RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));
 717 
 718     if (property.isDouble()) {
 719         double propertyAsDouble = property.asDouble();
 720         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 721         if (propertyAsUInt32 == propertyAsDouble)
 722             RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
 723 
 724     } else if (property.isString()) {
 725         Structure&amp; structure = *base-&gt;structure(vm);
 726         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 727             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(property)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified"> 728                 if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>


 729                     return JSValue::encode(result);
 730             }
 731         }
 732     }
 733 
 734     auto propertyName = property.toPropertyKey(exec);
 735     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 736     RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(exec, propertyName)));
 737 }
 738 
 739 ALWAYS_INLINE EncodedJSValue getByValCellInt(ExecState* exec, JSCell* base, int32_t index)
 740 {
<span class="line-modified"> 741     VM* vm = &amp;exec-&gt;vm();</span>
 742     NativeCallFrameTracer tracer(vm, exec);
 743 
 744     if (index &lt; 0) {
 745         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified"> 746         return JSValue::encode(JSValue(base).get(exec, Identifier::from(exec, index)));</span>
 747     }
 748 
 749     // Use this since we know that the value is out of bounds.
 750     return JSValue::encode(JSValue(base).get(exec, static_cast&lt;unsigned&gt;(index)));
 751 }
 752 
 753 EncodedJSValue JIT_OPERATION operationGetByValObjectInt(ExecState* exec, JSObject* base, int32_t index)
 754 {
 755     return getByValCellInt(exec, base, index);
 756 }
 757 
 758 EncodedJSValue JIT_OPERATION operationGetByValStringInt(ExecState* exec, JSString* base, int32_t index)
 759 {
 760     return getByValCellInt(exec, base, index);
 761 }
 762 
 763 EncodedJSValue JIT_OPERATION operationGetByValObjectString(ExecState* exec, JSCell* base, JSCell* string)
 764 {
 765     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 766     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 767 
 768     auto scope = DECLARE_THROW_SCOPE(vm);
 769 
 770     auto propertyName = asString(string)-&gt;toIdentifier(exec);
 771     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 772 
 773     RELEASE_AND_RETURN(scope, JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName)));
 774 }
 775 
 776 EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(ExecState* exec, JSCell* base, JSCell* symbol)
 777 {
 778     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 779     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 780 
<span class="line-modified"> 781     return JSValue::encode(getByValObject(exec, vm, asObject(base), asSymbol(symbol)-&gt;privateName()));</span>

 782 }
 783 
 784 void JIT_OPERATION operationPutByValStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 785 {
 786     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 787     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 788 
 789     putByValInternal&lt;true, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 790 }
 791 
 792 void JIT_OPERATION operationPutByValNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 793 {
 794     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 795     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 796 
 797     putByValInternal&lt;false, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 798 }
 799 
 800 void JIT_OPERATION operationPutByValCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 801 {
 802     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 803     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 804 
 805     putByValInternal&lt;true, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 806 }
 807 
 808 void JIT_OPERATION operationPutByValCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 809 {
 810     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 811     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 812 
 813     putByValInternal&lt;false, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 814 }
 815 
 816 void JIT_OPERATION operationPutByValCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 817 {
 818     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 819     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 820 
 821     putByValCellStringInternal&lt;true, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
 822 }
 823 
 824 void JIT_OPERATION operationPutByValCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 825 {
 826     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 827     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 828 
 829     putByValCellStringInternal&lt;false, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
 830 }
 831 
 832 void JIT_OPERATION operationPutByValCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
 833 {
 834     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 835     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 836 
<span class="line-modified"> 837     putByValCellInternal&lt;true, false&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>

 838 }
 839 
 840 void JIT_OPERATION operationPutByValCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
 841 {
 842     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 843     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 844 
<span class="line-modified"> 845     putByValCellInternal&lt;false, false&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>

 846 }
 847 
 848 void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
 849 {
 850     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 851     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 852 
 853     if (index &gt;= 0) {
 854         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), true);
 855         return;
 856     }
 857 
 858     PutPropertySlot slot(object, true);
 859     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 860         object, exec, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
 861 }
 862 
 863 void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
 864 {
<span class="line-modified"> 865     VM* vm = &amp;exec-&gt;vm();</span>
 866     NativeCallFrameTracer tracer(vm, exec);
 867 
 868     if (index &gt;= 0) {
 869         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), false);
 870         return;
 871     }
 872 
 873     PutPropertySlot slot(object, false);
<span class="line-modified"> 874     object-&gt;methodTable(*vm)-&gt;put(</span>
<span class="line-modified"> 875         object, exec, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
 876 }
 877 
 878 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 879 {
<span class="line-modified"> 880     VM* vm = &amp;exec-&gt;vm();</span>
 881     NativeCallFrameTracer tracer(vm, exec);
 882 
 883     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 884 
 885     if (index &gt;= 0) {
 886         object-&gt;putByIndexInline(exec, index, jsValue, true);
 887         return;
 888     }
 889 
 890     PutPropertySlot slot(object, true);
<span class="line-modified"> 891     object-&gt;methodTable(*vm)-&gt;put(</span>
<span class="line-modified"> 892         object, exec, Identifier::from(exec, index), jsValue, slot);</span>
 893 }
 894 
 895 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 896 {
<span class="line-modified"> 897     VM* vm = &amp;exec-&gt;vm();</span>
 898     NativeCallFrameTracer tracer(vm, exec);
 899 
 900     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 901 
 902     if (index &gt;= 0) {
 903         object-&gt;putByIndexInline(exec, index, jsValue, false);
 904         return;
 905     }
 906 
 907     PutPropertySlot slot(object, false);
<span class="line-modified"> 908     object-&gt;methodTable(*vm)-&gt;put(</span>
<span class="line-modified"> 909         object, exec, Identifier::from(exec, index), jsValue, slot);</span>
 910 }
 911 
 912 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 913 {
 914     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 915     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 916 
 917     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 918 
 919     if (index &gt;= 0) {
 920         object-&gt;putDirectIndex(exec, index, jsValue, 0, PutDirectIndexShouldThrow);
 921         return;
 922     }
 923 
 924     PutPropertySlot slot(object, true);
<span class="line-modified"> 925     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), jsValue, slot);</span>
 926 }
 927 
 928 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 929 {
 930     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 931     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 932 
 933     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 934 
 935     if (index &gt;= 0) {
 936         object-&gt;putDirectIndex(exec, index, jsValue);
 937         return;
 938     }
 939 
 940     PutPropertySlot slot(object, false);
<span class="line-modified"> 941     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), jsValue, slot);</span>
 942 }
 943 
 944 void JIT_OPERATION operationPutByValDirectStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 945 {
 946     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 947     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 948 
 949     putByValInternal&lt;true, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 950 }
 951 
 952 void JIT_OPERATION operationPutByValDirectNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 953 {
 954     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 955     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 956 
 957     putByValInternal&lt;false, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 958 }
 959 
 960 void JIT_OPERATION operationPutByValDirectCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 961 {
 962     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 963     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 964 
 965     putByValInternal&lt;true, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 966 }
 967 
 968 void JIT_OPERATION operationPutByValDirectCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 969 {
 970     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 971     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 972 
 973     putByValInternal&lt;false, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 974 }
 975 
 976 void JIT_OPERATION operationPutByValDirectCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 977 {
 978     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 979     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 980 
 981     putByValCellStringInternal&lt;true, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
 982 }
 983 
 984 void JIT_OPERATION operationPutByValDirectCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 985 {
 986     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 987     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 988 
 989     putByValCellStringInternal&lt;false, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
 990 }
 991 
 992 void JIT_OPERATION operationPutByValDirectCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
 993 {
 994     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 995     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 996 
<span class="line-modified"> 997     putByValCellInternal&lt;true, true&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>

 998 }
 999 
1000 void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
1001 {
1002     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1003     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1004 
<span class="line-modified">1005     putByValCellInternal&lt;false, true&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>

1006 }
1007 
1008 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
1009 {
1010     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1011     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1012     if (index &gt;= 0) {
1013         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);
1014         return;
1015     }
1016 
1017     PutPropertySlot slot(object, true);
<span class="line-modified">1018     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
1019 }
1020 
1021 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
1022 {
1023     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1024     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1025 
1026     if (index &gt;= 0) {
1027         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));
1028         return;
1029     }
1030 
1031     PutPropertySlot slot(object, false);
<span class="line-modified">1032     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
1033 }
1034 
1035 EncodedJSValue JIT_OPERATION operationArrayPush(ExecState* exec, EncodedJSValue encodedValue, JSArray* array)
1036 {
<span class="line-modified">1037     VM* vm = &amp;exec-&gt;vm();</span>
1038     NativeCallFrameTracer tracer(vm, exec);
1039 
1040     array-&gt;pushInline(exec, JSValue::decode(encodedValue));
1041     return JSValue::encode(jsNumber(array-&gt;length()));
1042 }
1043 
1044 EncodedJSValue JIT_OPERATION operationArrayPushDouble(ExecState* exec, double value, JSArray* array)
1045 {
<span class="line-modified">1046     VM* vm = &amp;exec-&gt;vm();</span>
1047     NativeCallFrameTracer tracer(vm, exec);
1048 
1049     array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, value));
1050     return JSValue::encode(jsNumber(array-&gt;length()));
1051 }
1052 
1053 EncodedJSValue JIT_OPERATION operationArrayPushMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
1054 {
1055     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1056     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1057     auto scope = DECLARE_THROW_SCOPE(vm);
1058 
1059     // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
1060     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1061     // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
1062     // that there is no indexed accessors in this object and its prototype chain.
1063     //
1064     // ArrayWithArrayStorage is also OK. It can have indexed accessors. But if you define an indexed accessor, the array&#39;s length
1065     // becomes larger than that index. So Array#push never overlaps with this accessor. So accessors are never called unless
1066     // the IndexingType is ArrayWithSlowPutArrayStorage which could have an indexed accessor in a prototype chain.
1067     RELEASE_ASSERT(!shouldUseSlowPut(array-&gt;indexingType()));
1068 
1069     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
1070     for (int32_t i = 0; i &lt; elementCount; ++i) {
1071         array-&gt;pushInline(exec, JSValue::decode(values[i]));
1072         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1073     }
1074     return JSValue::encode(jsNumber(array-&gt;length()));
1075 }
1076 
1077 EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
1078 {
1079     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1080     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1081     auto scope = DECLARE_THROW_SCOPE(vm);
1082 
1083     // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
1084     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1085     // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
1086     // that there is no indexed accessors in this object and its prototype chain.
1087     ASSERT(array-&gt;indexingMode() == ArrayWithDouble);
1088 
1089     double* values = static_cast&lt;double*&gt;(buffer);
1090     for (int32_t i = 0; i &lt; elementCount; ++i) {
1091         array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, values[i]));
1092         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1093     }
1094     return JSValue::encode(jsNumber(array-&gt;length()));
1095 }
1096 
1097 EncodedJSValue JIT_OPERATION operationArrayPop(ExecState* exec, JSArray* array)
1098 {
<span class="line-modified">1099     VM* vm = &amp;exec-&gt;vm();</span>
1100     NativeCallFrameTracer tracer(vm, exec);
1101 
1102     return JSValue::encode(array-&gt;pop(exec));
1103 }
1104 
1105 EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(ExecState* exec, JSArray* array)
1106 {
<span class="line-modified">1107     VM* vm = &amp;exec-&gt;vm();</span>
1108     NativeCallFrameTracer tracer(vm, exec);
1109 
1110     array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
1111 
1112     return JSValue::encode(array-&gt;pop(exec));
1113 }
1114 
1115 EncodedJSValue JIT_OPERATION operationRegExpExecString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
1116 {
1117     SuperSamplerScope superSamplerScope(false);
1118 
1119     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1120     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1121 
1122     return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
1123 }
1124 
1125 EncodedJSValue JIT_OPERATION operationRegExpExec(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
1126 {
1127     SuperSamplerScope superSamplerScope(false);
1128 
1129     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1130     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1131     auto scope = DECLARE_THROW_SCOPE(vm);
1132 
1133     JSValue argument = JSValue::decode(encodedArgument);
1134 
1135     JSString* input = argument.toStringOrNull(exec);
1136     EXCEPTION_ASSERT(!!scope.exception() == !input);
1137     if (!input)
1138         return encodedJSValue();
1139     RELEASE_AND_RETURN(scope, JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, input)));
1140 }
1141 
1142 EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
1143 {
1144     SuperSamplerScope superSamplerScope(false);
1145 
1146     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1147     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1148     auto scope = DECLARE_THROW_SCOPE(vm);
1149 
1150     JSValue base = JSValue::decode(encodedBase);
1151     JSValue argument = JSValue::decode(encodedArgument);
1152 
1153     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1154     if (UNLIKELY(!regexp))
1155         return throwVMTypeError(exec, scope);
1156 
1157     JSString* input = argument.toStringOrNull(exec);
1158     EXCEPTION_ASSERT(!!scope.exception() == !input);
1159     if (!input)
1160         return JSValue::encode(jsUndefined());
1161     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(exec, globalObject, input)));
1162 }
1163 
1164 EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
1165 {
1166     SuperSamplerScope superSamplerScope(false);
1167 
1168     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1169     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1170 
1171     auto scope = DECLARE_THROW_SCOPE(vm);
1172 
1173     String input = string-&gt;value(exec);
1174     RETURN_IF_EXCEPTION(scope, { });
1175 
1176     unsigned lastIndex = 0;
1177     MatchResult result;
1178     JSArray* array = createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
1179     if (!array) {
1180         ASSERT(!scope.exception());
1181         return JSValue::encode(jsNull());
1182     }
1183 
1184     RETURN_IF_EXCEPTION(scope, { });
1185     globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
1186     return JSValue::encode(array);
1187 }
1188 
1189 EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
1190 {
1191     SuperSamplerScope superSamplerScope(false);
1192 
1193     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1194     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1195 
1196     if (!regExpObject-&gt;regExp()-&gt;global())
1197         return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
1198     return JSValue::encode(regExpObject-&gt;matchGlobal(exec, globalObject, argument));
1199 }
1200 
1201 EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
1202 {
1203     SuperSamplerScope superSamplerScope(false);
1204 
1205     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1206     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1207 
1208     auto scope = DECLARE_THROW_SCOPE(vm);
1209 
1210     ASSERT(regExp-&gt;global());
1211 
1212     String s = string-&gt;value(exec);
1213     RETURN_IF_EXCEPTION(scope, { });
1214 
1215     if (regExp-&gt;unicode()) {
1216         unsigned stringLength = s.length();
1217         RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
1218             vm, exec, string, s, globalObject, regExp,
1219             [&amp;] (size_t end) -&gt; size_t {
1220                 return advanceStringUnicode(s, stringLength, end);
1221             })));
1222     }
1223 
1224     RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
1225         vm, exec, string, s, globalObject, regExp,
1226         [&amp;] (size_t end) -&gt; size_t {
1227             return end + 1;
1228         })));
1229 }
1230 
1231 EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(ExecState* exec, EncodedJSValue value)
1232 {
1233     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1234     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1235 
1236     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
1237         // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1238         return parseIntResult(parseInt(view, 0));
1239     });
1240 }
1241 
1242 EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(ExecState* exec, JSString* string)
1243 {
1244     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1245     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1246     auto scope = DECLARE_THROW_SCOPE(vm);
1247 
1248     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
1249     RETURN_IF_EXCEPTION(scope, { });
1250 
1251     // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1252     return parseIntResult(parseInt(viewWithString.view, 0));
1253 }
1254 
1255 EncodedJSValue JIT_OPERATION operationParseIntString(ExecState* exec, JSString* string, int32_t radix)
1256 {
1257     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1258     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1259     auto scope = DECLARE_THROW_SCOPE(vm);
1260 
1261     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
1262     RETURN_IF_EXCEPTION(scope, { });
1263 
1264     return parseIntResult(parseInt(viewWithString.view, radix));
1265 }
1266 
1267 EncodedJSValue JIT_OPERATION operationParseIntGeneric(ExecState* exec, EncodedJSValue value, int32_t radix)
1268 {
1269     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1270     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1271 
1272     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
1273         return parseIntResult(parseInt(view, radix));
1274     });
1275 }
1276 
1277 size_t JIT_OPERATION operationRegExpTestString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)
1278 {
1279     SuperSamplerScope superSamplerScope(false);
1280 
1281     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1282     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1283 
1284     return regExpObject-&gt;testInline(exec, globalObject, input);
1285 }
1286 
1287 size_t JIT_OPERATION operationRegExpTest(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
1288 {
1289     SuperSamplerScope superSamplerScope(false);
1290 
1291     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1292     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1293 
1294     JSValue argument = JSValue::decode(encodedArgument);
1295 
1296     JSString* input = argument.toStringOrNull(exec);
1297     if (!input)
1298         return false;
1299     return regExpObject-&gt;testInline(exec, globalObject, input);
1300 }
1301 
1302 size_t JIT_OPERATION operationRegExpTestGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
1303 {
1304     SuperSamplerScope superSamplerScope(false);
1305 
1306     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1307     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1308     auto scope = DECLARE_THROW_SCOPE(vm);
1309 
1310     JSValue base = JSValue::decode(encodedBase);
1311     JSValue argument = JSValue::decode(encodedArgument);
1312 
1313     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1314     if (UNLIKELY(!regexp)) {
1315         throwTypeError(exec, scope);
1316         return false;
1317     }
1318 
1319     JSString* input = argument.toStringOrNull(exec);
1320     EXCEPTION_ASSERT(!!scope.exception() == !input);
1321     if (!input)
1322         return false;
1323     RELEASE_AND_RETURN(scope, regexp-&gt;test(exec, globalObject, input));
1324 }
1325 
1326 JSCell* JIT_OPERATION operationSubBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1327 {
<span class="line-modified">1328     VM* vm = &amp;exec-&gt;vm();</span>
1329     NativeCallFrameTracer tracer(vm, exec);
1330 
1331     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1332     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1333 
1334     return JSBigInt::sub(exec, leftOperand, rightOperand);
1335 }
1336 










1337 JSCell* JIT_OPERATION operationMulBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1338 {
<span class="line-modified">1339     VM* vm = &amp;exec-&gt;vm();</span>
1340     NativeCallFrameTracer tracer(vm, exec);
1341 
1342     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1343     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1344 
1345     return JSBigInt::multiply(exec, leftOperand, rightOperand);
1346 }
1347 











1348 JSCell* JIT_OPERATION operationDivBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1349 {
<span class="line-modified">1350     VM* vm = &amp;exec-&gt;vm();</span>
1351     NativeCallFrameTracer tracer(vm, exec);
1352 
1353     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1354     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1355 
1356     return JSBigInt::divide(exec, leftOperand, rightOperand);
1357 }
1358 











1359 JSCell* JIT_OPERATION operationBitAndBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1360 {
<span class="line-modified">1361     VM* vm = &amp;exec-&gt;vm();</span>
1362     NativeCallFrameTracer tracer(vm, exec);
1363 
1364     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1365     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1366 
1367     return JSBigInt::bitwiseAnd(exec, leftOperand, rightOperand);
1368 }
1369 











1370 JSCell* JIT_OPERATION operationAddBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1371 {
<span class="line-modified">1372     VM* vm = &amp;exec-&gt;vm();</span>
1373     NativeCallFrameTracer tracer(vm, exec);
1374 
1375     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1376     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1377 
1378     return JSBigInt::add(exec, leftOperand, rightOperand);
1379 }
1380 
1381 JSCell* JIT_OPERATION operationBitOrBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1382 {
<span class="line-modified">1383     VM* vm = &amp;exec-&gt;vm();</span>
1384     NativeCallFrameTracer tracer(vm, exec);
1385 
1386     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1387     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1388 
1389     return JSBigInt::bitwiseOr(exec, leftOperand, rightOperand);
1390 }
1391 
1392 JSCell* JIT_OPERATION operationBitXorBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1393 {
<span class="line-modified">1394     VM* vm = &amp;exec-&gt;vm();</span>
1395     NativeCallFrameTracer tracer(vm, exec);
1396 
1397     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1398     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1399 
1400     return JSBigInt::bitwiseXor(exec, leftOperand, rightOperand);
1401 }
1402 
1403 size_t JIT_OPERATION operationCompareStrictEqCell(ExecState* exec, JSCell* op1, JSCell* op2)
1404 {
<span class="line-modified">1405     VM* vm = &amp;exec-&gt;vm();</span>
1406     NativeCallFrameTracer tracer(vm, exec);
1407 
1408     return JSValue::strictEqualSlowCaseInline(exec, op1, op2);
1409 }
1410 
1411 size_t JIT_OPERATION operationSameValue(ExecState* exec, EncodedJSValue arg1, EncodedJSValue arg2)
1412 {
1413     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1414     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1415 
1416     return sameValue(exec, JSValue::decode(arg1), JSValue::decode(arg2));
1417 }
1418 
1419 EncodedJSValue JIT_OPERATION operationToPrimitive(ExecState* exec, EncodedJSValue value)
1420 {
<span class="line-modified">1421     VM* vm = &amp;exec-&gt;vm();</span>
1422     NativeCallFrameTracer tracer(vm, exec);
1423 
1424     return JSValue::encode(JSValue::decode(value).toPrimitive(exec));
1425 }
1426 
1427 EncodedJSValue JIT_OPERATION operationToNumber(ExecState* exec, EncodedJSValue value)
1428 {
<span class="line-modified">1429     VM* vm = &amp;exec-&gt;vm();</span>
1430     NativeCallFrameTracer tracer(vm, exec);
1431 
1432     return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(exec)));
1433 }
1434 
1435 EncodedJSValue JIT_OPERATION operationGetByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)
1436 {
1437     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1438     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1439     auto scope = DECLARE_THROW_SCOPE(vm);
1440 
1441     JSValue baseValue = JSValue::decode(encodedBase);
1442     JSValue thisVal = JSValue::decode(encodedThis);
1443     JSValue subscript = JSValue::decode(encodedSubscript);
1444 
1445     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1446         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1447         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1448             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified">1449                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>


1450                     return JSValue::encode(result);
1451             }
1452         }
1453     }
1454 
1455     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1456     if (subscript.isUInt32()) {
1457         uint32_t i = subscript.asUInt32();
1458         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1459             return JSValue::encode(asString(baseValue)-&gt;getIndex(exec, i));
1460 
1461         RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, i, slot)));
1462     }
1463 
1464     baseValue.requireObjectCoercible(exec);
1465     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1466 
1467     auto property = subscript.toPropertyKey(exec);
1468     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1469     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, property, slot)));
1470 }
1471 
1472 void JIT_OPERATION operationPutByIdWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
1473 {
1474     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1475     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1476 
<span class="line-modified">1477     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(exec, impl));</span>
1478 }
1479 
1480 void JIT_OPERATION operationPutByIdWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
1481 {
1482     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1483     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1484 
<span class="line-modified">1485     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(exec, impl));</span>
1486 }
1487 
1488 void JIT_OPERATION operationPutByValWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
1489 {
1490     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1491     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1492     auto scope = DECLARE_THROW_SCOPE(vm);
1493 
1494     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
1495     RETURN_IF_EXCEPTION(scope, void());
1496     scope.release();
1497     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, property);
1498 }
1499 
1500 void JIT_OPERATION operationPutByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
1501 {
1502     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1503     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1504     auto scope = DECLARE_THROW_SCOPE(vm);
1505 
1506     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
1507     RETURN_IF_EXCEPTION(scope, void());
1508     scope.release();
1509     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, property);
1510 }
1511 
1512 ALWAYS_INLINE static void defineDataProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSValue value, int32_t attributes)
1513 {
1514     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes));
1515     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1516     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
1517         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);
1518     else
1519         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1520 }
1521 
1522 void JIT_OPERATION operationDefineDataProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)
1523 {
1524     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1525     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1526     auto scope = DECLARE_THROW_SCOPE(vm);
1527 
1528     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
1529     RETURN_IF_EXCEPTION(scope, void());
1530     scope.release();
1531     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);
1532 }
1533 
1534 void JIT_OPERATION operationDefineDataPropertyString(ExecState* exec, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)
1535 {
1536     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1537     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1538     auto scope = DECLARE_THROW_SCOPE(vm);
1539 
1540     Identifier propertyName = property-&gt;toIdentifier(exec);
1541     RETURN_IF_EXCEPTION(scope, void());
1542     scope.release();
1543     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);
1544 }
1545 
1546 void JIT_OPERATION operationDefineDataPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)
1547 {
1548     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1549     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-modified">1550     defineDataProperty(exec, vm, base, Identifier::fromUid(&amp;vm, property), JSValue::decode(encodedValue), attributes);</span>
1551 }
1552 
1553 void JIT_OPERATION operationDefineDataPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)
1554 {
1555     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1556     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1557     defineDataProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);
1558 }
1559 
1560 ALWAYS_INLINE static void defineAccessorProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)
1561 {
1562     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes));
1563     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1564     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
1565         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);
1566     else
1567         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1568 }
1569 
1570 void JIT_OPERATION operationDefineAccessorProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)
1571 {
1572     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1573     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1574     auto scope = DECLARE_THROW_SCOPE(vm);
1575 
1576     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
1577     RETURN_IF_EXCEPTION(scope, void());
1578     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
1579 }
1580 
1581 void JIT_OPERATION operationDefineAccessorPropertyString(ExecState* exec, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)
1582 {
1583     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1584     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1585     auto scope = DECLARE_THROW_SCOPE(vm);
1586 
1587     Identifier propertyName = property-&gt;toIdentifier(exec);
1588     RETURN_IF_EXCEPTION(scope, void());
1589     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
1590 }
1591 
1592 void JIT_OPERATION operationDefineAccessorPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)
1593 {
1594     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1595     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-modified">1596     defineAccessorProperty(exec, vm, base, Identifier::fromUid(&amp;vm, property), getter, setter, attributes);</span>
1597 }
1598 
1599 void JIT_OPERATION operationDefineAccessorPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)
1600 {
1601     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1602     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1603     defineAccessorProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);
1604 }
1605 
1606 char* JIT_OPERATION operationNewArray(ExecState* exec, Structure* arrayStructure, void* buffer, size_t size)
1607 {
<span class="line-modified">1608     VM* vm = &amp;exec-&gt;vm();</span>
1609     NativeCallFrameTracer tracer(vm, exec);
1610 
1611     return bitwise_cast&lt;char*&gt;(constructArray(exec, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));
1612 }
1613 
1614 char* JIT_OPERATION operationNewEmptyArray(ExecState* exec, Structure* arrayStructure)
1615 {
<span class="line-modified">1616     VM* vm = &amp;exec-&gt;vm();</span>
1617     NativeCallFrameTracer tracer(vm, exec);
1618 
<span class="line-modified">1619     return bitwise_cast&lt;char*&gt;(JSArray::create(*vm, arrayStructure));</span>
1620 }
1621 
1622 char* JIT_OPERATION operationNewArrayWithSize(ExecState* exec, Structure* arrayStructure, int32_t size, Butterfly* butterfly)
1623 {
1624     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1625     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1626     auto scope = DECLARE_THROW_SCOPE(vm);
1627 
1628     if (UNLIKELY(size &lt; 0))
1629         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
1630 
1631     JSArray* result;
1632     if (butterfly)
1633         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1634     else
1635         result = JSArray::create(vm, arrayStructure, size);
1636     return bitwise_cast&lt;char*&gt;(result);
1637 }
1638 
1639 char* JIT_OPERATION operationNewArrayWithSizeAndHint(ExecState* exec, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)
1640 {
1641     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1642     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1643     auto scope = DECLARE_THROW_SCOPE(vm);
1644 
1645     if (UNLIKELY(size &lt; 0))
1646         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
1647 
1648     JSArray* result;
1649     if (butterfly)
1650         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1651     else {
1652         result = JSArray::tryCreate(vm, arrayStructure, size, vectorLengthHint);
1653         RELEASE_ASSERT(result);
1654     }
1655     return bitwise_cast&lt;char*&gt;(result);
1656 }
1657 
1658 JSCell* JIT_OPERATION operationNewArrayBuffer(ExecState* exec, Structure* arrayStructure, JSCell* immutableButterflyCell)
1659 {
1660     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1661     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1662     ASSERT(!arrayStructure-&gt;outOfLineCapacity());
1663     auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
1664     ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
1665     auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
1666     ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
1667     ASSERT(result-&gt;structure(vm) == arrayStructure);
1668     return result;
1669 }
1670 
1671 char* JIT_OPERATION operationNewInt8ArrayWithSize(
1672     ExecState* exec, Structure* structure, int32_t length, char* vector)
1673 {
1674     return newTypedArrayWithSize&lt;JSInt8Array&gt;(exec, structure, length, vector);
1675 }
1676 
1677 char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
1678     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1679 {
1680     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1681     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1682     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1683 }
1684 
1685 char* JIT_OPERATION operationNewInt16ArrayWithSize(
1686     ExecState* exec, Structure* structure, int32_t length, char* vector)
1687 {
1688     return newTypedArrayWithSize&lt;JSInt16Array&gt;(exec, structure, length, vector);
1689 }
1690 
1691 char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
1692     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1693 {
1694     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1695     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1696     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1697 }
1698 
1699 char* JIT_OPERATION operationNewInt32ArrayWithSize(
1700     ExecState* exec, Structure* structure, int32_t length, char* vector)
1701 {
1702     return newTypedArrayWithSize&lt;JSInt32Array&gt;(exec, structure, length, vector);
1703 }
1704 
1705 char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
1706     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1707 {
1708     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1709     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1710     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1711 }
1712 
1713 char* JIT_OPERATION operationNewUint8ArrayWithSize(
1714     ExecState* exec, Structure* structure, int32_t length, char* vector)
1715 {
1716     return newTypedArrayWithSize&lt;JSUint8Array&gt;(exec, structure, length, vector);
1717 }
1718 
1719 char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
1720     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1721 {
1722     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1723     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1724     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1725 }
1726 
1727 char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
1728     ExecState* exec, Structure* structure, int32_t length, char* vector)
1729 {
1730     return newTypedArrayWithSize&lt;JSUint8ClampedArray&gt;(exec, structure, length, vector);
1731 }
1732 
1733 char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
1734     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1735 {
1736     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1737     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1738     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1739 }
1740 
1741 char* JIT_OPERATION operationNewUint16ArrayWithSize(
1742     ExecState* exec, Structure* structure, int32_t length, char* vector)
1743 {
1744     return newTypedArrayWithSize&lt;JSUint16Array&gt;(exec, structure, length, vector);
1745 }
1746 
1747 char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
1748     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1749 {
1750     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1751     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1752     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1753 }
1754 
1755 char* JIT_OPERATION operationNewUint32ArrayWithSize(
1756     ExecState* exec, Structure* structure, int32_t length, char* vector)
1757 {
1758     return newTypedArrayWithSize&lt;JSUint32Array&gt;(exec, structure, length, vector);
1759 }
1760 
1761 char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
1762     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1763 {
1764     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1765     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1766     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1767 }
1768 
1769 char* JIT_OPERATION operationNewFloat32ArrayWithSize(
1770     ExecState* exec, Structure* structure, int32_t length, char* vector)
1771 {
1772     return newTypedArrayWithSize&lt;JSFloat32Array&gt;(exec, structure, length, vector);
1773 }
1774 
1775 char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
1776     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1777 {
1778     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1779     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1780     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1781 }
1782 
1783 char* JIT_OPERATION operationNewFloat64ArrayWithSize(
1784     ExecState* exec, Structure* structure, int32_t length, char* vector)
1785 {
1786     return newTypedArrayWithSize&lt;JSFloat64Array&gt;(exec, structure, length, vector);
1787 }
1788 
1789 char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
1790     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1791 {
1792     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1793     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1794     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1795 }
1796 
1797 JSCell* JIT_OPERATION operationCreateActivationDirect(ExecState* exec, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)
1798 {


1799     JSValue initialValue = JSValue::decode(initialValueEncoded);
1800     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<span class="line-removed">1801     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">1802     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1803     return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
1804 }
1805 
1806 JSCell* JIT_OPERATION operationCreateDirectArguments(ExecState* exec, Structure* structure, uint32_t length, uint32_t minCapacity)
1807 {
1808     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1809     NativeCallFrameTracer target(&amp;vm, exec);</span>
1810     DirectArguments* result = DirectArguments::create(
1811         vm, structure, length, std::max(length, minCapacity));
1812     // The caller will store to this object without barriers. Most likely, at this point, this is
1813     // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
1814     // since the GC should be allowed to do crazy (like pretenuring, for example).
1815     vm.heap.writeBarrier(result);
1816     return result;
1817 }
1818 
1819 JSCell* JIT_OPERATION operationCreateScopedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)
1820 {
1821     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1822     NativeCallFrameTracer target(&amp;vm, exec);</span>
1823 
1824     // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
1825     // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
1826     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
1827 
1828     return ScopedArguments::createByCopyingFrom(
1829         vm, structure, argumentStart, length, callee, table, scope);
1830 }
1831 
1832 JSCell* JIT_OPERATION operationCreateClonedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)
1833 {
1834     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1835     NativeCallFrameTracer target(&amp;vm, exec);</span>
1836     return ClonedArguments::createByCopyingFrom(
1837         exec, structure, argumentStart, length, callee);
1838 }
1839 
1840 JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
1841 {
1842     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1843     NativeCallFrameTracer target(&amp;vm, exec);</span>
1844 
1845     DeferGCForAWhile deferGC(vm.heap);
1846 
1847     CodeBlock* codeBlock;
1848     if (inlineCallFrame)
1849         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
1850     else
1851         codeBlock = exec-&gt;codeBlock();
1852 
1853     unsigned length = argumentCount - 1;
1854     unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
1855     DirectArguments* result = DirectArguments::create(
1856         vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
1857 
1858     result-&gt;setCallee(vm, callee);
1859 
1860     Register* arguments =
1861         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +
1862         CallFrame::argumentOffset(0);
1863     for (unsigned i = length; i--;)
1864         result-&gt;setIndexQuickly(vm, i, arguments[i].jsValue());
1865 
1866     return result;
1867 }
1868 
1869 JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
1870 {
1871     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1872     NativeCallFrameTracer target(&amp;vm, exec);</span>
1873 
1874     DeferGCForAWhile deferGC(vm.heap);
1875 
1876     CodeBlock* codeBlock;
1877     if (inlineCallFrame)
1878         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
1879     else
1880         codeBlock = exec-&gt;codeBlock();
1881 
1882     unsigned length = argumentCount - 1;
1883     ClonedArguments* result = ClonedArguments::createEmpty(
1884         vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);
1885 
1886     Register* arguments =
1887         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +
1888         CallFrame::argumentOffset(0);
1889     for (unsigned i = length; i--;)
1890         result-&gt;putDirectIndex(exec, i, arguments[i].jsValue());
1891 
1892 
1893     return result;
1894 }
1895 
1896 JSCell* JIT_OPERATION operationCreateRest(ExecState* exec, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)
1897 {
<span class="line-modified">1898     VM* vm = &amp;exec-&gt;vm();</span>
1899     NativeCallFrameTracer tracer(vm, exec);
1900 
1901     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1902     Structure* structure = globalObject-&gt;restParameterStructure();
1903     static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
1904     JSValue* argumentsToCopyRegion = bitwise_cast&lt;JSValue*&gt;(argumentStart) + numberOfParamsToSkip;
1905     return constructArray(exec, structure, argumentsToCopyRegion, arraySize);
1906 }
1907 
1908 size_t JIT_OPERATION operationObjectIsObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
1909 {
1910     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1911     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1912 
1913     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
1914 
1915     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
1916         return false;
1917     if (object-&gt;isFunction(vm))
1918         return false;
1919     return true;
1920 }
1921 
1922 size_t JIT_OPERATION operationObjectIsFunction(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
1923 {
1924     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1925     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1926 
1927     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
1928 
1929     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
1930         return false;
1931     if (object-&gt;isFunction(vm))
1932         return true;
1933     return false;
1934 }
1935 
1936 JSCell* JIT_OPERATION operationTypeOfObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
1937 {
1938     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1939     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1940 
1941     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
1942 
1943     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
1944         return vm.smallStrings.undefinedString();
1945     if (object-&gt;isFunction(vm))
1946         return vm.smallStrings.functionString();
1947     return vm.smallStrings.objectString();
1948 }
1949 
1950 int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
1951 {
1952     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1953     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1954 
1955     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
1956 
1957     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
1958         return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
1959     if (object-&gt;isFunction(vm))
1960         return static_cast&lt;int32_t&gt;(TypeofType::Function);
1961     return static_cast&lt;int32_t&gt;(TypeofType::Object);
1962 }
1963 
1964 char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(ExecState* exec)
1965 {
1966     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1967     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1968 
1969     return reinterpret_cast&lt;char*&gt;(
1970         Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
1971 }
1972 
1973 char* JIT_OPERATION operationAllocateSimplePropertyStorage(ExecState* exec, size_t newSize)
1974 {
1975     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1976     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1977 
1978     return reinterpret_cast&lt;char*&gt;(
1979         Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
1980 }
1981 
1982 char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)
1983 {
1984     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1985     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1986 
1987     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
1988     return reinterpret_cast&lt;char*&gt;(
1989         object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
1990 }
1991 
1992 char* JIT_OPERATION operationAllocateComplexPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)
1993 {
1994     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1995     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1996 
1997     return reinterpret_cast&lt;char*&gt;(
1998         object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
1999 }
2000 
2001 char* JIT_OPERATION operationEnsureInt32(ExecState* exec, JSCell* cell)
2002 {
2003     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2004     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2005 
2006     if (!cell-&gt;isObject())
2007         return 0;
2008 
2009     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
2010     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasInt32(cell-&gt;indexingMode())) || !result);
2011     return result;
2012 }
2013 
2014 char* JIT_OPERATION operationEnsureDouble(ExecState* exec, JSCell* cell)
2015 {
2016     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2017     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2018 
2019     if (!cell-&gt;isObject())
2020         return 0;
2021 
2022     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
2023     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasDouble(cell-&gt;indexingMode())) || !result);
2024     return result;
2025 }
2026 
2027 char* JIT_OPERATION operationEnsureContiguous(ExecState* exec, JSCell* cell)
2028 {
2029     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2030     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2031 
2032     if (!cell-&gt;isObject())
2033         return 0;
2034 
2035     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
2036     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasContiguous(cell-&gt;indexingMode())) || !result);
2037     return result;
2038 }
2039 
2040 char* JIT_OPERATION operationEnsureArrayStorage(ExecState* exec, JSCell* cell)
2041 {
2042     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2043     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2044 
2045     if (!cell-&gt;isObject())
2046         return 0;
2047 
2048     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
2049     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
2050     return result;
2051 }
2052 
<span class="line-modified">2053 EncodedJSValue JIT_OPERATION operationHasGenericProperty(ExecState* exec, EncodedJSValue encodedBaseValue, JSCell* propertyName)</span>
2054 {
2055     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2056     NativeCallFrameTracer tracer(&amp;vm, exec);</span>


2057     JSValue baseValue = JSValue::decode(encodedBaseValue);
2058     if (baseValue.isUndefinedOrNull())
2059         return JSValue::encode(jsBoolean(false));
2060 
2061     JSObject* base = baseValue.toObject(exec);

2062     if (!base)
2063         return JSValue::encode(JSValue());
<span class="line-modified">2064     return JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(exec, asString(propertyName)-&gt;toIdentifier(exec), PropertySlot::InternalMethodType::GetOwnProperty)));</span>


2065 }
2066 
2067 size_t JIT_OPERATION operationHasIndexedPropertyByInt(ExecState* exec, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)
2068 {
2069     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2070     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2071     JSObject* object = baseCell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
2072     if (UNLIKELY(subscript &lt; 0)) {
2073         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">2074         return object-&gt;hasPropertyGeneric(exec, Identifier::from(exec, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
2075     }
2076     return object-&gt;hasPropertyGeneric(exec, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));
2077 }
2078 
2079 JSCell* JIT_OPERATION operationGetPropertyEnumerator(ExecState* exec, EncodedJSValue encodedBase)
2080 {
2081     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2082     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2083     auto scope = DECLARE_THROW_SCOPE(vm);
2084 
2085     JSValue base = JSValue::decode(encodedBase);
2086     if (base.isUndefinedOrNull())
<span class="line-modified">2087         return JSPropertyNameEnumerator::create(vm);</span>
2088 
2089     JSObject* baseObject = base.toObject(exec);
2090     RETURN_IF_EXCEPTION(scope, { });
2091 
2092     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, baseObject));
2093 }
2094 
2095 JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(ExecState* exec, JSCell* cell)
2096 {
2097     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2098     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2099     auto scope = DECLARE_THROW_SCOPE(vm);
2100 
2101     JSObject* base = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
2102     RETURN_IF_EXCEPTION(scope, { });
2103 
2104     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, base));
2105 }
2106 
2107 JSCell* JIT_OPERATION operationToIndexString(ExecState* exec, int32_t index)
2108 {
2109     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2110     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-modified">2111     return jsString(exec, Identifier::from(exec, index).string());</span>
2112 }
2113 
2114 JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(ExecState* exec, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)
2115 {
2116     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2117     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2118 
2119     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
2120     ASSERT(regexp-&gt;isValid());
2121     return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));
2122 }
2123 
2124 StringImpl* JIT_OPERATION operationResolveRope(ExecState* exec, JSString* string)
2125 {
2126     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2127     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2128 
2129     return string-&gt;value(exec).impl();
2130 }
2131 
2132 JSString* JIT_OPERATION operationStringValueOf(ExecState* exec, EncodedJSValue encodedArgument)
2133 {
2134     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2135     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2136     auto scope = DECLARE_THROW_SCOPE(vm);
2137 
2138     JSValue argument = JSValue::decode(encodedArgument);
2139 
2140     if (argument.isString())
2141         return asString(argument);
2142 
2143     if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, argument))
2144         return stringObject-&gt;internalValue();
2145 
2146     throwVMTypeError(exec, scope);
2147     return nullptr;
2148 }
2149 
2150 JSCell* JIT_OPERATION operationStringSubstr(ExecState* exec, JSCell* cell, int32_t from, int32_t span)
2151 {
2152     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2153     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-removed">2154     auto scope = DECLARE_THROW_SCOPE(vm);</span>
2155 
<span class="line-modified">2156     auto string = jsCast&lt;JSString*&gt;(cell)-&gt;value(exec);</span>
<span class="line-removed">2157     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-removed">2158     return jsSubstring(exec, string, from, span);</span>
2159 }
2160 
2161 JSCell* JIT_OPERATION operationStringSlice(ExecState* exec, JSCell* cell, int32_t start, int32_t end)
2162 {
2163     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2164     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-removed">2165     auto scope = DECLARE_THROW_SCOPE(vm);</span>
2166 
<span class="line-modified">2167     auto string = jsCast&lt;JSString*&gt;(cell)-&gt;value(exec);</span>
<span class="line-removed">2168     RETURN_IF_EXCEPTION(scope, nullptr);</span>
2169     static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">2170 </span>
<span class="line-removed">2171     scope.release();</span>
<span class="line-removed">2172     return stringSlice(exec, WTFMove(string), start, end);</span>
2173 }
2174 
2175 JSString* JIT_OPERATION operationToLowerCase(ExecState* exec, JSString* string, uint32_t failingIndex)
2176 {
2177     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2178     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2179 
2180     auto scope = DECLARE_THROW_SCOPE(vm);
2181 
2182     const String&amp; inputString = string-&gt;value(exec);
2183     RETURN_IF_EXCEPTION(scope, nullptr);
2184     if (!inputString.length())
2185         return vm.smallStrings.emptyString();
2186 
2187     String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
2188     if (lowercasedString.impl() == inputString.impl())
2189         return string;
<span class="line-modified">2190     RELEASE_AND_RETURN(scope, jsString(exec, lowercasedString));</span>
2191 }
2192 
2193 char* JIT_OPERATION operationInt32ToString(ExecState* exec, int32_t value, int32_t radix)
2194 {
2195     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2196     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2197 
2198     auto scope = DECLARE_THROW_SCOPE(vm);
2199 
2200     if (radix &lt; 2 || radix &gt; 36) {
2201         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2202         return nullptr;
2203     }
2204 
2205     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2206 }
2207 
2208 char* JIT_OPERATION operationInt52ToString(ExecState* exec, int64_t value, int32_t radix)
2209 {
2210     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2211     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2212 
2213     auto scope = DECLARE_THROW_SCOPE(vm);
2214 
2215     if (radix &lt; 2 || radix &gt; 36) {
2216         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2217         return nullptr;
2218     }
2219 
2220     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2221 }
2222 
2223 char* JIT_OPERATION operationDoubleToString(ExecState* exec, double value, int32_t radix)
2224 {
2225     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2226     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2227 
2228     auto scope = DECLARE_THROW_SCOPE(vm);
2229 
2230     if (radix &lt; 2 || radix &gt; 36) {
2231         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2232         return nullptr;
2233     }
2234 
2235     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2236 }
2237 
2238 char* JIT_OPERATION operationInt32ToStringWithValidRadix(ExecState* exec, int32_t value, int32_t radix)
2239 {
2240     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2241     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2242 
2243     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2244 }
2245 
2246 char* JIT_OPERATION operationInt52ToStringWithValidRadix(ExecState* exec, int64_t value, int32_t radix)
2247 {
2248     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2249     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2250 
2251     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2252 }
2253 
2254 char* JIT_OPERATION operationDoubleToStringWithValidRadix(ExecState* exec, double value, int32_t radix)
2255 {
2256     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2257     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2258 
2259     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2260 }
2261 
2262 JSString* JIT_OPERATION operationSingleCharacterString(ExecState* exec, int32_t character)
2263 {
2264     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2265     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2266 
<span class="line-modified">2267     return jsSingleCharacterString(exec, static_cast&lt;UChar&gt;(character));</span>
2268 }
2269 
2270 Symbol* JIT_OPERATION operationNewSymbol(ExecState* exec)
2271 {
2272     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2273     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2274 
2275     return Symbol::create(vm);
2276 }
2277 
2278 Symbol* JIT_OPERATION operationNewSymbolWithDescription(ExecState* exec, JSString* description)
2279 {
2280     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2281     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2282     auto scope = DECLARE_THROW_SCOPE(vm);
2283 
2284     String string = description-&gt;value(exec);
2285     RETURN_IF_EXCEPTION(scope, nullptr);
2286 
2287     return Symbol::createWithDescription(vm, string);
2288 }
2289 
2290 JSCell* JIT_OPERATION operationNewStringObject(ExecState* exec, JSString* string, Structure* structure)
2291 {
2292     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2293     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2294 
2295     return StringObject::create(vm, structure, string);
2296 }
2297 
2298 JSString* JIT_OPERATION operationToStringOnCell(ExecState* exec, JSCell* cell)
2299 {
2300     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2301     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2302 
2303     return JSValue(cell).toString(exec);
2304 }
2305 
2306 JSString* JIT_OPERATION operationToString(ExecState* exec, EncodedJSValue value)
2307 {
2308     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2309     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2310 
2311     return JSValue::decode(value).toString(exec);
2312 }
2313 
2314 JSString* JIT_OPERATION operationCallStringConstructorOnCell(ExecState* exec, JSCell* cell)
2315 {
2316     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2317     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2318 
2319     return stringConstructor(exec, cell);
2320 }
2321 
2322 JSString* JIT_OPERATION operationCallStringConstructor(ExecState* exec, EncodedJSValue value)
2323 {
2324     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2325     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2326 
2327     return stringConstructor(exec, JSValue::decode(value));
2328 }
2329 
2330 JSString* JIT_OPERATION operationMakeRope2(ExecState* exec, JSString* left, JSString* right)
2331 {
2332     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2333     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2334 
2335     return jsString(exec, left, right);
2336 }
2337 
2338 JSString* JIT_OPERATION operationMakeRope3(ExecState* exec, JSString* a, JSString* b, JSString* c)
2339 {
2340     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2341     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2342 
2343     return jsString(exec, a, b, c);
2344 }
2345 
2346 JSString* JIT_OPERATION operationStrCat2(ExecState* exec, EncodedJSValue a, EncodedJSValue b)
2347 {
2348     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2349     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2350     auto scope = DECLARE_THROW_SCOPE(vm);
2351 
2352     ASSERT(!JSValue::decode(a).isSymbol());
2353     ASSERT(!JSValue::decode(b).isSymbol());
2354     JSString* str1 = JSValue::decode(a).toString(exec);
2355     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
2356     JSString* str2 = JSValue::decode(b).toString(exec);
2357     scope.assertNoException();
2358 
2359     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2));
2360 }
2361 
2362 JSString* JIT_OPERATION operationStrCat3(ExecState* exec, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)
2363 {
2364     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2365     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2366     auto scope = DECLARE_THROW_SCOPE(vm);
2367 
2368     ASSERT(!JSValue::decode(a).isSymbol());
2369     ASSERT(!JSValue::decode(b).isSymbol());
2370     ASSERT(!JSValue::decode(c).isSymbol());
2371     JSString* str1 = JSValue::decode(a).toString(exec);
2372     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
2373     JSString* str2 = JSValue::decode(b).toString(exec);
2374     scope.assertNoException();
2375     JSString* str3 = JSValue::decode(c).toString(exec);
2376     scope.assertNoException();
2377 
2378     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2, str3));
2379 }
2380 
2381 char* JIT_OPERATION operationFindSwitchImmTargetForDouble(
2382     ExecState* exec, EncodedJSValue encodedValue, size_t tableIndex)
2383 {
2384     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2385     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-removed">2386 </span>
2387     CodeBlock* codeBlock = exec-&gt;codeBlock();
2388     SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
2389     JSValue value = JSValue::decode(encodedValue);
2390     ASSERT(value.isDouble());
2391     double asDouble = value.asDouble();
2392     int32_t asInt32 = static_cast&lt;int32_t&gt;(asDouble);
2393     if (asDouble == asInt32)
2394         return table.ctiForValue(asInt32).executableAddress&lt;char*&gt;();
2395     return table.ctiDefault.executableAddress&lt;char*&gt;();
2396 }
2397 
2398 char* JIT_OPERATION operationSwitchString(ExecState* exec, size_t tableIndex, JSString* string)
2399 {
2400     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2401     NativeCallFrameTracer tracer(&amp;vm, exec);</span>





2402 
<span class="line-modified">2403     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(string-&gt;value(exec).impl()).executableAddress&lt;char*&gt;();</span>
2404 }
2405 
2406 int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(ExecState* exec, size_t tableIndex, JSString* string)
2407 {
2408     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2409     NativeCallFrameTracer tracer(&amp;vm, exec);</span>



2410 
<span class="line-modified">2411     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(string-&gt;value(exec).impl(), std::numeric_limits&lt;int32_t&gt;::min());</span>


2412 }
2413 
2414 uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
2415 {
2416     return codePointCompare(a, b) &lt; 0;
2417 }
2418 
2419 uintptr_t JIT_OPERATION operationCompareStringImplLessEq(StringImpl* a, StringImpl* b)
2420 {
2421     return codePointCompare(a, b) &lt;= 0;
2422 }
2423 
2424 uintptr_t JIT_OPERATION operationCompareStringImplGreater(StringImpl* a, StringImpl* b)
2425 {
2426     return codePointCompare(a, b) &gt; 0;
2427 }
2428 
2429 uintptr_t JIT_OPERATION operationCompareStringImplGreaterEq(StringImpl* a, StringImpl* b)
2430 {
2431     return codePointCompare(a, b) &gt;= 0;
2432 }
2433 
2434 uintptr_t JIT_OPERATION operationCompareStringLess(ExecState* exec, JSString* a, JSString* b)
2435 {
2436     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2437     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2438 
2439     return codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
2440 }
2441 
2442 uintptr_t JIT_OPERATION operationCompareStringLessEq(ExecState* exec, JSString* a, JSString* b)
2443 {
2444     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2445     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2446 
2447     return !codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
2448 }
2449 
2450 uintptr_t JIT_OPERATION operationCompareStringGreater(ExecState* exec, JSString* a, JSString* b)
2451 {
2452     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2453     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2454 
2455     return codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
2456 }
2457 
2458 uintptr_t JIT_OPERATION operationCompareStringGreaterEq(ExecState* exec, JSString* a, JSString* b)
2459 {
2460     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2461     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2462 
2463     return !codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
2464 }
2465 
2466 void JIT_OPERATION operationNotifyWrite(ExecState* exec, WatchpointSet* set)
2467 {
2468     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2469     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2470 
2471     set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
2472 }
2473 
2474 void JIT_OPERATION operationThrowStackOverflowForVarargs(ExecState* exec)
2475 {
2476     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2477     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2478     auto scope = DECLARE_THROW_SCOPE(vm);
2479     throwStackOverflowError(exec, scope);
2480 }
2481 
2482 int32_t JIT_OPERATION operationSizeOfVarargs(ExecState* exec, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)
2483 {
2484     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2485     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2486     JSValue arguments = JSValue::decode(encodedArguments);
2487 
2488     return sizeOfVarargs(exec, arguments, firstVarArgOffset);
2489 }
2490 
2491 int32_t JIT_OPERATION operationHasOwnProperty(ExecState* exec, JSObject* thisObject, EncodedJSValue encodedKey)
2492 {
2493     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2494     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2495     auto scope = DECLARE_THROW_SCOPE(vm);
2496 
2497     JSValue key = JSValue::decode(encodedKey);
2498     Identifier propertyName = key.toPropertyKey(exec);
2499     RETURN_IF_EXCEPTION(scope, false);
2500 
2501     PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
2502     bool result = thisObject-&gt;hasOwnProperty(exec, propertyName.impl(), slot);
2503     RETURN_IF_EXCEPTION(scope, false);
2504 
2505     HasOwnPropertyCache* hasOwnPropertyCache = vm.hasOwnPropertyCache();
2506     ASSERT(hasOwnPropertyCache);
2507     hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName.impl(), result);
2508     return result;
2509 }
2510 
2511 int32_t JIT_OPERATION operationNumberIsInteger(ExecState* exec, EncodedJSValue value)
2512 {
2513     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2514     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2515     return NumberConstructor::isIntegerImpl(JSValue::decode(value));
2516 }
2517 
2518 int32_t JIT_OPERATION operationArrayIndexOfString(ExecState* exec, Butterfly* butterfly, JSString* searchElement, int32_t index)
2519 {
2520     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2521     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2522     auto scope = DECLARE_THROW_SCOPE(vm);
2523 
2524     int32_t length = butterfly-&gt;publicLength();
2525     auto data = butterfly-&gt;contiguous().data();
2526     for (; index &lt; length; ++index) {
2527         JSValue value = data[index].get();
2528         if (!value || !value.isString())
2529             continue;
2530         auto* string = asString(value);
2531         if (string == searchElement)
2532             return index;
<span class="line-modified">2533         if (string-&gt;equal(exec, searchElement))</span>

2534             return index;

2535         RETURN_IF_EXCEPTION(scope, { });
2536     }
2537     return -1;
2538 }
2539 
2540 int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
2541 {
2542     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2543     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2544     auto scope = DECLARE_THROW_SCOPE(vm);
2545 
2546     JSValue searchElement = JSValue::decode(encodedValue);
2547 
2548     int32_t length = butterfly-&gt;publicLength();
2549     auto data = butterfly-&gt;contiguous().data();
2550     for (; index &lt; length; ++index) {
2551         JSValue value = data[index].get();
2552         if (!value)
2553             continue;
<span class="line-modified">2554         if (JSValue::strictEqual(exec, searchElement, value))</span>
<span class="line-removed">2555             return index;</span>
2556         RETURN_IF_EXCEPTION(scope, { });


2557     }
2558     return -1;
2559 }
2560 
2561 int32_t JIT_OPERATION operationArrayIndexOfValueDouble(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
2562 {
2563     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2564     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2565 
2566     JSValue searchElement = JSValue::decode(encodedValue);
2567 
2568     if (!searchElement.isNumber())
2569         return -1;
2570     double number = searchElement.asNumber();
2571 
2572     int32_t length = butterfly-&gt;publicLength();
2573     const double* data = butterfly-&gt;contiguousDouble().data();
2574     for (; index &lt; length; ++index) {
2575         // This comparison ignores NaN.
2576         if (data[index] == number)
2577             return index;
2578     }
2579     return -1;
2580 }
2581 
2582 void JIT_OPERATION operationLoadVarargs(ExecState* exec, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t length, uint32_t mandatoryMinimum)
2583 {
2584     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2585     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2586     JSValue arguments = JSValue::decode(encodedArguments);
2587 
2588     loadVarargs(exec, VirtualRegister(firstElementDest), arguments, offset, length);
2589 
2590     for (uint32_t i = length; i &lt; mandatoryMinimum; ++i)
2591         exec-&gt;r(firstElementDest + i) = jsUndefined();
2592 }
2593 
2594 double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
2595 {
2596     return fmod(a, b);
2597 }
2598 
2599 #if USE(JSVALUE32_64)
2600 double JIT_OPERATION operationRandom(JSGlobalObject* globalObject)
2601 {
2602     return globalObject-&gt;weakRandomNumber();
2603 }
2604 #endif
2605 
2606 JSCell* JIT_OPERATION operationStringFromCharCode(ExecState* exec, int32_t op1)
2607 {
<span class="line-modified">2608     VM* vm = &amp;exec-&gt;vm();</span>
2609     NativeCallFrameTracer tracer(vm, exec);
2610     return JSC::stringFromCharCode(exec, op1);
2611 }
2612 
2613 EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(ExecState* exec, EncodedJSValue encodedValue)
2614 {
<span class="line-modified">2615     VM* vm = &amp;exec-&gt;vm();</span>
2616     NativeCallFrameTracer tracer(vm, exec);
2617     JSValue charValue = JSValue::decode(encodedValue);
2618     int32_t chInt = charValue.toUInt32(exec);
2619     return JSValue::encode(JSC::stringFromCharCode(exec, chInt));
2620 }
2621 
2622 int64_t JIT_OPERATION operationConvertBoxedDoubleToInt52(EncodedJSValue encodedValue)
2623 {
2624     JSValue value = JSValue::decode(encodedValue);
2625     if (!value.isDouble())
2626         return JSValue::notInt52;
2627     return tryConvertToInt52(value.asDouble());
2628 }
2629 
2630 int64_t JIT_OPERATION operationConvertDoubleToInt52(double value)
2631 {
2632     return tryConvertToInt52(value);
2633 }
2634 
2635 char* JIT_OPERATION operationNewRawObject(ExecState* exec, Structure* structure, int32_t length, Butterfly* butterfly)
2636 {
2637     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2638     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2639 
2640     if (!butterfly
2641         &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
2642         IndexingHeader header;
2643         header.setVectorLength(length);
2644         header.setPublicLength(0);
2645 
2646         butterfly = Butterfly::create(
2647             vm, nullptr, 0, structure-&gt;outOfLineCapacity(),
2648             hasIndexedProperties(structure-&gt;indexingType()), header,
2649             length * sizeof(EncodedJSValue));
2650     }
2651 
2652     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);
2653     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.
2654     return bitwise_cast&lt;char*&gt;(result);
2655 }
2656 
2657 JSCell* JIT_OPERATION operationNewObjectWithButterfly(ExecState* exec, Structure* structure, Butterfly* butterfly)
2658 {
2659     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2660     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2661 
2662     if (!butterfly) {
2663         butterfly = Butterfly::create(
2664             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
2665     }
2666 
2667     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);
2668     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.
2669     return result;
2670 }
2671 
2672 JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(ExecState* exec, Structure* structure, unsigned length, Butterfly* butterfly)
2673 {
2674     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2675     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2676 
2677     IndexingHeader header;
2678     header.setVectorLength(length);
2679     header.setPublicLength(0);
2680     if (butterfly)
2681         *butterfly-&gt;indexingHeader() = header;
2682     else {
2683         butterfly = Butterfly::create(
2684             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), true, header,
2685             sizeof(EncodedJSValue) * length);
2686     }
2687 
2688     // Paradoxically this may allocate a JSArray. That&#39;s totally cool.
2689     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);
2690     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.
2691     return result;
2692 }
2693 
2694 JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(ExecState* exec, void* buffer, uint32_t numItems)
2695 {
2696     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2697     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2698     auto scope = DECLARE_THROW_SCOPE(vm);
2699 
2700     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
2701     Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
2702     for (unsigned i = 0; i &lt; numItems; i++) {
2703         JSValue value = JSValue::decode(values[i]);
2704         if (JSFixedArray* array = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value))
2705             checkedLength += array-&gt;size();
2706         else
2707             ++checkedLength;
2708     }
2709 
2710     if (UNLIKELY(checkedLength.hasOverflowed())) {
2711         throwOutOfMemoryError(exec, scope);
2712         return nullptr;
2713     }
2714 
2715     unsigned length = checkedLength.unsafeGet();
2716     if (UNLIKELY(length &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)) {
2717         throwOutOfMemoryError(exec, scope);
</pre>
<hr />
<pre>
2735             // We are spreading.
2736             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {
2737                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));
2738                 RETURN_IF_EXCEPTION(scope, nullptr);
2739                 ++index;
2740             }
2741         } else {
2742             // We are not spreading.
2743             result-&gt;putDirectIndex(exec, index, value);
2744             RETURN_IF_EXCEPTION(scope, nullptr);
2745             ++index;
2746         }
2747     }
2748 
2749     return result;
2750 }
2751 
2752 JSCell* operationCreateFixedArray(ExecState* exec, unsigned length)
2753 {
2754     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2755     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2756     auto scope = DECLARE_THROW_SCOPE(vm);
2757 
2758     if (JSFixedArray* result = JSFixedArray::tryCreate(vm, vm.fixedArrayStructure.get(), length))
2759         return result;
2760 
2761     throwOutOfMemoryError(exec, scope);
2762     return nullptr;
2763 }
2764 
2765 JSCell* JIT_OPERATION operationSpreadGeneric(ExecState* exec, JSCell* iterable)
2766 {
2767     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2768     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2769 
2770     auto throwScope = DECLARE_THROW_SCOPE(vm);
2771 
2772     if (isJSArray(iterable)) {
2773         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
2774         if (array-&gt;isIteratorProtocolFastAndNonObservable())
2775             RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));
2776     }
2777 
2778     // FIXME: we can probably make this path faster by having our caller JS code call directly into
2779     // the iteration protocol builtin: https://bugs.webkit.org/show_bug.cgi?id=164520
2780 
2781     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
2782     JSArray* array;
2783     {
2784         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
2785         CallData callData;
2786         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
2787         ASSERT(callType != CallType::None);
2788 
2789         MarkedArgumentBuffer arguments;
2790         arguments.append(iterable);
2791         ASSERT(!arguments.hasOverflowed());
2792         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);
2793         RETURN_IF_EXCEPTION(throwScope, nullptr);
2794         array = jsCast&lt;JSArray*&gt;(arrayResult);
2795     }
2796 
2797     RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));
2798 }
2799 
2800 JSCell* JIT_OPERATION operationSpreadFastArray(ExecState* exec, JSCell* cell)
2801 {
2802     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2803     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2804 
2805     ASSERT(isJSArray(cell));
2806     JSArray* array = jsCast&lt;JSArray*&gt;(cell);
2807     ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
2808 
2809     return JSFixedArray::createFromArray(exec, vm, array);
2810 }
2811 
2812 void JIT_OPERATION operationProcessTypeProfilerLogDFG(ExecState* exec)
2813 {
2814     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2815     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2816 
2817     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
2818 }
2819 
2820 EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
2821 {
2822     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2823     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2824 
<span class="line-modified">2825     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, Identifier::fromUid(exec, impl));</span>
2826     return JSValue::encode(resolvedScope);
2827 }
2828 
2829 JSCell* JIT_OPERATION operationResolveScope(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
2830 {
2831     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2832     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2833 
<span class="line-modified">2834     JSObject* resolvedScope = JSScope::resolve(exec, scope, Identifier::fromUid(exec, impl));</span>
2835     return resolvedScope;
2836 }
2837 
2838 EncodedJSValue JIT_OPERATION operationGetDynamicVar(ExecState* exec, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)
2839 {
2840     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2841     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2842     auto throwScope = DECLARE_THROW_SCOPE(vm);
2843 
<span class="line-modified">2844     Identifier ident = Identifier::fromUid(exec, impl);</span>
2845     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
2846         if (!found) {
2847             GetPutInfo getPutInfo(getPutInfoBits);
2848             if (getPutInfo.resolveMode() == ThrowIfNotFound)
2849                 throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2850             return jsUndefined();
2851         }
2852 
2853         if (scope-&gt;isGlobalLexicalEnvironment()) {
2854             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2855             JSValue result = slot.getValue(exec, ident);
2856             if (result == jsTDZValue()) {
2857                 throwException(exec, throwScope, createTDZError(exec));
2858                 return jsUndefined();
2859             }
2860             return result;
2861         }
2862 
2863         return slot.getValue(exec, ident);
2864     })));
2865 }
2866 
<span class="line-modified">2867 void JIT_OPERATION operationPutDynamicVar(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
2868 {
<span class="line-removed">2869     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">2870     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2871     auto throwScope = DECLARE_THROW_SCOPE(vm);
2872 
<span class="line-modified">2873     const Identifier&amp; ident = Identifier::fromUid(exec, impl);</span>
2874     GetPutInfo getPutInfo(getPutInfoBits);
2875     bool hasProperty = scope-&gt;hasProperty(exec, ident);
2876     RETURN_IF_EXCEPTION(throwScope, void());
2877     if (hasProperty
2878         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
2879         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
2880         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2881         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
2882         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);
2883         if (slot.getValue(exec, ident) == jsTDZValue()) {
2884             throwException(exec, throwScope, createTDZError(exec));
2885             return;
2886         }
2887     }
2888 
2889     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
2890         throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2891         return;
2892     }
2893 
<span class="line-modified">2894     CodeOrigin origin = exec-&gt;codeOrigin();</span>
<span class="line-removed">2895     bool strictMode;</span>
<span class="line-removed">2896     if (origin.inlineCallFrame)</span>
<span class="line-removed">2897         strictMode = origin.inlineCallFrame-&gt;baselineCodeBlock-&gt;isStrictMode();</span>
<span class="line-removed">2898     else</span>
<span class="line-removed">2899         strictMode = exec-&gt;codeBlock()-&gt;isStrictMode();</span>
<span class="line-removed">2900     PutPropertySlot slot(scope, strictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));</span>
2901     throwScope.release();
2902     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, JSValue::decode(value), slot);
2903 }
2904 
















2905 int32_t JIT_OPERATION operationMapHash(ExecState* exec, EncodedJSValue input)
2906 {
2907     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2908     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2909 
2910     return jsMapHash(exec, vm, JSValue::decode(input));
2911 }
2912 
2913 JSCell* JIT_OPERATION operationJSMapFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
2914 {
2915     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2916     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2917     JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
2918     if (!bucket)
2919         return vm.sentinelMapBucket();
2920     return *bucket;
2921 }
2922 
2923 JSCell* JIT_OPERATION operationJSSetFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
2924 {
2925     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2926     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2927     JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
2928     if (!bucket)
2929         return vm.sentinelSetBucket();
2930     return *bucket;
2931 }
2932 
2933 JSCell* JIT_OPERATION operationSetAdd(ExecState* exec, JSCell* set, EncodedJSValue key, int32_t hash)
2934 {
2935     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2936     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2937     auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(exec, JSValue::decode(key), JSValue(), hash);
2938     if (!bucket)
2939         return vm.sentinelSetBucket();
2940     return bucket;
2941 }
2942 
2943 JSCell* JIT_OPERATION operationMapSet(ExecState* exec, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)
2944 {
2945     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2946     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2947     auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(exec, JSValue::decode(key), JSValue::decode(value), hash);
2948     if (!bucket)
2949         return vm.sentinelMapBucket();
2950     return bucket;
2951 }
2952 
2953 void JIT_OPERATION operationWeakSetAdd(ExecState* exec, JSCell* set, JSCell* key, int32_t hash)
2954 {
2955     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2956     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2957     jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
2958 }
2959 
2960 void JIT_OPERATION operationWeakMapSet(ExecState* exec, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)
2961 {
2962     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2963     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2964     jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
2965 }
2966 
2967 EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(ExecState* exec, JSObject* thisObject)
2968 {
2969     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2970     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2971     return JSValue::encode(thisObject-&gt;getPrototype(vm, exec));
2972 }
2973 
2974 EncodedJSValue JIT_OPERATION operationGetPrototypeOf(ExecState* exec, EncodedJSValue encodedValue)
2975 {
2976     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2977     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2978     auto scope = DECLARE_THROW_SCOPE(vm);
2979 
2980     JSValue thisValue = JSValue::decode(encodedValue).toThis(exec, StrictMode);
2981     if (thisValue.isUndefinedOrNull())
2982         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));
2983 
2984     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
2985     if (!thisObject) {
2986         JSObject* prototype = thisValue.synthesizePrototype(exec);
2987         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
2988         if (UNLIKELY(!prototype))
2989             return JSValue::encode(JSValue());
2990         return JSValue::encode(prototype);
2991     }
2992 
2993     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));
2994 }
2995 
2996 void JIT_OPERATION operationThrowDFG(ExecState* exec, EncodedJSValue valueToThrow)
2997 {
2998     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2999     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
3000     auto scope = DECLARE_THROW_SCOPE(vm);
3001     scope.throwException(exec, JSValue::decode(valueToThrow));
3002 }
3003 
3004 void JIT_OPERATION operationThrowStaticError(ExecState* exec, JSString* message, uint32_t errorType)
3005 {
3006     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3007     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
3008     auto scope = DECLARE_THROW_SCOPE(vm);
3009     String errorMessage = message-&gt;value(exec);
3010     scope.throwException(exec, createError(exec, static_cast&lt;ErrorType&gt;(errorType), errorMessage));
3011 }
3012 
3013 extern &quot;C&quot; void JIT_OPERATION triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)
3014 {
3015     // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
3016     // really be profitable.
<span class="line-modified">3017     DeferGCForAWhile deferGC(codeBlock-&gt;vm()-&gt;heap);</span>
3018 
3019     sanitizeStackForVM(codeBlock-&gt;vm());
3020 
3021     if (Options::verboseOSR())
3022         dataLog(*codeBlock, &quot;: Entered reoptimize\n&quot;);
3023     // We must be called with the baseline code block.
3024     ASSERT(JITCode::isBaselineCode(codeBlock-&gt;jitType()));
3025 
3026     // If I am my own replacement, then reoptimization has already been triggered.
3027     // This can happen in recursive functions.
3028     //
3029     // Note that even if optimizedCodeBlock is an FTLForOSREntry style CodeBlock, this condition is a
3030     // sure bet that we don&#39;t have anything else left to do.
3031     CodeBlock* replacement = codeBlock-&gt;replacement();
3032     if (!replacement || replacement == codeBlock) {
3033         if (Options::verboseOSR())
3034             dataLog(*codeBlock, &quot;: Not reoptimizing because we&#39;ve already been jettisoned.\n&quot;);
3035         return;
3036     }
3037 
3038     // Otherwise, the replacement must be optimized code. Use this as an opportunity
3039     // to check our logic.
3040     ASSERT(codeBlock-&gt;hasOptimizedReplacement());
3041     ASSERT(JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
3042 
3043     bool didTryToEnterIntoInlinedLoops = false;
<span class="line-modified">3044     for (InlineCallFrame* inlineCallFrame = exit-&gt;m_codeOrigin.inlineCallFrame; inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame) {</span>
3045         if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
3046             didTryToEnterIntoInlinedLoops = true;
3047             break;
3048         }
3049     }
3050 
3051     // In order to trigger reoptimization, one of two things must have happened:
3052     // 1) We exited more than some number of times.
3053     // 2) We exited and got stuck in a loop, and now we&#39;re exiting again.
3054     bool didExitABunch = optimizedCodeBlock-&gt;shouldReoptimizeNow();
3055     bool didGetStuckInLoop =
3056         (codeBlock-&gt;checkIfOptimizationThresholdReached() || didTryToEnterIntoInlinedLoops)
3057         &amp;&amp; optimizedCodeBlock-&gt;shouldReoptimizeFromLoopNow();
3058 
3059     if (!didExitABunch &amp;&amp; !didGetStuckInLoop) {
3060         if (Options::verboseOSR())
3061             dataLog(*codeBlock, &quot;: Not reoptimizing &quot;, *optimizedCodeBlock, &quot; because it either didn&#39;t exit enough or didn&#39;t loop enough after exit.\n&quot;);
3062         codeBlock-&gt;optimizeAfterLongWarmUp();
3063         return;
3064     }
</pre>
<hr />
<pre>
3070 static bool shouldTriggerFTLCompile(CodeBlock* codeBlock, JITCode* jitCode)
3071 {
3072     if (codeBlock-&gt;baselineVersion()-&gt;m_didFailFTLCompilation) {
3073         CODEBLOCK_LOG_EVENT(codeBlock, &quot;abortFTLCompile&quot;, ());
3074         if (Options::verboseOSR())
3075             dataLog(&quot;Deferring FTL-optimization of &quot;, *codeBlock, &quot; indefinitely because there was an FTL failure.\n&quot;);
3076         jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3077         return false;
3078     }
3079 
3080     if (!codeBlock-&gt;hasOptimizedReplacement()
3081         &amp;&amp; !jitCode-&gt;checkIfOptimizationThresholdReached(codeBlock)) {
3082         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;counter = &quot;, jitCode-&gt;tierUpCounter));
3083         if (Options::verboseOSR())
3084             dataLog(&quot;Choosing not to FTL-optimize &quot;, *codeBlock, &quot; yet.\n&quot;);
3085         return false;
3086     }
3087     return true;
3088 }
3089 
<span class="line-modified">3090 static void triggerFTLReplacementCompile(VM* vm, CodeBlock* codeBlock, JITCode* jitCode)</span>
3091 {
3092     if (codeBlock-&gt;codeType() == GlobalCode) {
3093         // Global code runs once, so we don&#39;t want to do anything. We don&#39;t want to defer indefinitely,
3094         // since this may have been spuriously called from tier-up initiated in a loop, and that loop may
3095         // later want to run faster code. Deferring for warm-up seems safest.
3096         jitCode-&gt;optimizeAfterWarmUp(codeBlock);
3097         return;
3098     }
3099 
3100     Worklist::State worklistState;
3101     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3102         worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">3103             *vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLMode));</span>
3104     } else
3105         worklistState = Worklist::NotKnown;
3106 
3107     if (worklistState == Worklist::Compiling) {
3108         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3109         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3110             codeBlock, CompilationDeferred);
3111         return;
3112     }
3113 
3114     if (codeBlock-&gt;hasOptimizedReplacement()) {
3115         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;has replacement&quot;));
3116         // That&#39;s great, we&#39;ve compiled the code - next time we call this function,
3117         // we&#39;ll enter that replacement.
3118         jitCode-&gt;optimizeSoon(codeBlock);
3119         return;
3120     }
3121 
3122     if (worklistState == Worklist::Compiled) {
3123         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3124         // This means that we finished compiling, but failed somehow; in that case the
3125         // thresholds will be set appropriately.
3126         if (Options::verboseOSR())
3127             dataLog(&quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.\n&quot;);
3128         return;
3129     }
3130 
3131     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
3132     // We need to compile the code.
3133     compile(
<span class="line-modified">3134         *vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, UINT_MAX,</span>
3135         Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
3136 
3137     // If we reached here, the counter has not be reset. Do that now.
3138     jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3139         codeBlock, CompilationDeferred);
3140 }
3141 
3142 void JIT_OPERATION triggerTierUpNow(ExecState* exec)
3143 {
<span class="line-modified">3144     VM* vm = &amp;exec-&gt;vm();</span>
3145     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">3146     DeferGCForAWhile deferGC(vm-&gt;heap);</span>
3147     CodeBlock* codeBlock = exec-&gt;codeBlock();
3148 
3149     sanitizeStackForVM(vm);
3150 
<span class="line-modified">3151     if (codeBlock-&gt;jitType() != JITCode::DFGJIT) {</span>
3152         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3153         RELEASE_ASSERT_NOT_REACHED();
3154     }
3155 
3156     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3157 
3158     if (Options::verboseOSR()) {
3159         dataLog(
3160             *codeBlock, &quot;: Entered triggerTierUpNow with executeCounter = &quot;,
3161             jitCode-&gt;tierUpCounter, &quot;\n&quot;);
3162     }
3163 
3164     if (shouldTriggerFTLCompile(codeBlock, jitCode))
3165         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3166 
3167     if (codeBlock-&gt;hasOptimizedReplacement()) {
3168         if (jitCode-&gt;tierUpEntryTriggers.isEmpty()) {
3169             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;replacement in place, delaying indefinitely&quot;));
3170             // There is nothing more we can do, the only way this will be entered
3171             // is through the function entry point.
3172             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3173             return;
3174         }
3175         if (jitCode-&gt;osrEntryBlock() &amp;&amp; jitCode-&gt;tierUpEntryTriggers.size() == 1) {
3176             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;trigger in place, delaying indefinitely&quot;));
3177             // There is only one outer loop and its trigger must have been set
3178             // when the plan completed.
3179             // Exiting the inner loop is useless, we can ignore the counter and leave
3180             // the trigger do its job.
3181             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3182             return;
3183         }
3184     }
3185 }
3186 
3187 static char* tierUpCommon(ExecState* exec, unsigned originBytecodeIndex, bool canOSREnterHere)
3188 {
<span class="line-modified">3189     VM* vm = &amp;exec-&gt;vm();</span>
3190     CodeBlock* codeBlock = exec-&gt;codeBlock();
3191 
3192     // Resolve any pending plan for OSR Enter on this function.
3193     Worklist::State worklistState;
3194     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3195         worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">3196             *vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLForOSREntryMode));</span>
3197     } else
3198         worklistState = Worklist::NotKnown;
3199 
3200     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3201 
3202     bool triggeredSlowPathToStartCompilation = false;
3203     auto tierUpEntryTriggers = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3204     if (tierUpEntryTriggers != jitCode-&gt;tierUpEntryTriggers.end()) {
3205         switch (tierUpEntryTriggers-&gt;value) {
3206         case JITCode::TriggerReason::DontTrigger:
3207             // The trigger isn&#39;t set, we entered because the counter reached its
3208             // threshold.
3209             break;
3210 
3211         case JITCode::TriggerReason::CompilationDone:
3212             // The trigger was set because compilation completed. Don&#39;t unset it
3213             // so that further DFG executions OSR enter as well.
3214             break;
3215 
3216         case JITCode::TriggerReason::StartCompilation:
</pre>
<hr />
<pre>
3279             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed, OSR entry threshold not met&quot;));
3280             jitCode-&gt;osrEntryRetry++;
3281             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3282                 codeBlock, CompilationDeferred);
3283             return nullptr;
3284         }
3285 
3286         FTL::ForOSREntryJITCode* entryCode = entryBlock-&gt;jitCode()-&gt;ftlForOSREntry();
3287         entryCode-&gt;countEntryFailure();
3288         if (entryCode-&gt;entryFailureCount() &lt;
3289             Options::ftlOSREntryFailureCountForReoptimization()) {
3290             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed&quot;));
3291             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3292                 codeBlock, CompilationDeferred);
3293             return nullptr;
3294         }
3295 
3296         // OSR entry failed. Oh no! This implies that we need to retry. We retry
3297         // without exponential backoff and we only do this for the entry code block.
3298         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed too many times&quot;));
<span class="line-modified">3299         unsigned osrEntryBytecode = entryBlock-&gt;jitCode()-&gt;ftlForOSREntry()-&gt;bytecodeIndex();</span>
<span class="line-removed">3300         jitCode-&gt;clearOSREntryBlock();</span>
<span class="line-removed">3301         jitCode-&gt;osrEntryRetry = 0;</span>
<span class="line-removed">3302         jitCode-&gt;tierUpEntryTriggers.set(osrEntryBytecode, JITCode::TriggerReason::DontTrigger);</span>
<span class="line-removed">3303         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(</span>
<span class="line-removed">3304             codeBlock, CompilationDeferred);</span>
3305         return nullptr;
3306     }
3307 
3308     // It&#39;s time to try to compile code for OSR entry.
3309 
3310     if (!triggeredSlowPathToStartCompilation) {
3311 
3312         // An inner loop didn&#39;t specifically ask for us to kick off a compilation. This means the counter
3313         // crossed its threshold. We either fall through and kick off a compile for originBytecodeIndex,
3314         // or we flag an outer loop to immediately try to compile itself. If there are outer loops,
3315         // we first try to make them compile themselves. But we will eventually fall back to compiling
3316         // a progressively inner loop if it takes too long for control to reach an outer loop.
3317 
3318         auto tryTriggerOuterLoopToCompile = [&amp;] {
3319             auto tierUpHierarchyEntry = jitCode-&gt;tierUpInLoopHierarchy.find(originBytecodeIndex);
3320             if (tierUpHierarchyEntry == jitCode-&gt;tierUpInLoopHierarchy.end())
3321                 return false;
3322 
3323             // This vector is ordered from innermost to outermost loop. Every bytecode entry in this vector is
3324             // allowed to do OSR entry. We start with the outermost loop and make our way inwards (hence why we
</pre>
<hr />
<pre>
3361 
3362     // We aren&#39;t compiling and haven&#39;t compiled anything for OSR entry. So, try to compile
3363     // something.
3364 
3365     auto triggerIterator = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3366     if (triggerIterator == jitCode-&gt;tierUpEntryTriggers.end()) {
3367         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3368         return nullptr;
3369     }
3370 
3371     JITCode::TriggerReason* triggerAddress = &amp;(triggerIterator-&gt;value);
3372 
3373     Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues;
3374     unsigned streamIndex = jitCode-&gt;bytecodeIndexToStreamIndex.get(originBytecodeIndex);
3375     jitCode-&gt;reconstruct(
3376         exec, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);
3377     CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
3378 
3379     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
3380     CompilationResult forEntryResult = compile(
<span class="line-modified">3381         *vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,</span>
3382         mustHandleValues, ToFTLForOSREntryDeferredCompilationCallback::create(triggerAddress));
3383 
3384     if (jitCode-&gt;neverExecutedEntry)
3385         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3386 
3387     if (forEntryResult != CompilationSuccessful) {
3388         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR ecompilation not successful&quot;));
3389         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3390             codeBlock, CompilationDeferred);
3391         return nullptr;
3392     }
3393 
3394     CODEBLOCK_LOG_EVENT(jitCode-&gt;osrEntryBlock(), &quot;osrEntry&quot;, (&quot;at bc#&quot;, originBytecodeIndex));
3395     // It&#39;s possible that the for-entry compile already succeeded. In that case OSR
3396     // entry will succeed unless we ran out of stack. It&#39;s not clear what we should do.
3397     // We signal to try again after a while if that happens.
3398     if (Options::verboseOSR())
3399         dataLog(&quot;Immediate OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(jitCode-&gt;osrEntryBlock()), &quot;\n&quot;);
3400 
3401     void* address = FTL::prepareOSREntry(
3402         exec, codeBlock, jitCode-&gt;osrEntryBlock(), originBytecodeIndex, streamIndex);
3403     if (!address)
3404         return nullptr;
3405     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));
3406 }
3407 
3408 void JIT_OPERATION triggerTierUpNowInLoop(ExecState* exec, unsigned bytecodeIndex)
3409 {
<span class="line-modified">3410     VM* vm = &amp;exec-&gt;vm();</span>
3411     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">3412     DeferGCForAWhile deferGC(vm-&gt;heap);</span>
3413     CodeBlock* codeBlock = exec-&gt;codeBlock();
3414 
3415     sanitizeStackForVM(vm);
3416 
<span class="line-modified">3417     if (codeBlock-&gt;jitType() != JITCode::DFGJIT) {</span>
3418         dataLog(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock, &quot;\n&quot;);
3419         RELEASE_ASSERT_NOT_REACHED();
3420     }
3421 
3422     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3423 
3424     if (Options::verboseOSR()) {
3425         dataLog(
3426             *codeBlock, &quot;: Entered triggerTierUpNowInLoop with executeCounter = &quot;,
3427             jitCode-&gt;tierUpCounter, &quot;\n&quot;);
3428     }
3429 
3430     if (jitCode-&gt;tierUpInLoopHierarchy.contains(bytecodeIndex))
3431         tierUpCommon(exec, bytecodeIndex, false);
3432     else if (shouldTriggerFTLCompile(codeBlock, jitCode))
3433         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3434 
3435     // Since we cannot OSR Enter here, the default &quot;optimizeSoon()&quot; is not useful.
3436     if (codeBlock-&gt;hasOptimizedReplacement()) {
3437         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR in loop failed, deferring&quot;));
3438         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3439     }
3440 }
3441 
3442 char* JIT_OPERATION triggerOSREntryNow(ExecState* exec, unsigned bytecodeIndex)
3443 {
<span class="line-modified">3444     VM* vm = &amp;exec-&gt;vm();</span>
3445     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">3446     DeferGCForAWhile deferGC(vm-&gt;heap);</span>
3447     CodeBlock* codeBlock = exec-&gt;codeBlock();
3448 
3449     sanitizeStackForVM(vm);
3450 
<span class="line-modified">3451     if (codeBlock-&gt;jitType() != JITCode::DFGJIT) {</span>
3452         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3453         RELEASE_ASSERT_NOT_REACHED();
3454     }
3455 
3456     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
<span class="line-removed">3457     jitCode-&gt;tierUpEntrySeen.add(bytecodeIndex);</span>
3458 
3459     if (Options::verboseOSR()) {
3460         dataLog(
3461             *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;,
3462             jitCode-&gt;tierUpCounter, &quot;\n&quot;);
3463     }
3464 
3465     return tierUpCommon(exec, bytecodeIndex, true);
3466 }
3467 
3468 #endif // ENABLE(FTL_JIT)
3469 
3470 } // extern &quot;C&quot;
3471 } } // namespace JSC::DFG
3472 
3473 #endif // ENABLE(DFG_JIT)
3474 
3475 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
  79 #include &quot;VMInlines.h&quot;
  80 #include &lt;wtf/InlineASM.h&gt;
  81 #include &lt;wtf/Variant.h&gt;
  82 
  83 #if ENABLE(JIT)
  84 #if ENABLE(DFG_JIT)
  85 
  86 namespace JSC { namespace DFG {
  87 
  88 template&lt;bool strict, bool direct&gt;
  89 static inline void putByVal(ExecState* exec, VM&amp; vm, JSValue baseValue, uint32_t index, JSValue value)
  90 {
  91     ASSERT(isIndex(index));
  92     if (direct) {
  93         RELEASE_ASSERT(baseValue.isObject());
  94         asObject(baseValue)-&gt;putDirectIndex(exec, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
  95         return;
  96     }
  97     if (baseValue.isObject()) {
  98         JSObject* object = asObject(baseValue);
<span class="line-modified">  99         if (object-&gt;canSetIndexQuickly(index, value)) {</span>
 100             object-&gt;setIndexQuickly(vm, index, value);
 101             return;
 102         }
 103 
 104         object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, index, value, strict);
 105         return;
 106     }
 107 
 108     baseValue.putByIndex(exec, index, value, strict);
 109 }
 110 
 111 template&lt;bool strict, bool direct&gt;
 112 ALWAYS_INLINE static void putByValInternal(ExecState* exec, VM&amp; vm, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 113 {
 114     auto scope = DECLARE_THROW_SCOPE(vm);
 115 
 116     JSValue baseValue = JSValue::decode(encodedBase);
 117     JSValue property = JSValue::decode(encodedProperty);
 118     JSValue value = JSValue::decode(encodedValue);
 119 
</pre>
<hr />
<pre>
 172     }
 173     base-&gt;putInline(exec, propertyName, value, slot);
 174 }
 175 
 176 template&lt;bool strict, bool direct&gt;
 177 ALWAYS_INLINE static void putByValCellStringInternal(ExecState* exec, VM&amp; vm, JSCell* base, JSString* property, JSValue value)
 178 {
 179     auto scope = DECLARE_THROW_SCOPE(vm);
 180 
 181     auto propertyName = property-&gt;toIdentifier(exec);
 182     RETURN_IF_EXCEPTION(scope, void());
 183 
 184     scope.release();
 185     putByValCellInternal&lt;strict, direct&gt;(exec, vm, base, propertyName, value);
 186 }
 187 
 188 template&lt;typename ViewClass&gt;
 189 char* newTypedArrayWithSize(ExecState* exec, Structure* structure, int32_t size, char* vector)
 190 {
 191     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 192     NativeCallFrameTracer tracer(vm, exec);</span>
 193     auto scope = DECLARE_THROW_SCOPE(vm);
 194 
 195     if (size &lt; 0) {
 196         throwException(exec, scope, createRangeError(exec, &quot;Requested length is negative&quot;_s));
 197         return 0;
 198     }
 199 
 200     if (vector)
<span class="line-modified"> 201         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(exec, structure, size, untagArrayPtr(vector, size)));</span>
 202 
 203     RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(exec, structure, size)));
 204 }
 205 
 206 template &lt;bool strict&gt;
 207 static ALWAYS_INLINE void putWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, const Identifier&amp; ident)
 208 {
 209     JSValue baseValue = JSValue::decode(encodedBase);
 210     JSValue thisVal = JSValue::decode(encodedThis);
 211     JSValue putValue = JSValue::decode(encodedValue);
 212     PutPropertySlot slot(thisVal, strict);
 213     baseValue.putInline(exec, ident, putValue, slot);
 214 }
 215 
<span class="line-added"> 216 template&lt;typename BigIntOperation, typename NumberOperation&gt;</span>
<span class="line-added"> 217 static ALWAYS_INLINE EncodedJSValue binaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, NumberOperation&amp;&amp; numberOp, const char* errorMessage)</span>
<span class="line-added"> 218 {</span>
<span class="line-added"> 219     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added"> 220     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added"> 221     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 222 </span>
<span class="line-added"> 223     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added"> 224     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226     auto leftNumeric = op1.toNumeric(exec);</span>
<span class="line-added"> 227     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 228     auto rightNumeric = op2.toNumeric(exec);</span>
<span class="line-added"> 229     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 230 </span>
<span class="line-added"> 231     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-added"> 232         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))</span>
<span class="line-added"> 233             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
<span class="line-added"> 234 </span>
<span class="line-added"> 235         return throwVMTypeError(exec, scope, errorMessage);</span>
<span class="line-added"> 236     }</span>
<span class="line-added"> 237 </span>
<span class="line-added"> 238     scope.release();</span>
<span class="line-added"> 239 </span>
<span class="line-added"> 240     return JSValue::encode(jsNumber(numberOp(WTF::get&lt;double&gt;(leftNumeric), WTF::get&lt;double&gt;(rightNumeric))));</span>
<span class="line-added"> 241 }</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243 template&lt;typename BigIntOperation, typename Int32Operation&gt;</span>
<span class="line-added"> 244 static ALWAYS_INLINE EncodedJSValue bitwiseBinaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, Int32Operation&amp;&amp; int32Op, const char* errorMessage)</span>
<span class="line-added"> 245 {</span>
<span class="line-added"> 246     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added"> 247     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added"> 248     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 249 </span>
<span class="line-added"> 250     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added"> 251     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-added"> 252 </span>
<span class="line-added"> 253     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-added"> 254     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 255     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
<span class="line-added"> 256     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 257 </span>
<span class="line-added"> 258     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-added"> 259         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))</span>
<span class="line-added"> 260             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
<span class="line-added"> 261 </span>
<span class="line-added"> 262         return throwVMTypeError(exec, scope, errorMessage);</span>
<span class="line-added"> 263     }</span>
<span class="line-added"> 264 </span>
<span class="line-added"> 265     scope.release();</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267     return JSValue::encode(jsNumber(int32Op(WTF::get&lt;int32_t&gt;(leftNumeric), WTF::get&lt;int32_t&gt;(rightNumeric))));</span>
<span class="line-added"> 268 }</span>
<span class="line-added"> 269 </span>
 270 static ALWAYS_INLINE EncodedJSValue parseIntResult(double input)
 271 {
 272     int asInt = static_cast&lt;int&gt;(input);
 273     if (static_cast&lt;double&gt;(asInt) == input)
 274         return JSValue::encode(jsNumber(asInt));
 275     return JSValue::encode(jsNumber(input));
 276 }
 277 
 278 ALWAYS_INLINE static JSValue getByValObject(ExecState* exec, VM&amp; vm, JSObject* base, PropertyName propertyName)
 279 {
 280     Structure&amp; structure = *base-&gt;structure(vm);
 281     if (JSCell::canUseFastGetOwnProperty(structure)) {
 282         if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, propertyName))
 283             return result;
 284     }
 285     return base-&gt;get(exec, propertyName);
 286 }
 287 
 288 extern &quot;C&quot; {
 289 
 290 EncodedJSValue JIT_OPERATION operationToThis(ExecState* exec, EncodedJSValue encodedOp)
 291 {
<span class="line-modified"> 292     VM&amp; vm = exec-&gt;vm();</span>
 293     NativeCallFrameTracer tracer(vm, exec);
 294 
 295     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, NotStrictMode));
 296 }
 297 
 298 EncodedJSValue JIT_OPERATION operationToThisStrict(ExecState* exec, EncodedJSValue encodedOp)
 299 {
<span class="line-modified"> 300     VM&amp; vm = exec-&gt;vm();</span>
 301     NativeCallFrameTracer tracer(vm, exec);
 302 
 303     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, StrictMode));
 304 }
 305 
 306 JSArray* JIT_OPERATION operationObjectKeys(ExecState* exec, EncodedJSValue encodedObject)
 307 {
 308     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 309     NativeCallFrameTracer tracer(vm, exec);</span>
 310     auto scope = DECLARE_THROW_SCOPE(vm);
 311 
 312     JSObject* object = JSValue::decode(encodedObject).toObject(exec);
 313     RETURN_IF_EXCEPTION(scope, nullptr);
 314     scope.release();
 315     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
 316 }
 317 
 318 JSArray* JIT_OPERATION operationObjectKeysObject(ExecState* exec, JSObject* object)
 319 {
 320     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 321     NativeCallFrameTracer tracer(vm, exec);</span>
 322     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
 323 }
 324 
 325 JSCell* JIT_OPERATION operationObjectCreate(ExecState* exec, EncodedJSValue encodedPrototype)
 326 {
 327     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 328     NativeCallFrameTracer tracer(vm, exec);</span>
 329     auto scope = DECLARE_THROW_SCOPE(vm);
 330 
 331     JSValue prototype = JSValue::decode(encodedPrototype);
 332 
 333     if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
 334         throwVMTypeError(exec, scope, &quot;Object prototype may only be an Object or null.&quot;_s);
 335         return nullptr;
 336     }
 337 
 338     if (prototype.isObject())
 339         RELEASE_AND_RETURN(scope, constructEmptyObject(exec, asObject(prototype)));
 340     RELEASE_AND_RETURN(scope, constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure()));
 341 }
 342 
 343 JSCell* JIT_OPERATION operationObjectCreateObject(ExecState* exec, JSObject* prototype)
 344 {
 345     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 346     NativeCallFrameTracer tracer(vm, exec);</span>
 347     return constructEmptyObject(exec, prototype);
 348 }
 349 
 350 JSCell* JIT_OPERATION operationCreateThis(ExecState* exec, JSObject* constructor, uint32_t inlineCapacity)
 351 {
 352     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 353     NativeCallFrameTracer tracer(vm, exec);</span>
 354     auto scope = DECLARE_THROW_SCOPE(vm);
 355     if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
 356         auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity);
 357         scope.releaseAssertNoException();
<span class="line-modified"> 358         ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();</span>
 359         Structure* structure = allocationProfile-&gt;structure();
 360         JSObject* result = constructEmptyObject(exec, structure);
 361         if (structure-&gt;hasPolyProto()) {
 362             JSObject* prototype = allocationProfile-&gt;prototype();
 363             ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, exec));
 364             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 365             prototype-&gt;didBecomePrototype();
 366             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 367         }
 368         return result;
 369     }
 370 
 371     JSValue proto = constructor-&gt;get(exec, vm.propertyNames-&gt;prototype);
 372     RETURN_IF_EXCEPTION(scope, nullptr);
 373     if (proto.isObject())
 374         return constructEmptyObject(exec, asObject(proto));
 375     return constructEmptyObject(exec);
 376 }
 377 
 378 JSCell* JIT_OPERATION operationCallObjectConstructor(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget)
 379 {
<span class="line-modified"> 380     VM&amp; vm = exec-&gt;vm();</span>
 381     NativeCallFrameTracer tracer(vm, exec);
 382 
 383     JSValue value = JSValue::decode(encodedTarget);
 384     ASSERT(!value.isObject());
 385 
 386     if (value.isUndefinedOrNull())
 387         return constructEmptyObject(exec, globalObject-&gt;objectPrototype());
 388     return value.toObject(exec, globalObject);
 389 }
 390 
 391 JSCell* JIT_OPERATION operationToObject(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)
 392 {
<span class="line-modified"> 393     VM&amp; vm = exec-&gt;vm();</span>
 394     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 395     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 396 
 397     JSValue value = JSValue::decode(encodedTarget);
 398     ASSERT(!value.isObject());
 399 
 400     if (UNLIKELY(value.isUndefinedOrNull())) {
 401         if (errorMessage-&gt;length()) {
 402             throwVMTypeError(exec, scope, errorMessage);
 403             return nullptr;
 404         }
 405     }
 406 
 407     RELEASE_AND_RETURN(scope, value.toObject(exec, globalObject));
 408 }
 409 
<span class="line-modified"> 410 EncodedJSValue JIT_OPERATION operationValueMod(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 411 {
<span class="line-modified"> 412     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 413         return JSBigInt::remainder(exec, left, right);</span>
<span class="line-modified"> 414     };</span>
 415 
<span class="line-modified"> 416     auto numberOp = [] (double left, double right) -&gt; double {</span>
<span class="line-added"> 417         return jsMod(left, right);</span>
<span class="line-added"> 418     };</span>
 419 
<span class="line-modified"> 420     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;);</span>



 421 }
 422 
<span class="line-modified"> 423 EncodedJSValue JIT_OPERATION operationValueBitNot(ExecState* exec, EncodedJSValue encodedOp1)</span>
 424 {
<span class="line-modified"> 425     VM&amp; vm = exec-&gt;vm();</span>
 426     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 427     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 428 
 429     JSValue op1 = JSValue::decode(encodedOp1);

 430 
<span class="line-modified"> 431     auto operandNumeric = op1.toBigIntOrInt32(exec);</span>


 432     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 433 
<span class="line-modified"> 434     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))</span>
<span class="line-modified"> 435         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>







 436 
<span class="line-modified"> 437     return JSValue::encode(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));</span>
 438 }
 439 
<span class="line-modified"> 440 EncodedJSValue JIT_OPERATION operationValueBitAnd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 441 {
<span class="line-modified"> 442     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 443         return JSBigInt::bitwiseAnd(exec, left, right);</span>
<span class="line-modified"> 444     };</span>
 445 
<span class="line-modified"> 446     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified"> 447         return left &amp; right;</span>
<span class="line-added"> 448     };</span>
 449 
<span class="line-modified"> 450     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;_s);</span>
<span class="line-modified"> 451 }</span>


 452 
<span class="line-modified"> 453 EncodedJSValue JIT_OPERATION operationValueBitOr(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
<span class="line-modified"> 454 {</span>
<span class="line-modified"> 455     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 456         return JSBigInt::bitwiseOr(exec, left, right);</span>
<span class="line-modified"> 457     };</span>

 458 
<span class="line-modified"> 459     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified"> 460         return left | right;</span>
<span class="line-added"> 461     };</span>
 462 
<span class="line-modified"> 463     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;_s);</span>
 464 }
 465 
 466 EncodedJSValue JIT_OPERATION operationValueBitXor(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 467 {
<span class="line-modified"> 468     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 469         return JSBigInt::bitwiseXor(exec, left, right);</span>
<span class="line-modified"> 470     };</span>















 471 
<span class="line-modified"> 472     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified"> 473         return left ^ right;</span>
<span class="line-added"> 474     };</span>
 475 
<span class="line-modified"> 476     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;_s);</span>
 477 }
 478 
 479 EncodedJSValue JIT_OPERATION operationValueBitLShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 480 {
<span class="line-modified"> 481     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 482         return JSBigInt::leftShift(exec, left, right);</span>
<span class="line-modified"> 483     };</span>
 484 
<span class="line-modified"> 485     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified"> 486         return left &lt;&lt; (right &amp; 0x1f);</span>
<span class="line-added"> 487     };</span>
 488 
<span class="line-modified"> 489     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;_s);</span>




 490 }
 491 
 492 EncodedJSValue JIT_OPERATION operationValueBitRShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 493 {
<span class="line-modified"> 494     VM&amp; vm = exec-&gt;vm();</span>
 495     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 496     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 497 
 498     JSValue op1 = JSValue::decode(encodedOp1);
 499     JSValue op2 = JSValue::decode(encodedOp2);
 500 
 501     int32_t a = op1.toInt32(exec);
 502     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 503     scope.release();
 504     uint32_t b = op2.toUInt32(exec);
 505     return JSValue::encode(jsNumber(a &gt;&gt; (b &amp; 0x1f)));
 506 }
 507 
 508 EncodedJSValue JIT_OPERATION operationValueBitURShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 509 {
<span class="line-modified"> 510     VM&amp; vm = exec-&gt;vm();</span>
 511     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 512     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 513 
 514     JSValue op1 = JSValue::decode(encodedOp1);
 515     JSValue op2 = JSValue::decode(encodedOp2);
 516 
 517     uint32_t a = op1.toUInt32(exec);
 518     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 519     scope.release();
 520     uint32_t b = op2.toUInt32(exec);
 521     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
 522 }
 523 
 524 EncodedJSValue JIT_OPERATION operationValueAddNotNumber(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 525 {
<span class="line-modified"> 526     VM&amp; vm = exec-&gt;vm();</span>
 527     NativeCallFrameTracer tracer(vm, exec);
 528 
 529     JSValue op1 = JSValue::decode(encodedOp1);
 530     JSValue op2 = JSValue::decode(encodedOp2);
 531 
 532     return JSValue::encode(jsAddNonNumber(exec, op1, op2));
 533 }
 534 
 535 EncodedJSValue JIT_OPERATION operationValueDiv(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 536 {
<span class="line-modified"> 537     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 538         return JSBigInt::divide(exec, left, right);</span>
<span class="line-modified"> 539     };</span>



 540 
<span class="line-modified"> 541     auto numberOp = [] (double left, double right) -&gt; double {</span>
<span class="line-modified"> 542         return left / right;</span>
<span class="line-modified"> 543     };</span>

 544 
<span class="line-modified"> 545     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
<span class="line-modified"> 546 }</span>




 547 
<span class="line-modified"> 548 EncodedJSValue JIT_OPERATION operationValuePow(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
<span class="line-modified"> 549 {</span>
<span class="line-added"> 550     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 551         return JSBigInt::exponentiate(exec, left, right);</span>
<span class="line-added"> 552     };</span>
 553 
<span class="line-modified"> 554     auto numberOp = [] (double left, double right) -&gt; double {</span>
<span class="line-added"> 555         return operationMathPow(left, right);</span>
<span class="line-added"> 556     };</span>
 557 
<span class="line-modified"> 558     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;_s);</span>


 559 }
 560 
 561 double JIT_OPERATION operationArithAbs(ExecState* exec, EncodedJSValue encodedOp1)
 562 {
<span class="line-modified"> 563     VM&amp; vm = exec-&gt;vm();</span>
 564     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 565     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 566 
 567     JSValue op1 = JSValue::decode(encodedOp1);
 568     double a = op1.toNumber(exec);
 569     RETURN_IF_EXCEPTION(scope, PNaN);
 570     return fabs(a);
 571 }
 572 
 573 uint32_t JIT_OPERATION operationArithClz32(ExecState* exec, EncodedJSValue encodedOp1)
 574 {
<span class="line-modified"> 575     VM&amp; vm = exec-&gt;vm();</span>
 576     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 577     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 578 
 579     JSValue op1 = JSValue::decode(encodedOp1);
 580     uint32_t value = op1.toUInt32(exec);
 581     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified"> 582     return clz(value);</span>
 583 }
 584 
 585 double JIT_OPERATION operationArithFRound(ExecState* exec, EncodedJSValue encodedOp1)
 586 {
<span class="line-modified"> 587     VM&amp; vm = exec-&gt;vm();</span>
 588     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 589     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 590 
 591     JSValue op1 = JSValue::decode(encodedOp1);
 592     double a = op1.toNumber(exec);
 593     RETURN_IF_EXCEPTION(scope, PNaN);
 594     return static_cast&lt;float&gt;(a);
 595 }
 596 
 597 #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
 598 double JIT_OPERATION operationArith##capitalizedName(ExecState* exec, EncodedJSValue encodedOp1) \
 599 { \
<span class="line-modified"> 600     VM&amp; vm = exec-&gt;vm(); \</span>
 601     NativeCallFrameTracer tracer(vm, exec); \
<span class="line-modified"> 602     auto scope = DECLARE_THROW_SCOPE(vm); \</span>
 603     JSValue op1 = JSValue::decode(encodedOp1); \
 604     double result = op1.toNumber(exec); \
 605     RETURN_IF_EXCEPTION(scope, PNaN); \
 606     return JSC::Math::lowerName(result); \
 607 }
 608     FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
 609 #undef DFG_ARITH_UNARY
 610 
 611 double JIT_OPERATION operationArithSqrt(ExecState* exec, EncodedJSValue encodedOp1)
 612 {
<span class="line-modified"> 613     VM&amp; vm = exec-&gt;vm();</span>
 614     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 615     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 616 
 617     JSValue op1 = JSValue::decode(encodedOp1);
 618     double a = op1.toNumber(exec);
 619     RETURN_IF_EXCEPTION(scope, PNaN);
 620     return sqrt(a);
 621 }
 622 
 623 EncodedJSValue JIT_OPERATION operationArithRound(ExecState* exec, EncodedJSValue encodedArgument)
 624 {
<span class="line-modified"> 625     VM&amp; vm = exec-&gt;vm();</span>
 626     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 627     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 628 
 629     JSValue argument = JSValue::decode(encodedArgument);
 630     double valueOfArgument = argument.toNumber(exec);
 631     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 632     return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
 633 }
 634 
 635 EncodedJSValue JIT_OPERATION operationArithFloor(ExecState* exec, EncodedJSValue encodedArgument)
 636 {
<span class="line-modified"> 637     VM&amp; vm = exec-&gt;vm();</span>
 638     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 639     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 640 
 641     JSValue argument = JSValue::decode(encodedArgument);
 642     double valueOfArgument = argument.toNumber(exec);
 643     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 644     return JSValue::encode(jsNumber(floor(valueOfArgument)));
 645 }
 646 
 647 EncodedJSValue JIT_OPERATION operationArithCeil(ExecState* exec, EncodedJSValue encodedArgument)
 648 {
<span class="line-modified"> 649     VM&amp; vm = exec-&gt;vm();</span>
 650     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 651     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 652 
 653     JSValue argument = JSValue::decode(encodedArgument);
 654     double valueOfArgument = argument.toNumber(exec);
 655     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 656     return JSValue::encode(jsNumber(ceil(valueOfArgument)));
 657 }
 658 
 659 EncodedJSValue JIT_OPERATION operationArithTrunc(ExecState* exec, EncodedJSValue encodedArgument)
 660 {
<span class="line-modified"> 661     VM&amp; vm = exec-&gt;vm();</span>
 662     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 663     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 664 
 665     JSValue argument = JSValue::decode(encodedArgument);
 666     double truncatedValueOfArgument = argument.toIntegerPreserveNaN(exec);
 667     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 668     return JSValue::encode(jsNumber(truncatedValueOfArgument));
 669 }
 670 
 671 static ALWAYS_INLINE EncodedJSValue getByVal(ExecState* exec, JSCell* base, uint32_t index)
 672 {
 673     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 674     NativeCallFrameTracer tracer(vm, exec);</span>
 675 
 676     if (base-&gt;isObject()) {
 677         JSObject* object = asObject(base);
 678         if (object-&gt;canGetIndexQuickly(index))
 679             return JSValue::encode(object-&gt;getIndexQuickly(index));
 680     }
 681 
 682     if (isJSString(base) &amp;&amp; asString(base)-&gt;canGetIndex(index))
 683         return JSValue::encode(asString(base)-&gt;getIndex(exec, index));
 684 
 685     return JSValue::encode(JSValue(base).get(exec, index));
 686 }
 687 
 688 EncodedJSValue JIT_OPERATION operationGetByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty)
 689 {
 690     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 691     NativeCallFrameTracer tracer(vm, exec);</span>
 692     auto scope = DECLARE_THROW_SCOPE(vm);
 693 
 694     JSValue baseValue = JSValue::decode(encodedBase);
 695     JSValue property = JSValue::decode(encodedProperty);
 696 
 697     if (LIKELY(baseValue.isCell())) {
 698         JSCell* base = baseValue.asCell();
 699 
 700         if (property.isUInt32())
 701             RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));
 702 
 703         if (property.isDouble()) {
 704             double propertyAsDouble = property.asDouble();
 705             uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 706             if (propertyAsUInt32 == propertyAsDouble &amp;&amp; isIndex(propertyAsUInt32))
 707                 RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
 708 
 709         } else if (property.isString()) {
 710             Structure&amp; structure = *base-&gt;structure(vm);
 711             if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 712                 RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified"> 713                 RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 714                 if (existingAtomString) {</span>
<span class="line-added"> 715                     if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
 716                         return JSValue::encode(result);
 717                 }
 718             }
 719         }
 720     }
 721 
 722     baseValue.requireObjectCoercible(exec);
 723     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 724     auto propertyName = property.toPropertyKey(exec);
 725     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 726     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, propertyName)));
 727 }
 728 
 729 EncodedJSValue JIT_OPERATION operationGetByValCell(ExecState* exec, JSCell* base, EncodedJSValue encodedProperty)
 730 {
 731     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 732     NativeCallFrameTracer tracer(vm, exec);</span>
 733     auto scope = DECLARE_THROW_SCOPE(vm);
 734 
 735     JSValue property = JSValue::decode(encodedProperty);
 736 
 737     if (property.isUInt32())
 738         RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));
 739 
 740     if (property.isDouble()) {
 741         double propertyAsDouble = property.asDouble();
 742         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 743         if (propertyAsUInt32 == propertyAsDouble)
 744             RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
 745 
 746     } else if (property.isString()) {
 747         Structure&amp; structure = *base-&gt;structure(vm);
 748         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 749             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified"> 750             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 751             if (existingAtomString) {</span>
<span class="line-added"> 752                 if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
 753                     return JSValue::encode(result);
 754             }
 755         }
 756     }
 757 
 758     auto propertyName = property.toPropertyKey(exec);
 759     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 760     RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(exec, propertyName)));
 761 }
 762 
 763 ALWAYS_INLINE EncodedJSValue getByValCellInt(ExecState* exec, JSCell* base, int32_t index)
 764 {
<span class="line-modified"> 765     VM&amp; vm = exec-&gt;vm();</span>
 766     NativeCallFrameTracer tracer(vm, exec);
 767 
 768     if (index &lt; 0) {
 769         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified"> 770         return JSValue::encode(JSValue(base).get(exec, Identifier::from(vm, index)));</span>
 771     }
 772 
 773     // Use this since we know that the value is out of bounds.
 774     return JSValue::encode(JSValue(base).get(exec, static_cast&lt;unsigned&gt;(index)));
 775 }
 776 
 777 EncodedJSValue JIT_OPERATION operationGetByValObjectInt(ExecState* exec, JSObject* base, int32_t index)
 778 {
 779     return getByValCellInt(exec, base, index);
 780 }
 781 
 782 EncodedJSValue JIT_OPERATION operationGetByValStringInt(ExecState* exec, JSString* base, int32_t index)
 783 {
 784     return getByValCellInt(exec, base, index);
 785 }
 786 
 787 EncodedJSValue JIT_OPERATION operationGetByValObjectString(ExecState* exec, JSCell* base, JSCell* string)
 788 {
 789     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 790     NativeCallFrameTracer tracer(vm, exec);</span>
 791 
 792     auto scope = DECLARE_THROW_SCOPE(vm);
 793 
 794     auto propertyName = asString(string)-&gt;toIdentifier(exec);
 795     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 796 
 797     RELEASE_AND_RETURN(scope, JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName)));
 798 }
 799 
 800 EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(ExecState* exec, JSCell* base, JSCell* symbol)
 801 {
 802     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 803     NativeCallFrameTracer tracer(vm, exec);</span>
 804 
<span class="line-modified"> 805     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added"> 806     return JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName));</span>
 807 }
 808 
 809 void JIT_OPERATION operationPutByValStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 810 {
 811     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 812     NativeCallFrameTracer tracer(vm, exec);</span>
 813 
 814     putByValInternal&lt;true, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 815 }
 816 
 817 void JIT_OPERATION operationPutByValNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 818 {
 819     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 820     NativeCallFrameTracer tracer(vm, exec);</span>
 821 
 822     putByValInternal&lt;false, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 823 }
 824 
 825 void JIT_OPERATION operationPutByValCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 826 {
 827     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 828     NativeCallFrameTracer tracer(vm, exec);</span>
 829 
 830     putByValInternal&lt;true, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 831 }
 832 
 833 void JIT_OPERATION operationPutByValCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 834 {
 835     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 836     NativeCallFrameTracer tracer(vm, exec);</span>
 837 
 838     putByValInternal&lt;false, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 839 }
 840 
 841 void JIT_OPERATION operationPutByValCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 842 {
 843     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 844     NativeCallFrameTracer tracer(vm, exec);</span>
 845 
 846     putByValCellStringInternal&lt;true, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
 847 }
 848 
 849 void JIT_OPERATION operationPutByValCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 850 {
 851     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 852     NativeCallFrameTracer tracer(vm, exec);</span>
 853 
 854     putByValCellStringInternal&lt;false, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
 855 }
 856 
 857 void JIT_OPERATION operationPutByValCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
 858 {
 859     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 860     NativeCallFrameTracer tracer(vm, exec);</span>
 861 
<span class="line-modified"> 862     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added"> 863     putByValCellInternal&lt;true, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
 864 }
 865 
 866 void JIT_OPERATION operationPutByValCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
 867 {
 868     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 869     NativeCallFrameTracer tracer(vm, exec);</span>
 870 
<span class="line-modified"> 871     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added"> 872     putByValCellInternal&lt;false, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
 873 }
 874 
 875 void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
 876 {
 877     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 878     NativeCallFrameTracer tracer(vm, exec);</span>
 879 
 880     if (index &gt;= 0) {
 881         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), true);
 882         return;
 883     }
 884 
 885     PutPropertySlot slot(object, true);
 886     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 887         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
 888 }
 889 
 890 void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
 891 {
<span class="line-modified"> 892     VM&amp; vm = exec-&gt;vm();</span>
 893     NativeCallFrameTracer tracer(vm, exec);
 894 
 895     if (index &gt;= 0) {
 896         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), false);
 897         return;
 898     }
 899 
 900     PutPropertySlot slot(object, false);
<span class="line-modified"> 901     object-&gt;methodTable(vm)-&gt;put(</span>
<span class="line-modified"> 902         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
 903 }
 904 
 905 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 906 {
<span class="line-modified"> 907     VM&amp; vm = exec-&gt;vm();</span>
 908     NativeCallFrameTracer tracer(vm, exec);
 909 
 910     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 911 
 912     if (index &gt;= 0) {
 913         object-&gt;putByIndexInline(exec, index, jsValue, true);
 914         return;
 915     }
 916 
 917     PutPropertySlot slot(object, true);
<span class="line-modified"> 918     object-&gt;methodTable(vm)-&gt;put(</span>
<span class="line-modified"> 919         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
 920 }
 921 
 922 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 923 {
<span class="line-modified"> 924     VM&amp; vm = exec-&gt;vm();</span>
 925     NativeCallFrameTracer tracer(vm, exec);
 926 
 927     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 928 
 929     if (index &gt;= 0) {
 930         object-&gt;putByIndexInline(exec, index, jsValue, false);
 931         return;
 932     }
 933 
 934     PutPropertySlot slot(object, false);
<span class="line-modified"> 935     object-&gt;methodTable(vm)-&gt;put(</span>
<span class="line-modified"> 936         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
 937 }
 938 
 939 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 940 {
 941     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 942     NativeCallFrameTracer tracer(vm, exec);</span>
 943 
 944     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 945 
 946     if (index &gt;= 0) {
 947         object-&gt;putDirectIndex(exec, index, jsValue, 0, PutDirectIndexShouldThrow);
 948         return;
 949     }
 950 
 951     PutPropertySlot slot(object, true);
<span class="line-modified"> 952     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
 953 }
 954 
 955 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
 956 {
 957     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 958     NativeCallFrameTracer tracer(vm, exec);</span>
 959 
 960     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 961 
 962     if (index &gt;= 0) {
 963         object-&gt;putDirectIndex(exec, index, jsValue);
 964         return;
 965     }
 966 
 967     PutPropertySlot slot(object, false);
<span class="line-modified"> 968     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
 969 }
 970 
 971 void JIT_OPERATION operationPutByValDirectStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 972 {
 973     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 974     NativeCallFrameTracer tracer(vm, exec);</span>
 975 
 976     putByValInternal&lt;true, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 977 }
 978 
 979 void JIT_OPERATION operationPutByValDirectNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 980 {
 981     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 982     NativeCallFrameTracer tracer(vm, exec);</span>
 983 
 984     putByValInternal&lt;false, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
 985 }
 986 
 987 void JIT_OPERATION operationPutByValDirectCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 988 {
 989     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 990     NativeCallFrameTracer tracer(vm, exec);</span>
 991 
 992     putByValInternal&lt;true, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 993 }
 994 
 995 void JIT_OPERATION operationPutByValDirectCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 996 {
 997     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 998     NativeCallFrameTracer tracer(vm, exec);</span>
 999 
1000     putByValInternal&lt;false, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
1001 }
1002 
1003 void JIT_OPERATION operationPutByValDirectCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
1004 {
1005     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1006     NativeCallFrameTracer tracer(vm, exec);</span>
1007 
1008     putByValCellStringInternal&lt;true, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
1009 }
1010 
1011 void JIT_OPERATION operationPutByValDirectCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
1012 {
1013     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1014     NativeCallFrameTracer tracer(vm, exec);</span>
1015 
1016     putByValCellStringInternal&lt;false, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
1017 }
1018 
1019 void JIT_OPERATION operationPutByValDirectCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
1020 {
1021     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1022     NativeCallFrameTracer tracer(vm, exec);</span>
1023 
<span class="line-modified">1024     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added">1025     putByValCellInternal&lt;true, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
1026 }
1027 
1028 void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
1029 {
1030     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1031     NativeCallFrameTracer tracer(vm, exec);</span>
1032 
<span class="line-modified">1033     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added">1034     putByValCellInternal&lt;false, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
1035 }
1036 
1037 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
1038 {
1039     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1040     NativeCallFrameTracer tracer(vm, exec);</span>
1041     if (index &gt;= 0) {
1042         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);
1043         return;
1044     }
1045 
1046     PutPropertySlot slot(object, true);
<span class="line-modified">1047     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
1048 }
1049 
1050 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
1051 {
1052     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1053     NativeCallFrameTracer tracer(vm, exec);</span>
1054 
1055     if (index &gt;= 0) {
1056         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));
1057         return;
1058     }
1059 
1060     PutPropertySlot slot(object, false);
<span class="line-modified">1061     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
1062 }
1063 
1064 EncodedJSValue JIT_OPERATION operationArrayPush(ExecState* exec, EncodedJSValue encodedValue, JSArray* array)
1065 {
<span class="line-modified">1066     VM&amp; vm = exec-&gt;vm();</span>
1067     NativeCallFrameTracer tracer(vm, exec);
1068 
1069     array-&gt;pushInline(exec, JSValue::decode(encodedValue));
1070     return JSValue::encode(jsNumber(array-&gt;length()));
1071 }
1072 
1073 EncodedJSValue JIT_OPERATION operationArrayPushDouble(ExecState* exec, double value, JSArray* array)
1074 {
<span class="line-modified">1075     VM&amp; vm = exec-&gt;vm();</span>
1076     NativeCallFrameTracer tracer(vm, exec);
1077 
1078     array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, value));
1079     return JSValue::encode(jsNumber(array-&gt;length()));
1080 }
1081 
1082 EncodedJSValue JIT_OPERATION operationArrayPushMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
1083 {
1084     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1085     NativeCallFrameTracer tracer(vm, exec);</span>
1086     auto scope = DECLARE_THROW_SCOPE(vm);
1087 
1088     // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
1089     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1090     // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
1091     // that there is no indexed accessors in this object and its prototype chain.
1092     //
1093     // ArrayWithArrayStorage is also OK. It can have indexed accessors. But if you define an indexed accessor, the array&#39;s length
1094     // becomes larger than that index. So Array#push never overlaps with this accessor. So accessors are never called unless
1095     // the IndexingType is ArrayWithSlowPutArrayStorage which could have an indexed accessor in a prototype chain.
1096     RELEASE_ASSERT(!shouldUseSlowPut(array-&gt;indexingType()));
1097 
1098     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
1099     for (int32_t i = 0; i &lt; elementCount; ++i) {
1100         array-&gt;pushInline(exec, JSValue::decode(values[i]));
1101         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1102     }
1103     return JSValue::encode(jsNumber(array-&gt;length()));
1104 }
1105 
1106 EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
1107 {
1108     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1109     NativeCallFrameTracer tracer(vm, exec);</span>
1110     auto scope = DECLARE_THROW_SCOPE(vm);
1111 
1112     // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
1113     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1114     // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
1115     // that there is no indexed accessors in this object and its prototype chain.
1116     ASSERT(array-&gt;indexingMode() == ArrayWithDouble);
1117 
1118     double* values = static_cast&lt;double*&gt;(buffer);
1119     for (int32_t i = 0; i &lt; elementCount; ++i) {
1120         array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, values[i]));
1121         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1122     }
1123     return JSValue::encode(jsNumber(array-&gt;length()));
1124 }
1125 
1126 EncodedJSValue JIT_OPERATION operationArrayPop(ExecState* exec, JSArray* array)
1127 {
<span class="line-modified">1128     VM&amp; vm = exec-&gt;vm();</span>
1129     NativeCallFrameTracer tracer(vm, exec);
1130 
1131     return JSValue::encode(array-&gt;pop(exec));
1132 }
1133 
1134 EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(ExecState* exec, JSArray* array)
1135 {
<span class="line-modified">1136     VM&amp; vm = exec-&gt;vm();</span>
1137     NativeCallFrameTracer tracer(vm, exec);
1138 
1139     array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
1140 
1141     return JSValue::encode(array-&gt;pop(exec));
1142 }
1143 
1144 EncodedJSValue JIT_OPERATION operationRegExpExecString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
1145 {
1146     SuperSamplerScope superSamplerScope(false);
1147 
1148     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1149     NativeCallFrameTracer tracer(vm, exec);</span>
1150 
1151     return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
1152 }
1153 
1154 EncodedJSValue JIT_OPERATION operationRegExpExec(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
1155 {
1156     SuperSamplerScope superSamplerScope(false);
1157 
1158     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1159     NativeCallFrameTracer tracer(vm, exec);</span>
1160     auto scope = DECLARE_THROW_SCOPE(vm);
1161 
1162     JSValue argument = JSValue::decode(encodedArgument);
1163 
1164     JSString* input = argument.toStringOrNull(exec);
1165     EXCEPTION_ASSERT(!!scope.exception() == !input);
1166     if (!input)
1167         return encodedJSValue();
1168     RELEASE_AND_RETURN(scope, JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, input)));
1169 }
1170 
1171 EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
1172 {
1173     SuperSamplerScope superSamplerScope(false);
1174 
1175     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1176     NativeCallFrameTracer tracer(vm, exec);</span>
1177     auto scope = DECLARE_THROW_SCOPE(vm);
1178 
1179     JSValue base = JSValue::decode(encodedBase);
1180     JSValue argument = JSValue::decode(encodedArgument);
1181 
1182     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1183     if (UNLIKELY(!regexp))
1184         return throwVMTypeError(exec, scope);
1185 
1186     JSString* input = argument.toStringOrNull(exec);
1187     EXCEPTION_ASSERT(!!scope.exception() == !input);
1188     if (!input)
1189         return JSValue::encode(jsUndefined());
1190     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(exec, globalObject, input)));
1191 }
1192 
1193 EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
1194 {
1195     SuperSamplerScope superSamplerScope(false);
1196 
1197     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1198     NativeCallFrameTracer tracer(vm, exec);</span>
1199 
1200     auto scope = DECLARE_THROW_SCOPE(vm);
1201 
1202     String input = string-&gt;value(exec);
1203     RETURN_IF_EXCEPTION(scope, { });
1204 
1205     unsigned lastIndex = 0;
1206     MatchResult result;
1207     JSArray* array = createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
1208     if (!array) {
1209         ASSERT(!scope.exception());
1210         return JSValue::encode(jsNull());
1211     }
1212 
1213     RETURN_IF_EXCEPTION(scope, { });
1214     globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
1215     return JSValue::encode(array);
1216 }
1217 
1218 EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
1219 {
1220     SuperSamplerScope superSamplerScope(false);
1221 
1222     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1223     NativeCallFrameTracer tracer(vm, exec);</span>
1224 
1225     if (!regExpObject-&gt;regExp()-&gt;global())
1226         return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
1227     return JSValue::encode(regExpObject-&gt;matchGlobal(exec, globalObject, argument));
1228 }
1229 
1230 EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
1231 {
1232     SuperSamplerScope superSamplerScope(false);
1233 
1234     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1235     NativeCallFrameTracer tracer(vm, exec);</span>
1236 
1237     auto scope = DECLARE_THROW_SCOPE(vm);
1238 
1239     ASSERT(regExp-&gt;global());
1240 
1241     String s = string-&gt;value(exec);
1242     RETURN_IF_EXCEPTION(scope, { });
1243 
1244     if (regExp-&gt;unicode()) {
1245         unsigned stringLength = s.length();
1246         RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
1247             vm, exec, string, s, globalObject, regExp,
1248             [&amp;] (size_t end) -&gt; size_t {
1249                 return advanceStringUnicode(s, stringLength, end);
1250             })));
1251     }
1252 
1253     RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
1254         vm, exec, string, s, globalObject, regExp,
1255         [&amp;] (size_t end) -&gt; size_t {
1256             return end + 1;
1257         })));
1258 }
1259 
1260 EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(ExecState* exec, EncodedJSValue value)
1261 {
1262     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1263     NativeCallFrameTracer tracer(vm, exec);</span>
1264 
1265     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
1266         // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1267         return parseIntResult(parseInt(view, 0));
1268     });
1269 }
1270 
1271 EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(ExecState* exec, JSString* string)
1272 {
1273     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1274     NativeCallFrameTracer tracer(vm, exec);</span>
1275     auto scope = DECLARE_THROW_SCOPE(vm);
1276 
1277     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
1278     RETURN_IF_EXCEPTION(scope, { });
1279 
1280     // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1281     return parseIntResult(parseInt(viewWithString.view, 0));
1282 }
1283 
1284 EncodedJSValue JIT_OPERATION operationParseIntString(ExecState* exec, JSString* string, int32_t radix)
1285 {
1286     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1287     NativeCallFrameTracer tracer(vm, exec);</span>
1288     auto scope = DECLARE_THROW_SCOPE(vm);
1289 
1290     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
1291     RETURN_IF_EXCEPTION(scope, { });
1292 
1293     return parseIntResult(parseInt(viewWithString.view, radix));
1294 }
1295 
1296 EncodedJSValue JIT_OPERATION operationParseIntGeneric(ExecState* exec, EncodedJSValue value, int32_t radix)
1297 {
1298     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1299     NativeCallFrameTracer tracer(vm, exec);</span>
1300 
1301     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
1302         return parseIntResult(parseInt(view, radix));
1303     });
1304 }
1305 
1306 size_t JIT_OPERATION operationRegExpTestString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)
1307 {
1308     SuperSamplerScope superSamplerScope(false);
1309 
1310     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1311     NativeCallFrameTracer tracer(vm, exec);</span>
1312 
1313     return regExpObject-&gt;testInline(exec, globalObject, input);
1314 }
1315 
1316 size_t JIT_OPERATION operationRegExpTest(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
1317 {
1318     SuperSamplerScope superSamplerScope(false);
1319 
1320     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1321     NativeCallFrameTracer tracer(vm, exec);</span>
1322 
1323     JSValue argument = JSValue::decode(encodedArgument);
1324 
1325     JSString* input = argument.toStringOrNull(exec);
1326     if (!input)
1327         return false;
1328     return regExpObject-&gt;testInline(exec, globalObject, input);
1329 }
1330 
1331 size_t JIT_OPERATION operationRegExpTestGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
1332 {
1333     SuperSamplerScope superSamplerScope(false);
1334 
1335     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1336     NativeCallFrameTracer tracer(vm, exec);</span>
1337     auto scope = DECLARE_THROW_SCOPE(vm);
1338 
1339     JSValue base = JSValue::decode(encodedBase);
1340     JSValue argument = JSValue::decode(encodedArgument);
1341 
1342     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1343     if (UNLIKELY(!regexp)) {
1344         throwTypeError(exec, scope);
1345         return false;
1346     }
1347 
1348     JSString* input = argument.toStringOrNull(exec);
1349     EXCEPTION_ASSERT(!!scope.exception() == !input);
1350     if (!input)
1351         return false;
1352     RELEASE_AND_RETURN(scope, regexp-&gt;test(exec, globalObject, input));
1353 }
1354 
1355 JSCell* JIT_OPERATION operationSubBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1356 {
<span class="line-modified">1357     VM&amp; vm = exec-&gt;vm();</span>
1358     NativeCallFrameTracer tracer(vm, exec);
1359 
1360     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1361     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1362 
1363     return JSBigInt::sub(exec, leftOperand, rightOperand);
1364 }
1365 
<span class="line-added">1366 JSCell* JIT_OPERATION operationBitNotBigInt(ExecState* exec, JSCell* op1)</span>
<span class="line-added">1367 {</span>
<span class="line-added">1368     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1369     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">1370 </span>
<span class="line-added">1371     JSBigInt* operand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">1372 </span>
<span class="line-added">1373     return JSBigInt::bitwiseNot(exec, operand);</span>
<span class="line-added">1374 }</span>
<span class="line-added">1375 </span>
1376 JSCell* JIT_OPERATION operationMulBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1377 {
<span class="line-modified">1378     VM&amp; vm = exec-&gt;vm();</span>
1379     NativeCallFrameTracer tracer(vm, exec);
1380 
1381     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1382     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1383 
1384     return JSBigInt::multiply(exec, leftOperand, rightOperand);
1385 }
1386 
<span class="line-added">1387 JSCell* JIT_OPERATION operationModBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
<span class="line-added">1388 {</span>
<span class="line-added">1389     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1390     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">1391 </span>
<span class="line-added">1392     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">1393     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
<span class="line-added">1394 </span>
<span class="line-added">1395     return JSBigInt::remainder(exec, leftOperand, rightOperand);</span>
<span class="line-added">1396 }</span>
<span class="line-added">1397 </span>
1398 JSCell* JIT_OPERATION operationDivBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1399 {
<span class="line-modified">1400     VM&amp; vm = exec-&gt;vm();</span>
1401     NativeCallFrameTracer tracer(vm, exec);
1402 
1403     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1404     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1405 
1406     return JSBigInt::divide(exec, leftOperand, rightOperand);
1407 }
1408 
<span class="line-added">1409 JSCell* JIT_OPERATION operationPowBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
<span class="line-added">1410 {</span>
<span class="line-added">1411     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1412     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">1413 </span>
<span class="line-added">1414     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">1415     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
<span class="line-added">1416 </span>
<span class="line-added">1417     return JSBigInt::exponentiate(exec, leftOperand, rightOperand);</span>
<span class="line-added">1418 }</span>
<span class="line-added">1419 </span>
1420 JSCell* JIT_OPERATION operationBitAndBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1421 {
<span class="line-modified">1422     VM&amp; vm = exec-&gt;vm();</span>
1423     NativeCallFrameTracer tracer(vm, exec);
1424 
1425     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1426     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1427 
1428     return JSBigInt::bitwiseAnd(exec, leftOperand, rightOperand);
1429 }
1430 
<span class="line-added">1431 JSCell* JIT_OPERATION operationBitLShiftBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
<span class="line-added">1432 {</span>
<span class="line-added">1433     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1434     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">1435 </span>
<span class="line-added">1436     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">1437     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
<span class="line-added">1438 </span>
<span class="line-added">1439     return JSBigInt::leftShift(exec, leftOperand, rightOperand);</span>
<span class="line-added">1440 }</span>
<span class="line-added">1441 </span>
1442 JSCell* JIT_OPERATION operationAddBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1443 {
<span class="line-modified">1444     VM&amp; vm = exec-&gt;vm();</span>
1445     NativeCallFrameTracer tracer(vm, exec);
1446 
1447     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1448     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1449 
1450     return JSBigInt::add(exec, leftOperand, rightOperand);
1451 }
1452 
1453 JSCell* JIT_OPERATION operationBitOrBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1454 {
<span class="line-modified">1455     VM&amp; vm = exec-&gt;vm();</span>
1456     NativeCallFrameTracer tracer(vm, exec);
1457 
1458     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1459     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1460 
1461     return JSBigInt::bitwiseOr(exec, leftOperand, rightOperand);
1462 }
1463 
1464 JSCell* JIT_OPERATION operationBitXorBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
1465 {
<span class="line-modified">1466     VM&amp; vm = exec-&gt;vm();</span>
1467     NativeCallFrameTracer tracer(vm, exec);
1468 
1469     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1470     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1471 
1472     return JSBigInt::bitwiseXor(exec, leftOperand, rightOperand);
1473 }
1474 
1475 size_t JIT_OPERATION operationCompareStrictEqCell(ExecState* exec, JSCell* op1, JSCell* op2)
1476 {
<span class="line-modified">1477     VM&amp; vm = exec-&gt;vm();</span>
1478     NativeCallFrameTracer tracer(vm, exec);
1479 
1480     return JSValue::strictEqualSlowCaseInline(exec, op1, op2);
1481 }
1482 
1483 size_t JIT_OPERATION operationSameValue(ExecState* exec, EncodedJSValue arg1, EncodedJSValue arg2)
1484 {
1485     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1486     NativeCallFrameTracer tracer(vm, exec);</span>
1487 
1488     return sameValue(exec, JSValue::decode(arg1), JSValue::decode(arg2));
1489 }
1490 
1491 EncodedJSValue JIT_OPERATION operationToPrimitive(ExecState* exec, EncodedJSValue value)
1492 {
<span class="line-modified">1493     VM&amp; vm = exec-&gt;vm();</span>
1494     NativeCallFrameTracer tracer(vm, exec);
1495 
1496     return JSValue::encode(JSValue::decode(value).toPrimitive(exec));
1497 }
1498 
1499 EncodedJSValue JIT_OPERATION operationToNumber(ExecState* exec, EncodedJSValue value)
1500 {
<span class="line-modified">1501     VM&amp; vm = exec-&gt;vm();</span>
1502     NativeCallFrameTracer tracer(vm, exec);
1503 
1504     return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(exec)));
1505 }
1506 
1507 EncodedJSValue JIT_OPERATION operationGetByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)
1508 {
1509     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1510     NativeCallFrameTracer tracer(vm, exec);</span>
1511     auto scope = DECLARE_THROW_SCOPE(vm);
1512 
1513     JSValue baseValue = JSValue::decode(encodedBase);
1514     JSValue thisVal = JSValue::decode(encodedThis);
1515     JSValue subscript = JSValue::decode(encodedSubscript);
1516 
1517     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1518         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1519         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1520             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified">1521             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">1522             if (existingAtomString) {</span>
<span class="line-added">1523                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
1524                     return JSValue::encode(result);
1525             }
1526         }
1527     }
1528 
1529     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1530     if (subscript.isUInt32()) {
1531         uint32_t i = subscript.asUInt32();
1532         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1533             return JSValue::encode(asString(baseValue)-&gt;getIndex(exec, i));
1534 
1535         RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, i, slot)));
1536     }
1537 
1538     baseValue.requireObjectCoercible(exec);
1539     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1540 
1541     auto property = subscript.toPropertyKey(exec);
1542     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1543     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, property, slot)));
1544 }
1545 
1546 void JIT_OPERATION operationPutByIdWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
1547 {
1548     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1549     NativeCallFrameTracer tracer(vm, exec);</span>
1550 
<span class="line-modified">1551     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
1552 }
1553 
1554 void JIT_OPERATION operationPutByIdWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
1555 {
1556     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1557     NativeCallFrameTracer tracer(vm, exec);</span>
1558 
<span class="line-modified">1559     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
1560 }
1561 
1562 void JIT_OPERATION operationPutByValWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
1563 {
1564     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1565     NativeCallFrameTracer tracer(vm, exec);</span>
1566     auto scope = DECLARE_THROW_SCOPE(vm);
1567 
1568     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
1569     RETURN_IF_EXCEPTION(scope, void());
1570     scope.release();
1571     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, property);
1572 }
1573 
1574 void JIT_OPERATION operationPutByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
1575 {
1576     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1577     NativeCallFrameTracer tracer(vm, exec);</span>
1578     auto scope = DECLARE_THROW_SCOPE(vm);
1579 
1580     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
1581     RETURN_IF_EXCEPTION(scope, void());
1582     scope.release();
1583     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, property);
1584 }
1585 
1586 ALWAYS_INLINE static void defineDataProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSValue value, int32_t attributes)
1587 {
1588     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes));
1589     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1590     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
1591         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);
1592     else
1593         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1594 }
1595 
1596 void JIT_OPERATION operationDefineDataProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)
1597 {
1598     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1599     NativeCallFrameTracer tracer(vm, exec);</span>
1600     auto scope = DECLARE_THROW_SCOPE(vm);
1601 
1602     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
1603     RETURN_IF_EXCEPTION(scope, void());
1604     scope.release();
1605     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);
1606 }
1607 
1608 void JIT_OPERATION operationDefineDataPropertyString(ExecState* exec, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)
1609 {
1610     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1611     NativeCallFrameTracer tracer(vm, exec);</span>
1612     auto scope = DECLARE_THROW_SCOPE(vm);
1613 
1614     Identifier propertyName = property-&gt;toIdentifier(exec);
1615     RETURN_IF_EXCEPTION(scope, void());
1616     scope.release();
1617     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);
1618 }
1619 
1620 void JIT_OPERATION operationDefineDataPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)
1621 {
1622     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1623     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1624     defineDataProperty(exec, vm, base, Identifier::fromUid(vm, property), JSValue::decode(encodedValue), attributes);</span>
1625 }
1626 
1627 void JIT_OPERATION operationDefineDataPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)
1628 {
1629     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1630     NativeCallFrameTracer tracer(vm, exec);</span>
1631     defineDataProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);
1632 }
1633 
1634 ALWAYS_INLINE static void defineAccessorProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)
1635 {
1636     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes));
1637     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1638     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
1639         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);
1640     else
1641         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1642 }
1643 
1644 void JIT_OPERATION operationDefineAccessorProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)
1645 {
1646     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1647     NativeCallFrameTracer tracer(vm, exec);</span>
1648     auto scope = DECLARE_THROW_SCOPE(vm);
1649 
1650     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
1651     RETURN_IF_EXCEPTION(scope, void());
1652     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
1653 }
1654 
1655 void JIT_OPERATION operationDefineAccessorPropertyString(ExecState* exec, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)
1656 {
1657     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1658     NativeCallFrameTracer tracer(vm, exec);</span>
1659     auto scope = DECLARE_THROW_SCOPE(vm);
1660 
1661     Identifier propertyName = property-&gt;toIdentifier(exec);
1662     RETURN_IF_EXCEPTION(scope, void());
1663     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
1664 }
1665 
1666 void JIT_OPERATION operationDefineAccessorPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)
1667 {
1668     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1669     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1670     defineAccessorProperty(exec, vm, base, Identifier::fromUid(vm, property), getter, setter, attributes);</span>
1671 }
1672 
1673 void JIT_OPERATION operationDefineAccessorPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)
1674 {
1675     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1676     NativeCallFrameTracer tracer(vm, exec);</span>
1677     defineAccessorProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);
1678 }
1679 
1680 char* JIT_OPERATION operationNewArray(ExecState* exec, Structure* arrayStructure, void* buffer, size_t size)
1681 {
<span class="line-modified">1682     VM&amp; vm = exec-&gt;vm();</span>
1683     NativeCallFrameTracer tracer(vm, exec);
1684 
1685     return bitwise_cast&lt;char*&gt;(constructArray(exec, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));
1686 }
1687 
1688 char* JIT_OPERATION operationNewEmptyArray(ExecState* exec, Structure* arrayStructure)
1689 {
<span class="line-modified">1690     VM&amp; vm = exec-&gt;vm();</span>
1691     NativeCallFrameTracer tracer(vm, exec);
1692 
<span class="line-modified">1693     return bitwise_cast&lt;char*&gt;(JSArray::create(vm, arrayStructure));</span>
1694 }
1695 
1696 char* JIT_OPERATION operationNewArrayWithSize(ExecState* exec, Structure* arrayStructure, int32_t size, Butterfly* butterfly)
1697 {
1698     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1699     NativeCallFrameTracer tracer(vm, exec);</span>
1700     auto scope = DECLARE_THROW_SCOPE(vm);
1701 
1702     if (UNLIKELY(size &lt; 0))
1703         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
1704 
1705     JSArray* result;
1706     if (butterfly)
1707         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1708     else
1709         result = JSArray::create(vm, arrayStructure, size);
1710     return bitwise_cast&lt;char*&gt;(result);
1711 }
1712 
1713 char* JIT_OPERATION operationNewArrayWithSizeAndHint(ExecState* exec, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)
1714 {
1715     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1716     NativeCallFrameTracer tracer(vm, exec);</span>
1717     auto scope = DECLARE_THROW_SCOPE(vm);
1718 
1719     if (UNLIKELY(size &lt; 0))
1720         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
1721 
1722     JSArray* result;
1723     if (butterfly)
1724         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1725     else {
1726         result = JSArray::tryCreate(vm, arrayStructure, size, vectorLengthHint);
1727         RELEASE_ASSERT(result);
1728     }
1729     return bitwise_cast&lt;char*&gt;(result);
1730 }
1731 
1732 JSCell* JIT_OPERATION operationNewArrayBuffer(ExecState* exec, Structure* arrayStructure, JSCell* immutableButterflyCell)
1733 {
1734     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1735     NativeCallFrameTracer tracer(vm, exec);</span>
1736     ASSERT(!arrayStructure-&gt;outOfLineCapacity());
1737     auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
1738     ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
1739     auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
1740     ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
1741     ASSERT(result-&gt;structure(vm) == arrayStructure);
1742     return result;
1743 }
1744 
1745 char* JIT_OPERATION operationNewInt8ArrayWithSize(
1746     ExecState* exec, Structure* structure, int32_t length, char* vector)
1747 {
1748     return newTypedArrayWithSize&lt;JSInt8Array&gt;(exec, structure, length, vector);
1749 }
1750 
1751 char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
1752     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1753 {
1754     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1755     NativeCallFrameTracer tracer(vm, exec);</span>
1756     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1757 }
1758 
1759 char* JIT_OPERATION operationNewInt16ArrayWithSize(
1760     ExecState* exec, Structure* structure, int32_t length, char* vector)
1761 {
1762     return newTypedArrayWithSize&lt;JSInt16Array&gt;(exec, structure, length, vector);
1763 }
1764 
1765 char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
1766     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1767 {
1768     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1769     NativeCallFrameTracer tracer(vm, exec);</span>
1770     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1771 }
1772 
1773 char* JIT_OPERATION operationNewInt32ArrayWithSize(
1774     ExecState* exec, Structure* structure, int32_t length, char* vector)
1775 {
1776     return newTypedArrayWithSize&lt;JSInt32Array&gt;(exec, structure, length, vector);
1777 }
1778 
1779 char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
1780     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1781 {
1782     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1783     NativeCallFrameTracer tracer(vm, exec);</span>
1784     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1785 }
1786 
1787 char* JIT_OPERATION operationNewUint8ArrayWithSize(
1788     ExecState* exec, Structure* structure, int32_t length, char* vector)
1789 {
1790     return newTypedArrayWithSize&lt;JSUint8Array&gt;(exec, structure, length, vector);
1791 }
1792 
1793 char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
1794     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1795 {
1796     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1797     NativeCallFrameTracer tracer(vm, exec);</span>
1798     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1799 }
1800 
1801 char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
1802     ExecState* exec, Structure* structure, int32_t length, char* vector)
1803 {
1804     return newTypedArrayWithSize&lt;JSUint8ClampedArray&gt;(exec, structure, length, vector);
1805 }
1806 
1807 char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
1808     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1809 {
1810     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1811     NativeCallFrameTracer tracer(vm, exec);</span>
1812     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1813 }
1814 
1815 char* JIT_OPERATION operationNewUint16ArrayWithSize(
1816     ExecState* exec, Structure* structure, int32_t length, char* vector)
1817 {
1818     return newTypedArrayWithSize&lt;JSUint16Array&gt;(exec, structure, length, vector);
1819 }
1820 
1821 char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
1822     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1823 {
1824     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1825     NativeCallFrameTracer tracer(vm, exec);</span>
1826     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1827 }
1828 
1829 char* JIT_OPERATION operationNewUint32ArrayWithSize(
1830     ExecState* exec, Structure* structure, int32_t length, char* vector)
1831 {
1832     return newTypedArrayWithSize&lt;JSUint32Array&gt;(exec, structure, length, vector);
1833 }
1834 
1835 char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
1836     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1837 {
1838     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1839     NativeCallFrameTracer tracer(vm, exec);</span>
1840     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1841 }
1842 
1843 char* JIT_OPERATION operationNewFloat32ArrayWithSize(
1844     ExecState* exec, Structure* structure, int32_t length, char* vector)
1845 {
1846     return newTypedArrayWithSize&lt;JSFloat32Array&gt;(exec, structure, length, vector);
1847 }
1848 
1849 char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
1850     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1851 {
1852     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1853     NativeCallFrameTracer tracer(vm, exec);</span>
1854     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1855 }
1856 
1857 char* JIT_OPERATION operationNewFloat64ArrayWithSize(
1858     ExecState* exec, Structure* structure, int32_t length, char* vector)
1859 {
1860     return newTypedArrayWithSize&lt;JSFloat64Array&gt;(exec, structure, length, vector);
1861 }
1862 
1863 char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
1864     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
1865 {
1866     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1867     NativeCallFrameTracer tracer(vm, exec);</span>
1868     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
1869 }
1870 
1871 JSCell* JIT_OPERATION operationCreateActivationDirect(ExecState* exec, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)
1872 {
<span class="line-added">1873     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1874     NativeCallFrameTracer tracer(vm, exec);</span>
1875     JSValue initialValue = JSValue::decode(initialValueEncoded);
1876     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());


1877     return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
1878 }
1879 
1880 JSCell* JIT_OPERATION operationCreateDirectArguments(ExecState* exec, Structure* structure, uint32_t length, uint32_t minCapacity)
1881 {
1882     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1883     NativeCallFrameTracer tracer(vm, exec);</span>
1884     DirectArguments* result = DirectArguments::create(
1885         vm, structure, length, std::max(length, minCapacity));
1886     // The caller will store to this object without barriers. Most likely, at this point, this is
1887     // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
1888     // since the GC should be allowed to do crazy (like pretenuring, for example).
1889     vm.heap.writeBarrier(result);
1890     return result;
1891 }
1892 
1893 JSCell* JIT_OPERATION operationCreateScopedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)
1894 {
1895     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1896     NativeCallFrameTracer tracer(vm, exec);</span>
1897 
1898     // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
1899     // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
1900     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
1901 
1902     return ScopedArguments::createByCopyingFrom(
1903         vm, structure, argumentStart, length, callee, table, scope);
1904 }
1905 
1906 JSCell* JIT_OPERATION operationCreateClonedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)
1907 {
1908     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1909     NativeCallFrameTracer tracer(vm, exec);</span>
1910     return ClonedArguments::createByCopyingFrom(
1911         exec, structure, argumentStart, length, callee);
1912 }
1913 
1914 JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
1915 {
1916     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1917     NativeCallFrameTracer tracer(vm, exec);</span>
1918 
1919     DeferGCForAWhile deferGC(vm.heap);
1920 
1921     CodeBlock* codeBlock;
1922     if (inlineCallFrame)
1923         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
1924     else
1925         codeBlock = exec-&gt;codeBlock();
1926 
1927     unsigned length = argumentCount - 1;
1928     unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
1929     DirectArguments* result = DirectArguments::create(
1930         vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
1931 
1932     result-&gt;setCallee(vm, callee);
1933 
1934     Register* arguments =
1935         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +
1936         CallFrame::argumentOffset(0);
1937     for (unsigned i = length; i--;)
1938         result-&gt;setIndexQuickly(vm, i, arguments[i].jsValue());
1939 
1940     return result;
1941 }
1942 
1943 JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
1944 {
1945     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1946     NativeCallFrameTracer tracer(vm, exec);</span>
1947 
1948     DeferGCForAWhile deferGC(vm.heap);
1949 
1950     CodeBlock* codeBlock;
1951     if (inlineCallFrame)
1952         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
1953     else
1954         codeBlock = exec-&gt;codeBlock();
1955 
1956     unsigned length = argumentCount - 1;
1957     ClonedArguments* result = ClonedArguments::createEmpty(
1958         vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);
1959 
1960     Register* arguments =
1961         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +
1962         CallFrame::argumentOffset(0);
1963     for (unsigned i = length; i--;)
1964         result-&gt;putDirectIndex(exec, i, arguments[i].jsValue());
1965 
1966 
1967     return result;
1968 }
1969 
1970 JSCell* JIT_OPERATION operationCreateRest(ExecState* exec, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)
1971 {
<span class="line-modified">1972     VM&amp; vm = exec-&gt;vm();</span>
1973     NativeCallFrameTracer tracer(vm, exec);
1974 
1975     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1976     Structure* structure = globalObject-&gt;restParameterStructure();
1977     static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
1978     JSValue* argumentsToCopyRegion = bitwise_cast&lt;JSValue*&gt;(argumentStart) + numberOfParamsToSkip;
1979     return constructArray(exec, structure, argumentsToCopyRegion, arraySize);
1980 }
1981 
1982 size_t JIT_OPERATION operationObjectIsObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
1983 {
1984     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1985     NativeCallFrameTracer tracer(vm, exec);</span>
1986 
1987     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
1988 
1989     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
1990         return false;
1991     if (object-&gt;isFunction(vm))
1992         return false;
1993     return true;
1994 }
1995 
1996 size_t JIT_OPERATION operationObjectIsFunction(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
1997 {
1998     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1999     NativeCallFrameTracer tracer(vm, exec);</span>
2000 
2001     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2002 
2003     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2004         return false;
2005     if (object-&gt;isFunction(vm))
2006         return true;
2007     return false;
2008 }
2009 
2010 JSCell* JIT_OPERATION operationTypeOfObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
2011 {
2012     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2013     NativeCallFrameTracer tracer(vm, exec);</span>
2014 
2015     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2016 
2017     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2018         return vm.smallStrings.undefinedString();
2019     if (object-&gt;isFunction(vm))
2020         return vm.smallStrings.functionString();
2021     return vm.smallStrings.objectString();
2022 }
2023 
2024 int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
2025 {
2026     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2027     NativeCallFrameTracer tracer(vm, exec);</span>
2028 
2029     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2030 
2031     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2032         return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
2033     if (object-&gt;isFunction(vm))
2034         return static_cast&lt;int32_t&gt;(TypeofType::Function);
2035     return static_cast&lt;int32_t&gt;(TypeofType::Object);
2036 }
2037 
2038 char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(ExecState* exec)
2039 {
2040     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2041     NativeCallFrameTracer tracer(vm, exec);</span>
2042 
2043     return reinterpret_cast&lt;char*&gt;(
2044         Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
2045 }
2046 
2047 char* JIT_OPERATION operationAllocateSimplePropertyStorage(ExecState* exec, size_t newSize)
2048 {
2049     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2050     NativeCallFrameTracer tracer(vm, exec);</span>
2051 
2052     return reinterpret_cast&lt;char*&gt;(
2053         Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
2054 }
2055 
2056 char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)
2057 {
2058     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2059     NativeCallFrameTracer tracer(vm, exec);</span>
2060 
2061     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2062     return reinterpret_cast&lt;char*&gt;(
2063         object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
2064 }
2065 
2066 char* JIT_OPERATION operationAllocateComplexPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)
2067 {
2068     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2069     NativeCallFrameTracer tracer(vm, exec);</span>
2070 
2071     return reinterpret_cast&lt;char*&gt;(
2072         object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
2073 }
2074 
2075 char* JIT_OPERATION operationEnsureInt32(ExecState* exec, JSCell* cell)
2076 {
2077     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2078     NativeCallFrameTracer tracer(vm, exec);</span>
2079 
2080     if (!cell-&gt;isObject())
2081         return 0;
2082 
2083     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
2084     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasInt32(cell-&gt;indexingMode())) || !result);
2085     return result;
2086 }
2087 
2088 char* JIT_OPERATION operationEnsureDouble(ExecState* exec, JSCell* cell)
2089 {
2090     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2091     NativeCallFrameTracer tracer(vm, exec);</span>
2092 
2093     if (!cell-&gt;isObject())
2094         return 0;
2095 
2096     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
2097     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasDouble(cell-&gt;indexingMode())) || !result);
2098     return result;
2099 }
2100 
2101 char* JIT_OPERATION operationEnsureContiguous(ExecState* exec, JSCell* cell)
2102 {
2103     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2104     NativeCallFrameTracer tracer(vm, exec);</span>
2105 
2106     if (!cell-&gt;isObject())
2107         return 0;
2108 
2109     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
2110     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasContiguous(cell-&gt;indexingMode())) || !result);
2111     return result;
2112 }
2113 
2114 char* JIT_OPERATION operationEnsureArrayStorage(ExecState* exec, JSCell* cell)
2115 {
2116     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2117     NativeCallFrameTracer tracer(vm, exec);</span>
2118 
2119     if (!cell-&gt;isObject())
2120         return 0;
2121 
2122     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
2123     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
2124     return result;
2125 }
2126 
<span class="line-modified">2127 EncodedJSValue JIT_OPERATION operationHasGenericProperty(ExecState* exec, EncodedJSValue encodedBaseValue, JSCell* property)</span>
2128 {
2129     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2130     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">2131     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2132 </span>
2133     JSValue baseValue = JSValue::decode(encodedBaseValue);
2134     if (baseValue.isUndefinedOrNull())
2135         return JSValue::encode(jsBoolean(false));
2136 
2137     JSObject* base = baseValue.toObject(exec);
<span class="line-added">2138     ASSERT(!scope.exception() || !base);</span>
2139     if (!base)
2140         return JSValue::encode(JSValue());
<span class="line-modified">2141     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
<span class="line-added">2142     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2143     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty))));</span>
2144 }
2145 
2146 size_t JIT_OPERATION operationHasIndexedPropertyByInt(ExecState* exec, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)
2147 {
2148     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2149     NativeCallFrameTracer tracer(vm, exec);</span>
2150     JSObject* object = baseCell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
2151     if (UNLIKELY(subscript &lt; 0)) {
2152         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">2153         return object-&gt;hasPropertyGeneric(exec, Identifier::from(vm, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
2154     }
2155     return object-&gt;hasPropertyGeneric(exec, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));
2156 }
2157 
2158 JSCell* JIT_OPERATION operationGetPropertyEnumerator(ExecState* exec, EncodedJSValue encodedBase)
2159 {
2160     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2161     NativeCallFrameTracer tracer(vm, exec);</span>
2162     auto scope = DECLARE_THROW_SCOPE(vm);
2163 
2164     JSValue base = JSValue::decode(encodedBase);
2165     if (base.isUndefinedOrNull())
<span class="line-modified">2166         return vm.emptyPropertyNameEnumerator();</span>
2167 
2168     JSObject* baseObject = base.toObject(exec);
2169     RETURN_IF_EXCEPTION(scope, { });
2170 
2171     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, baseObject));
2172 }
2173 
2174 JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(ExecState* exec, JSCell* cell)
2175 {
2176     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2177     NativeCallFrameTracer tracer(vm, exec);</span>
2178     auto scope = DECLARE_THROW_SCOPE(vm);
2179 
2180     JSObject* base = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
2181     RETURN_IF_EXCEPTION(scope, { });
2182 
2183     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, base));
2184 }
2185 
2186 JSCell* JIT_OPERATION operationToIndexString(ExecState* exec, int32_t index)
2187 {
2188     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2189     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2190     return jsString(vm, Identifier::from(vm, index).string());</span>
2191 }
2192 
2193 JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(ExecState* exec, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)
2194 {
2195     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2196     NativeCallFrameTracer tracer(vm, exec);</span>
2197 
2198     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
2199     ASSERT(regexp-&gt;isValid());
2200     return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));
2201 }
2202 
2203 StringImpl* JIT_OPERATION operationResolveRope(ExecState* exec, JSString* string)
2204 {
2205     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2206     NativeCallFrameTracer tracer(vm, exec);</span>
2207 
2208     return string-&gt;value(exec).impl();
2209 }
2210 
2211 JSString* JIT_OPERATION operationStringValueOf(ExecState* exec, EncodedJSValue encodedArgument)
2212 {
2213     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2214     NativeCallFrameTracer tracer(vm, exec);</span>
2215     auto scope = DECLARE_THROW_SCOPE(vm);
2216 
2217     JSValue argument = JSValue::decode(encodedArgument);
2218 
2219     if (argument.isString())
2220         return asString(argument);
2221 
2222     if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, argument))
2223         return stringObject-&gt;internalValue();
2224 
2225     throwVMTypeError(exec, scope);
2226     return nullptr;
2227 }
2228 
2229 JSCell* JIT_OPERATION operationStringSubstr(ExecState* exec, JSCell* cell, int32_t from, int32_t span)
2230 {
2231     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2232     NativeCallFrameTracer tracer(vm, exec);</span>

2233 
<span class="line-modified">2234     return jsSubstring(vm, exec, jsCast&lt;JSString*&gt;(cell), from, span);</span>


2235 }
2236 
2237 JSCell* JIT_OPERATION operationStringSlice(ExecState* exec, JSCell* cell, int32_t start, int32_t end)
2238 {
2239     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2240     NativeCallFrameTracer tracer(vm, exec);</span>

2241 
<span class="line-modified">2242     JSString* string = asString(cell);</span>

2243     static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">2244     return stringSlice(exec, vm, string, string-&gt;length(), start, end);</span>


2245 }
2246 
2247 JSString* JIT_OPERATION operationToLowerCase(ExecState* exec, JSString* string, uint32_t failingIndex)
2248 {
2249     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2250     NativeCallFrameTracer tracer(vm, exec);</span>
2251 
2252     auto scope = DECLARE_THROW_SCOPE(vm);
2253 
2254     const String&amp; inputString = string-&gt;value(exec);
2255     RETURN_IF_EXCEPTION(scope, nullptr);
2256     if (!inputString.length())
2257         return vm.smallStrings.emptyString();
2258 
2259     String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
2260     if (lowercasedString.impl() == inputString.impl())
2261         return string;
<span class="line-modified">2262     RELEASE_AND_RETURN(scope, jsString(vm, lowercasedString));</span>
2263 }
2264 
2265 char* JIT_OPERATION operationInt32ToString(ExecState* exec, int32_t value, int32_t radix)
2266 {
2267     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2268     NativeCallFrameTracer tracer(vm, exec);</span>
2269 
2270     auto scope = DECLARE_THROW_SCOPE(vm);
2271 
2272     if (radix &lt; 2 || radix &gt; 36) {
2273         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2274         return nullptr;
2275     }
2276 
2277     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2278 }
2279 
2280 char* JIT_OPERATION operationInt52ToString(ExecState* exec, int64_t value, int32_t radix)
2281 {
2282     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2283     NativeCallFrameTracer tracer(vm, exec);</span>
2284 
2285     auto scope = DECLARE_THROW_SCOPE(vm);
2286 
2287     if (radix &lt; 2 || radix &gt; 36) {
2288         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2289         return nullptr;
2290     }
2291 
2292     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2293 }
2294 
2295 char* JIT_OPERATION operationDoubleToString(ExecState* exec, double value, int32_t radix)
2296 {
2297     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2298     NativeCallFrameTracer tracer(vm, exec);</span>
2299 
2300     auto scope = DECLARE_THROW_SCOPE(vm);
2301 
2302     if (radix &lt; 2 || radix &gt; 36) {
2303         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2304         return nullptr;
2305     }
2306 
2307     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2308 }
2309 
2310 char* JIT_OPERATION operationInt32ToStringWithValidRadix(ExecState* exec, int32_t value, int32_t radix)
2311 {
2312     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2313     NativeCallFrameTracer tracer(vm, exec);</span>
2314 
2315     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2316 }
2317 
2318 char* JIT_OPERATION operationInt52ToStringWithValidRadix(ExecState* exec, int64_t value, int32_t radix)
2319 {
2320     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2321     NativeCallFrameTracer tracer(vm, exec);</span>
2322 
2323     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2324 }
2325 
2326 char* JIT_OPERATION operationDoubleToStringWithValidRadix(ExecState* exec, double value, int32_t radix)
2327 {
2328     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2329     NativeCallFrameTracer tracer(vm, exec);</span>
2330 
2331     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2332 }
2333 
2334 JSString* JIT_OPERATION operationSingleCharacterString(ExecState* exec, int32_t character)
2335 {
2336     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2337     NativeCallFrameTracer tracer(vm, exec);</span>
2338 
<span class="line-modified">2339     return jsSingleCharacterString(vm, static_cast&lt;UChar&gt;(character));</span>
2340 }
2341 
2342 Symbol* JIT_OPERATION operationNewSymbol(ExecState* exec)
2343 {
2344     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2345     NativeCallFrameTracer tracer(vm, exec);</span>
2346 
2347     return Symbol::create(vm);
2348 }
2349 
2350 Symbol* JIT_OPERATION operationNewSymbolWithDescription(ExecState* exec, JSString* description)
2351 {
2352     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2353     NativeCallFrameTracer tracer(vm, exec);</span>
2354     auto scope = DECLARE_THROW_SCOPE(vm);
2355 
2356     String string = description-&gt;value(exec);
2357     RETURN_IF_EXCEPTION(scope, nullptr);
2358 
2359     return Symbol::createWithDescription(vm, string);
2360 }
2361 
2362 JSCell* JIT_OPERATION operationNewStringObject(ExecState* exec, JSString* string, Structure* structure)
2363 {
2364     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2365     NativeCallFrameTracer tracer(vm, exec);</span>
2366 
2367     return StringObject::create(vm, structure, string);
2368 }
2369 
2370 JSString* JIT_OPERATION operationToStringOnCell(ExecState* exec, JSCell* cell)
2371 {
2372     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2373     NativeCallFrameTracer tracer(vm, exec);</span>
2374 
2375     return JSValue(cell).toString(exec);
2376 }
2377 
2378 JSString* JIT_OPERATION operationToString(ExecState* exec, EncodedJSValue value)
2379 {
2380     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2381     NativeCallFrameTracer tracer(vm, exec);</span>
2382 
2383     return JSValue::decode(value).toString(exec);
2384 }
2385 
2386 JSString* JIT_OPERATION operationCallStringConstructorOnCell(ExecState* exec, JSCell* cell)
2387 {
2388     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2389     NativeCallFrameTracer tracer(vm, exec);</span>
2390 
2391     return stringConstructor(exec, cell);
2392 }
2393 
2394 JSString* JIT_OPERATION operationCallStringConstructor(ExecState* exec, EncodedJSValue value)
2395 {
2396     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2397     NativeCallFrameTracer tracer(vm, exec);</span>
2398 
2399     return stringConstructor(exec, JSValue::decode(value));
2400 }
2401 
2402 JSString* JIT_OPERATION operationMakeRope2(ExecState* exec, JSString* left, JSString* right)
2403 {
2404     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2405     NativeCallFrameTracer tracer(vm, exec);</span>
2406 
2407     return jsString(exec, left, right);
2408 }
2409 
2410 JSString* JIT_OPERATION operationMakeRope3(ExecState* exec, JSString* a, JSString* b, JSString* c)
2411 {
2412     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2413     NativeCallFrameTracer tracer(vm, exec);</span>
2414 
2415     return jsString(exec, a, b, c);
2416 }
2417 
2418 JSString* JIT_OPERATION operationStrCat2(ExecState* exec, EncodedJSValue a, EncodedJSValue b)
2419 {
2420     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2421     NativeCallFrameTracer tracer(vm, exec);</span>
2422     auto scope = DECLARE_THROW_SCOPE(vm);
2423 
2424     ASSERT(!JSValue::decode(a).isSymbol());
2425     ASSERT(!JSValue::decode(b).isSymbol());
2426     JSString* str1 = JSValue::decode(a).toString(exec);
2427     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
2428     JSString* str2 = JSValue::decode(b).toString(exec);
2429     scope.assertNoException();
2430 
2431     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2));
2432 }
2433 
2434 JSString* JIT_OPERATION operationStrCat3(ExecState* exec, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)
2435 {
2436     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2437     NativeCallFrameTracer tracer(vm, exec);</span>
2438     auto scope = DECLARE_THROW_SCOPE(vm);
2439 
2440     ASSERT(!JSValue::decode(a).isSymbol());
2441     ASSERT(!JSValue::decode(b).isSymbol());
2442     ASSERT(!JSValue::decode(c).isSymbol());
2443     JSString* str1 = JSValue::decode(a).toString(exec);
2444     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
2445     JSString* str2 = JSValue::decode(b).toString(exec);
2446     scope.assertNoException();
2447     JSString* str3 = JSValue::decode(c).toString(exec);
2448     scope.assertNoException();
2449 
2450     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2, str3));
2451 }
2452 
2453 char* JIT_OPERATION operationFindSwitchImmTargetForDouble(
2454     ExecState* exec, EncodedJSValue encodedValue, size_t tableIndex)
2455 {
2456     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2457     NativeCallFrameTracer tracer(vm, exec);</span>

2458     CodeBlock* codeBlock = exec-&gt;codeBlock();
2459     SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
2460     JSValue value = JSValue::decode(encodedValue);
2461     ASSERT(value.isDouble());
2462     double asDouble = value.asDouble();
2463     int32_t asInt32 = static_cast&lt;int32_t&gt;(asDouble);
2464     if (asDouble == asInt32)
2465         return table.ctiForValue(asInt32).executableAddress&lt;char*&gt;();
2466     return table.ctiDefault.executableAddress&lt;char*&gt;();
2467 }
2468 
2469 char* JIT_OPERATION operationSwitchString(ExecState* exec, size_t tableIndex, JSString* string)
2470 {
2471     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2472     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">2473     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2474 </span>
<span class="line-added">2475     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
<span class="line-added">2476 </span>
<span class="line-added">2477     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
2478 
<span class="line-modified">2479     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(strImpl).executableAddress&lt;char*&gt;();</span>
2480 }
2481 
2482 int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(ExecState* exec, size_t tableIndex, JSString* string)
2483 {
2484     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2485     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">2486     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2487 </span>
<span class="line-added">2488     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
2489 
<span class="line-modified">2490     RETURN_IF_EXCEPTION(throwScope, 0);</span>
<span class="line-added">2491 </span>
<span class="line-added">2492     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(strImpl, std::numeric_limits&lt;int32_t&gt;::min());</span>
2493 }
2494 
2495 uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
2496 {
2497     return codePointCompare(a, b) &lt; 0;
2498 }
2499 
2500 uintptr_t JIT_OPERATION operationCompareStringImplLessEq(StringImpl* a, StringImpl* b)
2501 {
2502     return codePointCompare(a, b) &lt;= 0;
2503 }
2504 
2505 uintptr_t JIT_OPERATION operationCompareStringImplGreater(StringImpl* a, StringImpl* b)
2506 {
2507     return codePointCompare(a, b) &gt; 0;
2508 }
2509 
2510 uintptr_t JIT_OPERATION operationCompareStringImplGreaterEq(StringImpl* a, StringImpl* b)
2511 {
2512     return codePointCompare(a, b) &gt;= 0;
2513 }
2514 
2515 uintptr_t JIT_OPERATION operationCompareStringLess(ExecState* exec, JSString* a, JSString* b)
2516 {
2517     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2518     NativeCallFrameTracer tracer(vm, exec);</span>
2519 
2520     return codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
2521 }
2522 
2523 uintptr_t JIT_OPERATION operationCompareStringLessEq(ExecState* exec, JSString* a, JSString* b)
2524 {
2525     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2526     NativeCallFrameTracer tracer(vm, exec);</span>
2527 
2528     return !codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
2529 }
2530 
2531 uintptr_t JIT_OPERATION operationCompareStringGreater(ExecState* exec, JSString* a, JSString* b)
2532 {
2533     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2534     NativeCallFrameTracer tracer(vm, exec);</span>
2535 
2536     return codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
2537 }
2538 
2539 uintptr_t JIT_OPERATION operationCompareStringGreaterEq(ExecState* exec, JSString* a, JSString* b)
2540 {
2541     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2542     NativeCallFrameTracer tracer(vm, exec);</span>
2543 
2544     return !codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
2545 }
2546 
2547 void JIT_OPERATION operationNotifyWrite(ExecState* exec, WatchpointSet* set)
2548 {
2549     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2550     NativeCallFrameTracer tracer(vm, exec);</span>
2551 
2552     set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
2553 }
2554 
2555 void JIT_OPERATION operationThrowStackOverflowForVarargs(ExecState* exec)
2556 {
2557     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2558     NativeCallFrameTracer tracer(vm, exec);</span>
2559     auto scope = DECLARE_THROW_SCOPE(vm);
2560     throwStackOverflowError(exec, scope);
2561 }
2562 
2563 int32_t JIT_OPERATION operationSizeOfVarargs(ExecState* exec, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)
2564 {
2565     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2566     NativeCallFrameTracer tracer(vm, exec);</span>
2567     JSValue arguments = JSValue::decode(encodedArguments);
2568 
2569     return sizeOfVarargs(exec, arguments, firstVarArgOffset);
2570 }
2571 
2572 int32_t JIT_OPERATION operationHasOwnProperty(ExecState* exec, JSObject* thisObject, EncodedJSValue encodedKey)
2573 {
2574     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2575     NativeCallFrameTracer tracer(vm, exec);</span>
2576     auto scope = DECLARE_THROW_SCOPE(vm);
2577 
2578     JSValue key = JSValue::decode(encodedKey);
2579     Identifier propertyName = key.toPropertyKey(exec);
2580     RETURN_IF_EXCEPTION(scope, false);
2581 
2582     PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
2583     bool result = thisObject-&gt;hasOwnProperty(exec, propertyName.impl(), slot);
2584     RETURN_IF_EXCEPTION(scope, false);
2585 
2586     HasOwnPropertyCache* hasOwnPropertyCache = vm.hasOwnPropertyCache();
2587     ASSERT(hasOwnPropertyCache);
2588     hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName.impl(), result);
2589     return result;
2590 }
2591 
2592 int32_t JIT_OPERATION operationNumberIsInteger(ExecState* exec, EncodedJSValue value)
2593 {
2594     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2595     NativeCallFrameTracer tracer(vm, exec);</span>
2596     return NumberConstructor::isIntegerImpl(JSValue::decode(value));
2597 }
2598 
2599 int32_t JIT_OPERATION operationArrayIndexOfString(ExecState* exec, Butterfly* butterfly, JSString* searchElement, int32_t index)
2600 {
2601     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2602     NativeCallFrameTracer tracer(vm, exec);</span>
2603     auto scope = DECLARE_THROW_SCOPE(vm);
2604 
2605     int32_t length = butterfly-&gt;publicLength();
2606     auto data = butterfly-&gt;contiguous().data();
2607     for (; index &lt; length; ++index) {
2608         JSValue value = data[index].get();
2609         if (!value || !value.isString())
2610             continue;
2611         auto* string = asString(value);
2612         if (string == searchElement)
2613             return index;
<span class="line-modified">2614         if (string-&gt;equal(exec, searchElement)) {</span>
<span class="line-added">2615             scope.assertNoException();</span>
2616             return index;
<span class="line-added">2617         }</span>
2618         RETURN_IF_EXCEPTION(scope, { });
2619     }
2620     return -1;
2621 }
2622 
2623 int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
2624 {
2625     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2626     NativeCallFrameTracer tracer(vm, exec);</span>
2627     auto scope = DECLARE_THROW_SCOPE(vm);
2628 
2629     JSValue searchElement = JSValue::decode(encodedValue);
2630 
2631     int32_t length = butterfly-&gt;publicLength();
2632     auto data = butterfly-&gt;contiguous().data();
2633     for (; index &lt; length; ++index) {
2634         JSValue value = data[index].get();
2635         if (!value)
2636             continue;
<span class="line-modified">2637         bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>

2638         RETURN_IF_EXCEPTION(scope, { });
<span class="line-added">2639         if (isEqual)</span>
<span class="line-added">2640             return index;</span>
2641     }
2642     return -1;
2643 }
2644 
2645 int32_t JIT_OPERATION operationArrayIndexOfValueDouble(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
2646 {
2647     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2648     NativeCallFrameTracer tracer(vm, exec);</span>
2649 
2650     JSValue searchElement = JSValue::decode(encodedValue);
2651 
2652     if (!searchElement.isNumber())
2653         return -1;
2654     double number = searchElement.asNumber();
2655 
2656     int32_t length = butterfly-&gt;publicLength();
2657     const double* data = butterfly-&gt;contiguousDouble().data();
2658     for (; index &lt; length; ++index) {
2659         // This comparison ignores NaN.
2660         if (data[index] == number)
2661             return index;
2662     }
2663     return -1;
2664 }
2665 
2666 void JIT_OPERATION operationLoadVarargs(ExecState* exec, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t length, uint32_t mandatoryMinimum)
2667 {
2668     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2669     NativeCallFrameTracer tracer(vm, exec);</span>
2670     JSValue arguments = JSValue::decode(encodedArguments);
2671 
2672     loadVarargs(exec, VirtualRegister(firstElementDest), arguments, offset, length);
2673 
2674     for (uint32_t i = length; i &lt; mandatoryMinimum; ++i)
2675         exec-&gt;r(firstElementDest + i) = jsUndefined();
2676 }
2677 
2678 double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
2679 {
2680     return fmod(a, b);
2681 }
2682 
2683 #if USE(JSVALUE32_64)
2684 double JIT_OPERATION operationRandom(JSGlobalObject* globalObject)
2685 {
2686     return globalObject-&gt;weakRandomNumber();
2687 }
2688 #endif
2689 
2690 JSCell* JIT_OPERATION operationStringFromCharCode(ExecState* exec, int32_t op1)
2691 {
<span class="line-modified">2692     VM&amp; vm = exec-&gt;vm();</span>
2693     NativeCallFrameTracer tracer(vm, exec);
2694     return JSC::stringFromCharCode(exec, op1);
2695 }
2696 
2697 EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(ExecState* exec, EncodedJSValue encodedValue)
2698 {
<span class="line-modified">2699     VM&amp; vm = exec-&gt;vm();</span>
2700     NativeCallFrameTracer tracer(vm, exec);
2701     JSValue charValue = JSValue::decode(encodedValue);
2702     int32_t chInt = charValue.toUInt32(exec);
2703     return JSValue::encode(JSC::stringFromCharCode(exec, chInt));
2704 }
2705 
2706 int64_t JIT_OPERATION operationConvertBoxedDoubleToInt52(EncodedJSValue encodedValue)
2707 {
2708     JSValue value = JSValue::decode(encodedValue);
2709     if (!value.isDouble())
2710         return JSValue::notInt52;
2711     return tryConvertToInt52(value.asDouble());
2712 }
2713 
2714 int64_t JIT_OPERATION operationConvertDoubleToInt52(double value)
2715 {
2716     return tryConvertToInt52(value);
2717 }
2718 
2719 char* JIT_OPERATION operationNewRawObject(ExecState* exec, Structure* structure, int32_t length, Butterfly* butterfly)
2720 {
2721     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2722     NativeCallFrameTracer tracer(vm, exec);</span>
2723 
2724     if (!butterfly
2725         &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
2726         IndexingHeader header;
2727         header.setVectorLength(length);
2728         header.setPublicLength(0);
2729 
2730         butterfly = Butterfly::create(
2731             vm, nullptr, 0, structure-&gt;outOfLineCapacity(),
2732             hasIndexedProperties(structure-&gt;indexingType()), header,
2733             length * sizeof(EncodedJSValue));
2734     }
2735 
2736     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);
2737     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.
2738     return bitwise_cast&lt;char*&gt;(result);
2739 }
2740 
2741 JSCell* JIT_OPERATION operationNewObjectWithButterfly(ExecState* exec, Structure* structure, Butterfly* butterfly)
2742 {
2743     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2744     NativeCallFrameTracer tracer(vm, exec);</span>
2745 
2746     if (!butterfly) {
2747         butterfly = Butterfly::create(
2748             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
2749     }
2750 
2751     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);
2752     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.
2753     return result;
2754 }
2755 
2756 JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(ExecState* exec, Structure* structure, unsigned length, Butterfly* butterfly)
2757 {
2758     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2759     NativeCallFrameTracer tracer(vm, exec);</span>
2760 
2761     IndexingHeader header;
2762     header.setVectorLength(length);
2763     header.setPublicLength(0);
2764     if (butterfly)
2765         *butterfly-&gt;indexingHeader() = header;
2766     else {
2767         butterfly = Butterfly::create(
2768             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), true, header,
2769             sizeof(EncodedJSValue) * length);
2770     }
2771 
2772     // Paradoxically this may allocate a JSArray. That&#39;s totally cool.
2773     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);
2774     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.
2775     return result;
2776 }
2777 
2778 JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(ExecState* exec, void* buffer, uint32_t numItems)
2779 {
2780     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2781     NativeCallFrameTracer tracer(vm, exec);</span>
2782     auto scope = DECLARE_THROW_SCOPE(vm);
2783 
2784     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
2785     Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
2786     for (unsigned i = 0; i &lt; numItems; i++) {
2787         JSValue value = JSValue::decode(values[i]);
2788         if (JSFixedArray* array = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value))
2789             checkedLength += array-&gt;size();
2790         else
2791             ++checkedLength;
2792     }
2793 
2794     if (UNLIKELY(checkedLength.hasOverflowed())) {
2795         throwOutOfMemoryError(exec, scope);
2796         return nullptr;
2797     }
2798 
2799     unsigned length = checkedLength.unsafeGet();
2800     if (UNLIKELY(length &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)) {
2801         throwOutOfMemoryError(exec, scope);
</pre>
<hr />
<pre>
2819             // We are spreading.
2820             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {
2821                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));
2822                 RETURN_IF_EXCEPTION(scope, nullptr);
2823                 ++index;
2824             }
2825         } else {
2826             // We are not spreading.
2827             result-&gt;putDirectIndex(exec, index, value);
2828             RETURN_IF_EXCEPTION(scope, nullptr);
2829             ++index;
2830         }
2831     }
2832 
2833     return result;
2834 }
2835 
2836 JSCell* operationCreateFixedArray(ExecState* exec, unsigned length)
2837 {
2838     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2839     NativeCallFrameTracer tracer(vm, exec);</span>
2840     auto scope = DECLARE_THROW_SCOPE(vm);
2841 
2842     if (JSFixedArray* result = JSFixedArray::tryCreate(vm, vm.fixedArrayStructure.get(), length))
2843         return result;
2844 
2845     throwOutOfMemoryError(exec, scope);
2846     return nullptr;
2847 }
2848 
2849 JSCell* JIT_OPERATION operationSpreadGeneric(ExecState* exec, JSCell* iterable)
2850 {
2851     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2852     NativeCallFrameTracer tracer(vm, exec);</span>
2853 
2854     auto throwScope = DECLARE_THROW_SCOPE(vm);
2855 
2856     if (isJSArray(iterable)) {
2857         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
2858         if (array-&gt;isIteratorProtocolFastAndNonObservable())
2859             RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));
2860     }
2861 
2862     // FIXME: we can probably make this path faster by having our caller JS code call directly into
2863     // the iteration protocol builtin: https://bugs.webkit.org/show_bug.cgi?id=164520
2864 
2865     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
2866     JSArray* array;
2867     {
2868         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
2869         CallData callData;
2870         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
2871         ASSERT(callType != CallType::None);
2872 
2873         MarkedArgumentBuffer arguments;
2874         arguments.append(iterable);
2875         ASSERT(!arguments.hasOverflowed());
2876         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);
2877         RETURN_IF_EXCEPTION(throwScope, nullptr);
2878         array = jsCast&lt;JSArray*&gt;(arrayResult);
2879     }
2880 
2881     RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));
2882 }
2883 
2884 JSCell* JIT_OPERATION operationSpreadFastArray(ExecState* exec, JSCell* cell)
2885 {
2886     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2887     NativeCallFrameTracer tracer(vm, exec);</span>
2888 
2889     ASSERT(isJSArray(cell));
2890     JSArray* array = jsCast&lt;JSArray*&gt;(cell);
2891     ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
2892 
2893     return JSFixedArray::createFromArray(exec, vm, array);
2894 }
2895 
2896 void JIT_OPERATION operationProcessTypeProfilerLogDFG(ExecState* exec)
2897 {
2898     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2899     NativeCallFrameTracer tracer(vm, exec);</span>
2900 
2901     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
2902 }
2903 
2904 EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
2905 {
2906     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2907     NativeCallFrameTracer tracer(vm, exec);</span>
2908 
<span class="line-modified">2909     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, Identifier::fromUid(vm, impl));</span>
2910     return JSValue::encode(resolvedScope);
2911 }
2912 
2913 JSCell* JIT_OPERATION operationResolveScope(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
2914 {
2915     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2916     NativeCallFrameTracer tracer(vm, exec);</span>
2917 
<span class="line-modified">2918     JSObject* resolvedScope = JSScope::resolve(exec, scope, Identifier::fromUid(vm, impl));</span>
2919     return resolvedScope;
2920 }
2921 
2922 EncodedJSValue JIT_OPERATION operationGetDynamicVar(ExecState* exec, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)
2923 {
2924     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2925     NativeCallFrameTracer tracer(vm, exec);</span>
2926     auto throwScope = DECLARE_THROW_SCOPE(vm);
2927 
<span class="line-modified">2928     Identifier ident = Identifier::fromUid(vm, impl);</span>
2929     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
2930         if (!found) {
2931             GetPutInfo getPutInfo(getPutInfoBits);
2932             if (getPutInfo.resolveMode() == ThrowIfNotFound)
2933                 throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2934             return jsUndefined();
2935         }
2936 
2937         if (scope-&gt;isGlobalLexicalEnvironment()) {
2938             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2939             JSValue result = slot.getValue(exec, ident);
2940             if (result == jsTDZValue()) {
2941                 throwException(exec, throwScope, createTDZError(exec));
2942                 return jsUndefined();
2943             }
2944             return result;
2945         }
2946 
2947         return slot.getValue(exec, ident);
2948     })));
2949 }
2950 
<span class="line-modified">2951 ALWAYS_INLINE static void putDynamicVar(ExecState* exec, VM&amp; vm, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits, bool isStrictMode)</span>
2952 {


2953     auto throwScope = DECLARE_THROW_SCOPE(vm);
2954 
<span class="line-modified">2955     const Identifier&amp; ident = Identifier::fromUid(vm, impl);</span>
2956     GetPutInfo getPutInfo(getPutInfoBits);
2957     bool hasProperty = scope-&gt;hasProperty(exec, ident);
2958     RETURN_IF_EXCEPTION(throwScope, void());
2959     if (hasProperty
2960         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
2961         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
2962         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2963         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
2964         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);
2965         if (slot.getValue(exec, ident) == jsTDZValue()) {
2966             throwException(exec, throwScope, createTDZError(exec));
2967             return;
2968         }
2969     }
2970 
2971     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
2972         throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2973         return;
2974     }
2975 
<span class="line-modified">2976     PutPropertySlot slot(scope, isStrictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));</span>






2977     throwScope.release();
2978     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, JSValue::decode(value), slot);
2979 }
2980 
<span class="line-added">2981 void JIT_OPERATION operationPutDynamicVarStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
<span class="line-added">2982 {</span>
<span class="line-added">2983     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2984     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">2985     constexpr bool isStrictMode = true;</span>
<span class="line-added">2986     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
<span class="line-added">2987 }</span>
<span class="line-added">2988 </span>
<span class="line-added">2989 void JIT_OPERATION operationPutDynamicVarNonStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
<span class="line-added">2990 {</span>
<span class="line-added">2991     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2992     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">2993     constexpr bool isStrictMode = false;</span>
<span class="line-added">2994     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
<span class="line-added">2995 }</span>
<span class="line-added">2996 </span>
2997 int32_t JIT_OPERATION operationMapHash(ExecState* exec, EncodedJSValue input)
2998 {
2999     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3000     NativeCallFrameTracer tracer(vm, exec);</span>
3001 
3002     return jsMapHash(exec, vm, JSValue::decode(input));
3003 }
3004 
3005 JSCell* JIT_OPERATION operationJSMapFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
3006 {
3007     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3008     NativeCallFrameTracer tracer(vm, exec);</span>
3009     JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
3010     if (!bucket)
3011         return vm.sentinelMapBucket();
3012     return *bucket;
3013 }
3014 
3015 JSCell* JIT_OPERATION operationJSSetFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
3016 {
3017     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3018     NativeCallFrameTracer tracer(vm, exec);</span>
3019     JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
3020     if (!bucket)
3021         return vm.sentinelSetBucket();
3022     return *bucket;
3023 }
3024 
3025 JSCell* JIT_OPERATION operationSetAdd(ExecState* exec, JSCell* set, EncodedJSValue key, int32_t hash)
3026 {
3027     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3028     NativeCallFrameTracer tracer(vm, exec);</span>
3029     auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(exec, JSValue::decode(key), JSValue(), hash);
3030     if (!bucket)
3031         return vm.sentinelSetBucket();
3032     return bucket;
3033 }
3034 
3035 JSCell* JIT_OPERATION operationMapSet(ExecState* exec, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)
3036 {
3037     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3038     NativeCallFrameTracer tracer(vm, exec);</span>
3039     auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(exec, JSValue::decode(key), JSValue::decode(value), hash);
3040     if (!bucket)
3041         return vm.sentinelMapBucket();
3042     return bucket;
3043 }
3044 
3045 void JIT_OPERATION operationWeakSetAdd(ExecState* exec, JSCell* set, JSCell* key, int32_t hash)
3046 {
3047     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3048     NativeCallFrameTracer tracer(vm, exec);</span>
3049     jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
3050 }
3051 
3052 void JIT_OPERATION operationWeakMapSet(ExecState* exec, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)
3053 {
3054     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3055     NativeCallFrameTracer tracer(vm, exec);</span>
3056     jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
3057 }
3058 
3059 EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(ExecState* exec, JSObject* thisObject)
3060 {
3061     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3062     NativeCallFrameTracer tracer(vm, exec);</span>
3063     return JSValue::encode(thisObject-&gt;getPrototype(vm, exec));
3064 }
3065 
3066 EncodedJSValue JIT_OPERATION operationGetPrototypeOf(ExecState* exec, EncodedJSValue encodedValue)
3067 {
3068     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3069     NativeCallFrameTracer tracer(vm, exec);</span>
3070     auto scope = DECLARE_THROW_SCOPE(vm);
3071 
3072     JSValue thisValue = JSValue::decode(encodedValue).toThis(exec, StrictMode);
3073     if (thisValue.isUndefinedOrNull())
3074         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));
3075 
3076     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
3077     if (!thisObject) {
3078         JSObject* prototype = thisValue.synthesizePrototype(exec);
3079         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
3080         if (UNLIKELY(!prototype))
3081             return JSValue::encode(JSValue());
3082         return JSValue::encode(prototype);
3083     }
3084 
3085     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));
3086 }
3087 
3088 void JIT_OPERATION operationThrowDFG(ExecState* exec, EncodedJSValue valueToThrow)
3089 {
3090     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3091     NativeCallFrameTracer tracer(vm, exec);</span>
3092     auto scope = DECLARE_THROW_SCOPE(vm);
3093     scope.throwException(exec, JSValue::decode(valueToThrow));
3094 }
3095 
3096 void JIT_OPERATION operationThrowStaticError(ExecState* exec, JSString* message, uint32_t errorType)
3097 {
3098     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">3099     NativeCallFrameTracer tracer(vm, exec);</span>
3100     auto scope = DECLARE_THROW_SCOPE(vm);
3101     String errorMessage = message-&gt;value(exec);
3102     scope.throwException(exec, createError(exec, static_cast&lt;ErrorType&gt;(errorType), errorMessage));
3103 }
3104 
3105 extern &quot;C&quot; void JIT_OPERATION triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)
3106 {
3107     // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
3108     // really be profitable.
<span class="line-modified">3109     DeferGCForAWhile deferGC(codeBlock-&gt;vm().heap);</span>
3110 
3111     sanitizeStackForVM(codeBlock-&gt;vm());
3112 
3113     if (Options::verboseOSR())
3114         dataLog(*codeBlock, &quot;: Entered reoptimize\n&quot;);
3115     // We must be called with the baseline code block.
3116     ASSERT(JITCode::isBaselineCode(codeBlock-&gt;jitType()));
3117 
3118     // If I am my own replacement, then reoptimization has already been triggered.
3119     // This can happen in recursive functions.
3120     //
3121     // Note that even if optimizedCodeBlock is an FTLForOSREntry style CodeBlock, this condition is a
3122     // sure bet that we don&#39;t have anything else left to do.
3123     CodeBlock* replacement = codeBlock-&gt;replacement();
3124     if (!replacement || replacement == codeBlock) {
3125         if (Options::verboseOSR())
3126             dataLog(*codeBlock, &quot;: Not reoptimizing because we&#39;ve already been jettisoned.\n&quot;);
3127         return;
3128     }
3129 
3130     // Otherwise, the replacement must be optimized code. Use this as an opportunity
3131     // to check our logic.
3132     ASSERT(codeBlock-&gt;hasOptimizedReplacement());
3133     ASSERT(JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
3134 
3135     bool didTryToEnterIntoInlinedLoops = false;
<span class="line-modified">3136     for (InlineCallFrame* inlineCallFrame = exit-&gt;m_codeOrigin.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {</span>
3137         if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
3138             didTryToEnterIntoInlinedLoops = true;
3139             break;
3140         }
3141     }
3142 
3143     // In order to trigger reoptimization, one of two things must have happened:
3144     // 1) We exited more than some number of times.
3145     // 2) We exited and got stuck in a loop, and now we&#39;re exiting again.
3146     bool didExitABunch = optimizedCodeBlock-&gt;shouldReoptimizeNow();
3147     bool didGetStuckInLoop =
3148         (codeBlock-&gt;checkIfOptimizationThresholdReached() || didTryToEnterIntoInlinedLoops)
3149         &amp;&amp; optimizedCodeBlock-&gt;shouldReoptimizeFromLoopNow();
3150 
3151     if (!didExitABunch &amp;&amp; !didGetStuckInLoop) {
3152         if (Options::verboseOSR())
3153             dataLog(*codeBlock, &quot;: Not reoptimizing &quot;, *optimizedCodeBlock, &quot; because it either didn&#39;t exit enough or didn&#39;t loop enough after exit.\n&quot;);
3154         codeBlock-&gt;optimizeAfterLongWarmUp();
3155         return;
3156     }
</pre>
<hr />
<pre>
3162 static bool shouldTriggerFTLCompile(CodeBlock* codeBlock, JITCode* jitCode)
3163 {
3164     if (codeBlock-&gt;baselineVersion()-&gt;m_didFailFTLCompilation) {
3165         CODEBLOCK_LOG_EVENT(codeBlock, &quot;abortFTLCompile&quot;, ());
3166         if (Options::verboseOSR())
3167             dataLog(&quot;Deferring FTL-optimization of &quot;, *codeBlock, &quot; indefinitely because there was an FTL failure.\n&quot;);
3168         jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3169         return false;
3170     }
3171 
3172     if (!codeBlock-&gt;hasOptimizedReplacement()
3173         &amp;&amp; !jitCode-&gt;checkIfOptimizationThresholdReached(codeBlock)) {
3174         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;counter = &quot;, jitCode-&gt;tierUpCounter));
3175         if (Options::verboseOSR())
3176             dataLog(&quot;Choosing not to FTL-optimize &quot;, *codeBlock, &quot; yet.\n&quot;);
3177         return false;
3178     }
3179     return true;
3180 }
3181 
<span class="line-modified">3182 static void triggerFTLReplacementCompile(VM&amp; vm, CodeBlock* codeBlock, JITCode* jitCode)</span>
3183 {
3184     if (codeBlock-&gt;codeType() == GlobalCode) {
3185         // Global code runs once, so we don&#39;t want to do anything. We don&#39;t want to defer indefinitely,
3186         // since this may have been spuriously called from tier-up initiated in a loop, and that loop may
3187         // later want to run faster code. Deferring for warm-up seems safest.
3188         jitCode-&gt;optimizeAfterWarmUp(codeBlock);
3189         return;
3190     }
3191 
3192     Worklist::State worklistState;
3193     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3194         worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">3195             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLMode));</span>
3196     } else
3197         worklistState = Worklist::NotKnown;
3198 
3199     if (worklistState == Worklist::Compiling) {
3200         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3201         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3202             codeBlock, CompilationDeferred);
3203         return;
3204     }
3205 
3206     if (codeBlock-&gt;hasOptimizedReplacement()) {
3207         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;has replacement&quot;));
3208         // That&#39;s great, we&#39;ve compiled the code - next time we call this function,
3209         // we&#39;ll enter that replacement.
3210         jitCode-&gt;optimizeSoon(codeBlock);
3211         return;
3212     }
3213 
3214     if (worklistState == Worklist::Compiled) {
3215         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3216         // This means that we finished compiling, but failed somehow; in that case the
3217         // thresholds will be set appropriately.
3218         if (Options::verboseOSR())
3219             dataLog(&quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.\n&quot;);
3220         return;
3221     }
3222 
3223     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
3224     // We need to compile the code.
3225     compile(
<span class="line-modified">3226         vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, UINT_MAX,</span>
3227         Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
3228 
3229     // If we reached here, the counter has not be reset. Do that now.
3230     jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3231         codeBlock, CompilationDeferred);
3232 }
3233 
3234 void JIT_OPERATION triggerTierUpNow(ExecState* exec)
3235 {
<span class="line-modified">3236     VM&amp; vm = exec-&gt;vm();</span>
3237     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">3238     DeferGCForAWhile deferGC(vm.heap);</span>
3239     CodeBlock* codeBlock = exec-&gt;codeBlock();
3240 
3241     sanitizeStackForVM(vm);
3242 
<span class="line-modified">3243     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {</span>
3244         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3245         RELEASE_ASSERT_NOT_REACHED();
3246     }
3247 
3248     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3249 
3250     if (Options::verboseOSR()) {
3251         dataLog(
3252             *codeBlock, &quot;: Entered triggerTierUpNow with executeCounter = &quot;,
3253             jitCode-&gt;tierUpCounter, &quot;\n&quot;);
3254     }
3255 
3256     if (shouldTriggerFTLCompile(codeBlock, jitCode))
3257         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3258 
3259     if (codeBlock-&gt;hasOptimizedReplacement()) {
3260         if (jitCode-&gt;tierUpEntryTriggers.isEmpty()) {
3261             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;replacement in place, delaying indefinitely&quot;));
3262             // There is nothing more we can do, the only way this will be entered
3263             // is through the function entry point.
3264             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3265             return;
3266         }
3267         if (jitCode-&gt;osrEntryBlock() &amp;&amp; jitCode-&gt;tierUpEntryTriggers.size() == 1) {
3268             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;trigger in place, delaying indefinitely&quot;));
3269             // There is only one outer loop and its trigger must have been set
3270             // when the plan completed.
3271             // Exiting the inner loop is useless, we can ignore the counter and leave
3272             // the trigger do its job.
3273             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3274             return;
3275         }
3276     }
3277 }
3278 
3279 static char* tierUpCommon(ExecState* exec, unsigned originBytecodeIndex, bool canOSREnterHere)
3280 {
<span class="line-modified">3281     VM&amp; vm = exec-&gt;vm();</span>
3282     CodeBlock* codeBlock = exec-&gt;codeBlock();
3283 
3284     // Resolve any pending plan for OSR Enter on this function.
3285     Worklist::State worklistState;
3286     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3287         worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">3288             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLForOSREntryMode));</span>
3289     } else
3290         worklistState = Worklist::NotKnown;
3291 
3292     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3293 
3294     bool triggeredSlowPathToStartCompilation = false;
3295     auto tierUpEntryTriggers = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3296     if (tierUpEntryTriggers != jitCode-&gt;tierUpEntryTriggers.end()) {
3297         switch (tierUpEntryTriggers-&gt;value) {
3298         case JITCode::TriggerReason::DontTrigger:
3299             // The trigger isn&#39;t set, we entered because the counter reached its
3300             // threshold.
3301             break;
3302 
3303         case JITCode::TriggerReason::CompilationDone:
3304             // The trigger was set because compilation completed. Don&#39;t unset it
3305             // so that further DFG executions OSR enter as well.
3306             break;
3307 
3308         case JITCode::TriggerReason::StartCompilation:
</pre>
<hr />
<pre>
3371             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed, OSR entry threshold not met&quot;));
3372             jitCode-&gt;osrEntryRetry++;
3373             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3374                 codeBlock, CompilationDeferred);
3375             return nullptr;
3376         }
3377 
3378         FTL::ForOSREntryJITCode* entryCode = entryBlock-&gt;jitCode()-&gt;ftlForOSREntry();
3379         entryCode-&gt;countEntryFailure();
3380         if (entryCode-&gt;entryFailureCount() &lt;
3381             Options::ftlOSREntryFailureCountForReoptimization()) {
3382             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed&quot;));
3383             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3384                 codeBlock, CompilationDeferred);
3385             return nullptr;
3386         }
3387 
3388         // OSR entry failed. Oh no! This implies that we need to retry. We retry
3389         // without exponential backoff and we only do this for the entry code block.
3390         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed too many times&quot;));
<span class="line-modified">3391         jitCode-&gt;clearOSREntryBlockAndResetThresholds(codeBlock);</span>





3392         return nullptr;
3393     }
3394 
3395     // It&#39;s time to try to compile code for OSR entry.
3396 
3397     if (!triggeredSlowPathToStartCompilation) {
3398 
3399         // An inner loop didn&#39;t specifically ask for us to kick off a compilation. This means the counter
3400         // crossed its threshold. We either fall through and kick off a compile for originBytecodeIndex,
3401         // or we flag an outer loop to immediately try to compile itself. If there are outer loops,
3402         // we first try to make them compile themselves. But we will eventually fall back to compiling
3403         // a progressively inner loop if it takes too long for control to reach an outer loop.
3404 
3405         auto tryTriggerOuterLoopToCompile = [&amp;] {
3406             auto tierUpHierarchyEntry = jitCode-&gt;tierUpInLoopHierarchy.find(originBytecodeIndex);
3407             if (tierUpHierarchyEntry == jitCode-&gt;tierUpInLoopHierarchy.end())
3408                 return false;
3409 
3410             // This vector is ordered from innermost to outermost loop. Every bytecode entry in this vector is
3411             // allowed to do OSR entry. We start with the outermost loop and make our way inwards (hence why we
</pre>
<hr />
<pre>
3448 
3449     // We aren&#39;t compiling and haven&#39;t compiled anything for OSR entry. So, try to compile
3450     // something.
3451 
3452     auto triggerIterator = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3453     if (triggerIterator == jitCode-&gt;tierUpEntryTriggers.end()) {
3454         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3455         return nullptr;
3456     }
3457 
3458     JITCode::TriggerReason* triggerAddress = &amp;(triggerIterator-&gt;value);
3459 
3460     Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues;
3461     unsigned streamIndex = jitCode-&gt;bytecodeIndexToStreamIndex.get(originBytecodeIndex);
3462     jitCode-&gt;reconstruct(
3463         exec, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);
3464     CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
3465 
3466     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
3467     CompilationResult forEntryResult = compile(
<span class="line-modified">3468         vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,</span>
3469         mustHandleValues, ToFTLForOSREntryDeferredCompilationCallback::create(triggerAddress));
3470 
3471     if (jitCode-&gt;neverExecutedEntry)
3472         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3473 
3474     if (forEntryResult != CompilationSuccessful) {
3475         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR ecompilation not successful&quot;));
3476         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3477             codeBlock, CompilationDeferred);
3478         return nullptr;
3479     }
3480 
3481     CODEBLOCK_LOG_EVENT(jitCode-&gt;osrEntryBlock(), &quot;osrEntry&quot;, (&quot;at bc#&quot;, originBytecodeIndex));
3482     // It&#39;s possible that the for-entry compile already succeeded. In that case OSR
3483     // entry will succeed unless we ran out of stack. It&#39;s not clear what we should do.
3484     // We signal to try again after a while if that happens.
3485     if (Options::verboseOSR())
3486         dataLog(&quot;Immediate OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(jitCode-&gt;osrEntryBlock()), &quot;\n&quot;);
3487 
3488     void* address = FTL::prepareOSREntry(
3489         exec, codeBlock, jitCode-&gt;osrEntryBlock(), originBytecodeIndex, streamIndex);
3490     if (!address)
3491         return nullptr;
3492     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));
3493 }
3494 
3495 void JIT_OPERATION triggerTierUpNowInLoop(ExecState* exec, unsigned bytecodeIndex)
3496 {
<span class="line-modified">3497     VM&amp; vm = exec-&gt;vm();</span>
3498     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">3499     DeferGCForAWhile deferGC(vm.heap);</span>
3500     CodeBlock* codeBlock = exec-&gt;codeBlock();
3501 
3502     sanitizeStackForVM(vm);
3503 
<span class="line-modified">3504     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {</span>
3505         dataLog(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock, &quot;\n&quot;);
3506         RELEASE_ASSERT_NOT_REACHED();
3507     }
3508 
3509     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3510 
3511     if (Options::verboseOSR()) {
3512         dataLog(
3513             *codeBlock, &quot;: Entered triggerTierUpNowInLoop with executeCounter = &quot;,
3514             jitCode-&gt;tierUpCounter, &quot;\n&quot;);
3515     }
3516 
3517     if (jitCode-&gt;tierUpInLoopHierarchy.contains(bytecodeIndex))
3518         tierUpCommon(exec, bytecodeIndex, false);
3519     else if (shouldTriggerFTLCompile(codeBlock, jitCode))
3520         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3521 
3522     // Since we cannot OSR Enter here, the default &quot;optimizeSoon()&quot; is not useful.
3523     if (codeBlock-&gt;hasOptimizedReplacement()) {
3524         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR in loop failed, deferring&quot;));
3525         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3526     }
3527 }
3528 
3529 char* JIT_OPERATION triggerOSREntryNow(ExecState* exec, unsigned bytecodeIndex)
3530 {
<span class="line-modified">3531     VM&amp; vm = exec-&gt;vm();</span>
3532     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">3533     DeferGCForAWhile deferGC(vm.heap);</span>
3534     CodeBlock* codeBlock = exec-&gt;codeBlock();
3535 
3536     sanitizeStackForVM(vm);
3537 
<span class="line-modified">3538     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {</span>
3539         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3540         RELEASE_ASSERT_NOT_REACHED();
3541     }
3542 
3543     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();

3544 
3545     if (Options::verboseOSR()) {
3546         dataLog(
3547             *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;,
3548             jitCode-&gt;tierUpCounter, &quot;\n&quot;);
3549     }
3550 
3551     return tierUpCommon(exec, bytecodeIndex, true);
3552 }
3553 
3554 #endif // ENABLE(FTL_JIT)
3555 
3556 } // extern &quot;C&quot;
3557 } } // namespace JSC::DFG
3558 
3559 #endif // ENABLE(DFG_JIT)
3560 
3561 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGObjectAllocationSinkingPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>