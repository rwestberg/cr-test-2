<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLChecker.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLArrayReferenceType.h&quot;
  32 #include &quot;WHLSLArrayType.h&quot;
  33 #include &quot;WHLSLAssignmentExpression.h&quot;
  34 #include &quot;WHLSLCallExpression.h&quot;
  35 #include &quot;WHLSLCommaExpression.h&quot;
  36 #include &quot;WHLSLDereferenceExpression.h&quot;
  37 #include &quot;WHLSLDoWhileLoop.h&quot;
  38 #include &quot;WHLSLDotExpression.h&quot;
  39 #include &quot;WHLSLForLoop.h&quot;
  40 #include &quot;WHLSLGatherEntryPointItems.h&quot;
  41 #include &quot;WHLSLIfStatement.h&quot;
  42 #include &quot;WHLSLIndexExpression.h&quot;
  43 #include &quot;WHLSLInferTypes.h&quot;
  44 #include &quot;WHLSLLogicalExpression.h&quot;
  45 #include &quot;WHLSLLogicalNotExpression.h&quot;
  46 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  47 #include &quot;WHLSLMakePointerExpression.h&quot;
  48 #include &quot;WHLSLPointerType.h&quot;
  49 #include &quot;WHLSLProgram.h&quot;
  50 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  51 #include &quot;WHLSLResolvableType.h&quot;
  52 #include &quot;WHLSLResolveOverloadImpl.h&quot;
  53 #include &quot;WHLSLResolvingType.h&quot;
  54 #include &quot;WHLSLReturn.h&quot;
  55 #include &quot;WHLSLSwitchStatement.h&quot;
  56 #include &quot;WHLSLTernaryExpression.h&quot;
  57 #include &quot;WHLSLVisitor.h&quot;
  58 #include &quot;WHLSLWhileLoop.h&quot;
  59 #include &lt;wtf/HashMap.h&gt;
  60 #include &lt;wtf/HashSet.h&gt;
  61 #include &lt;wtf/Ref.h&gt;
  62 #include &lt;wtf/Vector.h&gt;
  63 #include &lt;wtf/text/WTFString.h&gt;
  64 
  65 namespace WebCore {
  66 
  67 namespace WHLSL {
  68 
  69 class PODChecker : public Visitor {
  70 public:
  71     PODChecker() = default;
  72 
  73     virtual ~PODChecker() = default;
  74 
  75     void visit(AST::EnumerationDefinition&amp; enumerationDefinition) override
  76     {
  77         Visitor::visit(enumerationDefinition);
  78     }
  79 
  80     void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
  81     {
  82         if (!nativeTypeDeclaration.isNumber()
  83             &amp;&amp; !nativeTypeDeclaration.isVector()
  84             &amp;&amp; !nativeTypeDeclaration.isMatrix())
  85             setError();
  86     }
  87 
  88     void visit(AST::StructureDefinition&amp; structureDefinition) override
  89     {
  90         Visitor::visit(structureDefinition);
  91     }
  92 
  93     void visit(AST::TypeDefinition&amp; typeDefinition) override
  94     {
  95         Visitor::visit(typeDefinition);
  96     }
  97 
  98     void visit(AST::ArrayType&amp; arrayType) override
  99     {
 100         Visitor::visit(arrayType);
 101     }
 102 
 103     void visit(AST::PointerType&amp;) override
 104     {
 105         setError();
 106     }
 107 
 108     void visit(AST::ArrayReferenceType&amp;) override
 109     {
 110         setError();
 111     }
 112 
 113     void visit(AST::TypeReference&amp; typeReference) override
 114     {
 115         ASSERT(typeReference.resolvedType());
 116         checkErrorAndVisit(*typeReference.resolvedType());
 117     }
 118 };
 119 
 120 static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(AST::CallExpression&amp; callExpression, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)
 121 {
 122     const bool isOperator = true;
 123     auto returnType = makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(callExpression.origin()), firstArgument.addressSpace(), firstArgument.elementType().clone());
 124     AST::VariableDeclarations parameters;
 125     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));
 126     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType()) }, String(), WTF::nullopt, WTF::nullopt));
 127     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));
 128 }
 129 
 130 static AST::NativeFunctionDeclaration resolveWithOperatorLength(AST::CallExpression&amp; callExpression, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)
 131 {
 132     const bool isOperator = true;
 133     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType());
 134     AST::VariableDeclarations parameters;
 135     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));
 136     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));
 137 }
 138 
 139 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(AST::CallExpression&amp; callExpression, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)
 140 {
 141     const bool isOperator = true;
 142     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.boolType());
 143     auto argumentType = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {
 144         return unnamedType-&gt;clone();
 145     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {
 146         return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {
 147             return unnamedType-&gt;clone();
 148         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {
 149             // We encountered &quot;null == null&quot;.
 150             // The type isn&#39;t observable, so we can pick whatever we want.
 151             // FIXME: This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals
 152             return AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.intType());
 153         }), secondArgument);
 154     }), firstArgument);
 155     AST::VariableDeclarations parameters;
 156     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { argumentType-&gt;clone() }, String(), WTF::nullopt, WTF::nullopt));
 157     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { WTFMove(argumentType) }, String(), WTF::nullopt, WTF::nullopt));
 158     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));
 159 }
 160 
 161 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(AST::CallExpression&amp; callExpression, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)
 162 {
 163     if (callExpression.name() == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {
 164         auto* firstArgumentArrayRef = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {
 165             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
 166                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
 167             return nullptr;
 168         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {
 169             return nullptr;
 170         }), types[0].get());
 171         bool secondArgumentIsUint = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {
 172             return matches(unnamedType, intrinsics.uintType());
 173         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {
 174             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());
 175         }), types[1].get());
 176         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)
 177             return resolveWithOperatorAnderIndexer(callExpression, *firstArgumentArrayRef, intrinsics);
 178     } else if (callExpression.name() == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {
 179         auto* firstArgumentReference = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {
 180             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
 181                 return &amp;unnamedType;
 182             return nullptr;
 183         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {
 184             return nullptr;
 185         }), types[0].get());
 186         if (firstArgumentReference)
 187             return resolveWithOperatorLength(callExpression, *firstArgumentReference, intrinsics);
 188     } else if (callExpression.name() == &quot;operator==&quot; &amp;&amp; types.size() == 2) {
 189         auto isAcceptable = [](ResolvingType&amp; resolvingType) -&gt; bool {
 190             return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {
 191                 return is&lt;AST::ReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
 192             }, [](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {
 193                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType());
 194             }), resolvingType);
 195         };
 196         if (isAcceptable(types[0].get()) &amp;&amp; isAcceptable(types[1].get()))
 197             return resolveWithReferenceComparator(callExpression, types[0].get(), types[1].get(), intrinsics);
 198     }
 199     return WTF::nullopt;
 200 }
 201 
 202 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 203 {
 204     {
 205         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 206             for (size_t i = 0; i &lt; items.size(); ++i) {
 207                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 208                     if (items[i].semantic == items[j].semantic)
 209                         return false;
 210                 }
 211             }
 212             return true;
 213         };
 214         if (!checkDuplicateSemantics(inputItems))
 215             return false;
 216         if (!checkDuplicateSemantics(outputItems))
 217             return false;
 218     }
 219 
 220     {
 221         auto checkSemanticTypes = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 222             for (auto&amp; item : items) {
 223                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 224                     return semantic.isAcceptableType(*item.unnamedType, intrinsics);
 225                 }), *item.semantic);
 226                 if (!acceptable)
 227                     return false;
 228             }
 229             return true;
 230         };
 231         if (!checkSemanticTypes(inputItems))
 232             return false;
 233         if (!checkSemanticTypes(outputItems))
 234             return false;
 235     }
 236 
 237     {
 238         auto checkSemanticForShaderType = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items, AST::BaseSemantic::ShaderItemDirection direction) -&gt; bool {
 239             for (auto&amp; item : items) {
 240                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 241                     return semantic.isAcceptableForShaderItemDirection(direction, entryPointType);
 242                 }), *item.semantic);
 243                 if (!acceptable)
 244                     return false;
 245             }
 246             return true;
 247         };
 248         if (!checkSemanticForShaderType(inputItems, AST::BaseSemantic::ShaderItemDirection::Input))
 249             return false;
 250         if (!checkSemanticForShaderType(outputItems, AST::BaseSemantic::ShaderItemDirection::Output))
 251             return false;
 252     }
 253 
 254     {
 255         auto checkPODData = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 256             for (auto&amp; item : items) {
 257                 PODChecker podChecker;
 258                 if (is&lt;AST::PointerType&gt;(item.unnamedType))
 259                     podChecker.checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(*item.unnamedType).elementType());
 260                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 261                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 262                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 263                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 264                 else
 265                     continue;
 266                 if (podChecker.error())
 267                     return false;
 268             }
 269             return true;
 270         };
 271         if (!checkPODData(inputItems))
 272             return false;
 273         if (!checkPODData(outputItems))
 274             return false;
 275     }
 276 
 277     return true;
 278 }
 279 
 280 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, const Intrinsics&amp; intrinsics, NameContext&amp; nameContext)
 281 {
 282     enum class CheckKind {
 283         Index,
 284         Dot
 285     };
 286 
 287     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {
 288         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 289         if (functionDefinition.parameters().size() != numExpectedParameters)
 290             return false;
 291         auto&amp; firstParameterUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();
 292         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {
 293             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);
 294             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 295                 return false;
 296         }
 297         if (kind == CheckKind::Index) {
 298             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();
 299             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 300                 return false;
 301             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 302             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 303                 return false;
 304             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 305             if (!nativeTypeDeclaration.isInt())
 306                 return false;
 307         }
 308         return true;
 309     };
 310 
 311     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {
 312         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
 313         if (functionDefinition.parameters().size() != numExpectedParameters)
 314             return false;
 315         auto&amp; firstArgumentUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();
 316         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {
 317             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);
 318             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 319                 return false;
 320         }
 321         if (kind == CheckKind::Index) {
 322             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();
 323             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 324                 return false;
 325             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 326             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 327                 return false;
 328             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 329             if (!nativeTypeDeclaration.isInt())
 330                 return false;
 331         }
 332         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0].type()))
 333             return false;
 334         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1].type();
 335         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
 336         auto* getterFuncs = nameContext.getFunctions(getterName);
 337         if (!getterFuncs)
 338             return false;
 339         Vector&lt;ResolvingType&gt; argumentTypes;
 340         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;
 341         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)
 342             argumentTypes.append((*functionDefinition.parameters()[0].type())-&gt;clone());
 343         for (auto&amp; argumentType : argumentTypes)
 344             argumentTypeReferences.append(argumentType);
 345         Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;
 346         auto* overload = resolveFunctionOverloadImpl(*getterFuncs, argumentTypeReferences, castReturnType);
 347         if (!overload)
 348             return false;
 349         auto&amp; resultType = overload-&gt;type();
 350         return matches(resultType, valueType);
 351     };
 352 
 353     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {
 354         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 355         if (functionDefinition.parameters().size() != numExpectedParameters)
 356             return false;
 357         {
 358             auto&amp; unifyNode = functionDefinition.type().unifyNode();
 359             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 360                 return false;
 361             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 362             if (!is&lt;AST::PointerType&gt;(unnamedType))
 363                 return false;
 364         }
 365         {
 366             auto&amp; unifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();
 367             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 368                 return false;
 369             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 370             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);
 371         }
 372     };
 373 
 374     if (!functionDefinition.isOperator())
 375         return true;
 376     if (functionDefinition.isCast())
 377         return true;
 378     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 379         return functionDefinition.parameters().size() == 1
 380             &amp;&amp; matches(*functionDefinition.parameters()[0].type(), functionDefinition.type());
 381     }
 382     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 383         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 384     if (functionDefinition.name() == &quot;operator*&quot;
 385         || functionDefinition.name() == &quot;operator/&quot;
 386         || functionDefinition.name() == &quot;operator%&quot;
 387         || functionDefinition.name() == &quot;operator&amp;&quot;
 388         || functionDefinition.name() == &quot;operator|&quot;
 389         || functionDefinition.name() == &quot;operator^&quot;
 390         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
 391         || functionDefinition.name() == &quot;opreator&gt;&gt;&quot;)
 392         return functionDefinition.parameters().size() == 2;
 393     if (functionDefinition.name() == &quot;operator~&quot;)
 394         return functionDefinition.parameters().size() == 1;
 395     if (functionDefinition.name() == &quot;operator==&quot;
 396         || functionDefinition.name() == &quot;operator&lt;&quot;
 397         || functionDefinition.name() == &quot;operator&lt;=&quot;
 398         || functionDefinition.name() == &quot;operator&gt;&quot;
 399         || functionDefinition.name() == &quot;operator&gt;=&quot;) {
 400         return functionDefinition.parameters().size() == 2
 401             &amp;&amp; matches(functionDefinition.type(), intrinsics.boolType());
 402     }
 403     if (functionDefinition.name() == &quot;operator[]&quot;)
 404         return checkGetter(CheckKind::Index);
 405     if (functionDefinition.name() == &quot;operator[]=&quot;)
 406         return checkSetter(CheckKind::Index);
 407     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)
 408         return checkAnder(CheckKind::Index);
 409     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {
 410         if (functionDefinition.name().endsWith(&quot;=&quot;))
 411             return checkSetter(CheckKind::Dot);
 412         return checkGetter(CheckKind::Dot);
 413     }
 414     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))
 415         return checkAnder(CheckKind::Dot);
 416     return false;
 417 }
 418 
 419 class Checker : public Visitor {
 420 public:
 421     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 422         : m_intrinsics(intrinsics)
 423         , m_program(program)
 424     {
 425     }
 426 
 427     ~Checker() = default;
 428 
 429     void visit(Program&amp;) override;
 430 
 431     bool assignTypes();
 432 
 433 private:
 434     bool checkShaderType(const AST::FunctionDefinition&amp;);
 435     void finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp;, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType = nullptr);
 436     bool isBoolType(ResolvingType&amp;);
 437     struct RecurseInfo {
 438         ResolvingType&amp; resolvingType;
 439         Optional&lt;AST::AddressSpace&gt;&amp; addressSpace;
 440     };
 441     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLValue = false);
 442     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLValue = false);
 443     Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);
 444     bool recurseAndRequireBoolType(AST::Expression&amp;);
 445     void assignType(AST::Expression&amp;, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);
 446     void assignType(AST::Expression&amp;, Ref&lt;ResolvableTypeReference&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);
 447     void forwardType(AST::Expression&amp;, ResolvingType&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);
 448 
 449     void visit(AST::FunctionDefinition&amp;) override;
 450     void visit(AST::EnumerationDefinition&amp;) override;
 451     void visit(AST::TypeReference&amp;) override;
 452     void visit(AST::VariableDeclaration&amp;) override;
 453     void visit(AST::AssignmentExpression&amp;) override;
 454     void visit(AST::ReadModifyWriteExpression&amp;) override;
 455     void visit(AST::DereferenceExpression&amp;) override;
 456     void visit(AST::MakePointerExpression&amp;) override;
 457     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 458     void visit(AST::DotExpression&amp;) override;
 459     void visit(AST::IndexExpression&amp;) override;
 460     void visit(AST::VariableReference&amp;) override;
 461     void visit(AST::Return&amp;) override;
 462     void visit(AST::PointerType&amp;) override;
 463     void visit(AST::ArrayReferenceType&amp;) override;
 464     void visit(AST::IntegerLiteral&amp;) override;
 465     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 466     void visit(AST::FloatLiteral&amp;) override;
 467     void visit(AST::NullLiteral&amp;) override;
 468     void visit(AST::BooleanLiteral&amp;) override;
 469     void visit(AST::EnumerationMemberLiteral&amp;) override;
 470     void visit(AST::LogicalNotExpression&amp;) override;
 471     void visit(AST::LogicalExpression&amp;) override;
 472     void visit(AST::IfStatement&amp;) override;
 473     void visit(AST::WhileLoop&amp;) override;
 474     void visit(AST::DoWhileLoop&amp;) override;
 475     void visit(AST::ForLoop&amp;) override;
 476     void visit(AST::SwitchStatement&amp;) override;
 477     void visit(AST::CommaExpression&amp;) override;
 478     void visit(AST::TernaryExpression&amp;) override;
 479     void visit(AST::CallExpression&amp;) override;
 480 
 481     HashMap&lt;AST::Expression*, ResolvingType&gt; m_typeMap;
 482     HashMap&lt;AST::Expression*, Optional&lt;AST::AddressSpace&gt;&gt; m_addressSpaceMap;
 483     HashSet&lt;String&gt; m_vertexEntryPoints;
 484     HashSet&lt;String&gt; m_fragmentEntryPoints;
 485     HashSet&lt;String&gt; m_computeEntryPoints;
 486     const Intrinsics&amp; m_intrinsics;
 487     Program&amp; m_program;
 488 };
 489 
 490 void Checker::visit(Program&amp; program)
 491 {
 492     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 493     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 494         checkErrorAndVisit(program.typeDefinitions()[i]);
 495     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 496         checkErrorAndVisit(program.structureDefinitions()[i]);
 497     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 498         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 499     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 500         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 501 
 502     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 503         checkErrorAndVisit(program.functionDefinitions()[i]);
 504     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 505         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 506 }
 507 
 508 bool Checker::assignTypes()
 509 {
 510     for (auto&amp; keyValuePair : m_typeMap) {
 511         auto success = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {
 512             keyValuePair.key-&gt;setType(unnamedType-&gt;clone());
 513             return true;
 514         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {
 515             if (!resolvableTypeReference-&gt;resolvableType().resolvedType()) {
 516                 // FIXME: Instead of trying to commit, it might be better to just return an error instead.
 517                 if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
 518                     return false;
 519             }
 520             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType()-&gt;clone());
 521             return true;
 522         }), keyValuePair.value);
 523         if (!success)
 524             return false;
 525     }
 526 
 527     for (auto&amp; keyValuePair : m_addressSpaceMap)
 528         keyValuePair.key-&gt;setAddressSpace(keyValuePair.value);
 529     return true;
 530 }
 531 
 532 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 533 {
 534     switch (*functionDefinition.entryPointType()) {
 535     case AST::EntryPointType::Vertex:
 536         return !m_vertexEntryPoints.add(functionDefinition.name()).isNewEntry;
 537     case AST::EntryPointType::Fragment:
 538         return !m_fragmentEntryPoints.add(functionDefinition.name()).isNewEntry;
 539     case AST::EntryPointType::Compute:
 540         return !m_computeEntryPoints.add(functionDefinition.name()).isNewEntry;
 541     }
 542 }
 543 
 544 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 545 {
 546     if (functionDefinition.entryPointType()) {
 547         if (!checkShaderType(functionDefinition)) {
 548             setError();
 549             return;
 550         }
 551         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 552         if (!entryPointItems) {
 553             setError();
 554             return;
 555         }
 556         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
 557             setError();
 558             return;
 559         }
 560     }
 561     if (!checkOperatorOverload(functionDefinition, m_intrinsics, m_program.nameContext())) {
 562         setError();
 563         return;
 564     }
 565 
 566     checkErrorAndVisit(functionDefinition);
 567 }
 568 
 569 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)
 570 {
 571     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 572         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 573             if (matches(left, right))
 574                 return left-&gt;clone();
 575             return WTF::nullopt;
 576         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 577             return matchAndCommit(left, right-&gt;resolvableType());
 578         }), right);
 579     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 580         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 581             return matchAndCommit(right, left-&gt;resolvableType());
 582         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 583             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
 584         }), right);
 585     }), left);
 586 }
 587 
 588 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)
 589 {
 590     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 591         if (matches(unnamedType, resolvingType))
 592             return unnamedType.clone();
 593         return WTF::nullopt;
 594     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 595         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
 596     }), resolvingType);
 597 }
 598 
 599 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::NamedType&amp; namedType)
 600 {
 601     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 602         if (matches(resolvingType, namedType))
 603             return resolvingType-&gt;clone();
 604         return WTF::nullopt;
 605     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {
 606         return matchAndCommit(namedType, resolvingType-&gt;resolvableType());
 607     }), resolvingType);
 608 }
 609 
 610 void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 611 {
 612     auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
 613         checkErrorAndVisit(enumerationDefinition.type());
 614         auto&amp; baseType = enumerationDefinition.type().unifyNode();
 615         if (!is&lt;AST::NamedType&gt;(baseType))
 616             return nullptr;
 617         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(baseType);
 618         if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 619             return nullptr;
 620         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 621         if (!nativeTypeDeclaration.isInt())
 622             return nullptr;
 623         return &amp;nativeTypeDeclaration;
 624     })();
 625     if (!baseType) {
 626         setError();
 627         return;
 628     }
 629 
 630     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 631 
 632     for (auto&amp; member : enumerationMembers) {
 633         if (!member.get().value())
 634             continue;
 635 
 636         bool success = false;
 637         member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::Expression&amp; value) {
 638             auto valueInfo = recurseAndGetInfo(value);
 639             if (!valueInfo)
 640                 return;
 641             success = static_cast&lt;bool&gt;(matchAndCommit(valueInfo-&gt;resolvingType, *baseType));
 642         }));
 643         if (!success) {
 644             setError();
 645             return;
 646         }
 647     }
 648 
 649     int64_t nextValue = 0;
 650     for (auto&amp; member : enumerationMembers) {
 651         if (member.get().value()) {
 652             int64_t value;
 653             member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
 654                 value = integerLiteral.valueForSelectedType();
 655             }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
 656                 value = unsignedIntegerLiteral.valueForSelectedType();
 657             }, [&amp;](auto&amp;) {
 658                 ASSERT_NOT_REACHED();
 659             }));
 660             nextValue = baseType-&gt;successor()(value);
 661         } else {
 662             if (nextValue &gt; std::numeric_limits&lt;int&gt;::max()) {
 663                 ASSERT(nextValue &lt;= std::numeric_limits&lt;unsigned&gt;::max());
 664                 member.get().setValue(AST::ConstantExpression(AST::UnsignedIntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;unsigned&gt;(nextValue))));
 665             }
 666             ASSERT(nextValue &gt;= std::numeric_limits&lt;int&gt;::min());
 667             member.get().setValue(AST::ConstantExpression(AST::IntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;int&gt;(nextValue))));
 668             nextValue = baseType-&gt;successor()(nextValue);
 669         }
 670     }
 671 
 672     auto getValue = [&amp;](AST::EnumerationMember&amp; member) -&gt; int64_t {
 673         int64_t value;
 674         ASSERT(member.value());
 675         member.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
 676             value = integerLiteral.value();
 677         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
 678             value = unsignedIntegerLiteral.value();
 679         }, [&amp;](auto&amp;) {
 680             ASSERT_NOT_REACHED();
 681         }));
 682         return value;
 683     };
 684 
 685     for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
 686         auto value = getValue(enumerationMembers[i].get());
 687         for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
 688             auto otherValue = getValue(enumerationMembers[j].get());
 689             if (value == otherValue) {
 690                 setError();
 691                 return;
 692             }
 693         }
 694     }
 695 
 696     bool foundZero = false;
 697     for (auto&amp; member : enumerationMembers) {
 698         if (!getValue(member.get())) {
 699             foundZero = true;
 700             break;
 701         }
 702     }
 703     if (!foundZero) {
 704         setError();
 705         return;
 706     }
 707 }
 708 
 709 void Checker::visit(AST::TypeReference&amp; typeReference)
 710 {
 711     ASSERT(typeReference.resolvedType());
 712 
 713     checkErrorAndVisit(typeReference);
 714 }
 715 
 716 auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;
 717 {
 718     checkErrorAndVisit(expression);
 719     if (!error())
 720         return WTF::nullopt;
 721     return getInfo(expression, requiresLValue);
 722 }
 723 
 724 auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;
 725 {
 726     auto typeIterator = m_typeMap.find(&amp;expression);
 727     ASSERT(typeIterator != m_typeMap.end());
 728 
 729     auto addressSpaceIterator = m_addressSpaceMap.find(&amp;expression);
 730     ASSERT(addressSpaceIterator != m_addressSpaceMap.end());
 731     if (requiresLValue &amp;&amp; !addressSpaceIterator-&gt;value) {
 732         setError();
 733         return WTF::nullopt;
 734     }
 735     return {{ typeIterator-&gt;value, addressSpaceIterator-&gt;value }};
 736 }
 737 
 738 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 739 {
 740     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 741     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 742     checkErrorAndVisit(*variableDeclaration.type());
 743     if (variableDeclaration.initializer()) {
 744         auto&amp; lhsType = *variableDeclaration.type();
 745         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 746         if (!initializerInfo)
 747             return;
 748         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
 749             setError();
 750             return;
 751         }
 752     }
 753 }
 754 
 755 void Checker::assignType(AST::Expression&amp; expression, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; unnamedType, Optional&lt;AST::AddressSpace&gt; addressSpace)
 756 {
 757     auto addResult = m_typeMap.add(&amp;expression, WTFMove(unnamedType));
 758     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 759     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);
 760     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);
 761 }
 762 
 763 void Checker::assignType(AST::Expression&amp; expression, Ref&lt;ResolvableTypeReference&gt;&amp;&amp; resolvableTypeReference, Optional&lt;AST::AddressSpace&gt; addressSpace)
 764 {
 765     auto addResult = m_typeMap.add(&amp;expression, WTFMove(resolvableTypeReference));
 766     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 767     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);
 768     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);
 769 }
 770 
 771 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
 772 {
 773     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
 774     if (!leftInfo)
 775         return;
 776 
 777     auto rightInfo = recurseAndGetInfo(assignmentExpression.right());
 778     if (!rightInfo)
 779         return;
 780 
 781     auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
 782     if (!resultType) {
 783         setError();
 784         return;
 785     }
 786 
 787     assignType(assignmentExpression, WTFMove(*resultType));
 788 }
 789 
 790 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, Optional&lt;AST::AddressSpace&gt; addressSpace)
 791 {
 792     WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; result) {
 793         auto addResult = m_typeMap.add(&amp;expression, result-&gt;clone());
 794         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 795     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; result) {
 796         auto addResult = m_typeMap.add(&amp;expression, result.copyRef());
 797         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 798     }), resolvingType);
 799     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);
 800     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);
 801 }
 802 
 803 void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
 804 {
 805     auto lValueInfo = recurseAndGetInfo(readModifyWriteExpression.lValue(), true);
 806     if (!lValueInfo)
 807         return;
 808 
 809     // FIXME: Figure out what to do with the ReadModifyWriteExpression&#39;s AnonymousVariables.
 810 
 811     auto newValueInfo = recurseAndGetInfo(*readModifyWriteExpression.newValueExpression());
 812     if (!newValueInfo)
 813         return;
 814 
 815     if (!matchAndCommit(lValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType)) {
 816         setError();
 817         return;
 818     }
 819 
 820     auto resultInfo = recurseAndGetInfo(*readModifyWriteExpression.resultExpression());
 821     if (!resultInfo)
 822         return;
 823 
 824     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);
 825 }
 826 
 827 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
 828 {
 829     return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {
 830         return &amp;type;
 831     }, [](Ref&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {
 832         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
 833         return type-&gt;resolvableType().resolvedType();
 834     }), resolvingType);
 835 }
 836 
 837 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
 838 {
 839     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
 840     if (!pointerInfo)
 841         return;
 842 
 843     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
 844 
 845     auto* pointerType = ([&amp;](AST::UnnamedType* unnamedType) -&gt; AST::PointerType* {
 846         if (!unnamedType)
 847             return nullptr;
 848         auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 849         if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 850             return nullptr;
 851         auto&amp; unnamedUnifyType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 852         if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
 853             return nullptr;
 854         return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
 855     })(unnamedType);
 856     if (!pointerType) {
 857         setError();
 858         return;
 859     }
 860 
 861     assignType(dereferenceExpression, pointerType-&gt;clone(), pointerType-&gt;addressSpace());
 862 }
 863 
 864 void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
 865 {
 866     auto lValueInfo = recurseAndGetInfo(makePointerExpression.lValue(), true);
 867     if (!lValueInfo)
 868         return;
 869 
 870     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);
 871     if (!lValueType) {
 872         setError();
 873         return;
 874     }
 875 
 876     assignType(makePointerExpression, makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(makePointerExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));
 877 }
 878 
 879 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
 880 {
 881     auto lValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.lValue());
 882     if (!lValueInfo)
 883         return;
 884 
 885     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);
 886     if (!lValueType) {
 887         setError();
 888         return;
 889     }
 890 
 891     auto&amp; unifyNode = lValueType-&gt;unifyNode();
 892     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
 893         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 894         if (is&lt;AST::PointerType&gt;(unnamedType)) {
 895             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
 896             // FIXME: Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.
 897             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), pointerType.addressSpace(), pointerType.elementType().clone()));
 898             return;
 899         }
 900 
 901         if (!lValueInfo-&gt;addressSpace) {
 902             setError();
 903             return;
 904         }
 905 
 906         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
 907             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
 908             // FIXME: Save the number of elements.
 909             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, arrayType.type().clone()));
 910             return;
 911         }
 912     }
 913 
 914     if (!lValueInfo-&gt;addressSpace) {
 915         setError();
 916         return;
 917     }
 918 
 919     assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));
 920 }
 921 
 922 void Checker::finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType)
 923 {
 924     Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;
 925     using OverloadResolution = std::tuple&lt;AST::FunctionDeclaration*, AST::UnnamedType*&gt;;
 926 
 927     AST::FunctionDeclaration* getFunction;
 928     AST::UnnamedType* getReturnType;
 929     std::tie(getFunction, getReturnType) = ([&amp;]() -&gt; OverloadResolution {
 930         ResolvingType getArgumentType1(wrappedBaseType.clone());
 931         Optional&lt;ResolvingType&gt; getArgumentType2;
 932         if (extraArgumentType)
 933             getArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());
 934 
 935         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getArgumentTypes;
 936         getArgumentTypes.append(getArgumentType1);
 937         if (getArgumentType2)
 938             getArgumentTypes.append(*getArgumentType2);
 939 
 940         auto* getFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleGetOverloads(), getArgumentTypes, castReturnType);
 941         if (!getFunction)
 942             return std::make_pair(nullptr, nullptr);
 943         return std::make_pair(getFunction, &amp;getFunction-&gt;type());
 944     })();
 945 
 946     AST::FunctionDeclaration* andFunction;
 947     AST::UnnamedType* andReturnType;
 948     std::tie(andFunction, andReturnType) = ([&amp;]() -&gt; OverloadResolution {
 949         auto computeAndArgumentType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; Optional&lt;ResolvingType&gt; {
 950             if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))
 951                 return { unnamedType.clone() };
 952             if (is&lt;AST::ArrayType&gt;(unnamedType))
 953                 return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };
 954             if (is&lt;AST::PointerType&gt;(unnamedType))
 955                 return WTF::nullopt;
 956             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };
 957         };
 958         auto computeAndReturnType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; AST::UnnamedType* {
 959             if (is&lt;AST::PointerType&gt;(unnamedType))
 960                 return &amp;downcast&lt;AST::PointerType&gt;(unnamedType).elementType();
 961             return nullptr;
 962         };
 963 
 964         auto andArgumentType1 = computeAndArgumentType(wrappedBaseType);
 965         if (!andArgumentType1)
 966             return std::make_pair(nullptr, nullptr);
 967         Optional&lt;ResolvingType&gt; andArgumentType2;
 968         if (extraArgumentType)
 969             andArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());
 970 
 971         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; andArgumentTypes;
 972         andArgumentTypes.append(*andArgumentType1);
 973         if (andArgumentType2)
 974             andArgumentTypes.append(*andArgumentType2);
 975 
 976         auto* andFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleAndOverloads(), andArgumentTypes, castReturnType);
 977         if (!andFunction)
 978             return std::make_pair(nullptr, nullptr);
 979         return std::make_pair(andFunction, computeAndReturnType(andFunction-&gt;type()));
 980     })();
 981 
 982     if (!getReturnType &amp;&amp; !andReturnType) {
 983         setError();
 984         return;
 985     }
 986 
 987     if (getReturnType &amp;&amp; andReturnType &amp;&amp; !matches(*getReturnType, *andReturnType)) {
 988         setError();
 989         return;
 990     }
 991 
 992     AST::FunctionDeclaration* setFunction;
 993     AST::UnnamedType* setReturnType;
 994     std::tie(setFunction, setReturnType) = ([&amp;]() -&gt; OverloadResolution {
 995         ResolvingType setArgument1Type(wrappedBaseType.clone());
 996         Optional&lt;ResolvingType&gt; setArgumentType2;
 997         if (extraArgumentType)
 998             setArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());
 999         ResolvingType setArgument3Type(getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone());
1000 
1001         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setArgumentTypes;
1002         setArgumentTypes.append(setArgument1Type);
1003         if (setArgumentType2)
1004             setArgumentTypes.append(*setArgumentType2);
1005         setArgumentTypes.append(setArgument3Type);
1006 
1007         auto* setFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleSetOverloads(), setArgumentTypes, castReturnType);
1008         if (!setFunction)
1009             return std::make_pair(nullptr, nullptr);
1010         return std::make_pair(setFunction, &amp;setFunction-&gt;type());
1011     })();
1012 
1013     if (setFunction) {
1014         if (!matches(setFunction-&gt;type(), wrappedBaseType)) {
1015             setError();
1016             return;
1017         }
1018     }
1019 
1020     Optional&lt;AST::AddressSpace&gt; addressSpace;
1021     if (getReturnType || andReturnType) {
1022         // FIXME: The reference compiler has &quot;else if (!node.base.isLValue &amp;&amp; !baseType.isArrayRef)&quot;,
1023         // but I don&#39;t understand why it exists. I haven&#39;t written it here, and I&#39;ll investigate
1024         // if we can remove it from the reference compiler.
1025         if (is&lt;AST::ReferenceType&gt;(wrappedBaseType))
1026             addressSpace = downcast&lt;AST::ReferenceType&gt;(wrappedBaseType).addressSpace();
1027         else {
1028             auto addressSpaceIterator = m_addressSpaceMap.find(&amp;propertyAccessExpression.base());
1029             ASSERT(addressSpaceIterator != m_addressSpaceMap.end());
1030             if (addressSpaceIterator-&gt;value)
1031                 addressSpace = *addressSpaceIterator-&gt;value;
1032             else {
1033                 setError();
1034                 return;
1035             }
1036         }
1037     }
1038 
1039     // FIXME: Generate the call expressions
1040 
1041     assignType(propertyAccessExpression, getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone(), addressSpace);
1042 }
1043 
1044 Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; Checker::recurseAndWrapBaseType(AST::PropertyAccessExpression&amp; propertyAccessExpression)
1045 {
1046     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());
1047     if (!baseInfo)
1048         return WTF::nullopt;
1049 
1050     auto* baseType = getUnnamedType(baseInfo-&gt;resolvingType);
1051     if (!baseType) {
1052         setError();
1053         return WTF::nullopt;
1054     }
1055     auto&amp; baseUnifyNode = baseType-&gt;unifyNode();
1056     if (is&lt;AST::UnnamedType&gt;(baseUnifyNode))
1057         return downcast&lt;AST::UnnamedType&gt;(baseUnifyNode).clone();
1058     ASSERT(is&lt;AST::NamedType&gt;(baseUnifyNode));
1059     return { AST::TypeReference::wrap(Lexer::Token(propertyAccessExpression.origin()), downcast&lt;AST::NamedType&gt;(baseUnifyNode)) };
1060 }
1061 
1062 void Checker::visit(AST::DotExpression&amp; dotExpression)
1063 {
1064     auto baseType = recurseAndWrapBaseType(dotExpression);
1065     if (!baseType)
1066         return;
1067 
1068     finishVisitingPropertyAccess(dotExpression, *baseType);
1069 }
1070 
1071 void Checker::visit(AST::IndexExpression&amp; indexExpression)
1072 {
1073     auto baseType = recurseAndWrapBaseType(indexExpression);
1074     if (!baseType)
1075         return;
1076 
1077     auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());
1078     if (!indexInfo)
1079         return;
1080     auto indexExpressionType = getUnnamedType(indexInfo-&gt;resolvingType);
1081     if (!indexExpressionType) {
1082         setError();
1083         return;
1084     }
1085 
1086     finishVisitingPropertyAccess(indexExpression, WTFMove(*baseType), indexExpressionType);
1087 }
1088 
1089 void Checker::visit(AST::VariableReference&amp; variableReference)
1090 {
1091     ASSERT(variableReference.variable());
1092     ASSERT(variableReference.variable()-&gt;type());
1093 
1094     Optional&lt;AST::AddressSpace&gt; addressSpace;
1095     if (!variableReference.variable()-&gt;isAnonymous())
1096         addressSpace = AST::AddressSpace::Thread;
1097     assignType(variableReference, variableReference.variable()-&gt;type()-&gt;clone(), addressSpace);
1098 }
1099 
1100 void Checker::visit(AST::Return&amp; returnStatement)
1101 {
1102     ASSERT(returnStatement.function());
1103     if (returnStatement.value()) {
1104         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1105         if (!valueInfo)
1106             return;
1107         if (!matchAndCommit(valueInfo-&gt;resolvingType, returnStatement.function()-&gt;type()))
1108             setError();
1109         return;
1110     }
1111 
1112     if (!matches(returnStatement.function()-&gt;type(), m_intrinsics.voidType()))
1113         setError();
1114 }
1115 
1116 void Checker::visit(AST::PointerType&amp;)
1117 {
1118     // Following pointer types can cause infinite loops because of data structures
1119     // like linked lists.
1120     // FIXME: Make sure this function should be empty
1121 }
1122 
1123 void Checker::visit(AST::ArrayReferenceType&amp;)
1124 {
1125     // Following array reference types can cause infinite loops because of data
1126     // structures like linked lists.
1127     // FIXME: Make sure this function should be empty
1128 }
1129 
1130 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1131 {
1132     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1133 }
1134 
1135 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1136 {
1137     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1138 }
1139 
1140 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1141 {
1142     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1143 }
1144 
1145 void Checker::visit(AST::NullLiteral&amp; nullLiteral)
1146 {
1147     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
1148 }
1149 
1150 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1151 {
1152     assignType(booleanLiteral, AST::TypeReference::wrap(Lexer::Token(booleanLiteral.origin()), m_intrinsics.boolType()));
1153 }
1154 
1155 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1156 {
1157     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1158     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
1159     assignType(enumerationMemberLiteral, AST::TypeReference::wrap(Lexer::Token(enumerationMemberLiteral.origin()), enumerationDefinition));
1160 }
1161 
1162 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1163 {
1164     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {
1165         return matches(left, m_intrinsics.boolType());
1166     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {
1167         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
1168     }), resolvingType);
1169 }
1170 
1171 bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
1172 {
1173     auto expressionInfo = recurseAndGetInfo(expression);
1174     if (!expressionInfo)
1175         return false;
1176     if (!isBoolType(expressionInfo-&gt;resolvingType)) {
1177         setError();
1178         return false;
1179     }
1180     return true;
1181 }
1182 
1183 void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
1184 {
1185     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
1186         return;
1187     assignType(logicalNotExpression, AST::TypeReference::wrap(Lexer::Token(logicalNotExpression.origin()), m_intrinsics.boolType()));
1188 }
1189 
1190 void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
1191 {
1192     if (!recurseAndRequireBoolType(logicalExpression.left()))
1193         return;
1194     if (!recurseAndRequireBoolType(logicalExpression.right()))
1195         return;
1196     assignType(logicalExpression, AST::TypeReference::wrap(Lexer::Token(logicalExpression.origin()), m_intrinsics.boolType()));
1197 }
1198 
1199 void Checker::visit(AST::IfStatement&amp; ifStatement)
1200 {
1201     if (!recurseAndRequireBoolType(ifStatement.conditional()))
1202         return;
1203     checkErrorAndVisit(ifStatement.body());
1204     if (ifStatement.elseBody())
1205         checkErrorAndVisit(*ifStatement.elseBody());
1206 }
1207 
1208 void Checker::visit(AST::WhileLoop&amp; whileLoop)
1209 {
1210     if (!recurseAndRequireBoolType(whileLoop.conditional()))
1211         return;
1212     checkErrorAndVisit(whileLoop.body());
1213 }
1214 
1215 void Checker::visit(AST::DoWhileLoop&amp; doWhileLoop)
1216 {
1217     checkErrorAndVisit(doWhileLoop.body());
1218     recurseAndRequireBoolType(doWhileLoop.conditional());
1219 }
1220 
1221 void Checker::visit(AST::ForLoop&amp; forLoop)
1222 {
1223     WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {
1224         checkErrorAndVisit(variableDeclarationsStatement);
1225     }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {
1226         checkErrorAndVisit(expression);
1227     }), forLoop.initialization());
1228     if (error())
1229         return;
1230     if (forLoop.condition()) {
1231         if (!recurseAndRequireBoolType(*forLoop.condition()))
1232             return;
1233     }
1234     if (forLoop.increment())
1235         checkErrorAndVisit(*forLoop.increment());
1236     checkErrorAndVisit(forLoop.body());
1237 }
1238 
1239 void Checker::visit(AST::SwitchStatement&amp; switchStatement)
1240 {
1241     auto* valueType = ([&amp;]() -&gt; AST::NamedType* {
1242         auto valueInfo = recurseAndGetInfo(switchStatement.value());
1243         if (!valueInfo)
1244             return nullptr;
1245         auto* valueType = getUnnamedType(valueInfo-&gt;resolvingType);
1246         if (!valueType)
1247             return nullptr;
1248         auto&amp; valueUnifyNode = valueType-&gt;unifyNode();
1249         if (!is&lt;AST::NamedType&gt;(valueUnifyNode))
1250             return nullptr;
1251         auto&amp; valueNamedUnifyNode = downcast&lt;AST::NamedType&gt;(valueUnifyNode);
1252         if (!(is&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode).isInt())
1253             &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
1254             return nullptr;
1255         return &amp;valueNamedUnifyNode;
1256     })();
1257     if (!valueType) {
1258         setError();
1259         return;
1260     }
1261 
1262     bool hasDefault = false;
1263     for (auto&amp; switchCase : switchStatement.switchCases()) {
1264         checkErrorAndVisit(switchCase.block());
1265         if (!switchCase.value()) {
1266             hasDefault = true;
1267             continue;
1268         }
1269         bool success;
1270         switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
1271             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));
1272         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
1273             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
1274         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {
1275             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));
1276         }, [&amp;](AST::NullLiteral&amp; nullLiteral) {
1277             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));
1278         }, [&amp;](AST::BooleanLiteral&amp;) {
1279             success = matches(*valueType, m_intrinsics.boolType());
1280         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1281             ASSERT(enumerationMemberLiteral.enumerationDefinition());
1282             success = matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
1283         }));
1284         if (!success) {
1285             setError();
1286             return;
1287         }
1288     }
1289 
1290     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1291         auto&amp; firstCase = switchStatement.switchCases()[i];
1292         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1293             auto&amp; secondCase = switchStatement.switchCases()[j];
1294 
1295             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1296                 continue;
1297 
1298             if (!static_cast&lt;bool&gt;(firstCase.value())) {
1299                 setError();
1300                 return;
1301             }
1302 
1303             bool success = true;
1304             firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) {
1305                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {
1306                     success = firstIntegerLiteral.value() != secondIntegerLiteral.value();
1307                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {
1308                     success = static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());
1309                 }, [](auto&amp;) {
1310                 }));
1311             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) {
1312                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {
1313                     success = static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());
1314                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {
1315                     success = firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();
1316                 }, [](auto&amp;) {
1317                 }));
1318             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) {
1319                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp;) {
1320                 }, [&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) {
1321                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
1322                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
1323                     success = firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();
1324                 }, [](auto&amp;) {
1325                 }));
1326             }, [](auto&amp;) {
1327             }));
1328         }
1329     }
1330 
1331     if (!hasDefault) {
1332         if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
1333             HashSet&lt;int64_t&gt; values;
1334             bool zeroValueExists;
1335             for (auto&amp; switchCase : switchStatement.switchCases()) {
1336                 int64_t value;
1337                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
1338                     value = integerLiteral.valueForSelectedType();
1339                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
1340                     value = unsignedIntegerLiteral.valueForSelectedType();
1341                 }, [](auto&amp;) {
1342                     ASSERT_NOT_REACHED();
1343                 }));
1344                 if (!value)
1345                     zeroValueExists = true;
1346                 else
1347                     values.add(value);
1348             }
1349             bool success = true;
1350             downcast&lt;AST::NativeTypeDeclaration&gt;(*valueType).iterateAllValues([&amp;](int64_t value) -&gt; bool {
1351                 if (!value) {
1352                     if (!zeroValueExists) {
1353                         success = false;
1354                         return true;
1355                     }
1356                     return false;
1357                 }
1358                 if (!values.contains(value)) {
1359                     success = false;
1360                     return true;
1361                 }
1362                 return false;
1363             });
1364             if (!success) {
1365                 setError();
1366                 return;
1367             }
1368         } else {
1369             ASSERT(is&lt;AST::EnumerationDefinition&gt;(*valueType));
1370             HashSet&lt;AST::EnumerationMember*&gt; values;
1371             for (auto&amp; switchCase : switchStatement.switchCases()) {
1372                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1373                     ASSERT(enumerationMemberLiteral.enumerationMember());
1374                     values.add(enumerationMemberLiteral.enumerationMember());
1375                 }, [](auto&amp;) {
1376                     ASSERT_NOT_REACHED();
1377                 }));
1378             }
1379             for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
1380                 if (!values.contains(&amp;enumerationMember.get())) {
1381                     setError();
1382                     return;
1383                 }
1384             }
1385         }
1386     }
1387 }
1388 
1389 void Checker::visit(AST::CommaExpression&amp; commaExpression)
1390 {
1391     ASSERT(commaExpression.list().size() &gt; 0);
1392     Visitor::visit(commaExpression);
1393     if (error())
1394         return;
1395     auto lastInfo = getInfo(commaExpression.list().last());
1396     forwardType(commaExpression, lastInfo-&gt;resolvingType);
1397 }
1398 
1399 void Checker::visit(AST::TernaryExpression&amp; ternaryExpression)
1400 {
1401     auto predicateInfo = recurseAndRequireBoolType(ternaryExpression.predicate());
1402     if (!predicateInfo)
1403         return;
1404 
1405     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
1406     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
1407 
1408     auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
1409     if (!resultType) {
1410         setError();
1411         return;
1412     }
1413 
1414     assignType(ternaryExpression, WTFMove(*resultType));
1415 }
1416 
1417 void Checker::visit(AST::CallExpression&amp; callExpression)
1418 {
1419     Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
1420     types.reserveInitialCapacity(callExpression.arguments().size());
1421     for (auto&amp; argument : callExpression.arguments()) {
1422         auto argumentInfo = recurseAndGetInfo(argument);
1423         if (!argumentInfo)
1424             return;
1425         types.uncheckedAppend(argumentInfo-&gt;resolvingType);
1426     }
1427     if (callExpression.castReturnType()) {
1428         checkErrorAndVisit(callExpression.castReturnType()-&gt;get());
1429         if (error())
1430             return;
1431     }
1432 
1433     ASSERT(callExpression.hasOverloads());
1434     auto* function = resolveFunctionOverloadImpl(*callExpression.overloads(), types, callExpression.castReturnType());
1435     if (!function) {
1436         if (auto newFunction = resolveByInstantiation(callExpression, types, m_intrinsics)) {
1437             m_program.append(WTFMove(*newFunction));
1438             function = &amp;m_program.nativeFunctionDeclarations().last();
1439         }
1440     }
1441 
1442     if (!function) {
1443         setError();
1444         return;
1445     }
1446 
1447     for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
1448         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i].type())) {
1449             setError();
1450             return;
1451         }
1452     }
1453 
1454     callExpression.setFunction(*function);
1455 
1456     assignType(callExpression, function-&gt;type().clone());
1457 }
1458 
1459 bool check(Program&amp; program)
1460 {
1461     Checker checker(program.intrinsics(), program);
1462     checker.checkErrorAndVisit(program);
1463     if (checker.error())
1464         return false;
1465     return checker.assignTypes();
1466 }
1467 
1468 } // namespace WHLSL
1469 
1470 } // namespace WebCore
1471 
1472 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>