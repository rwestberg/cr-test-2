<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2004 Allan Sandfeld Jensen (kde@carewolf.com)
   6  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2011, 2013 Apple Inc. All rights reserved.
   7  * Copyright (C) 2009 Google Inc. All rights reserved.
   8  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  *
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;RenderObject.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;CSSAnimationController.h&quot;
  32 #include &quot;Editing.h&quot;
  33 #include &quot;FloatQuad.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;FrameSelection.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;GeometryUtilities.h&quot;
  38 #include &quot;GraphicsContext.h&quot;
  39 #include &quot;HTMLElement.h&quot;
  40 #include &quot;HTMLNames.h&quot;
  41 #include &quot;HTMLTableCellElement.h&quot;
  42 #include &quot;HTMLTableElement.h&quot;
  43 #include &quot;HitTestResult.h&quot;
  44 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  45 #include &quot;Page.h&quot;
  46 #include &quot;PseudoElement.h&quot;
  47 #include &quot;RenderChildIterator.h&quot;
  48 #include &quot;RenderCounter.h&quot;
  49 #include &quot;RenderFragmentedFlow.h&quot;
  50 #include &quot;RenderGeometryMap.h&quot;
  51 #include &quot;RenderInline.h&quot;
  52 #include &quot;RenderIterator.h&quot;
  53 #include &quot;RenderLayer.h&quot;
  54 #include &quot;RenderLayerBacking.h&quot;
  55 #include &quot;RenderLayerCompositor.h&quot;
  56 #include &quot;RenderMultiColumnFlow.h&quot;
  57 #include &quot;RenderRuby.h&quot;
  58 #include &quot;RenderSVGBlock.h&quot;
  59 #include &quot;RenderSVGInline.h&quot;
  60 #include &quot;RenderSVGModelObject.h&quot;
  61 #include &quot;RenderSVGResourceContainer.h&quot;
  62 #include &quot;RenderSVGRoot.h&quot;
  63 #include &quot;RenderScrollbarPart.h&quot;
  64 #include &quot;RenderTableRow.h&quot;
  65 #include &quot;RenderTheme.h&quot;
  66 #include &quot;RenderTreeBuilder.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;RenderWidget.h&quot;
  69 #include &quot;SVGRenderSupport.h&quot;
  70 #include &quot;StyleResolver.h&quot;
  71 #include &quot;TransformState.h&quot;
  72 #include &lt;algorithm&gt;
  73 #include &lt;stdio.h&gt;
  74 #include &lt;wtf/IsoMallocInlines.h&gt;
  75 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  76 #include &lt;wtf/text/TextStream.h&gt;
  77 
  78 #if PLATFORM(IOS_FAMILY)
  79 #include &quot;SelectionRect.h&quot;
  80 #endif
  81 
  82 namespace WebCore {
  83 
  84 using namespace HTMLNames;
  85 
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderObject);
  87 
  88 #ifndef NDEBUG
  89 
  90 RenderObject::SetLayoutNeededForbiddenScope::SetLayoutNeededForbiddenScope(RenderObject* renderObject, bool isForbidden)
  91     : m_renderObject(renderObject)
  92     , m_preexistingForbidden(m_renderObject-&gt;isSetNeedsLayoutForbidden())
  93 {
  94     m_renderObject-&gt;setNeedsLayoutIsForbidden(isForbidden);
  95 }
  96 
  97 RenderObject::SetLayoutNeededForbiddenScope::~SetLayoutNeededForbiddenScope()
  98 {
  99     m_renderObject-&gt;setNeedsLayoutIsForbidden(m_preexistingForbidden);
 100 }
 101 #endif
 102 
 103 struct SameSizeAsRenderObject {
 104     virtual ~SameSizeAsRenderObject() = default; // Allocate vtable pointer.
 105 #if !ASSERT_DISABLED
 106     bool weakPtrFactorWasConstructedOnMainThread;
 107 #endif
 108     void* pointers[5];
 109 #ifndef NDEBUG
 110     unsigned m_debugBitfields : 2;
 111 #endif
 112     unsigned m_bitfields;
 113 };
 114 
 115 COMPILE_ASSERT(sizeof(RenderObject) == sizeof(SameSizeAsRenderObject), RenderObject_should_stay_small);
 116 
 117 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, renderObjectCounter, (&quot;RenderObject&quot;));
 118 
 119 void RenderObjectDeleter::operator() (RenderObject* renderer) const
 120 {
 121     renderer-&gt;destroy();
 122 }
 123 
 124 RenderObject::RenderObject(Node&amp; node)
 125     : CachedImageClient()
 126     , m_node(node)
 127     , m_parent(nullptr)
 128     , m_previous(nullptr)
 129     , m_next(nullptr)
 130 #ifndef NDEBUG
 131     , m_hasAXObject(false)
 132     , m_setNeedsLayoutForbidden(false)
 133 #endif
 134     , m_bitfields(node)
 135 {
 136     if (RenderView* renderView = node.document().renderView())
 137         renderView-&gt;didCreateRenderer();
 138 #ifndef NDEBUG
 139     renderObjectCounter.increment();
 140 #endif
 141 }
 142 
 143 RenderObject::~RenderObject()
 144 {
 145     view().didDestroyRenderer();
 146 #ifndef NDEBUG
 147     ASSERT(!m_hasAXObject);
 148     renderObjectCounter.decrement();
 149 #endif
 150     ASSERT(!hasRareData());
 151 }
 152 
 153 RenderTheme&amp; RenderObject::theme() const
 154 {
 155     return RenderTheme::singleton();
 156 }
 157 
 158 bool RenderObject::isDescendantOf(const RenderObject* ancestor) const
 159 {
 160     for (const RenderObject* renderer = this; renderer; renderer = renderer-&gt;m_parent) {
 161         if (renderer == ancestor)
 162             return true;
 163     }
 164     return false;
 165 }
 166 
 167 bool RenderObject::isLegend() const
 168 {
 169     return node() &amp;&amp; node()-&gt;hasTagName(legendTag);
 170 }
 171 
 172 
 173 bool RenderObject::isFieldset() const
 174 {
 175     return node() &amp;&amp; node()-&gt;hasTagName(fieldsetTag);
 176 }
 177 
 178 bool RenderObject::isHTMLMarquee() const
 179 {
 180     return node() &amp;&amp; node()-&gt;renderer() == this &amp;&amp; node()-&gt;hasTagName(marqueeTag);
 181 }
 182 
 183 void RenderObject::setFragmentedFlowStateIncludingDescendants(FragmentedFlowState state)
 184 {
 185     setFragmentedFlowState(state);
 186 
 187     if (!is&lt;RenderElement&gt;(*this))
 188         return;
 189 
 190     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(*this))) {
 191         // If the child is a fragmentation context it already updated the descendants flag accordingly.
 192         if (child.isRenderFragmentedFlow())
 193             continue;
 194         ASSERT(state != child.fragmentedFlowState());
 195         child.setFragmentedFlowStateIncludingDescendants(state);
 196     }
 197 }
 198 
 199 RenderObject::FragmentedFlowState RenderObject::computedFragmentedFlowState(const RenderObject&amp; renderer)
 200 {
 201     if (!renderer.parent())
 202         return renderer.fragmentedFlowState();
 203 
 204     if (is&lt;RenderMultiColumnFlow&gt;(renderer)) {
 205         // Multicolumn flows do not inherit the flow state.
 206         return InsideInFragmentedFlow;
 207     }
 208 
 209     auto inheritedFlowState = RenderObject::NotInsideFragmentedFlow;
 210     if (is&lt;RenderText&gt;(renderer))
 211         inheritedFlowState = renderer.parent()-&gt;fragmentedFlowState();
 212     else if (is&lt;RenderSVGBlock&gt;(renderer) || is&lt;RenderSVGInline&gt;(renderer) || is&lt;RenderSVGModelObject&gt;(renderer)) {
 213         // containingBlock() skips svg boundary (SVG root is a RenderReplaced).
 214         if (auto* svgRoot = SVGRenderSupport::findTreeRootObject(downcast&lt;RenderElement&gt;(renderer)))
 215             inheritedFlowState = svgRoot-&gt;fragmentedFlowState();
 216     } else if (auto* container = renderer.container())
 217         inheritedFlowState = container-&gt;fragmentedFlowState();
 218     else {
 219         // Splitting lines or doing continuation, so just keep the current state.
 220         inheritedFlowState = renderer.fragmentedFlowState();
 221     }
 222     return inheritedFlowState;
 223 }
 224 
 225 void RenderObject::initializeFragmentedFlowStateOnInsertion()
 226 {
 227     ASSERT(parent());
 228 
 229     // A RenderFragmentedFlow is always considered to be inside itself, so it never has to change its state in response to parent changes.
 230     if (isRenderFragmentedFlow())
 231         return;
 232 
 233     auto computedState = computedFragmentedFlowState(*this);
 234     if (fragmentedFlowState() == computedState)
 235         return;
 236 
 237     setFragmentedFlowStateIncludingDescendants(computedState);
 238 }
 239 
 240 void RenderObject::resetFragmentedFlowStateOnRemoval()
 241 {
 242     if (fragmentedFlowState() == NotInsideFragmentedFlow)
 243         return;
 244 
 245     if (!renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderElement&gt;(*this)) {
 246         downcast&lt;RenderElement&gt;(*this).removeFromRenderFragmentedFlow();
 247         return;
 248     }
 249 
 250     // A RenderFragmentedFlow is always considered to be inside itself, so it never has to change its state in response to parent changes.
 251     if (isRenderFragmentedFlow())
 252         return;
 253 
 254     setFragmentedFlowStateIncludingDescendants(NotInsideFragmentedFlow);
 255 }
 256 
 257 void RenderObject::setParent(RenderElement* parent)
 258 {
 259     m_parent = parent;
 260 }
 261 
 262 RenderObject* RenderObject::nextInPreOrder() const
 263 {
 264     if (RenderObject* o = firstChildSlow())
 265         return o;
 266 
 267     return nextInPreOrderAfterChildren();
 268 }
 269 
 270 RenderObject* RenderObject::nextInPreOrderAfterChildren() const
 271 {
 272     RenderObject* o;
 273     if (!(o = nextSibling())) {
 274         o = parent();
 275         while (o &amp;&amp; !o-&gt;nextSibling())
 276             o = o-&gt;parent();
 277         if (o)
 278             o = o-&gt;nextSibling();
 279     }
 280 
 281     return o;
 282 }
 283 
 284 RenderObject* RenderObject::nextInPreOrder(const RenderObject* stayWithin) const
 285 {
 286     if (RenderObject* o = firstChildSlow())
 287         return o;
 288 
 289     return nextInPreOrderAfterChildren(stayWithin);
 290 }
 291 
 292 RenderObject* RenderObject::nextInPreOrderAfterChildren(const RenderObject* stayWithin) const
 293 {
 294     if (this == stayWithin)
 295         return nullptr;
 296 
 297     const RenderObject* current = this;
 298     RenderObject* next;
 299     while (!(next = current-&gt;nextSibling())) {
 300         current = current-&gt;parent();
 301         if (!current || current == stayWithin)
 302             return nullptr;
 303     }
 304     return next;
 305 }
 306 
 307 RenderObject* RenderObject::previousInPreOrder() const
 308 {
 309     if (RenderObject* o = previousSibling()) {
 310         while (RenderObject* last = o-&gt;lastChildSlow())
 311             o = last;
 312         return o;
 313     }
 314 
 315     return parent();
 316 }
 317 
 318 RenderObject* RenderObject::previousInPreOrder(const RenderObject* stayWithin) const
 319 {
 320     if (this == stayWithin)
 321         return nullptr;
 322 
 323     return previousInPreOrder();
 324 }
 325 
 326 RenderObject* RenderObject::childAt(unsigned index) const
 327 {
 328     RenderObject* child = firstChildSlow();
 329     for (unsigned i = 0; child &amp;&amp; i &lt; index; i++)
 330         child = child-&gt;nextSibling();
 331     return child;
 332 }
 333 
 334 RenderObject* RenderObject::firstLeafChild() const
 335 {
 336     RenderObject* r = firstChildSlow();
 337     while (r) {
 338         RenderObject* n = nullptr;
 339         n = r-&gt;firstChildSlow();
 340         if (!n)
 341             break;
 342         r = n;
 343     }
 344     return r;
 345 }
 346 
 347 RenderObject* RenderObject::lastLeafChild() const
 348 {
 349     RenderObject* r = lastChildSlow();
 350     while (r) {
 351         RenderObject* n = nullptr;
 352         n = r-&gt;lastChildSlow();
 353         if (!n)
 354             break;
 355         r = n;
 356     }
 357     return r;
 358 }
 359 
 360 #if ENABLE(TEXT_AUTOSIZING)
 361 
 362 // Non-recursive version of the DFS search.
 363 RenderObject* RenderObject::traverseNext(const RenderObject* stayWithin, HeightTypeTraverseNextInclusionFunction inclusionFunction, int&amp; currentDepth, int&amp; newFixedDepth) const
 364 {
 365     BlockContentHeightType overflowType;
 366 
 367     // Check for suitable children.
 368     for (RenderObject* child = firstChildSlow(); child; child = child-&gt;nextSibling()) {
 369         overflowType = inclusionFunction(*child);
 370         if (overflowType != FixedHeight) {
 371             currentDepth++;
 372             if (overflowType == OverflowHeight)
 373                 newFixedDepth = currentDepth;
 374             ASSERT(!stayWithin || child-&gt;isDescendantOf(stayWithin));
 375             return child;
 376         }
 377     }
 378 
 379     if (this == stayWithin)
 380         return nullptr;
 381 
 382     // Now we traverse other nodes if they exist, otherwise
 383     // we go to the parent node and try doing the same.
 384     const RenderObject* n = this;
 385     while (n) {
 386         while (n &amp;&amp; !n-&gt;nextSibling() &amp;&amp; (!stayWithin || n-&gt;parent() != stayWithin)) {
 387             n = n-&gt;parent();
 388             currentDepth--;
 389         }
 390         if (!n)
 391             return nullptr;
 392         for (RenderObject* sibling = n-&gt;nextSibling(); sibling; sibling = sibling-&gt;nextSibling()) {
 393             overflowType = inclusionFunction(*sibling);
 394             if (overflowType != FixedHeight) {
 395                 if (overflowType == OverflowHeight)
 396                     newFixedDepth = currentDepth;
 397                 ASSERT(!stayWithin || !n-&gt;nextSibling() || n-&gt;nextSibling()-&gt;isDescendantOf(stayWithin));
 398                 return sibling;
 399             }
 400         }
 401         if (!stayWithin || n-&gt;parent() != stayWithin) {
 402             n = n-&gt;parent();
 403             currentDepth--;
 404         } else
 405             return nullptr;
 406     }
 407     return nullptr;
 408 }
 409 
 410 #endif // ENABLE(TEXT_AUTOSIZING)
 411 
 412 RenderLayer* RenderObject::enclosingLayer() const
 413 {
 414     for (auto&amp; renderer : lineageOfType&lt;RenderLayerModelObject&gt;(*this)) {
 415         if (renderer.hasLayer())
 416             return renderer.layer();
 417     }
 418     return nullptr;
 419 }
 420 
 421 bool RenderObject::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
 422 {
 423     if (options.revealMode == SelectionRevealMode::DoNotReveal)
 424         return false;
 425 
 426     RenderLayer* enclosingLayer = this-&gt;enclosingLayer();
 427     if (!enclosingLayer)
 428         return false;
 429 
 430     enclosingLayer-&gt;scrollRectToVisible(absoluteRect, insideFixed, options);
 431     return true;
 432 }
 433 
 434 RenderBox&amp; RenderObject::enclosingBox() const
 435 {
 436     return *lineageOfType&lt;RenderBox&gt;(const_cast&lt;RenderObject&amp;&gt;(*this)).first();
 437 }
 438 
 439 RenderBoxModelObject&amp; RenderObject::enclosingBoxModelObject() const
 440 {
 441     return *lineageOfType&lt;RenderBoxModelObject&gt;(const_cast&lt;RenderObject&amp;&gt;(*this)).first();
 442 }
 443 
 444 const RenderBox* RenderObject::enclosingScrollableContainerForSnapping() const
 445 {
 446     auto&amp; renderBox = enclosingBox();
 447     if (auto* scrollableContainer = renderBox.findEnclosingScrollableContainer()) {
 448         // The scrollable container for snapping cannot be the node itself.
 449         if (scrollableContainer != this)
 450             return scrollableContainer;
 451         if (renderBox.parentBox())
 452             return renderBox.parentBox()-&gt;findEnclosingScrollableContainer();
 453     }
 454     return nullptr;
 455 }
 456 
 457 RenderBlock* RenderObject::firstLineBlock() const
 458 {
 459     return nullptr;
 460 }
 461 
 462 static inline bool objectIsRelayoutBoundary(const RenderElement* object)
 463 {
 464     // FIXME: In future it may be possible to broaden these conditions in order to improve performance.
 465     if (object-&gt;isRenderView())
 466         return true;
 467 
 468     if (object-&gt;isTextControl())
 469         return true;
 470 
 471     if (object-&gt;isSVGRoot())
 472         return true;
 473 
 474     if (!object-&gt;hasOverflowClip())
 475         return false;
 476 
 477     if (object-&gt;style().width().isIntrinsicOrAuto() || object-&gt;style().height().isIntrinsicOrAuto() || object-&gt;style().height().isPercentOrCalculated())
 478         return false;
 479 
 480     // Table parts can&#39;t be relayout roots since the table is responsible for layouting all the parts.
 481     if (object-&gt;isTablePart())
 482         return false;
 483 
 484     return true;
 485 }
 486 
 487 void RenderObject::clearNeedsLayout()
 488 {
 489     m_bitfields.setNeedsLayout(false);
 490     setEverHadLayout(true);
 491     setPosChildNeedsLayoutBit(false);
 492     setNeedsSimplifiedNormalFlowLayoutBit(false);
 493     setNormalChildNeedsLayoutBit(false);
 494     setNeedsPositionedMovementLayoutBit(false);
 495     if (is&lt;RenderElement&gt;(*this))
 496         downcast&lt;RenderElement&gt;(*this).setAncestorLineBoxDirty(false);
 497 #ifndef NDEBUG
 498     checkBlockPositionedObjectsNeedLayout();
 499 #endif
 500 }
 501 
 502 static void scheduleRelayoutForSubtree(RenderElement&amp; renderer)
 503 {
 504     if (is&lt;RenderView&gt;(renderer)) {
 505         downcast&lt;RenderView&gt;(renderer).frameView().layoutContext().scheduleLayout();
 506         return;
 507     }
 508 
 509     if (renderer.isRooted())
 510         renderer.view().frameView().layoutContext().scheduleSubtreeLayout(renderer);
 511 }
 512 
 513 void RenderObject::markContainingBlocksForLayout(ScheduleRelayout scheduleRelayout, RenderElement* newRoot)
 514 {
 515     ASSERT(scheduleRelayout == ScheduleRelayout::No || !newRoot);
 516     ASSERT(!isSetNeedsLayoutForbidden());
 517 
 518     auto ancestor = container();
 519 
 520     bool simplifiedNormalFlowLayout = needsSimplifiedNormalFlowLayout() &amp;&amp; !selfNeedsLayout() &amp;&amp; !normalChildNeedsLayout();
 521     bool hasOutOfFlowPosition = !isText() &amp;&amp; style().hasOutOfFlowPosition();
 522 
 523     while (ancestor) {
 524 #ifndef NDEBUG
 525         // FIXME: Remove this once we remove the special cases for counters, quotes and mathml
 526         // calling setNeedsLayout during preferred width computation.
 527         SetLayoutNeededForbiddenScope layoutForbiddenScope(ancestor, isSetNeedsLayoutForbidden());
 528 #endif
 529         // Don&#39;t mark the outermost object of an unrooted subtree. That object will be
 530         // marked when the subtree is added to the document.
 531         auto container = ancestor-&gt;container();
 532         if (!container &amp;&amp; !ancestor-&gt;isRenderView())
 533             return;
 534         if (hasOutOfFlowPosition) {
 535             bool willSkipRelativelyPositionedInlines = !ancestor-&gt;isRenderBlock() || ancestor-&gt;isAnonymousBlock();
 536             // Skip relatively positioned inlines and anonymous blocks to get to the enclosing RenderBlock.
 537             while (ancestor &amp;&amp; (!ancestor-&gt;isRenderBlock() || ancestor-&gt;isAnonymousBlock()))
 538                 ancestor = ancestor-&gt;container();
 539             if (!ancestor || ancestor-&gt;posChildNeedsLayout())
 540                 return;
 541             if (willSkipRelativelyPositionedInlines)
 542                 container = ancestor-&gt;container();
 543             ancestor-&gt;setPosChildNeedsLayoutBit(true);
 544             simplifiedNormalFlowLayout = true;
 545         } else if (simplifiedNormalFlowLayout) {
 546             if (ancestor-&gt;needsSimplifiedNormalFlowLayout())
 547                 return;
 548             ancestor-&gt;setNeedsSimplifiedNormalFlowLayoutBit(true);
 549         } else {
 550             if (ancestor-&gt;normalChildNeedsLayout())
 551                 return;
 552             ancestor-&gt;setNormalChildNeedsLayoutBit(true);
 553         }
 554         ASSERT(!ancestor-&gt;isSetNeedsLayoutForbidden());
 555 
 556         if (ancestor == newRoot)
 557             return;
 558 
 559         if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; objectIsRelayoutBoundary(ancestor))
 560             break;
 561 
 562         hasOutOfFlowPosition = ancestor-&gt;style().hasOutOfFlowPosition();
 563         ancestor = container;
 564     }
 565 
 566     if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; ancestor)
 567         scheduleRelayoutForSubtree(*ancestor);
 568 }
 569 
 570 #ifndef NDEBUG
 571 void RenderObject::checkBlockPositionedObjectsNeedLayout()
 572 {
 573     ASSERT(!needsLayout());
 574 
 575     if (is&lt;RenderBlock&gt;(*this))
 576         downcast&lt;RenderBlock&gt;(*this).checkPositionedObjectsNeedLayout();
 577 }
 578 #endif
 579 
 580 void RenderObject::setPreferredLogicalWidthsDirty(bool shouldBeDirty, MarkingBehavior markParents)
 581 {
 582     bool alreadyDirty = preferredLogicalWidthsDirty();
 583     m_bitfields.setPreferredLogicalWidthsDirty(shouldBeDirty);
 584     if (shouldBeDirty &amp;&amp; !alreadyDirty &amp;&amp; markParents == MarkContainingBlockChain &amp;&amp; (isText() || !style().hasOutOfFlowPosition()))
 585         invalidateContainerPreferredLogicalWidths();
 586 }
 587 
 588 void RenderObject::invalidateContainerPreferredLogicalWidths()
 589 {
 590     // In order to avoid pathological behavior when inlines are deeply nested, we do include them
 591     // in the chain that we mark dirty (even though they&#39;re kind of irrelevant).
 592     auto o = isTableCell() ? containingBlock() : container();
 593     while (o &amp;&amp; !o-&gt;preferredLogicalWidthsDirty()) {
 594         // Don&#39;t invalidate the outermost object of an unrooted subtree. That object will be
 595         // invalidated when the subtree is added to the document.
 596         auto container = o-&gt;isTableCell() ? o-&gt;containingBlock() : o-&gt;container();
 597         if (!container &amp;&amp; !o-&gt;isRenderView())
 598             break;
 599 
 600         o-&gt;m_bitfields.setPreferredLogicalWidthsDirty(true);
 601         if (o-&gt;style().hasOutOfFlowPosition())
 602             // A positioned object has no effect on the min/max width of its containing block ever.
 603             // We can optimize this case and not go up any further.
 604             break;
 605         o = container;
 606     }
 607 }
 608 
 609 void RenderObject::setLayerNeedsFullRepaint()
 610 {
 611     ASSERT(hasLayer());
 612     downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;setRepaintStatus(NeedsFullRepaint);
 613 }
 614 
 615 void RenderObject::setLayerNeedsFullRepaintForPositionedMovementLayout()
 616 {
 617     ASSERT(hasLayer());
 618     downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;setRepaintStatus(NeedsFullRepaintForPositionedMovementLayout);
 619 }
 620 
 621 RenderBlock* RenderObject::containingBlock() const
 622 {
 623     auto containingBlockForRenderer = [](const RenderElement&amp; renderer)
 624     {
 625         if (renderer.isAbsolutelyPositioned())
 626             return renderer.containingBlockForAbsolutePosition();
 627         if (renderer.isFixedPositioned())
 628             return renderer.containingBlockForFixedPosition();
 629         return renderer.containingBlockForObjectInFlow();
 630     };
 631 
 632     if (is&lt;RenderText&gt;(*this))
 633         return containingBlockForObjectInFlow();
 634 
 635     if (!parent() &amp;&amp; is&lt;RenderScrollbarPart&gt;(*this)) {
 636         if (auto* scrollbarPart = downcast&lt;RenderScrollbarPart&gt;(*this).rendererOwningScrollbar())
 637             return containingBlockForRenderer(*scrollbarPart);
 638         return nullptr;
 639     }
 640     return containingBlockForRenderer(downcast&lt;RenderElement&gt;(*this));
 641 }
 642 
 643 RenderBlock* RenderObject::containingBlockForObjectInFlow() const
 644 {
 645     auto* renderer = parent();
 646     while (renderer &amp;&amp; ((renderer-&gt;isInline() &amp;&amp; !renderer-&gt;isReplaced()) || !renderer-&gt;isRenderBlock()))
 647         renderer = renderer-&gt;parent();
 648     return downcast&lt;RenderBlock&gt;(renderer);
 649 }
 650 
 651 void RenderObject::addPDFURLRect(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 652 {
 653     Vector&lt;LayoutRect&gt; focusRingRects;
 654     addFocusRingRects(focusRingRects, paintOffset, paintInfo.paintContainer);
 655     LayoutRect urlRect = unionRect(focusRingRects);
 656 
 657     if (urlRect.isEmpty())
 658         return;
 659     Node* node = this-&gt;node();
 660     if (!is&lt;Element&gt;(node) || !node-&gt;isLink())
 661         return;
 662     Element&amp; element = downcast&lt;Element&gt;(*node);
 663     const AtomString&amp; href = element.getAttribute(hrefAttr);
 664     if (href.isNull())
 665         return;
 666 
 667     if (paintInfo.context().supportsInternalLinks()) {
 668         String outAnchorName;
 669         Element* linkTarget = element.findAnchorElementForLink(outAnchorName);
 670         if (linkTarget) {
 671             paintInfo.context().setDestinationForRect(outAnchorName, urlRect);
 672             return;
 673         }
 674     }
 675 
 676     paintInfo.context().setURLForRect(node-&gt;document().completeURL(href), urlRect);
 677 
 678 }
 679 
 680 #if PLATFORM(IOS_FAMILY)
 681 // This function is similar in spirit to RenderText::absoluteRectsForRange, but returns rectangles
 682 // which are annotated with additional state which helps iOS draw selections in its unique way.
 683 // No annotations are added in this class.
 684 // FIXME: Move to RenderText with absoluteRectsForRange()?
 685 void RenderObject::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned start, unsigned end)
 686 {
 687     Vector&lt;FloatQuad&gt; quads;
 688 
 689     if (!firstChildSlow()) {
 690         // FIXME: WebKit&#39;s position for an empty span after a BR is incorrect, so we can&#39;t trust
 691         // quads for them. We don&#39;t need selection rects for those anyway though, since they
 692         // are just empty containers. See &lt;https://bugs.webkit.org/show_bug.cgi?id=49358&gt;.
 693         RenderObject* previous = previousSibling();
 694         Node* node = this-&gt;node();
 695         if (!previous || !previous-&gt;isBR() || !node || !node-&gt;isContainerNode() || !isInline()) {
 696             // For inline elements we don&#39;t use absoluteQuads, since it takes into account continuations and leads to wrong results.
 697             absoluteQuadsForSelection(quads);
 698         }
 699     } else {
 700         unsigned offset = start;
 701         for (RenderObject* child = childAt(start); child &amp;&amp; offset &lt; end; child = child-&gt;nextSibling(), ++offset)
 702             child-&gt;absoluteQuads(quads);
 703     }
 704 
 705     unsigned numberOfQuads = quads.size();
 706     for (unsigned i = 0; i &lt; numberOfQuads; ++i)
 707         rects.append(SelectionRect(quads[i].enclosingBoundingBox(), isHorizontalWritingMode(), view().pageNumberForBlockProgressionOffset(quads[i].enclosingBoundingBox().x())));
 708 }
 709 #endif
 710 
 711 IntRect RenderObject::absoluteBoundingBoxRect(bool useTransforms, bool* wasFixed) const
 712 {
 713     if (useTransforms) {
 714         Vector&lt;FloatQuad&gt; quads;
 715         absoluteQuads(quads, wasFixed);
 716 
 717         size_t n = quads.size();
 718         if (!n)
 719             return IntRect();
 720 
 721         IntRect result = quads[0].enclosingBoundingBox();
 722         for (size_t i = 1; i &lt; n; ++i)
 723             result.unite(quads[i].enclosingBoundingBox());
 724         return result;
 725     }
 726 
 727     FloatPoint absPos = localToAbsolute(FloatPoint(), 0 /* ignore transforms */, wasFixed);
 728     Vector&lt;IntRect&gt; rects;
 729     absoluteRects(rects, flooredLayoutPoint(absPos));
 730 
 731     size_t n = rects.size();
 732     if (!n)
 733         return IntRect();
 734 
 735     LayoutRect result = rects[0];
 736     for (size_t i = 1; i &lt; n; ++i)
 737         result.unite(rects[i]);
 738     return snappedIntRect(result);
 739 }
 740 
 741 void RenderObject::absoluteFocusRingQuads(Vector&lt;FloatQuad&gt;&amp; quads)
 742 {
 743     Vector&lt;LayoutRect&gt; rects;
 744     // FIXME: addFocusRingRects() needs to be passed this transform-unaware
 745     // localToAbsolute() offset here because RenderInline::addFocusRingRects()
 746     // implicitly assumes that. This doesn&#39;t work correctly with transformed
 747     // descendants.
 748     FloatPoint absolutePoint = localToAbsolute();
 749     addFocusRingRects(rects, flooredLayoutPoint(absolutePoint));
 750     float deviceScaleFactor = document().deviceScaleFactor();
 751     for (auto rect : rects) {
 752         rect.moveBy(LayoutPoint(-absolutePoint));
 753         quads.append(localToAbsoluteQuad(FloatQuad(snapRectToDevicePixels(rect, deviceScaleFactor))));
 754     }
 755 }
 756 
 757 FloatRect RenderObject::absoluteBoundingBoxRectForRange(const Range* range)
 758 {
 759     if (!range)
 760         return FloatRect();
 761 
 762     range-&gt;ownerDocument().updateLayout();
 763 
 764     Vector&lt;FloatQuad&gt; quads;
 765     range-&gt;absoluteTextQuads(quads);
 766 
 767     if (quads.isEmpty())
 768         return FloatRect();
 769 
 770     FloatRect result = quads[0].boundingBox();
 771     for (size_t i = 1; i &lt; quads.size(); ++i)
 772         result.uniteEvenIfEmpty(quads[i].boundingBox());
 773 
 774     return result;
 775 }
 776 
 777 void RenderObject::addAbsoluteRectForLayer(LayoutRect&amp; result)
 778 {
 779     if (hasLayer())
 780         result.unite(absoluteBoundingBoxRectIgnoringTransforms());
 781 
 782     if (!is&lt;RenderElement&gt;(*this))
 783         return;
 784 
 785     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(*this)))
 786         child.addAbsoluteRectForLayer(result);
 787 }
 788 
 789 // FIXME: change this to use the subtreePaint terminology
 790 LayoutRect RenderObject::paintingRootRect(LayoutRect&amp; topLevelRect)
 791 {
 792     LayoutRect result = absoluteBoundingBoxRectIgnoringTransforms();
 793     topLevelRect = result;
 794     if (is&lt;RenderElement&gt;(*this)) {
 795         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(*this)))
 796             child.addAbsoluteRectForLayer(result);
 797     }
 798     return result;
 799 }
 800 
 801 RenderLayerModelObject* RenderObject::containerForRepaint() const
 802 {
 803     RenderLayerModelObject* repaintContainer = nullptr;
 804 
 805     if (view().usesCompositing()) {
 806         if (RenderLayer* parentLayer = enclosingLayer()) {
 807             RenderLayer* compLayer = parentLayer-&gt;enclosingCompositingLayerForRepaint();
 808             if (compLayer)
 809                 repaintContainer = &amp;compLayer-&gt;renderer();
 810         }
 811     }
 812     if (view().hasSoftwareFilters()) {
 813         if (RenderLayer* parentLayer = enclosingLayer()) {
 814             RenderLayer* enclosingFilterLayer = parentLayer-&gt;enclosingFilterLayer();
 815             if (enclosingFilterLayer)
 816                 return &amp;enclosingFilterLayer-&gt;renderer();
 817         }
 818     }
 819 
 820     // If we have a flow thread, then we need to do individual repaints within the RenderFragmentContainers instead.
 821     // Return the flow thread as a repaint container in order to create a chokepoint that allows us to change
 822     // repainting to do individual region repaints.
 823     RenderFragmentedFlow* parentRenderFragmentedFlow = enclosingFragmentedFlow();
 824     if (parentRenderFragmentedFlow) {
 825         // If we have already found a repaint container then we will repaint into that container only if it is part of the same
 826         // flow thread. Otherwise we will need to catch the repaint call and send it to the flow thread.
 827         RenderFragmentedFlow* repaintContainerFragmentedFlow = repaintContainer ? repaintContainer-&gt;enclosingFragmentedFlow() : nullptr;
 828         if (!repaintContainerFragmentedFlow || repaintContainerFragmentedFlow != parentRenderFragmentedFlow)
 829             repaintContainer = parentRenderFragmentedFlow;
 830     }
 831     return repaintContainer;
 832 }
 833 
 834 void RenderObject::propagateRepaintToParentWithOutlineAutoIfNeeded(const RenderLayerModelObject&amp; repaintContainer, const LayoutRect&amp; repaintRect) const
 835 {
 836     if (!hasOutlineAutoAncestor())
 837         return;
 838 
 839     // FIXME: We should really propagate only when the child renderer sticks out.
 840     bool repaintRectNeedsConverting = false;
 841     // Issue repaint on the renderer with outline: auto.
 842     for (const auto* renderer = this; renderer; renderer = renderer-&gt;parent()) {
 843         bool rendererHasOutlineAutoAncestor = renderer-&gt;hasOutlineAutoAncestor();
 844         ASSERT(rendererHasOutlineAutoAncestor
 845             || renderer-&gt;outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On
 846             || (is&lt;RenderBoxModelObject&gt;(*renderer) &amp;&amp; downcast&lt;RenderBoxModelObject&gt;(*renderer).isContinuation()));
 847         if (renderer == &amp;repaintContainer &amp;&amp; rendererHasOutlineAutoAncestor)
 848             repaintRectNeedsConverting = true;
 849         if (rendererHasOutlineAutoAncestor)
 850             continue;
 851         // Issue repaint on the correct repaint container.
 852         LayoutRect adjustedRepaintRect = repaintRect;
 853         adjustedRepaintRect.inflate(renderer-&gt;outlineStyleForRepaint().outlineSize());
 854         if (!repaintRectNeedsConverting)
 855             repaintContainer.repaintRectangle(adjustedRepaintRect);
 856         else if (is&lt;RenderLayerModelObject&gt;(renderer)) {
 857             const auto&amp; rendererWithOutline = downcast&lt;RenderLayerModelObject&gt;(*renderer);
 858             adjustedRepaintRect = LayoutRect(repaintContainer.localToContainerQuad(FloatRect(adjustedRepaintRect), &amp;rendererWithOutline).boundingBox());
 859             rendererWithOutline.repaintRectangle(adjustedRepaintRect);
 860         }
 861         return;
 862     }
 863     ASSERT_NOT_REACHED();
 864 }
 865 
 866 void RenderObject::repaintUsingContainer(const RenderLayerModelObject* repaintContainer, const LayoutRect&amp; r, bool shouldClipToLayer) const
 867 {
 868     if (r.isEmpty())
 869         return;
 870 
 871     if (!repaintContainer)
 872         repaintContainer = &amp;view();
 873 
 874     if (is&lt;RenderFragmentedFlow&gt;(*repaintContainer)) {
 875         downcast&lt;RenderFragmentedFlow&gt;(*repaintContainer).repaintRectangleInFragments(r);
 876         return;
 877     }
 878 
 879     propagateRepaintToParentWithOutlineAutoIfNeeded(*repaintContainer, r);
 880 
 881     if (repaintContainer-&gt;hasFilter() &amp;&amp; repaintContainer-&gt;layer() &amp;&amp; repaintContainer-&gt;layer()-&gt;requiresFullLayerImageForFilters()) {
 882         repaintContainer-&gt;layer()-&gt;setFilterBackendNeedsRepaintingInRect(r);
 883         return;
 884     }
 885 
 886     if (repaintContainer-&gt;isRenderView()) {
 887         RenderView&amp; view = this-&gt;view();
 888         ASSERT(repaintContainer == &amp;view);
 889         bool viewHasCompositedLayer = view.isComposited();
 890         if (!viewHasCompositedLayer || view.layer()-&gt;backing()-&gt;paintsIntoWindow()) {
 891             LayoutRect rect = r;
 892             if (viewHasCompositedLayer &amp;&amp; view.layer()-&gt;transform())
 893                 rect = LayoutRect(view.layer()-&gt;transform()-&gt;mapRect(snapRectToDevicePixels(rect, document().deviceScaleFactor())));
 894             view.repaintViewRectangle(rect);
 895             return;
 896         }
 897     }
 898 
 899     if (view().usesCompositing()) {
 900         ASSERT(repaintContainer-&gt;isComposited());
 901         repaintContainer-&gt;layer()-&gt;setBackingNeedsRepaintInRect(r, shouldClipToLayer ? GraphicsLayer::ClipToLayer : GraphicsLayer::DoNotClipToLayer);
 902     }
 903 }
 904 
 905 void RenderObject::repaint() const
 906 {
 907     // Don&#39;t repaint if we&#39;re unrooted (note that view() still returns the view when unrooted)
 908     if (!isRooted())
 909         return;
 910 
 911     const RenderView&amp; view = this-&gt;view();
 912     if (view.printing())
 913         return;
 914 
 915     RenderLayerModelObject* repaintContainer = containerForRepaint();
 916     repaintUsingContainer(repaintContainer, clippedOverflowRectForRepaint(repaintContainer));
 917 }
 918 
 919 void RenderObject::repaintRectangle(const LayoutRect&amp; r, bool shouldClipToLayer) const
 920 {
 921     // Don&#39;t repaint if we&#39;re unrooted (note that view() still returns the view when unrooted)
 922     if (!isRooted())
 923         return;
 924 
 925     const RenderView&amp; view = this-&gt;view();
 926     if (view.printing())
 927         return;
 928 
 929     LayoutRect dirtyRect(r);
 930     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 931     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 932     dirtyRect.move(view.frameView().layoutContext().layoutDelta());
 933 
 934     RenderLayerModelObject* repaintContainer = containerForRepaint();
 935     repaintUsingContainer(repaintContainer, computeRectForRepaint(dirtyRect, repaintContainer), shouldClipToLayer);
 936 }
 937 
 938 void RenderObject::repaintSlowRepaintObject() const
 939 {
 940     // Don&#39;t repaint if we&#39;re unrooted (note that view() still returns the view when unrooted)
 941     if (!isRooted())
 942         return;
 943 
 944     const RenderView&amp; view = this-&gt;view();
 945     if (view.printing())
 946         return;
 947 
 948     const RenderLayerModelObject* repaintContainer = containerForRepaint();
 949 
 950     bool shouldClipToLayer = true;
 951     IntRect repaintRect;
 952     // If this is the root background, we need to check if there is an extended background rect. If
 953     // there is, then we should not allow painting to clip to the layer size.
 954     if (isDocumentElementRenderer() || isBody()) {
 955         shouldClipToLayer = !view.frameView().hasExtendedBackgroundRectForPainting();
 956         repaintRect = snappedIntRect(view.backgroundRect());
 957     } else
 958         repaintRect = snappedIntRect(clippedOverflowRectForRepaint(repaintContainer));
 959 
 960     repaintUsingContainer(repaintContainer, repaintRect, shouldClipToLayer);
 961 }
 962 
 963 IntRect RenderObject::pixelSnappedAbsoluteClippedOverflowRect() const
 964 {
 965     return snappedIntRect(absoluteClippedOverflowRect());
 966 }
 967 
 968 LayoutRect RenderObject::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
 969 {
 970     LayoutRect r(clippedOverflowRectForRepaint(repaintContainer));
 971     r.inflate(outlineWidth);
 972     return r;
 973 }
 974 
 975 LayoutRect RenderObject::clippedOverflowRectForRepaint(const RenderLayerModelObject*) const
 976 {
 977     ASSERT_NOT_REACHED();
 978     return LayoutRect();
 979 }
 980 
 981 LayoutRect RenderObject::computeRectForRepaint(const LayoutRect&amp; rect, const RenderLayerModelObject* repaintContainer) const
 982 {
 983     return *computeVisibleRectInContainer(rect, repaintContainer, visibleRectContextForRepaint());
 984 }
 985 
 986 FloatRect RenderObject::computeFloatRectForRepaint(const FloatRect&amp; rect, const RenderLayerModelObject* repaintContainer) const
 987 {
 988     return *computeFloatVisibleRectInContainer(rect, repaintContainer, visibleRectContextForRepaint());
 989 }
 990 
 991 Optional&lt;LayoutRect&gt; RenderObject::computeVisibleRectInContainer(const LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 992 {
 993     if (container == this)
 994         return rect;
 995 
 996     auto* parent = this-&gt;parent();
 997     if (!parent)
 998         return rect;
 999 
1000     LayoutRect adjustedRect = rect;
1001     if (parent-&gt;hasOverflowClip()) {
1002         bool isEmpty = !downcast&lt;RenderBox&gt;(*parent).applyCachedClipAndScrollPosition(adjustedRect, container, context);
1003         if (isEmpty) {
1004             if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
1005                 return WTF::nullopt;
1006             return adjustedRect;
1007         }
1008     }
1009     return parent-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
1010 }
1011 
1012 Optional&lt;FloatRect&gt; RenderObject::computeFloatVisibleRectInContainer(const FloatRect&amp;, const RenderLayerModelObject*, VisibleRectContext) const
1013 {
1014     ASSERT_NOT_REACHED();
1015     return FloatRect();
1016 }
1017 
1018 #if ENABLE(TREE_DEBUGGING)
1019 
1020 static void outputRenderTreeLegend(TextStream&amp; stream)
1021 {
1022     stream.nextLine();
1023     stream &lt;&lt; &quot;(B)lock/(I)nline/I(N)line-block, (A)bsolute/Fi(X)ed/(R)elative/Stic(K)y, (F)loating, (O)verflow clip, Anon(Y)mous, (G)enerated, has(L)ayer, (C)omposited, (+)Dirty style, (+)Dirty layout&quot;;
1024     stream.nextLine();
1025 }
1026 
1027 void RenderObject::showNodeTreeForThis() const
1028 {
1029     if (!node())
1030         return;
1031     node()-&gt;showTreeForThis();
1032 }
1033 
1034 void RenderObject::showRenderTreeForThis() const
1035 {
1036     const WebCore::RenderObject* root = this;
1037     while (root-&gt;parent())
1038         root = root-&gt;parent();
1039     TextStream stream(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
1040     outputRenderTreeLegend(stream);
1041     root-&gt;outputRenderSubTreeAndMark(stream, this, 1);
1042     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
1043 }
1044 
1045 void RenderObject::showLineTreeForThis() const
1046 {
1047     if (!is&lt;RenderBlockFlow&gt;(*this))
1048         return;
1049     TextStream stream(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
1050     outputRenderTreeLegend(stream);
1051     outputRenderObject(stream, false, 1);
1052     downcast&lt;RenderBlockFlow&gt;(*this).outputLineTreeAndMark(stream, nullptr, 2);
1053     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
1054 }
1055 
1056 static const RenderFragmentedFlow* enclosingFragmentedFlowFromRenderer(const RenderObject* renderer)
1057 {
1058     if (!renderer)
1059         return nullptr;
1060 
1061     if (renderer-&gt;fragmentedFlowState() == RenderObject::NotInsideFragmentedFlow)
1062         return nullptr;
1063 
1064     if (is&lt;RenderFragmentedFlow&gt;(*renderer))
1065         return downcast&lt;RenderFragmentedFlow&gt;(renderer);
1066 
1067     if (is&lt;RenderBlock&gt;(*renderer))
1068         return downcast&lt;RenderBlock&gt;(*renderer).cachedEnclosingFragmentedFlow();
1069 
1070     return nullptr;
1071 }
1072 
1073 void RenderObject::outputRegionsInformation(TextStream&amp; stream) const
1074 {
1075     const RenderFragmentedFlow* ftcb = enclosingFragmentedFlowFromRenderer(this);
1076 
1077     if (!ftcb) {
1078         // Only the boxes have region range information.
1079         // Try to get the flow thread containing block information
1080         // from the containing block of this box.
1081         if (is&lt;RenderBox&gt;(*this))
1082             ftcb = enclosingFragmentedFlowFromRenderer(containingBlock());
1083     }
1084 
1085     if (!ftcb)
1086         return;
1087 
1088     RenderFragmentContainer* startRegion = nullptr;
1089     RenderFragmentContainer* endRegion = nullptr;
1090     ftcb-&gt;getFragmentRangeForBox(downcast&lt;RenderBox&gt;(this), startRegion, endRegion);
1091     stream &lt;&lt; &quot; [Rs:&quot; &lt;&lt; startRegion &lt;&lt; &quot; Re:&quot; &lt;&lt; endRegion &lt;&lt; &quot;]&quot;;
1092 }
1093 
1094 void RenderObject::outputRenderObject(TextStream&amp; stream, bool mark, int depth) const
1095 {
1096     if (isInlineBlockOrInlineTable())
1097         stream &lt;&lt; &quot;N&quot;;
1098     else if (isInline())
1099         stream &lt;&lt; &quot;I&quot;;
1100     else
1101         stream &lt;&lt; &quot;B&quot;;
1102 
1103     if (isPositioned()) {
1104         if (isRelativelyPositioned())
1105             stream &lt;&lt; &quot;R&quot;;
1106         else if (isStickilyPositioned())
1107             stream &lt;&lt; &quot;K&quot;;
1108         else if (isOutOfFlowPositioned()) {
1109             if (isAbsolutelyPositioned())
1110                 stream &lt;&lt; &quot;A&quot;;
1111             else
1112                 stream &lt;&lt; &quot;X&quot;;
1113         }
1114     } else
1115         stream &lt;&lt; &quot;-&quot;;
1116 
1117     if (isFloating())
1118         stream &lt;&lt; &quot;F&quot;;
1119     else
1120         stream &lt;&lt; &quot;-&quot;;
1121 
1122     if (hasOverflowClip())
1123         stream &lt;&lt; &quot;O&quot;;
1124     else
1125         stream &lt;&lt; &quot;-&quot;;
1126 
1127     if (isAnonymous())
1128         stream &lt;&lt; &quot;Y&quot;;
1129     else
1130         stream &lt;&lt; &quot;-&quot;;
1131 
1132     if (isPseudoElement() || isAnonymous())
1133         stream &lt;&lt; &quot;G&quot;;
1134     else
1135         stream &lt;&lt; &quot;-&quot;;
1136 
1137     if (hasLayer())
1138         stream &lt;&lt; &quot;L&quot;;
1139     else
1140         stream &lt;&lt; &quot;-&quot;;
1141 
1142     if (isComposited())
1143         stream &lt;&lt; &quot;C&quot;;
1144     else
1145         stream &lt;&lt; &quot;-&quot;;
1146 
1147     stream &lt;&lt; &quot; &quot;;
1148 
1149     if (node() &amp;&amp; node()-&gt;needsStyleRecalc())
1150         stream &lt;&lt; &quot;+&quot;;
1151     else
1152         stream &lt;&lt; &quot;-&quot;;
1153 
1154     if (needsLayout())
1155         stream &lt;&lt; &quot;+&quot;;
1156     else
1157         stream &lt;&lt; &quot;-&quot;;
1158 
1159     int printedCharacters = 0;
1160     if (mark) {
1161         stream &lt;&lt; &quot;*&quot;;
1162         ++printedCharacters;
1163     }
1164 
1165     while (++printedCharacters &lt;= depth * 2)
1166         stream &lt;&lt; &quot; &quot;;
1167 
1168     if (node())
1169         stream &lt;&lt; node()-&gt;nodeName().utf8().data() &lt;&lt; &quot; &quot;;
1170 
1171     String name = renderName();
1172     // FIXME: Renderer&#39;s name should not include property value listing.
1173     int pos = name.find(&#39;(&#39;);
1174     if (pos &gt; 0)
1175         stream &lt;&lt; name.left(pos - 1).utf8().data();
1176     else
1177         stream &lt;&lt; name.utf8().data();
1178 
1179     if (is&lt;RenderBox&gt;(*this)) {
1180         auto&amp; renderBox = downcast&lt;RenderBox&gt;(*this);
1181         FloatRect boxRect = renderBox.frameRect();
1182         if (renderBox.isInFlowPositioned())
1183             boxRect.move(renderBox.offsetForInFlowPosition());
1184         stream &lt;&lt; &quot; &quot; &lt;&lt; boxRect;
1185     } else if (is&lt;RenderInline&gt;(*this) &amp;&amp; isInFlowPositioned()) {
1186         FloatSize inlineOffset = downcast&lt;RenderInline&gt;(*this).offsetForInFlowPosition();
1187         stream &lt;&lt; &quot;  (&quot; &lt;&lt; inlineOffset.width() &lt;&lt; &quot;, &quot; &lt;&lt; inlineOffset.height() &lt;&lt; &quot;)&quot;;
1188     }
1189 
1190     stream &lt;&lt; &quot; renderer-&gt;(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot;;
1191     if (node()) {
1192         stream &lt;&lt; &quot; node-&gt;(&quot; &lt;&lt; node() &lt;&lt; &quot;)&quot;;
1193         if (node()-&gt;isTextNode()) {
1194             String value = node()-&gt;nodeValue();
1195             stream &lt;&lt; &quot; length-&gt;(&quot; &lt;&lt; value.length() &lt;&lt; &quot;)&quot;;
1196 
1197             value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1198             value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1199 
1200             const int maxPrintedLength = 80;
1201             if (value.length() &gt; maxPrintedLength) {
1202                 String substring = value.substring(0, maxPrintedLength);
1203                 stream &lt;&lt; &quot; \&quot;&quot; &lt;&lt; substring.utf8().data() &lt;&lt; &quot;\&quot;...&quot;;
1204             } else
1205                 stream &lt;&lt; &quot; \&quot;&quot; &lt;&lt; value.utf8().data() &lt;&lt; &quot;\&quot;&quot;;
1206         }
1207     }
1208     if (is&lt;RenderBoxModelObject&gt;(*this)) {
1209         auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(*this);
1210         if (renderer.continuation())
1211             stream &lt;&lt; &quot; continuation-&gt;(&quot; &lt;&lt; renderer.continuation() &lt;&lt; &quot;)&quot;;
1212     }
1213     outputRegionsInformation(stream);
1214     if (needsLayout()) {
1215         stream &lt;&lt; &quot; layout-&gt;&quot;;
1216         if (selfNeedsLayout())
1217             stream &lt;&lt; &quot;[self]&quot;;
1218         if (normalChildNeedsLayout())
1219             stream &lt;&lt; &quot;[normal child]&quot;;
1220         if (posChildNeedsLayout())
1221             stream &lt;&lt; &quot;[positioned child]&quot;;
1222         if (needsSimplifiedNormalFlowLayout())
1223             stream &lt;&lt; &quot;[simplified]&quot;;
1224         if (needsPositionedMovementLayout())
1225             stream &lt;&lt; &quot;[positioned movement]&quot;;
1226     }
1227     stream.nextLine();
1228 }
1229 
1230 void RenderObject::outputRenderSubTreeAndMark(TextStream&amp; stream, const RenderObject* markedObject, int depth) const
1231 {
1232     outputRenderObject(stream, markedObject == this, depth);
1233     if (is&lt;RenderBlockFlow&gt;(*this))
1234         downcast&lt;RenderBlockFlow&gt;(*this).outputLineTreeAndMark(stream, nullptr, depth + 1);
1235 
1236     for (auto* child = firstChildSlow(); child; child = child-&gt;nextSibling())
1237         child-&gt;outputRenderSubTreeAndMark(stream, markedObject, depth + 1);
1238 }
1239 
1240 #endif // NDEBUG
1241 
1242 FloatPoint RenderObject::localToAbsolute(const FloatPoint&amp; localPoint, MapCoordinatesFlags mode, bool* wasFixed) const
1243 {
1244     TransformState transformState(TransformState::ApplyTransformDirection, localPoint);
1245     mapLocalToContainer(nullptr, transformState, mode | ApplyContainerFlip, wasFixed);
1246     transformState.flatten();
1247 
1248     return transformState.lastPlanarPoint();
1249 }
1250 
1251 FloatPoint RenderObject::absoluteToLocal(const FloatPoint&amp; containerPoint, MapCoordinatesFlags mode) const
1252 {
1253     TransformState transformState(TransformState::UnapplyInverseTransformDirection, containerPoint);
1254     mapAbsoluteToLocalPoint(mode, transformState);
1255     transformState.flatten();
1256 
1257     return transformState.lastPlanarPoint();
1258 }
1259 
1260 FloatQuad RenderObject::absoluteToLocalQuad(const FloatQuad&amp; quad, MapCoordinatesFlags mode) const
1261 {
1262     TransformState transformState(TransformState::UnapplyInverseTransformDirection, quad.boundingBox().center(), quad);
1263     mapAbsoluteToLocalPoint(mode, transformState);
1264     transformState.flatten();
1265     return transformState.lastPlanarQuad();
1266 }
1267 
1268 void RenderObject::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
1269 {
1270     if (repaintContainer == this)
1271         return;
1272 
1273     auto* parent = this-&gt;parent();
1274     if (!parent)
1275         return;
1276 
1277     // FIXME: this should call offsetFromContainer to share code, but I&#39;m not sure it&#39;s ever called.
1278     LayoutPoint centerPoint(transformState.mappedPoint());
1279     if (mode &amp; ApplyContainerFlip &amp;&amp; is&lt;RenderBox&gt;(*parent)) {
1280         if (parent-&gt;style().isFlippedBlocksWritingMode())
1281             transformState.move(downcast&lt;RenderBox&gt;(parent)-&gt;flipForWritingMode(LayoutPoint(transformState.mappedPoint())) - centerPoint);
1282         mode &amp;= ~ApplyContainerFlip;
1283     }
1284 
1285     if (is&lt;RenderBox&gt;(*parent))
1286         transformState.move(-toLayoutSize(downcast&lt;RenderBox&gt;(*parent).scrollPosition()));
1287 
1288     parent-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
1289 }
1290 
1291 const RenderObject* RenderObject::pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp; geometryMap) const
1292 {
1293     ASSERT_UNUSED(ancestorToStopAt, ancestorToStopAt != this);
1294 
1295     auto* container = parent();
1296     if (!container)
1297         return nullptr;
1298 
1299     // FIXME: this should call offsetFromContainer to share code, but I&#39;m not sure it&#39;s ever called.
1300     LayoutSize offset;
1301     if (is&lt;RenderBox&gt;(*container))
1302         offset = -toLayoutSize(downcast&lt;RenderBox&gt;(*container).scrollPosition());
1303 
1304     geometryMap.push(this, offset, false);
1305 
1306     return container;
1307 }
1308 
1309 void RenderObject::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
1310 {
1311     if (auto* parent = this-&gt;parent()) {
1312         parent-&gt;mapAbsoluteToLocalPoint(mode, transformState);
1313         if (is&lt;RenderBox&gt;(*parent))
1314             transformState.move(toLayoutSize(downcast&lt;RenderBox&gt;(*parent).scrollPosition()));
1315     }
1316 }
1317 
1318 bool RenderObject::shouldUseTransformFromContainer(const RenderObject* containerObject) const
1319 {
1320 #if ENABLE(3D_TRANSFORMS)
1321     return hasTransform() || (containerObject &amp;&amp; containerObject-&gt;style().hasPerspective());
1322 #else
1323     UNUSED_PARAM(containerObject);
1324     return hasTransform();
1325 #endif
1326 }
1327 
1328 void RenderObject::getTransformFromContainer(const RenderObject* containerObject, const LayoutSize&amp; offsetInContainer, TransformationMatrix&amp; transform) const
1329 {
1330     transform.makeIdentity();
1331     transform.translate(offsetInContainer.width(), offsetInContainer.height());
1332     RenderLayer* layer;
1333     if (hasLayer() &amp;&amp; (layer = downcast&lt;RenderLayerModelObject&gt;(*this).layer()) &amp;&amp; layer-&gt;transform())
1334         transform.multiply(layer-&gt;currentTransform());
1335 
1336 #if ENABLE(3D_TRANSFORMS)
1337     if (containerObject &amp;&amp; containerObject-&gt;hasLayer() &amp;&amp; containerObject-&gt;style().hasPerspective()) {
1338         // Perpsective on the container affects us, so we have to factor it in here.
1339         ASSERT(containerObject-&gt;hasLayer());
1340         FloatPoint perspectiveOrigin = downcast&lt;RenderLayerModelObject&gt;(*containerObject).layer()-&gt;perspectiveOrigin();
1341 
1342         TransformationMatrix perspectiveMatrix;
1343         perspectiveMatrix.applyPerspective(containerObject-&gt;style().perspective());
1344 
1345         transform.translateRight3d(-perspectiveOrigin.x(), -perspectiveOrigin.y(), 0);
1346         transform = perspectiveMatrix * transform;
1347         transform.translateRight3d(perspectiveOrigin.x(), perspectiveOrigin.y(), 0);
1348     }
1349 #else
1350     UNUSED_PARAM(containerObject);
1351 #endif
1352 }
1353 
1354 FloatQuad RenderObject::localToContainerQuad(const FloatQuad&amp; localQuad, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags mode, bool* wasFixed) const
1355 {
1356     // Track the point at the center of the quad&#39;s bounding box. As mapLocalToContainer() calls offsetFromContainer(),
1357     // it will use that point as the reference point to decide which column&#39;s transform to apply in multiple-column blocks.
1358     TransformState transformState(TransformState::ApplyTransformDirection, localQuad.boundingBox().center(), localQuad);
1359     mapLocalToContainer(repaintContainer, transformState, mode | ApplyContainerFlip, wasFixed);
1360     transformState.flatten();
1361 
1362     return transformState.lastPlanarQuad();
1363 }
1364 
1365 FloatPoint RenderObject::localToContainerPoint(const FloatPoint&amp; localPoint, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags mode, bool* wasFixed) const
1366 {
1367     TransformState transformState(TransformState::ApplyTransformDirection, localPoint);
1368     mapLocalToContainer(repaintContainer, transformState, mode | ApplyContainerFlip, wasFixed);
1369     transformState.flatten();
1370 
1371     return transformState.lastPlanarPoint();
1372 }
1373 
1374 LayoutSize RenderObject::offsetFromContainer(RenderElement&amp; container, const LayoutPoint&amp;, bool* offsetDependsOnPoint) const
1375 {
1376     ASSERT(&amp;container == this-&gt;container());
1377 
1378     LayoutSize offset;
1379     if (is&lt;RenderBox&gt;(container))
1380         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
1381 
1382     if (offsetDependsOnPoint)
1383         *offsetDependsOnPoint = is&lt;RenderFragmentedFlow&gt;(container);
1384 
1385     return offset;
1386 }
1387 
1388 LayoutSize RenderObject::offsetFromAncestorContainer(RenderElement&amp; container) const
1389 {
1390     LayoutSize offset;
1391     LayoutPoint referencePoint;
1392     const RenderObject* currContainer = this;
1393     do {
1394         RenderElement* nextContainer = currContainer-&gt;container();
1395         ASSERT(nextContainer);  // This means we reached the top without finding container.
1396         if (!nextContainer)
1397             break;
1398         ASSERT(!currContainer-&gt;hasTransform());
1399         LayoutSize currentOffset = currContainer-&gt;offsetFromContainer(*nextContainer, referencePoint);
1400         offset += currentOffset;
1401         referencePoint.move(currentOffset);
1402         currContainer = nextContainer;
1403     } while (currContainer != &amp;container);
1404 
1405     return offset;
1406 }
1407 
1408 LayoutRect RenderObject::localCaretRect(InlineBox*, unsigned, LayoutUnit* extraWidthToEndOfLine)
1409 {
1410     if (extraWidthToEndOfLine)
1411         *extraWidthToEndOfLine = 0;
1412 
1413     return LayoutRect();
1414 }
1415 
1416 bool RenderObject::isRooted() const
1417 {
1418     return isDescendantOf(&amp;view());
1419 }
1420 
1421 static inline RenderElement* containerForElement(const RenderObject&amp; renderer, const RenderLayerModelObject* repaintContainer, bool* repaintContainerSkipped)
1422 {
1423     // This method is extremely similar to containingBlock(), but with a few notable
1424     // exceptions.
1425     // (1) For normal flow elements, it just returns the parent.
1426     // (2) For absolute positioned elements, it will return a relative positioned inline, while
1427     // containingBlock() skips to the non-anonymous containing block.
1428     // This does mean that computePositionedLogicalWidth and computePositionedLogicalHeight have to use container().
1429     auto pos = renderer.style().position();
1430     auto* parent = renderer.parent();
1431     if (is&lt;RenderText&gt;(renderer) || (pos != PositionType::Fixed &amp;&amp; pos != PositionType::Absolute))
1432         return parent;
1433     for (; parent &amp;&amp; (pos == PositionType::Absolute ? !parent-&gt;canContainAbsolutelyPositionedObjects() : !parent-&gt;canContainFixedPositionObjects()); parent = parent-&gt;parent()) {
1434         if (repaintContainerSkipped &amp;&amp; repaintContainer == parent)
1435             *repaintContainerSkipped = true;
1436     }
1437     return parent;
1438 }
1439 
1440 RenderElement* RenderObject::container() const
1441 {
1442     return containerForElement(*this, nullptr, nullptr);
1443 }
1444 
1445 RenderElement* RenderObject::container(const RenderLayerModelObject* repaintContainer, bool&amp; repaintContainerSkipped) const
1446 {
1447     repaintContainerSkipped = false;
1448     return containerForElement(*this, repaintContainer, &amp;repaintContainerSkipped);
1449 }
1450 
1451 bool RenderObject::isSelectionBorder() const
1452 {
1453     SelectionState st = selectionState();
1454     return st == SelectionStart
1455         || st == SelectionEnd
1456         || st == SelectionBoth
1457         || view().selection().start() == this
1458         || view().selection().end() == this;
1459 }
1460 
1461 void RenderObject::willBeDestroyed()
1462 {
1463     ASSERT(!m_parent);
1464     ASSERT(renderTreeBeingDestroyed() || !is&lt;RenderElement&gt;(*this) || !view().frameView().hasSlowRepaintObject(downcast&lt;RenderElement&gt;(*this)));
1465 
1466     if (AXObjectCache* cache = document().existingAXObjectCache())
1467         cache-&gt;remove(this);
1468 
1469     if (auto* node = this-&gt;node()) {
1470         // FIXME: Continuations should be anonymous.
1471         ASSERT(!node-&gt;renderer() || node-&gt;renderer() == this || (is&lt;RenderElement&gt;(*this) &amp;&amp; downcast&lt;RenderElement&gt;(*this).isContinuation()));
1472         if (node-&gt;renderer() == this)
1473             node-&gt;setRenderer(nullptr);
1474     }
1475 
1476     removeRareData();
1477 }
1478 
1479 void RenderObject::insertedIntoTree()
1480 {
1481     // FIXME: We should ASSERT(isRooted()) here but generated content makes some out-of-order insertion.
1482     if (!isFloating() &amp;&amp; parent()-&gt;childrenInline())
1483         parent()-&gt;dirtyLinesFromChangedChild(*this);
1484 }
1485 
1486 void RenderObject::willBeRemovedFromTree()
1487 {
1488     // FIXME: We should ASSERT(isRooted()) but we have some out-of-order removals which would need to be fixed first.
1489     // Update cached boundaries in SVG renderers, if a child is removed.
1490     parent()-&gt;setNeedsBoundariesUpdate();
1491 }
1492 
1493 void RenderObject::destroy()
1494 {
1495     RELEASE_ASSERT(!m_parent);
1496     RELEASE_ASSERT(!m_next);
1497     RELEASE_ASSERT(!m_previous);
1498     RELEASE_ASSERT(!m_bitfields.beingDestroyed());
1499 
1500     m_bitfields.setBeingDestroyed(true);
1501 
1502 #if PLATFORM(IOS_FAMILY)
1503     if (hasLayer())
1504         downcast&lt;RenderBoxModelObject&gt;(*this).layer()-&gt;willBeDestroyed();
1505 #endif
1506 
1507     willBeDestroyed();
1508 
1509     if (is&lt;RenderWidget&gt;(*this)) {
1510         downcast&lt;RenderWidget&gt;(*this).deref();
1511         return;
1512     }
1513     delete this;
1514 }
1515 
1516 Position RenderObject::positionForPoint(const LayoutPoint&amp; point)
1517 {
1518     // FIXME: This should just create a Position object instead (webkit.org/b/168566).
1519     return positionForPoint(point, nullptr).deepEquivalent();
1520 }
1521 
1522 VisiblePosition RenderObject::positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*)
1523 {
1524     return createVisiblePosition(caretMinOffset(), DOWNSTREAM);
1525 }
1526 
1527 void RenderObject::updateDragState(bool dragOn)
1528 {
1529     bool valueChanged = (dragOn != isDragging());
1530     setIsDragging(dragOn);
1531 
1532     if (!is&lt;RenderElement&gt;(*this))
1533         return;
1534     auto&amp; renderElement = downcast&lt;RenderElement&gt;(*this);
1535 
1536     if (valueChanged &amp;&amp; renderElement.element() &amp;&amp; (style().affectedByDrag() || renderElement.element()-&gt;childrenAffectedByDrag()))
1537         renderElement.element()-&gt;invalidateStyleForSubtree();
1538 
1539     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderElement))
1540         child.updateDragState(dragOn);
1541 }
1542 
1543 bool RenderObject::isComposited() const
1544 {
1545     return hasLayer() &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited();
1546 }
1547 
1548 bool RenderObject::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestFilter hitTestFilter)
1549 {
1550     bool inside = false;
1551     if (hitTestFilter != HitTestSelf) {
1552         // First test the foreground layer (lines and inlines).
1553         inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestForeground);
1554 
1555         // Test floats next.
1556         if (!inside)
1557             inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestFloat);
1558 
1559         // Finally test to see if the mouse is in the background (within a child block&#39;s background).
1560         if (!inside)
1561             inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestChildBlockBackgrounds);
1562     }
1563 
1564     // See if the mouse is inside us but not any of our descendants
1565     if (hitTestFilter != HitTestDescendants &amp;&amp; !inside)
1566         inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestBlockBackground);
1567 
1568     return inside;
1569 }
1570 
1571 void RenderObject::updateHitTestResult(HitTestResult&amp; result, const LayoutPoint&amp; point)
1572 {
1573     if (result.innerNode())
1574         return;
1575 
1576     Node* node = this-&gt;node();
1577 
1578     // If we hit the anonymous renderers inside generated content we should
1579     // actually hit the generated content so walk up to the PseudoElement.
1580     if (!node &amp;&amp; parent() &amp;&amp; parent()-&gt;isBeforeOrAfterContent()) {
1581         for (auto* renderer = parent(); renderer &amp;&amp; !node; renderer = renderer-&gt;parent())
1582             node = renderer-&gt;element();
1583     }
1584 
1585     if (node) {
1586         result.setInnerNode(node);
1587         if (!result.innerNonSharedNode())
1588             result.setInnerNonSharedNode(node);
1589         result.setLocalPoint(point);
1590     }
1591 }
1592 
1593 bool RenderObject::nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; /*locationInContainer*/, const LayoutPoint&amp; /*accumulatedOffset*/, HitTestAction)
1594 {
1595     return false;
1596 }
1597 
1598 int RenderObject::innerLineHeight() const
1599 {
1600     return style().computedLineHeight();
1601 }
1602 
1603 int RenderObject::caretMinOffset() const
1604 {
1605     return 0;
1606 }
1607 
1608 int RenderObject::caretMaxOffset() const
1609 {
1610     if (isReplaced())
1611         return node() ? std::max(1U, node()-&gt;countChildNodes()) : 1;
1612     if (isHR())
1613         return 1;
1614     return 0;
1615 }
1616 
1617 int RenderObject::previousOffset(int current) const
1618 {
1619     return current - 1;
1620 }
1621 
1622 int RenderObject::previousOffsetForBackwardDeletion(int current) const
1623 {
1624     return current - 1;
1625 }
1626 
1627 int RenderObject::nextOffset(int current) const
1628 {
1629     return current + 1;
1630 }
1631 
1632 void RenderObject::adjustRectForOutlineAndShadow(LayoutRect&amp; rect) const
1633 {
1634     LayoutUnit outlineSize { outlineStyleForRepaint().outlineSize() };
1635     if (const ShadowData* boxShadow = style().boxShadow()) {
1636         boxShadow-&gt;adjustRectForShadow(rect, outlineSize);
1637         return;
1638     }
1639     rect.inflate(outlineSize);
1640 }
1641 
1642 void RenderObject::imageChanged(CachedImage* image, const IntRect* rect)
1643 {
1644     imageChanged(static_cast&lt;WrappedImagePtr&gt;(image), rect);
1645 }
1646 
1647 RenderBoxModelObject* RenderObject::offsetParent() const
1648 {
1649     // If any of the following holds true return null and stop this algorithm:
1650     // A is the root element.
1651     // A is the HTML body element.
1652     // The computed value of the position property for element A is fixed.
1653     if (isDocumentElementRenderer() || isBody() || isFixedPositioned())
1654         return nullptr;
1655 
1656     // If A is an area HTML element which has a map HTML element somewhere in the ancestor
1657     // chain return the nearest ancestor map HTML element and stop this algorithm.
1658     // FIXME: Implement!
1659 
1660     // Return the nearest ancestor element of A for which at least one of the following is
1661     // true and stop this algorithm if such an ancestor is found:
1662     //     * The computed value of the position property is not static.
1663     //     * It is the HTML body element.
1664     //     * The computed value of the position property of A is static and the ancestor
1665     //       is one of the following HTML elements: td, th, or table.
1666     //     * Our own extension: if there is a difference in the effective zoom
1667 
1668     bool skipTables = isPositioned();
1669     float currZoom = style().effectiveZoom();
1670     auto current = parent();
1671     while (current &amp;&amp; (!current-&gt;element() || (!current-&gt;isPositioned() &amp;&amp; !current-&gt;isBody()))) {
1672         Element* element = current-&gt;element();
1673         if (!skipTables &amp;&amp; element &amp;&amp; (is&lt;HTMLTableElement&gt;(*element) || is&lt;HTMLTableCellElement&gt;(*element)))
1674             break;
1675 
1676         float newZoom = current-&gt;style().effectiveZoom();
1677         if (currZoom != newZoom)
1678             break;
1679         currZoom = newZoom;
1680         current = current-&gt;parent();
1681     }
1682 
1683     return is&lt;RenderBoxModelObject&gt;(current) ? downcast&lt;RenderBoxModelObject&gt;(current) : nullptr;
1684 }
1685 
1686 VisiblePosition RenderObject::createVisiblePosition(int offset, EAffinity affinity) const
1687 {
1688     // If this is a non-anonymous renderer in an editable area, then it&#39;s simple.
1689     if (Node* node = nonPseudoNode()) {
1690         if (!node-&gt;hasEditableStyle()) {
1691             // If it can be found, we prefer a visually equivalent position that is editable.
1692             Position position = createLegacyEditingPosition(node, offset);
1693             Position candidate = position.downstream(CanCrossEditingBoundary);
1694             if (candidate.deprecatedNode()-&gt;hasEditableStyle())
1695                 return VisiblePosition(candidate, affinity);
1696             candidate = position.upstream(CanCrossEditingBoundary);
1697             if (candidate.deprecatedNode()-&gt;hasEditableStyle())
1698                 return VisiblePosition(candidate, affinity);
1699         }
1700         // FIXME: Eliminate legacy editing positions
1701         return VisiblePosition(createLegacyEditingPosition(node, offset), affinity);
1702     }
1703 
1704     // We don&#39;t want to cross the boundary between editable and non-editable
1705     // regions of the document, but that is either impossible or at least
1706     // extremely unlikely in any normal case because we stop as soon as we
1707     // find a single non-anonymous renderer.
1708 
1709     // Find a nearby non-anonymous renderer.
1710     const RenderObject* child = this;
1711     while (const auto parent = child-&gt;parent()) {
1712         // Find non-anonymous content after.
1713         const RenderObject* renderer = child;
1714         while ((renderer = renderer-&gt;nextInPreOrder(parent))) {
1715             if (Node* node = renderer-&gt;nonPseudoNode())
1716                 return VisiblePosition(firstPositionInOrBeforeNode(node), DOWNSTREAM);
1717         }
1718 
1719         // Find non-anonymous content before.
1720         renderer = child;
1721         while ((renderer = renderer-&gt;previousInPreOrder())) {
1722             if (renderer == parent)
1723                 break;
1724             if (Node* node = renderer-&gt;nonPseudoNode())
1725                 return VisiblePosition(lastPositionInOrAfterNode(node), DOWNSTREAM);
1726         }
1727 
1728         // Use the parent itself unless it too is anonymous.
1729         if (Element* element = parent-&gt;nonPseudoElement())
1730             return VisiblePosition(firstPositionInOrBeforeNode(element), DOWNSTREAM);
1731 
1732         // Repeat at the next level up.
1733         child = parent;
1734     }
1735 
1736     // Everything was anonymous. Give up.
1737     return VisiblePosition();
1738 }
1739 
1740 VisiblePosition RenderObject::createVisiblePosition(const Position&amp; position) const
1741 {
1742     if (position.isNotNull())
1743         return VisiblePosition(position);
1744 
1745     ASSERT(!node());
1746     return createVisiblePosition(0, DOWNSTREAM);
1747 }
1748 
1749 CursorDirective RenderObject::getCursor(const LayoutPoint&amp;, Cursor&amp;) const
1750 {
1751     return SetCursorBasedOnStyle;
1752 }
1753 
1754 bool RenderObject::useDarkAppearance() const
1755 {
1756     return document().useDarkAppearance(&amp;style());
1757 }
1758 
1759 OptionSet&lt;StyleColor::Options&gt; RenderObject::styleColorOptions() const
1760 {
1761     return document().styleColorOptions(&amp;style());
1762 }
1763 
1764 bool RenderObject::canUpdateSelectionOnRootLineBoxes()
1765 {
1766     if (needsLayout())
1767         return false;
1768 
1769     RenderBlock* containingBlock = this-&gt;containingBlock();
1770     return containingBlock ? !containingBlock-&gt;needsLayout() : true;
1771 }
1772 
1773 // We only create &quot;generated&quot; child renderers like one for first-letter if:
1774 // - the firstLetterBlock can have children in the DOM and
1775 // - the block doesn&#39;t have any special assumption on its text children.
1776 // This correctly prevents form controls from having such renderers.
1777 bool RenderObject::canHaveGeneratedChildren() const
1778 {
1779     return canHaveChildren();
1780 }
1781 
1782 Node* RenderObject::generatingPseudoHostElement() const
1783 {
1784     return downcast&lt;PseudoElement&gt;(*node()).hostElement();
1785 }
1786 
1787 void RenderObject::setNeedsBoundariesUpdate()
1788 {
1789     if (auto renderer = parent())
1790         renderer-&gt;setNeedsBoundariesUpdate();
1791 }
1792 
1793 FloatRect RenderObject::objectBoundingBox() const
1794 {
1795     ASSERT_NOT_REACHED();
1796     return FloatRect();
1797 }
1798 
1799 FloatRect RenderObject::strokeBoundingBox() const
1800 {
1801     ASSERT_NOT_REACHED();
1802     return FloatRect();
1803 }
1804 
1805 // Returns the smallest rectangle enclosing all of the painted content
1806 // respecting clipping, masking, filters, opacity, stroke-width and markers
1807 FloatRect RenderObject::repaintRectInLocalCoordinates() const
1808 {
1809     ASSERT_NOT_REACHED();
1810     return FloatRect();
1811 }
1812 
1813 AffineTransform RenderObject::localTransform() const
1814 {
1815     static const AffineTransform identity;
1816     return identity;
1817 }
1818 
1819 const AffineTransform&amp; RenderObject::localToParentTransform() const
1820 {
1821     static const AffineTransform identity;
1822     return identity;
1823 }
1824 
1825 bool RenderObject::nodeAtFloatPoint(const HitTestRequest&amp;, HitTestResult&amp;, const FloatPoint&amp;, HitTestAction)
1826 {
1827     ASSERT_NOT_REACHED();
1828     return false;
1829 }
1830 
1831 RenderFragmentedFlow* RenderObject::locateEnclosingFragmentedFlow() const
1832 {
1833     RenderBlock* containingBlock = this-&gt;containingBlock();
1834     return containingBlock ? containingBlock-&gt;enclosingFragmentedFlow() : nullptr;
1835 }
1836 
1837 void RenderObject::calculateBorderStyleColor(const BorderStyle&amp; style, const BoxSide&amp; side, Color&amp; color)
1838 {
1839     ASSERT(style == BorderStyle::Inset || style == BorderStyle::Outset);
1840     // This values were derived empirically.
1841     const RGBA32 baseDarkColor = 0xFF202020;
1842     const RGBA32 baseLightColor = 0xFFEBEBEB;
1843     enum Operation { Darken, Lighten };
1844 
1845     Operation operation = (side == BSTop || side == BSLeft) == (style == BorderStyle::Inset) ? Darken : Lighten;
1846 
1847     // Here we will darken the border decoration color when needed. This will yield a similar behavior as in FF.
1848     if (operation == Darken) {
1849         if (differenceSquared(color, Color::black) &gt; differenceSquared(baseDarkColor, Color::black))
1850             color = color.dark();
1851     } else {
1852         if (differenceSquared(color, Color::white) &gt; differenceSquared(baseLightColor, Color::white))
1853             color = color.light();
1854     }
1855 }
1856 
1857 void RenderObject::setIsDragging(bool isDragging)
1858 {
1859     if (isDragging || hasRareData())
1860         ensureRareData().setIsDragging(isDragging);
1861 }
1862 
1863 void RenderObject::setHasReflection(bool hasReflection)
1864 {
1865     if (hasReflection || hasRareData())
1866         ensureRareData().setHasReflection(hasReflection);
1867 }
1868 
1869 void RenderObject::setIsRenderFragmentedFlow(bool isFragmentedFlow)
1870 {
1871     if (isFragmentedFlow || hasRareData())
1872         ensureRareData().setIsRenderFragmentedFlow(isFragmentedFlow);
1873 }
1874 
1875 void RenderObject::setHasOutlineAutoAncestor(bool hasOutlineAutoAncestor)
1876 {
1877     if (hasOutlineAutoAncestor || hasRareData())
1878         ensureRareData().setHasOutlineAutoAncestor(hasOutlineAutoAncestor);
1879 }
1880 
1881 RenderObject::RareDataMap&amp; RenderObject::rareDataMap()
1882 {
1883     static NeverDestroyed&lt;RareDataMap&gt; map;
1884     return map;
1885 }
1886 
1887 const RenderObject::RenderObjectRareData&amp; RenderObject::rareData() const
1888 {
1889     ASSERT(hasRareData());
1890     return *rareDataMap().get(this);
1891 }
1892 
1893 RenderObject::RenderObjectRareData&amp; RenderObject::ensureRareData()
1894 {
1895     setHasRareData(true);
1896     return *rareDataMap().ensure(this, [] { return makeUnique&lt;RenderObjectRareData&gt;(); }).iterator-&gt;value;
1897 }
1898 
1899 void RenderObject::removeRareData()
1900 {
1901     rareDataMap().remove(this);
1902     setHasRareData(false);
1903 }
1904 
1905 #if ENABLE(TREE_DEBUGGING)
1906 
1907 void printRenderTreeForLiveDocuments()
1908 {
1909     for (const auto* document : Document::allDocuments()) {
1910         if (!document-&gt;renderView())
1911             continue;
1912         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
1913             fprintf(stderr, &quot;----------------------main frame--------------------------\n&quot;);
1914         fprintf(stderr, &quot;%s&quot;, document-&gt;url().string().utf8().data());
1915         showRenderTree(document-&gt;renderView());
1916     }
1917 }
1918 
1919 void printLayerTreeForLiveDocuments()
1920 {
1921     for (const auto* document : Document::allDocuments()) {
1922         if (!document-&gt;renderView())
1923             continue;
1924         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
1925             fprintf(stderr, &quot;----------------------main frame--------------------------\n&quot;);
1926         fprintf(stderr, &quot;%s&quot;, document-&gt;url().string().utf8().data());
1927         showLayerTree(document-&gt;renderView());
1928     }
1929 }
1930 
1931 void printGraphicsLayerTreeForLiveDocuments()
1932 {
1933     for (const auto* document : Document::allDocuments()) {
1934         if (!document-&gt;renderView())
1935             continue;
1936         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame()) {
1937             WTFLogAlways(&quot;Graphics layer tree for root document %p %s&quot;, document, document-&gt;url().string().utf8().data());
1938             showGraphicsLayerTreeForCompositor(document-&gt;renderView()-&gt;compositor());
1939         }
1940     }
1941 }
1942 
1943 #endif // ENABLE(TREE_DEBUGGING)
1944 
1945 } // namespace WebCore
1946 
1947 #if ENABLE(TREE_DEBUGGING)
1948 
1949 void showNodeTree(const WebCore::RenderObject* object)
1950 {
1951     if (!object)
1952         return;
1953     object-&gt;showNodeTreeForThis();
1954 }
1955 
1956 void showLineTree(const WebCore::RenderObject* object)
1957 {
1958     if (!object)
1959         return;
1960     object-&gt;showLineTreeForThis();
1961 }
1962 
1963 void showRenderTree(const WebCore::RenderObject* object)
1964 {
1965     if (!object)
1966         return;
1967     object-&gt;showRenderTreeForThis();
1968 }
1969 
1970 #endif
    </pre>
  </body>
</html>