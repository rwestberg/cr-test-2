<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RuntimeType.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SamplingProfiler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  31 #include &quot;CallFrame.h&quot;
  32 #include &quot;CatchScope.h&quot;
  33 #include &quot;CodeBlock.h&quot;
  34 #include &quot;CodeBlockSet.h&quot;
  35 #include &quot;HeapIterationScope.h&quot;
  36 #include &quot;HeapUtil.h&quot;
  37 #include &quot;InlineCallFrame.h&quot;
  38 #include &quot;Interpreter.h&quot;
  39 #include &quot;JSCInlines.h&quot;
  40 #include &quot;JSFunction.h&quot;
  41 #include &quot;LLIntPCRanges.h&quot;
  42 #include &quot;MachineContext.h&quot;
  43 #include &quot;MarkedBlock.h&quot;
  44 #include &quot;MarkedBlockSet.h&quot;
  45 #include &quot;MarkedSpaceInlines.h&quot;
  46 #include &quot;NativeExecutable.h&quot;
  47 #include &quot;PCToCodeOriginMap.h&quot;
  48 #include &quot;SlotVisitor.h&quot;
  49 #include &quot;StrongInlines.h&quot;
  50 #include &quot;VM.h&quot;


  51 #include &lt;thread&gt;
  52 #include &lt;wtf/FilePrintStream.h&gt;
  53 #include &lt;wtf/HashSet.h&gt;
  54 #include &lt;wtf/RefPtr.h&gt;
  55 #include &lt;wtf/StackTrace.h&gt;
  56 #include &lt;wtf/text/StringBuilder.h&gt;
  57 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  58 
  59 namespace JSC {
  60 
  61 static double sNumTotalStackTraces = 0;
  62 static double sNumTotalWalks = 0;
  63 static double sNumFailedWalks = 0;
  64 static const uint32_t sNumWalkReportingFrequency = 50;
  65 static const double sWalkErrorPercentage = .05;
  66 static const bool sReportStatsOnlyWhenTheyreAboveThreshold = false;
  67 static const bool sReportStats = false;
  68 
  69 using FrameType = SamplingProfiler::FrameType;
  70 using UnprocessedStackFrame = SamplingProfiler::UnprocessedStackFrame;
  71 
  72 ALWAYS_INLINE static void reportStats()
  73 {
  74     if (sReportStats &amp;&amp; sNumTotalWalks &amp;&amp; static_cast&lt;uint64_t&gt;(sNumTotalWalks) % sNumWalkReportingFrequency == 0) {
  75         if (!sReportStatsOnlyWhenTheyreAboveThreshold || (sNumFailedWalks / sNumTotalWalks &gt; sWalkErrorPercentage)) {
  76             dataLogF(&quot;Num total walks: %llu. Failed walks percent: %lf\n&quot;,
  77                 static_cast&lt;unsigned long long&gt;(sNumTotalWalks), sNumFailedWalks / sNumTotalWalks);
  78         }
  79     }
  80 }
  81 
  82 class FrameWalker {
  83 public:
<span class="line-modified">  84     FrameWalker(VM&amp; vm, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker)</span>
  85         : m_vm(vm)
  86         , m_callFrame(callFrame)
  87         , m_entryFrame(vm.topEntryFrame)
  88         , m_codeBlockSetLocker(codeBlockSetLocker)
  89         , m_machineThreadsLocker(machineThreadsLocker)

  90     {
  91     }
  92 
  93     SUPPRESS_ASAN
  94     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
  95     {
  96         if (sReportStats)
  97             sNumTotalWalks++;
  98         resetAtMachineFrame();
  99         size_t maxStackTraceSize = stackTrace.size();
 100         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
<span class="line-modified"> 101             recordJSFrame(stackTrace);</span>
 102             advanceToParentFrame();
 103             resetAtMachineFrame();
 104         }
 105         didRunOutOfSpace = m_depth &gt;= maxStackTraceSize &amp;&amp; !isAtTop();
 106         reportStats();
 107         return m_depth;
 108     }
 109 
 110     bool wasValidWalk() const
 111     {
 112         return !m_bailingOut;
 113     }
 114 
 115 protected:
 116 
 117     SUPPRESS_ASAN
<span class="line-modified"> 118     void recordJSFrame(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace)</span>
 119     {
 120         CallSiteIndex callSiteIndex;
 121         CalleeBits unsafeCallee = m_callFrame-&gt;unsafeCallee();
 122         CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
 123         if (codeBlock) {
 124             ASSERT(isValidCodeBlock(codeBlock));
 125             callSiteIndex = m_callFrame-&gt;unsafeCallSiteIndex();
 126         }
 127         stackTrace[m_depth] = UnprocessedStackFrame(codeBlock, unsafeCallee, callSiteIndex);











 128         m_depth++;
 129     }
 130 
 131     SUPPRESS_ASAN
 132     void advanceToParentFrame()
 133     {
 134         m_callFrame = m_callFrame-&gt;unsafeCallerFrame(m_entryFrame);
 135     }
 136 
 137     bool isAtTop() const
 138     {
 139         return !m_callFrame;
 140     }
 141 
 142     SUPPRESS_ASAN
 143     void resetAtMachineFrame()
 144     {
 145         if (isAtTop())
 146             return;
 147 
</pre>
<hr />
<pre>
 176             RELEASE_ASSERT(stackLimit &lt;= stackBase);
 177             if (fpCast &lt; stackBase &amp;&amp; fpCast &gt;= stackLimit)
 178                 return true;
 179         }
 180         return false;
 181     }
 182 
 183     bool isValidCodeBlock(CodeBlock* codeBlock)
 184     {
 185         if (!codeBlock)
 186             return false;
 187         bool result = m_vm.heap.codeBlockSet().contains(m_codeBlockSetLocker, codeBlock);
 188         return result;
 189     }
 190 
 191     VM&amp; m_vm;
 192     ExecState* m_callFrame;
 193     EntryFrame* m_entryFrame;
 194     const AbstractLocker&amp; m_codeBlockSetLocker;
 195     const AbstractLocker&amp; m_machineThreadsLocker;

 196     bool m_bailingOut { false };
 197     size_t m_depth { 0 };
 198 };
 199 
 200 class CFrameWalker : public FrameWalker {
 201 public:
 202     typedef FrameWalker Base;
 203 
<span class="line-modified"> 204     CFrameWalker(VM&amp; vm, void* machineFrame, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker)</span>
<span class="line-modified"> 205         : Base(vm, callFrame, codeBlockSetLocker, machineThreadsLocker)</span>
 206         , m_machineFrame(machineFrame)
 207     {
 208     }
 209 
 210     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
 211     {
 212         if (sReportStats)
 213             sNumTotalWalks++;
 214         resetAtMachineFrame();
 215         size_t maxStackTraceSize = stackTrace.size();
 216         // The way the C walker decides if a frame it is about to trace is C or JS is by
 217         // ensuring m_callFrame points to some frame above the machineFrame.
 218         if (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_machineFrame == m_callFrame) {
<span class="line-modified"> 219             recordJSFrame(stackTrace);</span>
 220             Base::advanceToParentFrame();
 221             resetAtMachineFrame();
 222         }
 223 
 224         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
 225             if (m_machineFrame &gt;= m_callFrame) {
 226                 // If we get to this state we probably have an invalid trace.
 227                 m_bailingOut = true;
 228                 break;
 229             }
 230 
 231             if (isCFrame()) {
 232                 RELEASE_ASSERT(!LLInt::isLLIntPC(frame()-&gt;callerFrame));
 233                 stackTrace[m_depth] = UnprocessedStackFrame(frame()-&gt;returnPC);
 234                 m_depth++;
 235             } else
<span class="line-modified"> 236                 recordJSFrame(stackTrace);</span>
 237             advanceToParentFrame();
 238             resetAtMachineFrame();
 239         }
 240         didRunOutOfSpace = m_depth &gt;= maxStackTraceSize &amp;&amp; !isAtTop();
 241         reportStats();
 242         return m_depth;
 243     }
 244 
 245 private:
 246 
 247     bool isCFrame()
 248     {
 249         return frame()-&gt;callerFrame != m_callFrame;
 250     }
 251 
 252     void advanceToParentFrame()
 253     {
 254         if (!isCFrame())
 255             Base::advanceToParentFrame();
 256         m_machineFrame = frame()-&gt;callerFrame;
</pre>
<hr />
<pre>
 260     {
 261         if (!isValidFramePointer(m_machineFrame)) {
 262             // Guard against pausing the process at weird program points.
 263             m_bailingOut = true;
 264             if (sReportStats)
 265                 sNumFailedWalks++;
 266             return;
 267         }
 268         Base::resetAtMachineFrame();
 269     }
 270 
 271     CallerFrameAndPC* frame()
 272     {
 273         return reinterpret_cast&lt;CallerFrameAndPC*&gt;(m_machineFrame);
 274     }
 275 
 276     void* m_machineFrame;
 277 };
 278 
 279 SamplingProfiler::SamplingProfiler(VM&amp; vm, RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
<span class="line-modified"> 280     : m_vm(vm)</span>


 281     , m_weakRandom()
 282     , m_stopwatch(WTFMove(stopwatch))
 283     , m_timingInterval(Seconds::fromMicroseconds(Options::sampleInterval()))
<span class="line-removed"> 284     , m_isPaused(false)</span>
<span class="line-removed"> 285     , m_isShutDown(false)</span>
 286 {
 287     if (sReportStats) {
 288         sNumTotalWalks = 0;
 289         sNumFailedWalks = 0;
 290     }
 291 
 292     m_currentFrames.grow(256);
 293 }
 294 
 295 SamplingProfiler::~SamplingProfiler()
 296 {
 297 }
 298 
 299 void SamplingProfiler::createThreadIfNecessary(const AbstractLocker&amp;)
 300 {
 301     ASSERT(m_lock.isLocked());
 302 
 303     if (m_thread)
 304         return;
 305 
</pre>
<hr />
<pre>
 324             m_lastTime = m_stopwatch-&gt;elapsedTime();
 325         }
 326 
 327         // Read section 6.2 of this paper for more elaboration of why we add a random
 328         // fluctuation here. The main idea is to prevent our timer from being in sync
 329         // with some system process such as a scheduled context switch.
 330         // http://plv.colorado.edu/papers/mytkowicz-pldi10.pdf
 331         double randomSignedNumber = (m_weakRandom.get() * 2.0) - 1.0; // A random number between [-1, 1).
 332         Seconds randomFluctuation = m_timingInterval * 0.2 * randomSignedNumber;
 333         WTF::sleep(m_timingInterval - std::min(m_timingInterval, stackTraceProcessingTime) + randomFluctuation);
 334     }
 335 }
 336 
 337 void SamplingProfiler::takeSample(const AbstractLocker&amp;, Seconds&amp; stackTraceProcessingTime)
 338 {
 339     ASSERT(m_lock.isLocked());
 340     if (m_vm.entryScope) {
 341         Seconds nowTime = m_stopwatch-&gt;elapsedTime();
 342 
 343         auto machineThreadsLocker = holdLock(m_vm.heap.machineThreads().getLock());
<span class="line-modified"> 344         LockHolder codeBlockSetLocker(m_vm.heap.codeBlockSet().getLock());</span>
<span class="line-modified"> 345         LockHolder executableAllocatorLocker(ExecutableAllocator::singleton().getLock());</span>





 346 
 347         auto didSuspend = m_jscExecutionThread-&gt;suspend();
 348         if (didSuspend) {
 349             // While the JSC thread is suspended, we can&#39;t do things like malloc because the JSC thread
 350             // may be holding the malloc lock.
 351             void* machineFrame;
 352             ExecState* callFrame;
 353             void* machinePC;
 354             bool topFrameIsLLInt = false;
 355             void* llintPC;
 356             {
 357                 PlatformRegisters registers;
 358                 m_jscExecutionThread-&gt;getRegisters(registers);
 359                 machineFrame = MachineContext::framePointer(registers);
 360                 callFrame = static_cast&lt;ExecState*&gt;(machineFrame);
 361                 auto instructionPointer = MachineContext::instructionPointer(registers);
 362                 if (instructionPointer)
 363                     machinePC = instructionPointer-&gt;untaggedExecutableAddress();
 364                 else
 365                     machinePC = nullptr;
</pre>
<hr />
<pre>
 371             if (ExecutableAllocator::singleton().isValidExecutableMemory(executableAllocatorLocker, machinePC)) {
 372                 if (m_vm.isExecutingInRegExpJIT) {
 373                     // FIXME: We&#39;re executing a regexp. Lets gather more intersting data.
 374                     // https://bugs.webkit.org/show_bug.cgi?id=152729
 375                     callFrame = m_vm.topCallFrame; // We need to do this or else we&#39;d fail our backtrace validation b/c this isn&#39;t a JS frame.
 376                 }
 377             } else if (LLInt::isLLIntPC(machinePC)) {
 378                 topFrameIsLLInt = true;
 379                 // We&#39;re okay to take a normal stack trace when the PC
 380                 // is in LLInt code.
 381             } else {
 382                 // We resort to topCallFrame to see if we can get anything
 383                 // useful. We usually get here when we&#39;re executing C code.
 384                 callFrame = m_vm.topCallFrame;
 385             }
 386 
 387             size_t walkSize;
 388             bool wasValidWalk;
 389             bool didRunOutOfVectorSpace;
 390             if (Options::sampleCCode()) {
<span class="line-modified"> 391                 CFrameWalker walker(m_vm, machineFrame, callFrame, codeBlockSetLocker, machineThreadsLocker);</span>
 392                 walkSize = walker.walk(m_currentFrames, didRunOutOfVectorSpace);
 393                 wasValidWalk = walker.wasValidWalk();
 394             } else {
<span class="line-modified"> 395                 FrameWalker walker(m_vm, callFrame, codeBlockSetLocker, machineThreadsLocker);</span>
 396                 walkSize = walker.walk(m_currentFrames, didRunOutOfVectorSpace);
 397                 wasValidWalk = walker.wasValidWalk();
 398             }
 399 
 400             m_jscExecutionThread-&gt;resume();
 401 
 402             auto startTime = MonotonicTime::now();
 403             // We can now use data structures that malloc, and do other interesting things, again.
 404 
 405             // FIXME: It&#39;d be interesting to take data about the program&#39;s state when
 406             // we fail to take a stack trace: https://bugs.webkit.org/show_bug.cgi?id=152758
 407             if (wasValidWalk &amp;&amp; walkSize) {
 408                 if (sReportStats)
 409                     sNumTotalStackTraces++;
 410                 Vector&lt;UnprocessedStackFrame&gt; stackTrace;
 411                 stackTrace.reserveInitialCapacity(walkSize);
 412                 for (size_t i = 0; i &lt; walkSize; i++) {
 413                     UnprocessedStackFrame frame = m_currentFrames[i];
 414                     stackTrace.uncheckedAppend(frame);
 415                 }
</pre>
<hr />
<pre>
 417                 m_unprocessedStackTraces.append(UnprocessedStackTrace { nowTime, machinePC, topFrameIsLLInt, llintPC, WTFMove(stackTrace) });
 418 
 419                 if (didRunOutOfVectorSpace)
 420                     m_currentFrames.grow(m_currentFrames.size() * 1.25);
 421             }
 422 
 423             auto endTime = MonotonicTime::now();
 424             stackTraceProcessingTime = endTime - startTime;
 425         }
 426     }
 427 }
 428 
 429 static ALWAYS_INLINE unsigned tryGetBytecodeIndex(unsigned llintPC, CodeBlock* codeBlock, bool&amp; isValid)
 430 {
 431 #if ENABLE(DFG_JIT)
 432     RELEASE_ASSERT(!codeBlock-&gt;hasCodeOrigins());
 433 #endif
 434 
 435 #if USE(JSVALUE64)
 436     unsigned bytecodeIndex = llintPC;
<span class="line-modified"> 437     if (bytecodeIndex &lt; codeBlock-&gt;instructionCount()) {</span>
 438         isValid = true;
 439         return bytecodeIndex;
 440     }
 441     isValid = false;
 442     return 0;
 443 #else
 444     Instruction* instruction = bitwise_cast&lt;Instruction*&gt;(llintPC);
 445 
 446     if (codeBlock-&gt;instructions().contains(instruction)) {
 447         isValid = true;
 448         return codeBlock-&gt;bytecodeOffset(instruction);
 449     }
 450     isValid = false;
 451     return 0;
 452 #endif
 453 }
 454 
 455 void SamplingProfiler::processUnverifiedStackTraces()
 456 {
 457     // This function needs to be called from the JSC execution thread.
 458     RELEASE_ASSERT(m_lock.isLocked());
 459 
 460     TinyBloomFilter filter = m_vm.heap.objectSpace().blocks().filter();
 461 
 462     for (UnprocessedStackTrace&amp; unprocessedStackTrace : m_unprocessedStackTraces) {
 463         m_stackTraces.append(StackTrace());
 464         StackTrace&amp; stackTrace = m_stackTraces.last();
 465         stackTrace.timestamp = unprocessedStackTrace.timestamp;
 466 
 467         auto populateCodeLocation = [] (CodeBlock* codeBlock, unsigned bytecodeIndex, StackFrame::CodeLocation&amp; location) {
<span class="line-modified"> 468             if (bytecodeIndex &lt; codeBlock-&gt;instructionCount()) {</span>
 469                 int divot;
 470                 int startOffset;
 471                 int endOffset;
 472                 codeBlock-&gt;expressionRangeForBytecodeOffset(bytecodeIndex, divot, startOffset, endOffset,
 473                     location.lineNumber, location.columnNumber);
 474                 location.bytecodeIndex = bytecodeIndex;
 475             }
 476             if (Options::collectSamplingProfilerDataForJSCShell()) {
 477                 location.codeBlockHash = codeBlock-&gt;hash();
 478                 location.jitType = codeBlock-&gt;jitType();
 479             }
 480         };
 481 
 482         auto appendCodeBlock = [&amp;] (CodeBlock* codeBlock, unsigned bytecodeIndex) {
 483             stackTrace.frames.append(StackFrame(codeBlock-&gt;ownerExecutable()));
 484             m_liveCellPointers.add(codeBlock-&gt;ownerExecutable());
 485             populateCodeLocation(codeBlock, bytecodeIndex, stackTrace.frames.last().semanticLocation);
 486         };
 487 
 488         auto appendEmptyFrame = [&amp;] {
 489             stackTrace.frames.append(StackFrame());
 490         };
 491 
<span class="line-modified"> 492         auto storeCalleeIntoLastFrame = [&amp;] (CalleeBits calleeBits) {</span>
 493             // Set the callee if it&#39;s a valid GC object.

 494             StackFrame&amp; stackFrame = stackTrace.frames.last();
 495             bool alreadyHasExecutable = !!stackFrame.executable;

 496             if (calleeBits.isWasm()) {
<span class="line-modified"> 497                 stackFrame.frameType = FrameType::Unknown;</span>


 498                 return;
 499             }

 500 
 501             JSValue callee = calleeBits.asCell();
 502             if (!HeapUtil::isValueGCObject(m_vm.heap, filter, callee)) {
 503                 if (!alreadyHasExecutable)
 504                     stackFrame.frameType = FrameType::Unknown;
 505                 return;
 506             }
 507 
 508             JSCell* calleeCell = callee.asCell();
 509             auto setFallbackFrameType = [&amp;] {
 510                 ASSERT(!alreadyHasExecutable);
 511                 FrameType result = FrameType::Unknown;
 512                 CallData callData;
 513                 CallType callType;
 514                 callType = getCallData(m_vm, calleeCell, callData);
 515                 if (callType == CallType::Host)
 516                     result = FrameType::Host;
 517 
 518                 stackFrame.frameType = result;
 519             };
 520 
 521             auto addCallee = [&amp;] (JSObject* callee) {
 522                 stackFrame.callee = callee;
 523                 m_liveCellPointers.add(callee);
 524             };
 525 
 526             if (calleeCell-&gt;type() != JSFunctionType) {
<span class="line-modified"> 527                 if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(*calleeCell-&gt;vm(), calleeCell))</span>
 528                     addCallee(object);
 529 
 530                 if (!alreadyHasExecutable)
 531                     setFallbackFrameType();
 532 
 533                 return;
 534             }
 535 
 536             addCallee(jsCast&lt;JSFunction*&gt;(calleeCell));
 537 
 538             if (alreadyHasExecutable)
 539                 return;
 540 
 541             ExecutableBase* executable = jsCast&lt;JSFunction*&gt;(calleeCell)-&gt;executable();
 542             if (!executable) {
 543                 setFallbackFrameType();
 544                 return;
 545             }
 546 
 547             RELEASE_ASSERT(HeapUtil::isPointerGCObjectJSCell(m_vm.heap, filter, executable));
 548             stackFrame.frameType = FrameType::Executable;
 549             stackFrame.executable = executable;
 550             m_liveCellPointers.add(executable);
 551         };
 552 
 553         auto appendCodeOrigin = [&amp;] (CodeBlock* machineCodeBlock, CodeOrigin origin) {
 554             size_t startIndex = stackTrace.frames.size(); // We want to change stack traces that we&#39;re about to append.
 555 
 556             CodeOrigin machineOrigin;
 557             origin.walkUpInlineStack([&amp;] (const CodeOrigin&amp; codeOrigin) {
 558                 machineOrigin = codeOrigin;
<span class="line-modified"> 559                 appendCodeBlock(codeOrigin.inlineCallFrame ? codeOrigin.inlineCallFrame-&gt;baselineCodeBlock.get() : machineCodeBlock, codeOrigin.bytecodeIndex);</span>

 560             });
 561 
 562             if (Options::collectSamplingProfilerDataForJSCShell()) {
 563                 RELEASE_ASSERT(machineOrigin.isSet());
<span class="line-modified"> 564                 RELEASE_ASSERT(!machineOrigin.inlineCallFrame);</span>
 565 
 566                 StackFrame::CodeLocation machineLocation = stackTrace.frames.last().semanticLocation;
 567 
 568                 // We want to tell each inlined frame about the machine frame
 569                 // they were inlined into. Currently, we only use this for dumping
 570                 // output on the command line, but we could extend it to the web
 571                 // inspector in the future if we find a need for it there.
 572                 RELEASE_ASSERT(stackTrace.frames.size());
 573                 m_liveCellPointers.add(machineCodeBlock);
 574                 for (size_t i = startIndex; i &lt; stackTrace.frames.size() - 1; i++)
 575                     stackTrace.frames[i].machineLocation = std::make_pair(machineLocation, machineCodeBlock);
 576             }
 577         };
 578 
 579         // Prepend the top-most inlined frame if needed and gather
 580         // location information about where the top frame is executing.
 581         size_t startIndex = 0;
 582         if (unprocessedStackTrace.frames.size() &amp;&amp; !!unprocessedStackTrace.frames[0].verifiedCodeBlock) {
 583             CodeBlock* topCodeBlock = unprocessedStackTrace.frames[0].verifiedCodeBlock;
 584             if (unprocessedStackTrace.topFrameIsLLInt) {
 585                 // We reuse LLInt CodeBlocks for the baseline JIT, so we need to check for both jit types.
 586                 // This might also be false for various reasons (known and unknown), even though
 587                 // it&#39;s super unlikely. One reason that this can be false is when we throw from a DFG frame,
 588                 // and we end up having to unwind past an EntryFrame, we will end up executing
 589                 // inside the LLInt&#39;s handleUncaughtException. So we just protect against this
 590                 // by ignoring it.
 591                 unsigned bytecodeIndex = 0;
<span class="line-modified"> 592                 if (topCodeBlock-&gt;jitType() == JITCode::InterpreterThunk || topCodeBlock-&gt;jitType() == JITCode::BaselineJIT) {</span>
 593                     bool isValidPC;
 594                     unsigned bits;
 595 #if USE(JSVALUE64)
 596                     bits = static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(unprocessedStackTrace.llintPC));
 597 #else
 598                     bits = bitwise_cast&lt;unsigned&gt;(unprocessedStackTrace.llintPC);
 599 #endif
 600                     bytecodeIndex = tryGetBytecodeIndex(bits, topCodeBlock, isValidPC);
 601 
 602                     UNUSED_PARAM(isValidPC); // FIXME: do something with this info for the web inspector: https://bugs.webkit.org/show_bug.cgi?id=153455
 603 
 604                     appendCodeBlock(topCodeBlock, bytecodeIndex);
<span class="line-modified"> 605                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0].unverifiedCallee);</span>
 606                     startIndex = 1;
 607                 }
 608             } else {
 609 #if ENABLE(JIT)
 610                 if (Optional&lt;CodeOrigin&gt; codeOrigin = topCodeBlock-&gt;findPC(unprocessedStackTrace.topPC)) {
 611                     appendCodeOrigin(topCodeBlock, *codeOrigin);
<span class="line-modified"> 612                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0].unverifiedCallee);</span>
 613                     startIndex = 1;
 614                 }
 615 #endif
 616                 UNUSED_PARAM(appendCodeOrigin);
 617             }
 618         }
 619 
 620         for (size_t i = startIndex; i &lt; unprocessedStackTrace.frames.size(); i++) {
 621             UnprocessedStackFrame&amp; unprocessedStackFrame = unprocessedStackTrace.frames[i];
 622             if (CodeBlock* codeBlock = unprocessedStackFrame.verifiedCodeBlock) {
 623                 CallSiteIndex callSiteIndex = unprocessedStackFrame.callSiteIndex;
 624 
 625                 auto appendCodeBlockNoInlining = [&amp;] {
 626                     bool isValidPC;
 627                     appendCodeBlock(codeBlock, tryGetBytecodeIndex(callSiteIndex.bits(), codeBlock, isValidPC));
 628                 };
 629 
 630 #if ENABLE(DFG_JIT)
 631                 if (codeBlock-&gt;hasCodeOrigins()) {
 632                     if (codeBlock-&gt;canGetCodeOrigin(callSiteIndex))
 633                         appendCodeOrigin(codeBlock, codeBlock-&gt;codeOrigin(callSiteIndex));
 634                     else
 635                         appendCodeBlock(codeBlock, std::numeric_limits&lt;unsigned&gt;::max());
 636                 } else
 637                     appendCodeBlockNoInlining();
 638 #else
 639                 appendCodeBlockNoInlining();
 640 #endif
 641             } else if (unprocessedStackFrame.cCodePC) {
 642                 appendEmptyFrame();
 643                 stackTrace.frames.last().cCodePC = unprocessedStackFrame.cCodePC;
 644                 stackTrace.frames.last().frameType = FrameType::C;
 645             } else
 646                 appendEmptyFrame();
 647 
 648             // Note that this is okay to do if we walked the inline stack because
 649             // the machine frame will be at the top of the processed stack trace.
 650             if (!unprocessedStackFrame.cCodePC)
<span class="line-modified"> 651                 storeCalleeIntoLastFrame(unprocessedStackFrame.unverifiedCallee);</span>
 652         }
 653     }
 654 
 655     m_unprocessedStackTraces.clear();
 656 }
 657 
 658 void SamplingProfiler::visit(SlotVisitor&amp; slotVisitor)
 659 {
 660     RELEASE_ASSERT(m_lock.isLocked());
 661     for (JSCell* cell : m_liveCellPointers)
 662         slotVisitor.appendUnbarriered(cell);
 663 }
 664 
 665 void SamplingProfiler::shutdown()
 666 {
 667     LockHolder locker(m_lock);
 668     m_isShutDown = true;
 669 }
 670 
 671 void SamplingProfiler::start()
</pre>
<hr />
<pre>
 743             }
 744         }
 745         return String();
 746     };
 747 
 748     String name = getPropertyIfPureOperation(vm.propertyNames-&gt;displayName);
 749     if (!name.isEmpty())
 750         return name;
 751 
 752     return getPropertyIfPureOperation(vm.propertyNames-&gt;name);
 753 }
 754 
 755 String SamplingProfiler::StackFrame::displayName(VM&amp; vm)
 756 {
 757     {
 758         String name = nameFromCallee(vm);
 759         if (!name.isEmpty())
 760             return name;
 761     }
 762 
<span class="line-modified"> 763     if (frameType == FrameType::Unknown || frameType == FrameType::C) {</span>


 764 #if HAVE(DLADDR)
 765         if (frameType == FrameType::C) {
 766             auto demangled = WTF::StackTrace::demangle(const_cast&lt;void*&gt;(cCodePC));
 767             if (demangled)
 768                 return String(demangled-&gt;demangledName() ? demangled-&gt;demangledName() : demangled-&gt;mangledName());
 769             WTF::dataLog(&quot;couldn&#39;t get a name&quot;);
 770         }
 771 #endif
 772         return &quot;(unknown)&quot;_s;
<span class="line-modified"> 773     }</span>
<span class="line-modified"> 774     if (frameType == FrameType::Host)</span>
 775         return &quot;(host)&quot;_s;
 776 
<span class="line-modified"> 777     if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 778         return static_cast&lt;NativeExecutable*&gt;(executable)-&gt;name();</span>




 779 
<span class="line-modified"> 780     if (executable-&gt;isFunctionExecutable())</span>
<span class="line-modified"> 781         return static_cast&lt;FunctionExecutable*&gt;(executable)-&gt;inferredName().string();</span>
<span class="line-modified"> 782     if (executable-&gt;isProgramExecutable() || executable-&gt;isEvalExecutable())</span>
<span class="line-removed"> 783         return &quot;(program)&quot;_s;</span>
<span class="line-removed"> 784     if (executable-&gt;isModuleProgramExecutable())</span>
<span class="line-removed"> 785         return &quot;(module)&quot;_s;</span>
 786 










 787     RELEASE_ASSERT_NOT_REACHED();
 788     return String();
 789 }
 790 
 791 String SamplingProfiler::StackFrame::displayNameForJSONTests(VM&amp; vm)
 792 {
 793     {
 794         String name = nameFromCallee(vm);
 795         if (!name.isEmpty())
 796             return name;
 797     }
 798 
<span class="line-modified"> 799     if (frameType == FrameType::Unknown || frameType == FrameType::C)</span>


 800         return &quot;(unknown)&quot;_s;
<span class="line-removed"> 801     if (frameType == FrameType::Host)</span>
<span class="line-removed"> 802         return &quot;(host)&quot;_s;</span>
 803 
<span class="line-modified"> 804     if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 805         return static_cast&lt;NativeExecutable*&gt;(executable)-&gt;name();</span>
 806 
<span class="line-modified"> 807     if (executable-&gt;isFunctionExecutable()) {</span>
<span class="line-modified"> 808         String result = static_cast&lt;FunctionExecutable*&gt;(executable)-&gt;inferredName().string();</span>
<span class="line-modified"> 809         if (result.isEmpty())</span>
<span class="line-modified"> 810             return &quot;(anonymous function)&quot;_s;</span>
<span class="line-modified"> 811         return result;</span>

 812     }
<span class="line-removed"> 813     if (executable-&gt;isEvalExecutable())</span>
<span class="line-removed"> 814         return &quot;(eval)&quot;_s;</span>
<span class="line-removed"> 815     if (executable-&gt;isProgramExecutable())</span>
<span class="line-removed"> 816         return &quot;(program)&quot;_s;</span>
<span class="line-removed"> 817     if (executable-&gt;isModuleProgramExecutable())</span>
<span class="line-removed"> 818         return &quot;(module)&quot;_s;</span>
 819 




















 820     RELEASE_ASSERT_NOT_REACHED();
 821     return String();
 822 }
 823 
 824 int SamplingProfiler::StackFrame::functionStartLine()
 825 {
<span class="line-modified"> 826     if (frameType == FrameType::Unknown || frameType == FrameType::Host || frameType == FrameType::C)</span>




 827         return -1;
 828 
<span class="line-modified"> 829     if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 830         return -1;</span>
<span class="line-modified"> 831     return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;firstLine();</span>




 832 }
 833 
 834 unsigned SamplingProfiler::StackFrame::functionStartColumn()
 835 {
<span class="line-modified"> 836     if (frameType == FrameType::Unknown || frameType == FrameType::Host || frameType == FrameType::C)</span>




 837         return std::numeric_limits&lt;unsigned&gt;::max();
 838 
<span class="line-modified"> 839     if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 840         return std::numeric_limits&lt;unsigned&gt;::max();</span>

 841 
<span class="line-modified"> 842     return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;startColumn();</span>



 843 }
 844 
 845 intptr_t SamplingProfiler::StackFrame::sourceID()
 846 {
<span class="line-modified"> 847     if (frameType == FrameType::Unknown || frameType == FrameType::Host || frameType == FrameType::C)</span>




 848         return -1;
 849 
<span class="line-modified"> 850     if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 851         return -1;</span>

 852 
<span class="line-modified"> 853     return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;sourceID();</span>



 854 }
 855 
 856 String SamplingProfiler::StackFrame::url()
 857 {
<span class="line-modified"> 858     if (frameType == FrameType::Unknown || frameType == FrameType::Host || frameType == FrameType::C)</span>
<span class="line-modified"> 859         return emptyString();</span>
<span class="line-modified"> 860 </span>
<span class="line-modified"> 861     if (executable-&gt;isHostFunction())</span>

 862         return emptyString();
<span class="line-modified"> 863 </span>
<span class="line-modified"> 864     String url = static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;sourceURL();</span>
<span class="line-modified"> 865     if (url.isEmpty())</span>
<span class="line-modified"> 866         return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;source().provider()-&gt;sourceURLDirective(); // Fall back to sourceURL directive.</span>
<span class="line-modified"> 867     return url;</span>






 868 }
 869 
 870 Vector&lt;SamplingProfiler::StackTrace&gt; SamplingProfiler::releaseStackTraces(const AbstractLocker&amp; locker)
 871 {
 872     ASSERT(m_lock.isLocked());
 873     {
 874         HeapIterationScope heapIterationScope(m_vm.heap);
 875         processUnverifiedStackTraces();
 876     }
 877 
 878     Vector&lt;StackTrace&gt; result(WTFMove(m_stackTraces));
 879     clearData(locker);
 880     return result;
 881 }
 882 
 883 String SamplingProfiler::stackTracesAsJSON()
 884 {
 885     DeferGC deferGC(m_vm.heap);
 886     LockHolder locker(m_lock);
 887 
</pre>
<hr />
<pre>
1007 void SamplingProfiler::reportTopBytecodes()
1008 {
1009     reportTopBytecodes(WTF::dataFile());
1010 }
1011 
1012 void SamplingProfiler::reportTopBytecodes(PrintStream&amp; out)
1013 {
1014     LockHolder locker(m_lock);
1015     DeferGCForAWhile deferGC(m_vm.heap);
1016 
1017     {
1018         HeapIterationScope heapIterationScope(m_vm.heap);
1019         processUnverifiedStackTraces();
1020     }
1021 
1022     HashMap&lt;String, size_t&gt; bytecodeCounts;
1023     for (StackTrace&amp; stackTrace : m_stackTraces) {
1024         if (!stackTrace.frames.size())
1025             continue;
1026 
<span class="line-modified">1027         auto descriptionForLocation = [&amp;] (StackFrame::CodeLocation location) -&gt; String {</span>
1028             String bytecodeIndex;
1029             String codeBlockHash;

1030             if (location.hasBytecodeIndex())
1031                 bytecodeIndex = String::number(location.bytecodeIndex);
1032             else
1033                 bytecodeIndex = &quot;&lt;nil&gt;&quot;;
1034 
1035             if (location.hasCodeBlockHash()) {
1036                 StringPrintStream stream;
1037                 location.codeBlockHash.dump(stream);
1038                 codeBlockHash = stream.toString();
1039             } else
1040                 codeBlockHash = &quot;&lt;nil&gt;&quot;;
1041 
<span class="line-modified">1042             return makeString(&quot;#&quot;, codeBlockHash, &quot;:&quot;, JITCode::typeName(location.jitType), &quot;:&quot;, bytecodeIndex);</span>





1043         };
1044 
1045         StackFrame&amp; frame = stackTrace.frames.first();
<span class="line-modified">1046         String frameDescription = makeString(frame.displayName(m_vm), descriptionForLocation(frame.semanticLocation));</span>
1047         if (Optional&lt;std::pair&lt;StackFrame::CodeLocation, CodeBlock*&gt;&gt; machineLocation = frame.machineLocation) {
1048             frameDescription = makeString(frameDescription, &quot; &lt;-- &quot;,
<span class="line-modified">1049                 machineLocation-&gt;second-&gt;inferredName().data(), descriptionForLocation(machineLocation-&gt;first));</span>
1050         }
1051         bytecodeCounts.add(frameDescription, 0).iterator-&gt;value++;
1052     }
1053 
1054     auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
1055         String maxFrameDescription;
1056         size_t maxFrameCount = 0;
1057         for (auto entry : bytecodeCounts) {
1058             if (entry.value &gt; maxFrameCount) {
1059                 maxFrameCount = entry.value;
1060                 maxFrameDescription = entry.key;
1061             }
1062         }
1063         if (!maxFrameDescription.isEmpty())
1064             bytecodeCounts.remove(maxFrameDescription);
1065         return std::make_pair(maxFrameDescription, maxFrameCount);
1066     };
1067 
1068     if (Options::samplingProfilerTopBytecodesCount()) {
1069         out.print(&quot;\n\nSampling rate: &quot;, m_timingInterval.microseconds(), &quot; microseconds\n&quot;);
</pre>
<hr />
<pre>
1083 {
1084     if (!m_thread)
1085         return MACH_PORT_NULL;
1086 
1087     return m_thread-&gt;machThread();
1088 }
1089 #endif
1090 
1091 } // namespace JSC
1092 
1093 namespace WTF {
1094 
1095 using namespace JSC;
1096 
1097 void printInternal(PrintStream&amp; out, SamplingProfiler::FrameType frameType)
1098 {
1099     switch (frameType) {
1100     case SamplingProfiler::FrameType::Executable:
1101         out.print(&quot;Executable&quot;);
1102         break;



1103     case SamplingProfiler::FrameType::Host:
1104         out.print(&quot;Host&quot;);
1105         break;
1106     case SamplingProfiler::FrameType::C:
1107     case SamplingProfiler::FrameType::Unknown:
1108         out.print(&quot;Unknown&quot;);
1109         break;
1110     }
1111 }
1112 
1113 } // namespace WTF
1114 
1115 #endif // ENABLE(SAMPLING_PROFILER)
</pre>
</td>
<td>
<hr />
<pre>
  31 #include &quot;CallFrame.h&quot;
  32 #include &quot;CatchScope.h&quot;
  33 #include &quot;CodeBlock.h&quot;
  34 #include &quot;CodeBlockSet.h&quot;
  35 #include &quot;HeapIterationScope.h&quot;
  36 #include &quot;HeapUtil.h&quot;
  37 #include &quot;InlineCallFrame.h&quot;
  38 #include &quot;Interpreter.h&quot;
  39 #include &quot;JSCInlines.h&quot;
  40 #include &quot;JSFunction.h&quot;
  41 #include &quot;LLIntPCRanges.h&quot;
  42 #include &quot;MachineContext.h&quot;
  43 #include &quot;MarkedBlock.h&quot;
  44 #include &quot;MarkedBlockSet.h&quot;
  45 #include &quot;MarkedSpaceInlines.h&quot;
  46 #include &quot;NativeExecutable.h&quot;
  47 #include &quot;PCToCodeOriginMap.h&quot;
  48 #include &quot;SlotVisitor.h&quot;
  49 #include &quot;StrongInlines.h&quot;
  50 #include &quot;VM.h&quot;
<span class="line-added">  51 #include &quot;WasmCallee.h&quot;</span>
<span class="line-added">  52 #include &quot;WasmCalleeRegistry.h&quot;</span>
  53 #include &lt;thread&gt;
  54 #include &lt;wtf/FilePrintStream.h&gt;
  55 #include &lt;wtf/HashSet.h&gt;
  56 #include &lt;wtf/RefPtr.h&gt;
  57 #include &lt;wtf/StackTrace.h&gt;
  58 #include &lt;wtf/text/StringBuilder.h&gt;
  59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  60 
  61 namespace JSC {
  62 
  63 static double sNumTotalStackTraces = 0;
  64 static double sNumTotalWalks = 0;
  65 static double sNumFailedWalks = 0;
  66 static const uint32_t sNumWalkReportingFrequency = 50;
  67 static const double sWalkErrorPercentage = .05;
  68 static const bool sReportStatsOnlyWhenTheyreAboveThreshold = false;
  69 static const bool sReportStats = false;
  70 
  71 using FrameType = SamplingProfiler::FrameType;
  72 using UnprocessedStackFrame = SamplingProfiler::UnprocessedStackFrame;
  73 
  74 ALWAYS_INLINE static void reportStats()
  75 {
  76     if (sReportStats &amp;&amp; sNumTotalWalks &amp;&amp; static_cast&lt;uint64_t&gt;(sNumTotalWalks) % sNumWalkReportingFrequency == 0) {
  77         if (!sReportStatsOnlyWhenTheyreAboveThreshold || (sNumFailedWalks / sNumTotalWalks &gt; sWalkErrorPercentage)) {
  78             dataLogF(&quot;Num total walks: %llu. Failed walks percent: %lf\n&quot;,
  79                 static_cast&lt;unsigned long long&gt;(sNumTotalWalks), sNumFailedWalks / sNumTotalWalks);
  80         }
  81     }
  82 }
  83 
  84 class FrameWalker {
  85 public:
<span class="line-modified">  86     FrameWalker(VM&amp; vm, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
  87         : m_vm(vm)
  88         , m_callFrame(callFrame)
  89         , m_entryFrame(vm.topEntryFrame)
  90         , m_codeBlockSetLocker(codeBlockSetLocker)
  91         , m_machineThreadsLocker(machineThreadsLocker)
<span class="line-added">  92         , m_wasmCalleeLocker(wasmCalleeLocker)</span>
  93     {
  94     }
  95 
  96     SUPPRESS_ASAN
  97     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
  98     {
  99         if (sReportStats)
 100             sNumTotalWalks++;
 101         resetAtMachineFrame();
 102         size_t maxStackTraceSize = stackTrace.size();
 103         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
<span class="line-modified"> 104             recordJITFrame(stackTrace);</span>
 105             advanceToParentFrame();
 106             resetAtMachineFrame();
 107         }
 108         didRunOutOfSpace = m_depth &gt;= maxStackTraceSize &amp;&amp; !isAtTop();
 109         reportStats();
 110         return m_depth;
 111     }
 112 
 113     bool wasValidWalk() const
 114     {
 115         return !m_bailingOut;
 116     }
 117 
 118 protected:
 119 
 120     SUPPRESS_ASAN
<span class="line-modified"> 121     void recordJITFrame(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace)</span>
 122     {
 123         CallSiteIndex callSiteIndex;
 124         CalleeBits unsafeCallee = m_callFrame-&gt;unsafeCallee();
 125         CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
 126         if (codeBlock) {
 127             ASSERT(isValidCodeBlock(codeBlock));
 128             callSiteIndex = m_callFrame-&gt;unsafeCallSiteIndex();
 129         }
 130         stackTrace[m_depth] = UnprocessedStackFrame(codeBlock, unsafeCallee, callSiteIndex);
<span class="line-added"> 131 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 132         if (unsafeCallee.isWasm()) {</span>
<span class="line-added"> 133             auto* wasmCallee = unsafeCallee.asWasmCallee();</span>
<span class="line-added"> 134             if (Wasm::CalleeRegistry::singleton().isValidCallee(m_wasmCalleeLocker, wasmCallee)) {</span>
<span class="line-added"> 135                 // At this point, Wasm::Callee would be dying (ref count is 0), but its fields are still live.</span>
<span class="line-added"> 136                 // And we can safely copy Wasm::IndexOrName even when any lock is held by suspended threads.</span>
<span class="line-added"> 137                 stackTrace[m_depth].wasmIndexOrName = wasmCallee-&gt;indexOrName();</span>
<span class="line-added"> 138                 stackTrace[m_depth].wasmCompilationMode = wasmCallee-&gt;compilationMode();</span>
<span class="line-added"> 139             }</span>
<span class="line-added"> 140         }</span>
<span class="line-added"> 141 #endif</span>
 142         m_depth++;
 143     }
 144 
 145     SUPPRESS_ASAN
 146     void advanceToParentFrame()
 147     {
 148         m_callFrame = m_callFrame-&gt;unsafeCallerFrame(m_entryFrame);
 149     }
 150 
 151     bool isAtTop() const
 152     {
 153         return !m_callFrame;
 154     }
 155 
 156     SUPPRESS_ASAN
 157     void resetAtMachineFrame()
 158     {
 159         if (isAtTop())
 160             return;
 161 
</pre>
<hr />
<pre>
 190             RELEASE_ASSERT(stackLimit &lt;= stackBase);
 191             if (fpCast &lt; stackBase &amp;&amp; fpCast &gt;= stackLimit)
 192                 return true;
 193         }
 194         return false;
 195     }
 196 
 197     bool isValidCodeBlock(CodeBlock* codeBlock)
 198     {
 199         if (!codeBlock)
 200             return false;
 201         bool result = m_vm.heap.codeBlockSet().contains(m_codeBlockSetLocker, codeBlock);
 202         return result;
 203     }
 204 
 205     VM&amp; m_vm;
 206     ExecState* m_callFrame;
 207     EntryFrame* m_entryFrame;
 208     const AbstractLocker&amp; m_codeBlockSetLocker;
 209     const AbstractLocker&amp; m_machineThreadsLocker;
<span class="line-added"> 210     const AbstractLocker&amp; m_wasmCalleeLocker;</span>
 211     bool m_bailingOut { false };
 212     size_t m_depth { 0 };
 213 };
 214 
 215 class CFrameWalker : public FrameWalker {
 216 public:
 217     typedef FrameWalker Base;
 218 
<span class="line-modified"> 219     CFrameWalker(VM&amp; vm, void* machineFrame, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
<span class="line-modified"> 220         : Base(vm, callFrame, codeBlockSetLocker, machineThreadsLocker, wasmCalleeLocker)</span>
 221         , m_machineFrame(machineFrame)
 222     {
 223     }
 224 
 225     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
 226     {
 227         if (sReportStats)
 228             sNumTotalWalks++;
 229         resetAtMachineFrame();
 230         size_t maxStackTraceSize = stackTrace.size();
 231         // The way the C walker decides if a frame it is about to trace is C or JS is by
 232         // ensuring m_callFrame points to some frame above the machineFrame.
 233         if (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_machineFrame == m_callFrame) {
<span class="line-modified"> 234             recordJITFrame(stackTrace);</span>
 235             Base::advanceToParentFrame();
 236             resetAtMachineFrame();
 237         }
 238 
 239         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
 240             if (m_machineFrame &gt;= m_callFrame) {
 241                 // If we get to this state we probably have an invalid trace.
 242                 m_bailingOut = true;
 243                 break;
 244             }
 245 
 246             if (isCFrame()) {
 247                 RELEASE_ASSERT(!LLInt::isLLIntPC(frame()-&gt;callerFrame));
 248                 stackTrace[m_depth] = UnprocessedStackFrame(frame()-&gt;returnPC);
 249                 m_depth++;
 250             } else
<span class="line-modified"> 251                 recordJITFrame(stackTrace);</span>
 252             advanceToParentFrame();
 253             resetAtMachineFrame();
 254         }
 255         didRunOutOfSpace = m_depth &gt;= maxStackTraceSize &amp;&amp; !isAtTop();
 256         reportStats();
 257         return m_depth;
 258     }
 259 
 260 private:
 261 
 262     bool isCFrame()
 263     {
 264         return frame()-&gt;callerFrame != m_callFrame;
 265     }
 266 
 267     void advanceToParentFrame()
 268     {
 269         if (!isCFrame())
 270             Base::advanceToParentFrame();
 271         m_machineFrame = frame()-&gt;callerFrame;
</pre>
<hr />
<pre>
 275     {
 276         if (!isValidFramePointer(m_machineFrame)) {
 277             // Guard against pausing the process at weird program points.
 278             m_bailingOut = true;
 279             if (sReportStats)
 280                 sNumFailedWalks++;
 281             return;
 282         }
 283         Base::resetAtMachineFrame();
 284     }
 285 
 286     CallerFrameAndPC* frame()
 287     {
 288         return reinterpret_cast&lt;CallerFrameAndPC*&gt;(m_machineFrame);
 289     }
 290 
 291     void* m_machineFrame;
 292 };
 293 
 294 SamplingProfiler::SamplingProfiler(VM&amp; vm, RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
<span class="line-modified"> 295     : m_isPaused(false)</span>
<span class="line-added"> 296     , m_isShutDown(false)</span>
<span class="line-added"> 297     , m_vm(vm)</span>
 298     , m_weakRandom()
 299     , m_stopwatch(WTFMove(stopwatch))
 300     , m_timingInterval(Seconds::fromMicroseconds(Options::sampleInterval()))


 301 {
 302     if (sReportStats) {
 303         sNumTotalWalks = 0;
 304         sNumFailedWalks = 0;
 305     }
 306 
 307     m_currentFrames.grow(256);
 308 }
 309 
 310 SamplingProfiler::~SamplingProfiler()
 311 {
 312 }
 313 
 314 void SamplingProfiler::createThreadIfNecessary(const AbstractLocker&amp;)
 315 {
 316     ASSERT(m_lock.isLocked());
 317 
 318     if (m_thread)
 319         return;
 320 
</pre>
<hr />
<pre>
 339             m_lastTime = m_stopwatch-&gt;elapsedTime();
 340         }
 341 
 342         // Read section 6.2 of this paper for more elaboration of why we add a random
 343         // fluctuation here. The main idea is to prevent our timer from being in sync
 344         // with some system process such as a scheduled context switch.
 345         // http://plv.colorado.edu/papers/mytkowicz-pldi10.pdf
 346         double randomSignedNumber = (m_weakRandom.get() * 2.0) - 1.0; // A random number between [-1, 1).
 347         Seconds randomFluctuation = m_timingInterval * 0.2 * randomSignedNumber;
 348         WTF::sleep(m_timingInterval - std::min(m_timingInterval, stackTraceProcessingTime) + randomFluctuation);
 349     }
 350 }
 351 
 352 void SamplingProfiler::takeSample(const AbstractLocker&amp;, Seconds&amp; stackTraceProcessingTime)
 353 {
 354     ASSERT(m_lock.isLocked());
 355     if (m_vm.entryScope) {
 356         Seconds nowTime = m_stopwatch-&gt;elapsedTime();
 357 
 358         auto machineThreadsLocker = holdLock(m_vm.heap.machineThreads().getLock());
<span class="line-modified"> 359         auto codeBlockSetLocker = holdLock(m_vm.heap.codeBlockSet().getLock());</span>
<span class="line-modified"> 360         auto executableAllocatorLocker = holdLock(ExecutableAllocator::singleton().getLock());</span>
<span class="line-added"> 361 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 362         auto wasmCalleesLocker = holdLock(Wasm::CalleeRegistry::singleton().getLock());</span>
<span class="line-added"> 363 #else</span>
<span class="line-added"> 364         LockHolder wasmCalleesLocker(NoLockingNecessary);</span>
<span class="line-added"> 365 #endif</span>
 366 
 367         auto didSuspend = m_jscExecutionThread-&gt;suspend();
 368         if (didSuspend) {
 369             // While the JSC thread is suspended, we can&#39;t do things like malloc because the JSC thread
 370             // may be holding the malloc lock.
 371             void* machineFrame;
 372             ExecState* callFrame;
 373             void* machinePC;
 374             bool topFrameIsLLInt = false;
 375             void* llintPC;
 376             {
 377                 PlatformRegisters registers;
 378                 m_jscExecutionThread-&gt;getRegisters(registers);
 379                 machineFrame = MachineContext::framePointer(registers);
 380                 callFrame = static_cast&lt;ExecState*&gt;(machineFrame);
 381                 auto instructionPointer = MachineContext::instructionPointer(registers);
 382                 if (instructionPointer)
 383                     machinePC = instructionPointer-&gt;untaggedExecutableAddress();
 384                 else
 385                     machinePC = nullptr;
</pre>
<hr />
<pre>
 391             if (ExecutableAllocator::singleton().isValidExecutableMemory(executableAllocatorLocker, machinePC)) {
 392                 if (m_vm.isExecutingInRegExpJIT) {
 393                     // FIXME: We&#39;re executing a regexp. Lets gather more intersting data.
 394                     // https://bugs.webkit.org/show_bug.cgi?id=152729
 395                     callFrame = m_vm.topCallFrame; // We need to do this or else we&#39;d fail our backtrace validation b/c this isn&#39;t a JS frame.
 396                 }
 397             } else if (LLInt::isLLIntPC(machinePC)) {
 398                 topFrameIsLLInt = true;
 399                 // We&#39;re okay to take a normal stack trace when the PC
 400                 // is in LLInt code.
 401             } else {
 402                 // We resort to topCallFrame to see if we can get anything
 403                 // useful. We usually get here when we&#39;re executing C code.
 404                 callFrame = m_vm.topCallFrame;
 405             }
 406 
 407             size_t walkSize;
 408             bool wasValidWalk;
 409             bool didRunOutOfVectorSpace;
 410             if (Options::sampleCCode()) {
<span class="line-modified"> 411                 CFrameWalker walker(m_vm, machineFrame, callFrame, codeBlockSetLocker, machineThreadsLocker, wasmCalleesLocker);</span>
 412                 walkSize = walker.walk(m_currentFrames, didRunOutOfVectorSpace);
 413                 wasValidWalk = walker.wasValidWalk();
 414             } else {
<span class="line-modified"> 415                 FrameWalker walker(m_vm, callFrame, codeBlockSetLocker, machineThreadsLocker, wasmCalleesLocker);</span>
 416                 walkSize = walker.walk(m_currentFrames, didRunOutOfVectorSpace);
 417                 wasValidWalk = walker.wasValidWalk();
 418             }
 419 
 420             m_jscExecutionThread-&gt;resume();
 421 
 422             auto startTime = MonotonicTime::now();
 423             // We can now use data structures that malloc, and do other interesting things, again.
 424 
 425             // FIXME: It&#39;d be interesting to take data about the program&#39;s state when
 426             // we fail to take a stack trace: https://bugs.webkit.org/show_bug.cgi?id=152758
 427             if (wasValidWalk &amp;&amp; walkSize) {
 428                 if (sReportStats)
 429                     sNumTotalStackTraces++;
 430                 Vector&lt;UnprocessedStackFrame&gt; stackTrace;
 431                 stackTrace.reserveInitialCapacity(walkSize);
 432                 for (size_t i = 0; i &lt; walkSize; i++) {
 433                     UnprocessedStackFrame frame = m_currentFrames[i];
 434                     stackTrace.uncheckedAppend(frame);
 435                 }
</pre>
<hr />
<pre>
 437                 m_unprocessedStackTraces.append(UnprocessedStackTrace { nowTime, machinePC, topFrameIsLLInt, llintPC, WTFMove(stackTrace) });
 438 
 439                 if (didRunOutOfVectorSpace)
 440                     m_currentFrames.grow(m_currentFrames.size() * 1.25);
 441             }
 442 
 443             auto endTime = MonotonicTime::now();
 444             stackTraceProcessingTime = endTime - startTime;
 445         }
 446     }
 447 }
 448 
 449 static ALWAYS_INLINE unsigned tryGetBytecodeIndex(unsigned llintPC, CodeBlock* codeBlock, bool&amp; isValid)
 450 {
 451 #if ENABLE(DFG_JIT)
 452     RELEASE_ASSERT(!codeBlock-&gt;hasCodeOrigins());
 453 #endif
 454 
 455 #if USE(JSVALUE64)
 456     unsigned bytecodeIndex = llintPC;
<span class="line-modified"> 457     if (bytecodeIndex &lt; codeBlock-&gt;instructionsSize()) {</span>
 458         isValid = true;
 459         return bytecodeIndex;
 460     }
 461     isValid = false;
 462     return 0;
 463 #else
 464     Instruction* instruction = bitwise_cast&lt;Instruction*&gt;(llintPC);
 465 
 466     if (codeBlock-&gt;instructions().contains(instruction)) {
 467         isValid = true;
 468         return codeBlock-&gt;bytecodeOffset(instruction);
 469     }
 470     isValid = false;
 471     return 0;
 472 #endif
 473 }
 474 
 475 void SamplingProfiler::processUnverifiedStackTraces()
 476 {
 477     // This function needs to be called from the JSC execution thread.
 478     RELEASE_ASSERT(m_lock.isLocked());
 479 
 480     TinyBloomFilter filter = m_vm.heap.objectSpace().blocks().filter();
 481 
 482     for (UnprocessedStackTrace&amp; unprocessedStackTrace : m_unprocessedStackTraces) {
 483         m_stackTraces.append(StackTrace());
 484         StackTrace&amp; stackTrace = m_stackTraces.last();
 485         stackTrace.timestamp = unprocessedStackTrace.timestamp;
 486 
 487         auto populateCodeLocation = [] (CodeBlock* codeBlock, unsigned bytecodeIndex, StackFrame::CodeLocation&amp; location) {
<span class="line-modified"> 488             if (bytecodeIndex &lt; codeBlock-&gt;instructionsSize()) {</span>
 489                 int divot;
 490                 int startOffset;
 491                 int endOffset;
 492                 codeBlock-&gt;expressionRangeForBytecodeOffset(bytecodeIndex, divot, startOffset, endOffset,
 493                     location.lineNumber, location.columnNumber);
 494                 location.bytecodeIndex = bytecodeIndex;
 495             }
 496             if (Options::collectSamplingProfilerDataForJSCShell()) {
 497                 location.codeBlockHash = codeBlock-&gt;hash();
 498                 location.jitType = codeBlock-&gt;jitType();
 499             }
 500         };
 501 
 502         auto appendCodeBlock = [&amp;] (CodeBlock* codeBlock, unsigned bytecodeIndex) {
 503             stackTrace.frames.append(StackFrame(codeBlock-&gt;ownerExecutable()));
 504             m_liveCellPointers.add(codeBlock-&gt;ownerExecutable());
 505             populateCodeLocation(codeBlock, bytecodeIndex, stackTrace.frames.last().semanticLocation);
 506         };
 507 
 508         auto appendEmptyFrame = [&amp;] {
 509             stackTrace.frames.append(StackFrame());
 510         };
 511 
<span class="line-modified"> 512         auto storeCalleeIntoLastFrame = [&amp;] (UnprocessedStackFrame&amp; unprocessedStackFrame) {</span>
 513             // Set the callee if it&#39;s a valid GC object.
<span class="line-added"> 514             CalleeBits calleeBits = unprocessedStackFrame.unverifiedCallee;</span>
 515             StackFrame&amp; stackFrame = stackTrace.frames.last();
 516             bool alreadyHasExecutable = !!stackFrame.executable;
<span class="line-added"> 517 #if ENABLE(WEBASSEMBLY)</span>
 518             if (calleeBits.isWasm()) {
<span class="line-modified"> 519                 stackFrame.frameType = FrameType::Wasm;</span>
<span class="line-added"> 520                 stackFrame.wasmIndexOrName = unprocessedStackFrame.wasmIndexOrName;</span>
<span class="line-added"> 521                 stackFrame.wasmCompilationMode = unprocessedStackFrame.wasmCompilationMode;</span>
 522                 return;
 523             }
<span class="line-added"> 524 #endif</span>
 525 
 526             JSValue callee = calleeBits.asCell();
 527             if (!HeapUtil::isValueGCObject(m_vm.heap, filter, callee)) {
 528                 if (!alreadyHasExecutable)
 529                     stackFrame.frameType = FrameType::Unknown;
 530                 return;
 531             }
 532 
 533             JSCell* calleeCell = callee.asCell();
 534             auto setFallbackFrameType = [&amp;] {
 535                 ASSERT(!alreadyHasExecutable);
 536                 FrameType result = FrameType::Unknown;
 537                 CallData callData;
 538                 CallType callType;
 539                 callType = getCallData(m_vm, calleeCell, callData);
 540                 if (callType == CallType::Host)
 541                     result = FrameType::Host;
 542 
 543                 stackFrame.frameType = result;
 544             };
 545 
 546             auto addCallee = [&amp;] (JSObject* callee) {
 547                 stackFrame.callee = callee;
 548                 m_liveCellPointers.add(callee);
 549             };
 550 
 551             if (calleeCell-&gt;type() != JSFunctionType) {
<span class="line-modified"> 552                 if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(calleeCell-&gt;vm(), calleeCell))</span>
 553                     addCallee(object);
 554 
 555                 if (!alreadyHasExecutable)
 556                     setFallbackFrameType();
 557 
 558                 return;
 559             }
 560 
 561             addCallee(jsCast&lt;JSFunction*&gt;(calleeCell));
 562 
 563             if (alreadyHasExecutable)
 564                 return;
 565 
 566             ExecutableBase* executable = jsCast&lt;JSFunction*&gt;(calleeCell)-&gt;executable();
 567             if (!executable) {
 568                 setFallbackFrameType();
 569                 return;
 570             }
 571 
 572             RELEASE_ASSERT(HeapUtil::isPointerGCObjectJSCell(m_vm.heap, filter, executable));
 573             stackFrame.frameType = FrameType::Executable;
 574             stackFrame.executable = executable;
 575             m_liveCellPointers.add(executable);
 576         };
 577 
 578         auto appendCodeOrigin = [&amp;] (CodeBlock* machineCodeBlock, CodeOrigin origin) {
 579             size_t startIndex = stackTrace.frames.size(); // We want to change stack traces that we&#39;re about to append.
 580 
 581             CodeOrigin machineOrigin;
 582             origin.walkUpInlineStack([&amp;] (const CodeOrigin&amp; codeOrigin) {
 583                 machineOrigin = codeOrigin;
<span class="line-modified"> 584                 auto* inlineCallFrame = codeOrigin.inlineCallFrame();</span>
<span class="line-added"> 585                 appendCodeBlock(inlineCallFrame ? inlineCallFrame-&gt;baselineCodeBlock.get() : machineCodeBlock, codeOrigin.bytecodeIndex());</span>
 586             });
 587 
 588             if (Options::collectSamplingProfilerDataForJSCShell()) {
 589                 RELEASE_ASSERT(machineOrigin.isSet());
<span class="line-modified"> 590                 RELEASE_ASSERT(!machineOrigin.inlineCallFrame());</span>
 591 
 592                 StackFrame::CodeLocation machineLocation = stackTrace.frames.last().semanticLocation;
 593 
 594                 // We want to tell each inlined frame about the machine frame
 595                 // they were inlined into. Currently, we only use this for dumping
 596                 // output on the command line, but we could extend it to the web
 597                 // inspector in the future if we find a need for it there.
 598                 RELEASE_ASSERT(stackTrace.frames.size());
 599                 m_liveCellPointers.add(machineCodeBlock);
 600                 for (size_t i = startIndex; i &lt; stackTrace.frames.size() - 1; i++)
 601                     stackTrace.frames[i].machineLocation = std::make_pair(machineLocation, machineCodeBlock);
 602             }
 603         };
 604 
 605         // Prepend the top-most inlined frame if needed and gather
 606         // location information about where the top frame is executing.
 607         size_t startIndex = 0;
 608         if (unprocessedStackTrace.frames.size() &amp;&amp; !!unprocessedStackTrace.frames[0].verifiedCodeBlock) {
 609             CodeBlock* topCodeBlock = unprocessedStackTrace.frames[0].verifiedCodeBlock;
 610             if (unprocessedStackTrace.topFrameIsLLInt) {
 611                 // We reuse LLInt CodeBlocks for the baseline JIT, so we need to check for both jit types.
 612                 // This might also be false for various reasons (known and unknown), even though
 613                 // it&#39;s super unlikely. One reason that this can be false is when we throw from a DFG frame,
 614                 // and we end up having to unwind past an EntryFrame, we will end up executing
 615                 // inside the LLInt&#39;s handleUncaughtException. So we just protect against this
 616                 // by ignoring it.
 617                 unsigned bytecodeIndex = 0;
<span class="line-modified"> 618                 if (topCodeBlock-&gt;jitType() == JITType::InterpreterThunk || topCodeBlock-&gt;jitType() == JITType::BaselineJIT) {</span>
 619                     bool isValidPC;
 620                     unsigned bits;
 621 #if USE(JSVALUE64)
 622                     bits = static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(unprocessedStackTrace.llintPC));
 623 #else
 624                     bits = bitwise_cast&lt;unsigned&gt;(unprocessedStackTrace.llintPC);
 625 #endif
 626                     bytecodeIndex = tryGetBytecodeIndex(bits, topCodeBlock, isValidPC);
 627 
 628                     UNUSED_PARAM(isValidPC); // FIXME: do something with this info for the web inspector: https://bugs.webkit.org/show_bug.cgi?id=153455
 629 
 630                     appendCodeBlock(topCodeBlock, bytecodeIndex);
<span class="line-modified"> 631                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);</span>
 632                     startIndex = 1;
 633                 }
 634             } else {
 635 #if ENABLE(JIT)
 636                 if (Optional&lt;CodeOrigin&gt; codeOrigin = topCodeBlock-&gt;findPC(unprocessedStackTrace.topPC)) {
 637                     appendCodeOrigin(topCodeBlock, *codeOrigin);
<span class="line-modified"> 638                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);</span>
 639                     startIndex = 1;
 640                 }
 641 #endif
 642                 UNUSED_PARAM(appendCodeOrigin);
 643             }
 644         }
 645 
 646         for (size_t i = startIndex; i &lt; unprocessedStackTrace.frames.size(); i++) {
 647             UnprocessedStackFrame&amp; unprocessedStackFrame = unprocessedStackTrace.frames[i];
 648             if (CodeBlock* codeBlock = unprocessedStackFrame.verifiedCodeBlock) {
 649                 CallSiteIndex callSiteIndex = unprocessedStackFrame.callSiteIndex;
 650 
 651                 auto appendCodeBlockNoInlining = [&amp;] {
 652                     bool isValidPC;
 653                     appendCodeBlock(codeBlock, tryGetBytecodeIndex(callSiteIndex.bits(), codeBlock, isValidPC));
 654                 };
 655 
 656 #if ENABLE(DFG_JIT)
 657                 if (codeBlock-&gt;hasCodeOrigins()) {
 658                     if (codeBlock-&gt;canGetCodeOrigin(callSiteIndex))
 659                         appendCodeOrigin(codeBlock, codeBlock-&gt;codeOrigin(callSiteIndex));
 660                     else
 661                         appendCodeBlock(codeBlock, std::numeric_limits&lt;unsigned&gt;::max());
 662                 } else
 663                     appendCodeBlockNoInlining();
 664 #else
 665                 appendCodeBlockNoInlining();
 666 #endif
 667             } else if (unprocessedStackFrame.cCodePC) {
 668                 appendEmptyFrame();
 669                 stackTrace.frames.last().cCodePC = unprocessedStackFrame.cCodePC;
 670                 stackTrace.frames.last().frameType = FrameType::C;
 671             } else
 672                 appendEmptyFrame();
 673 
 674             // Note that this is okay to do if we walked the inline stack because
 675             // the machine frame will be at the top of the processed stack trace.
 676             if (!unprocessedStackFrame.cCodePC)
<span class="line-modified"> 677                 storeCalleeIntoLastFrame(unprocessedStackFrame);</span>
 678         }
 679     }
 680 
 681     m_unprocessedStackTraces.clear();
 682 }
 683 
 684 void SamplingProfiler::visit(SlotVisitor&amp; slotVisitor)
 685 {
 686     RELEASE_ASSERT(m_lock.isLocked());
 687     for (JSCell* cell : m_liveCellPointers)
 688         slotVisitor.appendUnbarriered(cell);
 689 }
 690 
 691 void SamplingProfiler::shutdown()
 692 {
 693     LockHolder locker(m_lock);
 694     m_isShutDown = true;
 695 }
 696 
 697 void SamplingProfiler::start()
</pre>
<hr />
<pre>
 769             }
 770         }
 771         return String();
 772     };
 773 
 774     String name = getPropertyIfPureOperation(vm.propertyNames-&gt;displayName);
 775     if (!name.isEmpty())
 776         return name;
 777 
 778     return getPropertyIfPureOperation(vm.propertyNames-&gt;name);
 779 }
 780 
 781 String SamplingProfiler::StackFrame::displayName(VM&amp; vm)
 782 {
 783     {
 784         String name = nameFromCallee(vm);
 785         if (!name.isEmpty())
 786             return name;
 787     }
 788 
<span class="line-modified"> 789     switch (frameType) {</span>
<span class="line-added"> 790     case FrameType::Unknown:</span>
<span class="line-added"> 791     case FrameType::C:</span>
 792 #if HAVE(DLADDR)
 793         if (frameType == FrameType::C) {
 794             auto demangled = WTF::StackTrace::demangle(const_cast&lt;void*&gt;(cCodePC));
 795             if (demangled)
 796                 return String(demangled-&gt;demangledName() ? demangled-&gt;demangledName() : demangled-&gt;mangledName());
 797             WTF::dataLog(&quot;couldn&#39;t get a name&quot;);
 798         }
 799 #endif
 800         return &quot;(unknown)&quot;_s;
<span class="line-modified"> 801 </span>
<span class="line-modified"> 802     case FrameType::Host:</span>
 803         return &quot;(host)&quot;_s;
 804 
<span class="line-modified"> 805     case FrameType::Wasm:</span>
<span class="line-modified"> 806 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 807         if (wasmIndexOrName)</span>
<span class="line-added"> 808             return makeString(wasmIndexOrName.value());</span>
<span class="line-added"> 809 #endif</span>
<span class="line-added"> 810         return &quot;(wasm)&quot;_s;</span>
 811 
<span class="line-modified"> 812     case FrameType::Executable:</span>
<span class="line-modified"> 813         if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 814             return static_cast&lt;NativeExecutable*&gt;(executable)-&gt;name();</span>



 815 
<span class="line-added"> 816         if (executable-&gt;isFunctionExecutable())</span>
<span class="line-added"> 817             return static_cast&lt;FunctionExecutable*&gt;(executable)-&gt;ecmaName().string();</span>
<span class="line-added"> 818         if (executable-&gt;isProgramExecutable() || executable-&gt;isEvalExecutable())</span>
<span class="line-added"> 819             return &quot;(program)&quot;_s;</span>
<span class="line-added"> 820         if (executable-&gt;isModuleProgramExecutable())</span>
<span class="line-added"> 821             return &quot;(module)&quot;_s;</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 824         return String();</span>
<span class="line-added"> 825     }</span>
 826     RELEASE_ASSERT_NOT_REACHED();
 827     return String();
 828 }
 829 
 830 String SamplingProfiler::StackFrame::displayNameForJSONTests(VM&amp; vm)
 831 {
 832     {
 833         String name = nameFromCallee(vm);
 834         if (!name.isEmpty())
 835             return name;
 836     }
 837 
<span class="line-modified"> 838     switch (frameType) {</span>
<span class="line-added"> 839     case FrameType::Unknown:</span>
<span class="line-added"> 840     case FrameType::C:</span>
 841         return &quot;(unknown)&quot;_s;


 842 
<span class="line-modified"> 843     case FrameType::Host:</span>
<span class="line-modified"> 844         return &quot;(host)&quot;_s;</span>
 845 
<span class="line-modified"> 846     case FrameType::Wasm: {</span>
<span class="line-modified"> 847 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-modified"> 848         if (wasmIndexOrName)</span>
<span class="line-modified"> 849             return makeString(wasmIndexOrName.value());</span>
<span class="line-modified"> 850 #endif</span>
<span class="line-added"> 851         return &quot;(wasm)&quot;_s;</span>
 852     }






 853 
<span class="line-added"> 854     case FrameType::Executable:</span>
<span class="line-added"> 855         if (executable-&gt;isHostFunction())</span>
<span class="line-added"> 856             return static_cast&lt;NativeExecutable*&gt;(executable)-&gt;name();</span>
<span class="line-added"> 857 </span>
<span class="line-added"> 858         if (executable-&gt;isFunctionExecutable()) {</span>
<span class="line-added"> 859             String result = static_cast&lt;FunctionExecutable*&gt;(executable)-&gt;ecmaName().string();</span>
<span class="line-added"> 860             if (result.isEmpty())</span>
<span class="line-added"> 861                 return &quot;(anonymous function)&quot;_s;</span>
<span class="line-added"> 862             return result;</span>
<span class="line-added"> 863         }</span>
<span class="line-added"> 864         if (executable-&gt;isEvalExecutable())</span>
<span class="line-added"> 865             return &quot;(eval)&quot;_s;</span>
<span class="line-added"> 866         if (executable-&gt;isProgramExecutable())</span>
<span class="line-added"> 867             return &quot;(program)&quot;_s;</span>
<span class="line-added"> 868         if (executable-&gt;isModuleProgramExecutable())</span>
<span class="line-added"> 869             return &quot;(module)&quot;_s;</span>
<span class="line-added"> 870 </span>
<span class="line-added"> 871         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 872         return String();</span>
<span class="line-added"> 873     }</span>
 874     RELEASE_ASSERT_NOT_REACHED();
 875     return String();
 876 }
 877 
 878 int SamplingProfiler::StackFrame::functionStartLine()
 879 {
<span class="line-modified"> 880     switch (frameType) {</span>
<span class="line-added"> 881     case FrameType::Unknown:</span>
<span class="line-added"> 882     case FrameType::Host:</span>
<span class="line-added"> 883     case FrameType::C:</span>
<span class="line-added"> 884     case FrameType::Wasm:</span>
 885         return -1;
 886 
<span class="line-modified"> 887     case FrameType::Executable:</span>
<span class="line-modified"> 888         if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 889             return -1;</span>
<span class="line-added"> 890         return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;firstLine();</span>
<span class="line-added"> 891     }</span>
<span class="line-added"> 892     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 893     return -1;</span>
 894 }
 895 
 896 unsigned SamplingProfiler::StackFrame::functionStartColumn()
 897 {
<span class="line-modified"> 898     switch (frameType) {</span>
<span class="line-added"> 899     case FrameType::Unknown:</span>
<span class="line-added"> 900     case FrameType::Host:</span>
<span class="line-added"> 901     case FrameType::C:</span>
<span class="line-added"> 902     case FrameType::Wasm:</span>
 903         return std::numeric_limits&lt;unsigned&gt;::max();
 904 
<span class="line-modified"> 905     case FrameType::Executable:</span>
<span class="line-modified"> 906         if (executable-&gt;isHostFunction())</span>
<span class="line-added"> 907             return std::numeric_limits&lt;unsigned&gt;::max();</span>
 908 
<span class="line-modified"> 909         return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;startColumn();</span>
<span class="line-added"> 910     }</span>
<span class="line-added"> 911     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 912     return std::numeric_limits&lt;unsigned&gt;::max();</span>
 913 }
 914 
 915 intptr_t SamplingProfiler::StackFrame::sourceID()
 916 {
<span class="line-modified"> 917     switch (frameType) {</span>
<span class="line-added"> 918     case FrameType::Unknown:</span>
<span class="line-added"> 919     case FrameType::Host:</span>
<span class="line-added"> 920     case FrameType::C:</span>
<span class="line-added"> 921     case FrameType::Wasm:</span>
 922         return -1;
 923 
<span class="line-modified"> 924     case FrameType::Executable:</span>
<span class="line-modified"> 925         if (executable-&gt;isHostFunction())</span>
<span class="line-added"> 926             return -1;</span>
 927 
<span class="line-modified"> 928         return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;sourceID();</span>
<span class="line-added"> 929     }</span>
<span class="line-added"> 930     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 931     return -1;</span>
 932 }
 933 
 934 String SamplingProfiler::StackFrame::url()
 935 {
<span class="line-modified"> 936     switch (frameType) {</span>
<span class="line-modified"> 937     case FrameType::Unknown:</span>
<span class="line-modified"> 938     case FrameType::Host:</span>
<span class="line-modified"> 939     case FrameType::C:</span>
<span class="line-added"> 940     case FrameType::Wasm:</span>
 941         return emptyString();
<span class="line-modified"> 942     case FrameType::Executable:</span>
<span class="line-modified"> 943         if (executable-&gt;isHostFunction())</span>
<span class="line-modified"> 944             return emptyString();</span>
<span class="line-modified"> 945 </span>
<span class="line-modified"> 946         String url = static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;sourceURL();</span>
<span class="line-added"> 947         if (url.isEmpty())</span>
<span class="line-added"> 948             return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;source().provider()-&gt;sourceURLDirective(); // Fall back to sourceURL directive.</span>
<span class="line-added"> 949         return url;</span>
<span class="line-added"> 950     }</span>
<span class="line-added"> 951     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 952     return String();</span>
 953 }
 954 
 955 Vector&lt;SamplingProfiler::StackTrace&gt; SamplingProfiler::releaseStackTraces(const AbstractLocker&amp; locker)
 956 {
 957     ASSERT(m_lock.isLocked());
 958     {
 959         HeapIterationScope heapIterationScope(m_vm.heap);
 960         processUnverifiedStackTraces();
 961     }
 962 
 963     Vector&lt;StackTrace&gt; result(WTFMove(m_stackTraces));
 964     clearData(locker);
 965     return result;
 966 }
 967 
 968 String SamplingProfiler::stackTracesAsJSON()
 969 {
 970     DeferGC deferGC(m_vm.heap);
 971     LockHolder locker(m_lock);
 972 
</pre>
<hr />
<pre>
1092 void SamplingProfiler::reportTopBytecodes()
1093 {
1094     reportTopBytecodes(WTF::dataFile());
1095 }
1096 
1097 void SamplingProfiler::reportTopBytecodes(PrintStream&amp; out)
1098 {
1099     LockHolder locker(m_lock);
1100     DeferGCForAWhile deferGC(m_vm.heap);
1101 
1102     {
1103         HeapIterationScope heapIterationScope(m_vm.heap);
1104         processUnverifiedStackTraces();
1105     }
1106 
1107     HashMap&lt;String, size_t&gt; bytecodeCounts;
1108     for (StackTrace&amp; stackTrace : m_stackTraces) {
1109         if (!stackTrace.frames.size())
1110             continue;
1111 
<span class="line-modified">1112         auto descriptionForLocation = [&amp;] (StackFrame::CodeLocation location, Optional&lt;Wasm::CompilationMode&gt; wasmCompilationMode) -&gt; String {</span>
1113             String bytecodeIndex;
1114             String codeBlockHash;
<span class="line-added">1115             String jitType;</span>
1116             if (location.hasBytecodeIndex())
1117                 bytecodeIndex = String::number(location.bytecodeIndex);
1118             else
1119                 bytecodeIndex = &quot;&lt;nil&gt;&quot;;
1120 
1121             if (location.hasCodeBlockHash()) {
1122                 StringPrintStream stream;
1123                 location.codeBlockHash.dump(stream);
1124                 codeBlockHash = stream.toString();
1125             } else
1126                 codeBlockHash = &quot;&lt;nil&gt;&quot;;
1127 
<span class="line-modified">1128             if (wasmCompilationMode)</span>
<span class="line-added">1129                 jitType = Wasm::makeString(wasmCompilationMode.value());</span>
<span class="line-added">1130             else</span>
<span class="line-added">1131                 jitType = JITCode::typeName(location.jitType);</span>
<span class="line-added">1132 </span>
<span class="line-added">1133             return makeString(&quot;#&quot;, codeBlockHash, &quot;:&quot;, jitType, &quot;:&quot;, bytecodeIndex);</span>
1134         };
1135 
1136         StackFrame&amp; frame = stackTrace.frames.first();
<span class="line-modified">1137         String frameDescription = makeString(frame.displayName(m_vm), descriptionForLocation(frame.semanticLocation, frame.wasmCompilationMode));</span>
1138         if (Optional&lt;std::pair&lt;StackFrame::CodeLocation, CodeBlock*&gt;&gt; machineLocation = frame.machineLocation) {
1139             frameDescription = makeString(frameDescription, &quot; &lt;-- &quot;,
<span class="line-modified">1140                 machineLocation-&gt;second-&gt;inferredName().data(), descriptionForLocation(machineLocation-&gt;first, WTF::nullopt));</span>
1141         }
1142         bytecodeCounts.add(frameDescription, 0).iterator-&gt;value++;
1143     }
1144 
1145     auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
1146         String maxFrameDescription;
1147         size_t maxFrameCount = 0;
1148         for (auto entry : bytecodeCounts) {
1149             if (entry.value &gt; maxFrameCount) {
1150                 maxFrameCount = entry.value;
1151                 maxFrameDescription = entry.key;
1152             }
1153         }
1154         if (!maxFrameDescription.isEmpty())
1155             bytecodeCounts.remove(maxFrameDescription);
1156         return std::make_pair(maxFrameDescription, maxFrameCount);
1157     };
1158 
1159     if (Options::samplingProfilerTopBytecodesCount()) {
1160         out.print(&quot;\n\nSampling rate: &quot;, m_timingInterval.microseconds(), &quot; microseconds\n&quot;);
</pre>
<hr />
<pre>
1174 {
1175     if (!m_thread)
1176         return MACH_PORT_NULL;
1177 
1178     return m_thread-&gt;machThread();
1179 }
1180 #endif
1181 
1182 } // namespace JSC
1183 
1184 namespace WTF {
1185 
1186 using namespace JSC;
1187 
1188 void printInternal(PrintStream&amp; out, SamplingProfiler::FrameType frameType)
1189 {
1190     switch (frameType) {
1191     case SamplingProfiler::FrameType::Executable:
1192         out.print(&quot;Executable&quot;);
1193         break;
<span class="line-added">1194     case SamplingProfiler::FrameType::Wasm:</span>
<span class="line-added">1195         out.print(&quot;Wasm&quot;);</span>
<span class="line-added">1196         break;</span>
1197     case SamplingProfiler::FrameType::Host:
1198         out.print(&quot;Host&quot;);
1199         break;
1200     case SamplingProfiler::FrameType::C:
1201     case SamplingProfiler::FrameType::Unknown:
1202         out.print(&quot;Unknown&quot;);
1203         break;
1204     }
1205 }
1206 
1207 } // namespace WTF
1208 
1209 #endif // ENABLE(SAMPLING_PROFILER)
</pre>
</td>
</tr>
</table>
<center><a href="RuntimeType.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SamplingProfiler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>