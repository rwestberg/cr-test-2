<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLLink.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   29 #if ENABLE(FTL_JIT)
   30 
   31 #include &quot;AirCode.h&quot;
   32 #include &quot;AirGenerationContext.h&quot;
   33 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
   34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
   35 #include &quot;AtomicsObject.h&quot;
   36 #include &quot;B3CheckValue.h&quot;
   37 #include &quot;B3FenceValue.h&quot;
   38 #include &quot;B3PatchpointValue.h&quot;
   39 #include &quot;B3SlotBaseValue.h&quot;
   40 #include &quot;B3StackmapGenerationParams.h&quot;
   41 #include &quot;B3ValueInlines.h&quot;
   42 #include &quot;CallFrameShuffler.h&quot;
   43 #include &quot;CodeBlockWithJITType.h&quot;
   44 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   45 #include &quot;DFGCapabilities.h&quot;
   46 #include &quot;DFGDoesGC.h&quot;
   47 #include &quot;DFGDominators.h&quot;
   48 #include &quot;DFGInPlaceAbstractState.h&quot;

   49 #include &quot;DFGMayExit.h&quot;
   50 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
   51 #include &quot;DFGOSRExitFuzz.h&quot;
   52 #include &quot;DirectArguments.h&quot;
   53 #include &quot;FTLAbstractHeapRepository.h&quot;
   54 #include &quot;FTLAvailableRecovery.h&quot;
   55 #include &quot;FTLExceptionTarget.h&quot;
   56 #include &quot;FTLForOSREntryJITCode.h&quot;
   57 #include &quot;FTLFormattedValue.h&quot;
   58 #include &quot;FTLLazySlowPathCall.h&quot;
   59 #include &quot;FTLLoweredNodeValue.h&quot;
   60 #include &quot;FTLOperations.h&quot;
   61 #include &quot;FTLOutput.h&quot;
   62 #include &quot;FTLPatchpointExceptionHandle.h&quot;
   63 #include &quot;FTLSnippetParams.h&quot;
   64 #include &quot;FTLThunks.h&quot;
   65 #include &quot;FTLWeightedTarget.h&quot;
   66 #include &quot;JITAddGenerator.h&quot;
   67 #include &quot;JITBitAndGenerator.h&quot;
   68 #include &quot;JITBitOrGenerator.h&quot;
   69 #include &quot;JITBitXorGenerator.h&quot;
   70 #include &quot;JITDivGenerator.h&quot;
   71 #include &quot;JITInlineCacheGenerator.h&quot;
   72 #include &quot;JITLeftShiftGenerator.h&quot;
   73 #include &quot;JITMathIC.h&quot;
   74 #include &quot;JITMulGenerator.h&quot;
   75 #include &quot;JITRightShiftGenerator.h&quot;
   76 #include &quot;JITSubGenerator.h&quot;
   77 #include &quot;JSAsyncFunction.h&quot;
   78 #include &quot;JSAsyncGeneratorFunction.h&quot;
   79 #include &quot;JSCInlines.h&quot;
   80 #include &quot;JSGeneratorFunction.h&quot;
   81 #include &quot;JSImmutableButterfly.h&quot;
   82 #include &quot;JSLexicalEnvironment.h&quot;
   83 #include &quot;JSMap.h&quot;
   84 #include &quot;OperandsInlines.h&quot;

   85 #include &quot;RegExpObject.h&quot;
   86 #include &quot;ScopedArguments.h&quot;
   87 #include &quot;ScopedArgumentsTable.h&quot;
   88 #include &quot;ScratchRegisterAllocator.h&quot;
   89 #include &quot;SetupVarargsFrame.h&quot;
   90 #include &quot;ShadowChicken.h&quot;
   91 #include &quot;StructureStubInfo.h&quot;
   92 #include &quot;SuperSampler.h&quot;
   93 #include &quot;ThunkGenerators.h&quot;
   94 #include &quot;VirtualRegister.h&quot;
   95 #include &quot;Watchdog.h&quot;
   96 #include &lt;atomic&gt;
   97 #include &lt;wtf/Box.h&gt;
   98 #include &lt;wtf/Gigacage.h&gt;
   99 #include &lt;wtf/RecursableLambda.h&gt;
  100 #include &lt;wtf/StdUnorderedSet.h&gt;
  101 
  102 #undef RELEASE_ASSERT
  103 #define RELEASE_ASSERT(assertion) do { \
  104     if (!(assertion)) { \
</pre>
<hr />
<pre>
  138             break;                                                      \
  139         typeCheck(_ftc_lowValue, _ftc_highValue, _ftc_typesPassedThrough, (failCondition), exitKind); \
  140     } while (false)
  141 
  142 #define FTL_TYPE_CHECK(lowValue, highValue, typesPassedThrough, failCondition) \
  143     FTL_TYPE_CHECK_WITH_EXIT_KIND(BadType, lowValue, highValue, typesPassedThrough, failCondition)
  144 
  145 class LowerDFGToB3 {
  146     WTF_MAKE_NONCOPYABLE(LowerDFGToB3);
  147 public:
  148     LowerDFGToB3(State&amp; state)
  149         : m_graph(state.graph)
  150         , m_ftlState(state)
  151         , m_out(state)
  152         , m_proc(*state.proc)
  153         , m_availabilityCalculator(m_graph)
  154         , m_state(state.graph)
  155         , m_interpreter(state.graph, m_state)
  156         , m_indexMaskingMode(Options::enableSpectreMitigations() ?  IndexMaskingEnabled : IndexMaskingDisabled)
  157     {























  158     }
  159 
  160     void lower()
  161     {
  162         State* state = &amp;m_ftlState;
  163 
  164         CString name;
  165         if (verboseCompilationEnabled()) {
  166             name = toCString(
  167                 &quot;jsBody_&quot;, ++compileCounter, &quot;_&quot;, codeBlock()-&gt;inferredName(),
  168                 &quot;_&quot;, codeBlock()-&gt;hash());
  169         } else
  170             name = &quot;jsBody&quot;;
  171 
  172         {
  173             m_proc.setNumEntrypoints(m_graph.m_numberOfEntrypoints);
  174             CodeBlock* codeBlock = m_graph.m_codeBlock;
  175 
  176             Ref&lt;B3::Air::PrologueGenerator&gt; catchPrologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;(
  177                 [codeBlock] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
</pre>
<hr />
<pre>
  457                 break;
  458         }
  459         m_nextLowBlock = m_nextHighBlock ? m_blocks.get(m_nextHighBlock) : 0;
  460 
  461         // All of this effort to find the next block gives us the ability to keep the
  462         // generated IR in roughly program order. This ought not affect the performance
  463         // of the generated code (since we expect B3 to reorder things) but it will
  464         // make IR dumps easier to read.
  465         m_out.appendTo(lowBlock, m_nextLowBlock);
  466 
  467         if (Options::ftlCrashes())
  468             m_out.trap();
  469 
  470         if (!m_highBlock-&gt;cfaHasVisited) {
  471             if (verboseCompilationEnabled())
  472                 dataLog(&quot;Bailing because CFA didn&#39;t reach.\n&quot;);
  473             crash(m_highBlock, nullptr);
  474             return;
  475         }
  476 


  477         m_availabilityCalculator.beginBlock(m_highBlock);
  478 
  479         m_state.reset();
  480         m_state.beginBasicBlock(m_highBlock);
  481 
  482         for (m_nodeIndex = 0; m_nodeIndex &lt; m_highBlock-&gt;size(); ++m_nodeIndex) {
  483             if (!compileNode(m_nodeIndex))
  484                 break;
  485         }
  486     }
  487 
  488     void safelyInvalidateAfterTermination()
  489     {
  490         if (verboseCompilationEnabled())
  491             dataLog(&quot;Bailing.\n&quot;);
  492         crash();
  493 
  494         // Invalidate dominated blocks. Under normal circumstances we would expect
  495         // them to be invalidated already. But you can have the CFA become more
  496         // precise over time because the structures of objects change on the main
  497         // thread. Failing to do this would result in weird crashes due to a value
  498         // being used but not defined. Race conditions FTW!
  499         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  500             DFG::BasicBlock* target = m_graph.block(blockIndex);
  501             if (!target)
  502                 continue;
  503             if (m_graph.m_ssaDominators-&gt;dominates(m_highBlock, target)) {
  504                 if (verboseCompilationEnabled())
  505                     dataLog(&quot;Block &quot;, *target, &quot; will bail also.\n&quot;);
  506                 target-&gt;cfaHasVisited = false;
  507             }
  508         }
  509     }
  510 































































































































  511     bool compileNode(unsigned nodeIndex)
  512     {
  513         if (!m_state.isValid()) {
  514             safelyInvalidateAfterTermination();
  515             return false;
  516         }
  517 
  518         m_node = m_highBlock-&gt;at(nodeIndex);
  519         m_origin = m_node-&gt;origin;
  520         m_out.setOrigin(m_node);
  521 
  522         if (verboseCompilationEnabled())
  523             dataLog(&quot;Lowering &quot;, m_node, &quot;\n&quot;);
  524 
<span class="line-removed">  525         m_availableRecoveries.shrink(0);</span>
<span class="line-removed">  526 </span>
  527         m_interpreter.startExecuting();
  528         m_interpreter.executeKnownEdgeTypes(m_node);
  529 



  530         if (validateDFGDoesGC) {
  531             bool expectDoesGC = doesGC(m_graph, m_node);
  532             m_out.store(m_out.constBool(expectDoesGC), m_out.absolute(vm().heap.addressOfExpectDoesGC()));
  533         }
  534 
  535         switch (m_node-&gt;op()) {
  536         case DFG::Upsilon:
  537             compileUpsilon();
  538             break;
  539         case DFG::Phi:
  540             compilePhi();
  541             break;
  542         case JSConstant:
  543             break;
  544         case DoubleConstant:
  545             compileDoubleConstant();
  546             break;
  547         case Int52Constant:
  548             compileInt52Constant();
  549             break;
</pre>
<hr />
<pre>
  608             break;
  609         case StrCat:
  610             compileStrCat();
  611             break;
  612         case ArithAdd:
  613         case ArithSub:
  614             compileArithAddOrSub();
  615             break;
  616         case ArithClz32:
  617             compileArithClz32();
  618             break;
  619         case ArithMul:
  620             compileArithMul();
  621             break;
  622         case ValueDiv:
  623             compileValueDiv();
  624             break;
  625         case ArithDiv:
  626             compileArithDiv();
  627             break;



  628         case ArithMod:
  629             compileArithMod();
  630             break;
  631         case ArithMin:
  632         case ArithMax:
  633             compileArithMinOrMax();
  634             break;
  635         case ArithAbs:
  636             compileArithAbs();
  637             break;



  638         case ArithPow:
  639             compileArithPow();
  640             break;
  641         case ArithRandom:
  642             compileArithRandom();
  643             break;
  644         case ArithRound:
  645             compileArithRound();
  646             break;
  647         case ArithFloor:
  648             compileArithFloor();
  649             break;
  650         case ArithCeil:
  651             compileArithCeil();
  652             break;
  653         case ArithTrunc:
  654             compileArithTrunc();
  655             break;
  656         case ArithSqrt:
  657             compileArithSqrt();
  658             break;
  659         case ArithFRound:
  660             compileArithFRound();
  661             break;
  662         case ArithNegate:
  663             compileArithNegate();
  664             break;
  665         case ArithUnary:
  666             compileArithUnary();
  667             break;



  668         case ArithBitNot:
  669             compileArithBitNot();
  670             break;
  671         case ValueBitAnd:
  672             compileValueBitAnd();
  673             break;
  674         case ArithBitAnd:
  675             compileArithBitAnd();
  676             break;
  677         case ValueBitOr:
  678             compileValueBitOr();
  679             break;
  680         case ArithBitOr:
  681             compileArithBitOr();
  682             break;
  683         case ArithBitXor:
  684             compileArithBitXor();
  685             break;
  686         case ValueBitXor:
  687             compileValueBitXor();
  688             break;
  689         case BitRShift:
  690             compileBitRShift();
  691             break;
<span class="line-modified">  692         case BitLShift:</span>
<span class="line-modified">  693             compileBitLShift();</span>



  694             break;
  695         case BitURShift:
  696             compileBitURShift();
  697             break;
  698         case UInt32ToNumber:
  699             compileUInt32ToNumber();
  700             break;
  701         case CheckStructure:
  702             compileCheckStructure();
  703             break;
  704         case CheckStructureOrEmpty:
  705             compileCheckStructureOrEmpty();
  706             break;
  707         case CheckCell:
  708             compileCheckCell();
  709             break;
  710         case CheckNotEmpty:
  711             compileCheckNotEmpty();
  712             break;
  713         case AssertNotEmpty:
</pre>
<hr />
<pre>
 1757         ASSERT(scratchBuffer);
 1758         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 1759     }
 1760 
 1761     void compileGetStack()
 1762     {
 1763         StackAccessData* data = m_node-&gt;stackAccessData();
 1764         AbstractValue&amp; value = m_state.operand(data-&gt;local);
 1765 
 1766         DFG_ASSERT(m_graph, m_node, isConcrete(data-&gt;format), data-&gt;format);
 1767 
 1768         switch (data-&gt;format) {
 1769         case FlushedDouble:
 1770             setDouble(m_out.loadDouble(addressFor(data-&gt;machineLocal)));
 1771             break;
 1772         case FlushedInt52:
 1773             setInt52(m_out.load64(addressFor(data-&gt;machineLocal)));
 1774             break;
 1775         default:
 1776             if (isInt32Speculation(value.m_type))
<span class="line-modified"> 1777             setInt32(m_out.load32(payloadFor(data-&gt;machineLocal)));</span>
<span class="line-modified"> 1778         else</span>
<span class="line-modified"> 1779             setJSValue(m_out.load64(addressFor(data-&gt;machineLocal)));</span>
 1780             break;
 1781         }
 1782     }
 1783 
 1784     void compilePutStack()
 1785     {
 1786         StackAccessData* data = m_node-&gt;stackAccessData();
 1787         switch (data-&gt;format) {
 1788         case FlushedJSValue: {
 1789             LValue value = lowJSValue(m_node-&gt;child1());
 1790             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1791             break;
 1792         }
 1793 
 1794         case FlushedDouble: {
 1795             LValue value = lowDouble(m_node-&gt;child1());
 1796             m_out.storeDouble(value, addressFor(data-&gt;machineLocal));
 1797             break;
 1798         }
 1799 
</pre>
<hr />
<pre>
 1890         ValueFromBlock slowResult = m_out.anchor(
 1891             vmCall(Int64, m_out.operation(function), m_callFrame, value));
 1892         m_out.jump(continuation);
 1893 
 1894         m_out.appendTo(continuation, lastNext);
 1895         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 1896     }
 1897 
 1898     void compileValueAdd()
 1899     {
 1900         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 1901             LValue left = lowBigInt(m_node-&gt;child1());
 1902             LValue right = lowBigInt(m_node-&gt;child2());
 1903 
 1904             LValue result = vmCall(pointerType(), m_out.operation(operationAddBigInt), m_callFrame, left, right);
 1905             setJSValue(result);
 1906             return;
 1907         }
 1908 
 1909         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 1910         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 1911         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 1912         auto repatchingFunction = operationValueAddOptimize;
 1913         auto nonRepatchingFunction = operationValueAdd;
<span class="line-modified"> 1914         compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 1915     }
 1916 
 1917     void compileValueSub()
 1918     {
 1919         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 1920             LValue left = lowBigInt(m_node-&gt;child1());
 1921             LValue right = lowBigInt(m_node-&gt;child2());
 1922 
 1923             LValue result = vmCall(pointerType(), m_out.operation(operationSubBigInt), m_callFrame, left, right);
 1924             setJSValue(result);
 1925             return;
 1926         }
 1927 
 1928         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 1929         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 1930         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 1931         auto repatchingFunction = operationValueSubOptimize;
 1932         auto nonRepatchingFunction = operationValueSub;
<span class="line-modified"> 1933         compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 1934     }
 1935 
 1936     void compileValueMul()
 1937     {
 1938         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 1939             LValue left = lowBigInt(m_node-&gt;child1());
 1940             LValue right = lowBigInt(m_node-&gt;child2());
 1941 
 1942             LValue result = vmCall(Int64, m_out.operation(operationMulBigInt), m_callFrame, left, right);
 1943             setJSValue(result);
 1944             return;
 1945         }
 1946 
 1947         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 1948         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 1949         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 1950         auto repatchingFunction = operationValueMulOptimize;
 1951         auto nonRepatchingFunction = operationValueMul;
<span class="line-modified"> 1952         compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 1953     }
 1954 
 1955     template &lt;typename Generator, typename Func1, typename Func2,
 1956         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified"> 1957     void compileUnaryMathIC(ArithProfile* arithProfile, const Instruction* instruction, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 1958     {
 1959         Node* node = m_node;
 1960 
 1961         LValue operand = lowJSValue(node-&gt;child1());
 1962 
 1963         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 1964         patchpoint-&gt;appendSomeRegister(operand);
 1965         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 1966         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 1967         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 1968         patchpoint-&gt;numGPScratchRegisters = 1;
 1969         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 1970         State* state = &amp;m_ftlState;
 1971         patchpoint-&gt;setGenerator(
 1972             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 1973                 AllowMacroScratchRegisterUsage allowScratch(jit);
 1974 
 1975                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 1976                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 1977 
 1978 #if ENABLE(MATH_IC_STATS)
 1979                 auto inlineStart = jit.label();
 1980 #endif
 1981 
 1982                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified"> 1983                 JITUnaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile, instruction);</span>
 1984                 mathIC-&gt;m_generator = Generator(JSValueRegs(params[0].gpr()), JSValueRegs(params[1].gpr()), params.gpScratch(0));
 1985 
 1986                 bool shouldEmitProfiling = false;
 1987                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 1988 
 1989                 if (generatedInline) {
 1990                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 1991                     auto done = jit.label();
 1992                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 1993                         AllowMacroScratchRegisterUsage allowScratch(jit);
 1994                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 1995                         mathICGenerationState-&gt;slowPathStart = jit.label();
 1996 #if ENABLE(MATH_IC_STATS)
 1997                         auto slowPathStart = jit.label();
 1998 #endif
 1999 
 2000                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2001                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2002                                 repatchingFunction, params[0].gpr(), params[1].gpr(), CCallHelpers::TrustedImmPtr(mathIC));
 2003                             mathICGenerationState-&gt;slowPathCall = call.call();
</pre>
<hr />
<pre>
 2023                 } else {
 2024                     callOperation(
 2025                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2026                         nonRepatchingFunction, params[0].gpr(), params[1].gpr());
 2027                 }
 2028 
 2029 #if ENABLE(MATH_IC_STATS)
 2030                 auto inlineEnd = jit.label();
 2031                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2032                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2033                     mathIC-&gt;m_generatedCodeSize += size;
 2034                 });
 2035 #endif
 2036             });
 2037 
 2038         setJSValue(patchpoint);
 2039     }
 2040 
 2041     template &lt;typename Generator, typename Func1, typename Func2,
 2042         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified"> 2043     void compileBinaryMathIC(ArithProfile* arithProfile, const Instruction* instruction, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 2044     {
 2045         Node* node = m_node;
 2046 
 2047         LValue left = lowJSValue(node-&gt;child1());
 2048         LValue right = lowJSValue(node-&gt;child2());
 2049 
 2050         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
 2051         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
 2052 
 2053         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2054         patchpoint-&gt;appendSomeRegister(left);
 2055         patchpoint-&gt;appendSomeRegister(right);
 2056         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 2057         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 2058         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 2059             preparePatchpointForExceptions(patchpoint);
 2060         patchpoint-&gt;numGPScratchRegisters = 1;
 2061         patchpoint-&gt;numFPScratchRegisters = 2;
 2062         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2063         State* state = &amp;m_ftlState;
 2064         patchpoint-&gt;setGenerator(
 2065             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2066                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2067 
 2068 
 2069                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2070                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2071 
 2072 #if ENABLE(MATH_IC_STATS)
 2073                 auto inlineStart = jit.label();
 2074 #endif
 2075 
 2076                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified"> 2077                 JITBinaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile, instruction);</span>
 2078                 mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
 2079                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.fpScratch(0),
 2080                     params.fpScratch(1), params.gpScratch(0), InvalidFPRReg);
 2081 
 2082                 bool shouldEmitProfiling = false;
 2083                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2084 
 2085                 if (generatedInline) {
 2086                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2087                     auto done = jit.label();
 2088                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2089                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2090                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2091                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2092 #if ENABLE(MATH_IC_STATS)
 2093                         auto slowPathStart = jit.label();
 2094 #endif
 2095 
 2096                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2097                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
</pre>
<hr />
<pre>
 2156     {
 2157         bool isSub =  m_node-&gt;op() == ArithSub;
 2158         switch (m_node-&gt;binaryUseKind()) {
 2159         case Int32Use: {
 2160             LValue left = lowInt32(m_node-&gt;child1());
 2161             LValue right = lowInt32(m_node-&gt;child2());
 2162 
 2163             if (!shouldCheckOverflow(m_node-&gt;arithMode())) {
 2164                 setInt32(isSub ? m_out.sub(left, right) : m_out.add(left, right));
 2165                 break;
 2166             }
 2167 
 2168             CheckValue* result =
 2169                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2170             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2171             setInt32(result);
 2172             break;
 2173         }
 2174 
 2175         case Int52RepUse: {
<span class="line-modified"> 2176             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecInt52Only)</span>
<span class="line-modified"> 2177                 &amp;&amp; !abstractValue(m_node-&gt;child2()).couldBeType(SpecInt52Only)) {</span>
 2178                 Int52Kind kind;
 2179                 LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2180                 LValue right = lowInt52(m_node-&gt;child2(), kind);
 2181                 setInt52(isSub ? m_out.sub(left, right) : m_out.add(left, right), kind);
 2182                 break;
 2183             }
 2184 
 2185             LValue left = lowInt52(m_node-&gt;child1());
 2186             LValue right = lowInt52(m_node-&gt;child2());
 2187             CheckValue* result =
 2188                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2189             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2190             setInt52(result);
 2191             break;
 2192         }
 2193 
 2194         case DoubleRepUse: {
 2195             LValue C1 = lowDouble(m_node-&gt;child1());
 2196             LValue C2 = lowDouble(m_node-&gt;child2());
 2197 
 2198             setDouble(isSub ? m_out.doubleSub(C1, C2) : m_out.doubleAdd(C1, C2));
 2199             break;
 2200         }
 2201 
 2202         case UntypedUse: {
 2203             if (!isSub) {
 2204                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2205                 break;
 2206             }
 2207 
 2208             CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 2209             ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 2210             const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 2211             auto repatchingFunction = operationValueSubOptimize;
 2212             auto nonRepatchingFunction = operationValueSub;
<span class="line-modified"> 2213             compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 2214             break;
 2215         }
 2216 
 2217         default:
 2218             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2219             break;
 2220         }
 2221     }
 2222 
 2223     void compileArithClz32()
 2224     {
 2225         if (m_node-&gt;child1().useKind() == Int32Use || m_node-&gt;child1().useKind() == KnownInt32Use) {
 2226             LValue operand = lowInt32(m_node-&gt;child1());
 2227             setInt32(m_out.ctlz32(operand));
 2228             return;
 2229         }
 2230         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2231         LValue argument = lowJSValue(m_node-&gt;child1());
 2232         LValue result = vmCall(Int32, m_out.operation(operationArithClz32), m_callFrame, argument);
 2233         setInt32(result);
</pre>
<hr />
<pre>
 2367                     m_out.notEqual(m_out.mul(result, denominator), numerator));
 2368                 setInt32(result);
 2369             } else
 2370                 setInt32(m_out.chillDiv(numerator, denominator));
 2371 
 2372             break;
 2373         }
 2374 
 2375         case DoubleRepUse: {
 2376             setDouble(m_out.doubleDiv(
 2377                 lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2378             break;
 2379         }
 2380 
 2381         default:
 2382             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2383             break;
 2384         }
 2385     }
 2386 


















 2387     void compileArithMod()
 2388     {
 2389         switch (m_node-&gt;binaryUseKind()) {
 2390         case Int32Use: {
 2391             LValue numerator = lowInt32(m_node-&gt;child1());
 2392             LValue denominator = lowInt32(m_node-&gt;child2());
 2393 
 2394             LValue remainder;
 2395             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2396                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2397                 LBasicBlock continuation = m_out.newBlock();
 2398 
 2399                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2400                 m_out.branch(
 2401                     m_out.above(adjustedDenominator, m_out.int32One),
 2402                     usually(continuation), rarely(unsafeDenominator));
 2403 
 2404                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2405                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2406                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
</pre>
<hr />
<pre>
 2522             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2523             LValue argument = lowJSValue(m_node-&gt;child1());
 2524             LValue result = vmCall(Double, m_out.operation(operationArithAbs), m_callFrame, argument);
 2525             setDouble(result);
 2526             break;
 2527         }
 2528         }
 2529     }
 2530 
 2531     void compileArithUnary()
 2532     {
 2533         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2534             setDouble(m_out.doubleUnary(m_node-&gt;arithUnaryType(), lowDouble(m_node-&gt;child1())));
 2535             return;
 2536         }
 2537         LValue argument = lowJSValue(m_node-&gt;child1());
 2538         LValue result = vmCall(Double, m_out.operation(DFG::arithUnaryOperation(m_node-&gt;arithUnaryType())), m_callFrame, argument);
 2539         setDouble(result);
 2540     }
 2541 

















 2542     void compileArithPow()
 2543     {
 2544         if (m_node-&gt;child2().useKind() == Int32Use)
 2545             setDouble(m_out.doublePowi(lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2546         else {
 2547             LValue base = lowDouble(m_node-&gt;child1());
 2548             LValue exponent = lowDouble(m_node-&gt;child2());
 2549 
 2550             LBasicBlock integerExponentIsSmallBlock = m_out.newBlock();
 2551             LBasicBlock integerExponentPowBlock = m_out.newBlock();
 2552             LBasicBlock doubleExponentPowBlockEntry = m_out.newBlock();
 2553             LBasicBlock nanExceptionBaseIsOne = m_out.newBlock();
 2554             LBasicBlock nanExceptionExponentIsInfinity = m_out.newBlock();
 2555             LBasicBlock testExponentIsOneHalf = m_out.newBlock();
 2556             LBasicBlock handleBaseZeroExponentIsOneHalf = m_out.newBlock();
 2557             LBasicBlock handleInfinityForExponentIsOneHalf = m_out.newBlock();
 2558             LBasicBlock exponentIsOneHalfNormal = m_out.newBlock();
 2559             LBasicBlock exponentIsOneHalfInfinity = m_out.newBlock();
 2560             LBasicBlock testExponentIsNegativeOneHalf = m_out.newBlock();
 2561             LBasicBlock testBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
</pre>
<hr />
<pre>
 2821         LValue argument = lowJSValue(m_node-&gt;child1());
 2822         LValue result = vmCall(Double, m_out.operation(operationArithSqrt), m_callFrame, argument);
 2823         setDouble(result);
 2824     }
 2825 
 2826     void compileArithFRound()
 2827     {
 2828         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2829             setDouble(m_out.fround(lowDouble(m_node-&gt;child1())));
 2830             return;
 2831         }
 2832         LValue argument = lowJSValue(m_node-&gt;child1());
 2833         LValue result = vmCall(Double, m_out.operation(operationArithFRound), m_callFrame, argument);
 2834         setDouble(result);
 2835     }
 2836 
 2837     void compileValueNegate()
 2838     {
 2839         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
 2840         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 2841         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 2842         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 2843         auto repatchingFunction = operationArithNegateOptimize;
 2844         auto nonRepatchingFunction = operationArithNegate;
<span class="line-modified"> 2845         compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 2846     }
 2847 
 2848     void compileArithNegate()
 2849     {
 2850         switch (m_node-&gt;child1().useKind()) {
 2851         case Int32Use: {
 2852             LValue value = lowInt32(m_node-&gt;child1());
 2853 
 2854             LValue result;
 2855             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 2856                 result = m_out.neg(value);
 2857             else if (!shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2858                 CheckValue* check = m_out.speculateSub(m_out.int32Zero, value);
 2859                 blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 2860                 result = check;
 2861             } else {
 2862                 speculate(Overflow, noValue(), 0, m_out.testIsZero32(value, m_out.constInt32(0x7fffffff)));
 2863                 result = m_out.neg(value);
 2864             }
 2865 
 2866             setInt32(result);
 2867             break;
 2868         }
 2869 
 2870         case Int52RepUse: {
<span class="line-modified"> 2871             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecInt52Only)) {</span>
 2872                 Int52Kind kind;
 2873                 LValue value = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2874                 LValue result = m_out.neg(value);
 2875                 if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 2876                     speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 2877                 setInt52(result, kind);
 2878                 break;
 2879             }
 2880 
 2881             LValue value = lowInt52(m_node-&gt;child1());
 2882             CheckValue* result = m_out.speculateSub(m_out.int64Zero, value);
 2883             blessSpeculation(result, Int52Overflow, noValue(), nullptr, m_origin);
 2884             if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 2885                 speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 2886             setInt52(result);
 2887             break;
 2888         }
 2889 
 2890         case DoubleRepUse: {
 2891             setDouble(m_out.doubleNeg(lowDouble(m_node-&gt;child1())));
 2892             break;
 2893         }
 2894 
 2895         default:
 2896             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2897             break;
 2898         }
 2899     }
 2900 
<span class="line-modified"> 2901     void compileArithBitNot()</span>
 2902     {
<span class="line-modified"> 2903         if (m_node-&gt;child1().useKind() == UntypedUse) {</span>
<span class="line-modified"> 2904             LValue operand = lowJSValue(m_node-&gt;child1());</span>
<span class="line-modified"> 2905             LValue result = vmCall(Int64, m_out.operation(operationValueBitNot), m_callFrame, operand);</span>
 2906             setJSValue(result);
 2907             return;
 2908         }
 2909 







 2910         setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
 2911     }
 2912 
 2913     void compileValueBitAnd()
 2914     {
 2915         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2916             LValue left = lowBigInt(m_node-&gt;child1());
 2917             LValue right = lowBigInt(m_node-&gt;child2());
 2918 
 2919             LValue result = vmCall(pointerType(), m_out.operation(operationBitAndBigInt), m_callFrame, left, right);
 2920             setJSValue(result);
 2921             return;
 2922         }
 2923 
 2924         emitBinaryBitOpSnippet&lt;JITBitAndGenerator&gt;(operationValueBitAnd);
 2925     }
 2926 
 2927     void compileArithBitAnd()
 2928     {
 2929         setInt32(m_out.bitAnd(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
</pre>
<hr />
<pre>
 2961 
 2962         emitBinaryBitOpSnippet&lt;JITBitXorGenerator&gt;(operationValueBitXor);
 2963     }
 2964 
 2965     void compileArithBitXor()
 2966     {
 2967         setInt32(m_out.bitXor(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2968     }
 2969 
 2970     void compileBitRShift()
 2971     {
 2972         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 2973             emitRightShiftSnippet(JITRightShiftGenerator::SignedShift);
 2974             return;
 2975         }
 2976         setInt32(m_out.aShr(
 2977             lowInt32(m_node-&gt;child1()),
 2978             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 2979     }
 2980 
<span class="line-modified"> 2981     void compileBitLShift()</span>
 2982     {
<span class="line-removed"> 2983         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {</span>
<span class="line-removed"> 2984             emitBinaryBitOpSnippet&lt;JITLeftShiftGenerator&gt;(operationValueBitLShift);</span>
<span class="line-removed"> 2985             return;</span>
<span class="line-removed"> 2986         }</span>
 2987         setInt32(m_out.shl(
 2988             lowInt32(m_node-&gt;child1()),
 2989             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 2990     }
 2991 















 2992     void compileBitURShift()
 2993     {
 2994         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 2995             emitRightShiftSnippet(JITRightShiftGenerator::UnsignedShift);
 2996             return;
 2997         }
 2998         setInt32(m_out.lShr(
 2999             lowInt32(m_node-&gt;child1()),
 3000             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3001     }
 3002 
 3003     void compileUInt32ToNumber()
 3004     {
 3005         LValue value = lowInt32(m_node-&gt;child1());
 3006 
 3007         if (doesOverflow(m_node-&gt;arithMode())) {
 3008             setStrictInt52(m_out.zeroExtPtr(value));
 3009             return;
 3010         }
 3011 
</pre>
<hr />
<pre>
 3660             LValue fastResultValue = m_out.loadPtr(cell, m_heaps.JSString_value);
 3661             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 3662 
 3663             m_out.branch(isRopeString(cell, m_node-&gt;child1()), rarely(slowPath), usually(continuation));
 3664 
 3665             LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
 3666 
 3667             ValueFromBlock slowResult = m_out.anchor(
 3668                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, cell));
 3669 
 3670             m_out.jump(continuation);
 3671 
 3672             m_out.appendTo(continuation, lastNext);
 3673 
 3674             setStorage(m_out.loadPtr(m_out.phi(pointerType(), fastResult, slowResult), m_heaps.StringImpl_data));
 3675             return;
 3676         }
 3677 
 3678         DFG_ASSERT(m_graph, m_node, isTypedView(m_node-&gt;arrayMode().typedArrayType()), m_node-&gt;arrayMode().typedArrayType());
 3679         LValue vector = m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector);
<span class="line-modified"> 3680         setStorage(caged(Gigacage::Primitive, vector));</span>
 3681     }
 3682 
 3683     void compileCheckArray()
 3684     {
 3685         Edge edge = m_node-&gt;child1();
 3686         LValue cell = lowCell(edge);
 3687 
 3688         if (m_node-&gt;arrayMode().alreadyChecked(m_graph, m_node, abstractValue(edge)))
 3689             return;
 3690 
 3691         speculate(
 3692             BadIndexingType, jsValueValue(cell), 0,
 3693             m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));
 3694     }
 3695 
 3696     void compileGetTypedArrayByteOffset()
 3697     {
 3698         LValue basePtr = lowCell(m_node-&gt;child1());
 3699 
 3700         LBasicBlock simpleCase = m_out.newBlock();
</pre>
<hr />
<pre>
 3704 
 3705         LValue mode = m_out.load32(basePtr, m_heaps.JSArrayBufferView_mode);
 3706         m_out.branch(
 3707             m_out.notEqual(mode, m_out.constInt32(WastefulTypedArray)),
 3708             unsure(simpleCase), unsure(wastefulCase));
 3709 
 3710         LBasicBlock lastNext = m_out.appendTo(simpleCase, wastefulCase);
 3711 
 3712         ValueFromBlock simpleOut = m_out.anchor(m_out.constIntPtr(0));
 3713 
 3714         m_out.jump(continuation);
 3715 
 3716         m_out.appendTo(wastefulCase, notNull);
 3717 
 3718         LValue vector = m_out.loadPtr(basePtr, m_heaps.JSArrayBufferView_vector);
 3719         ValueFromBlock nullVectorOut = m_out.anchor(vector);
 3720         m_out.branch(vector, unsure(notNull), unsure(continuation));
 3721 
 3722         m_out.appendTo(notNull, continuation);
 3723 
<span class="line-modified"> 3724         LValue butterflyPtr = caged(Gigacage::JSValue, m_out.loadPtr(basePtr, m_heaps.JSObject_butterfly));</span>
 3725         LValue arrayBufferPtr = m_out.loadPtr(butterflyPtr, m_heaps.Butterfly_arrayBuffer);
 3726 
<span class="line-modified"> 3727         LValue vectorPtr = caged(Gigacage::Primitive, vector);</span>
 3728 
 3729         // FIXME: This needs caging.
 3730         // https://bugs.webkit.org/show_bug.cgi?id=175515
 3731         LValue dataPtr = m_out.loadPtr(arrayBufferPtr, m_heaps.ArrayBuffer_data);

 3732 
 3733         ValueFromBlock wastefulOut = m_out.anchor(m_out.sub(vectorPtr, dataPtr));
 3734 
 3735         m_out.jump(continuation);
 3736         m_out.appendTo(continuation, lastNext);
 3737 
 3738         setInt32(m_out.castToInt32(m_out.phi(pointerType(), simpleOut, nullVectorOut, wastefulOut)));
 3739     }
 3740 
 3741     void compileGetPrototypeOf()
 3742     {
 3743         switch (m_node-&gt;child1().useKind()) {
 3744         case ArrayUse:
 3745         case FunctionUse:
 3746         case FinalObjectUse: {
 3747             LValue object = lowCell(m_node-&gt;child1());
 3748             switch (m_node-&gt;child1().useKind()) {
 3749             case ArrayUse:
 3750                 speculateArray(m_node-&gt;child1(), object);
 3751                 break;
</pre>
<hr />
<pre>
 4223                     DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 4224                 }
 4225 
 4226                 setDouble(result);
 4227                 return;
 4228             }
 4229         }
 4230 
 4231         case Array::AnyTypedArray:
 4232         case Array::ForceExit:
 4233         case Array::SelectUsingArguments:
 4234         case Array::SelectUsingPredictions:
 4235         case Array::Unprofiled:
 4236             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4237             return;
 4238         }
 4239     }
 4240 
 4241     void compileGetMyArgumentByVal()
 4242     {
<span class="line-modified"> 4243         InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 4244 
 4245         LValue originalIndex = lowInt32(m_node-&gt;child2());
 4246 
 4247         LValue numberOfArgsIncludingThis;
 4248         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
 4249             numberOfArgsIncludingThis = m_out.constInt32(inlineCallFrame-&gt;argumentCountIncludingThis);
 4250         else {
 4251             VirtualRegister argumentCountRegister = AssemblyHelpers::argumentCount(inlineCallFrame);
 4252             numberOfArgsIncludingThis = m_out.load32(payloadFor(argumentCountRegister));
 4253         }
 4254 
 4255         LValue numberOfArgs = m_out.sub(numberOfArgsIncludingThis, m_out.int32One);
 4256         LValue indexToCheck = originalIndex;
 4257         LValue numberOfArgumentsToSkip = m_out.int32Zero;
 4258         if (m_node-&gt;numberOfArgumentsToSkip()) {
 4259             numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 4260             CheckValue* check = m_out.speculateAdd(indexToCheck, numberOfArgumentsToSkip);
 4261             blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 4262             indexToCheck = check;
 4263         }
</pre>
<hr />
<pre>
 4388 
 4389             switch (arrayMode.type()) {
 4390             case Array::Int32:
 4391             case Array::Contiguous: {
 4392                 LValue value = lowJSValue(child3, ManualOperandSpeculation);
 4393 
 4394                 if (arrayMode.type() == Array::Int32)
 4395                     FTL_TYPE_CHECK(jsValueValue(value), child3, SpecInt32Only, isNotInt32(value));
 4396 
 4397                 TypedPointer elementPointer = m_out.baseIndex(
 4398                     arrayMode.type() == Array::Int32 ?
 4399                     m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties,
 4400                     storage, m_out.zeroExtPtr(index), provenValue(child2));
 4401 
 4402                 if (m_node-&gt;op() == PutByValAlias) {
 4403                     m_out.store64(value, elementPointer);
 4404                     break;
 4405                 }
 4406 
 4407                 contiguousPutByValOutOfBounds(
<span class="line-modified"> 4408                     codeBlock()-&gt;isStrictMode()</span>
 4409                         ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4410                         : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
 4411                     base, storage, index, value, continuation);
 4412 
 4413                 m_out.store64(value, elementPointer);
 4414                 break;
 4415             }
 4416 
 4417             case Array::Double: {
 4418                 LValue value = lowDouble(child3);
 4419 
 4420                 FTL_TYPE_CHECK(
 4421                     doubleValue(value), child3, SpecDoubleReal,
 4422                     m_out.doubleNotEqualOrUnordered(value, value));
 4423 
 4424                 TypedPointer elementPointer = m_out.baseIndex(
 4425                     m_heaps.indexedDoubleProperties, storage, m_out.zeroExtPtr(index),
 4426                     provenValue(child2));
 4427 
 4428                 if (m_node-&gt;op() == PutByValAlias) {
 4429                     m_out.storeDouble(value, elementPointer);
 4430                     break;
 4431                 }
 4432 
 4433                 contiguousPutByValOutOfBounds(
<span class="line-modified"> 4434                     codeBlock()-&gt;isStrictMode()</span>
 4435                         ? (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 4436                         : (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 4437                     base, storage, index, value, continuation);
 4438 
 4439                 m_out.storeDouble(value, elementPointer);
 4440                 break;
 4441             }
 4442 
 4443             default:
 4444                 DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4445             }
 4446 
 4447             m_out.jump(continuation);
 4448             m_out.appendTo(continuation, outerLastNext);
 4449             return;
 4450         }
 4451 
 4452         case Array::ArrayStorage:
 4453         case Array::SlowPutArrayStorage: {
 4454             LValue value = lowJSValue(child3);
 4455 
 4456             TypedPointer elementPointer = m_out.baseIndex(
 4457                 m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(index),
 4458                 provenValue(child2));
 4459 
 4460             if (m_node-&gt;op() == PutByValAlias) {
 4461                 m_out.store64(value, elementPointer);
 4462                 return;
 4463             }
 4464 
 4465             if (arrayMode.isInBounds()) {
 4466                 speculate(StoreToHole, noValue(), 0, m_out.isZero64(m_out.load64(elementPointer)));
 4467                 m_out.store64(value, elementPointer);
 4468                 return;
 4469             }
 4470 
 4471             LValue isOutOfBounds = m_out.aboveOrEqual(
 4472                 index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength));
 4473 
<span class="line-modified"> 4474             auto slowPathFunction = codeBlock()-&gt;isStrictMode()</span>
 4475                 ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4476                 : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict);
 4477             if (!arrayMode.isOutOfBounds()) {
 4478                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
 4479                 isOutOfBounds = m_out.booleanFalse;
 4480             }
 4481 
 4482             LBasicBlock inBoundCase = m_out.newBlock();
 4483             LBasicBlock slowCase = m_out.newBlock();
 4484             LBasicBlock holeCase = m_out.newBlock();
 4485             LBasicBlock doStoreCase = m_out.newBlock();
 4486             LBasicBlock lengthUpdateCase = m_out.newBlock();
 4487             LBasicBlock continuation = m_out.newBlock();
 4488 
 4489             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBoundCase));
 4490 
 4491             LBasicBlock lastNext = m_out.appendTo(slowCase, inBoundCase);
 4492             vmCall(
 4493                 Void, m_out.operation(slowPathFunction),
 4494                 m_callFrame, base, index, value);
</pre>
<hr />
<pre>
 4657     }
 4658 
 4659     void compileArrayPush()
 4660     {
 4661         LValue base = lowCell(m_graph.varArgChild(m_node, 1));
 4662         LValue storage = lowStorage(m_graph.varArgChild(m_node, 0));
 4663         unsigned elementOffset = 2;
 4664         unsigned elementCount = m_node-&gt;numChildren() - elementOffset;
 4665 
 4666         switch (m_node-&gt;arrayMode().type()) {
 4667         case Array::Int32:
 4668         case Array::Contiguous:
 4669         case Array::Double: {
 4670             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 4671 
 4672             if (elementCount == 1) {
 4673                 LValue value;
 4674                 Output::StoreType storeType;
 4675 
 4676                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);

 4677                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4678                     value = lowJSValue(element, ManualOperandSpeculation);
<span class="line-removed"> 4679                     if (m_node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed"> 4680                         DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecInt32Only));</span>
 4681                     storeType = Output::Store64;
 4682                 } else {
 4683                     value = lowDouble(element);
<span class="line-removed"> 4684                     DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecDoubleReal));</span>
 4685                     storeType = Output::StoreDouble;
 4686                 }
 4687 
 4688                 LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4689 
 4690                 LBasicBlock fastPath = m_out.newBlock();
 4691                 LBasicBlock slowPath = m_out.newBlock();
 4692                 LBasicBlock continuation = m_out.newBlock();
 4693 
 4694                 m_out.branch(
 4695                     m_out.aboveOrEqual(
 4696                         prevLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength)),
 4697                     unsure(slowPath), unsure(fastPath));
 4698 
 4699                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4700                 m_out.store(
 4701                     value, m_out.baseIndex(heap, storage, m_out.zeroExtPtr(prevLength)), storeType);
 4702                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 4703                 m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4704 
 4705                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4706                 m_out.jump(continuation);
 4707 
 4708                 m_out.appendTo(slowPath, continuation);
 4709                 LValue operation;
 4710                 if (m_node-&gt;arrayMode().type() != Array::Double)
 4711                     operation = m_out.operation(operationArrayPush);
 4712                 else
 4713                     operation = m_out.operation(operationArrayPushDouble);
 4714                 ValueFromBlock slowResult = m_out.anchor(
 4715                     vmCall(Int64, operation, m_callFrame, value, base));
 4716                 m_out.jump(continuation);
 4717 
 4718                 m_out.appendTo(continuation, lastNext);
 4719                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4720                 return;
 4721             }
 4722 





 4723             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4724             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 4725 
 4726             LBasicBlock fastPath = m_out.newBlock();
 4727             LBasicBlock slowPath = m_out.newBlock();
 4728             LBasicBlock setup = m_out.newBlock();
 4729             LBasicBlock slowCallPath = m_out.newBlock();
 4730             LBasicBlock continuation = m_out.newBlock();
 4731 
 4732             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength));
 4733 
 4734             m_out.branch(beyondVectorLength, unsure(slowPath), unsure(fastPath));
 4735 
 4736             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4737             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4738             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight));
 4739             m_out.jump(setup);
 4740 
 4741             m_out.appendTo(slowPath, setup);
 4742             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 4743             static_assert(sizeof(EncodedJSValue) == sizeof(double), &quot;&quot;);
 4744             ASSERT(scratchSize);
 4745             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 4746             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4747             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 4748             m_out.jump(setup);
 4749 
 4750             m_out.appendTo(setup, slowCallPath);
 4751             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 4752             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 4753                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 4754 
 4755                 LValue value;
 4756                 Output::StoreType storeType;
 4757                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4758                     value = lowJSValue(element, ManualOperandSpeculation);
<span class="line-removed"> 4759                     if (m_node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed"> 4760                         DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecInt32Only));</span>
 4761                     storeType = Output::Store64;
 4762                 } else {
 4763                     value = lowDouble(element);
<span class="line-removed"> 4764                     DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecDoubleReal));</span>
 4765                     storeType = Output::StoreDouble;
 4766                 }
 4767 
 4768                 m_out.store(value, m_out.baseIndex(heap, buffer, m_out.constInt32(elementIndex), jsNumber(elementIndex)), storeType);
 4769             }
 4770             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4771 
 4772             m_out.branch(beyondVectorLength, unsure(slowCallPath), unsure(continuation));
 4773 
 4774             m_out.appendTo(slowCallPath, continuation);
 4775             LValue operation;
 4776             if (m_node-&gt;arrayMode().type() != Array::Double)
 4777                 operation = m_out.operation(operationArrayPushMultiple);
 4778             else
 4779                 operation = m_out.operation(operationArrayPushDoubleMultiple);
 4780             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, base, buffer, m_out.constInt32(elementCount)));
 4781             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4782             m_out.jump(continuation);
 4783 
 4784             m_out.appendTo(continuation, lastNext);
</pre>
<hr />
<pre>
 5221         auto objectEdge = m_node-&gt;child2();
 5222         if (objectEdge.useKind() == ObjectUse) {
 5223             LValue object = lowNonNullObject(objectEdge);
 5224             LValue result = vmCall(Int64, m_out.operation(operationPushWithScopeObject), m_callFrame, parentScope, object);
 5225             setJSValue(result);
 5226         } else {
 5227             ASSERT(objectEdge.useKind() == UntypedUse);
 5228             LValue object = lowJSValue(m_node-&gt;child2());
 5229             LValue result = vmCall(Int64, m_out.operation(operationPushWithScope), m_callFrame, parentScope, object);
 5230             setJSValue(result);
 5231         }
 5232     }
 5233 
 5234     void compileCreateActivation()
 5235     {
 5236         LValue scope = lowCell(m_node-&gt;child1());
 5237         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
 5238         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
 5239         JSValue initializationValue = m_node-&gt;initializationValueForActivation();
 5240         ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
<span class="line-modified"> 5241         if (table-&gt;singletonScope()-&gt;isStillValid()) {</span>
 5242             LValue callResult = vmCall(
 5243                 Int64,
 5244                 m_out.operation(operationCreateActivationDirect), m_callFrame, weakStructure(structure),
 5245                 scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
 5246             setJSValue(callResult);
 5247             return;
 5248         }
 5249 
 5250         LBasicBlock slowPath = m_out.newBlock();
 5251         LBasicBlock continuation = m_out.newBlock();
 5252 
 5253         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5254 
 5255         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
 5256             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
 5257 
 5258         // We don&#39;t need memory barriers since we just fast-created the activation, so the
 5259         // activation must be young.
 5260         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
 5261         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
</pre>
<hr />
<pre>
 5282                     CCallHelpers::TrustedImm64(JSValue::encode(initializationValue)));
 5283             },
 5284             scope);
 5285         ValueFromBlock slowResult = m_out.anchor(callResult);
 5286         m_out.jump(continuation);
 5287 
 5288         m_out.appendTo(continuation, lastNext);
 5289         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5290     }
 5291 
 5292     void compileNewFunction()
 5293     {
 5294         ASSERT(m_node-&gt;op() == NewFunction || m_node-&gt;op() == NewGeneratorFunction || m_node-&gt;op() == NewAsyncGeneratorFunction || m_node-&gt;op() == NewAsyncFunction);
 5295         bool isGeneratorFunction = m_node-&gt;op() == NewGeneratorFunction;
 5296         bool isAsyncFunction = m_node-&gt;op() == NewAsyncFunction;
 5297         bool isAsyncGeneratorFunction =  m_node-&gt;op() == NewAsyncGeneratorFunction;
 5298 
 5299         LValue scope = lowCell(m_node-&gt;child1());
 5300 
 5301         FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
<span class="line-modified"> 5302         if (executable-&gt;singletonFunction()-&gt;isStillValid()) {</span>
 5303             LValue callResult =
 5304                 isGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5305                 isAsyncFunction ? vmCall(Int64, m_out.operation(operationNewAsyncFunction), m_callFrame, scope, weakPointer(executable)) :
 5306                 isAsyncGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewAsyncGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5307                 vmCall(Int64, m_out.operation(operationNewFunction), m_callFrame, scope, weakPointer(executable));
 5308             setJSValue(callResult);
 5309             return;
 5310         }
 5311 
 5312         RegisteredStructure structure = m_graph.registerStructure(
 5313             [&amp;] () {
 5314                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5315                 switch (m_node-&gt;op()) {
 5316                 case NewGeneratorFunction:
 5317                     return globalObject-&gt;generatorFunctionStructure();
 5318                 case NewAsyncFunction:
 5319                     return globalObject-&gt;asyncFunctionStructure();
 5320                 case NewAsyncGeneratorFunction:
 5321                     return globalObject-&gt;asyncGeneratorFunctionStructure();
 5322                 case NewFunction:
</pre>
<hr />
<pre>
 5327             }());
 5328 
 5329         LBasicBlock slowPath = m_out.newBlock();
 5330         LBasicBlock continuation = m_out.newBlock();
 5331 
 5332         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5333 
 5334         LValue fastObject =
 5335             isGeneratorFunction ? allocateObject&lt;JSGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5336             isAsyncFunction ? allocateObject&lt;JSAsyncFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5337             isAsyncGeneratorFunction ? allocateObject&lt;JSAsyncGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5338             allocateObject&lt;JSFunction&gt;(structure, m_out.intPtrZero, slowPath);
 5339 
 5340 
 5341         // We don&#39;t need memory barriers since we just fast-created the function, so it
 5342         // must be young.
 5343         m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
 5344         m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executable);
 5345         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.JSFunction_rareData);
 5346 
<span class="line-modified"> 5347         mutatorFence();</span>

















 5348 
 5349         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5350         m_out.jump(continuation);
 5351 
 5352         m_out.appendTo(slowPath, continuation);
 5353 
 5354         Vector&lt;LValue&gt; slowPathArguments;
 5355         slowPathArguments.append(scope);
<span class="line-removed"> 5356         VM&amp; vm = this-&gt;vm();</span>
 5357         LValue callResult = lazySlowPath(
 5358             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5359                 auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
 5360                 if (isGeneratorFunction)
 5361                     operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5362                 else if (isAsyncFunction)
 5363                     operation = operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint;
 5364                 else if (isAsyncGeneratorFunction)
 5365                     operation = operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5366 
 5367                 return createLazyCallGenerator(vm, operation,
 5368                     locations[0].directGPR(), locations[1].directGPR(),
 5369                     CCallHelpers::TrustedImmPtr(executable));
 5370             },
 5371             slowPathArguments);
 5372         ValueFromBlock slowResult = m_out.anchor(callResult);
 5373         m_out.jump(continuation);
 5374 
 5375         m_out.appendTo(continuation, lastNext);
 5376         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
</pre>
<hr />
<pre>
 5803                 else {
 5804                     Edge&amp; child = m_graph.varArgChild(m_node, i);
 5805                     if (child-&gt;op() == PhantomSpread &amp;&amp; child-&gt;child1()-&gt;op() == PhantomNewArrayBuffer)
 5806                         startLength += child-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 5807                 }
 5808             }
 5809 
 5810             if (startLength.hasOverflowed()) {
 5811                 terminate(Overflow);
 5812                 return;
 5813             }
 5814 
 5815             LValue length = m_out.constInt32(startLength.unsafeGet());
 5816 
 5817             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 5818                 if (bitVector-&gt;get(i)) {
 5819                     Edge use = m_graph.varArgChild(m_node, i);
 5820                     CheckValue* lengthCheck = nullptr;
 5821                     if (use-&gt;op() == PhantomSpread) {
 5822                         if (use-&gt;child1()-&gt;op() == PhantomCreateRest) {
<span class="line-modified"> 5823                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 5824                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 5825                             LValue spreadLength = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 5826                                 return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 5827                             }).iterator-&gt;value;
 5828                             lengthCheck = m_out.speculateAdd(length, spreadLength);
 5829                         }
 5830                     } else {
 5831                         LValue fixedArray = lowCell(use);
 5832                         lengthCheck = m_out.speculateAdd(length, m_out.load32(fixedArray, m_heaps.JSFixedArray_size));
 5833                     }
 5834 
 5835                     if (lengthCheck) {
 5836                         blessSpeculation(lengthCheck, Overflow, noValue(), nullptr, m_origin);
 5837                         length = lengthCheck;
 5838                     }
 5839                 }
 5840             }
 5841 
 5842             LValue exceedsMaxAllowedLength = m_out.aboveOrEqual(length, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
 5843             blessSpeculation(m_out.speculate(exceedsMaxAllowedLength), Overflow, noValue(), nullptr, m_origin);
</pre>
<hr />
<pre>
 5847             LValue result = arrayValues.array;
 5848             LValue storage = arrayValues.butterfly;
 5849             LValue index = m_out.constIntPtr(0);
 5850 
 5851             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 5852                 Edge use = m_graph.varArgChild(m_node, i);
 5853                 if (bitVector-&gt;get(i)) {
 5854                     if (use-&gt;op() == PhantomSpread) {
 5855                         if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
 5856                             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 5857                             auto* array = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 5858                             for (unsigned i = 0; i &lt; array-&gt;length(); ++i) {
 5859                                 // Because resulted array from NewArrayWithSpread is always contiguous, we should not generate value
 5860                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 5861                                 int64_t value = JSValue::encode(array-&gt;get(i));
 5862                                 m_out.store64(m_out.constInt64(value), m_out.baseIndex(heap, storage, index, JSValue(), (Checked&lt;int32_t&gt;(sizeof(JSValue)) * i).unsafeGet()));
 5863                             }
 5864                             index = m_out.add(index, m_out.constIntPtr(array-&gt;length()));
 5865                         } else {
 5866                             RELEASE_ASSERT(use-&gt;child1()-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 5867                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 5868                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 5869 
 5870                             LValue length = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 5871                             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 5872 
 5873                             LBasicBlock loopStart = m_out.newBlock();
 5874                             LBasicBlock continuation = m_out.newBlock();
 5875 
 5876                             ValueFromBlock loadIndexStart = m_out.anchor(m_out.constIntPtr(0));
 5877                             ValueFromBlock arrayIndexStart = m_out.anchor(index);
 5878                             ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 5879 
 5880                             m_out.branch(
 5881                                 m_out.isZero64(length),
 5882                                 unsure(continuation), unsure(loopStart));
 5883 
 5884                             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 5885 
 5886                             LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
 5887                             LValue loadIndex = m_out.phi(pointerType(), loadIndexStart);
</pre>
<hr />
<pre>
 6039                     m_out.constInt64(value),
 6040                     m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, m_out.constIntPtr(i), jsNumber(i)));
 6041             }
 6042             mutatorFence();
 6043             setJSValue(fixedArray);
 6044             return;
 6045         }
 6046 
 6047         if (m_node-&gt;child1()-&gt;op() == PhantomCreateRest) {
 6048             // This IR is rare to generate since it requires escaping the Spread
 6049             // but not the CreateRest. In bytecode, we have only few operations that
 6050             // accept Spread&#39;s result as input. This usually leads to the Spread node not
 6051             // escaping. However, this can happen if for example we generate a PutStack on
 6052             // the Spread but nothing escapes the CreateRest.
 6053             LBasicBlock loopHeader = m_out.newBlock();
 6054             LBasicBlock loopBody = m_out.newBlock();
 6055             LBasicBlock slowAllocation = m_out.newBlock();
 6056             LBasicBlock continuation = m_out.newBlock();
 6057             LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopHeader);
 6058 
<span class="line-modified"> 6059             InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 6060             unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6061             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6062             LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6063             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6064             LValue size = m_out.add(
 6065                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
 6066                 m_out.constIntPtr(JSFixedArray::offsetOfData()));
 6067 
 6068             LValue fastArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);
 6069             m_out.store32(length, fastArrayValue, m_heaps.JSFixedArray_size);
 6070             ValueFromBlock fastArray = m_out.anchor(fastArrayValue);
 6071             m_out.jump(loopHeader);
 6072 
 6073             m_out.appendTo(slowAllocation, loopHeader);
 6074             ValueFromBlock slowArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, length));
 6075             m_out.jump(loopHeader);
 6076 
 6077             m_out.appendTo(loopHeader, loopBody);
 6078             LValue fixedArray = m_out.phi(pointerType(), fastArray, slowArray);
 6079             ValueFromBlock startIndex = m_out.anchor(m_out.constIntPtr(0));
</pre>
<hr />
<pre>
 6265             LBasicBlock lastNext = m_out.appendTo(smallEnoughCase, slowCase);
 6266 
 6267             LValue byteSize =
 6268                 m_out.shl(m_out.zeroExtPtr(size), m_out.constInt32(logElementSize(typedArrayType)));
 6269             if (elementSize(typedArrayType) &lt; 8) {
 6270                 byteSize = m_out.bitAnd(
 6271                     m_out.add(byteSize, m_out.constIntPtr(7)),
 6272                     m_out.constIntPtr(~static_cast&lt;intptr_t&gt;(7)));
 6273             }
 6274 
 6275             LValue allocator = allocatorForSize(vm().primitiveGigacageAuxiliarySpace, byteSize, slowCase);
 6276             LValue storage = allocateHeapCell(allocator, slowCase);
 6277 
 6278             splatWords(
 6279                 storage,
 6280                 m_out.int32Zero,
 6281                 m_out.castToInt32(m_out.lShr(byteSize, m_out.constIntPtr(3))),
 6282                 m_out.int64Zero,
 6283                 m_heaps.typedArrayProperties);
 6284 














 6285             ValueFromBlock haveStorage = m_out.anchor(storage);
 6286 
 6287             LValue fastResultValue =
 6288                 allocateObject&lt;JSArrayBufferView&gt;(structure, m_out.intPtrZero, slowCase);
 6289 
 6290             m_out.storePtr(storage, fastResultValue, m_heaps.JSArrayBufferView_vector);
 6291             m_out.store32(size, fastResultValue, m_heaps.JSArrayBufferView_length);
 6292             m_out.store32(m_out.constInt32(FastTypedArray), fastResultValue, m_heaps.JSArrayBufferView_mode);
 6293 
 6294             mutatorFence();
 6295             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 6296             m_out.jump(continuation);
 6297 
 6298             m_out.appendTo(slowCase, continuation);
 6299             LValue storageValue = m_out.phi(pointerType(), noStorage, haveStorage);
 6300 
 6301             VM&amp; vm = this-&gt;vm();
 6302             LValue slowResultValue = lazySlowPath(
 6303                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6304                     return createLazyCallGenerator(vm,
</pre>
<hr />
<pre>
 6524             LValue length;
 6525         };
 6526 
 6527         Edge edges[3] = {
 6528             m_node-&gt;child1(),
 6529             m_node-&gt;child2(),
 6530             m_node-&gt;child3(),
 6531         };
 6532         LValue kids[3];
 6533         unsigned numKids;
 6534         kids[0] = lowCell(edges[0]);
 6535         kids[1] = lowCell(edges[1]);
 6536         if (edges[2]) {
 6537             kids[2] = lowCell(edges[2]);
 6538             numKids = 3;
 6539         } else {
 6540             kids[2] = 0;
 6541             numKids = 2;
 6542         }
 6543 

 6544         LBasicBlock slowPath = m_out.newBlock();
 6545         LBasicBlock continuation = m_out.newBlock();
 6546 
 6547         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
 6548 
 6549         LValue result = allocateCell(
 6550             m_out.constIntPtr(allocator.localAllocator()), vm().stringStructure.get(), slowPath);
 6551 
<span class="line-modified"> 6552         m_out.storePtr(m_out.bitOr(kids[0], m_out.constIntPtr(JSString::isRopeInPointer)), result, m_heaps.JSRopeString_fiber0);</span>
<span class="line-modified"> 6553 </span>
<span class="line-removed"> 6554         m_out.store32(m_out.castToInt32(kids[1]), result, m_heaps.JSRopeString_fiber1Lower);</span>
<span class="line-removed"> 6555         m_out.store32As16(m_out.castToInt32(m_out.lShr(kids[1], m_out.constInt32(32))), result, m_heaps.JSRopeString_fiber1Upper);</span>
<span class="line-removed"> 6556 </span>
<span class="line-removed"> 6557         if (numKids == 3) {</span>
<span class="line-removed"> 6558             m_out.store32(m_out.castToInt32(kids[2]), result, m_heaps.JSRopeString_fiber2Lower);</span>
<span class="line-removed"> 6559             m_out.store32As16(m_out.castToInt32(m_out.lShr(kids[2], m_out.constInt32(32))), result, m_heaps.JSRopeString_fiber2Upper);</span>
<span class="line-removed"> 6560         } else {</span>
<span class="line-removed"> 6561             m_out.store32(m_out.int32Zero, result, m_heaps.JSRopeString_fiber2Lower);</span>
<span class="line-removed"> 6562             m_out.store32As16(m_out.int32Zero, result, m_heaps.JSRopeString_fiber2Upper);</span>
<span class="line-removed"> 6563         }</span>
 6564 
 6565         auto getFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child) {
 6566             if (JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
 6567                 return FlagsAndLength {
 6568                     m_out.constInt32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0),
 6569                     m_out.constInt32(string-&gt;length())
 6570                 };
 6571             }
 6572 
 6573             LBasicBlock continuation = m_out.newBlock();
 6574             LBasicBlock ropeCase = m_out.newBlock();
 6575             LBasicBlock notRopeCase = m_out.newBlock();
 6576 
 6577             m_out.branch(isRopeString(child, edge), unsure(ropeCase), unsure(notRopeCase));
 6578 
 6579             LBasicBlock lastNext = m_out.appendTo(ropeCase, notRopeCase);
<span class="line-modified"> 6580             ValueFromBlock flagsForRope = m_out.anchor(m_out.load16ZeroExt32(child, m_heaps.JSRopeString_flags));</span>
 6581             ValueFromBlock lengthForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_length));
 6582             m_out.jump(continuation);
 6583 
 6584             m_out.appendTo(notRopeCase, continuation);
 6585             LValue stringImpl = m_out.loadPtr(child, m_heaps.JSString_value);
 6586             ValueFromBlock flagsForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_hashAndFlags));
 6587             ValueFromBlock lengthForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length));
 6588             m_out.jump(continuation);
 6589 
 6590             m_out.appendTo(continuation, lastNext);
 6591             return FlagsAndLength {
 6592                 m_out.phi(Int32, flagsForRope, flagsForNonRope),
 6593                 m_out.phi(Int32, lengthForRope, lengthForNonRope)
 6594             };
 6595         };
 6596 
 6597         FlagsAndLength flagsAndLength = getFlagsAndLength(edges[0], kids[0]);
 6598         for (unsigned i = 1; i &lt; numKids; ++i) {
 6599             auto mergeFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child, FlagsAndLength previousFlagsAndLength) {
 6600                 FlagsAndLength flagsAndLength = getFlagsAndLength(edge, child);
 6601                 LValue flags = m_out.bitAnd(previousFlagsAndLength.flags, flagsAndLength.flags);
 6602                 CheckValue* lengthCheck = m_out.speculateAdd(previousFlagsAndLength.length, flagsAndLength.length);
<span class="line-modified"> 6603             blessSpeculation(lengthCheck, Uncountable, noValue(), nullptr, m_origin);</span>
 6604                 return FlagsAndLength {
 6605                     flags,
 6606                     lengthCheck
 6607                 };
 6608             };
 6609             flagsAndLength = mergeFlagsAndLength(edges[i], kids[i], flagsAndLength);
 6610         }
<span class="line-modified"> 6611         m_out.store32As16(flagsAndLength.flags, result, m_heaps.JSRopeString_flags);</span>
<span class="line-modified"> 6612         m_out.store32(flagsAndLength.length, result, m_heaps.JSRopeString_length);</span>











 6613 
 6614         mutatorFence();
<span class="line-modified"> 6615         ValueFromBlock fastResult = m_out.anchor(m_out.select(m_out.isZero32(flagsAndLength.length), weakPointer(jsEmptyString(&amp;m_graph.m_vm)), result));</span>




 6616         m_out.jump(continuation);
 6617 
<span class="line-modified"> 6618         LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);</span>
 6619         LValue slowResultValue;
 6620         VM&amp; vm = this-&gt;vm();
 6621         switch (numKids) {
 6622         case 2:
 6623             slowResultValue = lazySlowPath(
 6624                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6625                     return createLazyCallGenerator(vm,
 6626                         operationMakeRope2, locations[0].directGPR(), locations[1].directGPR(),
 6627                         locations[2].directGPR());
 6628                 }, kids[0], kids[1]);
 6629             break;
 6630         case 3:
 6631             slowResultValue = lazySlowPath(
 6632                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6633                     return createLazyCallGenerator(vm,
 6634                         operationMakeRope3, locations[0].directGPR(), locations[1].directGPR(),
 6635                         locations[2].directGPR(), locations[3].directGPR());
 6636                 }, kids[0], kids[1], kids[2]);
 6637             break;
 6638         default:
 6639             DFG_CRASH(m_graph, m_node, &quot;Bad number of children&quot;);
 6640             break;
 6641         }
 6642         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6643         m_out.jump(continuation);
 6644 
 6645         m_out.appendTo(continuation, lastNext);
<span class="line-modified"> 6646         setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
 6647     }
 6648 
 6649     void compileStringCharAt()
 6650     {
 6651         LValue base = lowString(m_graph.child(m_node, 0));
 6652         LValue index = lowInt32(m_graph.child(m_node, 1));
 6653         LValue storage = lowStorage(m_graph.child(m_node, 2));
 6654 
 6655         LBasicBlock fastPath = m_out.newBlock();
 6656         LBasicBlock slowPath = m_out.newBlock();
 6657         LBasicBlock continuation = m_out.newBlock();
 6658 
 6659         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 6660         m_out.branch(
 6661             m_out.aboveOrEqual(
 6662                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)),
 6663             rarely(slowPath), usually(fastPath));
 6664 
 6665         LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 6666 
</pre>
<hr />
<pre>
 6704             m_callFrame, char16BitValue)));
 6705         m_out.jump(continuation);
 6706 
 6707         m_out.appendTo(bitsContinuation, slowPath);
 6708 
 6709         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
 6710 
 6711         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 6712 
 6713         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
 6714             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
 6715         m_out.jump(continuation);
 6716 
 6717         m_out.appendTo(slowPath, continuation);
 6718 
 6719         if (m_node-&gt;arrayMode().isInBounds()) {
 6720             speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
 6721             results.append(m_out.anchor(m_out.intPtrZero));
 6722         } else {
 6723             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);



 6724 
<span class="line-removed"> 6725             bool prototypeChainIsSane = false;</span>
 6726             if (globalObject-&gt;stringPrototypeChainIsSane()) {
 6727                 // FIXME: This could be captured using a Speculation mode that means
 6728                 // &quot;out-of-bounds loads return a trivial value&quot;, something like
 6729                 // SaneChainOutOfBounds.
 6730                 // https://bugs.webkit.org/show_bug.cgi?id=144668
 6731 
<span class="line-modified"> 6732                 m_graph.registerAndWatchStructureTransition(globalObject-&gt;stringPrototype()-&gt;structure(vm()));</span>
<span class="line-modified"> 6733                 m_graph.registerAndWatchStructureTransition(globalObject-&gt;objectPrototype()-&gt;structure(vm()));</span>
 6734 
<span class="line-removed"> 6735                 prototypeChainIsSane = globalObject-&gt;stringPrototypeChainIsSane();</span>
<span class="line-removed"> 6736             }</span>
<span class="line-removed"> 6737             if (prototypeChainIsSane) {</span>
 6738                 LBasicBlock negativeIndex = m_out.newBlock();
 6739 
 6740                 results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 6741                 m_out.branch(
 6742                     m_out.lessThan(index, m_out.int32Zero),
 6743                     rarely(negativeIndex), usually(continuation));
 6744 
 6745                 m_out.appendTo(negativeIndex, continuation);
 6746             }
 6747 
 6748             results.append(m_out.anchor(vmCall(
 6749                 Int64, m_out.operation(operationGetByValStringInt), m_callFrame, base, index)));
 6750         }
 6751 
 6752         m_out.jump(continuation);
 6753 
 6754         m_out.appendTo(continuation, lastNext);
 6755         setJSValue(m_out.phi(Int64, results));
 6756     }
 6757 
</pre>
<hr />
<pre>
 6805     {
 6806         Edge childEdge = m_node-&gt;child1();
 6807 
 6808         if (childEdge.useKind() == UntypedUse) {
 6809             LValue result = vmCall(
 6810                 Int64, m_out.operation(operationStringFromCharCodeUntyped), m_callFrame,
 6811                 lowJSValue(childEdge));
 6812             setJSValue(result);
 6813             return;
 6814         }
 6815 
 6816         DFG_ASSERT(m_graph, m_node, childEdge.useKind() == Int32Use, childEdge.useKind());
 6817 
 6818         LValue value = lowInt32(childEdge);
 6819 
 6820         LBasicBlock smallIntCase = m_out.newBlock();
 6821         LBasicBlock slowCase = m_out.newBlock();
 6822         LBasicBlock continuation = m_out.newBlock();
 6823 
 6824         m_out.branch(
<span class="line-modified"> 6825             m_out.aboveOrEqual(value, m_out.constInt32(maxSingleCharacterString)),</span>
 6826             rarely(slowCase), usually(smallIntCase));
 6827 
 6828         LBasicBlock lastNext = m_out.appendTo(smallIntCase, slowCase);
 6829 
 6830         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 6831         LValue fastResultValue = m_out.loadPtr(
 6832             m_out.baseIndex(m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(value)));
 6833         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 6834         m_out.jump(continuation);
 6835 
 6836         m_out.appendTo(slowCase, continuation);
 6837 
 6838         LValue slowResultValue = vmCall(
 6839             pointerType(), m_out.operation(operationStringFromCharCode), m_callFrame, value);
 6840         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6841         m_out.jump(continuation);
 6842 
 6843         m_out.appendTo(continuation, lastNext);
 6844 
 6845         setJSValue(m_out.phi(Int64, fastResult, slowResult));
</pre>
<hr />
<pre>
 7616             intptr_t offsetFromSP =
 7617                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 7618             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 7619         };
 7620 
 7621         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 7622         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 7623         for (unsigned i = 0; i &lt; numArgs; ++i)
 7624             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 7625 
 7626         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 7627         patchpoint-&gt;appendVector(arguments);
 7628 
 7629         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 7630             preparePatchpointForExceptions(patchpoint);
 7631 
 7632         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 7633         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 7634         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 7635         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 7636         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 7637 
 7638         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 7639         State* state = &amp;m_ftlState;
 7640         VM* vm = &amp;this-&gt;vm();
 7641         patchpoint-&gt;setGenerator(
 7642             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7643                 AllowMacroScratchRegisterUsage allowScratch(jit);
 7644                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 7645 
 7646                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 7647 
 7648                 jit.store32(
 7649                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 7650                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 7651 
 7652                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 7653 
 7654                 CCallHelpers::DataLabelPtr targetToCheck;
 7655                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 7656                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
</pre>
<hr />
<pre>
 7735                 addArgument(m_out.constInt64(JSValue::encode(jsUndefined())), virtualRegisterForArgument(i), 0);
 7736         } else {
 7737             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
 7738                 arguments.append(ConstrainedValue(lowJSValue(m_graph.varArgChild(node, 1 + i)), ValueRep::WarmAny));
 7739         }
 7740 
 7741         PatchpointValue* patchpoint = m_out.patchpoint(isTail ? Void : Int64);
 7742         patchpoint-&gt;appendVector(arguments);
 7743 
 7744         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 7745 
 7746         if (isTail) {
 7747             // The shuffler needs tags.
 7748             patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 7749             patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 7750         }
 7751 
 7752         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 7753         if (!isTail) {
 7754             patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 7755             patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 7756         }
 7757 
 7758         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 7759         State* state = &amp;m_ftlState;
 7760         patchpoint-&gt;setGenerator(
 7761             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7762                 AllowMacroScratchRegisterUsage allowScratch(jit);
 7763                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 7764 
 7765                 GPRReg calleeGPR = params[!isTail].gpr();
 7766 
 7767                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 7768 
 7769                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 7770                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 7771 
 7772                 if (isTail) {
 7773                     CallFrameShuffleData shuffleData;
 7774                     shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 7775 
</pre>
<hr />
<pre>
 8029             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8030                 BitVector* bitVector = target-&gt;bitVector();
 8031                 for (unsigned i = target-&gt;numChildren(); i--; ) {
 8032                     if (bitVector-&gt;get(i))
 8033                         self(m_graph.varArgChild(target, i).node());
 8034                     else {
 8035                         ++staticArgumentCount;
 8036                         LValue argument = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 8037                         patchpointArguments.append(argument);
 8038                     }
 8039                 }
 8040                 return;
 8041             }
 8042 
 8043             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8044                 staticArgumentCount += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 8045                 return;
 8046             }
 8047 
 8048             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 8049             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8050             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8051             LValue length = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 8052                 return m_out.zeroExtPtr(this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));
 8053             }).iterator-&gt;value;
 8054             patchpointArguments.append(length);
 8055             spreadLengths.append(length);
 8056         });
 8057 
 8058         pushAndCountArgumentsFromRightToLeft(arguments);
 8059         LValue argumentCountIncludingThis = m_out.constIntPtr(staticArgumentCount + 1);
 8060         for (LValue length : spreadLengths)
 8061             argumentCountIncludingThis = m_out.add(length, argumentCountIncludingThis);
 8062 
 8063         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8064 
 8065         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 8066         patchpoint-&gt;append(thisArg, ValueRep::WarmAny);
 8067         patchpoint-&gt;append(argumentCountIncludingThis, ValueRep::WarmAny);
 8068         patchpoint-&gt;appendVectorWithRep(patchpointArguments, ValueRep::WarmAny);
 8069         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8070         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8071 
 8072         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8073 
 8074         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8075         patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
<span class="line-modified"> 8076         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 8077 
 8078         patchpoint-&gt;numGPScratchRegisters = 0;
 8079 
 8080         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8081         unsigned minimumJSCallAreaSize =
 8082             sizeof(CallerFrameAndPC) +
 8083             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8084 
 8085         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8086 
 8087         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8088         State* state = &amp;m_ftlState;
 8089         VM* vm = &amp;this-&gt;vm();
 8090         patchpoint-&gt;setGenerator(
 8091             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8092                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8093                 CallSiteIndex callSiteIndex =
 8094                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8095 
 8096                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
</pre>
<hr />
<pre>
 8192                         }
 8193 
 8194                         if (target-&gt;op() == PhantomNewArrayBuffer) {
 8195                             auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 8196                             Checked&lt;int32_t&gt; offsetCount { 1 };
 8197                             for (unsigned i = array-&gt;length(); i--; ++offsetCount) {
 8198                                 // Because varargs values are drained as JSValue, we should not generate value
 8199                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 8200                                 int64_t value = JSValue::encode(array-&gt;get(i));
 8201                                 jit.move(CCallHelpers::TrustedImm64(value), scratchGPR3);
 8202                                 Checked&lt;int32_t&gt; currentStoreOffset { storeOffset };
 8203                                 currentStoreOffset -= (offsetCount * static_cast&lt;int32_t&gt;(sizeof(Register)));
 8204                                 jit.store64(scratchGPR3,
 8205                                     CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, currentStoreOffset.unsafeGet()));
 8206                             }
 8207                             jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(array-&gt;length())), scratchGPR2);
 8208                             return;
 8209                         }
 8210 
 8211                         RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 8212                         InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8213 
 8214                         unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8215 
 8216                         B3::ValueRep numArgumentsToCopy = params[paramsOffset + (index++)];
 8217                         getValueFromRep(numArgumentsToCopy, scratchGPR3);
 8218                         int loadOffset = (AssemblyHelpers::argumentsStart(inlineCallFrame).offset() + numberOfArgumentsToSkip) * static_cast&lt;int&gt;(sizeof(Register));
 8219 
 8220                         auto done = jit.branchTestPtr(MacroAssembler::Zero, scratchGPR3);
 8221                         auto loopStart = jit.label();
 8222                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR3);
 8223                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 8224                         jit.load64(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR3, CCallHelpers::TimesEight, loadOffset), scratchGPR4);
 8225                         jit.store64(scratchGPR4,
 8226                             CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 8227                         jit.branchTestPtr(CCallHelpers::NonZero, scratchGPR3).linkTo(loopStart, &amp;jit);
 8228                         done.link(&amp;jit);
 8229                     });
 8230                     emitArgumentsFromRightToLeft(arguments);
 8231                 }
 8232 
</pre>
<hr />
<pre>
 8358             patchpoint-&gt;appendSomeRegister(jsArguments);
 8359         patchpoint-&gt;appendSomeRegister(thisArg);
 8360 
 8361         if (!forwarding) {
 8362             // Now append them again for after clobbering. Note that the compiler may ask us to use a
 8363             // different register for the late for the post-clobbering version of the value. This gives
 8364             // the compiler a chance to spill these values without having to burn any callee-saves.
 8365             patchpoint-&gt;append(jsCallee, ValueRep::LateColdAny);
 8366             patchpoint-&gt;append(jsArguments, ValueRep::LateColdAny);
 8367             patchpoint-&gt;append(thisArg, ValueRep::LateColdAny);
 8368         }
 8369 
 8370         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 8371             preparePatchpointForExceptions(patchpoint);
 8372 
 8373         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8374         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8375 
 8376         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8377         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 8378         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 8379 
 8380         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8381         unsigned minimumJSCallAreaSize =
 8382             sizeof(CallerFrameAndPC) +
 8383             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8384 
 8385         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8386 
 8387         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8388         State* state = &amp;m_ftlState;
 8389         VM* vm = &amp;this-&gt;vm();
 8390         patchpoint-&gt;setGenerator(
 8391             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8392                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8393                 CallSiteIndex callSiteIndex =
 8394                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8395 
 8396                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8397                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8398 
</pre>
<hr />
<pre>
 8472                 ScratchRegisterAllocator allocator(usedRegisters);
 8473                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 8474                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 8475                 GPRReg scratchGPR3 = forwarding ? allocator.allocateScratchGPR() : InvalidGPRReg;
 8476                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 8477 
 8478                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 8479                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 8480                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8481                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8482                 };
 8483 
 8484                 unsigned originalStackHeight = params.proc().frameSize();
 8485 
 8486                 if (forwarding) {
 8487                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8488 
 8489                     CCallHelpers::JumpList slowCase;
 8490                     InlineCallFrame* inlineCallFrame;
 8491                     if (node-&gt;child3())
<span class="line-modified"> 8492                         inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame;</span>
 8493                     else
<span class="line-modified"> 8494                         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;</span>
 8495 
 8496                     // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 8497                     emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 8498 
 8499                     CCallHelpers::Jump done = jit.jump();
 8500                     slowCase.link(&amp;jit);
 8501                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();
 8502                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 8503                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 8504 
 8505                     done.link(&amp;jit);
 8506                 } else {
 8507                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR1);
 8508                     jit.setupArguments&lt;decltype(operationSizeFrameForVarargs)&gt;(argumentsGPR, scratchGPR1, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset));
 8509                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSizeFrameForVarargs));
 8510 
 8511                     jit.move(GPRInfo::returnValueGPR, scratchGPR1);
 8512                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8513                     argumentsLateRep.emitRestore(jit, argumentsGPR);
 8514                     emitSetVarargsFrame(jit, scratchGPR1, false, scratchGPR2, scratchGPR2);
</pre>
<hr />
<pre>
 8615         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 8616             intptr_t offsetFromSP =
 8617                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 8618             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 8619         };
 8620 
 8621         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 8622         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 8623         for (unsigned i = 0; i &lt; numArgs; ++i)
 8624             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 8625 
 8626         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8627         patchpoint-&gt;appendVector(arguments);
 8628 
 8629         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8630 
 8631         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8632         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8633         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8634         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 8635         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 8636 
 8637         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8638         State* state = &amp;m_ftlState;
 8639         VM&amp; vm = this-&gt;vm();
 8640         patchpoint-&gt;setGenerator(
 8641             [=, &amp;vm] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8642                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8643                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8644 
 8645                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8646 
 8647                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8648 
 8649                 jit.store32(
 8650                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8651                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8652 
 8653                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8654                 callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, node-&gt;origin.semantic, GPRInfo::regT0);
 8655 
</pre>
<hr />
<pre>
 8718 
 8719         vmCall(
 8720             Void, m_out.operation(operationLoadVarargs), m_callFrame,
 8721             m_out.castToInt32(machineStart), jsArguments, m_out.constInt32(data-&gt;offset),
 8722             length, m_out.constInt32(data-&gt;mandatoryMinimum));
 8723     }
 8724 
 8725     void compileForwardVarargs()
 8726     {
 8727         if (m_node-&gt;child1()) {
 8728             Node* arguments = m_node-&gt;child1().node();
 8729             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 8730                 compileForwardVarargsWithSpread();
 8731                 return;
 8732             }
 8733         }
 8734 
 8735         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8736         InlineCallFrame* inlineCallFrame;
 8737         if (m_node-&gt;child1())
<span class="line-modified"> 8738             inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 8739         else
<span class="line-modified"> 8740             inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame;</span>
 8741 
 8742         LValue length = nullptr;
 8743         LValue lengthIncludingThis = nullptr;
 8744         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
 8745         if (argumentsLength.isKnown) {
 8746             unsigned knownLength = argumentsLength.known;
 8747             if (knownLength &gt;= data-&gt;offset)
 8748                 knownLength = knownLength - data-&gt;offset;
 8749             else
 8750                 knownLength = 0;
 8751             length = m_out.constInt32(knownLength);
 8752             lengthIncludingThis = m_out.constInt32(knownLength + 1);
 8753         } else {
 8754             // We need to perform the same logical operation as the code above, but through dynamic operations.
 8755             if (!data-&gt;offset)
 8756                 length = argumentsLength.value;
 8757             else {
 8758                 LBasicBlock isLarger = m_out.newBlock();
 8759                 LBasicBlock continuation = m_out.newBlock();
 8760 
</pre>
<hr />
<pre>
 8867                 return;
 8868             }
 8869 
 8870             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8871                 BitVector* bitVector = target-&gt;bitVector();
 8872                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {
 8873                     if (bitVector-&gt;get(i))
 8874                         self(m_graph.varArgChild(target, i).node());
 8875                     else
 8876                         ++numberOfStaticArguments;
 8877                 }
 8878                 return;
 8879             }
 8880 
 8881             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8882                 numberOfStaticArguments += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 8883                 return;
 8884             }
 8885 
 8886             ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 8887             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8888             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8889             spreadLengths.append(cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 8890                 return this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 8891             }).iterator-&gt;value);
 8892         });
 8893 
 8894         collectArgumentCount(arguments);
 8895         LValue lengthIncludingThis = m_out.constInt32(1 + numberOfStaticArguments);
 8896         for (LValue length : spreadLengths)
 8897             lengthIncludingThis = m_out.add(lengthIncludingThis, length);
 8898 
 8899         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8900         speculate(
 8901             VarargsOverflow, noValue(), nullptr,
 8902             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 8903 
 8904         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 8905 
 8906         LValue targetStart = addressFor(data-&gt;machineStart).value();
 8907 
</pre>
<hr />
<pre>
 8918                         LValue value = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 8919                         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, storeIndex));
 8920                         storeIndex = m_out.add(m_out.constIntPtr(1), storeIndex);
 8921                     }
 8922                 }
 8923                 return storeIndex;
 8924             }
 8925 
 8926             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8927                 auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 8928                 for (unsigned i = 0; i &lt; array-&gt;length(); i++) {
 8929                     // Because forwarded values are drained as JSValue, we should not generate value
 8930                     // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 8931                     int64_t value = JSValue::encode(array-&gt;get(i));
 8932                     m_out.store64(m_out.constInt64(value), m_out.baseIndex(m_heaps.variables, targetStart, storeIndex, JSValue(), (Checked&lt;int32_t&gt;(sizeof(Register)) * i).unsafeGet()));
 8933                 }
 8934                 return m_out.add(m_out.constIntPtr(array-&gt;length()), storeIndex);
 8935             }
 8936 
 8937             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 8938             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8939 
 8940             LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, target-&gt;numberOfArgumentsToSkip());
 8941             LValue spreadLength = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 8942 
 8943             LBasicBlock loop = m_out.newBlock();
 8944             LBasicBlock continuation = m_out.newBlock();
 8945             ValueFromBlock startLoadIndex = m_out.anchor(m_out.constIntPtr(0));
 8946             ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 8947             ValueFromBlock startStoreIndexForEnd = m_out.anchor(storeIndex);
 8948 
 8949             m_out.branch(m_out.isZero64(spreadLength), unsure(continuation), unsure(loop));
 8950 
 8951             LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 8952             LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 8953             LValue loadIndex = m_out.phi(Int64, startLoadIndex);
 8954             LValue value = m_out.load64(
 8955                 m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 8956             m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 8957             LValue nextLoadIndex = m_out.add(m_out.constIntPtr(1), loadIndex);
 8958             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
</pre>
<hr />
<pre>
 9269                     jit.mfence();
 9270                     break;
 9271                 case CPUCpuidIntrinsic:
 9272                     jit.cpuid();
 9273                     break;
 9274                 case CPUPauseIntrinsic:
 9275                     jit.pause();
 9276                     break;
 9277                 default:
 9278                     RELEASE_ASSERT_NOT_REACHED();
 9279                 }
 9280             });
 9281             setJSValue(m_out.constInt64(JSValue::encode(jsUndefined())));
 9282             break;
 9283         }
 9284         case CPURdtscIntrinsic: {
 9285             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 9286             patchpoint-&gt;effects = Effects::forCall();
 9287             patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::edx });
 9288             // The low 32-bits of rdtsc go into rax.
<span class="line-modified"> 9289             patchpoint-&gt;resultConstraint = ValueRep::reg(X86Registers::eax);</span>
 9290             patchpoint-&gt;setGenerator( [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 9291                 jit.rdtsc();
 9292             });
 9293             setJSValue(boxInt32(patchpoint));
 9294             break;
 9295         }
 9296         default:
 9297             RELEASE_ASSERT_NOT_REACHED();
 9298 
 9299         }
 9300 #endif
 9301     }
 9302 
 9303     void compileThrow()
 9304     {
 9305         LValue error = lowJSValue(m_node-&gt;child1());
 9306         vmCall(Void, m_out.operation(operationThrowDFG), m_callFrame, error);
 9307         // vmCall() does an exception check so we should never reach this.
 9308         m_out.unreachable();
 9309     }
</pre>
<hr />
<pre>
 9643     {
 9644         ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
 9645 
 9646         LBasicBlock isNumberCase = m_out.newBlock();
 9647         LBasicBlock notInt32NumberCase = m_out.newBlock();
 9648         LBasicBlock notNaNCase = m_out.newBlock();
 9649         LBasicBlock convertibleCase = m_out.newBlock();
 9650         LBasicBlock continuation = m_out.newBlock();
 9651 
 9652         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isNumberCase);
 9653 
 9654         LValue key = lowJSValue(m_node-&gt;child1());
 9655         ValueFromBlock fastResult = m_out.anchor(key);
 9656         m_out.branch(isNotNumber(key), unsure(continuation), unsure(isNumberCase));
 9657 
 9658         m_out.appendTo(isNumberCase, notInt32NumberCase);
 9659         m_out.branch(isInt32(key), unsure(continuation), unsure(notInt32NumberCase));
 9660 
 9661         m_out.appendTo(notInt32NumberCase, notNaNCase);
 9662         LValue doubleValue = unboxDouble(key);

 9663         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue), unsure(continuation), unsure(notNaNCase));
 9664 
 9665         m_out.appendTo(notNaNCase, convertibleCase);
 9666         LValue integerValue = m_out.doubleToInt(doubleValue);
 9667         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);

 9668         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, integerValueConvertedToDouble), unsure(continuation), unsure(convertibleCase));
 9669 
 9670         m_out.appendTo(convertibleCase, continuation);
<span class="line-modified"> 9671         ValueFromBlock slowResult = m_out.anchor(boxInt32(integerValue));</span>
 9672         m_out.jump(continuation);
 9673 
 9674         m_out.appendTo(continuation, lastNext);
<span class="line-modified"> 9675         setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
 9676     }
 9677 
 9678     void compileGetMapBucket()
 9679     {
 9680         LBasicBlock loopStart = m_out.newBlock();
 9681         LBasicBlock loopAround = m_out.newBlock();
 9682         LBasicBlock slowPath = m_out.newBlock();
 9683         LBasicBlock notPresentInTable = m_out.newBlock();
 9684         LBasicBlock notEmptyValue = m_out.newBlock();
 9685         LBasicBlock notDeletedValue = m_out.newBlock();
 9686         LBasicBlock continuation = m_out.newBlock();
 9687 
 9688         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
 9689 
 9690         LValue map;
 9691         if (m_node-&gt;child1().useKind() == MapObjectUse)
 9692             map = lowMapObject(m_node-&gt;child1());
 9693         else if (m_node-&gt;child1().useKind() == SetObjectUse)
 9694             map = lowSetObject(m_node-&gt;child1());
 9695         else
</pre>
<hr />
<pre>
10198                                 generator-&gt;finalize(linkBuffer, linkBuffer);
10199                             });
10200                     });
10201             });
10202 
10203         setJSValue(patchpoint);
10204     }
10205 
10206     void compileHasOwnProperty()
10207     {
10208         LBasicBlock slowCase = m_out.newBlock();
10209         LBasicBlock continuation = m_out.newBlock();
10210         LBasicBlock lastNext = nullptr;
10211 
10212         LValue object = lowObject(m_node-&gt;child1());
10213         LValue uniquedStringImpl;
10214         LValue keyAsValue = nullptr;
10215         switch (m_node-&gt;child2().useKind()) {
10216         case StringUse: {
10217             LBasicBlock isNonEmptyString = m_out.newBlock();
<span class="line-modified">10218             LBasicBlock isAtomicString = m_out.newBlock();</span>
10219 
10220             keyAsValue = lowString(m_node-&gt;child2());
10221             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10222 
<span class="line-modified">10223             lastNext = m_out.appendTo(isNonEmptyString, isAtomicString);</span>
10224             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
<span class="line-modified">10225             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtomic()));</span>
<span class="line-modified">10226             m_out.branch(isNotAtomic, rarely(slowCase), usually(isAtomicString));</span>
10227 
<span class="line-modified">10228             m_out.appendTo(isAtomicString, slowCase);</span>
10229             break;
10230         }
10231         case SymbolUse: {
10232             keyAsValue = lowSymbol(m_node-&gt;child2());
10233             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl);
10234             lastNext = m_out.insertNewBlocksBefore(slowCase);
10235             break;
10236         }
10237         case UntypedUse: {
10238             LBasicBlock isCellCase = m_out.newBlock();
10239             LBasicBlock isStringCase = m_out.newBlock();
10240             LBasicBlock notStringCase = m_out.newBlock();
10241             LBasicBlock isNonEmptyString = m_out.newBlock();
10242             LBasicBlock isSymbolCase = m_out.newBlock();
10243             LBasicBlock hasUniquedStringImpl = m_out.newBlock();
10244 
10245             keyAsValue = lowJSValue(m_node-&gt;child2());
10246             m_out.branch(isCell(keyAsValue), usually(isCellCase), rarely(slowCase));
10247 
10248             lastNext = m_out.appendTo(isCellCase, isStringCase);
10249             m_out.branch(isString(keyAsValue), unsure(isStringCase), unsure(notStringCase));
10250 
10251             m_out.appendTo(isStringCase, isNonEmptyString);
10252             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10253 
10254             m_out.appendTo(isNonEmptyString, notStringCase);
10255             LValue implFromString = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
10256             ValueFromBlock stringResult = m_out.anchor(implFromString);
<span class="line-modified">10257             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(implFromString, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtomic()));</span>
10258             m_out.branch(isNotAtomic, rarely(slowCase), usually(hasUniquedStringImpl));
10259 
10260             m_out.appendTo(notStringCase, isSymbolCase);
10261             m_out.branch(isSymbol(keyAsValue), unsure(isSymbolCase), unsure(slowCase));
10262 
10263             m_out.appendTo(isSymbolCase, hasUniquedStringImpl);
10264             ValueFromBlock symbolResult = m_out.anchor(m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl));
10265             m_out.jump(hasUniquedStringImpl);
10266 
10267             m_out.appendTo(hasUniquedStringImpl, slowCase);
10268             uniquedStringImpl = m_out.phi(pointerType(), stringResult, symbolResult);
10269             break;
10270         }
10271         default:
10272             RELEASE_ASSERT_NOT_REACHED();
10273         }
10274 
10275         ASSERT(keyAsValue);
10276 
<span class="line-modified">10277         // Note that we don&#39;t test if the hash is zero here. AtomicStringImpl&#39;s can&#39;t have a zero</span>
10278         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
10279         // ever load the result from the cache if the cache entry matches what we are querying for.
10280         // So we either get super lucky and use zero for the hash and somehow collide with the entity
10281         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
10282         // slow path anyways.
10283         LValue hash = m_out.lShr(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
10284 
10285         LValue structureID = m_out.load32(object, m_heaps.JSCell_structureID);
10286         LValue index = m_out.add(hash, structureID);
10287         index = m_out.zeroExtPtr(m_out.bitAnd(index, m_out.constInt32(HasOwnPropertyCache::mask)));
10288         ASSERT(vm().hasOwnPropertyCache());
10289         LValue cache = m_out.constIntPtr(vm().hasOwnPropertyCache());
10290 
10291         IndexedAbstractHeap&amp; heap = m_heaps.HasOwnPropertyCache;
10292         LValue sameStructureID = m_out.equal(structureID, m_out.load32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfStructureID())));
10293         LValue sameImpl = m_out.equal(uniquedStringImpl, m_out.loadPtr(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfImpl())));
10294         ValueFromBlock fastResult = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfResult())));
10295         LValue cacheHit = m_out.bitAnd(sameStructureID, sameImpl);
10296 
10297         m_out.branch(m_out.notZero32(cacheHit), usually(continuation), rarely(slowCase));
</pre>
<hr />
<pre>
10377             prototypeIsCell = true;
10378         } else {
10379             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
10380             DFG_ASSERT(m_graph, m_node, m_node-&gt;child2().useKind() == UntypedUse);
10381 
10382             value = lowJSValue(m_node-&gt;child1());
10383             prototype = lowJSValue(m_node-&gt;child2());
10384 
10385             valueIsCell = abstractValue(m_node-&gt;child1()).isType(SpecCell);
10386             prototypeIsCell = abstractValue(m_node-&gt;child2()).isType(SpecCell);
10387         }
10388 
10389         bool prototypeIsObject = abstractValue(m_node-&gt;child2()).isType(SpecObject | ~SpecCell);
10390 
10391         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
10392         patchpoint-&gt;appendSomeRegister(value);
10393         patchpoint-&gt;appendSomeRegister(prototype);
10394         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
10395         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
10396         patchpoint-&gt;numGPScratchRegisters = 2;
<span class="line-modified">10397         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
10398         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
10399 
10400         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
10401             preparePatchpointForExceptions(patchpoint);
10402 
10403         patchpoint-&gt;setGenerator(
10404             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10405                 AllowMacroScratchRegisterUsage allowScratch(jit);
10406 
10407                 GPRReg resultGPR = params[0].gpr();
10408                 GPRReg valueGPR = params[1].gpr();
10409                 GPRReg prototypeGPR = params[2].gpr();
10410                 GPRReg scratchGPR = params.gpScratch(0);
10411                 GPRReg scratch2GPR = params.gpScratch(1);
10412 
10413                 CCallHelpers::Jump doneJump;
10414                 if (!valueIsCell) {
10415                     CCallHelpers::Jump isCell = jit.branchIfCell(valueGPR);
10416                     jit.boxBooleanPayload(false, resultGPR);
10417                     doneJump = jit.jump();
</pre>
<hr />
<pre>
11070         }
11071 
11072         m_out.appendTo(dummyDefault, outerContinuation);
11073         m_out.unreachable();
11074 
11075         m_out.appendTo(outerContinuation, outerLastNext);
11076         setJSValue(m_out.phi(pointerType(), results));
11077         mutatorFence();
11078     }
11079 
11080     void compileMaterializeCreateActivation()
11081     {
11082         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
11083 
11084         Vector&lt;LValue, 8&gt; values;
11085         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)
11086             values.append(lowJSValue(m_graph.varArgChild(m_node, 2 + i)));
11087 
11088         LValue scope = lowCell(m_graph.varArgChild(m_node, 1));
11089         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
<span class="line-removed">11090         ASSERT(table == m_graph.varArgChild(m_node, 0)-&gt;castConstant&lt;SymbolTable*&gt;(vm()));</span>
11091         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
11092 
11093         LBasicBlock slowPath = m_out.newBlock();
11094         LBasicBlock continuation = m_out.newBlock();
11095 
11096         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
11097 
11098         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
11099             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
11100 
11101         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
11102         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
11103 
11104 
11105         ValueFromBlock fastResult = m_out.anchor(fastObject);
11106         m_out.jump(continuation);
11107 
11108         m_out.appendTo(slowPath, continuation);
11109         // We ensure allocation sinking explictly sets bottom values for all field members.
11110         // Therefore, it doesn&#39;t matter what JSValue we pass in as the initialization value
</pre>
<hr />
<pre>
11258             argument);
11259         setBoolean(result);
11260     }
11261 
11262     void compileRegExpMatchFast()
11263     {
11264         LValue globalObject = lowCell(m_node-&gt;child1());
11265         LValue base = lowRegExpObject(m_node-&gt;child2());
11266         LValue argument = lowString(m_node-&gt;child3());
11267         LValue result = vmCall(
11268             Int64, m_out.operation(operationRegExpMatchFastString), m_callFrame, globalObject,
11269             base, argument);
11270         setJSValue(result);
11271     }
11272 
11273     void compileNewRegexp()
11274     {
11275         FrozenValue* regexp = m_node-&gt;cellOperand();
11276         LValue lastIndex = lowJSValue(m_node-&gt;child1());
11277         ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
<span class="line-removed">11278         ASSERT(m_node-&gt;castOperand&lt;RegExp*&gt;()-&gt;isValid());</span>
11279 
11280         LBasicBlock slowCase = m_out.newBlock();
11281         LBasicBlock continuation = m_out.newBlock();
11282 
11283         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
11284 
11285         auto structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;regExpStructure());
11286         LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
<span class="line-modified">11287         m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExp);</span>
11288         m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
<span class="line-removed">11289         m_out.store32As8(m_out.constInt32(true), m_out.address(fastResultValue, m_heaps.RegExpObject_lastIndexIsWritable));</span>
11290         mutatorFence();
11291         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
11292         m_out.jump(continuation);
11293 
11294         m_out.appendTo(slowCase, continuation);
11295         VM&amp; vm = this-&gt;vm();
11296         RegExp* regexpCell = regexp-&gt;cast&lt;RegExp*&gt;();
11297         LValue slowResultValue = lazySlowPath(
11298             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11299                 return createLazyCallGenerator(vm,
11300                     operationNewRegexpWithLastIndex, locations[0].directGPR(),
11301                     CCallHelpers::TrustedImmPtr(regexpCell), locations[1].directGPR());
11302             }, lastIndex);
11303         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
11304         m_out.jump(continuation);
11305 
11306         m_out.appendTo(continuation, lastNext);
11307         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
11308     }
11309 
</pre>
<hr />
<pre>
11355             pointerType(), m_out.operation(operationStringProtoFuncReplaceGeneric), m_callFrame,
11356             lowJSValue(m_node-&gt;child1()), search,
11357             lowJSValue(m_node-&gt;child3()));
11358 
11359         setJSValue(result);
11360     }
11361 
11362     void compileGetRegExpObjectLastIndex()
11363     {
11364         setJSValue(m_out.load64(lowRegExpObject(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex));
11365     }
11366 
11367     void compileSetRegExpObjectLastIndex()
11368     {
11369         if (!m_node-&gt;ignoreLastIndexIsWritable()) {
11370             LValue regExp = lowRegExpObject(m_node-&gt;child1());
11371             LValue value = lowJSValue(m_node-&gt;child2());
11372 
11373             speculate(
11374                 ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">11375                 m_out.isZero32(m_out.load8ZeroExt32(regExp, m_heaps.RegExpObject_lastIndexIsWritable)));</span>


11376 
11377             m_out.store64(value, regExp, m_heaps.RegExpObject_lastIndex);
11378             return;
11379         }
11380 
11381         m_out.store64(lowJSValue(m_node-&gt;child2()), lowCell(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex);
11382     }
11383 
11384     void compileLogShadowChickenPrologue()
11385     {
11386         LValue packet = ensureShadowChickenPacket();
11387         LValue scope = lowCell(m_node-&gt;child1());
11388 
11389         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
11390         m_out.storePtr(m_out.loadPtr(addressFor(0)), packet, m_heaps.ShadowChicken_Packet_callerFrame);
11391         m_out.storePtr(m_out.loadPtr(payloadFor(CallFrameSlot::callee)), packet, m_heaps.ShadowChicken_Packet_callee);
11392         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
11393     }
11394 
11395     void compileLogShadowChickenTail()
</pre>
<hr />
<pre>
11452             length.known = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
11453             length.isKnown = true;
11454             length.value = m_out.constInt32(length.known);
11455         } else {
11456             length.known = UINT_MAX;
11457             length.isKnown = false;
11458 
11459             VirtualRegister argumentCountRegister;
11460             if (!inlineCallFrame)
11461                 argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
11462             else
11463                 argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
11464             length.value = m_out.sub(m_out.load32(payloadFor(argumentCountRegister)), m_out.int32One);
11465         }
11466 
11467         return length;
11468     }
11469 
11470     ArgumentsLength getArgumentsLength()
11471     {
<span class="line-modified">11472         return getArgumentsLength(m_node-&gt;origin.semantic.inlineCallFrame);</span>
11473     }
11474 
11475     LValue getCurrentCallee()
11476     {
<span class="line-modified">11477         if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame) {</span>
11478             if (frame-&gt;isClosureCall)
11479                 return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
11480             return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
11481         }
11482         return m_out.loadPtr(addressFor(CallFrameSlot::callee));
11483     }
11484 
11485     LValue getArgumentsStart(InlineCallFrame* inlineCallFrame, unsigned offset = 0)
11486     {
11487         VirtualRegister start = AssemblyHelpers::argumentsStart(inlineCallFrame) + offset;
11488         return addressFor(start).value();
11489     }
11490 
11491     LValue getArgumentsStart()
11492     {
<span class="line-modified">11493         return getArgumentsStart(m_node-&gt;origin.semantic.inlineCallFrame);</span>
11494     }
11495 
11496     template&lt;typename Functor&gt;
11497     void checkStructure(
11498         LValue structureDiscriminant, const FormattedValue&amp; formattedValue, ExitKind exitKind,
11499         const RegisteredStructureSet&amp; set, const Functor&amp; weakStructureDiscriminant)
11500     {
11501         if (set.isEmpty()) {
11502             terminate(exitKind);
11503             return;
11504         }
11505 
11506         if (set.size() == 1) {
11507             speculate(
11508                 exitKind, formattedValue, 0,
11509                 m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set[0])));
11510             return;
11511         }
11512 
11513         LBasicBlock continuation = m_out.newBlock();
</pre>
<hr />
<pre>
12007         LValue start = lowInt32(m_node-&gt;child2());
12008         LValue end = nullptr;
12009         if (m_node-&gt;child3())
12010             end = lowInt32(m_node-&gt;child3());
12011         else
12012             end = m_out.constInt32(std::numeric_limits&lt;int32_t&gt;::max());
12013         m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropeSlowCase), usually(lengthCheckCase));
12014 
12015         LBasicBlock lastNext = m_out.appendTo(lengthCheckCase, emptyCase);
12016         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
12017         LValue length = m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length);
12018         auto range = populateSliceRange(start, end, length);
12019         LValue from = range.first;
12020         LValue to = range.second;
12021         LValue span = m_out.sub(to, from);
12022         m_out.branch(m_out.lessThanOrEqual(span, m_out.int32Zero), unsure(emptyCase), unsure(notEmptyCase));
12023 
12024         Vector&lt;ValueFromBlock, 5&gt; results;
12025 
12026         m_out.appendTo(emptyCase, notEmptyCase);
<span class="line-modified">12027         results.append(m_out.anchor(weakPointer(jsEmptyString(&amp;vm()))));</span>
12028         m_out.jump(continuation);
12029 
12030         m_out.appendTo(notEmptyCase, oneCharCase);
12031         m_out.branch(m_out.equal(span, m_out.int32One), unsure(oneCharCase), unsure(slowCase));
12032 
12033         m_out.appendTo(oneCharCase, is8Bit);
12034         LValue storage = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
12035         m_out.branch(
12036             m_out.testIsZero32(
12037                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
12038                 m_out.constInt32(StringImpl::flagIs8Bit())),
12039             unsure(is16Bit), unsure(is8Bit));
12040 
12041         m_out.appendTo(is8Bit, is16Bit);
12042         ValueFromBlock char8Bit = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, storage, m_out.zeroExtPtr(from))));
12043         m_out.jump(bitsContinuation);
12044 
12045         m_out.appendTo(is16Bit, bigCharacter);
12046         LValue char16BitValue = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(from)));
12047         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
</pre>
<hr />
<pre>
12176         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScopeForHoistingFuncDeclInEval), m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12177     }
12178 
12179     void compileResolveScope()
12180     {
12181         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12182         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScope),
12183             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12184     }
12185 
12186     void compileGetDynamicVar()
12187     {
12188         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12189         setJSValue(vmCall(Int64, m_out.operation(operationGetDynamicVar),
12190             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12191     }
12192 
12193     void compilePutDynamicVar()
12194     {
12195         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">12196         setJSValue(vmCall(Void, m_out.operation(operationPutDynamicVar),</span>
12197             m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12198     }
12199 
12200     void compileUnreachable()
12201     {
12202         // It&#39;s so tempting to assert that AI has proved that this is unreachable. But that&#39;s
12203         // simply not a requirement of the Unreachable opcode at all. If you emit an opcode that
12204         // *you* know will not return, then it&#39;s fine to end the basic block with Unreachable
12205         // after that opcode. You don&#39;t have to also prove to AI that your opcode does not return.
12206         // Hence, there is nothing to do here but emit code that will crash, so that we catch
12207         // cases where you said Unreachable but you lied.
12208         //
12209         // It&#39;s also also worth noting that some clients emit this opcode because they&#39;re not 100% sure
12210         // if the code is unreachable, but they would really prefer if we crashed rather than kept going
12211         // if it did turn out to be reachable. Hence, this needs to deterministically crash.
12212 
12213         crash();
12214     }
12215 
12216     void compileCheckSubClass()
</pre>
<hr />
<pre>
12305                 switch (signature-&gt;arguments[index - 1]) {
12306                 case SpecString:
12307                     operands.append(lowString(edge));
12308                     break;
12309                 case SpecInt32Only:
12310                     operands.append(lowInt32(edge));
12311                     break;
12312                 case SpecBoolean:
12313                     operands.append(lowBoolean(edge));
12314                     break;
12315                 default:
12316                     RELEASE_ASSERT_NOT_REACHED();
12317                     break;
12318                 }
12319             }
12320             ++index;
12321         });
12322 
12323         unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
12324         LValue result;
<span class="line-modified">12325         assertIsTaggedWith(reinterpret_cast&lt;void*&gt;(signature-&gt;unsafeFunction), CFunctionPtrTag);</span>
12326         switch (argumentCountIncludingThis) {
12327         case 1:
<span class="line-modified">12328             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0]);</span>
12329             break;
12330         case 2:
<span class="line-modified">12331             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0], operands[1]);</span>
12332             break;
12333         case 3:
<span class="line-modified">12334             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0], operands[1], operands[2]);</span>
12335             break;
12336         default:
12337             RELEASE_ASSERT_NOT_REACHED();
12338             break;
12339         }
12340 
12341         setJSValue(result);
12342     }
12343 
12344     void compileCallDOMGetter()
12345     {
12346         DOMJIT::CallDOMGetterSnippet* domJIT = m_node-&gt;callDOMGetterData()-&gt;snippet;
12347         if (!domJIT) {
12348             // The following function is not an operation: we directly call a custom accessor getter.
12349             // Since the getter does not have code setting topCallFrame, As is the same to IC, we should set topCallFrame in caller side.
12350             m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));
12351             setJSValue(
12352                 vmCall(Int64, m_out.operation(m_node-&gt;callDOMGetterData()-&gt;customAccessorGetter.retaggedExecutableAddress&lt;CFunctionPtrTag&gt;()),
12353                     m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;callDOMGetterData()-&gt;identifierNumber])));
12354             return;
</pre>
<hr />
<pre>
12359         JSValue baseConstant = m_state.forNode(baseEdge).value();
12360 
12361         LValue globalObject;
12362         JSValue globalObjectConstant;
12363         if (domJIT-&gt;requireGlobalObject) {
12364             Edge&amp; globalObjectEdge = m_node-&gt;child2();
12365             globalObject = lowCell(globalObjectEdge);
12366             globalObjectConstant = m_state.forNode(globalObjectEdge).value();
12367         }
12368 
12369         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12370         patchpoint-&gt;appendSomeRegister(base);
12371         if (domJIT-&gt;requireGlobalObject)
12372             patchpoint-&gt;appendSomeRegister(globalObject);
12373         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
12374         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
12375         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
12376         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12377         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
12378         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
<span class="line-modified">12379         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
12380 
12381         State* state = &amp;m_ftlState;
12382         Node* node = m_node;
12383         patchpoint-&gt;setGenerator(
12384             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12385                 AllowMacroScratchRegisterUsage allowScratch(jit);
12386 
12387                 Vector&lt;GPRReg&gt; gpScratch;
12388                 Vector&lt;FPRReg&gt; fpScratch;
12389                 Vector&lt;SnippetParams::Value&gt; regs;
12390 
12391                 regs.append(JSValueRegs(params[0].gpr()));
12392                 regs.append(SnippetParams::Value(params[1].gpr(), baseConstant));
12393                 if (domJIT-&gt;requireGlobalObject)
12394                     regs.append(SnippetParams::Value(params[2].gpr(), globalObjectConstant));
12395 
12396                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
12397                     gpScratch.append(params.gpScratch(i));
12398 
12399                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
</pre>
<hr />
<pre>
12475             return m_out.phi(type, bigEndianResult, littleEndianResult);
12476         return nullptr;
12477     }
12478 
12479     void compileDataViewGet()
12480     {
12481         LValue dataView = lowDataViewObject(m_node-&gt;child1());
12482         LValue index = lowInt32(m_node-&gt;child2());
12483         LValue isLittleEndian = nullptr;
12484         if (m_node-&gt;child3())
12485             isLittleEndian = lowBoolean(m_node-&gt;child3());
12486 
12487         DataViewData data = m_node-&gt;dataViewData();
12488 
12489         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
12490         LValue indexToCheck = m_out.zeroExtPtr(index);
12491         if (data.byteSize &gt; 1)
12492             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12493         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12494 
<span class="line-modified">12495         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector));</span>
12496 
12497         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12498 
12499         if (m_node-&gt;op() == DataViewGetInt) {
12500             switch (data.byteSize) {
12501             case 1:
12502                 if (data.isSigned)
12503                     setInt32(m_out.load8SignExt32(pointer));
12504                 else
12505                     setInt32(m_out.load8ZeroExt32(pointer));
12506                 break;
12507             case 2: {
12508                 auto emitLittleEndianLoad = [&amp;] {
12509                     if (data.isSigned)
12510                         return m_out.load16SignExt32(pointer);
12511                     return m_out.load16ZeroExt32(pointer);
12512                 };
12513 
12514                 auto emitBigEndianLoad = [&amp;] {
12515                     LValue val = m_out.load16ZeroExt32(pointer);
</pre>
<hr />
<pre>
12634         if (data.byteSize &gt; 1)
12635             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12636         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12637 
12638         Edge&amp; valueEdge = m_graph.varArgChild(m_node, 2);
12639         LValue valueToStore;
12640         switch (valueEdge.useKind()) {
12641         case Int32Use:
12642             valueToStore = lowInt32(valueEdge);
12643             break;
12644         case DoubleRepUse:
12645             valueToStore = lowDouble(valueEdge);
12646             break;
12647         case Int52RepUse:
12648             valueToStore = lowStrictInt52(valueEdge);
12649             break;
12650         default:
12651             RELEASE_ASSERT_NOT_REACHED();
12652         }
12653 
<span class="line-modified">12654         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector));</span>
12655         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12656 
12657         if (data.isFloatingPoint) {
12658             if (data.byteSize == 4) {
12659                 valueToStore = m_out.doubleToFloat(valueToStore);
12660 
12661                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12662                     m_out.storeFloat(valueToStore, pointer);
12663                     return nullptr;
12664                 };
12665 
12666                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12667                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12668                     patchpoint-&gt;appendSomeRegister(valueToStore);
12669                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12670                         jit.moveFloatTo32(params[1].fpr(), params[0].gpr());
12671                         jit.byteSwap32(params[0].gpr());
12672                     });
12673                     patchpoint-&gt;effects = Effects::none();
12674                     m_out.store32(patchpoint, pointer);
</pre>
<hr />
<pre>
12965         Node* node = m_node;
12966 
12967         LValue left = lowJSValue(node-&gt;child1());
12968         LValue right = lowJSValue(node-&gt;child2());
12969 
12970         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
12971         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
12972 
12973         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12974         patchpoint-&gt;appendSomeRegister(left);
12975         patchpoint-&gt;appendSomeRegister(right);
12976         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
12977         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
12978         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
12979             preparePatchpointForExceptions(patchpoint);
12980         patchpoint-&gt;numGPScratchRegisters = 1;
12981         patchpoint-&gt;numFPScratchRegisters = 2;
12982         if (scratchFPRUsage == NeedScratchFPR)
12983             patchpoint-&gt;numFPScratchRegisters++;
12984         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">12985         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
12986         State* state = &amp;m_ftlState;
12987         patchpoint-&gt;setGenerator(
12988             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12989                 AllowMacroScratchRegisterUsage allowScratch(jit);
12990 
12991                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
12992                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12993 
12994                 auto generator = Box&lt;BinaryArithOpGenerator&gt;::create(
12995                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
12996                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
12997                     params.fpScratch(0), params.fpScratch(1), params.gpScratch(0),
12998                     scratchFPRUsage == NeedScratchFPR ? params.fpScratch(2) : InvalidFPRReg);
12999 
13000                 generator-&gt;generateFastPath(jit);
13001 
13002                 if (generator-&gt;didEmitFastPath()) {
13003                     generator-&gt;endJumpList().link(&amp;jit);
13004                     CCallHelpers::Label done = jit.label();
13005 
</pre>
<hr />
<pre>
13028     template&lt;typename BinaryBitOpGenerator&gt;
13029     void emitBinaryBitOpSnippet(J_JITOperation_EJJ slowPathFunction)
13030     {
13031         Node* node = m_node;
13032 
13033         LValue left = lowJSValue(node-&gt;child1());
13034         LValue right = lowJSValue(node-&gt;child2());
13035 
13036         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13037         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13038 
13039         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13040         patchpoint-&gt;appendSomeRegister(left);
13041         patchpoint-&gt;appendSomeRegister(right);
13042         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13043         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13044         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13045             preparePatchpointForExceptions(patchpoint);
13046         patchpoint-&gt;numGPScratchRegisters = 1;
13047         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">13048         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
13049         State* state = &amp;m_ftlState;
13050         patchpoint-&gt;setGenerator(
13051             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13052                 AllowMacroScratchRegisterUsage allowScratch(jit);
13053 
13054                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13055                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13056 
13057                 auto generator = Box&lt;BinaryBitOpGenerator&gt;::create(
13058                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13059                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.gpScratch(0));
13060 
13061                 generator-&gt;generateFastPath(jit);
13062                 generator-&gt;endJumpList().link(&amp;jit);
13063                 CCallHelpers::Label done = jit.label();
13064 
13065                 params.addLatePath(
13066                     [=] (CCallHelpers&amp; jit) {
13067                         AllowMacroScratchRegisterUsage allowScratch(jit);
13068 
</pre>
<hr />
<pre>
13084 
13085         // FIXME: Make this do exceptions.
13086         // https://bugs.webkit.org/show_bug.cgi?id=151686
13087 
13088         LValue left = lowJSValue(node-&gt;child1());
13089         LValue right = lowJSValue(node-&gt;child2());
13090 
13091         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13092         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13093 
13094         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13095         patchpoint-&gt;appendSomeRegister(left);
13096         patchpoint-&gt;appendSomeRegister(right);
13097         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13098         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13099         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13100             preparePatchpointForExceptions(patchpoint);
13101         patchpoint-&gt;numGPScratchRegisters = 1;
13102         patchpoint-&gt;numFPScratchRegisters = 1;
13103         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">13104         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
13105         State* state = &amp;m_ftlState;
13106         patchpoint-&gt;setGenerator(
13107             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13108                 AllowMacroScratchRegisterUsage allowScratch(jit);
13109 
13110                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13111                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13112 
13113                 auto generator = Box&lt;JITRightShiftGenerator&gt;::create(
13114                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13115                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
13116                     params.fpScratch(0), params.gpScratch(0), InvalidFPRReg, shiftType);
13117 
13118                 generator-&gt;generateFastPath(jit);
13119                 generator-&gt;endJumpList().link(&amp;jit);
13120                 CCallHelpers::Label done = jit.label();
13121 
13122                 params.addLatePath(
13123                     [=] (CCallHelpers&amp; jit) {
13124                         AllowMacroScratchRegisterUsage allowScratch(jit);
</pre>
<hr />
<pre>
13165                 m_out.notEqual(allocator, m_out.intPtrZero),
13166                 usually(haveAllocator), rarely(slowPath));
13167             m_out.appendTo(haveAllocator, lastNext);
13168         }
13169 
13170         LBasicBlock continuation = m_out.newBlock();
13171 
13172         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13173 
13174         PatchpointValue* patchpoint = m_out.patchpoint(pointerType());
13175         if (isARM64()) {
13176             // emitAllocateWithNonNullAllocator uses the scratch registers on ARM.
13177             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13178         }
13179         patchpoint-&gt;effects.terminal = true;
13180         if (actualAllocator.isConstant())
13181             patchpoint-&gt;numGPScratchRegisters++;
13182         else
13183             patchpoint-&gt;appendSomeRegisterWithClobber(allocator);
13184         patchpoint-&gt;numGPScratchRegisters++;
<span class="line-modified">13185         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
13186 
13187         m_out.appendSuccessor(usually(continuation));
13188         m_out.appendSuccessor(rarely(slowPath));
13189 
13190         patchpoint-&gt;setGenerator(
13191             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13192                 AllowMacroScratchRegisterUsageIf allowScratchIf(jit, isARM64());
13193                 CCallHelpers::JumpList jumpToSlowPath;
13194 
13195                 GPRReg allocatorGPR;
13196                 if (actualAllocator.isConstant())
13197                     allocatorGPR = params.gpScratch(1);
13198                 else
13199                     allocatorGPR = params[1].gpr();
13200 
13201                 // We use a patchpoint to emit the allocation path because whenever we mess with
13202                 // allocation paths, we already reason about them at the machine code level. We know
13203                 // exactly what instruction sequence we want. We&#39;re confident that no compiler
13204                 // optimization could make this code better. So, it&#39;s best to have the code in
13205                 // AssemblyHelpers::emitAllocate(). That way, the same optimized path is shared by
</pre>
<hr />
<pre>
13605 
13606         return result;
13607     }
13608 
13609     LValue boolify(Edge edge)
13610     {
13611         switch (edge.useKind()) {
13612         case BooleanUse:
13613         case KnownBooleanUse:
13614             return lowBoolean(edge);
13615         case Int32Use:
13616             return m_out.notZero32(lowInt32(edge));
13617         case DoubleRepUse:
13618             return m_out.doubleNotEqualAndOrdered(lowDouble(edge), m_out.doubleZero);
13619         case ObjectOrOtherUse:
13620             return m_out.logicalNot(
13621                 equalNullOrUndefined(
13622                     edge, CellCaseSpeculatesObject, SpeculateNullOrUndefined,
13623                     ManualOperandSpeculation));
13624         case StringUse:
<span class="line-modified">13625             return m_out.notEqual(lowString(edge), weakPointer(jsEmptyString(&amp;m_graph.m_vm)));</span>
13626         case StringOrOtherUse: {
13627             LValue value = lowJSValue(edge, ManualOperandSpeculation);
13628 
13629             LBasicBlock cellCase = m_out.newBlock();
13630             LBasicBlock notCellCase = m_out.newBlock();
13631             LBasicBlock continuation = m_out.newBlock();
13632 
13633             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13634 
13635             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
13636             FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
<span class="line-modified">13637             ValueFromBlock stringResult = m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(&amp;m_graph.m_vm))));</span>
13638             m_out.jump(continuation);
13639 
13640             m_out.appendTo(notCellCase, continuation);
13641             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
13642             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
13643             m_out.jump(continuation);
13644 
13645             m_out.appendTo(continuation, lastNext);
13646             return m_out.phi(Int32, stringResult, notCellResult);
13647         }
13648         case UntypedUse: {
13649             LValue value = lowJSValue(edge);
13650 
13651             // Implements the following control flow structure:
13652             // if (value is cell) {
13653             //     if (value is string or value is BigInt)
13654             //         result = !!value-&gt;length
13655             //     else {
13656             //         do evil things for masquerades-as-undefined
13657             //         result = true
</pre>
<hr />
<pre>
13674             LBasicBlock notInt32Case = m_out.newBlock();
13675             LBasicBlock doubleCase = m_out.newBlock();
13676             LBasicBlock notDoubleCase = m_out.newBlock();
13677             LBasicBlock continuation = m_out.newBlock();
13678 
13679             Vector&lt;ValueFromBlock&gt; results;
13680 
13681             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13682 
13683             LBasicBlock lastNext = m_out.appendTo(cellCase, notStringCase);
13684             m_out.branch(
13685                 isString(value, provenType(edge) &amp; SpecCell),
13686                 unsure(stringCase), unsure(notStringCase));
13687 
13688             m_out.appendTo(notStringCase, stringCase);
13689             m_out.branch(
13690                 isBigInt(value, provenType(edge) &amp; (SpecCell - SpecString)),
13691                 unsure(bigIntCase), unsure(notStringOrBigIntCase));
13692 
13693             m_out.appendTo(stringCase, bigIntCase);
<span class="line-modified">13694             results.append(m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(&amp;m_graph.m_vm)))));</span>
13695             m_out.jump(continuation);
13696 
13697             m_out.appendTo(bigIntCase, notStringOrBigIntCase);
13698             LValue nonZeroBigInt = m_out.notZero32(
13699                 m_out.load32NonNegative(value, m_heaps.JSBigInt_length));
13700             results.append(m_out.anchor(nonZeroBigInt));
13701             m_out.jump(continuation);
13702 
13703             m_out.appendTo(notStringOrBigIntCase, notCellCase);
13704             LValue isTruthyObject;
13705             if (masqueradesAsUndefinedWatchpointIsStillValid())
13706                 isTruthyObject = m_out.booleanTrue;
13707             else {
13708                 LBasicBlock masqueradesCase = m_out.newBlock();
13709 
13710                 results.append(m_out.anchor(m_out.booleanTrue));
13711 
13712                 m_out.branch(
13713                     m_out.testIsZero32(
13714                         m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
</pre>
<hr />
<pre>
13882                 LBasicBlock innerLastNext = m_out.appendTo(outOfBoundsCase, holeCase);
13883 
13884                 vmCall(
13885                     Void, m_out.operation(slowPathFunction),
13886                     m_callFrame, base, index, value);
13887 
13888                 m_out.jump(continuation);
13889 
13890                 m_out.appendTo(holeCase, innerLastNext);
13891             }
13892 
13893             m_out.store32(
13894                 m_out.add(index, m_out.int32One),
13895                 storage, m_heaps.Butterfly_publicLength);
13896 
13897             m_out.jump(performStore);
13898             m_out.appendTo(performStore, lastNext);
13899         }
13900     }
13901 
<span class="line-modified">13902     LValue caged(Gigacage::Kind kind, LValue ptr)</span>
13903     {












































13904 #if GIGACAGE_ENABLED
13905         if (!Gigacage::isEnabled(kind))
<span class="line-modified">13906             return ptr;</span>
13907 
13908         if (kind == Gigacage::Primitive &amp;&amp; Gigacage::canPrimitiveGigacageBeDisabled()) {
13909             if (vm().primitiveGigacageEnabled().isStillValid())
13910                 m_graph.watchpoints().addLazily(vm().primitiveGigacageEnabled());
13911             else
<span class="line-modified">13912                 return ptr;</span>
13913         }
13914 
13915         LValue basePtr = m_out.constIntPtr(Gigacage::basePtr(kind));
13916         LValue mask = m_out.constIntPtr(Gigacage::mask(kind));
13917 
13918         LValue masked = m_out.bitAnd(ptr, mask);
13919         LValue result = m_out.add(masked, basePtr);
13920 














13921         // Make sure that B3 doesn&#39;t try to do smart reassociation of these pointer bits.
13922         // FIXME: In an ideal world, B3 would not do harmful reassociations, and if it did, it would be able
13923         // to undo them during constant hoisting and regalloc. As it stands, if you remove this then Octane
13924         // gets 1.6% slower and Kraken gets 5% slower. It&#39;s all because the basePtr, which is a constant,
13925         // gets reassociated out of the add above and into the address arithmetic. This disables hoisting of
13926         // the basePtr constant. Hoisting that constant is worth a lot more perf than the reassociation. One
13927         // way to make this all work happily is to combine offset legalization with constant hoisting, and
13928         // then teach it reassociation. So, Add(Add(a, b), const) where a is loop-invariant while b isn&#39;t
13929         // will turn into Add(Add(a, const), b) by the constant hoister. We would have to teach B3 to do this
13930         // and possibly other smart things if we want to be able to remove this opaque.
13931         // https://bugs.webkit.org/show_bug.cgi?id=175493
13932         return m_out.opaque(result);
<span class="line-removed">13933 #else</span>
<span class="line-removed">13934         UNUSED_PARAM(kind);</span>
<span class="line-removed">13935         return ptr;</span>
13936 #endif




13937     }
13938 
13939     void buildSwitch(SwitchData* data, LType type, LValue switchValue)
13940     {
13941         ASSERT(type == pointerType() || type == Int32);
13942 
13943         Vector&lt;SwitchCase&gt; cases;
13944         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
13945             SwitchCase newCase;
13946 
13947             if (type == pointerType()) {
13948                 newCase = SwitchCase(m_out.constIntPtr(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
13949                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
13950             } else if (type == Int32) {
13951                 newCase = SwitchCase(m_out.constInt32(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
13952                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
13953             } else
13954                 CRASH();
13955 
13956             cases.append(newCase);
</pre>
<hr />
<pre>
14458             return Output::StoreDouble;
14459         default:
14460             DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
14461         }
14462     }
14463 
14464     void setIntTypedArrayLoadResult(LValue result, TypedArrayType type, bool canSpeculate = false)
14465     {
14466         if (elementSize(type) &lt; 4 || isSigned(type)) {
14467             setInt32(result);
14468             return;
14469         }
14470 
14471         if (m_node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
14472             speculate(
14473                 Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
14474             setInt32(result);
14475             return;
14476         }
14477 
<span class="line-modified">14478         if (m_node-&gt;shouldSpeculateAnyInt()) {</span>
14479             setStrictInt52(m_out.zeroExt(result, Int64));
14480             return;
14481         }
14482 
14483         setDouble(m_out.unsignedToDouble(result));
14484     }
14485 
14486     LValue getIntTypedArrayStoreOperand(Edge edge, bool isClamped = false)
14487     {
14488         LValue intValue;
14489         switch (edge.useKind()) {
14490         case Int52RepUse:
14491         case Int32Use: {
14492             if (edge.useKind() == Int32Use)
14493                 intValue = lowInt32(edge);
14494             else
14495                 intValue = m_out.castToInt32(lowStrictInt52(edge));
14496 
14497             if (isClamped) {
14498                 LBasicBlock atLeastZero = m_out.newBlock();
</pre>
<hr />
<pre>
14758                         AllowMacroScratchRegisterUsage allowScratch(jit);
14759                         patchableJump.m_jump.link(&amp;jit);
14760                         unsigned index = state-&gt;jitCode-&gt;lazySlowPaths.size();
14761                         state-&gt;jitCode-&gt;lazySlowPaths.append(nullptr);
14762                         jit.pushToSaveImmediateWithoutTouchingRegisters(
14763                             CCallHelpers::TrustedImm32(index));
14764                         CCallHelpers::Jump generatorJump = jit.jump();
14765 
14766                         // Note that so long as we&#39;re here, we don&#39;t really know if our late path
14767                         // runs before or after any other late paths that we might depend on, like
14768                         // the exception thunk.
14769 
14770                         RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode;
14771                         VM* vm = &amp;state-&gt;graph.m_vm;
14772 
14773                         jit.addLinkTask(
14774                             [=] (LinkBuffer&amp; linkBuffer) {
14775                                 linkBuffer.link(generatorJump,
14776                                     CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(lazySlowPathGenerationThunkGenerator).code()));
14777 
<span class="line-modified">14778                                 std::unique_ptr&lt;LazySlowPath&gt; lazySlowPath = std::make_unique&lt;LazySlowPath&gt;();</span>
14779 
14780                                 auto linkedPatchableJump = CodeLocationJump&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump));
14781 
14782                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; linkedDone = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(done);
14783 
14784                                 CallSiteIndex callSiteIndex =
14785                                     jitCode-&gt;common.addUniqueCallSiteIndex(origin);
14786 
14787                                 lazySlowPath-&gt;initialize(
14788                                         linkedPatchableJump, linkedDone,
14789                                         exceptionTarget-&gt;label(linkBuffer), usedRegisters,
14790                                         callSiteIndex, generator);
14791 
14792                                 jitCode-&gt;lazySlowPaths[index] = WTFMove(lazySlowPath);
14793                             });
14794                     });
14795             });
14796         return result;
14797     }
14798 
</pre>
<hr />
<pre>
15158         }
15159 
15160         LoweredNodeValue value = m_jsValueValues.get(edge.node());
15161         if (isValid(value))
15162             return value.value();
15163 
15164         value = m_int32Values.get(edge.node());
15165         if (isValid(value)) {
15166             LValue result = boxInt32(value.value());
15167             setJSValue(edge.node(), result);
15168             return result;
15169         }
15170 
15171         value = m_booleanValues.get(edge.node());
15172         if (isValid(value)) {
15173             LValue result = boxBoolean(value.value());
15174             setJSValue(edge.node(), result);
15175             return result;
15176         }
15177 
<span class="line-modified">15178         DFG_CRASH(m_graph, m_node, &quot;Value not defined&quot;);</span>
15179         return 0;
15180     }
15181 
15182     LValue lowNotCell(Edge edge)
15183     {
15184         LValue result = lowJSValue(edge, ManualOperandSpeculation);
15185         FTL_TYPE_CHECK(jsValueValue(result), edge, ~SpecCellCheck, isCell(result));
15186         return result;
15187     }
15188 
15189     LValue lowStorage(Edge edge)
15190     {
15191         LoweredNodeValue value = m_storageValues.get(edge.node());
15192         if (isValid(value))
15193             return value.value();
15194 
15195         LValue result = lowCell(edge);
15196         setStorage(edge.node(), result);
15197         return result;
15198     }
</pre>
<hr />
<pre>
15680     }
15681 
15682     LValue isString(LValue cell, SpeculatedType type = SpecFullTop)
15683     {
15684         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecString))
15685             return proven;
15686         return m_out.equal(
15687             m_out.load32(cell, m_heaps.JSCell_structureID),
15688             m_out.constInt32(vm().stringStructure-&gt;id()));
15689     }
15690 
15691     LValue isRopeString(LValue string, Edge edge = Edge())
15692     {
15693         if (edge) {
15694             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
15695                 return m_out.booleanFalse;
15696             if (JSValue value = provenValue(edge)) {
15697                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
15698                     return m_out.booleanFalse;
15699             }





15700         }
15701 
15702         return m_out.testNonZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
15703     }
15704 
15705     LValue isNotRopeString(LValue string, Edge edge = Edge())
15706     {
15707         if (edge) {
15708             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
15709                 return m_out.booleanTrue;
15710             if (JSValue value = provenValue(edge)) {
15711                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
15712                     return m_out.booleanTrue;
15713             }





15714         }
15715 
15716         return m_out.testIsZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
15717     }
15718 
15719     LValue isNotSymbol(LValue cell, SpeculatedType type = SpecFullTop)
15720     {
15721         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecSymbol))
15722             return proven;
15723         return m_out.notEqual(
15724             m_out.load32(cell, m_heaps.JSCell_structureID),
15725             m_out.constInt32(vm().symbolStructure-&gt;id()));
15726     }
15727 
15728     LValue isSymbol(LValue cell, SpeculatedType type = SpecFullTop)
15729     {
15730         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecSymbol))
15731             return proven;
15732         return m_out.equal(
15733             m_out.load32(cell, m_heaps.JSCell_structureID),
</pre>
<hr />
<pre>
16101 
16102         m_out.jump(continuation);
16103         m_out.appendTo(continuation, lastNext);
16104     }
16105 
16106     void speculateStringOrOther(Edge edge)
16107     {
16108         speculateStringOrOther(edge, lowJSValue(edge, ManualOperandSpeculation));
16109     }
16110 
16111     void speculateStringIdent(Edge edge, LValue string, LValue stringImpl)
16112     {
16113         if (!m_interpreter.needsTypeCheck(edge, SpecStringIdent | ~SpecString))
16114             return;
16115 
16116         speculate(BadType, jsValueValue(string), edge.node(), isRopeString(string));
16117         speculate(
16118             BadType, jsValueValue(string), edge.node(),
16119             m_out.testIsZero32(
16120                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
<span class="line-modified">16121                 m_out.constInt32(StringImpl::flagIsAtomic())));</span>
16122         m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
16123     }
16124 
16125     void speculateStringIdent(Edge edge)
16126     {
16127         lowStringIdent(edge);
16128     }
16129 
16130     void speculateStringObject(Edge edge)
16131     {
16132         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
16133             return;
16134 
16135         speculateStringObjectForCell(edge, lowCell(edge));
16136     }
16137 
16138     void speculateStringOrStringObject(Edge edge)
16139     {
16140         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
16141             return;
</pre>
<hr />
<pre>
16318     void speculateMisc(Edge edge)
16319     {
16320         if (!m_interpreter.needsTypeCheck(edge))
16321             return;
16322 
16323         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16324         typeCheck(jsValueValue(value), edge, SpecMisc, isNotMisc(value));
16325     }
16326 
16327     void speculateTypedArrayIsNotNeutered(LValue base)
16328     {
16329         LBasicBlock isWasteful = m_out.newBlock();
16330         LBasicBlock continuation = m_out.newBlock();
16331 
16332         LValue mode = m_out.load32(base, m_heaps.JSArrayBufferView_mode);
16333         m_out.branch(m_out.equal(mode, m_out.constInt32(WastefulTypedArray)),
16334             unsure(isWasteful), unsure(continuation));
16335 
16336         LBasicBlock lastNext = m_out.appendTo(isWasteful, continuation);
16337         LValue vector = m_out.loadPtr(base, m_heaps.JSArrayBufferView_vector);



16338         speculate(Uncountable, jsValueValue(vector), m_node, m_out.isZero64(vector));
16339         m_out.jump(continuation);
16340 
16341         m_out.appendTo(continuation, lastNext);
16342     }
16343 
16344     bool masqueradesAsUndefinedWatchpointIsStillValid()
16345     {
16346         return m_graph.masqueradesAsUndefinedWatchpointIsStillValid(m_node-&gt;origin.semantic);
16347     }
16348 
16349     LValue loadCellState(LValue base)
16350     {
16351         return m_out.load8ZeroExt32(base, m_heaps.JSCell_cellState);
16352     }
16353 
16354     void emitStoreBarrier(LValue base, bool isFenced)
16355     {
16356         LBasicBlock recheckPath = nullptr;
16357         if (isFenced)
</pre>
<hr />
<pre>
16512             tagFor(CallFrameSlot::argumentCount));
16513     }
16514 
16515     void callPreflight()
16516     {
16517         callPreflight(codeOriginDescriptionOfCallSite());
16518     }
16519 
16520     CodeOrigin codeOriginDescriptionOfCallSite() const
16521     {
16522         CodeOrigin codeOrigin = m_node-&gt;origin.semantic;
16523         if (m_node-&gt;op() == TailCallInlinedCaller
16524             || m_node-&gt;op() == TailCallVarargsInlinedCaller
16525             || m_node-&gt;op() == TailCallForwardVarargsInlinedCaller
16526             || m_node-&gt;op() == DirectTailCallInlinedCaller) {
16527             // This case arises when you have a situation like this:
16528             // foo makes a call to bar, bar is inlined in foo. bar makes a call
16529             // to baz and baz is inlined in bar. And then baz makes a tail-call to jaz,
16530             // and jaz is inlined in baz. We want the callframe for jaz to appear to
16531             // have caller be bar.
<span class="line-modified">16532             codeOrigin = *codeOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls();</span>
16533         }
16534 
16535         return codeOrigin;
16536     }
16537 
16538     void callCheck()
16539     {
16540         if (Options::useExceptionFuzz())
16541             m_out.call(Void, m_out.operation(operationExceptionFuzz), m_callFrame);
16542 
16543         LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
16544         LValue hadException = m_out.notZero64(exception);
16545 
16546         CodeOrigin opCatchOrigin;
16547         HandlerInfo* exceptionHandler;
16548         if (m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler)) {
16549             bool exitOK = true;
16550             bool isExceptionHandler = true;
16551             appendOSRExit(
16552                 ExceptionCheck, noValue(), nullptr, hadException,
16553                 m_origin.withForExitAndExitOK(opCatchOrigin, exitOK), isExceptionHandler);
16554             return;
16555         }
16556 
16557         LBasicBlock continuation = m_out.newBlock();
16558 
16559         m_out.branch(
16560             hadException, rarely(m_handleExceptions), usually(continuation));
16561 
16562         m_out.appendTo(continuation);
16563     }
16564 
16565     RefPtr&lt;PatchpointExceptionHandle&gt; preparePatchpointForExceptions(PatchpointValue* value)
16566     {
16567         CodeOrigin opCatchOrigin;
16568         HandlerInfo* exceptionHandler;
16569         bool willCatchException = m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler);
16570         if (!willCatchException)
16571             return PatchpointExceptionHandle::defaultHandle(m_ftlState);
16572 
<span class="line-modified">16573         if (verboseCompilationEnabled()) {</span>
<span class="line-removed">16574             dataLog(&quot;    Patchpoint exception OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap(), &quot;\n&quot;);</span>
<span class="line-removed">16575             if (!m_availableRecoveries.isEmpty())</span>
<span class="line-removed">16576                 dataLog(&quot;        Available recoveries: &quot;, listDump(m_availableRecoveries), &quot;\n&quot;);</span>
<span class="line-removed">16577         }</span>
16578 
16579         bool exitOK = true;
16580         NodeOrigin origin = m_origin.withForExitAndExitOK(opCatchOrigin, exitOK);
16581 
16582         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(noValue(), nullptr);
16583 
16584         // Compute the offset into the StackmapGenerationParams where we will find the exit arguments
16585         // we are about to append. We need to account for both the children we&#39;ve already added, and
16586         // for the possibility of a result value if the patchpoint is not void.
16587         unsigned offset = value-&gt;numChildren();
16588         if (value-&gt;type() != Void)
16589             offset++;
16590 
16591         // Use LateColdAny to ensure that the stackmap arguments interfere with the patchpoint&#39;s
16592         // result and with any late-clobbered registers.
16593         value-&gt;appendVectorWithRep(
16594             buildExitArguments(exitDescriptor, opCatchOrigin, noValue()),
16595             ValueRep::LateColdAny);
16596 
16597         return PatchpointExceptionHandle::create(
</pre>
<hr />
<pre>
16611     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile)
16612     {
16613         return &amp;m_ftlState.jitCode-&gt;osrExitDescriptors.alloc(
16614             lowValue.format(), profile,
16615             availabilityMap().m_locals.numberOfArguments(),
16616             availabilityMap().m_locals.numberOfLocals());
16617     }
16618 
16619     void appendOSRExit(
16620         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition,
16621         NodeOrigin origin, bool isExceptionHandler = false)
16622     {
16623         return appendOSRExit(kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue),
16624             failCondition, origin, isExceptionHandler);
16625     }
16626 
16627     void appendOSRExit(
16628         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition,
16629         NodeOrigin origin, bool isExceptionHandler = false)
16630     {
<span class="line-modified">16631         if (verboseCompilationEnabled()) {</span>
<span class="line-removed">16632             dataLog(&quot;    OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap(), &quot;\n&quot;);</span>
<span class="line-removed">16633             if (!m_availableRecoveries.isEmpty())</span>
<span class="line-removed">16634                 dataLog(&quot;        Available recoveries: &quot;, listDump(m_availableRecoveries), &quot;\n&quot;);</span>
<span class="line-removed">16635         }</span>
16636 
16637         DFG_ASSERT(m_graph, m_node, origin.exitOK);
16638 
16639         if (!isExceptionHandler
16640             &amp;&amp; Options::useOSRExitFuzz()
16641             &amp;&amp; canUseOSRExitFuzzing(m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic))
16642             &amp;&amp; doOSRExitFuzzing()) {
16643             LValue numberOfFuzzChecks = m_out.add(
16644                 m_out.load32(m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks)),
16645                 m_out.int32One);
16646 
16647             m_out.store32(numberOfFuzzChecks, m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks));
16648 
16649             if (unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter()) {
16650                 failCondition = m_out.bitOr(
16651                     failCondition,
16652                     m_out.aboveOrEqual(numberOfFuzzChecks, m_out.constInt32(atOrAfter)));
16653             }
16654             if (unsigned at = Options::fireOSRExitFuzzAt()) {
16655                 failCondition = m_out.bitOr(
</pre>
<hr />
<pre>
16809 
16810         if (node) {
16811             switch (node-&gt;op()) {
16812             case BottomValue:
16813                 // This might arise in object materializations. I actually doubt that it would,
16814                 // but it seems worthwhile to be conservative.
16815                 return ExitValue::dead();
16816 
16817             case JSConstant:
16818             case Int52Constant:
16819             case DoubleConstant:
16820                 return ExitValue::constant(node-&gt;asJSValue());
16821 
16822             default:
16823                 if (node-&gt;isPhantomAllocation())
16824                     return ExitValue::materializeNewObject(map.get(node));
16825                 break;
16826             }
16827         }
16828 
<span class="line-removed">16829         for (unsigned i = 0; i &lt; m_availableRecoveries.size(); ++i) {</span>
<span class="line-removed">16830             AvailableRecovery recovery = m_availableRecoveries[i];</span>
<span class="line-removed">16831             if (recovery.node() != node)</span>
<span class="line-removed">16832                 continue;</span>
<span class="line-removed">16833             ExitValue result = ExitValue::recovery(</span>
<span class="line-removed">16834                 recovery.opcode(), arguments.size(), arguments.size() + 1,</span>
<span class="line-removed">16835                 recovery.format());</span>
<span class="line-removed">16836             arguments.append(recovery.left());</span>
<span class="line-removed">16837             arguments.append(recovery.right());</span>
<span class="line-removed">16838             return result;</span>
<span class="line-removed">16839         }</span>
<span class="line-removed">16840 </span>
16841         LoweredNodeValue value = m_int32Values.get(node);
16842         if (isValid(value))
16843             return exitArgument(arguments, DataFormatInt32, value.value());
16844 
16845         value = m_int52Values.get(node);
16846         if (isValid(value))
16847             return exitArgument(arguments, DataFormatInt52, value.value());
16848 
16849         value = m_strictInt52Values.get(node);
16850         if (isValid(value))
16851             return exitArgument(arguments, DataFormatStrictInt52, value.value());
16852 
16853         value = m_booleanValues.get(node);
16854         if (isValid(value))
16855             return exitArgument(arguments, DataFormatBoolean, value.value());
16856 
16857         value = m_jsValueValues.get(node);
16858         if (isValid(value))
16859             return exitArgument(arguments, DataFormatJS, value.value());
16860 
</pre>
<hr />
<pre>
16887         default:
16888             break;
16889         }
16890 
16891         LoweredNodeValue value = m_jsValueValues.get(node);
16892         if (isValid(value))
16893             return exitArgument(arguments, DataFormatJS, value.value());
16894 
16895         value = m_int32Values.get(node);
16896         if (isValid(value))
16897             return exitArgument(arguments, DataFormatJS, boxInt32(value.value()));
16898 
16899         value = m_booleanValues.get(node);
16900         if (isValid(value))
16901             return exitArgument(arguments, DataFormatJS, boxBoolean(value.value()));
16902 
16903         // Doubles and Int52 have been converted by ValueRep()
16904         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
16905     }
16906 
<span class="line-removed">16907     void addAvailableRecovery(</span>
<span class="line-removed">16908         Node* node, RecoveryOpcode opcode, LValue left, LValue right, DataFormat format)</span>
<span class="line-removed">16909     {</span>
<span class="line-removed">16910         m_availableRecoveries.append(AvailableRecovery(node, opcode, left, right, format));</span>
<span class="line-removed">16911     }</span>
<span class="line-removed">16912 </span>
<span class="line-removed">16913     void addAvailableRecovery(</span>
<span class="line-removed">16914         Edge edge, RecoveryOpcode opcode, LValue left, LValue right, DataFormat format)</span>
<span class="line-removed">16915     {</span>
<span class="line-removed">16916         addAvailableRecovery(edge.node(), opcode, left, right, format);</span>
<span class="line-removed">16917     }</span>
<span class="line-removed">16918 </span>
16919     void setInt32(Node* node, LValue value)
16920     {
16921         m_int32Values.set(node, LoweredNodeValue(value, m_highBlock));
16922     }
16923     void setInt52(Node* node, LValue value)
16924     {
16925         m_int52Values.set(node, LoweredNodeValue(value, m_highBlock));
16926     }
16927     void setStrictInt52(Node* node, LValue value)
16928     {
16929         m_strictInt52Values.set(node, LoweredNodeValue(value, m_highBlock));
16930     }
16931     void setInt52(Node* node, LValue value, Int52Kind kind)
16932     {
16933         switch (kind) {
16934         case Int52:
16935             setInt52(node, value);
16936             return;
16937 
16938         case StrictInt52:
</pre>
<hr />
<pre>
16989     }
16990     void setDouble(LValue value)
16991     {
16992         setDouble(m_node, value);
16993     }
16994 
16995     bool isValid(const LoweredNodeValue&amp; value)
16996     {
16997         if (!value)
16998             return false;
16999         if (!m_graph.m_ssaDominators-&gt;dominates(value.block(), m_highBlock))
17000             return false;
17001         return true;
17002     }
17003 
17004     void keepAlive(LValue value)
17005     {
17006         PatchpointValue* patchpoint = m_out.patchpoint(Void);
17007         patchpoint-&gt;effects = Effects::none();
17008         patchpoint-&gt;effects.writesLocalState = true;

17009         patchpoint-&gt;append(value, ValueRep::ColdAny);
17010         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
17011     }
17012 
17013     void addWeakReference(JSCell* target)
17014     {
17015         m_graph.m_plan.weakReferences().addLazily(target);
17016     }
17017 
17018     LValue loadStructure(LValue value)
17019     {
17020         LValue structureID = m_out.load32(value, m_heaps.JSCell_structureID);
17021         LValue tableBase = m_out.loadPtr(m_out.absolute(vm().heap.structureIDTable().base()));
17022         LValue tableIndex = m_out.aShr(structureID, m_out.constInt32(StructureIDTable::s_numberOfEntropyBits));
17023         LValue entropyBits = m_out.shl(m_out.zeroExtPtr(structureID), m_out.constInt32(StructureIDTable::s_entropyBitsShiftForStructurePointer));
17024         TypedPointer address = m_out.baseIndex(m_heaps.structureTable, tableBase, m_out.zeroExtPtr(tableIndex));
17025         LValue encodedStructureBits = m_out.loadPtr(address);
17026         return m_out.bitXor(encodedStructureBits, entropyBits);
17027     }
17028 
</pre>
<hr />
<pre>
17168     LBasicBlock m_handleExceptions;
17169     HashMap&lt;DFG::BasicBlock*, LBasicBlock&gt; m_blocks;
17170 
17171     LValue m_callFrame;
17172     LValue m_captured;
17173     LValue m_tagTypeNumber;
17174     LValue m_tagMask;
17175 
17176     HashMap&lt;Node*, LoweredNodeValue&gt; m_int32Values;
17177     HashMap&lt;Node*, LoweredNodeValue&gt; m_strictInt52Values;
17178     HashMap&lt;Node*, LoweredNodeValue&gt; m_int52Values;
17179     HashMap&lt;Node*, LoweredNodeValue&gt; m_jsValueValues;
17180     HashMap&lt;Node*, LoweredNodeValue&gt; m_booleanValues;
17181     HashMap&lt;Node*, LoweredNodeValue&gt; m_storageValues;
17182     HashMap&lt;Node*, LoweredNodeValue&gt; m_doubleValues;
17183 
17184     HashMap&lt;Node*, LValue&gt; m_phis;
17185 
17186     LocalOSRAvailabilityCalculator m_availabilityCalculator;
17187 
<span class="line-removed">17188     Vector&lt;AvailableRecovery, 3&gt; m_availableRecoveries;</span>
<span class="line-removed">17189 </span>
17190     InPlaceAbstractState m_state;
17191     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
17192     DFG::BasicBlock* m_highBlock;
17193     DFG::BasicBlock* m_nextHighBlock;
17194     LBasicBlock m_nextLowBlock;
17195 
17196     enum IndexMaskingMode { IndexMaskingDisabled, IndexMaskingEnabled };
17197 
17198     IndexMaskingMode m_indexMaskingMode;
17199 
17200     NodeOrigin m_origin;
17201     unsigned m_nodeIndex;
17202     Node* m_node;





17203 };
17204 
17205 } // anonymous namespace
17206 
17207 void lowerDFGToB3(State&amp; state)
17208 {
17209     LowerDFGToB3 lowering(state);
17210     lowering.lower();
17211 }
17212 
17213 } } // namespace JSC::FTL
17214 
17215 #endif // ENABLE(FTL_JIT)
17216 
</pre>
</td>
<td>
<hr />
<pre>
   29 #if ENABLE(FTL_JIT)
   30 
   31 #include &quot;AirCode.h&quot;
   32 #include &quot;AirGenerationContext.h&quot;
   33 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
   34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
   35 #include &quot;AtomicsObject.h&quot;
   36 #include &quot;B3CheckValue.h&quot;
   37 #include &quot;B3FenceValue.h&quot;
   38 #include &quot;B3PatchpointValue.h&quot;
   39 #include &quot;B3SlotBaseValue.h&quot;
   40 #include &quot;B3StackmapGenerationParams.h&quot;
   41 #include &quot;B3ValueInlines.h&quot;
   42 #include &quot;CallFrameShuffler.h&quot;
   43 #include &quot;CodeBlockWithJITType.h&quot;
   44 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   45 #include &quot;DFGCapabilities.h&quot;
   46 #include &quot;DFGDoesGC.h&quot;
   47 #include &quot;DFGDominators.h&quot;
   48 #include &quot;DFGInPlaceAbstractState.h&quot;
<span class="line-added">   49 #include &quot;DFGLivenessAnalysisPhase.h&quot;</span>
   50 #include &quot;DFGMayExit.h&quot;
   51 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
   52 #include &quot;DFGOSRExitFuzz.h&quot;
   53 #include &quot;DirectArguments.h&quot;
   54 #include &quot;FTLAbstractHeapRepository.h&quot;
   55 #include &quot;FTLAvailableRecovery.h&quot;
   56 #include &quot;FTLExceptionTarget.h&quot;
   57 #include &quot;FTLForOSREntryJITCode.h&quot;
   58 #include &quot;FTLFormattedValue.h&quot;
   59 #include &quot;FTLLazySlowPathCall.h&quot;
   60 #include &quot;FTLLoweredNodeValue.h&quot;
   61 #include &quot;FTLOperations.h&quot;
   62 #include &quot;FTLOutput.h&quot;
   63 #include &quot;FTLPatchpointExceptionHandle.h&quot;
   64 #include &quot;FTLSnippetParams.h&quot;
   65 #include &quot;FTLThunks.h&quot;
   66 #include &quot;FTLWeightedTarget.h&quot;
   67 #include &quot;JITAddGenerator.h&quot;
   68 #include &quot;JITBitAndGenerator.h&quot;
   69 #include &quot;JITBitOrGenerator.h&quot;
   70 #include &quot;JITBitXorGenerator.h&quot;
   71 #include &quot;JITDivGenerator.h&quot;
   72 #include &quot;JITInlineCacheGenerator.h&quot;
   73 #include &quot;JITLeftShiftGenerator.h&quot;
   74 #include &quot;JITMathIC.h&quot;
   75 #include &quot;JITMulGenerator.h&quot;
   76 #include &quot;JITRightShiftGenerator.h&quot;
   77 #include &quot;JITSubGenerator.h&quot;
   78 #include &quot;JSAsyncFunction.h&quot;
   79 #include &quot;JSAsyncGeneratorFunction.h&quot;
   80 #include &quot;JSCInlines.h&quot;
   81 #include &quot;JSGeneratorFunction.h&quot;
   82 #include &quot;JSImmutableButterfly.h&quot;
   83 #include &quot;JSLexicalEnvironment.h&quot;
   84 #include &quot;JSMap.h&quot;
   85 #include &quot;OperandsInlines.h&quot;
<span class="line-added">   86 #include &quot;ProbeContext.h&quot;</span>
   87 #include &quot;RegExpObject.h&quot;
   88 #include &quot;ScopedArguments.h&quot;
   89 #include &quot;ScopedArgumentsTable.h&quot;
   90 #include &quot;ScratchRegisterAllocator.h&quot;
   91 #include &quot;SetupVarargsFrame.h&quot;
   92 #include &quot;ShadowChicken.h&quot;
   93 #include &quot;StructureStubInfo.h&quot;
   94 #include &quot;SuperSampler.h&quot;
   95 #include &quot;ThunkGenerators.h&quot;
   96 #include &quot;VirtualRegister.h&quot;
   97 #include &quot;Watchdog.h&quot;
   98 #include &lt;atomic&gt;
   99 #include &lt;wtf/Box.h&gt;
  100 #include &lt;wtf/Gigacage.h&gt;
  101 #include &lt;wtf/RecursableLambda.h&gt;
  102 #include &lt;wtf/StdUnorderedSet.h&gt;
  103 
  104 #undef RELEASE_ASSERT
  105 #define RELEASE_ASSERT(assertion) do { \
  106     if (!(assertion)) { \
</pre>
<hr />
<pre>
  140             break;                                                      \
  141         typeCheck(_ftc_lowValue, _ftc_highValue, _ftc_typesPassedThrough, (failCondition), exitKind); \
  142     } while (false)
  143 
  144 #define FTL_TYPE_CHECK(lowValue, highValue, typesPassedThrough, failCondition) \
  145     FTL_TYPE_CHECK_WITH_EXIT_KIND(BadType, lowValue, highValue, typesPassedThrough, failCondition)
  146 
  147 class LowerDFGToB3 {
  148     WTF_MAKE_NONCOPYABLE(LowerDFGToB3);
  149 public:
  150     LowerDFGToB3(State&amp; state)
  151         : m_graph(state.graph)
  152         , m_ftlState(state)
  153         , m_out(state)
  154         , m_proc(*state.proc)
  155         , m_availabilityCalculator(m_graph)
  156         , m_state(state.graph)
  157         , m_interpreter(state.graph, m_state)
  158         , m_indexMaskingMode(Options::enableSpectreMitigations() ?  IndexMaskingEnabled : IndexMaskingDisabled)
  159     {
<span class="line-added">  160         if (Options::validateAbstractInterpreterState()) {</span>
<span class="line-added">  161             performLivenessAnalysis(m_graph);</span>
<span class="line-added">  162 </span>
<span class="line-added">  163             // We only use node liveness here, not combined liveness, as we only track</span>
<span class="line-added">  164             // AI state for live nodes.</span>
<span class="line-added">  165             for (DFG::BasicBlock* block : m_graph.blocksInNaturalOrder()) {</span>
<span class="line-added">  166                 NodeSet live;</span>
<span class="line-added">  167 </span>
<span class="line-added">  168                 for (NodeFlowProjection node : block-&gt;ssa-&gt;liveAtTail) {</span>
<span class="line-added">  169                     if (node.kind() == NodeFlowProjection::Primary)</span>
<span class="line-added">  170                         live.addVoid(node.node());</span>
<span class="line-added">  171                 }</span>
<span class="line-added">  172 </span>
<span class="line-added">  173                 for (unsigned i = block-&gt;size(); i--; ) {</span>
<span class="line-added">  174                     Node* node = block-&gt;at(i);</span>
<span class="line-added">  175                     live.remove(node);</span>
<span class="line-added">  176                     m_graph.doToChildren(node, [&amp;] (Edge child) {</span>
<span class="line-added">  177                         live.addVoid(child.node());</span>
<span class="line-added">  178                     });</span>
<span class="line-added">  179                     m_liveInToNode.add(node, live);</span>
<span class="line-added">  180                 }</span>
<span class="line-added">  181             }</span>
<span class="line-added">  182         }</span>
  183     }
  184 
  185     void lower()
  186     {
  187         State* state = &amp;m_ftlState;
  188 
  189         CString name;
  190         if (verboseCompilationEnabled()) {
  191             name = toCString(
  192                 &quot;jsBody_&quot;, ++compileCounter, &quot;_&quot;, codeBlock()-&gt;inferredName(),
  193                 &quot;_&quot;, codeBlock()-&gt;hash());
  194         } else
  195             name = &quot;jsBody&quot;;
  196 
  197         {
  198             m_proc.setNumEntrypoints(m_graph.m_numberOfEntrypoints);
  199             CodeBlock* codeBlock = m_graph.m_codeBlock;
  200 
  201             Ref&lt;B3::Air::PrologueGenerator&gt; catchPrologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;(
  202                 [codeBlock] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
</pre>
<hr />
<pre>
  482                 break;
  483         }
  484         m_nextLowBlock = m_nextHighBlock ? m_blocks.get(m_nextHighBlock) : 0;
  485 
  486         // All of this effort to find the next block gives us the ability to keep the
  487         // generated IR in roughly program order. This ought not affect the performance
  488         // of the generated code (since we expect B3 to reorder things) but it will
  489         // make IR dumps easier to read.
  490         m_out.appendTo(lowBlock, m_nextLowBlock);
  491 
  492         if (Options::ftlCrashes())
  493             m_out.trap();
  494 
  495         if (!m_highBlock-&gt;cfaHasVisited) {
  496             if (verboseCompilationEnabled())
  497                 dataLog(&quot;Bailing because CFA didn&#39;t reach.\n&quot;);
  498             crash(m_highBlock, nullptr);
  499             return;
  500         }
  501 
<span class="line-added">  502         m_aiCheckedNodes.clear();</span>
<span class="line-added">  503 </span>
  504         m_availabilityCalculator.beginBlock(m_highBlock);
  505 
  506         m_state.reset();
  507         m_state.beginBasicBlock(m_highBlock);
  508 
  509         for (m_nodeIndex = 0; m_nodeIndex &lt; m_highBlock-&gt;size(); ++m_nodeIndex) {
  510             if (!compileNode(m_nodeIndex))
  511                 break;
  512         }
  513     }
  514 
  515     void safelyInvalidateAfterTermination()
  516     {
  517         if (verboseCompilationEnabled())
  518             dataLog(&quot;Bailing.\n&quot;);
  519         crash();
  520 
  521         // Invalidate dominated blocks. Under normal circumstances we would expect
  522         // them to be invalidated already. But you can have the CFA become more
  523         // precise over time because the structures of objects change on the main
  524         // thread. Failing to do this would result in weird crashes due to a value
  525         // being used but not defined. Race conditions FTW!
  526         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  527             DFG::BasicBlock* target = m_graph.block(blockIndex);
  528             if (!target)
  529                 continue;
  530             if (m_graph.m_ssaDominators-&gt;dominates(m_highBlock, target)) {
  531                 if (verboseCompilationEnabled())
  532                     dataLog(&quot;Block &quot;, *target, &quot; will bail also.\n&quot;);
  533                 target-&gt;cfaHasVisited = false;
  534             }
  535         }
  536     }
  537 
<span class="line-added">  538     void validateAIState(Node* node)</span>
<span class="line-added">  539     {</span>
<span class="line-added">  540         if (!m_graphDump) {</span>
<span class="line-added">  541             StringPrintStream out;</span>
<span class="line-added">  542             m_graph.dump(out);</span>
<span class="line-added">  543             m_graphDump = out.toString();</span>
<span class="line-added">  544         }</span>
<span class="line-added">  545 </span>
<span class="line-added">  546         switch (node-&gt;op()) {</span>
<span class="line-added">  547         case MovHint:</span>
<span class="line-added">  548         case ZombieHint:</span>
<span class="line-added">  549         case JSConstant:</span>
<span class="line-added">  550         case LazyJSConstant:</span>
<span class="line-added">  551         case DoubleConstant:</span>
<span class="line-added">  552         case Int52Constant:</span>
<span class="line-added">  553         case GetStack:</span>
<span class="line-added">  554         case PutStack:</span>
<span class="line-added">  555         case KillStack:</span>
<span class="line-added">  556         case ExitOK:</span>
<span class="line-added">  557             return;</span>
<span class="line-added">  558         default:</span>
<span class="line-added">  559             break;</span>
<span class="line-added">  560         }</span>
<span class="line-added">  561 </span>
<span class="line-added">  562         // Before we execute node.</span>
<span class="line-added">  563         NodeSet&amp; live = m_liveInToNode.find(node)-&gt;value;</span>
<span class="line-added">  564         unsigned highParentIndex = node-&gt;index();</span>
<span class="line-added">  565         {</span>
<span class="line-added">  566             uint64_t hash = WTF::intHash(highParentIndex);</span>
<span class="line-added">  567             if (hash &gt;= static_cast&lt;uint64_t&gt;((static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max()) + 1) * Options::validateAbstractInterpreterStateProbability()))</span>
<span class="line-added">  568                 return;</span>
<span class="line-added">  569         }</span>
<span class="line-added">  570 </span>
<span class="line-added">  571         for (Node* node : live) {</span>
<span class="line-added">  572             if (node-&gt;isPhantomAllocation())</span>
<span class="line-added">  573                 continue;</span>
<span class="line-added">  574 </span>
<span class="line-added">  575             if (node-&gt;op() == CheckInBounds)</span>
<span class="line-added">  576                 continue;</span>
<span class="line-added">  577 </span>
<span class="line-added">  578             AbstractValue value = m_interpreter.forNode(node);</span>
<span class="line-added">  579             {</span>
<span class="line-added">  580                 auto iter = m_aiCheckedNodes.find(node);</span>
<span class="line-added">  581                 if (iter != m_aiCheckedNodes.end()) {</span>
<span class="line-added">  582                     AbstractValue checkedValue = iter-&gt;value;</span>
<span class="line-added">  583                     if (checkedValue == value) {</span>
<span class="line-added">  584                         if (!(value.m_type &amp; SpecCell))</span>
<span class="line-added">  585                             continue;</span>
<span class="line-added">  586                     }</span>
<span class="line-added">  587                 }</span>
<span class="line-added">  588                 m_aiCheckedNodes.set(node, value);</span>
<span class="line-added">  589             }</span>
<span class="line-added">  590 </span>
<span class="line-added">  591             FlushFormat flushFormat;</span>
<span class="line-added">  592             LValue input;</span>
<span class="line-added">  593             if (node-&gt;hasJSResult()) {</span>
<span class="line-added">  594                 input = lowJSValue(Edge(node, UntypedUse));</span>
<span class="line-added">  595                 flushFormat = FlushedJSValue;</span>
<span class="line-added">  596             } else if (node-&gt;hasDoubleResult()) {</span>
<span class="line-added">  597                 input = lowDouble(Edge(node, DoubleRepUse));</span>
<span class="line-added">  598                 flushFormat = FlushedDouble;</span>
<span class="line-added">  599             } else if (node-&gt;hasInt52Result()) {</span>
<span class="line-added">  600                 input = strictInt52ToJSValue(lowStrictInt52(Edge(node, Int52RepUse)));</span>
<span class="line-added">  601                 flushFormat = FlushedInt52;</span>
<span class="line-added">  602             } else</span>
<span class="line-added">  603                 continue;</span>
<span class="line-added">  604 </span>
<span class="line-added">  605             unsigned highChildIndex = node-&gt;index();</span>
<span class="line-added">  606 </span>
<span class="line-added">  607             String graphDump = m_graphDump;</span>
<span class="line-added">  608 </span>
<span class="line-added">  609             PatchpointValue* patchpoint = m_out.patchpoint(Void);</span>
<span class="line-added">  610             patchpoint-&gt;effects = Effects::none();</span>
<span class="line-added">  611             patchpoint-&gt;effects.writesLocalState = true;</span>
<span class="line-added">  612             patchpoint-&gt;appendSomeRegister(input);</span>
<span class="line-added">  613             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">  614                 GPRReg reg = InvalidGPRReg;</span>
<span class="line-added">  615                 FPRReg fpReg = InvalidFPRReg;</span>
<span class="line-added">  616                 if (flushFormat == FlushedDouble)</span>
<span class="line-added">  617                     fpReg = params[0].fpr();</span>
<span class="line-added">  618                 else</span>
<span class="line-added">  619                     reg = params[0].gpr();</span>
<span class="line-added">  620                 jit.probe([=] (Probe::Context&amp; context) {</span>
<span class="line-added">  621                     JSValue input;</span>
<span class="line-added">  622                     double doubleInput;</span>
<span class="line-added">  623 </span>
<span class="line-added">  624                     auto dumpAndCrash = [&amp;] {</span>
<span class="line-added">  625                         dataLogLn(&quot;Validation failed at node: @&quot;, highParentIndex);</span>
<span class="line-added">  626                         dataLogLn(&quot;Failed validating live value: @&quot;, highChildIndex);</span>
<span class="line-added">  627                         dataLogLn();</span>
<span class="line-added">  628                         dataLogLn(&quot;Expected AI value = &quot;, value);</span>
<span class="line-added">  629                         if (flushFormat != FlushedDouble)</span>
<span class="line-added">  630                             dataLogLn(&quot;Unexpected value = &quot;, input);</span>
<span class="line-added">  631                         else</span>
<span class="line-added">  632                             dataLogLn(&quot;Unexpected double value = &quot;, doubleInput);</span>
<span class="line-added">  633                         dataLogLn();</span>
<span class="line-added">  634                         dataLogLn(graphDump);</span>
<span class="line-added">  635                         CRASH();</span>
<span class="line-added">  636                     };</span>
<span class="line-added">  637 </span>
<span class="line-added">  638                     if (flushFormat == FlushedDouble) {</span>
<span class="line-added">  639                         doubleInput = context.fpr(fpReg);</span>
<span class="line-added">  640                         SpeculatedType type;</span>
<span class="line-added">  641                         if (!std::isnan(doubleInput))</span>
<span class="line-added">  642                             type = speculationFromValue(jsDoubleNumber(doubleInput));</span>
<span class="line-added">  643                         else if (isImpureNaN(doubleInput))</span>
<span class="line-added">  644                             type = SpecDoubleImpureNaN;</span>
<span class="line-added">  645                         else</span>
<span class="line-added">  646                             type = SpecDoublePureNaN;</span>
<span class="line-added">  647 </span>
<span class="line-added">  648                         if (!value.couldBeType(type))</span>
<span class="line-added">  649                             dumpAndCrash();</span>
<span class="line-added">  650                     } else {</span>
<span class="line-added">  651                         input = JSValue::decode(context.gpr(reg));</span>
<span class="line-added">  652                         if (flushFormat == FlushedInt52) {</span>
<span class="line-added">  653                             RELEASE_ASSERT(input.isAnyInt());</span>
<span class="line-added">  654                             input = jsDoubleNumber(input.asAnyInt());</span>
<span class="line-added">  655                         }</span>
<span class="line-added">  656                         if (!value.validateOSREntryValue(input, flushFormat))</span>
<span class="line-added">  657                             dumpAndCrash();</span>
<span class="line-added">  658                     }</span>
<span class="line-added">  659 </span>
<span class="line-added">  660                 });</span>
<span class="line-added">  661             });</span>
<span class="line-added">  662         }</span>
<span class="line-added">  663     }</span>
<span class="line-added">  664 </span>
  665     bool compileNode(unsigned nodeIndex)
  666     {
  667         if (!m_state.isValid()) {
  668             safelyInvalidateAfterTermination();
  669             return false;
  670         }
  671 
  672         m_node = m_highBlock-&gt;at(nodeIndex);
  673         m_origin = m_node-&gt;origin;
  674         m_out.setOrigin(m_node);
  675 
  676         if (verboseCompilationEnabled())
  677             dataLog(&quot;Lowering &quot;, m_node, &quot;\n&quot;);
  678 


  679         m_interpreter.startExecuting();
  680         m_interpreter.executeKnownEdgeTypes(m_node);
  681 
<span class="line-added">  682         if (Options::validateAbstractInterpreterState())</span>
<span class="line-added">  683             validateAIState(m_node);</span>
<span class="line-added">  684 </span>
  685         if (validateDFGDoesGC) {
  686             bool expectDoesGC = doesGC(m_graph, m_node);
  687             m_out.store(m_out.constBool(expectDoesGC), m_out.absolute(vm().heap.addressOfExpectDoesGC()));
  688         }
  689 
  690         switch (m_node-&gt;op()) {
  691         case DFG::Upsilon:
  692             compileUpsilon();
  693             break;
  694         case DFG::Phi:
  695             compilePhi();
  696             break;
  697         case JSConstant:
  698             break;
  699         case DoubleConstant:
  700             compileDoubleConstant();
  701             break;
  702         case Int52Constant:
  703             compileInt52Constant();
  704             break;
</pre>
<hr />
<pre>
  763             break;
  764         case StrCat:
  765             compileStrCat();
  766             break;
  767         case ArithAdd:
  768         case ArithSub:
  769             compileArithAddOrSub();
  770             break;
  771         case ArithClz32:
  772             compileArithClz32();
  773             break;
  774         case ArithMul:
  775             compileArithMul();
  776             break;
  777         case ValueDiv:
  778             compileValueDiv();
  779             break;
  780         case ArithDiv:
  781             compileArithDiv();
  782             break;
<span class="line-added">  783         case ValueMod:</span>
<span class="line-added">  784             compileValueMod();</span>
<span class="line-added">  785             break;</span>
  786         case ArithMod:
  787             compileArithMod();
  788             break;
  789         case ArithMin:
  790         case ArithMax:
  791             compileArithMinOrMax();
  792             break;
  793         case ArithAbs:
  794             compileArithAbs();
  795             break;
<span class="line-added">  796         case ValuePow:</span>
<span class="line-added">  797             compileValuePow();</span>
<span class="line-added">  798             break;</span>
  799         case ArithPow:
  800             compileArithPow();
  801             break;
  802         case ArithRandom:
  803             compileArithRandom();
  804             break;
  805         case ArithRound:
  806             compileArithRound();
  807             break;
  808         case ArithFloor:
  809             compileArithFloor();
  810             break;
  811         case ArithCeil:
  812             compileArithCeil();
  813             break;
  814         case ArithTrunc:
  815             compileArithTrunc();
  816             break;
  817         case ArithSqrt:
  818             compileArithSqrt();
  819             break;
  820         case ArithFRound:
  821             compileArithFRound();
  822             break;
  823         case ArithNegate:
  824             compileArithNegate();
  825             break;
  826         case ArithUnary:
  827             compileArithUnary();
  828             break;
<span class="line-added">  829         case ValueBitNot:</span>
<span class="line-added">  830             compileValueBitNot();</span>
<span class="line-added">  831             break;</span>
  832         case ArithBitNot:
  833             compileArithBitNot();
  834             break;
  835         case ValueBitAnd:
  836             compileValueBitAnd();
  837             break;
  838         case ArithBitAnd:
  839             compileArithBitAnd();
  840             break;
  841         case ValueBitOr:
  842             compileValueBitOr();
  843             break;
  844         case ArithBitOr:
  845             compileArithBitOr();
  846             break;
  847         case ArithBitXor:
  848             compileArithBitXor();
  849             break;
  850         case ValueBitXor:
  851             compileValueBitXor();
  852             break;
  853         case BitRShift:
  854             compileBitRShift();
  855             break;
<span class="line-modified">  856         case ArithBitLShift:</span>
<span class="line-modified">  857             compileArithBitLShift();</span>
<span class="line-added">  858             break;</span>
<span class="line-added">  859         case ValueBitLShift:</span>
<span class="line-added">  860             compileValueBitLShift();</span>
  861             break;
  862         case BitURShift:
  863             compileBitURShift();
  864             break;
  865         case UInt32ToNumber:
  866             compileUInt32ToNumber();
  867             break;
  868         case CheckStructure:
  869             compileCheckStructure();
  870             break;
  871         case CheckStructureOrEmpty:
  872             compileCheckStructureOrEmpty();
  873             break;
  874         case CheckCell:
  875             compileCheckCell();
  876             break;
  877         case CheckNotEmpty:
  878             compileCheckNotEmpty();
  879             break;
  880         case AssertNotEmpty:
</pre>
<hr />
<pre>
 1924         ASSERT(scratchBuffer);
 1925         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 1926     }
 1927 
 1928     void compileGetStack()
 1929     {
 1930         StackAccessData* data = m_node-&gt;stackAccessData();
 1931         AbstractValue&amp; value = m_state.operand(data-&gt;local);
 1932 
 1933         DFG_ASSERT(m_graph, m_node, isConcrete(data-&gt;format), data-&gt;format);
 1934 
 1935         switch (data-&gt;format) {
 1936         case FlushedDouble:
 1937             setDouble(m_out.loadDouble(addressFor(data-&gt;machineLocal)));
 1938             break;
 1939         case FlushedInt52:
 1940             setInt52(m_out.load64(addressFor(data-&gt;machineLocal)));
 1941             break;
 1942         default:
 1943             if (isInt32Speculation(value.m_type))
<span class="line-modified"> 1944                 setInt32(m_out.load32(payloadFor(data-&gt;machineLocal)));</span>
<span class="line-modified"> 1945             else</span>
<span class="line-modified"> 1946                 setJSValue(m_out.load64(addressFor(data-&gt;machineLocal)));</span>
 1947             break;
 1948         }
 1949     }
 1950 
 1951     void compilePutStack()
 1952     {
 1953         StackAccessData* data = m_node-&gt;stackAccessData();
 1954         switch (data-&gt;format) {
 1955         case FlushedJSValue: {
 1956             LValue value = lowJSValue(m_node-&gt;child1());
 1957             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1958             break;
 1959         }
 1960 
 1961         case FlushedDouble: {
 1962             LValue value = lowDouble(m_node-&gt;child1());
 1963             m_out.storeDouble(value, addressFor(data-&gt;machineLocal));
 1964             break;
 1965         }
 1966 
</pre>
<hr />
<pre>
 2057         ValueFromBlock slowResult = m_out.anchor(
 2058             vmCall(Int64, m_out.operation(function), m_callFrame, value));
 2059         m_out.jump(continuation);
 2060 
 2061         m_out.appendTo(continuation, lastNext);
 2062         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 2063     }
 2064 
 2065     void compileValueAdd()
 2066     {
 2067         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2068             LValue left = lowBigInt(m_node-&gt;child1());
 2069             LValue right = lowBigInt(m_node-&gt;child2());
 2070 
 2071             LValue result = vmCall(pointerType(), m_out.operation(operationAddBigInt), m_callFrame, left, right);
 2072             setJSValue(result);
 2073             return;
 2074         }
 2075 
 2076         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 2077         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2078         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 2079         auto repatchingFunction = operationValueAddOptimize;
 2080         auto nonRepatchingFunction = operationValueAdd;
<span class="line-modified"> 2081         compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
 2082     }
 2083 
 2084     void compileValueSub()
 2085     {
 2086         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2087             LValue left = lowBigInt(m_node-&gt;child1());
 2088             LValue right = lowBigInt(m_node-&gt;child2());
 2089 
 2090             LValue result = vmCall(pointerType(), m_out.operation(operationSubBigInt), m_callFrame, left, right);
 2091             setJSValue(result);
 2092             return;
 2093         }
 2094 
 2095         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 2096         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2097         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 2098         auto repatchingFunction = operationValueSubOptimize;
 2099         auto nonRepatchingFunction = operationValueSub;
<span class="line-modified"> 2100         compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
 2101     }
 2102 
 2103     void compileValueMul()
 2104     {
 2105         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2106             LValue left = lowBigInt(m_node-&gt;child1());
 2107             LValue right = lowBigInt(m_node-&gt;child2());
 2108 
 2109             LValue result = vmCall(Int64, m_out.operation(operationMulBigInt), m_callFrame, left, right);
 2110             setJSValue(result);
 2111             return;
 2112         }
 2113 
 2114         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 2115         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2116         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 2117         auto repatchingFunction = operationValueMulOptimize;
 2118         auto nonRepatchingFunction = operationValueMul;
<span class="line-modified"> 2119         compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
 2120     }
 2121 
 2122     template &lt;typename Generator, typename Func1, typename Func2,
 2123         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified"> 2124     void compileUnaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 2125     {
 2126         Node* node = m_node;
 2127 
 2128         LValue operand = lowJSValue(node-&gt;child1());
 2129 
 2130         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2131         patchpoint-&gt;appendSomeRegister(operand);
 2132         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 2133         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 2134         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 2135         patchpoint-&gt;numGPScratchRegisters = 1;
 2136         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2137         State* state = &amp;m_ftlState;
 2138         patchpoint-&gt;setGenerator(
 2139             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2140                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2141 
 2142                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2143                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2144 
 2145 #if ENABLE(MATH_IC_STATS)
 2146                 auto inlineStart = jit.label();
 2147 #endif
 2148 
 2149                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified"> 2150                 JITUnaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);</span>
 2151                 mathIC-&gt;m_generator = Generator(JSValueRegs(params[0].gpr()), JSValueRegs(params[1].gpr()), params.gpScratch(0));
 2152 
 2153                 bool shouldEmitProfiling = false;
 2154                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2155 
 2156                 if (generatedInline) {
 2157                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2158                     auto done = jit.label();
 2159                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2160                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2161                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2162                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2163 #if ENABLE(MATH_IC_STATS)
 2164                         auto slowPathStart = jit.label();
 2165 #endif
 2166 
 2167                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2168                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2169                                 repatchingFunction, params[0].gpr(), params[1].gpr(), CCallHelpers::TrustedImmPtr(mathIC));
 2170                             mathICGenerationState-&gt;slowPathCall = call.call();
</pre>
<hr />
<pre>
 2190                 } else {
 2191                     callOperation(
 2192                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2193                         nonRepatchingFunction, params[0].gpr(), params[1].gpr());
 2194                 }
 2195 
 2196 #if ENABLE(MATH_IC_STATS)
 2197                 auto inlineEnd = jit.label();
 2198                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2199                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2200                     mathIC-&gt;m_generatedCodeSize += size;
 2201                 });
 2202 #endif
 2203             });
 2204 
 2205         setJSValue(patchpoint);
 2206     }
 2207 
 2208     template &lt;typename Generator, typename Func1, typename Func2,
 2209         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified"> 2210     void compileBinaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 2211     {
 2212         Node* node = m_node;
 2213 
 2214         LValue left = lowJSValue(node-&gt;child1());
 2215         LValue right = lowJSValue(node-&gt;child2());
 2216 
 2217         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
 2218         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
 2219 
 2220         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2221         patchpoint-&gt;appendSomeRegister(left);
 2222         patchpoint-&gt;appendSomeRegister(right);
 2223         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 2224         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 2225         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 2226             preparePatchpointForExceptions(patchpoint);
 2227         patchpoint-&gt;numGPScratchRegisters = 1;
 2228         patchpoint-&gt;numFPScratchRegisters = 2;
 2229         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2230         State* state = &amp;m_ftlState;
 2231         patchpoint-&gt;setGenerator(
 2232             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2233                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2234 
 2235 
 2236                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2237                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2238 
 2239 #if ENABLE(MATH_IC_STATS)
 2240                 auto inlineStart = jit.label();
 2241 #endif
 2242 
 2243                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified"> 2244                 JITBinaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);</span>
 2245                 mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
 2246                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.fpScratch(0),
 2247                     params.fpScratch(1), params.gpScratch(0), InvalidFPRReg);
 2248 
 2249                 bool shouldEmitProfiling = false;
 2250                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2251 
 2252                 if (generatedInline) {
 2253                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2254                     auto done = jit.label();
 2255                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2256                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2257                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2258                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2259 #if ENABLE(MATH_IC_STATS)
 2260                         auto slowPathStart = jit.label();
 2261 #endif
 2262 
 2263                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2264                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
</pre>
<hr />
<pre>
 2323     {
 2324         bool isSub =  m_node-&gt;op() == ArithSub;
 2325         switch (m_node-&gt;binaryUseKind()) {
 2326         case Int32Use: {
 2327             LValue left = lowInt32(m_node-&gt;child1());
 2328             LValue right = lowInt32(m_node-&gt;child2());
 2329 
 2330             if (!shouldCheckOverflow(m_node-&gt;arithMode())) {
 2331                 setInt32(isSub ? m_out.sub(left, right) : m_out.add(left, right));
 2332                 break;
 2333             }
 2334 
 2335             CheckValue* result =
 2336                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2337             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2338             setInt32(result);
 2339             break;
 2340         }
 2341 
 2342         case Int52RepUse: {
<span class="line-modified"> 2343             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified"> 2344                 &amp;&amp; !abstractValue(m_node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
 2345                 Int52Kind kind;
 2346                 LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2347                 LValue right = lowInt52(m_node-&gt;child2(), kind);
 2348                 setInt52(isSub ? m_out.sub(left, right) : m_out.add(left, right), kind);
 2349                 break;
 2350             }
 2351 
 2352             LValue left = lowInt52(m_node-&gt;child1());
 2353             LValue right = lowInt52(m_node-&gt;child2());
 2354             CheckValue* result =
 2355                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2356             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2357             setInt52(result);
 2358             break;
 2359         }
 2360 
 2361         case DoubleRepUse: {
 2362             LValue C1 = lowDouble(m_node-&gt;child1());
 2363             LValue C2 = lowDouble(m_node-&gt;child2());
 2364 
 2365             setDouble(isSub ? m_out.doubleSub(C1, C2) : m_out.doubleAdd(C1, C2));
 2366             break;
 2367         }
 2368 
 2369         case UntypedUse: {
 2370             if (!isSub) {
 2371                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2372                 break;
 2373             }
 2374 
 2375             CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 2376             unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2377             ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 2378             auto repatchingFunction = operationValueSubOptimize;
 2379             auto nonRepatchingFunction = operationValueSub;
<span class="line-modified"> 2380             compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
 2381             break;
 2382         }
 2383 
 2384         default:
 2385             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2386             break;
 2387         }
 2388     }
 2389 
 2390     void compileArithClz32()
 2391     {
 2392         if (m_node-&gt;child1().useKind() == Int32Use || m_node-&gt;child1().useKind() == KnownInt32Use) {
 2393             LValue operand = lowInt32(m_node-&gt;child1());
 2394             setInt32(m_out.ctlz32(operand));
 2395             return;
 2396         }
 2397         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2398         LValue argument = lowJSValue(m_node-&gt;child1());
 2399         LValue result = vmCall(Int32, m_out.operation(operationArithClz32), m_callFrame, argument);
 2400         setInt32(result);
</pre>
<hr />
<pre>
 2534                     m_out.notEqual(m_out.mul(result, denominator), numerator));
 2535                 setInt32(result);
 2536             } else
 2537                 setInt32(m_out.chillDiv(numerator, denominator));
 2538 
 2539             break;
 2540         }
 2541 
 2542         case DoubleRepUse: {
 2543             setDouble(m_out.doubleDiv(
 2544                 lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2545             break;
 2546         }
 2547 
 2548         default:
 2549             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2550             break;
 2551         }
 2552     }
 2553 
<span class="line-added"> 2554     void compileValueMod()</span>
<span class="line-added"> 2555     {</span>
<span class="line-added"> 2556         if (m_node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added"> 2557             LValue left = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added"> 2558             LValue right = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added"> 2559 </span>
<span class="line-added"> 2560             LValue result = vmCall(pointerType(), m_out.operation(operationModBigInt), m_callFrame, left, right);</span>
<span class="line-added"> 2561             setJSValue(result);</span>
<span class="line-added"> 2562             return;</span>
<span class="line-added"> 2563         }</span>
<span class="line-added"> 2564 </span>
<span class="line-added"> 2565         DFG_ASSERT(m_graph, m_node, m_node-&gt;binaryUseKind() == UntypedUse, m_node-&gt;binaryUseKind());</span>
<span class="line-added"> 2566         LValue left = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added"> 2567         LValue right = lowJSValue(m_node-&gt;child2());</span>
<span class="line-added"> 2568         LValue result = vmCall(Int64, m_out.operation(operationValueMod), m_callFrame, left, right);</span>
<span class="line-added"> 2569         setJSValue(result);</span>
<span class="line-added"> 2570     }</span>
<span class="line-added"> 2571 </span>
 2572     void compileArithMod()
 2573     {
 2574         switch (m_node-&gt;binaryUseKind()) {
 2575         case Int32Use: {
 2576             LValue numerator = lowInt32(m_node-&gt;child1());
 2577             LValue denominator = lowInt32(m_node-&gt;child2());
 2578 
 2579             LValue remainder;
 2580             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2581                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2582                 LBasicBlock continuation = m_out.newBlock();
 2583 
 2584                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2585                 m_out.branch(
 2586                     m_out.above(adjustedDenominator, m_out.int32One),
 2587                     usually(continuation), rarely(unsafeDenominator));
 2588 
 2589                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2590                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2591                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
</pre>
<hr />
<pre>
 2707             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2708             LValue argument = lowJSValue(m_node-&gt;child1());
 2709             LValue result = vmCall(Double, m_out.operation(operationArithAbs), m_callFrame, argument);
 2710             setDouble(result);
 2711             break;
 2712         }
 2713         }
 2714     }
 2715 
 2716     void compileArithUnary()
 2717     {
 2718         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2719             setDouble(m_out.doubleUnary(m_node-&gt;arithUnaryType(), lowDouble(m_node-&gt;child1())));
 2720             return;
 2721         }
 2722         LValue argument = lowJSValue(m_node-&gt;child1());
 2723         LValue result = vmCall(Double, m_out.operation(DFG::arithUnaryOperation(m_node-&gt;arithUnaryType())), m_callFrame, argument);
 2724         setDouble(result);
 2725     }
 2726 
<span class="line-added"> 2727     void compileValuePow()</span>
<span class="line-added"> 2728     {</span>
<span class="line-added"> 2729         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added"> 2730             LValue base = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added"> 2731             LValue exponent = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added"> 2732 </span>
<span class="line-added"> 2733             LValue result = vmCall(pointerType(), m_out.operation(operationPowBigInt), m_callFrame, base, exponent);</span>
<span class="line-added"> 2734             setJSValue(result);</span>
<span class="line-added"> 2735             return;</span>
<span class="line-added"> 2736         }</span>
<span class="line-added"> 2737 </span>
<span class="line-added"> 2738         LValue base = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added"> 2739         LValue exponent = lowJSValue(m_node-&gt;child2());</span>
<span class="line-added"> 2740         LValue result = vmCall(Int64, m_out.operation(operationValuePow), m_callFrame, base, exponent);</span>
<span class="line-added"> 2741         setJSValue(result);</span>
<span class="line-added"> 2742     }</span>
<span class="line-added"> 2743 </span>
 2744     void compileArithPow()
 2745     {
 2746         if (m_node-&gt;child2().useKind() == Int32Use)
 2747             setDouble(m_out.doublePowi(lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2748         else {
 2749             LValue base = lowDouble(m_node-&gt;child1());
 2750             LValue exponent = lowDouble(m_node-&gt;child2());
 2751 
 2752             LBasicBlock integerExponentIsSmallBlock = m_out.newBlock();
 2753             LBasicBlock integerExponentPowBlock = m_out.newBlock();
 2754             LBasicBlock doubleExponentPowBlockEntry = m_out.newBlock();
 2755             LBasicBlock nanExceptionBaseIsOne = m_out.newBlock();
 2756             LBasicBlock nanExceptionExponentIsInfinity = m_out.newBlock();
 2757             LBasicBlock testExponentIsOneHalf = m_out.newBlock();
 2758             LBasicBlock handleBaseZeroExponentIsOneHalf = m_out.newBlock();
 2759             LBasicBlock handleInfinityForExponentIsOneHalf = m_out.newBlock();
 2760             LBasicBlock exponentIsOneHalfNormal = m_out.newBlock();
 2761             LBasicBlock exponentIsOneHalfInfinity = m_out.newBlock();
 2762             LBasicBlock testExponentIsNegativeOneHalf = m_out.newBlock();
 2763             LBasicBlock testBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
</pre>
<hr />
<pre>
 3023         LValue argument = lowJSValue(m_node-&gt;child1());
 3024         LValue result = vmCall(Double, m_out.operation(operationArithSqrt), m_callFrame, argument);
 3025         setDouble(result);
 3026     }
 3027 
 3028     void compileArithFRound()
 3029     {
 3030         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3031             setDouble(m_out.fround(lowDouble(m_node-&gt;child1())));
 3032             return;
 3033         }
 3034         LValue argument = lowJSValue(m_node-&gt;child1());
 3035         LValue result = vmCall(Double, m_out.operation(operationArithFRound), m_callFrame, argument);
 3036         setDouble(result);
 3037     }
 3038 
 3039     void compileValueNegate()
 3040     {
 3041         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
 3042         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified"> 3043         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 3044         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 3045         auto repatchingFunction = operationArithNegateOptimize;
 3046         auto nonRepatchingFunction = operationArithNegate;
<span class="line-modified"> 3047         compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
 3048     }
 3049 
 3050     void compileArithNegate()
 3051     {
 3052         switch (m_node-&gt;child1().useKind()) {
 3053         case Int32Use: {
 3054             LValue value = lowInt32(m_node-&gt;child1());
 3055 
 3056             LValue result;
 3057             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 3058                 result = m_out.neg(value);
 3059             else if (!shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 3060                 CheckValue* check = m_out.speculateSub(m_out.int32Zero, value);
 3061                 blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 3062                 result = check;
 3063             } else {
 3064                 speculate(Overflow, noValue(), 0, m_out.testIsZero32(value, m_out.constInt32(0x7fffffff)));
 3065                 result = m_out.neg(value);
 3066             }
 3067 
 3068             setInt32(result);
 3069             break;
 3070         }
 3071 
 3072         case Int52RepUse: {
<span class="line-modified"> 3073             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {</span>
 3074                 Int52Kind kind;
 3075                 LValue value = lowWhicheverInt52(m_node-&gt;child1(), kind);
 3076                 LValue result = m_out.neg(value);
 3077                 if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 3078                     speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 3079                 setInt52(result, kind);
 3080                 break;
 3081             }
 3082 
 3083             LValue value = lowInt52(m_node-&gt;child1());
 3084             CheckValue* result = m_out.speculateSub(m_out.int64Zero, value);
 3085             blessSpeculation(result, Int52Overflow, noValue(), nullptr, m_origin);
 3086             if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 3087                 speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 3088             setInt52(result);
 3089             break;
 3090         }
 3091 
 3092         case DoubleRepUse: {
 3093             setDouble(m_out.doubleNeg(lowDouble(m_node-&gt;child1())));
 3094             break;
 3095         }
 3096 
 3097         default:
 3098             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3099             break;
 3100         }
 3101     }
 3102 
<span class="line-modified"> 3103     void compileValueBitNot()</span>
 3104     {
<span class="line-modified"> 3105         if (m_node-&gt;child1().useKind() == BigIntUse) {</span>
<span class="line-modified"> 3106             LValue operand = lowBigInt(m_node-&gt;child1());</span>
<span class="line-modified"> 3107             LValue result = vmCall(pointerType(), m_out.operation(operationBitNotBigInt), m_callFrame, operand);</span>
 3108             setJSValue(result);
 3109             return;
 3110         }
 3111 
<span class="line-added"> 3112         LValue operand = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added"> 3113         LValue result = vmCall(Int64, m_out.operation(operationValueBitNot), m_callFrame, operand);</span>
<span class="line-added"> 3114         setJSValue(result);</span>
<span class="line-added"> 3115     }</span>
<span class="line-added"> 3116 </span>
<span class="line-added"> 3117     void compileArithBitNot()</span>
<span class="line-added"> 3118     {</span>
 3119         setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
 3120     }
 3121 
 3122     void compileValueBitAnd()
 3123     {
 3124         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3125             LValue left = lowBigInt(m_node-&gt;child1());
 3126             LValue right = lowBigInt(m_node-&gt;child2());
 3127 
 3128             LValue result = vmCall(pointerType(), m_out.operation(operationBitAndBigInt), m_callFrame, left, right);
 3129             setJSValue(result);
 3130             return;
 3131         }
 3132 
 3133         emitBinaryBitOpSnippet&lt;JITBitAndGenerator&gt;(operationValueBitAnd);
 3134     }
 3135 
 3136     void compileArithBitAnd()
 3137     {
 3138         setInt32(m_out.bitAnd(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
</pre>
<hr />
<pre>
 3170 
 3171         emitBinaryBitOpSnippet&lt;JITBitXorGenerator&gt;(operationValueBitXor);
 3172     }
 3173 
 3174     void compileArithBitXor()
 3175     {
 3176         setInt32(m_out.bitXor(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3177     }
 3178 
 3179     void compileBitRShift()
 3180     {
 3181         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 3182             emitRightShiftSnippet(JITRightShiftGenerator::SignedShift);
 3183             return;
 3184         }
 3185         setInt32(m_out.aShr(
 3186             lowInt32(m_node-&gt;child1()),
 3187             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3188     }
 3189 
<span class="line-modified"> 3190     void compileArithBitLShift()</span>
 3191     {




 3192         setInt32(m_out.shl(
 3193             lowInt32(m_node-&gt;child1()),
 3194             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3195     }
 3196 
<span class="line-added"> 3197     void compileValueBitLShift()</span>
<span class="line-added"> 3198     {</span>
<span class="line-added"> 3199         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added"> 3200             LValue left = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added"> 3201             LValue right = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added"> 3202 </span>
<span class="line-added"> 3203             LValue result = vmCall(pointerType(), m_out.operation(operationBitLShiftBigInt), m_callFrame, left, right);</span>
<span class="line-added"> 3204             setJSValue(result);</span>
<span class="line-added"> 3205             return;</span>
<span class="line-added"> 3206         }</span>
<span class="line-added"> 3207 </span>
<span class="line-added"> 3208         ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));</span>
<span class="line-added"> 3209         emitBinaryBitOpSnippet&lt;JITLeftShiftGenerator&gt;(operationValueBitLShift);</span>
<span class="line-added"> 3210     }</span>
<span class="line-added"> 3211 </span>
 3212     void compileBitURShift()
 3213     {
 3214         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 3215             emitRightShiftSnippet(JITRightShiftGenerator::UnsignedShift);
 3216             return;
 3217         }
 3218         setInt32(m_out.lShr(
 3219             lowInt32(m_node-&gt;child1()),
 3220             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3221     }
 3222 
 3223     void compileUInt32ToNumber()
 3224     {
 3225         LValue value = lowInt32(m_node-&gt;child1());
 3226 
 3227         if (doesOverflow(m_node-&gt;arithMode())) {
 3228             setStrictInt52(m_out.zeroExtPtr(value));
 3229             return;
 3230         }
 3231 
</pre>
<hr />
<pre>
 3880             LValue fastResultValue = m_out.loadPtr(cell, m_heaps.JSString_value);
 3881             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 3882 
 3883             m_out.branch(isRopeString(cell, m_node-&gt;child1()), rarely(slowPath), usually(continuation));
 3884 
 3885             LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
 3886 
 3887             ValueFromBlock slowResult = m_out.anchor(
 3888                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, cell));
 3889 
 3890             m_out.jump(continuation);
 3891 
 3892             m_out.appendTo(continuation, lastNext);
 3893 
 3894             setStorage(m_out.loadPtr(m_out.phi(pointerType(), fastResult, slowResult), m_heaps.StringImpl_data));
 3895             return;
 3896         }
 3897 
 3898         DFG_ASSERT(m_graph, m_node, isTypedView(m_node-&gt;arrayMode().typedArrayType()), m_node-&gt;arrayMode().typedArrayType());
 3899         LValue vector = m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector);
<span class="line-modified"> 3900         setStorage(caged(Gigacage::Primitive, vector, cell));</span>
 3901     }
 3902 
 3903     void compileCheckArray()
 3904     {
 3905         Edge edge = m_node-&gt;child1();
 3906         LValue cell = lowCell(edge);
 3907 
 3908         if (m_node-&gt;arrayMode().alreadyChecked(m_graph, m_node, abstractValue(edge)))
 3909             return;
 3910 
 3911         speculate(
 3912             BadIndexingType, jsValueValue(cell), 0,
 3913             m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));
 3914     }
 3915 
 3916     void compileGetTypedArrayByteOffset()
 3917     {
 3918         LValue basePtr = lowCell(m_node-&gt;child1());
 3919 
 3920         LBasicBlock simpleCase = m_out.newBlock();
</pre>
<hr />
<pre>
 3924 
 3925         LValue mode = m_out.load32(basePtr, m_heaps.JSArrayBufferView_mode);
 3926         m_out.branch(
 3927             m_out.notEqual(mode, m_out.constInt32(WastefulTypedArray)),
 3928             unsure(simpleCase), unsure(wastefulCase));
 3929 
 3930         LBasicBlock lastNext = m_out.appendTo(simpleCase, wastefulCase);
 3931 
 3932         ValueFromBlock simpleOut = m_out.anchor(m_out.constIntPtr(0));
 3933 
 3934         m_out.jump(continuation);
 3935 
 3936         m_out.appendTo(wastefulCase, notNull);
 3937 
 3938         LValue vector = m_out.loadPtr(basePtr, m_heaps.JSArrayBufferView_vector);
 3939         ValueFromBlock nullVectorOut = m_out.anchor(vector);
 3940         m_out.branch(vector, unsure(notNull), unsure(continuation));
 3941 
 3942         m_out.appendTo(notNull, continuation);
 3943 
<span class="line-modified"> 3944         LValue butterflyPtr = caged(Gigacage::JSValue, m_out.loadPtr(basePtr, m_heaps.JSObject_butterfly), basePtr);</span>
 3945         LValue arrayBufferPtr = m_out.loadPtr(butterflyPtr, m_heaps.Butterfly_arrayBuffer);
 3946 
<span class="line-modified"> 3947         LValue vectorPtr = caged(Gigacage::Primitive, vector, basePtr);</span>
 3948 
 3949         // FIXME: This needs caging.
 3950         // https://bugs.webkit.org/show_bug.cgi?id=175515
 3951         LValue dataPtr = m_out.loadPtr(arrayBufferPtr, m_heaps.ArrayBuffer_data);
<span class="line-added"> 3952         dataPtr = removeArrayPtrTag(dataPtr);</span>
 3953 
 3954         ValueFromBlock wastefulOut = m_out.anchor(m_out.sub(vectorPtr, dataPtr));
 3955 
 3956         m_out.jump(continuation);
 3957         m_out.appendTo(continuation, lastNext);
 3958 
 3959         setInt32(m_out.castToInt32(m_out.phi(pointerType(), simpleOut, nullVectorOut, wastefulOut)));
 3960     }
 3961 
 3962     void compileGetPrototypeOf()
 3963     {
 3964         switch (m_node-&gt;child1().useKind()) {
 3965         case ArrayUse:
 3966         case FunctionUse:
 3967         case FinalObjectUse: {
 3968             LValue object = lowCell(m_node-&gt;child1());
 3969             switch (m_node-&gt;child1().useKind()) {
 3970             case ArrayUse:
 3971                 speculateArray(m_node-&gt;child1(), object);
 3972                 break;
</pre>
<hr />
<pre>
 4444                     DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 4445                 }
 4446 
 4447                 setDouble(result);
 4448                 return;
 4449             }
 4450         }
 4451 
 4452         case Array::AnyTypedArray:
 4453         case Array::ForceExit:
 4454         case Array::SelectUsingArguments:
 4455         case Array::SelectUsingPredictions:
 4456         case Array::Unprofiled:
 4457             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4458             return;
 4459         }
 4460     }
 4461 
 4462     void compileGetMyArgumentByVal()
 4463     {
<span class="line-modified"> 4464         InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 4465 
 4466         LValue originalIndex = lowInt32(m_node-&gt;child2());
 4467 
 4468         LValue numberOfArgsIncludingThis;
 4469         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
 4470             numberOfArgsIncludingThis = m_out.constInt32(inlineCallFrame-&gt;argumentCountIncludingThis);
 4471         else {
 4472             VirtualRegister argumentCountRegister = AssemblyHelpers::argumentCount(inlineCallFrame);
 4473             numberOfArgsIncludingThis = m_out.load32(payloadFor(argumentCountRegister));
 4474         }
 4475 
 4476         LValue numberOfArgs = m_out.sub(numberOfArgsIncludingThis, m_out.int32One);
 4477         LValue indexToCheck = originalIndex;
 4478         LValue numberOfArgumentsToSkip = m_out.int32Zero;
 4479         if (m_node-&gt;numberOfArgumentsToSkip()) {
 4480             numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 4481             CheckValue* check = m_out.speculateAdd(indexToCheck, numberOfArgumentsToSkip);
 4482             blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 4483             indexToCheck = check;
 4484         }
</pre>
<hr />
<pre>
 4609 
 4610             switch (arrayMode.type()) {
 4611             case Array::Int32:
 4612             case Array::Contiguous: {
 4613                 LValue value = lowJSValue(child3, ManualOperandSpeculation);
 4614 
 4615                 if (arrayMode.type() == Array::Int32)
 4616                     FTL_TYPE_CHECK(jsValueValue(value), child3, SpecInt32Only, isNotInt32(value));
 4617 
 4618                 TypedPointer elementPointer = m_out.baseIndex(
 4619                     arrayMode.type() == Array::Int32 ?
 4620                     m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties,
 4621                     storage, m_out.zeroExtPtr(index), provenValue(child2));
 4622 
 4623                 if (m_node-&gt;op() == PutByValAlias) {
 4624                     m_out.store64(value, elementPointer);
 4625                     break;
 4626                 }
 4627 
 4628                 contiguousPutByValOutOfBounds(
<span class="line-modified"> 4629                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)</span>
 4630                         ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4631                         : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
 4632                     base, storage, index, value, continuation);
 4633 
 4634                 m_out.store64(value, elementPointer);
 4635                 break;
 4636             }
 4637 
 4638             case Array::Double: {
 4639                 LValue value = lowDouble(child3);
 4640 
 4641                 FTL_TYPE_CHECK(
 4642                     doubleValue(value), child3, SpecDoubleReal,
 4643                     m_out.doubleNotEqualOrUnordered(value, value));
 4644 
 4645                 TypedPointer elementPointer = m_out.baseIndex(
 4646                     m_heaps.indexedDoubleProperties, storage, m_out.zeroExtPtr(index),
 4647                     provenValue(child2));
 4648 
 4649                 if (m_node-&gt;op() == PutByValAlias) {
 4650                     m_out.storeDouble(value, elementPointer);
 4651                     break;
 4652                 }
 4653 
 4654                 contiguousPutByValOutOfBounds(
<span class="line-modified"> 4655                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)</span>
 4656                         ? (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 4657                         : (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 4658                     base, storage, index, value, continuation);
 4659 
 4660                 m_out.storeDouble(value, elementPointer);
 4661                 break;
 4662             }
 4663 
 4664             default:
 4665                 DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4666             }
 4667 
 4668             m_out.jump(continuation);
 4669             m_out.appendTo(continuation, outerLastNext);
 4670             return;
 4671         }
 4672 
 4673         case Array::ArrayStorage:
 4674         case Array::SlowPutArrayStorage: {
 4675             LValue value = lowJSValue(child3);
 4676 
 4677             TypedPointer elementPointer = m_out.baseIndex(
 4678                 m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(index),
 4679                 provenValue(child2));
 4680 
 4681             if (m_node-&gt;op() == PutByValAlias) {
 4682                 m_out.store64(value, elementPointer);
 4683                 return;
 4684             }
 4685 
 4686             if (arrayMode.isInBounds()) {
 4687                 speculate(StoreToHole, noValue(), 0, m_out.isZero64(m_out.load64(elementPointer)));
 4688                 m_out.store64(value, elementPointer);
 4689                 return;
 4690             }
 4691 
 4692             LValue isOutOfBounds = m_out.aboveOrEqual(
 4693                 index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength));
 4694 
<span class="line-modified"> 4695             auto slowPathFunction = m_graph.isStrictModeFor(m_node-&gt;origin.semantic)</span>
 4696                 ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4697                 : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict);
 4698             if (!arrayMode.isOutOfBounds()) {
 4699                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
 4700                 isOutOfBounds = m_out.booleanFalse;
 4701             }
 4702 
 4703             LBasicBlock inBoundCase = m_out.newBlock();
 4704             LBasicBlock slowCase = m_out.newBlock();
 4705             LBasicBlock holeCase = m_out.newBlock();
 4706             LBasicBlock doStoreCase = m_out.newBlock();
 4707             LBasicBlock lengthUpdateCase = m_out.newBlock();
 4708             LBasicBlock continuation = m_out.newBlock();
 4709 
 4710             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBoundCase));
 4711 
 4712             LBasicBlock lastNext = m_out.appendTo(slowCase, inBoundCase);
 4713             vmCall(
 4714                 Void, m_out.operation(slowPathFunction),
 4715                 m_callFrame, base, index, value);
</pre>
<hr />
<pre>
 4878     }
 4879 
 4880     void compileArrayPush()
 4881     {
 4882         LValue base = lowCell(m_graph.varArgChild(m_node, 1));
 4883         LValue storage = lowStorage(m_graph.varArgChild(m_node, 0));
 4884         unsigned elementOffset = 2;
 4885         unsigned elementCount = m_node-&gt;numChildren() - elementOffset;
 4886 
 4887         switch (m_node-&gt;arrayMode().type()) {
 4888         case Array::Int32:
 4889         case Array::Contiguous:
 4890         case Array::Double: {
 4891             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 4892 
 4893             if (elementCount == 1) {
 4894                 LValue value;
 4895                 Output::StoreType storeType;
 4896 
 4897                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
<span class="line-added"> 4898                 speculate(element);</span>
 4899                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4900                     value = lowJSValue(element, ManualOperandSpeculation);


 4901                     storeType = Output::Store64;
 4902                 } else {
 4903                     value = lowDouble(element);

 4904                     storeType = Output::StoreDouble;
 4905                 }
 4906 
 4907                 LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4908 
 4909                 LBasicBlock fastPath = m_out.newBlock();
 4910                 LBasicBlock slowPath = m_out.newBlock();
 4911                 LBasicBlock continuation = m_out.newBlock();
 4912 
 4913                 m_out.branch(
 4914                     m_out.aboveOrEqual(
 4915                         prevLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength)),
 4916                     unsure(slowPath), unsure(fastPath));
 4917 
 4918                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4919                 m_out.store(
 4920                     value, m_out.baseIndex(heap, storage, m_out.zeroExtPtr(prevLength)), storeType);
 4921                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 4922                 m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4923 
 4924                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4925                 m_out.jump(continuation);
 4926 
 4927                 m_out.appendTo(slowPath, continuation);
 4928                 LValue operation;
 4929                 if (m_node-&gt;arrayMode().type() != Array::Double)
 4930                     operation = m_out.operation(operationArrayPush);
 4931                 else
 4932                     operation = m_out.operation(operationArrayPushDouble);
 4933                 ValueFromBlock slowResult = m_out.anchor(
 4934                     vmCall(Int64, operation, m_callFrame, value, base));
 4935                 m_out.jump(continuation);
 4936 
 4937                 m_out.appendTo(continuation, lastNext);
 4938                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4939                 return;
 4940             }
 4941 
<span class="line-added"> 4942             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added"> 4943                 Edge element = m_graph.varArgChild(m_node, elementIndex + elementOffset);</span>
<span class="line-added"> 4944                 speculate(element);</span>
<span class="line-added"> 4945             }</span>
<span class="line-added"> 4946 </span>
 4947             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4948             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 4949 
 4950             LBasicBlock fastPath = m_out.newBlock();
 4951             LBasicBlock slowPath = m_out.newBlock();
 4952             LBasicBlock setup = m_out.newBlock();
 4953             LBasicBlock slowCallPath = m_out.newBlock();
 4954             LBasicBlock continuation = m_out.newBlock();
 4955 
 4956             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength));
 4957 
 4958             m_out.branch(beyondVectorLength, unsure(slowPath), unsure(fastPath));
 4959 
 4960             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4961             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4962             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight));
 4963             m_out.jump(setup);
 4964 
 4965             m_out.appendTo(slowPath, setup);
 4966             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 4967             static_assert(sizeof(EncodedJSValue) == sizeof(double), &quot;&quot;);
 4968             ASSERT(scratchSize);
 4969             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 4970             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4971             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 4972             m_out.jump(setup);
 4973 
 4974             m_out.appendTo(setup, slowCallPath);
 4975             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 4976             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 4977                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 4978 
 4979                 LValue value;
 4980                 Output::StoreType storeType;
 4981                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4982                     value = lowJSValue(element, ManualOperandSpeculation);


 4983                     storeType = Output::Store64;
 4984                 } else {
 4985                     value = lowDouble(element);

 4986                     storeType = Output::StoreDouble;
 4987                 }
 4988 
 4989                 m_out.store(value, m_out.baseIndex(heap, buffer, m_out.constInt32(elementIndex), jsNumber(elementIndex)), storeType);
 4990             }
 4991             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4992 
 4993             m_out.branch(beyondVectorLength, unsure(slowCallPath), unsure(continuation));
 4994 
 4995             m_out.appendTo(slowCallPath, continuation);
 4996             LValue operation;
 4997             if (m_node-&gt;arrayMode().type() != Array::Double)
 4998                 operation = m_out.operation(operationArrayPushMultiple);
 4999             else
 5000                 operation = m_out.operation(operationArrayPushDoubleMultiple);
 5001             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, base, buffer, m_out.constInt32(elementCount)));
 5002             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5003             m_out.jump(continuation);
 5004 
 5005             m_out.appendTo(continuation, lastNext);
</pre>
<hr />
<pre>
 5442         auto objectEdge = m_node-&gt;child2();
 5443         if (objectEdge.useKind() == ObjectUse) {
 5444             LValue object = lowNonNullObject(objectEdge);
 5445             LValue result = vmCall(Int64, m_out.operation(operationPushWithScopeObject), m_callFrame, parentScope, object);
 5446             setJSValue(result);
 5447         } else {
 5448             ASSERT(objectEdge.useKind() == UntypedUse);
 5449             LValue object = lowJSValue(m_node-&gt;child2());
 5450             LValue result = vmCall(Int64, m_out.operation(operationPushWithScope), m_callFrame, parentScope, object);
 5451             setJSValue(result);
 5452         }
 5453     }
 5454 
 5455     void compileCreateActivation()
 5456     {
 5457         LValue scope = lowCell(m_node-&gt;child1());
 5458         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
 5459         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
 5460         JSValue initializationValue = m_node-&gt;initializationValueForActivation();
 5461         ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
<span class="line-modified"> 5462         if (table-&gt;singleton().isStillValid()) {</span>
 5463             LValue callResult = vmCall(
 5464                 Int64,
 5465                 m_out.operation(operationCreateActivationDirect), m_callFrame, weakStructure(structure),
 5466                 scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
 5467             setJSValue(callResult);
 5468             return;
 5469         }
 5470 
 5471         LBasicBlock slowPath = m_out.newBlock();
 5472         LBasicBlock continuation = m_out.newBlock();
 5473 
 5474         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5475 
 5476         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
 5477             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
 5478 
 5479         // We don&#39;t need memory barriers since we just fast-created the activation, so the
 5480         // activation must be young.
 5481         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
 5482         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
</pre>
<hr />
<pre>
 5503                     CCallHelpers::TrustedImm64(JSValue::encode(initializationValue)));
 5504             },
 5505             scope);
 5506         ValueFromBlock slowResult = m_out.anchor(callResult);
 5507         m_out.jump(continuation);
 5508 
 5509         m_out.appendTo(continuation, lastNext);
 5510         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5511     }
 5512 
 5513     void compileNewFunction()
 5514     {
 5515         ASSERT(m_node-&gt;op() == NewFunction || m_node-&gt;op() == NewGeneratorFunction || m_node-&gt;op() == NewAsyncGeneratorFunction || m_node-&gt;op() == NewAsyncFunction);
 5516         bool isGeneratorFunction = m_node-&gt;op() == NewGeneratorFunction;
 5517         bool isAsyncFunction = m_node-&gt;op() == NewAsyncFunction;
 5518         bool isAsyncGeneratorFunction =  m_node-&gt;op() == NewAsyncGeneratorFunction;
 5519 
 5520         LValue scope = lowCell(m_node-&gt;child1());
 5521 
 5522         FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
<span class="line-modified"> 5523         if (executable-&gt;singleton().isStillValid()) {</span>
 5524             LValue callResult =
 5525                 isGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5526                 isAsyncFunction ? vmCall(Int64, m_out.operation(operationNewAsyncFunction), m_callFrame, scope, weakPointer(executable)) :
 5527                 isAsyncGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewAsyncGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5528                 vmCall(Int64, m_out.operation(operationNewFunction), m_callFrame, scope, weakPointer(executable));
 5529             setJSValue(callResult);
 5530             return;
 5531         }
 5532 
 5533         RegisteredStructure structure = m_graph.registerStructure(
 5534             [&amp;] () {
 5535                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5536                 switch (m_node-&gt;op()) {
 5537                 case NewGeneratorFunction:
 5538                     return globalObject-&gt;generatorFunctionStructure();
 5539                 case NewAsyncFunction:
 5540                     return globalObject-&gt;asyncFunctionStructure();
 5541                 case NewAsyncGeneratorFunction:
 5542                     return globalObject-&gt;asyncGeneratorFunctionStructure();
 5543                 case NewFunction:
</pre>
<hr />
<pre>
 5548             }());
 5549 
 5550         LBasicBlock slowPath = m_out.newBlock();
 5551         LBasicBlock continuation = m_out.newBlock();
 5552 
 5553         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5554 
 5555         LValue fastObject =
 5556             isGeneratorFunction ? allocateObject&lt;JSGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5557             isAsyncFunction ? allocateObject&lt;JSAsyncFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5558             isAsyncGeneratorFunction ? allocateObject&lt;JSAsyncGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5559             allocateObject&lt;JSFunction&gt;(structure, m_out.intPtrZero, slowPath);
 5560 
 5561 
 5562         // We don&#39;t need memory barriers since we just fast-created the function, so it
 5563         // must be young.
 5564         m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
 5565         m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executable);
 5566         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.JSFunction_rareData);
 5567 
<span class="line-modified"> 5568         VM&amp; vm = this-&gt;vm();</span>
<span class="line-added"> 5569         if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="line-added"> 5570             mutatorFence();</span>
<span class="line-added"> 5571             Allocator allocator = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-added"> 5572             LValue rareData = allocateCell(m_out.constIntPtr(allocator.localAllocator()), vm.functionRareDataStructure.get(), slowPath);</span>
<span class="line-added"> 5573             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocator);</span>
<span class="line-added"> 5574             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_structure);</span>
<span class="line-added"> 5575             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_prototype);</span>
<span class="line-added"> 5576             m_out.storePtr(m_out.intPtrOne, rareData, m_heaps.FunctionRareData_objectAllocationProfileWatchpoint);</span>
<span class="line-added"> 5577             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);</span>
<span class="line-added"> 5578             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_boundFunctionStructure);</span>
<span class="line-added"> 5579             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocationProfileClearingWatchpoint);</span>
<span class="line-added"> 5580             m_out.store32As8(m_out.int32One, rareData, m_heaps.FunctionRareData_hasReifiedName);</span>
<span class="line-added"> 5581             m_out.store32As8(m_out.int32Zero, rareData, m_heaps.FunctionRareData_hasReifiedLength);</span>
<span class="line-added"> 5582             mutatorFence();</span>
<span class="line-added"> 5583             m_out.storePtr(rareData, fastObject, m_heaps.JSFunction_rareData);</span>
<span class="line-added"> 5584         } else</span>
<span class="line-added"> 5585             mutatorFence();</span>
 5586 
 5587         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5588         m_out.jump(continuation);
 5589 
 5590         m_out.appendTo(slowPath, continuation);
 5591 
 5592         Vector&lt;LValue&gt; slowPathArguments;
 5593         slowPathArguments.append(scope);

 5594         LValue callResult = lazySlowPath(
 5595             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5596                 auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
 5597                 if (isGeneratorFunction)
 5598                     operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5599                 else if (isAsyncFunction)
 5600                     operation = operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint;
 5601                 else if (isAsyncGeneratorFunction)
 5602                     operation = operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5603 
 5604                 return createLazyCallGenerator(vm, operation,
 5605                     locations[0].directGPR(), locations[1].directGPR(),
 5606                     CCallHelpers::TrustedImmPtr(executable));
 5607             },
 5608             slowPathArguments);
 5609         ValueFromBlock slowResult = m_out.anchor(callResult);
 5610         m_out.jump(continuation);
 5611 
 5612         m_out.appendTo(continuation, lastNext);
 5613         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
</pre>
<hr />
<pre>
 6040                 else {
 6041                     Edge&amp; child = m_graph.varArgChild(m_node, i);
 6042                     if (child-&gt;op() == PhantomSpread &amp;&amp; child-&gt;child1()-&gt;op() == PhantomNewArrayBuffer)
 6043                         startLength += child-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 6044                 }
 6045             }
 6046 
 6047             if (startLength.hasOverflowed()) {
 6048                 terminate(Overflow);
 6049                 return;
 6050             }
 6051 
 6052             LValue length = m_out.constInt32(startLength.unsafeGet());
 6053 
 6054             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6055                 if (bitVector-&gt;get(i)) {
 6056                     Edge use = m_graph.varArgChild(m_node, i);
 6057                     CheckValue* lengthCheck = nullptr;
 6058                     if (use-&gt;op() == PhantomSpread) {
 6059                         if (use-&gt;child1()-&gt;op() == PhantomCreateRest) {
<span class="line-modified"> 6060                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 6061                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6062                             LValue spreadLength = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 6063                                 return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6064                             }).iterator-&gt;value;
 6065                             lengthCheck = m_out.speculateAdd(length, spreadLength);
 6066                         }
 6067                     } else {
 6068                         LValue fixedArray = lowCell(use);
 6069                         lengthCheck = m_out.speculateAdd(length, m_out.load32(fixedArray, m_heaps.JSFixedArray_size));
 6070                     }
 6071 
 6072                     if (lengthCheck) {
 6073                         blessSpeculation(lengthCheck, Overflow, noValue(), nullptr, m_origin);
 6074                         length = lengthCheck;
 6075                     }
 6076                 }
 6077             }
 6078 
 6079             LValue exceedsMaxAllowedLength = m_out.aboveOrEqual(length, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
 6080             blessSpeculation(m_out.speculate(exceedsMaxAllowedLength), Overflow, noValue(), nullptr, m_origin);
</pre>
<hr />
<pre>
 6084             LValue result = arrayValues.array;
 6085             LValue storage = arrayValues.butterfly;
 6086             LValue index = m_out.constIntPtr(0);
 6087 
 6088             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6089                 Edge use = m_graph.varArgChild(m_node, i);
 6090                 if (bitVector-&gt;get(i)) {
 6091                     if (use-&gt;op() == PhantomSpread) {
 6092                         if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
 6093                             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 6094                             auto* array = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6095                             for (unsigned i = 0; i &lt; array-&gt;length(); ++i) {
 6096                                 // Because resulted array from NewArrayWithSpread is always contiguous, we should not generate value
 6097                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 6098                                 int64_t value = JSValue::encode(array-&gt;get(i));
 6099                                 m_out.store64(m_out.constInt64(value), m_out.baseIndex(heap, storage, index, JSValue(), (Checked&lt;int32_t&gt;(sizeof(JSValue)) * i).unsafeGet()));
 6100                             }
 6101                             index = m_out.add(index, m_out.constIntPtr(array-&gt;length()));
 6102                         } else {
 6103                             RELEASE_ASSERT(use-&gt;child1()-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 6104                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 6105                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6106 
 6107                             LValue length = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 6108                             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6109 
 6110                             LBasicBlock loopStart = m_out.newBlock();
 6111                             LBasicBlock continuation = m_out.newBlock();
 6112 
 6113                             ValueFromBlock loadIndexStart = m_out.anchor(m_out.constIntPtr(0));
 6114                             ValueFromBlock arrayIndexStart = m_out.anchor(index);
 6115                             ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 6116 
 6117                             m_out.branch(
 6118                                 m_out.isZero64(length),
 6119                                 unsure(continuation), unsure(loopStart));
 6120 
 6121                             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 6122 
 6123                             LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
 6124                             LValue loadIndex = m_out.phi(pointerType(), loadIndexStart);
</pre>
<hr />
<pre>
 6276                     m_out.constInt64(value),
 6277                     m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, m_out.constIntPtr(i), jsNumber(i)));
 6278             }
 6279             mutatorFence();
 6280             setJSValue(fixedArray);
 6281             return;
 6282         }
 6283 
 6284         if (m_node-&gt;child1()-&gt;op() == PhantomCreateRest) {
 6285             // This IR is rare to generate since it requires escaping the Spread
 6286             // but not the CreateRest. In bytecode, we have only few operations that
 6287             // accept Spread&#39;s result as input. This usually leads to the Spread node not
 6288             // escaping. However, this can happen if for example we generate a PutStack on
 6289             // the Spread but nothing escapes the CreateRest.
 6290             LBasicBlock loopHeader = m_out.newBlock();
 6291             LBasicBlock loopBody = m_out.newBlock();
 6292             LBasicBlock slowAllocation = m_out.newBlock();
 6293             LBasicBlock continuation = m_out.newBlock();
 6294             LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopHeader);
 6295 
<span class="line-modified"> 6296             InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 6297             unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6298             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6299             LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6300             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6301             LValue size = m_out.add(
 6302                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
 6303                 m_out.constIntPtr(JSFixedArray::offsetOfData()));
 6304 
 6305             LValue fastArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);
 6306             m_out.store32(length, fastArrayValue, m_heaps.JSFixedArray_size);
 6307             ValueFromBlock fastArray = m_out.anchor(fastArrayValue);
 6308             m_out.jump(loopHeader);
 6309 
 6310             m_out.appendTo(slowAllocation, loopHeader);
 6311             ValueFromBlock slowArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, length));
 6312             m_out.jump(loopHeader);
 6313 
 6314             m_out.appendTo(loopHeader, loopBody);
 6315             LValue fixedArray = m_out.phi(pointerType(), fastArray, slowArray);
 6316             ValueFromBlock startIndex = m_out.anchor(m_out.constIntPtr(0));
</pre>
<hr />
<pre>
 6502             LBasicBlock lastNext = m_out.appendTo(smallEnoughCase, slowCase);
 6503 
 6504             LValue byteSize =
 6505                 m_out.shl(m_out.zeroExtPtr(size), m_out.constInt32(logElementSize(typedArrayType)));
 6506             if (elementSize(typedArrayType) &lt; 8) {
 6507                 byteSize = m_out.bitAnd(
 6508                     m_out.add(byteSize, m_out.constIntPtr(7)),
 6509                     m_out.constIntPtr(~static_cast&lt;intptr_t&gt;(7)));
 6510             }
 6511 
 6512             LValue allocator = allocatorForSize(vm().primitiveGigacageAuxiliarySpace, byteSize, slowCase);
 6513             LValue storage = allocateHeapCell(allocator, slowCase);
 6514 
 6515             splatWords(
 6516                 storage,
 6517                 m_out.int32Zero,
 6518                 m_out.castToInt32(m_out.lShr(byteSize, m_out.constIntPtr(3))),
 6519                 m_out.int64Zero,
 6520                 m_heaps.typedArrayProperties);
 6521 
<span class="line-added"> 6522 #if CPU(ARM64E)</span>
<span class="line-added"> 6523             {</span>
<span class="line-added"> 6524                 LValue sizePtr = m_out.zeroExtPtr(size);</span>
<span class="line-added"> 6525                 PatchpointValue* authenticate = m_out.patchpoint(pointerType());</span>
<span class="line-added"> 6526                 authenticate-&gt;appendSomeRegister(storage);</span>
<span class="line-added"> 6527                 authenticate-&gt;append(sizePtr, B3::ValueRep(B3::ValueRep::SomeLateRegister));</span>
<span class="line-added"> 6528                 authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added"> 6529                     jit.move(params[1].gpr(), params[0].gpr());</span>
<span class="line-added"> 6530                     jit.tagArrayPtr(params[2].gpr(), params[0].gpr());</span>
<span class="line-added"> 6531                 });</span>
<span class="line-added"> 6532                 storage = authenticate;</span>
<span class="line-added"> 6533             }</span>
<span class="line-added"> 6534 #endif</span>
<span class="line-added"> 6535 </span>
 6536             ValueFromBlock haveStorage = m_out.anchor(storage);
 6537 
 6538             LValue fastResultValue =
 6539                 allocateObject&lt;JSArrayBufferView&gt;(structure, m_out.intPtrZero, slowCase);
 6540 
 6541             m_out.storePtr(storage, fastResultValue, m_heaps.JSArrayBufferView_vector);
 6542             m_out.store32(size, fastResultValue, m_heaps.JSArrayBufferView_length);
 6543             m_out.store32(m_out.constInt32(FastTypedArray), fastResultValue, m_heaps.JSArrayBufferView_mode);
 6544 
 6545             mutatorFence();
 6546             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 6547             m_out.jump(continuation);
 6548 
 6549             m_out.appendTo(slowCase, continuation);
 6550             LValue storageValue = m_out.phi(pointerType(), noStorage, haveStorage);
 6551 
 6552             VM&amp; vm = this-&gt;vm();
 6553             LValue slowResultValue = lazySlowPath(
 6554                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6555                     return createLazyCallGenerator(vm,
</pre>
<hr />
<pre>
 6775             LValue length;
 6776         };
 6777 
 6778         Edge edges[3] = {
 6779             m_node-&gt;child1(),
 6780             m_node-&gt;child2(),
 6781             m_node-&gt;child3(),
 6782         };
 6783         LValue kids[3];
 6784         unsigned numKids;
 6785         kids[0] = lowCell(edges[0]);
 6786         kids[1] = lowCell(edges[1]);
 6787         if (edges[2]) {
 6788             kids[2] = lowCell(edges[2]);
 6789             numKids = 3;
 6790         } else {
 6791             kids[2] = 0;
 6792             numKids = 2;
 6793         }
 6794 
<span class="line-added"> 6795         LBasicBlock emptyCase = m_out.newBlock();</span>
 6796         LBasicBlock slowPath = m_out.newBlock();
 6797         LBasicBlock continuation = m_out.newBlock();
 6798 
 6799         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
 6800 
 6801         LValue result = allocateCell(
 6802             m_out.constIntPtr(allocator.localAllocator()), vm().stringStructure.get(), slowPath);
 6803 
<span class="line-modified"> 6804         // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.</span>
<span class="line-modified"> 6805         m_out.storePtr(m_out.constIntPtr(JSString::isRopeInPointer), result, m_heaps.JSRopeString_fiber0);</span>










 6806 
 6807         auto getFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child) {
 6808             if (JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
 6809                 return FlagsAndLength {
 6810                     m_out.constInt32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0),
 6811                     m_out.constInt32(string-&gt;length())
 6812                 };
 6813             }
 6814 
 6815             LBasicBlock continuation = m_out.newBlock();
 6816             LBasicBlock ropeCase = m_out.newBlock();
 6817             LBasicBlock notRopeCase = m_out.newBlock();
 6818 
 6819             m_out.branch(isRopeString(child, edge), unsure(ropeCase), unsure(notRopeCase));
 6820 
 6821             LBasicBlock lastNext = m_out.appendTo(ropeCase, notRopeCase);
<span class="line-modified"> 6822             ValueFromBlock flagsForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_flags));</span>
 6823             ValueFromBlock lengthForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_length));
 6824             m_out.jump(continuation);
 6825 
 6826             m_out.appendTo(notRopeCase, continuation);
 6827             LValue stringImpl = m_out.loadPtr(child, m_heaps.JSString_value);
 6828             ValueFromBlock flagsForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_hashAndFlags));
 6829             ValueFromBlock lengthForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length));
 6830             m_out.jump(continuation);
 6831 
 6832             m_out.appendTo(continuation, lastNext);
 6833             return FlagsAndLength {
 6834                 m_out.phi(Int32, flagsForRope, flagsForNonRope),
 6835                 m_out.phi(Int32, lengthForRope, lengthForNonRope)
 6836             };
 6837         };
 6838 
 6839         FlagsAndLength flagsAndLength = getFlagsAndLength(edges[0], kids[0]);
 6840         for (unsigned i = 1; i &lt; numKids; ++i) {
 6841             auto mergeFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child, FlagsAndLength previousFlagsAndLength) {
 6842                 FlagsAndLength flagsAndLength = getFlagsAndLength(edge, child);
 6843                 LValue flags = m_out.bitAnd(previousFlagsAndLength.flags, flagsAndLength.flags);
 6844                 CheckValue* lengthCheck = m_out.speculateAdd(previousFlagsAndLength.length, flagsAndLength.length);
<span class="line-modified"> 6845                 blessSpeculation(lengthCheck, Uncountable, noValue(), nullptr, m_origin);</span>
 6846                 return FlagsAndLength {
 6847                     flags,
 6848                     lengthCheck
 6849                 };
 6850             };
 6851             flagsAndLength = mergeFlagsAndLength(edges[i], kids[i], flagsAndLength);
 6852         }
<span class="line-modified"> 6853 </span>
<span class="line-modified"> 6854         m_out.storePtr(</span>
<span class="line-added"> 6855             m_out.bitOr(</span>
<span class="line-added"> 6856                 m_out.bitOr(kids[0], m_out.constIntPtr(JSString::isRopeInPointer)),</span>
<span class="line-added"> 6857                 m_out.bitAnd(m_out.constIntPtr(JSRopeString::is8BitInPointer), m_out.zeroExtPtr(flagsAndLength.flags))),</span>
<span class="line-added"> 6858             result, m_heaps.JSRopeString_fiber0);</span>
<span class="line-added"> 6859         m_out.storePtr(</span>
<span class="line-added"> 6860             m_out.bitOr(m_out.zeroExtPtr(flagsAndLength.length), m_out.shl(kids[1], m_out.constInt32(32))),</span>
<span class="line-added"> 6861             result, m_heaps.JSRopeString_fiber1);</span>
<span class="line-added"> 6862         if (numKids == 2)</span>
<span class="line-added"> 6863             m_out.storePtr(m_out.lShr(kids[1], m_out.constInt32(32)), result, m_heaps.JSRopeString_fiber2);</span>
<span class="line-added"> 6864         else</span>
<span class="line-added"> 6865             m_out.storePtr(m_out.bitOr(m_out.lShr(kids[1], m_out.constInt32(32)), m_out.shl(kids[2], m_out.constInt32(16))), result, m_heaps.JSRopeString_fiber2);</span>
 6866 
 6867         mutatorFence();
<span class="line-modified"> 6868         ValueFromBlock fastResult = m_out.anchor(result);</span>
<span class="line-added"> 6869         m_out.branch(m_out.isZero32(flagsAndLength.length), rarely(emptyCase), usually(continuation));</span>
<span class="line-added"> 6870 </span>
<span class="line-added"> 6871         LBasicBlock lastNext = m_out.appendTo(emptyCase, slowPath);</span>
<span class="line-added"> 6872         ValueFromBlock emptyResult = m_out.anchor(weakPointer(jsEmptyString(m_graph.m_vm)));</span>
 6873         m_out.jump(continuation);
 6874 
<span class="line-modified"> 6875         m_out.appendTo(slowPath, continuation);</span>
 6876         LValue slowResultValue;
 6877         VM&amp; vm = this-&gt;vm();
 6878         switch (numKids) {
 6879         case 2:
 6880             slowResultValue = lazySlowPath(
 6881                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6882                     return createLazyCallGenerator(vm,
 6883                         operationMakeRope2, locations[0].directGPR(), locations[1].directGPR(),
 6884                         locations[2].directGPR());
 6885                 }, kids[0], kids[1]);
 6886             break;
 6887         case 3:
 6888             slowResultValue = lazySlowPath(
 6889                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6890                     return createLazyCallGenerator(vm,
 6891                         operationMakeRope3, locations[0].directGPR(), locations[1].directGPR(),
 6892                         locations[2].directGPR(), locations[3].directGPR());
 6893                 }, kids[0], kids[1], kids[2]);
 6894             break;
 6895         default:
 6896             DFG_CRASH(m_graph, m_node, &quot;Bad number of children&quot;);
 6897             break;
 6898         }
 6899         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6900         m_out.jump(continuation);
 6901 
 6902         m_out.appendTo(continuation, lastNext);
<span class="line-modified"> 6903         setJSValue(m_out.phi(Int64, fastResult, emptyResult, slowResult));</span>
 6904     }
 6905 
 6906     void compileStringCharAt()
 6907     {
 6908         LValue base = lowString(m_graph.child(m_node, 0));
 6909         LValue index = lowInt32(m_graph.child(m_node, 1));
 6910         LValue storage = lowStorage(m_graph.child(m_node, 2));
 6911 
 6912         LBasicBlock fastPath = m_out.newBlock();
 6913         LBasicBlock slowPath = m_out.newBlock();
 6914         LBasicBlock continuation = m_out.newBlock();
 6915 
 6916         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 6917         m_out.branch(
 6918             m_out.aboveOrEqual(
 6919                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)),
 6920             rarely(slowPath), usually(fastPath));
 6921 
 6922         LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 6923 
</pre>
<hr />
<pre>
 6961             m_callFrame, char16BitValue)));
 6962         m_out.jump(continuation);
 6963 
 6964         m_out.appendTo(bitsContinuation, slowPath);
 6965 
 6966         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
 6967 
 6968         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 6969 
 6970         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
 6971             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
 6972         m_out.jump(continuation);
 6973 
 6974         m_out.appendTo(slowPath, continuation);
 6975 
 6976         if (m_node-&gt;arrayMode().isInBounds()) {
 6977             speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
 6978             results.append(m_out.anchor(m_out.intPtrZero));
 6979         } else {
 6980             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<span class="line-added"> 6981             Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm());</span>
<span class="line-added"> 6982             Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());</span>
<span class="line-added"> 6983             WTF::loadLoadFence();</span>
 6984 

 6985             if (globalObject-&gt;stringPrototypeChainIsSane()) {
 6986                 // FIXME: This could be captured using a Speculation mode that means
 6987                 // &quot;out-of-bounds loads return a trivial value&quot;, something like
 6988                 // SaneChainOutOfBounds.
 6989                 // https://bugs.webkit.org/show_bug.cgi?id=144668
 6990 
<span class="line-modified"> 6991                 m_graph.registerAndWatchStructureTransition(stringPrototypeStructure);</span>
<span class="line-modified"> 6992                 m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);</span>
 6993 



 6994                 LBasicBlock negativeIndex = m_out.newBlock();
 6995 
 6996                 results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 6997                 m_out.branch(
 6998                     m_out.lessThan(index, m_out.int32Zero),
 6999                     rarely(negativeIndex), usually(continuation));
 7000 
 7001                 m_out.appendTo(negativeIndex, continuation);
 7002             }
 7003 
 7004             results.append(m_out.anchor(vmCall(
 7005                 Int64, m_out.operation(operationGetByValStringInt), m_callFrame, base, index)));
 7006         }
 7007 
 7008         m_out.jump(continuation);
 7009 
 7010         m_out.appendTo(continuation, lastNext);
 7011         setJSValue(m_out.phi(Int64, results));
 7012     }
 7013 
</pre>
<hr />
<pre>
 7061     {
 7062         Edge childEdge = m_node-&gt;child1();
 7063 
 7064         if (childEdge.useKind() == UntypedUse) {
 7065             LValue result = vmCall(
 7066                 Int64, m_out.operation(operationStringFromCharCodeUntyped), m_callFrame,
 7067                 lowJSValue(childEdge));
 7068             setJSValue(result);
 7069             return;
 7070         }
 7071 
 7072         DFG_ASSERT(m_graph, m_node, childEdge.useKind() == Int32Use, childEdge.useKind());
 7073 
 7074         LValue value = lowInt32(childEdge);
 7075 
 7076         LBasicBlock smallIntCase = m_out.newBlock();
 7077         LBasicBlock slowCase = m_out.newBlock();
 7078         LBasicBlock continuation = m_out.newBlock();
 7079 
 7080         m_out.branch(
<span class="line-modified"> 7081             m_out.above(value, m_out.constInt32(maxSingleCharacterString)),</span>
 7082             rarely(slowCase), usually(smallIntCase));
 7083 
 7084         LBasicBlock lastNext = m_out.appendTo(smallIntCase, slowCase);
 7085 
 7086         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 7087         LValue fastResultValue = m_out.loadPtr(
 7088             m_out.baseIndex(m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(value)));
 7089         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 7090         m_out.jump(continuation);
 7091 
 7092         m_out.appendTo(slowCase, continuation);
 7093 
 7094         LValue slowResultValue = vmCall(
 7095             pointerType(), m_out.operation(operationStringFromCharCode), m_callFrame, value);
 7096         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 7097         m_out.jump(continuation);
 7098 
 7099         m_out.appendTo(continuation, lastNext);
 7100 
 7101         setJSValue(m_out.phi(Int64, fastResult, slowResult));
</pre>
<hr />
<pre>
 7872             intptr_t offsetFromSP =
 7873                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 7874             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 7875         };
 7876 
 7877         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 7878         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 7879         for (unsigned i = 0; i &lt; numArgs; ++i)
 7880             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 7881 
 7882         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 7883         patchpoint-&gt;appendVector(arguments);
 7884 
 7885         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 7886             preparePatchpointForExceptions(patchpoint);
 7887 
 7888         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 7889         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 7890         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 7891         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 7892         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
 7893 
 7894         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 7895         State* state = &amp;m_ftlState;
 7896         VM* vm = &amp;this-&gt;vm();
 7897         patchpoint-&gt;setGenerator(
 7898             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7899                 AllowMacroScratchRegisterUsage allowScratch(jit);
 7900                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 7901 
 7902                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 7903 
 7904                 jit.store32(
 7905                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 7906                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 7907 
 7908                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 7909 
 7910                 CCallHelpers::DataLabelPtr targetToCheck;
 7911                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 7912                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
</pre>
<hr />
<pre>
 7991                 addArgument(m_out.constInt64(JSValue::encode(jsUndefined())), virtualRegisterForArgument(i), 0);
 7992         } else {
 7993             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
 7994                 arguments.append(ConstrainedValue(lowJSValue(m_graph.varArgChild(node, 1 + i)), ValueRep::WarmAny));
 7995         }
 7996 
 7997         PatchpointValue* patchpoint = m_out.patchpoint(isTail ? Void : Int64);
 7998         patchpoint-&gt;appendVector(arguments);
 7999 
 8000         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8001 
 8002         if (isTail) {
 8003             // The shuffler needs tags.
 8004             patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8005             patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8006         }
 8007 
 8008         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8009         if (!isTail) {
 8010             patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 8011             patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
 8012         }
 8013 
 8014         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8015         State* state = &amp;m_ftlState;
 8016         patchpoint-&gt;setGenerator(
 8017             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8018                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8019                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8020 
 8021                 GPRReg calleeGPR = params[!isTail].gpr();
 8022 
 8023                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8024 
 8025                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8026                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8027 
 8028                 if (isTail) {
 8029                     CallFrameShuffleData shuffleData;
 8030                     shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 8031 
</pre>
<hr />
<pre>
 8285             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8286                 BitVector* bitVector = target-&gt;bitVector();
 8287                 for (unsigned i = target-&gt;numChildren(); i--; ) {
 8288                     if (bitVector-&gt;get(i))
 8289                         self(m_graph.varArgChild(target, i).node());
 8290                     else {
 8291                         ++staticArgumentCount;
 8292                         LValue argument = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 8293                         patchpointArguments.append(argument);
 8294                     }
 8295                 }
 8296                 return;
 8297             }
 8298 
 8299             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8300                 staticArgumentCount += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 8301                 return;
 8302             }
 8303 
 8304             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 8305             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
 8306             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8307             LValue length = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 8308                 return m_out.zeroExtPtr(this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));
 8309             }).iterator-&gt;value;
 8310             patchpointArguments.append(length);
 8311             spreadLengths.append(length);
 8312         });
 8313 
 8314         pushAndCountArgumentsFromRightToLeft(arguments);
 8315         LValue argumentCountIncludingThis = m_out.constIntPtr(staticArgumentCount + 1);
 8316         for (LValue length : spreadLengths)
 8317             argumentCountIncludingThis = m_out.add(length, argumentCountIncludingThis);
 8318 
 8319         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8320 
 8321         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 8322         patchpoint-&gt;append(thisArg, ValueRep::WarmAny);
 8323         patchpoint-&gt;append(argumentCountIncludingThis, ValueRep::WarmAny);
 8324         patchpoint-&gt;appendVectorWithRep(patchpointArguments, ValueRep::WarmAny);
 8325         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8326         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8327 
 8328         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8329 
 8330         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8331         patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
<span class="line-modified"> 8332         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
 8333 
 8334         patchpoint-&gt;numGPScratchRegisters = 0;
 8335 
 8336         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8337         unsigned minimumJSCallAreaSize =
 8338             sizeof(CallerFrameAndPC) +
 8339             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8340 
 8341         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8342 
 8343         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8344         State* state = &amp;m_ftlState;
 8345         VM* vm = &amp;this-&gt;vm();
 8346         patchpoint-&gt;setGenerator(
 8347             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8348                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8349                 CallSiteIndex callSiteIndex =
 8350                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8351 
 8352                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
</pre>
<hr />
<pre>
 8448                         }
 8449 
 8450                         if (target-&gt;op() == PhantomNewArrayBuffer) {
 8451                             auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 8452                             Checked&lt;int32_t&gt; offsetCount { 1 };
 8453                             for (unsigned i = array-&gt;length(); i--; ++offsetCount) {
 8454                                 // Because varargs values are drained as JSValue, we should not generate value
 8455                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 8456                                 int64_t value = JSValue::encode(array-&gt;get(i));
 8457                                 jit.move(CCallHelpers::TrustedImm64(value), scratchGPR3);
 8458                                 Checked&lt;int32_t&gt; currentStoreOffset { storeOffset };
 8459                                 currentStoreOffset -= (offsetCount * static_cast&lt;int32_t&gt;(sizeof(Register)));
 8460                                 jit.store64(scratchGPR3,
 8461                                     CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, currentStoreOffset.unsafeGet()));
 8462                             }
 8463                             jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(array-&gt;length())), scratchGPR2);
 8464                             return;
 8465                         }
 8466 
 8467                         RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 8468                         InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
 8469 
 8470                         unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8471 
 8472                         B3::ValueRep numArgumentsToCopy = params[paramsOffset + (index++)];
 8473                         getValueFromRep(numArgumentsToCopy, scratchGPR3);
 8474                         int loadOffset = (AssemblyHelpers::argumentsStart(inlineCallFrame).offset() + numberOfArgumentsToSkip) * static_cast&lt;int&gt;(sizeof(Register));
 8475 
 8476                         auto done = jit.branchTestPtr(MacroAssembler::Zero, scratchGPR3);
 8477                         auto loopStart = jit.label();
 8478                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR3);
 8479                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 8480                         jit.load64(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR3, CCallHelpers::TimesEight, loadOffset), scratchGPR4);
 8481                         jit.store64(scratchGPR4,
 8482                             CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 8483                         jit.branchTestPtr(CCallHelpers::NonZero, scratchGPR3).linkTo(loopStart, &amp;jit);
 8484                         done.link(&amp;jit);
 8485                     });
 8486                     emitArgumentsFromRightToLeft(arguments);
 8487                 }
 8488 
</pre>
<hr />
<pre>
 8614             patchpoint-&gt;appendSomeRegister(jsArguments);
 8615         patchpoint-&gt;appendSomeRegister(thisArg);
 8616 
 8617         if (!forwarding) {
 8618             // Now append them again for after clobbering. Note that the compiler may ask us to use a
 8619             // different register for the late for the post-clobbering version of the value. This gives
 8620             // the compiler a chance to spill these values without having to burn any callee-saves.
 8621             patchpoint-&gt;append(jsCallee, ValueRep::LateColdAny);
 8622             patchpoint-&gt;append(jsArguments, ValueRep::LateColdAny);
 8623             patchpoint-&gt;append(thisArg, ValueRep::LateColdAny);
 8624         }
 8625 
 8626         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 8627             preparePatchpointForExceptions(patchpoint);
 8628 
 8629         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8630         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8631 
 8632         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8633         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 8634         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
 8635 
 8636         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8637         unsigned minimumJSCallAreaSize =
 8638             sizeof(CallerFrameAndPC) +
 8639             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8640 
 8641         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8642 
 8643         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8644         State* state = &amp;m_ftlState;
 8645         VM* vm = &amp;this-&gt;vm();
 8646         patchpoint-&gt;setGenerator(
 8647             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8648                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8649                 CallSiteIndex callSiteIndex =
 8650                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8651 
 8652                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8653                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8654 
</pre>
<hr />
<pre>
 8728                 ScratchRegisterAllocator allocator(usedRegisters);
 8729                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 8730                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 8731                 GPRReg scratchGPR3 = forwarding ? allocator.allocateScratchGPR() : InvalidGPRReg;
 8732                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 8733 
 8734                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 8735                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 8736                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8737                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8738                 };
 8739 
 8740                 unsigned originalStackHeight = params.proc().frameSize();
 8741 
 8742                 if (forwarding) {
 8743                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8744 
 8745                     CCallHelpers::JumpList slowCase;
 8746                     InlineCallFrame* inlineCallFrame;
 8747                     if (node-&gt;child3())
<span class="line-modified"> 8748                         inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();</span>
 8749                     else
<span class="line-modified"> 8750                         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
 8751 
 8752                     // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 8753                     emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 8754 
 8755                     CCallHelpers::Jump done = jit.jump();
 8756                     slowCase.link(&amp;jit);
 8757                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();
 8758                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 8759                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 8760 
 8761                     done.link(&amp;jit);
 8762                 } else {
 8763                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR1);
 8764                     jit.setupArguments&lt;decltype(operationSizeFrameForVarargs)&gt;(argumentsGPR, scratchGPR1, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset));
 8765                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSizeFrameForVarargs));
 8766 
 8767                     jit.move(GPRInfo::returnValueGPR, scratchGPR1);
 8768                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8769                     argumentsLateRep.emitRestore(jit, argumentsGPR);
 8770                     emitSetVarargsFrame(jit, scratchGPR1, false, scratchGPR2, scratchGPR2);
</pre>
<hr />
<pre>
 8871         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 8872             intptr_t offsetFromSP =
 8873                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 8874             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 8875         };
 8876 
 8877         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 8878         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 8879         for (unsigned i = 0; i &lt; numArgs; ++i)
 8880             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 8881 
 8882         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8883         patchpoint-&gt;appendVector(arguments);
 8884 
 8885         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8886 
 8887         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8888         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8889         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8890         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified"> 8891         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
 8892 
 8893         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8894         State* state = &amp;m_ftlState;
 8895         VM&amp; vm = this-&gt;vm();
 8896         patchpoint-&gt;setGenerator(
 8897             [=, &amp;vm] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8898                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8899                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8900 
 8901                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8902 
 8903                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8904 
 8905                 jit.store32(
 8906                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8907                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8908 
 8909                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8910                 callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, node-&gt;origin.semantic, GPRInfo::regT0);
 8911 
</pre>
<hr />
<pre>
 8974 
 8975         vmCall(
 8976             Void, m_out.operation(operationLoadVarargs), m_callFrame,
 8977             m_out.castToInt32(machineStart), jsArguments, m_out.constInt32(data-&gt;offset),
 8978             length, m_out.constInt32(data-&gt;mandatoryMinimum));
 8979     }
 8980 
 8981     void compileForwardVarargs()
 8982     {
 8983         if (m_node-&gt;child1()) {
 8984             Node* arguments = m_node-&gt;child1().node();
 8985             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 8986                 compileForwardVarargsWithSpread();
 8987                 return;
 8988             }
 8989         }
 8990 
 8991         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8992         InlineCallFrame* inlineCallFrame;
 8993         if (m_node-&gt;child1())
<span class="line-modified"> 8994             inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 8995         else
<span class="line-modified"> 8996             inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();</span>
 8997 
 8998         LValue length = nullptr;
 8999         LValue lengthIncludingThis = nullptr;
 9000         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
 9001         if (argumentsLength.isKnown) {
 9002             unsigned knownLength = argumentsLength.known;
 9003             if (knownLength &gt;= data-&gt;offset)
 9004                 knownLength = knownLength - data-&gt;offset;
 9005             else
 9006                 knownLength = 0;
 9007             length = m_out.constInt32(knownLength);
 9008             lengthIncludingThis = m_out.constInt32(knownLength + 1);
 9009         } else {
 9010             // We need to perform the same logical operation as the code above, but through dynamic operations.
 9011             if (!data-&gt;offset)
 9012                 length = argumentsLength.value;
 9013             else {
 9014                 LBasicBlock isLarger = m_out.newBlock();
 9015                 LBasicBlock continuation = m_out.newBlock();
 9016 
</pre>
<hr />
<pre>
 9123                 return;
 9124             }
 9125 
 9126             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 9127                 BitVector* bitVector = target-&gt;bitVector();
 9128                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {
 9129                     if (bitVector-&gt;get(i))
 9130                         self(m_graph.varArgChild(target, i).node());
 9131                     else
 9132                         ++numberOfStaticArguments;
 9133                 }
 9134                 return;
 9135             }
 9136 
 9137             if (target-&gt;op() == PhantomNewArrayBuffer) {
 9138                 numberOfStaticArguments += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 9139                 return;
 9140             }
 9141 
 9142             ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 9143             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
 9144             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 9145             spreadLengths.append(cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 9146                 return this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 9147             }).iterator-&gt;value);
 9148         });
 9149 
 9150         collectArgumentCount(arguments);
 9151         LValue lengthIncludingThis = m_out.constInt32(1 + numberOfStaticArguments);
 9152         for (LValue length : spreadLengths)
 9153             lengthIncludingThis = m_out.add(lengthIncludingThis, length);
 9154 
 9155         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 9156         speculate(
 9157             VarargsOverflow, noValue(), nullptr,
 9158             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 9159 
 9160         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 9161 
 9162         LValue targetStart = addressFor(data-&gt;machineStart).value();
 9163 
</pre>
<hr />
<pre>
 9174                         LValue value = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 9175                         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, storeIndex));
 9176                         storeIndex = m_out.add(m_out.constIntPtr(1), storeIndex);
 9177                     }
 9178                 }
 9179                 return storeIndex;
 9180             }
 9181 
 9182             if (target-&gt;op() == PhantomNewArrayBuffer) {
 9183                 auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 9184                 for (unsigned i = 0; i &lt; array-&gt;length(); i++) {
 9185                     // Because forwarded values are drained as JSValue, we should not generate value
 9186                     // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 9187                     int64_t value = JSValue::encode(array-&gt;get(i));
 9188                     m_out.store64(m_out.constInt64(value), m_out.baseIndex(m_heaps.variables, targetStart, storeIndex, JSValue(), (Checked&lt;int32_t&gt;(sizeof(Register)) * i).unsafeGet()));
 9189                 }
 9190                 return m_out.add(m_out.constIntPtr(array-&gt;length()), storeIndex);
 9191             }
 9192 
 9193             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 9194             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
 9195 
 9196             LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, target-&gt;numberOfArgumentsToSkip());
 9197             LValue spreadLength = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 9198 
 9199             LBasicBlock loop = m_out.newBlock();
 9200             LBasicBlock continuation = m_out.newBlock();
 9201             ValueFromBlock startLoadIndex = m_out.anchor(m_out.constIntPtr(0));
 9202             ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 9203             ValueFromBlock startStoreIndexForEnd = m_out.anchor(storeIndex);
 9204 
 9205             m_out.branch(m_out.isZero64(spreadLength), unsure(continuation), unsure(loop));
 9206 
 9207             LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 9208             LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 9209             LValue loadIndex = m_out.phi(Int64, startLoadIndex);
 9210             LValue value = m_out.load64(
 9211                 m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 9212             m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 9213             LValue nextLoadIndex = m_out.add(m_out.constIntPtr(1), loadIndex);
 9214             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
</pre>
<hr />
<pre>
 9525                     jit.mfence();
 9526                     break;
 9527                 case CPUCpuidIntrinsic:
 9528                     jit.cpuid();
 9529                     break;
 9530                 case CPUPauseIntrinsic:
 9531                     jit.pause();
 9532                     break;
 9533                 default:
 9534                     RELEASE_ASSERT_NOT_REACHED();
 9535                 }
 9536             });
 9537             setJSValue(m_out.constInt64(JSValue::encode(jsUndefined())));
 9538             break;
 9539         }
 9540         case CPURdtscIntrinsic: {
 9541             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 9542             patchpoint-&gt;effects = Effects::forCall();
 9543             patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::edx });
 9544             // The low 32-bits of rdtsc go into rax.
<span class="line-modified"> 9545             patchpoint-&gt;resultConstraints = { ValueRep::reg(X86Registers::eax) };</span>
 9546             patchpoint-&gt;setGenerator( [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 9547                 jit.rdtsc();
 9548             });
 9549             setJSValue(boxInt32(patchpoint));
 9550             break;
 9551         }
 9552         default:
 9553             RELEASE_ASSERT_NOT_REACHED();
 9554 
 9555         }
 9556 #endif
 9557     }
 9558 
 9559     void compileThrow()
 9560     {
 9561         LValue error = lowJSValue(m_node-&gt;child1());
 9562         vmCall(Void, m_out.operation(operationThrowDFG), m_callFrame, error);
 9563         // vmCall() does an exception check so we should never reach this.
 9564         m_out.unreachable();
 9565     }
</pre>
<hr />
<pre>
 9899     {
 9900         ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
 9901 
 9902         LBasicBlock isNumberCase = m_out.newBlock();
 9903         LBasicBlock notInt32NumberCase = m_out.newBlock();
 9904         LBasicBlock notNaNCase = m_out.newBlock();
 9905         LBasicBlock convertibleCase = m_out.newBlock();
 9906         LBasicBlock continuation = m_out.newBlock();
 9907 
 9908         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isNumberCase);
 9909 
 9910         LValue key = lowJSValue(m_node-&gt;child1());
 9911         ValueFromBlock fastResult = m_out.anchor(key);
 9912         m_out.branch(isNotNumber(key), unsure(continuation), unsure(isNumberCase));
 9913 
 9914         m_out.appendTo(isNumberCase, notInt32NumberCase);
 9915         m_out.branch(isInt32(key), unsure(continuation), unsure(notInt32NumberCase));
 9916 
 9917         m_out.appendTo(notInt32NumberCase, notNaNCase);
 9918         LValue doubleValue = unboxDouble(key);
<span class="line-added"> 9919         ValueFromBlock normalizedNaNResult = m_out.anchor(m_out.constInt64(JSValue::encode(jsNaN())));</span>
 9920         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue), unsure(continuation), unsure(notNaNCase));
 9921 
 9922         m_out.appendTo(notNaNCase, convertibleCase);
 9923         LValue integerValue = m_out.doubleToInt(doubleValue);
 9924         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
<span class="line-added"> 9925         ValueFromBlock doubleResult = m_out.anchor(key);</span>
 9926         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, integerValueConvertedToDouble), unsure(continuation), unsure(convertibleCase));
 9927 
 9928         m_out.appendTo(convertibleCase, continuation);
<span class="line-modified"> 9929         ValueFromBlock boxedIntResult = m_out.anchor(boxInt32(integerValue));</span>
 9930         m_out.jump(continuation);
 9931 
 9932         m_out.appendTo(continuation, lastNext);
<span class="line-modified"> 9933         setJSValue(m_out.phi(Int64, fastResult, normalizedNaNResult, doubleResult, boxedIntResult));</span>
 9934     }
 9935 
 9936     void compileGetMapBucket()
 9937     {
 9938         LBasicBlock loopStart = m_out.newBlock();
 9939         LBasicBlock loopAround = m_out.newBlock();
 9940         LBasicBlock slowPath = m_out.newBlock();
 9941         LBasicBlock notPresentInTable = m_out.newBlock();
 9942         LBasicBlock notEmptyValue = m_out.newBlock();
 9943         LBasicBlock notDeletedValue = m_out.newBlock();
 9944         LBasicBlock continuation = m_out.newBlock();
 9945 
 9946         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
 9947 
 9948         LValue map;
 9949         if (m_node-&gt;child1().useKind() == MapObjectUse)
 9950             map = lowMapObject(m_node-&gt;child1());
 9951         else if (m_node-&gt;child1().useKind() == SetObjectUse)
 9952             map = lowSetObject(m_node-&gt;child1());
 9953         else
</pre>
<hr />
<pre>
10456                                 generator-&gt;finalize(linkBuffer, linkBuffer);
10457                             });
10458                     });
10459             });
10460 
10461         setJSValue(patchpoint);
10462     }
10463 
10464     void compileHasOwnProperty()
10465     {
10466         LBasicBlock slowCase = m_out.newBlock();
10467         LBasicBlock continuation = m_out.newBlock();
10468         LBasicBlock lastNext = nullptr;
10469 
10470         LValue object = lowObject(m_node-&gt;child1());
10471         LValue uniquedStringImpl;
10472         LValue keyAsValue = nullptr;
10473         switch (m_node-&gt;child2().useKind()) {
10474         case StringUse: {
10475             LBasicBlock isNonEmptyString = m_out.newBlock();
<span class="line-modified">10476             LBasicBlock isAtomString = m_out.newBlock();</span>
10477 
10478             keyAsValue = lowString(m_node-&gt;child2());
10479             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10480 
<span class="line-modified">10481             lastNext = m_out.appendTo(isNonEmptyString, isAtomString);</span>
10482             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
<span class="line-modified">10483             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));</span>
<span class="line-modified">10484             m_out.branch(isNotAtomic, rarely(slowCase), usually(isAtomString));</span>
10485 
<span class="line-modified">10486             m_out.appendTo(isAtomString, slowCase);</span>
10487             break;
10488         }
10489         case SymbolUse: {
10490             keyAsValue = lowSymbol(m_node-&gt;child2());
10491             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl);
10492             lastNext = m_out.insertNewBlocksBefore(slowCase);
10493             break;
10494         }
10495         case UntypedUse: {
10496             LBasicBlock isCellCase = m_out.newBlock();
10497             LBasicBlock isStringCase = m_out.newBlock();
10498             LBasicBlock notStringCase = m_out.newBlock();
10499             LBasicBlock isNonEmptyString = m_out.newBlock();
10500             LBasicBlock isSymbolCase = m_out.newBlock();
10501             LBasicBlock hasUniquedStringImpl = m_out.newBlock();
10502 
10503             keyAsValue = lowJSValue(m_node-&gt;child2());
10504             m_out.branch(isCell(keyAsValue), usually(isCellCase), rarely(slowCase));
10505 
10506             lastNext = m_out.appendTo(isCellCase, isStringCase);
10507             m_out.branch(isString(keyAsValue), unsure(isStringCase), unsure(notStringCase));
10508 
10509             m_out.appendTo(isStringCase, isNonEmptyString);
10510             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10511 
10512             m_out.appendTo(isNonEmptyString, notStringCase);
10513             LValue implFromString = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
10514             ValueFromBlock stringResult = m_out.anchor(implFromString);
<span class="line-modified">10515             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(implFromString, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));</span>
10516             m_out.branch(isNotAtomic, rarely(slowCase), usually(hasUniquedStringImpl));
10517 
10518             m_out.appendTo(notStringCase, isSymbolCase);
10519             m_out.branch(isSymbol(keyAsValue), unsure(isSymbolCase), unsure(slowCase));
10520 
10521             m_out.appendTo(isSymbolCase, hasUniquedStringImpl);
10522             ValueFromBlock symbolResult = m_out.anchor(m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl));
10523             m_out.jump(hasUniquedStringImpl);
10524 
10525             m_out.appendTo(hasUniquedStringImpl, slowCase);
10526             uniquedStringImpl = m_out.phi(pointerType(), stringResult, symbolResult);
10527             break;
10528         }
10529         default:
10530             RELEASE_ASSERT_NOT_REACHED();
10531         }
10532 
10533         ASSERT(keyAsValue);
10534 
<span class="line-modified">10535         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero</span>
10536         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
10537         // ever load the result from the cache if the cache entry matches what we are querying for.
10538         // So we either get super lucky and use zero for the hash and somehow collide with the entity
10539         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
10540         // slow path anyways.
10541         LValue hash = m_out.lShr(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
10542 
10543         LValue structureID = m_out.load32(object, m_heaps.JSCell_structureID);
10544         LValue index = m_out.add(hash, structureID);
10545         index = m_out.zeroExtPtr(m_out.bitAnd(index, m_out.constInt32(HasOwnPropertyCache::mask)));
10546         ASSERT(vm().hasOwnPropertyCache());
10547         LValue cache = m_out.constIntPtr(vm().hasOwnPropertyCache());
10548 
10549         IndexedAbstractHeap&amp; heap = m_heaps.HasOwnPropertyCache;
10550         LValue sameStructureID = m_out.equal(structureID, m_out.load32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfStructureID())));
10551         LValue sameImpl = m_out.equal(uniquedStringImpl, m_out.loadPtr(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfImpl())));
10552         ValueFromBlock fastResult = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfResult())));
10553         LValue cacheHit = m_out.bitAnd(sameStructureID, sameImpl);
10554 
10555         m_out.branch(m_out.notZero32(cacheHit), usually(continuation), rarely(slowCase));
</pre>
<hr />
<pre>
10635             prototypeIsCell = true;
10636         } else {
10637             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
10638             DFG_ASSERT(m_graph, m_node, m_node-&gt;child2().useKind() == UntypedUse);
10639 
10640             value = lowJSValue(m_node-&gt;child1());
10641             prototype = lowJSValue(m_node-&gt;child2());
10642 
10643             valueIsCell = abstractValue(m_node-&gt;child1()).isType(SpecCell);
10644             prototypeIsCell = abstractValue(m_node-&gt;child2()).isType(SpecCell);
10645         }
10646 
10647         bool prototypeIsObject = abstractValue(m_node-&gt;child2()).isType(SpecObject | ~SpecCell);
10648 
10649         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
10650         patchpoint-&gt;appendSomeRegister(value);
10651         patchpoint-&gt;appendSomeRegister(prototype);
10652         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
10653         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
10654         patchpoint-&gt;numGPScratchRegisters = 2;
<span class="line-modified">10655         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
10656         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
10657 
10658         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
10659             preparePatchpointForExceptions(patchpoint);
10660 
10661         patchpoint-&gt;setGenerator(
10662             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10663                 AllowMacroScratchRegisterUsage allowScratch(jit);
10664 
10665                 GPRReg resultGPR = params[0].gpr();
10666                 GPRReg valueGPR = params[1].gpr();
10667                 GPRReg prototypeGPR = params[2].gpr();
10668                 GPRReg scratchGPR = params.gpScratch(0);
10669                 GPRReg scratch2GPR = params.gpScratch(1);
10670 
10671                 CCallHelpers::Jump doneJump;
10672                 if (!valueIsCell) {
10673                     CCallHelpers::Jump isCell = jit.branchIfCell(valueGPR);
10674                     jit.boxBooleanPayload(false, resultGPR);
10675                     doneJump = jit.jump();
</pre>
<hr />
<pre>
11328         }
11329 
11330         m_out.appendTo(dummyDefault, outerContinuation);
11331         m_out.unreachable();
11332 
11333         m_out.appendTo(outerContinuation, outerLastNext);
11334         setJSValue(m_out.phi(pointerType(), results));
11335         mutatorFence();
11336     }
11337 
11338     void compileMaterializeCreateActivation()
11339     {
11340         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
11341 
11342         Vector&lt;LValue, 8&gt; values;
11343         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)
11344             values.append(lowJSValue(m_graph.varArgChild(m_node, 2 + i)));
11345 
11346         LValue scope = lowCell(m_graph.varArgChild(m_node, 1));
11347         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();

11348         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
11349 
11350         LBasicBlock slowPath = m_out.newBlock();
11351         LBasicBlock continuation = m_out.newBlock();
11352 
11353         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
11354 
11355         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
11356             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
11357 
11358         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
11359         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
11360 
11361 
11362         ValueFromBlock fastResult = m_out.anchor(fastObject);
11363         m_out.jump(continuation);
11364 
11365         m_out.appendTo(slowPath, continuation);
11366         // We ensure allocation sinking explictly sets bottom values for all field members.
11367         // Therefore, it doesn&#39;t matter what JSValue we pass in as the initialization value
</pre>
<hr />
<pre>
11515             argument);
11516         setBoolean(result);
11517     }
11518 
11519     void compileRegExpMatchFast()
11520     {
11521         LValue globalObject = lowCell(m_node-&gt;child1());
11522         LValue base = lowRegExpObject(m_node-&gt;child2());
11523         LValue argument = lowString(m_node-&gt;child3());
11524         LValue result = vmCall(
11525             Int64, m_out.operation(operationRegExpMatchFastString), m_callFrame, globalObject,
11526             base, argument);
11527         setJSValue(result);
11528     }
11529 
11530     void compileNewRegexp()
11531     {
11532         FrozenValue* regexp = m_node-&gt;cellOperand();
11533         LValue lastIndex = lowJSValue(m_node-&gt;child1());
11534         ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));

11535 
11536         LBasicBlock slowCase = m_out.newBlock();
11537         LBasicBlock continuation = m_out.newBlock();
11538 
11539         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
11540 
11541         auto structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;regExpStructure());
11542         LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
<span class="line-modified">11543         m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag);</span>
11544         m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);

11545         mutatorFence();
11546         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
11547         m_out.jump(continuation);
11548 
11549         m_out.appendTo(slowCase, continuation);
11550         VM&amp; vm = this-&gt;vm();
11551         RegExp* regexpCell = regexp-&gt;cast&lt;RegExp*&gt;();
11552         LValue slowResultValue = lazySlowPath(
11553             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11554                 return createLazyCallGenerator(vm,
11555                     operationNewRegexpWithLastIndex, locations[0].directGPR(),
11556                     CCallHelpers::TrustedImmPtr(regexpCell), locations[1].directGPR());
11557             }, lastIndex);
11558         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
11559         m_out.jump(continuation);
11560 
11561         m_out.appendTo(continuation, lastNext);
11562         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
11563     }
11564 
</pre>
<hr />
<pre>
11610             pointerType(), m_out.operation(operationStringProtoFuncReplaceGeneric), m_callFrame,
11611             lowJSValue(m_node-&gt;child1()), search,
11612             lowJSValue(m_node-&gt;child3()));
11613 
11614         setJSValue(result);
11615     }
11616 
11617     void compileGetRegExpObjectLastIndex()
11618     {
11619         setJSValue(m_out.load64(lowRegExpObject(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex));
11620     }
11621 
11622     void compileSetRegExpObjectLastIndex()
11623     {
11624         if (!m_node-&gt;ignoreLastIndexIsWritable()) {
11625             LValue regExp = lowRegExpObject(m_node-&gt;child1());
11626             LValue value = lowJSValue(m_node-&gt;child2());
11627 
11628             speculate(
11629                 ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">11630                 m_out.testNonZeroPtr(</span>
<span class="line-added">11631                     m_out.loadPtr(regExp, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag),</span>
<span class="line-added">11632                     m_out.constIntPtr(RegExpObject::lastIndexIsNotWritableFlag)));</span>
11633 
11634             m_out.store64(value, regExp, m_heaps.RegExpObject_lastIndex);
11635             return;
11636         }
11637 
11638         m_out.store64(lowJSValue(m_node-&gt;child2()), lowCell(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex);
11639     }
11640 
11641     void compileLogShadowChickenPrologue()
11642     {
11643         LValue packet = ensureShadowChickenPacket();
11644         LValue scope = lowCell(m_node-&gt;child1());
11645 
11646         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
11647         m_out.storePtr(m_out.loadPtr(addressFor(0)), packet, m_heaps.ShadowChicken_Packet_callerFrame);
11648         m_out.storePtr(m_out.loadPtr(payloadFor(CallFrameSlot::callee)), packet, m_heaps.ShadowChicken_Packet_callee);
11649         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
11650     }
11651 
11652     void compileLogShadowChickenTail()
</pre>
<hr />
<pre>
11709             length.known = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
11710             length.isKnown = true;
11711             length.value = m_out.constInt32(length.known);
11712         } else {
11713             length.known = UINT_MAX;
11714             length.isKnown = false;
11715 
11716             VirtualRegister argumentCountRegister;
11717             if (!inlineCallFrame)
11718                 argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
11719             else
11720                 argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
11721             length.value = m_out.sub(m_out.load32(payloadFor(argumentCountRegister)), m_out.int32One);
11722         }
11723 
11724         return length;
11725     }
11726 
11727     ArgumentsLength getArgumentsLength()
11728     {
<span class="line-modified">11729         return getArgumentsLength(m_node-&gt;origin.semantic.inlineCallFrame());</span>
11730     }
11731 
11732     LValue getCurrentCallee()
11733     {
<span class="line-modified">11734         if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame()) {</span>
11735             if (frame-&gt;isClosureCall)
11736                 return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
11737             return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
11738         }
11739         return m_out.loadPtr(addressFor(CallFrameSlot::callee));
11740     }
11741 
11742     LValue getArgumentsStart(InlineCallFrame* inlineCallFrame, unsigned offset = 0)
11743     {
11744         VirtualRegister start = AssemblyHelpers::argumentsStart(inlineCallFrame) + offset;
11745         return addressFor(start).value();
11746     }
11747 
11748     LValue getArgumentsStart()
11749     {
<span class="line-modified">11750         return getArgumentsStart(m_node-&gt;origin.semantic.inlineCallFrame());</span>
11751     }
11752 
11753     template&lt;typename Functor&gt;
11754     void checkStructure(
11755         LValue structureDiscriminant, const FormattedValue&amp; formattedValue, ExitKind exitKind,
11756         const RegisteredStructureSet&amp; set, const Functor&amp; weakStructureDiscriminant)
11757     {
11758         if (set.isEmpty()) {
11759             terminate(exitKind);
11760             return;
11761         }
11762 
11763         if (set.size() == 1) {
11764             speculate(
11765                 exitKind, formattedValue, 0,
11766                 m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set[0])));
11767             return;
11768         }
11769 
11770         LBasicBlock continuation = m_out.newBlock();
</pre>
<hr />
<pre>
12264         LValue start = lowInt32(m_node-&gt;child2());
12265         LValue end = nullptr;
12266         if (m_node-&gt;child3())
12267             end = lowInt32(m_node-&gt;child3());
12268         else
12269             end = m_out.constInt32(std::numeric_limits&lt;int32_t&gt;::max());
12270         m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropeSlowCase), usually(lengthCheckCase));
12271 
12272         LBasicBlock lastNext = m_out.appendTo(lengthCheckCase, emptyCase);
12273         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
12274         LValue length = m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length);
12275         auto range = populateSliceRange(start, end, length);
12276         LValue from = range.first;
12277         LValue to = range.second;
12278         LValue span = m_out.sub(to, from);
12279         m_out.branch(m_out.lessThanOrEqual(span, m_out.int32Zero), unsure(emptyCase), unsure(notEmptyCase));
12280 
12281         Vector&lt;ValueFromBlock, 5&gt; results;
12282 
12283         m_out.appendTo(emptyCase, notEmptyCase);
<span class="line-modified">12284         results.append(m_out.anchor(weakPointer(jsEmptyString(vm()))));</span>
12285         m_out.jump(continuation);
12286 
12287         m_out.appendTo(notEmptyCase, oneCharCase);
12288         m_out.branch(m_out.equal(span, m_out.int32One), unsure(oneCharCase), unsure(slowCase));
12289 
12290         m_out.appendTo(oneCharCase, is8Bit);
12291         LValue storage = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
12292         m_out.branch(
12293             m_out.testIsZero32(
12294                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
12295                 m_out.constInt32(StringImpl::flagIs8Bit())),
12296             unsure(is16Bit), unsure(is8Bit));
12297 
12298         m_out.appendTo(is8Bit, is16Bit);
12299         ValueFromBlock char8Bit = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, storage, m_out.zeroExtPtr(from))));
12300         m_out.jump(bitsContinuation);
12301 
12302         m_out.appendTo(is16Bit, bigCharacter);
12303         LValue char16BitValue = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(from)));
12304         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
</pre>
<hr />
<pre>
12433         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScopeForHoistingFuncDeclInEval), m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12434     }
12435 
12436     void compileResolveScope()
12437     {
12438         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12439         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScope),
12440             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12441     }
12442 
12443     void compileGetDynamicVar()
12444     {
12445         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12446         setJSValue(vmCall(Int64, m_out.operation(operationGetDynamicVar),
12447             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12448     }
12449 
12450     void compilePutDynamicVar()
12451     {
12452         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">12453         setJSValue(vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict),</span>
12454             m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12455     }
12456 
12457     void compileUnreachable()
12458     {
12459         // It&#39;s so tempting to assert that AI has proved that this is unreachable. But that&#39;s
12460         // simply not a requirement of the Unreachable opcode at all. If you emit an opcode that
12461         // *you* know will not return, then it&#39;s fine to end the basic block with Unreachable
12462         // after that opcode. You don&#39;t have to also prove to AI that your opcode does not return.
12463         // Hence, there is nothing to do here but emit code that will crash, so that we catch
12464         // cases where you said Unreachable but you lied.
12465         //
12466         // It&#39;s also also worth noting that some clients emit this opcode because they&#39;re not 100% sure
12467         // if the code is unreachable, but they would really prefer if we crashed rather than kept going
12468         // if it did turn out to be reachable. Hence, this needs to deterministically crash.
12469 
12470         crash();
12471     }
12472 
12473     void compileCheckSubClass()
</pre>
<hr />
<pre>
12562                 switch (signature-&gt;arguments[index - 1]) {
12563                 case SpecString:
12564                     operands.append(lowString(edge));
12565                     break;
12566                 case SpecInt32Only:
12567                     operands.append(lowInt32(edge));
12568                     break;
12569                 case SpecBoolean:
12570                     operands.append(lowBoolean(edge));
12571                     break;
12572                 default:
12573                     RELEASE_ASSERT_NOT_REACHED();
12574                     break;
12575                 }
12576             }
12577             ++index;
12578         });
12579 
12580         unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
12581         LValue result;
<span class="line-modified">12582         auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);</span>
12583         switch (argumentCountIncludingThis) {
12584         case 1:
<span class="line-modified">12585             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get())), m_callFrame, operands[0]);</span>
12586             break;
12587         case 2:
<span class="line-modified">12588             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get())), m_callFrame, operands[0], operands[1]);</span>
12589             break;
12590         case 3:
<span class="line-modified">12591             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get())), m_callFrame, operands[0], operands[1], operands[2]);</span>
12592             break;
12593         default:
12594             RELEASE_ASSERT_NOT_REACHED();
12595             break;
12596         }
12597 
12598         setJSValue(result);
12599     }
12600 
12601     void compileCallDOMGetter()
12602     {
12603         DOMJIT::CallDOMGetterSnippet* domJIT = m_node-&gt;callDOMGetterData()-&gt;snippet;
12604         if (!domJIT) {
12605             // The following function is not an operation: we directly call a custom accessor getter.
12606             // Since the getter does not have code setting topCallFrame, As is the same to IC, we should set topCallFrame in caller side.
12607             m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));
12608             setJSValue(
12609                 vmCall(Int64, m_out.operation(m_node-&gt;callDOMGetterData()-&gt;customAccessorGetter.retaggedExecutableAddress&lt;CFunctionPtrTag&gt;()),
12610                     m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;callDOMGetterData()-&gt;identifierNumber])));
12611             return;
</pre>
<hr />
<pre>
12616         JSValue baseConstant = m_state.forNode(baseEdge).value();
12617 
12618         LValue globalObject;
12619         JSValue globalObjectConstant;
12620         if (domJIT-&gt;requireGlobalObject) {
12621             Edge&amp; globalObjectEdge = m_node-&gt;child2();
12622             globalObject = lowCell(globalObjectEdge);
12623             globalObjectConstant = m_state.forNode(globalObjectEdge).value();
12624         }
12625 
12626         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12627         patchpoint-&gt;appendSomeRegister(base);
12628         if (domJIT-&gt;requireGlobalObject)
12629             patchpoint-&gt;appendSomeRegister(globalObject);
12630         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
12631         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
12632         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
12633         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12634         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
12635         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
<span class="line-modified">12636         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
12637 
12638         State* state = &amp;m_ftlState;
12639         Node* node = m_node;
12640         patchpoint-&gt;setGenerator(
12641             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12642                 AllowMacroScratchRegisterUsage allowScratch(jit);
12643 
12644                 Vector&lt;GPRReg&gt; gpScratch;
12645                 Vector&lt;FPRReg&gt; fpScratch;
12646                 Vector&lt;SnippetParams::Value&gt; regs;
12647 
12648                 regs.append(JSValueRegs(params[0].gpr()));
12649                 regs.append(SnippetParams::Value(params[1].gpr(), baseConstant));
12650                 if (domJIT-&gt;requireGlobalObject)
12651                     regs.append(SnippetParams::Value(params[2].gpr(), globalObjectConstant));
12652 
12653                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
12654                     gpScratch.append(params.gpScratch(i));
12655 
12656                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
</pre>
<hr />
<pre>
12732             return m_out.phi(type, bigEndianResult, littleEndianResult);
12733         return nullptr;
12734     }
12735 
12736     void compileDataViewGet()
12737     {
12738         LValue dataView = lowDataViewObject(m_node-&gt;child1());
12739         LValue index = lowInt32(m_node-&gt;child2());
12740         LValue isLittleEndian = nullptr;
12741         if (m_node-&gt;child3())
12742             isLittleEndian = lowBoolean(m_node-&gt;child3());
12743 
12744         DataViewData data = m_node-&gt;dataViewData();
12745 
12746         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
12747         LValue indexToCheck = m_out.zeroExtPtr(index);
12748         if (data.byteSize &gt; 1)
12749             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12750         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12751 
<span class="line-modified">12752         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);</span>
12753 
12754         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12755 
12756         if (m_node-&gt;op() == DataViewGetInt) {
12757             switch (data.byteSize) {
12758             case 1:
12759                 if (data.isSigned)
12760                     setInt32(m_out.load8SignExt32(pointer));
12761                 else
12762                     setInt32(m_out.load8ZeroExt32(pointer));
12763                 break;
12764             case 2: {
12765                 auto emitLittleEndianLoad = [&amp;] {
12766                     if (data.isSigned)
12767                         return m_out.load16SignExt32(pointer);
12768                     return m_out.load16ZeroExt32(pointer);
12769                 };
12770 
12771                 auto emitBigEndianLoad = [&amp;] {
12772                     LValue val = m_out.load16ZeroExt32(pointer);
</pre>
<hr />
<pre>
12891         if (data.byteSize &gt; 1)
12892             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12893         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12894 
12895         Edge&amp; valueEdge = m_graph.varArgChild(m_node, 2);
12896         LValue valueToStore;
12897         switch (valueEdge.useKind()) {
12898         case Int32Use:
12899             valueToStore = lowInt32(valueEdge);
12900             break;
12901         case DoubleRepUse:
12902             valueToStore = lowDouble(valueEdge);
12903             break;
12904         case Int52RepUse:
12905             valueToStore = lowStrictInt52(valueEdge);
12906             break;
12907         default:
12908             RELEASE_ASSERT_NOT_REACHED();
12909         }
12910 
<span class="line-modified">12911         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);</span>
12912         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12913 
12914         if (data.isFloatingPoint) {
12915             if (data.byteSize == 4) {
12916                 valueToStore = m_out.doubleToFloat(valueToStore);
12917 
12918                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12919                     m_out.storeFloat(valueToStore, pointer);
12920                     return nullptr;
12921                 };
12922 
12923                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12924                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12925                     patchpoint-&gt;appendSomeRegister(valueToStore);
12926                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12927                         jit.moveFloatTo32(params[1].fpr(), params[0].gpr());
12928                         jit.byteSwap32(params[0].gpr());
12929                     });
12930                     patchpoint-&gt;effects = Effects::none();
12931                     m_out.store32(patchpoint, pointer);
</pre>
<hr />
<pre>
13222         Node* node = m_node;
13223 
13224         LValue left = lowJSValue(node-&gt;child1());
13225         LValue right = lowJSValue(node-&gt;child2());
13226 
13227         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13228         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13229 
13230         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13231         patchpoint-&gt;appendSomeRegister(left);
13232         patchpoint-&gt;appendSomeRegister(right);
13233         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13234         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13235         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13236             preparePatchpointForExceptions(patchpoint);
13237         patchpoint-&gt;numGPScratchRegisters = 1;
13238         patchpoint-&gt;numFPScratchRegisters = 2;
13239         if (scratchFPRUsage == NeedScratchFPR)
13240             patchpoint-&gt;numFPScratchRegisters++;
13241         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">13242         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
13243         State* state = &amp;m_ftlState;
13244         patchpoint-&gt;setGenerator(
13245             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13246                 AllowMacroScratchRegisterUsage allowScratch(jit);
13247 
13248                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13249                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13250 
13251                 auto generator = Box&lt;BinaryArithOpGenerator&gt;::create(
13252                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13253                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
13254                     params.fpScratch(0), params.fpScratch(1), params.gpScratch(0),
13255                     scratchFPRUsage == NeedScratchFPR ? params.fpScratch(2) : InvalidFPRReg);
13256 
13257                 generator-&gt;generateFastPath(jit);
13258 
13259                 if (generator-&gt;didEmitFastPath()) {
13260                     generator-&gt;endJumpList().link(&amp;jit);
13261                     CCallHelpers::Label done = jit.label();
13262 
</pre>
<hr />
<pre>
13285     template&lt;typename BinaryBitOpGenerator&gt;
13286     void emitBinaryBitOpSnippet(J_JITOperation_EJJ slowPathFunction)
13287     {
13288         Node* node = m_node;
13289 
13290         LValue left = lowJSValue(node-&gt;child1());
13291         LValue right = lowJSValue(node-&gt;child2());
13292 
13293         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13294         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13295 
13296         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13297         patchpoint-&gt;appendSomeRegister(left);
13298         patchpoint-&gt;appendSomeRegister(right);
13299         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13300         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13301         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13302             preparePatchpointForExceptions(patchpoint);
13303         patchpoint-&gt;numGPScratchRegisters = 1;
13304         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">13305         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
13306         State* state = &amp;m_ftlState;
13307         patchpoint-&gt;setGenerator(
13308             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13309                 AllowMacroScratchRegisterUsage allowScratch(jit);
13310 
13311                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13312                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13313 
13314                 auto generator = Box&lt;BinaryBitOpGenerator&gt;::create(
13315                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13316                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.gpScratch(0));
13317 
13318                 generator-&gt;generateFastPath(jit);
13319                 generator-&gt;endJumpList().link(&amp;jit);
13320                 CCallHelpers::Label done = jit.label();
13321 
13322                 params.addLatePath(
13323                     [=] (CCallHelpers&amp; jit) {
13324                         AllowMacroScratchRegisterUsage allowScratch(jit);
13325 
</pre>
<hr />
<pre>
13341 
13342         // FIXME: Make this do exceptions.
13343         // https://bugs.webkit.org/show_bug.cgi?id=151686
13344 
13345         LValue left = lowJSValue(node-&gt;child1());
13346         LValue right = lowJSValue(node-&gt;child2());
13347 
13348         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13349         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13350 
13351         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13352         patchpoint-&gt;appendSomeRegister(left);
13353         patchpoint-&gt;appendSomeRegister(right);
13354         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13355         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13356         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13357             preparePatchpointForExceptions(patchpoint);
13358         patchpoint-&gt;numGPScratchRegisters = 1;
13359         patchpoint-&gt;numFPScratchRegisters = 1;
13360         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">13361         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
13362         State* state = &amp;m_ftlState;
13363         patchpoint-&gt;setGenerator(
13364             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13365                 AllowMacroScratchRegisterUsage allowScratch(jit);
13366 
13367                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13368                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13369 
13370                 auto generator = Box&lt;JITRightShiftGenerator&gt;::create(
13371                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13372                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
13373                     params.fpScratch(0), params.gpScratch(0), InvalidFPRReg, shiftType);
13374 
13375                 generator-&gt;generateFastPath(jit);
13376                 generator-&gt;endJumpList().link(&amp;jit);
13377                 CCallHelpers::Label done = jit.label();
13378 
13379                 params.addLatePath(
13380                     [=] (CCallHelpers&amp; jit) {
13381                         AllowMacroScratchRegisterUsage allowScratch(jit);
</pre>
<hr />
<pre>
13422                 m_out.notEqual(allocator, m_out.intPtrZero),
13423                 usually(haveAllocator), rarely(slowPath));
13424             m_out.appendTo(haveAllocator, lastNext);
13425         }
13426 
13427         LBasicBlock continuation = m_out.newBlock();
13428 
13429         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13430 
13431         PatchpointValue* patchpoint = m_out.patchpoint(pointerType());
13432         if (isARM64()) {
13433             // emitAllocateWithNonNullAllocator uses the scratch registers on ARM.
13434             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13435         }
13436         patchpoint-&gt;effects.terminal = true;
13437         if (actualAllocator.isConstant())
13438             patchpoint-&gt;numGPScratchRegisters++;
13439         else
13440             patchpoint-&gt;appendSomeRegisterWithClobber(allocator);
13441         patchpoint-&gt;numGPScratchRegisters++;
<span class="line-modified">13442         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
13443 
13444         m_out.appendSuccessor(usually(continuation));
13445         m_out.appendSuccessor(rarely(slowPath));
13446 
13447         patchpoint-&gt;setGenerator(
13448             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13449                 AllowMacroScratchRegisterUsageIf allowScratchIf(jit, isARM64());
13450                 CCallHelpers::JumpList jumpToSlowPath;
13451 
13452                 GPRReg allocatorGPR;
13453                 if (actualAllocator.isConstant())
13454                     allocatorGPR = params.gpScratch(1);
13455                 else
13456                     allocatorGPR = params[1].gpr();
13457 
13458                 // We use a patchpoint to emit the allocation path because whenever we mess with
13459                 // allocation paths, we already reason about them at the machine code level. We know
13460                 // exactly what instruction sequence we want. We&#39;re confident that no compiler
13461                 // optimization could make this code better. So, it&#39;s best to have the code in
13462                 // AssemblyHelpers::emitAllocate(). That way, the same optimized path is shared by
</pre>
<hr />
<pre>
13862 
13863         return result;
13864     }
13865 
13866     LValue boolify(Edge edge)
13867     {
13868         switch (edge.useKind()) {
13869         case BooleanUse:
13870         case KnownBooleanUse:
13871             return lowBoolean(edge);
13872         case Int32Use:
13873             return m_out.notZero32(lowInt32(edge));
13874         case DoubleRepUse:
13875             return m_out.doubleNotEqualAndOrdered(lowDouble(edge), m_out.doubleZero);
13876         case ObjectOrOtherUse:
13877             return m_out.logicalNot(
13878                 equalNullOrUndefined(
13879                     edge, CellCaseSpeculatesObject, SpeculateNullOrUndefined,
13880                     ManualOperandSpeculation));
13881         case StringUse:
<span class="line-modified">13882             return m_out.notEqual(lowString(edge), weakPointer(jsEmptyString(m_graph.m_vm)));</span>
13883         case StringOrOtherUse: {
13884             LValue value = lowJSValue(edge, ManualOperandSpeculation);
13885 
13886             LBasicBlock cellCase = m_out.newBlock();
13887             LBasicBlock notCellCase = m_out.newBlock();
13888             LBasicBlock continuation = m_out.newBlock();
13889 
13890             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13891 
13892             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
13893             FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
<span class="line-modified">13894             ValueFromBlock stringResult = m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm))));</span>
13895             m_out.jump(continuation);
13896 
13897             m_out.appendTo(notCellCase, continuation);
13898             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
13899             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
13900             m_out.jump(continuation);
13901 
13902             m_out.appendTo(continuation, lastNext);
13903             return m_out.phi(Int32, stringResult, notCellResult);
13904         }
13905         case UntypedUse: {
13906             LValue value = lowJSValue(edge);
13907 
13908             // Implements the following control flow structure:
13909             // if (value is cell) {
13910             //     if (value is string or value is BigInt)
13911             //         result = !!value-&gt;length
13912             //     else {
13913             //         do evil things for masquerades-as-undefined
13914             //         result = true
</pre>
<hr />
<pre>
13931             LBasicBlock notInt32Case = m_out.newBlock();
13932             LBasicBlock doubleCase = m_out.newBlock();
13933             LBasicBlock notDoubleCase = m_out.newBlock();
13934             LBasicBlock continuation = m_out.newBlock();
13935 
13936             Vector&lt;ValueFromBlock&gt; results;
13937 
13938             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13939 
13940             LBasicBlock lastNext = m_out.appendTo(cellCase, notStringCase);
13941             m_out.branch(
13942                 isString(value, provenType(edge) &amp; SpecCell),
13943                 unsure(stringCase), unsure(notStringCase));
13944 
13945             m_out.appendTo(notStringCase, stringCase);
13946             m_out.branch(
13947                 isBigInt(value, provenType(edge) &amp; (SpecCell - SpecString)),
13948                 unsure(bigIntCase), unsure(notStringOrBigIntCase));
13949 
13950             m_out.appendTo(stringCase, bigIntCase);
<span class="line-modified">13951             results.append(m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm)))));</span>
13952             m_out.jump(continuation);
13953 
13954             m_out.appendTo(bigIntCase, notStringOrBigIntCase);
13955             LValue nonZeroBigInt = m_out.notZero32(
13956                 m_out.load32NonNegative(value, m_heaps.JSBigInt_length));
13957             results.append(m_out.anchor(nonZeroBigInt));
13958             m_out.jump(continuation);
13959 
13960             m_out.appendTo(notStringOrBigIntCase, notCellCase);
13961             LValue isTruthyObject;
13962             if (masqueradesAsUndefinedWatchpointIsStillValid())
13963                 isTruthyObject = m_out.booleanTrue;
13964             else {
13965                 LBasicBlock masqueradesCase = m_out.newBlock();
13966 
13967                 results.append(m_out.anchor(m_out.booleanTrue));
13968 
13969                 m_out.branch(
13970                     m_out.testIsZero32(
13971                         m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
</pre>
<hr />
<pre>
14139                 LBasicBlock innerLastNext = m_out.appendTo(outOfBoundsCase, holeCase);
14140 
14141                 vmCall(
14142                     Void, m_out.operation(slowPathFunction),
14143                     m_callFrame, base, index, value);
14144 
14145                 m_out.jump(continuation);
14146 
14147                 m_out.appendTo(holeCase, innerLastNext);
14148             }
14149 
14150             m_out.store32(
14151                 m_out.add(index, m_out.int32One),
14152                 storage, m_heaps.Butterfly_publicLength);
14153 
14154             m_out.jump(performStore);
14155             m_out.appendTo(performStore, lastNext);
14156         }
14157     }
14158 
<span class="line-modified">14159     LValue untagArrayPtr(LValue ptr, LValue size)</span>
14160     {
<span class="line-added">14161 #if CPU(ARM64E)</span>
<span class="line-added">14162         PatchpointValue* authenticate = m_out.patchpoint(pointerType());</span>
<span class="line-added">14163         authenticate-&gt;appendSomeRegister(ptr);</span>
<span class="line-added">14164         authenticate-&gt;append(size, B3::ValueRep(B3::ValueRep::SomeLateRegister));</span>
<span class="line-added">14165         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">14166             jit.move(params[1].gpr(), params[0].gpr());</span>
<span class="line-added">14167             jit.untagArrayPtr(params[2].gpr(), params[0].gpr());</span>
<span class="line-added">14168         });</span>
<span class="line-added">14169         return authenticate;</span>
<span class="line-added">14170 #else</span>
<span class="line-added">14171         UNUSED_PARAM(size);</span>
<span class="line-added">14172         return ptr;</span>
<span class="line-added">14173 #endif</span>
<span class="line-added">14174     }</span>
<span class="line-added">14175 </span>
<span class="line-added">14176     LValue removeArrayPtrTag(LValue ptr)</span>
<span class="line-added">14177     {</span>
<span class="line-added">14178 #if CPU(ARM64E)</span>
<span class="line-added">14179         PatchpointValue* authenticate = m_out.patchpoint(pointerType());</span>
<span class="line-added">14180         authenticate-&gt;appendSomeRegister(ptr);</span>
<span class="line-added">14181         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">14182             jit.move(params[1].gpr(), params[0].gpr());</span>
<span class="line-added">14183             jit.removeArrayPtrTag(params[0].gpr());</span>
<span class="line-added">14184         });</span>
<span class="line-added">14185         return authenticate;</span>
<span class="line-added">14186 #endif</span>
<span class="line-added">14187         return ptr;</span>
<span class="line-added">14188     }</span>
<span class="line-added">14189 </span>
<span class="line-added">14190     LValue caged(Gigacage::Kind kind, LValue ptr, LValue base)</span>
<span class="line-added">14191     {</span>
<span class="line-added">14192         auto doUntagArrayPtr = [&amp;](LValue taggedPtr) {</span>
<span class="line-added">14193 #if CPU(ARM64E)</span>
<span class="line-added">14194             if (kind == Gigacage::Primitive) {</span>
<span class="line-added">14195                 LValue size = m_out.load32(base, m_heaps.JSArrayBufferView_length);</span>
<span class="line-added">14196                 return untagArrayPtr(taggedPtr, size);</span>
<span class="line-added">14197             }</span>
<span class="line-added">14198             return ptr;</span>
<span class="line-added">14199 #else</span>
<span class="line-added">14200             UNUSED_PARAM(taggedPtr);</span>
<span class="line-added">14201             return ptr;</span>
<span class="line-added">14202 #endif</span>
<span class="line-added">14203         };</span>
<span class="line-added">14204 </span>
14205 #if GIGACAGE_ENABLED
14206         if (!Gigacage::isEnabled(kind))
<span class="line-modified">14207             return doUntagArrayPtr(ptr);</span>
14208 
14209         if (kind == Gigacage::Primitive &amp;&amp; Gigacage::canPrimitiveGigacageBeDisabled()) {
14210             if (vm().primitiveGigacageEnabled().isStillValid())
14211                 m_graph.watchpoints().addLazily(vm().primitiveGigacageEnabled());
14212             else
<span class="line-modified">14213                 return doUntagArrayPtr(ptr);</span>
14214         }
14215 
14216         LValue basePtr = m_out.constIntPtr(Gigacage::basePtr(kind));
14217         LValue mask = m_out.constIntPtr(Gigacage::mask(kind));
14218 
14219         LValue masked = m_out.bitAnd(ptr, mask);
14220         LValue result = m_out.add(masked, basePtr);
14221 
<span class="line-added">14222 #if CPU(ARM64E)</span>
<span class="line-added">14223         if (kind == Gigacage::Primitive) {</span>
<span class="line-added">14224             PatchpointValue* merge = m_out.patchpoint(pointerType());</span>
<span class="line-added">14225             merge-&gt;append(result, B3::ValueRep(B3::ValueRep::SomeLateRegister));</span>
<span class="line-added">14226             merge-&gt;appendSomeRegister(ptr);</span>
<span class="line-added">14227             merge-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">14228                 jit.move(params[2].gpr(), params[0].gpr());</span>
<span class="line-added">14229                 jit.bitFieldInsert64(params[1].gpr(), 0, 64 - MacroAssembler::numberOfPACBits, params[0].gpr());</span>
<span class="line-added">14230             });</span>
<span class="line-added">14231 </span>
<span class="line-added">14232             result = doUntagArrayPtr(merge);</span>
<span class="line-added">14233         }</span>
<span class="line-added">14234 #endif // CPU(ARM64E)</span>
<span class="line-added">14235 </span>
14236         // Make sure that B3 doesn&#39;t try to do smart reassociation of these pointer bits.
14237         // FIXME: In an ideal world, B3 would not do harmful reassociations, and if it did, it would be able
14238         // to undo them during constant hoisting and regalloc. As it stands, if you remove this then Octane
14239         // gets 1.6% slower and Kraken gets 5% slower. It&#39;s all because the basePtr, which is a constant,
14240         // gets reassociated out of the add above and into the address arithmetic. This disables hoisting of
14241         // the basePtr constant. Hoisting that constant is worth a lot more perf than the reassociation. One
14242         // way to make this all work happily is to combine offset legalization with constant hoisting, and
14243         // then teach it reassociation. So, Add(Add(a, b), const) where a is loop-invariant while b isn&#39;t
14244         // will turn into Add(Add(a, const), b) by the constant hoister. We would have to teach B3 to do this
14245         // and possibly other smart things if we want to be able to remove this opaque.
14246         // https://bugs.webkit.org/show_bug.cgi?id=175493
14247         return m_out.opaque(result);



14248 #endif
<span class="line-added">14249 </span>
<span class="line-added">14250         UNUSED_PARAM(kind);</span>
<span class="line-added">14251         UNUSED_PARAM(base);</span>
<span class="line-added">14252         return doUntagArrayPtr(ptr);</span>
14253     }
14254 
14255     void buildSwitch(SwitchData* data, LType type, LValue switchValue)
14256     {
14257         ASSERT(type == pointerType() || type == Int32);
14258 
14259         Vector&lt;SwitchCase&gt; cases;
14260         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
14261             SwitchCase newCase;
14262 
14263             if (type == pointerType()) {
14264                 newCase = SwitchCase(m_out.constIntPtr(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
14265                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
14266             } else if (type == Int32) {
14267                 newCase = SwitchCase(m_out.constInt32(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
14268                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
14269             } else
14270                 CRASH();
14271 
14272             cases.append(newCase);
</pre>
<hr />
<pre>
14774             return Output::StoreDouble;
14775         default:
14776             DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
14777         }
14778     }
14779 
14780     void setIntTypedArrayLoadResult(LValue result, TypedArrayType type, bool canSpeculate = false)
14781     {
14782         if (elementSize(type) &lt; 4 || isSigned(type)) {
14783             setInt32(result);
14784             return;
14785         }
14786 
14787         if (m_node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
14788             speculate(
14789                 Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
14790             setInt32(result);
14791             return;
14792         }
14793 
<span class="line-modified">14794         if (m_node-&gt;shouldSpeculateInt52()) {</span>
14795             setStrictInt52(m_out.zeroExt(result, Int64));
14796             return;
14797         }
14798 
14799         setDouble(m_out.unsignedToDouble(result));
14800     }
14801 
14802     LValue getIntTypedArrayStoreOperand(Edge edge, bool isClamped = false)
14803     {
14804         LValue intValue;
14805         switch (edge.useKind()) {
14806         case Int52RepUse:
14807         case Int32Use: {
14808             if (edge.useKind() == Int32Use)
14809                 intValue = lowInt32(edge);
14810             else
14811                 intValue = m_out.castToInt32(lowStrictInt52(edge));
14812 
14813             if (isClamped) {
14814                 LBasicBlock atLeastZero = m_out.newBlock();
</pre>
<hr />
<pre>
15074                         AllowMacroScratchRegisterUsage allowScratch(jit);
15075                         patchableJump.m_jump.link(&amp;jit);
15076                         unsigned index = state-&gt;jitCode-&gt;lazySlowPaths.size();
15077                         state-&gt;jitCode-&gt;lazySlowPaths.append(nullptr);
15078                         jit.pushToSaveImmediateWithoutTouchingRegisters(
15079                             CCallHelpers::TrustedImm32(index));
15080                         CCallHelpers::Jump generatorJump = jit.jump();
15081 
15082                         // Note that so long as we&#39;re here, we don&#39;t really know if our late path
15083                         // runs before or after any other late paths that we might depend on, like
15084                         // the exception thunk.
15085 
15086                         RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode;
15087                         VM* vm = &amp;state-&gt;graph.m_vm;
15088 
15089                         jit.addLinkTask(
15090                             [=] (LinkBuffer&amp; linkBuffer) {
15091                                 linkBuffer.link(generatorJump,
15092                                     CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(lazySlowPathGenerationThunkGenerator).code()));
15093 
<span class="line-modified">15094                                 std::unique_ptr&lt;LazySlowPath&gt; lazySlowPath = makeUnique&lt;LazySlowPath&gt;();</span>
15095 
15096                                 auto linkedPatchableJump = CodeLocationJump&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump));
15097 
15098                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; linkedDone = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(done);
15099 
15100                                 CallSiteIndex callSiteIndex =
15101                                     jitCode-&gt;common.addUniqueCallSiteIndex(origin);
15102 
15103                                 lazySlowPath-&gt;initialize(
15104                                         linkedPatchableJump, linkedDone,
15105                                         exceptionTarget-&gt;label(linkBuffer), usedRegisters,
15106                                         callSiteIndex, generator);
15107 
15108                                 jitCode-&gt;lazySlowPaths[index] = WTFMove(lazySlowPath);
15109                             });
15110                     });
15111             });
15112         return result;
15113     }
15114 
</pre>
<hr />
<pre>
15474         }
15475 
15476         LoweredNodeValue value = m_jsValueValues.get(edge.node());
15477         if (isValid(value))
15478             return value.value();
15479 
15480         value = m_int32Values.get(edge.node());
15481         if (isValid(value)) {
15482             LValue result = boxInt32(value.value());
15483             setJSValue(edge.node(), result);
15484             return result;
15485         }
15486 
15487         value = m_booleanValues.get(edge.node());
15488         if (isValid(value)) {
15489             LValue result = boxBoolean(value.value());
15490             setJSValue(edge.node(), result);
15491             return result;
15492         }
15493 
<span class="line-modified">15494         DFG_CRASH(m_graph, m_node, makeString(&quot;Value not defined: &quot;, String::number(edge.node()-&gt;index())).ascii().data());</span>
15495         return 0;
15496     }
15497 
15498     LValue lowNotCell(Edge edge)
15499     {
15500         LValue result = lowJSValue(edge, ManualOperandSpeculation);
15501         FTL_TYPE_CHECK(jsValueValue(result), edge, ~SpecCellCheck, isCell(result));
15502         return result;
15503     }
15504 
15505     LValue lowStorage(Edge edge)
15506     {
15507         LoweredNodeValue value = m_storageValues.get(edge.node());
15508         if (isValid(value))
15509             return value.value();
15510 
15511         LValue result = lowCell(edge);
15512         setStorage(edge.node(), result);
15513         return result;
15514     }
</pre>
<hr />
<pre>
15996     }
15997 
15998     LValue isString(LValue cell, SpeculatedType type = SpecFullTop)
15999     {
16000         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecString))
16001             return proven;
16002         return m_out.equal(
16003             m_out.load32(cell, m_heaps.JSCell_structureID),
16004             m_out.constInt32(vm().stringStructure-&gt;id()));
16005     }
16006 
16007     LValue isRopeString(LValue string, Edge edge = Edge())
16008     {
16009         if (edge) {
16010             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
16011                 return m_out.booleanFalse;
16012             if (JSValue value = provenValue(edge)) {
16013                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
16014                     return m_out.booleanFalse;
16015             }
<span class="line-added">16016             String value = edge-&gt;tryGetString(m_graph);</span>
<span class="line-added">16017             if (!value.isNull()) {</span>
<span class="line-added">16018                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.</span>
<span class="line-added">16019                 return m_out.booleanFalse;</span>
<span class="line-added">16020             }</span>
16021         }
16022 
16023         return m_out.testNonZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
16024     }
16025 
16026     LValue isNotRopeString(LValue string, Edge edge = Edge())
16027     {
16028         if (edge) {
16029             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
16030                 return m_out.booleanTrue;
16031             if (JSValue value = provenValue(edge)) {
16032                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
16033                     return m_out.booleanTrue;
16034             }
<span class="line-added">16035             String value = edge-&gt;tryGetString(m_graph);</span>
<span class="line-added">16036             if (!value.isNull()) {</span>
<span class="line-added">16037                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.</span>
<span class="line-added">16038                 return m_out.booleanTrue;</span>
<span class="line-added">16039             }</span>
16040         }
16041 
16042         return m_out.testIsZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
16043     }
16044 
16045     LValue isNotSymbol(LValue cell, SpeculatedType type = SpecFullTop)
16046     {
16047         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecSymbol))
16048             return proven;
16049         return m_out.notEqual(
16050             m_out.load32(cell, m_heaps.JSCell_structureID),
16051             m_out.constInt32(vm().symbolStructure-&gt;id()));
16052     }
16053 
16054     LValue isSymbol(LValue cell, SpeculatedType type = SpecFullTop)
16055     {
16056         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecSymbol))
16057             return proven;
16058         return m_out.equal(
16059             m_out.load32(cell, m_heaps.JSCell_structureID),
</pre>
<hr />
<pre>
16427 
16428         m_out.jump(continuation);
16429         m_out.appendTo(continuation, lastNext);
16430     }
16431 
16432     void speculateStringOrOther(Edge edge)
16433     {
16434         speculateStringOrOther(edge, lowJSValue(edge, ManualOperandSpeculation));
16435     }
16436 
16437     void speculateStringIdent(Edge edge, LValue string, LValue stringImpl)
16438     {
16439         if (!m_interpreter.needsTypeCheck(edge, SpecStringIdent | ~SpecString))
16440             return;
16441 
16442         speculate(BadType, jsValueValue(string), edge.node(), isRopeString(string));
16443         speculate(
16444             BadType, jsValueValue(string), edge.node(),
16445             m_out.testIsZero32(
16446                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
<span class="line-modified">16447                 m_out.constInt32(StringImpl::flagIsAtom())));</span>
16448         m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
16449     }
16450 
16451     void speculateStringIdent(Edge edge)
16452     {
16453         lowStringIdent(edge);
16454     }
16455 
16456     void speculateStringObject(Edge edge)
16457     {
16458         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
16459             return;
16460 
16461         speculateStringObjectForCell(edge, lowCell(edge));
16462     }
16463 
16464     void speculateStringOrStringObject(Edge edge)
16465     {
16466         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
16467             return;
</pre>
<hr />
<pre>
16644     void speculateMisc(Edge edge)
16645     {
16646         if (!m_interpreter.needsTypeCheck(edge))
16647             return;
16648 
16649         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16650         typeCheck(jsValueValue(value), edge, SpecMisc, isNotMisc(value));
16651     }
16652 
16653     void speculateTypedArrayIsNotNeutered(LValue base)
16654     {
16655         LBasicBlock isWasteful = m_out.newBlock();
16656         LBasicBlock continuation = m_out.newBlock();
16657 
16658         LValue mode = m_out.load32(base, m_heaps.JSArrayBufferView_mode);
16659         m_out.branch(m_out.equal(mode, m_out.constInt32(WastefulTypedArray)),
16660             unsure(isWasteful), unsure(continuation));
16661 
16662         LBasicBlock lastNext = m_out.appendTo(isWasteful, continuation);
16663         LValue vector = m_out.loadPtr(base, m_heaps.JSArrayBufferView_vector);
<span class="line-added">16664         // FIXME: We could probably make this a mask.</span>
<span class="line-added">16665         // https://bugs.webkit.org/show_bug.cgi?id=197701</span>
<span class="line-added">16666         vector = removeArrayPtrTag(vector);</span>
16667         speculate(Uncountable, jsValueValue(vector), m_node, m_out.isZero64(vector));
16668         m_out.jump(continuation);
16669 
16670         m_out.appendTo(continuation, lastNext);
16671     }
16672 
16673     bool masqueradesAsUndefinedWatchpointIsStillValid()
16674     {
16675         return m_graph.masqueradesAsUndefinedWatchpointIsStillValid(m_node-&gt;origin.semantic);
16676     }
16677 
16678     LValue loadCellState(LValue base)
16679     {
16680         return m_out.load8ZeroExt32(base, m_heaps.JSCell_cellState);
16681     }
16682 
16683     void emitStoreBarrier(LValue base, bool isFenced)
16684     {
16685         LBasicBlock recheckPath = nullptr;
16686         if (isFenced)
</pre>
<hr />
<pre>
16841             tagFor(CallFrameSlot::argumentCount));
16842     }
16843 
16844     void callPreflight()
16845     {
16846         callPreflight(codeOriginDescriptionOfCallSite());
16847     }
16848 
16849     CodeOrigin codeOriginDescriptionOfCallSite() const
16850     {
16851         CodeOrigin codeOrigin = m_node-&gt;origin.semantic;
16852         if (m_node-&gt;op() == TailCallInlinedCaller
16853             || m_node-&gt;op() == TailCallVarargsInlinedCaller
16854             || m_node-&gt;op() == TailCallForwardVarargsInlinedCaller
16855             || m_node-&gt;op() == DirectTailCallInlinedCaller) {
16856             // This case arises when you have a situation like this:
16857             // foo makes a call to bar, bar is inlined in foo. bar makes a call
16858             // to baz and baz is inlined in bar. And then baz makes a tail-call to jaz,
16859             // and jaz is inlined in baz. We want the callframe for jaz to appear to
16860             // have caller be bar.
<span class="line-modified">16861             codeOrigin = *codeOrigin.inlineCallFrame()-&gt;getCallerSkippingTailCalls();</span>
16862         }
16863 
16864         return codeOrigin;
16865     }
16866 
16867     void callCheck()
16868     {
16869         if (Options::useExceptionFuzz())
16870             m_out.call(Void, m_out.operation(operationExceptionFuzz), m_callFrame);
16871 
16872         LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
16873         LValue hadException = m_out.notZero64(exception);
16874 
16875         CodeOrigin opCatchOrigin;
16876         HandlerInfo* exceptionHandler;
16877         if (m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler)) {
16878             bool exitOK = true;
16879             bool isExceptionHandler = true;
16880             appendOSRExit(
16881                 ExceptionCheck, noValue(), nullptr, hadException,
16882                 m_origin.withForExitAndExitOK(opCatchOrigin, exitOK), isExceptionHandler);
16883             return;
16884         }
16885 
16886         LBasicBlock continuation = m_out.newBlock();
16887 
16888         m_out.branch(
16889             hadException, rarely(m_handleExceptions), usually(continuation));
16890 
16891         m_out.appendTo(continuation);
16892     }
16893 
16894     RefPtr&lt;PatchpointExceptionHandle&gt; preparePatchpointForExceptions(PatchpointValue* value)
16895     {
16896         CodeOrigin opCatchOrigin;
16897         HandlerInfo* exceptionHandler;
16898         bool willCatchException = m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler);
16899         if (!willCatchException)
16900             return PatchpointExceptionHandle::defaultHandle(m_ftlState);
16901 
<span class="line-modified">16902         dataLogLnIf(verboseCompilationEnabled(), &quot;    Patchpoint exception OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());</span>




16903 
16904         bool exitOK = true;
16905         NodeOrigin origin = m_origin.withForExitAndExitOK(opCatchOrigin, exitOK);
16906 
16907         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(noValue(), nullptr);
16908 
16909         // Compute the offset into the StackmapGenerationParams where we will find the exit arguments
16910         // we are about to append. We need to account for both the children we&#39;ve already added, and
16911         // for the possibility of a result value if the patchpoint is not void.
16912         unsigned offset = value-&gt;numChildren();
16913         if (value-&gt;type() != Void)
16914             offset++;
16915 
16916         // Use LateColdAny to ensure that the stackmap arguments interfere with the patchpoint&#39;s
16917         // result and with any late-clobbered registers.
16918         value-&gt;appendVectorWithRep(
16919             buildExitArguments(exitDescriptor, opCatchOrigin, noValue()),
16920             ValueRep::LateColdAny);
16921 
16922         return PatchpointExceptionHandle::create(
</pre>
<hr />
<pre>
16936     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile)
16937     {
16938         return &amp;m_ftlState.jitCode-&gt;osrExitDescriptors.alloc(
16939             lowValue.format(), profile,
16940             availabilityMap().m_locals.numberOfArguments(),
16941             availabilityMap().m_locals.numberOfLocals());
16942     }
16943 
16944     void appendOSRExit(
16945         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition,
16946         NodeOrigin origin, bool isExceptionHandler = false)
16947     {
16948         return appendOSRExit(kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue),
16949             failCondition, origin, isExceptionHandler);
16950     }
16951 
16952     void appendOSRExit(
16953         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition,
16954         NodeOrigin origin, bool isExceptionHandler = false)
16955     {
<span class="line-modified">16956         dataLogLnIf(verboseCompilationEnabled(), &quot;    OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());</span>




16957 
16958         DFG_ASSERT(m_graph, m_node, origin.exitOK);
16959 
16960         if (!isExceptionHandler
16961             &amp;&amp; Options::useOSRExitFuzz()
16962             &amp;&amp; canUseOSRExitFuzzing(m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic))
16963             &amp;&amp; doOSRExitFuzzing()) {
16964             LValue numberOfFuzzChecks = m_out.add(
16965                 m_out.load32(m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks)),
16966                 m_out.int32One);
16967 
16968             m_out.store32(numberOfFuzzChecks, m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks));
16969 
16970             if (unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter()) {
16971                 failCondition = m_out.bitOr(
16972                     failCondition,
16973                     m_out.aboveOrEqual(numberOfFuzzChecks, m_out.constInt32(atOrAfter)));
16974             }
16975             if (unsigned at = Options::fireOSRExitFuzzAt()) {
16976                 failCondition = m_out.bitOr(
</pre>
<hr />
<pre>
17130 
17131         if (node) {
17132             switch (node-&gt;op()) {
17133             case BottomValue:
17134                 // This might arise in object materializations. I actually doubt that it would,
17135                 // but it seems worthwhile to be conservative.
17136                 return ExitValue::dead();
17137 
17138             case JSConstant:
17139             case Int52Constant:
17140             case DoubleConstant:
17141                 return ExitValue::constant(node-&gt;asJSValue());
17142 
17143             default:
17144                 if (node-&gt;isPhantomAllocation())
17145                     return ExitValue::materializeNewObject(map.get(node));
17146                 break;
17147             }
17148         }
17149 












17150         LoweredNodeValue value = m_int32Values.get(node);
17151         if (isValid(value))
17152             return exitArgument(arguments, DataFormatInt32, value.value());
17153 
17154         value = m_int52Values.get(node);
17155         if (isValid(value))
17156             return exitArgument(arguments, DataFormatInt52, value.value());
17157 
17158         value = m_strictInt52Values.get(node);
17159         if (isValid(value))
17160             return exitArgument(arguments, DataFormatStrictInt52, value.value());
17161 
17162         value = m_booleanValues.get(node);
17163         if (isValid(value))
17164             return exitArgument(arguments, DataFormatBoolean, value.value());
17165 
17166         value = m_jsValueValues.get(node);
17167         if (isValid(value))
17168             return exitArgument(arguments, DataFormatJS, value.value());
17169 
</pre>
<hr />
<pre>
17196         default:
17197             break;
17198         }
17199 
17200         LoweredNodeValue value = m_jsValueValues.get(node);
17201         if (isValid(value))
17202             return exitArgument(arguments, DataFormatJS, value.value());
17203 
17204         value = m_int32Values.get(node);
17205         if (isValid(value))
17206             return exitArgument(arguments, DataFormatJS, boxInt32(value.value()));
17207 
17208         value = m_booleanValues.get(node);
17209         if (isValid(value))
17210             return exitArgument(arguments, DataFormatJS, boxBoolean(value.value()));
17211 
17212         // Doubles and Int52 have been converted by ValueRep()
17213         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
17214     }
17215 












17216     void setInt32(Node* node, LValue value)
17217     {
17218         m_int32Values.set(node, LoweredNodeValue(value, m_highBlock));
17219     }
17220     void setInt52(Node* node, LValue value)
17221     {
17222         m_int52Values.set(node, LoweredNodeValue(value, m_highBlock));
17223     }
17224     void setStrictInt52(Node* node, LValue value)
17225     {
17226         m_strictInt52Values.set(node, LoweredNodeValue(value, m_highBlock));
17227     }
17228     void setInt52(Node* node, LValue value, Int52Kind kind)
17229     {
17230         switch (kind) {
17231         case Int52:
17232             setInt52(node, value);
17233             return;
17234 
17235         case StrictInt52:
</pre>
<hr />
<pre>
17286     }
17287     void setDouble(LValue value)
17288     {
17289         setDouble(m_node, value);
17290     }
17291 
17292     bool isValid(const LoweredNodeValue&amp; value)
17293     {
17294         if (!value)
17295             return false;
17296         if (!m_graph.m_ssaDominators-&gt;dominates(value.block(), m_highBlock))
17297             return false;
17298         return true;
17299     }
17300 
17301     void keepAlive(LValue value)
17302     {
17303         PatchpointValue* patchpoint = m_out.patchpoint(Void);
17304         patchpoint-&gt;effects = Effects::none();
17305         patchpoint-&gt;effects.writesLocalState = true;
<span class="line-added">17306         patchpoint-&gt;effects.reads = HeapRange::top();</span>
17307         patchpoint-&gt;append(value, ValueRep::ColdAny);
17308         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
17309     }
17310 
17311     void addWeakReference(JSCell* target)
17312     {
17313         m_graph.m_plan.weakReferences().addLazily(target);
17314     }
17315 
17316     LValue loadStructure(LValue value)
17317     {
17318         LValue structureID = m_out.load32(value, m_heaps.JSCell_structureID);
17319         LValue tableBase = m_out.loadPtr(m_out.absolute(vm().heap.structureIDTable().base()));
17320         LValue tableIndex = m_out.aShr(structureID, m_out.constInt32(StructureIDTable::s_numberOfEntropyBits));
17321         LValue entropyBits = m_out.shl(m_out.zeroExtPtr(structureID), m_out.constInt32(StructureIDTable::s_entropyBitsShiftForStructurePointer));
17322         TypedPointer address = m_out.baseIndex(m_heaps.structureTable, tableBase, m_out.zeroExtPtr(tableIndex));
17323         LValue encodedStructureBits = m_out.loadPtr(address);
17324         return m_out.bitXor(encodedStructureBits, entropyBits);
17325     }
17326 
</pre>
<hr />
<pre>
17466     LBasicBlock m_handleExceptions;
17467     HashMap&lt;DFG::BasicBlock*, LBasicBlock&gt; m_blocks;
17468 
17469     LValue m_callFrame;
17470     LValue m_captured;
17471     LValue m_tagTypeNumber;
17472     LValue m_tagMask;
17473 
17474     HashMap&lt;Node*, LoweredNodeValue&gt; m_int32Values;
17475     HashMap&lt;Node*, LoweredNodeValue&gt; m_strictInt52Values;
17476     HashMap&lt;Node*, LoweredNodeValue&gt; m_int52Values;
17477     HashMap&lt;Node*, LoweredNodeValue&gt; m_jsValueValues;
17478     HashMap&lt;Node*, LoweredNodeValue&gt; m_booleanValues;
17479     HashMap&lt;Node*, LoweredNodeValue&gt; m_storageValues;
17480     HashMap&lt;Node*, LoweredNodeValue&gt; m_doubleValues;
17481 
17482     HashMap&lt;Node*, LValue&gt; m_phis;
17483 
17484     LocalOSRAvailabilityCalculator m_availabilityCalculator;
17485 


17486     InPlaceAbstractState m_state;
17487     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
17488     DFG::BasicBlock* m_highBlock;
17489     DFG::BasicBlock* m_nextHighBlock;
17490     LBasicBlock m_nextLowBlock;
17491 
17492     enum IndexMaskingMode { IndexMaskingDisabled, IndexMaskingEnabled };
17493 
17494     IndexMaskingMode m_indexMaskingMode;
17495 
17496     NodeOrigin m_origin;
17497     unsigned m_nodeIndex;
17498     Node* m_node;
<span class="line-added">17499 </span>
<span class="line-added">17500     // These are used for validating AI state.</span>
<span class="line-added">17501     HashMap&lt;Node*, NodeSet&gt; m_liveInToNode;</span>
<span class="line-added">17502     HashMap&lt;Node*, AbstractValue&gt; m_aiCheckedNodes;</span>
<span class="line-added">17503     String m_graphDump;</span>
17504 };
17505 
17506 } // anonymous namespace
17507 
17508 void lowerDFGToB3(State&amp; state)
17509 {
17510     LowerDFGToB3 lowering(state);
17511     lowering.lower();
17512 }
17513 
17514 } } // namespace JSC::FTL
17515 
17516 #endif // ENABLE(FTL_JIT)
17517 
</pre>
</td>
</tr>
</table>
<center><a href="FTLLink.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>