<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(VIDEO)
  29 
  30 #include &quot;ActiveDOMObject.h&quot;
  31 #include &quot;ApplicationStateChangeListener.h&quot;
  32 #include &quot;AutoplayEvent.h&quot;
  33 #include &quot;DeferrableTask.h&quot;
  34 #include &quot;GenericEventQueue.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLMediaElementEnums.h&quot;
  37 #include &quot;MediaCanStartListener.h&quot;
  38 #include &quot;MediaControllerInterface.h&quot;
  39 #include &quot;MediaElementSession.h&quot;
  40 #include &quot;MediaPlayer.h&quot;
  41 #include &quot;MediaProducer.h&quot;
  42 #include &quot;VisibilityChangeClient.h&quot;
  43 #include &lt;wtf/Function.h&gt;
  44 #include &lt;wtf/LoggerHelper.h&gt;
  45 #include &lt;wtf/WeakPtr.h&gt;
  46 
  47 #if ENABLE(VIDEO_TRACK)
  48 #include &quot;AudioTrack.h&quot;
  49 #include &quot;CaptionUserPreferences.h&quot;
  50 #include &quot;PODIntervalTree.h&quot;
  51 #include &quot;TextTrack.h&quot;
  52 #include &quot;TextTrackCue.h&quot;
  53 #include &quot;VTTCue.h&quot;
  54 #include &quot;VideoTrack.h&quot;
  55 #endif
  56 
  57 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
  58 #include &quot;AudioSession.h&quot;
  59 #endif
  60 
  61 #if ENABLE(ENCRYPTED_MEDIA)
  62 #include &quot;CDMClient.h&quot;
  63 #endif
  64 
  65 #ifndef NDEBUG
  66 #include &lt;wtf/StringPrintStream.h&gt;
  67 #endif
  68 
  69 namespace PAL {
  70 class SleepDisabler;
  71 }
  72 
  73 namespace WebCore {
  74 
  75 class AudioSourceProvider;
  76 class AudioTrackList;
  77 class AudioTrackPrivate;
  78 class Blob;
  79 class DOMException;
  80 class DOMWrapperWorld;
  81 class DeferredPromise;
  82 class Event;
  83 class HTMLSourceElement;
  84 class HTMLTrackElement;
  85 class InbandTextTrackPrivate;
  86 class JSDOMGlobalObject;
  87 class MediaController;
  88 class MediaControls;
  89 class MediaControlsHost;
  90 class MediaElementAudioSourceNode;
  91 class MediaError;
  92 class MediaKeys;
  93 class MediaResourceLoader;
  94 class MediaSession;
  95 class MediaSource;
  96 class MediaStream;
  97 class RenderMedia;
  98 class ScriptController;
  99 class ScriptExecutionContext;
 100 class SourceBuffer;
 101 class TextTrackList;
 102 class TimeRanges;
 103 class VideoPlaybackQuality;
 104 class VideoTrackList;
 105 class VideoTrackPrivate;
 106 class WebKitMediaKeys;
 107 
 108 template&lt;typename&gt; class DOMPromiseDeferred;
 109 
 110 #if ENABLE(VIDEO_TRACK)
 111 using CueIntervalTree = PODIntervalTree&lt;MediaTime, TextTrackCue*&gt;;
 112 using CueInterval = CueIntervalTree::IntervalType;
 113 using CueList = Vector&lt;CueInterval&gt;;
 114 #endif
 115 
 116 using MediaProvider = Optional&lt;Variant&lt;
 117 #if ENABLE(MEDIA_STREAM)
 118     RefPtr&lt;MediaStream&gt;,
 119 #endif
 120 #if ENABLE(MEDIA_SOURCE)
 121     RefPtr&lt;MediaSource&gt;,
 122 #endif
 123     RefPtr&lt;Blob&gt;&gt;&gt;;
 124 
 125 class HTMLMediaElement
 126     : public HTMLElement
 127     , public ActiveDOMObject
 128     , public MediaControllerInterface
<a name="1" id="anc1"></a><span class="line-removed"> 129     , public CanMakeWeakPtr&lt;HTMLMediaElement&gt;</span>
 130     , public PlatformMediaSessionClient
 131     , private MediaCanStartListener
 132     , private MediaPlayerClient
 133     , private MediaProducer
 134     , private VisibilityChangeClient
 135     , private ApplicationStateChangeListener
 136 #if ENABLE(VIDEO_TRACK)
 137     , private AudioTrackClient
 138     , private TextTrackClient
 139     , private VideoTrackClient
 140 #endif
 141 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 142     , private AudioSession::MutedStateObserver
 143 #endif
 144 #if ENABLE(ENCRYPTED_MEDIA)
 145     , private CDMClient
 146 #endif
 147 #if !RELEASE_LOG_DISABLED
 148     , private LoggerHelper
 149 #endif
 150 {
 151     WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
 152 public:
<a name="2" id="anc2"></a>


 153     RefPtr&lt;MediaPlayer&gt; player() const { return m_player; }
 154 
 155     virtual bool isVideo() const { return false; }
 156     bool hasVideo() const override { return false; }
 157     bool hasAudio() const override;
 158 
 159     static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
 160 
 161     WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
 162 
 163     static bool isRunningDestructor();
 164 
 165     WEBCORE_EXPORT void rewind(double timeDelta);
 166     WEBCORE_EXPORT void returnToRealtime() override;
 167 
 168     // Eventually overloaded in HTMLVideoElement
 169     bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
 170 
 171     bool supportsScanning() const override;
 172 
 173     bool canSaveMediaData() const;
 174 
<a name="3" id="anc3"></a><span class="line-modified"> 175     bool doesHaveAttribute(const AtomicString&amp;, AtomicString* value = nullptr) const override;</span>
 176 
 177     PlatformLayer* platformLayer() const;
 178     bool isVideoLayerInline();
 179     void setPreparedToReturnVideoLayerToInline(bool);
 180     void waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 181 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 182     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 183 #ifdef __OBJC__
 184     PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
 185 #endif
 186     void setVideoFullscreenFrame(FloatRect);
 187     void setVideoFullscreenGravity(MediaPlayerEnums::VideoGravity);
 188     MediaPlayerEnums::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }
 189 #endif
 190 
 191     void scheduleCheckPlaybackTargetCompatability();
 192     void checkPlaybackTargetCompatablity();
 193     void scheduleResolvePendingPlayPromises();
 194     void scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp;);
 195     using PlayPromiseVector = Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;;
 196     void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
 197     void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
 198     void scheduleNotifyAboutPlaying();
 199     void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
 200 
 201     MediaPlayerEnums::MovieLoadType movieLoadType() const;
 202 
 203     bool inActiveDocument() const { return m_inActiveDocument; }
 204 
 205     Document* hostingDocument() const final { return &amp;document(); }
 206 
 207 // DOM API
 208 // error state
 209     WEBCORE_EXPORT MediaError* error() const;
 210 
 211     const URL&amp; currentSrc() const { return m_currentSrc; }
 212 
 213     const MediaProvider&amp; srcObject() const { return m_mediaProvider; }
 214     void setSrcObject(MediaProvider&amp;&amp;);
 215 
<a name="4" id="anc4"></a><span class="line-modified"> 216     WEBCORE_EXPORT void setCrossOrigin(const AtomicString&amp;);</span>
 217     WEBCORE_EXPORT String crossOrigin() const;
 218 
 219 // network state
 220     using HTMLMediaElementEnums::NetworkState;
 221     WEBCORE_EXPORT NetworkState networkState() const;
 222 
 223     WEBCORE_EXPORT String preload() const;
 224     WEBCORE_EXPORT void setPreload(const String&amp;);
 225 
 226     Ref&lt;TimeRanges&gt; buffered() const override;
 227     WEBCORE_EXPORT void load();
 228     WEBCORE_EXPORT String canPlayType(const String&amp; mimeType) const;
 229 
 230 // ready state
 231     using HTMLMediaElementEnums::ReadyState;
 232     ReadyState readyState() const override;
 233     WEBCORE_EXPORT bool seeking() const;
 234 
 235 // playback state
 236     WEBCORE_EXPORT double currentTime() const override;
 237     WEBCORE_EXPORT void setCurrentTime(double) override;
 238     void setCurrentTimeWithTolerance(double, double toleranceBefore, double toleranceAfter);
 239     double currentTimeForBindings() const { return currentTime(); }
 240     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCurrentTimeForBindings(double);
 241     WEBCORE_EXPORT double getStartDate() const;
 242     WEBCORE_EXPORT double duration() const override;
 243     WEBCORE_EXPORT bool paused() const override;
 244     double defaultPlaybackRate() const override;
 245     void setDefaultPlaybackRate(double) override;
 246     WEBCORE_EXPORT double playbackRate() const override;
 247     void setPlaybackRate(double) override;
 248 
 249 // MediaTime versions of playback state
 250     MediaTime currentMediaTime() const;
 251     void setCurrentTime(const MediaTime&amp;);
 252     MediaTime durationMediaTime() const;
 253     WEBCORE_EXPORT void fastSeek(const MediaTime&amp;);
 254 
 255     void updatePlaybackRate();
 256     WEBCORE_EXPORT bool webkitPreservesPitch() const;
 257     WEBCORE_EXPORT void setWebkitPreservesPitch(bool);
 258     Ref&lt;TimeRanges&gt; played() override;
 259     Ref&lt;TimeRanges&gt; seekable() const override;
 260     double seekableTimeRangesLastModifiedTime() const;
 261     double liveUpdateInterval() const;
 262     WEBCORE_EXPORT bool ended() const;
 263     bool autoplay() const;
 264     bool isAutoplaying() const { return m_autoplaying; }
 265     bool loop() const;
 266     void setLoop(bool b);
 267 
 268     void play(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
 269 
 270     WEBCORE_EXPORT void play() override;
 271     WEBCORE_EXPORT void pause() override;
<a name="5" id="anc5"></a><span class="line-removed"> 272     void setShouldBufferData(bool);</span>
<span class="line-removed"> 273     WEBCORE_EXPORT bool shouldBufferData() const { return m_shouldBufferData; }</span>
 274     WEBCORE_EXPORT void fastSeek(double);
 275     double minFastReverseRate() const;
 276     double maxFastForwardRate() const;
 277 
<a name="6" id="anc6"></a><span class="line-modified"> 278     void purgeBufferedDataIfPossible();</span>



 279 
 280 // captions
 281     WEBCORE_EXPORT bool webkitHasClosedCaptions() const;
 282     WEBCORE_EXPORT bool webkitClosedCaptionsVisible() const;
 283     WEBCORE_EXPORT void setWebkitClosedCaptionsVisible(bool);
 284 
 285     bool elementIsHidden() const { return m_elementIsHidden; }
 286 
 287 #if ENABLE(MEDIA_STATISTICS)
 288 // Statistics
 289     unsigned webkitAudioDecodedByteCount() const;
 290     unsigned webkitVideoDecodedByteCount() const;
 291 #endif
 292 
 293 #if ENABLE(MEDIA_SOURCE)
 294 //  Media Source.
 295     void detachMediaSource();
 296     void incrementDroppedFrameCount() { ++m_droppedVideoFrames; }
 297     size_t maximumSourceBufferSize(const SourceBuffer&amp;) const;
 298 #endif
 299 
 300 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 301     WebKitMediaKeys* webkitKeys() const { return m_webKitMediaKeys.get(); }
 302     void webkitSetMediaKeys(WebKitMediaKeys*);
 303 
 304     void keyAdded();
 305 #endif
 306 
 307 #if ENABLE(ENCRYPTED_MEDIA)
 308     MediaKeys* mediaKeys() const;
 309 
 310     void setMediaKeys(MediaKeys*, Ref&lt;DeferredPromise&gt;&amp;&amp;);
 311 #endif
 312 
 313 // controls
 314     WEBCORE_EXPORT bool controls() const;
 315     WEBCORE_EXPORT void setControls(bool);
 316     WEBCORE_EXPORT double volume() const override;
 317     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setVolume(double) override;
 318     WEBCORE_EXPORT bool muted() const override;
 319     WEBCORE_EXPORT void setMuted(bool) override;
 320 
 321     WEBCORE_EXPORT void togglePlayState();
 322     WEBCORE_EXPORT void beginScrubbing() override;
 323     WEBCORE_EXPORT void endScrubbing() override;
 324 
 325     void beginScanning(ScanDirection) override;
 326     void endScanning() override;
 327     double nextScanRate();
 328 
 329     WEBCORE_EXPORT bool canPlay() const override;
 330 
 331     double percentLoaded() const;
 332 
 333     bool shouldForceControlsDisplay() const;
 334 
 335 #if ENABLE(VIDEO_TRACK)
 336     ExceptionOr&lt;TextTrack&amp;&gt; addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language);
 337 
 338     AudioTrackList&amp; ensureAudioTracks();
 339     TextTrackList&amp; ensureTextTracks();
 340     VideoTrackList&amp; ensureVideoTracks();
 341     AudioTrackList* audioTracks() const { return m_audioTracks.get(); }
 342     TextTrackList* textTracks() const { return m_textTracks.get(); }
 343     VideoTrackList* videoTracks() const { return m_videoTracks.get(); }
 344 
 345     CueList currentlyActiveCues() const { return m_currentlyActiveCues; }
 346 
 347     void addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 348     void addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;);
 349     void addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 350     void removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 351     void removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;, bool scheduleEvent = true);
 352     void removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 353     void forgetResourceSpecificTracks();
 354     void closeCaptionTracksChanged();
 355     void notifyMediaPlayerOfTextTrackChanges();
 356 
 357     virtual void didAddTextTrack(HTMLTrackElement&amp;);
 358     virtual void didRemoveTextTrack(HTMLTrackElement&amp;);
 359 
 360     void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) final;
 361     void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) final;
 362     void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) final;
 363     void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) final;
 364     void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) final;
 365     void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) final;
 366 
 367 #if ENABLE(AVF_CAPTIONS)
 368     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources() final;
 369 #endif
 370 
 371     struct TrackGroup;
 372     void configureTextTrackGroupForLanguage(const TrackGroup&amp;) const;
 373     void scheduleConfigureTextTracks();
 374     void configureTextTracks();
 375     void configureTextTrackGroup(const TrackGroup&amp;);
 376 
 377     void setSelectedTextTrack(TextTrack*);
 378 
 379     bool textTracksAreReady() const;
 380     using HTMLMediaElementEnums::TextTrackVisibilityCheckType;
 381     void configureTextTrackDisplay(TextTrackVisibilityCheckType checkType = CheckTextTrackVisibility);
 382     void updateTextTrackDisplay();
 383 
 384     // AudioTrackClient
 385     void audioTrackEnabledChanged(AudioTrack&amp;) final;
 386 
 387     void textTrackReadyStateChanged(TextTrack*);
 388 
 389     // TextTrackClient
 390     void textTrackKindChanged(TextTrack&amp;) override;
 391     void textTrackModeChanged(TextTrack&amp;) override;
 392     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 393     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 394     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) override;
 395     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) override;
 396 
 397     // VideoTrackClient
 398     void videoTrackSelectedChanged(VideoTrack&amp;) final;
 399 
 400     bool requiresTextTrackRepresentation() const;
 401     void setTextTrackRepresentation(TextTrackRepresentation*);
 402     void syncTextTrackBounds();
 403 #endif
 404 
 405 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 406     void webkitShowPlaybackTargetPicker();
<a name="7" id="anc7"></a><span class="line-modified"> 407     bool addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-modified"> 408     bool removeEventListener(const AtomicString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
 409 
 410     void wirelessRoutesAvailableDidChange() override;
 411     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
 412     void setShouldPlayToPlaybackTarget(bool) override;
 413 #endif
 414     bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
 415     void setIsPlayingToWirelessTarget(bool);
 416     bool webkitCurrentPlaybackTargetIsWireless() const;
 417 
 418     void setPlayingOnSecondScreen(bool value);
 419     bool isPlayingOnSecondScreen() const override { return m_playingOnSecondScreen; }
 420 
 421     bool isPlayingToExternalTarget() const { return isPlayingToWirelessPlaybackTarget() || isPlayingOnSecondScreen(); }
 422 
 423     // EventTarget function.
 424     // Both Node (via HTMLElement) and ActiveDOMObject define this method, which
 425     // causes an ambiguity error at compile time. This class&#39;s constructor
 426     // ensures that both implementations return document, so return the result
 427     // of one of them here.
 428     using HTMLElement::scriptExecutionContext;
 429 
 430     bool hasSingleSecurityOrigin() const { return !m_player || m_player-&gt;hasSingleSecurityOrigin(); }
 431     bool didPassCORSAccessCheck() const { return m_player &amp;&amp; m_player-&gt;didPassCORSAccessCheck(); }
 432     bool wouldTaintOrigin(const SecurityOrigin&amp; origin) const { return m_player &amp;&amp; m_player-&gt;wouldTaintOrigin(origin); }
 433 
 434     WEBCORE_EXPORT bool isFullscreen() const override;
 435     bool isStandardFullscreen() const;
 436     void toggleStandardFullscreenState();
 437 
 438     using MediaPlayerEnums::VideoFullscreenMode;
 439     VideoFullscreenMode fullscreenMode() const { return m_videoFullscreenMode; }
 440     virtual void fullscreenModeChanged(VideoFullscreenMode);
 441 
 442     void enterFullscreen(VideoFullscreenMode);
 443     void enterFullscreen() override;
 444     WEBCORE_EXPORT void exitFullscreen();
 445     WEBCORE_EXPORT void setVideoFullscreenStandby(bool);
 446 
 447     bool hasClosedCaptions() const override;
 448     bool closedCaptionsVisible() const override;
 449     void setClosedCaptionsVisible(bool) override;
 450 
 451     MediaControls* mediaControls() const;
 452 
 453     void sourceWasRemoved(HTMLSourceElement&amp;);
 454     void sourceWasAdded(HTMLSourceElement&amp;);
 455 
<a name="8" id="anc8"></a><span class="line-modified"> 456     void privateBrowsingStateDidChange() override;</span>
 457 
 458     // Media cache management.
 459     WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
 460     WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
 461     WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
 462     WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
 463     WEBCORE_EXPORT static void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
 464     static void resetMediaEngines();
 465 
 466     bool isPlaying() const { return m_playing; }
 467 
 468     bool hasPendingActivity() const override;
 469 
 470 #if ENABLE(WEB_AUDIO)
 471     MediaElementAudioSourceNode* audioSourceNode() { return m_audioSourceNode; }
 472     void setAudioSourceNode(MediaElementAudioSourceNode*);
 473 
 474     AudioSourceProvider* audioSourceProvider();
 475 #endif
 476 
 477     using HTMLMediaElementEnums::InvalidURLAction;
 478     bool isSafeToLoadURL(const URL&amp;, InvalidURLAction);
 479 
 480     const String&amp; mediaGroup() const;
 481     void setMediaGroup(const String&amp;);
 482 
 483     MediaController* controller() const;
 484     void setController(RefPtr&lt;MediaController&gt;&amp;&amp;);
 485 
 486     MediaController* controllerForBindings() const { return controller(); }
 487     void setControllerForBindings(MediaController*);
 488 
 489     void enteredOrExitedFullscreen() { configureMediaControls(); }
 490 
 491     unsigned long long fileSize() const;
 492 
 493     void mediaLoadingFailed(MediaPlayerEnums::NetworkState);
 494     void mediaLoadingFailedFatally(MediaPlayerEnums::NetworkState);
 495 
 496 #if ENABLE(MEDIA_SESSION)
 497     WEBCORE_EXPORT double playerVolume() const;
 498 
 499     const String&amp; kind() const { return m_kind; }
 500     void setKind(const String&amp; kind) { m_kind = kind; }
 501 
 502     MediaSession* session() const;
 503     void setSession(MediaSession*);
 504 
 505     void setShouldDuck(bool);
 506 
 507     static HTMLMediaElement* elementWithID(uint64_t);
 508     uint64_t elementID() const { return m_elementID; }
 509 #endif
 510 
 511     RefPtr&lt;VideoPlaybackQuality&gt; getVideoPlaybackQuality();
 512 
 513     MediaPlayerEnums::Preload preloadValue() const { return m_preload; }
 514     MediaElementSession&amp; mediaSession() const { return *m_mediaSession; }
 515 
 516 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 517     void pageScaleFactorChanged();
 518     void userInterfaceLayoutDirectionChanged();
 519     WEBCORE_EXPORT String getCurrentMediaControlsStatus();
 520 
 521     MediaControlsHost* mediaControlsHost() { return m_mediaControlsHost.get(); }
 522 #endif
 523 
 524     bool isDisablingSleep() const { return m_sleepDisabler.get(); }
 525 
 526     double maxBufferedTime() const;
 527 
 528     MediaProducer::MediaStateFlags mediaState() const override;
 529 
 530     void layoutSizeChanged();
 531     void visibilityDidChange();
 532 
 533     void allowsMediaDocumentInlinePlaybackChanged();
 534     void updateShouldPlay();
 535 
 536     RenderMedia* renderer() const;
 537 
 538     void resetPlaybackSessionState();
 539     bool isVisibleInViewport() const;
 540     bool hasEverNotifiedAboutPlaying() const;
 541     void setShouldDelayLoadEvent(bool);
 542 
 543     bool hasEverHadAudio() const { return m_hasEverHadAudio; }
 544     bool hasEverHadVideo() const { return m_hasEverHadVideo; }
 545 
 546     double playbackStartedTime() const { return m_playbackStartedTime; }
 547 
 548     bool isTemporarilyAllowingInlinePlaybackAfterFullscreen() const {return m_temporarilyAllowingInlinePlaybackAfterFullscreen; }
 549 
 550     void isVisibleInViewportChanged();
 551     void updateRateChangeRestrictions();
 552 
 553     WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
 554 
 555 #if ENABLE(MEDIA_STREAM)
 556     void mediaStreamCaptureStarted() { resumeAutoplaying(); }
 557     bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
 558 #endif
 559 
 560     bool supportsSeeking() const override;
 561 
 562 #if !RELEASE_LOG_DISABLED
 563     const Logger&amp; logger() const final { return *m_logger.get(); }
<a name="9" id="anc9"></a><span class="line-modified"> 564     const void* logIdentifier() const final { return reinterpret_cast&lt;const void*&gt;(m_logIdentifier); }</span>

 565     WTFLogChannel&amp; logChannel() const final;
 566 #endif
 567 
 568     bool willLog(WTFLogLevel) const;
 569 
 570     bool isSuspended() const final;
 571 
 572     WEBCORE_EXPORT void didBecomeFullscreenElement() override;
 573     WEBCORE_EXPORT void willExitFullscreen();
 574 
 575     enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
 576 
 577 protected:
 578     HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
 579     virtual void finishInitialization();
 580     virtual ~HTMLMediaElement();
 581 
<a name="10" id="anc10"></a><span class="line-modified"> 582     void parseAttribute(const QualifiedName&amp;, const AtomicString&amp;) override;</span>
 583     void finishParsingChildren() override;
 584     bool isURLAttribute(const Attribute&amp;) const override;
 585     void willAttachRenderers() override;
 586     void didAttachRenderers() override;
 587     void willDetachRenderers() override;
 588     void didDetachRenderers() override;
 589 
 590     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
 591 
 592     enum DisplayMode { Unknown, None, Poster, PosterWaitingForVideo, Video };
 593     DisplayMode displayMode() const { return m_displayMode; }
 594     virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
 595 
 596     bool isMediaElement() const final { return true; }
 597 
 598 #if ENABLE(VIDEO_TRACK)
 599     bool ignoreTrackDisplayUpdateRequests() const { return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueTree.size(); }
 600     void beginIgnoringTrackDisplayUpdateRequests();
 601     void endIgnoringTrackDisplayUpdateRequests();
 602 #endif
 603 
 604     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
 605 
 606 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 607     bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
 608     void setMediaControlsDependOnPageScaleFactor(bool);
 609     void updateMediaControlsAfterPresentationModeChange();
 610 #endif
 611 
<a name="11" id="anc11"></a><span class="line-modified"> 612     void scheduleEvent(const AtomicString&amp; eventName);</span>
 613 
 614 private:
 615     void createMediaPlayer();
 616 
 617     bool supportsFocus() const override;
 618     bool isMouseFocusable() const override;
 619     bool rendererIsNeeded(const RenderStyle&amp;) override;
 620     bool childShouldCreateRenderer(const Node&amp;) const override;
 621     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 622     void didFinishInsertingNode() override;
 623     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
 624     void didRecalcStyle(Style::Change) override;
<a name="12" id="anc12"></a>
 625 
 626     void willBecomeFullscreenElement() override;
 627     void willStopBeingFullscreenElement() override;
 628 
 629     // ActiveDOMObject API.
 630     const char* activeDOMObjectName() const override;
 631     bool canSuspendForDocumentSuspension() const override;
 632     void suspend(ReasonForSuspension) override;
 633     void resume() override;
 634     void stop() override;
 635     void stopWithoutDestroyingMediaPlayer();
 636     void contextDestroyed() override;
 637 
 638     void mediaVolumeDidChange() override;
 639 
 640     void visibilityStateChanged() override;
 641 
 642     virtual void updateDisplayState() { }
 643 
 644     void setReadyState(MediaPlayerEnums::ReadyState);
 645     void setNetworkState(MediaPlayerEnums::NetworkState);
 646 
 647     double effectivePlaybackRate() const;
 648     double requestedPlaybackRate() const;
 649 
 650     void mediaPlayerNetworkStateChanged(MediaPlayer*) override;
 651     void mediaPlayerReadyStateChanged(MediaPlayer*) override;
 652     void mediaPlayerTimeChanged(MediaPlayer*) override;
 653     void mediaPlayerVolumeChanged(MediaPlayer*) override;
 654     void mediaPlayerMuteChanged(MediaPlayer*) override;
 655     void mediaPlayerDurationChanged(MediaPlayer*) override;
 656     void mediaPlayerRateChanged(MediaPlayer*) override;
 657     void mediaPlayerPlaybackStateChanged(MediaPlayer*) override;
 658     void mediaPlayerSawUnsupportedTracks(MediaPlayer*) override;
 659     void mediaPlayerResourceNotSupported(MediaPlayer*) override;
 660     void mediaPlayerRepaint(MediaPlayer*) override;
 661     void mediaPlayerSizeChanged(MediaPlayer*) override;
 662     bool mediaPlayerRenderingCanBeAccelerated(MediaPlayer*) override;
 663     void mediaPlayerRenderingModeChanged(MediaPlayer*) override;
 664     bool mediaPlayerAcceleratedCompositingEnabled() override;
 665     void mediaPlayerEngineUpdated(MediaPlayer*) override;
 666 
 667     void scheduleMediaEngineWasUpdated();
 668     void mediaEngineWasUpdated();
 669 
 670     void mediaPlayerFirstVideoFrameAvailable(MediaPlayer*) override;
 671     void mediaPlayerCharacteristicChanged(MediaPlayer*) override;
 672 
 673 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 674     RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const override;
 675     bool mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array*) override;
 676     String mediaPlayerMediaKeysStorageDirectory() const override;
 677 #endif
 678 
 679 #if ENABLE(ENCRYPTED_MEDIA)
 680     void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) final;
 681     void mediaPlayerWaitingForKeyChanged() final;
 682 
 683     void attemptToDecrypt();
 684     void attemptToResumePlaybackIfNecessary();
 685 
 686     // CDMClient
 687     void cdmClientAttemptToResumePlaybackIfNecessary() final;
 688 #endif
 689 
 690 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 691     void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*) override;
 692     void enqueuePlaybackTargetAvailabilityChangedEvent();
 693 
 694     using EventTarget::dispatchEvent;
 695     void dispatchEvent(Event&amp;) override;
 696 #endif
 697 
 698 #if ENABLE(MEDIA_SESSION)
 699     void setSessionInternal(MediaSession&amp;);
 700 #endif
 701 
 702     String mediaPlayerReferrer() const override;
 703     String mediaPlayerUserAgent() const override;
 704 
 705     void mediaPlayerEnterFullscreen() override;
 706     void mediaPlayerExitFullscreen() override;
 707     bool mediaPlayerIsFullscreen() const override;
 708     bool mediaPlayerIsFullscreenPermitted() const override;
 709     bool mediaPlayerIsVideo() const override;
 710     LayoutRect mediaPlayerContentBoxRect() const override;
 711     float mediaPlayerContentsScale() const override;
 712     void mediaPlayerSetSize(const IntSize&amp;) override;
 713     void mediaPlayerPause() override;
 714     void mediaPlayerPlay() override;
 715     bool mediaPlayerPlatformVolumeConfigurationRequired() const override;
 716     bool mediaPlayerIsPaused() const override;
 717     bool mediaPlayerIsLooping() const override;
 718     CachedResourceLoader* mediaPlayerCachedResourceLoader() override;
 719     RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() override;
 720     bool mediaPlayerShouldUsePersistentCache() const override;
 721     const String&amp; mediaPlayerMediaCacheDirectory() const override;
 722 
 723 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
 724     GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const override;
 725 #endif
 726 
 727     void mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*) override;
 728 
 729     void mediaPlayerHandlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command) override { didReceiveRemoteControlCommand(command, nullptr); }
 730     String sourceApplicationIdentifier() const override;
 731     String mediaPlayerSourceApplicationIdentifier() const override { return sourceApplicationIdentifier(); }
 732     Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const override;
 733 
 734 #if PLATFORM(IOS_FAMILY)
 735     String mediaPlayerNetworkInterfaceName() const override;
 736     bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const override;
 737 #endif
 738 
 739     bool mediaPlayerIsInMediaDocument() const final;
 740     void mediaPlayerEngineFailedToLoad() const final;
 741 
 742     double mediaPlayerRequestedPlaybackRate() const final;
 743     VideoFullscreenMode mediaPlayerFullscreenMode() const final { return fullscreenMode(); }
 744     bool mediaPlayerIsVideoFullscreenStandby() const final { return m_videoFullscreenStandby; }
 745     bool mediaPlayerShouldDisableSleep() const final { return shouldDisableSleep() == SleepType::Display; }
 746     bool mediaPlayerShouldCheckHardwareSupport() const final;
 747     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const final;
 748 
 749 #if USE(GSTREAMER)
 750     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp;) final;
 751 #endif
 752 
 753     void pendingActionTimerFired();
 754     void progressEventTimerFired();
 755     void playbackProgressTimerFired();
 756     void scanTimerFired();
 757     void seekTask();
 758     void startPlaybackProgressTimer();
 759     void startProgressEventTimer();
 760     void stopPeriodicTimers();
 761     void cancelPendingTasks();
 762     void closeTaskQueues();
 763 
 764     void seek(const MediaTime&amp;);
 765     void seekInternal(const MediaTime&amp;);
 766     void seekWithTolerance(const MediaTime&amp;, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM);
 767     void finishSeek();
 768     void clearSeeking();
 769     void addPlayedRange(const MediaTime&amp; start, const MediaTime&amp; end);
 770 
 771     void scheduleTimeupdateEvent(bool periodicEvent);
 772     virtual void scheduleResizeEvent() { }
 773     virtual void scheduleResizeEventIfSizeChanged() { }
 774 
 775     void selectMediaResource();
 776     void loadResource(const URL&amp;, ContentType&amp;, const String&amp; keySystem);
 777     void scheduleNextSourceChild();
 778     void loadNextSourceChild();
 779     void userCancelledLoad();
 780     void clearMediaPlayer();
 781     bool havePotentialSourceChild();
 782     void noneSupported();
 783     void cancelPendingEventsAndCallbacks();
 784     void waitForSourceChange();
 785     void prepareToPlay();
 786 
 787     URL selectNextSourceChild(ContentType*, String* keySystem, InvalidURLAction);
 788 
 789 #if ENABLE(VIDEO_TRACK)
 790     void updateActiveTextTrackCues(const MediaTime&amp;);
 791     HTMLTrackElement* showingTrackWithSameKind(HTMLTrackElement*) const;
 792 
 793     enum ReconfigureMode {
 794         Immediately,
 795         AfterDelay,
 796     };
 797     void markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode);
 798     void captionPreferencesChanged() override;
 799     CaptionUserPreferences::CaptionDisplayMode captionDisplayMode();
 800 #endif
 801 
 802     // These &quot;internal&quot; functions do not check user gesture restrictions.
 803     void playInternal();
 804     void pauseInternal();
 805 
 806     void prepareForLoad();
 807     void allowVideoRendering();
 808 
 809     bool processingMediaPlayerCallback() const { return m_processingMediaPlayerCallback &gt; 0; }
 810     void beginProcessingMediaPlayerCallback() { ++m_processingMediaPlayerCallback; }
 811     void endProcessingMediaPlayerCallback() { ASSERT(m_processingMediaPlayerCallback); --m_processingMediaPlayerCallback; }
 812 
 813     void scheduleUpdatePlayState();
 814     void updatePlayState();
 815 
 816     void updateVolume();
 817     void setPlaying(bool);
 818     bool potentiallyPlaying() const;
 819     bool endedPlayback() const;
 820     bool stoppedDueToErrors() const;
 821     bool pausedForUserInteraction() const;
 822     bool couldPlayIfEnoughData() const;
 823     void dispatchPlayPauseEventsIfNeedsQuirks();
 824     SuccessOr&lt;MediaPlaybackDenialReason&gt; canTransitionFromAutoplayToPlay() const;
 825 
 826     void setAutoplayEventPlaybackState(AutoplayEventPlaybackState);
 827     void userDidInterfereWithAutoplay();
 828     void handleAutoplayEvent(AutoplayEvent);
 829 
 830     MediaTime minTimeSeekable() const;
 831     MediaTime maxTimeSeekable() const;
 832 
 833     // Pauses playback without changing any states or generating events
 834     void setPausedInternal(bool);
 835 
 836     void setPlaybackRateInternal(double);
 837 
 838     void mediaCanStart(Document&amp;) final;
 839 
 840     void invalidateCachedTime() const;
 841     void refreshCachedTime() const;
 842 
 843     bool hasMediaControls() const;
 844     bool createMediaControls();
 845     void configureMediaControls();
 846 
 847     void prepareMediaFragmentURI();
 848     void applyMediaFragmentURI();
 849 
 850     void changeNetworkStateFromLoadingToIdle();
 851 
<a name="13" id="anc13"></a><span class="line-modified"> 852     void removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask = MediaElementSession::AllRestrictions);</span>
 853 
 854     void updateMediaController();
 855     bool isBlocked() const;
 856     bool isBlockedOnMediaController() const;
 857     bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
 858     bool isLiveStream() const override { return movieLoadType() == MediaPlayerEnums::LiveStream; }
 859 
 860     void updateSleepDisabling();
 861     enum class SleepType {
 862         None,
 863         Display,
 864         System,
 865     };
 866     SleepType shouldDisableSleep() const;
 867 
 868 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 869     void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
 870     DOMWrapperWorld&amp; ensureIsolatedWorld();
 871     bool ensureMediaControlsInjectedScript();
 872 #endif
 873 
 874     PlatformMediaSession::MediaType mediaType() const override;
 875     PlatformMediaSession::MediaType presentationType() const override;
 876     PlatformMediaSession::DisplayType displayType() const override;
 877     PlatformMediaSession::CharacteristicsFlags characteristics() const final;
 878 
 879     void suspendPlayback() override;
 880     void resumeAutoplaying() override;
 881     void mayResumePlayback(bool shouldResume) override;
 882     uint64_t mediaSessionUniqueIdentifier() const final;
 883     String mediaSessionTitle() const override;
 884     double mediaSessionDuration() const override { return duration(); }
 885     double mediaSessionCurrentTime() const override { return currentTime(); }
 886     bool canReceiveRemoteControlCommands() const override { return true; }
 887     void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) override;
 888     bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const override;
 889     bool shouldOverrideBackgroundLoadingRestriction() const override;
 890     bool canProduceAudio() const final;
 891     bool processingUserGestureForMedia() const final;
<a name="14" id="anc14"></a>

 892 
 893     void pageMutedStateDidChange() override;
 894 
 895 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 896     void hardwareMutedStateDidChange(AudioSession*) final;
 897 #endif
 898 
 899     bool effectiveMuted() const;
<a name="15" id="anc15"></a>
 900 
 901     void registerWithDocument(Document&amp;);
 902     void unregisterWithDocument(Document&amp;);
 903 
 904     void updateCaptionContainer();
 905     void ensureMediaControlsShadowRoot();
 906 
 907     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::ExecState&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;
 908     bool setupAndCallJS(const JSSetupFunction&amp;);
 909 
 910 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 911     void prepareForDocumentSuspension() final;
 912     void resumeFromDocumentSuspension() final;
 913 
 914     void scheduleUpdateMediaState();
 915     void updateMediaState();
 916     bool hasPlaybackTargetAvailabilityListeners() const { return m_hasPlaybackTargetAvailabilityListeners; }
 917 #endif
 918 
 919     bool isVideoTooSmallForInlinePlayback();
 920     void updateShouldAutoplay();
 921 
 922     void pauseAfterDetachedTask();
 923     void updatePlaybackControlsManager();
 924     void schedulePlaybackControlsManagerUpdate();
 925     void playbackControlsManagerBehaviorRestrictionsTimerFired();
 926 
 927     void updateRenderer();
 928 
 929     void updatePageScaleFactorJSProperty();
 930     void updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
 931     void setControllerJSProperty(const char*, JSC::JSValue);
 932 
 933     void addBehaviorRestrictionsOnEndIfNecessary();
 934     void handleSeekToPlaybackPosition(double);
 935     void seekToPlaybackPositionEndedTimerFired();
 936 
 937     void applicationWillResignActive() final;
 938     void applicationDidBecomeActive() final;
 939 
 940     void setInActiveDocument(bool);
 941 
 942 #if !RELEASE_LOG_DISABLED
<a name="16" id="anc16"></a><span class="line-removed"> 943     const char* logClassName() const final { return &quot;HTMLMediaElement&quot;; }</span>
<span class="line-removed"> 944 </span>
 945     const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
 946     const Logger&amp; mediaPlayerLogger() final { return logger(); }
 947 #endif
 948 
 949     Timer m_progressEventTimer;
 950     Timer m_playbackProgressTimer;
 951     Timer m_scanTimer;
 952     Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
 953     Timer m_seekToPlaybackPositionEndedTimer;
 954     DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
 955     DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
 956     DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
 957     DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
 958     DeferrableTask&lt;Timer&gt; m_updatePlayStateTask;
 959     DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
 960     DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
 961     DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
 962     GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
 963     GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
 964     GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
 965     GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
 966     GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
 967     GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
 968     RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
 969     GenericEventQueue m_asyncEventQueue;
<a name="17" id="anc17"></a>


 970 
 971     PlayPromiseVector m_pendingPlayPromises;
 972 
 973     double m_requestedPlaybackRate { 1 };
 974     double m_reportedPlaybackRate { 1 };
 975     double m_defaultPlaybackRate { 1 };
 976     bool m_webkitPreservesPitch { true };
 977     NetworkState m_networkState { NETWORK_EMPTY };
 978     ReadyState m_readyState { HAVE_NOTHING };
 979     ReadyState m_readyStateMaximum { HAVE_NOTHING };
 980     URL m_currentSrc;
 981 
 982     RefPtr&lt;MediaError&gt; m_error;
 983 
 984     struct PendingSeek {
<a name="18" id="anc18"></a>
 985         PendingSeek(const MediaTime&amp; now, const MediaTime&amp; targetTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 986             : now(now)
 987             , targetTime(targetTime)
 988             , negativeTolerance(negativeTolerance)
 989             , positiveTolerance(positiveTolerance)
 990         {
 991         }
 992         MediaTime now;
 993         MediaTime targetTime;
 994         MediaTime negativeTolerance;
 995         MediaTime positiveTolerance;
 996     };
 997     std::unique_ptr&lt;PendingSeek&gt; m_pendingSeek;
 998     SeekType m_pendingSeekType { NoSeek };
 999 
1000     double m_volume { 1 };
1001     bool m_volumeInitialized { false };
1002     MediaTime m_lastSeekTime;
1003 
1004     MonotonicTime m_previousProgressTime { MonotonicTime::infinity() };
1005     double m_playbackStartedTime { 0 };
1006 
1007     // The last time a timeupdate event was sent (based on monotonic clock).
1008     MonotonicTime m_clockTimeAtLastUpdateEvent;
1009 
1010     // The last time a timeupdate event was sent in movie time.
1011     MediaTime m_lastTimeUpdateEventMovieTime;
1012 
1013     // Loading state.
1014     enum LoadState { WaitingForSource, LoadingFromSrcAttr, LoadingFromSourceElement };
1015     LoadState m_loadState { WaitingForSource };
1016     RefPtr&lt;HTMLSourceElement&gt; m_currentSourceNode;
1017     RefPtr&lt;HTMLSourceElement&gt; m_nextChildNodeToConsider;
1018 
1019     VideoFullscreenMode m_videoFullscreenMode { VideoFullscreenModeNone };
1020     bool m_videoFullscreenStandby { false };
1021     bool m_preparedForInline;
1022     WTF::Function&lt;void()&gt; m_preparedForInlineCompletionHandler;
1023 
1024     bool m_temporarilyAllowingInlinePlaybackAfterFullscreen { false };
1025 
1026 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
1027     RetainPtr&lt;PlatformLayer&gt; m_videoFullscreenLayer;
1028     FloatRect m_videoFullscreenFrame;
1029     MediaPlayerEnums::VideoGravity m_videoFullscreenGravity { MediaPlayer::VideoGravityResizeAspect };
1030 #endif
1031 
1032     RefPtr&lt;MediaPlayer&gt; m_player;
1033 
1034     MediaPlayerEnums::Preload m_preload { MediaPlayer::Auto };
1035 
1036     DisplayMode m_displayMode { Unknown };
1037 
1038     // Counter incremented while processing a callback from the media player, so we can avoid
1039     // calling the media engine recursively.
1040     int m_processingMediaPlayerCallback { 0 };
1041 
1042 #if ENABLE(MEDIA_SESSION)
1043     String m_kind;
1044     RefPtr&lt;MediaSession&gt; m_session;
1045     bool m_shouldDuck { false };
1046     uint64_t m_elementID;
1047 #endif
1048 
1049 #if ENABLE(MEDIA_SOURCE)
1050     RefPtr&lt;MediaSource&gt; m_mediaSource;
1051     unsigned m_droppedVideoFrames { 0 };
1052 #endif
1053 
1054     mutable MediaTime m_cachedTime;
1055     mutable MonotonicTime m_clockTimeAtLastCachedTimeUpdate;
1056     mutable MonotonicTime m_minimumClockTimeToUpdateCachedTime;
1057 
1058     MediaTime m_fragmentStartTime;
1059     MediaTime m_fragmentEndTime;
1060 
1061     using PendingActionFlags = unsigned;
1062     PendingActionFlags m_pendingActionFlags { 0 };
1063 
1064     enum ActionAfterScanType { Nothing, Play, Pause };
1065     ActionAfterScanType m_actionAfterScan { Nothing };
1066 
1067     enum ScanType { Seek, Scan };
1068     ScanType m_scanType { Scan };
1069     ScanDirection m_scanDirection { Forward };
1070 
<a name="19" id="anc19"></a>

1071     bool m_firstTimePlaying : 1;
1072     bool m_playing : 1;
1073     bool m_isWaitingUntilMediaCanStart : 1;
1074     bool m_shouldDelayLoadEvent : 1;
1075     bool m_haveFiredLoadedData : 1;
1076     bool m_inActiveDocument : 1;
1077     bool m_autoplaying : 1;
1078     bool m_muted : 1;
1079     bool m_explicitlyMuted : 1;
1080     bool m_initiallyMuted : 1;
1081     bool m_paused : 1;
1082     bool m_seeking : 1;
1083     bool m_seekRequested : 1;
1084 
1085     // data has not been loaded since sending a &quot;stalled&quot; event
1086     bool m_sentStalledEvent : 1;
1087 
1088     // time has not changed since sending an &quot;ended&quot; event
1089     bool m_sentEndEvent : 1;
1090 
1091     bool m_pausedInternal : 1;
1092 
1093     bool m_closedCaptionsVisible : 1;
1094     bool m_webkitLegacyClosedCaptionOverride : 1;
1095     bool m_completelyLoaded : 1;
1096     bool m_havePreparedToPlay : 1;
1097     bool m_parsingInProgress : 1;
<a name="20" id="anc20"></a><span class="line-removed">1098     bool m_shouldBufferData : 1;</span>
1099     bool m_elementIsHidden : 1;
1100     bool m_elementWasRemovedFromDOM : 1;
1101     bool m_creatingControls : 1;
1102     bool m_receivedLayoutSizeChanged : 1;
1103     bool m_hasEverNotifiedAboutPlaying : 1;
1104 
1105     bool m_hasEverHadAudio : 1;
1106     bool m_hasEverHadVideo : 1;
1107 
1108 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1109     bool m_mediaControlsDependOnPageScaleFactor : 1;
1110     bool m_haveSetUpCaptionContainer : 1;
1111 #endif
1112 
1113     bool m_isScrubbingRemotely : 1;
1114     bool m_waitingToEnterFullscreen : 1;
1115 
1116 #if ENABLE(VIDEO_TRACK)
1117     bool m_tracksAreReady : 1;
1118     bool m_haveVisibleTextTrack : 1;
1119     bool m_processingPreferenceChange : 1;
1120 
1121     AutoplayEventPlaybackState m_autoplayEventPlaybackState { AutoplayEventPlaybackState::None };
1122 
1123     String m_subtitleTrackLanguage;
1124     MediaTime m_lastTextTrackUpdateTime { -1, 1 };
1125 
1126     Optional&lt;CaptionUserPreferences::CaptionDisplayMode&gt; m_captionDisplayMode;
1127 
1128     RefPtr&lt;AudioTrackList&gt; m_audioTracks;
1129     RefPtr&lt;TextTrackList&gt; m_textTracks;
1130     RefPtr&lt;VideoTrackList&gt; m_videoTracks;
1131     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; m_textTracksWhenResourceSelectionBegan;
1132 
1133     CueIntervalTree m_cueTree;
1134 
1135     CueList m_currentlyActiveCues;
1136     int m_ignoreTrackDisplayUpdate { 0 };
1137 
1138     bool m_requireCaptionPreferencesChangedCallbacks { false };
1139 #endif
1140 
1141 #if ENABLE(WEB_AUDIO)
1142     // This is a weak reference, since m_audioSourceNode holds a reference to us.
1143     // The value is set just after the MediaElementAudioSourceNode is created.
1144     // The value is cleared in MediaElementAudioSourceNode::~MediaElementAudioSourceNode().
1145     MediaElementAudioSourceNode* m_audioSourceNode { nullptr };
1146 #endif
1147 
1148     String m_mediaGroup;
1149     friend class MediaController;
1150     RefPtr&lt;MediaController&gt; m_mediaController;
1151 
1152     std::unique_ptr&lt;PAL::SleepDisabler&gt; m_sleepDisabler;
1153 
1154     WeakPtr&lt;const MediaResourceLoader&gt; m_lastMediaResourceLoaderForTesting;
1155 
1156     friend class TrackDisplayUpdateScope;
1157 
1158     RefPtr&lt;Blob&gt; m_blob;
1159     MediaProvider m_mediaProvider;
1160 
1161 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1162     RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
1163 #endif
1164 #if ENABLE(ENCRYPTED_MEDIA)
1165     RefPtr&lt;MediaKeys&gt; m_mediaKeys;
1166     bool m_attachingMediaKeys { false };
1167     bool m_playbackBlockedWaitingForKey { false };
1168     GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
1169 #endif
1170 
1171     std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
1172     size_t m_reportedExtraMemoryCost { 0 };
1173 
1174 #if !RELEASE_LOG_DISABLED
1175     RefPtr&lt;Logger&gt; m_logger;
<a name="21" id="anc21"></a><span class="line-modified">1176     uint64_t m_logIdentifier;</span>
1177 #endif
1178 
1179 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1180     friend class MediaControlsHost;
1181     RefPtr&lt;MediaControlsHost&gt; m_mediaControlsHost;
1182     RefPtr&lt;DOMWrapperWorld&gt; m_isolatedWorld;
1183 #endif
1184 
1185 #if ENABLE(MEDIA_STREAM)
1186     RefPtr&lt;MediaStream&gt; m_mediaStreamSrcObject;
1187     bool m_settingMediaStreamSrcObject { false };
1188 #endif
1189 
1190 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1191     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1192     bool m_hasPlaybackTargetAvailabilityListeners { false };
1193     bool m_failedToPlayToWirelessTarget { false };
1194 #endif
1195 
1196     bool m_isPlayingToWirelessTarget { false };
1197     bool m_playingOnSecondScreen { false };
<a name="22" id="anc22"></a>
1198 };
1199 
1200 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
1201 
1202 } // namespace WebCore
1203 
1204 namespace WTF {
1205 
1206 template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
1207     static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
1208 };
1209 
1210 #if ENABLE(VIDEO_TRACK) &amp;&amp; !defined(NDEBUG)
1211 
1212 // Template specialization required by PodIntervalTree in debug mode.
1213 template&lt;&gt; struct ValueToString&lt;WebCore::TextTrackCue*&gt; {
1214     static String string(const WebCore::TextTrackCue* cue) { return cue-&gt;debugString(); }
1215 };
1216 
1217 #endif
1218 
1219 #ifndef NDEBUG
1220 
1221 template&lt;&gt; struct ValueToString&lt;MediaTime&gt; {
1222     static String string(const MediaTime&amp; time) { return toString(time); }
1223 };
1224 
1225 #endif
1226 
1227 } // namespace WTF
1228 
1229 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLMediaElement)
1230     static bool isType(const WebCore::Element&amp; element) { return element.isMediaElement(); }
1231     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
1232 SPECIALIZE_TYPE_TRAITS_END()
1233 
1234 #endif
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>