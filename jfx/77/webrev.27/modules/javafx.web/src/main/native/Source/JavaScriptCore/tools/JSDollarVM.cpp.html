<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;
  33 #include &quot;FrameTracers.h&quot;
  34 #include &quot;FunctionCodeBlock.h&quot;
  35 #include &quot;GetterSetter.h&quot;
  36 #include &quot;JSArray.h&quot;
  37 #include &quot;JSArrayBuffer.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSONObject.h&quot;
  41 #include &quot;JSProxy.h&quot;
  42 #include &quot;JSString.h&quot;
  43 #include &quot;Parser.h&quot;
  44 #include &quot;ShadowChicken.h&quot;
  45 #include &quot;Snippet.h&quot;
  46 #include &quot;SnippetParams.h&quot;
  47 #include &quot;TypeProfiler.h&quot;
  48 #include &quot;TypeProfilerLog.h&quot;
  49 #include &quot;VMInspector.h&quot;
  50 #include &quot;WasmCapabilities.h&quot;
  51 #include &lt;wtf/Atomics.h&gt;
  52 #include &lt;wtf/DataLog.h&gt;
  53 #include &lt;wtf/ProcessID.h&gt;
  54 #include &lt;wtf/StringPrintStream.h&gt;
  55 
  56 #if ENABLE(WEBASSEMBLY)
  57 #include &quot;JSWebAssemblyHelpers.h&quot;
  58 #include &quot;WasmStreamingParser.h&quot;
  59 #endif
  60 
  61 using namespace JSC;
  62 
  63 namespace {
  64 
  65 class JSDollarVMCallFrame : public JSDestructibleObject {
  66     using Base = JSDestructibleObject;
  67 public:
  68     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
  69         : Base(vm, structure)
  70     { }
  71 
  72     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  73     {
  74         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  75     }
  76 
  77     static JSDollarVMCallFrame* create(ExecState* exec, unsigned requestedFrameIndex)
  78     {
  79         VM&amp; vm = exec-&gt;vm();
  80         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
  81         Structure* structure = createStructure(vm, globalObject, jsNull());
  82         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);
  83         frame-&gt;finishCreation(vm, exec, requestedFrameIndex);
  84         return frame;
  85     }
  86 
  87     void finishCreation(VM&amp; vm, CallFrame* frame, unsigned requestedFrameIndex)
  88     {
  89         Base::finishCreation(vm);
  90 
  91         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
  92             JSDollarVMCallFrame::addProperty(vm, name, value);
  93         };
  94 
  95         unsigned frameIndex = 0;
  96         bool isValid = false;
  97         frame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {
  98 
  99             if (frameIndex++ != requestedFrameIndex)
 100                 return StackVisitor::Continue;
 101 
 102             addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));
 103 
 104             if (visitor-&gt;callee().isCell())
 105                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 106 
 107             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 108             if (codeBlock) {
 109                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 110                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 111                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 112             }
 113             isValid = true;
 114 
 115             return StackVisitor::Done;
 116         });
 117 
 118         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 119     }
 120 
 121     DECLARE_INFO;
 122 
 123 private:
 124     void addProperty(VM&amp; vm, const char* name, JSValue value)
 125     {
 126         Identifier identifier = Identifier::fromString(vm, name);
 127         putDirect(vm, identifier, value);
 128     }
 129 };
 130 
 131 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 132 
 133 class ElementHandleOwner;
 134 class Root;
 135 
 136 class Element : public JSNonFinalObject {
 137 public:
 138     Element(VM&amp; vm, Structure* structure)
 139         : Base(vm, structure)
 140     {
 141     }
 142 
 143     typedef JSNonFinalObject Base;
 144 
 145     Root* root() const { return m_root.get(); }
 146     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 147 
 148     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 149     {
 150         Structure* structure = createStructure(vm, globalObject, jsNull());
 151         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap)) Element(vm, structure);
 152         element-&gt;finishCreation(vm, root);
 153         return element;
 154     }
 155 
 156     void finishCreation(VM&amp;, Root*);
 157 
 158     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 159     {
 160         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 161         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 162         Base::visitChildren(thisObject, visitor);
 163         visitor.append(thisObject-&gt;m_root);
 164     }
 165 
 166     static ElementHandleOwner* handleOwner();
 167 
 168     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 169     {
 170         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 171     }
 172 
 173     DECLARE_INFO;
 174 
 175 private:
 176     WriteBarrier&lt;Root&gt; m_root;
 177 };
 178 
 179 class ElementHandleOwner : public WeakHandleOwner {
 180     WTF_MAKE_FAST_ALLOCATED;
 181 public:
 182     bool isReachableFromOpaqueRoots(Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override
 183     {
 184         if (UNLIKELY(reason))
 185             *reason = &quot;JSC::Element is opaque root&quot;;
 186         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 187         return visitor.containsOpaqueRoot(element-&gt;root());
 188     }
 189 };
 190 
 191 class Root : public JSDestructibleObject {
 192 public:
 193     Root(VM&amp; vm, Structure* structure)
 194         : Base(vm, structure)
 195     {
 196     }
 197 
 198     Element* element()
 199     {
 200         return m_element.get();
 201     }
 202 
 203     void setElement(Element* element)
 204     {
 205         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 206         m_element.swap(newElement);
 207     }
 208 
 209     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 210     {
 211         Structure* structure = createStructure(vm, globalObject, jsNull());
 212         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap)) Root(vm, structure);
 213         root-&gt;finishCreation(vm);
 214         return root;
 215     }
 216 
 217     typedef JSDestructibleObject Base;
 218 
 219     DECLARE_INFO;
 220 
 221     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 222     {
 223         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 224     }
 225 
 226     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 227     {
 228         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 229         Base::visitChildren(thisObject, visitor);
 230         visitor.addOpaqueRoot(thisObject);
 231     }
 232 
 233 private:
 234     Weak&lt;Element&gt; m_element;
 235 };
 236 
 237 class SimpleObject : public JSNonFinalObject {
 238 public:
 239     SimpleObject(VM&amp; vm, Structure* structure)
 240         : Base(vm, structure)
 241     {
 242     }
 243 
 244     typedef JSNonFinalObject Base;
 245     static const bool needsDestruction = false;
 246 
 247     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 248     {
 249         Structure* structure = createStructure(vm, globalObject, jsNull());
 250         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);
 251         simpleObject-&gt;finishCreation(vm);
 252         return simpleObject;
 253     }
 254 
 255     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 256     {
 257         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 258         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 259         Base::visitChildren(thisObject, visitor);
 260         visitor.append(thisObject-&gt;m_hiddenValue);
 261     }
 262 
 263     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 264     {
 265         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 266     }
 267 
 268     JSValue hiddenValue()
 269     {
 270         return m_hiddenValue.get();
 271     }
 272 
 273     void setHiddenValue(VM&amp; vm, JSValue value)
 274     {
 275         ASSERT(value.isCell());
 276         m_hiddenValue.set(vm, this, value);
 277     }
 278 
 279     DECLARE_INFO;
 280 
 281 private:
 282     WriteBarrier&lt;JSC::Unknown&gt; m_hiddenValue;
 283 };
 284 
 285 class ImpureGetter : public JSNonFinalObject {
 286 public:
 287     ImpureGetter(VM&amp; vm, Structure* structure)
 288         : Base(vm, structure)
 289     {
 290     }
 291 
 292     DECLARE_INFO;
 293     typedef JSNonFinalObject Base;
 294     static const unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;
 295 
 296     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 297     {
 298         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 299     }
 300 
 301     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 302     {
 303         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);
 304         getter-&gt;finishCreation(vm, delegate);
 305         return getter;
 306     }
 307 
 308     void finishCreation(VM&amp; vm, JSObject* delegate)
 309     {
 310         Base::finishCreation(vm);
 311         if (delegate)
 312             m_delegate.set(vm, this, delegate);
 313     }
 314 
 315     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName name, PropertySlot&amp; slot)
 316     {
 317         VM&amp; vm = exec-&gt;vm();
 318         auto scope = DECLARE_THROW_SCOPE(vm);
 319         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 320 
 321         if (thisObject-&gt;m_delegate) {
 322             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(exec, name, slot))
 323                 return true;
 324             RETURN_IF_EXCEPTION(scope, false);
 325         }
 326 
 327         return Base::getOwnPropertySlot(object, exec, name, slot);
 328     }
 329 
 330     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 331     {
 332         ASSERT_GC_OBJECT_INHERITS(cell, info());
 333         Base::visitChildren(cell, visitor);
 334         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 335         visitor.append(thisObject-&gt;m_delegate);
 336     }
 337 
 338     void setDelegate(VM&amp; vm, JSObject* delegate)
 339     {
 340         m_delegate.set(vm, this, delegate);
 341     }
 342 
 343 private:
 344     WriteBarrier&lt;JSObject&gt; m_delegate;
 345 };
 346 
 347 class CustomGetter : public JSNonFinalObject {
 348 public:
 349     CustomGetter(VM&amp; vm, Structure* structure)
 350         : Base(vm, structure)
 351     {
 352     }
 353 
 354     DECLARE_INFO;
 355     typedef JSNonFinalObject Base;
 356     static const unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;
 357 
 358     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 359     {
 360         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 361     }
 362 
 363     static CustomGetter* create(VM&amp; vm, Structure* structure)
 364     {
 365         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);
 366         getter-&gt;finishCreation(vm);
 367         return getter;
 368     }
 369 
 370     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 371     {
 372         VM&amp; vm = exec-&gt;vm();
 373         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
 374         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {
 375             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 376             return true;
 377         }
 378 
 379         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {
 380             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 381             return true;
 382         }
 383 
 384         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
 385     }
 386 
 387 private:
 388     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 389     {
 390         VM&amp; vm = exec-&gt;vm();
 391         auto scope = DECLARE_THROW_SCOPE(vm);
 392 
 393         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 394         if (!thisObject)
 395             return throwVMTypeError(exec, scope);
 396         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);
 397         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 398         if (shouldThrow)
 399             return throwVMTypeError(exec, scope);
 400         return JSValue::encode(jsNumber(100));
 401     }
 402 
 403     static EncodedJSValue customGetterAcessor(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 404     {
 405         VM&amp; vm = exec-&gt;vm();
 406         auto scope = DECLARE_THROW_SCOPE(vm);
 407 
 408         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 409         if (!thisObject)
 410             return throwVMTypeError(exec, scope);
 411         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);
 412         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 413         if (shouldThrow)
 414             return throwVMTypeError(exec, scope);
 415         return JSValue::encode(jsNumber(100));
 416     }
 417 };
 418 
 419 class RuntimeArray : public JSArray {
 420 public:
 421     typedef JSArray Base;
 422     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;
 423 
 424     static RuntimeArray* create(ExecState* exec)
 425     {
 426         VM&amp; vm = exec-&gt;vm();
 427         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 428         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
 429         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(exec, structure);
 430         runtimeArray-&gt;finishCreation(exec);
 431         vm.heap.addFinalizer(runtimeArray, destroy);
 432         return runtimeArray;
 433     }
 434 
 435     ~RuntimeArray() { }
 436 
 437     static void destroy(JSCell* cell)
 438     {
 439         static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
 440     }
 441 
 442     static const bool needsDestruction = false;
 443 
 444     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 445     {
 446         VM&amp; vm = exec-&gt;vm();
 447         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 448         if (propertyName == vm.propertyNames-&gt;length) {
 449             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
 450             return true;
 451         }
 452 
 453         Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 454         if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
 455             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
 456             return true;
 457         }
 458 
 459         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
 460     }
 461 
 462     static bool getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned index, PropertySlot&amp; slot)
 463     {
 464         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 465         if (index &lt; thisObject-&gt;getLength()) {
 466             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
 467             return true;
 468         }
 469 
 470         return JSObject::getOwnPropertySlotByIndex(thisObject, exec, index, slot);
 471     }
 472 
 473     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;)
 474     {
 475         RELEASE_ASSERT_NOT_REACHED();
 476     }
 477 
 478     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, ExecState*, PropertyName)
 479     {
 480         RELEASE_ASSERT_NOT_REACHED();
 481     }
 482 
 483     unsigned getLength() const { return m_vector.size(); }
 484 
 485     DECLARE_INFO;
 486 
 487     static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
 488     {
 489         return globalObject-&gt;arrayPrototype();
 490     }
 491 
 492     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 493     {
 494         return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
 495     }
 496 
 497 protected:
 498     void finishCreation(ExecState* exec)
 499     {
 500         VM&amp; vm = exec-&gt;vm();
 501         Base::finishCreation(vm);
 502         ASSERT(inherits(vm, info()));
 503 
 504         for (size_t i = 0; i &lt; exec-&gt;argumentCount(); i++)
 505             m_vector.append(exec-&gt;argument(i).toInt32(exec));
 506     }
 507 
 508 private:
 509     RuntimeArray(ExecState* exec, Structure* structure)
 510         : JSArray(exec-&gt;vm(), structure, 0)
 511     {
 512     }
 513 
 514     static EncodedJSValue lengthGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 515     {
 516         VM&amp; vm = exec-&gt;vm();
 517         auto scope = DECLARE_THROW_SCOPE(vm);
 518 
 519         RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
 520         if (!thisObject)
 521             return throwVMTypeError(exec, scope);
 522         return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
 523     }
 524 
 525     Vector&lt;int&gt; m_vector;
 526 };
 527 
 528 class DOMJITNode : public JSNonFinalObject {
 529 public:
 530     DOMJITNode(VM&amp; vm, Structure* structure)
 531         : Base(vm, structure)
 532     {
 533     }
 534 
 535     DECLARE_INFO;
 536     typedef JSNonFinalObject Base;
 537     static const unsigned StructureFlags = Base::StructureFlags;
 538 
 539     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 540     {
 541         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 542     }
 543 
 544 #if ENABLE(JIT)
 545     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 546     {
 547         Ref&lt;Snippet&gt; snippet = Snippet::create();
 548         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 549             CCallHelpers::JumpList failureCases;
 550             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 551             return failureCases;
 552         });
 553         return snippet;
 554     }
 555 #endif
 556 
 557     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 558     {
 559         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);
 560         getter-&gt;finishCreation(vm);
 561         return getter;
 562     }
 563 
 564     int32_t value() const
 565     {
 566         return m_value;
 567     }
 568 
 569     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 570 
 571 private:
 572     int32_t m_value { 42 };
 573 };
 574 
 575 class DOMJITGetter : public DOMJITNode {
 576 public:
 577     DOMJITGetter(VM&amp; vm, Structure* structure)
 578         : Base(vm, structure)
 579     {
 580     }
 581 
 582     DECLARE_INFO;
 583     typedef DOMJITNode Base;
 584     static const unsigned StructureFlags = Base::StructureFlags;
 585 
 586     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 587     {
 588         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 589     }
 590 
 591     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 592     {
 593         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);
 594         getter-&gt;finishCreation(vm);
 595         return getter;
 596     }
 597 
 598     class DOMJITAttribute : public DOMJIT::GetterSetter {
 599     public:
 600         constexpr DOMJITAttribute()
 601             : DOMJIT::GetterSetter(
 602                 DOMJITGetter::customGetter,
 603 #if ENABLE(JIT)
 604                 &amp;callDOMGetter,
 605 #else
 606                 nullptr,
 607 #endif
 608                 SpecInt32Only)
 609         {
 610         }
 611 
 612 #if ENABLE(JIT)
 613         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 614         {
 615             VM&amp; vm = exec-&gt;vm();
 616             NativeCallFrameTracer tracer(vm, exec);
 617             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 618         }
 619 
 620         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 621         {
 622             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 623             snippet-&gt;requireGlobalObject = false;
 624             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 625                 JSValueRegs results = params[0].jsValueRegs();
 626                 GPRReg dom = params[1].gpr();
 627                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 628                 return CCallHelpers::JumpList();
 629 
 630             });
 631             return snippet;
 632         }
 633 #endif
 634     };
 635 
 636 private:
 637     void finishCreation(VM&amp;);
 638 
 639     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 640     {
 641         VM&amp; vm = exec-&gt;vm();
 642         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 643         ASSERT(thisObject);
 644         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 645     }
 646 };
 647 
 648 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 649 
 650 void DOMJITGetter::finishCreation(VM&amp; vm)
 651 {
 652     Base::finishCreation(vm);
 653     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 654     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
 655     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 656 }
 657 
 658 class DOMJITGetterComplex : public DOMJITNode {
 659 public:
 660     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 661         : Base(vm, structure)
 662     {
 663     }
 664 
 665     DECLARE_INFO;
 666     typedef DOMJITNode Base;
 667     static const unsigned StructureFlags = Base::StructureFlags;
 668 
 669     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 670     {
 671         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 672     }
 673 
 674     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 675     {
 676         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);
 677         getter-&gt;finishCreation(vm, globalObject);
 678         return getter;
 679     }
 680 
 681     class DOMJITAttribute : public DOMJIT::GetterSetter {
 682     public:
 683         constexpr DOMJITAttribute()
 684             : DOMJIT::GetterSetter(
 685                 DOMJITGetterComplex::customGetter,
 686 #if ENABLE(JIT)
 687                 &amp;callDOMGetter,
 688 #else
 689                 nullptr,
 690 #endif
 691                 SpecInt32Only)
 692         {
 693         }
 694 
 695 #if ENABLE(JIT)
 696         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 697         {
 698             VM&amp; vm = exec-&gt;vm();
 699             NativeCallFrameTracer tracer(vm, exec);
 700             auto scope = DECLARE_THROW_SCOPE(vm);
 701             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 702             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 703             if (domjitGetterComplex) {
 704                 if (domjitGetterComplex-&gt;m_enableException)
 705                     return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 706             }
 707             return JSValue::encode(jsNumber(object-&gt;value()));
 708         }
 709 
 710         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 711         {
 712             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 713             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 714             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 715             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 716             snippet-&gt;numFPScratchRegisters = 3;
 717             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 718                 JSValueRegs results = params[0].jsValueRegs();
 719                 GPRReg domGPR = params[1].gpr();
 720                 for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
 721                     jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
 722 
 723                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, domGPR);
 724                 return CCallHelpers::JumpList();
 725             });
 726             return snippet;
 727         }
 728 #endif
 729     };
 730 
 731 private:
 732     void finishCreation(VM&amp;, JSGlobalObject*);
 733 
 734     static EncodedJSValue JSC_HOST_CALL functionEnableException(ExecState* exec)
 735     {
 736         VM&amp; vm = exec-&gt;vm();
 737         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, exec-&gt;thisValue());
 738         if (object)
 739             object-&gt;m_enableException = true;
 740         return JSValue::encode(jsUndefined());
 741     }
 742 
 743     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 744     {
 745         VM&amp; vm = exec-&gt;vm();
 746         auto scope = DECLARE_THROW_SCOPE(vm);
 747 
 748         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 749         ASSERT(thisObject);
 750         if (thisObject-&gt;m_enableException)
 751             return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 752         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 753     }
 754 
 755     bool m_enableException { false };
 756 };
 757 
 758 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 759 
 760 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 761 {
 762     Base::finishCreation(vm);
 763     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 764     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
 765     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 766     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
 767 }
 768 
 769 class DOMJITFunctionObject : public DOMJITNode {
 770 public:
 771     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 772         : Base(vm, structure)
 773     {
 774     }
 775 
 776     DECLARE_INFO;
 777     typedef DOMJITNode Base;
 778     static const unsigned StructureFlags = Base::StructureFlags;
 779 
 780 
 781     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 782     {
 783         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 784     }
 785 
 786     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 787     {
 788         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);
 789         object-&gt;finishCreation(vm, globalObject);
 790         return object;
 791     }
 792 
 793     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)
 794     {
 795         VM&amp; vm = exec-&gt;vm();
 796         auto scope = DECLARE_THROW_SCOPE(vm);
 797 
 798         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, exec-&gt;thisValue());
 799         if (!thisObject)
 800             return throwVMTypeError(exec, scope);
 801         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 802     }
 803 
 804     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)
 805     {
 806         VM&amp; vm = exec-&gt;vm();
 807         NativeCallFrameTracer tracer(vm, exec);
 808         return JSValue::encode(jsNumber(node-&gt;value()));
 809     }
 810 
 811 #if ENABLE(JIT)
 812     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 813     {
 814         Ref&lt;Snippet&gt; snippet = Snippet::create();
 815         snippet-&gt;numFPScratchRegisters = 1;
 816         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 817             static const double value = 42.0;
 818             CCallHelpers::JumpList failureCases;
 819             // May use scratch registers.
 820             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
 821             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 822             return failureCases;
 823         });
 824         return snippet;
 825     }
 826 #endif
 827 
 828 private:
 829     void finishCreation(VM&amp;, JSGlobalObject*);
 830 };
 831 
 832 static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 833 
 834 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 835 {
 836     Base::finishCreation(vm);
 837     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 838 }
 839 
 840 class DOMJITCheckSubClassObject : public DOMJITNode {
 841 public:
 842     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
 843         : Base(vm, structure)
 844     {
 845     }
 846 
 847     DECLARE_INFO;
 848     typedef DOMJITNode Base;
 849     static const unsigned StructureFlags = Base::StructureFlags;
 850 
 851 
 852     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 853     {
 854         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 855     }
 856 
 857     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 858     {
 859         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);
 860         object-&gt;finishCreation(vm, globalObject);
 861         return object;
 862     }
 863 
 864     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)
 865     {
 866         VM&amp; vm = exec-&gt;vm();
 867         auto scope = DECLARE_THROW_SCOPE(vm);
 868 
 869         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, exec-&gt;thisValue());
 870         if (!thisObject)
 871             return throwVMTypeError(exec, scope);
 872         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 873     }
 874 
 875     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)
 876     {
 877         VM&amp; vm = exec-&gt;vm();
 878         NativeCallFrameTracer tracer(vm, exec);
 879         return JSValue::encode(jsNumber(node-&gt;value()));
 880     }
 881 
 882 private:
 883     void finishCreation(VM&amp;, JSGlobalObject*);
 884 };
 885 
 886 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 887 
 888 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 889 {
 890     Base::finishCreation(vm);
 891     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 892 }
 893 
 894 class DOMJITGetterBaseJSObject : public DOMJITNode {
 895 public:
 896     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
 897         : Base(vm, structure)
 898     {
 899     }
 900 
 901     DECLARE_INFO;
 902     using Base = DOMJITNode;
 903     static const unsigned StructureFlags = Base::StructureFlags;
 904 
 905     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 906     {
 907         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 908     }
 909 
 910     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
 911     {
 912         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);
 913         getter-&gt;finishCreation(vm);
 914         return getter;
 915     }
 916 
 917     class DOMJITAttribute : public DOMJIT::GetterSetter {
 918     public:
 919         constexpr DOMJITAttribute()
 920             : DOMJIT::GetterSetter(
 921                 DOMJITGetterBaseJSObject::customGetter,
 922 #if ENABLE(JIT)
 923                 &amp;callDOMGetter,
 924 #else
 925                 nullptr,
 926 #endif
 927                 SpecBytecodeTop)
 928         {
 929         }
 930 
 931 #if ENABLE(JIT)
 932         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 933         {
 934             VM&amp; vm = exec-&gt;vm();
 935             NativeCallFrameTracer tracer(vm, exec);
 936             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
 937             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
 938         }
 939 
 940         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 941         {
 942             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 943             snippet-&gt;requireGlobalObject = false;
 944             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 945                 JSValueRegs results = params[0].jsValueRegs();
 946                 GPRReg dom = params[1].gpr();
 947                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 948                 return CCallHelpers::JumpList();
 949 
 950             });
 951             return snippet;
 952         }
 953 #endif
 954     };
 955 
 956 private:
 957     void finishCreation(VM&amp;);
 958 
 959     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 960     {
 961         VM&amp; vm = exec-&gt;vm();
 962         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 963         RELEASE_ASSERT(thisObject);
 964         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
 965     }
 966 };
 967 
 968 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
 969 
 970 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
 971 {
 972     Base::finishCreation(vm);
 973     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
 974     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
 975     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 976 }
 977 
 978 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 979 public:
 980     Message(ArrayBufferContents&amp;&amp;, int32_t);
 981     ~Message();
 982 
 983     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 984     int32_t index() const { return m_index; }
 985 
 986 private:
 987     ArrayBufferContents m_contents;
 988     int32_t m_index { 0 };
 989 };
 990 
 991 class JSTestCustomGetterSetter : public JSNonFinalObject {
 992 public:
 993     using Base = JSNonFinalObject;
 994     static const unsigned StructureFlags = Base::StructureFlags;
 995 
 996     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
 997         : Base(vm, structure)
 998     { }
 999 
1000     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
1001     {
1002         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);
1003         result-&gt;finishCreation(vm);
1004         return result;
1005     }
1006 
1007     void finishCreation(VM&amp;);
1008 
1009     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1010     {
1011         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1012     }
1013 
1014     DECLARE_INFO;
1015 };
1016 
1017 
1018 static EncodedJSValue customGetAccessor(ExecState*, EncodedJSValue thisValue, PropertyName)
1019 {
1020     // Passed |this|
1021     return thisValue;
1022 }
1023 
1024 static EncodedJSValue customGetValue(ExecState* exec, EncodedJSValue slotValue, PropertyName)
1025 {
1026     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1027     // Passed property holder.
1028     return slotValue;
1029 }
1030 
1031 static bool customSetAccessor(ExecState* exec, EncodedJSValue thisObject, EncodedJSValue encodedValue)
1032 {
1033     VM&amp; vm = exec-&gt;vm();
1034 
1035     JSValue value = JSValue::decode(encodedValue);
1036     RELEASE_ASSERT(value.isObject());
1037     JSObject* object = asObject(value);
1038     PutPropertySlot slot(object);
1039     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);
1040 
1041     return true;
1042 }
1043 
1044 static bool customSetValue(ExecState* exec, EncodedJSValue slotValue, EncodedJSValue encodedValue)
1045 {
1046     VM&amp; vm = exec-&gt;vm();
1047 
1048     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1049 
1050     JSValue value = JSValue::decode(encodedValue);
1051     RELEASE_ASSERT(value.isObject());
1052     JSObject* object = asObject(value);
1053     PutPropertySlot slot(object);
1054     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);
1055 
1056     return true;
1057 }
1058 
1059 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1060 {
1061     Base::finishCreation(vm);
1062 
1063     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),
1064         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
1065     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),
1066         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1067 }
1068 
1069 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1070 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1071 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1072 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1073 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1074 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1075 #if ENABLE(JIT)
1076 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1077 #else
1078 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1079 #endif
1080 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1081 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1082 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1083 #if ENABLE(JIT)
1084 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1085 #else
1086 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1087 #endif
1088 const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
1089 const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
1090 
1091 ElementHandleOwner* Element::handleOwner()
1092 {
1093     static ElementHandleOwner* owner = 0;
1094     if (!owner)
1095         owner = new ElementHandleOwner();
1096     return owner;
1097 }
1098 
1099 void Element::finishCreation(VM&amp; vm, Root* root)
1100 {
1101     Base::finishCreation(vm);
1102     setRoot(vm, root);
1103     m_root-&gt;setElement(this);
1104 }
1105 
1106 #if ENABLE(WEBASSEMBLY)
1107 
1108 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState*);
1109 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState*);
1110 
1111 class WasmStreamingParser : public JSDestructibleObject {
1112 public:
1113     WasmStreamingParser(VM&amp; vm, Structure* structure)
1114         : Base(vm, structure)
1115         , m_info(Wasm::ModuleInformation::create())
1116         , m_streamingParser(m_info.get())
1117     {
1118     }
1119 
1120     using Base = JSDestructibleObject;
1121 
1122     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1123     {
1124         Structure* structure = createStructure(vm, globalObject, jsNull());
1125         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);
1126         result-&gt;finishCreation(vm);
1127         return result;
1128     }
1129 
1130     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1131     {
1132         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1133     }
1134 
1135     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1136 
1137     void finishCreation(VM&amp; vm)
1138     {
1139         Base::finishCreation(vm);
1140 
1141         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
1142         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1143         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1144     }
1145 
1146     DECLARE_INFO;
1147 
1148     Ref&lt;Wasm::ModuleInformation&gt; m_info;
1149     Wasm::StreamingParser m_streamingParser;
1150 };
1151 
1152 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1153 
1154 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState* exec)
1155 {
1156     VM&amp; vm = exec-&gt;vm();
1157     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
1158     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());
1159     if (!thisObject)
1160         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1161 
1162     auto data = getWasmBufferFromValue(exec, exec-&gt;argument(0));
1163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1164     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
1165 }
1166 
1167 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState* exec)
1168 {
1169     VM&amp; vm = exec-&gt;vm();
1170     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());
1171     if (!thisObject)
1172         return JSValue::encode(jsBoolean(false));
1173     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
1174 }
1175 
1176 #endif
1177 
1178 } // namespace
1179 
1180 namespace JSC {
1181 
1182 const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
1183 
1184 // Triggers a crash immediately.
1185 // Usage: $vm.crash()
1186 static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(ExecState*)
1187 {
1188     CRASH();
1189 }
1190 
1191 // Executes a breakpoint instruction if the first argument is truthy or is unset.
1192 // Usage: $vm.breakpoint(&lt;condition&gt;)
1193 static EncodedJSValue JSC_HOST_CALL functionBreakpoint(ExecState* exec)
1194 {
1195     // Nothing should throw here but we might as well double check...
1196     VM&amp; vm = exec-&gt;vm();
1197     auto scope = DECLARE_CATCH_SCOPE(vm);
1198     UNUSED_PARAM(scope);
1199     if (!exec-&gt;argumentCount() || exec-&gt;argument(0).toBoolean(exec))
1200         WTFBreakpointTrap();
1201 
1202     return encodedJSUndefined();
1203 }
1204 
1205 // Returns true if the current frame is a DFG frame.
1206 // Usage: isDFG = $vm.dfgTrue()
1207 static EncodedJSValue JSC_HOST_CALL functionDFGTrue(ExecState*)
1208 {
1209     return JSValue::encode(jsBoolean(false));
1210 }
1211 
1212 // Returns true if the current frame is a FTL frame.
1213 // Usage: isFTL = $vm.ftlTrue()
1214 static EncodedJSValue JSC_HOST_CALL functionFTLTrue(ExecState*)
1215 {
1216     return JSValue::encode(jsBoolean(false));
1217 }
1218 
1219 static EncodedJSValue JSC_HOST_CALL functionCpuMfence(ExecState*)
1220 {
1221 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1222     asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
1223 #endif
1224     return JSValue::encode(jsUndefined());
1225 }
1226 
1227 static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(ExecState*)
1228 {
1229 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1230     unsigned high;
1231     unsigned low;
1232     asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
1233     return JSValue::encode(jsNumber(low));
1234 #else
1235     return JSValue::encode(jsNumber(0));
1236 #endif
1237 }
1238 
1239 static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(ExecState*)
1240 {
1241 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1242     WTF::x86_cpuid();
1243 #endif
1244     return JSValue::encode(jsUndefined());
1245 }
1246 
1247 static EncodedJSValue JSC_HOST_CALL functionCpuPause(ExecState*)
1248 {
1249 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1250     asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
1251 #endif
1252     return JSValue::encode(jsUndefined());
1253 }
1254 
1255 // This takes either a JSArrayBuffer, JSArrayBufferView*, or any other object as its first
1256 // argument. The second argument is expected to be an integer.
1257 //
1258 // If the first argument is a JSArrayBuffer, it&#39;ll clflush on that buffer
1259 // plus the second argument as a byte offset. It&#39;ll also flush on the object
1260 // itself so its length, etc, aren&#39;t in the cache.
1261 //
1262 // If the first argument is not a JSArrayBuffer, we load the butterfly
1263 // and clflush at the address of the butterfly.
1264 static EncodedJSValue JSC_HOST_CALL functionCpuClflush(ExecState* exec)
1265 {
1266 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1267     VM&amp; vm = exec-&gt;vm();
1268 
1269     if (!exec-&gt;argument(1).isInt32())
1270         return JSValue::encode(jsBoolean(false));
1271 
1272     auto clflush = [] (void* ptr) {
1273         char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
1274         asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
1275     };
1276 
1277     Vector&lt;void*&gt; toFlush;
1278 
1279     uint32_t offset = exec-&gt;argument(1).asUInt32();
1280 
1281     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, exec-&gt;argument(0)))
1282         toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
1283     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0))) {
1284         switch (object-&gt;indexingType()) {
1285         case ALL_INT32_INDEXING_TYPES:
1286         case ALL_CONTIGUOUS_INDEXING_TYPES:
1287         case ALL_DOUBLE_INDEXING_TYPES:
1288             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
1289             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1290         }
1291     }
1292 
1293     if (!toFlush.size())
1294         return JSValue::encode(jsBoolean(false));
1295 
1296     for (void* ptr : toFlush)
1297         clflush(ptr);
1298     return JSValue::encode(jsBoolean(true));
1299 #else
1300     UNUSED_PARAM(exec);
1301     return JSValue::encode(jsBoolean(false));
1302 #endif
1303 }
1304 
1305 class CallerFrameJITTypeFunctor {
1306 public:
1307     CallerFrameJITTypeFunctor()
1308         : m_currentFrame(0)
1309         , m_jitType(JITType::None)
1310     {
1311     }
1312 
1313     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1314     {
1315         if (m_currentFrame++ &gt; 1) {
1316             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1317             return StackVisitor::Done;
1318         }
1319         return StackVisitor::Continue;
1320     }
1321 
1322     JITType jitType() { return m_jitType; }
1323 
1324 private:
1325     mutable unsigned m_currentFrame;
1326     mutable JITType m_jitType;
1327 };
1328 
1329 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1330 {
1331     if (!theFunctionValue.isCell())
1332         return nullptr;
1333 
1334     VM&amp; vm = theFunctionValue.asCell()-&gt;vm();
1335     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1336     if (!theFunction)
1337         return nullptr;
1338 
1339     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1340         theFunction-&gt;executable());
1341 
1342     return executable;
1343 }
1344 
1345 // Returns true if the current frame is a LLInt frame.
1346 // Usage: isLLInt = $vm.llintTrue()
1347 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(ExecState* exec)
1348 {
1349     if (!exec)
1350         return JSValue::encode(jsUndefined());
1351     CallerFrameJITTypeFunctor functor;
1352     exec-&gt;iterate(functor);
1353     return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));
1354 }
1355 
1356 // Returns true if the current frame is a baseline JIT frame.
1357 // Usage: isBaselineJIT = $vm.jitTrue()
1358 static EncodedJSValue JSC_HOST_CALL functionJITTrue(ExecState* exec)
1359 {
1360     if (!exec)
1361         return JSValue::encode(jsUndefined());
1362     CallerFrameJITTypeFunctor functor;
1363     exec-&gt;iterate(functor);
1364     return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));
1365 }
1366 
1367 // Set that the argument function should not be inlined.
1368 // Usage:
1369 // function f() { };
1370 // $vm.noInline(f);
1371 static EncodedJSValue JSC_HOST_CALL functionNoInline(ExecState* exec)
1372 {
1373     if (exec-&gt;argumentCount() &lt; 1)
1374         return JSValue::encode(jsUndefined());
1375 
1376     JSValue theFunctionValue = exec-&gt;uncheckedArgument(0);
1377 
1378     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1379         executable-&gt;setNeverInline(true);
1380 
1381     return JSValue::encode(jsUndefined());
1382 }
1383 
1384 // Runs a full GC synchronously.
1385 // Usage: $vm.gc()
1386 static EncodedJSValue JSC_HOST_CALL functionGC(ExecState* exec)
1387 {
1388     VMInspector::gc(exec);
1389     return JSValue::encode(jsUndefined());
1390 }
1391 
1392 // Runs the edenGC synchronously.
1393 // Usage: $vm.edenGC()
1394 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)
1395 {
1396     VMInspector::edenGC(exec);
1397     return JSValue::encode(jsUndefined());
1398 }
1399 
1400 // Dumps the hashes of all subspaces currently registered with the VM.
1401 // Usage: $vm.dumpSubspaceHashes()
1402 static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(ExecState* exec)
1403 {
1404     VM&amp; vm = exec-&gt;vm();
1405     VMInspector::dumpSubspaceHashes(&amp;vm);
1406     return JSValue::encode(jsUndefined());
1407 }
1408 
1409 // Gets a JSDollarVMCallFrame for a specified frame index.
1410 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1411 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1412 //
1413 // This gives you the ability to query the following:
1414 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1415 //    callFrame.callee;
1416 //    callFrame.codeBlock;
1417 //    callFrame.unlinkedCodeBlock;
1418 //    callFrame.executable;
1419 //
1420 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1421 // there are internal objects and not a JS object. Hence, you cannot do string
1422 // concatenation with them.
1423 static EncodedJSValue JSC_HOST_CALL functionCallFrame(ExecState* exec)
1424 {
1425     unsigned frameNumber = 1;
1426     if (exec-&gt;argumentCount() &gt;= 1) {
1427         JSValue value = exec-&gt;uncheckedArgument(0);
1428         if (!value.isUInt32())
1429             return JSValue::encode(jsUndefined());
1430 
1431         // We need to inc the frame number because the caller would consider
1432         // its own frame as frame 0. Hence, we need discount the frame for this
1433         // function.
1434         frameNumber = value.asUInt32() + 1;
1435     }
1436 
1437     return JSValue::encode(JSDollarVMCallFrame::create(exec, frameNumber));
1438 }
1439 
1440 // Gets a token for the CodeBlock for a specified frame index.
1441 // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
1442 // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
1443 static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(ExecState* exec)
1444 {
1445     unsigned frameNumber = 1;
1446     if (exec-&gt;argumentCount() &gt;= 1) {
1447         JSValue value = exec-&gt;uncheckedArgument(0);
1448         if (!value.isUInt32())
1449             return JSValue::encode(jsUndefined());
1450 
1451         // We need to inc the frame number because the caller would consider
1452         // its own frame as frame 0. Hence, we need discount the frame for this
1453         // function.
1454         frameNumber = value.asUInt32() + 1;
1455     }
1456 
1457     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(exec, frameNumber);
1458     if (codeBlock)
1459         return JSValue::encode(codeBlock);
1460     return JSValue::encode(jsUndefined());
1461 }
1462 
1463 static CodeBlock* codeBlockFromArg(ExecState* exec)
1464 {
1465     VM&amp; vm = exec-&gt;vm();
1466     if (exec-&gt;argumentCount() &lt; 1)
1467         return nullptr;
1468 
1469     JSValue value = exec-&gt;uncheckedArgument(0);
1470     CodeBlock* candidateCodeBlock = nullptr;
1471     if (value.isCell()) {
1472         JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
1473         if (func) {
1474             if (func-&gt;isHostFunction())
1475                 candidateCodeBlock = nullptr;
1476             else
1477                 candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
1478         } else
1479             candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
1480     }
1481 
1482     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(exec, candidateCodeBlock))
1483         return candidateCodeBlock;
1484 
1485     if (candidateCodeBlock)
1486         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1487     else
1488         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1489     return nullptr;
1490 }
1491 
1492 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1493 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1494 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1495 // a JS object. Hence, you cannot do string concatenation with it.
1496 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(ExecState* exec)
1497 {
1498     CodeBlock* codeBlock = codeBlockFromArg(exec);
1499     WTF::StringPrintStream stream;
1500     if (codeBlock) {
1501         stream.print(*codeBlock);
1502         return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));
1503     }
1504     return JSValue::encode(jsUndefined());
1505 }
1506 
1507 // Usage: $vm.dumpSourceFor(functionObj)
1508 // Usage: $vm.dumpSourceFor(codeBlockToken)
1509 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(ExecState* exec)
1510 {
1511     CodeBlock* codeBlock = codeBlockFromArg(exec);
1512     if (codeBlock)
1513         codeBlock-&gt;dumpSource();
1514     return JSValue::encode(jsUndefined());
1515 }
1516 
1517 // Usage: $vm.dumpBytecodeFor(functionObj)
1518 // Usage: $vm.dumpBytecodeFor(codeBlock)
1519 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(ExecState* exec)
1520 {
1521     CodeBlock* codeBlock = codeBlockFromArg(exec);
1522     if (codeBlock)
1523         codeBlock-&gt;dumpBytecode();
1524     return JSValue::encode(jsUndefined());
1525 }
1526 
1527 static EncodedJSValue doPrint(ExecState* exec, bool addLineFeed)
1528 {
1529     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
1530     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1531         JSValue arg = exec-&gt;uncheckedArgument(i);
1532         if (arg.isCell()
1533             &amp;&amp; !arg.isObject()
1534             &amp;&amp; !arg.isString()
1535             &amp;&amp; !arg.isBigInt()) {
1536             dataLog(arg);
1537             continue;
1538         }
1539         String argStr = exec-&gt;uncheckedArgument(i).toWTFString(exec);
1540         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1541         dataLog(argStr);
1542     }
1543     if (addLineFeed)
1544         dataLog(&quot;\n&quot;);
1545     return JSValue::encode(jsUndefined());
1546 }
1547 
1548 // Prints a series of comma separate strings without appending a newline.
1549 // Usage: $vm.dataLog(str1, str2, str3)
1550 static EncodedJSValue JSC_HOST_CALL functionDataLog(ExecState* exec)
1551 {
1552     const bool addLineFeed = false;
1553     return doPrint(exec, addLineFeed);
1554 }
1555 
1556 // Prints a series of comma separate strings and appends a newline.
1557 // Usage: $vm.print(str1, str2, str3)
1558 static EncodedJSValue JSC_HOST_CALL functionPrint(ExecState* exec)
1559 {
1560     const bool addLineFeed = true;
1561     return doPrint(exec, addLineFeed);
1562 }
1563 
1564 // Dumps the current CallFrame.
1565 // Usage: $vm.dumpCallFrame()
1566 static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(ExecState* exec)
1567 {
1568     // When the callers call this function, they are expecting to dump their
1569     // own frame. So skip 1 for this frame.
1570     VMInspector::dumpCallFrame(exec, 1);
1571     return JSValue::encode(jsUndefined());
1572 }
1573 
1574 // Dumps the JS stack.
1575 // Usage: $vm.printStack()
1576 static EncodedJSValue JSC_HOST_CALL functionDumpStack(ExecState* exec)
1577 {
1578     // When the callers call this function, they are expecting to dump the
1579     // stack starting their own frame. So skip 1 for this frame.
1580     VMInspector::dumpStack(exec, 1);
1581     return JSValue::encode(jsUndefined());
1582 }
1583 
1584 // Dumps the current CallFrame.
1585 // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
1586 // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
1587 // FIXME: Currently, this function dumps the physical frame. We should make
1588 // it dump the logical frame (i.e. be able to dump inlined frames as well).
1589 static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(ExecState* exec)
1590 {
1591     unsigned requestedFrameIndex = 1;
1592     if (exec-&gt;argumentCount() &gt;= 1) {
1593         JSValue value = exec-&gt;uncheckedArgument(0);
1594         if (!value.isUInt32())
1595             return JSValue::encode(jsUndefined());
1596 
1597         // We need to inc the frame number because the caller would consider
1598         // its own frame as frame 0. Hence, we need discount the frame for this
1599         // function.
1600         requestedFrameIndex = value.asUInt32() + 1;
1601     }
1602 
1603     unsigned frameIndex = 0;
1604     exec-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {
1605         if (frameIndex++ != requestedFrameIndex)
1606             return StackVisitor::Continue;
1607         VMInspector::dumpRegisters(visitor-&gt;callFrame());
1608         return StackVisitor::Done;
1609     });
1610 
1611     return encodedJSUndefined();
1612 }
1613 
1614 // Dumps the internal memory layout of a JSCell.
1615 // Usage: $vm.dumpCell(cell)
1616 static EncodedJSValue JSC_HOST_CALL functionDumpCell(ExecState* exec)
1617 {
1618     JSValue value = exec-&gt;argument(0);
1619     if (!value.isCell())
1620         return encodedJSUndefined();
1621 
1622     VMInspector::dumpCellMemory(value.asCell());
1623     return encodedJSUndefined();
1624 }
1625 
1626 // Gets the dataLog dump of the indexingMode of the passed value.
1627 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
1628 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(ExecState* exec)
1629 {
1630     if (!exec-&gt;argument(0).isObject())
1631         return encodedJSUndefined();
1632 
1633     WTF::StringPrintStream stream;
1634     stream.print(IndexingTypeDump(exec-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));
1635     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));
1636 }
1637 
1638 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(ExecState* exec)
1639 {
1640     VM&amp; vm = exec-&gt;vm();
1641     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0)))
1642         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1643 
1644     return encodedJSUndefined();
1645 }
1646 
1647 // Gets the dataLog dump of a given JS value as a string.
1648 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
1649 static EncodedJSValue JSC_HOST_CALL functionValue(ExecState* exec)
1650 {
1651     WTF::StringPrintStream stream;
1652     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1653         if (i)
1654             stream.print(&quot;, &quot;);
1655         stream.print(exec-&gt;uncheckedArgument(i));
1656     }
1657 
1658     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));
1659 }
1660 
1661 // Gets the pid of the current process.
1662 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
1663 static EncodedJSValue JSC_HOST_CALL functionGetPID(ExecState*)
1664 {
1665     return JSValue::encode(jsNumber(getCurrentProcessID()));
1666 }
1667 
1668 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1669 // Usage: $vm.haveABadTime(globalObject)
1670 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(ExecState* exec)
1671 {
1672     VM&amp; vm = exec-&gt;vm();
1673     JSLockHolder lock(vm);
1674     JSValue objValue = exec-&gt;argument(0);
1675     if (!objValue.isObject())
1676         return JSValue::encode(jsBoolean(false));
1677 
1678     JSObject* obj = asObject(objValue.asCell());
1679     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);
1680     if (!globalObject)
1681         JSValue::encode(jsBoolean(false));
1682 
1683     globalObject-&gt;haveABadTime(vm);
1684     return JSValue::encode(jsBoolean(true));
1685 }
1686 
1687 // Checks if the object (or its global if the object is not a global) is having a bad time.
1688 // Usage: $vm.isHavingABadTime(obj)
1689 static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(ExecState* exec)
1690 {
1691     VM&amp; vm = exec-&gt;vm();
1692     JSLockHolder lock(vm);
1693     JSValue objValue = exec-&gt;argument(0);
1694     if (!objValue.isObject())
1695         return JSValue::encode(jsUndefined());
1696 
1697     JSObject* obj = asObject(objValue.asCell());
1698     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);
1699     if (globalObject)
1700         JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));
1701 
1702     globalObject = obj-&gt;globalObject();
1703     if (!globalObject)
1704         return JSValue::encode(jsUndefined());
1705 
1706     return JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));
1707 }
1708 
1709 // Creates a new global object.
1710 // Usage: $vm.createGlobalObject()
1711 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)
1712 {
1713     VM&amp; vm = exec-&gt;vm();
1714     JSLockHolder lock(vm);
1715     JSGlobalObject* globalObject = JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull()));
1716     return JSValue::encode(globalObject);
1717 }
1718 
1719 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(ExecState* exec)
1720 {
1721     VM&amp; vm = exec-&gt;vm();
1722     JSLockHolder lock(vm);
1723     JSValue target = exec-&gt;argument(0);
1724     if (!target.isObject())
1725         return JSValue::encode(jsUndefined());
1726     JSObject* jsTarget = asObject(target.asCell());
1727     Structure* structure = JSProxy::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);
1728     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
1729     return JSValue::encode(proxy);
1730 }
1731 
1732 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(ExecState* exec)
1733 {
1734     JSLockHolder lock(exec);
1735     RuntimeArray* array = RuntimeArray::create(exec);
1736     return JSValue::encode(array);
1737 }
1738 
1739 static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(ExecState* exec)
1740 {
1741     VM&amp; vm = exec-&gt;vm();
1742     JSLockHolder lock(vm);
1743     return JSValue::encode(JSRopeString::createNullForTesting(vm));
1744 }
1745 
1746 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(ExecState* exec)
1747 {
1748     VM&amp; vm = exec-&gt;vm();
1749     JSLockHolder lock(vm);
1750     JSValue target = exec-&gt;argument(0);
1751     JSObject* delegate = nullptr;
1752     if (target.isObject())
1753         delegate = asObject(target.asCell());
1754     Structure* structure = ImpureGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1755     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
1756     return JSValue::encode(result);
1757 }
1758 
1759 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(ExecState* exec)
1760 {
1761     VM&amp; vm = exec-&gt;vm();
1762     JSLockHolder lock(vm);
1763     Structure* structure = CustomGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1764     CustomGetter* result = CustomGetter::create(vm, structure);
1765     return JSValue::encode(result);
1766 }
1767 
1768 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(ExecState* exec)
1769 {
1770     VM&amp; vm = exec-&gt;vm();
1771     JSLockHolder lock(vm);
1772     Structure* structure = DOMJITNode::createStructure(vm, exec-&gt;lexicalGlobalObject(), DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull())));
1773     DOMJITNode* result = DOMJITNode::create(vm, structure);
1774     return JSValue::encode(result);
1775 }
1776 
1777 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(ExecState* exec)
1778 {
1779     VM&amp; vm = exec-&gt;vm();
1780     JSLockHolder lock(vm);
1781     Structure* structure = DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1782     DOMJITGetter* result = DOMJITGetter::create(vm, structure);
1783     return JSValue::encode(result);
1784 }
1785 
1786 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(ExecState* exec)
1787 {
1788     VM&amp; vm = exec-&gt;vm();
1789     JSLockHolder lock(vm);
1790     Structure* structure = DOMJITGetterComplex::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1791     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, exec-&gt;lexicalGlobalObject(), structure);
1792     return JSValue::encode(result);
1793 }
1794 
1795 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(ExecState* exec)
1796 {
1797     VM&amp; vm = exec-&gt;vm();
1798     JSLockHolder lock(vm);
1799     Structure* structure = DOMJITFunctionObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1800     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);
1801     return JSValue::encode(result);
1802 }
1803 
1804 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(ExecState* exec)
1805 {
1806     VM&amp; vm = exec-&gt;vm();
1807     JSLockHolder lock(vm);
1808     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1809     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);
1810     return JSValue::encode(result);
1811 }
1812 
1813 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(ExecState* exec)
1814 {
1815     VM&amp; vm = exec-&gt;vm();
1816     JSLockHolder lock(vm);
1817     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1818     DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
1819     return JSValue::encode(result);
1820 }
1821 
1822 #if ENABLE(WEBASSEMBLY)
1823 static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(ExecState* exec)
1824 {
1825     VM&amp; vm = exec-&gt;vm();
1826     JSLockHolder lock(vm);
1827     return JSValue::encode(WasmStreamingParser::create(vm, exec-&gt;lexicalGlobalObject()));
1828 }
1829 #endif
1830 
1831 static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(ExecState* exec)
1832 {
1833     VM&amp; vm = exec-&gt;vm();
1834     JSLockHolder lock(vm);
1835     auto scope = DECLARE_THROW_SCOPE(vm);
1836 
1837     JSValue base = exec-&gt;argument(0);
1838     if (!base.isObject())
1839         return JSValue::encode(jsUndefined());
1840     JSValue delegate = exec-&gt;argument(1);
1841     if (!delegate.isObject())
1842         return JSValue::encode(jsUndefined());
1843     ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
1844     if (UNLIKELY(!impureGetter)) {
1845         throwTypeError(exec, scope, &quot;argument is not an ImpureGetter&quot;_s);
1846         return encodedJSValue();
1847     }
1848     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
1849     return JSValue::encode(jsUndefined());
1850 }
1851 
1852 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(ExecState* exec)
1853 {
1854     VM&amp; vm = exec-&gt;vm();
1855     auto scope = DECLARE_THROW_SCOPE(vm);
1856 
1857     if (exec-&gt;argumentCount() &lt; 1 || !exec-&gt;argument(0).isString())
1858         return JSValue::encode(jsUndefined());
1859 
1860     String functionText = asString(exec-&gt;argument(0))-&gt;value(exec);
1861     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1862 
1863     const SourceCode&amp; source = makeSource(functionText, { });
1864     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), exec-&gt;lexicalGlobalObject());
1865 
1866     return JSValue::encode(func);
1867 }
1868 
1869 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(ExecState* exec)
1870 {
1871     VM&amp; vm = exec-&gt;vm();
1872     auto scope = DECLARE_THROW_SCOPE(vm);
1873 
1874     if (exec-&gt;argumentCount() &lt; 2 || !exec-&gt;argument(1).isString())
1875         return encodedJSUndefined();
1876 
1877     String str = asString(exec-&gt;argument(1))-&gt;value(exec);
1878 
1879     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));
1880     if (!symbol)
1881         return throwVMError(exec, scope, &quot;Unknown private name.&quot;);
1882 
1883     RELEASE_AND_RETURN(scope, JSValue::encode(exec-&gt;argument(0).get(exec, symbol)));
1884 }
1885 
1886 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(ExecState* exec)
1887 {
1888     VM&amp; vm = exec-&gt;vm();
1889     JSLockHolder lock(vm);
1890     return JSValue::encode(Root::create(vm, exec-&gt;lexicalGlobalObject()));
1891 }
1892 
1893 static EncodedJSValue JSC_HOST_CALL functionCreateElement(ExecState* exec)
1894 {
1895     VM&amp; vm = exec-&gt;vm();
1896     JSLockHolder lock(vm);
1897     auto scope = DECLARE_THROW_SCOPE(vm);
1898 
1899     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));
1900     if (!root)
1901         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Cannot create Element without a Root.&quot;_s)));
1902     return JSValue::encode(Element::create(vm, exec-&gt;lexicalGlobalObject(), root));
1903 }
1904 
1905 static EncodedJSValue JSC_HOST_CALL functionGetElement(ExecState* exec)
1906 {
1907     VM&amp; vm = exec-&gt;vm();
1908     JSLockHolder lock(vm);
1909     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));
1910     if (!root)
1911         return JSValue::encode(jsUndefined());
1912     Element* result = root-&gt;element();
1913     return JSValue::encode(result ? result : jsUndefined());
1914 }
1915 
1916 static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(ExecState* exec)
1917 {
1918     VM&amp; vm = exec-&gt;vm();
1919     JSLockHolder lock(vm);
1920     return JSValue::encode(SimpleObject::create(vm, exec-&gt;lexicalGlobalObject()));
1921 }
1922 
1923 static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(ExecState* exec)
1924 {
1925     VM&amp; vm = exec-&gt;vm();
1926     JSLockHolder lock(vm);
1927     auto scope = DECLARE_THROW_SCOPE(vm);
1928 
1929     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));
1930     if (UNLIKELY(!simpleObject)) {
1931         throwTypeError(exec, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);
1932         return encodedJSValue();
1933     }
1934     return JSValue::encode(simpleObject-&gt;hiddenValue());
1935 }
1936 
1937 static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState* exec)
1938 {
1939     VM&amp; vm = exec-&gt;vm();
1940     JSLockHolder lock(vm);
1941     auto scope = DECLARE_THROW_SCOPE(vm);
1942 
1943     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));
1944     if (UNLIKELY(!simpleObject)) {
1945         throwTypeError(exec, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);
1946         return encodedJSValue();
1947     }
1948     JSValue value = exec-&gt;argument(1);
1949     simpleObject-&gt;setHiddenValue(vm, value);
1950     return JSValue::encode(jsUndefined());
1951 }
1952 
1953 static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(ExecState* exec)
1954 {
1955     VM&amp; vm = exec-&gt;vm();
1956     auto scope = DECLARE_THROW_SCOPE(vm);
1957     if (auto* shadowChicken = vm.shadowChicken()) {
1958         scope.release();
1959         return JSValue::encode(shadowChicken-&gt;functionsOnStack(exec));
1960     }
1961 
1962     JSArray* result = constructEmptyArray(exec, 0);
1963     RETURN_IF_EXCEPTION(scope, { });
1964     StackVisitor::visit(exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {
1965         if (visitor-&gt;isInlinedFrame())
1966             return StackVisitor::Continue;
1967         if (visitor-&gt;isWasmFrame())
1968             return StackVisitor::Continue;
1969         result-&gt;push(exec, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));
1970         scope.releaseAssertNoException(); // This function is only called from tests.
1971         return StackVisitor::Continue;
1972     });
1973     RETURN_IF_EXCEPTION(scope, { });
1974     return JSValue::encode(result);
1975 }
1976 
1977 static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(ExecState* exec)
1978 {
1979     VM&amp; vm = exec-&gt;vm();
1980     vm.setGlobalConstRedeclarationShouldThrow(false);
1981     return JSValue::encode(jsUndefined());
1982 }
1983 
1984 static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(ExecState* exec)
1985 {
1986     VM&amp; vm = exec-&gt;vm();
1987     RELEASE_ASSERT(vm.typeProfiler());
1988     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
1989 
1990     JSValue functionValue = exec-&gt;argument(0);
1991     RELEASE_ASSERT(functionValue.isFunction(vm));
1992     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
1993 
1994     RELEASE_ASSERT(exec-&gt;argument(1).isString());
1995     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
1996     String sourceCodeText = executable-&gt;source().view().toString();
1997     unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
1998 
1999     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
2000     return JSValue::encode(JSONParse(exec, jsonString));
2001 }
2002 
2003 static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(ExecState* exec)
2004 {
2005     VM&amp; vm = exec-&gt;vm();
2006     RELEASE_ASSERT(vm.typeProfiler());
2007     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
2008 
2009     JSValue functionValue = exec-&gt;argument(0);
2010     RELEASE_ASSERT(functionValue.isFunction(vm));
2011     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2012 
2013     unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
2014     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
2015     return JSValue::encode(JSONParse(exec, jsonString));
2016 }
2017 
2018 static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(ExecState* exec)
2019 {
2020     VM&amp; vm = exec-&gt;vm();
2021     JSValue value = exec-&gt;argument(0);
2022     RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
2023     value.getObject()-&gt;flattenDictionaryObject(vm);
2024     return encodedJSUndefined();
2025 }
2026 
2027 static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(ExecState* exec)
2028 {
2029     VM&amp; vm = exec-&gt;vm();
2030     RELEASE_ASSERT(vm.controlFlowProfiler());
2031     vm.controlFlowProfiler()-&gt;dumpData();
2032     return JSValue::encode(jsUndefined());
2033 }
2034 
2035 static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(ExecState* exec)
2036 {
2037     VM&amp; vm = exec-&gt;vm();
2038     RELEASE_ASSERT(vm.controlFlowProfiler());
2039 
2040     JSValue functionValue = exec-&gt;argument(0);
2041     RELEASE_ASSERT(functionValue.isFunction(vm));
2042     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2043 
2044     RELEASE_ASSERT(exec-&gt;argument(1).isString());
2045     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
2046     String sourceCodeText = executable-&gt;source().view().toString();
2047     RELEASE_ASSERT(sourceCodeText.contains(substring));
2048     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2049 
2050     bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
2051     return JSValue::encode(jsBoolean(hasExecuted));
2052 }
2053 
2054 static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(ExecState* exec)
2055 {
2056     VM&amp; vm = exec-&gt;vm();
2057     RELEASE_ASSERT(vm.controlFlowProfiler());
2058 
2059     JSValue functionValue = exec-&gt;argument(0);
2060     RELEASE_ASSERT(functionValue.isFunction(vm));
2061     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2062 
2063     RELEASE_ASSERT(exec-&gt;argument(1).isString());
2064     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
2065     String sourceCodeText = executable-&gt;source().view().toString();
2066     RELEASE_ASSERT(sourceCodeText.contains(substring));
2067     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2068 
2069     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2070     return JSValue::encode(JSValue(executionCount));
2071 }
2072 
2073 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(ExecState*)
2074 {
2075     Options::useExceptionFuzz() = true;
2076     return JSValue::encode(jsUndefined());
2077 }
2078 
2079 static EncodedJSValue changeDebuggerModeWhenIdle(ExecState* exec, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
2080 {
2081     bool newDebuggerMode = codeGenerationMode.contains(CodeGenerationMode::Debugger);
2082     if (Options::forceDebuggerBytecodeGeneration() == newDebuggerMode)
2083         return JSValue::encode(jsUndefined());
2084 
2085     VM* vm = &amp;exec-&gt;vm();
2086     vm-&gt;whenIdle([=] () {
2087         Options::forceDebuggerBytecodeGeneration() = newDebuggerMode;
2088         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
2089         if (newDebuggerMode)
2090             vm-&gt;ensureShadowChicken();
2091     });
2092     return JSValue::encode(jsUndefined());
2093 }
2094 
2095 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(ExecState* exec)
2096 {
2097     return changeDebuggerModeWhenIdle(exec, { CodeGenerationMode::Debugger });
2098 }
2099 
2100 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(ExecState* exec)
2101 {
2102     return changeDebuggerModeWhenIdle(exec, { });
2103 }
2104 
2105 static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(ExecState* exec)
2106 {
2107     VM* vm = &amp;exec-&gt;vm();
2108     vm-&gt;whenIdle([=] () {
2109         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
2110     });
2111     return JSValue::encode(jsUndefined());
2112 }
2113 
2114 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(ExecState* exec)
2115 {
2116     return JSValue::encode(jsNumber(exec-&gt;vm().heap.globalObjectCount()));
2117 }
2118 
2119 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(ExecState* exec)
2120 {
2121     JSValue value = exec-&gt;argument(0);
2122     RELEASE_ASSERT(value.isObject());
2123     JSGlobalObject* globalObject = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(exec-&gt;vm());
2124     RELEASE_ASSERT(globalObject);
2125     return JSValue::encode(globalObject);
2126 }
2127 
2128 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(ExecState* exec)
2129 {
2130     VM&amp; vm = exec-&gt;vm();
2131     auto scope = DECLARE_THROW_SCOPE(vm);
2132 
2133     JSValue value = exec-&gt;argument(0);
2134     if (!value.isObject())
2135         return JSValue::encode(jsUndefined());
2136 
2137     JSValue property = exec-&gt;argument(1);
2138     if (!property.isString())
2139         return JSValue::encode(jsUndefined());
2140 
2141     auto propertyName = asString(property)-&gt;toIdentifier(exec);
2142     RETURN_IF_EXCEPTION(scope, { });
2143 
2144     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
2145     value.getPropertySlot(exec, propertyName, slot);
2146     RETURN_IF_EXCEPTION(scope, { });
2147 
2148     JSValue result;
2149     if (slot.isCacheableGetter())
2150         result = slot.getterSetter();
2151     else
2152         result = jsNull();
2153 
2154     return JSValue::encode(result);
2155 }
2156 
2157 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(ExecState* exec)
2158 {
2159     VM&amp; vm = exec-&gt;vm();
2160     auto scope = DECLARE_THROW_SCOPE(vm);
2161 
2162     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, exec-&gt;argument(0));
2163     if (UNLIKELY(!getterSetter)) {
2164         throwTypeError(exec, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);
2165         return encodedJSValue();
2166     }
2167 
2168     JSObject* getter = getterSetter-&gt;getter();
2169     RELEASE_ASSERT(getter);
2170     return JSValue::encode(getter);
2171 }
2172 
2173 static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(ExecState* exec)
2174 {
2175     VM&amp; vm = exec-&gt;vm();
2176     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
2177     return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
2178 }
2179 
2180 static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(ExecState* exec)
2181 {
2182     VM&amp; vm = exec-&gt;vm();
2183     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
2184     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));
2185     if (!a || !b)
2186         return JSValue::encode(jsNumber(PNaN));
2187 
2188     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2189     if (delta &lt; 0)
2190         return JSValue::encode(jsNumber(PNaN));
2191     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2192         return JSValue::encode(jsNumber(PNaN));
2193     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2194 }
2195 
2196 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(ExecState* exec)
2197 {
2198     VM&amp; vm = exec-&gt;vm();
2199     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2200 }
2201 
2202 static EncodedJSValue JSC_HOST_CALL functionParseCount(ExecState*)
2203 {
2204     return JSValue::encode(jsNumber(globalParseCount.load()));
2205 }
2206 
2207 static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(ExecState*)
2208 {
2209 #if ENABLE(WEBASSEMBLY)
2210     return JSValue::encode(jsBoolean(Wasm::isSupported()));
2211 #else
2212     return JSValue::encode(jsBoolean(false));
2213 #endif
2214 }
2215 
2216 void JSDollarVM::finishCreation(VM&amp; vm)
2217 {
2218     Base::finishCreation(vm);
2219 
2220     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2221 
2222     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2223         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2224     };
2225     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2226         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2227     };
2228 
2229     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2230     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2231     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2232 
2233     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2234     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2235 
2236     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);
2237     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);
2238     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);
2239     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);
2240     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2241 
2242     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2243     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2244 
2245     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
2246 
2247     addFunction(vm, &quot;gc&quot;, functionGC, 0);
2248     addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
2249     addFunction(vm, &quot;dumpSubspaceHashes&quot;, functionDumpSubspaceHashes, 0);
2250 
2251     addFunction(vm, &quot;callFrame&quot;, functionCallFrame, 1);
2252     addFunction(vm, &quot;codeBlockFor&quot;, functionCodeBlockFor, 1);
2253     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2254     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2255     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2256 
2257     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2258     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2259     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2260     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2261     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2262 
2263     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2264 
2265     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2266     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2267     addFunction(vm, &quot;value&quot;, functionValue, 1);
2268     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2269 
2270     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2271     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2272 
2273     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2274     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2275     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
2276     addFunction(vm, &quot;createNullRopeString&quot;, functionCreateNullRopeString, 0);
2277 
2278     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2279     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2280     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2281     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2282     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2283     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2284     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2285     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2286     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2287 #if ENABLE(WEBASSEMBLY)
2288     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2289 #endif
2290     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2291     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2292 
2293     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2294     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2295     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2296 
2297     addConstructibleFunction(vm, &quot;SimpleObject&quot;, functionCreateSimpleObject, 0);
2298     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2299     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2300 
2301     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2302     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2303 
2304     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2305     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2306 
2307     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2308 
2309     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2310     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2311     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2312 
2313     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2314 
2315     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2316     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2317 
2318     addFunction(vm, &quot;deleteAllCodeWhenIdle&quot;, functionDeleteAllCodeWhenIdle, 0);
2319 
2320     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2321     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2322 
2323     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2324     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2325     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2326 
2327     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2328 
2329     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
2330 
2331     addFunction(vm, &quot;parseCount&quot;, functionParseCount, 0);
2332 
2333     addFunction(vm, &quot;isWasmSupported&quot;, functionIsWasmSupported, 0);
2334 }
2335 
2336 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2337 {
2338     Identifier identifier = Identifier::fromString(vm, name);
2339     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2340 }
2341 
2342 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2343 {
2344     Identifier identifier = Identifier::fromString(vm, name);
2345     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2346 }
2347 
2348 } // namespace JSC
    </pre>
  </body>
</html>