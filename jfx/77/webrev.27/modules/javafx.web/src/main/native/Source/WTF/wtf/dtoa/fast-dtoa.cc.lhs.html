<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fast-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2012 the V8 project authors. All rights reserved.
  2 // Redistribution and use in source and binary forms, with or without
  3 // modification, are permitted provided that the following conditions are
  4 // met:
  5 //
  6 //     * Redistributions of source code must retain the above copyright
  7 //       notice, this list of conditions and the following disclaimer.
  8 //     * Redistributions in binary form must reproduce the above
  9 //       copyright notice, this list of conditions and the following
 10 //       disclaimer in the documentation and/or other materials provided
 11 //       with the distribution.
 12 //     * Neither the name of Google Inc. nor the names of its
 13 //       contributors may be used to endorse or promote products derived
 14 //       from this software without specific prior written permission.
 15 //
 16 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27 
 28 #include &quot;config.h&quot;
 29 
 30 #include &lt;wtf/dtoa/fast-dtoa.h&gt;
 31 
 32 #include &lt;wtf/dtoa/cached-powers.h&gt;
 33 #include &lt;wtf/dtoa/diy-fp.h&gt;
 34 #include &lt;wtf/dtoa/ieee.h&gt;
 35 
 36 namespace WTF {
 37 namespace double_conversion {
<a name="1" id="anc1"></a><span class="line-modified"> 38     </span>
 39 // The minimal and maximal target exponent define the range of w&#39;s binary
 40 // exponent, where &#39;w&#39; is the result of multiplying the input by a cached power
 41 // of ten.
 42 //
 43 // A different range might be chosen on a different platform, to optimize digit
 44 // generation, but a smaller range requires more powers of ten to be cached.
 45 static const int kMinimalTargetExponent = -60;
 46 static const int kMaximalTargetExponent = -32;
<a name="2" id="anc2"></a><span class="line-modified"> 47     </span>
<span class="line-modified"> 48     </span>
 49 // Adjusts the last digit of the generated number, and screens out generated
 50 // solutions that may be inaccurate. A solution may be inaccurate if it is
 51 // outside the safe interval, or if we cannot prove that it is closer to the
 52 // input than a neighboring representation of the same length.
 53 //
 54 // Input: * buffer containing the digits of too_high / 10^kappa
 55 //        * the buffer&#39;s length
 56 //        * distance_too_high_w == (too_high - w).f() * unit
 57 //        * unsafe_interval == (too_high - too_low).f() * unit
 58 //        * rest = (too_high - buffer * 10^kappa).f() * unit
 59 //        * ten_kappa = 10^kappa * unit
 60 //        * unit = the common multiplier
 61 // Output: returns true if the buffer is guaranteed to contain the closest
 62 //    representable number to the input.
 63 //  Modifies the generated digits in the buffer to approach (round towards) w.
 64 static bool RoundWeed(BufferReference&lt;char&gt; buffer,
<a name="3" id="anc3"></a><span class="line-modified"> 65                           int length,</span>
<span class="line-modified"> 66                           uint64_t distance_too_high_w,</span>
<span class="line-modified"> 67                           uint64_t unsafe_interval,</span>
<span class="line-modified"> 68                           uint64_t rest,</span>
<span class="line-modified"> 69                           uint64_t ten_kappa,</span>
<span class="line-modified"> 70                           uint64_t unit) {</span>
<span class="line-modified"> 71         uint64_t small_distance = distance_too_high_w - unit;</span>
<span class="line-modified"> 72         uint64_t big_distance = distance_too_high_w + unit;</span>
<span class="line-modified"> 73         // Let w_low  = too_high - big_distance, and</span>
<span class="line-modified"> 74         //     w_high = too_high - small_distance.</span>
<span class="line-modified"> 75         // Note: w_low &lt; w &lt; w_high</span>
<span class="line-modified"> 76         //</span>
<span class="line-modified"> 77         // The real w (* unit) must lie somewhere inside the interval</span>
<span class="line-modified"> 78         // ]w_low; w_high[ (often written as &quot;(w_low; w_high)&quot;)</span>
<span class="line-modified"> 79         </span>
<span class="line-modified"> 80         // Basically the buffer currently contains a number in the unsafe interval</span>
<span class="line-modified"> 81         // ]too_low; too_high[ with too_low &lt; w &lt; too_high</span>
<span class="line-modified"> 82         //</span>
<span class="line-modified"> 83         //  too_high - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="line-modified"> 84         //                     ^v 1 unit            ^      ^                 ^      ^</span>
<span class="line-modified"> 85         //  boundary_high ---------------------     .      .                 .      .</span>
<span class="line-modified"> 86         //                     ^v 1 unit            .      .                 .      .</span>
<span class="line-modified"> 87         //   - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .</span>
<span class="line-modified"> 88         //                                          .      .         ^       .      .</span>
<span class="line-modified"> 89         //                                          .  big_distance  .       .      .</span>
<span class="line-modified"> 90         //                                          .      .         .       .    rest</span>
<span class="line-modified"> 91         //                              small_distance     .         .       .      .</span>
<span class="line-modified"> 92         //                                          v      .         .       .      .</span>
<span class="line-modified"> 93         //  w_high - - - - - - - - - - - - - - - - - -     .         .       .      .</span>
<span class="line-modified"> 94         //                     ^v 1 unit                   .         .       .      .</span>
<span class="line-modified"> 95         //  w ----------------------------------------     .         .       .      .</span>
<span class="line-modified"> 96         //                     ^v 1 unit                   v         .       .      .</span>
<span class="line-modified"> 97         //  w_low  - - - - - - - - - - - - - - - - - - - - -         .       .      .</span>
<span class="line-modified"> 98         //                                                           .       .      v</span>
<span class="line-modified"> 99         //  buffer --------------------------------------------------+-------+--------</span>
<span class="line-modified">100         //                                                           .       .</span>
<span class="line-modified">101         //                                                  safe_interval    .</span>
<span class="line-modified">102         //                                                           v       .</span>
<span class="line-modified">103         //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .</span>
<span class="line-modified">104         //                     ^v 1 unit                                     .</span>
<span class="line-modified">105         //  boundary_low -------------------------                     unsafe_interval</span>
<span class="line-modified">106         //                     ^v 1 unit                                     v</span>
<span class="line-modified">107         //  too_low  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="line-modified">108         //</span>
<span class="line-modified">109         //</span>
<span class="line-modified">110         // Note that the value of buffer could lie anywhere inside the range too_low</span>
<span class="line-modified">111         // to too_high.</span>
<span class="line-modified">112         //</span>
<span class="line-modified">113         // boundary_low, boundary_high and w are approximations of the real boundaries</span>
<span class="line-modified">114         // and v (the input number). They are guaranteed to be precise up to one unit.</span>
<span class="line-modified">115         // In fact the error is guaranteed to be strictly less than one unit.</span>
<span class="line-modified">116         //</span>
<span class="line-modified">117         // Anything that lies outside the unsafe interval is guaranteed not to round</span>
<span class="line-modified">118         // to v when read again.</span>
<span class="line-modified">119         // Anything that lies inside the safe interval is guaranteed to round to v</span>
<span class="line-modified">120         // when read again.</span>
<span class="line-modified">121         // If the number inside the buffer lies inside the unsafe interval but not</span>
<span class="line-modified">122         // inside the safe interval then we simply do not know and bail out (returning</span>
<span class="line-modified">123         // false).</span>
<span class="line-modified">124         //</span>
<span class="line-modified">125         // Similarly we have to take into account the imprecision of &#39;w&#39; when finding</span>
<span class="line-modified">126         // the closest representation of &#39;w&#39;. If we have two potential</span>
<span class="line-modified">127         // representations, and one is closer to both w_low and w_high, then we know</span>
<span class="line-modified">128         // it is closer to the actual value v.</span>
<span class="line-modified">129         //</span>
<span class="line-modified">130         // By generating the digits of too_high we got the largest (closest to</span>
<span class="line-modified">131         // too_high) buffer that is still in the unsafe interval. In the case where</span>
<span class="line-modified">132         // w_high &lt; buffer &lt; too_high we try to decrement the buffer.</span>
<span class="line-modified">133         // This way the buffer approaches (rounds towards) w.</span>
<span class="line-modified">134         // There are 3 conditions that stop the decrementation process:</span>
<span class="line-modified">135         //   1) the buffer is already below w_high</span>
<span class="line-modified">136         //   2) decrementing the buffer would make it leave the unsafe interval</span>
<span class="line-modified">137         //   3) decrementing the buffer would yield a number below w_high and farther</span>
<span class="line-modified">138         //      away than the current number. In other words:</span>
<span class="line-modified">139         //              (buffer{-1} &lt; w_high) &amp;&amp; w_high - buffer{-1} &gt; buffer - w_high</span>
<span class="line-modified">140         // Instead of using the buffer directly we use its distance to too_high.</span>
<span class="line-modified">141         // Conceptually rest ~= too_high - buffer</span>
<span class="line-modified">142         // We need to do the following tests in this order to avoid over- and</span>
<span class="line-modified">143         // underflows.</span>
<span class="line-modified">144         ASSERT(rest &lt;= unsafe_interval);</span>
<span class="line-modified">145         while (rest &lt; small_distance &amp;&amp;  // Negated condition 1</span>
<span class="line-modified">146                unsafe_interval - rest &gt;= ten_kappa &amp;&amp;  // Negated condition 2</span>
<span class="line-modified">147                (rest + ten_kappa &lt; small_distance ||  // buffer{-1} &gt; w_high</span>
<span class="line-modified">148                 small_distance - rest &gt;= rest + ten_kappa - small_distance)) {</span>
<span class="line-modified">149                    buffer[length - 1]--;</span>
<span class="line-modified">150                    rest += ten_kappa;</span>
<span class="line-modified">151                }</span>
<span class="line-modified">152         </span>
<span class="line-modified">153         // We have approached w+ as much as possible. We now test if approaching w-</span>
<span class="line-modified">154         // would require changing the buffer. If yes, then we have two possible</span>
<span class="line-modified">155         // representations close to w, but we cannot decide which one is closer.</span>
<span class="line-modified">156         if (rest &lt; big_distance &amp;&amp;</span>
<span class="line-modified">157             unsafe_interval - rest &gt;= ten_kappa &amp;&amp;</span>
<span class="line-modified">158             (rest + ten_kappa &lt; big_distance ||</span>
<span class="line-modified">159              big_distance - rest &gt; rest + ten_kappa - big_distance)) {</span>
<span class="line-modified">160                 return false;</span>
<span class="line-modified">161             }</span>
<span class="line-modified">162         </span>
<span class="line-modified">163         // Weeding test.</span>
<span class="line-modified">164         //   The safe interval is [too_low + 2 ulp; too_high - 2 ulp]</span>
<span class="line-modified">165         //   Since too_low = too_high - unsafe_interval this is equivalent to</span>
<span class="line-modified">166         //      [too_high - unsafe_interval + 4 ulp; too_high - 2 ulp]</span>
<span class="line-modified">167         //   Conceptually we have: rest ~= too_high - buffer</span>
<span class="line-modified">168         return (2 * unit &lt;= rest) &amp;&amp; (rest &lt;= unsafe_interval - 4 * unit);</span>
169 }
<a name="4" id="anc4"></a><span class="line-modified">170     </span>
<span class="line-modified">171     </span>
172 // Rounds the buffer upwards if the result is closer to v by possibly adding
173 // 1 to the buffer. If the precision of the calculation is not sufficient to
174 // round correctly, return false.
175 // The rounding might shift the whole buffer in which case the kappa is
176 // adjusted. For example &quot;99&quot;, kappa = 3 might become &quot;10&quot;, kappa = 4.
177 //
178 // If 2*rest &gt; ten_kappa then the buffer needs to be round up.
179 // rest can have an error of +/- 1 unit. This function accounts for the
180 // imprecision and returns false, if the rounding direction cannot be
181 // unambiguously determined.
182 //
183 // Precondition: rest &lt; ten_kappa.
184 static bool RoundWeedCounted(BufferReference&lt;char&gt; buffer,
<a name="5" id="anc5"></a><span class="line-modified">185                                  int length,</span>
<span class="line-modified">186                                  uint64_t rest,</span>
<span class="line-modified">187                                  uint64_t ten_kappa,</span>
<span class="line-modified">188                                  uint64_t unit,</span>
<span class="line-modified">189                                  int* kappa) {</span>
<span class="line-modified">190         ASSERT(rest &lt; ten_kappa);</span>
<span class="line-modified">191         // The following tests are done in a specific order to avoid overflows. They</span>
<span class="line-modified">192         // will work correctly with any uint64 values of rest &lt; ten_kappa and unit.</span>
<span class="line-modified">193         //</span>
<span class="line-modified">194         // If the unit is too big, then we don&#39;t know which way to round. For example</span>
<span class="line-modified">195         // a unit of 50 means that the real number lies within rest +/- 50. If</span>
<span class="line-modified">196         // 10^kappa == 40 then there is no way to tell which way to round.</span>
<span class="line-modified">197         if (unit &gt;= ten_kappa) return false;</span>
<span class="line-modified">198         // Even if unit is just half the size of 10^kappa we are already completely</span>
<span class="line-modified">199         // lost. (And after the previous test we know that the expression will not</span>
<span class="line-modified">200         // over/underflow.)</span>
<span class="line-modified">201         if (ten_kappa - unit &lt;= unit) return false;</span>
<span class="line-modified">202         // If 2 * (rest + unit) &lt;= 10^kappa we can safely round down.</span>
<span class="line-modified">203         if ((ten_kappa - rest &gt; rest) &amp;&amp; (ten_kappa - 2 * rest &gt;= 2 * unit)) {</span>
<span class="line-modified">204             return true;</span>
<span class="line-modified">205         }</span>
<span class="line-modified">206         // If 2 * (rest - unit) &gt;= 10^kappa, then we can safely round up.</span>
<span class="line-modified">207         if ((rest &gt; unit) &amp;&amp; (ten_kappa - (rest - unit) &lt;= (rest - unit))) {</span>
<span class="line-modified">208             // Increment the last digit recursively until we find a non &#39;9&#39; digit.</span>
<span class="line-modified">209             buffer[length - 1]++;</span>
<span class="line-modified">210             for (int i = length - 1; i &gt; 0; --i) {</span>
<span class="line-modified">211                 if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="line-modified">212                 buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">213                 buffer[i - 1]++;</span>
<span class="line-modified">214             }</span>
<span class="line-modified">215             // If the first digit is now &#39;0&#39;+ 10 we had a buffer with all &#39;9&#39;s. With the</span>
<span class="line-modified">216             // exception of the first digit all digits are now &#39;0&#39;. Simply switch the</span>
<span class="line-modified">217             // first digit to &#39;1&#39; and adjust the kappa. Example: &quot;99&quot; becomes &quot;10&quot; and</span>
<span class="line-modified">218             // the power (the kappa) is increased.</span>
<span class="line-modified">219             if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">220                 buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">221                 (*kappa) += 1;</span>
<span class="line-modified">222             }</span>
<span class="line-modified">223             return true;</span>
<span class="line-modified">224         }</span>
<span class="line-modified">225         return false;</span>
226 }
<a name="6" id="anc6"></a><span class="line-modified">227     </span>
228 // Returns the biggest power of ten that is less than or equal to the given
229 // number. We furthermore receive the maximum number of bits &#39;number&#39; has.
230 //
231 // Returns power == 10^(exponent_plus_one-1) such that
232 //    power &lt;= number &lt; power * 10.
233 // If number_bits == 0 then 0^(0-1) is returned.
234 // The number of bits must be &lt;= 32.
235 // Precondition: number &lt; (1 &lt;&lt; (number_bits + 1)).
236 
237 // Inspired by the method for finding an integer log base 10 from here:
238 // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
239 static unsigned int const kSmallPowersOfTen[] =
240     {0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,
241      1000000000};
<a name="7" id="anc7"></a><span class="line-modified">242     </span>
243 static void BiggestPowerTen(uint32_t number,
<a name="8" id="anc8"></a><span class="line-modified">244                                 int number_bits,</span>
<span class="line-modified">245                                 uint32_t* power,</span>
246                             int* exponent_plus_one) {
247   ASSERT(number &lt; (1u &lt;&lt; (number_bits + 1)));
248   // 1233/4096 is approximately 1/lg(10).
249   int exponent_plus_one_guess = ((number_bits + 1) * 1233 &gt;&gt; 12);
250   // We increment to skip over the first entry in the kPowersOf10 table.
251   // Note: kPowersOf10[i] == 10^(i-1).
252   exponent_plus_one_guess++;
253   // We don&#39;t have any guarantees that 2^number_bits &lt;= number.
254   if (number &lt; kSmallPowersOfTen[exponent_plus_one_guess]) {
255     exponent_plus_one_guess--;
256   }
257   *power = kSmallPowersOfTen[exponent_plus_one_guess];
258   *exponent_plus_one = exponent_plus_one_guess;
259 }
260 
261 // Generates the digits of input number w.
262 // w is a floating-point number (DiyFp), consisting of a significand and an
263 // exponent. Its exponent is bounded by kMinimalTargetExponent and
264 // kMaximalTargetExponent.
265 //       Hence -60 &lt;= w.e() &lt;= -32.
266 //
267 // Returns false if it fails, in which case the generated digits in the buffer
268 // should not be used.
269 // Preconditions:
270 //  * low, w and high are correct up to 1 ulp (unit in the last place). That
271 //    is, their error must be less than a unit of their last digits.
272 //  * low.e() == w.e() == high.e()
273 //  * low &lt; w &lt; high, and taking into account their error: low~ &lt;= high~
274 //  * kMinimalTargetExponent &lt;= w.e() &lt;= kMaximalTargetExponent
275 // Postconditions: returns false if procedure fails.
276 //   otherwise:
277 //     * buffer is not null-terminated, but len contains the number of digits.
278 //     * buffer contains the shortest possible decimal digit-sequence
279 //       such that LOW &lt; buffer * 10^kappa &lt; HIGH, where LOW and HIGH are the
280 //       correct values of low and high (without their error).
281 //     * if more than one decimal representation gives the minimal number of
282 //       decimal digits then the one closest to W (where W is the correct value
283 //       of w) is chosen.
284 // Remark: this procedure takes into account the imprecision of its input
285 //   numbers. If the precision is not enough to guarantee all the postconditions
286 //   then false is returned. This usually happens rarely (~0.5%).
287 //
288 // Say, for the sake of example, that
289 //   w.e() == -48, and w.f() == 0x1234567890abcdef
290 // w&#39;s value can be computed by w.f() * 2^w.e()
291 // We can obtain w&#39;s integral digits by simply shifting w.f() by -w.e().
292 //  -&gt; w&#39;s integral part is 0x1234
293 //  w&#39;s fractional part is therefore 0x567890abcdef.
294 // Printing w&#39;s integral part is easy (simply print 0x1234 in decimal).
295 // In order to print its fraction we repeatedly multiply the fraction by 10 and
296 // get each digit. Example the first digit after the point would be computed by
297 //   (0x567890abcdef * 10) &gt;&gt; 48. -&gt; 3
298 // The whole thing becomes slightly more complicated because we want to stop
299 // once we have enough digits. That is, once the digits inside the buffer
300 // represent &#39;w&#39; we can stop. Everything inside the interval low - high
301 // represents w. However we have to pay attention to low, high and w&#39;s
302 // imprecision.
303 static bool DigitGen(DiyFp low,
<a name="9" id="anc9"></a><span class="line-modified">304                          DiyFp w,</span>
<span class="line-modified">305                          DiyFp high,</span>
<span class="line-modified">306                          BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">307                          int* length,</span>
<span class="line-modified">308                          int* kappa) {</span>
<span class="line-modified">309         ASSERT(low.e() == w.e() &amp;&amp; w.e() == high.e());</span>
<span class="line-modified">310         ASSERT(low.f() + 1 &lt;= high.f() - 1);</span>
<span class="line-modified">311         ASSERT(kMinimalTargetExponent &lt;= w.e() &amp;&amp; w.e() &lt;= kMaximalTargetExponent);</span>
<span class="line-modified">312         // low, w and high are imprecise, but by less than one ulp (unit in the last</span>
<span class="line-modified">313         // place).</span>
<span class="line-modified">314         // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that</span>
<span class="line-modified">315         // the new numbers are outside of the interval we want the final</span>
<span class="line-modified">316         // representation to lie in.</span>
<span class="line-modified">317         // Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield</span>
<span class="line-modified">318         // numbers that are certain to lie in the interval. We will use this fact</span>
<span class="line-modified">319         // later on.</span>
<span class="line-modified">320         // We will now start by generating the digits within the uncertain</span>
<span class="line-modified">321         // interval. Later we will weed out representations that lie outside the safe</span>
<span class="line-modified">322         // interval and thus _might_ lie outside the correct interval.</span>
<span class="line-modified">323         uint64_t unit = 1;</span>
<span class="line-modified">324         DiyFp too_low = DiyFp(low.f() - unit, low.e());</span>
<span class="line-modified">325         DiyFp too_high = DiyFp(high.f() + unit, high.e());</span>
<span class="line-modified">326         // too_low and too_high are guaranteed to lie outside the interval we want the</span>
<span class="line-modified">327         // generated number in.</span>
<span class="line-modified">328         DiyFp unsafe_interval = DiyFp::Minus(too_high, too_low);</span>
<span class="line-modified">329         // We now cut the input number into two parts: the integral digits and the</span>
<span class="line-modified">330         // fractionals. We will not write any decimal separator though, but adapt</span>
<span class="line-modified">331         // kappa instead.</span>
<span class="line-modified">332         // Reminder: we are currently computing the digits (stored inside the buffer)</span>
<span class="line-modified">333         // such that:   too_low &lt; buffer * 10^kappa &lt; too_high</span>
<span class="line-modified">334         // We use too_high for the digit_generation and stop as soon as possible.</span>
<span class="line-modified">335         // If we stop early we effectively round down.</span>
<span class="line-modified">336         DiyFp one = DiyFp(static_cast&lt;uint64_t&gt;(1) &lt;&lt; -w.e(), w.e());</span>
<span class="line-modified">337         // Division by one is a shift.</span>
<span class="line-modified">338         uint32_t integrals = static_cast&lt;uint32_t&gt;(too_high.f() &gt;&gt; -one.e());</span>
<span class="line-modified">339         // Modulo by one is an and.</span>
<span class="line-modified">340         uint64_t fractionals = too_high.f() &amp; (one.f() - 1);</span>
<span class="line-modified">341         uint32_t divisor;</span>
342   int divisor_exponent_plus_one;
<a name="10" id="anc10"></a><span class="line-modified">343         BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),</span>
344                   &amp;divisor, &amp;divisor_exponent_plus_one);
345   *kappa = divisor_exponent_plus_one;
<a name="11" id="anc11"></a><span class="line-modified">346         *length = 0;</span>
<span class="line-modified">347         // Loop invariant: buffer = too_high / 10^kappa  (integer division)</span>
<span class="line-modified">348         // The invariant holds for the first iteration: kappa has been initialized</span>
<span class="line-modified">349         // with the divisor exponent + 1. And the divisor is the biggest power of ten</span>
<span class="line-modified">350         // that is smaller than integrals.</span>
<span class="line-modified">351         while (*kappa &gt; 0) {</span>
<span class="line-modified">352             int digit = integrals / divisor;</span>
353     ASSERT(digit &lt;= 9);
354     buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<a name="12" id="anc12"></a><span class="line-modified">355             (*length)++;</span>
<span class="line-modified">356             integrals %= divisor;</span>
<span class="line-modified">357             (*kappa)--;</span>
<span class="line-modified">358             // Note that kappa now equals the exponent of the divisor and that the</span>
<span class="line-modified">359             // invariant thus holds again.</span>
<span class="line-modified">360             uint64_t rest =</span>
<span class="line-modified">361             (static_cast&lt;uint64_t&gt;(integrals) &lt;&lt; -one.e()) + fractionals;</span>
<span class="line-modified">362             // Invariant: too_high = buffer * 10^kappa + DiyFp(rest, one.e())</span>
<span class="line-modified">363             // Reminder: unsafe_interval.e() == one.e()</span>
<span class="line-modified">364             if (rest &lt; unsafe_interval.f()) {</span>
<span class="line-modified">365                 // Rounding down (by not emitting the remaining digits) yields a number</span>
<span class="line-modified">366                 // that lies within the unsafe interval.</span>
<span class="line-modified">367                 return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f(),</span>
<span class="line-modified">368                                  unsafe_interval.f(), rest,</span>
<span class="line-modified">369                                  static_cast&lt;uint64_t&gt;(divisor) &lt;&lt; -one.e(), unit);</span>
<span class="line-modified">370             }</span>
<span class="line-modified">371             divisor /= 10;</span>
<span class="line-modified">372         }</span>
<span class="line-modified">373         </span>
<span class="line-modified">374         // The integrals have been generated. We are at the point of the decimal</span>
<span class="line-modified">375         // separator. In the following loop we simply multiply the remaining digits by</span>
<span class="line-modified">376         // 10 and divide by one. We just need to pay attention to multiply associated</span>
<span class="line-modified">377         // data (like the interval or &#39;unit&#39;), too.</span>
<span class="line-modified">378         // Note that the multiplication by 10 does not overflow, because w.e &gt;= -60</span>
<span class="line-modified">379         // and thus one.e &gt;= -60.</span>
<span class="line-modified">380         ASSERT(one.e() &gt;= -60);</span>
<span class="line-modified">381         ASSERT(fractionals &lt; one.f());</span>
<span class="line-modified">382         ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 &gt;= one.f());</span>
383   for (;;) {
<a name="13" id="anc13"></a><span class="line-modified">384             fractionals *= 10;</span>
<span class="line-modified">385             unit *= 10;</span>
<span class="line-modified">386             unsafe_interval.set_f(unsafe_interval.f() * 10);</span>
<span class="line-modified">387             // Integer division by one.</span>
<span class="line-modified">388             int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; -one.e());</span>
389     ASSERT(digit &lt;= 9);
390     buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<a name="14" id="anc14"></a><span class="line-modified">391             (*length)++;</span>
<span class="line-modified">392             fractionals &amp;= one.f() - 1;  // Modulo by one.</span>
<span class="line-modified">393             (*kappa)--;</span>
<span class="line-modified">394             if (fractionals &lt; unsafe_interval.f()) {</span>
<span class="line-modified">395                 return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f() * unit,</span>
<span class="line-modified">396                                  unsafe_interval.f(), fractionals, one.f(), unit);</span>
<span class="line-modified">397             }</span>
<span class="line-modified">398         }</span>
399 }
<a name="15" id="anc15"></a><span class="line-modified">400     </span>
<span class="line-modified">401     </span>
<span class="line-modified">402     </span>
403 // Generates (at most) requested_digits digits of input number w.
404 // w is a floating-point number (DiyFp), consisting of a significand and an
405 // exponent. Its exponent is bounded by kMinimalTargetExponent and
406 // kMaximalTargetExponent.
407 //       Hence -60 &lt;= w.e() &lt;= -32.
408 //
409 // Returns false if it fails, in which case the generated digits in the buffer
410 // should not be used.
411 // Preconditions:
412 //  * w is correct up to 1 ulp (unit in the last place). That
413 //    is, its error must be strictly less than a unit of its last digit.
414 //  * kMinimalTargetExponent &lt;= w.e() &lt;= kMaximalTargetExponent
415 //
416 // Postconditions: returns false if procedure fails.
417 //   otherwise:
418 //     * buffer is not null-terminated, but length contains the number of
419 //       digits.
420 //     * the representation in buffer is the most precise representation of
421 //       requested_digits digits.
422 //     * buffer contains at most requested_digits digits of w. If there are less
423 //       than requested_digits digits then some trailing &#39;0&#39;s have been removed.
424 //     * kappa is such that
425 //            w = buffer * 10^kappa + eps with |eps| &lt; 10^kappa / 2.
426 //
427 // Remark: This procedure takes into account the imprecision of its input
428 //   numbers. If the precision is not enough to guarantee all the postconditions
429 //   then false is returned. This usually happens rarely, but the failure-rate
430 //   increases with higher requested_digits.
431 static bool DigitGenCounted(DiyFp w,
<a name="16" id="anc16"></a><span class="line-modified">432                                 int requested_digits,</span>
<span class="line-modified">433                                 BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">434                                 int* length,</span>
<span class="line-modified">435                                 int* kappa) {</span>
<span class="line-modified">436         ASSERT(kMinimalTargetExponent &lt;= w.e() &amp;&amp; w.e() &lt;= kMaximalTargetExponent);</span>
<span class="line-modified">437         ASSERT(kMinimalTargetExponent &gt;= -60);</span>
<span class="line-modified">438         ASSERT(kMaximalTargetExponent &lt;= -32);</span>
<span class="line-modified">439         // w is assumed to have an error less than 1 unit. Whenever w is scaled we</span>
<span class="line-modified">440         // also scale its error.</span>
<span class="line-modified">441         uint64_t w_error = 1;</span>
<span class="line-modified">442         // We cut the input number into two parts: the integral digits and the</span>
<span class="line-modified">443         // fractional digits. We don&#39;t emit any decimal separator, but adapt kappa</span>
<span class="line-modified">444         // instead. Example: instead of writing &quot;1.2&quot; we put &quot;12&quot; into the buffer and</span>
<span class="line-modified">445         // increase kappa by 1.</span>
<span class="line-modified">446         DiyFp one = DiyFp(static_cast&lt;uint64_t&gt;(1) &lt;&lt; -w.e(), w.e());</span>
<span class="line-modified">447         // Division by one is a shift.</span>
<span class="line-modified">448         uint32_t integrals = static_cast&lt;uint32_t&gt;(w.f() &gt;&gt; -one.e());</span>
<span class="line-modified">449         // Modulo by one is an and.</span>
<span class="line-modified">450         uint64_t fractionals = w.f() &amp; (one.f() - 1);</span>
<span class="line-modified">451         uint32_t divisor;</span>
452   int divisor_exponent_plus_one;
<a name="17" id="anc17"></a><span class="line-modified">453         BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),</span>
454                   &amp;divisor, &amp;divisor_exponent_plus_one);
455   *kappa = divisor_exponent_plus_one;
<a name="18" id="anc18"></a><span class="line-modified">456         *length = 0;</span>
<span class="line-modified">457         </span>
<span class="line-modified">458         // Loop invariant: buffer = w / 10^kappa  (integer division)</span>
<span class="line-modified">459         // The invariant holds for the first iteration: kappa has been initialized</span>
<span class="line-modified">460         // with the divisor exponent + 1. And the divisor is the biggest power of ten</span>
<span class="line-modified">461         // that is smaller than &#39;integrals&#39;.</span>
<span class="line-modified">462         while (*kappa &gt; 0) {</span>
<span class="line-modified">463             int digit = integrals / divisor;</span>
464     ASSERT(digit &lt;= 9);
465     buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<a name="19" id="anc19"></a><span class="line-modified">466             (*length)++;</span>
<span class="line-modified">467             requested_digits--;</span>
<span class="line-modified">468             integrals %= divisor;</span>
<span class="line-modified">469             (*kappa)--;</span>
<span class="line-modified">470             // Note that kappa now equals the exponent of the divisor and that the</span>
<span class="line-modified">471             // invariant thus holds again.</span>
<span class="line-modified">472             if (requested_digits == 0) break;</span>
<span class="line-modified">473             divisor /= 10;</span>
<span class="line-modified">474         }</span>
<span class="line-modified">475         </span>
<span class="line-modified">476         if (requested_digits == 0) {</span>
<span class="line-modified">477             uint64_t rest =</span>
<span class="line-modified">478             (static_cast&lt;uint64_t&gt;(integrals) &lt;&lt; -one.e()) + fractionals;</span>
<span class="line-modified">479             return RoundWeedCounted(buffer, *length, rest,</span>
<span class="line-modified">480                                     static_cast&lt;uint64_t&gt;(divisor) &lt;&lt; -one.e(), w_error,</span>
<span class="line-modified">481                                     kappa);</span>
<span class="line-modified">482         }</span>
<span class="line-modified">483         </span>
<span class="line-modified">484         // The integrals have been generated. We are at the point of the decimal</span>
<span class="line-modified">485         // separator. In the following loop we simply multiply the remaining digits by</span>
<span class="line-modified">486         // 10 and divide by one. We just need to pay attention to multiply associated</span>
<span class="line-modified">487         // data (the &#39;unit&#39;), too.</span>
<span class="line-modified">488         // Note that the multiplication by 10 does not overflow, because w.e &gt;= -60</span>
<span class="line-modified">489         // and thus one.e &gt;= -60.</span>
<span class="line-modified">490         ASSERT(one.e() &gt;= -60);</span>
<span class="line-modified">491         ASSERT(fractionals &lt; one.f());</span>
<span class="line-modified">492         ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 &gt;= one.f());</span>
<span class="line-modified">493         while (requested_digits &gt; 0 &amp;&amp; fractionals &gt; w_error) {</span>
<span class="line-modified">494             fractionals *= 10;</span>
<span class="line-modified">495             w_error *= 10;</span>
<span class="line-modified">496             // Integer division by one.</span>
<span class="line-modified">497             int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; -one.e());</span>
498     ASSERT(digit &lt;= 9);
499     buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<a name="20" id="anc20"></a><span class="line-modified">500             (*length)++;</span>
<span class="line-modified">501             requested_digits--;</span>
<span class="line-modified">502             fractionals &amp;= one.f() - 1;  // Modulo by one.</span>
<span class="line-modified">503             (*kappa)--;</span>
<span class="line-modified">504         }</span>
<span class="line-modified">505         if (requested_digits != 0) return false;</span>
<span class="line-modified">506         return RoundWeedCounted(buffer, *length, fractionals, one.f(), w_error,</span>
<span class="line-modified">507                                 kappa);</span>
508 }
<a name="21" id="anc21"></a><span class="line-modified">509     </span>
<span class="line-modified">510     </span>
511 // Provides a decimal representation of v.
512 // Returns true if it succeeds, otherwise the result cannot be trusted.
513 // There will be *length digits inside the buffer (not null-terminated).
514 // If the function returns true then
515 //        v == (double) (buffer * 10^decimal_exponent).
516 // The digits in the buffer are the shortest representation possible: no
517 // 0.09999999999999999 instead of 0.1. The shorter representation will even be
518 // chosen even if the longer one would be closer to v.
519 // The last digit will be closest to the actual v. That is, even if several
520 // digits might correctly yield &#39;v&#39; when read again, the closest will be
521 // computed.
522 static bool Grisu3(double v,
523                    FastDtoaMode mode,
<a name="22" id="anc22"></a><span class="line-modified">524                        BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">525                        int* length,</span>
<span class="line-modified">526                        int* decimal_exponent) {</span>
<span class="line-modified">527         DiyFp w = Double(v).AsNormalizedDiyFp();</span>
<span class="line-modified">528         // boundary_minus and boundary_plus are the boundaries between v and its</span>
<span class="line-modified">529         // closest floating-point neighbors. Any number strictly between</span>
<span class="line-modified">530         // boundary_minus and boundary_plus will round to v when convert to a double.</span>
<span class="line-modified">531         // Grisu3 will never output representations that lie exactly on a boundary.</span>
<span class="line-modified">532         DiyFp boundary_minus, boundary_plus;</span>
533   if (mode == FAST_DTOA_SHORTEST) {
<a name="23" id="anc23"></a><span class="line-modified">534         Double(v).NormalizedBoundaries(&amp;boundary_minus, &amp;boundary_plus);</span>
535   } else {
536     ASSERT(mode == FAST_DTOA_SHORTEST_SINGLE);
537     float single_v = static_cast&lt;float&gt;(v);
538     Single(single_v).NormalizedBoundaries(&amp;boundary_minus, &amp;boundary_plus);
539   }
<a name="24" id="anc24"></a><span class="line-modified">540         ASSERT(boundary_plus.e() == w.e());</span>
<span class="line-modified">541         DiyFp ten_mk;  // Cached power of ten: 10^-k</span>
<span class="line-modified">542         int mk;        // -k</span>
<span class="line-modified">543         int ten_mk_minimal_binary_exponent =</span>
<span class="line-modified">544         kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">545         int ten_mk_maximal_binary_exponent =</span>
<span class="line-modified">546         kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">547         PowersOfTenCache::GetCachedPowerForBinaryExponentRange(</span>
<span class="line-modified">548                                                                ten_mk_minimal_binary_exponent,</span>
<span class="line-modified">549                                                                ten_mk_maximal_binary_exponent,</span>
<span class="line-modified">550                                                                &amp;ten_mk, &amp;mk);</span>
<span class="line-modified">551         ASSERT((kMinimalTargetExponent &lt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">552                 DiyFp::kSignificandSize) &amp;&amp;</span>
<span class="line-modified">553                (kMaximalTargetExponent &gt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">554                 DiyFp::kSignificandSize));</span>
<span class="line-modified">555         // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a</span>
<span class="line-modified">556         // 64 bit significand and ten_mk is thus only precise up to 64 bits.</span>
<span class="line-modified">557         </span>
<span class="line-modified">558         // The DiyFp::Times procedure rounds its result, and ten_mk is approximated</span>
<span class="line-modified">559         // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now</span>
<span class="line-modified">560         // off by a small amount.</span>
<span class="line-modified">561         // In fact: scaled_w - w*10^k &lt; 1ulp (unit in the last place) of scaled_w.</span>
<span class="line-modified">562         // In other words: let f = scaled_w.f() and e = scaled_w.e(), then</span>
<span class="line-modified">563         //           (f-1) * 2^e &lt; w*10^k &lt; (f+1) * 2^e</span>
<span class="line-modified">564         DiyFp scaled_w = DiyFp::Times(w, ten_mk);</span>
<span class="line-modified">565         ASSERT(scaled_w.e() ==</span>
<span class="line-modified">566                boundary_plus.e() + ten_mk.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">567         // In theory it would be possible to avoid some recomputations by computing</span>
<span class="line-modified">568         // the difference between w and boundary_minus/plus (a power of 2) and to</span>
<span class="line-modified">569         // compute scaled_boundary_minus/plus by subtracting/adding from</span>
<span class="line-modified">570         // scaled_w. However the code becomes much less readable and the speed</span>
<span class="line-modified">571         // enhancements are not terriffic.</span>
<span class="line-modified">572         DiyFp scaled_boundary_minus = DiyFp::Times(boundary_minus, ten_mk);</span>
<span class="line-modified">573         DiyFp scaled_boundary_plus  = DiyFp::Times(boundary_plus,  ten_mk);</span>
<span class="line-modified">574         </span>
<span class="line-modified">575         // DigitGen will generate the digits of scaled_w. Therefore we have</span>
<span class="line-modified">576         // v == (double) (scaled_w * 10^-mk).</span>
<span class="line-modified">577         // Set decimal_exponent == -mk and pass it to DigitGen. If scaled_w is not an</span>
<span class="line-modified">578         // integer than it will be updated. For instance if scaled_w == 1.23 then</span>
<span class="line-modified">579         // the buffer will be filled with &quot;123&quot; und the decimal_exponent will be</span>
<span class="line-modified">580         // decreased by 2.</span>
<span class="line-modified">581         int kappa;</span>
<span class="line-modified">582         bool result = DigitGen(scaled_boundary_minus, scaled_w, scaled_boundary_plus,</span>
<span class="line-modified">583                                buffer, length, &amp;kappa);</span>
<span class="line-modified">584         *decimal_exponent = -mk + kappa;</span>
<span class="line-modified">585         return result;</span>
586 }
<a name="25" id="anc25"></a><span class="line-modified">587     </span>
<span class="line-modified">588     </span>
589 // The &quot;counted&quot; version of grisu3 (see above) only generates requested_digits
590 // number of digits. This version does not generate the shortest representation,
591 // and with enough requested digits 0.1 will at some point print as 0.9999999...
592 // Grisu3 is too imprecise for real halfway cases (1.5 will not work) and
593 // therefore the rounding strategy for halfway cases is irrelevant.
594 static bool Grisu3Counted(double v,
<a name="26" id="anc26"></a><span class="line-modified">595                               int requested_digits,</span>
<span class="line-modified">596                               BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">597                               int* length,</span>
<span class="line-modified">598                               int* decimal_exponent) {</span>
<span class="line-modified">599         DiyFp w = Double(v).AsNormalizedDiyFp();</span>
<span class="line-modified">600         DiyFp ten_mk;  // Cached power of ten: 10^-k</span>
<span class="line-modified">601         int mk;        // -k</span>
<span class="line-modified">602         int ten_mk_minimal_binary_exponent =</span>
<span class="line-modified">603         kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">604         int ten_mk_maximal_binary_exponent =</span>
<span class="line-modified">605         kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">606         PowersOfTenCache::GetCachedPowerForBinaryExponentRange(</span>
<span class="line-modified">607                                                                ten_mk_minimal_binary_exponent,</span>
<span class="line-modified">608                                                                ten_mk_maximal_binary_exponent,</span>
<span class="line-modified">609                                                                &amp;ten_mk, &amp;mk);</span>
<span class="line-modified">610         ASSERT((kMinimalTargetExponent &lt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">611                 DiyFp::kSignificandSize) &amp;&amp;</span>
<span class="line-modified">612                (kMaximalTargetExponent &gt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">613                 DiyFp::kSignificandSize));</span>
<span class="line-modified">614         // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a</span>
<span class="line-modified">615         // 64 bit significand and ten_mk is thus only precise up to 64 bits.</span>
<span class="line-modified">616         </span>
<span class="line-modified">617         // The DiyFp::Times procedure rounds its result, and ten_mk is approximated</span>
<span class="line-modified">618         // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now</span>
<span class="line-modified">619         // off by a small amount.</span>
<span class="line-modified">620         // In fact: scaled_w - w*10^k &lt; 1ulp (unit in the last place) of scaled_w.</span>
<span class="line-modified">621         // In other words: let f = scaled_w.f() and e = scaled_w.e(), then</span>
<span class="line-modified">622         //           (f-1) * 2^e &lt; w*10^k &lt; (f+1) * 2^e</span>
<span class="line-modified">623         DiyFp scaled_w = DiyFp::Times(w, ten_mk);</span>
<span class="line-modified">624         </span>
<span class="line-modified">625         // We now have (double) (scaled_w * 10^-mk).</span>
<span class="line-modified">626         // DigitGen will generate the first requested_digits digits of scaled_w and</span>
<span class="line-modified">627         // return together with a kappa such that scaled_w ~= buffer * 10^kappa. (It</span>
<span class="line-modified">628         // will not always be exactly the same since DigitGenCounted only produces a</span>
<span class="line-modified">629         // limited number of digits.)</span>
<span class="line-modified">630         int kappa;</span>
<span class="line-modified">631         bool result = DigitGenCounted(scaled_w, requested_digits,</span>
<span class="line-modified">632                                       buffer, length, &amp;kappa);</span>
<span class="line-modified">633         *decimal_exponent = -mk + kappa;</span>
<span class="line-modified">634         return result;</span>
635 }
<a name="27" id="anc27"></a><span class="line-modified">636     </span>
<span class="line-modified">637     </span>
638 bool FastDtoa(double v,
<a name="28" id="anc28"></a><span class="line-modified">639                   FastDtoaMode mode,</span>
<span class="line-modified">640                   int requested_digits,</span>
<span class="line-modified">641                   BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">642                   int* length,</span>
<span class="line-modified">643                   int* decimal_point) {</span>
<span class="line-modified">644         ASSERT(v &gt; 0);</span>
<span class="line-modified">645         ASSERT(!Double(v).IsSpecial());</span>
<span class="line-modified">646         </span>
<span class="line-modified">647         bool result = false;</span>
<span class="line-modified">648         int decimal_exponent = 0;</span>
<span class="line-modified">649         switch (mode) {</span>
<span class="line-modified">650             case FAST_DTOA_SHORTEST:</span>
651     case FAST_DTOA_SHORTEST_SINGLE:
652       result = Grisu3(v, mode, buffer, length, &amp;decimal_exponent);
<a name="29" id="anc29"></a><span class="line-modified">653                 break;</span>
<span class="line-modified">654             case FAST_DTOA_PRECISION:</span>
<span class="line-modified">655                 result = Grisu3Counted(v, requested_digits,</span>
<span class="line-modified">656                                        buffer, length, &amp;decimal_exponent);</span>
<span class="line-modified">657                 break;</span>
<span class="line-modified">658             default:</span>
<span class="line-modified">659                 UNREACHABLE();</span>
<span class="line-modified">660         }</span>
<span class="line-modified">661         if (result) {</span>
<span class="line-modified">662             *decimal_point = *length + decimal_exponent;</span>
<span class="line-modified">663             buffer[*length] = &#39;\0&#39;;</span>
<span class="line-modified">664         }</span>
<span class="line-modified">665         return result;</span>
666 }
<a name="30" id="anc30"></a><span class="line-modified">667     </span>
668 }  // namespace double_conversion
<a name="31" id="anc31"></a><span class="line-modified">669 } // namespace WTF</span>
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>