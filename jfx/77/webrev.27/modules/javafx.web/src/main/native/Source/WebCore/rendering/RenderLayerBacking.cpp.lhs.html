<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009, 2010, 2011 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerBacking.h&quot;
  29 
  30 #include &quot;BitmapImage.h&quot;
  31 #include &quot;CSSAnimationController.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CachedImage.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;DocumentTimeline.h&quot;
<a name="1" id="anc1"></a>
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameView.h&quot;
  39 #include &quot;GraphicsContext.h&quot;
  40 #include &quot;GraphicsLayer.h&quot;
  41 #include &quot;HTMLBodyElement.h&quot;
  42 #include &quot;HTMLCanvasElement.h&quot;
  43 #include &quot;HTMLIFrameElement.h&quot;
  44 #include &quot;HTMLMediaElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLPlugInElement.h&quot;
  47 #include &quot;InspectorInstrumentation.h&quot;
  48 #include &quot;KeyframeList.h&quot;
<a name="2" id="anc2"></a>
  49 #include &quot;Logging.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PerformanceLoggingClient.h&quot;
  52 #include &quot;PluginViewBase.h&quot;
  53 #include &quot;ProgressTracker.h&quot;
  54 #include &quot;RenderFragmentContainer.h&quot;
  55 #include &quot;RenderFragmentedFlow.h&quot;
  56 #include &quot;RenderHTMLCanvas.h&quot;
  57 #include &quot;RenderIFrame.h&quot;
  58 #include &quot;RenderImage.h&quot;
  59 #include &quot;RenderLayerCompositor.h&quot;
  60 #include &quot;RenderEmbeddedObject.h&quot;
  61 #include &quot;RenderMedia.h&quot;
  62 #include &quot;RenderVideo.h&quot;
  63 #include &quot;RenderView.h&quot;
  64 #include &quot;RuntimeEnabledFeatures.h&quot;
  65 #include &quot;ScrollingCoordinator.h&quot;
  66 #include &quot;Settings.h&quot;
  67 #include &quot;StyleResolver.h&quot;
  68 #include &quot;TiledBacking.h&quot;
  69 #include &lt;wtf/text/TextStream.h&gt;
  70 
  71 #if PLATFORM(IOS_FAMILY)
  72 #include &quot;RuntimeApplicationChecks.h&quot;
  73 #endif
  74 
  75 #if PLATFORM(MAC)
  76 #include &quot;LocalDefaultSystemAppearance.h&quot;
  77 #endif
  78 
  79 namespace WebCore {
  80 
  81 using namespace HTMLNames;
  82 
  83 CanvasCompositingStrategy canvasCompositingStrategy(const RenderObject&amp; renderer)
  84 {
  85     ASSERT(renderer.isCanvas());
  86 
  87     const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer.node());
  88     auto* context = canvas-&gt;renderingContext();
  89     if (!context || !context-&gt;isAccelerated())
  90         return UnacceleratedCanvas;
  91 
  92     if (context-&gt;isGPUBased())
  93         return CanvasAsLayerContents;
  94 
  95 #if ENABLE(ACCELERATED_2D_CANVAS)
  96     return CanvasAsLayerContents;
  97 #else
  98     return CanvasPaintedToLayer; // On Mac and iOS we paint accelerated canvases into their layers.
  99 #endif
 100 }
 101 
 102 // This acts as a cache of what we know about what is painting into this RenderLayerBacking.
 103 class PaintedContentsInfo {
 104 public:
 105     enum class ContentsTypeDetermination {
 106         Unknown,
 107         SimpleContainer,
 108         DirectlyCompositedImage,
 109         Painted
 110     };
 111 
 112     PaintedContentsInfo(RenderLayerBacking&amp; inBacking)
 113         : m_backing(inBacking)
 114     {
 115     }
 116 
 117     void setWantsSubpixelAntialiasedTextState(bool wantsSubpixelAntialiasedTextState)
 118     {
 119         m_subpixelAntialiasedText = wantsSubpixelAntialiasedTextState ? RequestState::Unknown : RequestState::DontCare;
 120     }
 121 
 122     RequestState paintsBoxDecorationsDetermination();
 123     bool paintsBoxDecorations()
 124     {
 125         RequestState state = paintsBoxDecorationsDetermination();
 126         return state == RequestState::True || state == RequestState::Undetermined;
 127     }
 128 
 129     RequestState paintsContentDetermination();
 130     bool paintsContent()
 131     {
 132         RequestState state = paintsContentDetermination();
 133         return state == RequestState::True || state == RequestState::Undetermined;
 134     }
 135 
 136     RequestState paintsSubpixelAntialiasedTextDetermination();
 137     bool paintsSubpixelAntialiasedText()
 138     {
 139         RequestState state = paintsSubpixelAntialiasedTextDetermination();
 140         return state == RequestState::True || state == RequestState::Undetermined;
 141     }
 142 
 143     ContentsTypeDetermination contentsTypeDetermination();
 144     bool isSimpleContainer()
 145     {
 146         return contentsTypeDetermination() == ContentsTypeDetermination::SimpleContainer;
 147     }
 148 
 149     bool isDirectlyCompositedImage()
 150     {
 151         return contentsTypeDetermination() == ContentsTypeDetermination::DirectlyCompositedImage;
 152     }
 153 
 154     RenderLayerBacking&amp; m_backing;
 155     RequestState m_boxDecorations { RequestState::Unknown };
 156     RequestState m_content { RequestState::Unknown };
 157     RequestState m_subpixelAntialiasedText { RequestState::DontCare };
 158 
 159     ContentsTypeDetermination m_contentsType { ContentsTypeDetermination::Unknown };
 160 };
 161 
 162 RequestState PaintedContentsInfo::paintsBoxDecorationsDetermination()
 163 {
 164     if (m_boxDecorations != RequestState::Unknown)
 165         return m_boxDecorations;
 166 
 167     m_boxDecorations = m_backing.paintsBoxDecorations() ? RequestState::True : RequestState::False;
 168     return m_boxDecorations;
 169 }
 170 
 171 RequestState PaintedContentsInfo::paintsContentDetermination()
 172 {
 173     if (m_content != RequestState::Unknown &amp;&amp; m_subpixelAntialiasedText != RequestState::Unknown)
 174         return m_content;
 175 
 176     RenderLayer::PaintedContentRequest contentRequest;
 177     if (m_subpixelAntialiasedText == RequestState::Unknown)
 178         contentRequest.hasSubpixelAntialiasedText = RequestState::Unknown;
 179 
 180     m_content = m_backing.paintsContent(contentRequest) ? RequestState::True : RequestState::False;
 181 
 182     if (m_subpixelAntialiasedText == RequestState::Unknown)
 183         m_subpixelAntialiasedText = contentRequest.hasSubpixelAntialiasedText;
 184 
 185     return m_content;
 186 }
 187 
 188 RequestState PaintedContentsInfo::paintsSubpixelAntialiasedTextDetermination()
 189 {
 190     if (m_subpixelAntialiasedText != RequestState::Unknown)
 191         return m_subpixelAntialiasedText;
 192 
 193     paintsContentDetermination();
 194 
 195     return m_subpixelAntialiasedText;
 196 }
 197 
 198 PaintedContentsInfo::ContentsTypeDetermination PaintedContentsInfo::contentsTypeDetermination()
 199 {
 200     if (m_contentsType != ContentsTypeDetermination::Unknown)
 201         return m_contentsType;
 202 
 203     if (m_backing.isSimpleContainerCompositingLayer(*this))
 204         m_contentsType = ContentsTypeDetermination::SimpleContainer;
 205     else if (m_backing.isDirectlyCompositedImage())
 206         m_contentsType = ContentsTypeDetermination::DirectlyCompositedImage;
 207     else
 208         m_contentsType = ContentsTypeDetermination::Painted;
 209 
 210     return m_contentsType;
 211 }
 212 
 213 
 214 RenderLayerBacking::RenderLayerBacking(RenderLayer&amp; layer)
 215     : m_owningLayer(layer)
 216 {
 217     if (layer.isRenderViewLayer()) {
 218         m_isMainFrameRenderViewLayer = renderer().frame().isMainFrame();
 219         m_isFrameLayerWithTiledBacking = renderer().page().chrome().client().shouldUseTiledBackingForFrameView(renderer().view().frameView());
 220     }
 221 
 222     createPrimaryGraphicsLayer();
 223 #if ENABLE(FULLSCREEN_API)
 224     setRequiresBackgroundLayer(layer.renderer().isRenderFullScreen());
 225 #endif
 226 
 227     if (auto* tiledBacking = this-&gt;tiledBacking()) {
 228         tiledBacking-&gt;setIsInWindow(renderer().page().isInWindow());
 229 
 230         if (m_isFrameLayerWithTiledBacking) {
 231             tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(renderer().settings().scrollingPerformanceLoggingEnabled());
 232             adjustTiledBackingCoverage();
 233         }
 234     }
 235 }
 236 
 237 RenderLayerBacking::~RenderLayerBacking()
 238 {
 239     // Note that m_owningLayer-&gt;backing() is null here.
<a name="3" id="anc3"></a><span class="line-modified"> 240     updateAncestorClippingLayer(false);</span>
 241     updateChildClippingStrategy(false);
 242     updateDescendantClippingLayer(false);
 243     updateOverflowControlsLayers(false, false, false);
 244     updateForegroundLayer(false);
 245     updateBackgroundLayer(false);
 246     updateMaskingLayer(false, false);
 247     updateScrollingLayers(false);
 248 
 249     ASSERT(!m_viewportConstrainedNodeID);
 250     ASSERT(!m_scrollingNodeID);
 251     ASSERT(!m_frameHostingNodeID);
<a name="4" id="anc4"></a>
 252 
 253     destroyGraphicsLayers();
 254 }
 255 
 256 void RenderLayerBacking::willBeDestroyed()
 257 {
 258     ASSERT(m_owningLayer.backing() == this);
 259     compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
<a name="5" id="anc5"></a>

 260 }
 261 
 262 void RenderLayerBacking::willDestroyLayer(const GraphicsLayer* layer)
 263 {
 264     if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
 265         compositor().layerTiledBackingUsageChanged(layer, false);
 266 }
 267 
<a name="6" id="anc6"></a>





















































 268 Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
 269 {
 270     auto* graphicsLayerFactory = renderer().page().chrome().client().graphicsLayerFactory();
 271 
 272     auto graphicsLayer = GraphicsLayer::create(graphicsLayerFactory, *this, layerType);
 273 
 274     graphicsLayer-&gt;setName(name);
 275 
 276 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 277     graphicsLayer-&gt;setAcceleratesDrawing(compositor().acceleratedDrawingEnabled());
 278     graphicsLayer-&gt;setUsesDisplayListDrawing(compositor().displayListDrawingEnabled());
 279 #endif
 280 
 281     return graphicsLayer;
 282 }
 283 
 284 void RenderLayerBacking::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
 285 {
 286     // Note that this only affects the primary layer.
 287     if (usesDisplayListDrawing == m_graphicsLayer-&gt;usesDisplayListDrawing())
 288         return;
 289 
 290     m_graphicsLayer-&gt;setUsesDisplayListDrawing(usesDisplayListDrawing);
 291     if (m_graphicsLayer-&gt;drawsContent())
 292         m_graphicsLayer-&gt;setNeedsDisplay();
 293 }
 294 
 295 String RenderLayerBacking::displayListAsText(DisplayList::AsTextFlags flags) const
 296 {
 297     return m_graphicsLayer-&gt;displayListAsText(flags);
 298 }
 299 
 300 void RenderLayerBacking::setIsTrackingDisplayListReplay(bool isTrackingReplay)
 301 {
 302     m_graphicsLayer-&gt;setIsTrackingDisplayListReplay(isTrackingReplay);
 303 }
 304 
 305 String RenderLayerBacking::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
 306 {
 307     return m_graphicsLayer-&gt;replayDisplayListAsText(flags);
 308 }
 309 
 310 void RenderLayerBacking::tiledBackingUsageChanged(const GraphicsLayer* layer, bool usingTiledBacking)
 311 {
 312     compositor().layerTiledBackingUsageChanged(layer, usingTiledBacking);
 313 }
 314 
 315 TiledBacking* RenderLayerBacking::tiledBacking() const
 316 {
 317     return m_graphicsLayer-&gt;tiledBacking();
 318 }
 319 
<a name="7" id="anc7"></a><span class="line-modified"> 320 static TiledBacking::TileCoverage computePageTiledBackingCoverage(RenderLayerBacking* backing)</span>
 321 {
<a name="8" id="anc8"></a><span class="line-removed"> 322     // FIXME: When we use TiledBacking for overflow, this should look at RenderView scrollability.</span>
<span class="line-removed"> 323     auto&amp; frameView = backing-&gt;owningLayer().renderer().view().frameView();</span>
<span class="line-removed"> 324 </span>
 325     // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.
<a name="9" id="anc9"></a><span class="line-modified"> 326     if (!backing-&gt;owningLayer().page().isVisible())</span>
 327         return TiledBacking::CoverageForVisibleArea;
 328 
<a name="10" id="anc10"></a>

 329     TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;
 330     bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();
 331     if (frameView.speculativeTilingEnabled() &amp;&amp; !useMinimalTilesDuringLiveResize) {
 332         bool clipsToExposedRect = static_cast&lt;bool&gt;(frameView.viewExposedRect());
 333         if (frameView.horizontalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 334             tileCoverage |= TiledBacking::CoverageForHorizontalScrolling;
 335 
 336         if (frameView.verticalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 337             tileCoverage |= TiledBacking::CoverageForVerticalScrolling;
 338     }
 339     return tileCoverage;
 340 }
 341 
<a name="11" id="anc11"></a>



















 342 void RenderLayerBacking::adjustTiledBackingCoverage()
 343 {
<a name="12" id="anc12"></a><span class="line-modified"> 344     if (!m_isFrameLayerWithTiledBacking)</span>
<span class="line-modified"> 345         return;</span>



 346 
<a name="13" id="anc13"></a><span class="line-modified"> 347     TiledBacking::TileCoverage tileCoverage = computePageTiledBackingCoverage(this);</span>
<span class="line-modified"> 348     tiledBacking()-&gt;setTileCoverage(tileCoverage);</span>




 349 }
 350 
 351 void RenderLayerBacking::setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom)
 352 {
 353     if (!m_isFrameLayerWithTiledBacking)
 354         return;
 355 
 356     tiledBacking()-&gt;setHasMargins(hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnLeftAndRight, hasExtendedBackgroundOnLeftAndRight);
 357 }
 358 
 359 void RenderLayerBacking::updateDebugIndicators(bool showBorder, bool showRepaintCounter)
 360 {
 361     m_graphicsLayer-&gt;setShowDebugBorder(showBorder);
 362     m_graphicsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 363 
<a name="14" id="anc14"></a><span class="line-modified"> 364     if (m_ancestorClippingLayer)</span>
<span class="line-modified"> 365         m_ancestorClippingLayer-&gt;setShowDebugBorder(showBorder);</span>


 366 
 367     if (m_foregroundLayer) {
 368         m_foregroundLayer-&gt;setShowDebugBorder(showBorder);
 369         m_foregroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 370     }
 371 
 372     if (m_contentsContainmentLayer)
 373         m_contentsContainmentLayer-&gt;setShowDebugBorder(showBorder);
 374 
 375     if (m_backgroundLayer) {
 376         m_backgroundLayer-&gt;setShowDebugBorder(showBorder);
 377         m_backgroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 378     }
 379 
 380     if (m_maskLayer) {
 381         m_maskLayer-&gt;setShowDebugBorder(showBorder);
 382         m_maskLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 383     }
 384 
 385     if (m_layerForHorizontalScrollbar)
 386         m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(showBorder);
 387 
 388     if (m_layerForVerticalScrollbar)
 389         m_layerForVerticalScrollbar-&gt;setShowDebugBorder(showBorder);
 390 
 391     if (m_layerForScrollCorner)
 392         m_layerForScrollCorner-&gt;setShowDebugBorder(showBorder);
 393 
 394     if (m_scrollContainerLayer)
 395         m_scrollContainerLayer-&gt;setShowDebugBorder(showBorder);
 396 
 397     if (m_scrolledContentsLayer) {
 398         m_scrolledContentsLayer-&gt;setShowDebugBorder(showBorder);
 399         m_scrolledContentsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 400     }
 401 }
 402 
 403 void RenderLayerBacking::createPrimaryGraphicsLayer()
 404 {
 405     String layerName = m_owningLayer.name();
 406     const unsigned maxLayerNameLength = 100;
 407     if (layerName.length() &gt; maxLayerNameLength) {
 408         layerName.truncate(maxLayerNameLength);
 409         layerName.append(&quot;...&quot;);
 410     }
 411     m_graphicsLayer = createGraphicsLayer(layerName, m_isFrameLayerWithTiledBacking ? GraphicsLayer::Type::PageTiledBacking : GraphicsLayer::Type::Normal);
 412 
 413     if (m_isFrameLayerWithTiledBacking) {
 414         m_childContainmentLayer = createGraphicsLayer(&quot;Page TiledBacking containment&quot;);
 415         m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
 416     }
 417 
 418 #if !PLATFORM(IOS_FAMILY)
 419     if (m_isMainFrameRenderViewLayer) {
 420         // Page scale is applied above the RenderView on iOS.
 421         m_graphicsLayer-&gt;setContentsOpaque(!compositor().viewHasTransparentBackground());
 422         m_graphicsLayer-&gt;setAppliesPageScale();
 423     }
 424 #endif
 425 
 426 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 427     if (!compositor().acceleratedDrawingEnabled() &amp;&amp; renderer().isCanvas()) {
 428         const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
 429         if (canvas-&gt;shouldAccelerate(canvas-&gt;size()))
 430             m_graphicsLayer-&gt;setAcceleratesDrawing(true);
 431     }
 432 #endif
 433 
 434     updateOpacity(renderer().style());
 435     updateTransform(renderer().style());
 436     updateFilters(renderer().style());
 437 #if ENABLE(FILTERS_LEVEL_2)
 438     updateBackdropFilters(renderer().style());
 439 #endif
 440 #if ENABLE(CSS_COMPOSITING)
 441     updateBlendMode(renderer().style());
 442 #endif
 443     updateCustomAppearance(renderer().style());
 444 }
 445 
 446 #if PLATFORM(IOS_FAMILY)
 447 void RenderLayerBacking::layerWillBeDestroyed()
 448 {
 449     auto&amp; renderer = this-&gt;renderer();
 450     if (is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing()) {
 451         auto* pluginViewBase = downcast&lt;PluginViewBase&gt;(downcast&lt;RenderWidget&gt;(renderer).widget());
 452         if (pluginViewBase &amp;&amp; m_graphicsLayer-&gt;contentsLayerForMedia())
 453             pluginViewBase-&gt;detachPluginLayer();
 454     }
 455 }
 456 
 457 bool RenderLayerBacking::needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(const GraphicsLayer&amp; layer) const
 458 {
 459     if (m_isMainFrameRenderViewLayer &amp;&amp; IOSApplication::isDumpRenderTree()) {
 460         // In iOS WebKit1 the main frame&#39;s RenderView layer is always transparent. We lie that it is opaque so that
 461         // internals.layerTreeAsText() tests succeed.
 462         ASSERT_UNUSED(layer, !layer.contentsOpaque());
 463         return true;
 464     }
 465     return false;
 466 }
 467 #endif
 468 
 469 void RenderLayerBacking::destroyGraphicsLayers()
 470 {
 471     if (m_graphicsLayer) {
 472         m_graphicsLayer-&gt;setMaskLayer(nullptr);
 473         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 474         willDestroyLayer(m_graphicsLayer.get());
 475     }
 476 
 477     GraphicsLayer::clear(m_maskLayer);
 478 
<a name="15" id="anc15"></a><span class="line-modified"> 479     GraphicsLayer::unparentAndClear(m_ancestorClippingLayer);</span>




 480     GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
 481     GraphicsLayer::unparentAndClear(m_foregroundLayer);
 482     GraphicsLayer::unparentAndClear(m_backgroundLayer);
 483     GraphicsLayer::unparentAndClear(m_childContainmentLayer);
 484     GraphicsLayer::unparentAndClear(m_childClippingMaskLayer);
 485     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
 486     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
 487     GraphicsLayer::unparentAndClear(m_graphicsLayer);
 488 }
 489 
 490 void RenderLayerBacking::updateOpacity(const RenderStyle&amp; style)
 491 {
 492     m_graphicsLayer-&gt;setOpacity(compositingOpacity(style.opacity()));
 493 }
 494 
 495 void RenderLayerBacking::updateTransform(const RenderStyle&amp; style)
 496 {
 497     // FIXME: This could use m_owningLayer.transform(), but that currently has transform-origin
 498     // baked into it, and we don&#39;t want that.
 499     TransformationMatrix t;
 500     if (m_owningLayer.hasTransform()) {
 501         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 502         style.applyTransform(t, snapRectToDevicePixels(renderBox.borderBoxRect(), deviceScaleFactor()), RenderStyle::ExcludeTransformOrigin);
 503         makeMatrixRenderable(t, compositor().canRender3DTransforms());
 504     }
 505 
 506     if (m_contentsContainmentLayer) {
 507         m_contentsContainmentLayer-&gt;setTransform(t);
<a name="16" id="anc16"></a><span class="line-modified"> 508         m_graphicsLayer-&gt;setTransform(TransformationMatrix());</span>
 509     } else
 510         m_graphicsLayer-&gt;setTransform(t);
 511 }
 512 
 513 void RenderLayerBacking::updateFilters(const RenderStyle&amp; style)
 514 {
 515     m_canCompositeFilters = m_graphicsLayer-&gt;setFilters(style.filter());
 516 }
 517 
 518 #if ENABLE(FILTERS_LEVEL_2)
 519 void RenderLayerBacking::updateBackdropFilters(const RenderStyle&amp; style)
 520 {
 521     m_canCompositeBackdropFilters = m_graphicsLayer-&gt;setBackdropFilters(style.backdropFilter());
 522 }
 523 
 524 void RenderLayerBacking::updateBackdropFiltersGeometry()
 525 {
 526     if (!m_canCompositeBackdropFilters)
 527         return;
 528 
 529     if (!is&lt;RenderBox&gt;(renderer()))
 530         return;
 531 
 532     auto&amp; renderer = downcast&lt;RenderBox&gt;(this-&gt;renderer());
 533     LayoutRect boxRect = renderer.borderBoxRect();
 534     if (renderer.hasClip())
 535         boxRect.intersect(renderer.clipRect(LayoutPoint(), nullptr));
<a name="17" id="anc17"></a><span class="line-modified"> 536     boxRect.move(contentOffsetInCompostingLayer());</span>
 537 
 538     FloatRoundedRect backdropFiltersRect;
 539     if (renderer.style().hasBorderRadius() &amp;&amp; !renderer.hasClip())
 540         backdropFiltersRect = renderer.style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 541     else
 542         backdropFiltersRect = FloatRoundedRect(snapRectToDevicePixels(boxRect, deviceScaleFactor()));
 543 
 544     m_graphicsLayer-&gt;setBackdropFiltersRect(backdropFiltersRect);
 545 }
 546 #endif
 547 
 548 #if ENABLE(CSS_COMPOSITING)
 549 void RenderLayerBacking::updateBlendMode(const RenderStyle&amp; style)
 550 {
<a name="18" id="anc18"></a><span class="line-modified"> 551     // FIXME: where is the blend mode updated when m_ancestorClippingLayers come and go?</span>
<span class="line-modified"> 552     if (m_ancestorClippingLayer) {</span>
<span class="line-modified"> 553         m_ancestorClippingLayer-&gt;setBlendMode(style.blendMode());</span>
 554         m_graphicsLayer-&gt;setBlendMode(BlendMode::Normal);
 555     } else
 556         m_graphicsLayer-&gt;setBlendMode(style.blendMode());
 557 }
 558 #endif
 559 
 560 void RenderLayerBacking::updateCustomAppearance(const RenderStyle&amp; style)
 561 {
 562     ControlPart appearance = style.appearance();
 563     if (appearance == MediaControlsLightBarBackgroundPart)
 564         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::LightBackdrop);
 565     else if (appearance == MediaControlsDarkBarBackgroundPart)
 566         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::DarkBackdrop);
 567     else
 568         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::None);
 569 }
 570 
 571 static bool layerOrAncestorIsTransformedOrUsingCompositedScrolling(RenderLayer&amp; layer)
 572 {
 573     for (auto* curr = &amp;layer; curr; curr = curr-&gt;parent()) {
 574         if (curr-&gt;hasTransform() || curr-&gt;hasCompositedScrollableOverflow())
 575             return true;
 576     }
 577 
 578     return false;
 579 }
 580 
 581 bool RenderLayerBacking::shouldClipCompositedBounds() const
 582 {
 583 #if !PLATFORM(IOS_FAMILY)
 584     // Scrollbar layers use this layer for relative positioning, so don&#39;t clip.
 585     if (layerForHorizontalScrollbar() || layerForVerticalScrollbar())
 586         return false;
 587 #endif
 588 
 589     if (m_isFrameLayerWithTiledBacking)
 590         return false;
 591 
 592     if (layerOrAncestorIsTransformedOrUsingCompositedScrolling(m_owningLayer))
 593         return false;
 594 
 595     return true;
 596 }
 597 
 598 static bool hasNonZeroTransformOrigin(const RenderObject&amp; renderer)
 599 {
 600     const RenderStyle&amp; style = renderer.style();
 601     return (style.transformOriginX().type() == Fixed &amp;&amp; style.transformOriginX().value())
 602         || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
 603 }
 604 
 605 bool RenderLayerBacking::updateCompositedBounds()
 606 {
<a name="19" id="anc19"></a><span class="line-modified"> 607     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, LayoutSize(), RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);</span>
 608     // Clip to the size of the document or enclosing overflow-scroll layer.
 609     // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
 610     // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
 611     if (shouldClipCompositedBounds()) {
 612         auto&amp; view = renderer().view();
 613         auto* rootLayer = view.layer();
 614 
 615         LayoutRect clippingBounds;
 616         if (renderer().isFixedPositioned() &amp;&amp; renderer().container() == &amp;view)
 617             clippingBounds = view.frameView().rectForFixedPositionLayout();
 618         else
 619             clippingBounds = view.unscaledDocumentRect();
 620 
 621         if (&amp;m_owningLayer != rootLayer)
 622             clippingBounds.intersect(m_owningLayer.backgroundClipRect(RenderLayer::ClipRectsContext(rootLayer, AbsoluteClipRects)).rect()); // FIXME: Incorrect for CSS regions.
 623 
 624         LayoutPoint delta = m_owningLayer.convertToLayerCoords(rootLayer, LayoutPoint(), RenderLayer::AdjustForColumns);
 625         clippingBounds.move(-delta.x(), -delta.y());
 626 
 627         layerBounds.intersect(clippingBounds);
 628     }
 629 
<a name="20" id="anc20"></a>










 630     // If the element has a transform-origin that has fixed lengths, and the renderer has zero size,
 631     // then we need to ensure that the compositing layer has non-zero size so that we can apply
 632     // the transform-origin via the GraphicsLayer anchorPoint (which is expressed as a fractional value).
 633     if (layerBounds.isEmpty() &amp;&amp; (hasNonZeroTransformOrigin(renderer()) || renderer().style().hasPerspective())) {
 634         layerBounds.setWidth(1);
 635         layerBounds.setHeight(1);
 636         m_artificiallyInflatedBounds = true;
 637     } else
 638         m_artificiallyInflatedBounds = false;
 639 
 640     return setCompositedBounds(layerBounds);
 641 }
 642 
<a name="21" id="anc21"></a>






























 643 void RenderLayerBacking::updateAfterWidgetResize()
 644 {
 645     if (!is&lt;RenderWidget&gt;(renderer()))
 646         return;
 647 
 648     if (auto* innerCompositor = RenderLayerCompositor::frameContentsCompositor(downcast&lt;RenderWidget&gt;(renderer()))) {
 649         innerCompositor-&gt;frameViewDidChangeSize();
 650         innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
 651     }
 652 }
 653 
<a name="22" id="anc22"></a><span class="line-modified"> 654 void RenderLayerBacking::updateAfterLayout(bool needsFullRepaint)</span>
 655 {
 656     LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
 657 
 658     // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
 659     // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
 660     // take overflow into account.
 661     if (updateCompositedBounds()) {
 662         m_owningLayer.setNeedsCompositingGeometryUpdate();
 663         // This layer&#39;s geometry affects those of its children.
 664         m_owningLayer.setChildrenNeedCompositingGeometryUpdate();
<a name="23" id="anc23"></a>


 665     }
 666 
 667     if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
 668         setContentsNeedDisplay();
 669 }
 670 
 671 // This can only update things that don&#39;t require up-to-date layout.
 672 void RenderLayerBacking::updateConfigurationAfterStyleChange()
 673 {
 674     updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath());
 675 
 676     if (m_owningLayer.hasReflection()) {
 677         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 678             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 679             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 680         }
 681     } else
 682         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 683 
 684     // FIXME: do we care if opacity is animating?
 685     auto&amp; style = renderer().style();
 686     updateOpacity(style);
 687     updateFilters(style);
 688 
 689 #if ENABLE(FILTERS_LEVEL_2)
 690     updateBackdropFilters(style);
 691 #endif
 692 #if ENABLE(CSS_COMPOSITING)
 693     updateBlendMode(style);
 694 #endif
 695     updateCustomAppearance(style);
 696 }
 697 
 698 bool RenderLayerBacking::updateConfiguration()
 699 {
 700     ASSERT(!m_owningLayer.normalFlowListDirty());
 701     ASSERT(!m_owningLayer.zOrderListsDirty());
 702     ASSERT(!renderer().view().needsLayout());
 703 
 704     bool layerConfigChanged = false;
 705     auto&amp; compositor = this-&gt;compositor();
 706 
 707     setBackgroundLayerPaintsFixedRootBackground(compositor.needsFixedRootBackgroundLayer(m_owningLayer));
 708 
 709     if (updateBackgroundLayer(m_backgroundLayerPaintsFixedRootBackground || m_requiresBackgroundLayer))
 710         layerConfigChanged = true;
 711 
 712     if (updateForegroundLayer(compositor.needsContentsCompositingLayer(m_owningLayer)))
 713         layerConfigChanged = true;
 714 
 715     bool needsDescendantsClippingLayer = false;
 716     bool usesCompositedScrolling = m_owningLayer.hasCompositedScrollableOverflow();
 717 
 718     if (usesCompositedScrolling) {
 719         // If it&#39;s scrollable, it has to be a box.
 720         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 721         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 722         needsDescendantsClippingLayer = contentsClippingRect.isRounded();
 723     } else
<a name="24" id="anc24"></a><span class="line-modified"> 724         needsDescendantsClippingLayer = compositor.clipsCompositingDescendants(m_owningLayer);</span>
 725 
 726     if (updateScrollingLayers(usesCompositedScrolling))
 727         layerConfigChanged = true;
 728 
 729     if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
 730         layerConfigChanged = true;
 731 
<a name="25" id="anc25"></a><span class="line-modified"> 732     // clippedByAncestor() does a tree walk.</span>
<span class="line-modified"> 733     if (updateAncestorClippingLayer(compositor.clippedByAncestor(m_owningLayer)))</span>
 734         layerConfigChanged = true;
 735 
 736     if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
 737         layerConfigChanged = true;
 738 
 739     if (layerConfigChanged)
 740         updateInternalHierarchy();
 741 
 742     if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
 743         if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
 744             m_graphicsLayer-&gt;addChild(*flatteningLayer);
 745     }
 746 
<a name="26" id="anc26"></a><span class="line-modified"> 747     updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath());</span>

 748 
 749     updateChildClippingStrategy(needsDescendantsClippingLayer);
 750 
 751     if (m_owningLayer.hasReflection()) {
 752         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 753             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 754             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 755         }
 756     } else
 757         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 758 
 759     PaintedContentsInfo contentsInfo(*this);
 760 
 761     // Requires layout.
 762     if (!m_owningLayer.isRenderViewLayer()) {
 763         bool didUpdateContentsRect = false;
 764         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
 765     } else
 766         updateRootLayerConfiguration();
 767 
 768     // Requires layout.
 769     if (contentsInfo.isDirectlyCompositedImage())
 770         updateImageContents(contentsInfo);
 771 
 772     if (is&lt;RenderEmbeddedObject&gt;(renderer()) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer()).allowsAcceleratedCompositing()) {
 773         auto* pluginViewBase = downcast&lt;PluginViewBase&gt;(downcast&lt;RenderWidget&gt;(renderer()).widget());
 774 #if PLATFORM(IOS_FAMILY)
 775         if (pluginViewBase &amp;&amp; !m_graphicsLayer-&gt;contentsLayerForMedia()) {
 776             pluginViewBase-&gt;detachPluginLayer();
 777             pluginViewBase-&gt;attachPluginLayer();
 778         }
 779 #else
 780         if (!pluginViewBase-&gt;shouldNotAddLayer())
 781             m_graphicsLayer-&gt;setContentsToPlatformLayer(pluginViewBase-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Plugin);
 782 #endif
 783     }
 784 #if ENABLE(VIDEO)
 785     else if (is&lt;RenderVideo&gt;(renderer()) &amp;&amp; downcast&lt;RenderVideo&gt;(renderer()).shouldDisplayVideo()) {
 786         auto* mediaElement = downcast&lt;HTMLMediaElement&gt;(renderer().element());
 787         m_graphicsLayer-&gt;setContentsToPlatformLayer(mediaElement-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Media);
 788         // Requires layout.
 789         resetContentsRect();
 790     }
 791 #endif
<a name="27" id="anc27"></a><span class="line-modified"> 792 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)</span>
 793     else if (renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
 794         const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
 795         if (auto* context = canvas-&gt;renderingContext())
 796             m_graphicsLayer-&gt;setContentsToPlatformLayer(context-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Canvas);
 797 
 798         layerConfigChanged = true;
 799     }
 800 #endif
 801     if (is&lt;RenderWidget&gt;(renderer()) &amp;&amp; compositor.parentFrameContentLayers(downcast&lt;RenderWidget&gt;(renderer()))) {
 802         m_owningLayer.setNeedsCompositingGeometryUpdate();
 803         layerConfigChanged = true;
 804     }
 805 
 806     if (is&lt;RenderImage&gt;(renderer()) &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage()) {
 807         auto element = renderer().element();
 808         if (is&lt;HTMLImageElement&gt;(element)) {
 809             m_graphicsLayer-&gt;setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType::EditableImage, downcast&lt;HTMLImageElement&gt;(element)-&gt;editableImageViewID());
 810             layerConfigChanged = true;
 811         }
 812     }
 813 
<a name="28" id="anc28"></a>


 814     return layerConfigChanged;
 815 }
 816 
 817 static LayoutRect clipBox(RenderBox&amp; renderer)
 818 {
 819     LayoutRect result = LayoutRect::infiniteRect();
 820     if (renderer.hasOverflowClip())
 821         result = renderer.overflowClipRect(LayoutPoint(), 0); // FIXME: Incorrect for CSS regions.
 822 
 823     if (renderer.hasClip())
 824         result.intersect(renderer.clipRect(LayoutPoint(), 0)); // FIXME: Incorrect for CSS regions.
 825 
 826     return result;
 827 }
 828 
 829 static bool subpixelOffsetFromRendererChanged(const LayoutSize&amp; oldSubpixelOffsetFromRenderer, const LayoutSize&amp; newSubpixelOffsetFromRenderer, float deviceScaleFactor)
 830 {
 831     FloatSize previous = snapSizeToDevicePixel(oldSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 832     FloatSize current = snapSizeToDevicePixel(newSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 833     return previous != current;
 834 }
 835 
 836 static FloatSize subpixelForLayerPainting(const LayoutPoint&amp; point, float pixelSnappingFactor)
 837 {
 838     LayoutUnit x = point.x();
 839     LayoutUnit y = point.y();
 840     x = x &gt;= 0 ? floorToDevicePixel(x, pixelSnappingFactor) : ceilToDevicePixel(x, pixelSnappingFactor);
 841     y = y &gt;= 0 ? floorToDevicePixel(y, pixelSnappingFactor) : ceilToDevicePixel(y, pixelSnappingFactor);
 842     return point - LayoutPoint(x, y);
 843 }
 844 
 845 struct OffsetFromRenderer {
 846     // 1.2px - &gt; { m_devicePixelOffset = 1px m_subpixelOffset = 0.2px }
 847     LayoutSize m_devicePixelOffset;
 848     LayoutSize m_subpixelOffset;
 849 };
 850 
 851 static OffsetFromRenderer computeOffsetFromRenderer(const LayoutSize&amp; offset, float deviceScaleFactor)
 852 {
 853     OffsetFromRenderer offsetFromRenderer;
 854     offsetFromRenderer.m_subpixelOffset = LayoutSize(subpixelForLayerPainting(toLayoutPoint(offset), deviceScaleFactor));
 855     offsetFromRenderer.m_devicePixelOffset = offset - offsetFromRenderer.m_subpixelOffset;
 856     return offsetFromRenderer;
 857 }
 858 
 859 struct SnappedRectInfo {
 860     LayoutRect m_snappedRect;
 861     LayoutSize m_snapDelta;
 862 };
 863 
 864 static SnappedRectInfo snappedGraphicsLayer(const LayoutSize&amp; offset, const LayoutSize&amp; size, float deviceScaleFactor)
 865 {
 866     SnappedRectInfo snappedGraphicsLayer;
 867     LayoutRect graphicsLayerRect = LayoutRect(toLayoutPoint(offset), size);
 868     snappedGraphicsLayer.m_snappedRect = LayoutRect(snapRectToDevicePixels(graphicsLayerRect, deviceScaleFactor));
 869     snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
 870     return snappedGraphicsLayer;
 871 }
 872 
<a name="29" id="anc29"></a><span class="line-modified"> 873 static LayoutSize computeOffsetFromAncestorGraphicsLayer(RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)</span>
 874 {
 875     if (!compositedAncestor)
 876         return toLayoutSize(location);
 877 
 878     // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
 879     // could be stale when a dynamic composited state change triggers a pre-order updateGeometry() traversal.
 880     LayoutSize ancestorSubpixelOffsetFromRenderer = compositedAncestor-&gt;backing()-&gt;subpixelOffsetFromRenderer();
 881     LayoutRect ancestorCompositedBounds = compositedAncestor-&gt;backing()-&gt;compositedBounds();
 882     LayoutSize floored = toLayoutSize(LayoutPoint(floorPointToDevicePixels(ancestorCompositedBounds.location() - ancestorSubpixelOffsetFromRenderer, deviceScaleFactor)));
 883     LayoutSize ancestorRendererOffsetFromAncestorGraphicsLayer = -(floored + ancestorSubpixelOffsetFromRenderer);
 884     return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
 885 }
 886 
 887 class ComputedOffsets {
 888 public:
 889     ComputedOffsets(const RenderLayer&amp; renderLayer, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)
 890         : m_renderLayer(renderLayer)
 891         , m_location(localRect.location())
 892         , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
 893         , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
 894         , m_deviceScaleFactor(renderLayer.renderer().document().deviceScaleFactor())
 895     {
 896     }
 897 
 898     LayoutSize fromParentGraphicsLayer()
 899     {
 900         if (!m_fromParentGraphicsLayer)
 901             m_fromParentGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset;
 902         return m_fromParentGraphicsLayer.value();
 903     }
 904 
 905     LayoutSize fromPrimaryGraphicsLayer()
 906     {
 907         if (!m_fromPrimaryGraphicsLayer)
 908             m_fromPrimaryGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset - m_primaryGraphicsLayerOffset;
 909         return m_fromPrimaryGraphicsLayer.value();
 910     }
 911 
 912 private:
 913     LayoutSize fromAncestorGraphicsLayer()
 914     {
 915         if (!m_fromAncestorGraphicsLayer) {
 916             auto* compositedAncestor = m_renderLayer.ancestorCompositingLayer();
 917             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(compositedAncestor, m_location, RenderLayer::AdjustForColumns);
 918             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);
 919         }
 920         return m_fromAncestorGraphicsLayer.value();
 921     }
 922 
 923     Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
 924     Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
 925     Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
 926 
 927     const RenderLayer&amp; m_renderLayer;
 928     // Location is relative to the renderer.
 929     const LayoutPoint m_location;
 930     const LayoutSize m_parentGraphicsLayerOffset;
 931     const LayoutSize m_primaryGraphicsLayerOffset;
 932     float m_deviceScaleFactor;
 933 };
 934 
 935 LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const
 936 {
<a name="30" id="anc30"></a><span class="line-modified"> 937     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, LayoutRect());</span>
 938     return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
 939         deviceScaleFactor()));
 940 }
 941 
 942 // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
<a name="31" id="anc31"></a><span class="line-modified"> 943 LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(RenderLayer* compositedAncestor, LayoutSize&amp; ancestorClippingLayerOffset) const</span>
 944 {
 945     if (!compositedAncestor || !compositedAncestor-&gt;backing())
 946         return renderer().view().documentRect();
 947 
 948     auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
 949     LayoutRect parentGraphicsLayerRect;
 950     if (m_owningLayer.isInsideFragmentedFlow()) {
 951         // FIXME: flows/columns need work.
 952         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
 953         ancestorCompositedBounds.setLocation(LayoutPoint());
 954         parentGraphicsLayerRect = ancestorCompositedBounds;
 955     }
 956 
 957     if (ancestorBackingLayer-&gt;hasClippingLayer()) {
 958         // If the compositing ancestor has a layer to clip children, we parent in that, and therefore position relative to it.
 959         LayoutRect clippingBox = clipBox(downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer()));
 960         LayoutSize clippingBoxOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clippingBox.location(), deviceScaleFactor());
 961         parentGraphicsLayerRect = snappedGraphicsLayer(clippingBoxOffset, clippingBox.size(), deviceScaleFactor()).m_snappedRect;
 962     }
 963 
 964     if (compositedAncestor-&gt;hasCompositedScrollableOverflow()) {
 965         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
 966         auto&amp; renderBox = downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer());
 967         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();
 968         ScrollOffset scrollOffset = compositedAncestor-&gt;scrollOffset();
 969         parentGraphicsLayerRect = LayoutRect((paddingBoxIncludingScrollbar.location() - toLayoutSize(ancestorCompositedBounds.location()) - toLayoutSize(scrollOffset)), paddingBoxIncludingScrollbar.size());
 970     }
 971 
<a name="32" id="anc32"></a><span class="line-removed"> 972     if (m_ancestorClippingLayer) {</span>
<span class="line-removed"> 973         // Call calculateRects to get the backgroundRect which is what is used to clip the contents of this</span>
<span class="line-removed"> 974         // layer. Note that we call it with temporaryClipRects = true because normally when computing clip rects</span>
<span class="line-removed"> 975         // for a compositing layer, rootLayer is the layer itself.</span>
<span class="line-removed"> 976         ShouldRespectOverflowClip shouldRespectOverflowClip = compositedAncestor-&gt;isolatesCompositedBlending() ? RespectOverflowClip : IgnoreOverflowClip;</span>
<span class="line-removed"> 977         RenderLayer::ClipRectsContext clipRectsContext(compositedAncestor, TemporaryClipRects, IgnoreOverlayScrollbarSize, shouldRespectOverflowClip);</span>
<span class="line-removed"> 978         LayoutRect parentClipRect = m_owningLayer.backgroundClipRect(clipRectsContext).rect(); // FIXME: Incorrect for CSS regions.</span>
<span class="line-removed"> 979         ASSERT(!parentClipRect.isInfinite());</span>
<span class="line-removed"> 980         LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, parentClipRect.location(), deviceScaleFactor());</span>
<span class="line-removed"> 981         LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, parentClipRect.size(), deviceScaleFactor()).m_snappedRect;</span>
<span class="line-removed"> 982         // The primary layer is then parented in, and positioned relative to this clipping layer.</span>
<span class="line-removed"> 983         ancestorClippingLayerOffset = snappedClippingLayerRect.location() - parentGraphicsLayerRect.location();</span>
<span class="line-removed"> 984         parentGraphicsLayerRect = snappedClippingLayerRect;</span>
<span class="line-removed"> 985     }</span>
 986     return parentGraphicsLayerRect;
 987 }
 988 
 989 void RenderLayerBacking::updateGeometry()
 990 {
 991     ASSERT(!m_owningLayer.normalFlowListDirty());
 992     ASSERT(!m_owningLayer.zOrderListsDirty());
 993     ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
 994     ASSERT(!renderer().view().needsLayout());
 995 
 996     const RenderStyle&amp; style = renderer().style();
 997 
 998     bool isRunningAcceleratedTransformAnimation = false;
<a name="33" id="anc33"></a><span class="line-removed"> 999     bool isRunningAcceleratedOpacityAnimation = false;</span>
1000     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<a name="34" id="anc34"></a><span class="line-modified">1001         if (auto* timeline = renderer().documentTimeline()) {</span>
1002             isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<a name="35" id="anc35"></a><span class="line-modified">1003             isRunningAcceleratedOpacityAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyOpacity);</span>
<span class="line-removed">1004         }</span>
<span class="line-removed">1005     } else {</span>
1006         isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<a name="36" id="anc36"></a><span class="line-removed">1007         isRunningAcceleratedOpacityAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyOpacity);</span>
<span class="line-removed">1008     }</span>
<span class="line-removed">1009 </span>
<span class="line-removed">1010     // Set transform property, if it is not animating. We have to do this here because the transform</span>
<span class="line-removed">1011     // is affected by the layer dimensions.</span>
<span class="line-removed">1012     if (!isRunningAcceleratedTransformAnimation)</span>
<span class="line-removed">1013         updateTransform(style);</span>
<span class="line-removed">1014 </span>
<span class="line-removed">1015     // Set opacity, if it is not animating.</span>
<span class="line-removed">1016     if (!isRunningAcceleratedOpacityAnimation)</span>
<span class="line-removed">1017         updateOpacity(style);</span>
1018 
<a name="37" id="anc37"></a>

1019     updateFilters(style);
1020 #if ENABLE(FILTERS_LEVEL_2)
1021     updateBackdropFilters(style);
1022 #endif
1023 #if ENABLE(CSS_COMPOSITING)
1024     updateBlendMode(style);
1025 #endif
1026 
<a name="38" id="anc38"></a><span class="line-removed">1027     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959</span>
<span class="line-removed">1028     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();</span>
<span class="line-removed">1029     m_graphicsLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-removed">1030     m_graphicsLayer-&gt;setBackfaceVisibility(style.backfaceVisibility() == BackfaceVisibility::Visible);</span>
<span class="line-removed">1031 </span>
1032     auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();
<a name="39" id="anc39"></a><span class="line-modified">1033     LayoutSize ancestorClippingLayerOffset;</span>
<span class="line-modified">1034     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor, ancestorClippingLayerOffset);</span>



























1035     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);
1036 
1037     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);
<a name="40" id="anc40"></a>

1038     m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
<a name="41" id="anc41"></a><span class="line-modified">1039     m_graphicsLayer-&gt;setPosition(primaryGraphicsLayerRect.location());</span>
<span class="line-modified">1040     m_graphicsLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>










1041 
1042     auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
1043         LayoutRect animatedBounds;
1044         if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
1045             return FloatRect(animatedBounds);
1046         return { };
1047     };
1048     m_graphicsLayer-&gt;setAnimationExtent(computeAnimationExtent());
<a name="42" id="anc42"></a>

1049 
<a name="43" id="anc43"></a><span class="line-modified">1050     ComputedOffsets rendererOffset(m_owningLayer, LayoutRect(), parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-modified">1051     if (m_ancestorClippingLayer) {</span>
<span class="line-removed">1052         // Clipping layer is parented in the ancestor layer.</span>
<span class="line-removed">1053         m_ancestorClippingLayer-&gt;setPosition(toLayoutPoint(ancestorClippingLayerOffset));</span>
<span class="line-removed">1054         m_ancestorClippingLayer-&gt;setSize(parentGraphicsLayerRect.size());</span>
<span class="line-removed">1055         m_ancestorClippingLayer-&gt;setOffsetFromRenderer(-rendererOffset.fromParentGraphicsLayer());</span>
<span class="line-removed">1056     }</span>
<span class="line-removed">1057 </span>
<span class="line-removed">1058     if (m_contentsContainmentLayer) {</span>
<span class="line-removed">1059         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-removed">1060         m_contentsContainmentLayer-&gt;setPosition(primaryGraphicsLayerRect.location());</span>
<span class="line-removed">1061         m_graphicsLayer-&gt;setPosition(FloatPoint());</span>
<span class="line-removed">1062         // Use the same size as m_graphicsLayer so transforms behave correctly.</span>
<span class="line-removed">1063         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>
<span class="line-removed">1064     }</span>
1065 
1066     // Compute renderer offset from primary graphics layer. Note that primaryGraphicsLayerRect is in parentGraphicsLayer&#39;s coordinate system which is not necessarily
1067     // the same as the ancestor graphics layer.
1068     OffsetFromRenderer primaryGraphicsLayerOffsetFromRenderer;
1069     LayoutSize oldSubpixelOffsetFromRenderer = m_subpixelOffsetFromRenderer;
1070     primaryGraphicsLayerOffsetFromRenderer = computeOffsetFromRenderer(-rendererOffset.fromPrimaryGraphicsLayer(), deviceScaleFactor());
1071     m_subpixelOffsetFromRenderer = primaryGraphicsLayerOffsetFromRenderer.m_subpixelOffset;
<a name="44" id="anc44"></a>
1072 
1073     if (primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset != m_graphicsLayer-&gt;offsetFromRenderer()) {
1074         m_graphicsLayer-&gt;setOffsetFromRenderer(primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset);
1075         positionOverflowControlsLayers();
1076     }
1077 
<a name="45" id="anc45"></a><span class="line-removed">1078     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {</span>
<span class="line-removed">1079         // For non-root layers, background is always painted by the primary graphics layer.</span>
<span class="line-removed">1080         ASSERT(!m_backgroundLayer);</span>
<span class="line-removed">1081         // Subpixel offset from graphics layer or size changed.</span>
<span class="line-removed">1082         bool hadSubpixelRounding = !m_subpixelOffsetFromRenderer.isZero() || compositedBounds().size() != primaryGraphicsLayerRect.size();</span>
<span class="line-removed">1083         m_graphicsLayer-&gt;setContentsOpaque(!hadSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));</span>
<span class="line-removed">1084     }</span>
<span class="line-removed">1085 </span>
1086     // If we have a layer that clips children, position it.
1087     LayoutRect clippingBox;
1088     if (auto* clipLayer = clippingLayer()) {
1089         // clipLayer is the m_childContainmentLayer.
1090         clippingBox = clipBox(downcast&lt;RenderBox&gt;(renderer()));
1091         // Clipping layer is parented in the primary graphics layer.
1092         LayoutSize clipBoxOffsetFromGraphicsLayer = toLayoutSize(clippingBox.location()) + rendererOffset.fromPrimaryGraphicsLayer();
1093         SnappedRectInfo snappedClippingGraphicsLayer = snappedGraphicsLayer(clipBoxOffsetFromGraphicsLayer, clippingBox.size(), deviceScaleFactor());
1094         clipLayer-&gt;setPosition(snappedClippingGraphicsLayer.m_snappedRect.location());
1095         clipLayer-&gt;setSize(snappedClippingGraphicsLayer.m_snappedRect.size());
1096         clipLayer-&gt;setOffsetFromRenderer(toLayoutSize(clippingBox.location() - snappedClippingGraphicsLayer.m_snapDelta));
1097 
<a name="46" id="anc46"></a>






1098         if (m_childClippingMaskLayer &amp;&amp; !m_scrollContainerLayer) {
1099             m_childClippingMaskLayer-&gt;setSize(clipLayer-&gt;size());
1100             m_childClippingMaskLayer-&gt;setPosition(FloatPoint());
1101             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(clipLayer-&gt;offsetFromRenderer());
1102         }
1103     }
1104 
1105     if (m_maskLayer)
1106         updateMaskingLayerGeometry();
1107 
1108     if (renderer().hasTransformRelatedProperty()) {
1109         // Update properties that depend on layer dimensions.
1110         FloatPoint3D transformOrigin = computeTransformOriginForPainting(downcast&lt;RenderBox&gt;(renderer()).borderBoxRect());
1111         FloatPoint layerOffset = roundPointToDevicePixels(toLayoutPoint(rendererOffset.fromParentGraphicsLayer()), deviceScaleFactor());
1112         // Compute the anchor point, which is in the center of the renderer box unless transform-origin is set.
1113         FloatPoint3D anchor(
1114             primaryGraphicsLayerRect.width() ? ((layerOffset.x() - primaryGraphicsLayerRect.x()) + transformOrigin.x()) / primaryGraphicsLayerRect.width() : 0.5,
1115             primaryGraphicsLayerRect.height() ? ((layerOffset.y() - primaryGraphicsLayerRect.y())+ transformOrigin.y()) / primaryGraphicsLayerRect.height() : 0.5,
1116             transformOrigin.z());
1117 
1118         if (m_contentsContainmentLayer)
1119             m_contentsContainmentLayer-&gt;setAnchorPoint(anchor);
1120         else
1121             m_graphicsLayer-&gt;setAnchorPoint(anchor);
1122 
1123         auto* clipLayer = clippingLayer();
1124         if (style.hasPerspective()) {
1125             TransformationMatrix t = owningLayer().perspectiveTransform();
1126 
1127             if (clipLayer) {
1128                 clipLayer-&gt;setChildrenTransform(t);
1129                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1130             }
1131             else
1132                 m_graphicsLayer-&gt;setChildrenTransform(t);
1133         } else {
1134             if (clipLayer)
1135                 clipLayer-&gt;setChildrenTransform(TransformationMatrix());
1136             else
1137                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1138         }
1139     } else {
1140         m_graphicsLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1141         if (m_contentsContainmentLayer)
1142             m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1143     }
1144 
<a name="47" id="anc47"></a><span class="line-removed">1145     if (m_foregroundLayer) {</span>
<span class="line-removed">1146         FloatPoint foregroundPosition;</span>
<span class="line-removed">1147         FloatSize foregroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-removed">1148         FloatSize foregroundOffset = m_graphicsLayer-&gt;offsetFromRenderer();</span>
<span class="line-removed">1149         if (hasClippingLayer()) {</span>
<span class="line-removed">1150             // If we have a clipping layer (which clips descendants), then the foreground layer is a child of it,</span>
<span class="line-removed">1151             // so that it gets correctly sorted with children. In that case, position relative to the clipping layer.</span>
<span class="line-removed">1152             foregroundSize = FloatSize(clippingBox.size());</span>
<span class="line-removed">1153             foregroundOffset = toFloatSize(clippingBox.location());</span>
<span class="line-removed">1154         }</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156         m_foregroundLayer-&gt;setPosition(foregroundPosition);</span>
<span class="line-removed">1157         m_foregroundLayer-&gt;setSize(foregroundSize);</span>
<span class="line-removed">1158         m_foregroundLayer-&gt;setOffsetFromRenderer(foregroundOffset);</span>
<span class="line-removed">1159     }</span>
<span class="line-removed">1160 </span>
<span class="line-removed">1161     if (m_backgroundLayer) {</span>
<span class="line-removed">1162         FloatPoint backgroundPosition;</span>
<span class="line-removed">1163         FloatSize backgroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-removed">1164         if (backgroundLayerPaintsFixedRootBackground()) {</span>
<span class="line-removed">1165             const FrameView&amp; frameView = renderer().view().frameView();</span>
<span class="line-removed">1166             backgroundPosition = frameView.scrollPositionForFixedPosition();</span>
<span class="line-removed">1167             backgroundSize = frameView.layoutSize();</span>
<span class="line-removed">1168         } else {</span>
<span class="line-removed">1169             auto boundingBox = renderer().objectBoundingBox();</span>
<span class="line-removed">1170             backgroundPosition = boundingBox.location();</span>
<span class="line-removed">1171             backgroundSize = boundingBox.size();</span>
<span class="line-removed">1172         }</span>
<span class="line-removed">1173         m_backgroundLayer-&gt;setPosition(backgroundPosition);</span>
<span class="line-removed">1174         m_backgroundLayer-&gt;setSize(backgroundSize);</span>
<span class="line-removed">1175         m_backgroundLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());</span>
<span class="line-removed">1176     }</span>
<span class="line-removed">1177 </span>
1178     if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
1179         auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
1180         reflectionBacking-&gt;updateGeometry();
1181 
1182         // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
1183         // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
1184         FloatRect layerBounds = this-&gt;compositedBounds();
1185         FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
1186         reflectionBacking-&gt;graphicsLayer()-&gt;setReplicatedLayerPosition(FloatPoint(layerBounds.location() - reflectionLayerBounds.location()));
1187     }
1188 
1189     if (m_scrollContainerLayer) {
1190         ASSERT(m_scrolledContentsLayer);
1191         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
<a name="48" id="anc48"></a><span class="line-modified">1192         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();</span>
1193         LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
1194 
1195         // FIXME: need to do some pixel snapping here.
<a name="49" id="anc49"></a><span class="line-modified">1196         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBoxIncludingScrollbar.location() - parentLayerBounds.location()));</span>
1197         m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
1198 
1199         ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
1200         updateScrollOffset(scrollOffset);
<a name="50" id="anc50"></a><span class="line-removed">1201 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1202         m_scrolledContentsLayer-&gt;setPosition({ }); // FIXME: necessary?</span>
<span class="line-removed">1203 #endif</span>
1204 
1205         FloatSize oldScrollingLayerOffset = m_scrollContainerLayer-&gt;offsetFromRenderer();
<a name="51" id="anc51"></a><span class="line-modified">1206         m_scrollContainerLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBoxIncludingScrollbar.location()));</span>
1207 
1208         if (m_childClippingMaskLayer) {
1209             m_childClippingMaskLayer-&gt;setPosition(m_scrollContainerLayer-&gt;position());
1210             m_childClippingMaskLayer-&gt;setSize(m_scrollContainerLayer-&gt;size());
<a name="52" id="anc52"></a><span class="line-modified">1211             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBoxIncludingScrollbar.location()));</span>
1212         }
1213 
1214         bool paddingBoxOffsetChanged = oldScrollingLayerOffset != m_scrollContainerLayer-&gt;offsetFromRenderer();
1215 
1216         IntSize scrollSize(m_owningLayer.scrollWidth(), m_owningLayer.scrollHeight());
1217         if (scrollSize != m_scrolledContentsLayer-&gt;size() || paddingBoxOffsetChanged)
1218             m_scrolledContentsLayer-&gt;setNeedsDisplay();
1219 
1220         m_scrolledContentsLayer-&gt;setSize(scrollSize);
1221         m_scrolledContentsLayer-&gt;setScrollOffset(scrollOffset, GraphicsLayer::DontSetNeedsDisplay);
<a name="53" id="anc53"></a><span class="line-modified">1222         m_scrolledContentsLayer-&gt;setOffsetFromRenderer(toLayoutSize(paddingBoxIncludingScrollbar.location()), GraphicsLayer::DontSetNeedsDisplay);</span>


























1223 
<a name="54" id="anc54"></a><span class="line-modified">1224         if (m_foregroundLayer) {</span>
<span class="line-modified">1225             m_foregroundLayer-&gt;setSize(m_scrolledContentsLayer-&gt;size());</span>
<span class="line-modified">1226             m_foregroundLayer-&gt;setOffsetFromRenderer(m_scrolledContentsLayer-&gt;offsetFromRenderer() - toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()));</span>








1227         }
<a name="55" id="anc55"></a>


1228     }
1229 
1230     // If this layer was created just for clipping or to apply perspective, it doesn&#39;t need its own backing store.
1231     LayoutRect ancestorCompositedBounds = compositedAncestor ? compositedAncestor-&gt;backing()-&gt;compositedBounds() : LayoutRect();
1232     setRequiresOwnBackingStore(compositor().requiresOwnBackingStore(m_owningLayer, compositedAncestor,
1233         LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()), ancestorCompositedBounds));
1234 #if ENABLE(FILTERS_LEVEL_2)
1235     updateBackdropFiltersGeometry();
1236 #endif
1237     updateAfterWidgetResize();
1238 
1239     if (subpixelOffsetFromRendererChanged(oldSubpixelOffsetFromRenderer, m_subpixelOffsetFromRenderer, deviceScaleFactor()) &amp;&amp; canIssueSetNeedsDisplay())
1240         setContentsNeedDisplay();
1241 }
1242 
1243 void RenderLayerBacking::setLocationOfScrolledContents(ScrollOffset scrollOffset, ScrollingLayerPositionAction setOrSync)
1244 {
<a name="56" id="anc56"></a><span class="line-removed">1245 #if PLATFORM(IOS_FAMILY)</span>
1246     if (setOrSync == ScrollingLayerPositionAction::Sync)
1247         m_scrollContainerLayer-&gt;syncBoundsOrigin(scrollOffset);
1248     else
1249         m_scrollContainerLayer-&gt;setBoundsOrigin(scrollOffset);
<a name="57" id="anc57"></a><span class="line-removed">1250 #else</span>
<span class="line-removed">1251     if (setOrSync == ScrollingLayerPositionAction::Sync)</span>
<span class="line-removed">1252         m_scrolledContentsLayer-&gt;syncPosition(-scrollOffset);</span>
<span class="line-removed">1253     else</span>
<span class="line-removed">1254         m_scrolledContentsLayer-&gt;setPosition(-scrollOffset);</span>
<span class="line-removed">1255 #endif</span>
1256 }
1257 
1258 void RenderLayerBacking::updateScrollOffset(ScrollOffset scrollOffset)
1259 {
<a name="58" id="anc58"></a><span class="line-modified">1260     if (m_owningLayer.isInUserScroll()) {</span>
1261         // If scrolling is happening externally, we don&#39;t want to touch the layer bounds origin here because that will cause jitter.
1262         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Sync);
1263         m_owningLayer.setRequiresScrollPositionReconciliation(true);
1264     } else {
1265         // Note that we implement the contents offset via the bounds origin on this layer, rather than a position on the sublayer.
1266         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Set);
1267         m_owningLayer.setRequiresScrollPositionReconciliation(false);
1268     }
<a name="59" id="anc59"></a>

1269 }
1270 
1271 void RenderLayerBacking::updateAfterDescendants()
1272 {
1273     // FIXME: this potentially duplicates work we did in updateConfiguration().
1274     PaintedContentsInfo contentsInfo(*this);
1275     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText() &amp;&amp; FontCascade::isSubpixelAntialiasingAvailable());
1276 
1277     if (!m_owningLayer.isRenderViewLayer()) {
1278         bool didUpdateContentsRect = false;
1279         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
1280         if (!didUpdateContentsRect &amp;&amp; m_graphicsLayer-&gt;usesContentsLayer())
1281             resetContentsRect();
1282     }
1283 
1284     updateDrawsContent(contentsInfo);
1285 
<a name="60" id="anc60"></a>





1286     m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
1287     if (m_scrollContainerLayer) {
1288         m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
1289         m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
1290     }
1291 }
1292 
1293 // FIXME: Avoid repaints when clip path changes.
1294 void RenderLayerBacking::updateMaskingLayerGeometry()
1295 {
1296     m_maskLayer-&gt;setSize(m_graphicsLayer-&gt;size());
1297     m_maskLayer-&gt;setPosition(FloatPoint());
1298     m_maskLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());
1299 
1300     if (!m_maskLayer-&gt;drawsContent()) {
1301         if (renderer().hasClipPath()) {
1302             ASSERT(renderer().style().clipPath()-&gt;type() != ClipPathOperation::Reference);
1303 
1304             WindRule windRule;
1305             // FIXME: Use correct reference box for inlines: https://bugs.webkit.org/show_bug.cgi?id=129047
1306             LayoutRect boundingBox = m_owningLayer.boundingBox(&amp;m_owningLayer);
1307             LayoutRect referenceBoxForClippedInline = LayoutRect(snapRectToDevicePixels(boundingBox, deviceScaleFactor()));
1308             LayoutSize offset = LayoutSize(snapSizeToDevicePixel(-m_subpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor()));
1309             Path clipPath = m_owningLayer.computeClipPath(offset, referenceBoxForClippedInline, windRule);
1310 
1311             FloatSize pathOffset = m_maskLayer-&gt;offsetFromRenderer();
1312             if (!pathOffset.isZero())
1313                 clipPath.translate(-pathOffset);
1314 
1315             m_maskLayer-&gt;setShapeLayerPath(clipPath);
1316             m_maskLayer-&gt;setShapeLayerWindRule(windRule);
1317         }
1318     }
1319 }
1320 
1321 void RenderLayerBacking::updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
1322 {
1323     if (!m_owningLayer.hasVisibleContent())
1324         return;
1325 
1326     // The order of operations here matters, since the last valid type of contents needs
1327     // to also update the contentsRect.
1328     updateDirectlyCompositedBackgroundColor(contentsInfo, didUpdateContentsRect);
1329     updateDirectlyCompositedBackgroundImage(contentsInfo, didUpdateContentsRect);
1330 }
1331 
1332 void RenderLayerBacking::updateInternalHierarchy()
1333 {
1334     // m_foregroundLayer has to be inserted in the correct order with child layers,
1335     // so it&#39;s not inserted here.
<a name="61" id="anc61"></a><span class="line-modified">1336     if (m_ancestorClippingLayer)</span>
<span class="line-modified">1337         m_ancestorClippingLayer-&gt;removeAllChildren();</span>











1338 
1339     if (m_contentsContainmentLayer) {
1340         m_contentsContainmentLayer-&gt;removeAllChildren();
<a name="62" id="anc62"></a><span class="line-modified">1341         if (m_ancestorClippingLayer)</span>
<span class="line-modified">1342             m_ancestorClippingLayer-&gt;addChild(*m_contentsContainmentLayer);</span>
1343     }
1344 
1345     if (m_backgroundLayer)
1346         m_contentsContainmentLayer-&gt;addChild(*m_backgroundLayer);
1347 
1348     if (m_contentsContainmentLayer)
1349         m_contentsContainmentLayer-&gt;addChild(*m_graphicsLayer);
<a name="63" id="anc63"></a><span class="line-modified">1350     else if (m_ancestorClippingLayer)</span>
<span class="line-modified">1351         m_ancestorClippingLayer-&gt;addChild(*m_graphicsLayer);</span>
1352 
1353     if (m_childContainmentLayer)
1354         m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
1355 
1356     if (m_scrollContainerLayer) {
1357         auto* superlayer = m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
1358         superlayer-&gt;addChild(*m_scrollContainerLayer);
1359     }
1360 
1361     // The clip for child layers does not include space for overflow controls, so they exist as
1362     // siblings of the clipping layer if we have one. Normal children of this layer are set as
1363     // children of the clipping layer.
1364     if (m_layerForHorizontalScrollbar)
1365         m_graphicsLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
1366 
1367     if (m_layerForVerticalScrollbar)
1368         m_graphicsLayer-&gt;addChild(*m_layerForVerticalScrollbar);
1369 
1370     if (m_layerForScrollCorner)
1371         m_graphicsLayer-&gt;addChild(*m_layerForScrollCorner);
1372 }
1373 
1374 void RenderLayerBacking::resetContentsRect()
1375 {
1376     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
1377 
1378     if (is&lt;RenderBox&gt;(renderer())) {
1379         LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<a name="64" id="anc64"></a><span class="line-modified">1380         boxRect.move(contentOffsetInCompostingLayer());</span>
1381         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
1382         m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
1383     }
1384 
1385     m_graphicsLayer-&gt;setContentsTileSize(IntSize());
1386     m_graphicsLayer-&gt;setContentsTilePhase(IntSize());
1387 }
1388 
1389 void RenderLayerBacking::updateDrawsContent()
1390 {
1391     PaintedContentsInfo contentsInfo(*this);
1392     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText());
1393 
1394     updateDrawsContent(contentsInfo);
1395 }
1396 
1397 void RenderLayerBacking::updateDrawsContent(PaintedContentsInfo&amp; contentsInfo)
1398 {
1399     if (m_scrollContainerLayer) {
1400         // We don&#39;t have to consider overflow controls, because we know that the scrollbars are drawn elsewhere.
1401         // m_graphicsLayer only needs backing store if the non-scrolling parts (background, outlines, borders, shadows etc) need to paint.
1402         // m_scrollContainerLayer never has backing store.
1403         // m_scrolledContentsLayer only needs backing store if the scrolled contents need to paint.
1404         bool hasNonScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasVisibleBoxDecorationsOrBackground();
1405         m_graphicsLayer-&gt;setDrawsContent(hasNonScrollingPaintedContent);
1406 
<a name="65" id="anc65"></a><span class="line-modified">1407         bool hasScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; (renderer().hasBackground() || contentsInfo.paintsContent());</span>
1408         m_scrolledContentsLayer-&gt;setDrawsContent(hasScrollingPaintedContent);
1409         return;
1410     }
1411 
1412     bool hasPaintedContent = containsPaintedContent(contentsInfo);
1413 
1414     m_paintsSubpixelAntialiasedText = renderer().settings().subpixelAntialiasedLayerTextEnabled() &amp;&amp; contentsInfo.paintsSubpixelAntialiasedText();
1415 
1416     // FIXME: we could refine this to only allocate backing for one of these layers if possible.
1417     m_graphicsLayer-&gt;setDrawsContent(hasPaintedContent);
1418     if (m_foregroundLayer) {
1419         m_foregroundLayer-&gt;setDrawsContent(hasPaintedContent);
1420         m_foregroundLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1421         // The text content is painted into the foreground layer.
1422         // FIXME: this ignores SVG background images which may contain text.
1423         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(false);
1424     } else
1425         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1426 
1427     if (m_backgroundLayer)
1428         m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
1429 }
1430 
<a name="66" id="anc66"></a>































































1431 // Return true if the layer changed.
<a name="67" id="anc67"></a><span class="line-modified">1432 bool RenderLayerBacking::updateAncestorClippingLayer(bool needsAncestorClip)</span>
1433 {
1434     bool layersChanged = false;
1435 
1436     if (needsAncestorClip) {
<a name="68" id="anc68"></a><span class="line-modified">1437         if (!m_ancestorClippingLayer) {</span>
<span class="line-modified">1438             m_ancestorClippingLayer = createGraphicsLayer(&quot;ancestor clipping&quot;);</span>
<span class="line-modified">1439             m_ancestorClippingLayer-&gt;setMasksToBounds(true);</span>









1440             layersChanged = true;
1441         }
<a name="69" id="anc69"></a><span class="line-modified">1442     } else if (hasAncestorClippingLayer()) {</span>
<span class="line-modified">1443         willDestroyLayer(m_ancestorClippingLayer.get());</span>
<span class="line-modified">1444         GraphicsLayer::unparentAndClear(m_ancestorClippingLayer);</span>


1445         layersChanged = true;
1446     }
1447 
1448     return layersChanged;
1449 }
1450 
1451 // Return true if the layer changed.
1452 bool RenderLayerBacking::updateDescendantClippingLayer(bool needsDescendantClip)
1453 {
1454     bool layersChanged = false;
1455 
1456     if (needsDescendantClip) {
1457         if (!m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking) {
1458             m_childContainmentLayer = createGraphicsLayer(&quot;child clipping&quot;);
1459             m_childContainmentLayer-&gt;setMasksToBounds(true);
1460             layersChanged = true;
1461         }
1462     } else if (hasClippingLayer()) {
1463         willDestroyLayer(m_childContainmentLayer.get());
1464         GraphicsLayer::unparentAndClear(m_childContainmentLayer);
1465         layersChanged = true;
1466     }
1467 
1468     return layersChanged;
1469 }
1470 
1471 void RenderLayerBacking::setBackgroundLayerPaintsFixedRootBackground(bool backgroundLayerPaintsFixedRootBackground)
1472 {
1473     if (backgroundLayerPaintsFixedRootBackground == m_backgroundLayerPaintsFixedRootBackground)
1474         return;
1475 
1476     m_backgroundLayerPaintsFixedRootBackground = backgroundLayerPaintsFixedRootBackground;
1477 
1478     if (m_backgroundLayerPaintsFixedRootBackground) {
1479         ASSERT(m_isFrameLayerWithTiledBacking);
1480         renderer().view().frameView().removeSlowRepaintObject(*renderer().view().rendererForRootBackground());
1481     }
1482 }
1483 
1484 void RenderLayerBacking::setRequiresBackgroundLayer(bool requiresBackgroundLayer)
1485 {
1486     if (requiresBackgroundLayer == m_requiresBackgroundLayer)
1487         return;
1488 
1489     m_requiresBackgroundLayer = requiresBackgroundLayer;
1490     m_owningLayer.setNeedsCompositingConfigurationUpdate();
1491 }
1492 
1493 bool RenderLayerBacking::requiresHorizontalScrollbarLayer() const
1494 {
1495     if (!m_owningLayer.hasOverlayScrollbars())
1496         return false;
1497     return m_owningLayer.horizontalScrollbar();
1498 }
1499 
1500 bool RenderLayerBacking::requiresVerticalScrollbarLayer() const
1501 {
1502     if (!m_owningLayer.hasOverlayScrollbars())
1503         return false;
1504     return m_owningLayer.verticalScrollbar();
1505 }
1506 
1507 bool RenderLayerBacking::requiresScrollCornerLayer() const
1508 {
1509     if (!m_owningLayer.hasOverlayScrollbars())
1510         return false;
1511     return !m_owningLayer.scrollCornerAndResizerRect().isEmpty();
1512 }
1513 
1514 bool RenderLayerBacking::updateOverflowControlsLayers(bool needsHorizontalScrollbarLayer, bool needsVerticalScrollbarLayer, bool needsScrollCornerLayer)
1515 {
1516     bool horizontalScrollbarLayerChanged = false;
1517     if (needsHorizontalScrollbarLayer) {
1518         if (!m_layerForHorizontalScrollbar) {
1519             m_layerForHorizontalScrollbar = createGraphicsLayer(&quot;horizontal scrollbar&quot;);
<a name="70" id="anc70"></a><span class="line-modified">1520             m_layerForHorizontalScrollbar-&gt;setCanDetachBackingStore(false);</span>
1521             horizontalScrollbarLayerChanged = true;
1522         }
1523     } else if (m_layerForHorizontalScrollbar) {
1524         willDestroyLayer(m_layerForHorizontalScrollbar.get());
1525         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
1526         horizontalScrollbarLayerChanged = true;
1527     }
1528 
1529     bool verticalScrollbarLayerChanged = false;
1530     if (needsVerticalScrollbarLayer) {
1531         if (!m_layerForVerticalScrollbar) {
1532             m_layerForVerticalScrollbar = createGraphicsLayer(&quot;vertical scrollbar&quot;);
<a name="71" id="anc71"></a><span class="line-modified">1533             m_layerForVerticalScrollbar-&gt;setCanDetachBackingStore(false);</span>
1534             verticalScrollbarLayerChanged = true;
1535         }
1536     } else if (m_layerForVerticalScrollbar) {
1537         willDestroyLayer(m_layerForVerticalScrollbar.get());
1538         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
1539         verticalScrollbarLayerChanged = true;
1540     }
1541 
1542     bool scrollCornerLayerChanged = false;
1543     if (needsScrollCornerLayer) {
1544         if (!m_layerForScrollCorner) {
1545             m_layerForScrollCorner = createGraphicsLayer(&quot;scroll corner&quot;);
<a name="72" id="anc72"></a><span class="line-modified">1546             m_layerForScrollCorner-&gt;setCanDetachBackingStore(false);</span>
1547             scrollCornerLayerChanged = true;
1548         }
1549     } else if (m_layerForScrollCorner) {
1550         willDestroyLayer(m_layerForScrollCorner.get());
1551         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
1552         scrollCornerLayerChanged = true;
1553     }
1554 
1555     if (auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator()) {
1556         if (horizontalScrollbarLayerChanged)
1557             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, HorizontalScrollbar);
1558         if (verticalScrollbarLayerChanged)
1559             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, VerticalScrollbar);
1560     }
1561 
1562     return horizontalScrollbarLayerChanged || verticalScrollbarLayerChanged || scrollCornerLayerChanged;
1563 }
1564 
1565 void RenderLayerBacking::positionOverflowControlsLayers()
1566 {
1567     if (!m_owningLayer.hasScrollbars())
1568         return;
1569 
1570     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
1571 
1572     FloatSize offsetFromRenderer = m_graphicsLayer-&gt;offsetFromRenderer();
1573     if (auto* layer = layerForHorizontalScrollbar()) {
1574         IntRect hBarRect = m_owningLayer.rectForHorizontalScrollbar(borderBox);
1575         layer-&gt;setPosition(hBarRect.location() - offsetFromRenderer);
1576         layer-&gt;setSize(hBarRect.size());
1577         if (layer-&gt;usesContentsLayer()) {
1578             IntRect barRect = IntRect(IntPoint(), hBarRect.size());
1579             layer-&gt;setContentsRect(barRect);
1580             layer-&gt;setContentsClippingRect(FloatRoundedRect(barRect));
1581         }
1582         layer-&gt;setDrawsContent(m_owningLayer.horizontalScrollbar() &amp;&amp; !layer-&gt;usesContentsLayer());
1583     }
1584 
1585     if (auto* layer = layerForVerticalScrollbar()) {
1586         IntRect vBarRect = m_owningLayer.rectForVerticalScrollbar(borderBox);
1587         layer-&gt;setPosition(vBarRect.location() - offsetFromRenderer);
1588         layer-&gt;setSize(vBarRect.size());
1589         if (layer-&gt;usesContentsLayer()) {
1590             IntRect barRect = IntRect(IntPoint(), vBarRect.size());
1591             layer-&gt;setContentsRect(barRect);
1592             layer-&gt;setContentsClippingRect(FloatRoundedRect(barRect));
1593         }
1594         layer-&gt;setDrawsContent(m_owningLayer.verticalScrollbar() &amp;&amp; !layer-&gt;usesContentsLayer());
1595     }
1596 
1597     if (auto* layer = layerForScrollCorner()) {
1598         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
1599         layer-&gt;setPosition(scrollCornerAndResizer.location() - offsetFromRenderer);
1600         layer-&gt;setSize(scrollCornerAndResizer.size());
1601         layer-&gt;setDrawsContent(!scrollCornerAndResizer.isEmpty());
1602     }
1603 }
1604 
1605 bool RenderLayerBacking::updateForegroundLayer(bool needsForegroundLayer)
1606 {
1607     bool layerChanged = false;
1608     if (needsForegroundLayer) {
1609         if (!m_foregroundLayer) {
1610             String layerName = m_owningLayer.name() + &quot; (foreground)&quot;;
1611             m_foregroundLayer = createGraphicsLayer(layerName);
1612             m_foregroundLayer-&gt;setDrawsContent(true);
<a name="73" id="anc73"></a><span class="line-removed">1613             m_foregroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintForeground);</span>
1614             layerChanged = true;
1615         }
1616     } else if (m_foregroundLayer) {
1617         willDestroyLayer(m_foregroundLayer.get());
1618         GraphicsLayer::unparentAndClear(m_foregroundLayer);
1619         layerChanged = true;
1620     }
1621 
<a name="74" id="anc74"></a><span class="line-removed">1622     if (layerChanged) {</span>
<span class="line-removed">1623         m_graphicsLayer-&gt;setNeedsDisplay();</span>
<span class="line-removed">1624         m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
<span class="line-removed">1625     }</span>
<span class="line-removed">1626 </span>
1627     return layerChanged;
1628 }
1629 
1630 bool RenderLayerBacking::updateBackgroundLayer(bool needsBackgroundLayer)
1631 {
1632     bool layerChanged = false;
1633     if (needsBackgroundLayer) {
1634         if (!m_backgroundLayer) {
1635             String layerName = m_owningLayer.name() + &quot; (background)&quot;;
1636             m_backgroundLayer = createGraphicsLayer(layerName);
1637             m_backgroundLayer-&gt;setDrawsContent(true);
1638             m_backgroundLayer-&gt;setAnchorPoint(FloatPoint3D());
<a name="75" id="anc75"></a><span class="line-removed">1639             m_backgroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintBackground);</span>
1640             layerChanged = true;
1641         }
1642 
1643         if (!m_contentsContainmentLayer) {
1644             String layerName = m_owningLayer.name() + &quot; (contents containment)&quot;;
1645             m_contentsContainmentLayer = createGraphicsLayer(layerName);
1646             m_contentsContainmentLayer-&gt;setAppliesPageScale(true);
1647             m_graphicsLayer-&gt;setAppliesPageScale(false);
1648             layerChanged = true;
1649         }
1650     } else {
1651         if (m_backgroundLayer) {
1652             willDestroyLayer(m_backgroundLayer.get());
1653             GraphicsLayer::unparentAndClear(m_backgroundLayer);
1654             layerChanged = true;
1655         }
1656         if (m_contentsContainmentLayer) {
1657             willDestroyLayer(m_contentsContainmentLayer.get());
1658             GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
1659             layerChanged = true;
1660             m_graphicsLayer-&gt;setAppliesPageScale(true);
1661         }
1662     }
1663 
<a name="76" id="anc76"></a><span class="line-removed">1664     if (layerChanged)</span>
<span class="line-removed">1665         m_graphicsLayer-&gt;setNeedsDisplay();</span>
<span class="line-removed">1666 </span>
1667     return layerChanged;
1668 }
1669 
1670 // Masking layer is used for masks or clip-path.
<a name="77" id="anc77"></a><span class="line-modified">1671 void RenderLayerBacking::updateMaskingLayer(bool hasMask, bool hasClipPath)</span>
1672 {
1673     bool layerChanged = false;
1674     if (hasMask || hasClipPath) {
<a name="78" id="anc78"></a><span class="line-modified">1675         GraphicsLayerPaintingPhase maskPhases = 0;</span>
1676         if (hasMask)
<a name="79" id="anc79"></a><span class="line-modified">1677             maskPhases = GraphicsLayerPaintMask;</span>
1678 
1679         if (hasClipPath) {
1680             // If we have a mask, we need to paint the combined clip-path and mask into the mask layer.
1681             if (hasMask || renderer().style().clipPath()-&gt;type() == ClipPathOperation::Reference || !GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape))
<a name="80" id="anc80"></a><span class="line-modified">1682                 maskPhases |= GraphicsLayerPaintClipPath;</span>
1683         }
1684 
<a name="81" id="anc81"></a><span class="line-modified">1685         bool paintsContent = maskPhases;</span>
1686         GraphicsLayer::Type requiredLayerType = paintsContent ? GraphicsLayer::Type::Normal : GraphicsLayer::Type::Shape;
1687         if (m_maskLayer &amp;&amp; m_maskLayer-&gt;type() != requiredLayerType) {
1688             m_graphicsLayer-&gt;setMaskLayer(nullptr);
1689             willDestroyLayer(m_maskLayer.get());
1690             GraphicsLayer::clear(m_maskLayer);
1691         }
1692 
1693         if (!m_maskLayer) {
1694             m_maskLayer = createGraphicsLayer(&quot;mask&quot;, requiredLayerType);
1695             m_maskLayer-&gt;setDrawsContent(paintsContent);
1696             m_maskLayer-&gt;setPaintingPhase(maskPhases);
1697             layerChanged = true;
1698             m_graphicsLayer-&gt;setMaskLayer(m_maskLayer.copyRef());
1699             // We need a geometry update to size the new mask layer.
1700             m_owningLayer.setNeedsCompositingGeometryUpdate();
1701         }
1702     } else if (m_maskLayer) {
1703         m_graphicsLayer-&gt;setMaskLayer(nullptr);
1704         willDestroyLayer(m_maskLayer.get());
1705         GraphicsLayer::clear(m_maskLayer);
1706         layerChanged = true;
1707     }
1708 
<a name="82" id="anc82"></a><span class="line-modified">1709     if (layerChanged)</span>
<span class="line-removed">1710         m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
1711 }
1712 
1713 void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
1714 {
1715     if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
1716         if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
<a name="83" id="anc83"></a>
1717             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<a name="84" id="anc84"></a><span class="line-removed">1718             boxRect.move(contentOffsetInCompostingLayer());</span>
1719             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<a name="85" id="anc85"></a><span class="line-modified">1720             if (clippingLayer()-&gt;setMasksToBoundsRect(contentsClippingRect)) {</span>
<span class="line-modified">1721                 clippingLayer()-&gt;setMaskLayer(nullptr);</span>


1722                 GraphicsLayer::clear(m_childClippingMaskLayer);
1723                 return;
1724             }
1725 
1726             if (!m_childClippingMaskLayer) {
1727                 m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
1728                 m_childClippingMaskLayer-&gt;setDrawsContent(true);
<a name="86" id="anc86"></a><span class="line-modified">1729                 m_childClippingMaskLayer-&gt;setPaintingPhase(GraphicsLayerPaintChildClippingMask);</span>
1730                 clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
1731             }
1732         }
1733     } else {
1734         if (m_childClippingMaskLayer) {
1735             if (hasClippingLayer())
1736                 clippingLayer()-&gt;setMaskLayer(nullptr);
1737             GraphicsLayer::clear(m_childClippingMaskLayer);
1738         } else
1739             if (hasClippingLayer())
<a name="87" id="anc87"></a><span class="line-modified">1740                 clippingLayer()-&gt;setMasksToBoundsRect(FloatRoundedRect(FloatRect(FloatPoint(), clippingLayer()-&gt;size())));</span>
1741     }
1742 }
1743 
1744 bool RenderLayerBacking::updateScrollingLayers(bool needsScrollingLayers)
1745 {
1746     if (needsScrollingLayers == !!m_scrollContainerLayer)
1747         return false;
1748 
1749     if (!m_scrollContainerLayer) {
<a name="88" id="anc88"></a><span class="line-modified">1750         // Outer layer which corresponds with the scroll view.</span>
1751         m_scrollContainerLayer = createGraphicsLayer(&quot;scroll container&quot;, GraphicsLayer::Type::ScrollContainer);
<a name="89" id="anc89"></a>
1752         m_scrollContainerLayer-&gt;setDrawsContent(false);
1753         m_scrollContainerLayer-&gt;setMasksToBounds(true);
1754 
1755         // Inner layer which renders the content that scrolls.
<a name="90" id="anc90"></a><span class="line-modified">1756         m_scrolledContentsLayer = createGraphicsLayer(&quot;scrolled contents&quot;);</span>
1757         m_scrolledContentsLayer-&gt;setDrawsContent(true);
1758         m_scrolledContentsLayer-&gt;setAnchorPoint({ });
<a name="91" id="anc91"></a><span class="line-removed">1759 </span>
<span class="line-removed">1760         GraphicsLayerPaintingPhase paintPhase = GraphicsLayerPaintOverflowContents | GraphicsLayerPaintCompositedScroll;</span>
<span class="line-removed">1761         if (!m_foregroundLayer)</span>
<span class="line-removed">1762             paintPhase |= GraphicsLayerPaintForeground;</span>
<span class="line-removed">1763         m_scrolledContentsLayer-&gt;setPaintingPhase(paintPhase);</span>
1764         m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
1765     } else {
1766         compositor().willRemoveScrollingLayerWithBacking(m_owningLayer, *this);
1767 
1768         willDestroyLayer(m_scrollContainerLayer.get());
1769         willDestroyLayer(m_scrolledContentsLayer.get());
1770 
1771         GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
1772         GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
1773     }
1774 
<a name="92" id="anc92"></a><span class="line-removed">1775     m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
<span class="line-removed">1776     m_graphicsLayer-&gt;setNeedsDisplay(); // Because painting phases changed.</span>
<span class="line-removed">1777 </span>
1778     if (m_scrollContainerLayer)
1779         compositor().didAddScrollingLayer(m_owningLayer);
1780 
1781     return true;
1782 }
1783 
<a name="93" id="anc93"></a><span class="line-removed">1784 OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerBacking::coordinatedScrollingRoles() const</span>
<span class="line-removed">1785 {</span>
<span class="line-removed">1786     auto&amp; compositor = this-&gt;compositor();</span>
<span class="line-removed">1787 </span>
<span class="line-removed">1788     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;</span>
<span class="line-removed">1789     if (compositor.isViewportConstrainedFixedOrStickyLayer(m_owningLayer))</span>
<span class="line-removed">1790         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);</span>
<span class="line-removed">1791 </span>
<span class="line-removed">1792     if (compositor.useCoordinatedScrollingForLayer(m_owningLayer))</span>
<span class="line-removed">1793         coordinationRoles.add(ScrollCoordinationRole::Scrolling);</span>
<span class="line-removed">1794 </span>
<span class="line-removed">1795     if (compositor.isLayerForIFrameWithScrollCoordinatedContents(m_owningLayer))</span>
<span class="line-removed">1796         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);</span>
<span class="line-removed">1797 </span>
<span class="line-removed">1798     return coordinationRoles;</span>
<span class="line-removed">1799 }</span>
<span class="line-removed">1800 </span>
1801 void RenderLayerBacking::detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt; roles)
1802 {
<a name="94" id="anc94"></a><span class="line-modified">1803     if (!m_scrollingNodeID &amp;&amp; !m_frameHostingNodeID &amp;&amp; !m_viewportConstrainedNodeID)</span>
1804         return;
1805 
1806     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
1807     if (!scrollingCoordinator)
1808         return;
1809 
1810     if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_scrollingNodeID) {
<a name="95" id="anc95"></a><span class="line-modified">1811         LOG(Compositing, &quot;Detaching Scrolling node %&quot; PRIu64, m_scrollingNodeID);</span>
1812         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_scrollingNodeID);
1813         m_scrollingNodeID = 0;
1814     }
1815 
<a name="96" id="anc96"></a><span class="line-modified">1816     if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_frameHostingNodeID) {</span>
<span class="line-modified">1817         LOG(Compositing, &quot;Detaching FrameHosting node %&quot; PRIu64, m_frameHostingNodeID);</span>





1818         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_frameHostingNodeID);
1819         m_frameHostingNodeID = 0;
1820     }
1821 
1822     if (roles.contains(ScrollCoordinationRole::ViewportConstrained) &amp;&amp; m_viewportConstrainedNodeID) {
<a name="97" id="anc97"></a><span class="line-modified">1823         LOG(Compositing, &quot;Detaching ViewportConstrained node %&quot; PRIu64, m_viewportConstrainedNodeID);</span>
1824         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_viewportConstrainedNodeID);
1825         m_viewportConstrainedNodeID = 0;
1826     }
<a name="98" id="anc98"></a><span class="line-removed">1827 }</span>
1828 
<a name="99" id="anc99"></a><span class="line-modified">1829 void RenderLayerBacking::setIsScrollCoordinatedWithViewportConstrainedRole(bool viewportCoordinated)</span>
<span class="line-modified">1830 {</span>
<span class="line-modified">1831     m_graphicsLayer-&gt;setIsViewportConstrained(viewportCoordinated);</span>


1832 }
1833 
<a name="100" id="anc100"></a><span class="line-modified">1834 GraphicsLayerPaintingPhase RenderLayerBacking::paintingPhaseForPrimaryLayer() const</span>
1835 {
<a name="101" id="anc101"></a><span class="line-modified">1836     unsigned phase = 0;</span>
<span class="line-modified">1837     if (!m_backgroundLayer)</span>
<span class="line-removed">1838         phase |= GraphicsLayerPaintBackground;</span>
<span class="line-removed">1839     if (!m_foregroundLayer)</span>
<span class="line-removed">1840         phase |= GraphicsLayerPaintForeground;</span>
1841 
<a name="102" id="anc102"></a><span class="line-modified">1842     if (m_scrolledContentsLayer) {</span>
<span class="line-modified">1843         phase &amp;= ~GraphicsLayerPaintForeground;</span>
<span class="line-modified">1844         phase |= GraphicsLayerPaintCompositedScroll;</span>






1845     }
1846 
<a name="103" id="anc103"></a><span class="line-modified">1847     return static_cast&lt;GraphicsLayerPaintingPhase&gt;(phase);</span>
1848 }
1849 
1850 float RenderLayerBacking::compositingOpacity(float rendererOpacity) const
1851 {
1852     float finalOpacity = rendererOpacity;
1853 
1854     for (auto* curr = m_owningLayer.parent(); curr; curr = curr-&gt;parent()) {
1855         // We only care about parents that are stacking contexts.
1856         // Recall that opacity creates stacking context.
<a name="104" id="anc104"></a><span class="line-modified">1857         if (!curr-&gt;isStackingContext())</span>
1858             continue;
1859 
1860         // If we found a compositing layer, we want to compute opacity
1861         // relative to it. So we can break here.
1862         if (curr-&gt;isComposited())
1863             break;
1864 
1865         finalOpacity *= curr-&gt;renderer().opacity();
1866     }
1867 
1868     return finalOpacity;
1869 }
1870 
1871 // FIXME: Code is duplicated in RenderLayer. Also, we should probably not consider filters a box decoration here.
1872 static inline bool hasVisibleBoxDecorations(const RenderStyle&amp; style)
1873 {
1874     return style.hasVisibleBorder() || style.hasBorderRadius() || style.hasOutline() || style.hasAppearance() || style.boxShadow() || style.hasFilter();
1875 }
1876 
1877 static bool canDirectlyCompositeBackgroundBackgroundImage(const RenderStyle&amp; style)
1878 {
1879     if (!GraphicsLayer::supportsContentsTiling())
1880         return false;
1881 
1882     auto&amp; fillLayer = style.backgroundLayers();
1883     if (fillLayer.next())
1884         return false;
1885 
1886     if (!fillLayer.imagesAreLoaded())
1887         return false;
1888 
1889     if (fillLayer.attachment() != FillAttachment::ScrollBackground)
1890         return false;
1891 
1892     // FIXME: Allow color+image compositing when it makes sense.
1893     // For now bailing out.
1894     if (style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isVisible())
1895         return false;
1896 
1897     // FIXME: support gradients with isGeneratedImage.
1898     auto* styleImage = fillLayer.image();
1899     if (!styleImage-&gt;isCachedImage())
1900         return false;
1901 
1902     auto* image = styleImage-&gt;cachedImage()-&gt;image();
1903     if (!image-&gt;isBitmapImage())
1904         return false;
1905 
1906     return true;
1907 }
1908 
1909 static bool hasPaintedBoxDecorationsOrBackgroundImage(const RenderStyle&amp; style)
1910 {
1911     if (hasVisibleBoxDecorations(style))
1912         return true;
1913 
1914     if (!style.hasBackgroundImage())
1915         return false;
1916 
1917     return !canDirectlyCompositeBackgroundBackgroundImage(style);
1918 }
1919 
1920 static inline bool hasPerspectiveOrPreserves3D(const RenderStyle&amp; style)
1921 {
1922     return style.hasPerspective() || style.preserves3D();
1923 }
1924 
1925 Color RenderLayerBacking::rendererBackgroundColor() const
1926 {
1927     RenderElement* backgroundRenderer = nullptr;
1928     if (renderer().isDocumentElementRenderer())
1929         backgroundRenderer = renderer().view().rendererForRootBackground();
1930 
1931     if (!backgroundRenderer)
1932         backgroundRenderer = &amp;renderer();
1933 
1934     return backgroundRenderer-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1935 }
1936 
1937 void RenderLayerBacking::updateDirectlyCompositedBackgroundColor(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
1938 {
1939     if (m_backgroundLayer &amp;&amp; !m_backgroundLayerPaintsFixedRootBackground &amp;&amp; !contentsInfo.paintsBoxDecorations()) {
1940         m_graphicsLayer-&gt;setContentsToSolidColor(Color());
1941         m_backgroundLayer-&gt;setContentsToSolidColor(rendererBackgroundColor());
1942 
1943         FloatRect contentsRect = backgroundBoxForSimpleContainerPainting();
1944         // NOTE: This is currently only used by RenderFullScreen, which we want to be
1945         // big enough to hide overflow areas of the root.
1946         contentsRect.inflate(contentsRect.size());
1947         m_backgroundLayer-&gt;setContentsRect(contentsRect);
1948         m_backgroundLayer-&gt;setContentsClippingRect(FloatRoundedRect(contentsRect));
1949         return;
1950     }
1951 
1952     if (!contentsInfo.isSimpleContainer() || (is&lt;RenderBox&gt;(renderer()) &amp;&amp; !downcast&lt;RenderBox&gt;(renderer()).paintsOwnBackground())) {
1953         m_graphicsLayer-&gt;setContentsToSolidColor(Color());
1954         return;
1955     }
1956 
1957     Color backgroundColor = rendererBackgroundColor();
1958 
1959     // An unset (invalid) color will remove the solid color.
1960     m_graphicsLayer-&gt;setContentsToSolidColor(backgroundColor);
1961     FloatRect contentsRect = backgroundBoxForSimpleContainerPainting();
1962     m_graphicsLayer-&gt;setContentsRect(contentsRect);
1963     m_graphicsLayer-&gt;setContentsClippingRect(FloatRoundedRect(contentsRect));
1964     didUpdateContentsRect = true;
1965 }
1966 
1967 void RenderLayerBacking::updateDirectlyCompositedBackgroundImage(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
1968 {
1969     if (!GraphicsLayer::supportsContentsTiling())
1970         return;
1971 
1972     if (contentsInfo.isDirectlyCompositedImage())
1973         return;
1974 
1975     auto&amp; style = renderer().style();
1976     if (!contentsInfo.isSimpleContainer() || !style.hasBackgroundImage()) {
1977         m_graphicsLayer-&gt;setContentsToImage(0);
1978         return;
1979     }
1980 
1981     auto destRect = backgroundBoxForSimpleContainerPainting();
1982     FloatSize phase;
1983     FloatSize tileSize;
1984     // FIXME: Absolute paint location is required here.
1985     downcast&lt;RenderBox&gt;(renderer()).getGeometryForBackgroundImage(&amp;renderer(), LayoutPoint(), destRect, phase, tileSize);
1986 
1987     m_graphicsLayer-&gt;setContentsTileSize(tileSize);
1988     m_graphicsLayer-&gt;setContentsTilePhase(phase);
1989     m_graphicsLayer-&gt;setContentsRect(destRect);
1990     m_graphicsLayer-&gt;setContentsClippingRect(FloatRoundedRect(destRect));
1991     m_graphicsLayer-&gt;setContentsToImage(style.backgroundLayers().image()-&gt;cachedImage()-&gt;image());
1992 
1993     didUpdateContentsRect = true;
1994 }
1995 
1996 void RenderLayerBacking::updateRootLayerConfiguration()
1997 {
1998     if (!m_isFrameLayerWithTiledBacking)
1999         return;
2000 
2001     Color backgroundColor;
2002     bool viewIsTransparent = compositor().viewHasTransparentBackground(&amp;backgroundColor);
2003 
2004     if (m_backgroundLayerPaintsFixedRootBackground &amp;&amp; m_backgroundLayer) {
2005         if (m_isMainFrameRenderViewLayer) {
2006             m_backgroundLayer-&gt;setBackgroundColor(backgroundColor);
2007             m_backgroundLayer-&gt;setContentsOpaque(!viewIsTransparent);
2008         }
2009 
2010         m_graphicsLayer-&gt;setBackgroundColor(Color());
2011         m_graphicsLayer-&gt;setContentsOpaque(false);
2012     } else if (m_isMainFrameRenderViewLayer) {
2013         m_graphicsLayer-&gt;setBackgroundColor(backgroundColor);
2014         m_graphicsLayer-&gt;setContentsOpaque(!viewIsTransparent);
2015     }
2016 }
2017 
<a name="105" id="anc105"></a>
































2018 static bool supportsDirectlyCompositedBoxDecorations(const RenderLayerModelObject&amp; renderer)
2019 {
2020     if (!GraphicsLayer::supportsBackgroundColorContent())
2021         return false;
2022 
2023     const RenderStyle&amp; style = renderer.style();
2024     if (renderer.hasClip())
2025         return false;
2026 
2027     if (hasPaintedBoxDecorationsOrBackgroundImage(style))
2028         return false;
2029 
2030     // FIXME: We can&#39;t create a directly composited background if this
2031     // layer will have children that intersect with the background layer.
2032     // A better solution might be to introduce a flattening layer if
2033     // we do direct box decoration composition.
2034     // https://bugs.webkit.org/show_bug.cgi?id=119461
2035     if (hasPerspectiveOrPreserves3D(style))
2036         return false;
2037 
2038     // FIXME: we should be able to allow backgroundComposite; However since this is not a common use case it has been deferred for now.
2039     if (style.backgroundComposite() != CompositeSourceOver)
2040         return false;
2041 
2042     return true;
2043 }
2044 
2045 bool RenderLayerBacking::paintsBoxDecorations() const
2046 {
2047     if (!m_owningLayer.hasVisibleBoxDecorations())
2048         return false;
2049 
2050     return !supportsDirectlyCompositedBoxDecorations(renderer());
2051 }
2052 
2053 bool RenderLayerBacking::paintsContent(RenderLayer::PaintedContentRequest&amp; request) const
2054 {
2055     m_owningLayer.updateDescendantDependentFlags();
2056 
2057     bool paintsContent = false;
2058 
2059     if (m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasNonEmptyChildRenderers(request))
2060         paintsContent = true;
2061 
2062     if (request.isSatisfied())
2063         return paintsContent;
2064 
2065     if (isPaintDestinationForDescendantLayers(request))
2066         paintsContent = true;
2067 
2068     if (request.isSatisfied())
2069         return paintsContent;
2070 
2071     if (request.hasPaintedContent == RequestState::Unknown)
2072         request.hasPaintedContent = RequestState::False;
2073 
2074     if (request.hasSubpixelAntialiasedText == RequestState::Unknown)
2075         request.hasSubpixelAntialiasedText = RequestState::False;
2076 
2077     return paintsContent;
2078 }
2079 
2080 static bool isRestartedPlugin(RenderObject&amp; renderer)
2081 {
2082     if (!is&lt;RenderEmbeddedObject&gt;(renderer))
2083         return false;
2084 
2085     auto&amp; element = downcast&lt;RenderEmbeddedObject&gt;(renderer).frameOwnerElement();
2086     if (!is&lt;HTMLPlugInElement&gt;(element))
2087         return false;
2088 
2089     return downcast&lt;HTMLPlugInElement&gt;(element).isRestartedPlugin();
2090 }
2091 
2092 static bool isCompositedPlugin(RenderObject&amp; renderer)
2093 {
2094     return is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing();
2095 }
2096 
2097 // A &quot;simple container layer&quot; is a RenderLayer which has no visible content to render.
2098 // It may have no children, or all its children may be themselves composited.
2099 // This is a useful optimization, because it allows us to avoid allocating backing store.
2100 bool RenderLayerBacking::isSimpleContainerCompositingLayer(PaintedContentsInfo&amp; contentsInfo) const
2101 {
2102     if (m_owningLayer.isRenderViewLayer())
2103         return false;
2104 
<a name="106" id="anc106"></a>


2105     if (renderer().isRenderReplaced() &amp;&amp; (!isCompositedPlugin(renderer()) || isRestartedPlugin(renderer())))
2106         return false;
2107 
2108     if (renderer().isTextControl())
2109         return false;
2110 
2111     if (contentsInfo.paintsBoxDecorations() || contentsInfo.paintsContent())
2112         return false;
2113 
2114     if (renderer().style().backgroundClip() == FillBox::Text)
2115         return false;
2116 
2117     if (renderer().isDocumentElementRenderer() &amp;&amp; m_owningLayer.isolatesCompositedBlending())
2118         return false;
2119 
2120     return true;
2121 }
2122 
2123 // Returning true stops the traversal.
2124 enum class LayerTraversal { Continue, Stop };
2125 
2126 static LayerTraversal traverseVisibleNonCompositedDescendantLayers(RenderLayer&amp; parent, const WTF::Function&lt;LayerTraversal (const RenderLayer&amp;)&gt;&amp; layerFunc)
2127 {
2128     // FIXME: We shouldn&#39;t be called with a stale z-order lists. See bug 85512.
2129     parent.updateLayerListsIfNeeded();
2130 
2131 #if !ASSERT_DISABLED
2132     LayerListMutationDetector mutationChecker(parent);
2133 #endif
2134 
2135     for (auto* childLayer : parent.normalFlowLayers()) {
2136         if (compositedWithOwnBackingStore(*childLayer))
2137             continue;
2138 
2139         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2140             return LayerTraversal::Stop;
2141 
2142         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2143             return LayerTraversal::Stop;
2144     }
2145 
2146     if (parent.isStackingContext() &amp;&amp; !parent.hasVisibleDescendant())
2147         return LayerTraversal::Continue;
2148 
2149     // Use the m_hasCompositingDescendant bit to optimize?
2150     for (auto* childLayer : parent.negativeZOrderLayers()) {
2151         if (compositedWithOwnBackingStore(*childLayer))
2152             continue;
2153 
2154         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2155             return LayerTraversal::Stop;
2156 
2157         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2158             return LayerTraversal::Stop;
2159     }
2160 
2161     for (auto* childLayer : parent.positiveZOrderLayers()) {
2162         if (compositedWithOwnBackingStore(*childLayer))
2163             continue;
2164 
2165         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2166             return LayerTraversal::Stop;
2167 
2168         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2169             return LayerTraversal::Stop;
2170     }
2171 
2172     return LayerTraversal::Continue;
2173 }
2174 
2175 // Conservative test for having no rendered children.
2176 bool RenderLayerBacking::isPaintDestinationForDescendantLayers(RenderLayer::PaintedContentRequest&amp; request) const
2177 {
2178     bool hasPaintingDescendant = false;
2179     traverseVisibleNonCompositedDescendantLayers(m_owningLayer, [&amp;hasPaintingDescendant, &amp;request](const RenderLayer&amp; layer) {
2180         hasPaintingDescendant |= layer.isVisuallyNonEmpty(&amp;request);
2181         return (hasPaintingDescendant &amp;&amp; request.isSatisfied()) ? LayerTraversal::Stop : LayerTraversal::Continue;
2182     });
2183 
2184     return hasPaintingDescendant;
2185 }
2186 
2187 bool RenderLayerBacking::hasVisibleNonCompositedDescendants() const
2188 {
2189     bool hasVisibleDescendant = false;
2190     traverseVisibleNonCompositedDescendantLayers(m_owningLayer, [&amp;hasVisibleDescendant](const RenderLayer&amp; layer) {
2191         hasVisibleDescendant |= layer.hasVisibleContent();
2192         return hasVisibleDescendant ? LayerTraversal::Stop : LayerTraversal::Continue;
2193     });
2194 
2195     return hasVisibleDescendant;
2196 }
2197 
2198 bool RenderLayerBacking::containsPaintedContent(PaintedContentsInfo&amp; contentsInfo) const
2199 {
2200     if (contentsInfo.isSimpleContainer() || paintsIntoWindow() || paintsIntoCompositedAncestor() || m_artificiallyInflatedBounds || m_owningLayer.isReflection())
2201         return false;
2202 
2203     if (contentsInfo.isDirectlyCompositedImage())
2204         return false;
2205 
2206     // FIXME: we could optimize cases where the image, video or canvas is known to fill the border box entirely,
2207     // and set background color on the layer in that case, instead of allocating backing store and painting.
2208 #if ENABLE(VIDEO)
2209     if (is&lt;RenderVideo&gt;(renderer()) &amp;&amp; downcast&lt;RenderVideo&gt;(renderer()).shouldDisplayVideo())
2210         return m_owningLayer.hasVisibleBoxDecorationsOrBackground() || (!(downcast&lt;RenderVideo&gt;(renderer()).supportsAcceleratedRendering()) &amp;&amp; m_requiresOwnBackingStore);
2211 #endif
2212 
2213 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)
2214     if (is&lt;RenderHTMLCanvas&gt;(renderer()) &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents)
2215         return m_owningLayer.hasVisibleBoxDecorationsOrBackground();
2216 #endif
2217 
2218     return true;
2219 }
2220 
2221 // An image can be directly compositing if it&#39;s the sole content of the layer, and has no box decorations
2222 // that require painting. Direct compositing saves backing store.
2223 bool RenderLayerBacking::isDirectlyCompositedImage() const
2224 {
2225     if (!is&lt;RenderImage&gt;(renderer()) || m_owningLayer.hasVisibleBoxDecorationsOrBackground() || m_owningLayer.paintsWithFilters() || renderer().hasClip())
2226         return false;
2227 
2228 #if ENABLE(VIDEO)
2229     if (is&lt;RenderMedia&gt;(renderer()))
2230         return false;
2231 #endif
2232 
2233     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2234     if (auto* cachedImage = imageRenderer.cachedImage()) {
2235         if (!cachedImage-&gt;hasImage())
2236             return false;
2237 
2238         auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2239         if (!is&lt;BitmapImage&gt;(image))
2240             return false;
2241 
<a name="107" id="anc107"></a><span class="line-modified">2242         if (downcast&lt;BitmapImage&gt;(*image).orientationForCurrentFrame() != DefaultImageOrientation)</span>
2243             return false;
2244 
2245 #if (PLATFORM(GTK) || PLATFORM(WPE))
2246         // GTK and WPE ports don&#39;t support rounded rect clipping at TextureMapper level, so they cannot
2247         // directly composite images that have border-radius propery. Draw them as non directly composited
2248         // content instead. See https://bugs.webkit.org/show_bug.cgi?id=174157.
2249         if (imageRenderer.style().hasBorderRadius())
2250             return false;
2251 #endif
2252 
2253         return m_graphicsLayer-&gt;shouldDirectlyCompositeImage(image);
2254     }
2255 
2256     return false;
2257 }
2258 
2259 void RenderLayerBacking::contentChanged(ContentChangeType changeType)
2260 {
2261     PaintedContentsInfo contentsInfo(*this);
2262     if ((changeType == ImageChanged) &amp;&amp; contentsInfo.isDirectlyCompositedImage()) {
2263         updateImageContents(contentsInfo);
2264         return;
2265     }
2266 
<a name="108" id="anc108"></a>




2267     if ((changeType == BackgroundImageChanged) &amp;&amp; canDirectlyCompositeBackgroundBackgroundImage(renderer().style()))
2268         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2269 
2270     if ((changeType == MaskImageChanged) &amp;&amp; m_maskLayer)
2271         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2272 
<a name="109" id="anc109"></a><span class="line-modified">2273 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)</span>
2274     if ((changeType == CanvasChanged || changeType == CanvasPixelsChanged) &amp;&amp; renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
<a name="110" id="anc110"></a>


2275         m_graphicsLayer-&gt;setContentsNeedsDisplay();
2276         return;
2277     }
2278 #endif
2279 }
2280 
2281 void RenderLayerBacking::updateImageContents(PaintedContentsInfo&amp; contentsInfo)
2282 {
2283     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2284 
2285     auto* cachedImage = imageRenderer.cachedImage();
2286     if (!cachedImage)
2287         return;
2288 
2289     auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2290     if (!image)
2291         return;
2292 
2293     // We have to wait until the image is fully loaded before setting it on the layer.
2294     if (!cachedImage-&gt;isLoaded())
2295         return;
2296 
2297     // This is a no-op if the layer doesn&#39;t have an inner layer for the image.
2298     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
2299 
2300     LayoutRect boxRect(LayoutPoint(), imageRenderer.size());
<a name="111" id="anc111"></a><span class="line-modified">2301     boxRect.move(contentOffsetInCompostingLayer());</span>
2302     FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
2303     m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
2304 
2305     m_graphicsLayer-&gt;setContentsToImage(image);
2306 
2307     updateDrawsContent(contentsInfo);
2308 
2309     // Image animation is &quot;lazy&quot;, in that it automatically stops unless someone is drawing
2310     // the image. So we have to kick the animation each time; this has the downside that the
2311     // image will keep animating, even if its layer is not visible.
2312     image-&gt;startAnimation();
2313 }
2314 
2315 FloatPoint3D RenderLayerBacking::computeTransformOriginForPainting(const LayoutRect&amp; borderBox) const
2316 {
2317     const RenderStyle&amp; style = renderer().style();
2318     float deviceScaleFactor = this-&gt;deviceScaleFactor();
2319 
2320     FloatPoint3D origin;
2321     origin.setX(roundToDevicePixel(floatValueForLength(style.transformOriginX(), borderBox.width()), deviceScaleFactor));
2322     origin.setY(roundToDevicePixel(floatValueForLength(style.transformOriginY(), borderBox.height()), deviceScaleFactor));
2323     origin.setZ(style.transformOriginZ());
2324 
2325     return origin;
2326 }
2327 
2328 // Return the offset from the top-left of this compositing layer at which the renderer&#39;s contents are painted.
<a name="112" id="anc112"></a><span class="line-modified">2329 LayoutSize RenderLayerBacking::contentOffsetInCompostingLayer() const</span>
2330 {
2331     return LayoutSize(-m_compositedBounds.x() + m_compositedBoundsOffsetFromGraphicsLayer.width(), -m_compositedBounds.y() + m_compositedBoundsOffsetFromGraphicsLayer.height());
2332 }
2333 
2334 LayoutRect RenderLayerBacking::contentsBox() const
2335 {
2336     if (!is&lt;RenderBox&gt;(renderer()))
2337         return LayoutRect();
2338 
2339     auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
2340     LayoutRect contentsRect;
2341 #if ENABLE(VIDEO)
2342     if (is&lt;RenderVideo&gt;(renderBox))
2343         contentsRect = downcast&lt;RenderVideo&gt;(renderBox).videoBox();
2344     else
2345 #endif
2346     if (is&lt;RenderReplaced&gt;(renderBox)) {
2347         RenderReplaced&amp; renderReplaced = downcast&lt;RenderReplaced&gt;(renderBox);
2348         contentsRect = renderReplaced.replacedContentRect();
2349     } else
2350         contentsRect = renderBox.contentBoxRect();
2351 
<a name="113" id="anc113"></a><span class="line-modified">2352     contentsRect.move(contentOffsetInCompostingLayer());</span>
2353     return contentsRect;
2354 }
2355 
2356 static LayoutRect backgroundRectForBox(const RenderBox&amp; box)
2357 {
2358     switch (box.style().backgroundClip()) {
2359     case FillBox::Border:
2360         return box.borderBoxRect();
2361     case FillBox::Padding:
2362         return box.paddingBoxRect();
2363     case FillBox::Content:
2364         return box.contentBoxRect();
2365     default:
2366         break;
2367     }
2368 
2369     ASSERT_NOT_REACHED();
2370     return LayoutRect();
2371 }
2372 
2373 FloatRect RenderLayerBacking::backgroundBoxForSimpleContainerPainting() const
2374 {
2375     if (!is&lt;RenderBox&gt;(renderer()))
2376         return FloatRect();
2377 
2378     LayoutRect backgroundBox = backgroundRectForBox(downcast&lt;RenderBox&gt;(renderer()));
<a name="114" id="anc114"></a><span class="line-modified">2379     backgroundBox.move(contentOffsetInCompostingLayer());</span>
2380     return snapRectToDevicePixels(backgroundBox, deviceScaleFactor());
2381 }
2382 
2383 GraphicsLayer* RenderLayerBacking::parentForSublayers() const
2384 {
2385     if (m_scrolledContentsLayer)
2386         return m_scrolledContentsLayer.get();
2387 
2388     return m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
2389 }
2390 
2391 GraphicsLayer* RenderLayerBacking::childForSuperlayers() const
2392 {
<a name="115" id="anc115"></a><span class="line-modified">2393     if (m_ancestorClippingLayer)</span>
<span class="line-modified">2394         return m_ancestorClippingLayer.get();</span>
2395 
2396     if (m_contentsContainmentLayer)
2397         return m_contentsContainmentLayer.get();
2398 
2399     return m_graphicsLayer.get();
2400 }
2401 
2402 bool RenderLayerBacking::paintsIntoWindow() const
2403 {
2404 #if USE(COORDINATED_GRAPHICS)
2405         return false;
2406 #endif
2407 
2408     if (m_isFrameLayerWithTiledBacking)
2409         return false;
2410 
2411     if (m_owningLayer.isRenderViewLayer()) {
2412 #if PLATFORM(IOS_FAMILY) || USE(COORDINATED_GRAPHICS)
2413         if (compositor().inForcedCompositingMode())
2414             return false;
2415 #endif
2416 
2417         return compositor().rootLayerAttachment() != RenderLayerCompositor::RootLayerAttachedViaEnclosingFrame;
2418     }
2419 
2420     return false;
2421 }
2422 
2423 void RenderLayerBacking::setRequiresOwnBackingStore(bool requiresOwnBacking)
2424 {
2425     if (requiresOwnBacking == m_requiresOwnBackingStore)
2426         return;
2427 
2428     m_requiresOwnBackingStore = requiresOwnBacking;
2429 
2430     // This affects the answer to paintsIntoCompositedAncestor(), which in turn affects
2431     // cached clip rects, so when it changes we have to clear clip rects on descendants.
2432     m_owningLayer.clearClipRectsIncludingDescendants(PaintingClipRects);
2433     m_owningLayer.computeRepaintRectsIncludingDescendants();
2434 
2435     compositor().repaintInCompositedAncestor(m_owningLayer, compositedBounds());
2436 }
2437 
2438 void RenderLayerBacking::setContentsNeedDisplay(GraphicsLayer::ShouldClipToLayer shouldClip)
2439 {
2440     ASSERT(!paintsIntoCompositedAncestor());
2441 
2442     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2443     if (!m_owningLayer.isRenderViewLayer())
2444         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2445 
<a name="116" id="anc116"></a>

2446     auto&amp; frameView = renderer().view().frameView();
2447     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2448         frameView.addTrackedRepaintRect(owningLayer().absoluteBoundingBoxForPainting());
2449 
2450     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2451         // By default, setNeedsDisplay will clip to the size of the GraphicsLayer, which does not include margin tiles.
2452         // So if the TiledBacking has a margin that needs to be invalidated, we need to send in a rect to setNeedsDisplayInRect
2453         // that is large enough to include the margin. TiledBacking::bounds() includes the margin.
2454         auto* tiledBacking = this-&gt;tiledBacking();
2455         FloatRect rectToRepaint = tiledBacking ? tiledBacking-&gt;bounds() : FloatRect(FloatPoint(0, 0), m_graphicsLayer-&gt;size());
2456         m_graphicsLayer-&gt;setNeedsDisplayInRect(rectToRepaint, shouldClip);
2457     }
2458 
2459     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent())
2460         m_foregroundLayer-&gt;setNeedsDisplay();
2461 
2462     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent())
2463         m_backgroundLayer-&gt;setNeedsDisplay();
2464 
2465     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent())
2466         m_maskLayer-&gt;setNeedsDisplay();
2467 
2468     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent())
2469         m_childClippingMaskLayer-&gt;setNeedsDisplay();
2470 
2471     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent())
2472         m_scrolledContentsLayer-&gt;setNeedsDisplay();
2473 }
2474 
2475 // r is in the coordinate space of the layer&#39;s render object
2476 void RenderLayerBacking::setContentsNeedDisplayInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
2477 {
2478     ASSERT(!paintsIntoCompositedAncestor());
2479 
2480     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2481     if (!m_owningLayer.isRenderViewLayer())
2482         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2483 
<a name="117" id="anc117"></a>

2484     FloatRect pixelSnappedRectForPainting = snapRectToDevicePixels(r, deviceScaleFactor());
2485     auto&amp; frameView = renderer().view().frameView();
2486     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2487         frameView.addTrackedRepaintRect(pixelSnappedRectForPainting);
2488 
2489     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2490         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2491         layerDirtyRect.move(-m_graphicsLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2492         m_graphicsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2493     }
2494 
2495     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent()) {
2496         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2497         layerDirtyRect.move(-m_foregroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2498         m_foregroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2499     }
2500 
2501     // FIXME: need to split out repaints for the background.
2502     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent()) {
2503         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2504         layerDirtyRect.move(-m_backgroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2505         m_backgroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2506     }
2507 
2508     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent()) {
2509         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2510         layerDirtyRect.move(-m_maskLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2511         m_maskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2512     }
2513 
2514     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent()) {
2515         FloatRect layerDirtyRect = r;
2516         layerDirtyRect.move(-m_childClippingMaskLayer-&gt;offsetFromRenderer());
2517         m_childClippingMaskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect);
2518     }
2519 
2520     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
2521         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2522         layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);
<a name="118" id="anc118"></a><span class="line-removed">2523 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">2524         // Account for the fact that RenderLayerBacking::updateGeometry() bakes scrollOffset into offsetFromRenderer on iOS,</span>
<span class="line-removed">2525         // but the repaint rect is computed without taking the scroll position into account (see shouldApplyClipAndScrollPositionForRepaint()).</span>
<span class="line-removed">2526         layerDirtyRect.moveBy(-m_owningLayer.scrollPosition());</span>
<span class="line-removed">2527 #endif</span>
2528         m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2529     }
2530 }
2531 
2532 void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
2533     const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<a name="119" id="anc119"></a><span class="line-modified">2534     OptionSet&lt;PaintBehavior&gt; paintBehavior, GraphicsLayerPaintingPhase paintingPhase)</span>
2535 {
<a name="120" id="anc120"></a><span class="line-modified">2536     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; paintingPhase != GraphicsLayerPaintChildClippingMask) {</span>
2537 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
2538         // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
2539         // when pages are restored from the PageCache.
2540         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in PageCache
2541         ASSERT_NOT_REACHED();
2542 #endif
2543         return;
2544     }
2545 
2546     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;
<a name="121" id="anc121"></a><span class="line-modified">2547     if (paintingPhase &amp; GraphicsLayerPaintBackground)</span>
2548         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
<a name="122" id="anc122"></a><span class="line-modified">2549     if (paintingPhase &amp; GraphicsLayerPaintForeground)</span>
2550         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
<a name="123" id="anc123"></a><span class="line-modified">2551     if (paintingPhase &amp; GraphicsLayerPaintMask)</span>
2552         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
<a name="124" id="anc124"></a><span class="line-modified">2553     if (paintingPhase &amp; GraphicsLayerPaintClipPath)</span>
2554         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
<a name="125" id="anc125"></a><span class="line-modified">2555     if (paintingPhase &amp; GraphicsLayerPaintChildClippingMask)</span>
2556         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
<a name="126" id="anc126"></a><span class="line-modified">2557     if (paintingPhase &amp; GraphicsLayerPaintOverflowContents)</span>
2558         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
<a name="127" id="anc127"></a><span class="line-modified">2559     if (paintingPhase &amp; GraphicsLayerPaintCompositedScroll)</span>
2560         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
2561 
2562     if (graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)
2563         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
2564     else if (compositor().fixedRootBackgroundLayer())
2565         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);
2566 
2567 #ifndef NDEBUG
2568     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
2569 #endif
2570 
<a name="128" id="anc128"></a><span class="line-modified">2571     FrameView::PaintingState paintingState;</span>
<span class="line-modified">2572     if (m_owningLayer.isRenderViewLayer())</span>
<span class="line-removed">2573         renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
2574 
<a name="129" id="anc129"></a><span class="line-modified">2575     // FIXME: GraphicsLayers need a way to split for RenderFragmentContainers.</span>
<span class="line-modified">2576     RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);</span>
<span class="line-modified">2577     m_owningLayer.paintLayerContents(context, paintingInfo, paintFlags);</span>
2578 
<a name="130" id="anc130"></a><span class="line-modified">2579     if (m_owningLayer.containsDirtyOverlayScrollbars())</span>
<span class="line-removed">2580         m_owningLayer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);</span>
2581 
<a name="131" id="anc131"></a><span class="line-modified">2582     if (m_owningLayer.isRenderViewLayer())</span>
<span class="line-modified">2583         renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>






























2584 
2585     compositor().didPaintBacking(this);
<a name="132" id="anc132"></a>

















































2586 
<a name="133" id="anc133"></a><span class="line-modified">2587     ASSERT(!m_owningLayer.m_usedTransparency);</span>



































































2588 }
2589 
2590 // Up-call from compositing layer drawing callback.
<a name="134" id="anc134"></a><span class="line-modified">2591 void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, GraphicsLayerPaintingPhase paintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
2592 {
2593 #ifndef NDEBUG
2594     renderer().page().setIsPainting(true);
2595 #endif
2596 
2597 #if PLATFORM(MAC)
2598     LocalDefaultSystemAppearance localAppearance(renderer().useDarkAppearance());
2599 #endif
2600 
2601     // The dirtyRect is in the coords of the painting root.
2602     FloatRect adjustedClipRect = clip;
2603     adjustedClipRect.move(m_subpixelOffsetFromRenderer);
2604     IntRect dirtyRect = enclosingIntRect(adjustedClipRect);
2605 
2606     if (!graphicsLayer-&gt;repaintCount())
2607         layerPaintBehavior |= GraphicsLayerPaintFirstTilePaint;
2608 
2609     if (graphicsLayer == m_graphicsLayer.get()
2610         || graphicsLayer == m_foregroundLayer.get()
2611         || graphicsLayer == m_backgroundLayer.get()
2612         || graphicsLayer == m_maskLayer.get()
2613         || graphicsLayer == m_childClippingMaskLayer.get()
2614         || graphicsLayer == m_scrolledContentsLayer.get()) {
<a name="135" id="anc135"></a><span class="line-removed">2615         InspectorInstrumentation::willPaint(renderer());</span>
2616 
<a name="136" id="anc136"></a><span class="line-modified">2617         if (!(paintingPhase &amp; GraphicsLayerPaintOverflowContents))</span>
2618             dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
2619 
2620         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
2621         OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
2622         if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
2623             behavior.add(PaintBehavior::Snapshotting);
2624 
2625         if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
2626             behavior.add(PaintBehavior::TileFirstPaint);
2627 
2628         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);
2629 
<a name="137" id="anc137"></a><span class="line-modified">2630         InspectorInstrumentation::didPaint(renderer(), dirtyRect);</span>


2631     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
2632         paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
2633     } else if (graphicsLayer == layerForVerticalScrollbar()) {
2634         paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
2635     } else if (graphicsLayer == layerForScrollCorner()) {
2636         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
<a name="138" id="anc138"></a><span class="line-modified">2637         context.save();</span>
2638         context.translate(-scrollCornerAndResizer.location());
2639         LayoutRect transformedClip = LayoutRect(clip);
2640         transformedClip.moveBy(scrollCornerAndResizer.location());
2641         m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
2642         m_owningLayer.paintResizer(context, IntPoint(), transformedClip);
<a name="139" id="anc139"></a><span class="line-removed">2643         context.restore();</span>
2644     }
2645 #ifndef NDEBUG
2646     renderer().page().setIsPainting(false);
2647 #endif
2648 }
2649 
2650 float RenderLayerBacking::pageScaleFactor() const
2651 {
2652     return compositor().pageScaleFactor();
2653 }
2654 
2655 float RenderLayerBacking::zoomedOutPageScaleFactor() const
2656 {
2657     return compositor().zoomedOutPageScaleFactor();
2658 }
2659 
2660 float RenderLayerBacking::deviceScaleFactor() const
2661 {
2662     return compositor().deviceScaleFactor();
2663 }
2664 
2665 float RenderLayerBacking::contentsScaleMultiplierForNewTiles(const GraphicsLayer* layer) const
2666 {
2667     return compositor().contentsScaleMultiplierForNewTiles(layer);
2668 }
2669 
2670 bool RenderLayerBacking::paintsOpaquelyAtNonIntegralScales(const GraphicsLayer*) const
2671 {
2672     return m_isMainFrameRenderViewLayer;
2673 }
2674 
2675 void RenderLayerBacking::didChangePlatformLayerForLayer(const GraphicsLayer* layer)
2676 {
2677     compositor().didChangePlatformLayerForLayer(m_owningLayer, layer);
2678 }
2679 
2680 bool RenderLayerBacking::getCurrentTransform(const GraphicsLayer* graphicsLayer, TransformationMatrix&amp; transform) const
2681 {
2682     auto* transformedLayer = m_contentsContainmentLayer.get() ? m_contentsContainmentLayer.get() : m_graphicsLayer.get();
2683     if (graphicsLayer != transformedLayer)
2684         return false;
2685 
2686     if (m_owningLayer.hasTransform()) {
2687         transform = m_owningLayer.currentTransform(RenderStyle::ExcludeTransformOrigin);
2688         return true;
2689     }
2690     return false;
2691 }
2692 
2693 bool RenderLayerBacking::isTrackingRepaints() const
2694 {
2695     return static_cast&lt;GraphicsLayerClient&amp;&gt;(compositor()).isTrackingRepaints();
2696 }
2697 
2698 bool RenderLayerBacking::shouldSkipLayerInDump(const GraphicsLayer* layer, LayerTreeAsTextBehavior behavior) const
2699 {
2700     if (behavior &amp; LayerTreeAsTextDebug)
2701         return false;
2702 
2703     // Skip the root tile cache&#39;s flattening layer.
2704     return m_isMainFrameRenderViewLayer &amp;&amp; layer &amp;&amp; layer == m_childContainmentLayer.get();
2705 }
2706 
2707 bool RenderLayerBacking::shouldDumpPropertyForLayer(const GraphicsLayer* layer, const char* propertyName, LayerTreeAsTextBehavior flags) const
2708 {
2709     // For backwards compatibility with WebKit1 and other platforms,
2710     // skip some properties on the root tile cache.
2711     if (m_isMainFrameRenderViewLayer &amp;&amp; layer == m_graphicsLayer.get() &amp;&amp; !(flags &amp; LayerTreeAsTextIncludeRootLayerProperties)) {
2712         if (!strcmp(propertyName, &quot;drawsContent&quot;))
2713             return false;
2714 
2715         // Background color could be of interest to tests or other dumpers if it&#39;s non-white.
2716         if (!strcmp(propertyName, &quot;backgroundColor&quot;) &amp;&amp; Color::isWhiteColor(layer-&gt;backgroundColor()))
2717             return false;
2718 
2719         // The root tile cache&#39;s repaints will show up at the top with FrameView&#39;s,
2720         // so don&#39;t dump them twice.
2721         if (!strcmp(propertyName, &quot;repaintRects&quot;))
2722             return false;
2723     }
2724 
2725     return true;
2726 }
2727 
2728 bool RenderLayerBacking::shouldAggressivelyRetainTiles(const GraphicsLayer*) const
2729 {
2730     // Only the main frame TileController has enough information about in-window state to
2731     // correctly implement aggressive tile retention.
2732     if (!m_isMainFrameRenderViewLayer)
2733         return false;
2734 
2735     return renderer().settings().aggressiveTileRetentionEnabled();
2736 }
2737 
2738 bool RenderLayerBacking::shouldTemporarilyRetainTileCohorts(const GraphicsLayer*) const
2739 {
2740     return renderer().settings().temporaryTileCohortRetentionEnabled();
2741 }
2742 
2743 bool RenderLayerBacking::useGiantTiles() const
2744 {
2745     return renderer().settings().useGiantTiles();
2746 }
2747 
2748 void RenderLayerBacking::logFilledVisibleFreshTile(unsigned blankPixelCount)
2749 {
2750     if (auto* loggingClient = renderer().page().performanceLoggingClient())
2751         loggingClient-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::FilledTile, MonotonicTime::now(), blankPixelCount);
2752 }
2753 
2754 #ifndef NDEBUG
2755 void RenderLayerBacking::verifyNotPainting()
2756 {
2757     ASSERT(!renderer().page().isPainting());
2758 }
2759 #endif
2760 
<a name="140" id="anc140"></a><span class="line-modified">2761 bool RenderLayerBacking::startAnimation(double timeOffset, const Animation* anim, const KeyframeList&amp; keyframes)</span>
2762 {
2763     bool hasOpacity = keyframes.containsProperty(CSSPropertyOpacity);
2764     bool hasTransform = renderer().isBox() &amp;&amp; keyframes.containsProperty(CSSPropertyTransform);
2765     bool hasFilter = keyframes.containsProperty(CSSPropertyFilter);
2766 
2767     bool hasBackdropFilter = false;
2768 #if ENABLE(FILTERS_LEVEL_2)
2769     hasBackdropFilter = keyframes.containsProperty(CSSPropertyWebkitBackdropFilter);
2770 #endif
2771 
2772     if (!hasOpacity &amp;&amp; !hasTransform &amp;&amp; !hasFilter &amp;&amp; !hasBackdropFilter)
2773         return false;
2774 
2775     KeyframeValueList transformVector(AnimatedPropertyTransform);
2776     KeyframeValueList opacityVector(AnimatedPropertyOpacity);
2777     KeyframeValueList filterVector(AnimatedPropertyFilter);
2778 #if ENABLE(FILTERS_LEVEL_2)
2779     KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
2780 #endif
2781 
2782     size_t numKeyframes = keyframes.size();
2783     for (size_t i = 0; i &lt; numKeyframes; ++i) {
2784         const KeyframeValue&amp; currentKeyframe = keyframes[i];
2785         const RenderStyle* keyframeStyle = currentKeyframe.style();
2786         double key = currentKeyframe.key();
2787 
2788         if (!keyframeStyle)
2789             continue;
2790 
2791         auto* tf = currentKeyframe.timingFunction();
2792 
2793         bool isFirstOrLastKeyframe = key == 0 || key == 1;
2794         if ((hasTransform &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyTransform))
<a name="141" id="anc141"></a><span class="line-modified">2795             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(key, keyframeStyle-&gt;transform(), tf));</span>
2796 
2797         if ((hasOpacity &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyOpacity))
<a name="142" id="anc142"></a><span class="line-modified">2798             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(key, keyframeStyle-&gt;opacity(), tf));</span>
2799 
2800         if ((hasFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyFilter))
<a name="143" id="anc143"></a><span class="line-modified">2801             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;filter(), tf));</span>
2802 
2803 #if ENABLE(FILTERS_LEVEL_2)
2804         if ((hasBackdropFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyWebkitBackdropFilter))
<a name="144" id="anc144"></a><span class="line-modified">2805             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;backdropFilter(), tf));</span>
2806 #endif
2807     }
2808 
2809     if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
2810         return false;
2811 
2812     bool didAnimate = false;
2813 
<a name="145" id="anc145"></a><span class="line-modified">2814     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), anim, keyframes.animationName(), timeOffset))</span>
2815         didAnimate = true;
2816 
<a name="146" id="anc146"></a><span class="line-modified">2817     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
2818         didAnimate = true;
2819 
<a name="147" id="anc147"></a><span class="line-modified">2820     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
2821         didAnimate = true;
2822 
2823 #if ENABLE(FILTERS_LEVEL_2)
<a name="148" id="anc148"></a><span class="line-modified">2824     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
2825         didAnimate = true;
2826 #endif
2827 
2828     if (didAnimate)
2829         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
2830 
2831     return didAnimate;
2832 }
2833 
2834 void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
2835 {
2836     m_graphicsLayer-&gt;pauseAnimation(animationName, timeOffset);
2837 }
2838 
2839 void RenderLayerBacking::animationSeeked(double timeOffset, const String&amp; animationName)
2840 {
2841     m_graphicsLayer-&gt;seekAnimation(animationName, timeOffset);
2842 }
2843 
2844 void RenderLayerBacking::animationFinished(const String&amp; animationName)
2845 {
2846     m_graphicsLayer-&gt;removeAnimation(animationName);
2847     m_owningLayer.setNeedsPostLayoutCompositingUpdate();
2848 }
2849 
2850 bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
2851 {
2852     bool didAnimate = false;
2853 
2854     ASSERT(property != CSSPropertyInvalid);
2855 
2856     if (property == CSSPropertyOpacity) {
2857         const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
2858         if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
2859             KeyframeValueList opacityVector(AnimatedPropertyOpacity);
<a name="149" id="anc149"></a><span class="line-modified">2860             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));</span>
<span class="line-modified">2861             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));</span>
2862             // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
2863             if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
2864                 // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
2865                 updateOpacity(*toStyle);
2866                 didAnimate = true;
2867             }
2868         }
2869     }
2870 
2871     if (property == CSSPropertyTransform &amp;&amp; m_owningLayer.hasTransform()) {
2872         const Animation* transformAnim = toStyle-&gt;transitionForProperty(CSSPropertyTransform);
2873         if (transformAnim &amp;&amp; !transformAnim-&gt;isEmptyOrZeroDuration()) {
2874             KeyframeValueList transformVector(AnimatedPropertyTransform);
<a name="150" id="anc150"></a><span class="line-modified">2875             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(0, fromStyle-&gt;transform()));</span>
<span class="line-modified">2876             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(1, toStyle-&gt;transform()));</span>
2877             if (m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), transformAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyTransform), timeOffset)) {
2878                 // To ensure that the correct transform is visible when the animation ends, also set the final transform.
2879                 updateTransform(*toStyle);
2880                 didAnimate = true;
2881             }
2882         }
2883     }
2884 
2885     if (property == CSSPropertyFilter &amp;&amp; m_owningLayer.hasFilter()) {
2886         const Animation* filterAnim = toStyle-&gt;transitionForProperty(CSSPropertyFilter);
2887         if (filterAnim &amp;&amp; !filterAnim-&gt;isEmptyOrZeroDuration()) {
2888             KeyframeValueList filterVector(AnimatedPropertyFilter);
<a name="151" id="anc151"></a><span class="line-modified">2889             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;filter()));</span>
<span class="line-modified">2890             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;filter()));</span>
2891             if (m_graphicsLayer-&gt;addAnimation(filterVector, FloatSize(), filterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyFilter), timeOffset)) {
2892                 // To ensure that the correct filter is visible when the animation ends, also set the final filter.
2893                 updateFilters(*toStyle);
2894                 didAnimate = true;
2895             }
2896         }
2897     }
2898 
2899 #if ENABLE(FILTERS_LEVEL_2)
2900     if (property == CSSPropertyWebkitBackdropFilter &amp;&amp; m_owningLayer.hasBackdropFilter()) {
2901         const Animation* backdropFilterAnim = toStyle-&gt;transitionForProperty(CSSPropertyWebkitBackdropFilter);
2902         if (backdropFilterAnim &amp;&amp; !backdropFilterAnim-&gt;isEmptyOrZeroDuration()) {
2903             KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
<a name="152" id="anc152"></a><span class="line-modified">2904             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;backdropFilter()));</span>
<span class="line-modified">2905             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;backdropFilter()));</span>
2906             if (m_graphicsLayer-&gt;addAnimation(backdropFilterVector, FloatSize(), backdropFilterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyWebkitBackdropFilter), timeOffset)) {
2907                 // To ensure that the correct backdrop filter is visible when the animation ends, also set the final backdrop filter.
2908                 updateBackdropFilters(*toStyle);
2909                 didAnimate = true;
2910             }
2911         }
2912     }
2913 #endif
2914 
2915     if (didAnimate)
2916         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
2917 
2918     return didAnimate;
2919 }
2920 
2921 void RenderLayerBacking::transitionPaused(double timeOffset, CSSPropertyID property)
2922 {
2923     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
2924     if (animatedProperty != AnimatedPropertyInvalid)
2925         m_graphicsLayer-&gt;pauseAnimation(GraphicsLayer::animationNameForTransition(animatedProperty), timeOffset);
2926 }
2927 
2928 void RenderLayerBacking::transitionFinished(CSSPropertyID property)
2929 {
2930     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
2931     if (animatedProperty != AnimatedPropertyInvalid) {
2932         m_graphicsLayer-&gt;removeAnimation(GraphicsLayer::animationNameForTransition(animatedProperty));
2933         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
2934     }
2935 }
2936 
2937 void RenderLayerBacking::notifyAnimationStarted(const GraphicsLayer*, const String&amp;, MonotonicTime time)
2938 {
2939     renderer().animation().notifyAnimationStarted(renderer(), time);
2940 }
2941 
2942 void RenderLayerBacking::notifyFlushRequired(const GraphicsLayer* layer)
2943 {
2944     if (renderer().renderTreeBeingDestroyed())
2945         return;
2946     compositor().scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
2947 }
2948 
2949 void RenderLayerBacking::notifyFlushBeforeDisplayRefresh(const GraphicsLayer* layer)
2950 {
2951     compositor().notifyFlushBeforeDisplayRefresh(layer);
2952 }
2953 
2954 // This is used for the &#39;freeze&#39; API, for testing only.
2955 void RenderLayerBacking::suspendAnimations(MonotonicTime time)
2956 {
2957     m_graphicsLayer-&gt;suspendAnimations(time);
2958 }
2959 
2960 void RenderLayerBacking::resumeAnimations()
2961 {
2962     m_graphicsLayer-&gt;resumeAnimations();
2963 }
2964 
2965 LayoutRect RenderLayerBacking::compositedBounds() const
2966 {
2967     return m_compositedBounds;
2968 }
2969 
2970 bool RenderLayerBacking::setCompositedBounds(const LayoutRect&amp; bounds)
2971 {
2972     if (bounds == m_compositedBounds)
2973         return false;
2974 
2975     m_compositedBounds = bounds;
2976     return true;
2977 }
2978 
2979 LayoutRect RenderLayerBacking::compositedBoundsIncludingMargin() const
2980 {
2981     auto* tiledBacking = this-&gt;tiledBacking();
2982     if (!tiledBacking || !tiledBacking-&gt;hasMargins())
2983         return compositedBounds();
2984 
2985     LayoutRect boundsIncludingMargin = compositedBounds();
2986     LayoutUnit leftMarginWidth = tiledBacking-&gt;leftMarginWidth();
2987     LayoutUnit topMarginHeight = tiledBacking-&gt;topMarginHeight();
2988 
2989     boundsIncludingMargin.moveBy(LayoutPoint(-leftMarginWidth, -topMarginHeight));
2990     boundsIncludingMargin.expand(leftMarginWidth + tiledBacking-&gt;rightMarginWidth(), topMarginHeight + tiledBacking-&gt;bottomMarginHeight());
2991 
2992     return boundsIncludingMargin;
2993 }
2994 
2995 CSSPropertyID RenderLayerBacking::graphicsLayerToCSSProperty(AnimatedPropertyID property)
2996 {
2997     CSSPropertyID cssProperty = CSSPropertyInvalid;
2998     switch (property) {
2999     case AnimatedPropertyTransform:
3000         cssProperty = CSSPropertyTransform;
3001         break;
3002     case AnimatedPropertyOpacity:
3003         cssProperty = CSSPropertyOpacity;
3004         break;
3005     case AnimatedPropertyBackgroundColor:
3006         cssProperty = CSSPropertyBackgroundColor;
3007         break;
3008     case AnimatedPropertyFilter:
3009         cssProperty = CSSPropertyFilter;
3010         break;
3011 #if ENABLE(FILTERS_LEVEL_2)
3012     case AnimatedPropertyWebkitBackdropFilter:
3013         cssProperty = CSSPropertyWebkitBackdropFilter;
3014         break;
3015 #endif
3016     case AnimatedPropertyInvalid:
3017         ASSERT_NOT_REACHED();
3018     }
3019     return cssProperty;
3020 }
3021 
3022 AnimatedPropertyID RenderLayerBacking::cssToGraphicsLayerProperty(CSSPropertyID cssProperty)
3023 {
3024     switch (cssProperty) {
3025     case CSSPropertyTransform:
3026         return AnimatedPropertyTransform;
3027     case CSSPropertyOpacity:
3028         return AnimatedPropertyOpacity;
3029     case CSSPropertyBackgroundColor:
3030         return AnimatedPropertyBackgroundColor;
3031     case CSSPropertyFilter:
3032         return AnimatedPropertyFilter;
3033 #if ENABLE(FILTERS_LEVEL_2)
3034     case CSSPropertyWebkitBackdropFilter:
3035         return AnimatedPropertyWebkitBackdropFilter;
3036 #endif
3037     default:
3038         // It&#39;s fine if we see other css properties here; they are just not accelerated.
3039         break;
3040     }
3041     return AnimatedPropertyInvalid;
3042 }
3043 
3044 CompositingLayerType RenderLayerBacking::compositingLayerType() const
3045 {
3046     if (m_graphicsLayer-&gt;usesContentsLayer())
3047         return MediaCompositingLayer;
3048 
3049     if (m_graphicsLayer-&gt;drawsContent())
3050         return m_graphicsLayer-&gt;tiledBacking() ? TiledCompositingLayer : NormalCompositingLayer;
3051 
3052     return ContainerCompositingLayer;
3053 }
3054 
3055 double RenderLayerBacking::backingStoreMemoryEstimate() const
3056 {
3057     double backingMemory;
3058 
<a name="153" id="anc153"></a><span class="line-modified">3059     // m_ancestorClippingLayer, m_contentsContainmentLayer and m_childContainmentLayer are just used for masking or containment, so have no backing.</span>
3060     backingMemory = m_graphicsLayer-&gt;backingStoreMemoryEstimate();
3061     if (m_foregroundLayer)
3062         backingMemory += m_foregroundLayer-&gt;backingStoreMemoryEstimate();
3063     if (m_backgroundLayer)
3064         backingMemory += m_backgroundLayer-&gt;backingStoreMemoryEstimate();
3065     if (m_maskLayer)
3066         backingMemory += m_maskLayer-&gt;backingStoreMemoryEstimate();
3067     if (m_childClippingMaskLayer)
3068         backingMemory += m_childClippingMaskLayer-&gt;backingStoreMemoryEstimate();
3069 
3070     if (m_scrolledContentsLayer)
3071         backingMemory += m_scrolledContentsLayer-&gt;backingStoreMemoryEstimate();
3072 
3073     if (m_layerForHorizontalScrollbar)
3074         backingMemory += m_layerForHorizontalScrollbar-&gt;backingStoreMemoryEstimate();
3075 
3076     if (m_layerForVerticalScrollbar)
3077         backingMemory += m_layerForVerticalScrollbar-&gt;backingStoreMemoryEstimate();
3078 
3079     if (m_layerForScrollCorner)
3080         backingMemory += m_layerForScrollCorner-&gt;backingStoreMemoryEstimate();
3081 
3082     return backingMemory;
3083 }
3084 
3085 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayerBacking&amp; backing)
3086 {
3087     ts &lt;&lt; &quot;RenderLayerBacking &quot; &lt;&lt; &amp;backing &lt;&lt; &quot; bounds &quot; &lt;&lt; backing.compositedBounds();
3088 
3089     if (backing.isFrameLayerWithTiledBacking())
3090         ts &lt;&lt; &quot; frame layer tiled backing&quot;;
3091     if (backing.paintsIntoWindow())
3092         ts &lt;&lt; &quot; paintsIntoWindow&quot;;
3093     if (backing.paintsIntoCompositedAncestor())
3094         ts &lt;&lt; &quot; paintsIntoCompositedAncestor&quot;;
3095 
3096     ts &lt;&lt; &quot; primary layer ID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID();
3097     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
3098         ts &lt;&lt; &quot; viewport constrained scrolling node &quot; &lt;&lt; nodeID;
3099     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
3100         ts &lt;&lt; &quot; scrolling node &quot; &lt;&lt; nodeID;
<a name="154" id="anc154"></a>



3101     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
3102         ts &lt;&lt; &quot; frame hosting node &quot; &lt;&lt; nodeID;
<a name="155" id="anc155"></a>

3103     return ts;
3104 }
3105 
3106 } // namespace WebCore
<a name="156" id="anc156"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="156" type="hidden" />
</body>
</html>