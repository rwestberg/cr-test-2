<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WasmToJS.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSWebAssemblyTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WasmToJS.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WasmToJS.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmToJS.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;FrameTracers.h&quot;
 33 #include &quot;JITExceptions.h&quot;
 34 #include &quot;JSCInlines.h&quot;

 35 #include &quot;JSWebAssemblyInstance.h&quot;
 36 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 37 #include &quot;LinkBuffer.h&quot;
 38 #include &quot;NativeErrorConstructor.h&quot;
 39 #include &quot;ThunkGenerators.h&quot;
 40 #include &quot;WasmCallingConvention.h&quot;
 41 #include &quot;WasmContext.h&quot;
 42 #include &quot;WasmExceptionType.h&quot;
 43 #include &quot;WasmInstance.h&quot;
 44 #include &quot;WasmSignatureInlines.h&quot;
 45 
 46 namespace JSC { namespace Wasm {
 47 
 48 using JIT = CCallHelpers;
 49 
 50 static void materializeImportJSCell(JIT&amp; jit, unsigned importIndex, GPRReg result)
 51 {
 52     // We&#39;re calling out of the current WebAssembly.Instance. That Instance has a list of all its import functions.
 53     jit.loadWasmContextInstance(result);
 54     jit.loadPtr(JIT::Address(result, Instance::offsetOfImportFunction(importIndex)), result);
 55 }
 56 
 57 static Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; handleBadI64Use(VM* vm, JIT&amp; jit, const Signature&amp; signature, unsigned importIndex)
 58 {
 59     unsigned argCount = signature.argumentCount();
 60 
 61     bool hasBadI64Use = false;
 62     hasBadI64Use |= signature.returnType() == I64;
 63     for (unsigned argNum = 0; argNum &lt; argCount &amp;&amp; !hasBadI64Use; ++argNum) {
 64         Type argType = signature.argument(argNum);
 65         switch (argType) {
 66         case Void:
 67         case Func:
<span class="line-removed"> 68         case Anyfunc:</span>
 69             RELEASE_ASSERT_NOT_REACHED();
 70 
 71         case I64: {
 72             hasBadI64Use = true;
 73             break;
 74         }
 75 
 76         default:
 77             break;
 78         }
 79     }
 80 
 81     if (hasBadI64Use) {
 82         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
 83         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
 84         jit.loadWasmContextInstance(GPRInfo::argumentGPR1);
 85 
 86         // Store Callee.
 87         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, Instance::offsetOfOwner()), GPRInfo::argumentGPR1);
 88         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR2);
 89         jit.storePtr(GPRInfo::argumentGPR2, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
 90 
 91         auto call = jit.call(OperationPtrTag);
 92         jit.jumpToExceptionHandler(*vm);
 93 
 94         void (*throwBadI64)(ExecState*, JSWebAssemblyInstance*) = [] (ExecState* exec, JSWebAssemblyInstance* instance) -&gt; void {
<span class="line-modified"> 95             VM* vm = &amp;exec-&gt;vm();</span>
 96             NativeCallFrameTracer tracer(vm, exec);
 97 
 98             {
<span class="line-modified"> 99                 auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="line-modified">100                 JSGlobalObject* globalObject = instance-&gt;globalObject(*vm);</span>
<span class="line-modified">101                 auto* error = ErrorInstance::create(exec, *vm, globalObject-&gt;errorStructure(ErrorType::TypeError), &quot;i64 not allowed as return type or argument to an imported function&quot;_s);</span>
102                 throwException(exec, throwScope, error);
103             }
104 
105             genericUnwind(vm, exec);
<span class="line-modified">106             ASSERT(!!vm-&gt;callFrameForCatch);</span>
107         };
108 
109         LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
110         if (UNLIKELY(linkBuffer.didFailToAllocate()))
111             return makeUnexpected(BindingFailure::OutOfMemory);
112 
113         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(throwBadI64));
114         return FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript invalid i64 use in import[%i]&quot;, importIndex);
115     }
116 
117     return MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;();
118 }
119 
120 Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; wasmToJS(VM* vm, Bag&lt;CallLinkInfo&gt;&amp; callLinkInfos, SignatureIndex signatureIndex, unsigned importIndex)
121 {
122     // FIXME: This function doesn&#39;t properly abstract away the calling convention.
123     // It&#39;d be super easy to do so: https://bugs.webkit.org/show_bug.cgi?id=169401
124     const WasmCallingConvention&amp; wasmCC = wasmCallingConvention();
125     const JSCCallingConvention&amp; jsCC = jscCallingConvention();
126     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
</pre>
<hr />
<pre>
145     RegisterSet missingCalleeSaves = wasmCC.m_calleeSaveRegisters;
146     missingCalleeSaves.exclude(jsCC.m_calleeSaveRegisters);
147     ASSERT(missingCalleeSaves.isEmpty());
148 
149     if (!Options::useCallICsForWebAssemblyToJSCalls()) {
150         ScratchBuffer* scratchBuffer = vm-&gt;scratchBufferForSize(argCount * sizeof(uint64_t));
151         char* buffer = argCount ? static_cast&lt;char*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
152         unsigned marshalledGPRs = 0;
153         unsigned marshalledFPRs = 0;
154         unsigned bufferOffset = 0;
155         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
156         const GPRReg scratchGPR = GPRInfo::regCS0;
157         jit.subPtr(MacroAssembler::TrustedImm32(WTF::roundUpToMultipleOf(stackAlignmentBytes(), sizeof(Register))), MacroAssembler::stackPointerRegister);
158         jit.storePtr(scratchGPR, MacroAssembler::Address(MacroAssembler::stackPointerRegister));
159 
160         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
161             Type argType = signature.argument(argNum);
162             switch (argType) {
163             case Void:
164             case Func:
<span class="line-removed">165             case Anyfunc:</span>
166             case I64:
167                 RELEASE_ASSERT_NOT_REACHED();


168             case I32: {
169                 GPRReg gprReg;
170                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())
171                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();
172                 else {
173                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
174                     gprReg = GPRInfo::argumentGPR0;
175                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);
176                     frOffset += sizeof(Register);
177                 }
<span class="line-modified">178                 jit.zeroExtend32ToPtr(gprReg, gprReg);</span>

179                 jit.store64(gprReg, buffer + bufferOffset);
180                 ++marshalledGPRs;
181                 break;
182             }
183             case F32: {
184                 FPRReg fprReg;
185                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())
186                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();
187                 else {
188                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
189                     fprReg = FPRInfo::argumentFPR0;
190                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
191                     frOffset += sizeof(Register);
192                 }
193                 jit.convertFloatToDouble(fprReg, fprReg);
194                 jit.moveDoubleTo64(fprReg, scratchGPR);
195                 jit.store64(scratchGPR, buffer + bufferOffset);
196                 ++marshalledFPRs;
197                 break;
198             }
</pre>
<hr />
<pre>
207                     frOffset += sizeof(Register);
208                 }
209                 jit.moveDoubleTo64(fprReg, scratchGPR);
210                 jit.store64(scratchGPR, buffer + bufferOffset);
211                 ++marshalledFPRs;
212                 break;
213             }
214             }
215 
216             bufferOffset += sizeof(Register);
217         }
218         jit.loadPtr(MacroAssembler::Address(MacroAssembler::stackPointerRegister), scratchGPR);
219         if (argCount) {
220             // The GC should not look at this buffer at all, these aren&#39;t JSValues.
221             jit.move(CCallHelpers::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::argumentGPR0);
222             jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), GPRInfo::argumentGPR0);
223         }
224 
225         uint64_t (*callFunc)(ExecState*, JSObject*, SignatureIndex, uint64_t*) =
226             [] (ExecState* exec, JSObject* callee, SignatureIndex signatureIndex, uint64_t* buffer) -&gt; uint64_t {
<span class="line-modified">227                 VM* vm = &amp;exec-&gt;vm();</span>
228                 NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">229                 auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
230                 const Signature&amp; signature = SignatureInformation::get(signatureIndex);
231                 MarkedArgumentBuffer args;
232                 for (unsigned argNum = 0; argNum &lt; signature.argumentCount(); ++argNum) {
233                     Type argType = signature.argument(argNum);
234                     JSValue arg;
235                     switch (argType) {
236                     case Void:
237                     case Func:
<span class="line-removed">238                     case Anyfunc:</span>
239                     case I64:
240                         RELEASE_ASSERT_NOT_REACHED();
241                     case I32:
242                         arg = jsNumber(static_cast&lt;int32_t&gt;(buffer[argNum]));
243                         break;








244                     case F32:
245                     case F64:
246                         arg = jsNumber(purifyNaN(bitwise_cast&lt;double&gt;(buffer[argNum])));
247                         break;
248                     }
249                     args.append(arg);
250                 }
251                 if (UNLIKELY(args.hasOverflowed())) {
252                     throwOutOfMemoryError(exec, throwScope);
253                     return 0;
254                 }
255 
256                 CallData callData;
<span class="line-modified">257                 CallType callType = callee-&gt;methodTable(*vm)-&gt;getCallData(callee, callData);</span>
258                 RELEASE_ASSERT(callType != CallType::None);
259                 JSValue result = call(exec, callee, callType, callData, jsUndefined(), args);
260                 RETURN_IF_EXCEPTION(throwScope, 0);
261 
262                 uint64_t realResult;
263                 switch (signature.returnType()) {
264                 case Func:
<span class="line-removed">265                 case Anyfunc:</span>
266                 case I64:
267                     RELEASE_ASSERT_NOT_REACHED();
268                     break;
269                 case Void:
270                     break;
271                 case I32: {
272                     realResult = static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(result.toInt32(exec)));
273                     break;
274                 }









275                 case F64:
276                 case F32: {
277                     realResult = bitwise_cast&lt;uint64_t&gt;(result.toNumber(exec));
278                     break;
279                 }
280                 }
281 
282                 RETURN_IF_EXCEPTION(throwScope, 0);
283                 return realResult;
284             };
285 
286         jit.loadWasmContextInstance(GPRInfo::argumentGPR0);
287         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);
288         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR0);
289         jit.storePtr(GPRInfo::argumentGPR0, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
290 
291         materializeImportJSCell(jit, importIndex, GPRInfo::argumentGPR1);
292 
293         static_assert(GPRInfo::numberOfArgumentRegisters &gt;= 4, &quot;We rely on this with the call below.&quot;);
294         static_assert(sizeof(SignatureIndex) == sizeof(uint64_t), &quot;Following code assumes SignatureIndex is 64bit.&quot;);
295         jit.setupArguments&lt;decltype(callFunc)&gt;(GPRInfo::argumentGPR1, CCallHelpers::TrustedImm64(signatureIndex), CCallHelpers::TrustedImmPtr(buffer));
296         auto call = jit.call(OperationPtrTag);
297         auto noException = jit.emitExceptionCheck(*vm, AssemblyHelpers::InvertedExceptionCheck);
298 
299         // Exception here.
300         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
301         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
302         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {
<span class="line-modified">303             VM* vm = &amp;exec-&gt;vm();</span>
304             NativeCallFrameTracer tracer(vm, exec);
305             genericUnwind(vm, exec);
<span class="line-modified">306             ASSERT(!!vm-&gt;callFrameForCatch);</span>
307         };
308         auto exceptionCall = jit.call(OperationPtrTag);
309         jit.jumpToExceptionHandler(*vm);
310 
311         noException.link(&amp;jit);
312         switch (signature.returnType()) {
313         case F64: {
314             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
315             break;
316         }
317         case F32: {
318             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
319             jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);
320             break;
321         }
322         default:
323             break;
324         }
325 
326         jit.emitFunctionEpilogue();
</pre>
<hr />
<pre>
344     const unsigned numberOfParameters = argCount + 1; // There is a &quot;this&quot; argument.
345     const unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + numberOfParameters;
346     const unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
347     const unsigned stackOffset = WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);
348     jit.subPtr(MacroAssembler::TrustedImm32(stackOffset), MacroAssembler::stackPointerRegister);
349     JIT::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
350 
351     // FIXME make these loops which switch on Signature if there are many arguments on the stack. It&#39;ll otherwise be huge for huge signatures. https://bugs.webkit.org/show_bug.cgi?id=165547
352 
353     // First go through the integer parameters, freeing up their register for use afterwards.
354     {
355         unsigned marshalledGPRs = 0;
356         unsigned marshalledFPRs = 0;
357         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
358         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
359         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
360             Type argType = signature.argument(argNum);
361             switch (argType) {
362             case Void:
363             case Func:
<span class="line-removed">364             case Anyfunc:</span>
365             case I64:
366                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.


367             case I32: {
368                 GPRReg gprReg;
369                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())
370                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();
371                 else {
372                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
373                     gprReg = GPRInfo::argumentGPR0;
374                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);
375                     frOffset += sizeof(Register);
376                 }
377                 ++marshalledGPRs;
<span class="line-modified">378                 jit.zeroExtend32ToPtr(gprReg, gprReg); // Clear non-int32 and non-tag bits.</span>
<span class="line-modified">379                 jit.boxInt32(gprReg, JSValueRegs(gprReg), DoNotHaveTagRegisters);</span>


380                 jit.store64(gprReg, calleeFrame.withOffset(calleeFrameOffset));
381                 calleeFrameOffset += sizeof(Register);
382                 break;
383             }
384             case F32:
385             case F64:
386                 // Skipped: handled below.
387                 if (marshalledFPRs &gt;= wasmCC.m_fprArgs.size())
388                     frOffset += sizeof(Register);
389                 ++marshalledFPRs;
390                 calleeFrameOffset += sizeof(Register);
391                 break;
392             }
393         }
394     }
395 
396     {
397         // Integer registers have already been spilled, these are now available.
398         GPRReg doubleEncodeOffsetGPRReg = GPRInfo::argumentGPR0;
399         GPRReg scratch = GPRInfo::argumentGPR1;
</pre>
<hr />
<pre>
410         unsigned marshalledGPRs = 0;
411         unsigned marshalledFPRs = 0;
412         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
413         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
414 
415         auto marshallFPR = [&amp;] (FPRReg fprReg) {
416             jit.purifyNaN(fprReg);
417             jit.moveDoubleTo64(fprReg, scratch);
418             materializeDoubleEncodeOffset(doubleEncodeOffsetGPRReg);
419             jit.add64(doubleEncodeOffsetGPRReg, scratch);
420             jit.store64(scratch, calleeFrame.withOffset(calleeFrameOffset));
421             calleeFrameOffset += sizeof(Register);
422             ++marshalledFPRs;
423         };
424 
425         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
426             Type argType = signature.argument(argNum);
427             switch (argType) {
428             case Void:
429             case Func:
<span class="line-removed">430             case Anyfunc:</span>
431             case I64:
432                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.


433             case I32:
434                 // Skipped: handled above.
435                 if (marshalledGPRs &gt;= wasmCC.m_gprArgs.size())
436                     frOffset += sizeof(Register);
437                 ++marshalledGPRs;
438                 calleeFrameOffset += sizeof(Register);
439                 break;
440             case F32: {
441                 FPRReg fprReg;
442                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())
443                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();
444                 else {
445                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
446                     fprReg = FPRInfo::argumentFPR0;
447                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
448                     frOffset += sizeof(Register);
449                 }
450                 jit.convertFloatToDouble(fprReg, fprReg);
451                 marshallFPR(fprReg);
452                 break;
</pre>
<hr />
<pre>
487     CallLinkInfo* callLinkInfo = callLinkInfos.add();
488     callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(), importJSCellGPRReg);
489     JIT::DataLabelPtr targetToCheck;
490     JIT::TrustedImmPtr initialRightValue(nullptr);
491     JIT::Jump slowPath = jit.branchPtrWithPatch(MacroAssembler::NotEqual, importJSCellGPRReg, targetToCheck, initialRightValue);
492     JIT::Call fastCall = jit.nearCall();
493     JIT::Jump done = jit.jump();
494     slowPath.link(&amp;jit);
495     // Callee needs to be in regT0 here.
496     jit.move(MacroAssembler::TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2.
497     JIT::Call slowCall = jit.nearCall();
498     done.link(&amp;jit);
499 
500     CCallHelpers::JumpList exceptionChecks;
501 
502     switch (signature.returnType()) {
503     case Void:
504         // Discard.
505         break;
506     case Func:
<span class="line-removed">507     case Anyfunc:</span>
508         // For the JavaScript embedding, imports with these types in their signature return are a WebAssembly.Module validation error.
509         RELEASE_ASSERT_NOT_REACHED();
510         break;
511     case I64: {
512         RELEASE_ASSERT_NOT_REACHED(); // Handled above.
513     }
514     case I32: {
515         CCallHelpers::JumpList done;
516         CCallHelpers::JumpList slowPath;
517 
518         int32_t (*convertToI32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; int32_t {
<span class="line-modified">519             VM* vm = &amp;exec-&gt;vm();</span>
520             NativeCallFrameTracer tracer(vm, exec);
521             return v.toInt32(exec);
522         };
523 
524         slowPath.append(jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters));
525         slowPath.append(jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters));
526         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);
527         done.append(jit.jump());
528 
529         slowPath.link(&amp;jit);
530         jit.setupArguments&lt;decltype(convertToI32)&gt;(GPRInfo::returnValueGPR);
531         auto call = jit.call(OperationPtrTag);
532         exceptionChecks.append(jit.emitJumpIfException(*vm));
533 
534         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
535             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToI32));
536         });
537 
538         done.link(&amp;jit);
539         break;
540     }



541     case F32: {
542         CCallHelpers::JumpList done;
543 
544         float (*convertToF32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; float {
<span class="line-modified">545             VM* vm = &amp;exec-&gt;vm();</span>
546             NativeCallFrameTracer tracer(vm, exec);
547             return static_cast&lt;float&gt;(v.toNumber(exec));
548         };
549 
550         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);
551         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);
552         // We&#39;re an int32
553         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);
554         jit.convertInt64ToFloat(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
555         done.append(jit.jump());
556 
557         isDouble.link(&amp;jit);
558         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);
559         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);
560         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
561         jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);
562         done.append(jit.jump());
563 
564         notANumber.link(&amp;jit);
565         jit.setupArguments&lt;decltype(convertToF32)&gt;(GPRInfo::returnValueGPR);
566         auto call = jit.call(OperationPtrTag);
567         exceptionChecks.append(jit.emitJumpIfException(*vm));
568 
569         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
570             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF32));
571         });
572 
573         done.link(&amp;jit);
574         break;
575     }
576     case F64: {
577         CCallHelpers::JumpList done;
578 
579         double (*convertToF64)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; double {
<span class="line-modified">580             VM* vm = &amp;exec-&gt;vm();</span>
581             NativeCallFrameTracer tracer(vm, exec);
582             return v.toNumber(exec);
583         };
584 
585         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);
586         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);
587         // We&#39;re an int32
588         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);
589         jit.convertInt64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
590         done.append(jit.jump());
591 
592         isDouble.link(&amp;jit);
593         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);
594         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);
595         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
596         done.append(jit.jump());
597 
598         notANumber.link(&amp;jit);
599         jit.setupArguments&lt;decltype(convertToF64)&gt;(GPRInfo::returnValueGPR);
600         auto call = jit.call(OperationPtrTag);
</pre>
<hr />
<pre>
603         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
604             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF64));
605         });
606 
607         done.link(&amp;jit);
608         break;
609     }
610     }
611 
612     jit.emitFunctionEpilogue();
613     jit.ret();
614 
615     if (!exceptionChecks.empty()) {
616         exceptionChecks.link(&amp;jit);
617         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
618         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
619         auto call = jit.call(OperationPtrTag);
620         jit.jumpToExceptionHandler(*vm);
621 
622         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {
<span class="line-modified">623             VM* vm = &amp;exec-&gt;vm();</span>
624             NativeCallFrameTracer tracer(vm, exec);
625             genericUnwind(vm, exec);
<span class="line-modified">626             ASSERT(!!vm-&gt;callFrameForCatch);</span>
627         };
628 
629         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
630             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(doUnwinding));
631         });
632     }
633 
634     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
635     if (UNLIKELY(patchBuffer.didFailToAllocate()))
636         return makeUnexpected(BindingFailure::OutOfMemory);
637 
638     patchBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(linkCallThunkGenerator).code()));
639     CodeLocationLabel&lt;JSInternalPtrTag&gt; callReturnLocation(patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall));
640     CodeLocationLabel&lt;JSInternalPtrTag&gt; hotPathBegin(patchBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck));
641     CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther = patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall);
642     callLinkInfo-&gt;setCallLocations(callReturnLocation, hotPathBegin, hotPathOther);
643 
644     return FINALIZE_CODE(patchBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());
645 }
646 
647 void* wasmToJSException(ExecState* exec, Wasm::ExceptionType type, Instance* wasmInstance)
648 {
649     wasmInstance-&gt;storeTopCallFrame(exec);
650     JSWebAssemblyInstance* instance = wasmInstance-&gt;owner&lt;JSWebAssemblyInstance&gt;();
651     JSGlobalObject* globalObject = instance-&gt;globalObject();
652 
653     // Do not retrieve VM&amp; from ExecState since ExecState&#39;s callee is not a JSCell.
654     VM&amp; vm = globalObject-&gt;vm();
655 
656     {
657         auto throwScope = DECLARE_THROW_SCOPE(vm);
658 
659         JSObject* error;
660         if (type == ExceptionType::StackOverflow)
661             error = createStackOverflowError(exec, globalObject);
662         else
<span class="line-modified">663             error = JSWebAssemblyRuntimeError::create(exec, vm, globalObject-&gt;WebAssemblyRuntimeErrorStructure(), Wasm::errorMessageForExceptionType(type));</span>
664         throwException(exec, throwScope, error);
665     }
666 
<span class="line-modified">667     genericUnwind(&amp;vm, exec);</span>
668     ASSERT(!!vm.callFrameForCatch);
669     ASSERT(!!vm.targetMachinePCForThrow);
670     // FIXME: We could make this better:
671     // This is a total hack, but the llint (both op_catch and handleUncaughtException)
672     // require a cell in the callee field to load the VM. (The baseline JIT does not require
673     // this since it is compiled with a constant VM pointer.) We could make the calling convention
674     // for exceptions first load callFrameForCatch info call frame register before jumping
675     // to the exception handler. If we did this, we could remove this terrible hack.
676     // https://bugs.webkit.org/show_bug.cgi?id=170440
677     bitwise_cast&lt;uint64_t*&gt;(exec)[CallFrameSlot::callee] = bitwise_cast&lt;uint64_t&gt;(instance-&gt;webAssemblyToJSCallee());
678     return vm.targetMachinePCForThrow;
679 }
680 



















681 } } // namespace JSC::Wasm
682 
683 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmToJS.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;FrameTracers.h&quot;
 33 #include &quot;JITExceptions.h&quot;
 34 #include &quot;JSCInlines.h&quot;
<span class="line-added"> 35 #include &quot;JSWebAssemblyHelpers.h&quot;</span>
 36 #include &quot;JSWebAssemblyInstance.h&quot;
 37 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 38 #include &quot;LinkBuffer.h&quot;
 39 #include &quot;NativeErrorConstructor.h&quot;
 40 #include &quot;ThunkGenerators.h&quot;
 41 #include &quot;WasmCallingConvention.h&quot;
 42 #include &quot;WasmContext.h&quot;
 43 #include &quot;WasmExceptionType.h&quot;
 44 #include &quot;WasmInstance.h&quot;
 45 #include &quot;WasmSignatureInlines.h&quot;
 46 
 47 namespace JSC { namespace Wasm {
 48 
 49 using JIT = CCallHelpers;
 50 
 51 static void materializeImportJSCell(JIT&amp; jit, unsigned importIndex, GPRReg result)
 52 {
 53     // We&#39;re calling out of the current WebAssembly.Instance. That Instance has a list of all its import functions.
 54     jit.loadWasmContextInstance(result);
 55     jit.loadPtr(JIT::Address(result, Instance::offsetOfImportFunction(importIndex)), result);
 56 }
 57 
 58 static Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; handleBadI64Use(VM* vm, JIT&amp; jit, const Signature&amp; signature, unsigned importIndex)
 59 {
 60     unsigned argCount = signature.argumentCount();
 61 
 62     bool hasBadI64Use = false;
 63     hasBadI64Use |= signature.returnType() == I64;
 64     for (unsigned argNum = 0; argNum &lt; argCount &amp;&amp; !hasBadI64Use; ++argNum) {
 65         Type argType = signature.argument(argNum);
 66         switch (argType) {
 67         case Void:
 68         case Func:

 69             RELEASE_ASSERT_NOT_REACHED();
 70 
 71         case I64: {
 72             hasBadI64Use = true;
 73             break;
 74         }
 75 
 76         default:
 77             break;
 78         }
 79     }
 80 
 81     if (hasBadI64Use) {
 82         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
 83         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
 84         jit.loadWasmContextInstance(GPRInfo::argumentGPR1);
 85 
 86         // Store Callee.
 87         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, Instance::offsetOfOwner()), GPRInfo::argumentGPR1);
 88         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR2);
 89         jit.storePtr(GPRInfo::argumentGPR2, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
 90 
 91         auto call = jit.call(OperationPtrTag);
 92         jit.jumpToExceptionHandler(*vm);
 93 
 94         void (*throwBadI64)(ExecState*, JSWebAssemblyInstance*) = [] (ExecState* exec, JSWebAssemblyInstance* instance) -&gt; void {
<span class="line-modified"> 95             VM&amp; vm = exec-&gt;vm();</span>
 96             NativeCallFrameTracer tracer(vm, exec);
 97 
 98             {
<span class="line-modified"> 99                 auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-modified">100                 JSGlobalObject* globalObject = instance-&gt;globalObject(vm);</span>
<span class="line-modified">101                 auto* error = ErrorInstance::create(exec, vm, globalObject-&gt;errorStructure(ErrorType::TypeError), &quot;i64 not allowed as return type or argument to an imported function&quot;_s);</span>
102                 throwException(exec, throwScope, error);
103             }
104 
105             genericUnwind(vm, exec);
<span class="line-modified">106             ASSERT(!!vm.callFrameForCatch);</span>
107         };
108 
109         LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
110         if (UNLIKELY(linkBuffer.didFailToAllocate()))
111             return makeUnexpected(BindingFailure::OutOfMemory);
112 
113         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(throwBadI64));
114         return FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript invalid i64 use in import[%i]&quot;, importIndex);
115     }
116 
117     return MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;();
118 }
119 
120 Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; wasmToJS(VM* vm, Bag&lt;CallLinkInfo&gt;&amp; callLinkInfos, SignatureIndex signatureIndex, unsigned importIndex)
121 {
122     // FIXME: This function doesn&#39;t properly abstract away the calling convention.
123     // It&#39;d be super easy to do so: https://bugs.webkit.org/show_bug.cgi?id=169401
124     const WasmCallingConvention&amp; wasmCC = wasmCallingConvention();
125     const JSCCallingConvention&amp; jsCC = jscCallingConvention();
126     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
</pre>
<hr />
<pre>
145     RegisterSet missingCalleeSaves = wasmCC.m_calleeSaveRegisters;
146     missingCalleeSaves.exclude(jsCC.m_calleeSaveRegisters);
147     ASSERT(missingCalleeSaves.isEmpty());
148 
149     if (!Options::useCallICsForWebAssemblyToJSCalls()) {
150         ScratchBuffer* scratchBuffer = vm-&gt;scratchBufferForSize(argCount * sizeof(uint64_t));
151         char* buffer = argCount ? static_cast&lt;char*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
152         unsigned marshalledGPRs = 0;
153         unsigned marshalledFPRs = 0;
154         unsigned bufferOffset = 0;
155         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
156         const GPRReg scratchGPR = GPRInfo::regCS0;
157         jit.subPtr(MacroAssembler::TrustedImm32(WTF::roundUpToMultipleOf(stackAlignmentBytes(), sizeof(Register))), MacroAssembler::stackPointerRegister);
158         jit.storePtr(scratchGPR, MacroAssembler::Address(MacroAssembler::stackPointerRegister));
159 
160         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
161             Type argType = signature.argument(argNum);
162             switch (argType) {
163             case Void:
164             case Func:

165             case I64:
166                 RELEASE_ASSERT_NOT_REACHED();
<span class="line-added">167             case Anyref:</span>
<span class="line-added">168             case Funcref:</span>
169             case I32: {
170                 GPRReg gprReg;
171                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())
172                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();
173                 else {
174                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
175                     gprReg = GPRInfo::argumentGPR0;
176                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);
177                     frOffset += sizeof(Register);
178                 }
<span class="line-modified">179                 if (argType == I32)</span>
<span class="line-added">180                     jit.zeroExtend32ToPtr(gprReg, gprReg);</span>
181                 jit.store64(gprReg, buffer + bufferOffset);
182                 ++marshalledGPRs;
183                 break;
184             }
185             case F32: {
186                 FPRReg fprReg;
187                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())
188                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();
189                 else {
190                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
191                     fprReg = FPRInfo::argumentFPR0;
192                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
193                     frOffset += sizeof(Register);
194                 }
195                 jit.convertFloatToDouble(fprReg, fprReg);
196                 jit.moveDoubleTo64(fprReg, scratchGPR);
197                 jit.store64(scratchGPR, buffer + bufferOffset);
198                 ++marshalledFPRs;
199                 break;
200             }
</pre>
<hr />
<pre>
209                     frOffset += sizeof(Register);
210                 }
211                 jit.moveDoubleTo64(fprReg, scratchGPR);
212                 jit.store64(scratchGPR, buffer + bufferOffset);
213                 ++marshalledFPRs;
214                 break;
215             }
216             }
217 
218             bufferOffset += sizeof(Register);
219         }
220         jit.loadPtr(MacroAssembler::Address(MacroAssembler::stackPointerRegister), scratchGPR);
221         if (argCount) {
222             // The GC should not look at this buffer at all, these aren&#39;t JSValues.
223             jit.move(CCallHelpers::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::argumentGPR0);
224             jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), GPRInfo::argumentGPR0);
225         }
226 
227         uint64_t (*callFunc)(ExecState*, JSObject*, SignatureIndex, uint64_t*) =
228             [] (ExecState* exec, JSObject* callee, SignatureIndex signatureIndex, uint64_t* buffer) -&gt; uint64_t {
<span class="line-modified">229                 VM&amp; vm = exec-&gt;vm();</span>
230                 NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">231                 auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
232                 const Signature&amp; signature = SignatureInformation::get(signatureIndex);
233                 MarkedArgumentBuffer args;
234                 for (unsigned argNum = 0; argNum &lt; signature.argumentCount(); ++argNum) {
235                     Type argType = signature.argument(argNum);
236                     JSValue arg;
237                     switch (argType) {
238                     case Void:
239                     case Func:

240                     case I64:
241                         RELEASE_ASSERT_NOT_REACHED();
242                     case I32:
243                         arg = jsNumber(static_cast&lt;int32_t&gt;(buffer[argNum]));
244                         break;
<span class="line-added">245                     case Funcref: {</span>
<span class="line-added">246                         arg = JSValue::decode(buffer[argNum]);</span>
<span class="line-added">247                         ASSERT(isWebAssemblyHostFunction(vm, arg) || arg.isNull());</span>
<span class="line-added">248                         break;</span>
<span class="line-added">249                     }</span>
<span class="line-added">250                     case Anyref:</span>
<span class="line-added">251                         arg = JSValue::decode(buffer[argNum]);</span>
<span class="line-added">252                         break;</span>
253                     case F32:
254                     case F64:
255                         arg = jsNumber(purifyNaN(bitwise_cast&lt;double&gt;(buffer[argNum])));
256                         break;
257                     }
258                     args.append(arg);
259                 }
260                 if (UNLIKELY(args.hasOverflowed())) {
261                     throwOutOfMemoryError(exec, throwScope);
262                     return 0;
263                 }
264 
265                 CallData callData;
<span class="line-modified">266                 CallType callType = callee-&gt;methodTable(vm)-&gt;getCallData(callee, callData);</span>
267                 RELEASE_ASSERT(callType != CallType::None);
268                 JSValue result = call(exec, callee, callType, callData, jsUndefined(), args);
269                 RETURN_IF_EXCEPTION(throwScope, 0);
270 
271                 uint64_t realResult;
272                 switch (signature.returnType()) {
273                 case Func:

274                 case I64:
275                     RELEASE_ASSERT_NOT_REACHED();
276                     break;
277                 case Void:
278                     break;
279                 case I32: {
280                     realResult = static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(result.toInt32(exec)));
281                     break;
282                 }
<span class="line-added">283                 case Funcref: {</span>
<span class="line-added">284                     realResult = JSValue::encode(result);</span>
<span class="line-added">285                     ASSERT(result.isFunction(vm) || result.isNull());</span>
<span class="line-added">286                     break;</span>
<span class="line-added">287                 }</span>
<span class="line-added">288                 case Anyref: {</span>
<span class="line-added">289                     realResult = JSValue::encode(result);</span>
<span class="line-added">290                     break;</span>
<span class="line-added">291                 }</span>
292                 case F64:
293                 case F32: {
294                     realResult = bitwise_cast&lt;uint64_t&gt;(result.toNumber(exec));
295                     break;
296                 }
297                 }
298 
299                 RETURN_IF_EXCEPTION(throwScope, 0);
300                 return realResult;
301             };
302 
303         jit.loadWasmContextInstance(GPRInfo::argumentGPR0);
304         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);
305         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR0);
306         jit.storePtr(GPRInfo::argumentGPR0, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
307 
308         materializeImportJSCell(jit, importIndex, GPRInfo::argumentGPR1);
309 
310         static_assert(GPRInfo::numberOfArgumentRegisters &gt;= 4, &quot;We rely on this with the call below.&quot;);
311         static_assert(sizeof(SignatureIndex) == sizeof(uint64_t), &quot;Following code assumes SignatureIndex is 64bit.&quot;);
312         jit.setupArguments&lt;decltype(callFunc)&gt;(GPRInfo::argumentGPR1, CCallHelpers::TrustedImm64(signatureIndex), CCallHelpers::TrustedImmPtr(buffer));
313         auto call = jit.call(OperationPtrTag);
314         auto noException = jit.emitExceptionCheck(*vm, AssemblyHelpers::InvertedExceptionCheck);
315 
316         // Exception here.
317         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
318         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
319         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {
<span class="line-modified">320             VM&amp; vm = exec-&gt;vm();</span>
321             NativeCallFrameTracer tracer(vm, exec);
322             genericUnwind(vm, exec);
<span class="line-modified">323             ASSERT(!!vm.callFrameForCatch);</span>
324         };
325         auto exceptionCall = jit.call(OperationPtrTag);
326         jit.jumpToExceptionHandler(*vm);
327 
328         noException.link(&amp;jit);
329         switch (signature.returnType()) {
330         case F64: {
331             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
332             break;
333         }
334         case F32: {
335             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
336             jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);
337             break;
338         }
339         default:
340             break;
341         }
342 
343         jit.emitFunctionEpilogue();
</pre>
<hr />
<pre>
361     const unsigned numberOfParameters = argCount + 1; // There is a &quot;this&quot; argument.
362     const unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + numberOfParameters;
363     const unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
364     const unsigned stackOffset = WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);
365     jit.subPtr(MacroAssembler::TrustedImm32(stackOffset), MacroAssembler::stackPointerRegister);
366     JIT::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
367 
368     // FIXME make these loops which switch on Signature if there are many arguments on the stack. It&#39;ll otherwise be huge for huge signatures. https://bugs.webkit.org/show_bug.cgi?id=165547
369 
370     // First go through the integer parameters, freeing up their register for use afterwards.
371     {
372         unsigned marshalledGPRs = 0;
373         unsigned marshalledFPRs = 0;
374         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
375         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
376         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
377             Type argType = signature.argument(argNum);
378             switch (argType) {
379             case Void:
380             case Func:

381             case I64:
382                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.
<span class="line-added">383             case Anyref:</span>
<span class="line-added">384             case Funcref:</span>
385             case I32: {
386                 GPRReg gprReg;
387                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())
388                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();
389                 else {
390                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
391                     gprReg = GPRInfo::argumentGPR0;
392                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);
393                     frOffset += sizeof(Register);
394                 }
395                 ++marshalledGPRs;
<span class="line-modified">396                 if (argType == I32) {</span>
<span class="line-modified">397                     jit.zeroExtend32ToPtr(gprReg, gprReg); // Clear non-int32 and non-tag bits.</span>
<span class="line-added">398                     jit.boxInt32(gprReg, JSValueRegs(gprReg), DoNotHaveTagRegisters);</span>
<span class="line-added">399                 }</span>
400                 jit.store64(gprReg, calleeFrame.withOffset(calleeFrameOffset));
401                 calleeFrameOffset += sizeof(Register);
402                 break;
403             }
404             case F32:
405             case F64:
406                 // Skipped: handled below.
407                 if (marshalledFPRs &gt;= wasmCC.m_fprArgs.size())
408                     frOffset += sizeof(Register);
409                 ++marshalledFPRs;
410                 calleeFrameOffset += sizeof(Register);
411                 break;
412             }
413         }
414     }
415 
416     {
417         // Integer registers have already been spilled, these are now available.
418         GPRReg doubleEncodeOffsetGPRReg = GPRInfo::argumentGPR0;
419         GPRReg scratch = GPRInfo::argumentGPR1;
</pre>
<hr />
<pre>
430         unsigned marshalledGPRs = 0;
431         unsigned marshalledFPRs = 0;
432         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
433         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
434 
435         auto marshallFPR = [&amp;] (FPRReg fprReg) {
436             jit.purifyNaN(fprReg);
437             jit.moveDoubleTo64(fprReg, scratch);
438             materializeDoubleEncodeOffset(doubleEncodeOffsetGPRReg);
439             jit.add64(doubleEncodeOffsetGPRReg, scratch);
440             jit.store64(scratch, calleeFrame.withOffset(calleeFrameOffset));
441             calleeFrameOffset += sizeof(Register);
442             ++marshalledFPRs;
443         };
444 
445         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
446             Type argType = signature.argument(argNum);
447             switch (argType) {
448             case Void:
449             case Func:

450             case I64:
451                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.
<span class="line-added">452             case Anyref:</span>
<span class="line-added">453             case Funcref:</span>
454             case I32:
455                 // Skipped: handled above.
456                 if (marshalledGPRs &gt;= wasmCC.m_gprArgs.size())
457                     frOffset += sizeof(Register);
458                 ++marshalledGPRs;
459                 calleeFrameOffset += sizeof(Register);
460                 break;
461             case F32: {
462                 FPRReg fprReg;
463                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())
464                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();
465                 else {
466                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
467                     fprReg = FPRInfo::argumentFPR0;
468                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
469                     frOffset += sizeof(Register);
470                 }
471                 jit.convertFloatToDouble(fprReg, fprReg);
472                 marshallFPR(fprReg);
473                 break;
</pre>
<hr />
<pre>
508     CallLinkInfo* callLinkInfo = callLinkInfos.add();
509     callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(), importJSCellGPRReg);
510     JIT::DataLabelPtr targetToCheck;
511     JIT::TrustedImmPtr initialRightValue(nullptr);
512     JIT::Jump slowPath = jit.branchPtrWithPatch(MacroAssembler::NotEqual, importJSCellGPRReg, targetToCheck, initialRightValue);
513     JIT::Call fastCall = jit.nearCall();
514     JIT::Jump done = jit.jump();
515     slowPath.link(&amp;jit);
516     // Callee needs to be in regT0 here.
517     jit.move(MacroAssembler::TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2.
518     JIT::Call slowCall = jit.nearCall();
519     done.link(&amp;jit);
520 
521     CCallHelpers::JumpList exceptionChecks;
522 
523     switch (signature.returnType()) {
524     case Void:
525         // Discard.
526         break;
527     case Func:

528         // For the JavaScript embedding, imports with these types in their signature return are a WebAssembly.Module validation error.
529         RELEASE_ASSERT_NOT_REACHED();
530         break;
531     case I64: {
532         RELEASE_ASSERT_NOT_REACHED(); // Handled above.
533     }
534     case I32: {
535         CCallHelpers::JumpList done;
536         CCallHelpers::JumpList slowPath;
537 
538         int32_t (*convertToI32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; int32_t {
<span class="line-modified">539             VM&amp; vm = exec-&gt;vm();</span>
540             NativeCallFrameTracer tracer(vm, exec);
541             return v.toInt32(exec);
542         };
543 
544         slowPath.append(jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters));
545         slowPath.append(jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters));
546         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);
547         done.append(jit.jump());
548 
549         slowPath.link(&amp;jit);
550         jit.setupArguments&lt;decltype(convertToI32)&gt;(GPRInfo::returnValueGPR);
551         auto call = jit.call(OperationPtrTag);
552         exceptionChecks.append(jit.emitJumpIfException(*vm));
553 
554         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
555             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToI32));
556         });
557 
558         done.link(&amp;jit);
559         break;
560     }
<span class="line-added">561     case Funcref:</span>
<span class="line-added">562     case Anyref:</span>
<span class="line-added">563         break;</span>
564     case F32: {
565         CCallHelpers::JumpList done;
566 
567         float (*convertToF32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; float {
<span class="line-modified">568             VM&amp; vm = exec-&gt;vm();</span>
569             NativeCallFrameTracer tracer(vm, exec);
570             return static_cast&lt;float&gt;(v.toNumber(exec));
571         };
572 
573         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);
574         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);
575         // We&#39;re an int32
576         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);
577         jit.convertInt64ToFloat(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
578         done.append(jit.jump());
579 
580         isDouble.link(&amp;jit);
581         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);
582         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);
583         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
584         jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);
585         done.append(jit.jump());
586 
587         notANumber.link(&amp;jit);
588         jit.setupArguments&lt;decltype(convertToF32)&gt;(GPRInfo::returnValueGPR);
589         auto call = jit.call(OperationPtrTag);
590         exceptionChecks.append(jit.emitJumpIfException(*vm));
591 
592         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
593             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF32));
594         });
595 
596         done.link(&amp;jit);
597         break;
598     }
599     case F64: {
600         CCallHelpers::JumpList done;
601 
602         double (*convertToF64)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; double {
<span class="line-modified">603             VM&amp; vm = exec-&gt;vm();</span>
604             NativeCallFrameTracer tracer(vm, exec);
605             return v.toNumber(exec);
606         };
607 
608         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);
609         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);
610         // We&#39;re an int32
611         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);
612         jit.convertInt64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
613         done.append(jit.jump());
614 
615         isDouble.link(&amp;jit);
616         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);
617         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);
618         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);
619         done.append(jit.jump());
620 
621         notANumber.link(&amp;jit);
622         jit.setupArguments&lt;decltype(convertToF64)&gt;(GPRInfo::returnValueGPR);
623         auto call = jit.call(OperationPtrTag);
</pre>
<hr />
<pre>
626         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
627             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF64));
628         });
629 
630         done.link(&amp;jit);
631         break;
632     }
633     }
634 
635     jit.emitFunctionEpilogue();
636     jit.ret();
637 
638     if (!exceptionChecks.empty()) {
639         exceptionChecks.link(&amp;jit);
640         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
641         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
642         auto call = jit.call(OperationPtrTag);
643         jit.jumpToExceptionHandler(*vm);
644 
645         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {
<span class="line-modified">646             VM&amp; vm = exec-&gt;vm();</span>
647             NativeCallFrameTracer tracer(vm, exec);
648             genericUnwind(vm, exec);
<span class="line-modified">649             ASSERT(!!vm.callFrameForCatch);</span>
650         };
651 
652         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
653             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(doUnwinding));
654         });
655     }
656 
657     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
658     if (UNLIKELY(patchBuffer.didFailToAllocate()))
659         return makeUnexpected(BindingFailure::OutOfMemory);
660 
661     patchBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(linkCallThunkGenerator).code()));
662     CodeLocationLabel&lt;JSInternalPtrTag&gt; callReturnLocation(patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall));
663     CodeLocationLabel&lt;JSInternalPtrTag&gt; hotPathBegin(patchBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck));
664     CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther = patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall);
665     callLinkInfo-&gt;setCallLocations(callReturnLocation, hotPathBegin, hotPathOther);
666 
667     return FINALIZE_CODE(patchBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());
668 }
669 
670 void* wasmToJSException(ExecState* exec, Wasm::ExceptionType type, Instance* wasmInstance)
671 {
672     wasmInstance-&gt;storeTopCallFrame(exec);
673     JSWebAssemblyInstance* instance = wasmInstance-&gt;owner&lt;JSWebAssemblyInstance&gt;();
674     JSGlobalObject* globalObject = instance-&gt;globalObject();
675 
676     // Do not retrieve VM&amp; from ExecState since ExecState&#39;s callee is not a JSCell.
677     VM&amp; vm = globalObject-&gt;vm();
678 
679     {
680         auto throwScope = DECLARE_THROW_SCOPE(vm);
681 
682         JSObject* error;
683         if (type == ExceptionType::StackOverflow)
684             error = createStackOverflowError(exec, globalObject);
685         else
<span class="line-modified">686             error = JSWebAssemblyRuntimeError::create(exec, vm, globalObject-&gt;webAssemblyRuntimeErrorStructure(), Wasm::errorMessageForExceptionType(type));</span>
687         throwException(exec, throwScope, error);
688     }
689 
<span class="line-modified">690     genericUnwind(vm, exec);</span>
691     ASSERT(!!vm.callFrameForCatch);
692     ASSERT(!!vm.targetMachinePCForThrow);
693     // FIXME: We could make this better:
694     // This is a total hack, but the llint (both op_catch and handleUncaughtException)
695     // require a cell in the callee field to load the VM. (The baseline JIT does not require
696     // this since it is compiled with a constant VM pointer.) We could make the calling convention
697     // for exceptions first load callFrameForCatch info call frame register before jumping
698     // to the exception handler. If we did this, we could remove this terrible hack.
699     // https://bugs.webkit.org/show_bug.cgi?id=170440
700     bitwise_cast&lt;uint64_t*&gt;(exec)[CallFrameSlot::callee] = bitwise_cast&lt;uint64_t&gt;(instance-&gt;webAssemblyToJSCallee());
701     return vm.targetMachinePCForThrow;
702 }
703 
<span class="line-added">704 void emitThrowWasmToJSException(CCallHelpers&amp; jit, GPRReg wasmInstance, Wasm::ExceptionType type)</span>
<span class="line-added">705 {</span>
<span class="line-added">706     ASSERT(wasmInstance != GPRInfo::argumentGPR0);</span>
<span class="line-added">707     jit.loadPtr(CCallHelpers::Address(wasmInstance, Wasm::Instance::offsetOfPointerToTopEntryFrame()), GPRInfo::argumentGPR0);</span>
<span class="line-added">708     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0), GPRInfo::argumentGPR0);</span>
<span class="line-added">709     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(GPRInfo::argumentGPR0);</span>
<span class="line-added">710     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);</span>
<span class="line-added">711     jit.move(CCallHelpers::TrustedImm32(static_cast&lt;int32_t&gt;(type)), GPRInfo::argumentGPR1);</span>
<span class="line-added">712 </span>
<span class="line-added">713     CCallHelpers::Call call = jit.call(OperationPtrTag);</span>
<span class="line-added">714 </span>
<span class="line-added">715     jit.farJump(GPRInfo::returnValueGPR, ExceptionHandlerPtrTag);</span>
<span class="line-added">716     jit.breakpoint(); // We should not reach this.</span>
<span class="line-added">717 </span>
<span class="line-added">718     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-added">719         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(Wasm::wasmToJSException));</span>
<span class="line-added">720     });</span>
<span class="line-added">721 }</span>
<span class="line-added">722 </span>
723 } } // namespace JSC::Wasm
724 
725 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="JSWebAssemblyTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WasmToJS.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>