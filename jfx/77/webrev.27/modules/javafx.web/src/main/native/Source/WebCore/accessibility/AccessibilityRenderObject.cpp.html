<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2 * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3 *
   4 * Redistribution and use in source and binary forms, with or without
   5 * modification, are permitted provided that the following conditions
   6 * are met:
   7 *
   8 * 1.  Redistributions of source code must retain the above copyright
   9 *     notice, this list of conditions and the following disclaimer.
  10 * 2.  Redistributions in binary form must reproduce the above copyright
  11 *     notice, this list of conditions and the following disclaimer in the
  12 *     documentation and/or other materials provided with the distribution.
  13 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14 *     its contributors may be used to endorse or promote products derived
  15 *     from this software without specific prior written permission.
  16 *
  17 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27 */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityRenderObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityImageMapLink.h&quot;
  34 #include &quot;AccessibilityLabel.h&quot;
  35 #include &quot;AccessibilityListBox.h&quot;
  36 #include &quot;AccessibilitySVGRoot.h&quot;
  37 #include &quot;AccessibilitySpinButton.h&quot;
  38 #include &quot;AccessibilityTable.h&quot;
  39 #include &quot;CachedImage.h&quot;
  40 #include &quot;Editing.h&quot;
  41 #include &quot;Editor.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;FloatRect.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameSelection.h&quot;
  47 #include &quot;HTMLAreaElement.h&quot;
  48 #include &quot;HTMLAudioElement.h&quot;
  49 #include &quot;HTMLDetailsElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLFrameElementBase.h&quot;
  52 #include &quot;HTMLImageElement.h&quot;
  53 #include &quot;HTMLInputElement.h&quot;
  54 #include &quot;HTMLLabelElement.h&quot;
  55 #include &quot;HTMLMapElement.h&quot;
  56 #include &quot;HTMLMeterElement.h&quot;
  57 #include &quot;HTMLNames.h&quot;
  58 #include &quot;HTMLOptionElement.h&quot;
  59 #include &quot;HTMLOptionsCollection.h&quot;
  60 #include &quot;HTMLParserIdioms.h&quot;
  61 #include &quot;HTMLSelectElement.h&quot;
  62 #include &quot;HTMLSummaryElement.h&quot;
  63 #include &quot;HTMLTableElement.h&quot;
  64 #include &quot;HTMLTextAreaElement.h&quot;
  65 #include &quot;HTMLVideoElement.h&quot;
  66 #include &quot;HitTestRequest.h&quot;
  67 #include &quot;HitTestResult.h&quot;
  68 #include &quot;Image.h&quot;
  69 #include &quot;LocalizedStrings.h&quot;
  70 #include &quot;NodeList.h&quot;
  71 #include &quot;Page.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;RenderButton.h&quot;
  74 #include &quot;RenderFileUploadControl.h&quot;
  75 #include &quot;RenderHTMLCanvas.h&quot;
  76 #include &quot;RenderImage.h&quot;
  77 #include &quot;RenderInline.h&quot;
  78 #include &quot;RenderIterator.h&quot;
  79 #include &quot;RenderLayer.h&quot;
  80 #include &quot;RenderLineBreak.h&quot;
  81 #include &quot;RenderListBox.h&quot;
  82 #include &quot;RenderListItem.h&quot;
  83 #include &quot;RenderListMarker.h&quot;
  84 #include &quot;RenderMathMLBlock.h&quot;
  85 #include &quot;RenderMenuList.h&quot;
  86 #include &quot;RenderSVGRoot.h&quot;
  87 #include &quot;RenderSVGShape.h&quot;
  88 #include &quot;RenderTableCell.h&quot;
  89 #include &quot;RenderText.h&quot;
  90 #include &quot;RenderTextControl.h&quot;
  91 #include &quot;RenderTextControlSingleLine.h&quot;
  92 #include &quot;RenderTextFragment.h&quot;
  93 #include &quot;RenderTheme.h&quot;
  94 #include &quot;RenderView.h&quot;
  95 #include &quot;RenderWidget.h&quot;
  96 #include &quot;RenderedPosition.h&quot;
  97 #include &quot;SVGDocument.h&quot;
  98 #include &quot;SVGImage.h&quot;
  99 #include &quot;SVGSVGElement.h&quot;
 100 #include &quot;Text.h&quot;
 101 #include &quot;TextControlInnerElements.h&quot;
 102 #include &quot;TextIterator.h&quot;
 103 #include &quot;VisibleUnits.h&quot;
 104 #include &lt;wtf/NeverDestroyed.h&gt;
 105 #include &lt;wtf/StdLibExtras.h&gt;
 106 #include &lt;wtf/unicode/CharacterNames.h&gt;
 107 
 108 namespace WebCore {
 109 
 110 using namespace HTMLNames;
 111 
 112 AccessibilityRenderObject::AccessibilityRenderObject(RenderObject* renderer)
 113     : AccessibilityNodeObject(renderer-&gt;node())
 114     , m_renderer(makeWeakPtr(renderer))
 115 {
 116 #ifndef NDEBUG
 117     m_renderer-&gt;setHasAXObject(true);
 118 #endif
 119 }
 120 
 121 AccessibilityRenderObject::~AccessibilityRenderObject()
 122 {
 123     ASSERT(isDetached());
 124 }
 125 
 126 void AccessibilityRenderObject::init()
 127 {
 128     AccessibilityNodeObject::init();
 129 }
 130 
 131 Ref&lt;AccessibilityRenderObject&gt; AccessibilityRenderObject::create(RenderObject* renderer)
 132 {
 133     return adoptRef(*new AccessibilityRenderObject(renderer));
 134 }
 135 
 136 void AccessibilityRenderObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
 137 {
 138     AccessibilityNodeObject::detach(detachmentType, cache);
 139 
 140     detachRemoteSVGRoot();
 141 
 142 #ifndef NDEBUG
 143     if (m_renderer)
 144         m_renderer-&gt;setHasAXObject(false);
 145 #endif
 146     m_renderer = nullptr;
 147 }
 148 
 149 RenderBoxModelObject* AccessibilityRenderObject::renderBoxModelObject() const
 150 {
 151     if (!is&lt;RenderBoxModelObject&gt;(renderer()))
 152         return nullptr;
 153     return downcast&lt;RenderBoxModelObject&gt;(renderer());
 154 }
 155 
 156 void AccessibilityRenderObject::setRenderer(RenderObject* renderer)
 157 {
 158     m_renderer = makeWeakPtr(renderer);
 159     setNode(renderer-&gt;node());
 160 }
 161 
 162 static inline bool isInlineWithContinuation(RenderObject&amp; object)
 163 {
 164     return is&lt;RenderInline&gt;(object) &amp;&amp; downcast&lt;RenderInline&gt;(object).continuation();
 165 }
 166 
 167 static inline RenderObject* firstChildInContinuation(RenderInline&amp; renderer)
 168 {
 169     auto* continuation = renderer.continuation();
 170 
 171     while (continuation) {
 172         if (is&lt;RenderBlock&gt;(*continuation))
 173             return continuation;
 174         if (RenderObject* child = continuation-&gt;firstChild())
 175             return child;
 176         continuation = downcast&lt;RenderInline&gt;(*continuation).continuation();
 177     }
 178 
 179     return nullptr;
 180 }
 181 
 182 static inline RenderObject* firstChildConsideringContinuation(RenderObject&amp; renderer)
 183 {
 184     RenderObject* firstChild = renderer.firstChildSlow();
 185 
 186     // We don&#39;t want to include the end of a continuation as the firstChild of the
 187     // anonymous parent, because everything has already been linked up via continuation.
 188     // CSS first-letter selector is an example of this case.
 189     if (renderer.isAnonymous() &amp;&amp; is&lt;RenderInline&gt;(firstChild) &amp;&amp; downcast&lt;RenderInline&gt;(*firstChild).isContinuation())
 190         firstChild = nullptr;
 191 
 192     if (!firstChild &amp;&amp; isInlineWithContinuation(renderer))
 193         firstChild = firstChildInContinuation(downcast&lt;RenderInline&gt;(renderer));
 194 
 195     return firstChild;
 196 }
 197 
 198 
 199 static inline RenderObject* lastChildConsideringContinuation(RenderObject&amp; renderer)
 200 {
 201     if (!is&lt;RenderInline&gt;(renderer) &amp;&amp; !is&lt;RenderBlock&gt;(renderer))
 202         return &amp;renderer;
 203 
 204     RenderObject* lastChild = downcast&lt;RenderBoxModelObject&gt;(renderer).lastChild();
 205     for (auto* current = &amp;downcast&lt;RenderBoxModelObject&gt;(renderer); current; ) {
 206         if (RenderObject* newLastChild = current-&gt;lastChild())
 207             lastChild = newLastChild;
 208 
 209         current = current-&gt;inlineContinuation();
 210     }
 211 
 212     return lastChild;
 213 }
 214 
 215 AccessibilityObject* AccessibilityRenderObject::firstChild() const
 216 {
 217     if (!m_renderer)
 218         return nullptr;
 219 
 220     RenderObject* firstChild = firstChildConsideringContinuation(*m_renderer);
 221 
 222     // If an object can&#39;t have children, then it is using this method to help
 223     // calculate some internal property (like its description).
 224     // In this case, it should check the Node level for children in case they&#39;re
 225     // not rendered (like a &lt;meter&gt; element).
 226     if (!firstChild &amp;&amp; !canHaveChildren())
 227         return AccessibilityNodeObject::firstChild();
 228 
 229     return axObjectCache()-&gt;getOrCreate(firstChild);
 230 }
 231 
 232 AccessibilityObject* AccessibilityRenderObject::lastChild() const
 233 {
 234     if (!m_renderer)
 235         return nullptr;
 236 
 237     RenderObject* lastChild = lastChildConsideringContinuation(*m_renderer);
 238 
 239     if (!lastChild &amp;&amp; !canHaveChildren())
 240         return AccessibilityNodeObject::lastChild();
 241 
 242     return axObjectCache()-&gt;getOrCreate(lastChild);
 243 }
 244 
 245 static inline RenderInline* startOfContinuations(RenderObject&amp; renderer)
 246 {
 247     if (!is&lt;RenderElement&gt;(renderer))
 248         return nullptr;
 249     auto&amp; renderElement = downcast&lt;RenderElement&gt;(renderer);
 250     if (is&lt;RenderInline&gt;(renderElement) &amp;&amp; renderElement.isContinuation() &amp;&amp; is&lt;RenderInline&gt;(renderElement.element()-&gt;renderer()))
 251         return downcast&lt;RenderInline&gt;(renderer.node()-&gt;renderer());
 252 
 253     // Blocks with a previous continuation always have a next continuation
 254     if (is&lt;RenderBlock&gt;(renderElement) &amp;&amp; downcast&lt;RenderBlock&gt;(renderElement).inlineContinuation())
 255         return downcast&lt;RenderInline&gt;(downcast&lt;RenderBlock&gt;(renderElement).inlineContinuation()-&gt;element()-&gt;renderer());
 256 
 257     return nullptr;
 258 }
 259 
 260 static inline RenderObject* endOfContinuations(RenderObject&amp; renderer)
 261 {
 262     if (!is&lt;RenderInline&gt;(renderer) &amp;&amp; !is&lt;RenderBlock&gt;(renderer))
 263         return &amp;renderer;
 264 
 265     auto* previous = &amp;downcast&lt;RenderBoxModelObject&gt;(renderer);
 266     for (auto* current = previous; current; ) {
 267         previous = current;
 268         current = current-&gt;inlineContinuation();
 269     }
 270 
 271     return previous;
 272 }
 273 
 274 
 275 static inline RenderObject* childBeforeConsideringContinuations(RenderInline* renderer, RenderObject* child)
 276 {
 277     RenderObject* previous = nullptr;
 278     for (RenderBoxModelObject* currentContainer = renderer; currentContainer; ) {
 279         if (is&lt;RenderInline&gt;(*currentContainer)) {
 280             auto* current = currentContainer-&gt;firstChild();
 281             while (current) {
 282                 if (current == child)
 283                     return previous;
 284                 previous = current;
 285                 current = current-&gt;nextSibling();
 286             }
 287 
 288             currentContainer = currentContainer-&gt;continuation();
 289         } else if (is&lt;RenderBlock&gt;(*currentContainer)) {
 290             if (currentContainer == child)
 291                 return previous;
 292 
 293             previous = currentContainer;
 294             currentContainer = currentContainer-&gt;inlineContinuation();
 295         }
 296     }
 297 
 298     ASSERT_NOT_REACHED();
 299     return nullptr;
 300 }
 301 
 302 static inline bool firstChildIsInlineContinuation(RenderElement&amp; renderer)
 303 {
 304     RenderObject* child = renderer.firstChild();
 305     return is&lt;RenderInline&gt;(child) &amp;&amp; downcast&lt;RenderInline&gt;(*child).isContinuation();
 306 }
 307 
 308 AccessibilityObject* AccessibilityRenderObject::previousSibling() const
 309 {
 310     if (!m_renderer)
 311         return nullptr;
 312 
 313     RenderObject* previousSibling = nullptr;
 314 
 315     // Case 1: The node is a block and is an inline&#39;s continuation. In that case, the inline&#39;s
 316     // last child is our previous sibling (or further back in the continuation chain)
 317     RenderInline* startOfConts;
 318     if (is&lt;RenderBox&gt;(*m_renderer) &amp;&amp; (startOfConts = startOfContinuations(*m_renderer)))
 319         previousSibling = childBeforeConsideringContinuations(startOfConts, renderer());
 320 
 321     // Case 2: Anonymous block parent of the end of a continuation - skip all the way to before
 322     // the parent of the start, since everything in between will be linked up via the continuation.
 323     else if (m_renderer-&gt;isAnonymousBlock() &amp;&amp; firstChildIsInlineContinuation(downcast&lt;RenderBlock&gt;(*m_renderer))) {
 324         RenderBlock&amp; renderBlock = downcast&lt;RenderBlock&gt;(*m_renderer);
 325         auto* firstParent = startOfContinuations(*renderBlock.firstChild())-&gt;parent();
 326         ASSERT(firstParent);
 327         while (firstChildIsInlineContinuation(*firstParent))
 328             firstParent = startOfContinuations(*firstParent-&gt;firstChild())-&gt;parent();
 329         previousSibling = firstParent-&gt;previousSibling();
 330     }
 331 
 332     // Case 3: The node has an actual previous sibling
 333     else if (RenderObject* ps = m_renderer-&gt;previousSibling())
 334         previousSibling = ps;
 335 
 336     // Case 4: This node has no previous siblings, but its parent is an inline,
 337     // and is another node&#39;s inline continutation. Follow the continuation chain.
 338     else if (is&lt;RenderInline&gt;(*m_renderer-&gt;parent()) &amp;&amp; (startOfConts = startOfContinuations(*m_renderer-&gt;parent())))
 339         previousSibling = childBeforeConsideringContinuations(startOfConts, m_renderer-&gt;parent()-&gt;firstChild());
 340 
 341     if (!previousSibling)
 342         return nullptr;
 343 
 344     return axObjectCache()-&gt;getOrCreate(previousSibling);
 345 }
 346 
 347 static inline bool lastChildHasContinuation(RenderElement&amp; renderer)
 348 {
 349     RenderObject* child = renderer.lastChild();
 350     return child &amp;&amp; isInlineWithContinuation(*child);
 351 }
 352 
 353 AccessibilityObject* AccessibilityRenderObject::nextSibling() const
 354 {
 355     if (!m_renderer)
 356         return nullptr;
 357 
 358     RenderObject* nextSibling = nullptr;
 359 
 360     // Case 1: node is a block and has an inline continuation. Next sibling is the inline continuation&#39;s
 361     // first child.
 362     RenderInline* inlineContinuation;
 363     if (is&lt;RenderBlock&gt;(*m_renderer) &amp;&amp; (inlineContinuation = downcast&lt;RenderBlock&gt;(*m_renderer).inlineContinuation()))
 364         nextSibling = firstChildConsideringContinuation(*inlineContinuation);
 365 
 366     // Case 2: Anonymous block parent of the start of a continuation - skip all the way to
 367     // after the parent of the end, since everything in between will be linked up via the continuation.
 368     else if (m_renderer-&gt;isAnonymousBlock() &amp;&amp; lastChildHasContinuation(downcast&lt;RenderBlock&gt;(*m_renderer))) {
 369         RenderElement* lastParent = endOfContinuations(*downcast&lt;RenderBlock&gt;(*m_renderer).lastChild())-&gt;parent();
 370         ASSERT(lastParent);
 371         while (lastChildHasContinuation(*lastParent))
 372             lastParent = endOfContinuations(*lastParent-&gt;lastChild())-&gt;parent();
 373         nextSibling = lastParent-&gt;nextSibling();
 374     }
 375 
 376     // Case 3: node has an actual next sibling
 377     else if (RenderObject* ns = m_renderer-&gt;nextSibling())
 378         nextSibling = ns;
 379 
 380     // Case 4: node is an inline with a continuation. Next sibling is the next sibling of the end
 381     // of the continuation chain.
 382     else if (isInlineWithContinuation(*m_renderer))
 383         nextSibling = endOfContinuations(*m_renderer)-&gt;nextSibling();
 384 
 385     // Case 5: node has no next sibling, and its parent is an inline with a continuation.
 386     // Case 5.1: After case 4, (the element was inline w/ continuation but had no sibling), then check it&#39;s parent.
 387     if (!nextSibling &amp;&amp; isInlineWithContinuation(*m_renderer-&gt;parent())) {
 388         auto&amp; continuation = *downcast&lt;RenderInline&gt;(*m_renderer-&gt;parent()).continuation();
 389 
 390         // Case 5a: continuation is a block - in this case the block itself is the next sibling.
 391         if (is&lt;RenderBlock&gt;(continuation))
 392             nextSibling = &amp;continuation;
 393         // Case 5b: continuation is an inline - in this case the inline&#39;s first child is the next sibling
 394         else
 395             nextSibling = firstChildConsideringContinuation(continuation);
 396 
 397         // After case 4, there are chances that nextSibling has the same node as the current renderer,
 398         // which might lead to adding the same child repeatedly.
 399         if (nextSibling &amp;&amp; nextSibling-&gt;node() == m_renderer-&gt;node()) {
 400             if (AccessibilityObject* nextObj = axObjectCache()-&gt;getOrCreate(nextSibling))
 401                 return nextObj-&gt;nextSibling();
 402         }
 403     }
 404 
 405     if (!nextSibling)
 406         return nullptr;
 407 
 408     // Make sure next sibling has the same parent.
 409     AccessibilityObject* nextObj = axObjectCache()-&gt;getOrCreate(nextSibling);
 410     if (nextObj &amp;&amp; nextObj-&gt;parentObject() != this-&gt;parentObject())
 411         return nullptr;
 412 
 413     return nextObj;
 414 }
 415 
 416 static RenderBoxModelObject* nextContinuation(RenderObject&amp; renderer)
 417 {
 418     if (is&lt;RenderInline&gt;(renderer) &amp;&amp; !renderer.isReplaced())
 419         return downcast&lt;RenderInline&gt;(renderer).continuation();
 420     if (is&lt;RenderBlock&gt;(renderer))
 421         return downcast&lt;RenderBlock&gt;(renderer).inlineContinuation();
 422     return nullptr;
 423 }
 424 
 425 RenderObject* AccessibilityRenderObject::renderParentObject() const
 426 {
 427     if (!m_renderer)
 428         return nullptr;
 429 
 430     RenderElement* parent = m_renderer-&gt;parent();
 431 
 432     // Case 1: node is a block and is an inline&#39;s continuation. Parent
 433     // is the start of the continuation chain.
 434     RenderInline* startOfConts = nullptr;
 435     RenderObject* firstChild = nullptr;
 436     if (is&lt;RenderBlock&gt;(*m_renderer) &amp;&amp; (startOfConts = startOfContinuations(*m_renderer)))
 437         parent = startOfConts;
 438 
 439     // Case 2: node&#39;s parent is an inline which is some node&#39;s continuation; parent is
 440     // the earliest node in the continuation chain.
 441     else if (is&lt;RenderInline&gt;(parent) &amp;&amp; (startOfConts = startOfContinuations(*parent)))
 442         parent = startOfConts;
 443 
 444     // Case 3: The first sibling is the beginning of a continuation chain. Find the origin of that continuation.
 445     else if (parent &amp;&amp; (firstChild = parent-&gt;firstChild()) &amp;&amp; firstChild-&gt;node()) {
 446         // Get the node&#39;s renderer and follow that continuation chain until the first child is found
 447         RenderObject* nodeRenderFirstChild = firstChild-&gt;node()-&gt;renderer();
 448         while (nodeRenderFirstChild != firstChild) {
 449             for (RenderObject* contsTest = nodeRenderFirstChild; contsTest; contsTest = nextContinuation(*contsTest)) {
 450                 if (contsTest == firstChild) {
 451                     parent = nodeRenderFirstChild-&gt;parent();
 452                     break;
 453                 }
 454             }
 455             RenderObject* parentFirstChild = parent-&gt;firstChild();
 456             if (firstChild == parentFirstChild)
 457                 break;
 458             firstChild = parentFirstChild;
 459             if (!firstChild-&gt;node())
 460                 break;
 461             nodeRenderFirstChild = firstChild-&gt;node()-&gt;renderer();
 462         }
 463     }
 464 
 465     return parent;
 466 }
 467 
 468 AccessibilityObject* AccessibilityRenderObject::parentObjectIfExists() const
 469 {
 470     AXObjectCache* cache = axObjectCache();
 471     if (!cache)
 472         return nullptr;
 473 
 474     // WebArea&#39;s parent should be the scroll view containing it.
 475     if (isWebArea())
 476         return cache-&gt;get(&amp;m_renderer-&gt;view().frameView());
 477 
 478     return cache-&gt;get(renderParentObject());
 479 }
 480 
 481 AccessibilityObject* AccessibilityRenderObject::parentObject() const
 482 {
 483     if (!m_renderer)
 484         return nullptr;
 485 
 486     if (ariaRoleAttribute() == AccessibilityRole::MenuBar)
 487         return axObjectCache()-&gt;getOrCreate(m_renderer-&gt;parent());
 488 
 489     // menuButton and its corresponding menu are DOM siblings, but Accessibility needs them to be parent/child
 490     if (ariaRoleAttribute() == AccessibilityRole::Menu) {
 491         AccessibilityObject* parent = menuButtonForMenu();
 492         if (parent)
 493             return parent;
 494     }
 495 
 496     AXObjectCache* cache = axObjectCache();
 497     if (!cache)
 498         return nullptr;
 499 
 500     RenderObject* parentObj = renderParentObject();
 501     if (parentObj)
 502         return cache-&gt;getOrCreate(parentObj);
 503 
 504     // WebArea&#39;s parent should be the scroll view containing it.
 505     if (isWebArea())
 506         return cache-&gt;getOrCreate(&amp;m_renderer-&gt;view().frameView());
 507 
 508     return nullptr;
 509 }
 510 
 511 bool AccessibilityRenderObject::isAttachment() const
 512 {
 513     RenderBoxModelObject* renderer = renderBoxModelObject();
 514     if (!renderer)
 515         return false;
 516     // Widgets are the replaced elements that we represent to AX as attachments
 517     bool isWidget = renderer-&gt;isWidget();
 518 
 519     return isWidget &amp;&amp; ariaRoleAttribute() == AccessibilityRole::Unknown;
 520 }
 521 
 522 bool AccessibilityRenderObject::isFileUploadButton() const
 523 {
 524     if (m_renderer &amp;&amp; is&lt;HTMLInputElement&gt;(m_renderer-&gt;node())) {
 525         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*m_renderer-&gt;node());
 526         return input.isFileUpload();
 527     }
 528 
 529     return false;
 530 }
 531 
 532 bool AccessibilityRenderObject::isOffScreen() const
 533 {
 534     if (!m_renderer)
 535         return true;
 536 
 537     IntRect contentRect = snappedIntRect(m_renderer-&gt;absoluteClippedOverflowRect());
 538     // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
 539     IntRect viewRect = m_renderer-&gt;view().frameView().visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
 540     viewRect.intersect(contentRect);
 541     return viewRect.isEmpty();
 542 }
 543 
 544 Element* AccessibilityRenderObject::anchorElement() const
 545 {
 546     if (!m_renderer)
 547         return nullptr;
 548 
 549     AXObjectCache* cache = axObjectCache();
 550     if (!cache)
 551         return nullptr;
 552 
 553     RenderObject* currentRenderer;
 554 
 555     // Search up the render tree for a RenderObject with a DOM node.  Defer to an earlier continuation, though.
 556     for (currentRenderer = renderer(); currentRenderer &amp;&amp; !currentRenderer-&gt;node(); currentRenderer = currentRenderer-&gt;parent()) {
 557         if (currentRenderer-&gt;isAnonymousBlock()) {
 558             if (RenderObject* continuation = downcast&lt;RenderBlock&gt;(*currentRenderer).continuation())
 559                 return cache-&gt;getOrCreate(continuation)-&gt;anchorElement();
 560         }
 561     }
 562 
 563     // bail if none found
 564     if (!currentRenderer)
 565         return nullptr;
 566 
 567     // search up the DOM tree for an anchor element
 568     // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
 569     for (Node* node = currentRenderer-&gt;node(); node; node = node-&gt;parentNode()) {
 570         if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
 571             return downcast&lt;Element&gt;(node);
 572     }
 573 
 574     return nullptr;
 575 }
 576 
 577 String AccessibilityRenderObject::helpText() const
 578 {
 579     if (!m_renderer)
 580         return String();
 581 
 582     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);
 583     if (!ariaHelp.isEmpty())
 584         return ariaHelp;
 585 
 586     String describedBy = ariaDescribedByAttribute();
 587     if (!describedBy.isEmpty())
 588         return describedBy;
 589 
 590     String description = accessibilityDescription();
 591     for (RenderObject* ancestor = renderer(); ancestor; ancestor = ancestor-&gt;parent()) {
 592         if (is&lt;HTMLElement&gt;(ancestor-&gt;node())) {
 593             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;node());
 594             const AtomString&amp; summary = element.getAttribute(summaryAttr);
 595             if (!summary.isEmpty())
 596                 return summary;
 597 
 598             // The title attribute should be used as help text unless it is already being used as descriptive text.
 599             const AtomString&amp; title = element.getAttribute(titleAttr);
 600             if (!title.isEmpty() &amp;&amp; description != title)
 601                 return title;
 602         }
 603 
 604         // Only take help text from an ancestor element if its a group or an unknown role. If help was
 605         // added to those kinds of elements, it is likely it was meant for a child element.
 606         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(ancestor)) {
 607             if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
 608                 break;
 609         }
 610     }
 611 
 612     return String();
 613 }
 614 
 615 String AccessibilityRenderObject::textUnderElement(AccessibilityTextUnderElementMode mode) const
 616 {
 617     if (!m_renderer)
 618         return String();
 619 
 620     if (is&lt;RenderFileUploadControl&gt;(*m_renderer))
 621         return downcast&lt;RenderFileUploadControl&gt;(*m_renderer).buttonValue();
 622 
 623     // Reflect when a content author has explicitly marked a line break.
 624     if (m_renderer-&gt;isBR())
 625         return &quot;\n&quot;_s;
 626 
 627     if (shouldGetTextFromNode(mode))
 628         return AccessibilityNodeObject::textUnderElement(mode);
 629 
 630     // We use a text iterator for text objects AND for those cases where we are
 631     // explicitly asking for the full text under a given element.
 632     if (is&lt;RenderText&gt;(*m_renderer) || mode.childrenInclusion == AccessibilityTextUnderElementMode::TextUnderElementModeIncludeAllChildren) {
 633         // If possible, use a text iterator to get the text, so that whitespace
 634         // is handled consistently.
 635         Document* nodeDocument = nullptr;
 636         RefPtr&lt;Range&gt; textRange;
 637         if (Node* node = m_renderer-&gt;node()) {
 638             nodeDocument = &amp;node-&gt;document();
 639             textRange = rangeOfContents(*node);
 640         } else {
 641             // For anonymous blocks, we work around not having a direct node to create a range from
 642             // defining one based in the two external positions defining the boundaries of the subtree.
 643             RenderObject* firstChildRenderer = m_renderer-&gt;firstChildSlow();
 644             RenderObject* lastChildRenderer = m_renderer-&gt;lastChildSlow();
 645             if (firstChildRenderer &amp;&amp; firstChildRenderer-&gt;node() &amp;&amp; lastChildRenderer &amp;&amp; lastChildRenderer-&gt;node()) {
 646                 // We define the start and end positions for the range as the ones right before and after
 647                 // the first and the last nodes in the DOM tree that is wrapped inside the anonymous block.
 648                 Node* firstNodeInBlock = firstChildRenderer-&gt;node();
 649                 Position startPosition = positionInParentBeforeNode(firstNodeInBlock);
 650                 Position endPosition = positionInParentAfterNode(lastChildRenderer-&gt;node());
 651 
 652                 nodeDocument = &amp;firstNodeInBlock-&gt;document();
 653                 textRange = Range::create(*nodeDocument, startPosition, endPosition);
 654             }
 655         }
 656 
 657         if (nodeDocument &amp;&amp; textRange) {
 658             if (Frame* frame = nodeDocument-&gt;frame()) {
 659                 // catch stale WebCoreAXObject (see &lt;rdar://problem/3960196&gt;)
 660                 if (frame-&gt;document() != nodeDocument)
 661                     return String();
 662 
 663                 // Renders referenced by accessibility objects could get destroyed, if TextIterator ends up triggering
 664                 // style update/layout here. See also AXObjectCache::deferTextChangedIfNeeded().
 665                 ASSERT_WITH_SECURITY_IMPLICATION(!nodeDocument-&gt;childNeedsStyleRecalc());
 666                 ASSERT_WITH_SECURITY_IMPLICATION(!nodeDocument-&gt;view()-&gt;layoutContext().isInRenderTreeLayout());
 667                 return plainText(textRange.get(), textIteratorBehaviorForTextRange());
 668             }
 669         }
 670 
 671         // Sometimes text fragments don&#39;t have Nodes associated with them (like when
 672         // CSS content is used to insert text or when a RenderCounter is used.)
 673         if (is&lt;RenderText&gt;(*m_renderer)) {
 674             RenderText&amp; renderTextObject = downcast&lt;RenderText&gt;(*m_renderer);
 675             if (is&lt;RenderTextFragment&gt;(renderTextObject)) {
 676                 RenderTextFragment&amp; renderTextFragment = downcast&lt;RenderTextFragment&gt;(renderTextObject);
 677                 // The alt attribute may be set on a text fragment through CSS, which should be honored.
 678                 const String&amp; altText = renderTextFragment.altText();
 679                 if (!altText.isEmpty())
 680                     return altText;
 681                 return renderTextFragment.contentString();
 682             }
 683 
 684             return renderTextObject.text();
 685         }
 686     }
 687 
 688     return AccessibilityNodeObject::textUnderElement(mode);
 689 }
 690 
 691 bool AccessibilityRenderObject::shouldGetTextFromNode(AccessibilityTextUnderElementMode mode) const
 692 {
 693     if (!m_renderer)
 694         return false;
 695 
 696     // AccessibilityRenderObject::textUnderElement() gets the text of anonymous blocks by using
 697     // the child nodes to define positions. CSS tables and their anonymous descendants lack
 698     // children with nodes.
 699     if (m_renderer-&gt;isAnonymous() &amp;&amp; m_renderer-&gt;isTablePart())
 700         return mode.childrenInclusion == AccessibilityTextUnderElementMode::TextUnderElementModeIncludeAllChildren;
 701 
 702     // AccessibilityRenderObject::textUnderElement() calls rangeOfContents() to create the text
 703     // range. rangeOfContents() does not include CSS-generated content.
 704     if (m_renderer-&gt;isBeforeOrAfterContent())
 705         return true;
 706     if (Node* node = m_renderer-&gt;node()) {
 707         Node* firstChild = node-&gt;pseudoAwareFirstChild();
 708         Node* lastChild = node-&gt;pseudoAwareLastChild();
 709         if ((firstChild &amp;&amp; firstChild-&gt;isPseudoElement()) || (lastChild &amp;&amp; lastChild-&gt;isPseudoElement()))
 710             return true;
 711     }
 712 
 713     return false;
 714 }
 715 
 716 Node* AccessibilityRenderObject::node() const
 717 {
 718     if (!m_renderer)
 719         return nullptr;
 720     if (m_renderer-&gt;isRenderView())
 721         return &amp;m_renderer-&gt;document();
 722     return m_renderer-&gt;node();
 723 }
 724 
 725 String AccessibilityRenderObject::stringValue() const
 726 {
 727     if (!m_renderer)
 728         return String();
 729 
 730     if (isPasswordField())
 731         return passwordFieldValue();
 732 
 733     RenderBoxModelObject* cssBox = renderBoxModelObject();
 734 
 735     if (isARIAStaticText()) {
 736         String staticText = text();
 737         if (!staticText.length())
 738             staticText = textUnderElement();
 739         return staticText;
 740     }
 741 
 742     if (is&lt;RenderText&gt;(*m_renderer))
 743         return textUnderElement();
 744 
 745     if (is&lt;RenderMenuList&gt;(cssBox)) {
 746         // RenderMenuList will go straight to the text() of its selected item.
 747         // This has to be overridden in the case where the selected item has an ARIA label.
 748         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*m_renderer-&gt;node());
 749         int selectedIndex = selectElement.selectedIndex();
 750         const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
 751         if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
 752             const AtomString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);
 753             if (!overriddenDescription.isNull())
 754                 return overriddenDescription;
 755         }
 756         return downcast&lt;RenderMenuList&gt;(*m_renderer).text();
 757     }
 758 
 759     if (is&lt;RenderListMarker&gt;(*m_renderer))
 760         return downcast&lt;RenderListMarker&gt;(*m_renderer).text();
 761 
 762     if (isWebArea())
 763         return String();
 764 
 765     if (isTextControl())
 766         return text();
 767 
 768 #if PLATFORM(IOS_FAMILY)
 769     if (isInputTypePopupButton())
 770         return textUnderElement();
 771 #endif
 772 
 773     if (is&lt;RenderFileUploadControl&gt;(*m_renderer))
 774         return downcast&lt;RenderFileUploadControl&gt;(*m_renderer).fileTextValue();
 775 
 776     // FIXME: We might need to implement a value here for more types
 777     // FIXME: It would be better not to advertise a value at all for the types for which we don&#39;t implement one;
 778     // this would require subclassing or making accessibilityAttributeNames do something other than return a
 779     // single static array.
 780     return String();
 781 }
 782 
 783 bool AccessibilityRenderObject::canHavePlainText() const
 784 {
 785     return isARIAStaticText() || is&lt;RenderText&gt;(*m_renderer) || isTextControl();
 786 }
 787 
 788 HTMLLabelElement* AccessibilityRenderObject::labelElementContainer() const
 789 {
 790     if (!m_renderer)
 791         return nullptr;
 792 
 793     // the control element should not be considered part of the label
 794     if (isControl())
 795         return nullptr;
 796 
 797     // find if this has a parent that is a label
 798     for (Node* parentNode = m_renderer-&gt;node(); parentNode; parentNode = parentNode-&gt;parentNode()) {
 799         if (is&lt;HTMLLabelElement&gt;(*parentNode))
 800             return downcast&lt;HTMLLabelElement&gt;(parentNode);
 801     }
 802 
 803     return nullptr;
 804 }
 805 
 806 // The boundingBox for elements within the remote SVG element needs to be offset by its position
 807 // within the parent page, otherwise they are in relative coordinates only.
 808 void AccessibilityRenderObject::offsetBoundingBoxForRemoteSVGElement(LayoutRect&amp; rect) const
 809 {
 810     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
 811         if (parent-&gt;isAccessibilitySVGRoot()) {
 812             rect.moveBy(parent-&gt;parentObject()-&gt;boundingBoxRect().location());
 813             break;
 814         }
 815     }
 816 }
 817 
 818 LayoutRect AccessibilityRenderObject::boundingBoxRect() const
 819 {
 820     RenderObject* obj = renderer();
 821 
 822     if (!obj)
 823         return LayoutRect();
 824 
 825     if (obj-&gt;node()) // If we are a continuation, we want to make sure to use the primary renderer.
 826         obj = obj-&gt;node()-&gt;renderer();
 827 
 828     // absoluteFocusRingQuads will query the hierarchy below this element, which for large webpages can be very slow.
 829     // For a web area, which will have the most elements of any element, absoluteQuads should be used.
 830     // We should also use absoluteQuads for SVG elements, otherwise transforms won&#39;t be applied.
 831     Vector&lt;FloatQuad&gt; quads;
 832     bool isSVGRoot = false;
 833 
 834     if (obj-&gt;isSVGRoot())
 835         isSVGRoot = true;
 836 
 837     if (is&lt;RenderText&gt;(*obj))
 838         quads = downcast&lt;RenderText&gt;(*obj).absoluteQuadsClippedToEllipsis();
 839     else if (isWebArea() || isSVGRoot)
 840         obj-&gt;absoluteQuads(quads);
 841     else
 842         obj-&gt;absoluteFocusRingQuads(quads);
 843 
 844     LayoutRect result = boundingBoxForQuads(obj, quads);
 845 
 846     Document* document = this-&gt;document();
 847     if (document &amp;&amp; document-&gt;isSVGDocument())
 848         offsetBoundingBoxForRemoteSVGElement(result);
 849 
 850     // The size of the web area should be the content size, not the clipped size.
 851     if (isWebArea())
 852         result.setSize(obj-&gt;view().frameView().contentsSize());
 853 
 854     return result;
 855 }
 856 
 857 LayoutRect AccessibilityRenderObject::checkboxOrRadioRect() const
 858 {
 859     if (!m_renderer)
 860         return LayoutRect();
 861 
 862     HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(m_renderer-&gt;node()));
 863     if (!label || !label-&gt;renderer())
 864         return boundingBoxRect();
 865 
 866     LayoutRect labelRect = axObjectCache()-&gt;getOrCreate(label)-&gt;elementRect();
 867     labelRect.unite(boundingBoxRect());
 868     return labelRect;
 869 }
 870 
 871 LayoutRect AccessibilityRenderObject::elementRect() const
 872 {
 873     // a checkbox or radio button should encompass its label
 874     if (isCheckboxOrRadio())
 875         return checkboxOrRadioRect();
 876 
 877     return boundingBoxRect();
 878 }
 879 
 880 bool AccessibilityRenderObject::supportsPath() const
 881 {
 882     return is&lt;RenderSVGShape&gt;(renderer());
 883 }
 884 
 885 Path AccessibilityRenderObject::elementPath() const
 886 {
 887     if (is&lt;RenderSVGShape&gt;(renderer()) &amp;&amp; downcast&lt;RenderSVGShape&gt;(*m_renderer).hasPath()) {
 888         Path path = downcast&lt;RenderSVGShape&gt;(*m_renderer).path();
 889 
 890         // The SVG path is in terms of the parent&#39;s bounding box. The path needs to be offset to frame coordinates.
 891         if (auto svgRoot = ancestorsOfType&lt;RenderSVGRoot&gt;(*m_renderer).first()) {
 892             LayoutPoint parentOffset = axObjectCache()-&gt;getOrCreate(&amp;*svgRoot)-&gt;elementRect().location();
 893             path.transform(AffineTransform().translate(parentOffset.x(), parentOffset.y()));
 894         }
 895 
 896         return path;
 897     }
 898 
 899     return Path();
 900 }
 901 
 902 IntPoint AccessibilityRenderObject::linkClickPoint()
 903 {
 904     ASSERT(isLink());
 905     /* A link bounding rect can contain points that are not part of the link.
 906      For instance, a link that starts at the end of a line and finishes at the
 907      beginning of the next line will have a bounding rect that includes the
 908      entire two lines. In such a case, the middle point of the bounding rect
 909      may not belong to the link element and thus may not activate the link.
 910      Hence, return the middle point of the first character in the link if exists.
 911      */
 912     if (RefPtr&lt;Range&gt; range = elementRange()) {
 913         VisiblePosition start = range-&gt;startPosition();
 914         VisiblePosition end = nextVisiblePosition(start);
 915         if (start.isNull() || !range-&gt;contains(end))
 916             return AccessibilityObject::clickPoint();
 917 
 918         RefPtr&lt;Range&gt; charRange = makeRange(start, end);
 919         IntRect rect = boundsForRange(charRange);
 920         return { rect.x() + rect.width() / 2, rect.y() + rect.height() / 2 };
 921     }
 922     return AccessibilityObject::clickPoint();
 923 }
 924 
 925 IntPoint AccessibilityRenderObject::clickPoint()
 926 {
 927     // Headings are usually much wider than their textual content. If the mid point is used, often it can be wrong.
 928     AccessibilityChildrenVector children = this-&gt;children();
 929     if (isHeading() &amp;&amp; children.size() == 1)
 930         return children[0]-&gt;clickPoint();
 931 
 932     if (isLink())
 933         return linkClickPoint();
 934 
 935     // use the default position unless this is an editable web area, in which case we use the selection bounds.
 936     if (!isWebArea() || !canSetValueAttribute())
 937         return AccessibilityObject::clickPoint();
 938 
 939     VisibleSelection visSelection = selection();
 940     VisiblePositionRange range = VisiblePositionRange(visSelection.visibleStart(), visSelection.visibleEnd());
 941     IntRect bounds = boundsForVisiblePositionRange(range);
 942     return { bounds.x() + (bounds.width() / 2), bounds.y() + (bounds.height() / 2) };
 943 }
 944 
 945 AccessibilityObject* AccessibilityRenderObject::internalLinkElement() const
 946 {
 947     Element* element = anchorElement();
 948     // Right now, we do not support ARIA links as internal link elements
 949     if (!is&lt;HTMLAnchorElement&gt;(element))
 950         return nullptr;
 951     HTMLAnchorElement&amp; anchor = downcast&lt;HTMLAnchorElement&gt;(*element);
 952 
 953     URL linkURL = anchor.href();
 954     String fragmentIdentifier = linkURL.fragmentIdentifier();
 955     if (fragmentIdentifier.isEmpty())
 956         return nullptr;
 957 
 958     // check if URL is the same as current URL
 959     URL documentURL = m_renderer-&gt;document().url();
 960     if (!equalIgnoringFragmentIdentifier(documentURL, linkURL))
 961         return nullptr;
 962 
 963     Node* linkedNode = m_renderer-&gt;document().findAnchor(fragmentIdentifier);
 964     if (!linkedNode)
 965         return nullptr;
 966 
 967     // The element we find may not be accessible, so find the first accessible object.
 968     return firstAccessibleObjectFromNode(linkedNode);
 969 }
 970 
 971 OptionSet&lt;SpeakAs&gt; AccessibilityRenderObject::speakAsProperty() const
 972 {
 973     if (!m_renderer)
 974         return AccessibilityObject::speakAsProperty();
 975 
 976     return m_renderer-&gt;style().speakAs();
 977 }
 978 
 979 void AccessibilityRenderObject::addRadioButtonGroupChildren(AccessibilityObject* parent, AccessibilityChildrenVector&amp; linkedUIElements) const
 980 {
 981     for (const auto&amp; child : parent-&gt;children()) {
 982         if (child-&gt;roleValue() == AccessibilityRole::RadioButton)
 983             linkedUIElements.append(child);
 984         else
 985             addRadioButtonGroupChildren(child.get(), linkedUIElements);
 986     }
 987 }
 988 
 989 void AccessibilityRenderObject::addRadioButtonGroupMembers(AccessibilityChildrenVector&amp; linkedUIElements) const
 990 {
 991     if (roleValue() != AccessibilityRole::RadioButton)
 992         return;
 993 
 994     Node* node = this-&gt;node();
 995     if (is&lt;HTMLInputElement&gt;(node)) {
 996         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 997         for (auto&amp; radioSibling : input.radioButtonGroup()) {
 998             if (AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(radioSibling))
 999                 linkedUIElements.append(object);
1000         }
1001     } else {
1002         // If we didn&#39;t find any radio button siblings with the traditional naming, lets search for a radio group role and find its children.
1003         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1004             if (parent-&gt;roleValue() == AccessibilityRole::RadioGroup)
1005                 addRadioButtonGroupChildren(parent, linkedUIElements);
1006         }
1007     }
1008 }
1009 
1010 // linked ui elements could be all the related radio buttons in a group
1011 // or an internal anchor connection
1012 void AccessibilityRenderObject::linkedUIElements(AccessibilityChildrenVector&amp; linkedUIElements) const
1013 {
1014     ariaFlowToElements(linkedUIElements);
1015 
1016     if (isLink()) {
1017         AccessibilityObject* linkedAXElement = internalLinkElement();
1018         if (linkedAXElement)
1019             linkedUIElements.append(linkedAXElement);
1020     }
1021 
1022     if (roleValue() == AccessibilityRole::RadioButton)
1023         addRadioButtonGroupMembers(linkedUIElements);
1024 }
1025 
1026 bool AccessibilityRenderObject::hasTextAlternative() const
1027 {
1028     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
1029     // override the &quot;label&quot; element association.
1030     return ariaAccessibilityDescription().length();
1031 }
1032 
1033 bool AccessibilityRenderObject::hasPopup() const
1034 {
1035     // Return true if this has the aria-haspopup attribute, or if it has an ancestor of type link with the aria-haspopup attribute.
1036     return AccessibilityObject::matchedParent(*this, true, [this] (const AccessibilityObject&amp; object) {
1037         return (this == &amp;object) ? !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;)
1038             : object.isLink() &amp;&amp; !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;);
1039     });
1040 }
1041 
1042 bool AccessibilityRenderObject::supportsARIADropping() const
1043 {
1044     const AtomString&amp; dropEffect = getAttribute(aria_dropeffectAttr);
1045     return !dropEffect.isEmpty();
1046 }
1047 
1048 bool AccessibilityRenderObject::supportsARIADragging() const
1049 {
1050     const AtomString&amp; grabbed = getAttribute(aria_grabbedAttr);
1051     return equalLettersIgnoringASCIICase(grabbed, &quot;true&quot;) || equalLettersIgnoringASCIICase(grabbed, &quot;false&quot;);
1052 }
1053 
1054 bool AccessibilityRenderObject::isARIAGrabbed()
1055 {
1056     return elementAttributeValue(aria_grabbedAttr);
1057 }
1058 
1059 Vector&lt;String&gt; AccessibilityRenderObject::determineARIADropEffects()
1060 {
1061     const AtomString&amp; dropEffects = getAttribute(aria_dropeffectAttr);
1062     if (dropEffects.isEmpty()) {
1063         return { };
1064     }
1065 
1066     String dropEffectsString = dropEffects.string();
1067     dropEffectsString.replace(&#39;\n&#39;, &#39; &#39;);
1068     return dropEffectsString.split(&#39; &#39;);
1069 }
1070 
1071 bool AccessibilityRenderObject::exposesTitleUIElement() const
1072 {
1073     if (!isControl() &amp;&amp; !isFigureElement())
1074         return false;
1075 
1076     // If this control is ignored (because it&#39;s invisible),
1077     // then the label needs to be exposed so it can be visible to accessibility.
1078     if (accessibilityIsIgnored())
1079         return true;
1080 
1081     // When controls have their own descriptions, the title element should be ignored.
1082     if (hasTextAlternative())
1083         return false;
1084 
1085     // When &lt;label&gt; element has aria-label or aria-labelledby on it, we shouldn&#39;t expose it as the
1086     // titleUIElement, otherwise its inner text will be announced by a screenreader.
1087     if (isLabelable()) {
1088         if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node()))) {
1089             if (!label-&gt;attributeWithoutSynchronization(aria_labelAttr).isEmpty())
1090                 return false;
1091             if (AccessibilityObject* labelObject = axObjectCache()-&gt;getOrCreate(label)) {
1092                 if (!labelObject-&gt;ariaLabeledByAttribute().isEmpty())
1093                     return false;
1094                 // To simplify instances where the labeling element includes widget descendants
1095                 // which it does not label.
1096                 if (is&lt;AccessibilityLabel&gt;(*labelObject)
1097                     &amp;&amp; downcast&lt;AccessibilityLabel&gt;(*labelObject).containsUnrelatedControls())
1098                     return false;
1099             }
1100         }
1101     }
1102 
1103     return true;
1104 }
1105 
1106 #if ENABLE(APPLE_PAY)
1107 String AccessibilityRenderObject::applePayButtonDescription() const
1108 {
1109     switch (applePayButtonType()) {
1110     case ApplePayButtonType::Plain:
1111         return AXApplePayPlainLabel();
1112     case ApplePayButtonType::Buy:
1113         return AXApplePayBuyLabel();
1114     case ApplePayButtonType::SetUp:
1115         return AXApplePaySetupLabel();
1116     case ApplePayButtonType::Donate:
1117         return AXApplePayDonateLabel();
1118 #if ENABLE(APPLE_PAY_SESSION_V4)
1119     case ApplePayButtonType::CheckOut:
1120         return AXApplePayCheckOutLabel();
1121     case ApplePayButtonType::Book:
1122         return AXApplePayBookLabel();
1123     case ApplePayButtonType::Subscribe:
1124         return AXApplePaySubscribeLabel();
1125 #endif
1126     }
1127 }
1128 #endif
1129 
1130 void AccessibilityRenderObject::titleElementText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1131 {
1132 #if ENABLE(APPLE_PAY)
1133     if (isApplePayButton()) {
1134         textOrder.append(AccessibilityText(applePayButtonDescription(), AccessibilityTextSource::Alternative));
1135         return;
1136     }
1137 #endif
1138 
1139     AccessibilityNodeObject::titleElementText(textOrder);
1140 }
1141 
1142 AccessibilityObject* AccessibilityRenderObject::titleUIElement() const
1143 {
1144     if (!m_renderer)
1145         return nullptr;
1146 
1147     // if isFieldset is true, the renderer is guaranteed to be a RenderFieldset
1148     if (isFieldset())
1149         return axObjectCache()-&gt;getOrCreate(downcast&lt;RenderBlock&gt;(*m_renderer).findFieldsetLegend(RenderBlock::FieldsetIncludeFloatingOrOutOfFlow));
1150 
1151     if (isFigureElement())
1152         return captionForFigure();
1153 
1154     Node* node = m_renderer-&gt;node();
1155     if (!is&lt;Element&gt;(node))
1156         return nullptr;
1157     HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node));
1158     if (label &amp;&amp; label-&gt;renderer())
1159         return axObjectCache()-&gt;getOrCreate(label);
1160 
1161     return nullptr;
1162 }
1163 
1164 bool AccessibilityRenderObject::isAllowedChildOfTree() const
1165 {
1166     // Determine if this is in a tree. If so, we apply special behavior to make it work like an AXOutline.
1167     AccessibilityObject* axObj = parentObject();
1168     bool isInTree = false;
1169     bool isTreeItemDescendant = false;
1170     while (axObj) {
1171         if (axObj-&gt;roleValue() == AccessibilityRole::TreeItem)
1172             isTreeItemDescendant = true;
1173         if (axObj-&gt;isTree()) {
1174             isInTree = true;
1175             break;
1176         }
1177         axObj = axObj-&gt;parentObject();
1178     }
1179 
1180     // If the object is in a tree, only tree items should be exposed (and the children of tree items).
1181     if (isInTree) {
1182         AccessibilityRole role = roleValue();
1183         if (role != AccessibilityRole::TreeItem &amp;&amp; role != AccessibilityRole::StaticText &amp;&amp; !isTreeItemDescendant)
1184             return false;
1185     }
1186     return true;
1187 }
1188 
1189 static AccessibilityObjectInclusion objectInclusionFromAltText(const String&amp; altText)
1190 {
1191     // Don&#39;t ignore an image that has an alt tag.
1192     if (!altText.isAllSpecialCharacters&lt;isHTMLSpace&gt;())
1193         return AccessibilityObjectInclusion::IncludeObject;
1194 
1195     // The informal standard is to ignore images with zero-length alt strings.
1196     if (!altText.isNull())
1197         return AccessibilityObjectInclusion::IgnoreObject;
1198 
1199     return AccessibilityObjectInclusion::DefaultBehavior;
1200 }
1201 
1202 AccessibilityObjectInclusion AccessibilityRenderObject::defaultObjectInclusion() const
1203 {
1204     // The following cases can apply to any element that&#39;s a subclass of AccessibilityRenderObject.
1205 
1206     if (!m_renderer)
1207         return AccessibilityObjectInclusion::IgnoreObject;
1208 
1209     if (m_renderer-&gt;style().visibility() != Visibility::Visible) {
1210         // aria-hidden is meant to override visibility as the determinant in AX hierarchy inclusion.
1211         if (equalLettersIgnoringASCIICase(getAttribute(aria_hiddenAttr), &quot;false&quot;))
1212             return AccessibilityObjectInclusion::DefaultBehavior;
1213 
1214         return AccessibilityObjectInclusion::IgnoreObject;
1215     }
1216 
1217     return AccessibilityObject::defaultObjectInclusion();
1218 }
1219 
1220 static bool webAreaIsPresentational(RenderObject* renderer)
1221 {
1222     if (!renderer || !is&lt;RenderView&gt;(*renderer))
1223         return false;
1224 
1225     if (auto ownerElement = renderer-&gt;document().ownerElement())
1226         return nodeHasPresentationRole(ownerElement);
1227 
1228     return false;
1229 }
1230 
1231 bool AccessibilityRenderObject::computeAccessibilityIsIgnored() const
1232 {
1233 #ifndef NDEBUG
1234     ASSERT(m_initialized);
1235 #endif
1236 
1237     if (!m_renderer)
1238         return true;
1239 
1240     // Check first if any of the common reasons cause this element to be ignored.
1241     // Then process other use cases that need to be applied to all the various roles
1242     // that AccessibilityRenderObjects take on.
1243     AccessibilityObjectInclusion decision = defaultObjectInclusion();
1244     if (decision == AccessibilityObjectInclusion::IncludeObject)
1245         return false;
1246     if (decision == AccessibilityObjectInclusion::IgnoreObject)
1247         return true;
1248 
1249     // If this element is within a parent that cannot have children, it should not be exposed.
1250     if (isDescendantOfBarrenParent())
1251         return true;
1252 
1253     if (roleValue() == AccessibilityRole::Ignored)
1254         return true;
1255 
1256     if (roleValue() == AccessibilityRole::Presentational || inheritsPresentationalRole())
1257         return true;
1258 
1259     // WebAreas should be ignored if their iframe container is marked as presentational.
1260     if (webAreaIsPresentational(renderer()))
1261         return true;
1262 
1263     // An ARIA tree can only have tree items and static text as children.
1264     if (!isAllowedChildOfTree())
1265         return true;
1266 
1267     // Allow the platform to decide if the attachment is ignored or not.
1268     if (isAttachment())
1269         return accessibilityIgnoreAttachment();
1270 
1271     // ignore popup menu items because AppKit does
1272     if (m_renderer &amp;&amp; ancestorsOfType&lt;RenderMenuList&gt;(*m_renderer).first())
1273         return true;
1274 
1275     // https://webkit.org/b/161276 Getting the controlObject might cause the m_renderer to be nullptr.
1276     if (!m_renderer)
1277         return true;
1278 
1279     if (m_renderer-&gt;isBR())
1280         return true;
1281 
1282     if (is&lt;RenderText&gt;(*m_renderer)) {
1283         // static text beneath MenuItems and MenuButtons are just reported along with the menu item, so it&#39;s ignored on an individual level
1284         AccessibilityObject* parent = parentObjectUnignored();
1285         if (parent &amp;&amp; (parent-&gt;isMenuItem() || parent-&gt;ariaRoleAttribute() == AccessibilityRole::MenuButton))
1286             return true;
1287         auto&amp; renderText = downcast&lt;RenderText&gt;(*m_renderer);
1288         if (!renderText.hasRenderedText())
1289             return true;
1290 
1291         if (renderText.parent()-&gt;isFirstLetter())
1292             return true;
1293 
1294         // static text beneath TextControls is reported along with the text control text so it&#39;s ignored.
1295         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1296             if (parent-&gt;roleValue() == AccessibilityRole::TextField)
1297                 return true;
1298         }
1299 
1300         // Walking up the parent chain might reset the m_renderer.
1301         if (!m_renderer)
1302             return true;
1303 
1304         // The alt attribute may be set on a text fragment through CSS, which should be honored.
1305         if (is&lt;RenderTextFragment&gt;(renderText)) {
1306             AccessibilityObjectInclusion altTextInclusion = objectInclusionFromAltText(downcast&lt;RenderTextFragment&gt;(renderText).altText());
1307             if (altTextInclusion == AccessibilityObjectInclusion::IgnoreObject)
1308                 return true;
1309             if (altTextInclusion == AccessibilityObjectInclusion::IncludeObject)
1310                 return false;
1311         }
1312 
1313         // text elements that are just empty whitespace should not be returned
1314         return renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
1315     }
1316 
1317     if (isHeading())
1318         return false;
1319 
1320     if (isLink())
1321         return false;
1322 
1323     if (isLandmark())
1324         return false;
1325 
1326     // all controls are accessible
1327     if (isControl())
1328         return false;
1329 
1330     if (isFigureElement())
1331         return false;
1332 
1333     switch (roleValue()) {
1334     case AccessibilityRole::Audio:
1335     case AccessibilityRole::DescriptionListTerm:
1336     case AccessibilityRole::DescriptionListDetail:
1337     case AccessibilityRole::Details:
1338     case AccessibilityRole::DocumentArticle:
1339     case AccessibilityRole::Footer:
1340     case AccessibilityRole::LandmarkRegion:
1341     case AccessibilityRole::ListItem:
1342     case AccessibilityRole::Time:
1343     case AccessibilityRole::Video:
1344         return false;
1345     default:
1346         break;
1347     }
1348 
1349     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
1350         return false;
1351 
1352     if (roleValue() == AccessibilityRole::HorizontalRule)
1353         return false;
1354 
1355     // don&#39;t ignore labels, because they serve as TitleUIElements
1356     Node* node = m_renderer-&gt;node();
1357     if (is&lt;HTMLLabelElement&gt;(node))
1358         return false;
1359 
1360     // Anything that is content editable should not be ignored.
1361     // However, one cannot just call node-&gt;hasEditableStyle() since that will ask if its parents
1362     // are also editable. Only the top level content editable region should be exposed.
1363     if (hasContentEditableAttributeSet())
1364         return false;
1365 
1366 
1367     // if this element has aria attributes on it, it should not be ignored.
1368     if (supportsARIAAttributes())
1369         return false;
1370 
1371 #if ENABLE(MATHML)
1372     // First check if this is a special case within the math tree that needs to be ignored.
1373     if (isIgnoredElementWithinMathTree())
1374         return true;
1375     // Otherwise all other math elements are in the tree.
1376     if (isMathElement())
1377         return false;
1378 #endif
1379 
1380     if (is&lt;RenderBlockFlow&gt;(*m_renderer) &amp;&amp; m_renderer-&gt;childrenInline() &amp;&amp; !canSetFocusAttribute())
1381         return !downcast&lt;RenderBlockFlow&gt;(*m_renderer).hasLines() &amp;&amp; !mouseButtonListener();
1382 
1383     // ignore images seemingly used as spacers
1384     if (isImage()) {
1385 
1386         // If the image can take focus, it should not be ignored, lest the user not be able to interact with something important.
1387         if (canSetFocusAttribute())
1388             return false;
1389 
1390         // First check the RenderImage&#39;s altText (which can be set through a style sheet, or come from the Element).
1391         // However, if this is not a native image, fallback to the attribute on the Element.
1392         AccessibilityObjectInclusion altTextInclusion = AccessibilityObjectInclusion::DefaultBehavior;
1393         bool isRenderImage = is&lt;RenderImage&gt;(renderer());
1394         if (isRenderImage)
1395             altTextInclusion = objectInclusionFromAltText(downcast&lt;RenderImage&gt;(*m_renderer).altText());
1396         else
1397             altTextInclusion = objectInclusionFromAltText(getAttribute(altAttr).string());
1398 
1399         if (altTextInclusion == AccessibilityObjectInclusion::IgnoreObject)
1400             return true;
1401         if (altTextInclusion == AccessibilityObjectInclusion::IncludeObject)
1402             return false;
1403 
1404         // If an image has a title attribute on it, accessibility should be lenient and allow it to appear in the hierarchy (according to WAI-ARIA).
1405         if (!getAttribute(titleAttr).isEmpty())
1406             return false;
1407 
1408         if (isRenderImage) {
1409             // check for one-dimensional image
1410             RenderImage&amp; image = downcast&lt;RenderImage&gt;(*m_renderer);
1411             if (image.height() &lt;= 1 || image.width() &lt;= 1)
1412                 return true;
1413 
1414             // check whether rendered image was stretched from one-dimensional file image
1415             if (image.cachedImage()) {
1416                 LayoutSize imageSize = image.cachedImage()-&gt;imageSizeForRenderer(&amp;image, image.view().zoomFactor());
1417                 return imageSize.height() &lt;= 1 || imageSize.width() &lt;= 1;
1418             }
1419         }
1420         return false;
1421     }
1422 
1423     if (isCanvas()) {
1424         if (canvasHasFallbackContent())
1425             return false;
1426 
1427         if (is&lt;RenderBox&gt;(*m_renderer)) {
1428             auto&amp; canvasBox = downcast&lt;RenderBox&gt;(*m_renderer);
1429             if (canvasBox.height() &lt;= 1 || canvasBox.width() &lt;= 1)
1430                 return true;
1431         }
1432         // Otherwise fall through; use presence of help text, title, or description to decide.
1433     }
1434 
1435     if (m_renderer-&gt;isListMarker()) {
1436         AccessibilityObject* parent = parentObjectUnignored();
1437         return parent &amp;&amp; !parent-&gt;isListItem();
1438     }
1439 
1440     if (isWebArea())
1441         return false;
1442 
1443 #if ENABLE(METER_ELEMENT)
1444     // The render tree of meter includes a RenderBlock (meter) and a RenderMeter (div).
1445     // We expose the latter and thus should ignore the former. However, if the author
1446     // includes a title attribute on the element, hasAttributesRequiredForInclusion()
1447     // will return true, potentially resulting in a redundant accessible object.
1448     if (is&lt;HTMLMeterElement&gt;(node))
1449         return true;
1450 #endif
1451 
1452     // Using the presence of an accessible name to decide an element&#39;s visibility is not
1453     // as definitive as previous checks, so this should remain as one of the last.
1454     if (hasAttributesRequiredForInclusion())
1455         return false;
1456 
1457     // Don&#39;t ignore generic focusable elements like &lt;div tabindex=0&gt;
1458     // unless they&#39;re completely empty, with no children.
1459     if (isGenericFocusableElement() &amp;&amp; node-&gt;firstChild())
1460         return false;
1461 
1462     // &lt;span&gt; tags are inline tags and not meant to convey information if they have no other aria
1463     // information on them. If we don&#39;t ignore them, they may emit signals expected to come from
1464     // their parent. In addition, because included spans are AccessibilityRole::Group objects, and AccessibilityRole::Group
1465     // objects are often containers with meaningful information, the inclusion of a span can have
1466     // the side effect of causing the immediate parent accessible to be ignored. This is especially
1467     // problematic for platforms which have distinct roles for textual block elements.
1468     if (node &amp;&amp; node-&gt;hasTagName(spanTag))
1469         return true;
1470 
1471     // Other non-ignored host language elements
1472     if (node &amp;&amp; node-&gt;hasTagName(dfnTag))
1473         return false;
1474 
1475     if (isStyleFormatGroup())
1476         return false;
1477 
1478     // Make sure that ruby containers are not ignored.
1479     if (m_renderer-&gt;isRubyRun() || m_renderer-&gt;isRubyBlock() || m_renderer-&gt;isRubyInline())
1480         return false;
1481 
1482     // Find out if this element is inside of a label element.
1483     // If so, it may be ignored because it&#39;s the label for a checkbox or radio button.
1484     AccessibilityObject* controlObject = correspondingControlForLabelElement();
1485     if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement() &amp;&amp; controlObject-&gt;isCheckboxOrRadio())
1486         return true;
1487 
1488     // By default, objects should be ignored so that the AX hierarchy is not
1489     // filled with unnecessary items.
1490     return true;
1491 }
1492 
1493 bool AccessibilityRenderObject::isLoaded() const
1494 {
1495     return !m_renderer-&gt;document().parser();
1496 }
1497 
1498 double AccessibilityRenderObject::estimatedLoadingProgress() const
1499 {
1500     if (!m_renderer)
1501         return 0;
1502 
1503     if (isLoaded())
1504         return 1.0;
1505 
1506     return m_renderer-&gt;page().progress().estimatedProgress();
1507 }
1508 
1509 int AccessibilityRenderObject::layoutCount() const
1510 {
1511     if (!m_renderer || !is&lt;RenderView&gt;(*m_renderer))
1512         return 0;
1513     return downcast&lt;RenderView&gt;(*m_renderer).frameView().layoutContext().layoutCount();
1514 }
1515 
1516 String AccessibilityRenderObject::text() const
1517 {
1518     if (isPasswordField())
1519         return passwordFieldValue();
1520 
1521     return AccessibilityNodeObject::text();
1522 }
1523 
1524 int AccessibilityRenderObject::textLength() const
1525 {
1526     ASSERT(isTextControl());
1527 
1528     if (isPasswordField())
1529         return passwordFieldValue().length();
1530 
1531     return text().length();
1532 }
1533 
1534 PlainTextRange AccessibilityRenderObject::documentBasedSelectedTextRange() const
1535 {
1536     Node* node = m_renderer-&gt;node();
1537     if (!node)
1538         return PlainTextRange();
1539 
1540     VisibleSelection visibleSelection = selection();
1541     RefPtr&lt;Range&gt; currentSelectionRange = visibleSelection.toNormalizedRange();
1542     if (!currentSelectionRange)
1543         return PlainTextRange();
1544     // FIXME: The reason this does the correct thing when the selection is in the
1545     // shadow tree of an input element is that we get an exception below, and we
1546     // choose to interpret all exceptions as &quot;does not intersect&quot;. Seems likely
1547     // that does not handle all cases correctly.
1548     auto intersectsResult = currentSelectionRange-&gt;intersectsNode(*node);
1549     if (!intersectsResult.hasException() &amp;&amp; !intersectsResult.releaseReturnValue())
1550         return PlainTextRange();
1551 
1552     int start = indexForVisiblePosition(visibleSelection.start());
1553     int end = indexForVisiblePosition(visibleSelection.end());
1554 
1555     return PlainTextRange(start, end - start);
1556 }
1557 
1558 String AccessibilityRenderObject::selectedText() const
1559 {
1560     ASSERT(isTextControl());
1561 
1562     if (isPasswordField())
1563         return String(); // need to return something distinct from empty string
1564 
1565     if (isNativeTextControl()) {
1566         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1567         return textControl.selectedText();
1568     }
1569 
1570     return doAXStringForRange(documentBasedSelectedTextRange());
1571 }
1572 
1573 const AtomString&amp; AccessibilityRenderObject::accessKey() const
1574 {
1575     Node* node = m_renderer-&gt;node();
1576     if (!is&lt;Element&gt;(node))
1577         return nullAtom();
1578     return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
1579 }
1580 
1581 VisibleSelection AccessibilityRenderObject::selection() const
1582 {
1583     return m_renderer-&gt;frame().selection().selection();
1584 }
1585 
1586 PlainTextRange AccessibilityRenderObject::selectedTextRange() const
1587 {
1588     ASSERT(isTextControl());
1589 
1590     if (isPasswordField())
1591         return PlainTextRange();
1592 
1593     AccessibilityRole ariaRole = ariaRoleAttribute();
1594     // Use the text control native range if it&#39;s a native object and it has no ARIA role (or has a text based ARIA role).
1595     if (isNativeTextControl() &amp;&amp; (ariaRole == AccessibilityRole::Unknown || isARIATextControl())) {
1596         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1597         return PlainTextRange(textControl.selectionStart(), textControl.selectionEnd() - textControl.selectionStart());
1598     }
1599 
1600     return documentBasedSelectedTextRange();
1601 }
1602 
1603 static void setTextSelectionIntent(AXObjectCache* cache, AXTextStateChangeType type)
1604 {
1605     if (!cache)
1606         return;
1607     AXTextStateChangeIntent intent(type, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false });
1608     cache-&gt;setTextSelectionIntent(intent);
1609     cache-&gt;setIsSynchronizingSelection(true);
1610 }
1611 
1612 static void clearTextSelectionIntent(AXObjectCache* cache)
1613 {
1614     if (!cache)
1615         return;
1616     cache-&gt;setTextSelectionIntent(AXTextStateChangeIntent());
1617     cache-&gt;setIsSynchronizingSelection(false);
1618 }
1619 
1620 void AccessibilityRenderObject::setSelectedTextRange(const PlainTextRange&amp; range)
1621 {
1622     setTextSelectionIntent(axObjectCache(), range.length ? AXTextStateChangeTypeSelectionExtend : AXTextStateChangeTypeSelectionMove);
1623 
1624     if (isNativeTextControl()) {
1625         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1626         textControl.setSelectionRange(range.start, range.start + range.length);
1627     } else {
1628         auto node = this-&gt;node();
1629         ASSERT(node);
1630         VisiblePosition start = visiblePositionForIndexUsingCharacterIterator(*node, range.start);
1631         VisiblePosition end = visiblePositionForIndexUsingCharacterIterator(*node, range.start + range.length);
1632         m_renderer-&gt;frame().selection().setSelection(VisibleSelection(start, end), FrameSelection::defaultSetSelectionOptions(UserTriggered));
1633     }
1634 
1635     clearTextSelectionIntent(axObjectCache());
1636 }
1637 
1638 URL AccessibilityRenderObject::url() const
1639 {
1640     if (isLink() &amp;&amp; is&lt;HTMLAnchorElement&gt;(*m_renderer-&gt;node())) {
1641         if (HTMLAnchorElement* anchor = downcast&lt;HTMLAnchorElement&gt;(anchorElement()))
1642             return anchor-&gt;href();
1643     }
1644 
1645     if (isWebArea())
1646         return m_renderer-&gt;document().url();
1647 
1648     if (isImage() &amp;&amp; is&lt;HTMLImageElement&gt;(m_renderer-&gt;node()))
1649         return downcast&lt;HTMLImageElement&gt;(*m_renderer-&gt;node()).src();
1650 
1651     if (isInputImage())
1652         return downcast&lt;HTMLInputElement&gt;(*m_renderer-&gt;node()).src();
1653 
1654     return URL();
1655 }
1656 
1657 bool AccessibilityRenderObject::isUnvisited() const
1658 {
1659     if (!m_renderer)
1660         return true;
1661 
1662     // FIXME: Is it a privacy violation to expose unvisited information to accessibility APIs?
1663     return m_renderer-&gt;style().isLink() &amp;&amp; m_renderer-&gt;style().insideLink() == InsideLink::InsideUnvisited;
1664 }
1665 
1666 bool AccessibilityRenderObject::isVisited() const
1667 {
1668     if (!m_renderer)
1669         return false;
1670 
1671     // FIXME: Is it a privacy violation to expose visited information to accessibility APIs?
1672     return m_renderer-&gt;style().isLink() &amp;&amp; m_renderer-&gt;style().insideLink() == InsideLink::InsideVisited;
1673 }
1674 
1675 void AccessibilityRenderObject::setElementAttributeValue(const QualifiedName&amp; attributeName, bool value)
1676 {
1677     if (!m_renderer)
1678         return;
1679 
1680     Node* node = m_renderer-&gt;node();
1681     if (!is&lt;Element&gt;(node))
1682         return;
1683 
1684     downcast&lt;Element&gt;(*node).setAttribute(attributeName, (value) ? &quot;true&quot; : &quot;false&quot;);
1685 }
1686 
1687 bool AccessibilityRenderObject::elementAttributeValue(const QualifiedName&amp; attributeName) const
1688 {
1689     if (!m_renderer)
1690         return false;
1691 
1692     return equalLettersIgnoringASCIICase(getAttribute(attributeName), &quot;true&quot;);
1693 }
1694 
1695 bool AccessibilityRenderObject::isSelected() const
1696 {
1697     if (!m_renderer)
1698         return false;
1699 
1700     if (!m_renderer-&gt;node())
1701         return false;
1702 
1703     if (equalLettersIgnoringASCIICase(getAttribute(aria_selectedAttr), &quot;true&quot;))
1704         return true;
1705 
1706     if (isTabItem() &amp;&amp; isTabItemSelected())
1707         return true;
1708 
1709     // Menu items are considered selectable by assistive technologies
1710     if (isMenuItem())
1711         return isFocused() || parentObjectUnignored()-&gt;activeDescendant() == this;
1712 
1713     return false;
1714 }
1715 
1716 bool AccessibilityRenderObject::isTabItemSelected() const
1717 {
1718     if (!isTabItem() || !m_renderer)
1719         return false;
1720 
1721     Node* node = m_renderer-&gt;node();
1722     if (!node || !node-&gt;isElementNode())
1723         return false;
1724 
1725     // The ARIA spec says a tab item can also be selected if it is aria-labeled by a tabpanel
1726     // that has keyboard focus inside of it, or if a tabpanel in its aria-controls list has KB
1727     // focus inside of it.
1728     AccessibilityObject* focusedElement = static_cast&lt;AccessibilityObject*&gt;(focusedUIElement());
1729     if (!focusedElement)
1730         return false;
1731 
1732     Vector&lt;Element*&gt; elements;
1733     elementsFromAttribute(elements, aria_controlsAttr);
1734 
1735     AXObjectCache* cache = axObjectCache();
1736     if (!cache)
1737         return false;
1738 
1739     for (const auto&amp; element : elements) {
1740         AccessibilityObject* tabPanel = cache-&gt;getOrCreate(element);
1741 
1742         // A tab item should only control tab panels.
1743         if (!tabPanel || tabPanel-&gt;roleValue() != AccessibilityRole::TabPanel)
1744             continue;
1745 
1746         AccessibilityObject* checkFocusElement = focusedElement;
1747         // Check if the focused element is a descendant of the element controlled by the tab item.
1748         while (checkFocusElement) {
1749             if (tabPanel == checkFocusElement)
1750                 return true;
1751             checkFocusElement = checkFocusElement-&gt;parentObject();
1752         }
1753     }
1754 
1755     return false;
1756 }
1757 
1758 bool AccessibilityRenderObject::isFocused() const
1759 {
1760     if (!m_renderer)
1761         return false;
1762 
1763     Document&amp; document = m_renderer-&gt;document();
1764 
1765     Element* focusedElement = document.focusedElement();
1766     if (!focusedElement)
1767         return false;
1768 
1769     // A web area is represented by the Document node in the DOM tree, which isn&#39;t focusable.
1770     // Check instead if the frame&#39;s selection controller is focused
1771     if (focusedElement == m_renderer-&gt;node()
1772         || (roleValue() == AccessibilityRole::WebArea &amp;&amp; document.frame()-&gt;selection().isFocusedAndActive()))
1773         return true;
1774 
1775     return false;
1776 }
1777 
1778 void AccessibilityRenderObject::setFocused(bool on)
1779 {
1780     if (!canSetFocusAttribute())
1781         return;
1782 
1783     Document* document = this-&gt;document();
1784     Node* node = this-&gt;node();
1785 
1786     if (!on || !is&lt;Element&gt;(node)) {
1787         document-&gt;setFocusedElement(nullptr);
1788         return;
1789     }
1790 
1791     // When a node is told to set focus, that can cause it to be deallocated, which means that doing
1792     // anything else inside this object will crash. To fix this, we added a RefPtr to protect this object
1793     // long enough for duration.
1794     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1795 
1796     // If this node is already the currently focused node, then calling focus() won&#39;t do anything.
1797     // That is a problem when focus is removed from the webpage to chrome, and then returns.
1798     // In these cases, we need to do what keyboard and mouse focus do, which is reset focus first.
1799     if (document-&gt;focusedElement() == node)
1800         document-&gt;setFocusedElement(nullptr);
1801 
1802     // If we return from setFocusedElement and our element has been removed from a tree, axObjectCache() may be null.
1803     if (AXObjectCache* cache = axObjectCache()) {
1804         cache-&gt;setIsSynchronizingSelection(true);
1805         downcast&lt;Element&gt;(*node).focus();
1806         cache-&gt;setIsSynchronizingSelection(false);
1807     }
1808 }
1809 
1810 void AccessibilityRenderObject::setSelectedRows(AccessibilityChildrenVector&amp; selectedRows)
1811 {
1812     // Setting selected only makes sense in trees and tables (and tree-tables).
1813     AccessibilityRole role = roleValue();
1814     if (role != AccessibilityRole::Tree &amp;&amp; role != AccessibilityRole::TreeGrid &amp;&amp; role != AccessibilityRole::Table &amp;&amp; role != AccessibilityRole::Grid)
1815         return;
1816 
1817     bool isMulti = isMultiSelectable();
1818     unsigned count = selectedRows.size();
1819     if (count &gt; 1 &amp;&amp; !isMulti)
1820         count = 1;
1821 
1822     for (const auto&amp; selectedRow : selectedRows)
1823         selectedRow-&gt;setSelected(true);
1824 }
1825 
1826 void AccessibilityRenderObject::setValue(const String&amp; string)
1827 {
1828     if (!m_renderer || !is&lt;Element&gt;(m_renderer-&gt;node()))
1829         return;
1830 
1831     Element&amp; element = downcast&lt;Element&gt;(*m_renderer-&gt;node());
1832     RenderObject&amp; renderer = *m_renderer;
1833 
1834     // We should use the editor&#39;s insertText to mimic typing into the field.
1835     // Also only do this when the field is in editing mode.
1836     if (Frame* frame = renderer.document().frame()) {
1837         Editor&amp; editor = frame-&gt;editor();
1838         if (element.shouldUseInputMethod()) {
1839             editor.clearText();
1840             editor.insertText(string, nullptr);
1841             return;
1842         }
1843     }
1844     // FIXME: Do we want to do anything here for ARIA textboxes?
1845     if (renderer.isTextField() &amp;&amp; is&lt;HTMLInputElement&gt;(element))
1846         downcast&lt;HTMLInputElement&gt;(element).setValue(string);
1847     else if (renderer.isTextArea() &amp;&amp; is&lt;HTMLTextAreaElement&gt;(element))
1848         downcast&lt;HTMLTextAreaElement&gt;(element).setValue(string);
1849 }
1850 
1851 bool AccessibilityRenderObject::supportsARIAOwns() const
1852 {
1853     if (!m_renderer)
1854         return false;
1855     const AtomString&amp; ariaOwns = getAttribute(aria_ownsAttr);
1856 
1857     return !ariaOwns.isEmpty();
1858 }
1859 
1860 RenderView* AccessibilityRenderObject::topRenderer() const
1861 {
1862     Document* topDoc = topDocument();
1863     if (!topDoc)
1864         return nullptr;
1865 
1866     return topDoc-&gt;renderView();
1867 }
1868 
1869 Document* AccessibilityRenderObject::document() const
1870 {
1871     if (!m_renderer)
1872         return nullptr;
1873     return &amp;m_renderer-&gt;document();
1874 }
1875 
1876 Widget* AccessibilityRenderObject::widget() const
1877 {
1878     if (!m_renderer || !is&lt;RenderWidget&gt;(*m_renderer))
1879         return nullptr;
1880     return downcast&lt;RenderWidget&gt;(*m_renderer).widget();
1881 }
1882 
1883 AccessibilityObject* AccessibilityRenderObject::accessibilityParentForImageMap(HTMLMapElement* map) const
1884 {
1885     // find an image that is using this map
1886     if (!map)
1887         return nullptr;
1888 
1889     HTMLImageElement* imageElement = map-&gt;imageElement();
1890     if (!imageElement)
1891         return nullptr;
1892 
1893     if (AXObjectCache* cache = axObjectCache())
1894         return cache-&gt;getOrCreate(imageElement);
1895 
1896     return nullptr;
1897 }
1898 
1899 void AccessibilityRenderObject::getDocumentLinks(AccessibilityChildrenVector&amp; result)
1900 {
1901     Document&amp; document = m_renderer-&gt;document();
1902     Ref&lt;HTMLCollection&gt; links = document.links();
1903     for (unsigned i = 0; auto* current = links-&gt;item(i); ++i) {
1904         if (auto* renderer = current-&gt;renderer()) {
1905             RefPtr&lt;AccessibilityObject&gt; axObject = document.axObjectCache()-&gt;getOrCreate(renderer);
1906             ASSERT(axObject);
1907             if (!axObject-&gt;accessibilityIsIgnored() &amp;&amp; axObject-&gt;isLink())
1908                 result.append(axObject);
1909         } else {
1910             auto* parent = current-&gt;parentNode();
1911             if (is&lt;HTMLAreaElement&gt;(*current) &amp;&amp; is&lt;HTMLMapElement&gt;(parent)) {
1912                 auto&amp; areaObject = downcast&lt;AccessibilityImageMapLink&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::ImageMapLink));
1913                 HTMLMapElement&amp; map = downcast&lt;HTMLMapElement&gt;(*parent);
1914                 areaObject.setHTMLAreaElement(downcast&lt;HTMLAreaElement&gt;(current));
1915                 areaObject.setHTMLMapElement(&amp;map);
1916                 areaObject.setParent(accessibilityParentForImageMap(&amp;map));
1917 
1918                 result.append(&amp;areaObject);
1919             }
1920         }
1921     }
1922 }
1923 
1924 FrameView* AccessibilityRenderObject::documentFrameView() const
1925 {
1926     if (!m_renderer)
1927         return nullptr;
1928 
1929     // this is the RenderObject&#39;s Document&#39;s Frame&#39;s FrameView
1930     return &amp;m_renderer-&gt;view().frameView();
1931 }
1932 
1933 Widget* AccessibilityRenderObject::widgetForAttachmentView() const
1934 {
1935     if (!isAttachment())
1936         return nullptr;
1937     return downcast&lt;RenderWidget&gt;(*m_renderer).widget();
1938 }
1939 
1940 // This function is like a cross-platform version of - (WebCoreTextMarkerRange*)textMarkerRange. It returns
1941 // a Range that we can convert to a WebCoreTextMarkerRange in the Obj-C file
1942 VisiblePositionRange AccessibilityRenderObject::visiblePositionRange() const
1943 {
1944     if (!m_renderer)
1945         return VisiblePositionRange();
1946 
1947     // construct VisiblePositions for start and end
1948     Node* node = m_renderer-&gt;node();
1949     if (!node)
1950         return VisiblePositionRange();
1951 
1952     VisiblePosition startPos = firstPositionInOrBeforeNode(node);
1953     VisiblePosition endPos = lastPositionInOrAfterNode(node);
1954 
1955     // the VisiblePositions are equal for nodes like buttons, so adjust for that
1956     // FIXME: Really?  [button, 0] and [button, 1] are distinct (before and after the button)
1957     // I expect this code is only hit for things like empty divs?  In which case I don&#39;t think
1958     // the behavior is correct here -- eseidel
1959     if (startPos == endPos) {
1960         endPos = endPos.next();
1961         if (endPos.isNull())
1962             endPos = startPos;
1963     }
1964 
1965     return VisiblePositionRange(startPos, endPos);
1966 }
1967 
1968 VisiblePositionRange AccessibilityRenderObject::visiblePositionRangeForLine(unsigned lineCount) const
1969 {
1970     if (!lineCount || !m_renderer)
1971         return VisiblePositionRange();
1972 
1973     // iterate over the lines
1974     // FIXME: this is wrong when lineNumber is lineCount+1,  because nextLinePosition takes you to the
1975     // last offset of the last line
1976     VisiblePosition visiblePos = m_renderer-&gt;view().positionForPoint(IntPoint(), nullptr);
1977     VisiblePosition savedVisiblePos;
1978     while (--lineCount) {
1979         savedVisiblePos = visiblePos;
1980         visiblePos = nextLinePosition(visiblePos, 0);
1981         if (visiblePos.isNull()
1982             || visiblePos == savedVisiblePos
1983             || visiblePos.equals(savedVisiblePos))
1984             return VisiblePositionRange();
1985     }
1986 
1987     // make a caret selection for the marker position, then extend it to the line
1988     // NOTE: ignores results of sel.modify because it returns false when
1989     // starting at an empty line.  The resulting selection in that case
1990     // will be a caret at visiblePos.
1991     FrameSelection selection;
1992     selection.setSelection(VisibleSelection(visiblePos));
1993     selection.modify(FrameSelection::AlterationExtend, DirectionRight, LineBoundary);
1994 
1995     return VisiblePositionRange(selection.selection().visibleStart(), selection.selection().visibleEnd());
1996 }
1997 
1998 VisiblePosition AccessibilityRenderObject::visiblePositionForIndex(int index) const
1999 {
2000     if (!m_renderer)
2001         return VisiblePosition();
2002 
2003     if (isNativeTextControl())
2004         return downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement().visiblePositionForIndex(index);
2005 
2006     if (!allowsTextRanges() &amp;&amp; !is&lt;RenderText&gt;(*m_renderer))
2007         return VisiblePosition();
2008 
2009     Node* node = m_renderer-&gt;node();
2010     if (!node)
2011         return VisiblePosition();
2012 
2013     return visiblePositionForIndexUsingCharacterIterator(*node, index);
2014 }
2015 
2016 int AccessibilityRenderObject::indexForVisiblePosition(const VisiblePosition&amp; position) const
2017 {
2018     if (isNativeTextControl())
2019         return downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement().indexForVisiblePosition(position);
2020 
2021     if (!isTextControl())
2022         return 0;
2023 
2024     Node* node = m_renderer-&gt;node();
2025     if (!node)
2026         return 0;
2027 
2028     Position indexPosition = position.deepEquivalent();
2029     if (indexPosition.isNull() || highestEditableRoot(indexPosition, HasEditableAXRole) != node)
2030         return 0;
2031 
2032 #if USE(ATK)
2033     // We need to consider replaced elements for GTK, as they will be
2034     // presented with the &#39;object replacement character&#39; (0xFFFC).
2035     bool forSelectionPreservation = true;
2036 #else
2037     bool forSelectionPreservation = false;
2038 #endif
2039 
2040     return WebCore::indexForVisiblePosition(*node, position, forSelectionPreservation);
2041 }
2042 
2043 Element* AccessibilityRenderObject::rootEditableElementForPosition(const Position&amp; position) const
2044 {
2045     // Find the root editable or pseudo-editable (i.e. having an editable ARIA role) element.
2046     Element* result = nullptr;
2047 
2048     Element* rootEditableElement = position.rootEditableElement();
2049 
2050     for (Element* e = position.element(); e &amp;&amp; e != rootEditableElement; e = e-&gt;parentElement()) {
2051         if (nodeIsTextControl(e))
2052             result = e;
2053         if (e-&gt;hasTagName(bodyTag))
2054             break;
2055     }
2056 
2057     if (result)
2058         return result;
2059 
2060     return rootEditableElement;
2061 }
2062 
2063 bool AccessibilityRenderObject::nodeIsTextControl(const Node* node) const
2064 {
2065     if (!node)
2066         return false;
2067 
2068     if (AXObjectCache* cache = axObjectCache()) {
2069         if (AccessibilityObject* axObjectForNode = cache-&gt;getOrCreate(const_cast&lt;Node*&gt;(node)))
2070             return axObjectForNode-&gt;isTextControl();
2071     }
2072 
2073     return false;
2074 }
2075 
2076 IntRect AccessibilityRenderObject::boundsForRects(LayoutRect const&amp; rect1, LayoutRect const&amp; rect2, RefPtr&lt;Range&gt; const&amp; dataRange)
2077 {
2078     LayoutRect ourRect = rect1;
2079     ourRect.unite(rect2);
2080 
2081     // if the rectangle spans lines and contains multiple text chars, use the range&#39;s bounding box intead
2082     if (rect1.maxY() != rect2.maxY()) {
2083         LayoutRect boundingBox = dataRange-&gt;absoluteBoundingBox();
2084         String rangeString = plainText(dataRange.get());
2085         if (rangeString.length() &gt; 1 &amp;&amp; !boundingBox.isEmpty())
2086             ourRect = boundingBox;
2087     }
2088 
2089     return snappedIntRect(ourRect);
2090 }
2091 
2092 IntRect AccessibilityRenderObject::boundsForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange) const
2093 {
2094     if (visiblePositionRange.isNull())
2095         return IntRect();
2096 
2097     // Create a mutable VisiblePositionRange.
2098     VisiblePositionRange range(visiblePositionRange);
2099     LayoutRect rect1 = range.start.absoluteCaretBounds();
2100     LayoutRect rect2 = range.end.absoluteCaretBounds();
2101 
2102     // readjust for position at the edge of a line.  This is to exclude line rect that doesn&#39;t need to be accounted in the range bounds
2103     if (rect2.y() != rect1.y()) {
2104         VisiblePosition endOfFirstLine = endOfLine(range.start);
2105         if (range.start == endOfFirstLine) {
2106             range.start.setAffinity(DOWNSTREAM);
2107             rect1 = range.start.absoluteCaretBounds();
2108         }
2109         if (range.end == endOfFirstLine) {
2110             range.end.setAffinity(UPSTREAM);
2111             rect2 = range.end.absoluteCaretBounds();
2112         }
2113     }
2114 
2115     RefPtr&lt;Range&gt; dataRange = makeRange(range.start, range.end);
2116     return boundsForRects(rect1, rect2, dataRange);
2117 }
2118 
2119 IntRect AccessibilityRenderObject::boundsForRange(const RefPtr&lt;Range&gt; range) const
2120 {
2121     if (!range)
2122         return IntRect();
2123 
2124     AXObjectCache* cache = this-&gt;axObjectCache();
2125     if (!cache)
2126         return IntRect();
2127 
2128     CharacterOffset start = cache-&gt;startOrEndCharacterOffsetForRange(range, true);
2129     CharacterOffset end = cache-&gt;startOrEndCharacterOffsetForRange(range, false);
2130 
2131     LayoutRect rect1 = cache-&gt;absoluteCaretBoundsForCharacterOffset(start);
2132     LayoutRect rect2 = cache-&gt;absoluteCaretBoundsForCharacterOffset(end);
2133 
2134     // readjust for position at the edge of a line. This is to exclude line rect that doesn&#39;t need to be accounted in the range bounds.
2135     if (rect2.y() != rect1.y()) {
2136         CharacterOffset endOfFirstLine = cache-&gt;endCharacterOffsetOfLine(start);
2137         if (start.isEqual(endOfFirstLine)) {
2138             start = cache-&gt;nextCharacterOffset(start, false);
2139             rect1 = cache-&gt;absoluteCaretBoundsForCharacterOffset(start);
2140         }
2141         if (end.isEqual(endOfFirstLine)) {
2142             end = cache-&gt;previousCharacterOffset(end, false);
2143             rect2 = cache-&gt;absoluteCaretBoundsForCharacterOffset(end);
2144         }
2145     }
2146 
2147     return boundsForRects(rect1, rect2, range);
2148 }
2149 
2150 bool AccessibilityRenderObject::isVisiblePositionRangeInDifferentDocument(const VisiblePositionRange&amp; range) const
2151 {
2152     if (range.start.isNull() || range.end.isNull())
2153         return false;
2154 
2155     VisibleSelection newSelection = VisibleSelection(range.start, range.end);
2156     if (Document* newSelectionDocument = newSelection.base().document()) {
2157         if (RefPtr&lt;Frame&gt; newSelectionFrame = newSelectionDocument-&gt;frame()) {
2158             Frame* frame = this-&gt;frame();
2159             if (!frame || (newSelectionFrame != frame &amp;&amp; newSelectionDocument != frame-&gt;document()))
2160                 return true;
2161         }
2162     }
2163 
2164     return false;
2165 }
2166 
2167 void AccessibilityRenderObject::setSelectedVisiblePositionRange(const VisiblePositionRange&amp; range) const
2168 {
2169     if (range.start.isNull() || range.end.isNull())
2170         return;
2171 
2172     // In WebKit1, when the top web area sets the selection to be an input element in an iframe, the caret will disappear.
2173     // FrameSelection::setSelectionWithoutUpdatingAppearance is setting the selection on the new frame in this case, and causing this behavior.
2174     if (isWebArea() &amp;&amp; parentObject() &amp;&amp; parentObject()-&gt;isAttachment()) {
2175         if (isVisiblePositionRangeInDifferentDocument(range))
2176             return;
2177     }
2178 
2179     // make selection and tell the document to use it. if it&#39;s zero length, then move to that position
2180     if (range.start == range.end) {
2181         setTextSelectionIntent(axObjectCache(), AXTextStateChangeTypeSelectionMove);
2182         m_renderer-&gt;frame().selection().moveTo(range.start, UserTriggered);
2183         clearTextSelectionIntent(axObjectCache());
2184     }
2185     else {
2186         setTextSelectionIntent(axObjectCache(), AXTextStateChangeTypeSelectionExtend);
2187         VisibleSelection newSelection = VisibleSelection(range.start, range.end);
2188         m_renderer-&gt;frame().selection().setSelection(newSelection, FrameSelection::defaultSetSelectionOptions());
2189         clearTextSelectionIntent(axObjectCache());
2190     }
2191 }
2192 
2193 VisiblePosition AccessibilityRenderObject::visiblePositionForPoint(const IntPoint&amp; point) const
2194 {
2195     if (!m_renderer)
2196         return VisiblePosition();
2197 
2198     // convert absolute point to view coordinates
2199     RenderView* renderView = topRenderer();
2200     if (!renderView)
2201         return VisiblePosition();
2202 
2203 #if PLATFORM(COCOA)
2204     FrameView* frameView = &amp;renderView-&gt;frameView();
2205 #endif
2206 
2207     Node* innerNode = nullptr;
2208 
2209     // locate the node containing the point
2210     LayoutPoint pointResult;
2211     while (1) {
2212         LayoutPoint ourpoint;
2213 #if PLATFORM(MAC)
2214         ourpoint = frameView-&gt;screenToContents(point);
2215 #else
2216         ourpoint = point;
2217 #endif
2218         HitTestRequest request(HitTestRequest::ReadOnly |
2219                                HitTestRequest::Active);
2220         HitTestResult result(ourpoint);
2221         renderView-&gt;document().hitTest(request, result);
2222         innerNode = result.innerNode();
2223         if (!innerNode)
2224             return VisiblePosition();
2225 
2226         RenderObject* renderer = innerNode-&gt;renderer();
2227         if (!renderer)
2228             return VisiblePosition();
2229 
2230         pointResult = result.localPoint();
2231 
2232         // done if hit something other than a widget
2233         if (!is&lt;RenderWidget&gt;(*renderer))
2234             break;
2235 
2236         // descend into widget (FRAME, IFRAME, OBJECT...)
2237         Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
2238         if (!is&lt;FrameView&gt;(widget))
2239             break;
2240         Frame&amp; frame = downcast&lt;FrameView&gt;(*widget).frame();
2241         renderView = frame.document()-&gt;renderView();
2242 #if PLATFORM(COCOA)
2243         frameView = downcast&lt;FrameView&gt;(widget);
2244 #endif
2245     }
2246 
2247     return innerNode-&gt;renderer()-&gt;positionForPoint(pointResult, nullptr);
2248 }
2249 
2250 // NOTE: Consider providing this utility method as AX API
2251 VisiblePosition AccessibilityRenderObject::visiblePositionForIndex(unsigned indexValue, bool lastIndexOK) const
2252 {
2253     if (!isTextControl())
2254         return VisiblePosition();
2255 
2256     // lastIndexOK specifies whether the position after the last character is acceptable
2257     if (indexValue &gt;= text().length()) {
2258         if (!lastIndexOK || indexValue &gt; text().length())
2259             return VisiblePosition();
2260     }
2261     VisiblePosition position = visiblePositionForIndex(indexValue);
2262     position.setAffinity(DOWNSTREAM);
2263     return position;
2264 }
2265 
2266 // NOTE: Consider providing this utility method as AX API
2267 int AccessibilityRenderObject::index(const VisiblePosition&amp; position) const
2268 {
2269     if (position.isNull() || !isTextControl())
2270         return -1;
2271 
2272     if (renderObjectContainsPosition(renderer(), position.deepEquivalent()))
2273         return indexForVisiblePosition(position);
2274 
2275     return -1;
2276 }
2277 
2278 void AccessibilityRenderObject::lineBreaks(Vector&lt;int&gt;&amp; lineBreaks) const
2279 {
2280     if (!isTextControl())
2281         return;
2282 
2283     VisiblePosition visiblePos = visiblePositionForIndex(0);
2284     VisiblePosition savedVisiblePos = visiblePos;
2285     visiblePos = nextLinePosition(visiblePos, 0);
2286     while (!visiblePos.isNull() &amp;&amp; visiblePos != savedVisiblePos) {
2287         lineBreaks.append(indexForVisiblePosition(visiblePos));
2288         savedVisiblePos = visiblePos;
2289         visiblePos = nextLinePosition(visiblePos, 0);
2290     }
2291 }
2292 
2293 // Given a line number, the range of characters of the text associated with this accessibility
2294 // object that contains the line number.
2295 PlainTextRange AccessibilityRenderObject::doAXRangeForLine(unsigned lineNumber) const
2296 {
2297     if (!isTextControl())
2298         return PlainTextRange();
2299 
2300     // iterate to the specified line
2301     VisiblePosition visiblePos = visiblePositionForIndex(0);
2302     VisiblePosition savedVisiblePos;
2303     for (unsigned lineCount = lineNumber; lineCount; lineCount -= 1) {
2304         savedVisiblePos = visiblePos;
2305         visiblePos = nextLinePosition(visiblePos, 0);
2306         if (visiblePos.isNull() || visiblePos == savedVisiblePos)
2307             return PlainTextRange();
2308     }
2309 
2310     // Get the end of the line based on the starting position.
2311     VisiblePosition endPosition = endOfLine(visiblePos);
2312 
2313     int index1 = indexForVisiblePosition(visiblePos);
2314     int index2 = indexForVisiblePosition(endPosition);
2315 
2316     // add one to the end index for a line break not caused by soft line wrap (to match AppKit)
2317     if (endPosition.affinity() == DOWNSTREAM &amp;&amp; endPosition.next().isNotNull())
2318         index2 += 1;
2319 
2320     // return nil rather than an zero-length range (to match AppKit)
2321     if (index1 == index2)
2322         return PlainTextRange();
2323 
2324     return PlainTextRange(index1, index2 - index1);
2325 }
2326 
2327 // The composed character range in the text associated with this accessibility object that
2328 // is specified by the given index value. This parameterized attribute returns the complete
2329 // range of characters (including surrogate pairs of multi-byte glyphs) at the given index.
2330 PlainTextRange AccessibilityRenderObject::doAXRangeForIndex(unsigned index) const
2331 {
2332     if (!isTextControl())
2333         return PlainTextRange();
2334 
2335     String elementText = text();
2336     if (!elementText.length() || index &gt; elementText.length() - 1)
2337         return PlainTextRange();
2338 
2339     return PlainTextRange(index, 1);
2340 }
2341 
2342 // A substring of the text associated with this accessibility object that is
2343 // specified by the given character range.
2344 String AccessibilityRenderObject::doAXStringForRange(const PlainTextRange&amp; range) const
2345 {
2346     if (!range.length)
2347         return String();
2348 
2349     if (!isTextControl())
2350         return String();
2351 
2352     String elementText = isPasswordField() ? passwordFieldValue() : text();
2353     return elementText.substring(range.start, range.length);
2354 }
2355 
2356 // The bounding rectangle of the text associated with this accessibility object that is
2357 // specified by the given range. This is the bounding rectangle a sighted user would see
2358 // on the display screen, in pixels.
2359 IntRect AccessibilityRenderObject::doAXBoundsForRange(const PlainTextRange&amp; range) const
2360 {
2361     if (allowsTextRanges())
2362         return boundsForVisiblePositionRange(visiblePositionRangeForRange(range));
2363     return IntRect();
2364 }
2365 
2366 IntRect AccessibilityRenderObject::doAXBoundsForRangeUsingCharacterOffset(const PlainTextRange&amp; range) const
2367 {
2368     if (allowsTextRanges())
2369         return boundsForRange(rangeForPlainTextRange(range));
2370     return IntRect();
2371 }
2372 
2373 AccessibilityObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint&amp; point) const
2374 {
2375     if (!area)
2376         return nullptr;
2377 
2378     AccessibilityObject* parent = nullptr;
2379     for (Element* mapParent = area-&gt;parentElement(); mapParent; mapParent = mapParent-&gt;parentElement()) {
2380         if (is&lt;HTMLMapElement&gt;(*mapParent)) {
2381             parent = accessibilityParentForImageMap(downcast&lt;HTMLMapElement&gt;(mapParent));
2382             break;
2383         }
2384     }
2385     if (!parent)
2386         return nullptr;
2387 
2388     for (const auto&amp; child : parent-&gt;children()) {
2389         if (child-&gt;elementRect().contains(point))
2390             return child.get();
2391     }
2392 
2393     return nullptr;
2394 }
2395 
2396 AccessibilityObjectInterface* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const
2397 {
2398     AccessibilityObject* remote = remoteSVGRootElement(Create);
2399     if (!remote)
2400         return nullptr;
2401 
2402     IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
2403     return remote-&gt;accessibilityHitTest(IntPoint(offset));
2404 }
2405 
2406 AccessibilityObjectInterface* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const
2407 {
2408     if (isSVGImage())
2409         return remoteSVGElementHitTest(point);
2410 
2411     return AccessibilityObject::elementAccessibilityHitTest(point);
2412 }
2413 
2414 static bool shouldUseShadowHostForHitTesting(Node* shadowHost)
2415 {
2416     // We need to allow automation of mouse events on video tags.
2417     return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
2418 }
2419 
2420 AccessibilityObjectInterface* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const
2421 {
2422     if (!m_renderer || !m_renderer-&gt;hasLayer())
2423         return nullptr;
2424 
2425     m_renderer-&gt;document().updateLayout();
2426 
2427     if (!m_renderer || !m_renderer-&gt;hasLayer())
2428         return nullptr;
2429 
2430     RenderLayer* layer = downcast&lt;RenderBox&gt;(*m_renderer).layer();
2431 
2432     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
2433     HitTestResult hitTestResult = HitTestResult(point);
2434     layer-&gt;hitTest(request, hitTestResult);
2435     Node* node = hitTestResult.innerNode();
2436     if (!node)
2437         return nullptr;
2438     Node* shadowAncestorNode = node-&gt;shadowHost();
2439     if (shouldUseShadowHostForHitTesting(shadowAncestorNode))
2440         node = shadowAncestorNode;
2441     ASSERT(node);
2442 
2443     if (is&lt;HTMLAreaElement&gt;(*node))
2444         return accessibilityImageMapHitTest(downcast&lt;HTMLAreaElement&gt;(node), point);
2445 
2446     if (is&lt;HTMLOptionElement&gt;(*node))
2447         node = downcast&lt;HTMLOptionElement&gt;(*node).ownerSelectElement();
2448 
2449     RenderObject* obj = node-&gt;renderer();
2450     if (!obj)
2451         return nullptr;
2452 
2453     AccessibilityObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
2454     result-&gt;updateChildrenIfNecessary();
2455 
2456     // Allow the element to perform any hit-testing it might need to do to reach non-render children.
2457     result = static_cast&lt;AccessibilityObject*&gt;(result-&gt;elementAccessibilityHitTest(point));
2458 
2459     if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
2460         // If this element is the label of a control, a hit test should return the control.
2461         AccessibilityObject* controlObject = result-&gt;correspondingControlForLabelElement();
2462         if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
2463             return controlObject;
2464 
2465         result = result-&gt;parentObjectUnignored();
2466     }
2467 
2468     return result;
2469 }
2470 
2471 bool AccessibilityRenderObject::shouldNotifyActiveDescendant() const
2472 {
2473 #if USE(ATK)
2474     // According to the Core AAM spec, ATK expects object:state-changed:focused notifications
2475     // whenever the active descendant changes.
2476     return true;
2477 #endif
2478     // We want to notify that the combo box has changed its active descendant,
2479     // but we do not want to change the focus, because focus should remain with the combo box.
2480     if (isComboBox())
2481         return true;
2482 
2483     return shouldFocusActiveDescendant();
2484 }
2485 
2486 bool AccessibilityRenderObject::shouldFocusActiveDescendant() const
2487 {
2488     switch (ariaRoleAttribute()) {
2489     case AccessibilityRole::ApplicationGroup:
2490     case AccessibilityRole::ListBox:
2491     case AccessibilityRole::Menu:
2492     case AccessibilityRole::MenuBar:
2493     case AccessibilityRole::RadioGroup:
2494     case AccessibilityRole::Row:
2495     case AccessibilityRole::PopUpButton:
2496     case AccessibilityRole::Meter:
2497     case AccessibilityRole::ProgressIndicator:
2498     case AccessibilityRole::Toolbar:
2499     case AccessibilityRole::Outline:
2500     case AccessibilityRole::Tree:
2501     case AccessibilityRole::Grid:
2502     /* FIXME: replace these with actual roles when they are added to AccessibilityRole
2503     composite
2504     alert
2505     alertdialog
2506     status
2507     timer
2508     */
2509         return true;
2510     default:
2511         return false;
2512     }
2513 }
2514 
2515 AccessibilityObject* AccessibilityRenderObject::activeDescendant() const
2516 {
2517     if (!m_renderer)
2518         return nullptr;
2519 
2520     const AtomString&amp; activeDescendantAttrStr = getAttribute(aria_activedescendantAttr);
2521     if (activeDescendantAttrStr.isNull() || activeDescendantAttrStr.isEmpty())
2522         return nullptr;
2523     Element* element = this-&gt;element();
2524     if (!element)
2525         return nullptr;
2526 
2527     Element* target = element-&gt;treeScope().getElementById(activeDescendantAttrStr);
2528     if (!target)
2529         return nullptr;
2530 
2531     if (AXObjectCache* cache = axObjectCache()) {
2532         AccessibilityObject* obj = cache-&gt;getOrCreate(target);
2533         if (obj &amp;&amp; obj-&gt;isAccessibilityRenderObject())
2534             // an activedescendant is only useful if it has a renderer, because that&#39;s what&#39;s needed to post the notification
2535             return obj;
2536     }
2537 
2538     return nullptr;
2539 }
2540 
2541 void AccessibilityRenderObject::handleAriaExpandedChanged()
2542 {
2543     // This object might be deleted under the call to the parentObject() method.
2544     auto protectedThis = makeRef(*this);
2545 
2546     // Find if a parent of this object should handle aria-expanded changes.
2547     AccessibilityObject* containerParent = this-&gt;parentObject();
2548     while (containerParent) {
2549         bool foundParent = false;
2550 
2551         switch (containerParent-&gt;roleValue()) {
2552         case AccessibilityRole::Tree:
2553         case AccessibilityRole::TreeGrid:
2554         case AccessibilityRole::Grid:
2555         case AccessibilityRole::Table:
2556         case AccessibilityRole::Browser:
2557             foundParent = true;
2558             break;
2559         default:
2560             break;
2561         }
2562 
2563         if (foundParent)
2564             break;
2565 
2566         containerParent = containerParent-&gt;parentObject();
2567     }
2568 
2569     // Post that the row count changed.
2570     AXObjectCache* cache = axObjectCache();
2571     if (!cache)
2572         return;
2573 
2574     if (containerParent)
2575         cache-&gt;postNotification(containerParent, document(), AXObjectCache::AXRowCountChanged);
2576 
2577     // Post that the specific row either collapsed or expanded.
2578     if (roleValue() == AccessibilityRole::Row || roleValue() == AccessibilityRole::TreeItem)
2579         cache-&gt;postNotification(this, document(), isExpanded() ? AXObjectCache::AXRowExpanded : AXObjectCache::AXRowCollapsed);
2580     else
2581         cache-&gt;postNotification(this, document(), AXObjectCache::AXExpandedChanged);
2582 }
2583 
2584 RenderObject* AccessibilityRenderObject::targetElementForActiveDescendant(const QualifiedName&amp; attributeName, AccessibilityObject* activeDescendant) const
2585 {
2586     AccessibilityObject::AccessibilityChildrenVector elements;
2587     ariaElementsFromAttribute(elements, attributeName);
2588     for (const auto&amp; element : elements) {
2589         if (activeDescendant-&gt;isDescendantOfObject(element.get()))
2590             return element-&gt;renderer();
2591     }
2592 
2593     return nullptr;
2594 }
2595 
2596 void AccessibilityRenderObject::handleActiveDescendantChanged()
2597 {
2598     Element* element = downcast&lt;Element&gt;(renderer()-&gt;node());
2599     if (!element)
2600         return;
2601     if (!renderer()-&gt;frame().selection().isFocusedAndActive() || renderer()-&gt;document().focusedElement() != element)
2602         return;
2603 
2604     auto* activeDescendant = this-&gt;activeDescendant();
2605     if (activeDescendant &amp;&amp; shouldNotifyActiveDescendant()) {
2606         auto* targetRenderer = renderer();
2607 
2608 #if PLATFORM(COCOA)
2609         // If the combobox&#39;s activeDescendant is inside another object, the target element should be that parent.
2610         if (isComboBox()) {
2611             if (auto* ariaOwner = targetElementForActiveDescendant(aria_ownsAttr, activeDescendant))
2612                 targetRenderer = ariaOwner;
2613             else if (auto* ariaController = targetElementForActiveDescendant(aria_controlsAttr, activeDescendant))
2614                 targetRenderer = ariaController;
2615         }
2616 #endif
2617 
2618         renderer()-&gt;document().axObjectCache()-&gt;postNotification(targetRenderer, AXObjectCache::AXActiveDescendantChanged);
2619     }
2620 }
2621 
2622 AccessibilityObject* AccessibilityRenderObject::correspondingControlForLabelElement() const
2623 {
2624     HTMLLabelElement* labelElement = labelElementContainer();
2625     if (!labelElement)
2626         return nullptr;
2627 
2628     auto correspondingControl = labelElement-&gt;control();
2629     if (!correspondingControl)
2630         return nullptr;
2631 
2632     // Make sure the corresponding control isn&#39;t a descendant of this label that&#39;s in the middle of being destroyed.
2633     if (correspondingControl-&gt;renderer() &amp;&amp; !correspondingControl-&gt;renderer()-&gt;parent())
2634         return nullptr;
2635 
2636     return axObjectCache()-&gt;getOrCreate(correspondingControl.get());
2637 }
2638 
2639 AccessibilityObject* AccessibilityRenderObject::correspondingLabelForControlElement() const
2640 {
2641     if (!m_renderer)
2642         return nullptr;
2643 
2644     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
2645     // override the &quot;label&quot; element association.
2646     if (hasTextAlternative())
2647         return nullptr;
2648 
2649     Node* node = m_renderer-&gt;node();
2650     if (is&lt;HTMLElement&gt;(node)) {
2651         if (HTMLLabelElement* label = labelForElement(downcast&lt;HTMLElement&gt;(node)))
2652             return axObjectCache()-&gt;getOrCreate(label);
2653     }
2654 
2655     return nullptr;
2656 }
2657 
2658 bool AccessibilityRenderObject::renderObjectIsObservable(RenderObject&amp; renderer) const
2659 {
2660     // AX clients will listen for AXValueChange on a text control.
2661     if (is&lt;RenderTextControl&gt;(renderer))
2662         return true;
2663 
2664     // AX clients will listen for AXSelectedChildrenChanged on listboxes.
2665     Node* node = renderer.node();
2666     if (!node)
2667         return false;
2668 
2669     if (nodeHasRole(node, &quot;listbox&quot;) || (is&lt;RenderBoxModelObject&gt;(renderer) &amp;&amp; downcast&lt;RenderBoxModelObject&gt;(renderer).isListBox()))
2670         return true;
2671 
2672     // Textboxes should send out notifications.
2673     if (nodeHasRole(node, &quot;textbox&quot;) || (is&lt;Element&gt;(*node) &amp;&amp; contentEditableAttributeIsEnabled(downcast&lt;Element&gt;(node))))
2674         return true;
2675 
2676     return false;
2677 }
2678 
2679 AccessibilityObject* AccessibilityRenderObject::observableObject() const
2680 {
2681     // Find the object going up the parent chain that is used in accessibility to monitor certain notifications.
2682     for (RenderObject* renderer = this-&gt;renderer(); renderer &amp;&amp; renderer-&gt;node(); renderer = renderer-&gt;parent()) {
2683         if (renderObjectIsObservable(*renderer)) {
2684             if (AXObjectCache* cache = axObjectCache())
2685                 return cache-&gt;getOrCreate(renderer);
2686         }
2687     }
2688 
2689     return nullptr;
2690 }
2691 
2692 bool AccessibilityRenderObject::isDescendantOfElementType(const HashSet&lt;QualifiedName&gt;&amp; tagNames) const
2693 {
2694     for (auto&amp; ancestor : ancestorsOfType&lt;RenderElement&gt;(*m_renderer)) {
2695         if (ancestor.element() &amp;&amp; tagNames.contains(ancestor.element()-&gt;tagQName()))
2696             return true;
2697     }
2698     return false;
2699 }
2700 
2701 bool AccessibilityRenderObject::isDescendantOfElementType(const QualifiedName&amp; tagName) const
2702 {
2703     for (auto&amp; ancestor : ancestorsOfType&lt;RenderElement&gt;(*m_renderer)) {
2704         if (ancestor.element() &amp;&amp; ancestor.element()-&gt;hasTagName(tagName))
2705             return true;
2706     }
2707     return false;
2708 }
2709 
2710 String AccessibilityRenderObject::expandedTextValue() const
2711 {
2712     if (AccessibilityObject* parent = parentObject()) {
2713         if (parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag))
2714             return parent-&gt;getAttribute(titleAttr);
2715     }
2716 
2717     return String();
2718 }
2719 
2720 bool AccessibilityRenderObject::supportsExpandedTextValue() const
2721 {
2722     if (roleValue() == AccessibilityRole::StaticText) {
2723         if (AccessibilityObject* parent = parentObject())
2724             return parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag);
2725     }
2726 
2727     return false;
2728 }
2729 
2730 AccessibilityRole AccessibilityRenderObject::determineAccessibilityRole()
2731 {
2732     if (!m_renderer)
2733         return AccessibilityRole::Unknown;
2734 
2735 #if ENABLE(APPLE_PAY)
2736     if (isApplePayButton())
2737         return AccessibilityRole::Button;
2738 #endif
2739 
2740     // Sometimes we need to ignore the attribute role. Like if a tree is malformed,
2741     // we want to ignore the treeitem&#39;s attribute role.
2742     if ((m_ariaRole = determineAriaRoleAttribute()) != AccessibilityRole::Unknown &amp;&amp; !shouldIgnoreAttributeRole())
2743         return m_ariaRole;
2744 
2745     Node* node = m_renderer-&gt;node();
2746     RenderBoxModelObject* cssBox = renderBoxModelObject();
2747 
2748     if (node &amp;&amp; node-&gt;isLink())
2749         return AccessibilityRole::WebCoreLink;
2750     if (node &amp;&amp; is&lt;HTMLImageElement&gt;(*node) &amp;&amp; downcast&lt;HTMLImageElement&gt;(*node).hasAttributeWithoutSynchronization(usemapAttr))
2751         return AccessibilityRole::ImageMap;
2752     if ((cssBox &amp;&amp; cssBox-&gt;isListItem()) || (node &amp;&amp; node-&gt;hasTagName(liTag)))
2753         return AccessibilityRole::ListItem;
2754     if (m_renderer-&gt;isListMarker())
2755         return AccessibilityRole::ListMarker;
2756     if (node &amp;&amp; node-&gt;hasTagName(buttonTag))
2757         return buttonRoleType();
2758     if (node &amp;&amp; node-&gt;hasTagName(legendTag))
2759         return AccessibilityRole::Legend;
2760     if (m_renderer-&gt;isText())
2761         return AccessibilityRole::StaticText;
2762     if (cssBox &amp;&amp; cssBox-&gt;isImage()) {
2763         if (is&lt;HTMLInputElement&gt;(node))
2764             return hasPopup() ? AccessibilityRole::PopUpButton : AccessibilityRole::Button;
2765         if (isSVGImage())
2766             return AccessibilityRole::SVGRoot;
2767         return AccessibilityRole::Image;
2768     }
2769 
2770     if (node &amp;&amp; node-&gt;hasTagName(canvasTag))
2771         return AccessibilityRole::Canvas;
2772 
2773     if (cssBox &amp;&amp; cssBox-&gt;isRenderView())
2774         return AccessibilityRole::WebArea;
2775 
2776     if (cssBox &amp;&amp; cssBox-&gt;isTextField()) {
2777         if (is&lt;HTMLInputElement&gt;(node))
2778             return downcast&lt;HTMLInputElement&gt;(*node).isSearchField() ? AccessibilityRole::SearchField : AccessibilityRole::TextField;
2779     }
2780 
2781     if (cssBox &amp;&amp; cssBox-&gt;isTextArea())
2782         return AccessibilityRole::TextArea;
2783 
2784     if (is&lt;HTMLInputElement&gt;(node)) {
2785         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
2786         if (input.isCheckbox())
2787             return AccessibilityRole::CheckBox;
2788         if (input.isRadioButton())
2789             return AccessibilityRole::RadioButton;
2790         if (input.isTextButton())
2791             return buttonRoleType();
2792         // On iOS, the date field and time field are popup buttons. On other platforms they are text fields.
2793 #if PLATFORM(IOS_FAMILY)
2794         if (input.isDateField() || input.isTimeField())
2795             return AccessibilityRole::PopUpButton;
2796 #endif
2797 #if ENABLE(INPUT_TYPE_COLOR)
2798         if (input.isColorControl())
2799             return AccessibilityRole::ColorWell;
2800 #endif
2801     }
2802 
2803     if (hasContentEditableAttributeSet())
2804         return AccessibilityRole::TextArea;
2805 
2806     if (isFileUploadButton())
2807         return AccessibilityRole::Button;
2808 
2809     if (cssBox &amp;&amp; cssBox-&gt;isMenuList())
2810         return AccessibilityRole::PopUpButton;
2811 
2812     if (headingLevel())
2813         return AccessibilityRole::Heading;
2814 
2815     if (m_renderer-&gt;isSVGRoot())
2816         return AccessibilityRole::SVGRoot;
2817 
2818     if (isStyleFormatGroup()) {
2819         if (node-&gt;hasTagName(delTag))
2820             return AccessibilityRole::Deletion;
2821         if (node-&gt;hasTagName(insTag))
2822             return AccessibilityRole::Insertion;
2823         if (node-&gt;hasTagName(subTag))
2824             return AccessibilityRole::Subscript;
2825         if (node-&gt;hasTagName(supTag))
2826             return AccessibilityRole::Superscript;
2827         return is&lt;RenderInline&gt;(*m_renderer) ? AccessibilityRole::Inline : AccessibilityRole::TextGroup;
2828     }
2829 
2830     if (node &amp;&amp; node-&gt;hasTagName(ddTag))
2831         return AccessibilityRole::DescriptionListDetail;
2832 
2833     if (node &amp;&amp; node-&gt;hasTagName(dtTag))
2834         return AccessibilityRole::DescriptionListTerm;
2835 
2836     if (node &amp;&amp; node-&gt;hasTagName(dlTag))
2837         return AccessibilityRole::DescriptionList;
2838 
2839     if (node &amp;&amp; node-&gt;hasTagName(fieldsetTag))
2840         return AccessibilityRole::Group;
2841 
2842     if (node &amp;&amp; node-&gt;hasTagName(figureTag))
2843         return AccessibilityRole::Figure;
2844 
2845     // Check for Ruby elements
2846     if (m_renderer-&gt;isRubyText())
2847         return AccessibilityRole::RubyText;
2848     if (m_renderer-&gt;isRubyBase())
2849         return AccessibilityRole::RubyBase;
2850     if (m_renderer-&gt;isRubyRun())
2851         return AccessibilityRole::RubyRun;
2852     if (m_renderer-&gt;isRubyBlock())
2853         return AccessibilityRole::RubyBlock;
2854     if (m_renderer-&gt;isRubyInline())
2855         return AccessibilityRole::RubyInline;
2856 
2857     // This return value is what will be used if AccessibilityTableCell determines
2858     // the cell should not be treated as a cell (e.g. because it is a layout table.
2859     if (is&lt;RenderTableCell&gt;(renderer()))
2860         return AccessibilityRole::TextGroup;
2861 
2862     // Table sections should be ignored.
2863     if (m_renderer-&gt;isTableSection())
2864         return AccessibilityRole::Ignored;
2865 
2866     if (m_renderer-&gt;isHR())
2867         return AccessibilityRole::HorizontalRule;
2868 
2869     if (node &amp;&amp; node-&gt;hasTagName(pTag))
2870         return AccessibilityRole::Paragraph;
2871 
2872     if (is&lt;HTMLLabelElement&gt;(node))
2873         return AccessibilityRole::Label;
2874 
2875     if (node &amp;&amp; node-&gt;hasTagName(dfnTag))
2876         return AccessibilityRole::Definition;
2877 
2878     if (node &amp;&amp; node-&gt;hasTagName(divTag))
2879         return AccessibilityRole::Div;
2880 
2881     if (is&lt;HTMLFormElement&gt;(node))
2882         return AccessibilityRole::Form;
2883 
2884     if (node &amp;&amp; node-&gt;hasTagName(articleTag))
2885         return AccessibilityRole::DocumentArticle;
2886 
2887     if (node &amp;&amp; node-&gt;hasTagName(mainTag))
2888         return AccessibilityRole::LandmarkMain;
2889 
2890     if (node &amp;&amp; node-&gt;hasTagName(navTag))
2891         return AccessibilityRole::LandmarkNavigation;
2892 
2893     if (node &amp;&amp; node-&gt;hasTagName(asideTag))
2894         return AccessibilityRole::LandmarkComplementary;
2895 
2896     // The default role attribute value for the section element, region, became a landmark in ARIA 1.1.
2897     // The HTML AAM spec says it is &quot;strongly recommended&quot; that ATs only convey and provide navigation
2898     // for section elements which have names.
2899     if (node &amp;&amp; node-&gt;hasTagName(sectionTag))
2900         return hasAttribute(aria_labelAttr) || hasAttribute(aria_labelledbyAttr) ? AccessibilityRole::LandmarkRegion : AccessibilityRole::TextGroup;
2901 
2902     if (node &amp;&amp; node-&gt;hasTagName(addressTag))
2903         return AccessibilityRole::LandmarkContentInfo;
2904 
2905     if (node &amp;&amp; node-&gt;hasTagName(blockquoteTag))
2906         return AccessibilityRole::Blockquote;
2907 
2908     if (node &amp;&amp; node-&gt;hasTagName(captionTag))
2909         return AccessibilityRole::Caption;
2910 
2911     if (node &amp;&amp; node-&gt;hasTagName(markTag))
2912         return AccessibilityRole::Mark;
2913 
2914     if (node &amp;&amp; node-&gt;hasTagName(preTag))
2915         return AccessibilityRole::Pre;
2916 
2917     if (is&lt;HTMLDetailsElement&gt;(node))
2918         return AccessibilityRole::Details;
2919     if (is&lt;HTMLSummaryElement&gt;(node))
2920         return AccessibilityRole::Summary;
2921 
2922     // http://rawgit.com/w3c/aria/master/html-aam/html-aam.html
2923     // Output elements should be mapped to status role.
2924     if (isOutput())
2925         return AccessibilityRole::ApplicationStatus;
2926 
2927 #if ENABLE(VIDEO)
2928     if (is&lt;HTMLVideoElement&gt;(node))
2929         return AccessibilityRole::Video;
2930     if (is&lt;HTMLAudioElement&gt;(node))
2931         return AccessibilityRole::Audio;
2932 #endif
2933 
2934     // The HTML element should not be exposed as an element. That&#39;s what the RenderView element does.
2935     if (node &amp;&amp; node-&gt;hasTagName(htmlTag))
2936         return AccessibilityRole::Ignored;
2937 
2938     // There should only be one banner/contentInfo per page. If header/footer are being used within an article or section
2939     // then it should not be exposed as whole page&#39;s banner/contentInfo
2940     if (node &amp;&amp; node-&gt;hasTagName(headerTag) &amp;&amp; !isDescendantOfElementType({ articleTag, sectionTag }))
2941         return AccessibilityRole::LandmarkBanner;
2942 
2943     // http://webkit.org/b/190138 Footers should become contentInfo&#39;s if scoped to body (and consequently become a landmark).
2944     // It should remain a footer if scoped to main, sectioning elements (article, section) or root sectioning element (blockquote, details, dialog, fieldset, figure, td).
2945     if (node &amp;&amp; node-&gt;hasTagName(footerTag)) {
2946         if (!isDescendantOfElementType({ articleTag, sectionTag, mainTag, blockquoteTag, detailsTag, fieldsetTag, figureTag, tdTag }))
2947             return AccessibilityRole::LandmarkContentInfo;
2948         return AccessibilityRole::Footer;
2949     }
2950 
2951     // menu tags with toolbar type should have Toolbar role.
2952     if (node &amp;&amp; node-&gt;hasTagName(menuTag) &amp;&amp; equalLettersIgnoringASCIICase(getAttribute(typeAttr), &quot;toolbar&quot;))
2953         return AccessibilityRole::Toolbar;
2954 
2955     if (node &amp;&amp; node-&gt;hasTagName(timeTag))
2956         return AccessibilityRole::Time;
2957 
2958     // If the element does not have role, but it has ARIA attributes, or accepts tab focus, accessibility should fallback to exposing it as a group.
2959     if (supportsARIAAttributes() || canSetFocusAttribute())
2960         return AccessibilityRole::Group;
2961 
2962     if (m_renderer-&gt;isRenderBlockFlow())
2963         return m_renderer-&gt;isAnonymousBlock() ? AccessibilityRole::TextGroup : AccessibilityRole::Group;
2964 
2965     // InlineRole is the final fallback before assigning AccessibilityRole::Unknown to an object. It makes it
2966     // possible to distinguish truly unknown objects from non-focusable inline text elements
2967     // which have an event handler or attribute suggesting possible inclusion by the platform.
2968     if (is&lt;RenderInline&gt;(*m_renderer)
2969         &amp;&amp; (hasAttributesRequiredForInclusion()
2970             || (node &amp;&amp; node-&gt;hasEventListeners())
2971             || (supportsDatetimeAttribute() &amp;&amp; !getAttribute(datetimeAttr).isEmpty())))
2972         return AccessibilityRole::Inline;
2973 
2974     return AccessibilityRole::Unknown;
2975 }
2976 
2977 AccessibilityOrientation AccessibilityRenderObject::orientation() const
2978 {
2979     const AtomString&amp; ariaOrientation = getAttribute(aria_orientationAttr);
2980     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;horizontal&quot;))
2981         return AccessibilityOrientation::Horizontal;
2982     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;vertical&quot;))
2983         return AccessibilityOrientation::Vertical;
2984     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;undefined&quot;))
2985         return AccessibilityOrientation::Undefined;
2986 
2987     // In ARIA 1.1, the implicit value of aria-orientation changed from horizontal
2988     // to undefined on all roles that don&#39;t have their own role-specific values. In
2989     // addition, the implicit value of combobox became undefined.
2990     if (isComboBox() || isRadioGroup() || isTreeGrid())
2991         return AccessibilityOrientation::Undefined;
2992 
2993     if (isScrollbar() || isListBox() || isMenu() || isTree())
2994         return AccessibilityOrientation::Vertical;
2995 
2996     if (isMenuBar() || isSplitter() || isTabList() || isToolbar() || isSlider())
2997         return AccessibilityOrientation::Horizontal;
2998 
2999     return AccessibilityObject::orientation();
3000 }
3001 
3002 bool AccessibilityRenderObject::inheritsPresentationalRole() const
3003 {
3004     // ARIA states if an item can get focus, it should not be presentational.
3005     if (canSetFocusAttribute())
3006         return false;
3007 
3008     // ARIA spec says that when a parent object is presentational, and it has required child elements,
3009     // those child elements are also presentational. For example, &lt;li&gt; becomes presentational from &lt;ul&gt;.
3010     // http://www.w3.org/WAI/PF/aria/complete#presentation
3011 
3012     const Vector&lt;const HTMLQualifiedName*&gt;* parentTags;
3013     switch (roleValue()) {
3014     case AccessibilityRole::ListItem:
3015     case AccessibilityRole::ListMarker: {
3016         static const auto listItemParents = makeNeverDestroyed(Vector&lt;const HTMLQualifiedName*&gt; { &amp;dlTag.get(), &amp;olTag.get(), &amp;ulTag.get() });
3017         parentTags = &amp;listItemParents.get();
3018         break;
3019     }
3020     case AccessibilityRole::GridCell:
3021     case AccessibilityRole::Cell: {
3022         static const auto tableCellParents = makeNeverDestroyed(Vector&lt;const HTMLQualifiedName*&gt; { &amp;tableTag.get() });
3023         parentTags = &amp;tableCellParents.get();
3024         break;
3025     }
3026     default:
3027         // Not all elements need to do the following check, only ones that are required children.
3028         return false;
3029     }
3030 
3031     for (auto* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
3032         if (!is&lt;AccessibilityRenderObject&gt;(*parent))
3033             continue;
3034 
3035         Node* node = downcast&lt;AccessibilityRenderObject&gt;(*parent).node();
3036         if (!is&lt;Element&gt;(node))
3037             continue;
3038 
3039         // If native tag of the parent element matches an acceptable name, then return
3040         // based on its presentational status.
3041         auto&amp; name = downcast&lt;Element&gt;(*node).tagQName();
3042         if (std::any_of(parentTags-&gt;begin(), parentTags-&gt;end(), [&amp;name] (auto* possibleName) { return *possibleName == name; }))
3043             return parent-&gt;roleValue() == AccessibilityRole::Presentational;
3044     }
3045 
3046     return false;
3047 }
3048 
3049 bool AccessibilityRenderObject::isPresentationalChildOfAriaRole() const
3050 {
3051     // Walk the parent chain looking for a parent that has presentational children
3052     AccessibilityObject* parent;
3053     for (parent = parentObject(); parent &amp;&amp; !parent-&gt;ariaRoleHasPresentationalChildren(); parent = parent-&gt;parentObject())
3054     { }
3055 
3056     return parent;
3057 }
3058 
3059 bool AccessibilityRenderObject::ariaRoleHasPresentationalChildren() const
3060 {
3061     switch (m_ariaRole) {
3062     case AccessibilityRole::Button:
3063     case AccessibilityRole::Slider:
3064     case AccessibilityRole::Image:
3065     case AccessibilityRole::ProgressIndicator:
3066     case AccessibilityRole::SpinButton:
3067     // case SeparatorRole:
3068         return true;
3069     default:
3070         return false;
3071     }
3072 }
3073 
3074 bool AccessibilityRenderObject::canSetExpandedAttribute() const
3075 {
3076     if (roleValue() == AccessibilityRole::Details)
3077         return true;
3078 
3079     // An object can be expanded if it aria-expanded is true or false.
3080     const AtomString&amp; expanded = getAttribute(aria_expandedAttr);
3081     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
3082         return true;
3083     return false;
3084 }
3085 
3086 bool AccessibilityRenderObject::canSetTextRangeAttributes() const
3087 {
3088     return isTextControl();
3089 }
3090 
3091 void AccessibilityRenderObject::textChanged()
3092 {
3093     // If this element supports ARIA live regions, or is part of a region with an ARIA editable role,
3094     // then notify the AT of changes.
3095     AXObjectCache* cache = axObjectCache();
3096     if (!cache)
3097         return;
3098 
3099     for (RenderObject* renderParent = renderer(); renderParent; renderParent = renderParent-&gt;parent()) {
3100         AccessibilityObject* parent = cache-&gt;get(renderParent);
3101         if (!parent)
3102             continue;
3103 
3104         if (parent-&gt;supportsLiveRegion())
3105             cache-&gt;postLiveRegionChangeNotification(parent);
3106 
3107         if (parent-&gt;isNonNativeTextControl())
3108             cache-&gt;postNotification(renderParent, AXObjectCache::AXValueChanged);
3109     }
3110 }
3111 
3112 void AccessibilityRenderObject::clearChildren()
3113 {
3114     AccessibilityObject::clearChildren();
3115     m_childrenDirty = false;
3116 }
3117 
3118 void AccessibilityRenderObject::addImageMapChildren()
3119 {
3120     RenderBoxModelObject* cssBox = renderBoxModelObject();
3121     if (!is&lt;RenderImage&gt;(cssBox))
3122         return;
3123 
3124     HTMLMapElement* map = downcast&lt;RenderImage&gt;(*cssBox).imageMap();
3125     if (!map)
3126         return;
3127 
3128     for (auto&amp; area : descendantsOfType&lt;HTMLAreaElement&gt;(*map)) {
3129         // add an &lt;area&gt; element for this child if it has a link
3130         if (!area.isLink())
3131             continue;
3132         auto&amp; areaObject = downcast&lt;AccessibilityImageMapLink&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::ImageMapLink));
3133         areaObject.setHTMLAreaElement(&amp;area);
3134         areaObject.setHTMLMapElement(map);
3135         areaObject.setParent(this);
3136         if (!areaObject.accessibilityIsIgnored())
3137             m_children.append(&amp;areaObject);
3138         else
3139             axObjectCache()-&gt;remove(areaObject.axObjectID());
3140     }
3141 }
3142 
3143 void AccessibilityRenderObject::updateChildrenIfNecessary()
3144 {
3145     if (needsToUpdateChildren())
3146         clearChildren();
3147 
3148     AccessibilityObject::updateChildrenIfNecessary();
3149 }
3150 
3151 void AccessibilityRenderObject::addTextFieldChildren()
3152 {
3153     Node* node = this-&gt;node();
3154     if (!is&lt;HTMLInputElement&gt;(node))
3155         return;
3156 
3157     HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
3158     if (HTMLElement* autoFillElement = input.autoFillButtonElement()) {
3159         if (AccessibilityObject* axAutoFill = axObjectCache()-&gt;getOrCreate(autoFillElement))
3160             m_children.append(axAutoFill);
3161     }
3162 
3163     HTMLElement* spinButtonElement = input.innerSpinButtonElement();
3164     if (!is&lt;SpinButtonElement&gt;(spinButtonElement))
3165         return;
3166 
3167     auto&amp; axSpinButton = downcast&lt;AccessibilitySpinButton&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::SpinButton));
3168     axSpinButton.setSpinButtonElement(downcast&lt;SpinButtonElement&gt;(spinButtonElement));
3169     axSpinButton.setParent(this);
3170     m_children.append(&amp;axSpinButton);
3171 }
3172 
3173 bool AccessibilityRenderObject::isSVGImage() const
3174 {
3175     return remoteSVGRootElement(Create);
3176 }
3177 
3178 void AccessibilityRenderObject::detachRemoteSVGRoot()
3179 {
3180     if (AccessibilitySVGRoot* root = remoteSVGRootElement(Retrieve))
3181         root-&gt;setParent(nullptr);
3182 }
3183 
3184 AccessibilitySVGRoot* AccessibilityRenderObject::remoteSVGRootElement(CreationChoice createIfNecessary) const
3185 {
3186     if (!is&lt;RenderImage&gt;(renderer()))
3187         return nullptr;
3188 
3189     CachedImage* cachedImage = downcast&lt;RenderImage&gt;(*m_renderer).cachedImage();
3190     if (!cachedImage)
3191         return nullptr;
3192 
3193     Image* image = cachedImage-&gt;image();
3194     if (!is&lt;SVGImage&gt;(image))
3195         return nullptr;
3196 
3197     FrameView* frameView = downcast&lt;SVGImage&gt;(*image).frameView();
3198     if (!frameView)
3199         return nullptr;
3200     Frame&amp; frame = frameView-&gt;frame();
3201 
3202     Document* document = frame.document();
3203     if (!is&lt;SVGDocument&gt;(document))
3204         return nullptr;
3205 
3206     auto rootElement = SVGDocument::rootElement(*document);
3207     if (!rootElement)
3208         return nullptr;
3209     RenderObject* rendererRoot = rootElement-&gt;renderer();
3210     if (!rendererRoot)
3211         return nullptr;
3212 
3213     AXObjectCache* cache = frame.document()-&gt;axObjectCache();
3214     if (!cache)
3215         return nullptr;
3216     AccessibilityObject* rootSVGObject = createIfNecessary == Create ? cache-&gt;getOrCreate(rendererRoot) : cache-&gt;get(rendererRoot);
3217 
3218     // In order to connect the AX hierarchy from the SVG root element from the loaded resource
3219     // the parent must be set, because there&#39;s no other way to get back to who created the image.
3220     ASSERT(!createIfNecessary || rootSVGObject);
3221     if (!is&lt;AccessibilitySVGRoot&gt;(rootSVGObject))
3222         return nullptr;
3223 
3224     return downcast&lt;AccessibilitySVGRoot&gt;(rootSVGObject);
3225 }
3226 
3227 void AccessibilityRenderObject::addRemoteSVGChildren()
3228 {
3229     AccessibilitySVGRoot* root = remoteSVGRootElement(Create);
3230     if (!root)
3231         return;
3232 
3233     root-&gt;setParent(this);
3234 
3235     if (root-&gt;accessibilityIsIgnored()) {
3236         for (const auto&amp; child : root-&gt;children())
3237             m_children.append(child);
3238     } else
3239         m_children.append(root);
3240 }
3241 
3242 void AccessibilityRenderObject::addCanvasChildren()
3243 {
3244     // Add the unrendered canvas children as AX nodes, unless we&#39;re not using a canvas renderer
3245     // because JS is disabled for example.
3246     if (!node() || !node()-&gt;hasTagName(canvasTag) || (renderer() &amp;&amp; !renderer()-&gt;isCanvas()))
3247         return;
3248 
3249     // If it&#39;s a canvas, it won&#39;t have rendered children, but it might have accessible fallback content.
3250     // Clear m_haveChildren because AccessibilityNodeObject::addChildren will expect it to be false.
3251     ASSERT(!m_children.size());
3252     m_haveChildren = false;
3253     AccessibilityNodeObject::addChildren();
3254 }
3255 
3256 void AccessibilityRenderObject::addAttachmentChildren()
3257 {
3258     if (!isAttachment())
3259         return;
3260 
3261     // FrameView&#39;s need to be inserted into the AX hierarchy when encountered.
3262     Widget* widget = widgetForAttachmentView();
3263     if (!widget || !widget-&gt;isFrameView())
3264         return;
3265 
3266     addChild(axObjectCache()-&gt;getOrCreate(widget));
3267 }
3268 
3269 #if PLATFORM(COCOA)
3270 void AccessibilityRenderObject::updateAttachmentViewParents()
3271 {
3272     // Only the unignored parent should set the attachment parent, because that&#39;s what is reflected in the AX
3273     // hierarchy to the client.
3274     if (accessibilityIsIgnored())
3275         return;
3276 
3277     for (const auto&amp; child : m_children) {
3278         if (child-&gt;isAttachment())
3279             child-&gt;overrideAttachmentParent(this);
3280     }
3281 }
3282 #endif
3283 
3284 // Hidden children are those that are not rendered or visible, but are specifically marked as aria-hidden=false,
3285 // meaning that they should be exposed to the AX hierarchy.
3286 void AccessibilityRenderObject::addHiddenChildren()
3287 {
3288     Node* node = this-&gt;node();
3289     if (!node)
3290         return;
3291 
3292     // First do a quick run through to determine if we have any hidden nodes (most often we will not).
3293     // If we do have hidden nodes, we need to determine where to insert them so they match DOM order as close as possible.
3294     bool shouldInsertHiddenNodes = false;
3295     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3296         if (!child-&gt;renderer() &amp;&amp; isNodeAriaVisible(child)) {
3297             shouldInsertHiddenNodes = true;
3298             break;
3299         }
3300     }
3301 
3302     if (!shouldInsertHiddenNodes)
3303         return;
3304 
3305     // Iterate through all of the children, including those that may have already been added, and
3306     // try to insert hidden nodes in the correct place in the DOM order.
3307     unsigned insertionIndex = 0;
3308     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3309         if (child-&gt;renderer()) {
3310             // Find out where the last render sibling is located within m_children.
3311             AccessibilityObject* childObject = axObjectCache()-&gt;get(child-&gt;renderer());
3312             if (childObject &amp;&amp; childObject-&gt;accessibilityIsIgnored()) {
3313                 auto&amp; children = childObject-&gt;children();
3314                 if (children.size())
3315                     childObject = children.last().get();
3316                 else
3317                     childObject = nullptr;
3318             }
3319 
3320             if (childObject)
3321                 insertionIndex = m_children.find(childObject) + 1;
3322             continue;
3323         }
3324 
3325         if (!isNodeAriaVisible(child))
3326             continue;
3327 
3328         unsigned previousSize = m_children.size();
3329         if (insertionIndex &gt; previousSize)
3330             insertionIndex = previousSize;
3331 
3332         insertChild(axObjectCache()-&gt;getOrCreate(child), insertionIndex);
3333         insertionIndex += (m_children.size() - previousSize);
3334     }
3335 }
3336 
3337 void AccessibilityRenderObject::updateRoleAfterChildrenCreation()
3338 {
3339     // If a menu does not have valid menuitem children, it should not be exposed as a menu.
3340     auto role = roleValue();
3341     if (role == AccessibilityRole::Menu) {
3342         // Elements marked as menus must have at least one menu item child.
3343         size_t menuItemCount = 0;
3344         for (const auto&amp; child : children()) {
3345             if (child-&gt;isMenuItem()) {
3346                 menuItemCount++;
3347                 break;
3348             }
3349         }
3350 
3351         if (!menuItemCount)
3352             m_role = AccessibilityRole::Group;
3353     }
3354     if (role == AccessibilityRole::SVGRoot &amp;&amp; !hasChildren())
3355         m_role = AccessibilityRole::Image;
3356 }
3357 
3358 void AccessibilityRenderObject::addChildren()
3359 {
3360     // If the need to add more children in addition to existing children arises,
3361     // childrenChanged should have been called, leaving the object with no children.
3362     ASSERT(!m_haveChildren);
3363 
3364     m_haveChildren = true;
3365 
3366     if (!canHaveChildren())
3367         return;
3368 
3369     for (RefPtr&lt;AccessibilityObject&gt; obj = firstChild(); obj; obj = obj-&gt;nextSibling())
3370         addChild(obj.get());
3371 
3372     m_subtreeDirty = false;
3373 
3374     addHiddenChildren();
3375     addAttachmentChildren();
3376     addImageMapChildren();
3377     addTextFieldChildren();
3378     addCanvasChildren();
3379     addRemoteSVGChildren();
3380 
3381 #if PLATFORM(COCOA)
3382     updateAttachmentViewParents();
3383 #endif
3384 
3385     updateRoleAfterChildrenCreation();
3386 }
3387 
3388 bool AccessibilityRenderObject::canHaveChildren() const
3389 {
3390     if (!m_renderer)
3391         return false;
3392 
3393     return AccessibilityNodeObject::canHaveChildren();
3394 }
3395 
3396 const String AccessibilityRenderObject::liveRegionStatus() const
3397 {
3398     const AtomString&amp; liveRegionStatus = getAttribute(aria_liveAttr);
3399     // These roles have implicit live region status.
3400     if (liveRegionStatus.isEmpty())
3401         return defaultLiveRegionStatusForRole(roleValue());
3402 
3403     return liveRegionStatus;
3404 }
3405 
3406 const String AccessibilityRenderObject::liveRegionRelevant() const
3407 {
3408     static NeverDestroyed&lt;const AtomString&gt; defaultLiveRegionRelevant(&quot;additions text&quot;, AtomString::ConstructFromLiteral);
3409     const AtomString&amp; relevant = getAttribute(aria_relevantAttr);
3410 
3411     // Default aria-relevant = &quot;additions text&quot;.
3412     if (relevant.isEmpty())
3413         return &quot;additions text&quot;;
3414 
3415     return relevant;
3416 }
3417 
3418 bool AccessibilityRenderObject::liveRegionAtomic() const
3419 {
3420     const AtomString&amp; atomic = getAttribute(aria_atomicAttr);
3421     if (equalLettersIgnoringASCIICase(atomic, &quot;true&quot;))
3422         return true;
3423     if (equalLettersIgnoringASCIICase(atomic, &quot;false&quot;))
3424         return false;
3425 
3426     // WAI-ARIA &quot;alert&quot; and &quot;status&quot; roles have an implicit aria-atomic value of true.
3427     switch (roleValue()) {
3428     case AccessibilityRole::ApplicationAlert:
3429     case AccessibilityRole::ApplicationStatus:
3430         return true;
3431     default:
3432         return false;
3433     }
3434 }
3435 
3436 bool AccessibilityRenderObject::isBusy() const
3437 {
3438     return elementAttributeValue(aria_busyAttr);
3439 }
3440 
3441 bool AccessibilityRenderObject::canHaveSelectedChildren() const
3442 {
3443     switch (roleValue()) {
3444     // These roles are containers whose children support aria-selected:
3445     case AccessibilityRole::Grid:
3446     case AccessibilityRole::ListBox:
3447     case AccessibilityRole::TabList:
3448     case AccessibilityRole::Tree:
3449     case AccessibilityRole::TreeGrid:
3450     case AccessibilityRole::List:
3451     // These roles are containers whose children are treated as selected by assistive
3452     // technologies. We can get the &quot;selected&quot; item via aria-activedescendant or the
3453     // focused element.
3454     case AccessibilityRole::Menu:
3455     case AccessibilityRole::MenuBar:
3456         return true;
3457     default:
3458         return false;
3459     }
3460 }
3461 
3462 void AccessibilityRenderObject::ariaSelectedRows(AccessibilityChildrenVector&amp; result)
3463 {
3464     // Determine which rows are selected.
3465     bool isMulti = isMultiSelectable();
3466 
3467     // Prefer active descendant over aria-selected.
3468     AccessibilityObject* activeDesc = activeDescendant();
3469     if (activeDesc &amp;&amp; (activeDesc-&gt;isTreeItem() || activeDesc-&gt;isTableRow())) {
3470         result.append(activeDesc);
3471         if (!isMulti)
3472             return;
3473     }
3474 
3475     // Get all the rows.
3476     auto rowsIteration = [&amp;](auto&amp; rows) {
3477         for (auto&amp; row : rows) {
3478             if (row-&gt;isSelected() || row-&gt;isActiveDescendantOfFocusedContainer()) {
3479                 result.append(row);
3480                 if (!isMulti)
3481                     break;
3482             }
3483         }
3484     };
3485     if (isTree()) {
3486         AccessibilityChildrenVector allRows;
3487         ariaTreeRows(allRows);
3488         rowsIteration(allRows);
3489     } else if (is&lt;AccessibilityTable&gt;(*this)) {
3490         auto&amp; thisTable = downcast&lt;AccessibilityTable&gt;(*this);
3491         if (thisTable.isExposableThroughAccessibility() &amp;&amp; thisTable.supportsSelectedRows())
3492             rowsIteration(thisTable.rows());
3493     }
3494 }
3495 
3496 void AccessibilityRenderObject::ariaListboxSelectedChildren(AccessibilityChildrenVector&amp; result)
3497 {
3498     bool isMulti = isMultiSelectable();
3499 
3500     for (const auto&amp; child : children()) {
3501         // Every child should have aria-role option, and if so, check for selected attribute/state.
3502         if (child-&gt;ariaRoleAttribute() == AccessibilityRole::ListBoxOption &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer())) {
3503             result.append(child);
3504             if (!isMulti)
3505                 return;
3506         }
3507     }
3508 }
3509 
3510 void AccessibilityRenderObject::selectedChildren(AccessibilityChildrenVector&amp; result)
3511 {
3512     ASSERT(result.isEmpty());
3513 
3514     if (!canHaveSelectedChildren())
3515         return;
3516 
3517     switch (roleValue()) {
3518     case AccessibilityRole::ListBox:
3519         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes
3520         ariaListboxSelectedChildren(result);
3521         return;
3522     case AccessibilityRole::Grid:
3523     case AccessibilityRole::Tree:
3524     case AccessibilityRole::TreeGrid:
3525         ariaSelectedRows(result);
3526         return;
3527     case AccessibilityRole::TabList:
3528         if (AccessibilityObject* selectedTab = selectedTabItem())
3529             result.append(selectedTab);
3530         return;
3531     case AccessibilityRole::List:
3532         if (auto* selectedListItemChild = selectedListItem())
3533             result.append(selectedListItemChild);
3534         return;
3535     case AccessibilityRole::Menu:
3536     case AccessibilityRole::MenuBar:
3537         if (AccessibilityObject* descendant = activeDescendant()) {
3538             result.append(descendant);
3539             return;
3540         }
3541         if (AccessibilityObject* focusedElement = static_cast&lt;AccessibilityObject*&gt;(focusedUIElement())) {
3542             result.append(focusedElement);
3543             return;
3544         }
3545         return;
3546     default:
3547         ASSERT_NOT_REACHED();
3548     }
3549 }
3550 
3551 void AccessibilityRenderObject::ariaListboxVisibleChildren(AccessibilityChildrenVector&amp; result)
3552 {
3553     if (!hasChildren())
3554         addChildren();
3555 
3556     for (const auto&amp; child : children()) {
3557         if (child-&gt;isOffScreen())
3558             result.append(child);
3559     }
3560 }
3561 
3562 void AccessibilityRenderObject::visibleChildren(AccessibilityChildrenVector&amp; result)
3563 {
3564     ASSERT(result.isEmpty());
3565 
3566     // only listboxes are asked for their visible children.
3567     if (ariaRoleAttribute() != AccessibilityRole::ListBox) {
3568         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes
3569         ASSERT_NOT_REACHED();
3570         return;
3571     }
3572     return ariaListboxVisibleChildren(result);
3573 }
3574 
3575 void AccessibilityRenderObject::tabChildren(AccessibilityChildrenVector&amp; result)
3576 {
3577     ASSERT(roleValue() == AccessibilityRole::TabList);
3578 
3579     for (const auto&amp; child : children()) {
3580         if (child-&gt;isTabItem())
3581             result.append(child);
3582     }
3583 }
3584 
3585 const String&amp; AccessibilityRenderObject::actionVerb() const
3586 {
3587 #if !PLATFORM(IOS_FAMILY)
3588     // FIXME: Need to add verbs for select elements.
3589     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
3590     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
3591     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
3592     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3593     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3594     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
3595 
3596     switch (roleValue()) {
3597     case AccessibilityRole::Button:
3598     case AccessibilityRole::ToggleButton:
3599         return buttonAction;
3600     case AccessibilityRole::TextField:
3601     case AccessibilityRole::TextArea:
3602         return textFieldAction;
3603     case AccessibilityRole::RadioButton:
3604         return radioButtonAction;
3605     case AccessibilityRole::CheckBox:
3606         return isChecked() ? checkedCheckBoxAction : uncheckedCheckBoxAction;
3607     case AccessibilityRole::Link:
3608     case AccessibilityRole::WebCoreLink:
3609         return linkAction;
3610     default:
3611         return nullAtom();
3612     }
3613 #else
3614     return nullAtom();
3615 #endif
3616 }
3617 
3618 void AccessibilityRenderObject::setAccessibleName(const AtomString&amp; name)
3619 {
3620     // Setting the accessible name can store the value in the DOM
3621     if (!m_renderer)
3622         return;
3623 
3624     Node* node = nullptr;
3625     // For web areas, set the aria-label on the HTML element.
3626     if (isWebArea())
3627         node = m_renderer-&gt;document().documentElement();
3628     else
3629         node = m_renderer-&gt;node();
3630 
3631     if (is&lt;Element&gt;(node))
3632         downcast&lt;Element&gt;(*node).setAttribute(aria_labelAttr, name);
3633 }
3634 
3635 static bool isLinkable(const AccessibilityRenderObject&amp; object)
3636 {
3637     if (!object.renderer())
3638         return false;
3639 
3640     // See https://wiki.mozilla.org/Accessibility/AT-Windows-API for the elements
3641     // Mozilla considers linkable.
3642     return object.isLink() || object.isImage() || object.renderer()-&gt;isText();
3643 }
3644 
3645 String AccessibilityRenderObject::stringValueForMSAA() const
3646 {
3647     if (isLinkable(*this)) {
3648         Element* anchor = anchorElement();
3649         if (is&lt;HTMLAnchorElement&gt;(anchor))
3650             return downcast&lt;HTMLAnchorElement&gt;(*anchor).href();
3651     }
3652 
3653     return stringValue();
3654 }
3655 
3656 bool AccessibilityRenderObject::isLinked() const
3657 {
3658     if (!isLinkable(*this))
3659         return false;
3660 
3661     Element* anchor = anchorElement();
3662     if (!is&lt;HTMLAnchorElement&gt;(anchor))
3663         return false;
3664 
3665     return !downcast&lt;HTMLAnchorElement&gt;(*anchor).href().isEmpty();
3666 }
3667 
3668 bool AccessibilityRenderObject::hasBoldFont() const
3669 {
3670     if (!m_renderer)
3671         return false;
3672 
3673     return isFontWeightBold(m_renderer-&gt;style().fontDescription().weight());
3674 }
3675 
3676 bool AccessibilityRenderObject::hasItalicFont() const
3677 {
3678     if (!m_renderer)
3679         return false;
3680 
3681     return isItalic(m_renderer-&gt;style().fontDescription().italic());
3682 }
3683 
3684 bool AccessibilityRenderObject::hasPlainText() const
3685 {
3686     if (!m_renderer)
3687         return false;
3688 
3689     if (!canHavePlainText())
3690         return false;
3691 
3692     const RenderStyle&amp; style = m_renderer-&gt;style();
3693     return style.fontDescription().weight() == normalWeightValue()
3694         &amp;&amp; !isItalic(style.fontDescription().italic())
3695         &amp;&amp; style.textDecorationsInEffect().isEmpty();
3696 }
3697 
3698 bool AccessibilityRenderObject::hasSameFont(RenderObject* renderer) const
3699 {
3700     if (!m_renderer || !renderer)
3701         return false;
3702 
3703     return m_renderer-&gt;style().fontDescription().families() == renderer-&gt;style().fontDescription().families();
3704 }
3705 
3706 #if ENABLE(APPLE_PAY)
3707 bool AccessibilityRenderObject::isApplePayButton() const
3708 {
3709     if (!m_renderer)
3710         return false;
3711     return m_renderer-&gt;style().appearance() == ApplePayButtonPart;
3712 }
3713 
3714 ApplePayButtonType AccessibilityRenderObject::applePayButtonType() const
3715 {
3716     if (!m_renderer)
3717         return ApplePayButtonType::Plain;
3718     return m_renderer-&gt;style().applePayButtonType();
3719 }
3720 #endif
3721 
3722 bool AccessibilityRenderObject::hasSameFontColor(RenderObject* renderer) const
3723 {
3724     if (!m_renderer || !renderer)
3725         return false;
3726 
3727     return m_renderer-&gt;style().visitedDependentColor(CSSPropertyColor) == renderer-&gt;style().visitedDependentColor(CSSPropertyColor);
3728 }
3729 
3730 bool AccessibilityRenderObject::hasSameStyle(RenderObject* renderer) const
3731 {
3732     if (!m_renderer || !renderer)
3733         return false;
3734 
3735     return m_renderer-&gt;style() == renderer-&gt;style();
3736 }
3737 
3738 bool AccessibilityRenderObject::hasUnderline() const
3739 {
3740     if (!m_renderer)
3741         return false;
3742 
3743     return m_renderer-&gt;style().textDecorationsInEffect().contains(TextDecoration::Underline);
3744 }
3745 
3746 String AccessibilityRenderObject::nameForMSAA() const
3747 {
3748     if (m_renderer &amp;&amp; m_renderer-&gt;isText())
3749         return textUnderElement();
3750 
3751     return title();
3752 }
3753 
3754 static bool shouldReturnTagNameAsRoleForMSAA(const Element&amp; element)
3755 {
3756     return element.hasTagName(abbrTag) || element.hasTagName(acronymTag)
3757         || element.hasTagName(blockquoteTag) || element.hasTagName(ddTag)
3758         || element.hasTagName(dlTag) || element.hasTagName(dtTag)
3759         || element.hasTagName(formTag) || element.hasTagName(frameTag)
3760         || element.hasTagName(h1Tag) || element.hasTagName(h2Tag)
3761         || element.hasTagName(h3Tag) || element.hasTagName(h4Tag)
3762         || element.hasTagName(h5Tag) || element.hasTagName(h6Tag)
3763         || element.hasTagName(iframeTag) || element.hasTagName(qTag)
3764         || element.hasTagName(tbodyTag) || element.hasTagName(tfootTag)
3765         || element.hasTagName(theadTag);
3766 }
3767 
3768 String AccessibilityRenderObject::stringRoleForMSAA() const
3769 {
3770     if (!m_renderer)
3771         return String();
3772 
3773     Node* node = m_renderer-&gt;node();
3774     if (!is&lt;Element&gt;(node))
3775         return String();
3776 
3777     Element&amp; element = downcast&lt;Element&gt;(*node);
3778     if (!shouldReturnTagNameAsRoleForMSAA(element))
3779         return String();
3780 
3781     return element.tagName();
3782 }
3783 
3784 String AccessibilityRenderObject::positionalDescriptionForMSAA() const
3785 {
3786     // See &quot;positional descriptions&quot;,
3787     // https://wiki.mozilla.org/Accessibility/AT-Windows-API
3788     if (isHeading())
3789         return makeString(&#39;L&#39;, headingLevel());
3790 
3791     // FIXME: Add positional descriptions for other elements.
3792     return String();
3793 }
3794 
3795 String AccessibilityRenderObject::descriptionForMSAA() const
3796 {
3797     String description = positionalDescriptionForMSAA();
3798     if (!description.isEmpty())
3799         return description;
3800 
3801     description = accessibilityDescription();
3802     if (!description.isEmpty()) {
3803         // From the Mozilla MSAA implementation:
3804         // &quot;Signal to screen readers that this description is speakable and is not
3805         // a formatted positional information description. Don&#39;t localize the
3806         // &#39;Description: &#39; part of this string, it will be parsed out by assistive
3807         // technologies.&quot;
3808         return &quot;Description: &quot; + description;
3809     }
3810 
3811     return String();
3812 }
3813 
3814 static AccessibilityRole msaaRoleForRenderer(const RenderObject* renderer)
3815 {
3816     if (!renderer)
3817         return AccessibilityRole::Unknown;
3818 
3819     if (is&lt;RenderText&gt;(*renderer))
3820         return AccessibilityRole::EditableText;
3821 
3822     if (is&lt;RenderListItem&gt;(*renderer))
3823         return AccessibilityRole::ListItem;
3824 
3825     return AccessibilityRole::Unknown;
3826 }
3827 
3828 AccessibilityRole AccessibilityRenderObject::roleValueForMSAA() const
3829 {
3830     if (m_roleForMSAA != AccessibilityRole::Unknown)
3831         return m_roleForMSAA;
3832 
3833     m_roleForMSAA = msaaRoleForRenderer(renderer());
3834 
3835     if (m_roleForMSAA == AccessibilityRole::Unknown)
3836         m_roleForMSAA = roleValue();
3837 
3838     return m_roleForMSAA;
3839 }
3840 
3841 String AccessibilityRenderObject::passwordFieldValue() const
3842 {
3843     ASSERT(isPasswordField());
3844 
3845     // Look for the RenderText object in the RenderObject tree for this input field.
3846     RenderObject* renderer = node()-&gt;renderer();
3847     while (renderer &amp;&amp; !is&lt;RenderText&gt;(renderer))
3848         renderer = downcast&lt;RenderElement&gt;(*renderer).firstChild();
3849 
3850     if (!is&lt;RenderText&gt;(renderer))
3851         return String();
3852 
3853     // Return the text that is actually being rendered in the input field.
3854     return downcast&lt;RenderText&gt;(*renderer).textWithoutConvertingBackslashToYenSymbol();
3855 }
3856 
3857 ScrollableArea* AccessibilityRenderObject::getScrollableAreaIfScrollable() const
3858 {
3859     // If the parent is a scroll view, then this object isn&#39;t really scrollable, the parent ScrollView should handle the scrolling.
3860     if (parentObject() &amp;&amp; parentObject()-&gt;isAccessibilityScrollView())
3861         return nullptr;
3862 
3863     if (!is&lt;RenderBox&gt;(renderer()))
3864         return nullptr;
3865 
3866     auto&amp; box = downcast&lt;RenderBox&gt;(*m_renderer);
3867     if (!box.canBeScrolledAndHasScrollableArea())
3868         return nullptr;
3869 
3870     return box.layer();
3871 }
3872 
3873 void AccessibilityRenderObject::scrollTo(const IntPoint&amp; point) const
3874 {
3875     if (!is&lt;RenderBox&gt;(renderer()))
3876         return;
3877 
3878     auto&amp; box = downcast&lt;RenderBox&gt;(*m_renderer);
3879     if (!box.canBeScrolledAndHasScrollableArea())
3880         return;
3881 
3882     // FIXME: is point a ScrollOffset or ScrollPosition? Test in RTL overflow.
3883     box.layer()-&gt;scrollToOffset(point);
3884 }
3885 
3886 #if ENABLE(MATHML)
3887 bool AccessibilityRenderObject::isIgnoredElementWithinMathTree() const
3888 {
3889     // We ignore anonymous boxes inserted into RenderMathMLBlocks to honor CSS rules.
3890     // See https://www.w3.org/TR/css3-box/#block-level0
3891     return m_renderer &amp;&amp; m_renderer-&gt;isAnonymous() &amp;&amp; m_renderer-&gt;parent() &amp;&amp; is&lt;RenderMathMLBlock&gt;(m_renderer-&gt;parent());
3892 }
3893 #endif
3894 
3895 } // namespace WebCore
    </pre>
  </body>
</html>