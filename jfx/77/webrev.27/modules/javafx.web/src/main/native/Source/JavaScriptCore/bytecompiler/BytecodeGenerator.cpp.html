<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 
  34 #include &quot;ArithProfile.h&quot;
  35 #include &quot;BuiltinExecutables.h&quot;
  36 #include &quot;BuiltinNames.h&quot;
  37 #include &quot;BytecodeGeneratorification.h&quot;
  38 #include &quot;BytecodeLivenessAnalysis.h&quot;
  39 #include &quot;BytecodeStructs.h&quot;
  40 #include &quot;BytecodeUseDef.h&quot;
  41 #include &quot;CatchScope.h&quot;
  42 #include &quot;DefinePropertyAttributes.h&quot;
  43 #include &quot;Interpreter.h&quot;
  44 #include &quot;JSAsyncGeneratorFunction.h&quot;
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
  47 #include &quot;JSFixedArray.h&quot;
  48 #include &quot;JSFunction.h&quot;
  49 #include &quot;JSGeneratorFunction.h&quot;
  50 #include &quot;JSImmutableButterfly.h&quot;
  51 #include &quot;JSLexicalEnvironment.h&quot;
  52 #include &quot;JSTemplateObjectDescriptor.h&quot;
  53 #include &quot;LowLevelInterpreter.h&quot;
  54 #include &quot;Options.h&quot;
  55 #include &quot;PreciseJumpTargetsInlines.h&quot;
  56 #include &quot;StackAlignment.h&quot;
  57 #include &quot;StrongInlines.h&quot;
  58 #include &quot;SuperSamplerBytecodeScope.h&quot;
  59 #include &quot;UnlinkedCodeBlock.h&quot;
  60 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  61 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  62 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  63 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  64 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  65 #include &lt;wtf/BitVector.h&gt;
  66 #include &lt;wtf/CommaPrinter.h&gt;
  67 #include &lt;wtf/Optional.h&gt;
  68 #include &lt;wtf/SmallPtrSet.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 #include &lt;wtf/text/WTFString.h&gt;
  71 
  72 namespace JSC {
  73 
  74 template&lt;typename CallOp, typename = std::true_type&gt;
  75 struct VarArgsOp;
  76 
  77 template&lt;typename CallOp&gt;
  78 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  79     using type = OpTailCallVarargs;
  80 };
  81 
  82 
  83 template&lt;typename CallOp&gt;
  84 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  85     using type = OpCallVarargs;
  86 };
  87 
  88 
  89 template&lt;typename T&gt;
  90 static inline void shrinkToFit(T&amp; segmentedVector)
  91 {
  92     while (segmentedVector.size() &amp;&amp; !segmentedVector.last().refCount())
  93         segmentedVector.removeLast();
  94 }
  95 
  96 void Label::setLocation(BytecodeGenerator&amp; generator, unsigned location)
  97 {
  98     m_location = location;
  99 
 100     for (auto offset : m_unresolvedJumps) {
 101         auto instruction = generator.m_writer.ref(offset);
 102         int target = m_location - offset;
 103 
 104 #define CASE(__op) \
 105     case __op::opcodeID:  \
 106         instruction-&gt;cast&lt;__op&gt;()-&gt;setTargetLabel(BoundLabel(target), [&amp;]() { \
 107             generator.m_codeBlock-&gt;addOutOfLineJumpTarget(instruction.offset(), target); \
 108             return BoundLabel(); \
 109         }); \
 110         break;
 111 
 112         switch (instruction-&gt;opcodeID()) {
 113         CASE(OpJmp)
 114         CASE(OpJtrue)
 115         CASE(OpJfalse)
 116         CASE(OpJeqNull)
 117         CASE(OpJneqNull)
 118         CASE(OpJundefinedOrNull)
 119         CASE(OpJnundefinedOrNull)
 120         CASE(OpJeq)
 121         CASE(OpJstricteq)
 122         CASE(OpJneq)
 123         CASE(OpJneqPtr)
 124         CASE(OpJnstricteq)
 125         CASE(OpJless)
 126         CASE(OpJlesseq)
 127         CASE(OpJgreater)
 128         CASE(OpJgreatereq)
 129         CASE(OpJnless)
 130         CASE(OpJnlesseq)
 131         CASE(OpJngreater)
 132         CASE(OpJngreatereq)
 133         CASE(OpJbelow)
 134         CASE(OpJbeloweq)
 135         default:
 136             ASSERT_NOT_REACHED();
 137         }
 138 #undef CASE
 139     }
 140 }
 141 
 142 int BoundLabel::target()
 143 {
 144     switch (m_type) {
 145     case Offset:
 146         return m_target;
 147     case GeneratorBackward:
 148         return m_target - m_generator-&gt;m_writer.position();
 149     case GeneratorForward:
 150         return 0;
 151     default:
 152         RELEASE_ASSERT_NOT_REACHED();
 153     }
 154 }
 155 
 156 int BoundLabel::saveTarget()
 157 {
 158     if (m_type == GeneratorForward) {
 159         m_savedTarget = m_generator-&gt;m_writer.position();
 160         return 0;
 161     }
 162 
 163     m_savedTarget = target();
 164     return m_savedTarget;
 165 }
 166 
 167 int BoundLabel::commitTarget()
 168 {
 169     if (m_type == GeneratorForward) {
 170         m_label-&gt;m_unresolvedJumps.append(m_savedTarget);
 171         return 0;
 172     }
 173 
 174     return m_savedTarget;
 175 }
 176 
 177 void Variable::dump(PrintStream&amp; out) const
 178 {
 179     out.print(
 180         &quot;{ident = &quot;, m_ident,
 181         &quot;, offset = &quot;, m_offset,
 182         &quot;, local = &quot;, RawPointer(m_local),
 183         &quot;, attributes = &quot;, m_attributes,
 184         &quot;, kind = &quot;, m_kind,
 185         &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
 186         &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
 187 }
 188 
 189 FinallyContext::FinallyContext(BytecodeGenerator&amp; generator, Label&amp; finallyLabel)
 190     : m_outerContext(generator.m_currentFinallyContext)
 191     , m_finallyLabel(&amp;finallyLabel)
 192 {
 193     ASSERT(m_jumps.isEmpty());
 194     m_completionRecord.typeRegister = generator.newTemporary();
 195     m_completionRecord.valueRegister = generator.newTemporary();
 196     generator.emitLoad(completionTypeRegister(), CompletionType::Normal);
 197     generator.moveEmptyValue(completionValueRegister());
 198 }
 199 
 200 ParserError BytecodeGenerator::generate()
 201 {
 202     m_codeBlock-&gt;setThisRegister(m_thisRegister.virtualRegister());
 203 
 204     emitLogShadowChickenPrologueIfNecessary();
 205 
 206     // If we have declared a variable named &quot;arguments&quot; and we are using arguments then we should
 207     // perform that assignment now.
 208     if (m_needToInitializeArguments)
 209         initializeVariable(variable(propertyNames().arguments), m_argumentsRegister);
 210 
 211     if (m_restParameter)
 212         m_restParameter-&gt;emit(*this);
 213 
 214     {
 215         RefPtr&lt;RegisterID&gt; temp = newTemporary();
 216         RefPtr&lt;RegisterID&gt; tolLevelScope;
 217         for (auto functionPair : m_functionsToInitialize) {
 218             FunctionMetadataNode* metadata = functionPair.first;
 219             FunctionVariableType functionType = functionPair.second;
 220             emitNewFunction(temp.get(), metadata);
 221             if (functionType == NormalFunctionVariable)
 222                 initializeVariable(variable(metadata-&gt;ident()), temp.get());
 223             else if (functionType == TopLevelFunctionVariable) {
 224                 if (!tolLevelScope) {
 225                     // We know this will resolve to the top level scope or global object because our parser/global initialization code
 226                     // doesn&#39;t allow let/const/class variables to have the same names as functions.
 227                     // This is a top level function, and it&#39;s an error to ever create a top level function
 228                     // name that would resolve to a lexical variable. E.g:
 229                     // ```
 230                     //     function f() {
 231                     //         {
 232                     //             let x;
 233                     //             {
 234                     //             //// error thrown here
 235                     //                  eval(&quot;function x(){}&quot;);
 236                     //             }
 237                     //         }
 238                     //     }
 239                     // ```
 240                     // Therefore, we&#39;re guaranteed to have this resolve to a top level variable.
 241                     RefPtr&lt;RegisterID&gt; tolLevelObjectScope = emitResolveScope(nullptr, Variable(metadata-&gt;ident()));
 242                     tolLevelScope = newBlockScopeVariable();
 243                     move(tolLevelScope.get(), tolLevelObjectScope.get());
 244                 }
 245                 emitPutToScope(tolLevelScope.get(), Variable(metadata-&gt;ident()), temp.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
 246             } else
 247                 RELEASE_ASSERT_NOT_REACHED();
 248         }
 249     }
 250 
 251     bool callingClassConstructor = constructorKind() != ConstructorKind::None &amp;&amp; !isConstructor();
 252     if (!callingClassConstructor)
 253         m_scopeNode-&gt;emitBytecode(*this);
 254     else {
 255         // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
 256         // just an artifact of how this generator is structured. That code never runs, but it confuses
 257         // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
 258         // basic block the strongest way possible.
 259         emitUnreachable();
 260     }
 261 
 262     for (auto&amp; handler : m_exceptionHandlersToEmit) {
 263         Ref&lt;Label&gt; realCatchTarget = newLabel();
 264         TryData* tryData = handler.tryData;
 265 
 266         OpCatch::emit(this, handler.exceptionRegister, handler.thrownValueRegister);
 267         realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
 268         if (handler.completionTypeRegister.isValid()) {
 269             RegisterID completionTypeRegister { handler.completionTypeRegister };
 270             CompletionType completionType =
 271                 tryData-&gt;handlerType == HandlerType::Finally || tryData-&gt;handlerType == HandlerType::SynthesizedFinally
 272                 ? CompletionType::Throw
 273                 : CompletionType::Normal;
 274             emitLoad(&amp;completionTypeRegister, completionType);
 275         }
 276         m_codeBlock-&gt;addJumpTarget(m_lastInstruction.offset());
 277 
 278 
 279         emitJump(tryData-&gt;target.get());
 280         tryData-&gt;target = WTFMove(realCatchTarget);
 281     }
 282 
 283     m_staticPropertyAnalyzer.kill();
 284 
 285     for (auto&amp; range : m_tryRanges) {
 286         int start = range.start-&gt;bind();
 287         int end = range.end-&gt;bind();
 288 
 289         // This will happen for empty try blocks and for some cases of finally blocks:
 290         //
 291         // try {
 292         //    try {
 293         //    } finally {
 294         //        return 42;
 295         //        // *HERE*
 296         //    }
 297         // } finally {
 298         //    print(&quot;things&quot;);
 299         // }
 300         //
 301         // The return will pop scopes to execute the outer finally block. But this includes
 302         // popping the try context for the inner try. The try context is live in the fall-through
 303         // part of the finally block not because we will emit a handler that overlaps the finally,
 304         // but because we haven&#39;t yet had a chance to plant the catch target. Then when we finish
 305         // emitting code for the outer finally block, we repush the try contex, this time with a
 306         // new start index. But that means that the start index for the try range corresponding
 307         // to the inner-finally-following-the-return (marked as &quot;*HERE*&quot; above) will be greater
 308         // than the end index of the try block. This is harmless since end &lt; start handlers will
 309         // never get matched in our logic, but we do the runtime a favor and choose to not emit
 310         // such handlers at all.
 311         if (end &lt;= start)
 312             continue;
 313 
 314         UnlinkedHandlerInfo info(static_cast&lt;uint32_t&gt;(start), static_cast&lt;uint32_t&gt;(end),
 315             static_cast&lt;uint32_t&gt;(range.tryData-&gt;target-&gt;bind()), range.tryData-&gt;handlerType);
 316         m_codeBlock-&gt;addExceptionHandler(info);
 317     }
 318 
 319 
 320     if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
 321         performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
 322 
 323     RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
 324     m_codeBlock-&gt;setInstructions(m_writer.finalize());
 325 
 326     m_codeBlock-&gt;shrinkToFit();
 327 
 328     if (m_expressionTooDeep)
 329         return ParserError(ParserError::OutOfMemory);
 330     return ParserError(ParserError::ErrorNone);
 331 }
 332 
 333 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
 334     : m_codeGenerationMode(codeGenerationMode)
 335     , m_scopeNode(programNode)
 336     , m_codeBlock(vm, codeBlock)
 337     , m_thisRegister(CallFrame::thisArgumentOffset())
 338     , m_codeType(GlobalCode)
 339     , m_vm(vm)
 340     , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
 341 {
 342     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 343 
 344     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 345         constantRegister = nullptr;
 346 
 347     allocateCalleeSaveSpace();
 348 
 349     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 350 
 351     emitEnter();
 352 
 353     allocateAndEmitScope();
 354 
 355     const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
 356 
 357     for (auto* function : functionStack)
 358         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 359 
 360     if (Options::validateBytecode()) {
 361         for (auto&amp; entry : programNode-&gt;varDeclarations())
 362             RELEASE_ASSERT(entry.value.isVar());
 363     }
 364     codeBlock-&gt;setVariableDeclarations(programNode-&gt;varDeclarations());
 365     codeBlock-&gt;setLexicalDeclarations(programNode-&gt;lexicalVariables());
 366     // Even though this program may have lexical variables that go under TDZ, when linking the get_from_scope/put_to_scope
 367     // operations we emit we will have ResolveTypes that implictly do TDZ checks. Therefore, we don&#39;t need
 368     // additional TDZ checks on top of those. This is why we can omit pushing programNode-&gt;lexicalVariables()
 369     // to the TDZ stack.
 370 
 371     if (needsToUpdateArrowFunctionContext()) {
 372         initializeArrowFunctionContextScopeIfNeeded();
 373         emitPutThisToArrowFunctionContextScope();
 374     }
 375 }
 376 
 377 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
 378     : m_codeGenerationMode(codeGenerationMode)
 379     , m_scopeNode(functionNode)
 380     , m_codeBlock(vm, codeBlock)
 381     , m_codeType(FunctionCode)
 382     , m_vm(vm)
 383     , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
 384     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 385     // FIXME: We should be able to have tail call elimination with the profiler
 386     // enabled. This is currently not possible because the profiler expects
 387     // op_will_call / op_did_call pairs before and after a call, which are not
 388     // compatible with tail calls (we have no way of emitting op_did_call).
 389     // https://bugs.webkit.org/show_bug.cgi?id=148819
 390     , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
 391     , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
 392     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 393 {
 394     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 395         constantRegister = nullptr;
 396 
 397     allocateCalleeSaveSpace();
 398 
 399     SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);
 400     functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 401     int symbolTableConstantIndex = 0;
 402 
 403     FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 404     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
 405     // This implements IsSimpleParameterList in the Ecma 2015 spec.
 406     // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
 407     // IsSimpleParameterList is false if the argument list contains any default parameter values,
 408     // a rest parameter, or any destructuring patterns.
 409     // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
 410     bool isSimpleParameterList = parameters.isSimpleParameterList();
 411 
 412     SourceParseMode parseMode = codeBlock-&gt;parseMode();
 413 
 414     bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
 415     bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;
 416 
 417     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
 418     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));
 419 
 420     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 421         // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
 422         needsArguments = false;
 423     }
 424 
 425     if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
 426         // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
 427         // This is because arguments of a generator should be evaluated before starting it.
 428         // To workaround it, we evaluate these arguments as arguments of a wrapping generator function, and reference it from a generator.
 429         //
 430         //    function *gen(a, b = hello())
 431         //    {
 432         //        return {
 433         //            @generatorNext: function (@generator, @generatorState, @generatorValue, @generatorResumeMode, @generatorFrame)
 434         //            {
 435         //                arguments;  // This `arguments` should reference to the gen&#39;s arguments.
 436         //                ...
 437         //            }
 438         //        }
 439         //    }
 440         shouldCaptureSomeOfTheThings = true;
 441     }
 442 
 443     if (shouldCaptureAllOfTheThings)
 444         functionNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 445 
 446     auto captures = scopedLambda&lt;bool (UniquedStringImpl*)&gt;([&amp;] (UniquedStringImpl* uid) -&gt; bool {
 447         if (!shouldCaptureSomeOfTheThings)
 448             return false;
 449         if (needsArguments &amp;&amp; uid == propertyNames().arguments.impl()) {
 450             // Actually, we only need to capture the arguments object when we &quot;need full activation&quot;
 451             // because of name scopes. But historically we did it this way, so for now we just preserve
 452             // the old behavior.
 453             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=143072
 454             return true;
 455         }
 456         return functionNode-&gt;captures(uid);
 457     });
 458     auto varKind = [&amp;] (UniquedStringImpl* uid) -&gt; VarKind {
 459         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 460     };
 461 
 462     m_calleeRegister.setIndex(CallFrameSlot::callee);
 463 
 464     initializeParameters(parameters);
 465     ASSERT(!(isSimpleParameterList &amp;&amp; m_restParameter));
 466 
 467     emitEnter();
 468 
 469     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 470         m_generatorRegister = &amp;m_parameters[1];
 471 
 472     allocateAndEmitScope();
 473 
 474     if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
 475         ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
 476         ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
 477         bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
 478         bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
 479         bool markAsCaptured = isDynamicScope || isFunctionNameCaptured;
 480         emitPushFunctionNameScope(functionNode-&gt;ident(), &amp;m_calleeRegister, markAsCaptured);
 481     }
 482 
 483     if (shouldCaptureSomeOfTheThings)
 484         m_lexicalEnvironmentRegister = addVar();
 485 
 486     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode) || shouldCaptureSomeOfTheThings || shouldEmitTypeProfilerHooks())
 487         symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
 488 
 489     // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
 490     // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
 491     // the parent scope of the &quot;var&quot; environment is the parameter environment.
 492     if (isSimpleParameterList)
 493         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, shouldCaptureSomeOfTheThings);
 494 
 495     // Figure out some interesting facts about our arguments.
 496     bool capturesAnyArgumentByName = false;
 497     if (functionNode-&gt;hasCapturedVariables()) {
 498         FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 499         for (size_t i = 0; i &lt; parameters.size(); ++i) {
 500             auto pattern = parameters.at(i).first;
 501             if (!pattern-&gt;isBindingNode())
 502                 continue;
 503             const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
 504             capturesAnyArgumentByName |= captures(ident.impl());
 505         }
 506     }
 507 
 508     if (capturesAnyArgumentByName)
 509         ASSERT(m_lexicalEnvironmentRegister);
 510 
 511     // Need to know what our functions are called. Parameters have some goofy behaviors when it
 512     // comes to functions of the same name.
 513     for (FunctionMetadataNode* function : functionNode-&gt;functionStack())
 514         m_functions.add(function-&gt;ident().impl());
 515 
 516     if (needsArguments) {
 517         // Create the arguments object now. We may put the arguments object into the activation if
 518         // it is captured. Either way, we create two arguments object variables: one is our
 519         // private variable that is immutable, and another that is the user-visible variable. The
 520         // immutable one is only used here, or during formal parameter resolutions if we opt for
 521         // DirectArguments.
 522 
 523         m_argumentsRegister = addVar();
 524         m_argumentsRegister-&gt;ref();
 525     }
 526 
 527     if (needsArguments &amp;&amp; !codeBlock-&gt;isStrictMode() &amp;&amp; isSimpleParameterList) {
 528         // If we captured any formal parameter by name, then we use ScopedArguments. Otherwise we
 529         // use DirectArguments. With ScopedArguments, we lift all of our arguments into the
 530         // activation.
 531 
 532         if (capturesAnyArgumentByName) {
 533             functionSymbolTable-&gt;setArgumentsLength(vm, parameters.size());
 534 
 535             // For each parameter, we have two possibilities:
 536             // Either it&#39;s a binding node with no function overlap, in which case it gets a name
 537             // in the symbol table - or it just gets space reserved in the symbol table. Either
 538             // way we lift the value into the scope.
 539             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 540                 ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 541                 functionSymbolTable-&gt;setArgumentOffset(vm, i, offset);
 542                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first)) {
 543                     VarOffset varOffset(offset);
 544                     SymbolTableEntry entry(varOffset);
 545                     // Stores to these variables via the ScopedArguments object will not do
 546                     // notifyWrite(), since that would be cumbersome. Also, watching formal
 547                     // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
 548                     // So, we just disable it.
 549                     entry.disableWatching(m_vm);
 550                     functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
 551                 }
 552                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());
 553             }
 554 
 555             // This creates a scoped arguments object and copies the overflow arguments into the
 556             // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
 557             OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
 558         } else {
 559             // We&#39;re going to put all parameters into the DirectArguments object. First ensure
 560             // that the symbol table knows that this is happening.
 561             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 562                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first))
 563                     functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(DirectArgumentsOffset(i))));
 564             }
 565 
 566             OpCreateDirectArguments::emit(this, m_argumentsRegister);
 567         }
 568     } else if (isSimpleParameterList) {
 569         // Create the formal parameters the normal way. Any of them could be captured, or not. If
 570         // captured, lift them into the scope. We cannot do this if we have default parameter expressions
 571         // because when default parameter expressions exist, they belong in their own lexical environment
 572         // separate from the &quot;var&quot; lexical environment.
 573         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 574             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 575             if (!name)
 576                 continue;
 577 
 578             if (!captures(name)) {
 579                 // This is the easy case - just tell the symbol table about the argument. It will
 580                 // be accessed directly.
 581                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgument(1 + i))));
 582                 continue;
 583             }
 584 
 585             ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 586             const Identifier&amp; ident =
 587                 static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
 588             functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
 589 
 590             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());
 591         }
 592     }
 593 
 594     if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
 595         // Allocate a cloned arguments object.
 596         OpCreateClonedArguments::emit(this, m_argumentsRegister);
 597     }
 598 
 599     // There are some variables that need to be preinitialized to something other than Undefined:
 600     //
 601     // - &quot;arguments&quot;: unless it&#39;s used as a function or parameter, this should refer to the
 602     //   arguments object.
 603     //
 604     // - functions: these always override everything else.
 605     //
 606     // The most logical way to do all of this is to initialize none of the variables until now,
 607     // and then initialize them in BytecodeGenerator::generate() in such an order that the rules
 608     // for how these things override each other end up holding. We would initialize &quot;arguments&quot; first,
 609     // then all arguments, then the functions.
 610     //
 611     // But some arguments are already initialized by default, since if they aren&#39;t captured and we
 612     // don&#39;t have &quot;arguments&quot; then we just point the symbol table at the stack slot of those
 613     // arguments. We end up initializing the rest of the arguments that have an uncomplicated
 614     // binding (i.e. don&#39;t involve destructuring) above when figuring out how to lay them out,
 615     // because that&#39;s just the simplest thing. This means that when we initialize them, we have to
 616     // watch out for the things that override arguments (namely, functions).
 617 
 618     // This is our final act of weirdness. &quot;arguments&quot; is overridden by everything except the
 619     // callee. We add it to the symbol table if it&#39;s not already there and it&#39;s not an argument.
 620     bool shouldCreateArgumentsVariableInParameterScope = false;
 621     if (needsArguments) {
 622         // If &quot;arguments&quot; is overridden by a function or destructuring parameter name, then it&#39;s
 623         // OK for us to call createVariable() because it won&#39;t change anything. It&#39;s also OK for
 624         // us to them tell BytecodeGenerator::generate() to write to it because it will do so
 625         // before it initializes functions and destructuring parameters. But if &quot;arguments&quot; is
 626         // overridden by a &quot;simple&quot; function parameter, then we have to bail: createVariable()
 627         // would assert and BytecodeGenerator::generate() would write the &quot;arguments&quot; after the
 628         // argument value had already been properly initialized.
 629 
 630         bool haveParameterNamedArguments = false;
 631         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 632             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 633             if (name == propertyNames().arguments.impl()) {
 634                 haveParameterNamedArguments = true;
 635                 break;
 636             }
 637         }
 638 
 639         bool shouldCreateArgumensVariable = !haveParameterNamedArguments
 640             &amp;&amp; !SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(m_codeBlock-&gt;parseMode());
 641         shouldCreateArgumentsVariableInParameterScope = shouldCreateArgumensVariable &amp;&amp; !isSimpleParameterList;
 642         // Do not create arguments variable in case of Arrow function. Value will be loaded from parent scope
 643         if (shouldCreateArgumensVariable &amp;&amp; !shouldCreateArgumentsVariableInParameterScope) {
 644             createVariable(
 645                 propertyNames().arguments, varKind(propertyNames().arguments.impl()), functionSymbolTable);
 646 
 647             m_needToInitializeArguments = true;
 648         }
 649     }
 650 
 651     for (FunctionMetadataNode* function : functionNode-&gt;functionStack()) {
 652         const Identifier&amp; ident = function-&gt;ident();
 653         createVariable(ident, varKind(ident.impl()), functionSymbolTable);
 654         m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
 655     }
 656     for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
 657         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 658         if (!entry.value.isVar()) // This is either a parameter or callee.
 659             continue;
 660         if (shouldCreateArgumentsVariableInParameterScope &amp;&amp; entry.key.get() == propertyNames().arguments.impl())
 661             continue;
 662         createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
 663     }
 664 
 665 
 666     if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())
 667         m_newTargetRegister = addVar();
 668 
 669     switch (parseMode) {
 670     case SourceParseMode::GeneratorWrapperFunctionMode:
 671     case SourceParseMode::GeneratorWrapperMethodMode:
 672     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 673     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
 674         m_generatorRegister = addVar();
 675 
 676         // FIXME: Emit to_this only when Generator uses it.
 677         // https://bugs.webkit.org/show_bug.cgi?id=151586
 678         emitToThis();
 679 
 680         move(m_generatorRegister, &amp;m_calleeRegister);
 681         emitCreateThis(m_generatorRegister);
 682         break;
 683     }
 684 
 685     case SourceParseMode::AsyncArrowFunctionMode:
 686     case SourceParseMode::AsyncMethodMode:
 687     case SourceParseMode::AsyncFunctionMode: {
 688         ASSERT(!isConstructor());
 689         ASSERT(constructorKind() == ConstructorKind::None);
 690         m_generatorRegister = addVar();
 691         m_promiseCapabilityRegister = addVar();
 692 
 693         if (parseMode != SourceParseMode::AsyncArrowFunctionMode) {
 694             // FIXME: Emit to_this only when AsyncFunctionBody uses it.
 695             // https://bugs.webkit.org/show_bug.cgi?id=151586
 696             emitToThis();
 697         }
 698 
 699         emitNewObject(m_generatorRegister);
 700 
 701         // let promiseCapability be @newPromiseCapability(@Promise)
 702         auto varNewPromiseCapability = variable(propertyNames().builtinNames().newPromiseCapabilityPrivateName());
 703         RefPtr&lt;RegisterID&gt; scope = newTemporary();
 704         move(scope.get(), emitResolveScope(scope.get(), varNewPromiseCapability));
 705         RefPtr&lt;RegisterID&gt; newPromiseCapability = emitGetFromScope(newTemporary(), scope.get(), varNewPromiseCapability, ThrowIfNotFound);
 706 
 707         CallArguments args(*this, nullptr, 1);
 708         emitLoad(args.thisRegister(), jsUndefined());
 709 
 710         auto&amp; builtinNames = propertyNames().builtinNames();
 711         auto varPromiseConstructor = variable(m_isBuiltinFunction ? builtinNames.InternalPromisePrivateName() : builtinNames.PromisePrivateName());
 712         move(scope.get(), emitResolveScope(scope.get(), varPromiseConstructor));
 713         emitGetFromScope(args.argumentRegister(0), scope.get(), varPromiseConstructor, ThrowIfNotFound);
 714 
 715         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
 716         JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
 717         emitCall(promiseCapabilityRegister(), newPromiseCapability.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
 718         break;
 719     }
 720 
 721     case SourceParseMode::AsyncGeneratorBodyMode:
 722     case SourceParseMode::AsyncFunctionBodyMode:
 723     case SourceParseMode::AsyncArrowFunctionBodyMode:
 724     case SourceParseMode::GeneratorBodyMode: {
 725         // |this| is already filled correctly before here.
 726         if (m_newTargetRegister)
 727             emitLoad(m_newTargetRegister, jsUndefined());
 728         break;
 729     }
 730 
 731     default: {
 732         if (SourceParseMode::ArrowFunctionMode != parseMode) {
 733             if (isConstructor()) {
 734                 if (m_newTargetRegister)
 735                     move(m_newTargetRegister, &amp;m_thisRegister);
 736                 if (constructorKind() == ConstructorKind::Extends) {
 737                     moveEmptyValue(&amp;m_thisRegister);
 738                 } else
 739                     emitCreateThis(&amp;m_thisRegister);
 740             } else if (constructorKind() != ConstructorKind::None)
 741                 emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);
 742             else {
 743                 bool shouldEmitToThis = false;
 744                 if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())
 745                     shouldEmitToThis = true;
 746                 else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {
 747                     // We must emit to_this when we&#39;re not in strict mode because we
 748                     // will convert |this| to an object, and that object may be passed
 749                     // to a strict function as |this|. This is observable because that
 750                     // strict function&#39;s to_this will just return the object.
 751                     //
 752                     // We don&#39;t need to emit this for strict-mode code because
 753                     // strict-mode code may call another strict function, which will
 754                     // to_this if it directly uses this; this is OK, because we defer
 755                     // to_this until |this| is used directly. Strict-mode code might
 756                     // also call a sloppy mode function, and that will to_this, which
 757                     // will defer the conversion, again, until necessary.
 758                     shouldEmitToThis = true;
 759                 }
 760 
 761                 if (shouldEmitToThis)
 762                     emitToThis();
 763             }
 764         }
 765         break;
 766     }
 767     }
 768 
 769     // We need load |super| &amp; |this| for arrow function before initializeDefaultParameterValuesAndSetupFunctionScopeStack
 770     // if we have default parameter expression. Because |super| &amp; |this| values can be used there
 771     if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 772         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 773             emitLoadThisFromArrowFunctionLexicalEnvironment();
 774 
 775         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 776             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 777     }
 778 
 779     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
 780         bool canReuseLexicalEnvironment = isSimpleParameterList;
 781         initializeArrowFunctionContextScopeIfNeeded(functionSymbolTable, canReuseLexicalEnvironment);
 782         emitPutThisToArrowFunctionContextScope();
 783         emitPutNewTargetToArrowFunctionContextScope();
 784         emitPutDerivedConstructorToArrowFunctionContextScope();
 785     }
 786 
 787     // All &quot;addVar()&quot;s needs to happen before &quot;initializeDefaultParameterValuesAndSetupFunctionScopeStack()&quot; is called
 788     // because a function&#39;s default parameter ExpressionNodes will use temporary registers.
 789     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 790 
 791     Ref&lt;Label&gt; catchLabel = newLabel();
 792     TryData* tryFormalParametersData = nullptr;
 793     bool needTryCatch = isAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; !isSimpleParameterList;
 794     if (needTryCatch) {
 795         Ref&lt;Label&gt; tryFormalParametersStart = newEmittedLabel();
 796         tryFormalParametersData = pushTry(tryFormalParametersStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
 797     }
 798 
 799     initializeDefaultParameterValuesAndSetupFunctionScopeStack(parameters, isSimpleParameterList, functionNode, functionSymbolTable, symbolTableConstantIndex, captures, shouldCreateArgumentsVariableInParameterScope);
 800 
 801     if (needTryCatch) {
 802         Ref&lt;Label&gt; didNotThrow = newLabel();
 803         emitJump(didNotThrow.get());
 804         emitLabel(catchLabel.get());
 805         popTry(tryFormalParametersData, catchLabel.get());
 806 
 807         RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
 808         emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);
 809 
 810         // return promiseCapability.@reject(thrownValue)
 811         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().rejectPrivateName());
 812 
 813         CallArguments args(*this, nullptr, 1);
 814         emitLoad(args.thisRegister(), jsUndefined());
 815         move(args.argumentRegister(0), thrownValue.get());
 816 
 817         JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
 818 
 819         RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
 820         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().promisePrivateName()));
 821 
 822         emitLabel(didNotThrow.get());
 823     }
 824 
 825     // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
 826     // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
 827     // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
 828     if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
 829         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 830             emitLoadThisFromArrowFunctionLexicalEnvironment();
 831 
 832         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 833             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 834     }
 835 
 836     // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
 837     // Since they are symbol keyed, these variables cannot be reached from the usual code.
 838     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 839         m_generatorFrameSymbolTable.set(m_vm, functionSymbolTable);
 840         m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
 841         if (m_lexicalEnvironmentRegister)
 842             move(generatorFrameRegister(), m_lexicalEnvironmentRegister);
 843         else {
 844             // It would be possible that generator does not need to suspend and resume any registers.
 845             // In this case, we would like to avoid creating a lexical environment as much as possible.
 846             // op_create_generator_frame_environment is a marker, which is similar to op_yield.
 847             // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.
 848             OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
 849         }
 850         emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());
 851     }
 852 
 853     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 854     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 855 }
 856 
 857 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
 858     : m_codeGenerationMode(codeGenerationMode)
 859     , m_scopeNode(evalNode)
 860     , m_codeBlock(vm, codeBlock)
 861     , m_thisRegister(CallFrame::thisArgumentOffset())
 862     , m_codeType(EvalCode)
 863     , m_vm(vm)
 864     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 865     , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
 866     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 867 {
 868     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 869         constantRegister = nullptr;
 870 
 871     allocateCalleeSaveSpace();
 872 
 873     m_codeBlock-&gt;setNumParameters(1);
 874 
 875     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 876 
 877     emitEnter();
 878 
 879     allocateAndEmitScope();
 880 
 881     for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
 882         m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
 883         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 884     }
 885 
 886     const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
 887     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
 888     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
 889     for (auto&amp; entry : varDeclarations) {
 890         ASSERT(entry.value.isVar());
 891         ASSERT(entry.key-&gt;isAtom() || entry.key-&gt;isSymbol());
 892         if (entry.value.isSloppyModeHoistingCandidate())
 893             hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
 894         else
 895             variables.append(Identifier::fromUid(m_vm, entry.key.get()));
 896     }
 897     codeBlock-&gt;adoptVariables(variables);
 898     codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
 899 
 900     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 901         m_newTargetRegister = addVar();
 902 
 903     if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
 904         emitLoadThisFromArrowFunctionLexicalEnvironment();
 905 
 906     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 907         emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 908 
 909     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
 910         initializeArrowFunctionContextScopeIfNeeded();
 911         emitPutThisToArrowFunctionContextScope();
 912     }
 913 
 914     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 915     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 916 }
 917 
 918 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
 919     : m_codeGenerationMode(codeGenerationMode)
 920     , m_scopeNode(moduleProgramNode)
 921     , m_codeBlock(vm, codeBlock)
 922     , m_thisRegister(CallFrame::thisArgumentOffset())
 923     , m_codeType(ModuleCode)
 924     , m_vm(vm)
 925     , m_usesNonStrictEval(false)
 926     , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
 927 {
 928     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 929 
 930     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 931         constantRegister = nullptr;
 932 
 933     allocateCalleeSaveSpace();
 934 
 935     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);
 936     moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 937     moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
 938 
 939     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
 940     if (shouldCaptureAllOfTheThings)
 941         moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 942 
 943     auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
 944         return moduleProgramNode-&gt;captures(uid);
 945     };
 946     auto lookUpVarKind = [&amp;] (UniquedStringImpl* uid, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
 947         // Allocate the exported variables in the module environment.
 948         if (entry.isExported())
 949             return VarKind::Scope;
 950 
 951         // Allocate the namespace variables in the module environment to instantiate
 952         // it from the outside of the module code.
 953         if (entry.isImportedNamespace())
 954             return VarKind::Scope;
 955 
 956         if (entry.isCaptured())
 957             return VarKind::Scope;
 958         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 959     };
 960 
 961     emitEnter();
 962 
 963     allocateAndEmitScope();
 964 
 965     m_calleeRegister.setIndex(CallFrameSlot::callee);
 966 
 967     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 968 
 969     // Now declare all variables.
 970 
 971     createVariable(m_vm.propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);
 972 
 973     for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
 974         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 975         if (!entry.value.isVar()) // This is either a parameter or callee.
 976             continue;
 977         // Imported bindings are not allocated in the module environment as usual variables&#39; way.
 978         // These references remain the &quot;Dynamic&quot; in the unlinked code block. Later, when linking
 979         // the code block, we resolve the reference to the &quot;ModuleVar&quot;.
 980         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
 981             continue;
 982         createVariable(Identifier::fromUid(m_vm, entry.key.get()), lookUpVarKind(entry.key.get(), entry.value), moduleEnvironmentSymbolTable, IgnoreExisting);
 983     }
 984 
 985     VariableEnvironment&amp; lexicalVariables = moduleProgramNode-&gt;lexicalVariables();
 986     instantiateLexicalVariables(lexicalVariables, moduleEnvironmentSymbolTable, ScopeRegisterType::Block, lookUpVarKind);
 987 
 988     // We keep the symbol table in the constant pool.
 989     RegisterID* constantSymbolTable = nullptr;
 990     if (shouldEmitTypeProfilerHooks())
 991         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable);
 992     else
 993         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable-&gt;cloneScopePart(m_vm));
 994 
 995     pushTDZVariables(lexicalVariables, TDZCheckOptimization::Optimize, TDZRequirement::UnderTDZ);
 996     bool isWithScope = false;
 997     m_lexicalScopeStack.append({ moduleEnvironmentSymbolTable, m_topMostScope, isWithScope, constantSymbolTable-&gt;index() });
 998     emitPrefillStackTDZVariables(lexicalVariables, moduleEnvironmentSymbolTable);
 999 
1000     // makeFunction assumes that there&#39;s correct TDZ stack entries.
1001     // So it should be called after putting our lexical environment to the TDZ stack correctly.
1002 
1003     for (FunctionMetadataNode* function : moduleProgramNode-&gt;functionStack()) {
1004         const auto&amp; iterator = moduleProgramNode-&gt;varDeclarations().find(function-&gt;ident().impl());
1005         RELEASE_ASSERT(iterator != moduleProgramNode-&gt;varDeclarations().end());
1006         RELEASE_ASSERT(!iterator-&gt;value.isImported());
1007 
1008         VarKind varKind = lookUpVarKind(iterator-&gt;key.get(), iterator-&gt;value);
1009         if (varKind == VarKind::Scope) {
1010             // http://www.ecma-international.org/ecma-262/6.0/#sec-moduledeclarationinstantiation
1011             // Section 15.2.1.16.4, step 16-a-iv-1.
1012             // All heap allocated function declarations should be instantiated when the module environment
1013             // is created. They include the exported function declarations and not-exported-but-heap-allocated
1014             // function declarations. This is required because exported function should be instantiated before
1015             // executing the any module in the dependency graph. This enables the modules to link the imported
1016             // bindings before executing the any module code.
1017             //
1018             // And since function declarations are instantiated before executing the module body code, the spec
1019             // allows the functions inside the module to be executed before its module body is executed under
1020             // the circular dependencies. The following is the example.
1021             //
1022             // Module A (executed first):
1023             //    import { b } from &quot;B&quot;;
1024             //    // Here, the module &quot;B&quot; is not executed yet, but the function declaration is already instantiated.
1025             //    // So we can call the function exported from &quot;B&quot;.
1026             //    b();
1027             //
1028             //    export function a() {
1029             //    }
1030             //
1031             // Module B (executed second):
1032             //    import { a } from &quot;A&quot;;
1033             //
1034             //    export function b() {
1035             //        c();
1036             //    }
1037             //
1038             //    // c is not exported, but since it is referenced from the b, we should instantiate it before
1039             //    // executing the &quot;B&quot; module code.
1040             //    function c() {
1041             //        a();
1042             //    }
1043             //
1044             // Module EntryPoint (executed last):
1045             //    import &quot;B&quot;;
1046             //    import &quot;A&quot;;
1047             //
1048             m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
1049         } else {
1050             // Stack allocated functions can be allocated when executing the module&#39;s body.
1051             m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
1052         }
1053     }
1054 
1055     // Remember the constant register offset to the top-most symbol table. This symbol table will be
1056     // cloned in the code block linking. After that, to create the module environment, we retrieve
1057     // the cloned symbol table from the linked code block by using this offset.
1058     codeBlock-&gt;setModuleEnvironmentSymbolTableConstantRegisterOffset(constantSymbolTable-&gt;index());
1059 }
1060 
1061 BytecodeGenerator::~BytecodeGenerator()
1062 {
1063 }
1064 
1065 void BytecodeGenerator::initializeDefaultParameterValuesAndSetupFunctionScopeStack(
1066     FunctionParameters&amp; parameters, bool isSimpleParameterList, FunctionNode* functionNode, SymbolTable* functionSymbolTable,
1067     int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope)
1068 {
1069     Vector&lt;std::pair&lt;Identifier, RefPtr&lt;RegisterID&gt;&gt;&gt; valuesToMoveIntoVars;
1070     ASSERT(!(isSimpleParameterList &amp;&amp; shouldCreateArgumentsVariableInParameterScope));
1071     if (!isSimpleParameterList) {
1072         // Refer to the ES6 spec section 9.2.12: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
1073         // This implements step 21.
1074         VariableEnvironment environment;
1075         Vector&lt;Identifier&gt; allParameterNames;
1076         for (unsigned i = 0; i &lt; parameters.size(); i++)
1077             parameters.at(i).first-&gt;collectBoundIdentifiers(allParameterNames);
1078         if (shouldCreateArgumentsVariableInParameterScope)
1079             allParameterNames.append(propertyNames().arguments);
1080         IdentifierSet parameterSet;
1081         for (auto&amp; ident : allParameterNames) {
1082             parameterSet.add(ident.impl());
1083             auto addResult = environment.add(ident);
1084             addResult.iterator-&gt;value.setIsLet(); // When we have default parameter expressions, parameters act like &quot;let&quot; variables.
1085             if (captures(ident.impl()))
1086                 addResult.iterator-&gt;value.setIsCaptured();
1087         }
1088         // This implements step 25 of section 9.2.12.
1089         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1090 
1091         if (shouldCreateArgumentsVariableInParameterScope) {
1092             Variable argumentsVariable = variable(propertyNames().arguments);
1093             initializeVariable(argumentsVariable, m_argumentsRegister);
1094             liftTDZCheckIfPossible(argumentsVariable);
1095         }
1096 
1097         RefPtr&lt;RegisterID&gt; temp = newTemporary();
1098         for (unsigned i = 0; i &lt; parameters.size(); i++) {
1099             std::pair&lt;DestructuringPatternNode*, ExpressionNode*&gt; parameter = parameters.at(i);
1100             if (parameter.first-&gt;isRestParameter())
1101                 continue;
1102             if ((i + 1) &lt; m_parameters.size())
1103                 move(temp.get(), &amp;m_parameters[i + 1]);
1104             else
1105                 emitGetArgument(temp.get(), i);
1106             if (parameter.second) {
1107                 RefPtr&lt;RegisterID&gt; condition = emitIsUndefined(newTemporary(), temp.get());
1108                 Ref&lt;Label&gt; skipDefaultParameterBecauseNotUndefined = newLabel();
1109                 emitJumpIfFalse(condition.get(), skipDefaultParameterBecauseNotUndefined.get());
1110                 emitNode(temp.get(), parameter.second);
1111                 emitLabel(skipDefaultParameterBecauseNotUndefined.get());
1112             }
1113 
1114             parameter.first-&gt;bindValue(*this, temp.get());
1115         }
1116 
1117         // Final act of weirdness for default parameters. If a &quot;var&quot; also
1118         // has the same name as a parameter, it should start out as the
1119         // value of that parameter. Note, though, that they will be distinct
1120         // bindings.
1121         // This is step 28 of section 9.2.12.
1122         for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
1123             if (!entry.value.isVar()) // This is either a parameter or callee.
1124                 continue;
1125 
1126             if (parameterSet.contains(entry.key)) {
1127                 Identifier ident = Identifier::fromUid(m_vm, entry.key.get());
1128                 Variable var = variable(ident);
1129                 RegisterID* scope = emitResolveScope(nullptr, var);
1130                 RefPtr&lt;RegisterID&gt; value = emitGetFromScope(newTemporary(), scope, var, DoNotThrowIfNotFound);
1131                 valuesToMoveIntoVars.append(std::make_pair(ident, value));
1132             }
1133         }
1134 
1135         // Functions with default parameter expressions must have a separate environment
1136         // record for parameters and &quot;var&quot;s. The &quot;var&quot; environment record must have the
1137         // parameter environment record as its parent.
1138         // See step 28 of section 9.2.12.
1139         bool hasCapturedVariables = !!m_lexicalEnvironmentRegister;
1140         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, hasCapturedVariables);
1141     }
1142 
1143     // This completes step 28 of section 9.2.12.
1144     for (unsigned i = 0; i &lt; valuesToMoveIntoVars.size(); i++) {
1145         ASSERT(!isSimpleParameterList);
1146         Variable var = variable(valuesToMoveIntoVars[i].first);
1147         RegisterID* scope = emitResolveScope(nullptr, var);
1148         emitPutToScope(scope, var, valuesToMoveIntoVars[i].second.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
1149     }
1150 }
1151 
1152 bool BytecodeGenerator::needsDerivedConstructorInArrowFunctionLexicalEnvironment()
1153 {
1154     ASSERT(m_codeBlock-&gt;isClassContext() || !(isConstructor() &amp;&amp; constructorKind() == ConstructorKind::Extends));
1155     return m_codeBlock-&gt;isClassContext() &amp;&amp; isSuperUsedInInnerArrowFunction();
1156 }
1157 
1158 void BytecodeGenerator::initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable, bool canReuseLexicalEnvironment)
1159 {
1160     ASSERT(!m_arrowFunctionContextLexicalEnvironmentRegister);
1161 
1162     if (canReuseLexicalEnvironment &amp;&amp; m_lexicalEnvironmentRegister) {
1163         RELEASE_ASSERT(!m_codeBlock-&gt;isArrowFunction());
1164         RELEASE_ASSERT(functionSymbolTable);
1165 
1166         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalEnvironmentRegister;
1167 
1168         ScopeOffset offset;
1169 
1170         if (isThisUsedInInnerArrowFunction()) {
1171             offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
1172             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().thisIdentifier.impl(), SymbolTableEntry(VarOffset(offset)));
1173         }
1174 
1175         if (m_codeType == FunctionCode &amp;&amp; isNewTargetUsedInInnerArrowFunction()) {
1176             offset = functionSymbolTable-&gt;takeNextScopeOffset();
1177             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().builtinNames().newTargetLocalPrivateName().impl(), SymbolTableEntry(VarOffset(offset)));
1178         }
1179 
1180         if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1181             offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
1182             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().builtinNames().derivedConstructorPrivateName().impl(), SymbolTableEntry(VarOffset(offset)));
1183         }
1184 
1185         return;
1186     }
1187 
1188     VariableEnvironment environment;
1189 
1190     if (isThisUsedInInnerArrowFunction()) {
1191         auto addResult = environment.add(propertyNames().thisIdentifier);
1192         addResult.iterator-&gt;value.setIsCaptured();
1193         addResult.iterator-&gt;value.setIsLet();
1194     }
1195 
1196     if (m_codeType == FunctionCode &amp;&amp; isNewTargetUsedInInnerArrowFunction()) {
1197         auto addTarget = environment.add(propertyNames().builtinNames().newTargetLocalPrivateName());
1198         addTarget.iterator-&gt;value.setIsCaptured();
1199         addTarget.iterator-&gt;value.setIsLet();
1200     }
1201 
1202     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1203         auto derivedConstructor = environment.add(propertyNames().builtinNames().derivedConstructorPrivateName());
1204         derivedConstructor.iterator-&gt;value.setIsCaptured();
1205         derivedConstructor.iterator-&gt;value.setIsLet();
1206     }
1207 
1208     if (environment.size() &gt; 0) {
1209         size_t size = m_lexicalScopeStack.size();
1210         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1211 
1212         ASSERT_UNUSED(size, m_lexicalScopeStack.size() == size + 1);
1213 
1214         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalScopeStack.last().m_scope;
1215     }
1216 }
1217 
1218 RegisterID* BytecodeGenerator::initializeNextParameter()
1219 {
1220     VirtualRegister reg = virtualRegisterForArgument(m_codeBlock-&gt;numParameters());
1221     m_parameters.grow(m_parameters.size() + 1);
1222     auto&amp; parameter = registerFor(reg);
1223     parameter.setIndex(reg.offset());
1224     m_codeBlock-&gt;addParameter();
1225     return &amp;parameter;
1226 }
1227 
1228 void BytecodeGenerator::initializeParameters(FunctionParameters&amp; parameters)
1229 {
1230     // Make sure the code block knows about all of our parameters, and make sure that parameters
1231     // needing destructuring are noted.
1232     m_thisRegister.setIndex(initializeNextParameter()-&gt;index()); // this
1233 
1234     bool nonSimpleArguments = false;
1235     for (unsigned i = 0; i &lt; parameters.size(); ++i) {
1236         auto parameter = parameters.at(i);
1237         auto pattern = parameter.first;
1238         if (pattern-&gt;isRestParameter()) {
1239             RELEASE_ASSERT(!m_restParameter);
1240             m_restParameter = static_cast&lt;RestParameterNode*&gt;(pattern);
1241             nonSimpleArguments = true;
1242             continue;
1243         }
1244         if (parameter.second) {
1245             nonSimpleArguments = true;
1246             continue;
1247         }
1248         if (!nonSimpleArguments)
1249             initializeNextParameter();
1250     }
1251 }
1252 
1253 void BytecodeGenerator::initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables)
1254 {
1255     if (hasCapturedVariables) {
1256         RELEASE_ASSERT(m_lexicalEnvironmentRegister);
1257         OpCreateLexicalEnvironment::emit(this, m_lexicalEnvironmentRegister, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
1258 
1259         OpMov::emit(this, scopeRegister(), m_lexicalEnvironmentRegister);
1260 
1261         pushLocalControlFlowScope();
1262     }
1263     bool isWithScope = false;
1264     m_lexicalScopeStack.append({ functionSymbolTable, m_lexicalEnvironmentRegister, isWithScope, symbolTableConstantIndex });
1265     m_varScopeLexicalScopeStackIndex = m_lexicalScopeStack.size() - 1;
1266 }
1267 
1268 UniquedStringImpl* BytecodeGenerator::visibleNameForParameter(DestructuringPatternNode* pattern)
1269 {
1270     if (pattern-&gt;isBindingNode()) {
1271         const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
1272         if (!m_functions.contains(ident.impl()))
1273             return ident.impl();
1274     }
1275     return nullptr;
1276 }
1277 
1278 RegisterID* BytecodeGenerator::newRegister()
1279 {
1280     m_calleeLocals.append(virtualRegisterForLocal(m_calleeLocals.size()));
1281     int numCalleeLocals = std::max&lt;int&gt;(m_codeBlock-&gt;m_numCalleeLocals, m_calleeLocals.size());
1282     numCalleeLocals = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), numCalleeLocals);
1283     m_codeBlock-&gt;m_numCalleeLocals = numCalleeLocals;
1284     return &amp;m_calleeLocals.last();
1285 }
1286 
1287 void BytecodeGenerator::reclaimFreeRegisters()
1288 {
1289     shrinkToFit(m_calleeLocals);
1290 }
1291 
1292 RegisterID* BytecodeGenerator::newBlockScopeVariable()
1293 {
1294     reclaimFreeRegisters();
1295 
1296     return newRegister();
1297 }
1298 
1299 RegisterID* BytecodeGenerator::newTemporary()
1300 {
1301     reclaimFreeRegisters();
1302 
1303     RegisterID* result = newRegister();
1304     result-&gt;setTemporary();
1305     return result;
1306 }
1307 
1308 Ref&lt;LabelScope&gt; BytecodeGenerator::newLabelScope(LabelScope::Type type, const Identifier* name)
1309 {
1310     shrinkToFit(m_labelScopes);
1311 
1312     // Allocate new label scope.
1313     m_labelScopes.append(type, name, labelScopeDepth(), newLabel(), type == LabelScope::Loop ? RefPtr&lt;Label&gt;(newLabel()) : RefPtr&lt;Label&gt;()); // Only loops have continue targets.
1314     return m_labelScopes.last();
1315 }
1316 
1317 Ref&lt;Label&gt; BytecodeGenerator::newLabel()
1318 {
1319     shrinkToFit(m_labels);
1320 
1321     // Allocate new label ID.
1322     m_labels.append();
1323     return m_labels.last();
1324 }
1325 
1326 Ref&lt;Label&gt; BytecodeGenerator::newEmittedLabel()
1327 {
1328     Ref&lt;Label&gt; label = newLabel();
1329     emitLabel(label.get());
1330     return label;
1331 }
1332 
1333 void BytecodeGenerator::recordOpcode(OpcodeID opcodeID)
1334 {
1335     ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));
1336     m_lastInstruction = m_writer.ref();
1337     m_lastOpcodeID = opcodeID;
1338 }
1339 
1340 void BytecodeGenerator::alignWideOpcode16()
1341 {
1342 #if CPU(NEEDS_ALIGNED_ACCESS)
1343     while ((m_writer.position() + 1) % OpcodeSize::Wide16)
1344         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
1345 #endif
1346 }
1347 
1348 void BytecodeGenerator::alignWideOpcode32()
1349 {
1350 #if CPU(NEEDS_ALIGNED_ACCESS)
1351     while ((m_writer.position() + 1) % OpcodeSize::Wide32)
1352         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
1353 #endif
1354 }
1355 
1356 void BytecodeGenerator::emitLabel(Label&amp; l0)
1357 {
1358     unsigned newLabelIndex = instructions().size();
1359     l0.setLocation(*this, newLabelIndex);
1360 
1361     if (m_codeBlock-&gt;numberOfJumpTargets()) {
1362         unsigned lastLabelIndex = m_codeBlock-&gt;lastJumpTarget();
1363         ASSERT(lastLabelIndex &lt;= newLabelIndex);
1364         if (newLabelIndex == lastLabelIndex) {
1365             // Peephole optimizations have already been disabled by emitting the last label
1366             return;
1367         }
1368     }
1369 
1370     m_codeBlock-&gt;addJumpTarget(newLabelIndex);
1371 
1372     // This disables peephole optimizations when an instruction is a jump target
1373     m_lastOpcodeID = op_end;
1374 }
1375 
1376 void BytecodeGenerator::emitEnter()
1377 {
1378     OpEnter::emit(this);
1379 
1380     if (LIKELY(Options::optimizeRecursiveTailCalls())) {
1381         // We must add the end of op_enter as a potential jump target, because the bytecode parser may decide to split its basic block
1382         // to have somewhere to jump to if there is a recursive tail-call that points to this function.
1383         m_codeBlock-&gt;addJumpTarget(instructions().size());
1384         // This disables peephole optimizations when an instruction is a jump target
1385         m_lastOpcodeID = op_end;
1386     }
1387 }
1388 
1389 void BytecodeGenerator::emitLoopHint()
1390 {
1391     OpLoopHint::emit(this);
1392 }
1393 
1394 void BytecodeGenerator::emitJump(Label&amp; target)
1395 {
1396     OpJmp::emit(this, target.bind(this));
1397 }
1398 
1399 void ALWAYS_INLINE BytecodeGenerator::rewind()
1400 {
1401     ASSERT(m_lastInstruction.isValid());
1402     m_lastOpcodeID = op_end;
1403     m_writer.rewind(m_lastInstruction);
1404 }
1405 
1406 template&lt;typename BinOp, typename JmpOp&gt;
1407 bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
1408 {
1409     ASSERT(canDoPeepholeOptimization());
1410     auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
1411     if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1412         rewind();
1413 
1414         if (swapOperands)
1415             std::swap(binop.m_lhs, binop.m_rhs);
1416 
1417         JmpOp::emit(this, binop.m_lhs, binop.m_rhs, target.bind(this));
1418         return true;
1419     }
1420     return false;
1421 }
1422 
1423 template&lt;typename UnaryOp, typename JmpOp&gt;
1424 bool BytecodeGenerator::fuseTestAndJmp(RegisterID* cond, Label&amp; target)
1425 {
1426     ASSERT(canDoPeepholeOptimization());
1427     auto unop = m_lastInstruction-&gt;as&lt;UnaryOp&gt;();
1428     if (cond-&gt;index() == unop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1429         rewind();
1430 
1431         JmpOp::emit(this, unop.m_operand, target.bind(this));
1432         return true;
1433     }
1434     return false;
1435 }
1436 
1437 void BytecodeGenerator::emitJumpIfTrue(RegisterID* cond, Label&amp; target)
1438 {
1439     if (canDoPeepholeOptimization()) {
1440         if (m_lastOpcodeID == op_less) {
1441             if (fuseCompareAndJump&lt;OpLess, OpJless&gt;(cond, target))
1442                 return;
1443         } else if (m_lastOpcodeID == op_lesseq) {
1444             if (fuseCompareAndJump&lt;OpLesseq, OpJlesseq&gt;(cond, target))
1445                 return;
1446         } else if (m_lastOpcodeID == op_greater) {
1447             if (fuseCompareAndJump&lt;OpGreater, OpJgreater&gt;(cond, target))
1448                 return;
1449         } else if (m_lastOpcodeID == op_greatereq) {
1450             if (fuseCompareAndJump&lt;OpGreatereq, OpJgreatereq&gt;(cond, target))
1451                 return;
1452         } else if (m_lastOpcodeID == op_eq) {
1453             if (fuseCompareAndJump&lt;OpEq, OpJeq&gt;(cond, target))
1454                 return;
1455         } else if (m_lastOpcodeID == op_stricteq) {
1456             if (fuseCompareAndJump&lt;OpStricteq, OpJstricteq&gt;(cond, target))
1457                 return;
1458         } else if (m_lastOpcodeID == op_neq) {
1459             if (fuseCompareAndJump&lt;OpNeq, OpJneq&gt;(cond, target))
1460                 return;
1461         } else if (m_lastOpcodeID == op_nstricteq) {
1462             if (fuseCompareAndJump&lt;OpNstricteq, OpJnstricteq&gt;(cond, target))
1463                 return;
1464         } else if (m_lastOpcodeID == op_below) {
1465             if (fuseCompareAndJump&lt;OpBelow, OpJbelow&gt;(cond, target))
1466                 return;
1467         } else if (m_lastOpcodeID == op_beloweq) {
1468             if (fuseCompareAndJump&lt;OpBeloweq, OpJbeloweq&gt;(cond, target))
1469                 return;
1470         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {
1471             if (fuseTestAndJmp&lt;OpEqNull, OpJeqNull&gt;(cond, target))
1472                 return;
1473         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {
1474             if (fuseTestAndJmp&lt;OpNeqNull, OpJneqNull&gt;(cond, target))
1475                 return;
1476         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {
1477             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJundefinedOrNull&gt;(cond, target))
1478                 return;
1479         }
1480     }
1481 
1482     OpJtrue::emit(this, cond, target.bind(this));
1483 }
1484 
1485 void BytecodeGenerator::emitJumpIfFalse(RegisterID* cond, Label&amp; target)
1486 {
1487     if (canDoPeepholeOptimization()) {
1488         if (m_lastOpcodeID == op_less &amp;&amp; target.isForward()) {
1489             if (fuseCompareAndJump&lt;OpLess, OpJnless&gt;(cond, target))
1490                 return;
1491         } else if (m_lastOpcodeID == op_lesseq &amp;&amp; target.isForward()) {
1492             if (fuseCompareAndJump&lt;OpLesseq, OpJnlesseq&gt;(cond, target))
1493                 return;
1494         } else if (m_lastOpcodeID == op_greater &amp;&amp; target.isForward()) {
1495             if (fuseCompareAndJump&lt;OpGreater, OpJngreater&gt;(cond, target))
1496                 return;
1497         } else if (m_lastOpcodeID == op_greatereq &amp;&amp; target.isForward()) {
1498             if (fuseCompareAndJump&lt;OpGreatereq, OpJngreatereq&gt;(cond, target))
1499                 return;
1500         } else if (m_lastOpcodeID == op_eq &amp;&amp; target.isForward()) {
1501             if (fuseCompareAndJump&lt;OpEq, OpJneq&gt;(cond, target))
1502                 return;
1503         } else if (m_lastOpcodeID == op_stricteq &amp;&amp; target.isForward()) {
1504             if (fuseCompareAndJump&lt;OpStricteq, OpJnstricteq&gt;(cond, target))
1505                 return;
1506         } else if (m_lastOpcodeID == op_neq &amp;&amp; target.isForward()) {
1507             if (fuseCompareAndJump&lt;OpNeq, OpJeq&gt;(cond, target))
1508                 return;
1509         } else if (m_lastOpcodeID == op_nstricteq &amp;&amp; target.isForward()) {
1510             if (fuseCompareAndJump&lt;OpNstricteq, OpJstricteq&gt;(cond, target))
1511                 return;
1512         } else if (m_lastOpcodeID == op_below &amp;&amp; target.isForward()) {
1513             if (fuseCompareAndJump&lt;OpBelow, OpJbeloweq&gt;(cond, target, true))
1514                 return;
1515         } else if (m_lastOpcodeID == op_beloweq &amp;&amp; target.isForward()) {
1516             if (fuseCompareAndJump&lt;OpBeloweq, OpJbelow&gt;(cond, target, true))
1517                 return;
1518         } else if (m_lastOpcodeID == op_not) {
1519             if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))
1520                 return;
1521         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {
1522             if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))
1523                 return;
1524         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {
1525             if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))
1526                 return;
1527         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {
1528             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJnundefinedOrNull&gt;(cond, target))
1529                 return;
1530         }
1531     }
1532 
1533     OpJfalse::emit(this, cond, target.bind(this));
1534 }
1535 
1536 void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
1537 {
1538     OpJneqPtr::emit(this, cond, Special::CallFunction, target.bind(this));
1539 }
1540 
1541 void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
1542 {
1543     OpJneqPtr::emit(this, cond, Special::ApplyFunction, target.bind(this));
1544 }
1545 
1546 bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
1547 {
1548     UniquedStringImpl* rep = ident.impl();
1549     return m_identifierMap.contains(rep);
1550 }
1551 
1552 unsigned BytecodeGenerator::addConstant(const Identifier&amp; ident)
1553 {
1554     UniquedStringImpl* rep = ident.impl();
1555     IdentifierMap::AddResult result = m_identifierMap.add(rep, m_codeBlock-&gt;numberOfIdentifiers());
1556     if (result.isNewEntry)
1557         m_codeBlock-&gt;addIdentifier(ident);
1558 
1559     return result.iterator-&gt;value;
1560 }
1561 
1562 // We can&#39;t hash JSValue(), so we use a dedicated data member to cache it.
1563 RegisterID* BytecodeGenerator::addConstantEmptyValue()
1564 {
1565     if (!m_emptyValueRegister) {
1566         int index = addConstantIndex();
1567         m_codeBlock-&gt;addConstant(JSValue());
1568         m_emptyValueRegister = &amp;m_constantPoolRegisters[index];
1569     }
1570 
1571     return m_emptyValueRegister;
1572 }
1573 
1574 RegisterID* BytecodeGenerator::addConstantValue(JSValue v, SourceCodeRepresentation sourceCodeRepresentation)
1575 {
1576     if (!v)
1577         return addConstantEmptyValue();
1578 
1579     int index = m_nextConstantOffset;
1580 
1581     if (sourceCodeRepresentation == SourceCodeRepresentation::Double &amp;&amp; v.isInt32())
1582         v = jsDoubleNumber(v.asNumber());
1583     EncodedJSValueWithRepresentation valueMapKey { JSValue::encode(v), sourceCodeRepresentation };
1584     JSValueMap::AddResult result = m_jsValueMap.add(valueMapKey, m_nextConstantOffset);
1585     if (result.isNewEntry) {
1586         addConstantIndex();
1587         m_codeBlock-&gt;addConstant(v, sourceCodeRepresentation);
1588     } else
1589         index = result.iterator-&gt;value;
1590     return &amp;m_constantPoolRegisters[index];
1591 }
1592 
1593 RegisterID* BytecodeGenerator::moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant type)
1594 {
1595     unsigned constantIndex = static_cast&lt;unsigned&gt;(type);
1596     if (!m_linkTimeConstantRegisters[constantIndex]) {
1597         int index = addConstantIndex();
1598         m_codeBlock-&gt;addConstant(type);
1599         m_linkTimeConstantRegisters[constantIndex] = &amp;m_constantPoolRegisters[index];
1600     }
1601 
1602     if (!dst)
1603         return m_linkTimeConstantRegisters[constantIndex];
1604 
1605     OpMov::emit(this, dst, m_linkTimeConstantRegisters[constantIndex]);
1606 
1607     return dst;
1608 }
1609 
1610 RegisterID* BytecodeGenerator::moveEmptyValue(RegisterID* dst)
1611 {
1612     RefPtr&lt;RegisterID&gt; emptyValue = addConstantEmptyValue();
1613 
1614     OpMov::emit(this, dst, emptyValue.get());
1615 
1616     return dst;
1617 }
1618 
1619 RegisterID* BytecodeGenerator::emitMove(RegisterID* dst, RegisterID* src)
1620 {
1621     ASSERT(src != m_emptyValueRegister);
1622 
1623     m_staticPropertyAnalyzer.mov(dst, src);
1624     OpMov::emit(this, dst, src);
1625 
1626     return dst;
1627 }
1628 
1629 RegisterID* BytecodeGenerator::emitUnaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src, OperandTypes types)
1630 {
1631     switch (opcodeID) {
1632     case op_not:
1633         emitUnaryOp&lt;OpNot&gt;(dst, src);
1634         break;
1635     case op_negate:
1636         OpNegate::emit(this, dst, src, types);
1637         break;
1638     case op_bitnot:
1639         emitUnaryOp&lt;OpBitnot&gt;(dst, src);
1640         break;
1641     case op_to_number:
1642         emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1643         break;
1644     default:
1645         ASSERT_NOT_REACHED();
1646     }
1647     return dst;
1648 }
1649 
1650 RegisterID* BytecodeGenerator::emitBinaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
1651 {
1652     switch (opcodeID) {
1653     case op_eq:
1654         return emitBinaryOp&lt;OpEq&gt;(dst, src1, src2, types);
1655     case op_neq:
1656         return emitBinaryOp&lt;OpNeq&gt;(dst, src1, src2, types);
1657     case op_stricteq:
1658         return emitBinaryOp&lt;OpStricteq&gt;(dst, src1, src2, types);
1659     case op_nstricteq:
1660         return emitBinaryOp&lt;OpNstricteq&gt;(dst, src1, src2, types);
1661     case op_less:
1662         return emitBinaryOp&lt;OpLess&gt;(dst, src1, src2, types);
1663     case op_lesseq:
1664         return emitBinaryOp&lt;OpLesseq&gt;(dst, src1, src2, types);
1665     case op_greater:
1666         return emitBinaryOp&lt;OpGreater&gt;(dst, src1, src2, types);
1667     case op_greatereq:
1668         return emitBinaryOp&lt;OpGreatereq&gt;(dst, src1, src2, types);
1669     case op_below:
1670         return emitBinaryOp&lt;OpBelow&gt;(dst, src1, src2, types);
1671     case op_beloweq:
1672         return emitBinaryOp&lt;OpBeloweq&gt;(dst, src1, src2, types);
1673     case op_mod:
1674         return emitBinaryOp&lt;OpMod&gt;(dst, src1, src2, types);
1675     case op_pow:
1676         return emitBinaryOp&lt;OpPow&gt;(dst, src1, src2, types);
1677     case op_lshift:
1678         return emitBinaryOp&lt;OpLshift&gt;(dst, src1, src2, types);
1679     case op_rshift:
1680         return emitBinaryOp&lt;OpRshift&gt;(dst, src1, src2, types);
1681     case op_urshift:
1682         return emitBinaryOp&lt;OpUrshift&gt;(dst, src1, src2, types);
1683     case op_add:
1684         return emitBinaryOp&lt;OpAdd&gt;(dst, src1, src2, types);
1685     case op_mul:
1686         return emitBinaryOp&lt;OpMul&gt;(dst, src1, src2, types);
1687     case op_div:
1688         return emitBinaryOp&lt;OpDiv&gt;(dst, src1, src2, types);
1689     case op_sub:
1690         return emitBinaryOp&lt;OpSub&gt;(dst, src1, src2, types);
1691     case op_bitand:
1692         return emitBinaryOp&lt;OpBitand&gt;(dst, src1, src2, types);
1693     case op_bitxor:
1694         return emitBinaryOp&lt;OpBitxor&gt;(dst, src1, src2, types);
1695     case op_bitor:
1696         return emitBinaryOp&lt;OpBitor&gt;(dst, src1, src2, types);
1697     default:
1698         ASSERT_NOT_REACHED();
1699         return nullptr;
1700     }
1701 }
1702 
1703 RegisterID* BytecodeGenerator::emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message)
1704 {
1705     OpToObject::emit(this, dst, src, addConstant(message));
1706     return dst;
1707 }
1708 
1709 RegisterID* BytecodeGenerator::emitToNumber(RegisterID* dst, RegisterID* src)
1710 {
1711     return emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1712 }
1713 
1714 RegisterID* BytecodeGenerator::emitToString(RegisterID* dst, RegisterID* src)
1715 {
1716     return emitUnaryOp&lt;OpToString&gt;(dst, src);
1717 }
1718 
1719 RegisterID* BytecodeGenerator::emitTypeOf(RegisterID* dst, RegisterID* src)
1720 {
1721     return emitUnaryOp&lt;OpTypeof&gt;(dst, src);
1722 }
1723 
1724 RegisterID* BytecodeGenerator::emitInc(RegisterID* srcDst)
1725 {
1726     OpInc::emit(this, srcDst);
1727     return srcDst;
1728 }
1729 
1730 RegisterID* BytecodeGenerator::emitDec(RegisterID* srcDst)
1731 {
1732     OpDec::emit(this, srcDst);
1733     return srcDst;
1734 }
1735 
1736 bool BytecodeGenerator::emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2)
1737 {
1738     if (!canDoPeepholeOptimization())
1739         return false;
1740 
1741     if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
1742         auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
1743         if (src1-&gt;index() == op.m_dst.offset()
1744             &amp;&amp; src1-&gt;isTemporary()
1745             &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())
1746             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {
1747             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();
1748             if (value == &quot;undefined&quot;) {
1749                 rewind();
1750                 OpIsUndefined::emit(this, dst, op.m_value);
1751                 return true;
1752             }
1753             if (value == &quot;boolean&quot;) {
1754                 rewind();
1755                 OpIsBoolean::emit(this, dst, op.m_value);
1756                 return true;
1757             }
1758             if (value == &quot;number&quot;) {
1759                 rewind();
1760                 OpIsNumber::emit(this, dst, op.m_value);
1761                 return true;
1762             }
1763             if (value == &quot;string&quot;) {
1764                 rewind();
1765                 OpIsCellWithType::emit(this, dst, op.m_value, StringType);
1766                 return true;
1767             }
1768             if (value == &quot;symbol&quot;) {
1769                 rewind();
1770                 OpIsCellWithType::emit(this, dst, op.m_value, SymbolType);
1771                 return true;
1772             }
1773             if (Options::useBigInt() &amp;&amp; value == &quot;bigint&quot;) {
1774                 rewind();
1775                 OpIsCellWithType::emit(this, dst, op.m_value, BigIntType);
1776                 return true;
1777             }
1778             if (value == &quot;object&quot;) {
1779                 rewind();
1780                 OpIsObjectOrNull::emit(this, dst, op.m_value);
1781                 return true;
1782             }
1783             if (value == &quot;function&quot;) {
1784                 rewind();
1785                 OpIsFunction::emit(this, dst, op.m_value);
1786                 return true;
1787             }
1788         }
1789     }
1790 
1791     return false;
1792 }
1793 
1794 void BytecodeGenerator::emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1795 {
1796     ASSERT(shouldEmitTypeProfilerHooks());
1797 
1798     unsigned start = startDivot.offset; // Ranges are inclusive of their endpoints, AND 0 indexed.
1799     unsigned end = endDivot.offset - 1; // End Ranges already go one past the inclusive range, so subtract 1.
1800     unsigned instructionOffset = instructions().size() - 1;
1801     m_codeBlock-&gt;addTypeProfilerExpressionInfo(instructionOffset, start, end);
1802 }
1803 
1804 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag)
1805 {
1806     if (!shouldEmitTypeProfilerHooks())
1807         return;
1808 
1809     if (!registerToProfile)
1810         return;
1811 
1812     OpProfileType::emit(this, registerToProfile, { }, flag, { }, resolveType());
1813 
1814     // Don&#39;t emit expression info for this version of profile type. This generally means
1815     // we&#39;re profiling information for something that isn&#39;t in the actual text of a JavaScript
1816     // program. For example, implicit return undefined from a function call.
1817 }
1818 
1819 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1820 {
1821     emitProfileType(registerToProfile, ProfileTypeBytecodeDoesNotHaveGlobalID, startDivot, endDivot);
1822 }
1823 
1824 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1825 {
1826     if (!shouldEmitTypeProfilerHooks())
1827         return;
1828 
1829     if (!registerToProfile)
1830         return;
1831 
1832     OpProfileType::emit(this, registerToProfile, { },  flag, { }, resolveType());
1833     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1834 }
1835 
1836 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const Variable&amp; var, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1837 {
1838     if (!shouldEmitTypeProfilerHooks())
1839         return;
1840 
1841     if (!registerToProfile)
1842         return;
1843 
1844     ProfileTypeBytecodeFlag flag;
1845     SymbolTableOrScopeDepth symbolTableOrScopeDepth;
1846     if (var.local() || var.offset().isScope()) {
1847         flag = ProfileTypeBytecodeLocallyResolved;
1848         ASSERT(var.symbolTableConstantIndex());
1849         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { var.symbolTableConstantIndex() });
1850     } else {
1851         flag = ProfileTypeBytecodeClosureVar;
1852         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());
1853     }
1854 
1855     OpProfileType::emit(this, registerToProfile, symbolTableOrScopeDepth, flag, addConstant(var.ident()), resolveType());
1856     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1857 }
1858 
1859 void BytecodeGenerator::emitProfileControlFlow(int textOffset)
1860 {
1861     if (shouldEmitControlFlowProfilerHooks()) {
1862         RELEASE_ASSERT(textOffset &gt;= 0);
1863 
1864         OpProfileControlFlow::emit(this, textOffset);
1865         m_codeBlock-&gt;addOpProfileControlFlowBytecodeOffset(m_lastInstruction.offset());
1866     }
1867 }
1868 
1869 unsigned BytecodeGenerator::addConstantIndex()
1870 {
1871     unsigned index = m_nextConstantOffset;
1872     m_constantPoolRegisters.append(FirstConstantRegisterIndex + m_nextConstantOffset);
1873     ++m_nextConstantOffset;
1874     return index;
1875 }
1876 
1877 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, bool b)
1878 {
1879     return emitLoad(dst, jsBoolean(b));
1880 }
1881 
1882 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, const Identifier&amp; identifier)
1883 {
1884     ASSERT(!identifier.isSymbol());
1885     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
1886     if (!stringInMap)
1887         stringInMap = jsOwnedString(vm(), identifier.string());
1888 
1889     return emitLoad(dst, JSValue(stringInMap));
1890 }
1891 
1892 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, JSValue v, SourceCodeRepresentation sourceCodeRepresentation)
1893 {
1894     RegisterID* constantID = addConstantValue(v, sourceCodeRepresentation);
1895     if (dst)
1896         return move(dst, constantID);
1897     return constantID;
1898 }
1899 
1900 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, IdentifierSet&amp; set)
1901 {
1902     if (m_codeBlock-&gt;numberOfConstantIdentifierSets()) {
1903         for (const auto&amp; entry : m_codeBlock-&gt;constantIdentifierSets()) {
1904             if (entry.first != set)
1905                 continue;
1906 
1907             return &amp;m_constantPoolRegisters[entry.second];
1908         }
1909     }
1910 
1911     unsigned index = addConstantIndex();
1912     m_codeBlock-&gt;addSetConstant(set);
1913     RegisterID* m_setRegister = &amp;m_constantPoolRegisters[index];
1914 
1915     if (dst)
1916         return move(dst, m_setRegister);
1917 
1918     return m_setRegister;
1919 }
1920 
1921 template&lt;typename LookUpVarKindFunctor&gt;
1922 bool BytecodeGenerator::instantiateLexicalVariables(const VariableEnvironment&amp; lexicalVariables, SymbolTable* symbolTable, ScopeRegisterType scopeRegisterType, LookUpVarKindFunctor lookUpVarKind)
1923 {
1924     bool hasCapturedVariables = false;
1925     {
1926         for (auto&amp; entry : lexicalVariables) {
1927             ASSERT(entry.value.isLet() || entry.value.isConst() || entry.value.isFunction());
1928             ASSERT(!entry.value.isVar());
1929             SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
1930             ASSERT(symbolTableEntry.isNull());
1931 
1932             // Imported bindings which are not the namespace bindings are not allocated
1933             // in the module environment as usual variables&#39; way.
1934             // And since these types of the variables only seen in the module environment,
1935             // other lexical environment need not to take care this.
1936             if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
1937                 continue;
1938 
1939             VarKind varKind = lookUpVarKind(entry.key.get(), entry.value);
1940             VarOffset varOffset;
1941             if (varKind == VarKind::Scope) {
1942                 varOffset = VarOffset(symbolTable-&gt;takeNextScopeOffset(NoLockingNecessary));
1943                 hasCapturedVariables = true;
1944             } else {
1945                 ASSERT(varKind == VarKind::Stack);
1946                 RegisterID* local;
1947                 if (scopeRegisterType == ScopeRegisterType::Block) {
1948                     local = newBlockScopeVariable();
1949                     local-&gt;ref();
1950                 } else
1951                     local = addVar();
1952                 varOffset = VarOffset(local-&gt;virtualRegister());
1953             }
1954 
1955             SymbolTableEntry newEntry(varOffset, static_cast&lt;unsigned&gt;(entry.value.isConst() ? PropertyAttribute::ReadOnly : PropertyAttribute::None));
1956             symbolTable-&gt;add(NoLockingNecessary, entry.key.get(), newEntry);
1957         }
1958     }
1959     return hasCapturedVariables;
1960 }
1961 
1962 void BytecodeGenerator::emitPrefillStackTDZVariables(const VariableEnvironment&amp; lexicalVariables, SymbolTable* symbolTable)
1963 {
1964     // Prefill stack variables with the TDZ empty value.
1965     // Scope variables will be initialized to the TDZ empty value when JSLexicalEnvironment is allocated.
1966     for (auto&amp; entry : lexicalVariables) {
1967         // Imported bindings which are not the namespace bindings are not allocated
1968         // in the module environment as usual variables&#39; way.
1969         // And since these types of the variables only seen in the module environment,
1970         // other lexical environment need not to take care this.
1971         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
1972             continue;
1973 
1974         if (entry.value.isFunction())
1975             continue;
1976 
1977         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
1978         ASSERT(!symbolTableEntry.isNull());
1979         VarOffset offset = symbolTableEntry.varOffset();
1980         if (offset.isScope())
1981             continue;
1982 
1983         ASSERT(offset.isStack());
1984         moveEmptyValue(&amp;registerFor(offset.stackOffset()));
1985     }
1986 }
1987 
1988 void BytecodeGenerator::pushLexicalScope(VariableEnvironmentNode* node, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType, RegisterID** constantSymbolTableResult, bool shouldInitializeBlockScopedFunctions)
1989 {
1990     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
1991     RegisterID* constantSymbolTableResultTemp = nullptr;
1992     pushLexicalScopeInternal(environment, tdzCheckOptimization, nestedScopeType, &amp;constantSymbolTableResultTemp, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1993 
1994     if (shouldInitializeBlockScopedFunctions)
1995         initializeBlockScopedFunctions(environment, node-&gt;functionStack(), constantSymbolTableResultTemp);
1996 
1997     if (constantSymbolTableResult &amp;&amp; constantSymbolTableResultTemp)
1998         *constantSymbolTableResult = constantSymbolTableResultTemp;
1999 }
2000 
2001 void BytecodeGenerator::pushLexicalScopeInternal(VariableEnvironment&amp; environment, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType,
2002     RegisterID** constantSymbolTableResult, TDZRequirement tdzRequirement, ScopeType scopeType, ScopeRegisterType scopeRegisterType)
2003 {
2004     if (!environment.size())
2005         return;
2006 
2007     if (shouldEmitDebugHooks())
2008         environment.markAllVariablesAsCaptured();
2009 
2010     SymbolTable* symbolTable = SymbolTable::create(m_vm);
2011     switch (scopeType) {
2012     case ScopeType::CatchScope:
2013         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::CatchScope);
2014         break;
2015     case ScopeType::LetConstScope:
2016         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
2017         break;
2018     case ScopeType::FunctionNameScope:
2019         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::FunctionNameScope);
2020         break;
2021     }
2022 
2023     if (nestedScopeType == NestedScopeType::IsNested)
2024         symbolTable-&gt;markIsNestedLexicalScope();
2025 
2026     auto lookUpVarKind = [] (UniquedStringImpl*, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
2027         return entry.isCaptured() ? VarKind::Scope : VarKind::Stack;
2028     };
2029 
2030     bool hasCapturedVariables = instantiateLexicalVariables(environment, symbolTable, scopeRegisterType, lookUpVarKind);
2031 
2032     RegisterID* newScope = nullptr;
2033     RegisterID* constantSymbolTable = nullptr;
2034     int symbolTableConstantIndex = 0;
2035     if (shouldEmitTypeProfilerHooks()) {
2036         constantSymbolTable = addConstantValue(symbolTable);
2037         symbolTableConstantIndex = constantSymbolTable-&gt;index();
2038     }
2039     if (hasCapturedVariables) {
2040         if (scopeRegisterType == ScopeRegisterType::Block) {
2041             newScope = newBlockScopeVariable();
2042             newScope-&gt;ref();
2043         } else
2044             newScope = addVar();
2045         if (!constantSymbolTable) {
2046             ASSERT(!shouldEmitTypeProfilerHooks());
2047             constantSymbolTable = addConstantValue(symbolTable-&gt;cloneScopePart(m_vm));
2048             symbolTableConstantIndex = constantSymbolTable-&gt;index();
2049         }
2050         if (constantSymbolTableResult)
2051             *constantSymbolTableResult = constantSymbolTable;
2052 
2053         OpCreateLexicalEnvironment::emit(this, newScope, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(tdzRequirement == TDZRequirement::UnderTDZ ? jsTDZValue() : jsUndefined()));
2054 
2055         move(scopeRegister(), newScope);
2056 
2057         pushLocalControlFlowScope();
2058     }
2059 
2060     bool isWithScope = false;
2061     m_lexicalScopeStack.append({ symbolTable, newScope, isWithScope, symbolTableConstantIndex });
2062     pushTDZVariables(environment, tdzCheckOptimization, tdzRequirement);
2063 
2064     if (tdzRequirement == TDZRequirement::UnderTDZ)
2065         emitPrefillStackTDZVariables(environment, symbolTable);
2066 }
2067 
2068 void BytecodeGenerator::initializeBlockScopedFunctions(VariableEnvironment&amp; environment, FunctionStack&amp; functionStack, RegisterID* constantSymbolTable)
2069 {
2070     /*
2071      * We must transform block scoped function declarations in strict mode like so:
2072      *
2073      * function foo() {
2074      *     if (c) {
2075      *           function foo() { ... }
2076      *           if (bar) { ... }
2077      *           else { ... }
2078      *           function baz() { ... }
2079      *     }
2080      * }
2081      *
2082      * to:
2083      *
2084      * function foo() {
2085      *     if (c) {
2086      *         let foo = function foo() { ... }
2087      *         let baz = function baz() { ... }
2088      *         if (bar) { ... }
2089      *         else { ... }
2090      *     }
2091      * }
2092      *
2093      * But without the TDZ checks.
2094     */
2095 
2096     if (!environment.size()) {
2097         RELEASE_ASSERT(!functionStack.size());
2098         return;
2099     }
2100 
2101     if (!functionStack.size())
2102         return;
2103 
2104     SymbolTable* symbolTable = m_lexicalScopeStack.last().m_symbolTable;
2105     RegisterID* scope = m_lexicalScopeStack.last().m_scope;
2106     RefPtr&lt;RegisterID&gt; temp = newTemporary();
2107     int symbolTableIndex = constantSymbolTable ? constantSymbolTable-&gt;index() : 0;
2108     for (FunctionMetadataNode* function : functionStack) {
2109         const Identifier&amp; name = function-&gt;ident();
2110         auto iter = environment.find(name.impl());
2111         RELEASE_ASSERT(iter != environment.end());
2112         RELEASE_ASSERT(iter-&gt;value.isFunction());
2113         // We purposefully don&#39;t hold the symbol table lock around this loop because emitNewFunctionExpressionCommon may GC.
2114         SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, name.impl());
2115         RELEASE_ASSERT(!entry.isNull());
2116         emitNewFunctionExpressionCommon(temp.get(), function);
2117         bool isLexicallyScoped = true;
2118         emitPutToScope(scope, variableForLocalEntry(name, entry, symbolTableIndex, isLexicallyScoped), temp.get(), DoNotThrowIfNotFound, InitializationMode::Initialization);
2119     }
2120 }
2121 
2122 void BytecodeGenerator::hoistSloppyModeFunctionIfNecessary(const Identifier&amp; functionName)
2123 {
2124     if (m_scopeNode-&gt;hasSloppyModeHoistedFunction(functionName.impl())) {
2125         if (codeType() != EvalCode) {
2126             Variable currentFunctionVariable = variable(functionName);
2127             RefPtr&lt;RegisterID&gt; currentValue;
2128             if (RegisterID* local = currentFunctionVariable.local())
2129                 currentValue = local;
2130             else {
2131                 RefPtr&lt;RegisterID&gt; scope = emitResolveScope(nullptr, currentFunctionVariable);
2132                 currentValue = emitGetFromScope(newTemporary(), scope.get(), currentFunctionVariable, DoNotThrowIfNotFound);
2133             }
2134 
2135             ASSERT(m_varScopeLexicalScopeStackIndex);
2136             ASSERT(*m_varScopeLexicalScopeStackIndex &lt; m_lexicalScopeStack.size());
2137             LexicalScopeStackEntry varScope = m_lexicalScopeStack[*m_varScopeLexicalScopeStackIndex];
2138             SymbolTable* varSymbolTable = varScope.m_symbolTable;
2139             ASSERT(varSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope);
2140             SymbolTableEntry entry = varSymbolTable-&gt;get(NoLockingNecessary, functionName.impl());
2141             if (functionName == propertyNames().arguments &amp;&amp; entry.isNull()) {
2142                 // &quot;arguments&quot; might be put in the parameter scope when we have a non-simple
2143                 // parameter list since &quot;arguments&quot; is visible to expressions inside the
2144                 // parameter evaluation list.
2145                 // e.g:
2146                 // function foo(x = arguments) { { function arguments() { } } }
2147                 RELEASE_ASSERT(*m_varScopeLexicalScopeStackIndex &gt; 0);
2148                 varScope = m_lexicalScopeStack[*m_varScopeLexicalScopeStackIndex - 1];
2149                 SymbolTable* parameterSymbolTable = varScope.m_symbolTable;
2150                 entry = parameterSymbolTable-&gt;get(NoLockingNecessary, functionName.impl());
2151             }
2152             RELEASE_ASSERT(!entry.isNull());
2153             bool isLexicallyScoped = false;
2154             emitPutToScope(varScope.m_scope, variableForLocalEntry(functionName, entry, varScope.m_symbolTableConstantIndex, isLexicallyScoped), currentValue.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2155         } else {
2156             Variable currentFunctionVariable = variable(functionName);
2157             RefPtr&lt;RegisterID&gt; currentValue;
2158             if (RegisterID* local = currentFunctionVariable.local())
2159                 currentValue = local;
2160             else {
2161                 RefPtr&lt;RegisterID&gt; scope = emitResolveScope(nullptr, currentFunctionVariable);
2162                 currentValue = emitGetFromScope(newTemporary(), scope.get(), currentFunctionVariable, DoNotThrowIfNotFound);
2163             }
2164 
2165             RefPtr&lt;RegisterID&gt; scopeId = emitResolveScopeForHoistingFuncDeclInEval(nullptr, functionName);
2166             RefPtr&lt;RegisterID&gt; checkResult = emitIsUndefined(newTemporary(), scopeId.get());
2167 
2168             Ref&lt;Label&gt; isNotVarScopeLabel = newLabel();
2169             emitJumpIfTrue(checkResult.get(), isNotVarScopeLabel.get());
2170 
2171             // Put to outer scope
2172             emitPutToScope(scopeId.get(), functionName, currentValue.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2173             emitLabel(isNotVarScopeLabel.get());
2174 
2175         }
2176     }
2177 }
2178 
2179 RegisterID* BytecodeGenerator::emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp; property)
2180 {
2181     ASSERT(m_codeType == EvalCode);
2182 
2183     dst = finalDestination(dst);
2184     OpResolveScopeForHoistingFuncDeclInEval::emit(this, kill(dst), m_topMostScope, addConstant(property));
2185     return dst;
2186 }
2187 
2188 void BytecodeGenerator::popLexicalScope(VariableEnvironmentNode* node)
2189 {
2190     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2191     popLexicalScopeInternal(environment);
2192 }
2193 
2194 void BytecodeGenerator::popLexicalScopeInternal(VariableEnvironment&amp; environment)
2195 {
2196     // NOTE: This function only makes sense for scopes that aren&#39;t ScopeRegisterType::Var (only function name scope right now is ScopeRegisterType::Var).
2197     // This doesn&#39;t make sense for ScopeRegisterType::Var because we deref RegisterIDs here.
2198     if (!environment.size())
2199         return;
2200 
2201     if (shouldEmitDebugHooks())
2202         environment.markAllVariablesAsCaptured();
2203 
2204     auto stackEntry = m_lexicalScopeStack.takeLast();
2205     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2206     bool hasCapturedVariables = false;
2207     for (auto&amp; entry : environment) {
2208         if (entry.value.isCaptured()) {
2209             hasCapturedVariables = true;
2210             continue;
2211         }
2212         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
2213         ASSERT(!symbolTableEntry.isNull());
2214         VarOffset offset = symbolTableEntry.varOffset();
2215         ASSERT(offset.isStack());
2216         RegisterID* local = &amp;registerFor(offset.stackOffset());
2217         local-&gt;deref();
2218     }
2219 
2220     if (hasCapturedVariables) {
2221         RELEASE_ASSERT(stackEntry.m_scope);
2222         emitPopScope(scopeRegister(), stackEntry.m_scope);
2223         popLocalControlFlowScope();
2224         stackEntry.m_scope-&gt;deref();
2225     }
2226 
2227     m_TDZStack.removeLast();
2228     m_cachedVariablesUnderTDZ = { };
2229 }
2230 
2231 void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
2232 {
2233     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2234     if (!environment.size())
2235         return;
2236     if (shouldEmitDebugHooks())
2237         environment.markAllVariablesAsCaptured();
2238     if (!environment.hasCapturedVariables())
2239         return;
2240 
2241     RELEASE_ASSERT(loopSymbolTable);
2242 
2243     // This function needs to do setup for a for loop&#39;s activation if any of
2244     // the for loop&#39;s lexically declared variables are captured (that is, variables
2245     // declared in the loop header, not the loop body). This function needs to
2246     // make a copy of the current activation and copy the values from the previous
2247     // activation into the new activation because each iteration of a for loop
2248     // gets a new activation.
2249 
2250     auto stackEntry = m_lexicalScopeStack.last();
2251     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2252     RegisterID* loopScope = stackEntry.m_scope;
2253     ASSERT(symbolTable-&gt;scopeSize());
2254     ASSERT(loopScope);
2255     Vector&lt;std::pair&lt;RegisterID*, Identifier&gt;&gt; activationValuesToCopyOver;
2256 
2257     {
2258         activationValuesToCopyOver.reserveInitialCapacity(symbolTable-&gt;scopeSize());
2259 
2260         for (auto end = symbolTable-&gt;end(NoLockingNecessary), ptr = symbolTable-&gt;begin(NoLockingNecessary); ptr != end; ++ptr) {
2261             if (!ptr-&gt;value.varOffset().isScope())
2262                 continue;
2263 
2264             RefPtr&lt;UniquedStringImpl&gt; ident = ptr-&gt;key;
2265             Identifier identifier = Identifier::fromUid(m_vm, ident.get());
2266 
2267             RegisterID* transitionValue = newBlockScopeVariable();
2268             transitionValue-&gt;ref();
2269             emitGetFromScope(transitionValue, loopScope, variableForLocalEntry(identifier, ptr-&gt;value, loopSymbolTable-&gt;index(), true), DoNotThrowIfNotFound);
2270             activationValuesToCopyOver.uncheckedAppend(std::make_pair(transitionValue, identifier));
2271         }
2272     }
2273 
2274     // We need this dynamic behavior of the executing code to ensure
2275     // each loop iteration has a new activation object. (It&#39;s pretty ugly).
2276     // Also, this new activation needs to be assigned to the same register
2277     // as the previous scope because the loop body is compiled under
2278     // the assumption that the scope&#39;s register index is constant even
2279     // though the value in that register will change on each loop iteration.
2280     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), loopScope);
2281     move(scopeRegister(), parentScope.get());
2282 
2283     OpCreateLexicalEnvironment::emit(this, loopScope, scopeRegister(), loopSymbolTable, addConstantValue(jsTDZValue()));
2284 
2285     move(scopeRegister(), loopScope);
2286 
2287     {
2288         for (auto pair : activationValuesToCopyOver) {
2289             const Identifier&amp; identifier = pair.second;
2290             SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, identifier.impl());
2291             RELEASE_ASSERT(!entry.isNull());
2292             RegisterID* transitionValue = pair.first;
2293             emitPutToScope(loopScope, variableForLocalEntry(identifier, entry, loopSymbolTable-&gt;index(), true), transitionValue, DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2294             transitionValue-&gt;deref();
2295         }
2296     }
2297 }
2298 
2299 Variable BytecodeGenerator::variable(const Identifier&amp; property, ThisResolutionType thisResolutionType)
2300 {
2301     if (property == propertyNames().thisIdentifier &amp;&amp; thisResolutionType == ThisResolutionType::Local)
2302         return Variable(property, VarOffset(thisRegister()-&gt;virtualRegister()), thisRegister(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly), Variable::SpecialVariable, 0, false);
2303 
2304     // We can optimize lookups if the lexical variable is found before a &quot;with&quot; or &quot;catch&quot;
2305     // scope because we&#39;re guaranteed static resolution. If we have to pass through
2306     // a &quot;with&quot; or &quot;catch&quot; scope we loose this guarantee.
2307     // We can&#39;t optimize cases like this:
2308     // {
2309     //     let x = ...;
2310     //     with (o) {
2311     //         doSomethingWith(x);
2312     //     }
2313     // }
2314     // Because we can&#39;t gaurantee static resolution on x.
2315     // But, in this case, we are guaranteed static resolution:
2316     // {
2317     //     let x = ...;
2318     //     with (o) {
2319     //         let x = ...;
2320     //         doSomethingWith(x);
2321     //     }
2322     // }
2323     for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2324         auto&amp; stackEntry = m_lexicalScopeStack[i];
2325         if (stackEntry.m_isWithScope)
2326             return Variable(property);
2327         SymbolTable* symbolTable = stackEntry.m_symbolTable;
2328         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, property.impl());
2329         if (symbolTableEntry.isNull())
2330             continue;
2331         bool resultIsCallee = false;
2332         if (symbolTable-&gt;scopeType() == SymbolTable::ScopeType::FunctionNameScope) {
2333             if (m_usesNonStrictEval) {
2334                 // We don&#39;t know if an eval has introduced a &quot;var&quot; named the same thing as the function name scope variable name.
2335                 // We resort to dynamic lookup to answer this question.
2336                 Variable result = Variable(property);
2337                 return result;
2338             }
2339             resultIsCallee = true;
2340         }
2341         Variable result = variableForLocalEntry(property, symbolTableEntry, stackEntry.m_symbolTableConstantIndex, symbolTable-&gt;scopeType() == SymbolTable::ScopeType::LexicalScope);
2342         if (resultIsCallee)
2343             result.setIsReadOnly();
2344         return result;
2345     }
2346 
2347     return Variable(property);
2348 }
2349 
2350 Variable BytecodeGenerator::variableForLocalEntry(
2351     const Identifier&amp; property, const SymbolTableEntry&amp; entry, int symbolTableConstantIndex, bool isLexicallyScoped)
2352 {
2353     VarOffset offset = entry.varOffset();
2354 
2355     RegisterID* local;
2356     if (offset.isStack())
2357         local = &amp;registerFor(offset.stackOffset());
2358     else
2359         local = nullptr;
2360 
2361     return Variable(property, offset, local, entry.getAttributes(), Variable::NormalVariable, symbolTableConstantIndex, isLexicallyScoped);
2362 }
2363 
2364 void BytecodeGenerator::createVariable(
2365     const Identifier&amp; property, VarKind varKind, SymbolTable* symbolTable, ExistingVariableMode existingVariableMode)
2366 {
2367     ASSERT(property != propertyNames().thisIdentifier);
2368     SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, property.impl());
2369 
2370     if (!entry.isNull()) {
2371         if (existingVariableMode == IgnoreExisting)
2372             return;
2373 
2374         // Do some checks to ensure that the variable we&#39;re being asked to create is sufficiently
2375         // compatible with the one we have already created.
2376 
2377         VarOffset offset = entry.varOffset();
2378 
2379         // We can&#39;t change our minds about whether it&#39;s captured.
2380         if (offset.kind() != varKind) {
2381             dataLog(
2382                 &quot;Trying to add variable called &quot;, property, &quot; as &quot;, varKind,
2383                 &quot; but it was already added as &quot;, offset, &quot;.\n&quot;);
2384             RELEASE_ASSERT_NOT_REACHED();
2385         }
2386 
2387         return;
2388     }
2389 
2390     VarOffset varOffset;
2391     if (varKind == VarKind::Scope)
2392         varOffset = VarOffset(symbolTable-&gt;takeNextScopeOffset(NoLockingNecessary));
2393     else {
2394         ASSERT(varKind == VarKind::Stack);
2395         varOffset = VarOffset(virtualRegisterForLocal(m_calleeLocals.size()));
2396     }
2397     SymbolTableEntry newEntry(varOffset, 0);
2398     symbolTable-&gt;add(NoLockingNecessary, property.impl(), newEntry);
2399 
2400     if (varKind == VarKind::Stack) {
2401         RegisterID* local = addVar();
2402         RELEASE_ASSERT(local-&gt;index() == varOffset.stackOffset().offset());
2403     }
2404 }
2405 
2406 RegisterID* BytecodeGenerator::emitOverridesHasInstance(RegisterID* dst, RegisterID* constructor, RegisterID* hasInstanceValue)
2407 {
2408     OpOverridesHasInstance::emit(this, dst, constructor, hasInstanceValue);
2409     return dst;
2410 }
2411 
2412 // Indicates the least upper bound of resolve type based on local scope. The bytecode linker
2413 // will start with this ResolveType and compute the least upper bound including intercepting scopes.
2414 ResolveType BytecodeGenerator::resolveType()
2415 {
2416     for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2417         if (m_lexicalScopeStack[i].m_isWithScope)
2418             return Dynamic;
2419         if (m_usesNonStrictEval &amp;&amp; m_lexicalScopeStack[i].m_symbolTable-&gt;scopeType() == SymbolTable::ScopeType::FunctionNameScope) {
2420             // We never want to assign to a FunctionNameScope. Returning Dynamic here achieves this goal.
2421             // If we aren&#39;t in non-strict eval mode, then NodesCodeGen needs to take care not to emit
2422             // a put_to_scope with the destination being the function name scope variable.
2423             return Dynamic;
2424         }
2425     }
2426 
2427     if (m_usesNonStrictEval)
2428         return GlobalPropertyWithVarInjectionChecks;
2429     return GlobalProperty;
2430 }
2431 
2432 RegisterID* BytecodeGenerator::emitResolveScope(RegisterID* dst, const Variable&amp; variable)
2433 {
2434     switch (variable.offset().kind()) {
2435     case VarKind::Stack:
2436         return nullptr;
2437 
2438     case VarKind::DirectArgument:
2439         return argumentsRegister();
2440 
2441     case VarKind::Scope: {
2442         // This always refers to the activation that *we* allocated, and not the current scope that code
2443         // lives in. Note that this will change once we have proper support for block scoping. Once that
2444         // changes, it will be correct for this code to return scopeRegister(). The only reason why we
2445         // don&#39;t do that already is that m_lexicalEnvironment is required by ConstDeclNode. ConstDeclNode
2446         // requires weird things because it is a shameful pile of nonsense, but block scoping would make
2447         // that code sensible and obviate the need for us to do bad things.
2448         for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2449             auto&amp; stackEntry = m_lexicalScopeStack[i];
2450             // We should not resolve a variable to VarKind::Scope if a &quot;with&quot; scope lies in between the current
2451             // scope and the resolved scope.
2452             RELEASE_ASSERT(!stackEntry.m_isWithScope);
2453 
2454             if (stackEntry.m_symbolTable-&gt;get(NoLockingNecessary, variable.ident().impl()).isNull())
2455                 continue;
2456 
2457             RegisterID* scope = stackEntry.m_scope;
2458             RELEASE_ASSERT(scope);
2459             return scope;
2460         }
2461 
2462         RELEASE_ASSERT_NOT_REACHED();
2463         return nullptr;
2464 
2465     }
2466     case VarKind::Invalid:
2467         // Indicates non-local resolution.
2468 
2469         dst = tempDestination(dst);
2470         OpResolveScope::emit(this, kill(dst), scopeRegister(), addConstant(variable.ident()), resolveType(), localScopeDepth());
2471         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2472         return dst;
2473     }
2474 
2475     RELEASE_ASSERT_NOT_REACHED();
2476     return nullptr;
2477 }
2478 
2479 RegisterID* BytecodeGenerator::emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp; variable, ResolveMode resolveMode)
2480 {
2481     switch (variable.offset().kind()) {
2482     case VarKind::Stack:
2483         return move(dst, variable.local());
2484 
2485     case VarKind::DirectArgument: {
2486         OpGetFromArguments::emit(this, kill(dst), scope, variable.offset().capturedArgumentsOffset().offset());
2487         return dst;
2488     }
2489 
2490     case VarKind::Scope:
2491     case VarKind::Invalid: {
2492         OpGetFromScope::emit(
2493             this,
2494             kill(dst),
2495             scope,
2496             addConstant(variable.ident()),
2497             GetPutInfo(resolveMode, variable.offset().isScope() ? LocalClosureVar : resolveType(), InitializationMode::NotInitialization),
2498             localScopeDepth(),
2499             variable.offset().isScope() ? variable.offset().scopeOffset().offset() : 0);
2500         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2501         return dst;
2502     } }
2503 
2504     RELEASE_ASSERT_NOT_REACHED();
2505 }
2506 
2507 RegisterID* BytecodeGenerator::emitPutToScope(RegisterID* scope, const Variable&amp; variable, RegisterID* value, ResolveMode resolveMode, InitializationMode initializationMode)
2508 {
2509     switch (variable.offset().kind()) {
2510     case VarKind::Stack:
2511         move(variable.local(), value);
2512         return value;
2513 
2514     case VarKind::DirectArgument:
2515         OpPutToArguments::emit(this, scope, variable.offset().capturedArgumentsOffset().offset(), value);
2516         return value;
2517 
2518     case VarKind::Scope:
2519     case VarKind::Invalid: {
2520         GetPutInfo getPutInfo(0);
2521         SymbolTableOrScopeDepth symbolTableOrScopeDepth;
2522         ScopeOffset offset;
2523         if (variable.offset().isScope()) {
2524             offset = variable.offset().scopeOffset();
2525             getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
2526             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { variable.symbolTableConstantIndex() });
2527         } else {
2528             ASSERT(resolveType() != LocalClosureVar);
2529             getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
2530             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());
2531         }
2532         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, symbolTableOrScopeDepth, !!offset ? offset.offset() : 0);
2533         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2534         return value;
2535     } }
2536 
2537     RELEASE_ASSERT_NOT_REACHED();
2538 }
2539 
2540 RegisterID* BytecodeGenerator::initializeVariable(const Variable&amp; variable, RegisterID* value)
2541 {
2542     RELEASE_ASSERT(variable.offset().kind() != VarKind::Invalid);
2543     RegisterID* scope = emitResolveScope(nullptr, variable);
2544     return emitPutToScope(scope, variable, value, ThrowIfNotFound, InitializationMode::NotInitialization);
2545 }
2546 
2547 RegisterID* BytecodeGenerator::emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype)
2548 {
2549     OpInstanceof::emit(this, dst, value, basePrototype);
2550     return dst;
2551 }
2552 
2553 RegisterID* BytecodeGenerator::emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue)
2554 {
2555     OpInstanceofCustom::emit(this, dst, value, constructor, hasInstanceValue);
2556     return dst;
2557 }
2558 
2559 RegisterID* BytecodeGenerator::emitInByVal(RegisterID* dst, RegisterID* property, RegisterID* base)
2560 {
2561     OpInByVal::emit(this, dst, base, property);
2562     return dst;
2563 }
2564 
2565 RegisterID* BytecodeGenerator::emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2566 {
2567     OpInById::emit(this, dst, base, addConstant(property));
2568     return dst;
2569 }
2570 
2571 RegisterID* BytecodeGenerator::emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2572 {
2573     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties are not supported with tryGetById.&quot;);
2574 
2575     OpTryGetById::emit(this, kill(dst), base, addConstant(property));
2576     return dst;
2577 }
2578 
2579 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2580 {
2581     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2582 
2583     OpGetById::emit(this, kill(dst), base, addConstant(property));
2584     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2585     return dst;
2586 }
2587 
2588 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property)
2589 {
2590     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2591 
2592     OpGetByIdWithThis::emit(this, kill(dst), base, thisVal, addConstant(property));
2593     return dst;
2594 }
2595 
2596 RegisterID* BytecodeGenerator::emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2597 {
2598     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val_direct.&quot;);
2599 
2600     OpGetByIdDirect::emit(this, kill(dst), base, addConstant(property));
2601     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2602     return dst;
2603 }
2604 
2605 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value)
2606 {
2607     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2608 
2609     unsigned propertyIndex = addConstant(property);
2610 
2611     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2612 
2613     OpPutById::emit(this, base, propertyIndex, value, PutByIdNone); // is not direct
2614     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2615 
2616     return value;
2617 }
2618 
2619 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
2620 {
2621     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2622 
2623     unsigned propertyIndex = addConstant(property);
2624 
2625     OpPutByIdWithThis::emit(this, base, thisValue, propertyIndex, value);
2626 
2627     return value;
2628 }
2629 
2630 RegisterID* BytecodeGenerator::emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType putType)
2631 {
2632     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val(direct).&quot;);
2633 
2634     unsigned propertyIndex = addConstant(property);
2635 
2636     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2637 
2638     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm.propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;
2639     OpPutById::emit(this, base, propertyIndex, value, type);
2640     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2641     return value;
2642 }
2643 
2644 void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
2645 {
2646     unsigned propertyIndex = addConstant(property);
2647     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2648 
2649     OpPutGetterById::emit(this, base, propertyIndex, attributes, getter);
2650 }
2651 
2652 void BytecodeGenerator::emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* setter)
2653 {
2654     unsigned propertyIndex = addConstant(property);
2655     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2656 
2657     OpPutSetterById::emit(this, base, propertyIndex, attributes, setter);
2658 }
2659 
2660 void BytecodeGenerator::emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter)
2661 {
2662     unsigned propertyIndex = addConstant(property);
2663 
2664     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2665 
2666     OpPutGetterSetterById::emit(this, base, propertyIndex, attributes, getter, setter);
2667 }
2668 
2669 void BytecodeGenerator::emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* getter)
2670 {
2671     OpPutGetterByVal::emit(this, base, property, attributes, getter);
2672 }
2673 
2674 void BytecodeGenerator::emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* setter)
2675 {
2676     OpPutSetterByVal::emit(this, base, property, attributes, setter);
2677 }
2678 
2679 void BytecodeGenerator::emitPutGeneratorFields(RegisterID* nextFunction)
2680 {
2681     // FIXME: Currently, we just create an object and store generator related fields as its properties for ease.
2682     // But to make it efficient, we will introduce JSGenerator class, add opcode new_generator and use its C++ fields instead of these private properties.
2683     // https://bugs.webkit.org/show_bug.cgi?id=151545
2684 
2685     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);
2686 
2687     // We do not store &#39;this&#39; in arrow function within constructor,
2688     // because it might be not initialized, if super is called later.
2689     if (!(isDerivedConstructorContext() &amp;&amp; m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionMode))
2690         emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);
2691 
2692     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(0)), PropertyNode::KnownDirect);
2693 
2694     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2695 }
2696 
2697 void BytecodeGenerator::emitPutAsyncGeneratorFields(RegisterID* nextFunction)
2698 {
2699     ASSERT(isAsyncGeneratorWrapperParseMode(parseMode()));
2700 
2701     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);
2702 
2703     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);
2704 
2705     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorState::SuspendedStart))), PropertyNode::KnownDirect);
2706 
2707     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2708 
2709     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::None))), PropertyNode::KnownDirect);
2710 
2711     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueFirstPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2712     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueLastPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2713 }
2714 
2715 RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2716 {
2717     OpDelById::emit(this, dst, base, addConstant(property));
2718     return dst;
2719 }
2720 
2721 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2722 {
2723     for (size_t i = m_forInContextStack.size(); i--; ) {
2724         ForInContext&amp; context = m_forInContextStack[i].get();
2725         if (context.local() != property)
2726             continue;
2727 
2728         if (context.isIndexedForInContext()) {
2729             auto&amp; indexedContext = context.asIndexedForInContext();
2730             kill(dst);
2731             if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Narrow&gt;(this, dst, base, property))
2732                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(this, dst, base, indexedContext.index());
2733             else if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Wide16&gt;(this, dst, base, property))
2734                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Wide16&gt;(this, dst, base, indexedContext.index());
2735             else
2736                 OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(this, dst, base, indexedContext.index());
2737             indexedContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2738             return dst;
2739         }
2740 
2741         // We cannot do the above optimization here since OpGetDirectPname =&gt; OpGetByVal conversion involves different metadata ID allocation.
2742         StructureForInContext&amp; structureContext = context.asStructureForInContext();
2743         OpGetDirectPname::emit&lt;OpcodeSize::Wide32&gt;(this, kill(dst), base, property, structureContext.index(), structureContext.enumerator());
2744 
2745         structureContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2746         return dst;
2747     }
2748 
2749     OpGetByVal::emit(this, kill(dst), base, property);
2750     return dst;
2751 }
2752 
2753 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property)
2754 {
2755     OpGetByValWithThis::emit(this, kill(dst), base, thisValue, property);
2756     return dst;
2757 }
2758 
2759 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2760 {
2761     OpPutByVal::emit(this, base, property, value);
2762     return value;
2763 }
2764 
2765 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value)
2766 {
2767     OpPutByValWithThis::emit(this, base, thisValue, property, value);
2768     return value;
2769 }
2770 
2771 RegisterID* BytecodeGenerator::emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2772 {
2773     OpPutByValDirect::emit(this, base, property, value);
2774     return value;
2775 }
2776 
2777 RegisterID* BytecodeGenerator::emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2778 {
2779     OpDelByVal::emit(this, dst, base, property);
2780     return dst;
2781 }
2782 
2783 void BytecodeGenerator::emitSuperSamplerBegin()
2784 {
2785     OpSuperSamplerBegin::emit(this);
2786 }
2787 
2788 void BytecodeGenerator::emitSuperSamplerEnd()
2789 {
2790     OpSuperSamplerEnd::emit(this);
2791 }
2792 
2793 RegisterID* BytecodeGenerator::emitIdWithProfile(RegisterID* src, SpeculatedType profile)
2794 {
2795     OpIdentityWithProfile::emit(this, src, static_cast&lt;uint32_t&gt;(profile &gt;&gt; 32), static_cast&lt;uint32_t&gt;(profile));
2796     return src;
2797 }
2798 
2799 void BytecodeGenerator::emitUnreachable()
2800 {
2801     OpUnreachable::emit(this);
2802 }
2803 
2804 RegisterID* BytecodeGenerator::emitGetArgument(RegisterID* dst, int32_t index)
2805 {
2806     OpGetArgument::emit(this, dst, index + 1 /* Including |this| */);
2807     return dst;
2808 }
2809 
2810 RegisterID* BytecodeGenerator::emitCreateThis(RegisterID* dst)
2811 {
2812     OpCreateThis::emit(this, dst, dst, 0);
2813     m_staticPropertyAnalyzer.createThis(dst, m_lastInstruction);
2814 
2815     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2816     return dst;
2817 }
2818 
2819 void BytecodeGenerator::emitTDZCheck(RegisterID* target)
2820 {
2821     OpCheckTdz::emit(this, target);
2822 }
2823 
2824 bool BytecodeGenerator::needsTDZCheck(const Variable&amp; variable)
2825 {
2826     for (unsigned i = m_TDZStack.size(); i--;) {
2827         auto iter = m_TDZStack[i].find(variable.ident().impl());
2828         if (iter == m_TDZStack[i].end())
2829             continue;
2830         return iter-&gt;value != TDZNecessityLevel::NotNeeded;
2831     }
2832 
2833     return false;
2834 }
2835 
2836 void BytecodeGenerator::emitTDZCheckIfNecessary(const Variable&amp; variable, RegisterID* target, RegisterID* scope)
2837 {
2838     if (needsTDZCheck(variable)) {
2839         if (target)
2840             emitTDZCheck(target);
2841         else {
2842             RELEASE_ASSERT(!variable.isLocal() &amp;&amp; scope);
2843             RefPtr&lt;RegisterID&gt; result = emitGetFromScope(newTemporary(), scope, variable, DoNotThrowIfNotFound);
2844             emitTDZCheck(result.get());
2845         }
2846     }
2847 }
2848 
2849 void BytecodeGenerator::liftTDZCheckIfPossible(const Variable&amp; variable)
2850 {
2851     RefPtr&lt;UniquedStringImpl&gt; identifier(variable.ident().impl());
2852     for (unsigned i = m_TDZStack.size(); i--;) {
2853         auto iter = m_TDZStack[i].find(identifier);
2854         if (iter != m_TDZStack[i].end()) {
2855             if (iter-&gt;value == TDZNecessityLevel::Optimize) {
2856                 m_cachedVariablesUnderTDZ = { };
2857                 iter-&gt;value = TDZNecessityLevel::NotNeeded;
2858             }
2859             break;
2860         }
2861     }
2862 }
2863 
2864 void BytecodeGenerator::pushTDZVariables(const VariableEnvironment&amp; environment, TDZCheckOptimization optimization, TDZRequirement requirement)
2865 {
2866     if (!environment.size())
2867         return;
2868 
2869     TDZNecessityLevel level;
2870     if (requirement == TDZRequirement::UnderTDZ) {
2871         if (optimization == TDZCheckOptimization::Optimize)
2872             level = TDZNecessityLevel::Optimize;
2873         else
2874             level = TDZNecessityLevel::DoNotOptimize;
2875     } else
2876         level = TDZNecessityLevel::NotNeeded;
2877 
2878     TDZMap map;
2879     for (const auto&amp; entry : environment)
2880         map.add(entry.key, entry.value.isFunction() ? TDZNecessityLevel::NotNeeded : level);
2881 
2882     m_TDZStack.append(WTFMove(map));
2883     m_cachedVariablesUnderTDZ = { };
2884 }
2885 
2886 Optional&lt;CompactVariableMap::Handle&gt; BytecodeGenerator::getVariablesUnderTDZ()
2887 {
2888     if (m_cachedVariablesUnderTDZ) {
2889         if (!m_hasCachedVariablesUnderTDZ) {
2890             ASSERT(m_cachedVariablesUnderTDZ.environment().toVariableEnvironment().isEmpty());
2891             return WTF::nullopt;
2892         }
2893         return m_cachedVariablesUnderTDZ;
2894     }
2895 
2896     // We keep track of variablesThatDontNeedTDZ in this algorithm to prevent
2897     // reporting that &quot;x&quot; is under TDZ if this function is called at &quot;...&quot;.
2898     //
2899     //     {
2900     //         {
2901     //             let x;
2902     //             ...
2903     //         }
2904     //         let x;
2905     //     }
2906     SmallPtrSet&lt;UniquedStringImpl*, 16&gt; variablesThatDontNeedTDZ;
2907     VariableEnvironment environment;
2908     for (unsigned i = m_TDZStack.size(); i--; ) {
2909         auto&amp; map = m_TDZStack[i];
2910         for (auto&amp; entry : map)  {
2911             if (entry.value != TDZNecessityLevel::NotNeeded) {
2912                 if (!variablesThatDontNeedTDZ.contains(entry.key.get()))
2913                     environment.add(entry.key.get());
2914             } else
2915                 variablesThatDontNeedTDZ.add(entry.key.get());
2916         }
2917     }
2918 
2919     m_cachedVariablesUnderTDZ = m_vm.m_compactVariableMap-&gt;get(environment);
2920     m_hasCachedVariablesUnderTDZ = !environment.isEmpty();
2921     if (!m_hasCachedVariablesUnderTDZ)
2922         return WTF::nullopt;
2923 
2924     return m_cachedVariablesUnderTDZ;
2925 }
2926 
2927 void BytecodeGenerator::preserveTDZStack(BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2928 {
2929     preservedStack.m_preservedTDZStack = m_TDZStack;
2930 }
2931 
2932 void BytecodeGenerator::restoreTDZStack(const BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2933 {
2934     m_TDZStack = preservedStack.m_preservedTDZStack;
2935     m_cachedVariablesUnderTDZ = { };
2936 }
2937 
2938 RegisterID* BytecodeGenerator::emitNewObject(RegisterID* dst)
2939 {
2940     OpNewObject::emit(this, dst, 0);
2941     m_staticPropertyAnalyzer.newObject(dst, m_lastInstruction);
2942 
2943     return dst;
2944 }
2945 
2946 JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
2947 {
2948     return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
2949         auto scope = DECLARE_CATCH_SCOPE(vm());
2950         auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
2951         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);
2952         // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step
2953         // https://bugs.webkit.org/show_bug.cgi?id=180139
2954         scope.assertNoException();
2955         RELEASE_ASSERT(bigIntInMap);
2956         addConstantValue(bigIntInMap);
2957 
2958         return bigIntInMap;
2959     }).iterator-&gt;value;
2960 }
2961 
2962 JSString* BytecodeGenerator::addStringConstant(const Identifier&amp; identifier)
2963 {
2964     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
2965     if (!stringInMap) {
2966         stringInMap = jsString(vm(), identifier.string());
2967         addConstantValue(stringInMap);
2968     }
2969     return stringInMap;
2970 }
2971 
2972 RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor, int endOffset)
2973 {
2974     auto result = m_templateObjectDescriptorSet.add(WTFMove(descriptor));
2975     JSTemplateObjectDescriptor* descriptorValue = m_templateDescriptorMap.ensure(endOffset, [&amp;] {
2976         return JSTemplateObjectDescriptor::create(vm(), result.iterator-&gt;copyRef(), endOffset);
2977     }).iterator-&gt;value;
2978     int index = addConstantIndex();
2979     m_codeBlock-&gt;addConstant(descriptorValue);
2980     return &amp;m_constantPoolRegisters[index];
2981 }
2982 
2983 RegisterID* BytecodeGenerator::emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly* array, IndexingType recommendedIndexingType)
2984 {
2985     OpNewArrayBuffer::emit(this, dst, addConstantValue(array), recommendedIndexingType);
2986     return dst;
2987 }
2988 
2989 RegisterID* BytecodeGenerator::emitNewArray(RegisterID* dst, ElementNode* elements, unsigned length, IndexingType recommendedIndexingType)
2990 {
2991     Vector&lt;RefPtr&lt;RegisterID&gt;, 16, UnsafeVectorOverflow&gt; argv;
2992     for (ElementNode* n = elements; n; n = n-&gt;next()) {
2993         if (!length)
2994             break;
2995         length--;
2996         ASSERT(!n-&gt;value()-&gt;isSpreadExpression());
2997         argv.append(newTemporary());
2998         // op_new_array requires the initial values to be a sequential range of registers
2999         ASSERT(argv.size() == 1 || argv[argv.size() - 1]-&gt;index() == argv[argv.size() - 2]-&gt;index() - 1);
3000         emitNode(argv.last().get(), n-&gt;value());
3001     }
3002     ASSERT(!length);
3003     OpNewArray::emit(this, dst, argv.size() ? argv[0].get() : VirtualRegister { 0 }, argv.size(), recommendedIndexingType);
3004     return dst;
3005 }
3006 
3007 RegisterID* BytecodeGenerator::emitNewArrayWithSpread(RegisterID* dst, ElementNode* elements)
3008 {
3009     BitVector bitVector;
3010     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; argv;
3011     for (ElementNode* node = elements; node; node = node-&gt;next()) {
3012         bitVector.set(argv.size(), node-&gt;value()-&gt;isSpreadExpression());
3013 
3014         argv.append(newTemporary());
3015         // op_new_array_with_spread requires the initial values to be a sequential range of registers.
3016         RELEASE_ASSERT(argv.size() == 1 || argv[argv.size() - 1]-&gt;index() == argv[argv.size() - 2]-&gt;index() - 1);
3017     }
3018 
3019     RELEASE_ASSERT(argv.size());
3020 
3021     {
3022         unsigned i = 0;
3023         for (ElementNode* node = elements; node; node = node-&gt;next()) {
3024             if (node-&gt;value()-&gt;isSpreadExpression()) {
3025                 ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(node-&gt;value())-&gt;expression();
3026                 RefPtr&lt;RegisterID&gt; tmp = newTemporary();
3027                 emitNode(tmp.get(), expression);
3028 
3029                 OpSpread::emit(this, argv[i].get(), tmp.get());
3030             } else {
3031                 ExpressionNode* expression = node-&gt;value();
3032                 emitNode(argv[i].get(), expression);
3033             }
3034             i++;
3035         }
3036     }
3037 
3038     unsigned bitVectorIndex = m_codeBlock-&gt;addBitVector(WTFMove(bitVector));
3039     OpNewArrayWithSpread::emit(this, dst, argv[0].get(), argv.size(), bitVectorIndex);
3040     return dst;
3041 }
3042 
3043 RegisterID* BytecodeGenerator::emitNewArrayWithSize(RegisterID* dst, RegisterID* length)
3044 {
3045     OpNewArrayWithSize::emit(this, dst, length);
3046     return dst;
3047 }
3048 
3049 RegisterID* BytecodeGenerator::emitNewRegExp(RegisterID* dst, RegExp* regExp)
3050 {
3051     OpNewRegexp::emit(this, dst, addConstantValue(regExp));
3052     return dst;
3053 }
3054 
3055 void BytecodeGenerator::emitNewFunctionExpressionCommon(RegisterID* dst, FunctionMetadataNode* function)
3056 {
3057     unsigned index = m_codeBlock-&gt;addFunctionExpr(makeFunction(function));
3058 
3059     switch (function-&gt;parseMode()) {
3060     case SourceParseMode::GeneratorWrapperFunctionMode:
3061     case SourceParseMode::GeneratorWrapperMethodMode:
3062         OpNewGeneratorFuncExp::emit(this, dst, scopeRegister(), index);
3063         break;
3064     case SourceParseMode::AsyncFunctionMode:
3065     case SourceParseMode::AsyncMethodMode:
3066     case SourceParseMode::AsyncArrowFunctionMode:
3067         OpNewAsyncFuncExp::emit(this, dst, scopeRegister(), index);
3068         break;
3069     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
3070     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
3071         OpNewAsyncGeneratorFuncExp::emit(this, dst, scopeRegister(), index);
3072         break;
3073     default:
3074         OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3075         break;
3076     }
3077 }
3078 
3079 RegisterID* BytecodeGenerator::emitNewFunctionExpression(RegisterID* dst, FuncExprNode* func)
3080 {
3081     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3082     return dst;
3083 }
3084 
3085 RegisterID* BytecodeGenerator::emitNewArrowFunctionExpression(RegisterID* dst, ArrowFuncExprNode* func)
3086 {
3087     ASSERT(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(func-&gt;metadata()-&gt;parseMode()));
3088     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3089     return dst;
3090 }
3091 
3092 RegisterID* BytecodeGenerator::emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode* func)
3093 {
3094     ASSERT(isMethodParseMode(func-&gt;metadata()-&gt;parseMode()));
3095     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3096     return dst;
3097 }
3098 
3099 RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
3100     const Identifier&amp; ecmaName, const SourceCode&amp; classSource)
3101 {
3102     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);
3103     executable-&gt;setInvalidTypeProfilingOffsets();
3104     executable-&gt;setEcmaName(ecmaName);
3105     executable-&gt;setClassSource(classSource);
3106 
3107     unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
3108 
3109     OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3110     return dst;
3111 }
3112 
3113 RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
3114 {
3115     unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
3116     if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
3117         OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
3118     else if (function-&gt;parseMode() == SourceParseMode::AsyncFunctionMode)
3119         OpNewAsyncFunc::emit(this, dst, scopeRegister(), index);
3120     else if (isAsyncGeneratorWrapperParseMode(function-&gt;parseMode()))
3121         OpNewAsyncGeneratorFunc::emit(this, dst, scopeRegister(), index);
3122     else
3123         OpNewFunc::emit(this, dst, scopeRegister(), index);
3124     return dst;
3125 }
3126 
3127 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)
3128 {
3129     if (valueNode-&gt;isBaseFuncExprNode()) {
3130         FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
3131         if (!metadata-&gt;ecmaName().isNull())
3132             return;
3133     } else if (valueNode-&gt;isClassExprNode()) {
3134         ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
3135         if (!classExprNode-&gt;ecmaName().isNull())
3136             return;
3137         if (classExprNode-&gt;hasStaticProperty(m_vm.propertyNames-&gt;name))
3138             return;
3139     } else
3140         return;
3141 
3142     // FIXME: We should use an op_call to an internal function here instead.
3143     // https://bugs.webkit.org/show_bug.cgi?id=155547
3144     OpSetFunctionName::emit(this, value, name);
3145 }
3146 
3147 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3148 {
3149     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3150 }
3151 
3152 RegisterID* BytecodeGenerator::emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3153 {
3154     if (m_inTailPosition) {
3155         m_codeBlock-&gt;setHasTailCalls();
3156         return emitCall&lt;OpTailCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3157     }
3158     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3159 }
3160 
3161 RegisterID* BytecodeGenerator::emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3162 {
3163     return emitCall&lt;OpCallEval&gt;(dst, func, NoExpectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3164 }
3165 
3166 ExpectedFunction BytecodeGenerator::expectedFunctionForIdentifier(const Identifier&amp; identifier)
3167 {
3168     if (identifier == propertyNames().Object || identifier == propertyNames().builtinNames().ObjectPrivateName())
3169         return ExpectObjectConstructor;
3170     if (identifier == propertyNames().Array || identifier == propertyNames().builtinNames().ArrayPrivateName())
3171         return ExpectArrayConstructor;
3172     return NoExpectedFunction;
3173 }
3174 
3175 ExpectedFunction BytecodeGenerator::emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, Label&amp; done)
3176 {
3177     Ref&lt;Label&gt; realCall = newLabel();
3178     switch (expectedFunction) {
3179     case ExpectObjectConstructor: {
3180         // If the number of arguments is non-zero, then we can&#39;t do anything interesting.
3181         if (callArguments.argumentCountIncludingThis() &gt;= 2)
3182             return NoExpectedFunction;
3183 
3184         OpJneqPtr::emit(this, func, Special::ObjectConstructor, realCall-&gt;bind(this));
3185 
3186         if (dst != ignoredResult())
3187             emitNewObject(dst);
3188         break;
3189     }
3190 
3191     case ExpectArrayConstructor: {
3192         // If you&#39;re doing anything other than &quot;new Array()&quot; or &quot;new Array(foo)&quot; then we
3193         // don&#39;t do inline it, for now. The only reason is that call arguments are in
3194         // the opposite order of what op_new_array expects, so we&#39;d either need to change
3195         // how op_new_array works or we&#39;d need an op_new_array_reverse. Neither of these
3196         // things sounds like it&#39;s worth it.
3197         if (callArguments.argumentCountIncludingThis() &gt; 2)
3198             return NoExpectedFunction;
3199 
3200         OpJneqPtr::emit(this, func, Special::ArrayConstructor, realCall-&gt;bind(this));
3201 
3202         if (dst != ignoredResult()) {
3203             if (callArguments.argumentCountIncludingThis() == 2)
3204                 emitNewArrayWithSize(dst, callArguments.argumentRegister(0));
3205             else {
3206                 ASSERT(callArguments.argumentCountIncludingThis() == 1);
3207                 OpNewArray::emit(this, dst, VirtualRegister { 0 }, 0, ArrayWithUndecided);
3208             }
3209         }
3210         break;
3211     }
3212 
3213     default:
3214         ASSERT(expectedFunction == NoExpectedFunction);
3215         return NoExpectedFunction;
3216     }
3217 
3218     OpJmp::emit(this, done.bind(this));
3219     emitLabel(realCall.get());
3220 
3221     return expectedFunction;
3222 }
3223 
3224 template&lt;typename CallOp&gt;
3225 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3226 {
3227     constexpr auto opcodeID = CallOp::opcodeID;
3228     ASSERT(opcodeID == op_call || opcodeID == op_call_eval || opcodeID == op_tail_call);
3229     ASSERT(func-&gt;refCount());
3230 
3231     // Generate code for arguments.
3232     unsigned argument = 0;
3233     if (callArguments.argumentsNode()) {
3234         ArgumentListNode* n = callArguments.argumentsNode()-&gt;m_listNode;
3235         if (n &amp;&amp; n-&gt;m_expr-&gt;isSpreadExpression()) {
3236             RELEASE_ASSERT(!n-&gt;m_next);
3237             auto expression = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;m_expr)-&gt;expression();
3238             if (expression-&gt;isArrayLiteral()) {
3239                 auto* elements = static_cast&lt;ArrayNode*&gt;(expression)-&gt;elements();
3240                 if (elements &amp;&amp; !elements-&gt;next() &amp;&amp; elements-&gt;value()-&gt;isSpreadExpression()) {
3241                     ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(elements-&gt;value())-&gt;expression();
3242                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3243                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3244 
3245                     return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3246                 }
3247             }
3248             RefPtr&lt;RegisterID&gt; argumentRegister;
3249             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3250             RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3251             return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3252         }
3253         for (; n; n = n-&gt;m_next)
3254             emitNode(callArguments.argumentRegister(argument++), n);
3255     }
3256 
3257     // Reserve space for call frame.
3258     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3259     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3260         callFrame.append(newTemporary());
3261 
3262     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)
3263         emitDebugHook(WillExecuteExpression, divotStart);
3264 
3265     emitExpressionInfo(divot, divotStart, divotEnd);
3266 
3267     Ref&lt;Label&gt; done = newLabel();
3268     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3269 
3270     if (opcodeID == op_tail_call)
3271         emitLogShadowChickenTailIfNecessary();
3272 
3273     // Emit call.
3274     ASSERT(dst);
3275     ASSERT(dst != ignoredResult());
3276     CallOp::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3277 
3278     if (expectedFunction != NoExpectedFunction)
3279         emitLabel(done.get());
3280 
3281     return dst;
3282 }
3283 
3284 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3285 {
3286     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3287 }
3288 
3289 RegisterID* BytecodeGenerator::emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3290 {
3291     if (m_inTailPosition)
3292         return emitCallVarargs&lt;OpTailCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3293     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3294 }
3295 
3296 RegisterID* BytecodeGenerator::emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3297 {
3298     return emitCallVarargs&lt;OpConstructVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3299 }
3300 
3301 RegisterID* BytecodeGenerator::emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3302 {
3303     // We must emit a tail call here because we did not allocate an arguments object thus we would otherwise have no way to correctly make this call.
3304     ASSERT(m_inTailPosition || !Options::useTailCalls());
3305     return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3306 }
3307 
3308 template&lt;typename VarargsOp&gt;
3309 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3310 {
3311     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)
3312         emitDebugHook(WillExecuteExpression, divotStart);
3313 
3314     emitExpressionInfo(divot, divotStart, divotEnd);
3315 
3316     if (VarargsOp::opcodeID == op_tail_call_varargs)
3317         emitLogShadowChickenTailIfNecessary();
3318 
3319     // Emit call.
3320     ASSERT(dst != ignoredResult());
3321     VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);
3322     return dst;
3323 }
3324 
3325 void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
3326 {
3327     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3328         return;
3329     OpLogShadowChickenPrologue::emit(this, scopeRegister());
3330 }
3331 
3332 void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
3333 {
3334     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3335         return;
3336     OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
3337 }
3338 
3339 void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
3340     RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp; position)
3341 {
3342     DefinePropertyAttributes attributes;
3343     if (options &amp; PropertyConfigurable)
3344         attributes.setConfigurable(true);
3345 
3346     if (options &amp; PropertyWritable)
3347         attributes.setWritable(true);
3348     else if (valueRegister)
3349         attributes.setWritable(false);
3350 
3351     if (options &amp; PropertyEnumerable)
3352         attributes.setEnumerable(true);
3353 
3354     if (valueRegister)
3355         attributes.setValue();
3356     if (getterRegister)
3357         attributes.setGet();
3358     if (setterRegister)
3359         attributes.setSet();
3360 
3361     ASSERT(!valueRegister || (!getterRegister &amp;&amp; !setterRegister));
3362 
3363     emitExpressionInfo(position, position, position);
3364 
3365     if (attributes.hasGet() || attributes.hasSet()) {
3366         RefPtr&lt;RegisterID&gt; throwTypeErrorFunction;
3367         if (!attributes.hasGet() || !attributes.hasSet())
3368             throwTypeErrorFunction = moveLinkTimeConstant(nullptr, LinkTimeConstant::ThrowTypeErrorFunction);
3369 
3370         RefPtr&lt;RegisterID&gt; getter;
3371         if (attributes.hasGet())
3372             getter = getterRegister;
3373         else
3374             getter = throwTypeErrorFunction;
3375 
3376         RefPtr&lt;RegisterID&gt; setter;
3377         if (attributes.hasSet())
3378             setter = setterRegister;
3379         else
3380             setter = throwTypeErrorFunction;
3381 
3382         OpDefineAccessorProperty::emit(this, newObj, propertyNameRegister, getter.get(), setter.get(), emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3383     } else {
3384         OpDefineDataProperty::emit(this, newObj, propertyNameRegister, valueRegister, emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3385     }
3386 }
3387 
3388 RegisterID* BytecodeGenerator::emitReturn(RegisterID* src, ReturnFrom from)
3389 {
3390     if (isConstructor()) {
3391         bool isDerived = constructorKind() == ConstructorKind::Extends;
3392         bool srcIsThis = src-&gt;index() == m_thisRegister.index();
3393 
3394         if (isDerived &amp;&amp; (srcIsThis || from == ReturnFrom::Finally))
3395             emitTDZCheck(src);
3396 
3397         if (!srcIsThis || from == ReturnFrom::Finally) {
3398             Ref&lt;Label&gt; isObjectLabel = newLabel();
3399             emitJumpIfTrue(emitIsObject(newTemporary(), src), isObjectLabel.get());
3400 
3401             if (isDerived) {
3402                 Ref&lt;Label&gt; isUndefinedLabel = newLabel();
3403                 emitJumpIfTrue(emitIsUndefined(newTemporary(), src), isUndefinedLabel.get());
3404                 emitThrowTypeError(&quot;Cannot return a non-object type in the constructor of a derived class.&quot;);
3405                 emitLabel(isUndefinedLabel.get());
3406                 emitTDZCheck(&amp;m_thisRegister);
3407             }
3408             OpRet::emit(this, &amp;m_thisRegister);
3409             emitLabel(isObjectLabel.get());
3410         }
3411     }
3412 
3413     OpRet::emit(this, src);
3414     return src;
3415 }
3416 
3417 RegisterID* BytecodeGenerator::emitEnd(RegisterID* src)
3418 {
3419     OpEnd::emit(this, src);
3420     return src;
3421 }
3422 
3423 
3424 RegisterID* BytecodeGenerator::emitConstruct(RegisterID* dst, RegisterID* func, RegisterID* lazyThis, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
3425 {
3426     ASSERT(func-&gt;refCount());
3427 
3428     // Generate code for arguments.
3429     unsigned argument = 0;
3430     if (ArgumentsNode* argumentsNode = callArguments.argumentsNode()) {
3431 
3432         ArgumentListNode* n = callArguments.argumentsNode()-&gt;m_listNode;
3433         if (n &amp;&amp; n-&gt;m_expr-&gt;isSpreadExpression()) {
3434             RELEASE_ASSERT(!n-&gt;m_next);
3435             auto expression = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;m_expr)-&gt;expression();
3436             if (expression-&gt;isArrayLiteral()) {
3437                 auto* elements = static_cast&lt;ArrayNode*&gt;(expression)-&gt;elements();
3438                 if (elements &amp;&amp; !elements-&gt;next() &amp;&amp; elements-&gt;value()-&gt;isSpreadExpression()) {
3439                     ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(elements-&gt;value())-&gt;expression();
3440                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3441                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3442 
3443                     move(callArguments.thisRegister(), lazyThis);
3444                     RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3445                     return emitConstructVarargs(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, DebuggableCall::No);
3446                 }
3447             }
3448             RefPtr&lt;RegisterID&gt; argumentRegister;
3449             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3450             move(callArguments.thisRegister(), lazyThis);
3451             return emitConstructVarargs(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, DebuggableCall::No);
3452         }
3453 
3454         for (ArgumentListNode* n = argumentsNode-&gt;m_listNode; n; n = n-&gt;m_next)
3455             emitNode(callArguments.argumentRegister(argument++), n);
3456     }
3457 
3458     move(callArguments.thisRegister(), lazyThis);
3459 
3460     // Reserve space for call frame.
3461     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3462     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3463         callFrame.append(newTemporary());
3464 
3465     emitExpressionInfo(divot, divotStart, divotEnd);
3466 
3467     Ref&lt;Label&gt; done = newLabel();
3468     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3469 
3470     OpConstruct::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3471 
3472     if (expectedFunction != NoExpectedFunction)
3473         emitLabel(done.get());
3474 
3475     return dst;
3476 }
3477 
3478 RegisterID* BytecodeGenerator::emitStrcat(RegisterID* dst, RegisterID* src, int count)
3479 {
3480     OpStrcat::emit(this, dst, src, count);
3481     return dst;
3482 }
3483 
3484 void BytecodeGenerator::emitToPrimitive(RegisterID* dst, RegisterID* src)
3485 {
3486     OpToPrimitive::emit(this, dst, src);
3487 }
3488 
3489 void BytecodeGenerator::emitGetScope()
3490 {
3491     OpGetScope::emit(this, scopeRegister());
3492 }
3493 
3494 RegisterID* BytecodeGenerator::emitPushWithScope(RegisterID* objectScope)
3495 {
3496     pushLocalControlFlowScope();
3497     RegisterID* newScope = newBlockScopeVariable();
3498     newScope-&gt;ref();
3499 
3500     OpPushWithScope::emit(this, newScope, scopeRegister(), objectScope);
3501 
3502     move(scopeRegister(), newScope);
3503     m_lexicalScopeStack.append({ nullptr, newScope, true, 0 });
3504 
3505     return newScope;
3506 }
3507 
3508 RegisterID* BytecodeGenerator::emitGetParentScope(RegisterID* dst, RegisterID* scope)
3509 {
3510     OpGetParentScope::emit(this, dst, scope);
3511     return dst;
3512 }
3513 
3514 void BytecodeGenerator::emitPopScope(RegisterID* dst, RegisterID* scope)
3515 {
3516     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), scope);
3517     move(dst, parentScope.get());
3518 }
3519 
3520 void BytecodeGenerator::emitPopWithScope()
3521 {
3522     emitPopScope(scopeRegister(), scopeRegister());
3523     popLocalControlFlowScope();
3524     auto stackEntry = m_lexicalScopeStack.takeLast();
3525     stackEntry.m_scope-&gt;deref();
3526     RELEASE_ASSERT(stackEntry.m_isWithScope);
3527 }
3528 
3529 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
3530 {
3531     if (!shouldEmitDebugHooks())
3532         return;
3533 
3534     emitExpressionInfo(divot, divot, divot);
3535     OpDebug::emit(this, debugHookType, false);
3536 }
3537 
3538 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, unsigned line, unsigned charOffset, unsigned lineStart)
3539 {
3540     emitDebugHook(debugHookType, JSTextPosition(line, charOffset, lineStart));
3541 }
3542 
3543 void BytecodeGenerator::emitDebugHook(StatementNode* statement)
3544 {
3545     // DebuggerStatementNode will output its own special debug hook.
3546     if (statement-&gt;isDebuggerStatement())
3547         return;
3548 
3549     emitDebugHook(WillExecuteStatement, statement-&gt;position());
3550 }
3551 
3552 void BytecodeGenerator::emitDebugHook(ExpressionNode* expr)
3553 {
3554     emitDebugHook(WillExecuteStatement, expr-&gt;position());
3555 }
3556 
3557 void BytecodeGenerator::emitWillLeaveCallFrameDebugHook()
3558 {
3559     RELEASE_ASSERT(m_scopeNode-&gt;isFunctionNode());
3560     emitDebugHook(WillLeaveCallFrame, m_scopeNode-&gt;lastLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
3561 }
3562 
3563 void BytecodeGenerator::pushFinallyControlFlowScope(FinallyContext&amp; finallyContext)
3564 {
3565     ControlFlowScope scope(ControlFlowScope::Finally, currentLexicalScopeIndex(), &amp;finallyContext);
3566     m_controlFlowScopeStack.append(WTFMove(scope));
3567 
3568     m_finallyDepth++;
3569     m_currentFinallyContext = &amp;finallyContext;
3570 }
3571 
3572 void BytecodeGenerator::popFinallyControlFlowScope()
3573 {
3574     ASSERT(m_controlFlowScopeStack.size());
3575     ASSERT(m_controlFlowScopeStack.last().isFinallyScope());
3576     ASSERT(m_finallyDepth &gt; 0);
3577     ASSERT(m_currentFinallyContext);
3578     m_currentFinallyContext = m_currentFinallyContext-&gt;outerContext();
3579     m_finallyDepth--;
3580     m_controlFlowScopeStack.removeLast();
3581 }
3582 
3583 LabelScope* BytecodeGenerator::breakTarget(const Identifier&amp; name)
3584 {
3585     shrinkToFit(m_labelScopes);
3586 
3587     if (!m_labelScopes.size())
3588         return nullptr;
3589 
3590     // We special-case the following, which is a syntax error in Firefox:
3591     // label:
3592     //     break;
3593     if (name.isEmpty()) {
3594         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3595             LabelScope&amp; scope = m_labelScopes[i];
3596             if (scope.type() != LabelScope::NamedLabel)
3597                 return &amp;scope;
3598         }
3599         return nullptr;
3600     }
3601 
3602     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3603         LabelScope&amp; scope = m_labelScopes[i];
3604         if (scope.name() &amp;&amp; *scope.name() == name)
3605             return &amp;scope;
3606     }
3607     return nullptr;
3608 }
3609 
3610 LabelScope* BytecodeGenerator::continueTarget(const Identifier&amp; name)
3611 {
3612     shrinkToFit(m_labelScopes);
3613 
3614     if (!m_labelScopes.size())
3615         return nullptr;
3616 
3617     if (name.isEmpty()) {
3618         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3619             LabelScope&amp; scope = m_labelScopes[i];
3620             if (scope.type() == LabelScope::Loop) {
3621                 ASSERT(scope.continueTarget());
3622                 return &amp;scope;
3623             }
3624         }
3625         return nullptr;
3626     }
3627 
3628     // Continue to the loop nested nearest to the label scope that matches
3629     // &#39;name&#39;.
3630     LabelScope* result = nullptr;
3631     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3632         LabelScope&amp; scope = m_labelScopes[i];
3633         if (scope.type() == LabelScope::Loop) {
3634             ASSERT(scope.continueTarget());
3635             result = &amp;scope;
3636         }
3637         if (scope.name() &amp;&amp; *scope.name() == name)
3638             return result; // may be null.
3639     }
3640     return nullptr;
3641 }
3642 
3643 void BytecodeGenerator::allocateCalleeSaveSpace()
3644 {
3645     size_t virtualRegisterCountForCalleeSaves = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters();
3646 
3647     for (size_t i = 0; i &lt; virtualRegisterCountForCalleeSaves; i++) {
3648         RegisterID* localRegister = addVar();
3649         localRegister-&gt;ref();
3650         m_localRegistersForCalleeSaveRegisters.append(localRegister);
3651     }
3652 }
3653 
3654 void BytecodeGenerator::allocateAndEmitScope()
3655 {
3656     m_scopeRegister = addVar();
3657     m_scopeRegister-&gt;ref();
3658     m_codeBlock-&gt;setScopeRegister(scopeRegister()-&gt;virtualRegister());
3659     emitGetScope();
3660     m_topMostScope = addVar();
3661     move(m_topMostScope, scopeRegister());
3662 }
3663 
3664 TryData* BytecodeGenerator::pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType handlerType)
3665 {
3666     m_tryData.append(TryData { handlerLabel, handlerType });
3667     TryData* result = &amp;m_tryData.last();
3668 
3669     m_tryContextStack.append(TryContext {
3670         start,
3671         result
3672     });
3673 
3674     return result;
3675 }
3676 
3677 void BytecodeGenerator::popTry(TryData* tryData, Label&amp; end)
3678 {
3679     m_usesExceptions = true;
3680 
3681     ASSERT_UNUSED(tryData, m_tryContextStack.last().tryData == tryData);
3682 
3683     m_tryRanges.append(TryRange {
3684         m_tryContextStack.last().start.copyRef(),
3685         end,
3686         m_tryContextStack.last().tryData
3687     });
3688     m_tryContextStack.removeLast();
3689 }
3690 
3691 void BytecodeGenerator::emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)
3692 {
3693     RegisterID* unused = newTemporary();
3694     emitOutOfLineExceptionHandler(unused, thrownValueRegister, completionTypeRegister, data);
3695 }
3696 
3697 void BytecodeGenerator::emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData* data)
3698 {
3699     RegisterID* unused = newTemporary();
3700     ASSERT(completionTypeRegister);
3701     emitOutOfLineExceptionHandler(exceptionRegister, unused, completionTypeRegister, data);
3702 }
3703 
3704 void BytecodeGenerator::emitOutOfLineExceptionHandler(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)
3705 {
3706     VirtualRegister completionTypeVirtualRegister = completionTypeRegister ? completionTypeRegister : VirtualRegister();
3707     m_exceptionHandlersToEmit.append({ data, exceptionRegister, thrownValueRegister, completionTypeVirtualRegister });
3708 }
3709 
3710 void BytecodeGenerator::restoreScopeRegister(int lexicalScopeIndex)
3711 {
3712     if (lexicalScopeIndex == CurrentLexicalScopeIndex)
3713         return; // No change needed.
3714 
3715     if (lexicalScopeIndex != OutermostLexicalScopeIndex) {
3716         ASSERT(lexicalScopeIndex &lt; static_cast&lt;int&gt;(m_lexicalScopeStack.size()));
3717         int endIndex = lexicalScopeIndex + 1;
3718         for (size_t i = endIndex; i--; ) {
3719             if (m_lexicalScopeStack[i].m_scope) {
3720                 move(scopeRegister(), m_lexicalScopeStack[i].m_scope);
3721                 return;
3722             }
3723         }
3724     }
3725     // Note that if we don&#39;t find a local scope in the current function/program,
3726     // we must grab the outer-most scope of this bytecode generation.
3727     move(scopeRegister(), m_topMostScope);
3728 }
3729 
3730 void BytecodeGenerator::restoreScopeRegister()
3731 {
3732     restoreScopeRegister(currentLexicalScopeIndex());
3733 }
3734 
3735 int BytecodeGenerator::labelScopeDepthToLexicalScopeIndex(int targetLabelScopeDepth)
3736 {
3737     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
3738     size_t scopeDelta = labelScopeDepth() - targetLabelScopeDepth;
3739     ASSERT(scopeDelta &lt;= m_controlFlowScopeStack.size());
3740     if (!scopeDelta)
3741         return CurrentLexicalScopeIndex;
3742 
3743     ControlFlowScope&amp; targetScope = m_controlFlowScopeStack[targetLabelScopeDepth];
3744     return targetScope.lexicalScopeIndex;
3745 }
3746 
3747 void BytecodeGenerator::emitThrow(RegisterID* exc)
3748 {
3749     m_usesExceptions = true;
3750     OpThrow::emit(this, exc);
3751 }
3752 
3753 RegisterID* BytecodeGenerator::emitArgumentCount(RegisterID* dst)
3754 {
3755     OpArgumentCount::emit(this, dst);
3756     return dst;
3757 }
3758 
3759 unsigned BytecodeGenerator::localScopeDepth() const
3760 {
3761     return m_localScopeDepth;
3762 }
3763 
3764 int BytecodeGenerator::labelScopeDepth() const
3765 {
3766     unsigned depth = localScopeDepth() + m_finallyDepth;
3767     ASSERT(depth == m_controlFlowScopeStack.size());
3768     return depth;
3769 }
3770 
3771 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, RegisterID* raw)
3772 {
3773     RefPtr&lt;RegisterID&gt; message = newTemporary();
3774     emitToString(message.get(), raw);
3775     OpThrowStaticError::emit(this, message.get(), errorType);
3776 }
3777 
3778 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, const Identifier&amp; message)
3779 {
3780     OpThrowStaticError::emit(this, addConstantValue(addStringConstant(message)), errorType);
3781 }
3782 
3783 void BytecodeGenerator::emitThrowReferenceError(const String&amp; message)
3784 {
3785     emitThrowStaticError(ErrorType::ReferenceError, Identifier::fromString(m_vm, message));
3786 }
3787 
3788 void BytecodeGenerator::emitThrowTypeError(const String&amp; message)
3789 {
3790     emitThrowStaticError(ErrorType::TypeError, Identifier::fromString(m_vm, message));
3791 }
3792 
3793 void BytecodeGenerator::emitThrowTypeError(const Identifier&amp; message)
3794 {
3795     emitThrowStaticError(ErrorType::TypeError, message);
3796 }
3797 
3798 void BytecodeGenerator::emitThrowRangeError(const Identifier&amp; message)
3799 {
3800     emitThrowStaticError(ErrorType::RangeError, message);
3801 }
3802 
3803 void BytecodeGenerator::emitThrowOutOfMemoryError()
3804 {
3805     emitThrowStaticError(ErrorType::Error, Identifier::fromString(m_vm, &quot;Out of memory&quot;));
3806 }
3807 
3808 void BytecodeGenerator::emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* callee, bool isCaptured)
3809 {
3810     // There is some nuance here:
3811     // If we&#39;re in strict mode code, the function name scope variable acts exactly like a &quot;const&quot; variable.
3812     // If we&#39;re not in strict mode code, we want to allow bogus assignments to the name scoped variable.
3813     // This means any assignment to the variable won&#39;t throw, but it won&#39;t actually assign a new value to it.
3814     // To accomplish this, we don&#39;t report that this scope is a lexical scope. This will prevent
3815     // any throws when trying to assign to the variable (while still ensuring it keeps its original
3816     // value). There is some ugliness and exploitation of a leaky abstraction here, but it&#39;s better than
3817     // having a completely new op code and a class to handle name scopes which are so close in functionality
3818     // to lexical environments.
3819     VariableEnvironment nameScopeEnvironment;
3820     auto addResult = nameScopeEnvironment.add(property);
3821     if (isCaptured)
3822         addResult.iterator-&gt;value.setIsCaptured();
3823     addResult.iterator-&gt;value.setIsConst(); // The function name scope name acts like a const variable.
3824     unsigned numVars = m_codeBlock-&gt;m_numVars;
3825     pushLexicalScopeInternal(nameScopeEnvironment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::NotUnderTDZ, ScopeType::FunctionNameScope, ScopeRegisterType::Var);
3826     ASSERT_UNUSED(numVars, m_codeBlock-&gt;m_numVars == static_cast&lt;int&gt;(numVars + 1)); // Should have only created one new &quot;var&quot; for the function name scope.
3827     bool shouldTreatAsLexicalVariable = isStrictMode();
3828     Variable functionVar = variableForLocalEntry(property, m_lexicalScopeStack.last().m_symbolTable-&gt;get(NoLockingNecessary, property.impl()), m_lexicalScopeStack.last().m_symbolTableConstantIndex, shouldTreatAsLexicalVariable);
3829     emitPutToScope(m_lexicalScopeStack.last().m_scope, functionVar, callee, ThrowIfNotFound, InitializationMode::NotInitialization);
3830 }
3831 
3832 void BytecodeGenerator::pushLocalControlFlowScope()
3833 {
3834     ControlFlowScope scope(ControlFlowScope::Label, currentLexicalScopeIndex());
3835     m_controlFlowScopeStack.append(WTFMove(scope));
3836     m_localScopeDepth++;
3837 }
3838 
3839 void BytecodeGenerator::popLocalControlFlowScope()
3840 {
3841     ASSERT(m_controlFlowScopeStack.size());
3842     ASSERT(!m_controlFlowScopeStack.last().isFinallyScope());
3843     m_controlFlowScopeStack.removeLast();
3844     m_localScopeDepth--;
3845 }
3846 
3847 void BytecodeGenerator::emitPushCatchScope(VariableEnvironment&amp; environment)
3848 {
3849     pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::CatchScope, ScopeRegisterType::Block);
3850 }
3851 
3852 void BytecodeGenerator::emitPopCatchScope(VariableEnvironment&amp; environment)
3853 {
3854     popLexicalScopeInternal(environment);
3855 }
3856 
3857 void BytecodeGenerator::beginSwitch(RegisterID* scrutineeRegister, SwitchInfo::SwitchType type)
3858 {
3859     switch (type) {
3860     case SwitchInfo::SwitchImmediate: {
3861         size_t tableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
3862         m_codeBlock-&gt;addSwitchJumpTable();
3863         OpSwitchImm::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3864         break;
3865     }
3866     case SwitchInfo::SwitchCharacter: {
3867         size_t tableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
3868         m_codeBlock-&gt;addSwitchJumpTable();
3869         OpSwitchChar::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3870         break;
3871     }
3872     case SwitchInfo::SwitchString: {
3873         size_t tableIndex = m_codeBlock-&gt;numberOfStringSwitchJumpTables();
3874         m_codeBlock-&gt;addStringSwitchJumpTable();
3875         OpSwitchString::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3876         break;
3877     }
3878     default:
3879         RELEASE_ASSERT_NOT_REACHED();
3880     }
3881 
3882     SwitchInfo info = { m_lastInstruction.offset(), type };
3883     m_switchContextStack.append(info);
3884 }
3885 
3886 static int32_t keyForImmediateSwitch(ExpressionNode* node, int32_t min, int32_t max)
3887 {
3888     UNUSED_PARAM(max);
3889     ASSERT(node-&gt;isNumber());
3890     double value = static_cast&lt;NumberNode*&gt;(node)-&gt;value();
3891     int32_t key = static_cast&lt;int32_t&gt;(value);
3892     ASSERT(key == value);
3893     ASSERT(key &gt;= min);
3894     ASSERT(key &lt;= max);
3895     return key - min;
3896 }
3897 
3898 static int32_t keyForCharacterSwitch(ExpressionNode* node, int32_t min, int32_t max)
3899 {
3900     UNUSED_PARAM(max);
3901     ASSERT(node-&gt;isString());
3902     StringImpl* clause = static_cast&lt;StringNode*&gt;(node)-&gt;value().impl();
3903     ASSERT(clause-&gt;length() == 1);
3904 
3905     int32_t key = (*clause)[0];
3906     ASSERT(key &gt;= min);
3907     ASSERT(key &lt;= max);
3908     return key - min;
3909 }
3910 
3911 static void prepareJumpTableForSwitch(
3912     UnlinkedSimpleJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount,
3913     const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, int32_t min, int32_t max,
3914     int32_t (*keyGetter)(ExpressionNode*, int32_t min, int32_t max))
3915 {
3916     jumpTable.min = min;
3917     jumpTable.branchOffsets.resize(max - min + 1);
3918     jumpTable.branchOffsets.fill(0);
3919     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3920         // We&#39;re emitting this after the clause labels should have been fixed, so
3921         // the labels should not be &quot;forward&quot; references
3922         ASSERT(!labels[i]-&gt;isForward());
3923         jumpTable.add(keyGetter(nodes[i], min, max), labels[i]-&gt;bind(switchAddress));
3924     }
3925 }
3926 
3927 static void prepareJumpTableForStringSwitch(UnlinkedStringJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes)
3928 {
3929     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3930         // We&#39;re emitting this after the clause labels should have been fixed, so
3931         // the labels should not be &quot;forward&quot; references
3932         ASSERT(!labels[i]-&gt;isForward());
3933 
3934         ASSERT(nodes[i]-&gt;isString());
3935         StringImpl* clause = static_cast&lt;StringNode*&gt;(nodes[i])-&gt;value().impl();
3936         jumpTable.offsetTable.add(clause, UnlinkedStringJumpTable::OffsetLocation { labels[i]-&gt;bind(switchAddress) });
3937     }
3938 }
3939 
3940 void BytecodeGenerator::endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, Label&amp; defaultLabel, int32_t min, int32_t max)
3941 {
3942     SwitchInfo switchInfo = m_switchContextStack.last();
3943     m_switchContextStack.removeLast();
3944 
3945     BoundLabel defaultTarget = defaultLabel.bind(switchInfo.bytecodeOffset);
3946     auto handleSwitch = [&amp;](auto* op, auto bytecode) {
3947         op-&gt;setDefaultOffset(defaultTarget, [&amp;]() {
3948             m_codeBlock-&gt;addOutOfLineJumpTarget(switchInfo.bytecodeOffset, defaultTarget);
3949             return BoundLabel();
3950         });
3951 
3952         UnlinkedSimpleJumpTable&amp; jumpTable = m_codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex);
3953         prepareJumpTableForSwitch(
3954             jumpTable, switchInfo.bytecodeOffset, clauseCount, labels, nodes, min, max,
3955             switchInfo.switchType == SwitchInfo::SwitchImmediate
3956                 ? keyForImmediateSwitch
3957                 : keyForCharacterSwitch);
3958     };
3959 
3960     auto ref = m_writer.ref(switchInfo.bytecodeOffset);
3961     switch (switchInfo.switchType) {
3962     case SwitchInfo::SwitchImmediate: {
3963         handleSwitch(ref-&gt;cast&lt;OpSwitchImm&gt;(), ref-&gt;as&lt;OpSwitchImm&gt;());
3964         break;
3965     }
3966     case SwitchInfo::SwitchCharacter: {
3967         handleSwitch(ref-&gt;cast&lt;OpSwitchChar&gt;(), ref-&gt;as&lt;OpSwitchChar&gt;());
3968         break;
3969     }
3970 
3971     case SwitchInfo::SwitchString: {
3972         ref-&gt;cast&lt;OpSwitchString&gt;()-&gt;setDefaultOffset(defaultTarget, [&amp;]() {
3973             m_codeBlock-&gt;addOutOfLineJumpTarget(switchInfo.bytecodeOffset, defaultTarget);
3974             return BoundLabel();
3975         });
3976 
3977         UnlinkedStringJumpTable&amp; jumpTable = m_codeBlock-&gt;stringSwitchJumpTable(ref-&gt;as&lt;OpSwitchString&gt;().m_tableIndex);
3978         prepareJumpTableForStringSwitch(jumpTable, switchInfo.bytecodeOffset, clauseCount, labels, nodes);
3979         break;
3980     }
3981 
3982     default:
3983         RELEASE_ASSERT_NOT_REACHED();
3984         break;
3985     }
3986 }
3987 
3988 RegisterID* BytecodeGenerator::emitThrowExpressionTooDeepException()
3989 {
3990     // It would be nice to do an even better job of identifying exactly where the expression is.
3991     // And we could make the caller pass the node pointer in, if there was some way of getting
3992     // that from an arbitrary node. However, calling emitExpressionInfo without any useful data
3993     // is still good enough to get us an accurate line number.
3994     m_expressionTooDeep = true;
3995     return newTemporary();
3996 }
3997 
3998 bool BytecodeGenerator::isArgumentNumber(const Identifier&amp; ident, int argumentNumber)
3999 {
4000     RegisterID* registerID = variable(ident).local();
4001     if (!registerID)
4002         return false;
4003     return registerID-&gt;index() == CallFrame::argumentOffset(argumentNumber);
4004 }
4005 
4006 bool BytecodeGenerator::emitReadOnlyExceptionIfNeeded(const Variable&amp; variable)
4007 {
4008     // If we&#39;re in strict mode, we always throw.
4009     // If we&#39;re not in strict mode, we throw for &quot;const&quot; variables but not the function callee.
4010     if (isStrictMode() || variable.isConst()) {
4011         emitThrowTypeError(Identifier::fromString(m_vm, ReadonlyPropertyWriteError));
4012         return true;
4013     }
4014     return false;
4015 }
4016 
4017 void BytecodeGenerator::emitEnumeration(ThrowableExpressionData* node, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* forLoopNode, RegisterID* forLoopSymbolTable)
4018 {
4019     bool isForAwait = forLoopNode ? forLoopNode-&gt;isForAwait() : false;
4020     ASSERT(!isForAwait || (isForAwait &amp;&amp; isAsyncFunctionParseMode(parseMode())));
4021 
4022     RefPtr&lt;RegisterID&gt; subject = newTemporary();
4023     emitNode(subject.get(), subjectNode);
4024     RefPtr&lt;RegisterID&gt; iterator = isForAwait ? emitGetAsyncIterator(subject.get(), node) : emitGetIterator(subject.get(), node);
4025     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4026 
4027     Ref&lt;Label&gt; loopDone = newLabel();
4028     Ref&lt;Label&gt; tryStartLabel = newLabel();
4029     Ref&lt;Label&gt; finallyViaThrowLabel = newLabel();
4030     Ref&lt;Label&gt; finallyLabel = newLabel();
4031     Ref&lt;Label&gt; catchLabel = newLabel();
4032     Ref&lt;Label&gt; endCatchLabel = newLabel();
4033 
4034     // RefPtr&lt;Register&gt; iterator&#39;s lifetime must be longer than IteratorCloseContext.
4035     FinallyContext finallyContext(*this, finallyLabel.get());
4036     pushFinallyControlFlowScope(finallyContext);
4037 
4038     {
4039         Ref&lt;LabelScope&gt; scope = newLabelScope(LabelScope::Loop);
4040         RefPtr&lt;RegisterID&gt; value = newTemporary();
4041         emitLoad(value.get(), jsUndefined());
4042 
4043         emitJump(*scope-&gt;continueTarget());
4044 
4045         Ref&lt;Label&gt; loopStart = newLabel();
4046         emitLabel(loopStart.get());
4047         emitLoopHint();
4048 
4049         emitLabel(tryStartLabel.get());
4050         TryData* tryData = pushTry(tryStartLabel.get(), finallyViaThrowLabel.get(), HandlerType::SynthesizedFinally);
4051         callBack(*this, value.get());
4052         emitJump(*scope-&gt;continueTarget());
4053 
4054         // IteratorClose sequence for abrupt completions.
4055         {
4056             // Finally block for the enumeration.
4057             emitLabel(finallyViaThrowLabel.get());
4058             popTry(tryData, finallyViaThrowLabel.get());
4059 
4060             Ref&lt;Label&gt; finallyBodyLabel = newLabel();
4061             RefPtr&lt;RegisterID&gt; finallyExceptionRegister = newTemporary();
4062 
4063             emitOutOfLineFinallyHandler(finallyContext.completionValueRegister(), finallyContext.completionTypeRegister(), tryData);
4064             move(finallyExceptionRegister.get(), finallyContext.completionValueRegister());
4065             emitJump(finallyBodyLabel.get());
4066 
4067             emitLabel(finallyLabel.get());
4068             moveEmptyValue(finallyExceptionRegister.get());
4069 
4070             // Finally fall through case.
4071             emitLabel(finallyBodyLabel.get());
4072             restoreScopeRegister();
4073 
4074             Ref&lt;Label&gt; finallyDone = newLabel();
4075 
4076             RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4077             emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), finallyDone.get());
4078 
4079             Ref&lt;Label&gt; returnCallTryStart = newLabel();
4080             emitLabel(returnCallTryStart.get());
4081             TryData* returnCallTryData = pushTry(returnCallTryStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
4082 
4083             CallArguments returnArguments(*this, nullptr);
4084             move(returnArguments.thisRegister(), iterator.get());
4085             emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4086 
4087             if (isForAwait)
4088                 emitAwait(value.get());
4089 
4090             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), finallyDone.get());
4091             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4092 
4093             emitLabel(finallyDone.get());
4094             emitFinallyCompletion(finallyContext, endCatchLabel.get());
4095 
4096             popTry(returnCallTryData, finallyDone.get());
4097 
4098             // Catch block for exceptions that may be thrown while calling the return
4099             // handler in the enumeration finally block. The only reason we need this
4100             // catch block is because if entered the above finally block due to a thrown
4101             // exception, then we want to re-throw the original exception on exiting
4102             // the finally block. Otherwise, we&#39;ll let any new exception pass through.
4103             {
4104                 emitLabel(catchLabel.get());
4105 
4106                 RefPtr&lt;RegisterID&gt; exceptionRegister = newTemporary();
4107                 emitOutOfLineFinallyHandler(exceptionRegister.get(), finallyContext.completionTypeRegister(), returnCallTryData);
4108                 // Since this is a synthesized catch block and we&#39;re guaranteed to never need
4109                 // to resolve any symbols from the scope, we can skip restoring the scope
4110                 // register here.
4111 
4112                 Ref&lt;Label&gt; throwLabel = newLabel();
4113                 emitJumpIfTrue(emitIsEmpty(newTemporary(), finallyExceptionRegister.get()), throwLabel.get());
4114                 move(exceptionRegister.get(), finallyExceptionRegister.get());
4115 
4116                 emitLabel(throwLabel.get());
4117                 emitThrow(exceptionRegister.get());
4118 
4119                 emitLabel(endCatchLabel.get());
4120             }
4121         }
4122 
4123         emitLabel(*scope-&gt;continueTarget());
4124         if (forLoopNode) {
4125             RELEASE_ASSERT(forLoopNode-&gt;isForOfNode());
4126             prepareLexicalScopeForNextForLoopIteration(forLoopNode, forLoopSymbolTable);
4127             emitDebugHook(forLoopNode-&gt;lexpr());
4128         }
4129 
4130         {
4131             emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), node, isForAwait ? EmitAwait::Yes : EmitAwait::No);
4132 
4133             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4134             emitGetById(value.get(), value.get(), propertyNames().value);
4135             emitJump(loopStart.get());
4136         }
4137 
4138         bool breakLabelIsBound = scope-&gt;breakTargetMayBeBound();
4139         if (breakLabelIsBound)
4140             emitLabel(scope-&gt;breakTarget());
4141         popFinallyControlFlowScope();
4142         if (breakLabelIsBound) {
4143             // IteratorClose sequence for break-ed control flow.
4144             emitIteratorClose(iterator.get(), node, isForAwait ? EmitAwait::Yes : EmitAwait::No);
4145         }
4146     }
4147     emitLabel(loopDone.get());
4148 }
4149 
4150 RegisterID* BytecodeGenerator::emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode* taggedTemplate)
4151 {
4152     TemplateObjectDescriptor::StringVector rawStrings;
4153     TemplateObjectDescriptor::OptionalStringVector cookedStrings;
4154 
4155     TemplateStringListNode* templateString = taggedTemplate-&gt;templateLiteral()-&gt;templateStrings();
4156     for (; templateString; templateString = templateString-&gt;next()) {
4157         auto* string = templateString-&gt;value();
4158         ASSERT(string-&gt;raw());
4159         rawStrings.append(string-&gt;raw()-&gt;impl());
4160         if (!string-&gt;cooked())
4161             cookedStrings.append(WTF::nullopt);
4162         else
4163             cookedStrings.append(string-&gt;cooked()-&gt;impl());
4164     }
4165     RefPtr&lt;RegisterID&gt; constant = addTemplateObjectConstant(TemplateObjectDescriptor::create(WTFMove(rawStrings), WTFMove(cookedStrings)), taggedTemplate-&gt;endOffset());
4166     if (!dst)
4167         return constant.get();
4168     return move(dst, constant.get());
4169 }
4170 
4171 RegisterID* BytecodeGenerator::emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property)
4172 {
4173     dst = tempDestination(dst);
4174     Variable var = variable(property);
4175     if (RegisterID* local = var.local())
4176         return move(dst, local);
4177 
4178     RefPtr&lt;RegisterID&gt; scope = newTemporary();
4179     move(scope.get(), emitResolveScope(scope.get(), var));
4180     return emitGetFromScope(dst, scope.get(), var, ThrowIfNotFound);
4181 }
4182 
4183 RegisterID* BytecodeGenerator::emitGetEnumerableLength(RegisterID* dst, RegisterID* base)
4184 {
4185     OpGetEnumerableLength::emit(this, dst, base);
4186     return dst;
4187 }
4188 
4189 RegisterID* BytecodeGenerator::emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName)
4190 {
4191     OpHasGenericProperty::emit(this, dst, base, propertyName);
4192     return dst;
4193 }
4194 
4195 RegisterID* BytecodeGenerator::emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName)
4196 {
4197     OpHasIndexedProperty::emit(this, dst, base, propertyName);
4198     return dst;
4199 }
4200 
4201 RegisterID* BytecodeGenerator::emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator)
4202 {
4203     OpHasStructureProperty::emit(this, dst, base, propertyName, enumerator);
4204     return dst;
4205 }
4206 
4207 RegisterID* BytecodeGenerator::emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base)
4208 {
4209     OpGetPropertyEnumerator::emit(this, dst, base);
4210     return dst;
4211 }
4212 
4213 RegisterID* BytecodeGenerator::emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index)
4214 {
4215     OpEnumeratorStructurePname::emit(this, dst, enumerator, index);
4216     return dst;
4217 }
4218 
4219 RegisterID* BytecodeGenerator::emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index)
4220 {
4221     OpEnumeratorGenericPname::emit(this, dst, enumerator, index);
4222     return dst;
4223 }
4224 
4225 RegisterID* BytecodeGenerator::emitToIndexString(RegisterID* dst, RegisterID* index)
4226 {
4227     OpToIndexString::emit(this, dst, index);
4228     return dst;
4229 }
4230 
4231 RegisterID* BytecodeGenerator::emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType type)
4232 {
4233     OpIsCellWithType::emit(this, dst, src, type);
4234     return dst;
4235 }
4236 
4237 RegisterID* BytecodeGenerator::emitIsObject(RegisterID* dst, RegisterID* src)
4238 {
4239     OpIsObject::emit(this, dst, src);
4240     return dst;
4241 }
4242 
4243 RegisterID* BytecodeGenerator::emitIsNumber(RegisterID* dst, RegisterID* src)
4244 {
4245     OpIsNumber::emit(this, dst, src);
4246     return dst;
4247 }
4248 
4249 RegisterID* BytecodeGenerator::emitIsUndefined(RegisterID* dst, RegisterID* src)
4250 {
4251     OpIsUndefined::emit(this, dst, src);
4252     return dst;
4253 }
4254 
4255 RegisterID* BytecodeGenerator::emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src)
4256 {
4257     OpIsUndefinedOrNull::emit(this, dst, src);
4258     return dst;
4259 }
4260 
4261 RegisterID* BytecodeGenerator::emitIsEmpty(RegisterID* dst, RegisterID* src)
4262 {
4263     OpIsEmpty::emit(this, dst, src);
4264     return dst;
4265 }
4266 
4267 RegisterID* BytecodeGenerator::emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait doEmitAwait)
4268 {
4269     {
4270         CallArguments nextArguments(*this, nullptr);
4271         move(nextArguments.thisRegister(), iterator);
4272         emitCall(dst, nextMethod, NoExpectedFunction, nextArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4273 
4274         if (doEmitAwait == EmitAwait::Yes)
4275             emitAwait(dst);
4276     }
4277     {
4278         Ref&lt;Label&gt; typeIsObject = newLabel();
4279         emitJumpIfTrue(emitIsObject(newTemporary(), dst), typeIsObject.get());
4280         emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4281         emitLabel(typeIsObject.get());
4282     }
4283     return dst;
4284 }
4285 
4286 RegisterID* BytecodeGenerator::emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node)
4287 {
4288     {
4289         CallArguments nextArguments(*this, nullptr, 1);
4290         move(nextArguments.thisRegister(), iterator);
4291         move(nextArguments.argumentRegister(0), value);
4292         emitCall(dst, nextMethod, NoExpectedFunction, nextArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4293     }
4294 
4295     return dst;
4296 }
4297 
4298 void BytecodeGenerator::emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait doEmitAwait)
4299 {
4300     Ref&lt;Label&gt; done = newLabel();
4301     RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator, propertyNames().returnKeyword);
4302     emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), done.get());
4303 
4304     RefPtr&lt;RegisterID&gt; value = newTemporary();
4305     CallArguments returnArguments(*this, nullptr);
4306     move(returnArguments.thisRegister(), iterator);
4307     emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4308 
4309     if (doEmitAwait == EmitAwait::Yes)
4310         emitAwait(value.get());
4311 
4312     emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), done.get());
4313     emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4314     emitLabel(done.get());
4315 }
4316 
4317 void BytecodeGenerator::pushIndexedForInScope(RegisterID* localRegister, RegisterID* indexRegister)
4318 {
4319     if (!localRegister)
4320         return;
4321     unsigned bodyBytecodeStartOffset = instructions().size();
4322     m_forInContextStack.append(adoptRef(*new IndexedForInContext(localRegister, indexRegister, bodyBytecodeStartOffset)));
4323 }
4324 
4325 void BytecodeGenerator::popIndexedForInScope(RegisterID* localRegister)
4326 {
4327     if (!localRegister)
4328         return;
4329     unsigned bodyBytecodeEndOffset = instructions().size();
4330     m_forInContextStack.last()-&gt;asIndexedForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4331     m_forInContextStack.removeLast();
4332 }
4333 
4334 RegisterID* BytecodeGenerator::emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp; identifier)
4335 {
4336     ASSERT(m_codeBlock-&gt;isArrowFunction() || m_codeBlock-&gt;isArrowFunctionContext() || constructorKind() == ConstructorKind::Extends || m_codeType == EvalCode);
4337 
4338     return emitResolveScope(nullptr, variable(identifier, ThisResolutionType::Scoped));
4339 }
4340 
4341 void BytecodeGenerator::emitLoadThisFromArrowFunctionLexicalEnvironment()
4342 {
4343     emitGetFromScope(thisRegister(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier), variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped), DoNotThrowIfNotFound);
4344 }
4345 
4346 RegisterID* BytecodeGenerator::emitLoadNewTargetFromArrowFunctionLexicalEnvironment()
4347 {
4348     Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4349 
4350     return emitGetFromScope(m_newTargetRegister, emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().newTargetLocalPrivateName()), newTargetVar, ThrowIfNotFound);
4351 
4352 }
4353 
4354 RegisterID* BytecodeGenerator::emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment()
4355 {
4356     Variable protoScopeVar = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4357     return emitGetFromScope(newTemporary(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().derivedConstructorPrivateName()), protoScopeVar, ThrowIfNotFound);
4358 }
4359 
4360 RegisterID* BytecodeGenerator::ensureThis()
4361 {
4362     if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {
4363         if ((needsToUpdateArrowFunctionContext() &amp;&amp; isSuperCallUsedInInnerArrowFunction()) || m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionBodyMode)
4364             emitLoadThisFromArrowFunctionLexicalEnvironment();
4365 
4366         emitTDZCheck(thisRegister());
4367     }
4368 
4369     return thisRegister();
4370 }
4371 
4372 bool BytecodeGenerator::isThisUsedInInnerArrowFunction()
4373 {
4374     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4375 }
4376 
4377 bool BytecodeGenerator::isArgumentsUsedInInnerArrowFunction()
4378 {
4379     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseArguments() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval();
4380 }
4381 
4382 bool BytecodeGenerator::isNewTargetUsedInInnerArrowFunction()
4383 {
4384     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseNewTarget() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4385 }
4386 
4387 bool BytecodeGenerator::isSuperUsedInInnerArrowFunction()
4388 {
4389     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4390 }
4391 
4392 bool BytecodeGenerator::isSuperCallUsedInInnerArrowFunction()
4393 {
4394     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4395 }
4396 
4397 void BytecodeGenerator::emitPutNewTargetToArrowFunctionContextScope()
4398 {
4399     if (isNewTargetUsedInInnerArrowFunction()) {
4400         ASSERT(m_arrowFunctionContextLexicalEnvironmentRegister);
4401 
4402         Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4403         emitPutToScope(m_arrowFunctionContextLexicalEnvironmentRegister, newTargetVar, newTarget(), DoNotThrowIfNotFound, InitializationMode::Initialization);
4404     }
4405 }
4406 
4407 void BytecodeGenerator::emitPutDerivedConstructorToArrowFunctionContextScope()
4408 {
4409     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
4410         ASSERT(m_arrowFunctionContextLexicalEnvironmentRegister);
4411 
4412         Variable protoScope = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4413         emitPutToScope(m_arrowFunctionContextLexicalEnvironmentRegister, protoScope, &amp;m_calleeRegister, DoNotThrowIfNotFound, InitializationMode::Initialization);
4414     }
4415 }
4416 
4417 void BytecodeGenerator::emitPutThisToArrowFunctionContextScope()
4418 {
4419     if (isThisUsedInInnerArrowFunction() || (m_scopeNode-&gt;usesSuperCall() &amp;&amp; m_codeType == EvalCode)) {
4420         ASSERT(isDerivedConstructorContext() || m_arrowFunctionContextLexicalEnvironmentRegister != nullptr);
4421 
4422         Variable thisVar = variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped);
4423         RegisterID* scope = isDerivedConstructorContext() ? emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier) : m_arrowFunctionContextLexicalEnvironmentRegister;
4424 
4425         emitPutToScope(scope, thisVar, thisRegister(), ThrowIfNotFound, InitializationMode::NotInitialization);
4426     }
4427 }
4428 
4429 void BytecodeGenerator::pushStructureForInScope(RegisterID* localRegister, RegisterID* indexRegister, RegisterID* propertyRegister, RegisterID* enumeratorRegister)
4430 {
4431     if (!localRegister)
4432         return;
4433     unsigned bodyBytecodeStartOffset = instructions().size();
4434     m_forInContextStack.append(adoptRef(*new StructureForInContext(localRegister, indexRegister, propertyRegister, enumeratorRegister, bodyBytecodeStartOffset)));
4435 }
4436 
4437 void BytecodeGenerator::popStructureForInScope(RegisterID* localRegister)
4438 {
4439     if (!localRegister)
4440         return;
4441     unsigned bodyBytecodeEndOffset = instructions().size();
4442     m_forInContextStack.last()-&gt;asStructureForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4443     m_forInContextStack.removeLast();
4444 }
4445 
4446 RegisterID* BytecodeGenerator::emitRestParameter(RegisterID* result, unsigned numParametersToSkip)
4447 {
4448     RefPtr&lt;RegisterID&gt; restArrayLength = newTemporary();
4449     OpGetRestLength::emit(this, restArrayLength.get(), numParametersToSkip);
4450 
4451     OpCreateRest::emit(this, result, restArrayLength.get(), numParametersToSkip);
4452 
4453     return result;
4454 }
4455 
4456 void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
4457 {
4458     Ref&lt;Label&gt; target = newLabel();
4459     OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));
4460     emitThrowTypeError(error);
4461     emitLabel(target.get());
4462 }
4463 
4464 void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4465 {
4466     Ref&lt;Label&gt; mergePoint = newLabel();
4467     unsigned yieldPointIndex = m_yieldPoints++;
4468     emitGeneratorStateChange(yieldPointIndex + 1);
4469 
4470     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
4471         int suspendReason = static_cast&lt;int32_t&gt;(result);
4472         emitPutById(generatorRegister(), propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(suspendReason)));
4473     }
4474 
4475     // Split the try range here.
4476     Ref&lt;Label&gt; savePoint = newEmittedLabel();
4477     for (unsigned i = m_tryContextStack.size(); i--;) {
4478         TryContext&amp; context = m_tryContextStack[i];
4479         m_tryRanges.append(TryRange {
4480             context.start.copyRef(),
4481             savePoint.copyRef(),
4482             context.tryData
4483         });
4484         // Try range will be restared at the merge point.
4485         context.start = mergePoint.get();
4486     }
4487     Vector&lt;TryContext&gt; savedTryContextStack;
4488     m_tryContextStack.swap(savedTryContextStack);
4489 
4490 
4491 #if CPU(NEEDS_ALIGNED_ACCESS)
4492     // conservatively align for the bytecode rewriter: it will delete this yield and
4493     // append a fragment, so we make sure that the start of the fragments is aligned
4494     while (m_writer.position() % OpcodeSize::Wide32)
4495         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
4496 #endif
4497     OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
4498 
4499     // Restore the try contexts, which start offset is updated to the merge point.
4500     m_tryContextStack.swap(savedTryContextStack);
4501     emitLabel(mergePoint.get());
4502 }
4503 
4504 RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4505 {
4506     emitYieldPoint(argument, result);
4507 
4508     Ref&lt;Label&gt; normalLabel = newLabel();
4509     RefPtr&lt;RegisterID&gt; condition = newTemporary();
4510     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
4511     emitJumpIfTrue(condition.get(), normalLabel.get());
4512 
4513     Ref&lt;Label&gt; throwLabel = newLabel();
4514     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));
4515     emitJumpIfTrue(condition.get(), throwLabel.get());
4516     // Return.
4517     {
4518         RefPtr&lt;RegisterID&gt; returnRegister = generatorValueRegister();
4519         bool hasFinally = emitReturnViaFinallyIfNeeded(returnRegister.get());
4520         if (!hasFinally)
4521             emitReturn(returnRegister.get());
4522     }
4523 
4524     // Throw.
4525     emitLabel(throwLabel.get());
4526     emitThrow(generatorValueRegister());
4527 
4528     // Normal.
4529     emitLabel(normalLabel.get());
4530     return generatorValueRegister();
4531 }
4532 
4533 RegisterID* BytecodeGenerator::emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData* node)
4534 {
4535     CallArguments args(*this, nullptr);
4536     move(args.thisRegister(), argument);
4537     emitCall(iterator, iterator, NoExpectedFunction, args, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4538 
4539     return iterator;
4540 }
4541 
4542 void BytecodeGenerator::emitAwait(RegisterID* value)
4543 {
4544     emitYield(value, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);
4545     move(value, generatorValueRegister());
4546 }
4547 
4548 RegisterID* BytecodeGenerator::emitGetIterator(RegisterID* argument, ThrowableExpressionData* node)
4549 {
4550     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().iteratorSymbol);
4551     emitCallIterator(iterator.get(), argument, node);
4552 
4553     return iterator.get();
4554 }
4555 
4556 RegisterID* BytecodeGenerator::emitGetAsyncIterator(RegisterID* argument, ThrowableExpressionData* node)
4557 {
4558     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().asyncIteratorSymbol);
4559     Ref&lt;Label&gt; asyncIteratorNotFound = newLabel();
4560     Ref&lt;Label&gt; asyncIteratorFound = newLabel();
4561     Ref&lt;Label&gt; iteratorReceived = newLabel();
4562 
4563     emitJumpIfTrue(emitUnaryOp&lt;OpEqNull&gt;(newTemporary(), iterator.get()), asyncIteratorNotFound.get());
4564 
4565     emitJump(asyncIteratorFound.get());
4566     emitLabel(asyncIteratorNotFound.get());
4567 
4568     RefPtr&lt;RegisterID&gt; commonIterator = emitGetIterator(argument, node);
4569     move(iterator.get(), commonIterator.get());
4570 
4571     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4572 
4573     auto varCreateAsyncFromSyncIterator = variable(propertyNames().builtinNames().createAsyncFromSyncIteratorPrivateName());
4574     RefPtr&lt;RegisterID&gt; scope = newTemporary();
4575     move(scope.get(), emitResolveScope(scope.get(), varCreateAsyncFromSyncIterator));
4576     RefPtr&lt;RegisterID&gt; createAsyncFromSyncIterator = emitGetFromScope(newTemporary(), scope.get(), varCreateAsyncFromSyncIterator, ThrowIfNotFound);
4577 
4578     CallArguments args(*this, nullptr, 2);
4579     emitLoad(args.thisRegister(), jsUndefined());
4580 
4581     move(args.argumentRegister(0), iterator.get());
4582     move(args.argumentRegister(1), nextMethod.get());
4583 
4584     JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
4585     emitCall(iterator.get(), createAsyncFromSyncIterator.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
4586 
4587     emitJump(iteratorReceived.get());
4588 
4589     emitLabel(asyncIteratorFound.get());
4590     emitCallIterator(iterator.get(), argument, node);
4591     emitLabel(iteratorReceived.get());
4592 
4593     return iterator.get();
4594 }
4595 
4596 RegisterID* BytecodeGenerator::emitDelegateYield(RegisterID* argument, ThrowableExpressionData* node)
4597 {
4598     RefPtr&lt;RegisterID&gt; value = newTemporary();
4599     {
4600         RefPtr&lt;RegisterID&gt; iterator = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? emitGetAsyncIterator(argument, node) : emitGetIterator(argument, node);
4601         RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4602 
4603         Ref&lt;Label&gt; loopDone = newLabel();
4604         {
4605             Ref&lt;Label&gt; nextElement = newLabel();
4606             emitLoad(value.get(), jsUndefined());
4607 
4608             emitJump(nextElement.get());
4609 
4610             Ref&lt;Label&gt; loopStart = newLabel();
4611             emitLabel(loopStart.get());
4612             emitLoopHint();
4613 
4614             Ref&lt;Label&gt; branchOnResult = newLabel();
4615             {
4616                 emitYieldPoint(value.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
4617 
4618                 Ref&lt;Label&gt; normalLabel = newLabel();
4619                 Ref&lt;Label&gt; returnLabel = newLabel();
4620                 {
4621                     RefPtr&lt;RegisterID&gt; condition = newTemporary();
4622                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
4623                     emitJumpIfTrue(condition.get(), normalLabel.get());
4624 
4625                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ReturnMode))));
4626                     emitJumpIfTrue(condition.get(), returnLabel.get());
4627 
4628                     // Fallthrough to ThrowMode.
4629                 }
4630 
4631                 // Throw.
4632                 {
4633                     Ref&lt;Label&gt; throwMethodFound = newLabel();
4634                     RefPtr&lt;RegisterID&gt; throwMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().throwKeyword);
4635                     emitJumpIfFalse(emitIsUndefined(newTemporary(), throwMethod.get()), throwMethodFound.get());
4636 
4637                     EmitAwait emitAwaitInIteratorClose = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? EmitAwait::Yes : EmitAwait::No;
4638                     emitIteratorClose(iterator.get(), node, emitAwaitInIteratorClose);
4639 
4640                     emitThrowTypeError(&quot;Delegated generator does not have a &#39;throw&#39; method.&quot;_s);
4641 
4642                     emitLabel(throwMethodFound.get());
4643                     CallArguments throwArguments(*this, nullptr, 1);
4644                     move(throwArguments.thisRegister(), iterator.get());
4645                     move(throwArguments.argumentRegister(0), generatorValueRegister());
4646                     emitCall(value.get(), throwMethod.get(), NoExpectedFunction, throwArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4647 
4648                     emitJump(branchOnResult.get());
4649                 }
4650 
4651                 // Return.
4652                 emitLabel(returnLabel.get());
4653                 {
4654                     Ref&lt;Label&gt; returnMethodFound = newLabel();
4655                     RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4656                     emitJumpIfFalse(emitIsUndefined(newTemporary(), returnMethod.get()), returnMethodFound.get());
4657 
4658                     move(value.get(), generatorValueRegister());
4659 
4660                     Ref&lt;Label&gt; returnSequence = newLabel();
4661                     emitJump(returnSequence.get());
4662 
4663                     emitLabel(returnMethodFound.get());
4664                     CallArguments returnArguments(*this, nullptr, 1);
4665                     move(returnArguments.thisRegister(), iterator.get());
4666                     move(returnArguments.argumentRegister(0), generatorValueRegister());
4667                     emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4668 
4669                     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode)
4670                         emitAwait(value.get());
4671 
4672                     Ref&lt;Label&gt; returnIteratorResultIsObject = newLabel();
4673                     emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), returnIteratorResultIsObject.get());
4674                     emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4675 
4676                     emitLabel(returnIteratorResultIsObject.get());
4677 
4678                     Ref&lt;Label&gt; returnFromGenerator = newLabel();
4679                     emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), returnFromGenerator.get());
4680 
4681                     emitGetById(value.get(), value.get(), propertyNames().value);
4682                     emitJump(loopStart.get());
4683 
4684                     emitLabel(returnFromGenerator.get());
4685                     emitGetById(value.get(), value.get(), propertyNames().value);
4686 
4687                     emitLabel(returnSequence.get());
4688                     bool hasFinally = emitReturnViaFinallyIfNeeded(value.get());
4689                     if (!hasFinally)
4690                         emitReturn(value.get());
4691                 }
4692 
4693                 // Normal.
4694                 emitLabel(normalLabel.get());
4695                 move(value.get(), generatorValueRegister());
4696             }
4697 
4698             emitLabel(nextElement.get());
4699             emitIteratorNextWithValue(value.get(), nextMethod.get(), iterator.get(), value.get(), node);
4700 
4701             emitLabel(branchOnResult.get());
4702 
4703             if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode)
4704                 emitAwait(value.get());
4705 
4706             Ref&lt;Label&gt; iteratorValueIsObject = newLabel();
4707             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), iteratorValueIsObject.get());
4708             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4709             emitLabel(iteratorValueIsObject.get());
4710 
4711             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4712             emitGetById(value.get(), value.get(), propertyNames().value);
4713 
4714             emitJump(loopStart.get());
4715         }
4716         emitLabel(loopDone.get());
4717     }
4718 
4719     emitGetById(value.get(), value.get(), propertyNames().value);
4720     return value.get();
4721 }
4722 
4723 
4724 void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
4725 {
4726     RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
4727     emitPutById(generatorRegister(), propertyNames().builtinNames().generatorStatePrivateName(), completedState);
4728 }
4729 
4730 bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
4731 {
4732     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
4733     size_t numberOfScopesToCheckForFinally = labelScopeDepth() - targetLabelScopeDepth;
4734     ASSERT(numberOfScopesToCheckForFinally &lt;= m_controlFlowScopeStack.size());
4735     if (!numberOfScopesToCheckForFinally)
4736         return false;
4737 
4738     FinallyContext* innermostFinallyContext = nullptr;
4739     FinallyContext* outermostFinallyContext = nullptr;
4740     size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
4741     while (numberOfScopesToCheckForFinally--) {
4742         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
4743         if (scope-&gt;isFinallyScope()) {
4744             FinallyContext* finallyContext = scope-&gt;finallyContext;
4745             if (!innermostFinallyContext)
4746                 innermostFinallyContext = finallyContext;
4747             outermostFinallyContext = finallyContext;
4748             finallyContext-&gt;incNumberOfBreaksOrContinues();
4749         }
4750     }
4751     if (!outermostFinallyContext)
4752         return false; // No finallys to thread through.
4753 
4754     auto jumpID = bytecodeOffsetToJumpID(instructions().size());
4755     int lexicalScopeIndex = labelScopeDepthToLexicalScopeIndex(targetLabelScopeDepth);
4756     outermostFinallyContext-&gt;registerJump(jumpID, lexicalScopeIndex, jumpTarget);
4757 
4758     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), jumpID);
4759     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4760     return true; // We&#39;ll be jumping to a finally block.
4761 }
4762 
4763 bool BytecodeGenerator::emitReturnViaFinallyIfNeeded(RegisterID* returnRegister)
4764 {
4765     size_t numberOfScopesToCheckForFinally = m_controlFlowScopeStack.size();
4766     if (!numberOfScopesToCheckForFinally)
4767         return false;
4768 
4769     FinallyContext* innermostFinallyContext = nullptr;
4770     while (numberOfScopesToCheckForFinally) {
4771         size_t scopeIndex = --numberOfScopesToCheckForFinally;
4772         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex];
4773         if (scope-&gt;isFinallyScope()) {
4774             FinallyContext* finallyContext = scope-&gt;finallyContext;
4775             if (!innermostFinallyContext)
4776                 innermostFinallyContext = finallyContext;
4777             finallyContext-&gt;setHandlesReturns();
4778         }
4779     }
4780     if (!innermostFinallyContext)
4781         return false; // No finallys to thread through.
4782 
4783     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), CompletionType::Return);
4784     move(innermostFinallyContext-&gt;completionValueRegister(), returnRegister);
4785     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4786     return true; // We&#39;ll be jumping to a finally block.
4787 }
4788 
4789 void BytecodeGenerator::emitFinallyCompletion(FinallyContext&amp; context, Label&amp; normalCompletionLabel)
4790 {
4791     if (context.numberOfBreaksOrContinues() || context.handlesReturns()) {
4792         emitJumpIf&lt;OpStricteq&gt;(context.completionTypeRegister(), CompletionType::Normal, normalCompletionLabel);
4793 
4794         FinallyContext* outerContext = context.outerContext();
4795 
4796         size_t numberOfJumps = context.numberOfJumps();
4797         ASSERT(outerContext || numberOfJumps == context.numberOfBreaksOrContinues());
4798 
4799         // Handle Break or Continue completions that jumps into this FinallyContext.
4800         for (size_t i = 0; i &lt; numberOfJumps; i++) {
4801             Ref&lt;Label&gt; nextLabel = newLabel();
4802             auto&amp; jump = context.jumps(i);
4803             emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), jump.jumpID, nextLabel.get());
4804 
4805             // This case is for Break / Continue completions from an inner finally context
4806             // with a jump target that is not beyond the next outer finally context:
4807             //
4808             //     try {
4809             //         for (... stuff ...) {
4810             //             try {
4811             //                 continue; // Sets completionType to jumpID of top of the for loop.
4812             //             } finally {
4813             //             } // Jump to top of the for loop on completion.
4814             //         }
4815             //     } finally {
4816             //     }
4817             //
4818             // Since the jumpID is targetting a label that is inside the outer finally context,
4819             // we can jump to it directly on completion of this finally context: there is no intermediate
4820             // finally blocks to run. After the Break / Continue, we will contnue execution as normal.
4821             // So, we&#39;ll set the completionType to Normal (on behalf of the target) before we jump.
4822             // We can also set the completion value to undefined, but it will never be used for normal
4823             // completion anyway. So, we&#39;ll skip setting it.
4824 
4825             restoreScopeRegister(jump.targetLexicalScopeIndex);
4826             emitLoad(context.completionTypeRegister(), CompletionType::Normal);
4827             emitJump(jump.targetLabel.get());
4828 
4829             emitLabel(nextLabel.get());
4830         }
4831 
4832         // Handle completions that take us out of this FinallyContext.
4833         if (outerContext) {
4834             if (context.handlesReturns()) {
4835                 Ref&lt;Label&gt; isNotReturnLabel = newLabel();
4836                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, isNotReturnLabel.get());
4837 
4838                 // This case is for Return completion from an inner finally context:
4839                 //
4840                 //     try {
4841                 //         try {
4842                 //             return result; // Sets completionType to Return, and completionValue to result.
4843                 //         } finally {
4844                 //         } // Jump to outer finally on completion.
4845                 //     } finally {
4846                 //     }
4847                 //
4848                 // Since we know there&#39;s at least one outer finally context (beyond the current context),
4849                 // we cannot actually return from here. Instead, we pass the completionType and completionValue
4850                 // on to the next outer finally, and let it decide what to do next on its completion. The
4851                 // outer finally may or may not actual return depending on whether it encounters an abrupt
4852                 // completion in its body that overrrides this Return completion.
4853 
4854                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());
4855                 move(outerContext-&gt;completionValueRegister(), context.completionValueRegister());
4856                 emitJump(*outerContext-&gt;finallyLabel());
4857 
4858                 emitLabel(isNotReturnLabel.get());
4859             }
4860 
4861             bool hasBreaksOrContinuesThatEscapeCurrentFinally = context.numberOfBreaksOrContinues() &gt; numberOfJumps;
4862             if (hasBreaksOrContinuesThatEscapeCurrentFinally) {
4863                 Ref&lt;Label&gt; isThrowOrNormalLabel = newLabel();
4864                 emitJumpIf&lt;OpBeloweq&gt;(context.completionTypeRegister(), CompletionType::Throw, isThrowOrNormalLabel.get());
4865 
4866                 // A completionType above Throw means we have a Break or Continue encoded as a jumpID.
4867                 // We already ruled out Return above.
4868                 static_assert(CompletionType::Throw &lt; CompletionType::Return &amp;&amp; CompletionType::Throw &lt; CompletionType::Return, &quot;jumpIDs are above CompletionType::Return&quot;);
4869 
4870                 // This case is for Break / Continue completions in an inner finally context:
4871                 //
4872                 // 10: label:
4873                 // 11: try {
4874                 // 12:     try {
4875                 // 13:         for (... stuff ...)
4876                 // 14:             break label; // Sets completionType to jumpID of label.
4877                 // 15:     } finally {
4878                 // 16:     } // Jumps to outer finally on completion.
4879                 // 17:  } finally {
4880                 // 18:  }
4881                 //
4882                 // The break (line 14) says to continue execution at the label at line 10. Before we can
4883                 // goto line 10, the inner context&#39;s finally (line 15) needs to be run, followed by the
4884                 // outer context&#39;s finally (line 17). &#39;outerContext&#39; being non-null above tells us that
4885                 // there is at least one outer finally context that we need to run after we complete the
4886                 // current finally. Note that unless the body of the outer finally abruptly completes in a
4887                 // different way, that outer finally also needs to complete with a Break / Continue to
4888                 // the same target label. Hence, we need to pass the jumpID in this finally&#39;s completionTypeRegister
4889                 // to the outer finally. The completion value for Break and Continue according to the spec
4890                 // is undefined, but it won&#39;t ever be used. So, we&#39;ll skip setting it.
4891                 //
4892                 // Note that all we&#39;re doing here is passing the Break / Continue completion to the next
4893                 // outer finally context. We don&#39;t worry about finally contexts beyond that. It is the
4894                 // responsibility of the next outer finally to determine what to do next at its completion,
4895                 // and pass on to the next outer context if present and needed.
4896 
4897                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());
4898                 emitJump(*outerContext-&gt;finallyLabel());
4899 
4900                 emitLabel(isThrowOrNormalLabel.get());
4901             }
4902 
4903         } else {
4904             // We are the outermost finally.
4905             if (context.handlesReturns()) {
4906                 Ref&lt;Label&gt; notReturnLabel = newLabel();
4907                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, notReturnLabel.get());
4908 
4909                 // This case is for Return completion from the outermost finally context:
4910                 //
4911                 //     try {
4912                 //         return result; // Sets completionType to Return, and completionValue to result.
4913                 //     } finally {
4914                 //     } // Executes the return of the completionValue.
4915                 //
4916                 // Since we know there&#39;s no outer finally context (beyond the current context) to run,
4917                 // we can actually execute a return for this Return completion. The value to return
4918                 // is whatever is in the completionValueRegister.
4919 
4920                 emitWillLeaveCallFrameDebugHook();
4921                 emitReturn(context.completionValueRegister(), ReturnFrom::Finally);
4922 
4923                 emitLabel(notReturnLabel.get());
4924             }
4925         }
4926     }
4927 
4928     // By now, we&#39;ve rule out all Break / Continue / Return completions above. The only remaining
4929     // possibilities are Normal or Throw.
4930 
4931     emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Throw, normalCompletionLabel);
4932 
4933     // We get here because we entered this finally context with Throw completionType (i.e. we have
4934     // an exception that we need to rethrow), and we didn&#39;t encounter a different abrupt completion
4935     // that overrides that incoming completionType. All we have to do here is re-throw the exception
4936     // captured in the completionValue.
4937     //
4938     // Note that unlike for Break / Continue / Return, we don&#39;t need to worry about outer finally
4939     // contexts. This is because any outer finally context (if present) will have its own exception
4940     // handler, which will take care of receiving the Throw completion, and re-capturing the exception
4941     // in its completionValue.
4942 
4943     emitThrow(context.completionValueRegister());
4944 }
4945 
4946 template&lt;typename CompareOp&gt;
4947 void BytecodeGenerator::emitJumpIf(RegisterID* completionTypeRegister, CompletionType type, Label&amp; jumpTarget)
4948 {
4949     RefPtr&lt;RegisterID&gt; tempRegister = newTemporary();
4950     RegisterID* valueConstant = addConstantValue(jsNumber(static_cast&lt;int&gt;(type)));
4951     OperandTypes operandTypes = OperandTypes(ResultType::numberTypeIsInt32(), ResultType::unknownType());
4952 
4953     auto equivalenceResult = emitBinaryOp&lt;CompareOp&gt;(tempRegister.get(), completionTypeRegister, valueConstant, operandTypes);
4954     emitJumpIfTrue(equivalenceResult, jumpTarget);
4955 }
4956 
4957 void BytecodeGenerator::pushOptionalChainTarget()
4958 {
4959     m_optionalChainTargetStack.append(newLabel());
4960 }
4961 
4962 void BytecodeGenerator::popOptionalChainTarget()
4963 {
4964     ASSERT(m_optionalChainTargetStack.size());
4965     emitLabel(m_optionalChainTargetStack.takeLast().get());
4966 }
4967 
4968 void BytecodeGenerator::popOptionalChainTarget(RegisterID* dst, bool isDelete)
4969 {
4970     Ref&lt;Label&gt; endLabel = newLabel();
4971     emitJump(endLabel.get());
4972 
4973     popOptionalChainTarget();
4974     emitLoad(dst, isDelete ? jsBoolean(true) : jsUndefined());
4975 
4976     emitLabel(endLabel.get());
4977 }
4978 
4979 void BytecodeGenerator::emitOptionalCheck(RegisterID* src)
4980 {
4981     ASSERT(m_optionalChainTargetStack.size());
4982     emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());
4983 }
4984 
4985 void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4986 {
4987     // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
4988     // either of the following conditions is true:
4989     //
4990     // (1) The loop iteration variable is re-assigned within the body of the loop.
4991     // (2) The loop iteration variable is captured in the lexical scope of the function.
4992     //
4993     // These two situations occur sufficiently rarely that it&#39;s okay to use this style of
4994     // &quot;analysis&quot; to make iteration faster. If we didn&#39;t want to do this, we would either have
4995     // to perform some flow-sensitive analysis to see if/when the loop iteration variable was
4996     // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
4997     // reassigned from its original value.
4998 
4999     for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
5000         auto instruction = generator.instructions().at(offset);
5001         OpcodeID opcodeID = instruction-&gt;opcodeID();
5002 
5003         ASSERT(opcodeID != op_enter);
5004         computeDefsForBytecodeOffset(codeBlock, opcodeID, instruction.ptr(), [&amp;] (VirtualRegister operand) {
5005             if (local()-&gt;virtualRegister() == operand)
5006                 invalidate();
5007         });
5008         offset += instruction-&gt;size();
5009     }
5010 }
5011 
5012 void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
5013 {
5014     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5015     if (isValid())
5016         return;
5017 
5018     OpcodeID lastOpcodeID = generator.m_lastOpcodeID;
5019     InstructionStream::MutableRef lastInstruction = generator.m_lastInstruction;
5020     for (const auto&amp; instTuple : m_getInsts) {
5021         unsigned instIndex = std::get&lt;0&gt;(instTuple);
5022         int propertyRegIndex = std::get&lt;1&gt;(instTuple);
5023         auto instruction = generator.m_writer.ref(instIndex);
5024         auto end = instIndex + instruction-&gt;size();
5025         ASSERT(instruction-&gt;isWide32());
5026 
5027         generator.m_writer.seek(instIndex);
5028 
5029         auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
5030 
5031         // disable peephole optimizations
5032         generator.m_lastOpcodeID = op_end;
5033 
5034         // Change the opcode to get_by_val.
5035         // 1. dst stays the same.
5036         // 2. base stays the same.
5037         // 3. property gets switched to the original property.
5038         OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));
5039 
5040         // 4. nop out the remaining bytes
5041         while (generator.m_writer.position() &lt; end)
5042             OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
5043     }
5044     generator.m_writer.seek(generator.m_writer.size());
5045     if (generator.m_lastInstruction.offset() + generator.m_lastInstruction-&gt;size() != generator.m_writer.size()) {
5046         generator.m_lastOpcodeID = lastOpcodeID;
5047         generator.m_lastInstruction = lastInstruction;
5048     }
5049 }
5050 
5051 void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
5052 {
5053     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5054     if (isValid())
5055         return;
5056 
5057     for (const auto&amp; instPair : m_getInsts) {
5058         unsigned instIndex = instPair.first;
5059         int propertyRegIndex = instPair.second;
5060         generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
5061             ASSERT_NOT_REACHED();
5062             return VirtualRegister();
5063         });
5064     }
5065 }
5066 
5067 void StaticPropertyAnalysis::record()
5068 {
5069     auto* instruction = m_instructionRef.ptr();
5070     auto size = m_propertyIndexes.size();
5071     switch (instruction-&gt;opcodeID()) {
5072     case OpNewObject::opcodeID:
5073         instruction-&gt;cast&lt;OpNewObject&gt;()-&gt;setInlineCapacity(size, []() {
5074             return 255;
5075         });
5076         return;
5077     case OpCreateThis::opcodeID:
5078         instruction-&gt;cast&lt;OpCreateThis&gt;()-&gt;setInlineCapacity(size, []() {
5079             return 255;
5080         });
5081         return;
5082     default:
5083         ASSERT_NOT_REACHED();
5084     }
5085 }
5086 
5087 void BytecodeGenerator::emitToThis()
5088 {
5089     OpToThis::emit(this, kill(&amp;m_thisRegister));
5090     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
5091 }
5092 
5093 } // namespace JSC
5094 
5095 namespace WTF {
5096 
5097 void printInternal(PrintStream&amp; out, JSC::Variable::VariableKind kind)
5098 {
5099     switch (kind) {
5100     case JSC::Variable::NormalVariable:
5101         out.print(&quot;Normal&quot;);
5102         return;
5103     case JSC::Variable::SpecialVariable:
5104         out.print(&quot;Special&quot;);
5105         return;
5106     }
5107     RELEASE_ASSERT_NOT_REACHED();
5108 }
5109 
5110 } // namespace WTF
5111 
    </pre>
  </body>
</html>