<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Interpreter.h&quot;
  32 
  33 #include &quot;BatchedTransitionOptimizer.h&quot;
  34 #include &quot;Bytecodes.h&quot;
  35 #include &quot;CallFrameClosure.h&quot;
  36 #include &quot;CatchScope.h&quot;
  37 #include &quot;CodeBlock.h&quot;
  38 #include &quot;CodeCache.h&quot;
  39 #include &quot;DirectArguments.h&quot;
  40 #include &quot;ExecutableBaseInlines.h&quot;
  41 #include &quot;Heap.h&quot;
  42 #include &quot;Debugger.h&quot;
  43 #include &quot;DebuggerCallFrame.h&quot;
  44 #include &quot;DirectEvalCodeCache.h&quot;
  45 #include &quot;ErrorInstance.h&quot;
  46 #include &quot;EvalCodeBlock.h&quot;
  47 #include &quot;Exception.h&quot;
  48 #include &quot;ExceptionHelpers.h&quot;
  49 #include &quot;FrameTracers.h&quot;
  50 #include &quot;FunctionCodeBlock.h&quot;
  51 #include &quot;InterpreterInlines.h&quot;
  52 #include &quot;JITCodeInlines.h&quot;
  53 #include &quot;JSArrayInlines.h&quot;
  54 #include &quot;JSBoundFunction.h&quot;
  55 #include &quot;JSCInlines.h&quot;
  56 #include &quot;JSFixedArray.h&quot;
  57 #include &quot;JSImmutableButterfly.h&quot;
  58 #include &quot;JSLexicalEnvironment.h&quot;
  59 #include &quot;JSModuleEnvironment.h&quot;
  60 #include &quot;JSString.h&quot;
  61 #include &quot;JSWithScope.h&quot;
  62 #include &quot;LLIntCLoop.h&quot;
  63 #include &quot;LLIntThunks.h&quot;
  64 #include &quot;LiteralParser.h&quot;
  65 #include &quot;ModuleProgramCodeBlock.h&quot;
  66 #include &quot;ObjectPrototype.h&quot;
  67 #include &quot;Parser.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
  69 #include &quot;ProtoCallFrame.h&quot;
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;Register.h&quot;
  72 #include &quot;RegisterAtOffsetList.h&quot;
  73 #include &quot;ScopedArguments.h&quot;
  74 #include &quot;StackAlignment.h&quot;
  75 #include &quot;StackFrame.h&quot;
  76 #include &quot;StackVisitor.h&quot;
  77 #include &quot;StrictEvalActivation.h&quot;
  78 #include &quot;StrongInlines.h&quot;
  79 #include &quot;Symbol.h&quot;
  80 #include &quot;VMEntryScope.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;VMInspector.h&quot;
  83 #include &quot;VirtualRegister.h&quot;
<a name="2" id="anc2"></a>
  84 #include &lt;limits.h&gt;
  85 #include &lt;stdio.h&gt;
  86 #include &lt;wtf/NeverDestroyed.h&gt;
  87 #include &lt;wtf/StackStats.h&gt;
  88 #include &lt;wtf/StdLibExtras.h&gt;
  89 #include &lt;wtf/StringPrintStream.h&gt;
  90 #include &lt;wtf/Threading.h&gt;
  91 #include &lt;wtf/text/StringBuilder.h&gt;
  92 
  93 #if ENABLE(JIT)
  94 #include &quot;JIT.h&quot;
  95 #endif
  96 
<a name="3" id="anc3"></a><span class="line-added">  97 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">  98 #include &quot;WasmContextInlines.h&quot;</span>
<span class="line-added">  99 #include &quot;WebAssemblyFunction.h&quot;</span>
<span class="line-added"> 100 #endif</span>
<span class="line-added"> 101 </span>
 102 namespace JSC {
 103 
 104 JSValue eval(CallFrame* callFrame)
 105 {
 106     VM&amp; vm = callFrame-&gt;vm();
 107     auto scope = DECLARE_THROW_SCOPE(vm);
 108 
 109     if (!callFrame-&gt;argumentCount())
 110         return jsUndefined();
 111 
 112     JSValue program = callFrame-&gt;argument(0);
 113     if (!program.isString())
 114         return program;
 115 
 116     TopCallFrameSetter topCallFrame(vm, callFrame);
 117     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject();
 118     if (!globalObject-&gt;evalEnabled()) {
 119         throwException(callFrame, scope, createEvalError(callFrame, globalObject-&gt;evalDisabledErrorMessage()));
 120         return jsUndefined();
 121     }
 122     String programSource = asString(program)-&gt;value(callFrame);
 123     RETURN_IF_EXCEPTION(scope, JSValue());
 124 
 125     CallFrame* callerFrame = callFrame-&gt;callerFrame();
 126     CallSiteIndex callerCallSiteIndex = callerFrame-&gt;callSiteIndex();
 127     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
 128     JSScope* callerScopeChain = callerFrame-&gt;uncheckedR(callerCodeBlock-&gt;scopeRegister().offset()).Register::scope();
 129     UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock-&gt;unlinkedCodeBlock();
 130 
 131     bool isArrowFunctionContext = callerUnlinkedCodeBlock-&gt;isArrowFunction() || callerUnlinkedCodeBlock-&gt;isArrowFunctionContext();
 132 
 133     DerivedContextType derivedContextType = callerUnlinkedCodeBlock-&gt;derivedContextType();
 134     if (!isArrowFunctionContext &amp;&amp; callerUnlinkedCodeBlock-&gt;isClassContext()) {
 135         derivedContextType = callerUnlinkedCodeBlock-&gt;isConstructor()
 136             ? DerivedContextType::DerivedConstructorContext
 137             : DerivedContextType::DerivedMethodContext;
 138     }
 139 
 140     EvalContextType evalContextType;
 141     if (isFunctionParseMode(callerUnlinkedCodeBlock-&gt;parseMode()))
 142         evalContextType = EvalContextType::FunctionEvalContext;
 143     else if (callerUnlinkedCodeBlock-&gt;codeType() == EvalCode)
 144         evalContextType = callerUnlinkedCodeBlock-&gt;evalContextType();
 145     else
 146         evalContextType = EvalContextType::None;
 147 
 148     DirectEvalExecutable* eval = callerCodeBlock-&gt;directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
 149     if (!eval) {
 150         if (!callerCodeBlock-&gt;isStrictMode()) {
 151             if (programSource.is8Bit()) {
 152                 LiteralParser&lt;LChar&gt; preparser(callFrame, programSource.characters8(), programSource.length(), NonStrictJSON);
 153                 if (JSValue parsedObject = preparser.tryLiteralParse())
 154                     RELEASE_AND_RETURN(scope, parsedObject);
 155 
 156             } else {
 157                 LiteralParser&lt;UChar&gt; preparser(callFrame, programSource.characters16(), programSource.length(), NonStrictJSON);
 158                 if (JSValue parsedObject = preparser.tryLiteralParse())
 159                     RELEASE_AND_RETURN(scope, parsedObject);
 160 
 161             }
 162             RETURN_IF_EXCEPTION(scope, JSValue());
 163         }
 164 
 165         VariableEnvironment variablesUnderTDZ;
 166         JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
 167         eval = DirectEvalExecutable::create(callFrame, makeSource(programSource, callerCodeBlock-&gt;source().provider()-&gt;sourceOrigin()), callerCodeBlock-&gt;isStrictMode(), derivedContextType, isArrowFunctionContext, evalContextType, &amp;variablesUnderTDZ);
 168         EXCEPTION_ASSERT(!!scope.exception() == !eval);
 169         if (!eval)
 170             return jsUndefined();
 171 
 172         callerCodeBlock-&gt;directEvalCodeCache().set(callFrame, callerCodeBlock, programSource, callerCallSiteIndex, eval);
 173     }
 174 
 175     JSValue thisValue = callerFrame-&gt;thisValue();
 176     Interpreter* interpreter = vm.interpreter;
 177     RELEASE_AND_RETURN(scope, interpreter-&gt;execute(eval, callFrame, thisValue, callerScopeChain));
 178 }
 179 
 180 unsigned sizeOfVarargs(CallFrame* callFrame, JSValue arguments, uint32_t firstVarArgOffset)
 181 {
 182     VM&amp; vm = callFrame-&gt;vm();
 183     auto scope = DECLARE_THROW_SCOPE(vm);
 184 
 185     if (UNLIKELY(!arguments.isCell())) {
 186         if (arguments.isUndefinedOrNull())
 187             return 0;
 188 
 189         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame, arguments));
 190         return 0;
 191     }
 192 
 193     JSCell* cell = arguments.asCell();
 194     unsigned length;
 195     switch (cell-&gt;type()) {
 196     case DirectArgumentsType:
 197         length = jsCast&lt;DirectArguments*&gt;(cell)-&gt;length(callFrame);
 198         break;
 199     case ScopedArgumentsType:
 200         length = jsCast&lt;ScopedArguments*&gt;(cell)-&gt;length(callFrame);
 201         break;
 202     case JSFixedArrayType:
 203         length = jsCast&lt;JSFixedArray*&gt;(cell)-&gt;size();
 204         break;
 205     case JSImmutableButterflyType:
 206         length = jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;length();
 207         break;
 208     case StringType:
 209     case SymbolType:
 210     case BigIntType:
 211         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame,  arguments));
 212         return 0;
 213 
 214     default:
 215         RELEASE_ASSERT(arguments.isObject());
 216         length = clampToUnsigned(toLength(callFrame, jsCast&lt;JSObject*&gt;(cell)));
 217         break;
 218     }
 219     RETURN_IF_EXCEPTION(scope, 0);
 220 
 221     if (length &gt;= firstVarArgOffset)
 222         length -= firstVarArgOffset;
 223     else
 224         length = 0;
 225 
 226     return length;
 227 }
 228 
 229 unsigned sizeFrameForForwardArguments(CallFrame* callFrame, VM&amp; vm, unsigned numUsedStackSlots)
 230 {
 231     auto scope = DECLARE_THROW_SCOPE(vm);
 232 
 233     unsigned length = callFrame-&gt;argumentCount();
 234     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 235     if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame-&gt;registers())))
 236         throwStackOverflowError(callFrame, scope);
 237 
 238     return length;
 239 }
 240 
 241 unsigned sizeFrameForVarargs(CallFrame* callFrame, VM&amp; vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)
 242 {
 243     auto scope = DECLARE_THROW_SCOPE(vm);
 244 
 245     unsigned length = sizeOfVarargs(callFrame, arguments, firstVarArgOffset);
 246     RETURN_IF_EXCEPTION(scope, 0);
 247 
 248     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 249     if (UNLIKELY(length &gt; maxArguments || !vm.ensureStackCapacityFor(calleeFrame-&gt;registers()))) {
 250         throwStackOverflowError(callFrame, scope);
 251         return 0;
 252     }
 253 
 254     return length;
 255 }
 256 
 257 void loadVarargs(CallFrame* callFrame, VirtualRegister firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)
 258 {
 259     if (UNLIKELY(!arguments.isCell()) || !length)
 260         return;
 261 
 262     VM&amp; vm = callFrame-&gt;vm();
 263     auto scope = DECLARE_THROW_SCOPE(vm);
 264     JSCell* cell = arguments.asCell();
 265 
 266     switch (cell-&gt;type()) {
 267     case DirectArgumentsType:
 268         scope.release();
 269         jsCast&lt;DirectArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 270         return;
 271     case ScopedArgumentsType:
 272         scope.release();
 273         jsCast&lt;ScopedArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 274         return;
 275     case JSFixedArrayType:
 276         scope.release();
 277         jsCast&lt;JSFixedArray*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 278         return;
 279     case JSImmutableButterflyType:
 280         scope.release();
 281         jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 282         return;
 283     default: {
 284         ASSERT(arguments.isObject());
 285         JSObject* object = jsCast&lt;JSObject*&gt;(cell);
 286         if (isJSArray(object)) {
 287             scope.release();
 288             jsCast&lt;JSArray*&gt;(object)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 289             return;
 290         }
 291         unsigned i;
 292         for (i = 0; i &lt; length &amp;&amp; object-&gt;canGetIndexQuickly(i + offset); ++i)
 293             callFrame-&gt;r(firstElementDest + i) = object-&gt;getIndexQuickly(i + offset);
 294         for (; i &lt; length; ++i) {
 295             JSValue value = object-&gt;get(callFrame, i + offset);
 296             RETURN_IF_EXCEPTION(scope, void());
 297             callFrame-&gt;r(firstElementDest + i) = value;
 298         }
 299         return;
 300     } }
 301 }
 302 
 303 void setupVarargsFrame(CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)
 304 {
 305     VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
 306 
 307     loadVarargs(
 308         callFrame,
 309         calleeFrameOffset + CallFrame::argumentOffset(0),
 310         arguments, offset, length);
 311 
 312     newCallFrame-&gt;setArgumentCountIncludingThis(length + 1);
 313 }
 314 
 315 void setupVarargsFrameAndSetThis(CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)
 316 {
 317     setupVarargsFrame(callFrame, newCallFrame, arguments, firstVarArgOffset, length);
 318     newCallFrame-&gt;setThisValue(thisValue);
 319 }
 320 
 321 void setupForwardArgumentsFrame(CallFrame* execCaller, CallFrame* execCallee, uint32_t length)
 322 {
 323     ASSERT(length == execCaller-&gt;argumentCount());
 324     unsigned offset = execCaller-&gt;argumentOffset(0) * sizeof(Register);
 325     memcpy(reinterpret_cast&lt;char*&gt;(execCallee) + offset, reinterpret_cast&lt;char*&gt;(execCaller) + offset, length * sizeof(Register));
 326     execCallee-&gt;setArgumentCountIncludingThis(length + 1);
 327 }
 328 
 329 void setupForwardArgumentsFrameAndSetThis(CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)
 330 {
 331     setupForwardArgumentsFrame(execCaller, execCallee, length);
 332     execCallee-&gt;setThisValue(thisValue);
 333 }
 334 
 335 
 336 
 337 Interpreter::Interpreter(VM&amp; vm)
 338     : m_vm(vm)
 339 #if ENABLE(C_LOOP)
 340     , m_cloopStack(vm)
 341 #endif
 342 {
 343 #if !ASSERT_DISABLED
 344     static std::once_flag assertOnceKey;
 345     std::call_once(assertOnceKey, [] {
 346         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i) {
 347             OpcodeID opcodeID = static_cast&lt;OpcodeID&gt;(i);
 348             RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
 349         }
 350     });
 351 #endif // USE(LLINT_EMBEDDED_OPCODE_ID)
 352 }
 353 
 354 Interpreter::~Interpreter()
 355 {
 356 }
 357 
 358 #if ENABLE(COMPUTED_GOTO_OPCODES)
 359 #if !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED
 360 HashMap&lt;Opcode, OpcodeID&gt;&amp; Interpreter::opcodeIDTable()
 361 {
 362     static NeverDestroyed&lt;HashMap&lt;Opcode, OpcodeID&gt;&gt; opcodeIDTable;
 363 
 364     static std::once_flag initializeKey;
 365     std::call_once(initializeKey, [&amp;] {
 366         const Opcode* opcodeTable = LLInt::opcodeMap();
 367         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i)
 368             opcodeIDTable.get().add(opcodeTable[i], static_cast&lt;OpcodeID&gt;(i));
 369     });
 370 
 371     return opcodeIDTable;
 372 }
 373 #endif // !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED
 374 #endif // ENABLE(COMPUTED_GOTO_OPCODES)
 375 
 376 #if !ASSERT_DISABLED
 377 bool Interpreter::isOpcode(Opcode opcode)
 378 {
 379 #if ENABLE(COMPUTED_GOTO_OPCODES)
 380     return opcode != HashTraits&lt;Opcode&gt;::emptyValue()
 381         &amp;&amp; !HashTraits&lt;Opcode&gt;::isDeletedValue(opcode)
 382         &amp;&amp; opcodeIDTable().contains(opcode);
 383 #else
 384     return opcode &gt;= 0 &amp;&amp; opcode &lt;= op_end;
 385 #endif
 386 }
 387 #endif // !ASSERT_DISABLED
 388 
 389 class GetStackTraceFunctor {
 390 public:
 391     GetStackTraceFunctor(VM&amp; vm, JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t capacity)
 392         : m_vm(vm)
 393         , m_owner(owner)
 394         , m_results(results)
 395         , m_framesToSkip(framesToSkip)
 396         , m_remainingCapacityForFrameCapture(capacity)
 397     {
 398         m_results.reserveInitialCapacity(capacity);
 399     }
 400 
 401     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 402     {
 403         if (m_framesToSkip &gt; 0) {
 404             m_framesToSkip--;
 405             return StackVisitor::Continue;
 406         }
 407 
 408         if (m_remainingCapacityForFrameCapture) {
 409             if (visitor-&gt;isWasmFrame()) {
 410                 m_results.append(StackFrame(visitor-&gt;wasmFunctionIndexOrName()));
 411             } else if (!!visitor-&gt;codeBlock() &amp;&amp; !visitor-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;isBuiltinFunction()) {
 412                 m_results.append(
 413                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell(), visitor-&gt;codeBlock(), visitor-&gt;bytecodeOffset()));
 414             } else {
 415                 m_results.append(
 416                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell()));
 417             }
 418 
 419             m_remainingCapacityForFrameCapture--;
 420             return StackVisitor::Continue;
 421         }
 422         return StackVisitor::Done;
 423     }
 424 
 425 private:
 426     VM&amp; m_vm;
 427     JSCell* m_owner;
 428     Vector&lt;StackFrame&gt;&amp; m_results;
 429     mutable size_t m_framesToSkip;
 430     mutable size_t m_remainingCapacityForFrameCapture;
 431 };
 432 
 433 void Interpreter::getStackTrace(JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t maxStackSize)
 434 {
 435     DisallowGC disallowGC;
 436     VM&amp; vm = m_vm;
 437     CallFrame* callFrame = vm.topCallFrame;
 438     if (!callFrame || !maxStackSize)
 439         return;
 440 
 441     size_t framesCount = 0;
 442     size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
 443     StackVisitor::visit(callFrame, &amp;vm, [&amp;] (StackVisitor&amp;) -&gt; StackVisitor::Status {
 444         if (++framesCount &lt; maxFramesCountNeeded)
 445             return StackVisitor::Continue;
 446         return StackVisitor::Done;
 447     });
 448     if (framesCount &lt;= framesToSkip)
 449         return;
 450 
 451     framesCount -= framesToSkip;
 452     framesCount = std::min(maxStackSize, framesCount);
 453 
 454     GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
 455     StackVisitor::visit(callFrame, &amp;vm, functor);
 456     ASSERT(results.size() == results.capacity());
 457 }
 458 
 459 String Interpreter::stackTraceAsString(VM&amp; vm, const Vector&lt;StackFrame&gt;&amp; stackTrace)
 460 {
 461     // FIXME: JSStringJoiner could be more efficient than StringBuilder here.
 462     StringBuilder builder;
 463     for (unsigned i = 0; i &lt; stackTrace.size(); i++) {
 464         builder.append(String(stackTrace[i].toString(vm)));
 465         if (i != stackTrace.size() - 1)
 466             builder.append(&#39;\n&#39;);
 467     }
 468     return builder.toString();
 469 }
 470 
 471 ALWAYS_INLINE static HandlerInfo* findExceptionHandler(StackVisitor&amp; visitor, CodeBlock* codeBlock, RequiredHandler requiredHandler)
 472 {
 473     ASSERT(codeBlock);
 474 #if ENABLE(DFG_JIT)
 475     ASSERT(!visitor-&gt;isInlinedFrame());
 476 #endif
 477 
 478     CallFrame* callFrame = visitor-&gt;callFrame();
 479     unsigned exceptionHandlerIndex;
 480     if (JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
 481         exceptionHandlerIndex = callFrame-&gt;callSiteIndex().bits();
 482     else
 483         exceptionHandlerIndex = callFrame-&gt;bytecodeOffset();
 484 
 485     return codeBlock-&gt;handlerForIndex(exceptionHandlerIndex, requiredHandler);
 486 }
 487 
 488 class GetCatchHandlerFunctor {
 489 public:
 490     GetCatchHandlerFunctor()
 491         : m_handler(0)
 492     {
 493     }
 494 
 495     HandlerInfo* handler() { return m_handler; }
 496 
 497     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 498     {
 499         visitor.unwindToMachineCodeBlockFrame();
 500 
 501         CodeBlock* codeBlock = visitor-&gt;codeBlock();
 502         if (!codeBlock)
 503             return StackVisitor::Continue;
 504 
 505         m_handler = findExceptionHandler(visitor, codeBlock, RequiredHandler::CatchHandler);
 506         if (m_handler)
 507             return StackVisitor::Done;
 508 
 509         return StackVisitor::Continue;
 510     }
 511 
 512 private:
 513     mutable HandlerInfo* m_handler;
 514 };
 515 
 516 ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM&amp; vm, CallFrame* callFrame)
 517 {
 518     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 519     if (Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger()) {
 520         SuspendExceptionScope scope(&amp;vm);
 521         if (callFrame-&gt;isAnyWasmCallee()
 522             || (callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;inherits&lt;JSFunction&gt;(vm)))
 523             debugger-&gt;unwindEvent(callFrame);
 524         else
 525             debugger-&gt;didExecuteProgram(callFrame);
 526         catchScope.assertNoException();
 527     }
 528 }
 529 
 530 class UnwindFunctor {
 531 public:
 532     UnwindFunctor(VM&amp; vm, CallFrame*&amp; callFrame, bool isTermination, CodeBlock*&amp; codeBlock, HandlerInfo*&amp; handler)
 533         : m_vm(vm)
 534         , m_callFrame(callFrame)
 535         , m_isTermination(isTermination)
 536         , m_codeBlock(codeBlock)
 537         , m_handler(handler)
 538     {
 539     }
 540 
 541     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 542     {
 543         visitor.unwindToMachineCodeBlockFrame();
 544         m_callFrame = visitor-&gt;callFrame();
 545         m_codeBlock = visitor-&gt;codeBlock();
 546 
 547         m_handler = nullptr;
 548         if (!m_isTermination) {
 549             if (m_codeBlock) {
 550                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
 551                 if (m_handler)
 552                     return StackVisitor::Done;
 553             }
 554         }
 555 
<a name="4" id="anc4"></a><span class="line-added"> 556 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 557         if (visitor-&gt;callee().isCell()) {</span>
<span class="line-added"> 558             if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(m_vm, visitor-&gt;callee().asCell()))</span>
<span class="line-added"> 559                 m_vm.wasmContext.store(jsToWasmICCallee-&gt;function()-&gt;previousInstance(m_callFrame), m_vm.softStackLimit());</span>
<span class="line-added"> 560         }</span>
<span class="line-added"> 561 #endif</span>
<span class="line-added"> 562 </span>
 563         notifyDebuggerOfUnwinding(m_vm, m_callFrame);
 564 
 565         copyCalleeSavesToEntryFrameCalleeSavesBuffer(visitor);
 566 
 567         bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
 568         if (shouldStopUnwinding)
 569             return StackVisitor::Done;
 570 
 571         return StackVisitor::Continue;
 572     }
 573 
 574 private:
 575     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
 576     {
<a name="5" id="anc5"></a><span class="line-modified"> 577 #if ENABLE(ASSEMBLER)</span>
<span class="line-modified"> 578         Optional&lt;RegisterAtOffsetList&gt; currentCalleeSaves = visitor-&gt;calleeSaveRegistersForUnwinding();</span>
 579 
 580         if (!currentCalleeSaves)
 581             return;
 582 
 583         RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
 584         RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();
 585         CPURegister* frame = reinterpret_cast&lt;CPURegister*&gt;(m_callFrame-&gt;registers());
 586 
 587         unsigned registerCount = currentCalleeSaves-&gt;size();
 588         VMEntryRecord* record = vmEntryRecord(m_vm.topEntryFrame);
 589         for (unsigned i = 0; i &lt; registerCount; i++) {
 590             RegisterAtOffset currentEntry = currentCalleeSaves-&gt;at(i);
 591             if (dontCopyRegisters.get(currentEntry.reg()))
 592                 continue;
 593             RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
 594 
 595             record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()] = *(frame + currentEntry.offsetAsIndex());
 596         }
 597 #else
 598         UNUSED_PARAM(visitor);
 599 #endif
 600     }
 601 
 602     VM&amp; m_vm;
 603     CallFrame*&amp; m_callFrame;
 604     bool m_isTermination;
 605     CodeBlock*&amp; m_codeBlock;
 606     HandlerInfo*&amp; m_handler;
 607 };
 608 
 609 NEVER_INLINE HandlerInfo* Interpreter::unwind(VM&amp; vm, CallFrame*&amp; callFrame, Exception* exception)
 610 {
 611     auto scope = DECLARE_CATCH_SCOPE(vm);
 612 
 613     ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) != vm.topEntryFrame);
 614     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
 615 
 616     JSValue exceptionValue = exception-&gt;value();
 617     ASSERT(!exceptionValue.isEmpty());
 618     ASSERT(!exceptionValue.isCell() || exceptionValue.asCell());
 619     // This shouldn&#39;t be possible (hence the assertions), but we&#39;re already in the slowest of
 620     // slow cases, so let&#39;s harden against it anyway to be safe.
 621     if (exceptionValue.isEmpty() || (exceptionValue.isCell() &amp;&amp; !exceptionValue.asCell()))
 622         exceptionValue = jsNull();
 623 
 624     EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
 625 
 626     // Calculate an exception handler vPC, unwinding call frames as necessary.
 627     HandlerInfo* handler = nullptr;
 628     UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
 629     StackVisitor::visit&lt;StackVisitor::TerminateIfTopEntryFrameIsEmpty&gt;(callFrame, &amp;vm, functor);
 630     if (!handler)
 631         return nullptr;
 632 
 633     return handler;
 634 }
 635 
 636 void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM&amp; vm, CallFrame* callFrame, Exception* exception)
 637 {
 638     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();
 639     if (debugger &amp;&amp; debugger-&gt;needsExceptionCallbacks() &amp;&amp; !exception-&gt;didNotifyInspectorOfThrow()) {
 640         // This code assumes that if the debugger is enabled then there is no inlining.
 641         // If that assumption turns out to be false then we&#39;ll ignore the inlined call
 642         // frames.
 643         // https://bugs.webkit.org/show_bug.cgi?id=121754
 644 
 645         bool hasCatchHandler;
 646         bool isTermination = isTerminatedExecutionException(vm, exception);
 647         if (isTermination)
 648             hasCatchHandler = false;
 649         else {
 650             GetCatchHandlerFunctor functor;
 651             StackVisitor::visit(callFrame, &amp;vm, functor);
 652             HandlerInfo* handler = functor.handler();
 653             ASSERT(!handler || handler-&gt;isCatchHandler());
 654             hasCatchHandler = !!handler;
 655         }
 656 
 657         debugger-&gt;exception(callFrame, exception-&gt;value(), hasCatchHandler);
 658     }
 659     exception-&gt;setDidNotifyInspectorOfThrow();
 660 }
 661 
 662 JSValue Interpreter::executeProgram(const SourceCode&amp; source, CallFrame* callFrame, JSObject* thisObj)
 663 {
 664     JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
<a name="6" id="anc6"></a><span class="line-modified"> 665     VM&amp; vm = scope-&gt;vm();</span>
 666     auto throwScope = DECLARE_THROW_SCOPE(vm);
 667 
 668     ProgramExecutable* program = ProgramExecutable::create(callFrame, source);
 669     EXCEPTION_ASSERT(throwScope.exception() || program);
 670     RETURN_IF_EXCEPTION(throwScope, { });
 671 
 672     throwScope.assertNoException();
 673     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 674     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
 675     if (vm.isCollectorBusyOnCurrentThread())
 676         return jsNull();
 677 
 678     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 679         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 680 
 681     // First check if the &quot;program&quot; is actually just a JSON object. If so,
 682     // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
 683     // below at failedJSONP.
 684 
 685     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);
 686     Vector&lt;JSONPData&gt; JSONPData;
 687     bool parseResult;
 688     StringView programSource = program-&gt;source().view();
 689     if (programSource.isNull())
 690         return jsUndefined();
 691     if (programSource.is8Bit()) {
 692         LiteralParser&lt;LChar&gt; literalParser(callFrame, programSource.characters8(), programSource.length(), JSONP);
 693         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 694     } else {
 695         LiteralParser&lt;UChar&gt; literalParser(callFrame, programSource.characters16(), programSource.length(), JSONP);
 696         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 697     }
 698 
 699     RETURN_IF_EXCEPTION(throwScope, { });
 700     if (parseResult) {
 701         JSValue result;
 702         for (unsigned entry = 0; entry &lt; JSONPData.size(); entry++) {
 703             Vector&lt;JSONPPathEntry&gt; JSONPPath;
 704             JSONPPath.swap(JSONPData[entry].m_path);
 705             JSValue JSONPValue = JSONPData[entry].m_value.get();
 706             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
 707                 globalObject-&gt;addVar(callFrame, JSONPPath[0].m_pathEntryName);
 708                 RETURN_IF_EXCEPTION(throwScope, { });
 709                 PutPropertySlot slot(globalObject);
 710                 globalObject-&gt;methodTable(vm)-&gt;put(globalObject, callFrame, JSONPPath[0].m_pathEntryName, JSONPValue, slot);
 711                 RETURN_IF_EXCEPTION(throwScope, { });
 712                 result = jsUndefined();
 713                 continue;
 714             }
 715             JSValue baseObject(globalObject);
 716             for (unsigned i = 0; i &lt; JSONPPath.size() - 1; i++) {
 717                 ASSERT(JSONPPath[i].m_type != JSONPPathEntryTypeDeclareVar);
 718                 switch (JSONPPath[i].m_type) {
 719                 case JSONPPathEntryTypeDot: {
 720                     if (i == 0) {
 721                         RELEASE_ASSERT(baseObject == globalObject);
 722 
 723                         auto doGet = [&amp;] (JSSegmentedVariableObject* scope) {
 724                             PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
 725                             if (scope-&gt;getPropertySlot(callFrame, JSONPPath[i].m_pathEntryName, slot))
 726                                 return slot.getValue(callFrame, JSONPPath[i].m_pathEntryName);
 727                             return JSValue();
 728                         };
 729 
 730                         JSValue result = doGet(globalObject-&gt;globalLexicalEnvironment());
 731                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 732                         if (result) {
 733                             baseObject = result;
 734                             continue;
 735                         }
 736 
 737                         result = doGet(globalObject);
 738                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 739                         if (result) {
 740                             baseObject = result;
 741                             continue;
 742                         }
 743 
 744                         if (entry)
 745                             return throwException(callFrame, throwScope, createUndefinedVariableError(callFrame, JSONPPath[i].m_pathEntryName));
 746                         goto failedJSONP;
 747                     }
 748 
 749                     baseObject = baseObject.get(callFrame, JSONPPath[i].m_pathEntryName);
 750                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 751                     continue;
 752                 }
 753                 case JSONPPathEntryTypeLookup: {
 754                     baseObject = baseObject.get(callFrame, static_cast&lt;unsigned&gt;(JSONPPath[i].m_pathIndex));
 755                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 756                     continue;
 757                 }
 758                 default:
 759                     RELEASE_ASSERT_NOT_REACHED();
 760                     return jsUndefined();
 761                 }
 762             }
 763 
 764             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
 765                 RELEASE_ASSERT(baseObject == globalObject);
 766                 JSGlobalLexicalEnvironment* scope = globalObject-&gt;globalLexicalEnvironment();
 767                 if (scope-&gt;hasProperty(callFrame, JSONPPath.last().m_pathEntryName))
 768                     baseObject = scope;
 769                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 770             }
 771 
 772             PutPropertySlot slot(baseObject);
 773             switch (JSONPPath.last().m_type) {
 774             case JSONPPathEntryTypeCall: {
 775                 JSValue function = baseObject.get(callFrame, JSONPPath.last().m_pathEntryName);
 776                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 777                 CallData callData;
 778                 CallType callType = getCallData(vm, function, callData);
 779                 if (callType == CallType::None)
 780                     return throwException(callFrame, throwScope, createNotAFunctionError(callFrame, function));
 781                 MarkedArgumentBuffer jsonArg;
 782                 jsonArg.append(JSONPValue);
 783                 ASSERT(!jsonArg.hasOverflowed());
 784                 JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
 785                 JSONPValue = JSC::call(callFrame, function, callType, callData, thisValue, jsonArg);
 786                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 787                 break;
 788             }
 789             case JSONPPathEntryTypeDot: {
 790                 baseObject.put(callFrame, JSONPPath.last().m_pathEntryName, JSONPValue, slot);
 791                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 792                 break;
 793             }
 794             case JSONPPathEntryTypeLookup: {
 795                 baseObject.putByIndex(callFrame, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());
 796                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 797                 break;
 798             }
 799             default:
 800                 RELEASE_ASSERT_NOT_REACHED();
 801                 return jsUndefined();
 802             }
 803             result = JSONPValue;
 804         }
 805         return result;
 806     }
 807 failedJSONP:
 808     // If we get here, then we have already proven that the script is not a JSON
 809     // object.
 810 
 811     VMEntryScope entryScope(vm, globalObject);
 812 
 813     // Compile source to bytecode if necessary:
 814     JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope);
 815     EXCEPTION_ASSERT(!throwScope.exception() || !error);
 816     if (UNLIKELY(error))
 817         return checkedReturn(throwException(callFrame, throwScope, error));
 818 
 819     ProgramCodeBlock* codeBlock;
 820     {
 821         CodeBlock* tempCodeBlock;
<a name="7" id="anc7"></a><span class="line-modified"> 822         Exception* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified"> 823         EXCEPTION_ASSERT(throwScope.exception() == error);</span>
 824         if (UNLIKELY(error))
 825             return checkedReturn(error);
 826         codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
 827     }
 828 
 829     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 830     if (UNLIKELY(vm.needTrapHandling(mask))) {
 831         vm.handleTraps(callFrame, mask);
 832         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 833     }
 834 
 835     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
 836         scope-&gt;flattenDictionaryObject(vm);
 837 
 838     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
 839 
 840     ProtoCallFrame protoCallFrame;
 841     protoCallFrame.init(codeBlock, JSCallee::create(vm, globalObject, scope), thisObj, 1);
 842 
 843     // Execute the code:
 844     throwScope.release();
 845     JSValue result = program-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 846     return checkedReturn(result);
 847 }
 848 
 849 JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData&amp; callData, JSValue thisValue, const ArgList&amp; args)
 850 {
 851     VM&amp; vm = callFrame-&gt;vm();
 852     auto throwScope = DECLARE_THROW_SCOPE(vm);
 853 
 854     throwScope.assertNoException();
 855     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 856     if (vm.isCollectorBusyOnCurrentThread())
 857         return jsNull();
 858 
 859     bool isJSCall = (callType == CallType::JS);
 860     JSScope* scope = nullptr;
 861     CodeBlock* newCodeBlock;
 862     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 863 
 864     JSGlobalObject* globalObject;
 865 
 866     if (isJSCall) {
 867         scope = callData.js.scope;
 868         globalObject = scope-&gt;globalObject(vm);
 869     } else {
 870         ASSERT(callType == CallType::Host);
 871         globalObject = function-&gt;globalObject(vm);
 872     }
 873 
 874     VMEntryScope entryScope(vm, globalObject);
 875     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 876         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 877 
 878     if (isJSCall) {
 879         // Compile the callee:
<a name="8" id="anc8"></a><span class="line-modified"> 880         Exception* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);</span>
<span class="line-modified"> 881         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
 882         if (UNLIKELY(!!compileError))
 883             return checkedReturn(compileError);
 884 
 885         ASSERT(!!newCodeBlock);
 886         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 887     } else
 888         newCodeBlock = 0;
 889 
 890     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 891     if (UNLIKELY(vm.needTrapHandling(mask))) {
 892         vm.handleTraps(callFrame, mask);
 893         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 894     }
 895 
 896     ProtoCallFrame protoCallFrame;
 897     protoCallFrame.init(newCodeBlock, function, thisValue, argsCount, args.data());
 898 
 899     JSValue result;
 900     {
 901         // Execute the code:
 902         if (isJSCall) {
 903             throwScope.release();
 904             result = callData.js.functionExecutable-&gt;generatedJITCodeForCall()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 905         } else {
 906             result = JSValue::decode(vmEntryToNative(callData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 907             RETURN_IF_EXCEPTION(throwScope, JSValue());
 908         }
 909     }
 910 
 911     return checkedReturn(result);
 912 }
 913 
 914 JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)
 915 {
 916     VM&amp; vm = callFrame-&gt;vm();
 917     auto throwScope = DECLARE_THROW_SCOPE(vm);
 918 
 919     throwScope.assertNoException();
 920     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 921     // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
 922     // already in an invalid state.
<a name="9" id="anc9"></a><span class="line-modified"> 923     if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {</span>
<span class="line-modified"> 924         throwStackOverflowError(callFrame, throwScope);</span>
<span class="line-added"> 925         return nullptr;</span>
<span class="line-added"> 926     }</span>
 927 
 928     bool isJSConstruct = (constructType == ConstructType::JS);
 929     JSScope* scope = nullptr;
 930     CodeBlock* newCodeBlock;
 931     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 932 
 933     JSGlobalObject* globalObject;
 934 
 935     if (isJSConstruct) {
 936         scope = constructData.js.scope;
 937         globalObject = scope-&gt;globalObject(vm);
 938     } else {
 939         ASSERT(constructType == ConstructType::Host);
 940         globalObject = constructor-&gt;globalObject(vm);
 941     }
 942 
 943     VMEntryScope entryScope(vm, globalObject);
<a name="10" id="anc10"></a><span class="line-modified"> 944     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {</span>
<span class="line-modified"> 945         throwStackOverflowError(callFrame, throwScope);</span>
<span class="line-added"> 946         return nullptr;</span>
<span class="line-added"> 947     }</span>
 948 
 949     if (isJSConstruct) {
 950         // Compile the callee:
<a name="11" id="anc11"></a><span class="line-modified"> 951         Exception* compileError = constructData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(constructor), scope, CodeForConstruct, newCodeBlock);</span>
<span class="line-modified"> 952         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
 953         if (UNLIKELY(!!compileError))
<a name="12" id="anc12"></a><span class="line-modified"> 954             return nullptr;</span>
 955 
 956         ASSERT(!!newCodeBlock);
 957         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 958     } else
 959         newCodeBlock = 0;
 960 
 961     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 962     if (UNLIKELY(vm.needTrapHandling(mask))) {
 963         vm.handleTraps(callFrame, mask);
<a name="13" id="anc13"></a><span class="line-modified"> 964         RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
 965     }
 966 
 967     ProtoCallFrame protoCallFrame;
 968     protoCallFrame.init(newCodeBlock, constructor, newTarget, argsCount, args.data());
 969 
 970     JSValue result;
 971     {
 972         // Execute the code.
 973         if (isJSConstruct)
 974             result = constructData.js.functionExecutable-&gt;generatedJITCodeForConstruct()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 975         else {
 976             result = JSValue::decode(vmEntryToNative(constructData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 977 
 978             if (LIKELY(!throwScope.exception()))
 979                 RELEASE_ASSERT(result.isObject());
 980         }
 981     }
 982 
 983     RETURN_IF_EXCEPTION(throwScope, 0);
 984     ASSERT(result.isObject());
 985     return checkedReturn(asObject(result));
 986 }
 987 
 988 CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* functionExecutable, CallFrame* callFrame, ProtoCallFrame* protoCallFrame, JSFunction* function, int argumentCountIncludingThis, JSScope* scope, const ArgList&amp; args)
 989 {
<a name="14" id="anc14"></a><span class="line-modified"> 990     VM&amp; vm = scope-&gt;vm();</span>
 991     auto throwScope = DECLARE_THROW_SCOPE(vm);
 992     throwScope.assertNoException();
 993 
 994     if (vm.isCollectorBusyOnCurrentThread())
 995         return CallFrameClosure();
 996 
 997     // Compile the callee:
 998     CodeBlock* newCodeBlock;
<a name="15" id="anc15"></a><span class="line-modified"> 999     Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, CodeForCall, newCodeBlock);</span>
<span class="line-modified">1000     EXCEPTION_ASSERT(throwScope.exception() == error);</span>
1001     if (UNLIKELY(error))
1002         return CallFrameClosure();
1003     newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
1004 
1005     size_t argsCount = argumentCountIncludingThis;
1006 
1007     protoCallFrame-&gt;init(newCodeBlock, function, jsUndefined(), argsCount, args.data());
1008     // Return the successful closure:
1009     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
1010     return result;
1011 }
1012 
1013 JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, JSScope* scope)
1014 {
<a name="16" id="anc16"></a><span class="line-modified">1015     VM&amp; vm = scope-&gt;vm();</span>
1016     auto throwScope = DECLARE_THROW_SCOPE(vm);
1017 
1018     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1019     throwScope.assertNoException();
1020     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1021     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1022     if (vm.isCollectorBusyOnCurrentThread())
1023         return jsNull();
1024 
1025     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1026     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1027         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1028 
1029     unsigned numVariables = eval-&gt;numVariables();
1030     unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
1031     unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
1032 
1033     JSScope* variableObject;
1034     if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<a name="17" id="anc17"></a><span class="line-modified">1035         scope = StrictEvalActivation::create(vm, callFrame-&gt;lexicalGlobalObject()-&gt;strictEvalActivationStructure(), scope);</span>
1036         variableObject = scope;
1037     } else {
1038         for (JSScope* node = scope; ; node = node-&gt;next()) {
1039             RELEASE_ASSERT(node);
1040             if (node-&gt;isGlobalObject()) {
1041                 variableObject = node;
1042                 break;
1043             }
1044             if (node-&gt;isJSLexicalEnvironment()) {
1045                 JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(node);
1046                 if (lexicalEnvironment-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope) {
1047                     variableObject = node;
1048                     break;
1049                 }
1050             }
1051         }
1052     }
1053 
1054     EvalCodeBlock* codeBlock;
1055     {
1056         CodeBlock* tempCodeBlock;
<a name="18" id="anc18"></a><span class="line-modified">1057         Exception* compileError = eval-&gt;prepareForExecution&lt;EvalExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified">1058         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
1059         if (UNLIKELY(!!compileError))
1060             return checkedReturn(compileError);
1061         codeBlock = jsCast&lt;EvalCodeBlock*&gt;(tempCodeBlock);
1062     }
1063     UnlinkedEvalCodeBlock* unlinkedCodeBlock = codeBlock-&gt;unlinkedEvalCodeBlock();
1064 
1065     // We can&#39;t declare a &quot;var&quot;/&quot;function&quot; that overwrites a global &quot;let&quot;/&quot;const&quot;/&quot;class&quot; in a sloppy-mode eval.
1066     if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
1067         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
1068         for (unsigned i = 0; i &lt; numVariables; ++i) {
1069             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1070             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
1071             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, ident, slot)) {
1072                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));
1073             }
1074         }
1075 
1076         for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1077             FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1078             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
1079             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, function-&gt;name(), slot)) {
1080                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));
1081             }
1082         }
1083     }
1084 
1085     if (variableObject-&gt;structure(vm)-&gt;isUncacheableDictionary())
1086         variableObject-&gt;flattenDictionaryObject(vm);
1087 
1088     if (numVariables || numTopLevelFunctionDecls || numFunctionHoistingCandidates) {
1089         BatchedTransitionOptimizer optimizer(vm, variableObject);
1090         if (variableObject-&gt;next() &amp;&amp; !eval-&gt;isStrictMode())
1091             variableObject-&gt;globalObject(vm)-&gt;varInjectionWatchpoint()-&gt;fireAll(vm, &quot;Executed eval, fired VarInjection watchpoint&quot;);
1092 
1093         for (unsigned i = 0; i &lt; numVariables; ++i) {
1094             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1095             bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);
1096             RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1097             if (!hasProperty) {
1098                 PutPropertySlot slot(variableObject);
1099                 if (!variableObject-&gt;isExtensible(callFrame))
1100                     return checkedReturn(throwTypeError(callFrame, throwScope, NonExtensibleObjectPropertyDefineError));
1101                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);
1102                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1103             }
1104         }
1105 
1106         if (eval-&gt;isStrictMode()) {
1107             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1108                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1109                 PutPropertySlot slot(variableObject);
1110                 // We need create this variables because it will be used to emits code by bytecode generator
1111                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);
1112                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1113             }
1114         } else {
1115             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1116                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1117                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, function-&gt;name());
1118                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1119                 if (resolvedScope.isUndefined())
1120                     return checkedReturn(throwSyntaxError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));
1121                 PutPropertySlot slot(variableObject);
1122                 // We need create this variables because it will be used to emits code by bytecode generator
1123                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);
1124                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1125             }
1126 
1127             for (unsigned i = 0; i &lt; numFunctionHoistingCandidates; ++i) {
1128                 const Identifier&amp; ident = unlinkedCodeBlock-&gt;functionHoistingCandidate(i);
1129                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, ident);
1130                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1131                 if (!resolvedScope.isUndefined()) {
1132                     bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);
1133                     RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1134                     if (!hasProperty) {
1135                         PutPropertySlot slot(variableObject);
1136                         variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);
1137                         RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1138                     }
1139                 }
1140             }
1141         }
1142     }
1143 
1144     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1145     if (UNLIKELY(vm.needTrapHandling(mask))) {
1146         vm.handleTraps(callFrame, mask);
1147         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1148     }
1149 
1150     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1151 
1152     ProtoCallFrame protoCallFrame;
1153     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), thisValue, 1);
1154 
1155     // Execute the code:
1156     throwScope.release();
1157     JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1158 
1159     return checkedReturn(result);
1160 }
1161 
1162 JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, CallFrame* callFrame, JSModuleEnvironment* scope)
1163 {
<a name="19" id="anc19"></a><span class="line-modified">1164     VM&amp; vm = scope-&gt;vm();</span>
1165     auto throwScope = DECLARE_THROW_SCOPE(vm);
1166 
1167     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1168     throwScope.assertNoException();
1169     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1170     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1171     if (vm.isCollectorBusyOnCurrentThread())
1172         return jsNull();
1173 
1174     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1175     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1176         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1177 
1178     ModuleProgramCodeBlock* codeBlock;
1179     {
1180         CodeBlock* tempCodeBlock;
<a name="20" id="anc20"></a><span class="line-modified">1181         Exception* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified">1182         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
1183         if (UNLIKELY(!!compileError))
1184             return checkedReturn(compileError);
1185         codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
1186     }
1187 
1188     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1189     if (UNLIKELY(vm.needTrapHandling(mask))) {
1190         vm.handleTraps(callFrame, mask);
1191         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1192     }
1193 
1194     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
1195         scope-&gt;flattenDictionaryObject(vm);
1196 
1197     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1198 
1199     // The |this| of the module is always `undefined`.
1200     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
1201     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
1202     ProtoCallFrame protoCallFrame;
1203     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), jsUndefined(), 1);
1204 
1205     // Execute the code:
1206     throwScope.release();
1207     JSValue result = executable-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1208 
1209     return checkedReturn(result);
1210 }
1211 
1212 NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
1213 {
1214     VM&amp; vm = callFrame-&gt;vm();
1215     auto scope = DECLARE_CATCH_SCOPE(vm);
1216     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();
1217     if (!debugger)
1218         return;
1219 
1220     ASSERT(callFrame-&gt;codeBlock()-&gt;hasDebuggerRequests());
1221     scope.assertNoException();
1222 
1223     switch (debugHookType) {
1224         case DidEnterCallFrame:
1225             debugger-&gt;callEvent(callFrame);
1226             break;
1227         case WillLeaveCallFrame:
1228             debugger-&gt;returnEvent(callFrame);
1229             break;
1230         case WillExecuteStatement:
1231             debugger-&gt;atStatement(callFrame);
1232             break;
1233         case WillExecuteExpression:
1234             debugger-&gt;atExpression(callFrame);
1235             break;
1236         case WillExecuteProgram:
1237             debugger-&gt;willExecuteProgram(callFrame);
1238             break;
1239         case DidExecuteProgram:
1240             debugger-&gt;didExecuteProgram(callFrame);
1241             break;
1242         case DidReachBreakpoint:
1243             debugger-&gt;didReachBreakpoint(callFrame);
1244             break;
1245     }
1246     scope.assertNoException();
1247 }
1248 
1249 } // namespace JSC
1250 
1251 namespace WTF {
1252 
1253 void printInternal(PrintStream&amp; out, JSC::DebugHookType type)
1254 {
1255     switch (type) {
1256     case JSC::WillExecuteProgram:
1257         out.print(&quot;WillExecuteProgram&quot;);
1258         return;
1259     case JSC::DidExecuteProgram:
1260         out.print(&quot;DidExecuteProgram&quot;);
1261         return;
1262     case JSC::DidEnterCallFrame:
1263         out.print(&quot;DidEnterCallFrame&quot;);
1264         return;
1265     case JSC::DidReachBreakpoint:
1266         out.print(&quot;DidReachBreakpoint&quot;);
1267         return;
1268     case JSC::WillLeaveCallFrame:
1269         out.print(&quot;WillLeaveCallFrame&quot;);
1270         return;
1271     case JSC::WillExecuteStatement:
1272         out.print(&quot;WillExecuteStatement&quot;);
1273         return;
1274     case JSC::WillExecuteExpression:
1275         out.print(&quot;WillExecuteExpression&quot;);
1276         return;
1277     }
1278 }
1279 
1280 } // namespace WTF
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>