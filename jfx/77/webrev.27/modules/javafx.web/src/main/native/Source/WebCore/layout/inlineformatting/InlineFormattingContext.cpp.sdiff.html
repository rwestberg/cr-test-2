<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../floats/FloatingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;InlineFormattingState.h&quot;
 32 #include &quot;InlineLineBreaker.h&quot;
<span class="line-modified"> 33 #include &quot;InlineRunProvider.h&quot;</span>
 34 #include &quot;LayoutBox.h&quot;
 35 #include &quot;LayoutContainer.h&quot;
<span class="line-removed"> 36 #include &quot;LayoutInlineBox.h&quot;</span>
<span class="line-removed"> 37 #include &quot;LayoutInlineContainer.h&quot;</span>
 38 #include &quot;LayoutState.h&quot;
 39 #include &quot;Logging.h&quot;
 40 #include &quot;Textutil.h&quot;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 #include &lt;wtf/text/TextStream.h&gt;
 43 
 44 namespace WebCore {
 45 namespace Layout {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
 48 
 49 InlineFormattingContext::InlineFormattingContext(const Box&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)
 50     : FormattingContext(formattingContextRoot, formattingState)
 51 {
 52 }
 53 
<span class="line-modified"> 54 static inline const Box* nextInPreOrder(const Box&amp; layoutBox, const Container&amp; root)</span>
 55 {
 56     const Box* nextInPreOrder = nullptr;
 57     if (!layoutBox.establishesFormattingContext() &amp;&amp; is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
 58         return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();
 59 
<span class="line-modified"> 60     for (nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;root; nextInPreOrder = nextInPreOrder-&gt;parent()) {</span>
 61         if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
 62             return nextSibling;
 63     }
 64     return nullptr;
 65 }
 66 
 67 void InlineFormattingContext::layout() const
 68 {
 69     if (!is&lt;Container&gt;(root()))
 70         return;
 71 
<span class="line-removed"> 72     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);</span>
 73     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());
<span class="line-modified"> 74     auto usedValues = UsedHorizontalValues { layoutState().displayBoxForLayoutBox(root).contentBoxWidth() };</span>





 75     auto* layoutBox = root.firstInFlowOrFloatingChild();
 76     // Compute width/height for non-text content and margin/border/padding for inline containers.
 77     while (layoutBox) {
 78         if (layoutBox-&gt;establishesFormattingContext())
 79             layoutFormattingContextRoot(*layoutBox, usedValues);
<span class="line-modified"> 80         else if (is&lt;Container&gt;(*layoutBox)) {</span>
<span class="line-modified"> 81             auto&amp; inlineContainer = downcast&lt;InlineContainer&gt;(*layoutBox);</span>
<span class="line-modified"> 82             computeMargin(inlineContainer, usedValues);</span>
<span class="line-removed"> 83             computeBorderAndPadding(inlineContainer, usedValues);</span>
<span class="line-removed"> 84         } else if (layoutBox-&gt;isReplaced())</span>
 85             computeWidthAndHeightForReplacedInlineBox(*layoutBox, usedValues);




 86         layoutBox = nextInPreOrder(*layoutBox, root);
 87     }
 88 
<span class="line-modified"> 89     InlineRunProvider inlineRunProvider;</span>
<span class="line-modified"> 90     collectInlineContent(inlineRunProvider);</span>
<span class="line-modified"> 91     LineLayout(*this).layout(inlineRunProvider);</span>



 92     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);
 93 }
 94 
<span class="line-modified"> 95 void InlineFormattingContext::computeIntrinsicWidthConstraints() const</span>
 96 {
<span class="line-removed"> 97     ASSERT(is&lt;Container&gt;(root()));</span>
<span class="line-removed"> 98 </span>
 99     auto&amp; layoutState = this-&gt;layoutState();
<span class="line-modified">100     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
<span class="line-modified">101     ASSERT(!layoutState.formattingStateForBox(root).intrinsicWidthConstraints(root));</span>





102 

103     Vector&lt;const Box*&gt; formattingContextRootList;
104     auto usedValues = UsedHorizontalValues { };
105     auto* layoutBox = root.firstInFlowOrFloatingChild();
106     while (layoutBox) {
107         if (layoutBox-&gt;establishesFormattingContext()) {
108             formattingContextRootList.append(layoutBox);
<span class="line-modified">109             if (layoutBox-&gt;isFloatingPositioned())</span>
<span class="line-removed">110                 computeIntrinsicWidthForFloatBox(*layoutBox);</span>
<span class="line-removed">111             else if (layoutBox-&gt;isInlineBlockBox())</span>
<span class="line-removed">112                 computeIntrinsicWidthForInlineBlock(*layoutBox);</span>
<span class="line-removed">113             else</span>
<span class="line-removed">114                 ASSERT_NOT_REACHED();</span>
115         } else if (layoutBox-&gt;isReplaced() || is&lt;Container&gt;(*layoutBox)) {
116             computeBorderAndPadding(*layoutBox, usedValues);
117             // inline-block and replaced.
<span class="line-modified">118             auto needsWidthComputation = layoutBox-&gt;isReplaced() || layoutBox-&gt;establishesFormattingContext();</span>
119             if (needsWidthComputation)
120                 computeWidthAndMargin(*layoutBox, usedValues);
121             else {
122                 // Simple inline container with no intrinsic width &lt;span&gt;.
<span class="line-modified">123                 computeMargin(*layoutBox, usedValues);</span>
124             }
125         }
126         layoutBox = nextInPreOrder(*layoutBox, root);
127     }
128 
<span class="line-modified">129     InlineRunProvider inlineRunProvider;</span>
<span class="line-removed">130     collectInlineContent(inlineRunProvider);</span>
131 
132     auto maximumLineWidth = [&amp;](auto availableWidth) {
<span class="line-removed">133         LayoutUnit maxContentLogicalRight;</span>
<span class="line-removed">134         auto lineBreaker = InlineLineBreaker { layoutState, formattingState().inlineContent(), inlineRunProvider.runs() };</span>
<span class="line-removed">135         LayoutUnit lineLogicalRight;</span>
<span class="line-removed">136 </span>
137         // Switch to the min/max formatting root width values before formatting the lines.
138         for (auto* formattingRoot : formattingContextRootList) {
<span class="line-modified">139             auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraints(*formattingRoot);</span>
<span class="line-modified">140             layoutState.displayBoxForLayoutBox(*formattingRoot).setContentBoxWidth(availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum);</span>
<span class="line-modified">141         }</span>
<span class="line-modified">142 </span>
<span class="line-removed">143         while (auto run = lineBreaker.nextRun(lineLogicalRight, availableWidth, !lineLogicalRight)) {</span>
<span class="line-removed">144             if (run-&gt;position == InlineLineBreaker::Run::Position::LineBegin)</span>
<span class="line-removed">145                 lineLogicalRight = 0;</span>
<span class="line-removed">146             lineLogicalRight += run-&gt;width;</span>
<span class="line-removed">147 </span>
<span class="line-removed">148             maxContentLogicalRight = std::max(maxContentLogicalRight, lineLogicalRight);</span>
149         }
<span class="line-modified">150         return maxContentLogicalRight;</span>
151     };
152 
<span class="line-modified">153     auto intrinsicWidthConstraints = Geometry::constrainByMinMaxWidth(root, { maximumLineWidth(0), maximumLineWidth(LayoutUnit::max()) });</span>
<span class="line-modified">154     layoutState.formattingStateForBox(root).setIntrinsicWidthConstraints(root, intrinsicWidthConstraints);</span>

155 }
156 
<span class="line-modified">157 void InlineFormattingContext::computeIntrinsicWidthForFloatBox(const Box&amp; layoutBox) const</span>
158 {
<span class="line-modified">159     ASSERT(layoutBox.isFloatingPositioned());</span>
<span class="line-modified">160     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">161 </span>
<span class="line-removed">162     auto usedHorizontalValues = UsedHorizontalValues { };</span>
<span class="line-removed">163     computeBorderAndPadding(layoutBox, usedHorizontalValues);</span>
<span class="line-removed">164     computeMargin(layoutBox, usedHorizontalValues);</span>
<span class="line-removed">165     layoutState.createFormattingContext(layoutBox)-&gt;computeIntrinsicWidthConstraints();</span>
166 
<span class="line-modified">167     auto usedVerticalValues = UsedVerticalValues { };</span>
<span class="line-modified">168     auto heightAndMargin = Geometry::floatingHeightAndMargin(layoutState, layoutBox, usedVerticalValues, usedHorizontalValues);</span>



169 
<span class="line-modified">170     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">171     displayBox.setContentBoxHeight(heightAndMargin.height);</span>
<span class="line-modified">172     displayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });</span>



173 }
174 
<span class="line-modified">175 void InlineFormattingContext::computeIntrinsicWidthForInlineBlock(const Box&amp; layoutBox) const</span>
176 {
<span class="line-modified">177     ASSERT(layoutBox.isInlineBlockBox());</span>

178 
179     auto usedValues = UsedHorizontalValues { };
<span class="line-modified">180     computeBorderAndPadding(layoutBox, usedValues);</span>
<span class="line-modified">181     computeMargin(layoutBox, usedValues);</span>
<span class="line-modified">182     layoutState().createFormattingContext(layoutBox)-&gt;computeIntrinsicWidthConstraints();</span>








183 }
184 
<span class="line-modified">185 void InlineFormattingContext::computeMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
186 {
187     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
188     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);
189     displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
190     displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
191 }
192 
193 void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const
194 {
195     auto&amp; layoutState = this-&gt;layoutState();
196     WidthAndMargin widthAndMargin;
197     if (layoutBox.isFloatingPositioned())
198         widthAndMargin = Geometry::floatingWidthAndMargin(layoutState, layoutBox, usedValues);
199     else if (layoutBox.isInlineBlockBox())
200         widthAndMargin = Geometry::inlineBlockWidthAndMargin(layoutState, layoutBox, usedValues);
201     else if (layoutBox.replaced())
202         widthAndMargin = Geometry::inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues);
203     else
204         ASSERT_NOT_REACHED();
205 
</pre>
<hr />
<pre>
218         heightAndMargin = Geometry::floatingHeightAndMargin(layoutState, layoutBox, { }, UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() });
219     else if (layoutBox.isInlineBlockBox())
220         heightAndMargin = Geometry::inlineBlockHeightAndMargin(layoutState, layoutBox);
221     else if (layoutBox.replaced())
222         heightAndMargin = Geometry::inlineReplacedHeightAndMargin(layoutState, layoutBox, { });
223     else
224         ASSERT_NOT_REACHED();
225 
226     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
227     displayBox.setContentBoxHeight(heightAndMargin.height);
228     displayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });
229 }
230 
231 void InlineFormattingContext::layoutFormattingContextRoot(const Box&amp; root, UsedHorizontalValues usedValues) const
232 {
233     ASSERT(root.isFloatingPositioned() || root.isInlineBlockBox());
234     ASSERT(usedValues.containingBlockWidth);
235 
236     computeBorderAndPadding(root, usedValues);
237     computeWidthAndMargin(root, usedValues);


238     // Swich over to the new formatting context (the one that the root creates).
239     auto formattingContext = layoutState().createFormattingContext(root);
240     formattingContext-&gt;layout();
241     // Come back and finalize the root&#39;s height and margin.
242     computeHeightAndMargin(root);
<span class="line-modified">243     // Now that we computed the root&#39;s height, we can go back and layout the out-of-flow descedants (if any).</span>
<span class="line-modified">244     formattingContext-&gt;layoutOutOfFlowDescendants(root);</span>
245 }
246 
247 void InlineFormattingContext::computeWidthAndHeightForReplacedInlineBox(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const
248 {
249     ASSERT(!layoutBox.isContainer());
250     ASSERT(!layoutBox.establishesFormattingContext());
251     ASSERT(layoutBox.replaced());
252     ASSERT(usedValues.containingBlockWidth);
253 
254     computeBorderAndPadding(layoutBox, usedValues);
255     computeWidthAndMargin(layoutBox, usedValues);
256     computeHeightAndMargin(layoutBox);
257 }
258 
<span class="line-modified">259 static void addDetachingRules(InlineItem&amp; inlineItem, Optional&lt;LayoutUnit&gt; nonBreakableStartWidth, Optional&lt;LayoutUnit&gt; nonBreakableEndWidth)</span>
<span class="line-removed">260 {</span>
<span class="line-removed">261     OptionSet&lt;InlineItem::DetachingRule&gt; detachingRules;</span>
<span class="line-removed">262     if (nonBreakableStartWidth) {</span>
<span class="line-removed">263         detachingRules.add(InlineItem::DetachingRule::BreakAtStart);</span>
<span class="line-removed">264         inlineItem.addNonBreakableStart(*nonBreakableStartWidth);</span>
<span class="line-removed">265     }</span>
<span class="line-removed">266     if (nonBreakableEndWidth) {</span>
<span class="line-removed">267         detachingRules.add(InlineItem::DetachingRule::BreakAtEnd);</span>
<span class="line-removed">268         inlineItem.addNonBreakableEnd(*nonBreakableEndWidth);</span>
<span class="line-removed">269     }</span>
<span class="line-removed">270     inlineItem.addDetachingRule(detachingRules);</span>
<span class="line-removed">271 }</span>
<span class="line-removed">272 </span>
<span class="line-removed">273 static InlineItem&amp; createAndAppendInlineItem(InlineRunProvider&amp; inlineRunProvider, InlineContent&amp; inlineContent, const Box&amp; layoutBox)</span>
<span class="line-removed">274 {</span>
<span class="line-removed">275     ASSERT(layoutBox.isInlineLevelBox() || layoutBox.isFloatingPositioned());</span>
<span class="line-removed">276     auto inlineItem = std::make_unique&lt;InlineItem&gt;(layoutBox);</span>
<span class="line-removed">277     auto* inlineItemPtr = inlineItem.get();</span>
<span class="line-removed">278     inlineContent.add(WTFMove(inlineItem));</span>
<span class="line-removed">279     inlineRunProvider.append(*inlineItemPtr);</span>
<span class="line-removed">280     return *inlineItemPtr;</span>
<span class="line-removed">281 }</span>
<span class="line-removed">282 </span>
<span class="line-removed">283 void InlineFormattingContext::collectInlineContent(InlineRunProvider&amp; inlineRunProvider) const</span>
284 {
<span class="line-removed">285     if (!is&lt;Container&gt;(root()))</span>
<span class="line-removed">286         return;</span>
287     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());
<span class="line-modified">288     if (!root.hasInFlowOrFloatingChild())</span>
<span class="line-modified">289         return;</span>
<span class="line-modified">290     // The logic here is very similar to BFC layout.</span>
<span class="line-removed">291     // 1. Travers down the layout tree and collect &quot;start&quot; unbreakable widths (margin-left, border-left, padding-left)</span>
<span class="line-removed">292     // 2. Create InlineItem per leaf inline box (text nodes, inline-blocks, floats) and set &quot;start&quot; unbreakable width on them.</span>
<span class="line-removed">293     // 3. Climb back and collect &quot;end&quot; unbreakable width and set it on the last InlineItem.</span>
<span class="line-removed">294     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">295     auto&amp; inlineContent = formattingState().inlineContent();</span>
<span class="line-removed">296 </span>
<span class="line-removed">297     enum class NonBreakableWidthType { Start, End };</span>
<span class="line-removed">298     auto nonBreakableWidth = [&amp;](auto&amp; container, auto type) {</span>
<span class="line-removed">299         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(container);</span>
<span class="line-removed">300         if (type == NonBreakableWidthType::Start)</span>
<span class="line-removed">301             return displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0);</span>
<span class="line-removed">302         return displayBox.marginEnd() + displayBox.borderRight() + displayBox.paddingRight().valueOr(0);</span>
<span class="line-removed">303     };</span>
<span class="line-removed">304 </span>
305     LayoutQueue layoutQueue;
306     layoutQueue.append(root.firstInFlowOrFloatingChild());
<span class="line-removed">307 </span>
<span class="line-removed">308     Optional&lt;LayoutUnit&gt; nonBreakableStartWidth;</span>
<span class="line-removed">309     Optional&lt;LayoutUnit&gt; nonBreakableEndWidth;</span>
<span class="line-removed">310     InlineItem* lastInlineItem = nullptr;</span>
311     while (!layoutQueue.isEmpty()) {



312         while (true) {
313             auto&amp; layoutBox = *layoutQueue.last();
<span class="line-modified">314             if (!is&lt;Container&gt;(layoutBox))</span>
315                 break;


316             auto&amp; container = downcast&lt;Container&gt;(layoutBox);
<span class="line-removed">317 </span>
<span class="line-removed">318             if (container.establishesFormattingContext()) {</span>
<span class="line-removed">319                 // Formatting contexts are treated as leaf nodes.</span>
<span class="line-removed">320                 auto&amp; inlineItem = createAndAppendInlineItem(inlineRunProvider, inlineContent, container);</span>
<span class="line-removed">321                 auto&amp; displayBox = layoutState.displayBoxForLayoutBox(container);</span>
<span class="line-removed">322                 auto currentNonBreakableStartWidth = nonBreakableStartWidth.valueOr(0) + displayBox.marginStart() + nonBreakableEndWidth.valueOr(0);</span>
<span class="line-removed">323                 addDetachingRules(inlineItem, currentNonBreakableStartWidth, displayBox.marginEnd());</span>
<span class="line-removed">324                 nonBreakableStartWidth = { };</span>
<span class="line-removed">325                 nonBreakableEndWidth = { };</span>
<span class="line-removed">326 </span>
<span class="line-removed">327                 // Formatting context roots take care of their subtrees. Continue with next sibling if exists.</span>
<span class="line-removed">328                 layoutQueue.removeLast();</span>
<span class="line-removed">329                 if (!container.nextInFlowOrFloatingSibling())</span>
<span class="line-removed">330                     break;</span>
<span class="line-removed">331                 layoutQueue.append(container.nextInFlowOrFloatingSibling());</span>
<span class="line-removed">332                 continue;</span>
<span class="line-removed">333             }</span>
<span class="line-removed">334 </span>
<span class="line-removed">335             // Check if this non-formatting context container has any non-breakable start properties (margin-left, border-left, padding-left)</span>
<span class="line-removed">336             // &lt;span style=&quot;padding-left: 5px&quot;&gt;&lt;span style=&quot;padding-left: 5px&quot;&gt;foobar&lt;/span&gt;&lt;/span&gt; -&gt; 5px + 5px</span>
<span class="line-removed">337             auto currentNonBreakableStartWidth = nonBreakableWidth(layoutBox, NonBreakableWidthType::Start);</span>
<span class="line-removed">338             if (currentNonBreakableStartWidth || layoutBox.isPositioned())</span>
<span class="line-removed">339                 nonBreakableStartWidth = nonBreakableStartWidth.valueOr(0) + currentNonBreakableStartWidth;</span>
<span class="line-removed">340 </span>
341             if (!container.hasInFlowOrFloatingChild())
342                 break;
343             layoutQueue.append(container.firstInFlowOrFloatingChild());
344         }
345 
346         while (!layoutQueue.isEmpty()) {
347             auto&amp; layoutBox = *layoutQueue.takeLast();
<span class="line-modified">348             if (is&lt;Container&gt;(layoutBox)) {</span>
<span class="line-modified">349                 // This is the end of an inline container. Compute the non-breakable end width and add it to the last inline box.</span>
<span class="line-modified">350                 // &lt;span style=&quot;padding-right: 5px&quot;&gt;foobar&lt;/span&gt; -&gt; 5px; last inline item -&gt; &quot;foobar&quot;</span>
<span class="line-modified">351                 auto currentNonBreakableEndWidth = nonBreakableWidth(layoutBox, NonBreakableWidthType::End);</span>
<span class="line-modified">352                 if (currentNonBreakableEndWidth || layoutBox.isPositioned())</span>
<span class="line-modified">353                     nonBreakableEndWidth = nonBreakableEndWidth.valueOr(0) + currentNonBreakableEndWidth;</span>
<span class="line-modified">354                 // Add it to the last inline box</span>
<span class="line-modified">355                 if (lastInlineItem) {</span>
<span class="line-modified">356                     addDetachingRules(*lastInlineItem, { }, nonBreakableEndWidth);</span>
<span class="line-modified">357                     nonBreakableEndWidth = { };</span>
<span class="line-modified">358                 }</span>
<span class="line-modified">359             } else {</span>
<span class="line-modified">360                 // Leaf inline box</span>
<span class="line-removed">361                 auto&amp; inlineItem = createAndAppendInlineItem(inlineRunProvider, inlineContent, layoutBox);</span>
<span class="line-removed">362                 // Add start and the (through empty containers) accumulated end width.</span>
<span class="line-removed">363                 // &lt;span style=&quot;padding-left: 1px&quot;&gt;foobar&lt;/span&gt; -&gt; nonBreakableStartWidth: 1px;</span>
<span class="line-removed">364                 // &lt;span style=&quot;padding: 5px&quot;&gt;&lt;/span&gt;foobar -&gt; nonBreakableStartWidth: 5px; nonBreakableEndWidth: 5px</span>
<span class="line-removed">365                 if (nonBreakableStartWidth || nonBreakableEndWidth) {</span>
<span class="line-removed">366                     addDetachingRules(inlineItem, nonBreakableStartWidth.valueOr(0) + nonBreakableEndWidth.valueOr(0), { });</span>
<span class="line-removed">367                     nonBreakableStartWidth = { };</span>
<span class="line-removed">368                     nonBreakableEndWidth = { };</span>
<span class="line-removed">369                 }</span>
<span class="line-removed">370                 lastInlineItem = &amp;inlineItem;</span>
371             }
372 
373             if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
374                 layoutQueue.append(nextSibling);
375                 break;
376             }
377         }
378     }
379 }
380 
381 }
382 }
383 
384 #endif
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;InlineFormattingState.h&quot;
 32 #include &quot;InlineLineBreaker.h&quot;
<span class="line-modified"> 33 #include &quot;InlineTextItem.h&quot;</span>
 34 #include &quot;LayoutBox.h&quot;
 35 #include &quot;LayoutContainer.h&quot;


 36 #include &quot;LayoutState.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Textutil.h&quot;
 39 #include &lt;wtf/IsoMallocInlines.h&gt;
 40 #include &lt;wtf/text/TextStream.h&gt;
 41 
 42 namespace WebCore {
 43 namespace Layout {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
 46 
 47 InlineFormattingContext::InlineFormattingContext(const Box&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)
 48     : FormattingContext(formattingContextRoot, formattingState)
 49 {
 50 }
 51 
<span class="line-modified"> 52 static inline const Box* nextInPreOrder(const Box&amp; layoutBox, const Container&amp; stayWithin)</span>
 53 {
 54     const Box* nextInPreOrder = nullptr;
 55     if (!layoutBox.establishesFormattingContext() &amp;&amp; is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
 56         return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();
 57 
<span class="line-modified"> 58     for (nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;stayWithin; nextInPreOrder = nextInPreOrder-&gt;parent()) {</span>
 59         if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
 60             return nextSibling;
 61     }
 62     return nullptr;
 63 }
 64 
 65 void InlineFormattingContext::layout() const
 66 {
 67     if (!is&lt;Container&gt;(root()))
 68         return;
 69 

 70     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());
<span class="line-modified"> 71     if (!root.hasInFlowOrFloatingChild())</span>
<span class="line-added"> 72         return;</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);</span>
<span class="line-added"> 75     auto availableWidth = layoutState().displayBoxForLayoutBox(root).contentBoxWidth();</span>
<span class="line-added"> 76     auto usedValues = UsedHorizontalValues { availableWidth };</span>
 77     auto* layoutBox = root.firstInFlowOrFloatingChild();
 78     // Compute width/height for non-text content and margin/border/padding for inline containers.
 79     while (layoutBox) {
 80         if (layoutBox-&gt;establishesFormattingContext())
 81             layoutFormattingContextRoot(*layoutBox, usedValues);
<span class="line-modified"> 82         else if (is&lt;Container&gt;(*layoutBox))</span>
<span class="line-modified"> 83             computeMarginBorderAndPaddingForInlineContainer(downcast&lt;Container&gt;(*layoutBox), usedValues);</span>
<span class="line-modified"> 84         else if (layoutBox-&gt;isReplaced())</span>


 85             computeWidthAndHeightForReplacedInlineBox(*layoutBox, usedValues);
<span class="line-added"> 86         else {</span>
<span class="line-added"> 87             ASSERT(layoutBox-&gt;isInlineLevelBox());</span>
<span class="line-added"> 88             initializeMarginBorderAndPaddingForGenericInlineBox(*layoutBox);</span>
<span class="line-added"> 89         }</span>
 90         layoutBox = nextInPreOrder(*layoutBox, root);
 91     }
 92 
<span class="line-modified"> 93     // FIXME: This is such a waste when intrinsic width computation already collected the inline items.</span>
<span class="line-modified"> 94     formattingState().inlineItems().clear();</span>
<span class="line-modified"> 95     formattingState().inlineRuns().clear();</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     collectInlineContent();</span>
<span class="line-added"> 98     InlineLayout(*this).layout(formattingState().inlineItems(), availableWidth);</span>
 99     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);
100 }
101 
<span class="line-modified">102 FormattingContext::IntrinsicWidthConstraints InlineFormattingContext::computedIntrinsicWidthConstraints() const</span>
103 {


104     auto&amp; layoutState = this-&gt;layoutState();
<span class="line-modified">105     ASSERT(!formattingState().intrinsicWidthConstraints());</span>
<span class="line-modified">106 </span>
<span class="line-added">107     if (!is&lt;Container&gt;(root()) || !downcast&lt;Container&gt;(root()).hasInFlowOrFloatingChild()) {</span>
<span class="line-added">108         auto constraints = Geometry::constrainByMinMaxWidth(root(), { });</span>
<span class="line-added">109         formattingState().setIntrinsicWidthConstraints(constraints);</span>
<span class="line-added">110         return constraints;</span>
<span class="line-added">111     }</span>
112 
<span class="line-added">113     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
114     Vector&lt;const Box*&gt; formattingContextRootList;
115     auto usedValues = UsedHorizontalValues { };
116     auto* layoutBox = root.firstInFlowOrFloatingChild();
117     while (layoutBox) {
118         if (layoutBox-&gt;establishesFormattingContext()) {
119             formattingContextRootList.append(layoutBox);
<span class="line-modified">120             computeIntrinsicWidthForFormattingRoot(*layoutBox);</span>





121         } else if (layoutBox-&gt;isReplaced() || is&lt;Container&gt;(*layoutBox)) {
122             computeBorderAndPadding(*layoutBox, usedValues);
123             // inline-block and replaced.
<span class="line-modified">124             auto needsWidthComputation = layoutBox-&gt;isReplaced();</span>
125             if (needsWidthComputation)
126                 computeWidthAndMargin(*layoutBox, usedValues);
127             else {
128                 // Simple inline container with no intrinsic width &lt;span&gt;.
<span class="line-modified">129                 computeHorizontalMargin(*layoutBox, usedValues);</span>
130             }
131         }
132         layoutBox = nextInPreOrder(*layoutBox, root);
133     }
134 
<span class="line-modified">135     collectInlineContent();</span>

136 
137     auto maximumLineWidth = [&amp;](auto availableWidth) {




138         // Switch to the min/max formatting root width values before formatting the lines.
139         for (auto* formattingRoot : formattingContextRootList) {
<span class="line-modified">140             auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraintsForBox(*formattingRoot);</span>
<span class="line-modified">141             auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*formattingRoot);</span>
<span class="line-modified">142             auto contentWidth = (availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum) - displayBox.horizontalMarginBorderAndPadding();</span>
<span class="line-modified">143             displayBox.setContentBoxWidth(contentWidth);</span>






144         }
<span class="line-modified">145         return InlineLayout(*this).computedIntrinsicWidth(formattingState().inlineItems(), availableWidth);</span>
146     };
147 
<span class="line-modified">148     auto constraints = Geometry::constrainByMinMaxWidth(root, { maximumLineWidth(0), maximumLineWidth(LayoutUnit::max()) });</span>
<span class="line-modified">149     formattingState().setIntrinsicWidthConstraints(constraints);</span>
<span class="line-added">150     return constraints;</span>
151 }
152 
<span class="line-modified">153 void InlineFormattingContext::initializeMarginBorderAndPaddingForGenericInlineBox(const Box&amp; layoutBox) const</span>
154 {
<span class="line-modified">155     ASSERT(layoutBox.isAnonymous() || layoutBox.isLineBreakBox());</span>
<span class="line-modified">156     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>





157 
<span class="line-modified">158     displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-modified">159     displayBox.setHorizontalMargin({ });</span>
<span class="line-added">160     displayBox.setBorder({ { }, { } });</span>
<span class="line-added">161     displayBox.setPadding({ });</span>
<span class="line-added">162 }</span>
163 
<span class="line-modified">164 void InlineFormattingContext::computeMarginBorderAndPaddingForInlineContainer(const Container&amp; container, UsedHorizontalValues usedValues) const</span>
<span class="line-modified">165 {</span>
<span class="line-modified">166     computeHorizontalMargin(container, usedValues);</span>
<span class="line-added">167     computeBorderAndPadding(container, usedValues);</span>
<span class="line-added">168     // Inline containers (&lt;span&gt;) have 0 vertical margins.</span>
<span class="line-added">169     layoutState().displayBoxForLayoutBox(container).setVerticalMargin({ { }, { } });</span>
170 }
171 
<span class="line-modified">172 void InlineFormattingContext::computeIntrinsicWidthForFormattingRoot(const Box&amp; formattingRoot) const</span>
173 {
<span class="line-modified">174     ASSERT(formattingRoot.establishesFormattingContext());</span>
<span class="line-added">175     auto&amp; layoutState = this-&gt;layoutState();</span>
176 
177     auto usedValues = UsedHorizontalValues { };
<span class="line-modified">178     computeBorderAndPadding(formattingRoot, usedValues);</span>
<span class="line-modified">179     computeHorizontalMargin(formattingRoot, usedValues);</span>
<span class="line-modified">180 </span>
<span class="line-added">181     IntrinsicWidthConstraints constraints;</span>
<span class="line-added">182     if (auto fixedWidth = Geometry::fixedValue(formattingRoot.style().logicalWidth()))</span>
<span class="line-added">183         constraints = { *fixedWidth, *fixedWidth };</span>
<span class="line-added">184     else</span>
<span class="line-added">185         constraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added">186     constraints = Geometry::constrainByMinMaxWidth(formattingRoot, constraints);</span>
<span class="line-added">187     constraints.expand(layoutState.displayBoxForLayoutBox(formattingRoot).horizontalMarginBorderAndPadding());</span>
<span class="line-added">188     formattingState().setIntrinsicWidthConstraintsForBox(formattingRoot, constraints);</span>
189 }
190 
<span class="line-modified">191 void InlineFormattingContext::computeHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
192 {
193     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
194     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);
195     displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
196     displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
197 }
198 
199 void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const
200 {
201     auto&amp; layoutState = this-&gt;layoutState();
202     WidthAndMargin widthAndMargin;
203     if (layoutBox.isFloatingPositioned())
204         widthAndMargin = Geometry::floatingWidthAndMargin(layoutState, layoutBox, usedValues);
205     else if (layoutBox.isInlineBlockBox())
206         widthAndMargin = Geometry::inlineBlockWidthAndMargin(layoutState, layoutBox, usedValues);
207     else if (layoutBox.replaced())
208         widthAndMargin = Geometry::inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues);
209     else
210         ASSERT_NOT_REACHED();
211 
</pre>
<hr />
<pre>
224         heightAndMargin = Geometry::floatingHeightAndMargin(layoutState, layoutBox, { }, UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() });
225     else if (layoutBox.isInlineBlockBox())
226         heightAndMargin = Geometry::inlineBlockHeightAndMargin(layoutState, layoutBox);
227     else if (layoutBox.replaced())
228         heightAndMargin = Geometry::inlineReplacedHeightAndMargin(layoutState, layoutBox, { });
229     else
230         ASSERT_NOT_REACHED();
231 
232     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
233     displayBox.setContentBoxHeight(heightAndMargin.height);
234     displayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });
235 }
236 
237 void InlineFormattingContext::layoutFormattingContextRoot(const Box&amp; root, UsedHorizontalValues usedValues) const
238 {
239     ASSERT(root.isFloatingPositioned() || root.isInlineBlockBox());
240     ASSERT(usedValues.containingBlockWidth);
241 
242     computeBorderAndPadding(root, usedValues);
243     computeWidthAndMargin(root, usedValues);
<span class="line-added">244     // This is similar to static positioning in block formatting context. We just need to initialize the top left position.</span>
<span class="line-added">245     layoutState().displayBoxForLayoutBox(root).setTopLeft({ 0, 0 });</span>
246     // Swich over to the new formatting context (the one that the root creates).
247     auto formattingContext = layoutState().createFormattingContext(root);
248     formattingContext-&gt;layout();
249     // Come back and finalize the root&#39;s height and margin.
250     computeHeightAndMargin(root);
<span class="line-modified">251     // Now that we computed the root&#39;s height, we can go back and layout the out-of-flow content.</span>
<span class="line-modified">252     formattingContext-&gt;layoutOutOfFlowContent();</span>
253 }
254 
255 void InlineFormattingContext::computeWidthAndHeightForReplacedInlineBox(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const
256 {
257     ASSERT(!layoutBox.isContainer());
258     ASSERT(!layoutBox.establishesFormattingContext());
259     ASSERT(layoutBox.replaced());
260     ASSERT(usedValues.containingBlockWidth);
261 
262     computeBorderAndPadding(layoutBox, usedValues);
263     computeWidthAndMargin(layoutBox, usedValues);
264     computeHeightAndMargin(layoutBox);
265 }
266 
<span class="line-modified">267 void InlineFormattingContext::collectInlineContent() const</span>
























268 {


269     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());
<span class="line-modified">270     // Traverse the tree and create inline items out of containers and leaf nodes. This essentially turns the tree inline structure into a flat one.</span>
<span class="line-modified">271     // &lt;span&gt;text&lt;span&gt;&lt;/span&gt;&lt;img&gt;&lt;/span&gt; -&gt; [ContainerStart][InlineBox][ContainerStart][ContainerEnd][InlineBox][ContainerEnd]</span>
<span class="line-modified">272     auto&amp; formattingState = this-&gt;formattingState();</span>














273     LayoutQueue layoutQueue;
274     layoutQueue.append(root.firstInFlowOrFloatingChild());




275     while (!layoutQueue.isEmpty()) {
<span class="line-added">276         auto treatAsInlineContainer = [](auto&amp; layoutBox) {</span>
<span class="line-added">277             return is&lt;Container&gt;(layoutBox) &amp;&amp; !layoutBox.establishesFormattingContext();</span>
<span class="line-added">278         };</span>
279         while (true) {
280             auto&amp; layoutBox = *layoutQueue.last();
<span class="line-modified">281             if (!treatAsInlineContainer(layoutBox))</span>
282                 break;
<span class="line-added">283             // This is the start of an inline container (e.g. &lt;span&gt;).</span>
<span class="line-added">284             formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerStart));</span>
285             auto&amp; container = downcast&lt;Container&gt;(layoutBox);
























286             if (!container.hasInFlowOrFloatingChild())
287                 break;
288             layoutQueue.append(container.firstInFlowOrFloatingChild());
289         }
290 
291         while (!layoutQueue.isEmpty()) {
292             auto&amp; layoutBox = *layoutQueue.takeLast();
<span class="line-modified">293             // This is the end of an inline container (e.g. &lt;/span&gt;).</span>
<span class="line-modified">294             if (treatAsInlineContainer(layoutBox))</span>
<span class="line-modified">295                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerEnd));</span>
<span class="line-modified">296             else if (layoutBox.isLineBreakBox())</span>
<span class="line-modified">297                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::HardLineBreak));</span>
<span class="line-modified">298             else if (layoutBox.isFloatingPositioned())</span>
<span class="line-modified">299                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Float));</span>
<span class="line-modified">300             else {</span>
<span class="line-modified">301                 ASSERT(layoutBox.isInlineLevelBox());</span>
<span class="line-modified">302                 if (layoutBox.hasTextContent())</span>
<span class="line-modified">303                     InlineTextItem::createAndAppendTextItems(formattingState.inlineItems(), layoutBox);</span>
<span class="line-modified">304                 else</span>
<span class="line-modified">305                     formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Box));</span>










306             }
307 
308             if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
309                 layoutQueue.append(nextSibling);
310                 break;
311             }
312         }
313     }
314 }
315 
316 }
317 }
318 
319 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../floats/FloatingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>