<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2012-2018 Apple Inc. All rights reserved.
   2 #
   3 # Redistribution and use in source and binary forms, with or without
   4 # modification, are permitted provided that the following conditions
   5 # are met:
   6 # 1. Redistributions of source code must retain the above copyright
   7 #    notice, this list of conditions and the following disclaimer.
   8 # 2. Redistributions in binary form must reproduce the above copyright
   9 #    notice, this list of conditions and the following disclaimer in the
  10 #    documentation and/or other materials provided with the distribution.
  11 #
  12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  22 # THE POSSIBILITY OF SUCH DAMAGE.
  23 
  24 require &quot;config&quot;
  25 require &quot;ast&quot;
  26 require &quot;opt&quot;
  27 
  28 # The CLoop llint backend is initially based on the ARMv7 backend, and
  29 # then further enhanced with a few instructions from the x86 backend to
  30 # support building for X64 targets.  Hence, the shape of the generated
  31 # code and the usage convention of registers will look a lot like the
  32 # ARMv7 backend&#39;s.
  33 
  34 def cloopMapType(type)
  35     case type
  36     when :int;            &quot;.i()&quot;
  37     when :uint;           &quot;.u()&quot;
  38     when :int32;          &quot;.i32()&quot;
  39     when :uint32;         &quot;.u32()&quot;
  40     when :int64;          &quot;.i64()&quot;
  41     when :uint64;         &quot;.u64()&quot;
  42     when :int8;           &quot;.i8()&quot;
  43     when :uint8;          &quot;.u8()&quot;
  44     when :int8Ptr;        &quot;.i8p()&quot;
  45     when :voidPtr;        &quot;.vp()&quot;
  46     when :nativeFunc;     &quot;.nativeFunc()&quot;
  47     when :double;         &quot;.d()&quot;
  48     when :bitsAsDouble;   &quot;.bitsAsDouble()&quot;
  49     when :bitsAsInt64;    &quot;.bitsAsInt64()&quot;
  50     when :opcode;         &quot;.opcode()&quot;
  51     else;
  52         raise &quot;Unsupported type&quot;
  53     end
  54 end
  55 
  56 
  57 class SpecialRegister &lt; NoChildren
  58     def clLValue(type=:int)
  59         clDump
  60     end
  61     def clDump
  62         @name
  63     end
  64     def clValue(type=:int)
  65         @name + cloopMapType(type)
  66     end
  67 end
  68 
  69 C_LOOP_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
  70 
  71 class RegisterID
  72     def clDump
  73         case name
  74         # The cloop is modelled on the ARM implementation. Hence, the a0-a3
  75         # registers are aliases for r0-r3 i.e. t0-t3 in our case.
  76         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
  77             &quot;t0&quot;
  78         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
  79             &quot;t1&quot;
  80         when &quot;t2&quot;, &quot;a2&quot;
  81             &quot;t2&quot;
  82         when &quot;t3&quot;, &quot;a3&quot;
  83             &quot;t3&quot;
  84         when &quot;t4&quot;
  85             &quot;pc&quot;
  86         when &quot;t5&quot;
  87             &quot;t5&quot;
  88         when &quot;csr0&quot;
  89             &quot;pcBase&quot;
  90         when &quot;csr1&quot;
  91             &quot;tagTypeNumber&quot;
  92         when &quot;csr2&quot;
  93             &quot;tagMask&quot;
  94         when &quot;csr3&quot;
  95             &quot;metadataTable&quot;
  96         when &quot;cfr&quot;
  97             &quot;cfr&quot;
  98         when &quot;lr&quot;
  99             &quot;lr&quot;
 100         when &quot;sp&quot;
 101             &quot;sp&quot;
 102         else
 103             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 104         end
 105     end
 106     def clLValue(type=:int)
 107         clDump
 108     end
 109     def clValue(type=:int)
 110         clDump + cloopMapType(type)
 111     end
 112 end
 113 
 114 class FPRegisterID
 115     def clDump
 116         case name
 117         when &quot;ft0&quot;, &quot;fr&quot;
 118             &quot;d0&quot;
 119         when &quot;ft1&quot;
 120             &quot;d1&quot;
 121         when &quot;ft2&quot;
 122             &quot;d2&quot;
 123         when &quot;ft3&quot;
 124             &quot;d3&quot;
 125         when &quot;ft4&quot;
 126             &quot;d4&quot;
 127         when &quot;ft5&quot;
 128             &quot;d5&quot;
 129         else
 130             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 131         end
 132     end
 133     def clLValue(type=:int)
 134         clDump
 135     end
 136     def clValue(type=:int)
 137         clDump + cloopMapType(type)
 138     end
 139 end
 140 
 141 class Immediate
 142     def clDump
 143         &quot;#{value}&quot;
 144     end
 145     def clLValue(type=:int)
 146         raise &quot;Immediate cannot be used as an LValue&quot;
 147     end
 148     def clValue(type=:int)
 149         # There is a case of a very large unsigned number (0x8000000000000000)
 150         # which we wish to encode.  Unfortunately, the C/C++ compiler
 151         # complains if we express that number as a positive decimal integer.
 152         # Hence, for positive values, we just convert the number into hex form
 153         # to keep the compiler happy.
 154         #
 155         # However, for negative values, the to_s(16) hex conversion method does
 156         # not strip the &quot;-&quot; sign resulting in a meaningless &quot;0x-...&quot; valueStr.
 157         # To workaround this, we simply don&#39;t encode negative numbers as hex.
 158 
 159         valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
 160 
 161         case type
 162         when :int8;    &quot;int8_t(#{valueStr})&quot;
 163         when :int32;   &quot;int32_t(#{valueStr})&quot;
 164         when :int64;   &quot;int64_t(#{valueStr})&quot;
 165         when :int;     &quot;intptr_t(#{valueStr})&quot;
 166         when :uint8;   &quot;uint8_t(#{valueStr})&quot;
 167         when :uint32;  &quot;uint32_t(#{valueStr})&quot;
 168         when :uint64;  &quot;uint64_t(#{valueStr})&quot;
 169         when :uint;    &quot;uintptr_t(#{valueStr})&quot;
 170         else
 171             raise &quot;Not implemented immediate of type: #{type}&quot; 
 172         end
 173     end
 174 end
 175 
 176 class Address
 177     def clDump
 178         &quot;[#{base.clDump}, #{offset.value}]&quot;
 179     end
 180     def clLValue(type=:int)
 181         clValue(type)
 182     end
 183     def clValue(type=:int)
 184         case type
 185         when :int8;         int8MemRef
 186         when :int32;        int32MemRef
 187         when :int64;        int64MemRef
 188         when :int;          intMemRef
 189         when :uint8;        uint8MemRef
 190         when :uint32;       uint32MemRef
 191         when :uint64;       uint64MemRef
 192         when :uint;         uintMemRef
 193         when :opcode;       opcodeMemRef
 194         when :nativeFunc;   nativeFuncMemRef
 195         else
 196             raise &quot;Unexpected Address type: #{type}&quot;
 197         end
 198     end
 199     def pointerExpr
 200         if  offset.value == 0
 201             &quot;#{base.clValue(:int8Ptr)}&quot;
 202         elsif offset.value &gt; 0
 203             &quot;#{base.clValue(:int8Ptr)} + #{offset.value}&quot;
 204         else
 205             &quot;#{base.clValue(:int8Ptr)} - #{-offset.value}&quot;
 206         end
 207     end
 208     def int8MemRef
 209         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 210     end
 211     def int16MemRef
 212         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 213     end
 214     def int32MemRef
 215         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 216     end
 217     def int64MemRef
 218         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 219     end
 220     def intMemRef
 221         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 222     end
 223     def uint8MemRef
 224         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 225     end
 226     def uint16MemRef
 227         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 228     end
 229     def uint32MemRef
 230         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 231     end
 232     def uint64MemRef
 233         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 234     end
 235     def uintMemRef
 236         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 237     end
 238     def nativeFuncMemRef
 239         &quot;*CAST&lt;NativeFunction*&gt;(#{pointerExpr})&quot;
 240     end
 241     def opcodeMemRef
 242         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 243     end
 244     def dblMemRef
 245         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 246     end
 247 end
 248 
 249 class BaseIndex
 250     def clDump
 251         &quot;[#{base.clDump}, #{offset.clDump}, #{index.clDump} &lt;&lt; #{scaleShift}]&quot;
 252     end
 253     def clLValue(type=:int)
 254         clValue(type)
 255     end
 256     def clValue(type=:int)
 257         case type
 258         when :int8;       int8MemRef
 259         when :int32;      int32MemRef
 260         when :int64;      int64MemRef
 261         when :int;        intMemRef
 262         when :uint8;      uint8MemRef
 263         when :uint32;     uint32MemRef
 264         when :uint64;     uint64MemRef
 265         when :uint;       uintMemRef
 266         when :opcode;     opcodeMemRef
 267         else
 268             raise &quot;Unexpected BaseIndex type: #{type}&quot;
 269         end
 270     end
 271     def pointerExpr
 272         if offset.value == 0
 273             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift})&quot;
 274         else
 275             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift}) + #{offset.clValue}&quot;
 276         end
 277     end
 278     def int8MemRef
 279         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 280     end
 281     def int16MemRef
 282         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 283     end
 284     def int32MemRef
 285         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 286     end
 287     def int64MemRef
 288         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 289     end
 290     def intMemRef
 291         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 292     end
 293     def uint8MemRef
 294         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 295     end
 296     def uint16MemRef
 297         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 298     end
 299     def uint32MemRef
 300         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 301     end
 302     def uint64MemRef
 303         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 304     end
 305     def uintMemRef
 306         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 307     end
 308     def opcodeMemRef
 309         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 310     end
 311     def dblMemRef
 312         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 313     end
 314 end
 315 
 316 class AbsoluteAddress
 317     def clDump
 318         &quot;#{codeOriginString}&quot;
 319     end
 320     def clLValue(type=:int)
 321         clValue(type)
 322     end
 323     def clValue
 324         clDump
 325     end
 326 end
 327 
 328 class LabelReference
 329     def intMemRef
 330         &quot;*CAST&lt;intptr_t*&gt;(&amp;#{cLabel})&quot;
 331     end
 332     def cloopEmitLea(destination, type)
 333         $asm.putc &quot;#{destination.clLValue(:voidPtr)} = CAST&lt;void*&gt;(&amp;#{cLabel});&quot;
 334     end
 335 end
 336 
 337 
 338 #
 339 # Lea support.
 340 #
 341 
 342 class Address
 343     def cloopEmitLea(destination, type)
 344         if destination == base
 345             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} += #{offset.clValue(type)};&quot;
 346         else
 347             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + #{offset.clValue(type)};&quot;
 348         end
 349     end
 350 end
 351 
 352 class BaseIndex
 353     def cloopEmitLea(destination, type)
 354         raise &quot;Malformed BaseIndex, offset should be zero at #{codeOriginString}&quot; unless offset.value == 0
 355         $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift});&quot;
 356     end
 357 end
 358 
 359 #
 360 # Actual lowering code follows.
 361 #
 362 
 363 class Sequence
 364     def getModifiedListC_LOOP
 365         myList = @list
 366         
 367         # Verify that we will only see instructions and labels.
 368         myList.each {
 369             | node |
 370             unless node.is_a? Instruction or
 371                     node.is_a? Label or
 372                     node.is_a? LocalLabel or
 373                     node.is_a? Skip
 374                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 375             end
 376         }
 377         
 378         return myList
 379     end
 380 end
 381 
 382 def clOperands(operands)
 383     operands.map{|v| v.clDump}.join(&quot;, &quot;)
 384 end
 385 
 386 
 387 def cloopEmitOperation(operands, type, operator)
 388     raise unless type == :int || type == :uint || type == :int32 || type == :uint32 || \
 389         type == :int64 || type == :uint64 || type == :double
 390     if operands.size == 3
 391         op1 = operands[0]
 392         op2 = operands[1]
 393         dst = operands[2]
 394     else
 395         raise unless operands.size == 2
 396         op1 = operands[1]
 397         op2 = operands[0]
 398         dst = operands[1]
 399     end
 400     raise unless not dst.is_a? Immediate
 401     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 402         truncationHeader = &quot;(uint32_t)(&quot;
 403         truncationFooter = &quot;)&quot;
 404     else
 405         truncationHeader = &quot;&quot;
 406         truncationFooter = &quot;&quot;
 407     end
 408     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
 409 end
 410 
 411 def cloopEmitShiftOperation(operands, type, operator)
 412     raise unless type == :int || type == :uint || type == :int32 || type == :uint32 || type == :int64 || type == :uint64
 413     if operands.size == 3
 414         op1 = operands[0]
 415         op2 = operands[1]
 416         dst = operands[2]
 417     else
 418         op1 = operands[1]
 419         op2 = operands[0]
 420         dst = operands[1]
 421     end
 422     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 423         truncationHeader = &quot;(uint32_t)(&quot;
 424         truncationFooter = &quot;)&quot;
 425     else
 426         truncationHeader = &quot;&quot;
 427         truncationFooter = &quot;&quot;
 428     end
 429     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operands[1].clValue(type)} #{operator} (#{operands[0].clValue(:int)} &amp; 0x1f)#{truncationFooter};&quot;
 430 end
 431 
 432 def cloopEmitUnaryOperation(operands, type, operator)
 433     raise unless type == :int || type == :uint || type == :int32 || type == :uint32 || type == :int64 || type == :uint64
 434     raise unless operands.size == 1
 435     raise unless not operands[0].is_a? Immediate
 436     op = operands[0]
 437     dst = operands[0]
 438     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 439         truncationHeader = &quot;(uint32_t)(&quot;
 440         truncationFooter = &quot;)&quot;
 441     else
 442         truncationHeader = &quot;&quot;
 443         truncationFooter = &quot;&quot;
 444     end
 445     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operator}#{op.clValue(type)}#{truncationFooter};&quot;
 446 end
 447 
 448 def cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, condition)
 449     $asm.putc &quot;if (std::isnan(#{operands[0].clValue(:double)}) || std::isnan(#{operands[1].clValue(:double)})&quot;
 450     $asm.putc &quot;    || (#{operands[0].clValue(:double)} #{condition} #{operands[1].clValue(:double)}))&quot;
 451     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 452 end
 453 
 454 
 455 def cloopEmitCompareAndSet(operands, type, comparator)
 456     # The result is a boolean.  Hence, it doesn&#39;t need to be based on the type
 457     # of the arguments being compared.
 458     $asm.putc &quot;#{operands[2].clLValue(type)} = (#{operands[0].clValue(type)} #{comparator} #{operands[1].clValue(type)});&quot;
 459 end
 460 
 461 
 462 def cloopEmitCompareAndBranch(operands, type, comparator)
 463     $asm.putc &quot;if (#{operands[0].clValue(type)} #{comparator} #{operands[1].clValue(type)})&quot;
 464     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 465 end
 466 
 467 
 468 # conditionTest should contain a string that provides a comparator and a RHS
 469 # value e.g. &quot;&lt; 0&quot;.
 470 def cloopGenerateConditionExpression(operands, type, conditionTest)
 471     op1 = operands[0].clValue(type)
 472 
 473     # The operands must consist of 2 or 3 values.
 474     case operands.size
 475     when 2 # Just test op1 against the conditionTest.
 476         lhs = op1
 477     when 3 # Mask op1 with op2 before testing against the conditionTest.
 478         lhs = &quot;(#{op1} &amp; #{operands[1].clValue(type)})&quot;
 479     else
 480         raise &quot;Expected 2 or 3 operands but got #{operands.size} at #{codeOriginString}&quot;
 481     end
 482     
 483     &quot;#{lhs} #{conditionTest}&quot;
 484 end
 485 
 486 # conditionTest should contain a string that provides a comparator and a RHS
 487 # value e.g. &quot;&lt; 0&quot;.
 488 def cloopEmitTestAndBranchIf(operands, type, conditionTest, branchTarget)
 489     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 490     $asm.putc &quot;if (#{conditionExpr})&quot;
 491     $asm.putc &quot;    goto #{branchTarget};&quot;
 492 end
 493 
 494 def cloopEmitTestSet(operands, type, conditionTest)
 495     # The result is a boolean condition.  Hence, the result type is always an
 496     # int.  The passed in type is only used for the values being tested in
 497     # the condition test.
 498     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 499     $asm.putc &quot;#{operands[-1].clLValue} = (#{conditionExpr});&quot;
 500 end
 501 
 502 def cloopEmitOpAndBranch(operands, operator, type, conditionTest)
 503     case type
 504     when :int;   tempType = &quot;intptr_t&quot;
 505     when :int32; tempType = &quot;int32_t&quot;
 506     when :int64; tempType = &quot;int64_t&quot;
 507     else
 508         raise &quot;Unimplemented type&quot;
 509     end
 510 
 511     $asm.putc &quot;{&quot;
 512     $asm.putc &quot;    #{tempType} temp = #{operands[1].clValue(type)} #{operator} #{operands[0].clValue(type)};&quot;
 513     $asm.putc &quot;    #{operands[1].clLValue(type)} = temp;&quot;
 514     $asm.putc &quot;    if (temp #{conditionTest})&quot;
 515     $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 516     $asm.putc &quot;}&quot;
 517 end
 518 
 519 def cloopEmitOpAndBranchIfOverflow(operands, operator, type)
 520     case type
 521     when :int32
 522         tempType = &quot;int32_t&quot;
 523         truncationHeader = &quot;(uint32_t)(&quot;
 524         truncationFooter = &quot;)&quot;
 525     else
 526         raise &quot;Unimplemented type&quot;
 527     end
 528 
 529     $asm.putc &quot;{&quot;
 530 
 531     # Emit the overflow test based on the operands and the type:
 532     case operator
 533     when &quot;+&quot;; operation = &quot;add&quot;
 534     when &quot;-&quot;; operation = &quot;sub&quot;
 535     when &quot;*&quot;; operation = &quot;multiply&quot;
 536     else
 537         raise &quot;Unimplemented opeartor&quot;
 538     end
 539 
 540     $asm.putc &quot;    #{tempType} result;&quot;
 541     $asm.putc &quot;    bool success = WTF::ArithmeticOperations&lt;#{tempType}, #{tempType}, #{tempType}&gt;::#{operation}(#{operands[1].clValue(type)}, #{operands[0].clValue(type)}, result);&quot;
 542     $asm.putc &quot;    #{operands[1].clLValue(type)} = #{truncationHeader}result#{truncationFooter};&quot;
 543     $asm.putc &quot;    if (!success)&quot;
 544     $asm.putc &quot;        goto #{operands[2].cLabel};&quot;
 545     $asm.putc &quot;}&quot;
 546 end
 547 
 548 # operands: callTarget, currentFrame, currentPC
 549 def cloopEmitCallSlowPath(operands)
 550     $asm.putc &quot;{&quot;
 551     $asm.putc &quot;    cloopStack.setCurrentStackPointer(sp.vp());&quot;
 552     $asm.putc &quot;    SlowPathReturnType result = #{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 553     $asm.putc &quot;    decodeResult(result, t0, t1);&quot;
 554     $asm.putc &quot;}&quot;
 555 end
 556 
 557 def cloopEmitCallSlowPathVoid(operands)
 558     $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
 559     $asm.putc &quot;#{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 560 end
 561 
 562 class Instruction
 563     def lowerC_LOOP
 564         case opcode
 565         when &quot;addi&quot;
 566             cloopEmitOperation(operands, :int32, &quot;+&quot;)
 567         when &quot;addq&quot;
 568             cloopEmitOperation(operands, :int64, &quot;+&quot;)
 569         when &quot;addp&quot;
 570             cloopEmitOperation(operands, :int, &quot;+&quot;)
 571 
 572         when &quot;andi&quot;
 573             cloopEmitOperation(operands, :int32, &quot;&amp;&quot;)
 574         when &quot;andq&quot;
 575             cloopEmitOperation(operands, :int64, &quot;&amp;&quot;)
 576         when &quot;andp&quot;
 577             cloopEmitOperation(operands, :int, &quot;&amp;&quot;)
 578 
 579         when &quot;ori&quot;
 580             cloopEmitOperation(operands, :int32, &quot;|&quot;)
 581         when &quot;orq&quot;
 582             cloopEmitOperation(operands, :int64, &quot;|&quot;)
 583         when &quot;orp&quot;
 584             cloopEmitOperation(operands, :int, &quot;|&quot;)
 585 
 586         when &quot;xori&quot;
 587             cloopEmitOperation(operands, :int32, &quot;^&quot;)
 588         when &quot;xorq&quot;
 589             cloopEmitOperation(operands, :int64, &quot;^&quot;)
 590         when &quot;xorp&quot;
 591             cloopEmitOperation(operands, :int, &quot;^&quot;)
 592 
 593         when &quot;lshifti&quot;
 594             cloopEmitShiftOperation(operands, :int32, &quot;&lt;&lt;&quot;)
 595         when &quot;lshiftq&quot;
 596             cloopEmitShiftOperation(operands, :int64, &quot;&lt;&lt;&quot;)
 597         when &quot;lshiftp&quot;
 598             cloopEmitShiftOperation(operands, :int, &quot;&lt;&lt;&quot;)
 599 
 600         when &quot;rshifti&quot;
 601             cloopEmitShiftOperation(operands, :int32, &quot;&gt;&gt;&quot;)
 602         when &quot;rshiftq&quot;
 603             cloopEmitShiftOperation(operands, :int64, &quot;&gt;&gt;&quot;)
 604         when &quot;rshiftp&quot;
 605             cloopEmitShiftOperation(operands, :int, &quot;&gt;&gt;&quot;)
 606 
 607         when &quot;urshifti&quot;
 608             cloopEmitShiftOperation(operands, :uint32, &quot;&gt;&gt;&quot;)
 609         when &quot;urshiftq&quot;
 610             cloopEmitShiftOperation(operands, :uint64, &quot;&gt;&gt;&quot;)
 611         when &quot;urshiftp&quot;
 612             cloopEmitShiftOperation(operands, :uint, &quot;&gt;&gt;&quot;)
 613 
 614         when &quot;muli&quot;
 615             cloopEmitOperation(operands, :int32, &quot;*&quot;)
 616         when &quot;mulq&quot;
 617             cloopEmitOperation(operands, :int64, &quot;*&quot;)
 618         when &quot;mulp&quot;
 619             cloopEmitOperation(operands, :int, &quot;*&quot;)
 620 
 621         when &quot;subi&quot;
 622             cloopEmitOperation(operands, :int32, &quot;-&quot;)
 623         when &quot;subq&quot;
 624             cloopEmitOperation(operands, :int64, &quot;-&quot;)
 625         when &quot;subp&quot;
 626             cloopEmitOperation(operands, :int, &quot;-&quot;)
 627 
 628         when &quot;negi&quot;
 629             cloopEmitUnaryOperation(operands, :int32, &quot;-&quot;)
 630         when &quot;negq&quot;
 631             cloopEmitUnaryOperation(operands, :int64, &quot;-&quot;)
 632         when &quot;negp&quot;
 633             cloopEmitUnaryOperation(operands, :int, &quot;-&quot;)
 634 
 635         when &quot;noti&quot;
 636             cloopEmitUnaryOperation(operands, :int32, &quot;~&quot;)
 637 
 638         when &quot;loadi&quot;
 639             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = #{operands[0].uint32MemRef};&quot;
 640             # There&#39;s no need to call clearHighWord() here because the above will
 641             # automatically take care of 0 extension.
 642         when &quot;loadis&quot;
 643             $asm.putc &quot;#{operands[1].clLValue(:int32)} = #{operands[0].int32MemRef};&quot;
 644         when &quot;loadq&quot;
 645             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].int64MemRef};&quot;
 646         when &quot;loadp&quot;
 647             $asm.putc &quot;#{operands[1].clLValue} = #{operands[0].intMemRef};&quot;
 648         when &quot;storei&quot;
 649             $asm.putc &quot;#{operands[1].int32MemRef} = #{operands[0].clValue(:int32)};&quot;
 650         when &quot;storeq&quot;
 651             $asm.putc &quot;#{operands[1].int64MemRef} = #{operands[0].clValue(:int64)};&quot;
 652         when &quot;storep&quot;
 653             $asm.putc &quot;#{operands[1].intMemRef} = #{operands[0].clValue(:int)};&quot;
 654         when &quot;loadb&quot;
 655             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].uint8MemRef};&quot;
 656         when &quot;loadbs&quot;
 657             $asm.putc &quot;#{operands[1].clLValue(:int)} = (uint32_t)(#{operands[0].int8MemRef});&quot;
 658         when &quot;loadbsp&quot;
 659             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].int8MemRef};&quot;
 660         when &quot;storeb&quot;
 661             $asm.putc &quot;#{operands[1].uint8MemRef} = #{operands[0].clValue(:int8)};&quot;
 662         when &quot;loadh&quot;
 663             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].uint16MemRef};&quot;
 664         when &quot;loadhs&quot;
 665             $asm.putc &quot;#{operands[1].clLValue(:int)} = (uint32_t)(#{operands[0].int16MemRef});&quot;
 666         when &quot;storeh&quot;
 667             $asm.putc &quot;*#{operands[1].uint16MemRef} = #{operands[0].clValue(:int16)};&quot;
 668         when &quot;loadd&quot;
 669             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].dblMemRef};&quot;
 670         when &quot;stored&quot;
 671             $asm.putc &quot;#{operands[1].dblMemRef} = #{operands[0].clValue(:double)};&quot;
 672 
 673         when &quot;addd&quot;
 674             cloopEmitOperation(operands, :double, &quot;+&quot;)
 675         when &quot;divd&quot;
 676             cloopEmitOperation(operands, :double, &quot;/&quot;)
 677         when &quot;subd&quot;
 678             cloopEmitOperation(operands, :double, &quot;-&quot;)
 679         when &quot;muld&quot;
 680             cloopEmitOperation(operands, :double, &quot;*&quot;)
 681 
 682         # Convert an int value to its double equivalent, and store it in a double register.
 683         when &quot;ci2d&quot;
 684             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2d&quot;
 685 
 686         when &quot;bdeq&quot;
 687             cloopEmitCompareAndBranch(operands, :double, &quot;==&quot;)
 688         when &quot;bdneq&quot;
 689             cloopEmitCompareAndBranch(operands, :double, &quot;!=&quot;)
 690         when &quot;bdgt&quot;
 691             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;&quot;);
 692         when &quot;bdgteq&quot;
 693             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;=&quot;);
 694         when &quot;bdlt&quot;
 695             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;&quot;);
 696         when &quot;bdlteq&quot;
 697             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;=&quot;);
 698 
 699         when &quot;bdequn&quot;
 700             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;==&quot;)
 701         when &quot;bdnequn&quot;
 702             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;!=&quot;)
 703         when &quot;bdgtun&quot;
 704             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;&quot;)
 705         when &quot;bdgtequn&quot;
 706             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;=&quot;)
 707         when &quot;bdltun&quot;
 708             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;&quot;)
 709         when &quot;bdltequn&quot;
 710             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;=&quot;)
 711 
 712         when &quot;td2i&quot;
 713             $asm.putc &quot;#{operands[1].clLValue(:int)} = (uint32_t)(intptr_t)#{operands[0].clValue(:double)}; // td2i&quot;
 714 
 715         when &quot;bcd2i&quot;  # operands: srcDbl dstInt slowPath
 716             $asm.putc &quot;{ // bcd2i&quot;
 717             $asm.putc &quot;    double d = #{operands[0].clValue(:double)};&quot;
 718             $asm.putc &quot;    const int32_t asInt32 = int32_t(d);&quot;
 719             $asm.putc &quot;    if (asInt32 != d || (!asInt32 &amp;&amp; std::signbit(d))) // true for -0.0&quot;
 720             $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 721             $asm.putc &quot;    #{operands[1].clLValue} = (uint32_t)asInt32;&quot;
 722             $asm.putc &quot;}&quot;
 723 
 724         when &quot;move&quot;
 725             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].clValue(:int)};&quot;
 726         when &quot;sxi2q&quot;
 727             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:int32)};&quot;
 728         when &quot;zxi2q&quot;
 729             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = #{operands[0].clValue(:uint32)};&quot;
 730         when &quot;nop&quot;
 731             $asm.putc &quot;// nop&quot;
 732         when &quot;bbeq&quot;
 733             cloopEmitCompareAndBranch(operands, :int8, &quot;==&quot;)
 734         when &quot;bieq&quot;
 735             cloopEmitCompareAndBranch(operands, :int32, &quot;==&quot;)
 736         when &quot;bqeq&quot;
 737             cloopEmitCompareAndBranch(operands, :int64, &quot;==&quot;)
 738         when &quot;bpeq&quot;
 739             cloopEmitCompareAndBranch(operands, :int, &quot;==&quot;)
 740 
 741         when &quot;bbneq&quot;
 742             cloopEmitCompareAndBranch(operands, :int8, &quot;!=&quot;)
 743         when &quot;bineq&quot;
 744             cloopEmitCompareAndBranch(operands, :int32, &quot;!=&quot;)
 745         when &quot;bqneq&quot;
 746             cloopEmitCompareAndBranch(operands, :int64, &quot;!=&quot;)
 747         when &quot;bpneq&quot;
 748             cloopEmitCompareAndBranch(operands, :int, &quot;!=&quot;)
 749 
 750         when &quot;bba&quot;
 751             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;&quot;)
 752         when &quot;bia&quot;
 753             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;&quot;)
 754         when &quot;bqa&quot;
 755             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;&quot;)
 756         when &quot;bpa&quot;
 757             cloopEmitCompareAndBranch(operands, :uint, &quot;&gt;&quot;)
 758 
 759         when &quot;bbaeq&quot;
 760             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;=&quot;)
 761         when &quot;biaeq&quot;
 762             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;=&quot;)
 763         when &quot;bqaeq&quot;
 764             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;=&quot;)
 765         when &quot;bpaeq&quot;
 766             cloopEmitCompareAndBranch(operands, :uint, &quot;&gt;=&quot;)
 767 
 768         when &quot;bbb&quot;
 769             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;&quot;)
 770         when &quot;bib&quot;
 771             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;&quot;)
 772         when &quot;bqb&quot;
 773             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;&quot;)
 774         when &quot;bpb&quot;
 775             cloopEmitCompareAndBranch(operands, :uint, &quot;&lt;&quot;)
 776 
 777         when &quot;bbbeq&quot;
 778             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;=&quot;)
 779         when &quot;bibeq&quot;
 780             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;=&quot;)
 781         when &quot;bqbeq&quot;
 782             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;=&quot;)
 783         when &quot;bpbeq&quot;
 784             cloopEmitCompareAndBranch(operands, :uint, &quot;&lt;=&quot;)
 785 
 786         when &quot;bbgt&quot;
 787             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;&quot;)
 788         when &quot;bigt&quot;
 789             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;&quot;)
 790         when &quot;bqgt&quot;
 791             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;&quot;)
 792         when &quot;bpgt&quot;
 793             cloopEmitCompareAndBranch(operands, :int, &quot;&gt;&quot;)
 794 
 795         when &quot;bbgteq&quot;
 796             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;=&quot;)
 797         when &quot;bigteq&quot;
 798             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;=&quot;)
 799         when &quot;bqgteq&quot;
 800             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;=&quot;)
 801         when &quot;bpgteq&quot;
 802             cloopEmitCompareAndBranch(operands, :int, &quot;&gt;=&quot;)
 803 
 804         when &quot;bblt&quot;
 805             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;&quot;)
 806         when &quot;bilt&quot;
 807             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;&quot;)
 808         when &quot;bqlt&quot;
 809             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;&quot;)
 810         when &quot;bplt&quot;
 811             cloopEmitCompareAndBranch(operands, :int, &quot;&lt;&quot;)
 812 
 813         when &quot;bblteq&quot;
 814             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;=&quot;)
 815         when &quot;bilteq&quot;
 816             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;=&quot;)
 817         when &quot;bqlteq&quot;
 818             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;=&quot;)
 819         when &quot;bplteq&quot;
 820             cloopEmitCompareAndBranch(operands, :int, &quot;&lt;=&quot;)
 821 
 822         when &quot;btbz&quot;
 823             cloopEmitTestAndBranchIf(operands, :int8, &quot;== 0&quot;, operands[-1].cLabel)
 824         when &quot;btiz&quot;
 825             cloopEmitTestAndBranchIf(operands, :int32, &quot;== 0&quot;, operands[-1].cLabel)
 826         when &quot;btqz&quot;
 827             cloopEmitTestAndBranchIf(operands, :int64, &quot;== 0&quot;, operands[-1].cLabel)
 828         when &quot;btpz&quot;
 829             cloopEmitTestAndBranchIf(operands, :int, &quot;== 0&quot;, operands[-1].cLabel)
 830 
 831         when &quot;btbnz&quot;
 832             cloopEmitTestAndBranchIf(operands, :int8, &quot;!= 0&quot;, operands[-1].cLabel)
 833         when &quot;btinz&quot;
 834             cloopEmitTestAndBranchIf(operands, :int32, &quot;!= 0&quot;, operands[-1].cLabel)
 835         when &quot;btqnz&quot;
 836             cloopEmitTestAndBranchIf(operands, :int64, &quot;!= 0&quot;, operands[-1].cLabel)
 837         when &quot;btpnz&quot;
 838             cloopEmitTestAndBranchIf(operands, :int, &quot;!= 0&quot;, operands[-1].cLabel)
 839 
 840         when &quot;btbs&quot;
 841             cloopEmitTestAndBranchIf(operands, :int8, &quot;&lt; 0&quot;, operands[-1].cLabel)
 842         when &quot;btis&quot;
 843             cloopEmitTestAndBranchIf(operands, :int32, &quot;&lt; 0&quot;, operands[-1].cLabel)
 844         when &quot;btqs&quot;
 845             cloopEmitTestAndBranchIf(operands, :int64, &quot;&lt; 0&quot;, operands[-1].cLabel)
 846         when &quot;btps&quot;
 847             cloopEmitTestAndBranchIf(operands, :int, &quot;&lt; 0&quot;, operands[-1].cLabel)
 848 
 849         # For jmp, we do not want to assume that we have COMPUTED_GOTO support.
 850         # Fortunately, the only times we should ever encounter indirect jmps is
 851         # when the jmp target is a CLoop opcode (by design).
 852         #
 853         # Hence, we check if the jmp target is a known label reference. If so,
 854         # we can emit a goto directly. If it is not a known target, then we set
 855         # the target in the opcode, and dispatch to it via whatever dispatch
 856         # mechanism is in used.
 857         when &quot;jmp&quot;
 858             if operands[0].is_a? LocalLabelReference or operands[0].is_a? LabelReference
 859                 # Handles jumps local or global labels.
 860                 $asm.putc &quot;goto #{operands[0].cLabel};&quot;
 861             else
 862                 # Handles jumps to some computed target.
 863                 # NOTE: must be an opcode handler or a llint glue helper.
 864                 $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
 865                 $asm.putc &quot;DISPATCH_OPCODE();&quot;
 866             end
 867 
 868         when &quot;call&quot;
 869             $asm.putc &quot;CRASH(); // generic call instruction not supported by design!&quot;
 870         when &quot;break&quot;
 871             $asm.putc &quot;CRASH(); // break instruction not implemented.&quot;
 872         when &quot;ret&quot;
 873             $asm.putc &quot;opcode = lr.opcode();&quot;
 874             $asm.putc &quot;DISPATCH_OPCODE();&quot;
 875 
 876         when &quot;cbeq&quot;
 877             cloopEmitCompareAndSet(operands, :uint8, &quot;==&quot;)
 878         when &quot;cieq&quot;
 879             cloopEmitCompareAndSet(operands, :uint32, &quot;==&quot;)
 880         when &quot;cqeq&quot;
 881             cloopEmitCompareAndSet(operands, :uint64, &quot;==&quot;)
 882         when &quot;cpeq&quot;
 883             cloopEmitCompareAndSet(operands, :uint, &quot;==&quot;)
 884 
 885         when &quot;cbneq&quot;
 886             cloopEmitCompareAndSet(operands, :uint8, &quot;!=&quot;)
 887         when &quot;cineq&quot;
 888             cloopEmitCompareAndSet(operands, :uint32, &quot;!=&quot;)
 889         when &quot;cqneq&quot;
 890             cloopEmitCompareAndSet(operands, :uint64, &quot;!=&quot;)
 891         when &quot;cpneq&quot;
 892             cloopEmitCompareAndSet(operands, :uint, &quot;!=&quot;)
 893 
 894         when &quot;cba&quot;
 895             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;&quot;)
 896         when &quot;cia&quot;
 897             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;&quot;)
 898         when &quot;cqa&quot;
 899             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;&quot;)
 900         when &quot;cpa&quot;
 901             cloopEmitCompareAndSet(operands, :uint, &quot;&gt;&quot;)
 902 
 903         when &quot;cbaeq&quot;
 904             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;=&quot;)
 905         when &quot;ciaeq&quot;
 906             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;=&quot;)
 907         when &quot;cqaeq&quot;
 908             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;=&quot;)
 909         when &quot;cpaeq&quot;
 910             cloopEmitCompareAndSet(operands, :uint, &quot;&gt;=&quot;)
 911 
 912         when &quot;cbb&quot;
 913             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;&quot;)
 914         when &quot;cib&quot;
 915             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;&quot;)
 916         when &quot;cqb&quot;
 917             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;&quot;)
 918         when &quot;cpb&quot;
 919             cloopEmitCompareAndSet(operands, :uint, &quot;&lt;&quot;)
 920 
 921         when &quot;cbbeq&quot;
 922             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;=&quot;)
 923         when &quot;cibeq&quot;
 924             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;=&quot;)
 925         when &quot;cqbeq&quot;
 926             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;=&quot;)
 927         when &quot;cpbeq&quot;
 928             cloopEmitCompareAndSet(operands, :uint, &quot;&lt;=&quot;)
 929 
 930         when &quot;cbgt&quot;
 931             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;&quot;)
 932         when &quot;cigt&quot;
 933             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;&quot;)
 934         when &quot;cqgt&quot;
 935             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;&quot;)
 936         when &quot;cpgt&quot;
 937             cloopEmitCompareAndSet(operands, :int, &quot;&gt;&quot;)
 938 
 939         when &quot;cbgteq&quot;
 940             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;=&quot;)
 941         when &quot;cigteq&quot;
 942             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;=&quot;)
 943         when &quot;cqgteq&quot;
 944             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;=&quot;)
 945         when &quot;cpgteq&quot;
 946             cloopEmitCompareAndSet(operands, :int, &quot;&gt;=&quot;)
 947 
 948         when &quot;cblt&quot;
 949             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;&quot;)
 950         when &quot;cilt&quot;
 951             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;&quot;)
 952         when &quot;cqlt&quot;
 953             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;&quot;)
 954         when &quot;cplt&quot;
 955             cloopEmitCompareAndSet(operands, :int, &quot;&lt;&quot;)
 956 
 957         when &quot;cblteq&quot;
 958             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;=&quot;)
 959         when &quot;cilteq&quot;
 960             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;=&quot;)
 961         when &quot;cqlteq&quot;
 962             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;=&quot;)
 963         when &quot;cplteq&quot;
 964             cloopEmitCompareAndSet(operands, :int, &quot;&lt;=&quot;)
 965 
 966         when &quot;tbs&quot;
 967             cloopEmitTestSet(operands, :int8, &quot;&lt; 0&quot;)
 968         when &quot;tis&quot;
 969             cloopEmitTestSet(operands, :int32, &quot;&lt; 0&quot;)
 970         when &quot;tqs&quot;
 971             cloopEmitTestSet(operands, :int64, &quot;&lt; 0&quot;)
 972         when &quot;tps&quot;
 973             cloopEmitTestSet(operands, :int, &quot;&lt; 0&quot;)
 974 
 975         when &quot;tbz&quot;
 976             cloopEmitTestSet(operands, :int8, &quot;== 0&quot;)
 977         when &quot;tiz&quot;
 978             cloopEmitTestSet(operands, :int32, &quot;== 0&quot;)
 979         when &quot;tqz&quot;
 980             cloopEmitTestSet(operands, :int64, &quot;== 0&quot;)
 981         when &quot;tpz&quot;
 982             cloopEmitTestSet(operands, :int, &quot;== 0&quot;)
 983 
 984         when &quot;tbnz&quot;
 985             cloopEmitTestSet(operands, :int8, &quot;!= 0&quot;)
 986         when &quot;tinz&quot;
 987             cloopEmitTestSet(operands, :int32, &quot;!= 0&quot;)
 988         when &quot;tqnz&quot;
 989             cloopEmitTestSet(operands, :int64, &quot;!= 0&quot;)
 990         when &quot;tpnz&quot;
 991             cloopEmitTestSet(operands, :int, &quot;!= 0&quot;)
 992 
 993         # 64-bit instruction: cdqi (based on X64)
 994         # Sign extends the lower 32 bits of t0, but put the sign extension into
 995         # the lower 32 bits of t1. Leave the upper 32 bits of t0 and t1 unchanged.
 996         when &quot;cdqi&quot;
 997             $asm.putc &quot;{ // cdqi&quot;
 998             $asm.putc &quot;    int64_t temp = t0.i32(); // sign extend the low 32bit&quot;
 999             $asm.putc &quot;    t0 = (uint32_t)temp; // low word&quot;
1000             $asm.putc &quot;    t1 = (uint32_t)(temp &gt;&gt; 32); // high word&quot;
1001             $asm.putc &quot;}&quot;
1002 
1003         # 64-bit instruction: idivi op1 (based on X64)
1004         # Divide a 64-bit integer numerator by the specified denominator.
1005         # The numerator is specified in t0 and t1 as follows:
1006         #     1. low 32 bits of the numerator is in the low 32 bits of t0.
1007         #     2. high 32 bits of the numerator is in the low 32 bits of t1.
1008         #
1009         # The resultant quotient is a signed 32-bit int, and is to be stored
1010         # in the lower 32 bits of t0.
1011         # The resultant remainder is a signed 32-bit int, and is to be stored
1012         # in the lower 32 bits of t1.
1013         when &quot;idivi&quot;
1014             # Divide t1,t0 (EDX,EAX) by the specified arg, and store the remainder in t1,
1015             # and quotient in t0:
1016             $asm.putc &quot;{ // idivi&quot;
1017             $asm.putc &quot;    int64_t dividend = (int64_t(t1.u32()) &lt;&lt; 32) | t0.u32();&quot;
1018             $asm.putc &quot;    int64_t divisor = #{operands[0].clValue(:int)};&quot;
1019             $asm.putc &quot;    t1 = (uint32_t)(dividend % divisor); // remainder&quot;
1020             $asm.putc &quot;    t0 = (uint32_t)(dividend / divisor); // quotient&quot;
1021             $asm.putc &quot;}&quot;
1022 
1023         # 32-bit instruction: fii2d int32LoOp int32HiOp dblOp (based on ARMv7)
1024         # Decode 2 32-bit ints (low and high) into a 64-bit double.
1025         when &quot;fii2d&quot;
1026             $asm.putc &quot;#{operands[2].clLValue(:double)} = ints2Double(#{operands[0].clValue(:uint32)}, #{operands[1].clValue(:uint32)}); // fii2d&quot;
1027 
1028         # 32-bit instruction: f2dii dblOp int32LoOp int32HiOp (based on ARMv7)
1029         # Encode a 64-bit double into 2 32-bit ints (low and high).
1030         when &quot;fd2ii&quot;
1031             $asm.putc &quot;double2Ints(#{operands[0].clValue(:double)}, #{operands[1].clDump}, #{operands[2].clDump}); // fd2ii&quot;
1032 
1033         # 64-bit instruction: fq2d int64Op dblOp (based on X64)
1034         # Copy a bit-encoded double in a 64-bit int register to a double register.
1035         when &quot;fq2d&quot;
1036             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].clValue(:bitsAsDouble)}; // fq2d&quot;
1037 
1038         # 64-bit instruction: fd2q dblOp int64Op (based on X64 instruction set)
1039         # Copy a double as a bit-encoded double into a 64-bit int register.
1040         when &quot;fd2q&quot;
1041             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:bitsAsInt64)}; // fd2q&quot;
1042 
1043         when &quot;leai&quot;
1044             operands[0].cloopEmitLea(operands[1], :int32)
1045         when &quot;leap&quot;
1046             operands[0].cloopEmitLea(operands[1], :int)
1047 
1048         when &quot;baddio&quot;
1049             cloopEmitOpAndBranchIfOverflow(operands, &quot;+&quot;, :int32)
1050         when &quot;bsubio&quot;
1051             cloopEmitOpAndBranchIfOverflow(operands, &quot;-&quot;, :int32)
1052         when &quot;bmulio&quot;
1053             cloopEmitOpAndBranchIfOverflow(operands, &quot;*&quot;, :int32)
1054 
1055         when &quot;baddis&quot;
1056             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;&lt; 0&quot;)
1057         when &quot;baddiz&quot;
1058             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;== 0&quot;)
1059         when &quot;baddinz&quot;
1060             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;!= 0&quot;)
1061 
1062         when &quot;baddqs&quot;
1063             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;&lt; 0&quot;)
1064         when &quot;baddqz&quot;
1065             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;== 0&quot;)
1066         when &quot;baddqnz&quot;
1067             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;!= 0&quot;)
1068 
1069         when &quot;baddps&quot;
1070             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int, &quot;&lt; 0&quot;)
1071         when &quot;baddpz&quot;
1072             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int, &quot;== 0&quot;)
1073         when &quot;baddpnz&quot;
1074             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int, &quot;!= 0&quot;)
1075 
1076         when &quot;bsubis&quot;
1077             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;&lt; 0&quot;)
1078         when &quot;bsubiz&quot;
1079             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;== 0&quot;)
1080         when &quot;bsubinz&quot;
1081             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;!= 0&quot;)
1082 
1083         when &quot;borris&quot;
1084             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;&lt; 0&quot;)
1085         when &quot;borriz&quot;
1086             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;== 0&quot;)
1087         when &quot;borrinz&quot;
1088             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;!= 0&quot;)
1089             
1090         when &quot;memfence&quot;
1091 
1092         when &quot;push&quot;
1093             operands.each {
1094                 | op |
1095                 $asm.putc &quot;PUSH(#{op.clDump});&quot;
1096             }
1097         when &quot;pop&quot;
1098             operands.each {
1099                 | op |
1100                 $asm.putc &quot;POP(#{op.clDump});&quot;
1101             }
1102 
1103 
1104         # A convenience and compact call to crash because we don&#39;t want to use
1105         # the generic llint crash mechanism which relies on the availability
1106         # of the call instruction (which cannot be implemented in a generic
1107         # way, and can be abused if we made it just work for this special case).
1108         # Using a special cloopCrash instruction is cleaner.
1109         when &quot;cloopCrash&quot;
1110             $asm.putc &quot;CRASH();&quot;
1111 
1112         # We can&#39;t rely on the llint JS call mechanism which actually makes
1113         # use of the call instruction. Instead, we just implement JS calls
1114         # as an opcode dispatch.
1115         when &quot;cloopCallJSFunction&quot;
1116             uid = $asm.newUID
1117             $asm.putc &quot;lr = getOpcode(llint_cloop_did_return_from_js_#{uid});&quot;
1118             $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
1119             $asm.putc &quot;DISPATCH_OPCODE();&quot;
1120             $asm.putsLabel(&quot;llint_cloop_did_return_from_js_#{uid}&quot;, false)
1121 
1122         # We can&#39;t do generic function calls with an arbitrary set of args, but
1123         # fortunately we don&#39;t have to here. All native function calls always
1124         # have a fixed prototype of 1 args: the passed ExecState.
1125         when &quot;cloopCallNative&quot;
1126             $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
1127             $asm.putc &quot;nativeFunc = #{operands[0].clValue(:nativeFunc)};&quot;
1128             $asm.putc &quot;functionReturnValue = JSValue::decode(nativeFunc(t0.execState()));&quot;
1129             $asm.putc &quot;#if USE(JSVALUE32_64)&quot;
1130             $asm.putc &quot;    t1 = functionReturnValue.tag();&quot;
1131             $asm.putc &quot;    t0 = functionReturnValue.payload();&quot;
1132             $asm.putc &quot;#else // USE_JSVALUE64)&quot;
1133             $asm.putc &quot;    t0 = JSValue::encode(functionReturnValue);&quot;
1134             $asm.putc &quot;#endif // USE_JSVALUE64)&quot;
1135 
1136         # We can&#39;t do generic function calls with an arbitrary set of args, but
1137         # fortunately we don&#39;t have to here. All slow path function calls always
1138         # have a fixed prototype too. See cloopEmitCallSlowPath() for details.
1139         when &quot;cloopCallSlowPath&quot;
1140             cloopEmitCallSlowPath(operands)
1141 
1142         when &quot;cloopCallSlowPathVoid&quot;
1143             cloopEmitCallSlowPathVoid(operands)
1144 
1145         # For debugging only. This is used to insert instrumentation into the
1146         # generated LLIntAssembly.h during llint development only. Do not use
1147         # for production code.
1148         when &quot;cloopDo&quot;
1149             $asm.putc &quot;#{annotation}&quot;
1150 
1151         else
1152             lowerDefault
1153         end
1154     end
1155 
1156     def recordMetaDataC_LOOP
1157         $asm.codeOrigin codeOriginString if $enableCodeOriginComments
1158         $asm.annotation annotation if $enableInstrAnnotations &amp;&amp; (opcode != &quot;cloopDo&quot;)
1159         $asm.debugAnnotation codeOrigin.debugDirective if $enableDebugAnnotations
1160     end
1161 end
    </pre>
  </body>
</html>