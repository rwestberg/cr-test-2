<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGFixupPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGGraph.h&quot;
  33 #include &quot;DFGInsertionSet.h&quot;
  34 #include &quot;DFGPhase.h&quot;
  35 #include &quot;DFGPredictionPropagationPhase.h&quot;
  36 #include &quot;DFGVariableAccessDataDump.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;TypeLocation.h&quot;
  39 
  40 namespace JSC { namespace DFG {
  41 
  42 class FixupPhase : public Phase {
  43 public:
  44     FixupPhase(Graph&amp; graph)
  45         : Phase(graph, &quot;fixup&quot;)
  46         , m_insertionSet(graph)
  47     {
  48     }
  49 
  50     bool run()
  51     {
  52         ASSERT(m_graph.m_fixpointState == BeforeFixpoint);
  53         ASSERT(m_graph.m_form == ThreadedCPS);
  54 
  55         m_profitabilityChanged = false;
  56         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  57             fixupBlock(m_graph.block(blockIndex));
  58 
  59         while (m_profitabilityChanged) {
  60             m_profitabilityChanged = false;
  61 
  62             for (unsigned i = m_graph.m_argumentPositions.size(); i--;)
  63                 m_graph.m_argumentPositions[i].mergeArgumentUnboxingAwareness();
  64 
  65             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  66                 fixupGetAndSetLocalsInBlock(m_graph.block(blockIndex));
  67         }
  68 
  69         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  70             fixupChecksInBlock(m_graph.block(blockIndex));
  71 
  72         m_graph.m_planStage = PlanStage::AfterFixup;
  73 
  74         return true;
  75     }
  76 
  77 private:
  78     void fixupArithDiv(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
  79     {
  80         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
  81             if (optimizeForX86() || optimizeForARM64() || optimizeForARMv7IDIVSupported()) {
  82                 fixIntOrBooleanEdge(leftChild);
  83                 fixIntOrBooleanEdge(rightChild);
  84                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
  85                     node-&gt;setArithMode(Arith::Unchecked);
  86                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
  87                     node-&gt;setArithMode(Arith::CheckOverflow);
  88                 else
  89                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
  90                 return;
  91             }
  92 
  93             // This will cause conversion nodes to be inserted later.
  94             fixDoubleOrBooleanEdge(leftChild);
  95             fixDoubleOrBooleanEdge(rightChild);
  96 
  97             // We don&#39;t need to do ref&#39;ing on the children because we&#39;re stealing them from
  98             // the original division.
  99             Node* newDivision = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, *node);
 100             newDivision-&gt;setResult(NodeResultDouble);
 101 
 102             node-&gt;setOp(DoubleAsInt32);
 103             node-&gt;children.initialize(Edge(newDivision, DoubleRepUse), Edge(), Edge());
 104             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 105                 node-&gt;setArithMode(Arith::CheckOverflow);
 106             else
 107                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 108             return;
 109         }
 110 
 111         fixDoubleOrBooleanEdge(leftChild);
 112         fixDoubleOrBooleanEdge(rightChild);
 113         node-&gt;setResult(NodeResultDouble);
 114     }
 115 
 116     void fixupArithMul(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
 117     {
 118         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 119             fixIntOrBooleanEdge(leftChild);
 120             fixIntOrBooleanEdge(rightChild);
 121             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 122                 node-&gt;setArithMode(Arith::Unchecked);
 123             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 124                 node-&gt;setArithMode(Arith::CheckOverflow);
 125             else
 126                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 127             return;
 128         }
 129         if (m_graph.binaryArithShouldSpeculateAnyInt(node, FixupPass)) {
 130             fixEdge&lt;Int52RepUse&gt;(leftChild);
 131             fixEdge&lt;Int52RepUse&gt;(rightChild);
 132             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 133                 node-&gt;setArithMode(Arith::CheckOverflow);
 134             else
 135                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 136             node-&gt;setResult(NodeResultInt52);
 137             return;
 138         }
 139 
 140         fixDoubleOrBooleanEdge(leftChild);
 141         fixDoubleOrBooleanEdge(rightChild);
 142         node-&gt;setResult(NodeResultDouble);
 143     }
 144 
 145     void fixupBlock(BasicBlock* block)
 146     {
 147         if (!block)
 148             return;
 149         ASSERT(block-&gt;isReachable);
 150         m_block = block;
 151         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
 152             m_currentNode = block-&gt;at(m_indexInBlock);
 153             fixupNode(m_currentNode);
 154         }
 155         m_insertionSet.execute(block);
 156     }
 157 
 158     void fixupNode(Node* node)
 159     {
 160         NodeType op = node-&gt;op();
 161 
 162         switch (op) {
 163         case SetLocal: {
 164             // This gets handled by fixupGetAndSetLocalsInBlock().
 165             return;
 166         }
 167 
 168         case ValueSub: {
 169             Edge&amp; child1 = node-&gt;child1();
 170             Edge&amp; child2 = node-&gt;child2();
 171 
 172             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 173                 fixEdge&lt;BigIntUse&gt;(child1);
 174                 fixEdge&lt;BigIntUse&gt;(child2);
 175                 break;
 176             }
 177 
 178             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {
 179                 fixEdge&lt;UntypedUse&gt;(child1);
 180                 fixEdge&lt;UntypedUse&gt;(child2);
 181                 break;
 182             }
 183 
 184             if (attemptToMakeIntegerAdd(node)) {
 185                 // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 186                 // https://bugs.webkit.org/show_bug.cgi?id=190607
 187                 node-&gt;setOp(ArithSub);
 188                 break;
 189             }
 190 
 191             fixDoubleOrBooleanEdge(node-&gt;child1());
 192             fixDoubleOrBooleanEdge(node-&gt;child2());
 193             node-&gt;setOp(ArithSub);
 194             node-&gt;setResult(NodeResultDouble);
 195 
 196             break;
 197         }
 198 
 199         case ValueBitXor:
 200         case ValueBitOr:
 201         case ValueBitAnd: {
 202             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 203                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 204                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 205                 break;
 206             }
 207 
 208             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 209                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 210                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 211                 break;
 212             }
 213 
 214             // In such case, we need to fallback to ArithBitOp
 215             switch (op) {
 216             case ValueBitXor:
 217                 node-&gt;setOp(ArithBitXor);
 218                 break;
 219             case ValueBitOr:
 220                 node-&gt;setOp(ArithBitOr);
 221                 break;
 222             case ValueBitAnd:
 223                 node-&gt;setOp(ArithBitAnd);
 224                 break;
 225             default:
 226                 DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
 227                 break;
 228             }
 229 
 230             node-&gt;clearFlags(NodeMustGenerate);
 231             node-&gt;setResult(NodeResultInt32);
 232             fixIntConvertingEdge(node-&gt;child1());
 233             fixIntConvertingEdge(node-&gt;child2());
 234             break;
 235         }
 236 
 237         case ArithBitNot: {
 238             if (node-&gt;child1().node()-&gt;shouldSpeculateUntypedForBitOps()) {
 239                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 240                 break;
 241             }
 242 
 243             fixIntConvertingEdge(node-&gt;child1());
 244             node-&gt;clearFlags(NodeMustGenerate);
 245             break;
 246         }
 247 
 248         case ArithBitXor:
 249         case ArithBitOr:
 250         case ArithBitAnd: {
 251             fixIntConvertingEdge(node-&gt;child1());
 252             fixIntConvertingEdge(node-&gt;child2());
 253             break;
 254         }
 255 
 256         case BitRShift:
 257         case BitLShift:
 258         case BitURShift: {
 259             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 260                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 261                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 262                 break;
 263             }
 264             fixIntConvertingEdge(node-&gt;child1());
 265             fixIntConvertingEdge(node-&gt;child2());
 266             break;
 267         }
 268 
 269         case ArithIMul: {
 270             fixIntConvertingEdge(node-&gt;child1());
 271             fixIntConvertingEdge(node-&gt;child2());
 272             node-&gt;setOp(ArithMul);
 273             node-&gt;setArithMode(Arith::Unchecked);
 274             node-&gt;child1().setUseKind(Int32Use);
 275             node-&gt;child2().setUseKind(Int32Use);
 276             break;
 277         }
 278 
 279         case ArithClz32: {
 280             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 281                 fixIntConvertingEdge(node-&gt;child1());
 282                 node-&gt;clearFlags(NodeMustGenerate);
 283             } else
 284                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 285             break;
 286         }
 287 
 288         case UInt32ToNumber: {
 289             fixIntConvertingEdge(node-&gt;child1());
 290             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 291                 node-&gt;convertToIdentity();
 292             else if (node-&gt;canSpeculateInt32(FixupPass))
 293                 node-&gt;setArithMode(Arith::CheckOverflow);
 294             else {
 295                 node-&gt;setArithMode(Arith::DoOverflow);
 296                 node-&gt;setResult(enableInt52() ? NodeResultInt52 : NodeResultDouble);
 297             }
 298             break;
 299         }
 300 
 301         case ValueNegate: {
 302             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 303                 node-&gt;setOp(ArithNegate);
 304                 fixIntOrBooleanEdge(node-&gt;child1());
 305                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 306                     node-&gt;setArithMode(Arith::Unchecked);
 307                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 308                     node-&gt;setArithMode(Arith::CheckOverflow);
 309                 else
 310                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 311                 node-&gt;setResult(NodeResultInt32);
 312                 node-&gt;clearFlags(NodeMustGenerate);
 313                 break;
 314             }
 315 
 316             if (m_graph.unaryArithShouldSpeculateAnyInt(node, FixupPass)) {
 317                 node-&gt;setOp(ArithNegate);
 318                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 319                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 320                     node-&gt;setArithMode(Arith::CheckOverflow);
 321                 else
 322                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 323                 node-&gt;setResult(NodeResultInt52);
 324                 node-&gt;clearFlags(NodeMustGenerate);
 325                 break;
 326             }
 327             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 328                 node-&gt;setOp(ArithNegate);
 329                 fixDoubleOrBooleanEdge(node-&gt;child1());
 330                 node-&gt;setResult(NodeResultDouble);
 331                 node-&gt;clearFlags(NodeMustGenerate);
 332             } else {
 333                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 334                 node-&gt;setResult(NodeResultJS);
 335             }
 336             break;
 337         }
 338 
 339         case ValueAdd: {
 340             if (attemptToMakeIntegerAdd(node)) {
 341                 node-&gt;setOp(ArithAdd);
 342                 break;
 343             }
 344             if (Node::shouldSpeculateNumberOrBooleanExpectingDefined(node-&gt;child1().node(), node-&gt;child2().node())) {
 345                 fixDoubleOrBooleanEdge(node-&gt;child1());
 346                 fixDoubleOrBooleanEdge(node-&gt;child2());
 347                 node-&gt;setOp(ArithAdd);
 348                 node-&gt;setResult(NodeResultDouble);
 349                 break;
 350             }
 351 
 352             if (attemptToMakeFastStringAdd(node))
 353                 break;
 354 
 355             Edge&amp; child1 = node-&gt;child1();
 356             Edge&amp; child2 = node-&gt;child2();
 357             if (child1-&gt;shouldSpeculateString() || child2-&gt;shouldSpeculateString()) {
 358                 if (child1-&gt;shouldSpeculateInt32() || child2-&gt;shouldSpeculateInt32()) {
 359                     auto convertString = [&amp;](Node* node, Edge&amp; edge) {
 360                         if (edge-&gt;shouldSpeculateInt32())
 361                             convertStringAddUse&lt;Int32Use&gt;(node, edge);
 362                         else {
 363                             ASSERT(edge-&gt;shouldSpeculateString());
 364                             convertStringAddUse&lt;StringUse&gt;(node, edge);
 365                         }
 366                     };
 367                     convertString(node, child1);
 368                     convertString(node, child2);
 369                     convertToMakeRope(node);
 370                     break;
 371                 }
 372             }
 373 
 374             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 375                 fixEdge&lt;BigIntUse&gt;(child1);
 376                 fixEdge&lt;BigIntUse&gt;(child2);
 377             } else {
 378                 fixEdge&lt;UntypedUse&gt;(child1);
 379                 fixEdge&lt;UntypedUse&gt;(child2);
 380             }
 381 
 382             node-&gt;setResult(NodeResultJS);
 383             break;
 384         }
 385 
 386         case StrCat: {
 387             if (attemptToMakeFastStringAdd(node))
 388                 break;
 389 
 390             // FIXME: Remove empty string arguments and possibly turn this into a ToString operation. That
 391             // would require a form of ToString that takes a KnownPrimitiveUse. This is necessary because
 392             // the implementation of StrCat doesn&#39;t dynamically optimize for empty strings.
 393             // https://bugs.webkit.org/show_bug.cgi?id=148540
 394             m_graph.doToChildren(
 395                 node,
 396                 [&amp;] (Edge&amp; edge) {
 397                     fixEdge&lt;KnownPrimitiveUse&gt;(edge);
 398                     // StrCat automatically coerces the values into strings before concatenating them.
 399                     // The ECMA spec says that we&#39;re not allowed to automatically coerce a Symbol into
 400                     // a string. If a Symbol is encountered, a TypeError will be thrown. As a result,
 401                     // our runtime functions for this slow path expect that they will never be passed
 402                     // Symbols.
 403                     m_insertionSet.insertNode(
 404                         m_indexInBlock, SpecNone, Check, node-&gt;origin,
 405                         Edge(edge.node(), NotSymbolUse));
 406                 });
 407             break;
 408         }
 409 
 410         case MakeRope: {
 411             fixupMakeRope(node);
 412             break;
 413         }
 414 
 415         case ArithAdd:
 416         case ArithSub: {
 417             // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 418             // https://bugs.webkit.org/show_bug.cgi?id=190607
 419             if (attemptToMakeIntegerAdd(node))
 420                 break;
 421             fixDoubleOrBooleanEdge(node-&gt;child1());
 422             fixDoubleOrBooleanEdge(node-&gt;child2());
 423             node-&gt;setResult(NodeResultDouble);
 424             break;
 425         }
 426 
 427         case ArithNegate: {
 428             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 429                 fixIntOrBooleanEdge(node-&gt;child1());
 430                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 431                     node-&gt;setArithMode(Arith::Unchecked);
 432                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 433                     node-&gt;setArithMode(Arith::CheckOverflow);
 434                 else
 435                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 436                 node-&gt;setResult(NodeResultInt32);
 437                 node-&gt;clearFlags(NodeMustGenerate);
 438                 break;
 439             }
 440             if (m_graph.unaryArithShouldSpeculateAnyInt(node, FixupPass)) {
 441                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 442                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 443                     node-&gt;setArithMode(Arith::CheckOverflow);
 444                 else
 445                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 446                 node-&gt;setResult(NodeResultInt52);
 447                 node-&gt;clearFlags(NodeMustGenerate);
 448                 break;
 449             }
 450 
 451             fixDoubleOrBooleanEdge(node-&gt;child1());
 452             node-&gt;setResult(NodeResultDouble);
 453             node-&gt;clearFlags(NodeMustGenerate);
 454             break;
 455         }
 456 
 457         case ValueMul: {
 458             Edge&amp; leftChild = node-&gt;child1();
 459             Edge&amp; rightChild = node-&gt;child2();
 460 
 461             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 462                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 463                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 464                 break;
 465             }
 466 
 467             // There are cases where we can have BigInt + Int32 operands reaching ValueMul.
 468             // Imagine the scenario where ValueMul was never executed, but we can predict types
 469             // reaching the node:
 470             //
 471             // 63: GetLocal(Check:Untyped:@72, JS|MustGen, NonBoolInt32, ...)  predicting NonBoolInt32
 472             // 64: GetLocal(Check:Untyped:@71, JS|MustGen, BigInt, ...)  predicting BigInt
 473             // 65: ValueMul(Check:Untyped:@63, Check:Untyped:@64, BigInt|BoolInt32|NonBoolInt32, ...)
 474             //
 475             // In such scenario, we need to emit ValueMul(Untyped, Untyped), so the runtime can throw
 476             // an exception whenever it gets excuted.
 477             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 478                 fixEdge&lt;UntypedUse&gt;(leftChild);
 479                 fixEdge&lt;UntypedUse&gt;(rightChild);
 480                 break;
 481             }
 482 
 483             // At this point, all other possible specializations are only handled by ArithMul.
 484             node-&gt;setOp(ArithMul);
 485             node-&gt;setResult(NodeResultNumber);
 486             fixupArithMul(node, leftChild, rightChild);
 487             break;
 488         }
 489 
 490         case ArithMul: {
 491             Edge&amp; leftChild = node-&gt;child1();
 492             Edge&amp; rightChild = node-&gt;child2();
 493 
 494             fixupArithMul(node, leftChild, rightChild);
 495             break;
 496         }
 497 
 498         case ValueDiv: {
 499             Edge&amp; leftChild = node-&gt;child1();
 500             Edge&amp; rightChild = node-&gt;child2();
 501 
 502             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 503                 fixEdge&lt;BigIntUse&gt;(leftChild);
 504                 fixEdge&lt;BigIntUse&gt;(rightChild);
 505                 break;
 506             }
 507 
 508             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 509                 fixEdge&lt;UntypedUse&gt;(leftChild);
 510                 fixEdge&lt;UntypedUse&gt;(rightChild);
 511                 break;
 512             }
 513             node-&gt;setOp(ArithDiv);
 514             node-&gt;setResult(NodeResultNumber);
 515             fixupArithDiv(node, leftChild, rightChild);
 516             break;
 517 
 518         }
 519 
 520         case ArithDiv:
 521         case ArithMod: {
 522             Edge&amp; leftChild = node-&gt;child1();
 523             Edge&amp; rightChild = node-&gt;child2();
 524 
 525             fixupArithDiv(node, leftChild, rightChild);
 526             break;
 527         }
 528 
 529         case ArithMin:
 530         case ArithMax: {
 531             if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 532                 fixIntOrBooleanEdge(node-&gt;child1());
 533                 fixIntOrBooleanEdge(node-&gt;child2());
 534                 break;
 535             }
 536             fixDoubleOrBooleanEdge(node-&gt;child1());
 537             fixDoubleOrBooleanEdge(node-&gt;child2());
 538             node-&gt;setResult(NodeResultDouble);
 539             break;
 540         }
 541 
 542         case ArithAbs: {
 543             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()
 544                 &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 545                 fixIntOrBooleanEdge(node-&gt;child1());
 546                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 547                     node-&gt;setArithMode(Arith::Unchecked);
 548                 else
 549                     node-&gt;setArithMode(Arith::CheckOverflow);
 550                 node-&gt;clearFlags(NodeMustGenerate);
 551                 node-&gt;setResult(NodeResultInt32);
 552                 break;
 553             }
 554 
 555             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 556                 fixDoubleOrBooleanEdge(node-&gt;child1());
 557                 node-&gt;clearFlags(NodeMustGenerate);
 558             } else
 559                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 560             node-&gt;setResult(NodeResultDouble);
 561             break;
 562         }
 563 
 564         case ArithPow: {
 565             if (node-&gt;child2()-&gt;shouldSpeculateInt32OrBooleanForArithmetic()) {
 566                 fixDoubleOrBooleanEdge(node-&gt;child1());
 567                 fixIntOrBooleanEdge(node-&gt;child2());
 568                 break;
 569             }
 570 
 571             fixDoubleOrBooleanEdge(node-&gt;child1());
 572             fixDoubleOrBooleanEdge(node-&gt;child2());
 573             break;
 574         }
 575 
 576         case ArithRandom: {
 577             node-&gt;setResult(NodeResultDouble);
 578             break;
 579         }
 580 
 581         case ArithRound:
 582         case ArithFloor:
 583         case ArithCeil:
 584         case ArithTrunc: {
 585             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 586                 fixIntOrBooleanEdge(node-&gt;child1());
 587                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
 588                 node-&gt;convertToIdentity();
 589                 break;
 590             }
 591             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 592                 fixDoubleOrBooleanEdge(node-&gt;child1());
 593 
 594                 if (isInt32OrBooleanSpeculation(node-&gt;getHeapPrediction()) &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 595                     node-&gt;setResult(NodeResultInt32);
 596                     if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 597                         node-&gt;setArithRoundingMode(Arith::RoundingMode::Int32);
 598                     else
 599                         node-&gt;setArithRoundingMode(Arith::RoundingMode::Int32WithNegativeZeroCheck);
 600                 } else {
 601                     node-&gt;setResult(NodeResultDouble);
 602                     node-&gt;setArithRoundingMode(Arith::RoundingMode::Double);
 603                 }
 604                 node-&gt;clearFlags(NodeMustGenerate);
 605             } else
 606                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 607             break;
 608         }
 609 
 610         case ArithFRound:
 611         case ArithSqrt:
 612         case ArithUnary: {
 613             Edge&amp; child1 = node-&gt;child1();
 614             if (child1-&gt;shouldSpeculateNotCell()) {
 615                 fixDoubleOrBooleanEdge(child1);
 616                 node-&gt;clearFlags(NodeMustGenerate);
 617             } else
 618                 fixEdge&lt;UntypedUse&gt;(child1);
 619             break;
 620         }
 621 
 622         case LogicalNot: {
 623             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
 624                 if (node-&gt;child1()-&gt;result() == NodeResultBoolean) {
 625                     // This is necessary in case we have a bytecode instruction implemented by:
 626                     //
 627                     // a: CompareEq(...)
 628                     // b: LogicalNot(@a)
 629                     //
 630                     // In that case, CompareEq might have a side-effect. Then, we need to make
 631                     // sure that we know that Branch does not exit.
 632                     fixEdge&lt;KnownBooleanUse&gt;(node-&gt;child1());
 633                 } else
 634                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 635             } else if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther())
 636                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
 637             else if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean())
 638                 fixIntOrBooleanEdge(node-&gt;child1());
 639             else if (node-&gt;child1()-&gt;shouldSpeculateNumber())
 640                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 641             else if (node-&gt;child1()-&gt;shouldSpeculateString())
 642                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
 643             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrOther())
 644                 fixEdge&lt;StringOrOtherUse&gt;(node-&gt;child1());
 645             else {
 646                 WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
 647                 if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid())
 648                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
 649             }
 650             break;
 651         }
 652 
 653         case CompareEq:
 654         case CompareLess:
 655         case CompareLessEq:
 656         case CompareGreater:
 657         case CompareGreaterEq: {
 658             if (node-&gt;op() == CompareEq
 659                 &amp;&amp; Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 660                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 661                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
 662                 node-&gt;clearFlags(NodeMustGenerate);
 663                 break;
 664             }
 665             if (Node::shouldSpeculateInt32OrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 666                 fixIntOrBooleanEdge(node-&gt;child1());
 667                 fixIntOrBooleanEdge(node-&gt;child2());
 668                 node-&gt;clearFlags(NodeMustGenerate);
 669                 break;
 670             }
 671             if (enableInt52()
 672                 &amp;&amp; Node::shouldSpeculateAnyInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 673                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 674                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
 675                 node-&gt;clearFlags(NodeMustGenerate);
 676                 break;
 677             }
 678             if (Node::shouldSpeculateNumberOrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 679                 fixDoubleOrBooleanEdge(node-&gt;child1());
 680                 fixDoubleOrBooleanEdge(node-&gt;child2());
 681             }
 682             if (node-&gt;op() != CompareEq
 683                 &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotCell()
 684                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotCell()) {
 685                 if (node-&gt;child1()-&gt;shouldSpeculateNumberOrBoolean())
 686                     fixDoubleOrBooleanEdge(node-&gt;child1());
 687                 else
 688                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 689                 if (node-&gt;child2()-&gt;shouldSpeculateNumberOrBoolean())
 690                     fixDoubleOrBooleanEdge(node-&gt;child2());
 691                 else
 692                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
 693                 node-&gt;clearFlags(NodeMustGenerate);
 694                 break;
 695             }
 696             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateStringIdent()) {
 697                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
 698                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
 699                 node-&gt;clearFlags(NodeMustGenerate);
 700                 break;
 701             }
 702             if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; GPRInfo::numberOfRegisters &gt;= 7) {
 703                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
 704                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
 705                 node-&gt;clearFlags(NodeMustGenerate);
 706                 break;
 707             }
 708 
 709             if (node-&gt;op() != CompareEq)
 710                 break;
 711             if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
 712                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
 713                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
 714                 node-&gt;clearFlags(NodeMustGenerate);
 715                 break;
 716             }
 717             if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
 718                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
 719                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
 720                 node-&gt;clearFlags(NodeMustGenerate);
 721                 break;
 722             }
 723 
 724             // If either child can be proved to be Null or Undefined, comparing them is greatly simplified.
 725             bool oneArgumentIsUsedAsSpecOther = false;
 726             if (node-&gt;child1()-&gt;isUndefinedOrNullConstant()) {
 727                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child1());
 728                 oneArgumentIsUsedAsSpecOther = true;
 729             } else if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
 730                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin,
 731                     Edge(node-&gt;child1().node(), OtherUse));
 732                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child1());
 733                 oneArgumentIsUsedAsSpecOther = true;
 734             }
 735             if (node-&gt;child2()-&gt;isUndefinedOrNullConstant()) {
 736                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child2());
 737                 oneArgumentIsUsedAsSpecOther = true;
 738             } else if (node-&gt;child2()-&gt;shouldSpeculateOther()) {
 739                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin,
 740                     Edge(node-&gt;child2().node(), OtherUse));
 741                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child2());
 742                 oneArgumentIsUsedAsSpecOther = true;
 743             }
 744             if (oneArgumentIsUsedAsSpecOther) {
 745                 node-&gt;clearFlags(NodeMustGenerate);
 746                 break;
 747             }
 748 
 749             if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObjectOrOther()) {
 750                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
 751                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child2());
 752                 node-&gt;clearFlags(NodeMustGenerate);
 753                 break;
 754             }
 755             if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
 756                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
 757                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
 758                 node-&gt;clearFlags(NodeMustGenerate);
 759                 break;
 760             }
 761 
 762             break;
 763         }
 764 
 765         case CompareStrictEq:
 766         case SameValue: {
 767             fixupCompareStrictEqAndSameValue(node);
 768             break;
 769         }
 770 
 771         case StringFromCharCode:
 772             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 773                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
 774                 node-&gt;clearFlags(NodeMustGenerate);
 775             } else
 776                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 777             break;
 778 
 779         case StringCharAt:
 780         case StringCharCodeAt: {
 781             // Currently we have no good way of refining these.
 782             ASSERT(node-&gt;arrayMode() == ArrayMode(Array::String, Array::Read));
 783             blessArrayOperation(node-&gt;child1(), node-&gt;child2(), node-&gt;child3());
 784             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
 785             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
 786             break;
 787         }
 788 
 789         case GetByVal: {
 790             if (!node-&gt;prediction()) {
 791                 m_insertionSet.insertNode(
 792                     m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
 793             }
 794 
 795             node-&gt;setArrayMode(
 796                 node-&gt;arrayMode().refine(
 797                     m_graph, node,
 798                     m_graph.varArgChild(node, 0)-&gt;prediction(),
 799                     m_graph.varArgChild(node, 1)-&gt;prediction(),
 800                     SpecNone));
 801 
 802             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
 803 
 804             ArrayMode arrayMode = node-&gt;arrayMode();
 805             switch (arrayMode.type()) {
 806             case Array::Contiguous:
 807             case Array::Double:
 808                 if (arrayMode.isJSArrayWithOriginalStructure() &amp;&amp; arrayMode.speculation() == Array::InBounds) {
 809                     // Check if SaneChain will work on a per-type basis. Note that:
 810                     //
 811                     // 1) We don&#39;t want double arrays to sometimes return undefined, since
 812                     // that would require a change to the return type and it would pessimise
 813                     // things a lot. So, we&#39;d only want to do that if we actually had
 814                     // evidence that we could read from a hole. That&#39;s pretty annoying.
 815                     // Likely the best way to handle that case is with an equivalent of
 816                     // SaneChain for OutOfBounds. For now we just detect when Undefined and
 817                     // NaN are indistinguishable according to backwards propagation, and just
 818                     // use SaneChain in that case. This happens to catch a lot of cases.
 819                     //
 820                     // 2) We don&#39;t want int32 array loads to have to do a hole check just to
 821                     // coerce to Undefined, since that would mean twice the checks.
 822                     //
 823                     // This has two implications. First, we have to do more checks than we&#39;d
 824                     // like. It&#39;s unfortunate that we have to do the hole check. Second,
 825                     // some accesses that hit a hole will now need to take the full-blown
 826                     // out-of-bounds slow path. We can fix that with:
 827                     // https://bugs.webkit.org/show_bug.cgi?id=144668
 828 
 829                     bool canDoSaneChain = false;
 830                     switch (arrayMode.type()) {
 831                     case Array::Contiguous:
 832                         // This is happens to be entirely natural. We already would have
 833                         // returned any JSValue, and now we&#39;ll return Undefined. We still do
 834                         // the check but it doesn&#39;t require taking any kind of slow path.
 835                         canDoSaneChain = true;
 836                         break;
 837 
 838                     case Array::Double:
 839                         if (!(node-&gt;flags() &amp; NodeBytecodeUsesAsOther)) {
 840                             // Holes look like NaN already, so if the user doesn&#39;t care
 841                             // about the difference between Undefined and NaN then we can
 842                             // do this.
 843                             canDoSaneChain = true;
 844                         }
 845                         break;
 846 
 847                     default:
 848                         break;
 849                     }
 850 
 851                     if (canDoSaneChain) {
 852                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
 853                         Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(vm());
 854                         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
 855                         if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 856                             &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 857                             &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
 858                             m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
 859                             m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 860                             node-&gt;setArrayMode(arrayMode.withSpeculation(Array::SaneChain));
 861                         }
 862                     }
 863                 }
 864                 break;
 865 
 866             case Array::String:
 867                 if ((node-&gt;prediction() &amp; ~SpecString)
 868                     || m_graph.hasExitSite(node-&gt;origin.semantic, OutOfBounds))
 869                     node-&gt;setArrayMode(arrayMode.withSpeculation(Array::OutOfBounds));
 870                 break;
 871 
 872             default:
 873                 break;
 874             }
 875 
 876             arrayMode = node-&gt;arrayMode();
 877             switch (arrayMode.type()) {
 878             case Array::SelectUsingPredictions:
 879             case Array::Unprofiled:
 880                 RELEASE_ASSERT_NOT_REACHED();
 881                 break;
 882             case Array::Generic:
 883                 if (m_graph.varArgChild(node, 0)-&gt;shouldSpeculateObject()) {
 884                     if (m_graph.varArgChild(node, 1)-&gt;shouldSpeculateString()) {
 885                         fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 0));
 886                         fixEdge&lt;StringUse&gt;(m_graph.varArgChild(node, 1));
 887                         break;
 888                     }
 889 
 890                     if (m_graph.varArgChild(node, 1)-&gt;shouldSpeculateSymbol()) {
 891                         fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 0));
 892                         fixEdge&lt;SymbolUse&gt;(m_graph.varArgChild(node, 1));
 893                         break;
 894                     }
 895                 }
 896 #if USE(JSVALUE32_64)
 897                 fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0)); // Speculating cell due to register pressure on 32-bit.
 898 #endif
 899                 break;
 900             case Array::ForceExit:
 901                 break;
 902             case Array::String:
 903                 fixEdge&lt;KnownStringUse&gt;(m_graph.varArgChild(node, 0));
 904                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
 905                 break;
 906             default:
 907                 fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
 908                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
 909                 break;
 910             }
 911 
 912             switch (arrayMode.type()) {
 913             case Array::Double:
 914                 if (!arrayMode.isOutOfBounds())
 915                     node-&gt;setResult(NodeResultDouble);
 916                 break;
 917 
 918             case Array::Float32Array:
 919             case Array::Float64Array:
 920                 node-&gt;setResult(NodeResultDouble);
 921                 break;
 922 
 923             case Array::Uint32Array:
 924                 if (node-&gt;shouldSpeculateInt32())
 925                     break;
 926                 if (node-&gt;shouldSpeculateAnyInt() &amp;&amp; enableInt52())
 927                     node-&gt;setResult(NodeResultInt52);
 928                 else
 929                     node-&gt;setResult(NodeResultDouble);
 930                 break;
 931 
 932             default:
 933                 break;
 934             }
 935 
 936             break;
 937         }
 938 
 939         case PutByValDirect:
 940         case PutByVal:
 941         case PutByValAlias: {
 942             Edge&amp; child1 = m_graph.varArgChild(node, 0);
 943             Edge&amp; child2 = m_graph.varArgChild(node, 1);
 944             Edge&amp; child3 = m_graph.varArgChild(node, 2);
 945 
 946             node-&gt;setArrayMode(
 947                 node-&gt;arrayMode().refine(
 948                     m_graph, node,
 949                     child1-&gt;prediction(),
 950                     child2-&gt;prediction(),
 951                     child3-&gt;prediction()));
 952 
 953             blessArrayOperation(child1, child2, m_graph.varArgChild(node, 3));
 954 
 955             switch (node-&gt;arrayMode().modeForPut().type()) {
 956             case Array::SelectUsingPredictions:
 957             case Array::SelectUsingArguments:
 958             case Array::Unprofiled:
 959             case Array::Undecided:
 960                 RELEASE_ASSERT_NOT_REACHED();
 961                 break;
 962             case Array::ForceExit:
 963             case Array::Generic:
 964                 if (child1-&gt;shouldSpeculateCell()) {
 965                     if (child2-&gt;shouldSpeculateString()) {
 966                         fixEdge&lt;CellUse&gt;(child1);
 967                         fixEdge&lt;StringUse&gt;(child2);
 968                         break;
 969                     }
 970 
 971                     if (child2-&gt;shouldSpeculateSymbol()) {
 972                         fixEdge&lt;CellUse&gt;(child1);
 973                         fixEdge&lt;SymbolUse&gt;(child2);
 974                         break;
 975                     }
 976                 }
 977 #if USE(JSVALUE32_64)
 978                 // Due to register pressure on 32-bit, we speculate cell and
 979                 // ignore the base-is-not-cell case entirely by letting the
 980                 // baseline JIT handle it.
 981                 fixEdge&lt;CellUse&gt;(child1);
 982 #endif
 983                 break;
 984             case Array::Int32:
 985                 fixEdge&lt;KnownCellUse&gt;(child1);
 986                 fixEdge&lt;Int32Use&gt;(child2);
 987                 fixEdge&lt;Int32Use&gt;(child3);
 988                 break;
 989             case Array::Double:
 990                 fixEdge&lt;KnownCellUse&gt;(child1);
 991                 fixEdge&lt;Int32Use&gt;(child2);
 992                 fixEdge&lt;DoubleRepRealUse&gt;(child3);
 993                 break;
 994             case Array::Int8Array:
 995             case Array::Int16Array:
 996             case Array::Int32Array:
 997             case Array::Uint8Array:
 998             case Array::Uint8ClampedArray:
 999             case Array::Uint16Array:
1000             case Array::Uint32Array:
1001                 fixEdge&lt;KnownCellUse&gt;(child1);
1002                 fixEdge&lt;Int32Use&gt;(child2);
1003                 if (child3-&gt;shouldSpeculateInt32())
1004                     fixIntOrBooleanEdge(child3);
1005                 else if (child3-&gt;shouldSpeculateAnyInt())
1006                     fixEdge&lt;Int52RepUse&gt;(child3);
1007                 else
1008                     fixDoubleOrBooleanEdge(child3);
1009                 break;
1010             case Array::Float32Array:
1011             case Array::Float64Array:
1012                 fixEdge&lt;KnownCellUse&gt;(child1);
1013                 fixEdge&lt;Int32Use&gt;(child2);
1014                 fixDoubleOrBooleanEdge(child3);
1015                 break;
1016             case Array::Contiguous:
1017             case Array::ArrayStorage:
1018             case Array::SlowPutArrayStorage:
1019                 fixEdge&lt;KnownCellUse&gt;(child1);
1020                 fixEdge&lt;Int32Use&gt;(child2);
1021                 speculateForBarrier(child3);
1022                 break;
1023             default:
1024                 fixEdge&lt;KnownCellUse&gt;(child1);
1025                 fixEdge&lt;Int32Use&gt;(child2);
1026                 break;
1027             }
1028             break;
1029         }
1030 
1031         case AtomicsAdd:
1032         case AtomicsAnd:
1033         case AtomicsCompareExchange:
1034         case AtomicsExchange:
1035         case AtomicsLoad:
1036         case AtomicsOr:
1037         case AtomicsStore:
1038         case AtomicsSub:
1039         case AtomicsXor: {
1040             Edge&amp; base = m_graph.child(node, 0);
1041             Edge&amp; index = m_graph.child(node, 1);
1042 
1043             bool badNews = false;
1044             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1045                 Edge&amp; child = m_graph.child(node, 2 + i);
1046                 // NOTE: DFG is not smart enough to handle double-&gt;int conversions in atomics. So, we
1047                 // just call the function when that happens. But the FTL is totally cool with those
1048                 // conversions.
1049                 if (!child-&gt;shouldSpeculateInt32()
1050                     &amp;&amp; !child-&gt;shouldSpeculateAnyInt()
1051                     &amp;&amp; !(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL()))
1052                     badNews = true;
1053             }
1054 
1055             if (badNews) {
1056                 node-&gt;setArrayMode(ArrayMode(Array::Generic, node-&gt;arrayMode().action()));
1057                 break;
1058             }
1059 
1060             node-&gt;setArrayMode(
1061                 node-&gt;arrayMode().refine(
1062                     m_graph, node, base-&gt;prediction(), index-&gt;prediction()));
1063 
1064             if (node-&gt;arrayMode().type() == Array::Generic)
1065                 break;
1066 
1067             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1068                 Edge&amp; child = m_graph.child(node, 2 + i);
1069                 if (child-&gt;shouldSpeculateInt32())
1070                     fixIntOrBooleanEdge(child);
1071                 else if (child-&gt;shouldSpeculateAnyInt())
1072                     fixEdge&lt;Int52RepUse&gt;(child);
1073                 else {
1074                     RELEASE_ASSERT(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL());
1075                     fixDoubleOrBooleanEdge(child);
1076                 }
1077             }
1078 
1079             blessArrayOperation(base, index, m_graph.child(node, 2 + numExtraAtomicsArgs(node-&gt;op())));
1080             fixEdge&lt;CellUse&gt;(base);
1081             fixEdge&lt;Int32Use&gt;(index);
1082 
1083             if (node-&gt;arrayMode().type() == Array::Uint32Array) {
1084                 // NOTE: This means basically always doing Int52.
1085                 if (node-&gt;shouldSpeculateAnyInt() &amp;&amp; enableInt52())
1086                     node-&gt;setResult(NodeResultInt52);
1087                 else
1088                     node-&gt;setResult(NodeResultDouble);
1089             }
1090             break;
1091         }
1092 
1093         case AtomicsIsLockFree:
1094             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1095                 fixIntOrBooleanEdge(node-&gt;child1());
1096             break;
1097 
1098         case ArrayPush: {
1099             // May need to refine the array mode in case the value prediction contravenes
1100             // the array prediction. For example, we may have evidence showing that the
1101             // array is in Int32 mode, but the value we&#39;re storing is likely to be a double.
1102             // Then we should turn this into a conversion to Double array followed by the
1103             // push. On the other hand, we absolutely don&#39;t want to refine based on the
1104             // base prediction. If it has non-cell garbage in it, then we want that to be
1105             // ignored. That&#39;s because ArrayPush can&#39;t handle any array modes that aren&#39;t
1106             // array-related - so if refine() turned this into a &quot;Generic&quot; ArrayPush then
1107             // that would break things.
1108             Edge&amp; storageEdge = m_graph.varArgChild(node, 0);
1109             Edge&amp; arrayEdge = m_graph.varArgChild(node, 1);
1110             unsigned elementOffset = 2;
1111             unsigned elementCount = node-&gt;numChildren() - elementOffset;
1112             for (unsigned i = 0; i &lt; elementCount; ++i) {
1113                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1114                 node-&gt;setArrayMode(
1115                     node-&gt;arrayMode().refine(
1116                         m_graph, node,
1117                         arrayEdge-&gt;prediction() &amp; SpecCell,
1118                         SpecInt32Only,
1119                         element-&gt;prediction()));
1120             }
1121             blessArrayOperation(arrayEdge, Edge(), storageEdge);
1122             fixEdge&lt;KnownCellUse&gt;(arrayEdge);
1123 
1124             // Convert `array.push()` to GetArrayLength.
1125             if (!elementCount &amp;&amp; node-&gt;arrayMode().supportsSelfLength()) {
1126                 node-&gt;setOpAndDefaultFlags(GetArrayLength);
1127                 node-&gt;child1() = arrayEdge;
1128                 node-&gt;child2() = storageEdge;
1129                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1130                 break;
1131             }
1132 
1133             // We do not want to perform osr exit and retry for ArrayPush. We insert Check with appropriate type,
1134             // and ArrayPush uses the edge as known typed edge. Therefore, ArrayPush do not need to perform type checks.
1135             for (unsigned i = 0; i &lt; elementCount; ++i) {
1136                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1137                 switch (node-&gt;arrayMode().type()) {
1138                 case Array::Int32:
1139                     insertCheck&lt;Int32Use&gt;(element.node());
1140                     fixEdge&lt;KnownInt32Use&gt;(element);
1141                     break;
1142                 case Array::Double:
1143                     insertCheck&lt;DoubleRepRealUse&gt;(element.node());
1144                     fixEdge&lt;DoubleRepUse&gt;(element);
1145                     break;
1146                 case Array::Contiguous:
1147                 case Array::ArrayStorage:
1148                     speculateForBarrier(element);
1149                     break;
1150                 default:
1151                     break;
1152                 }
1153                 ASSERT(shouldNotHaveTypeCheck(element.useKind()));
1154             }
1155             break;
1156         }
1157 
1158         case ArrayPop: {
1159             blessArrayOperation(node-&gt;child1(), Edge(), node-&gt;child2());
1160             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1161             break;
1162         }
1163 
1164         case ArraySlice: {
1165             fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
1166             if (node-&gt;numChildren() &gt;= 3) {
1167                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1168                 if (node-&gt;numChildren() == 4)
1169                     fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
1170             }
1171             break;
1172         }
1173 
1174         case ArrayIndexOf:
1175             fixupArrayIndexOf(node);
1176             break;
1177 
1178         case RegExpExec:
1179         case RegExpTest: {
1180             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1181 
1182             if (node-&gt;child2()-&gt;shouldSpeculateRegExpObject()) {
1183                 fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1184 
1185                 if (node-&gt;child3()-&gt;shouldSpeculateString())
1186                     fixEdge&lt;StringUse&gt;(node-&gt;child3());
1187             }
1188             break;
1189         }
1190 
1191         case RegExpMatchFast: {
1192             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1193             fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1194             fixEdge&lt;StringUse&gt;(node-&gt;child3());
1195             break;
1196         }
1197 
1198         case StringReplace:
1199         case StringReplaceRegExp: {
1200             if (node-&gt;child2()-&gt;shouldSpeculateString()) {
1201                 m_insertionSet.insertNode(
1202                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
1203                     Edge(node-&gt;child2().node(), StringUse));
1204                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1205             } else if (op == StringReplace) {
1206                 if (node-&gt;child2()-&gt;shouldSpeculateRegExpObject())
1207                     addStringReplacePrimordialChecks(node-&gt;child2().node());
1208                 else
1209                     m_insertionSet.insertNode(
1210                         m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
1211             }
1212 
1213             if (node-&gt;child1()-&gt;shouldSpeculateString()
1214                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateRegExpObject()
1215                 &amp;&amp; node-&gt;child3()-&gt;shouldSpeculateString()) {
1216 
1217                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1218                 fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1219                 fixEdge&lt;StringUse&gt;(node-&gt;child3());
1220                 break;
1221             }
1222             break;
1223         }
1224 
1225         case Branch: {
1226             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
1227                 if (node-&gt;child1()-&gt;result() == NodeResultBoolean) {
1228                     // This is necessary in case we have a bytecode instruction implemented by:
1229                     //
1230                     // a: CompareEq(...)
1231                     // b: Branch(@a)
1232                     //
1233                     // In that case, CompareEq might have a side-effect. Then, we need to make
1234                     // sure that we know that Branch does not exit.
1235                     fixEdge&lt;KnownBooleanUse&gt;(node-&gt;child1());
1236                 } else
1237                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
1238             } else if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther())
1239                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
1240             else if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean())
1241                 fixIntOrBooleanEdge(node-&gt;child1());
1242             else if (node-&gt;child1()-&gt;shouldSpeculateNumber())
1243                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
1244             else if (node-&gt;child1()-&gt;shouldSpeculateString())
1245                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1246             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrOther())
1247                 fixEdge&lt;StringOrOtherUse&gt;(node-&gt;child1());
1248             else {
1249                 WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
1250                 if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid())
1251                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
1252             }
1253             break;
1254         }
1255 
1256         case Switch: {
1257             SwitchData* data = node-&gt;switchData();
1258             switch (data-&gt;kind) {
1259             case SwitchImm:
1260                 if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1261                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1262                 break;
1263             case SwitchChar:
1264                 if (node-&gt;child1()-&gt;shouldSpeculateString())
1265                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1266                 break;
1267             case SwitchString:
1268                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent())
1269                     fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
1270                 else if (node-&gt;child1()-&gt;shouldSpeculateString())
1271                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1272                 break;
1273             case SwitchCell:
1274                 if (node-&gt;child1()-&gt;shouldSpeculateCell())
1275                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
1276                 // else it&#39;s fine for this to have UntypedUse; we will handle this by just making
1277                 // non-cells take the default case.
1278                 break;
1279             }
1280             break;
1281         }
1282 
1283         case ToPrimitive: {
1284             fixupToPrimitive(node);
1285             break;
1286         }
1287 
1288         case ToNumber: {
1289             fixupToNumber(node);
1290             break;
1291         }
1292 
1293         case ToString:
1294         case CallStringConstructor: {
1295             fixupToStringOrCallStringConstructor(node);
1296             break;
1297         }
1298 
1299         case NewStringObject: {
1300             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1301             break;
1302         }
1303 
1304         case NewSymbol: {
1305             if (node-&gt;child1())
1306                 fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1307             break;
1308         }
1309 
1310         case NewArrayWithSpread: {
1311             watchHavingABadTime(node);
1312 
1313             BitVector* bitVector = node-&gt;bitVector();
1314             for (unsigned i = node-&gt;numChildren(); i--;) {
1315                 if (bitVector-&gt;get(i))
1316                     fixEdge&lt;KnownCellUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + i]);
1317                 else
1318                     fixEdge&lt;UntypedUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + i]);
1319             }
1320 
1321             break;
1322         }
1323 
1324         case Spread: {
1325             // Note: We care about performing the protocol on our child&#39;s global object, not necessarily ours.
1326 
1327             watchHavingABadTime(node-&gt;child1().node());
1328 
1329             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;child1()-&gt;origin.semantic);
1330             // When we go down the fast path, we don&#39;t consult the prototype chain, so we must prove
1331             // that it doesn&#39;t contain any indexed properties, and that any holes will result in
1332             // jsUndefined().
1333             Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(vm());
1334             Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
1335             if (node-&gt;child1()-&gt;shouldSpeculateArray()
1336                 &amp;&amp; arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1337                 &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1338                 &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()
1339                 &amp;&amp; m_graph.isWatchingArrayIteratorProtocolWatchpoint(node-&gt;child1().node())
1340                 &amp;&amp; m_graph.isWatchingHavingABadTimeWatchpoint(node-&gt;child1().node())) {
1341                 m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
1342                 m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
1343                 fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
1344             } else
1345                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1346             break;
1347         }
1348 
1349         case NewArray: {
1350             watchHavingABadTime(node);
1351 
1352             for (unsigned i = m_graph.varArgNumChildren(node); i--;) {
1353                 node-&gt;setIndexingType(
1354                     leastUpperBoundOfIndexingTypeAndType(
1355                         node-&gt;indexingType(), m_graph.varArgChild(node, i)-&gt;prediction()));
1356             }
1357             switch (node-&gt;indexingType()) {
1358             case ALL_BLANK_INDEXING_TYPES:
1359                 CRASH();
1360                 break;
1361             case ALL_UNDECIDED_INDEXING_TYPES:
1362                 if (node-&gt;numChildren()) {
1363                     // This will only happen if the children have no type predictions. We
1364                     // would have already exited by now, but insert a forced exit just to
1365                     // be safe.
1366                     m_insertionSet.insertNode(
1367                         m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
1368                 }
1369                 break;
1370             case ALL_INT32_INDEXING_TYPES:
1371                 for (unsigned operandIndex = 0; operandIndex &lt; node-&gt;numChildren(); ++operandIndex)
1372                     fixEdge&lt;Int32Use&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + operandIndex]);
1373                 break;
1374             case ALL_DOUBLE_INDEXING_TYPES:
1375                 for (unsigned operandIndex = 0; operandIndex &lt; node-&gt;numChildren(); ++operandIndex)
1376                     fixEdge&lt;DoubleRepRealUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + operandIndex]);
1377                 break;
1378             case ALL_CONTIGUOUS_INDEXING_TYPES:
1379             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1380                 break;
1381             default:
1382                 CRASH();
1383                 break;
1384             }
1385             break;
1386         }
1387 
1388         case NewTypedArray: {
1389             watchHavingABadTime(node);
1390 
1391             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1392                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1393                 node-&gt;clearFlags(NodeMustGenerate);
1394                 break;
1395             }
1396             break;
1397         }
1398 
1399         case NewArrayWithSize: {
1400             watchHavingABadTime(node);
1401             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1402             break;
1403         }
1404 
1405         case NewArrayBuffer: {
1406             watchHavingABadTime(node);
1407             break;
1408         }
1409 
1410         case ToObject: {
1411             fixupToObject(node);
1412             break;
1413         }
1414 
1415         case CallObjectConstructor: {
1416             fixupCallObjectConstructor(node);
1417             break;
1418         }
1419 
1420         case ToThis: {
1421             fixupToThis(node);
1422             break;
1423         }
1424 
1425         case PutStructure: {
1426             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1427             break;
1428         }
1429 
1430         case GetClosureVar:
1431         case GetFromArguments: {
1432             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1433             break;
1434         }
1435 
1436         case PutClosureVar:
1437         case PutToArguments: {
1438             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1439             speculateForBarrier(node-&gt;child2());
1440             break;
1441         }
1442 
1443         case SkipScope:
1444         case GetScope:
1445         case GetGetter:
1446         case GetSetter:
1447         case GetGlobalObject: {
1448             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1449             break;
1450         }
1451 
1452         case AllocatePropertyStorage:
1453         case ReallocatePropertyStorage: {
1454             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1455             break;
1456         }
1457 
1458         case NukeStructureAndSetButterfly: {
1459             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1460             break;
1461         }
1462 
1463         case TryGetById: {
1464             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1465                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1466             break;
1467         }
1468 
1469         case GetByIdDirect:
1470         case GetByIdDirectFlush: {
1471             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1472                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1473             break;
1474         }
1475 
1476         case GetById:
1477         case GetByIdFlush: {
1478             // FIXME: This should be done in the ByteCodeParser based on reading the
1479             // PolymorphicAccess, which will surely tell us that this is a AccessCase::ArrayLength.
1480             // https://bugs.webkit.org/show_bug.cgi?id=154990
1481             auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
1482             if (node-&gt;child1()-&gt;shouldSpeculateCellOrOther()
1483                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadType)
1484                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadCache)
1485                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadIndexingType)
1486                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, ExoticObjectMode)) {
1487 
1488                 if (uid == vm().propertyNames-&gt;length.impl()) {
1489                     attemptToMakeGetArrayLength(node);
1490                     break;
1491                 }
1492 
1493                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1494                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1495                     node-&gt;setOp(GetRegExpObjectLastIndex);
1496                     node-&gt;clearFlags(NodeMustGenerate);
1497                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1498                     break;
1499                 }
1500             }
1501 
1502             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
1503                 if (uid == vm().propertyNames-&gt;toString.impl()) {
1504                     if (m_graph.isWatchingNumberToStringWatchpoint(node)) {
1505                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1506                         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1507                             insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
1508                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1509                             break;
1510                         }
1511 
1512                         if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {
1513                             insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
1514                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1515                             break;
1516                         }
1517 
1518                         ASSERT(node-&gt;child1()-&gt;shouldSpeculateNumber());
1519                         insertCheck&lt;DoubleRepUse&gt;(node-&gt;child1().node());
1520                         m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1521                         break;
1522                     }
1523                 }
1524             }
1525 
1526             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1527                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1528             break;
1529         }
1530 
1531         case GetByIdWithThis: {
1532             if (node-&gt;child1()-&gt;shouldSpeculateCell() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()) {
1533                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1534                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
1535             }
1536             break;
1537         }
1538 
1539         case PutById:
1540         case PutByIdFlush:
1541         case PutByIdDirect: {
1542             if (node-&gt;child1()-&gt;shouldSpeculateCellOrOther()
1543                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadType)
1544                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadCache)
1545                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadIndexingType)
1546                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, ExoticObjectMode)) {
1547 
1548                 auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
1549 
1550                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1551                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1552                     node-&gt;convertToSetRegExpObjectLastIndex();
1553                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1554                     speculateForBarrier(node-&gt;child2());
1555                     break;
1556                 }
1557             }
1558 
1559             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1560             break;
1561         }
1562 
1563         case PutGetterById:
1564         case PutSetterById: {
1565             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1566             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1567             break;
1568         }
1569 
1570         case PutGetterSetterById: {
1571             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1572             break;
1573         }
1574 
1575         case PutGetterByVal:
1576         case PutSetterByVal: {
1577             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1578             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1579             break;
1580         }
1581 
1582         case GetExecutable: {
1583             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
1584             break;
1585         }
1586 
1587         case OverridesHasInstance:
1588         case CheckStructure:
1589         case CheckCell:
1590         case CreateThis:
1591         case GetButterfly: {
1592             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1593             break;
1594         }
1595 
1596         case ObjectCreate: {
1597             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1598                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1599                 node-&gt;clearFlags(NodeMustGenerate);
1600                 break;
1601             }
1602             break;
1603         }
1604 
1605         case ObjectKeys: {
1606             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1607                 watchHavingABadTime(node);
1608                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1609             }
1610             break;
1611         }
1612 
1613         case CheckStringIdent: {
1614             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
1615             break;
1616         }
1617 
1618         case Arrayify:
1619         case ArrayifyToStructure: {
1620             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1621             if (node-&gt;child2())
1622                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1623             break;
1624         }
1625 
1626         case GetByOffset:
1627         case GetGetterSetterByOffset: {
1628             if (!node-&gt;child1()-&gt;hasStorageResult())
1629                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1630             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1631             break;
1632         }
1633 
1634         case MultiGetByOffset: {
1635             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1636             break;
1637         }
1638 
1639         case PutByOffset: {
1640             if (!node-&gt;child1()-&gt;hasStorageResult())
1641                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1642             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1643             speculateForBarrier(node-&gt;child3());
1644             break;
1645         }
1646 
1647         case MultiPutByOffset: {
1648             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1649             break;
1650         }
1651 
1652         case MatchStructure: {
1653             // FIXME: Introduce a variant of MatchStructure that doesn&#39;t do a cell check.
1654             // https://bugs.webkit.org/show_bug.cgi?id=185784
1655             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1656             break;
1657         }
1658 
1659         case InstanceOf: {
1660             if (node-&gt;child1()-&gt;shouldSpeculateCell()
1661                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()
1662                 &amp;&amp; is64Bit()) {
1663                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1664                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
1665                 break;
1666             }
1667             break;
1668         }
1669 
1670         case InstanceOfCustom:
1671             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1672             break;
1673 
1674         case InById: {
1675             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1676             break;
1677         }
1678 
1679         case InByVal: {
1680             if (node-&gt;child2()-&gt;shouldSpeculateInt32()) {
1681                 convertToHasIndexedProperty(node);
1682                 break;
1683             }
1684 
1685             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1686             break;
1687         }
1688 
1689         case HasOwnProperty: {
1690             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1691 #if CPU(X86)
1692             // We don&#39;t have enough registers to do anything interesting on x86 and mips.
1693             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
1694 #else
1695             if (node-&gt;child2()-&gt;shouldSpeculateString())
1696                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1697             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
1698                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
1699             else
1700                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
1701 #endif
1702             break;
1703         }
1704 
1705         case CheckVarargs:
1706         case Check: {
1707             m_graph.doToChildren(
1708                 node,
1709                 [&amp;] (Edge&amp; edge) {
1710                     switch (edge.useKind()) {
1711                     case NumberUse:
1712                         if (edge-&gt;shouldSpeculateInt32ForArithmetic())
1713                             edge.setUseKind(Int32Use);
1714                         break;
1715                     default:
1716                         break;
1717                     }
1718                     observeUseKindOnEdge(edge);
1719                 });
1720             break;
1721         }
1722 
1723         case Phantom:
1724             // Phantoms are meaningless past Fixup. We recreate them on-demand in the backend.
1725             node-&gt;remove(m_graph);
1726             break;
1727 
1728         case FiatInt52: {
1729             RELEASE_ASSERT(enableInt52());
1730             node-&gt;convertToIdentity();
1731             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
1732             node-&gt;setResult(NodeResultInt52);
1733             break;
1734         }
1735 
1736         case GetArrayLength: {
1737             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1738             break;
1739         }
1740 
1741         case GetTypedArrayByteOffset: {
1742             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1743             break;
1744         }
1745 
1746         case CompareBelow:
1747         case CompareBelowEq: {
1748             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1749             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1750             break;
1751         }
1752 
1753         case GetPrototypeOf: {
1754             fixupGetPrototypeOf(node);
1755             break;
1756         }
1757 
1758         case Phi:
1759         case Upsilon:
1760         case EntrySwitch:
1761         case GetIndexedPropertyStorage:
1762         case LastNodeType:
1763         case CheckTierUpInLoop:
1764         case CheckTierUpAtReturn:
1765         case CheckTierUpAndOSREnter:
1766         case CheckArray:
1767         case CheckInBounds:
1768         case ConstantStoragePointer:
1769         case DoubleAsInt32:
1770         case ValueToInt32:
1771         case DoubleRep:
1772         case ValueRep:
1773         case Int52Rep:
1774         case Int52Constant:
1775         case Identity: // This should have been cleaned up.
1776         case BooleanToNumber:
1777         case PhantomNewObject:
1778         case PhantomNewFunction:
1779         case PhantomNewGeneratorFunction:
1780         case PhantomNewAsyncGeneratorFunction:
1781         case PhantomNewAsyncFunction:
1782         case PhantomCreateActivation:
1783         case PhantomDirectArguments:
1784         case PhantomCreateRest:
1785         case PhantomSpread:
1786         case PhantomNewArrayWithSpread:
1787         case PhantomNewArrayBuffer:
1788         case PhantomClonedArguments:
1789         case PhantomNewRegexp:
1790         case GetMyArgumentByVal:
1791         case GetMyArgumentByValOutOfBounds:
1792         case GetVectorLength:
1793         case PutHint:
1794         case CheckStructureImmediate:
1795         case CheckStructureOrEmpty:
1796         case MaterializeNewObject:
1797         case MaterializeCreateActivation:
1798         case PutStack:
1799         case KillStack:
1800         case GetStack:
1801         case StoreBarrier:
1802         case FencedStoreBarrier:
1803         case GetRegExpObjectLastIndex:
1804         case SetRegExpObjectLastIndex:
1805         case RecordRegExpCachedResult:
1806         case RegExpExecNonGlobalOrSticky:
1807         case RegExpMatchFastGlobal:
1808             // These are just nodes that we don&#39;t currently expect to see during fixup.
1809             // If we ever wanted to insert them prior to fixup, then we just have to create
1810             // fixup rules for them.
1811             DFG_CRASH(m_graph, node, &quot;Unexpected node during fixup&quot;);
1812             break;
1813 
1814         case PutGlobalVariable: {
1815             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1816             speculateForBarrier(node-&gt;child2());
1817             break;
1818         }
1819 
1820         case IsObject:
1821             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1822                 m_insertionSet.insertNode(
1823                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
1824                     Edge(node-&gt;child1().node(), ObjectUse));
1825                 m_graph.convertToConstant(node, jsBoolean(true));
1826                 observeUseKindOnNode&lt;ObjectUse&gt;(node);
1827             }
1828             break;
1829 
1830         case IsCellWithType: {
1831             fixupIsCellWithType(node);
1832             break;
1833         }
1834 
1835         case GetEnumerableLength: {
1836             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1837             break;
1838         }
1839         case HasGenericProperty: {
1840             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1841             break;
1842         }
1843         case HasStructureProperty: {
1844             fixEdge&lt;StringUse&gt;(node-&gt;child2());
1845             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1846             break;
1847         }
1848         case HasIndexedProperty: {
1849             node-&gt;setArrayMode(
1850                 node-&gt;arrayMode().refine(
1851                     m_graph, node,
1852                     m_graph.varArgChild(node, 0)-&gt;prediction(),
1853                     m_graph.varArgChild(node, 1)-&gt;prediction(),
1854                     SpecNone));
1855 
1856             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
1857             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
1858             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 1));
1859             break;
1860         }
1861         case GetDirectPname: {
1862             Edge&amp; base = m_graph.varArgChild(node, 0);
1863             Edge&amp; property = m_graph.varArgChild(node, 1);
1864             Edge&amp; index = m_graph.varArgChild(node, 2);
1865             Edge&amp; enumerator = m_graph.varArgChild(node, 3);
1866             fixEdge&lt;CellUse&gt;(base);
1867             fixEdge&lt;KnownCellUse&gt;(property);
1868             fixEdge&lt;KnownInt32Use&gt;(index);
1869             fixEdge&lt;KnownCellUse&gt;(enumerator);
1870             break;
1871         }
1872         case GetPropertyEnumerator: {
1873             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1874                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1875             break;
1876         }
1877         case GetEnumeratorStructurePname: {
1878             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1879             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child2());
1880             break;
1881         }
1882         case GetEnumeratorGenericPname: {
1883             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1884             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child2());
1885             break;
1886         }
1887         case ToIndexString: {
1888             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());
1889             break;
1890         }
1891         case ProfileType: {
1892             // We want to insert type checks based on the instructionTypeSet of the TypeLocation, not the globalTypeSet.
1893             // Because the instructionTypeSet is contained in globalTypeSet, if we produce a type check for
1894             // type T for the instructionTypeSet, the global type set must also have information for type T.
1895             // So if it the type check succeeds for type T in the instructionTypeSet, a type check for type T
1896             // in the globalTypeSet would&#39;ve also succeeded.
1897             // (The other direction does not hold in general).
1898 
1899             RefPtr&lt;TypeSet&gt; typeSet = node-&gt;typeLocation()-&gt;m_instructionTypeSet;
1900             RuntimeTypeMask seenTypes = typeSet-&gt;seenTypes();
1901             if (typeSet-&gt;doesTypeConformTo(TypeAnyInt)) {
1902                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1903                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1904                     node-&gt;remove(m_graph);
1905                     break;
1906                 }
1907 
1908                 if (enableInt52()) {
1909                     fixEdge&lt;AnyIntUse&gt;(node-&gt;child1());
1910                     node-&gt;remove(m_graph);
1911                     break;
1912                 }
1913 
1914                 // Must not perform fixEdge&lt;NumberUse&gt; here since the type set only includes TypeAnyInt. Double values should be logged.
1915             }
1916 
1917             if (typeSet-&gt;doesTypeConformTo(TypeNumber | TypeAnyInt)) {
1918                 fixEdge&lt;NumberUse&gt;(node-&gt;child1());
1919                 node-&gt;remove(m_graph);
1920             } else if (typeSet-&gt;doesTypeConformTo(TypeString)) {
1921                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1922                 node-&gt;remove(m_graph);
1923             } else if (typeSet-&gt;doesTypeConformTo(TypeBoolean)) {
1924                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
1925                 node-&gt;remove(m_graph);
1926             } else if (typeSet-&gt;doesTypeConformTo(TypeUndefined | TypeNull) &amp;&amp; (seenTypes &amp; TypeUndefined) &amp;&amp; (seenTypes &amp; TypeNull)) {
1927                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
1928                 node-&gt;remove(m_graph);
1929             } else if (typeSet-&gt;doesTypeConformTo(TypeObject)) {
1930                 StructureSet set;
1931                 {
1932                     ConcurrentJSLocker locker(typeSet-&gt;m_lock);
1933                     set = typeSet-&gt;structureSet(locker);
1934                 }
1935                 if (!set.isEmpty()) {
1936                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
1937                     node-&gt;convertToCheckStructureOrEmpty(m_graph.addStructureSet(set));
1938                 }
1939             }
1940 
1941             break;
1942         }
1943 
1944         case CreateClonedArguments: {
1945             watchHavingABadTime(node);
1946             break;
1947         }
1948 
1949         case CreateScopedArguments:
1950         case CreateActivation:
1951         case NewFunction:
1952         case NewGeneratorFunction:
1953         case NewAsyncGeneratorFunction:
1954         case NewAsyncFunction: {
1955             // Child 1 is always the current scope, which is guaranteed to be an object
1956             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
1957             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1958             break;
1959         }
1960 
1961         case PushWithScope: {
1962             // Child 1 is always the current scope, which is guaranteed to be an object
1963             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
1964             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1965             if (node-&gt;child2()-&gt;shouldSpeculateObject())
1966                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
1967             break;
1968         }
1969 
1970         case SetFunctionName: {
1971             // The first child is guaranteed to be a cell because op_set_function_name is only used
1972             // on a newly instantiated function object (the first child).
1973             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1974             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
1975             break;
1976         }
1977 
1978         case CreateRest: {
1979             watchHavingABadTime(node);
1980             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());
1981             break;
1982         }
1983 
1984         case ResolveScopeForHoistingFuncDeclInEval: {
1985             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1986             break;
1987         }
1988         case ResolveScope:
1989         case GetDynamicVar:
1990         case PutDynamicVar: {
1991             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1992             break;
1993         }
1994 
1995         case LogShadowChickenPrologue: {
1996             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1997             break;
1998         }
1999         case LogShadowChickenTail: {
2000             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2001             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
2002             break;
2003         }
2004 
2005         case GetMapBucket:
2006             if (node-&gt;child1().useKind() == MapObjectUse)
2007                 fixEdge&lt;MapObjectUse&gt;(node-&gt;child1());
2008             else if (node-&gt;child1().useKind() == SetObjectUse)
2009                 fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2010             else
2011                 RELEASE_ASSERT_NOT_REACHED();
2012 
2013 #if USE(JSVALUE64)
2014             if (node-&gt;child2()-&gt;shouldSpeculateBoolean())
2015                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
2016             else if (node-&gt;child2()-&gt;shouldSpeculateInt32())
2017                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2018             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
2019                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
2020             else if (node-&gt;child2()-&gt;shouldSpeculateObject())
2021                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2022             else if (node-&gt;child2()-&gt;shouldSpeculateString())
2023                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
2024             else if (node-&gt;child2()-&gt;shouldSpeculateCell())
2025                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
2026             else
2027                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2028 #else
2029             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2030 #endif // USE(JSVALUE64)
2031 
2032             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2033             break;
2034 
2035         case GetMapBucketHead:
2036             if (node-&gt;child1().useKind() == MapObjectUse)
2037                 fixEdge&lt;MapObjectUse&gt;(node-&gt;child1());
2038             else if (node-&gt;child1().useKind() == SetObjectUse)
2039                 fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2040             else
2041                 RELEASE_ASSERT_NOT_REACHED();
2042             break;
2043 
2044         case GetMapBucketNext:
2045         case LoadKeyFromMapBucket:
2046         case LoadValueFromMapBucket:
2047             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2048             break;
2049 
2050         case MapHash: {
2051 #if USE(JSVALUE64)
2052             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2053                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2054                 break;
2055             }
2056 
2057             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2058                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2059                 break;
2060             }
2061 
2062             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2063                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2064                 break;
2065             }
2066 
2067             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2068                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2069                 break;
2070             }
2071 
2072             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2073                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2074                 break;
2075             }
2076 
2077             if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2078                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
2079                 break;
2080             }
2081 
2082             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2083 #else
2084             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2085 #endif // USE(JSVALUE64)
2086             break;
2087         }
2088 
2089         case NormalizeMapKey: {
2090             fixupNormalizeMapKey(node);
2091             break;
2092         }
2093 
2094         case WeakMapGet: {
2095             if (node-&gt;child1().useKind() == WeakMapObjectUse)
2096                 fixEdge&lt;WeakMapObjectUse&gt;(node-&gt;child1());
2097             else if (node-&gt;child1().useKind() == WeakSetObjectUse)
2098                 fixEdge&lt;WeakSetObjectUse&gt;(node-&gt;child1());
2099             else
2100                 RELEASE_ASSERT_NOT_REACHED();
2101             fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2102             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2103             break;
2104         }
2105 
2106         case SetAdd: {
2107             fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2108             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2109             break;
2110         }
2111 
2112         case MapSet: {
2113             fixEdge&lt;MapObjectUse&gt;(m_graph.varArgChild(node, 0));
2114             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2115             break;
2116         }
2117 
2118         case WeakSetAdd: {
2119             fixEdge&lt;WeakSetObjectUse&gt;(node-&gt;child1());
2120             fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2121             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2122             break;
2123         }
2124 
2125         case WeakMapSet: {
2126             fixEdge&lt;WeakMapObjectUse&gt;(m_graph.varArgChild(node, 0));
2127             fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 1));
2128             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2129             break;
2130         }
2131 
2132         case DefineDataProperty: {
2133             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2134             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2135             if (propertyEdge-&gt;shouldSpeculateSymbol())
2136                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2137             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2138                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2139             else if (propertyEdge-&gt;shouldSpeculateString())
2140                 fixEdge&lt;StringUse&gt;(propertyEdge);
2141             else
2142                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2143             fixEdge&lt;UntypedUse&gt;(m_graph.varArgChild(node, 2));
2144             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 3));
2145             break;
2146         }
2147 
2148         case StringValueOf: {
2149             fixupStringValueOf(node);
2150             break;
2151         }
2152 
2153         case StringSlice: {
2154             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2155             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2156             if (node-&gt;child3())
2157                 fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2158             break;
2159         }
2160 
2161         case ToLowerCase: {
2162             // We currently only support StringUse since that will ensure that
2163             // ToLowerCase is a pure operation. If we decide to update this with
2164             // more types in the future, we need to ensure that the clobberize rules
2165             // are correct.
2166             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2167             break;
2168         }
2169 
2170         case NumberToStringWithRadix: {
2171             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
2172                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2173             else if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt())
2174                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2175             else
2176                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2177             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2178             break;
2179         }
2180 
2181         case DefineAccessorProperty: {
2182             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2183             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2184             if (propertyEdge-&gt;shouldSpeculateSymbol())
2185                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2186             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2187                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2188             else if (propertyEdge-&gt;shouldSpeculateString())
2189                 fixEdge&lt;StringUse&gt;(propertyEdge);
2190             else
2191                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2192             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 2));
2193             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 3));
2194             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 4));
2195             break;
2196         }
2197 
2198         case CheckSubClass: {
2199             fixupCheckSubClass(node);
2200             break;
2201         }
2202 
2203         case CallDOMGetter: {
2204             DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
2205             fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
2206             if (snippet &amp;&amp; snippet-&gt;requireGlobalObject)
2207                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child2()); // GlobalObject.
2208             break;
2209         }
2210 
2211         case CallDOM: {
2212             fixupCallDOM(node);
2213             break;
2214         }
2215 
2216         case Call: {
2217             attemptToMakeCallDOM(node);
2218             break;
2219         }
2220 
2221         case ParseInt: {
2222             if (node-&gt;child1()-&gt;shouldSpeculateInt32() &amp;&amp; !node-&gt;child2()) {
2223                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2224                 node-&gt;convertToIdentity();
2225                 break;
2226             }
2227 
2228             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2229                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2230                 node-&gt;clearFlags(NodeMustGenerate);
2231             }
2232 
2233             if (node-&gt;child2())
2234                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2235 
2236             break;
2237         }
2238 
2239         case IdentityWithProfile: {
2240             node-&gt;clearFlags(NodeMustGenerate);
2241             break;
2242         }
2243 
2244         case ThrowStaticError:
2245             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2246             break;
2247 
2248         case NumberIsInteger:
2249             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2250                 m_insertionSet.insertNode(
2251                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2252                     Edge(node-&gt;child1().node(), Int32Use));
2253                 m_graph.convertToConstant(node, jsBoolean(true));
2254                 break;
2255             }
2256             break;
2257 
2258         case SetCallee:
2259             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2260             break;
2261 
2262         case DataViewGetInt:
2263         case DataViewGetFloat: {
2264             fixEdge&lt;DataViewObjectUse&gt;(node-&gt;child1());
2265             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2266             if (node-&gt;child3())
2267                 fixEdge&lt;BooleanUse&gt;(node-&gt;child3());
2268 
2269             if (node-&gt;op() == DataViewGetInt) {
2270                 DataViewData data = node-&gt;dataViewData();
2271                 switch (data.byteSize) {
2272                 case 1:
2273                 case 2:
2274                     node-&gt;setResult(NodeResultInt32);
2275                     break;
2276                 case 4:
2277                     if (data.isSigned)
2278                         node-&gt;setResult(NodeResultInt32);
2279                     else
2280                         node-&gt;setResult(NodeResultInt52);
2281                     break;
2282                 default:
2283                     RELEASE_ASSERT_NOT_REACHED();
2284                 }
2285             }
2286             break;
2287         }
2288 
2289         case DataViewSet: {
2290             fixEdge&lt;DataViewObjectUse&gt;(m_graph.varArgChild(node, 0));
2291             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
2292             if (m_graph.varArgChild(node, 3))
2293                 fixEdge&lt;BooleanUse&gt;(m_graph.varArgChild(node, 3));
2294 
2295             DataViewData data = node-&gt;dataViewData();
2296             Edge&amp; valueToStore = m_graph.varArgChild(node, 2);
2297             if (data.isFloatingPoint)
2298                 fixEdge&lt;DoubleRepUse&gt;(valueToStore);
2299             else {
2300                 switch (data.byteSize) {
2301                 case 1:
2302                 case 2:
2303                     fixEdge&lt;Int32Use&gt;(valueToStore);
2304                     break;
2305                 case 4:
2306                     if (data.isSigned)
2307                         fixEdge&lt;Int32Use&gt;(valueToStore);
2308                     else
2309                         fixEdge&lt;Int52RepUse&gt;(valueToStore);
2310                     break;
2311                 }
2312             }
2313             break;
2314         }
2315 
2316 #if !ASSERT_DISABLED
2317         // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
2318         case SetArgument:
2319         case JSConstant:
2320         case LazyJSConstant:
2321         case DoubleConstant:
2322         case GetLocal:
2323         case GetCallee:
2324         case GetArgumentCountIncludingThis:
2325         case SetArgumentCountIncludingThis:
2326         case GetRestLength:
2327         case GetArgument:
2328         case Flush:
2329         case PhantomLocal:
2330         case GetGlobalVar:
2331         case GetGlobalLexicalVariable:
2332         case NotifyWrite:
2333         case DirectCall:
2334         case CheckTypeInfoFlags:
2335         case TailCallInlinedCaller:
2336         case DirectTailCallInlinedCaller:
2337         case Construct:
2338         case DirectConstruct:
2339         case CallVarargs:
2340         case CallEval:
2341         case TailCallVarargsInlinedCaller:
2342         case ConstructVarargs:
2343         case CallForwardVarargs:
2344         case ConstructForwardVarargs:
2345         case TailCallForwardVarargs:
2346         case TailCallForwardVarargsInlinedCaller:
2347         case LoadVarargs:
2348         case ForwardVarargs:
2349         case ProfileControlFlow:
2350         case NewObject:
2351         case NewRegexp:
2352         case DeleteById:
2353         case DeleteByVal:
2354         case IsTypedArrayView:
2355         case IsEmpty:
2356         case IsUndefined:
2357         case IsUndefinedOrNull:
2358         case IsBoolean:
2359         case IsNumber:
2360         case IsObjectOrNull:
2361         case IsFunction:
2362         case CreateDirectArguments:
2363         case Jump:
2364         case Return:
2365         case TailCall:
2366         case DirectTailCall:
2367         case TailCallVarargs:
2368         case Throw:
2369         case CountExecution:
2370         case SuperSamplerBegin:
2371         case SuperSamplerEnd:
2372         case ForceOSRExit:
2373         case CheckBadCell:
2374         case CheckNotEmpty:
2375         case AssertNotEmpty:
2376         case CheckTraps:
2377         case Unreachable:
2378         case ExtractOSREntryLocal:
2379         case ExtractCatchLocal:
2380         case ClearCatchLocals:
2381         case LoopHint:
2382         case MovHint:
2383         case InitializeEntrypointArguments:
2384         case ZombieHint:
2385         case ExitOK:
2386         case BottomValue:
2387         case TypeOf:
2388         case PutByIdWithThis:
2389         case PutByValWithThis:
2390         case GetByValWithThis:
2391         case CompareEqPtr:
2392         case NumberToStringWithValidRadixConstant:
2393         case GetGlobalThis:
2394         case ExtractValueFromWeakMapGet:
2395         case CPUIntrinsic:
2396         case FilterCallLinkStatus:
2397         case FilterGetByIdStatus:
2398         case FilterPutByIdStatus:
2399         case FilterInByIdStatus:
2400         case InvalidationPoint:
2401             break;
2402 #else
2403         default:
2404             break;
2405 #endif
2406         }
2407     }
2408 
2409     void watchHavingABadTime(Node* node)
2410     {
2411         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2412 
2413         // If this global object is not having a bad time, watch it. We go down this path anytime the code
2414         // does an array allocation. The types of array allocations may change if we start to have a bad
2415         // time. It&#39;s easier to reason about this if we know that whenever the types change after we start
2416         // optimizing, the code just gets thrown out. Doing this at FixupPhase is just early enough, since
2417         // prior to this point nobody should have been doing optimizations based on the indexing type of
2418         // the allocation.
2419         if (!globalObject-&gt;isHavingABadTime()) {
2420             m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2421             m_graph.freeze(globalObject);
2422         }
2423     }
2424 
2425     template&lt;UseKind useKind&gt;
2426     void createToString(Node* node, Edge&amp; edge)
2427     {
2428         Node* toString = m_insertionSet.insertNode(
2429             m_indexInBlock, SpecString, ToString, node-&gt;origin,
2430             Edge(edge.node(), useKind));
2431         switch (useKind) {
2432         case Int32Use:
2433         case Int52RepUse:
2434         case DoubleRepUse:
2435         case NotCellUse:
2436             toString-&gt;clearFlags(NodeMustGenerate);
2437             break;
2438         default:
2439             break;
2440         }
2441         edge.setNode(toString);
2442     }
2443 
2444     template&lt;UseKind useKind&gt;
2445     void attemptToForceStringArrayModeByToStringConversion(ArrayMode&amp; arrayMode, Node* node)
2446     {
2447         ASSERT(arrayMode == ArrayMode(Array::Generic, Array::Read) || arrayMode == ArrayMode(Array::Generic, Array::OriginalNonArray, Array::Read));
2448 
2449         if (!m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic))
2450             return;
2451 
2452         addCheckStructureForOriginalStringObjectUse(useKind, node-&gt;origin, node-&gt;child1().node());
2453         createToString&lt;useKind&gt;(node, node-&gt;child1());
2454         arrayMode = ArrayMode(Array::String, Array::Read);
2455     }
2456 
2457     void addCheckStructureForOriginalStringObjectUse(UseKind useKind, const NodeOrigin&amp; origin, Node* node)
2458     {
2459         RELEASE_ASSERT(useKind == StringObjectUse || useKind == StringOrStringObjectUse);
2460 
2461         StructureSet set;
2462         set.add(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringObjectStructure());
2463         if (useKind == StringOrStringObjectUse)
2464             set.add(vm().stringStructure.get());
2465 
2466         m_insertionSet.insertNode(
2467             m_indexInBlock, SpecNone, CheckStructure, origin,
2468             OpInfo(m_graph.addStructureSet(set)), Edge(node, CellUse));
2469     }
2470 
2471     template&lt;UseKind useKind&gt;
2472     void convertStringAddUse(Node* node, Edge&amp; edge)
2473     {
2474         if (useKind == StringUse) {
2475             observeUseKindOnNode&lt;StringUse&gt;(edge.node());
2476             m_insertionSet.insertNode(
2477                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2478                 Edge(edge.node(), StringUse));
2479             edge.setUseKind(KnownStringUse);
2480             return;
2481         }
2482 
2483         observeUseKindOnNode&lt;useKind&gt;(edge.node());
2484         createToString&lt;useKind&gt;(node, edge);
2485     }
2486 
2487     void convertToMakeRope(Node* node)
2488     {
2489         node-&gt;setOpAndDefaultFlags(MakeRope);
2490         fixupMakeRope(node);
2491     }
2492 
2493     void fixupMakeRope(Node* node)
2494     {
2495         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
2496             Edge&amp; edge = node-&gt;children.child(i);
2497             if (!edge)
2498                 break;
2499             edge.setUseKind(KnownStringUse);
2500             JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm());
2501             if (!string)
2502                 continue;
2503             if (string-&gt;length())
2504                 continue;
2505 
2506             // Don&#39;t allow the MakeRope to have zero children.
2507             if (!i &amp;&amp; !node-&gt;child2())
2508                 break;
2509 
2510             node-&gt;children.removeEdge(i--);
2511         }
2512 
2513         if (!node-&gt;child2()) {
2514             ASSERT(!node-&gt;child3());
2515             node-&gt;convertToIdentity();
2516         }
2517     }
2518 
2519     void fixupIsCellWithType(Node* node)
2520     {
2521         switch (node-&gt;speculatedTypeForQuery()) {
2522         case SpecString:
2523             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2524                 m_insertionSet.insertNode(
2525                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2526                     Edge(node-&gt;child1().node(), StringUse));
2527                 m_graph.convertToConstant(node, jsBoolean(true));
2528                 observeUseKindOnNode&lt;StringUse&gt;(node);
2529                 return;
2530             }
2531             break;
2532 
2533         case SpecProxyObject:
2534             if (node-&gt;child1()-&gt;shouldSpeculateProxyObject()) {
2535                 m_insertionSet.insertNode(
2536                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2537                     Edge(node-&gt;child1().node(), ProxyObjectUse));
2538                 m_graph.convertToConstant(node, jsBoolean(true));
2539                 observeUseKindOnNode&lt;ProxyObjectUse&gt;(node);
2540                 return;
2541             }
2542             break;
2543 
2544         case SpecRegExpObject:
2545             if (node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
2546                 m_insertionSet.insertNode(
2547                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2548                     Edge(node-&gt;child1().node(), RegExpObjectUse));
2549                 m_graph.convertToConstant(node, jsBoolean(true));
2550                 observeUseKindOnNode&lt;RegExpObjectUse&gt;(node);
2551                 return;
2552             }
2553             break;
2554 
2555         case SpecArray:
2556             if (node-&gt;child1()-&gt;shouldSpeculateArray()) {
2557                 m_insertionSet.insertNode(
2558                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2559                     Edge(node-&gt;child1().node(), ArrayUse));
2560                 m_graph.convertToConstant(node, jsBoolean(true));
2561                 observeUseKindOnNode&lt;ArrayUse&gt;(node);
2562                 return;
2563             }
2564             break;
2565 
2566         case SpecDerivedArray:
2567             if (node-&gt;child1()-&gt;shouldSpeculateDerivedArray()) {
2568                 m_insertionSet.insertNode(
2569                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2570                     Edge(node-&gt;child1().node(), DerivedArrayUse));
2571                 m_graph.convertToConstant(node, jsBoolean(true));
2572                 observeUseKindOnNode&lt;DerivedArrayUse&gt;(node);
2573                 return;
2574             }
2575             break;
2576         }
2577 
2578         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2579             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2580             return;
2581         }
2582 
2583         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2584             m_insertionSet.insertNode(
2585                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2586                 Edge(node-&gt;child1().node(), NotCellUse));
2587             m_graph.convertToConstant(node, jsBoolean(false));
2588             observeUseKindOnNode&lt;NotCellUse&gt;(node);
2589             return;
2590         }
2591     }
2592 
2593     void fixupGetPrototypeOf(Node* node)
2594     {
2595         // Reflect.getPrototypeOf only accepts Objects. For Reflect.getPrototypeOf, ByteCodeParser attaches ObjectUse edge filter before fixup phase.
2596         if (node-&gt;child1().useKind() != ObjectUse) {
2597             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2598                 insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2599                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringPrototype()));
2600                 return;
2601             }
2602             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2603                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
2604                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2605                 return;
2606             }
2607             if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {
2608                 insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
2609                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2610                 return;
2611             }
2612             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2613                 insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
2614                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2615                 return;
2616             }
2617             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2618                 insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
2619                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;symbolPrototype()));
2620                 return;
2621             }
2622             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2623                 insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
2624                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;booleanPrototype()));
2625                 return;
2626             }
2627         }
2628 
2629         if (node-&gt;child1()-&gt;shouldSpeculateFinalObject()) {
2630             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2631             node-&gt;clearFlags(NodeMustGenerate);
2632             return;
2633         }
2634         if (node-&gt;child1()-&gt;shouldSpeculateArray()) {
2635             fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
2636             node-&gt;clearFlags(NodeMustGenerate);
2637             return;
2638         }
2639         if (node-&gt;child1()-&gt;shouldSpeculateFunction()) {
2640             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
2641             node-&gt;clearFlags(NodeMustGenerate);
2642             return;
2643         }
2644     }
2645 
2646     void fixupToThis(Node* node)
2647     {
2648         ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode() ? StrictMode : NotStrictMode;
2649 
2650         if (ecmaMode == StrictMode) {
2651             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2652                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2653                 node-&gt;convertToIdentity();
2654                 return;
2655             }
2656 
2657             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2658                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2659                 node-&gt;convertToIdentity();
2660                 return;
2661             }
2662 
2663             if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {
2664                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2665                 node-&gt;convertToIdentity();
2666                 node-&gt;setResult(NodeResultInt52);
2667                 return;
2668             }
2669 
2670             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2671                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2672                 node-&gt;convertToIdentity();
2673                 node-&gt;setResult(NodeResultDouble);
2674                 return;
2675             }
2676 
2677             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2678                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2679                 node-&gt;convertToIdentity();
2680                 return;
2681             }
2682 
2683             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
2684                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
2685                 node-&gt;convertToIdentity();
2686                 return;
2687             }
2688 
2689             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2690                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2691                 node-&gt;convertToIdentity();
2692                 return;
2693             }
2694 
2695             if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
2696                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
2697                 node-&gt;convertToIdentity();
2698                 return;
2699             }
2700         }
2701 
2702         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
2703             if (ecmaMode == StrictMode) {
2704                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
2705                 node-&gt;convertToIdentity();
2706                 return;
2707             }
2708 
2709             m_insertionSet.insertNode(
2710                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2711                 Edge(node-&gt;child1().node(), OtherUse));
2712             observeUseKindOnNode&lt;OtherUse&gt;(node-&gt;child1().node());
2713             m_graph.convertToConstant(
2714                 node, m_graph.globalThisObjectFor(node-&gt;origin.semantic));
2715             return;
2716         }
2717 
2718         // FIXME: This should cover other use cases but we don&#39;t have use kinds for them. It&#39;s not critical,
2719         // however, since we cover all the missing cases in constant folding.
2720         // https://bugs.webkit.org/show_bug.cgi?id=157213
2721         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
2722             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2723             node-&gt;convertToIdentity();
2724             return;
2725         }
2726 
2727         if (isFinalObjectSpeculation(node-&gt;child1()-&gt;prediction())) {
2728             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2729             node-&gt;convertToIdentity();
2730             return;
2731         }
2732     }
2733 
2734     void fixupToPrimitive(Node* node)
2735     {
2736         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2737             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2738             node-&gt;convertToIdentity();
2739             return;
2740         }
2741 
2742         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2743             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2744             node-&gt;convertToIdentity();
2745             return;
2746         }
2747 
2748         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2749             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2750             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2751             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2752             node-&gt;convertToToString();
2753             return;
2754         }
2755 
2756         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2757             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2758             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2759             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2760             node-&gt;convertToToString();
2761             return;
2762         }
2763     }
2764 
2765     void fixupToNumber(Node* node)
2766     {
2767         // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
2768         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2769             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2770                 // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
2771                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2772                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2773                     node-&gt;convertToIdentity();
2774                     return;
2775                 }
2776 
2777                 // The another case is that the predicted type of the child is Int32, but the heap prediction tell the users that this will produce non Int32 values.
2778                 // In that case, let&#39;s receive the child value as a Double value and convert it to Int32. This case happens in misc-bugs-847389-jpeg2000.
2779                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2780                 node-&gt;setOp(DoubleAsInt32);
2781                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
2782                     node-&gt;setArithMode(Arith::CheckOverflow);
2783                 else
2784                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
2785                 return;
2786             }
2787 
2788             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2789             node-&gt;convertToIdentity();
2790             node-&gt;setResult(NodeResultDouble);
2791             return;
2792         }
2793 
2794         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2795         node-&gt;setResult(NodeResultJS);
2796     }
2797 
2798     void fixupToObject(Node* node)
2799     {
2800         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2801             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2802             node-&gt;convertToIdentity();
2803             return;
2804         }
2805 
2806         // ToObject(Null/Undefined) can throw an error. We can emit filters to convert ToObject to CallObjectConstructor.
2807 
2808         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2809 
2810         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2811             insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2812             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
2813             node-&gt;convertToNewStringObject(m_graph.registerStructure(globalObject-&gt;stringObjectStructure()));
2814             return;
2815         }
2816 
2817         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2818             insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
2819             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
2820             return;
2821         }
2822 
2823         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2824             insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
2825             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
2826             return;
2827         }
2828 
2829         if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2830             insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
2831             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
2832             return;
2833         }
2834 
2835         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2836     }
2837 
2838     void fixupCallObjectConstructor(Node* node)
2839     {
2840         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2841             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2842             node-&gt;convertToIdentity();
2843             return;
2844         }
2845 
2846         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2847             auto* globalObject = jsCast&lt;JSGlobalObject*&gt;(node-&gt;cellOperand()-&gt;cell());
2848             insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2849             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
2850             node-&gt;convertToNewStringObject(m_graph.registerStructure(globalObject-&gt;stringObjectStructure()));
2851             return;
2852         }
2853 
2854         // While ToObject(Null/Undefined) throws an error, CallObjectConstructor(Null/Undefined) generates a new empty object.
2855         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
2856             insertCheck&lt;OtherUse&gt;(node-&gt;child1().node());
2857             node-&gt;convertToNewObject(m_graph.registerStructure(jsCast&lt;JSGlobalObject*&gt;(node-&gt;cellOperand()-&gt;cell())-&gt;objectStructureForObjectConstructor()));
2858             return;
2859         }
2860 
2861         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2862     }
2863 
2864     void fixupToStringOrCallStringConstructor(Node* node)
2865     {
2866         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2867             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2868             node-&gt;convertToIdentity();
2869             return;
2870         }
2871 
2872         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2873             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2874             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2875             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2876             return;
2877         }
2878 
2879         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2880             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2881             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2882             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2883             return;
2884         }
2885 
2886         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2887             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2888             return;
2889         }
2890 
2891         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2892             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2893             node-&gt;clearFlags(NodeMustGenerate);
2894             return;
2895         }
2896 
2897         if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {
2898             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2899             node-&gt;clearFlags(NodeMustGenerate);
2900             return;
2901         }
2902 
2903         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2904             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2905             node-&gt;clearFlags(NodeMustGenerate);
2906             return;
2907         }
2908 
2909         // ToString(Symbol) throws an error. So if the child1 can include Symbols,
2910         // we need to care about it in the clobberize. In the following case,
2911         // since NotCellUse edge filter is used and this edge filters Symbols,
2912         // we can say that ToString never throws an error!
2913         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2914             fixEdge&lt;NotCellUse&gt;(node-&gt;child1());
2915             node-&gt;clearFlags(NodeMustGenerate);
2916             return;
2917         }
2918     }
2919 
2920     void fixupStringValueOf(Node* node)
2921     {
2922         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2923             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2924             node-&gt;convertToIdentity();
2925             return;
2926         }
2927 
2928         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
2929             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2930             node-&gt;convertToToString();
2931             // It does not need to look up a toString property for the StringObject case. So we can clear NodeMustGenerate.
2932             node-&gt;clearFlags(NodeMustGenerate);
2933             return;
2934         }
2935 
2936         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()) {
2937             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2938             node-&gt;convertToToString();
2939             // It does not need to look up a toString property for the StringObject case. So we can clear NodeMustGenerate.
2940             node-&gt;clearFlags(NodeMustGenerate);
2941             return;
2942         }
2943     }
2944 
2945     bool attemptToMakeFastStringAdd(Node* node)
2946     {
2947         bool goodToGo = true;
2948         m_graph.doToChildren(
2949             node,
2950             [&amp;] (Edge&amp; edge) {
2951                 if (edge-&gt;shouldSpeculateString())
2952                     return;
2953                 if (m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2954                     if (edge-&gt;shouldSpeculateStringObject())
2955                         return;
2956                     if (edge-&gt;shouldSpeculateStringOrStringObject())
2957                         return;
2958                 }
2959                 goodToGo = false;
2960             });
2961         if (!goodToGo)
2962             return false;
2963 
2964         m_graph.doToChildren(
2965             node,
2966             [&amp;] (Edge&amp; edge) {
2967                 if (edge-&gt;shouldSpeculateString()) {
2968                     convertStringAddUse&lt;StringUse&gt;(node, edge);
2969                     return;
2970                 }
2971                 if (!Options::useConcurrentJIT())
2972                     ASSERT(m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic));
2973                 if (edge-&gt;shouldSpeculateStringObject()) {
2974                     addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, edge.node());
2975                     convertStringAddUse&lt;StringObjectUse&gt;(node, edge);
2976                     return;
2977                 }
2978                 if (edge-&gt;shouldSpeculateStringOrStringObject()) {
2979                     addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, edge.node());
2980                     convertStringAddUse&lt;StringOrStringObjectUse&gt;(node, edge);
2981                     return;
2982                 }
2983                 RELEASE_ASSERT_NOT_REACHED();
2984             });
2985 
2986         convertToMakeRope(node);
2987         return true;
2988     }
2989 
2990     void fixupGetAndSetLocalsInBlock(BasicBlock* block)
2991     {
2992         if (!block)
2993             return;
2994         ASSERT(block-&gt;isReachable);
2995         m_block = block;
2996         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
2997             Node* node = m_currentNode = block-&gt;at(m_indexInBlock);
2998             if (node-&gt;op() != SetLocal &amp;&amp; node-&gt;op() != GetLocal)
2999                 continue;
3000 
3001             VariableAccessData* variable = node-&gt;variableAccessData();
3002             switch (node-&gt;op()) {
3003             case GetLocal:
3004                 switch (variable-&gt;flushFormat()) {
3005                 case FlushedDouble:
3006                     node-&gt;setResult(NodeResultDouble);
3007                     break;
3008                 case FlushedInt52:
3009                     node-&gt;setResult(NodeResultInt52);
3010                     break;
3011                 default:
3012                     break;
3013                 }
3014                 break;
3015 
3016             case SetLocal:
3017                 // NOTE: Any type checks we put here may get hoisted by fixupChecksInBlock(). So, if we
3018                 // add new type checking use kind for SetLocals, we need to modify that code as well.
3019 
3020                 switch (variable-&gt;flushFormat()) {
3021                 case FlushedJSValue:
3022                     break;
3023                 case FlushedDouble:
3024                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3025                     break;
3026                 case FlushedInt32:
3027                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3028                     break;
3029                 case FlushedInt52:
3030                     fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3031                     break;
3032                 case FlushedCell:
3033                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
3034                     break;
3035                 case FlushedBoolean:
3036                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3037                     break;
3038                 default:
3039                     RELEASE_ASSERT_NOT_REACHED();
3040                     break;
3041                 }
3042                 break;
3043 
3044             default:
3045                 RELEASE_ASSERT_NOT_REACHED();
3046                 break;
3047             }
3048         }
3049         m_insertionSet.execute(block);
3050     }
3051 
3052     void addStringReplacePrimordialChecks(Node* searchRegExp)
3053     {
3054         Node* node = m_currentNode;
3055 
3056         // Check that structure of searchRegExp is RegExp object
3057         m_insertionSet.insertNode(
3058             m_indexInBlock, SpecNone, Check, node-&gt;origin,
3059             Edge(searchRegExp, RegExpObjectUse));
3060 
3061         auto emitPrimordialCheckFor = [&amp;] (JSValue primordialProperty, UniquedStringImpl* propertyUID) {
3062             unsigned index = m_graph.identifiers().ensure(propertyUID);
3063 
3064             Node* actualProperty = m_insertionSet.insertNode(
3065                 m_indexInBlock, SpecNone, TryGetById, node-&gt;origin,
3066                 OpInfo(index), OpInfo(SpecFunction), Edge(searchRegExp, CellUse));
3067 
3068             m_insertionSet.insertNode(
3069                 m_indexInBlock, SpecNone, CheckCell, node-&gt;origin,
3070                 OpInfo(m_graph.freeze(primordialProperty)), Edge(actualProperty, CellUse));
3071         };
3072 
3073         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
3074 
3075         // Check that searchRegExp.exec is the primordial RegExp.prototype.exec
3076         emitPrimordialCheckFor(globalObject-&gt;regExpProtoExecFunction(), vm().propertyNames-&gt;exec.impl());
3077         // Check that searchRegExp.global is the primordial RegExp.prototype.global
3078         emitPrimordialCheckFor(globalObject-&gt;regExpProtoGlobalGetter(), vm().propertyNames-&gt;global.impl());
3079         // Check that searchRegExp.unicode is the primordial RegExp.prototype.unicode
3080         emitPrimordialCheckFor(globalObject-&gt;regExpProtoUnicodeGetter(), vm().propertyNames-&gt;unicode.impl());
3081         // Check that searchRegExp[Symbol.match] is the primordial RegExp.prototype[Symbol.replace]
3082         emitPrimordialCheckFor(globalObject-&gt;regExpProtoSymbolReplaceFunction(), vm().propertyNames-&gt;replaceSymbol.impl());
3083     }
3084 
3085     Node* checkArray(ArrayMode arrayMode, const NodeOrigin&amp; origin, Node* array, Node* index, bool (*storageCheck)(const ArrayMode&amp;) = canCSEStorage)
3086     {
3087         ASSERT(arrayMode.isSpecific());
3088 
3089         if (arrayMode.type() == Array::String) {
3090             m_insertionSet.insertNode(
3091                 m_indexInBlock, SpecNone, Check, origin, Edge(array, StringUse));
3092         } else {
3093             // Note that we only need to be using a structure check if we opt for SaneChain, since
3094             // that needs to protect against JSArray&#39;s __proto__ being changed.
3095             Structure* structure = arrayMode.originalArrayStructure(m_graph, origin.semantic);
3096 
3097             Edge indexEdge = index ? Edge(index, Int32Use) : Edge();
3098 
3099             if (arrayMode.doesConversion()) {
3100                 if (structure) {
3101                     m_insertionSet.insertNode(
3102                         m_indexInBlock, SpecNone, ArrayifyToStructure, origin,
3103                         OpInfo(m_graph.registerStructure(structure)), OpInfo(arrayMode.asWord()), Edge(array, CellUse), indexEdge);
3104                 } else {
3105                     m_insertionSet.insertNode(
3106                         m_indexInBlock, SpecNone, Arrayify, origin,
3107                         OpInfo(arrayMode.asWord()), Edge(array, CellUse), indexEdge);
3108                 }
3109             } else {
3110                 if (structure) {
3111                     m_insertionSet.insertNode(
3112                         m_indexInBlock, SpecNone, CheckStructure, origin,
3113                         OpInfo(m_graph.addStructureSet(structure)), Edge(array, CellUse));
3114                 } else {
3115                     m_insertionSet.insertNode(
3116                         m_indexInBlock, SpecNone, CheckArray, origin,
3117                         OpInfo(arrayMode.asWord()), Edge(array, CellUse));
3118                 }
3119             }
3120         }
3121 
3122         if (!storageCheck(arrayMode))
3123             return nullptr;
3124 
3125         if (arrayMode.usesButterfly()) {
3126             return m_insertionSet.insertNode(
3127                 m_indexInBlock, SpecNone, GetButterfly, origin, Edge(array, CellUse));
3128         }
3129 
3130         return m_insertionSet.insertNode(
3131             m_indexInBlock, SpecNone, GetIndexedPropertyStorage, origin,
3132             OpInfo(arrayMode.asWord()), Edge(array, KnownCellUse));
3133     }
3134 
3135     void blessArrayOperation(Edge base, Edge index, Edge&amp; storageChild)
3136     {
3137         Node* node = m_currentNode;
3138 
3139         switch (node-&gt;arrayMode().type()) {
3140         case Array::ForceExit: {
3141             m_insertionSet.insertNode(
3142                 m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
3143             return;
3144         }
3145 
3146         case Array::SelectUsingPredictions:
3147         case Array::Unprofiled:
3148             RELEASE_ASSERT_NOT_REACHED();
3149             return;
3150 
3151         case Array::Generic:
3152             return;
3153 
3154         default: {
3155             Node* storage = checkArray(node-&gt;arrayMode(), node-&gt;origin, base.node(), index.node());
3156             if (!storage)
3157                 return;
3158 
3159             storageChild = Edge(storage);
3160             return;
3161         } }
3162     }
3163 
3164     bool alwaysUnboxSimplePrimitives()
3165     {
3166 #if USE(JSVALUE64)
3167         return false;
3168 #else
3169         // Any boolean, int, or cell value is profitable to unbox on 32-bit because it
3170         // reduces traffic.
3171         return true;
3172 #endif
3173     }
3174 
3175     template&lt;UseKind useKind&gt;
3176     void observeUseKindOnNode(Node* node)
3177     {
3178         if (useKind == UntypedUse)
3179             return;
3180         observeUseKindOnNode(node, useKind);
3181     }
3182 
3183     void observeUseKindOnEdge(Edge edge)
3184     {
3185         observeUseKindOnNode(edge.node(), edge.useKind());
3186     }
3187 
3188     void observeUseKindOnNode(Node* node, UseKind useKind)
3189     {
3190         if (node-&gt;op() != GetLocal)
3191             return;
3192 
3193         // FIXME: The way this uses alwaysUnboxSimplePrimitives() is suspicious.
3194         // https://bugs.webkit.org/show_bug.cgi?id=121518
3195 
3196         VariableAccessData* variable = node-&gt;variableAccessData();
3197         switch (useKind) {
3198         case Int32Use:
3199         case KnownInt32Use:
3200             if (alwaysUnboxSimplePrimitives()
3201                 || isInt32Speculation(variable-&gt;prediction()))
3202                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3203             break;
3204         case NumberUse:
3205         case RealNumberUse:
3206         case DoubleRepUse:
3207         case DoubleRepRealUse:
3208             if (variable-&gt;doubleFormatState() == UsingDoubleFormat)
3209                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3210             break;
3211         case BooleanUse:
3212         case KnownBooleanUse:
3213             if (alwaysUnboxSimplePrimitives()
3214                 || isBooleanSpeculation(variable-&gt;prediction()))
3215                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3216             break;
3217         case Int52RepUse:
3218             if (isAnyIntSpeculation(variable-&gt;prediction()))
3219                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3220             break;
3221         case CellUse:
3222         case KnownCellUse:
3223         case ObjectUse:
3224         case FunctionUse:
3225         case StringUse:
3226         case KnownStringUse:
3227         case SymbolUse:
3228         case BigIntUse:
3229         case StringObjectUse:
3230         case StringOrStringObjectUse:
3231             if (alwaysUnboxSimplePrimitives()
3232                 || isCellSpeculation(variable-&gt;prediction()))
3233                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3234             break;
3235         default:
3236             break;
3237         }
3238     }
3239 
3240     template&lt;UseKind useKind&gt;
3241     void fixEdge(Edge&amp; edge)
3242     {
3243         observeUseKindOnNode&lt;useKind&gt;(edge.node());
3244         edge.setUseKind(useKind);
3245     }
3246 
3247     unsigned indexForChecks()
3248     {
3249         unsigned index = m_indexInBlock;
3250         while (!m_block-&gt;at(index)-&gt;origin.exitOK)
3251             index--;
3252         return index;
3253     }
3254 
3255     NodeOrigin originForCheck(unsigned index)
3256     {
3257         return m_block-&gt;at(index)-&gt;origin.withSemantic(m_currentNode-&gt;origin.semantic);
3258     }
3259 
3260     void speculateForBarrier(Edge value)
3261     {
3262         // Currently, the DFG won&#39;t take advantage of this speculation. But, we want to do it in
3263         // the DFG anyway because if such a speculation would be wrong, we want to know before
3264         // we do an expensive compile.
3265 
3266         if (value-&gt;shouldSpeculateInt32()) {
3267             insertCheck&lt;Int32Use&gt;(value.node());
3268             return;
3269         }
3270 
3271         if (value-&gt;shouldSpeculateBoolean()) {
3272             insertCheck&lt;BooleanUse&gt;(value.node());
3273             return;
3274         }
3275 
3276         if (value-&gt;shouldSpeculateOther()) {
3277             insertCheck&lt;OtherUse&gt;(value.node());
3278             return;
3279         }
3280 
3281         if (value-&gt;shouldSpeculateNumber()) {
3282             insertCheck&lt;NumberUse&gt;(value.node());
3283             return;
3284         }
3285 
3286         if (value-&gt;shouldSpeculateNotCell()) {
3287             insertCheck&lt;NotCellUse&gt;(value.node());
3288             return;
3289         }
3290     }
3291 
3292     template&lt;UseKind useKind&gt;
3293     void insertCheck(Node* node)
3294     {
3295         observeUseKindOnNode&lt;useKind&gt;(node);
3296         unsigned index = indexForChecks();
3297         m_insertionSet.insertNode(index, SpecNone, Check, originForCheck(index), Edge(node, useKind));
3298     }
3299 
3300     void fixIntConvertingEdge(Edge&amp; edge)
3301     {
3302         Node* node = edge.node();
3303         if (node-&gt;shouldSpeculateInt32OrBoolean()) {
3304             fixIntOrBooleanEdge(edge);
3305             return;
3306         }
3307 
3308         UseKind useKind;
3309         if (node-&gt;shouldSpeculateAnyInt())
3310             useKind = Int52RepUse;
3311         else if (node-&gt;shouldSpeculateNumber())
3312             useKind = DoubleRepUse;
3313         else
3314             useKind = NotCellUse;
3315         Node* newNode = m_insertionSet.insertNode(
3316             m_indexInBlock, SpecInt32Only, ValueToInt32, m_currentNode-&gt;origin,
3317             Edge(node, useKind));
3318         observeUseKindOnNode(node, useKind);
3319 
3320         edge = Edge(newNode, KnownInt32Use);
3321     }
3322 
3323     void fixIntOrBooleanEdge(Edge&amp; edge)
3324     {
3325         Node* node = edge.node();
3326         if (!node-&gt;sawBooleans()) {
3327             fixEdge&lt;Int32Use&gt;(edge);
3328             return;
3329         }
3330 
3331         UseKind useKind;
3332         if (node-&gt;shouldSpeculateBoolean())
3333             useKind = BooleanUse;
3334         else
3335             useKind = UntypedUse;
3336         Node* newNode = m_insertionSet.insertNode(
3337             m_indexInBlock, SpecInt32Only, BooleanToNumber, m_currentNode-&gt;origin,
3338             Edge(node, useKind));
3339         observeUseKindOnNode(node, useKind);
3340 
3341         edge = Edge(newNode, Int32Use);
3342     }
3343 
3344     void fixDoubleOrBooleanEdge(Edge&amp; edge)
3345     {
3346         Node* node = edge.node();
3347         if (!node-&gt;sawBooleans()) {
3348             fixEdge&lt;DoubleRepUse&gt;(edge);
3349             return;
3350         }
3351 
3352         UseKind useKind;
3353         if (node-&gt;shouldSpeculateBoolean())
3354             useKind = BooleanUse;
3355         else
3356             useKind = UntypedUse;
3357         Node* newNode = m_insertionSet.insertNode(
3358             m_indexInBlock, SpecInt32Only, BooleanToNumber, m_currentNode-&gt;origin,
3359             Edge(node, useKind));
3360         observeUseKindOnNode(node, useKind);
3361 
3362         edge = Edge(newNode, DoubleRepUse);
3363     }
3364 
3365     void truncateConstantToInt32(Edge&amp; edge)
3366     {
3367         Node* oldNode = edge.node();
3368 
3369         JSValue value = oldNode-&gt;asJSValue();
3370         if (value.isInt32())
3371             return;
3372 
3373         value = jsNumber(JSC::toInt32(value.asNumber()));
3374         ASSERT(value.isInt32());
3375         edge.setNode(m_insertionSet.insertNode(
3376             m_indexInBlock, SpecInt32Only, JSConstant, m_currentNode-&gt;origin,
3377             OpInfo(m_graph.freeze(value))));
3378     }
3379 
3380     void truncateConstantsIfNecessary(Node* node, AddSpeculationMode mode)
3381     {
3382         if (mode != SpeculateInt32AndTruncateConstants)
3383             return;
3384 
3385         ASSERT(node-&gt;child1()-&gt;hasConstant() || node-&gt;child2()-&gt;hasConstant());
3386         if (node-&gt;child1()-&gt;hasConstant())
3387             truncateConstantToInt32(node-&gt;child1());
3388         else
3389             truncateConstantToInt32(node-&gt;child2());
3390     }
3391 
3392     bool attemptToMakeIntegerAdd(Node* node)
3393     {
3394         AddSpeculationMode mode = m_graph.addSpeculationMode(node, FixupPass);
3395         if (mode != DontSpeculateInt32) {
3396             truncateConstantsIfNecessary(node, mode);
3397             fixIntOrBooleanEdge(node-&gt;child1());
3398             fixIntOrBooleanEdge(node-&gt;child2());
3399             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
3400                 node-&gt;setArithMode(Arith::Unchecked);
3401             else
3402                 node-&gt;setArithMode(Arith::CheckOverflow);
3403             return true;
3404         }
3405 
3406         if (m_graph.addShouldSpeculateAnyInt(node)) {
3407             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3408             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3409             node-&gt;setArithMode(Arith::CheckOverflow);
3410             node-&gt;setResult(NodeResultInt52);
3411             return true;
3412         }
3413 
3414         return false;
3415     }
3416 
3417     bool attemptToMakeGetArrayLength(Node* node)
3418     {
3419         if (!isInt32Speculation(node-&gt;prediction()))
3420             return false;
3421         CodeBlock* profiledBlock = m_graph.baselineCodeBlockFor(node-&gt;origin.semantic);
3422         ArrayProfile* arrayProfile =
3423             profiledBlock-&gt;getArrayProfile(node-&gt;origin.semantic.bytecodeIndex);
3424         ArrayMode arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3425         if (arrayProfile) {
3426             ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
3427             arrayProfile-&gt;computeUpdatedPrediction(locker, profiledBlock);
3428             arrayMode = ArrayMode::fromObserved(locker, arrayProfile, Array::Read, false);
3429             if (arrayMode.type() == Array::Unprofiled) {
3430                 // For normal array operations, it makes sense to treat Unprofiled
3431                 // accesses as ForceExit and get more data rather than using
3432                 // predictions and then possibly ending up with a Generic. But here,
3433                 // we treat anything that is Unprofiled as Generic and keep the
3434                 // GetById. I.e. ForceExit = Generic. So, there is no harm - and only
3435                 // profit - from treating the Unprofiled case as
3436                 // SelectUsingPredictions.
3437                 arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3438             }
3439         }
3440 
3441         arrayMode = arrayMode.refine(
3442             m_graph, node, node-&gt;child1()-&gt;prediction(), node-&gt;prediction());
3443 
3444         if (arrayMode.type() == Array::Generic) {
3445             // Check if the input is something that we can&#39;t get array length for, but for which we
3446             // could insert some conversions in order to transform it into something that we can do it
3447             // for.
3448             if (node-&gt;child1()-&gt;shouldSpeculateStringObject())
3449                 attemptToForceStringArrayModeByToStringConversion&lt;StringObjectUse&gt;(arrayMode, node);
3450             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject())
3451                 attemptToForceStringArrayModeByToStringConversion&lt;StringOrStringObjectUse&gt;(arrayMode, node);
3452         }
3453 
3454         if (!arrayMode.supportsSelfLength())
3455             return false;
3456 
3457         convertToGetArrayLength(node, arrayMode);
3458         return true;
3459     }
3460 
3461     void convertToGetArrayLength(Node* node, ArrayMode arrayMode)
3462     {
3463         node-&gt;setOp(GetArrayLength);
3464         node-&gt;clearFlags(NodeMustGenerate);
3465         fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
3466         node-&gt;setArrayMode(arrayMode);
3467 
3468         Node* storage = checkArray(arrayMode, node-&gt;origin, node-&gt;child1().node(), 0, lengthNeedsStorage);
3469         if (!storage)
3470             return;
3471 
3472         node-&gt;child2() = Edge(storage);
3473     }
3474 
3475     Node* prependGetArrayLength(NodeOrigin origin, Node* child, ArrayMode arrayMode)
3476     {
3477         Node* storage = checkArray(arrayMode, origin, child, 0, lengthNeedsStorage);
3478         return m_insertionSet.insertNode(
3479             m_indexInBlock, SpecInt32Only, GetArrayLength, origin,
3480             OpInfo(arrayMode.asWord()), Edge(child, KnownCellUse), Edge(storage));
3481     }
3482 
3483     void convertToHasIndexedProperty(Node* node)
3484     {
3485         node-&gt;setOp(HasIndexedProperty);
3486         node-&gt;clearFlags(NodeMustGenerate);
3487 
3488         {
3489             unsigned firstChild = m_graph.m_varArgChildren.size();
3490             unsigned numChildren = 3;
3491             m_graph.m_varArgChildren.append(node-&gt;child1());
3492             m_graph.m_varArgChildren.append(node-&gt;child2());
3493             m_graph.m_varArgChildren.append(Edge());
3494             node-&gt;mergeFlags(NodeHasVarArgs);
3495             node-&gt;children = AdjacencyList(AdjacencyList::Variable, firstChild, numChildren);
3496         }
3497 
3498         node-&gt;setArrayMode(
3499             node-&gt;arrayMode().refine(
3500                 m_graph, node,
3501                 m_graph.varArgChild(node, 0)-&gt;prediction(),
3502                 m_graph.varArgChild(node, 1)-&gt;prediction(),
3503                 SpecNone));
3504         node-&gt;setInternalMethodType(PropertySlot::InternalMethodType::HasProperty);
3505 
3506         blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
3507 
3508         fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
3509         fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
3510     }
3511 
3512     void fixupNormalizeMapKey(Node* node)
3513     {
3514         if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
3515             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3516             node-&gt;convertToIdentity();
3517             return;
3518         }
3519 
3520         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
3521             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3522             node-&gt;convertToIdentity();
3523             return;
3524         }
3525 
3526         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
3527             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3528             node-&gt;convertToIdentity();
3529             return;
3530         }
3531 
3532         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3533             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3534             node-&gt;convertToIdentity();
3535             return;
3536         }
3537 
3538         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
3539             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3540             node-&gt;convertToIdentity();
3541             return;
3542         }
3543 
3544         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
3545             fixEdge&lt;CellUse&gt;(node-&gt;child1());
3546             node-&gt;convertToIdentity();
3547             return;
3548         }
3549 
3550         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
3551     }
3552 
3553     bool attemptToMakeCallDOM(Node* node)
3554     {
3555         if (m_graph.hasExitSite(node-&gt;origin.semantic, BadType))
3556             return false;
3557 
3558         const DOMJIT::Signature* signature = node-&gt;signature();
3559         if (!signature)
3560             return false;
3561 
3562         {
3563             unsigned index = 0;
3564             bool shouldConvertToCallDOM = true;
3565             m_graph.doToChildren(node, [&amp;](Edge&amp; edge) {
3566                 // Callee. Ignore this. DFGByteCodeParser already emit appropriate checks.
3567                 if (!index)
3568                     return;
3569 
3570                 if (index == 1) {
3571                     // DOM node case.
3572                     if (edge-&gt;shouldSpeculateNotCell())
3573                         shouldConvertToCallDOM = false;
3574                 } else {
3575                     switch (signature-&gt;arguments[index - 2]) {
3576                     case SpecString:
3577                         if (edge-&gt;shouldSpeculateNotString())
3578                             shouldConvertToCallDOM = false;
3579                         break;
3580                     case SpecInt32Only:
3581                         if (edge-&gt;shouldSpeculateNotInt32())
3582                             shouldConvertToCallDOM = false;
3583                         break;
3584                     case SpecBoolean:
3585                         if (edge-&gt;shouldSpeculateNotBoolean())
3586                             shouldConvertToCallDOM = false;
3587                         break;
3588                     default:
3589                         RELEASE_ASSERT_NOT_REACHED();
3590                         break;
3591                     }
3592                 }
3593                 ++index;
3594             });
3595             if (!shouldConvertToCallDOM)
3596                 return false;
3597         }
3598 
3599         Node* thisNode = m_graph.varArgChild(node, 1).node();
3600         Node* checkSubClass = m_insertionSet.insertNode(m_indexInBlock, SpecNone, CheckSubClass, node-&gt;origin, OpInfo(signature-&gt;classInfo), Edge(thisNode));
3601         node-&gt;convertToCallDOM(m_graph);
3602         fixupCheckSubClass(checkSubClass);
3603         fixupCallDOM(node);
3604         return true;
3605     }
3606 
3607     void fixupCheckSubClass(Node* node)
3608     {
3609         fixEdge&lt;CellUse&gt;(node-&gt;child1());
3610     }
3611 
3612     void fixupCallDOM(Node* node)
3613     {
3614         const DOMJIT::Signature* signature = node-&gt;signature();
3615         auto fixup = [&amp;](Edge&amp; edge, unsigned argumentIndex) {
3616             if (!edge)
3617                 return;
3618             switch (signature-&gt;arguments[argumentIndex]) {
3619             case SpecString:
3620                 fixEdge&lt;StringUse&gt;(edge);
3621                 break;
3622             case SpecInt32Only:
3623                 fixEdge&lt;Int32Use&gt;(edge);
3624                 break;
3625             case SpecBoolean:
3626                 fixEdge&lt;BooleanUse&gt;(edge);
3627                 break;
3628             default:
3629                 RELEASE_ASSERT_NOT_REACHED();
3630                 break;
3631             }
3632         };
3633         fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
3634         fixup(node-&gt;child2(), 0);
3635         fixup(node-&gt;child3(), 1);
3636     }
3637 
3638     void fixupArrayIndexOf(Node* node)
3639     {
3640         Edge&amp; array = m_graph.varArgChild(node, 0);
3641         Edge&amp; storage = m_graph.varArgChild(node, node-&gt;numChildren() == 3 ? 2 : 3);
3642         blessArrayOperation(array, Edge(), storage);
3643         ASSERT_WITH_MESSAGE(storage.node(), &quot;blessArrayOperation for ArrayIndexOf must set Butterfly for storage edge.&quot;);
3644 
3645         Edge&amp; searchElement = m_graph.varArgChild(node, 1);
3646 
3647         // Constant folding.
3648         switch (node-&gt;arrayMode().type()) {
3649         case Array::Double:
3650         case Array::Int32: {
3651             if (searchElement-&gt;shouldSpeculateCell()) {
3652                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), CellUse));
3653                 m_graph.convertToConstant(node, jsNumber(-1));
3654                 observeUseKindOnNode&lt;CellUse&gt;(searchElement.node());
3655                 return;
3656             }
3657 
3658             if (searchElement-&gt;shouldSpeculateOther()) {
3659                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), OtherUse));
3660                 m_graph.convertToConstant(node, jsNumber(-1));
3661                 observeUseKindOnNode&lt;OtherUse&gt;(searchElement.node());
3662                 return;
3663             }
3664 
3665             if (searchElement-&gt;shouldSpeculateBoolean()) {
3666                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), BooleanUse));
3667                 m_graph.convertToConstant(node, jsNumber(-1));
3668                 observeUseKindOnNode&lt;BooleanUse&gt;(searchElement.node());
3669                 return;
3670             }
3671             break;
3672         }
3673         default:
3674             break;
3675         }
3676 
3677         fixEdge&lt;KnownCellUse&gt;(array);
3678         if (node-&gt;numChildren() == 4)
3679             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
3680 
3681         switch (node-&gt;arrayMode().type()) {
3682         case Array::Double: {
3683             if (searchElement-&gt;shouldSpeculateNumber())
3684                 fixEdge&lt;DoubleRepUse&gt;(searchElement);
3685             return;
3686         }
3687         case Array::Int32: {
3688             if (searchElement-&gt;shouldSpeculateInt32())
3689                 fixEdge&lt;Int32Use&gt;(searchElement);
3690             return;
3691         }
3692         case Array::Contiguous: {
3693             if (searchElement-&gt;shouldSpeculateString())
3694                 fixEdge&lt;StringUse&gt;(searchElement);
3695             else if (searchElement-&gt;shouldSpeculateSymbol())
3696                 fixEdge&lt;SymbolUse&gt;(searchElement);
3697             else if (searchElement-&gt;shouldSpeculateOther())
3698                 fixEdge&lt;OtherUse&gt;(searchElement);
3699             else if (searchElement-&gt;shouldSpeculateObject())
3700                 fixEdge&lt;ObjectUse&gt;(searchElement);
3701             return;
3702         }
3703         default:
3704             RELEASE_ASSERT_NOT_REACHED();
3705             return;
3706         }
3707     }
3708 
3709     void fixupCompareStrictEqAndSameValue(Node* node)
3710     {
3711         ASSERT(node-&gt;op() == SameValue || node-&gt;op() == CompareStrictEq);
3712 
3713         if (Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
3714             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3715             fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
3716             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3717             return;
3718         }
3719         if (Node::shouldSpeculateInt32(node-&gt;child1().node(), node-&gt;child2().node())) {
3720             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3721             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
3722             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3723             return;
3724         }
3725         if (enableInt52()
3726             &amp;&amp; Node::shouldSpeculateAnyInt(node-&gt;child1().node(), node-&gt;child2().node())) {
3727             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3728             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3729             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3730             return;
3731         }
3732         if (Node::shouldSpeculateNumber(node-&gt;child1().node(), node-&gt;child2().node())) {
3733             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3734             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
3735             // Do not convert SameValue to CompareStrictEq in this case since SameValue(NaN, NaN) and SameValue(-0, +0)
3736             // are not the same to CompareStrictEq(NaN, NaN) and CompareStrictEq(-0, +0).
3737             return;
3738         }
3739         if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
3740             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3741             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3742             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3743             return;
3744         }
3745         if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
3746             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
3747             fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
3748             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3749             return;
3750         }
3751         if (node-&gt;child1()-&gt;shouldSpeculateStringIdent() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateStringIdent()) {
3752             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
3753             fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
3754             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3755             return;
3756         }
3757         if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 7) || m_graph.m_plan.isFTL())) {
3758             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3759             fixEdge&lt;StringUse&gt;(node-&gt;child2());
3760             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3761             return;
3762         }
3763 
3764         if (node-&gt;op() == SameValue) {
3765             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3766                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3767                 node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3768                 return;
3769             }
3770             if (node-&gt;child2()-&gt;shouldSpeculateObject()) {
3771                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3772                 node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3773                 return;
3774             }
3775         } else {
3776             WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
3777             if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid()) {
3778                 if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3779                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
3780                     fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3781                     return;
3782                 }
3783                 if (node-&gt;child2()-&gt;shouldSpeculateObject()) {
3784                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
3785                     fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3786                     return;
3787                 }
3788             } else if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
3789                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3790                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3791                 return;
3792             }
3793         }
3794 
3795         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
3796             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3797             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3798             return;
3799         }
3800         if (node-&gt;child2()-&gt;shouldSpeculateSymbol()) {
3801             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3802             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3803             return;
3804         }
3805         if (node-&gt;child1()-&gt;shouldSpeculateMisc()) {
3806             fixEdge&lt;MiscUse&gt;(node-&gt;child1());
3807             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3808             return;
3809         }
3810         if (node-&gt;child2()-&gt;shouldSpeculateMisc()) {
3811             fixEdge&lt;MiscUse&gt;(node-&gt;child2());
3812             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3813             return;
3814         }
3815         if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()
3816             &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotStringVar()) {
3817             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
3818             fixEdge&lt;NotStringVarUse&gt;(node-&gt;child2());
3819             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3820             return;
3821         }
3822         if (node-&gt;child2()-&gt;shouldSpeculateStringIdent()
3823             &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotStringVar()) {
3824             fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
3825             fixEdge&lt;NotStringVarUse&gt;(node-&gt;child1());
3826             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3827             return;
3828         }
3829         if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 8) || m_graph.m_plan.isFTL())) {
3830             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3831             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3832             return;
3833         }
3834         if (node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 8) || m_graph.m_plan.isFTL())) {
3835             fixEdge&lt;StringUse&gt;(node-&gt;child2());
3836             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3837             return;
3838         }
3839     }
3840 
3841     void fixupChecksInBlock(BasicBlock* block)
3842     {
3843         if (!block)
3844             return;
3845         ASSERT(block-&gt;isReachable);
3846         m_block = block;
3847         unsigned indexForChecks = UINT_MAX;
3848         NodeOrigin originForChecks;
3849         for (unsigned indexInBlock = 0; indexInBlock &lt; block-&gt;size(); ++indexInBlock) {
3850             Node* node = block-&gt;at(indexInBlock);
3851 
3852             // If this is a node at which we could exit, then save its index. If nodes after this one
3853             // cannot exit, then we will hoist checks to here.
3854             if (node-&gt;origin.exitOK) {
3855                 indexForChecks = indexInBlock;
3856                 originForChecks = node-&gt;origin;
3857             }
3858 
3859             originForChecks = originForChecks.withSemantic(node-&gt;origin.semantic);
3860 
3861             // First, try to relax the representational demands of each node, in order to have
3862             // fewer conversions.
3863             switch (node-&gt;op()) {
3864             case MovHint:
3865             case Check:
3866             case CheckVarargs:
3867                 m_graph.doToChildren(
3868                     node,
3869                     [&amp;] (Edge&amp; edge) {
3870                         switch (edge.useKind()) {
3871                         case DoubleRepUse:
3872                         case DoubleRepRealUse:
3873                             if (edge-&gt;hasDoubleResult())
3874                                 break;
3875 
3876                             if (edge-&gt;hasInt52Result())
3877                                 edge.setUseKind(Int52RepUse);
3878                             else if (edge.useKind() == DoubleRepUse)
3879                                 edge.setUseKind(NumberUse);
3880                             break;
3881 
3882                         case Int52RepUse:
3883                             // Nothing we can really do.
3884                             break;
3885 
3886                         case UntypedUse:
3887                         case NumberUse:
3888                             if (edge-&gt;hasDoubleResult())
3889                                 edge.setUseKind(DoubleRepUse);
3890                             else if (edge-&gt;hasInt52Result())
3891                                 edge.setUseKind(Int52RepUse);
3892                             break;
3893 
3894                         case RealNumberUse:
3895                             if (edge-&gt;hasDoubleResult())
3896                                 edge.setUseKind(DoubleRepRealUse);
3897                             else if (edge-&gt;hasInt52Result())
3898                                 edge.setUseKind(Int52RepUse);
3899                             break;
3900 
3901                         default:
3902                             break;
3903                         }
3904                     });
3905                 break;
3906 
3907             case ValueToInt32:
3908                 if (node-&gt;child1().useKind() == DoubleRepUse
3909                     &amp;&amp; !node-&gt;child1()-&gt;hasDoubleResult()) {
3910                     node-&gt;child1().setUseKind(NumberUse);
3911                     break;
3912                 }
3913                 break;
3914 
3915             default:
3916                 break;
3917             }
3918 
3919             // Now, insert type conversions if necessary.
3920             m_graph.doToChildren(
3921                 node,
3922                 [&amp;] (Edge&amp; edge) {
3923                     Node* result = nullptr;
3924 
3925                     switch (edge.useKind()) {
3926                     case DoubleRepUse:
3927                     case DoubleRepRealUse:
3928                     case DoubleRepAnyIntUse: {
3929                         if (edge-&gt;hasDoubleResult())
3930                             break;
3931 
3932                         ASSERT(indexForChecks != UINT_MAX);
3933                         if (edge-&gt;isNumberConstant()) {
3934                             result = m_insertionSet.insertNode(
3935                                 indexForChecks, SpecBytecodeDouble, DoubleConstant, originForChecks,
3936                                 OpInfo(m_graph.freeze(jsDoubleNumber(edge-&gt;asNumber()))));
3937                         } else if (edge-&gt;hasInt52Result()) {
3938                             result = m_insertionSet.insertNode(
3939                                 indexForChecks, SpecAnyIntAsDouble, DoubleRep, originForChecks,
3940                                 Edge(edge.node(), Int52RepUse));
3941                         } else {
3942                             UseKind useKind;
3943                             if (edge-&gt;shouldSpeculateDoubleReal())
3944                                 useKind = RealNumberUse;
3945                             else if (edge-&gt;shouldSpeculateNumber())
3946                                 useKind = NumberUse;
3947                             else
3948                                 useKind = NotCellUse;
3949 
3950                             result = m_insertionSet.insertNode(
3951                                 indexForChecks, SpecBytecodeDouble, DoubleRep, originForChecks,
3952                                 Edge(edge.node(), useKind));
3953                         }
3954 
3955                         edge.setNode(result);
3956                         break;
3957                     }
3958 
3959                     case Int52RepUse: {
3960                         if (edge-&gt;hasInt52Result())
3961                             break;
3962 
3963                         ASSERT(indexForChecks != UINT_MAX);
3964                         if (edge-&gt;isAnyIntConstant()) {
3965                             result = m_insertionSet.insertNode(
3966                                 indexForChecks, SpecAnyInt, Int52Constant, originForChecks,
3967                                 OpInfo(edge-&gt;constant()));
3968                         } else if (edge-&gt;hasDoubleResult()) {
3969                             result = m_insertionSet.insertNode(
3970                                 indexForChecks, SpecAnyInt, Int52Rep, originForChecks,
3971                                 Edge(edge.node(), DoubleRepAnyIntUse));
3972                         } else if (edge-&gt;shouldSpeculateInt32ForArithmetic()) {
3973                             result = m_insertionSet.insertNode(
3974                                 indexForChecks, SpecInt32Only, Int52Rep, originForChecks,
3975                                 Edge(edge.node(), Int32Use));
3976                         } else {
3977                             result = m_insertionSet.insertNode(
3978                                 indexForChecks, SpecAnyInt, Int52Rep, originForChecks,
3979                                 Edge(edge.node(), AnyIntUse));
3980                         }
3981 
3982                         edge.setNode(result);
3983                         break;
3984                     }
3985 
3986                     default: {
3987                         if (!edge-&gt;hasDoubleResult() &amp;&amp; !edge-&gt;hasInt52Result())
3988                             break;
3989 
3990                         ASSERT(indexForChecks != UINT_MAX);
3991                         if (edge-&gt;hasDoubleResult()) {
3992                             result = m_insertionSet.insertNode(
3993                                 indexForChecks, SpecBytecodeDouble, ValueRep, originForChecks,
3994                                 Edge(edge.node(), DoubleRepUse));
3995                         } else {
3996                             result = m_insertionSet.insertNode(
3997                                 indexForChecks, SpecInt32Only | SpecAnyIntAsDouble, ValueRep,
3998                                 originForChecks, Edge(edge.node(), Int52RepUse));
3999                         }
4000 
4001                         edge.setNode(result);
4002                         break;
4003                     } }
4004 
4005                     // It&#39;s remotely possible that this node cannot do type checks, but we now have a
4006                     // type check on this node. We don&#39;t have to handle the general form of this
4007                     // problem. It only arises when ByteCodeParser emits an immediate SetLocal, rather
4008                     // than a delayed one. So, we only worry about those checks that we may have put on
4009                     // a SetLocal. Note that &quot;indexForChecks != indexInBlock&quot; is just another way of
4010                     // saying &quot;!node-&gt;origin.exitOK&quot;.
4011                     if (indexForChecks != indexInBlock &amp;&amp; mayHaveTypeCheck(edge.useKind())) {
4012                         UseKind knownUseKind;
4013 
4014                         switch (edge.useKind()) {
4015                         case Int32Use:
4016                             knownUseKind = KnownInt32Use;
4017                             break;
4018                         case CellUse:
4019                             knownUseKind = KnownCellUse;
4020                             break;
4021                         case BooleanUse:
4022                             knownUseKind = KnownBooleanUse;
4023                             break;
4024                         default:
4025                             // This can only arise if we have a Check node, and in that case, we can
4026                             // just remove the original check.
4027                             DFG_ASSERT(m_graph, node, node-&gt;op() == Check, node-&gt;op(), edge.useKind());
4028                             knownUseKind = UntypedUse;
4029                             break;
4030                         }
4031 
4032                         ASSERT(indexForChecks != UINT_MAX);
4033                         m_insertionSet.insertNode(
4034                             indexForChecks, SpecNone, Check, originForChecks, edge);
4035 
4036                         edge.setUseKind(knownUseKind);
4037                     }
4038                 });
4039         }
4040 
4041         m_insertionSet.execute(block);
4042     }
4043 
4044     BasicBlock* m_block;
4045     unsigned m_indexInBlock;
4046     Node* m_currentNode;
4047     InsertionSet m_insertionSet;
4048     bool m_profitabilityChanged;
4049 };
4050 
4051 bool performFixup(Graph&amp; graph)
4052 {
4053     return runPhase&lt;FixupPhase&gt;(graph);
4054 }
4055 
4056 } } // namespace JSC::DFG
4057 
4058 #endif // ENABLE(DFG_JIT)
4059 
    </pre>
  </body>
</html>