<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CommonSlowPaths.h&quot;
  28 
  29 #include &quot;ArithProfile.h&quot;
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeStructs.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;ClonedArguments.h&quot;
  35 #include &quot;CodeProfiling.h&quot;
  36 #include &quot;DefinePropertyAttributes.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;Error.h&quot;
  39 #include &quot;ErrorHandlingScope.h&quot;
  40 #include &quot;ExceptionFuzz.h&quot;
  41 #include &quot;FrameTracers.h&quot;
  42 #include &quot;GetterSetter.h&quot;
  43 #include &quot;HostCallReturnValue.h&quot;
  44 #include &quot;ICStats.h&quot;
  45 #include &quot;Interpreter.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JSArrayInlines.h&quot;
  49 #include &quot;JSCInlines.h&quot;
  50 #include &quot;JSCJSValue.h&quot;
  51 #include &quot;JSFixedArray.h&quot;
  52 #include &quot;JSGlobalObjectFunctions.h&quot;
  53 #include &quot;JSImmutableButterfly.h&quot;
  54 #include &quot;JSLexicalEnvironment.h&quot;
  55 #include &quot;JSPropertyNameEnumerator.h&quot;
  56 #include &quot;JSString.h&quot;
  57 #include &quot;JSWithScope.h&quot;
  58 #include &quot;LLIntCommon.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LowLevelInterpreter.h&quot;
  61 #include &quot;MathCommon.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;OpcodeInlines.h&quot;
  64 #include &quot;ScopedArguments.h&quot;
  65 #include &quot;StructureRareDataInlines.h&quot;
  66 #include &quot;ThunkGenerators.h&quot;
  67 #include &quot;TypeProfilerLog.h&quot;
  68 #include &lt;wtf/StringPrintStream.h&gt;
  69 #include &lt;wtf/Variant.h&gt;
  70 
  71 namespace JSC {
  72 
  73 #define BEGIN_NO_SET_PC() \
  74     VM&amp; vm = exec-&gt;vm();      \
  75     NativeCallFrameTracer tracer(vm, exec); \
  76     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  77     UNUSED_PARAM(throwScope)
  78 
  79 #ifndef NDEBUG
  80 #define SET_PC_FOR_STUBS() do { \
  81         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \
  82         exec-&gt;setCurrentVPC(pc); \
  83     } while (false)
  84 #else
  85 #define SET_PC_FOR_STUBS() do { \
  86         exec-&gt;setCurrentVPC(pc); \
  87     } while (false)
  88 #endif
  89 
  90 #define RETURN_TO_THROW(exec, pc)   pc = LLInt::returnToThrow(exec)
  91 
  92 #define BEGIN()                           \
  93     BEGIN_NO_SET_PC();                    \
  94     SET_PC_FOR_STUBS()
  95 
  96 #define GET(operand) (exec-&gt;uncheckedR(operand.offset()))
  97 #define GET_C(operand) (exec-&gt;r(operand.offset()))
  98 
  99 #define RETURN_TWO(first, second) do {       \
 100         return encodeResult(first, second);        \
 101     } while (false)
 102 
 103 #define END_IMPL() RETURN_TWO(pc, exec)
 104 
 105 #define THROW(exceptionToThrow) do {                        \
 106         throwException(exec, throwScope, exceptionToThrow); \
 107         RETURN_TO_THROW(exec, pc);                          \
 108         END_IMPL();                                         \
 109     } while (false)
 110 
 111 #define CHECK_EXCEPTION() do {                    \
 112         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;CommonSlowPaths&quot;, pc);   \
 113         if (UNLIKELY(throwScope.exception())) {   \
 114             RETURN_TO_THROW(exec, pc);            \
 115             END_IMPL();                           \
 116         }                                         \
 117     } while (false)
 118 
 119 #define END() do {                        \
 120         CHECK_EXCEPTION();                \
 121         END_IMPL();                       \
 122     } while (false)
 123 
 124 #define BRANCH(condition) do {                      \
 125         bool bCondition = (condition);                         \
 126         CHECK_EXCEPTION();                                  \
 127         if (bCondition)                                        \
 128             pc = bytecode.m_targetLabel \
 129                 ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
 130                 : exec-&gt;codeBlock()-&gt;outOfLineJumpTarget(pc);                              \
 131         else                                                      \
 132             pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
 133         END_IMPL();                                         \
 134     } while (false)
 135 
 136 #define RETURN_WITH_PROFILING_CUSTOM(result__, value__, profilingAction__) do { \
 137         JSValue returnValue__ = (value__);  \
 138         CHECK_EXCEPTION();                  \
 139         GET(result__) = returnValue__;              \
 140         profilingAction__;                  \
 141         END_IMPL();                         \
 142     } while (false)
 143 
 144 #define RETURN_WITH_PROFILING(value__, profilingAction__) RETURN_WITH_PROFILING_CUSTOM(bytecode.m_dst, value__, profilingAction__)
 145 
 146 #define RETURN(value) \
 147     RETURN_WITH_PROFILING(value, { })
 148 
 149 #define RETURN_PROFILED(value__) \
 150     RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
 151 
 152 #define PROFILE_VALUE(value) do { \
 153         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \
 154     } while (false)
 155 
 156 #define CALL_END_IMPL(exec, callTarget, callTargetTag) \
 157     RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))
 158 
 159 #define CALL_CHECK_EXCEPTION(exec, pc) do {                          \
 160         ExecState* cceExec = (exec);                                 \
 161         Instruction* ccePC = (pc);                                   \
 162         if (UNLIKELY(throwScope.exception()))                        \
 163             CALL_END_IMPL(cceExec, LLInt::callToThrow(cceExec), ExceptionHandlerPtrTag); \
 164     } while (false)
 165 
 166 static void throwArityCheckStackOverflowError(ExecState* exec, ThrowScope&amp; scope)
 167 {
 168     JSObject* error = createStackOverflowError(exec);
 169     throwException(exec, scope, error);
 170 #if LLINT_TRACING
 171     if (UNLIKELY(Options::traceLLIntSlowPath()))
 172         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 173 #endif
 174 }
 175 
 176 SLOW_PATH_DECL(slow_path_call_arityCheck)
 177 {
 178     BEGIN();
 179     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);
 180     if (UNLIKELY(slotsToAdd &lt; 0)) {
 181         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);
 182         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
 183         NativeCallFrameTracer tracer(vm, exec);
 184         ErrorHandlingScope errorScope(vm);
 185         throwScope.release();
 186         throwArityCheckStackOverflowError(exec, throwScope);
 187         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 188     }
 189     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 190 }
 191 
 192 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 193 {
 194     BEGIN();
 195     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);
 196     if (UNLIKELY(slotsToAdd &lt; 0)) {
 197         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);
 198         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
 199         NativeCallFrameTracer tracer(vm, exec);
 200         ErrorHandlingScope errorScope(vm);
 201         throwArityCheckStackOverflowError(exec, throwScope);
 202         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 203     }
 204     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 205 }
 206 
 207 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 208 {
 209     BEGIN();
 210     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
 211     RETURN(DirectArguments::createByCopying(exec));
 212 }
 213 
 214 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 215 {
 216     BEGIN();
 217     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 218     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 219     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
 220     RETURN(ScopedArguments::createByCopying(exec, table, scope));
 221 }
 222 
 223 SLOW_PATH_DECL(slow_path_create_cloned_arguments)
 224 {
 225     BEGIN();
 226     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
 227     RETURN(ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned));
 228 }
 229 
 230 SLOW_PATH_DECL(slow_path_create_this)
 231 {
 232     BEGIN();
 233     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 234     JSObject* result;
 235     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
 236     if (constructorAsObject-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructorAsObject)-&gt;canUseAllocationProfile()) {
 237         JSFunction* constructor = jsCast&lt;JSFunction*&gt;(constructorAsObject);
 238         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(exec).m_cachedCallee;
 239         if (!cachedCallee)
 240             cachedCallee.set(vm, exec-&gt;codeBlock(), constructor);
 241         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 242             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 243 
 244         size_t inlineCapacity = bytecode.m_inlineCapacity;
 245         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity)-&gt;objectAllocationProfile();
 246         throwScope.releaseAssertNoException();
 247         Structure* structure = allocationProfile-&gt;structure();
 248         result = constructEmptyObject(exec, structure);
 249         if (structure-&gt;hasPolyProto()) {
 250             JSObject* prototype = allocationProfile-&gt;prototype();
 251             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, exec));
 252             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 253             prototype-&gt;didBecomePrototype();
 254             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 255         }
 256     } else {
 257         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
 258         JSValue proto = constructorAsObject-&gt;get(exec, vm.propertyNames-&gt;prototype);
 259         CHECK_EXCEPTION();
 260         if (proto.isObject())
 261             result = constructEmptyObject(exec, asObject(proto));
 262         else
 263             result = constructEmptyObject(exec);
 264     }
 265     RETURN(result);
 266 }
 267 
 268 SLOW_PATH_DECL(slow_path_to_this)
 269 {
 270     BEGIN();
 271     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
 272     auto&amp; metadata = bytecode.metadata(exec);
 273     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 274     if (v1.isCell()) {
 275         StructureID myStructureID = v1.asCell()-&gt;structureID();
 276         StructureID otherStructureID = metadata.m_cachedStructureID;
 277         if (myStructureID != otherStructureID) {
 278             if (otherStructureID)
 279                 metadata.m_toThisStatus = ToThisConflicted;
 280             metadata.m_cachedStructureID = myStructureID;
 281             vm.heap.writeBarrier(exec-&gt;codeBlock(), vm.getStructure(myStructureID));
 282         }
 283     } else {
 284         metadata.m_toThisStatus = ToThisConflicted;
 285         metadata.m_cachedStructureID = 0;
 286     }
 287     // Note: We only need to do this value profiling here on the slow path. The fast path
 288     // just returns the input to to_this if the structure check succeeds. If the structure
 289     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 290     // different object that still has the same structure on the fast path since it&#39;ll produce
 291     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 292     // fast path.
 293     auto value = v1.toThis(exec, exec-&gt;codeBlock()-&gt;isStrictMode() ? StrictMode : NotStrictMode);
 294     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 295 }
 296 
 297 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 298 {
 299     BEGIN();
 300     THROW(createTDZError(exec));
 301 }
 302 
 303 SLOW_PATH_DECL(slow_path_check_tdz)
 304 {
 305     BEGIN();
 306     THROW(createTDZError(exec));
 307 }
 308 
 309 SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
 310 {
 311     BEGIN();
 312     THROW(createTypeError(exec, ReadonlyPropertyWriteError));
 313 }
 314 
 315 SLOW_PATH_DECL(slow_path_not)
 316 {
 317     BEGIN();
 318     auto bytecode = pc-&gt;as&lt;OpNot&gt;();
 319     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(exec)));
 320 }
 321 
 322 SLOW_PATH_DECL(slow_path_eq)
 323 {
 324     BEGIN();
 325     auto bytecode = pc-&gt;as&lt;OpEq&gt;();
 326     RETURN(jsBoolean(JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 327 }
 328 
 329 SLOW_PATH_DECL(slow_path_neq)
 330 {
 331     BEGIN();
 332     auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
 333     RETURN(jsBoolean(!JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 334 }
 335 
 336 SLOW_PATH_DECL(slow_path_stricteq)
 337 {
 338     BEGIN();
 339     auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
 340     RETURN(jsBoolean(JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 341 }
 342 
 343 SLOW_PATH_DECL(slow_path_nstricteq)
 344 {
 345     BEGIN();
 346     auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
 347     RETURN(jsBoolean(!JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 348 }
 349 
 350 SLOW_PATH_DECL(slow_path_less)
 351 {
 352     BEGIN();
 353     auto bytecode = pc-&gt;as&lt;OpLess&gt;();
 354     RETURN(jsBoolean(jsLess&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 355 }
 356 
 357 SLOW_PATH_DECL(slow_path_lesseq)
 358 {
 359     BEGIN();
 360     auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
 361     RETURN(jsBoolean(jsLessEq&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 362 }
 363 
 364 SLOW_PATH_DECL(slow_path_greater)
 365 {
 366     BEGIN();
 367     auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
 368     RETURN(jsBoolean(jsLess&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));
 369 }
 370 
 371 SLOW_PATH_DECL(slow_path_greatereq)
 372 {
 373     BEGIN();
 374     auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
 375     RETURN(jsBoolean(jsLessEq&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));
 376 }
 377 
 378 SLOW_PATH_DECL(slow_path_inc)
 379 {
 380     BEGIN();
 381     auto bytecode = pc-&gt;as&lt;OpInc&gt;();
 382     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) + 1), { });
 383 }
 384 
 385 SLOW_PATH_DECL(slow_path_dec)
 386 {
 387     BEGIN();
 388     auto bytecode = pc-&gt;as&lt;OpDec&gt;();
 389     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) - 1), { });
 390 }
 391 
 392 SLOW_PATH_DECL(slow_path_to_string)
 393 {
 394     BEGIN();
 395     auto bytecode = pc-&gt;as&lt;OpToString&gt;();
 396     RETURN(GET_C(bytecode.m_operand).jsValue().toString(exec));
 397 }
 398 
 399 #if ENABLE(JIT)
 400 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
 401 {
 402     ArithProfile&amp; profile = metadata.m_arithProfile;
 403     profile.observeLHS(operand);
 404     ASSERT(result.isNumber() || result.isBigInt());
 405     if (result.isNumber()) {
 406         if (!result.isInt32()) {
 407             if (operand.isInt32())
 408                 profile.setObservedInt32Overflow();
 409 
 410             double doubleVal = result.asNumber();
 411             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 412                 profile.setObservedNegZeroDouble();
 413             else {
 414                 profile.setObservedNonNegZeroDouble();
 415 
 416                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 417                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 418                 // done to simplify the checking algorithm.
 419                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 420                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 421                 if (int64Val &gt;= int52OverflowPoint)
 422                     profile.setObservedInt52Overflow();
 423             }
 424         }
 425     } else if (result.isBigInt())
 426         profile.setObservedBigInt();
 427     else
 428         profile.setObservedNonNumeric();
 429 }
 430 #else
 431 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp;, JSValue, JSValue) { }
 432 #endif
 433 
 434 SLOW_PATH_DECL(slow_path_negate)
 435 {
 436     BEGIN();
 437     auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
 438     auto&amp; metadata = bytecode.metadata(exec);
 439     JSValue operand = GET_C(bytecode.m_operand).jsValue();
 440     JSValue primValue = operand.toPrimitive(exec, PreferNumber);
 441     CHECK_EXCEPTION();
 442 
 443     if (primValue.isBigInt()) {
 444         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
 445         RETURN_WITH_PROFILING(result, {
 446             updateArithProfileForUnaryArithOp(metadata, result, operand);
 447         });
 448     }
 449 
 450     JSValue result = jsNumber(-primValue.toNumber(exec));
 451     CHECK_EXCEPTION();
 452     RETURN_WITH_PROFILING(result, {
 453         updateArithProfileForUnaryArithOp(metadata, result, operand);
 454     });
 455 }
 456 
 457 #if ENABLE(DFG_JIT)
 458 static void updateArithProfileForBinaryArithOp(ExecState* exec, const Instruction* pc, JSValue result, JSValue left, JSValue right)
 459 {
 460     CodeBlock* codeBlock = exec-&gt;codeBlock();
 461     ArithProfile&amp; profile = *codeBlock-&gt;arithProfileForPC(pc);
 462 
 463     if (result.isNumber()) {
 464         if (!result.isInt32()) {
 465             if (left.isInt32() &amp;&amp; right.isInt32())
 466                 profile.setObservedInt32Overflow();
 467 
 468             double doubleVal = result.asNumber();
 469             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 470                 profile.setObservedNegZeroDouble();
 471             else {
 472                 profile.setObservedNonNegZeroDouble();
 473 
 474                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 475                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 476                 // done to simplify the checking algorithm.
 477                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 478                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 479                 if (int64Val &gt;= int52OverflowPoint)
 480                     profile.setObservedInt52Overflow();
 481             }
 482         }
 483     } else if (result.isBigInt())
 484         profile.setObservedBigInt();
 485     else
 486         profile.setObservedNonNumeric();
 487 }
 488 #else
 489 static void updateArithProfileForBinaryArithOp(ExecState*, const Instruction*, JSValue, JSValue, JSValue) { }
 490 #endif
 491 
 492 SLOW_PATH_DECL(slow_path_to_number)
 493 {
 494     BEGIN();
 495     auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
 496     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 497     JSValue result = jsNumber(argument.toNumber(exec));
 498     RETURN_PROFILED(result);
 499 }
 500 
 501 SLOW_PATH_DECL(slow_path_to_object)
 502 {
 503     BEGIN();
 504     auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
 505     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 506     if (UNLIKELY(argument.isUndefinedOrNull())) {
 507         const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_message);
 508         if (!ident.isEmpty())
 509             THROW(createTypeError(exec, ident.impl()));
 510     }
 511     JSObject* result = argument.toObject(exec);
 512     RETURN_PROFILED(result);
 513 }
 514 
 515 SLOW_PATH_DECL(slow_path_add)
 516 {
 517     BEGIN();
 518     auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
 519     JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
 520     JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
 521 
 522     ArithProfile&amp; arithProfile = *exec-&gt;codeBlock()-&gt;arithProfileForPC(pc);
 523     arithProfile.observeLHSAndRHS(v1, v2);
 524 
 525     JSValue result = jsAdd(exec, v1, v2);
 526 
 527     RETURN_WITH_PROFILING(result, {
 528         updateArithProfileForBinaryArithOp(exec, pc, result, v1, v2);
 529     });
 530 }
 531 
 532 // The following arithmetic and bitwise operations need to be sure to run
 533 // toNumber() on their operands in order.  (A call to toNumber() is idempotent
 534 // if an exception is already set on the ExecState.)
 535 
 536 SLOW_PATH_DECL(slow_path_mul)
 537 {
 538     BEGIN();
 539     auto bytecode = pc-&gt;as&lt;OpMul&gt;();
 540     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 541     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 542     JSValue result = jsMul(exec, left, right);
 543     CHECK_EXCEPTION();
 544     RETURN_WITH_PROFILING(result, {
 545         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 546     });
 547 }
 548 
 549 SLOW_PATH_DECL(slow_path_sub)
 550 {
 551     BEGIN();
 552     auto bytecode = pc-&gt;as&lt;OpSub&gt;();
 553     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 554     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 555     auto leftNumeric = left.toNumeric(exec);
 556     CHECK_EXCEPTION();
 557     auto rightNumeric = right.toNumeric(exec);
 558     CHECK_EXCEPTION();
 559 
 560     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 561         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 562             JSBigInt* result = JSBigInt::sub(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 563             CHECK_EXCEPTION();
 564             RETURN_WITH_PROFILING(result, {
 565                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 566             });
 567         }
 568 
 569         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));
 570     }
 571 
 572     JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
 573     RETURN_WITH_PROFILING(result, {
 574         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 575     });
 576 }
 577 
 578 SLOW_PATH_DECL(slow_path_div)
 579 {
 580     BEGIN();
 581     auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
 582     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 583     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 584     auto leftNumeric = left.toNumeric(exec);
 585     CHECK_EXCEPTION();
 586     auto rightNumeric = right.toNumeric(exec);
 587     CHECK_EXCEPTION();
 588 
 589     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 590         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 591             JSBigInt* result = JSBigInt::divide(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 592             CHECK_EXCEPTION();
 593             RETURN_WITH_PROFILING(result, {
 594                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 595             });
 596         }
 597 
 598         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in division.&quot;));
 599     }
 600 
 601     double a = WTF::get&lt;double&gt;(leftNumeric);
 602     double b = WTF::get&lt;double&gt;(rightNumeric);
 603     JSValue result = jsNumber(a / b);
 604     RETURN_WITH_PROFILING(result, {
 605         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 606     });
 607 }
 608 
 609 SLOW_PATH_DECL(slow_path_mod)
 610 {
 611     BEGIN();
 612     auto bytecode = pc-&gt;as&lt;OpMod&gt;();
 613     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 614     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 615     auto leftNumeric = left.toNumeric(exec);
 616     CHECK_EXCEPTION();
 617     auto rightNumeric = right.toNumeric(exec);
 618     CHECK_EXCEPTION();
 619 
 620     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 621         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 622             JSBigInt* result = JSBigInt::remainder(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 623             CHECK_EXCEPTION();
 624             RETURN(result);
 625         }
 626 
 627         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));
 628     }
 629 
 630     double a = WTF::get&lt;double&gt;(leftNumeric);
 631     double b = WTF::get&lt;double&gt;(rightNumeric);
 632     RETURN(jsNumber(jsMod(a, b)));
 633 }
 634 
 635 SLOW_PATH_DECL(slow_path_pow)
 636 {
 637     BEGIN();
 638     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
 639     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 640     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 641     auto leftNumeric = left.toNumeric(exec);
 642     CHECK_EXCEPTION();
 643     auto rightNumeric = right.toNumeric(exec);
 644     CHECK_EXCEPTION();
 645 
 646     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 647         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 648             JSBigInt* result = JSBigInt::exponentiate(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 649             CHECK_EXCEPTION();
 650             RETURN(result);
 651         }
 652 
 653         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));
 654     }
 655 
 656     double a = WTF::get&lt;double&gt;(leftNumeric);
 657     double b = WTF::get&lt;double&gt;(rightNumeric);
 658 
 659     RETURN(jsNumber(operationMathPow(a, b)));
 660 }
 661 
 662 SLOW_PATH_DECL(slow_path_lshift)
 663 {
 664     BEGIN();
 665     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 666     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 667     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 668     auto leftNumeric = left.toBigIntOrInt32(exec);
 669     CHECK_EXCEPTION();
 670     auto rightNumeric = right.toBigIntOrInt32(exec);
 671     CHECK_EXCEPTION();
 672 
 673     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 674         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 675             JSBigInt* result = JSBigInt::leftShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 676             CHECK_EXCEPTION();
 677             RETURN_PROFILED(result);
 678         }
 679 
 680         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));
 681     }
 682 
 683     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 684 }
 685 
 686 SLOW_PATH_DECL(slow_path_rshift)
 687 {
 688     BEGIN();
 689     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 690     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 691     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 692     auto leftNumeric = left.toBigIntOrInt32(exec);
 693     CHECK_EXCEPTION();
 694     auto rightNumeric = right.toBigIntOrInt32(exec);
 695     CHECK_EXCEPTION();
 696 
 697     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 698         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 699             JSBigInt* result = JSBigInt::signedRightShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 700             CHECK_EXCEPTION();
 701             RETURN(result);
 702         }
 703 
 704         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;));
 705     }
 706 
 707     RETURN(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 708 }
 709 
 710 SLOW_PATH_DECL(slow_path_urshift)
 711 {
 712     BEGIN();
 713     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
 714     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(exec);
 715     if (UNLIKELY(throwScope.exception()))
 716         RETURN(JSValue());
 717     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(exec);
 718     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 719 }
 720 
 721 SLOW_PATH_DECL(slow_path_unsigned)
 722 {
 723     BEGIN();
 724     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
 725     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(exec);
 726     RETURN(jsNumber(a));
 727 }
 728 
 729 SLOW_PATH_DECL(slow_path_bitnot)
 730 {
 731     BEGIN();
 732     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
 733     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(exec);
 734     CHECK_EXCEPTION();
 735 
 736     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
 737         JSBigInt* result = JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric));
 738         CHECK_EXCEPTION();
 739         RETURN_PROFILED(result);
 740     }
 741 
 742     RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 743 }
 744 
 745 SLOW_PATH_DECL(slow_path_bitand)
 746 {
 747     BEGIN();
 748     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
 749     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 750     CHECK_EXCEPTION();
 751     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 752     CHECK_EXCEPTION();
 753     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 754         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 755             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 756             CHECK_EXCEPTION();
 757             RETURN_PROFILED(result);
 758         }
 759 
 760         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));
 761     }
 762 
 763     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
 764 }
 765 
 766 SLOW_PATH_DECL(slow_path_bitor)
 767 {
 768     BEGIN();
 769     auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
 770     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 771     CHECK_EXCEPTION();
 772     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 773     CHECK_EXCEPTION();
 774     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 775         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 776             JSBigInt* result = JSBigInt::bitwiseOr(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 777             CHECK_EXCEPTION();
 778             RETURN_PROFILED(result);
 779         }
 780 
 781         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));
 782     }
 783 
 784     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
 785 }
 786 
 787 SLOW_PATH_DECL(slow_path_bitxor)
 788 {
 789     BEGIN();
 790     auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
 791     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 792     CHECK_EXCEPTION();
 793     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 794     CHECK_EXCEPTION();
 795     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 796         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 797             JSBigInt* result = JSBigInt::bitwiseXor(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 798             CHECK_EXCEPTION();
 799             RETURN_PROFILED(result);
 800         }
 801 
 802         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));
 803     }
 804 
 805     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
 806 }
 807 
 808 SLOW_PATH_DECL(slow_path_typeof)
 809 {
 810     BEGIN();
 811     auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
 812     RETURN(jsTypeStringForValue(exec, GET_C(bytecode.m_value).jsValue()));
 813 }
 814 
 815 SLOW_PATH_DECL(slow_path_is_object_or_null)
 816 {
 817     BEGIN();
 818     auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
 819     RETURN(jsBoolean(jsIsObjectTypeOrNull(exec, GET_C(bytecode.m_operand).jsValue())));
 820 }
 821 
 822 SLOW_PATH_DECL(slow_path_is_function)
 823 {
 824     BEGIN();
 825     auto bytecode = pc-&gt;as&lt;OpIsFunction&gt;();
 826     RETURN(jsBoolean(GET_C(bytecode.m_operand).jsValue().isFunction(vm)));
 827 }
 828 
 829 SLOW_PATH_DECL(slow_path_in_by_val)
 830 {
 831     BEGIN();
 832     auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
 833     auto&amp; metadata = bytecode.metadata(exec);
 834     RETURN(jsBoolean(CommonSlowPaths::opInByVal(exec, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));
 835 }
 836 
 837 SLOW_PATH_DECL(slow_path_in_by_id)
 838 {
 839     BEGIN();
 840 
 841     auto bytecode = pc-&gt;as&lt;OpInById&gt;();
 842     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 843     if (!baseValue.isObject())
 844         THROW(createInvalidInParameterError(exec, baseValue));
 845 
 846     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property))));
 847 }
 848 
 849 SLOW_PATH_DECL(slow_path_del_by_val)
 850 {
 851     BEGIN();
 852     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
 853     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 854     JSObject* baseObject = baseValue.toObject(exec);
 855     CHECK_EXCEPTION();
 856 
 857     JSValue subscript = GET_C(bytecode.m_property).jsValue();
 858 
 859     bool couldDelete;
 860 
 861     uint32_t i;
 862     if (subscript.getUInt32(i))
 863         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);
 864     else {
 865         CHECK_EXCEPTION();
 866         auto property = subscript.toPropertyKey(exec);
 867         CHECK_EXCEPTION();
 868         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);
 869     }
 870 
 871     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
 872         THROW(createTypeError(exec, UnableToDeletePropertyError));
 873 
 874     RETURN(jsBoolean(couldDelete));
 875 }
 876 
 877 SLOW_PATH_DECL(slow_path_strcat)
 878 {
 879     BEGIN();
 880     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
 881     RETURN(jsStringFromRegisterArray(exec, &amp;GET(bytecode.m_src), bytecode.m_count));
 882 }
 883 
 884 SLOW_PATH_DECL(slow_path_to_primitive)
 885 {
 886     BEGIN();
 887     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
 888     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(exec));
 889 }
 890 
 891 SLOW_PATH_DECL(slow_path_get_enumerable_length)
 892 {
 893     BEGIN();
 894     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
 895     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
 896     if (enumeratorValue.isUndefinedOrNull())
 897         RETURN(jsNumber(0));
 898 
 899     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
 900 
 901     RETURN(jsNumber(enumerator-&gt;indexedLength()));
 902 }
 903 
 904 SLOW_PATH_DECL(slow_path_has_indexed_property)
 905 {
 906     BEGIN();
 907     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
 908     auto&amp; metadata = bytecode.metadata(exec);
 909     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 910     CHECK_EXCEPTION();
 911     JSValue property = GET(bytecode.m_property).jsValue();
 912     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
 913     ASSERT(property.isUInt32AsAnyInt());
 914     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));
 915 }
 916 
 917 SLOW_PATH_DECL(slow_path_has_structure_property)
 918 {
 919     BEGIN();
 920     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
 921     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 922     CHECK_EXCEPTION();
 923     JSValue property = GET(bytecode.m_property).jsValue();
 924     ASSERT(property.isString());
 925     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 926     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
 927         RETURN(jsBoolean(true));
 928     JSString* string = asString(property);
 929     auto propertyName = string-&gt;toIdentifier(exec);
 930     CHECK_EXCEPTION();
 931     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
 932 }
 933 
 934 SLOW_PATH_DECL(slow_path_has_generic_property)
 935 {
 936     BEGIN();
 937     auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
 938     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 939     CHECK_EXCEPTION();
 940     JSValue property = GET(bytecode.m_property).jsValue();
 941     ASSERT(property.isString());
 942     JSString* string = asString(property);
 943     auto propertyName = string-&gt;toIdentifier(exec);
 944     CHECK_EXCEPTION();
 945     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
 946 }
 947 
 948 SLOW_PATH_DECL(slow_path_get_direct_pname)
 949 {
 950     BEGIN();
 951     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
 952     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 953     JSValue property = GET(bytecode.m_property).jsValue();
 954     ASSERT(property.isString());
 955     JSString* string = asString(property);
 956     auto propertyName = string-&gt;toIdentifier(exec);
 957     CHECK_EXCEPTION();
 958     RETURN(baseValue.get(exec, propertyName));
 959 }
 960 
 961 SLOW_PATH_DECL(slow_path_get_property_enumerator)
 962 {
 963     BEGIN();
 964     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
 965     JSValue baseValue = GET(bytecode.m_base).jsValue();
 966     if (baseValue.isUndefinedOrNull())
 967         RETURN(vm.emptyPropertyNameEnumerator());
 968 
 969     JSObject* base = baseValue.toObject(exec);
 970     CHECK_EXCEPTION();
 971 
 972     RETURN(propertyNameEnumerator(exec, base));
 973 }
 974 
 975 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
 976 {
 977     BEGIN();
 978     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
 979     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 980     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 981 
 982     JSString* propertyName = nullptr;
 983     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
 984         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 985     RETURN(propertyName ? propertyName : jsNull());
 986 }
 987 
 988 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
 989 {
 990     BEGIN();
 991     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
 992     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 993     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 994 
 995     JSString* propertyName = nullptr;
 996     if (enumerator-&gt;endStructurePropertyIndex() &lt;= index &amp;&amp; index &lt; enumerator-&gt;endGenericPropertyIndex())
 997         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 998     RETURN(propertyName ? propertyName : jsNull());
 999 }
1000 
1001 SLOW_PATH_DECL(slow_path_to_index_string)
1002 {
1003     BEGIN();
1004     auto bytecode = pc-&gt;as&lt;OpToIndexString&gt;();
1005     JSValue indexValue = GET(bytecode.m_index).jsValue();
1006     ASSERT(indexValue.isUInt32AsAnyInt());
1007     RETURN(jsString(vm, Identifier::from(vm, indexValue.asUInt32AsAnyInt()).string()));
1008 }
1009 
1010 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
1011 {
1012     BEGIN();
1013     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
1014     END();
1015 }
1016 
1017 SLOW_PATH_DECL(slow_path_unreachable)
1018 {
1019     BEGIN();
1020     UNREACHABLE_FOR_PLATFORM();
1021     END();
1022 }
1023 
1024 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1025 {
1026     BEGIN();
1027     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
1028     int scopeReg = bytecode.m_scope.offset();
1029     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();
1030     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
1031     JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
1032     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
1033     JSScope* newScope = JSLexicalEnvironment::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, symbolTable, initialValue);
1034     RETURN(newScope);
1035 }
1036 
1037 SLOW_PATH_DECL(slow_path_push_with_scope)
1038 {
1039     BEGIN();
1040     auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
1041     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(exec);
1042     CHECK_EXCEPTION();
1043 
1044     int scopeReg = bytecode.m_currentScope.offset();
1045     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();
1046     RETURN(JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, newScope));
1047 }
1048 
1049 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1050 {
1051     BEGIN();
1052     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
1053     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1054     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1055     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, ident);
1056 
1057     CHECK_EXCEPTION();
1058 
1059     RETURN(resolvedScope);
1060 }
1061 
1062 SLOW_PATH_DECL(slow_path_resolve_scope)
1063 {
1064     BEGIN();
1065     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
1066     auto&amp; metadata = bytecode.metadata(exec);
1067     CodeBlock* codeBlock = exec-&gt;codeBlock();
1068     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
1069     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1070     JSObject* resolvedScope = JSScope::resolve(exec, scope, ident);
1071     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1072     CHECK_EXCEPTION();
1073 
1074     ResolveType resolveType = metadata.m_resolveType;
1075 
1076     // ModuleVar does not keep the scope register value alive in DFG.
1077     ASSERT(resolveType != ModuleVar);
1078 
1079     switch (resolveType) {
1080     case GlobalProperty:
1081     case GlobalPropertyWithVarInjectionChecks:
1082     case UnresolvedProperty:
1083     case UnresolvedPropertyWithVarInjectionChecks: {
1084         if (resolvedScope-&gt;isGlobalObject()) {
1085             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
1086             bool hasProperty = globalObject-&gt;hasProperty(exec, ident);
1087             CHECK_EXCEPTION();
1088             if (hasProperty) {
1089                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1090                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
1091                 metadata.m_globalObject.set(vm, codeBlock, globalObject);
1092                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1093             }
1094         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1095             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
1096             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1097             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
1098             metadata.m_globalLexicalEnvironment.set(vm, codeBlock, globalLexicalEnvironment);
1099         }
1100         break;
1101     }
1102     default:
1103         break;
1104     }
1105 
1106     RETURN(resolvedScope);
1107 }
1108 
1109 SLOW_PATH_DECL(slow_path_create_rest)
1110 {
1111     BEGIN();
1112     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1113     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
1114     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1115     Structure* structure = globalObject-&gt;restParameterStructure();
1116     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
1117     JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numParamsToSkip;
1118     RETURN(constructArray(exec, structure, argumentsToCopyRegion, arraySize));
1119 }
1120 
1121 SLOW_PATH_DECL(slow_path_get_by_id_with_this)
1122 {
1123     BEGIN();
1124     auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
1125     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1126     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1127     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1128     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1129     JSValue result = baseValue.get(exec, ident, slot);
1130     RETURN_PROFILED(result);
1131 }
1132 
1133 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1134 {
1135     BEGIN();
1136 
1137     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1138     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1139     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1140     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1141 
1142     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1143         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1144         if (JSCell::canUseFastGetOwnProperty(structure)) {
1145             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);
1146             CHECK_EXCEPTION();
1147             if (existingAtomString) {
1148                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1149                     RETURN_PROFILED(result);
1150             }
1151         }
1152     }
1153 
1154     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1155     if (subscript.isUInt32()) {
1156         uint32_t i = subscript.asUInt32();
1157         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1158             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(exec, i));
1159 
1160         RETURN_PROFILED(baseValue.get(exec, i, slot));
1161     }
1162 
1163     baseValue.requireObjectCoercible(exec);
1164     CHECK_EXCEPTION();
1165     auto property = subscript.toPropertyKey(exec);
1166     CHECK_EXCEPTION();
1167     RETURN_PROFILED(baseValue.get(exec, property, slot));
1168 }
1169 
1170 SLOW_PATH_DECL(slow_path_put_by_id_with_this)
1171 {
1172     BEGIN();
1173     auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
1174     CodeBlock* codeBlock = exec-&gt;codeBlock();
1175     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1176     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1177     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1178     JSValue putValue = GET_C(bytecode.m_value).jsValue();
1179     PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
1180     baseValue.putInline(exec, ident, putValue, slot);
1181     END();
1182 }
1183 
1184 SLOW_PATH_DECL(slow_path_put_by_val_with_this)
1185 {
1186     BEGIN();
1187     auto bytecode = pc-&gt;as&lt;OpPutByValWithThis&gt;();
1188     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1189     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1190     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1191     JSValue value = GET_C(bytecode.m_value).jsValue();
1192 
1193     auto property = subscript.toPropertyKey(exec);
1194     CHECK_EXCEPTION();
1195     PutPropertySlot slot(thisValue, exec-&gt;codeBlock()-&gt;isStrictMode());
1196     baseValue.put(exec, property, value, slot);
1197     END();
1198 }
1199 
1200 SLOW_PATH_DECL(slow_path_define_data_property)
1201 {
1202     BEGIN();
1203     auto bytecode = pc-&gt;as&lt;OpDefineDataProperty&gt;();
1204     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1205     JSValue property = GET_C(bytecode.m_property).jsValue();
1206     JSValue value = GET_C(bytecode.m_value).jsValue();
1207     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1208     ASSERT(attributes.isInt32());
1209 
1210     auto propertyName = property.toPropertyKey(exec);
1211     CHECK_EXCEPTION();
1212     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
1213     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1214     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1215     END();
1216 }
1217 
1218 SLOW_PATH_DECL(slow_path_define_accessor_property)
1219 {
1220     BEGIN();
1221     auto bytecode = pc-&gt;as&lt;OpDefineAccessorProperty&gt;();
1222     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1223     JSValue property = GET_C(bytecode.m_property).jsValue();
1224     JSValue getter = GET_C(bytecode.m_getter).jsValue();
1225     JSValue setter = GET_C(bytecode.m_setter).jsValue();
1226     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1227     ASSERT(attributes.isInt32());
1228 
1229     auto propertyName = property.toPropertyKey(exec);
1230     CHECK_EXCEPTION();
1231     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
1232     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1233     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1234     END();
1235 }
1236 
1237 SLOW_PATH_DECL(slow_path_throw_static_error)
1238 {
1239     BEGIN();
1240     auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
1241     JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
1242     RELEASE_ASSERT(errorMessageValue.isString());
1243     String errorMessage = asString(errorMessageValue)-&gt;value(exec);
1244     ErrorType errorType = bytecode.m_errorType;
1245     THROW(createError(exec, errorType, errorMessage));
1246 }
1247 
1248 SLOW_PATH_DECL(slow_path_new_array_with_spread)
1249 {
1250     BEGIN();
1251     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
1252     int numItems = bytecode.m_argc;
1253     ASSERT(numItems &gt;= 0);
1254     const BitVector&amp; bitVector = exec-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);
1255 
1256     JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
1257 
1258     Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
1259     for (int i = 0; i &lt; numItems; i++) {
1260         if (bitVector.get(i)) {
1261             JSValue value = values[-i];
1262             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);
1263             checkedArraySize += array-&gt;size();
1264         } else
1265             checkedArraySize += 1;
1266     }
1267     if (UNLIKELY(checkedArraySize.hasOverflowed()))
1268         THROW(createOutOfMemoryError(exec));
1269 
1270     unsigned arraySize = checkedArraySize.unsafeGet();
1271     if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
1272         THROW(createOutOfMemoryError(exec));
1273 
1274     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1275     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
1276 
1277     JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
1278     if (UNLIKELY(!result))
1279         THROW(createOutOfMemoryError(exec));
1280     CHECK_EXCEPTION();
1281 
1282     unsigned index = 0;
1283     for (int i = 0; i &lt; numItems; i++) {
1284         JSValue value = values[-i];
1285         if (bitVector.get(i)) {
1286             // We are spreading.
1287             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);
1288             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {
1289                 RELEASE_ASSERT(array-&gt;get(i));
1290                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));
1291                 CHECK_EXCEPTION();
1292                 ++index;
1293             }
1294         } else {
1295             // We are not spreading.
1296             result-&gt;putDirectIndex(exec, index, value);
1297             CHECK_EXCEPTION();
1298             ++index;
1299         }
1300     }
1301 
1302     RETURN(result);
1303 }
1304 
1305 SLOW_PATH_DECL(slow_path_new_array_buffer)
1306 {
1307     BEGIN();
1308     auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
1309     ASSERT(exec-&gt;codeBlock()-&gt;isConstantRegisterIndex(bytecode.m_immutableButterfly.offset()));
1310     JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
1311     auto&amp; profile = bytecode.metadata(exec).m_arrayAllocationProfile;
1312 
1313     IndexingType indexingMode = profile.selectIndexingType();
1314     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);
1315     ASSERT(isCopyOnWrite(indexingMode));
1316     ASSERT(!structure-&gt;outOfLineCapacity());
1317 
1318     if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
1319         auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
1320         for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
1321             newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
1322         immutableButterfly = newButterfly;
1323         CodeBlock* codeBlock = exec-&gt;codeBlock();
1324 
1325         // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
1326         // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
1327         // a compilation thread.
1328         WTF::storeStoreFence();
1329         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly.offset()).set(vm, codeBlock, immutableButterfly);
1330         WTF::storeStoreFence();
1331     }
1332 
1333     JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
1334     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || exec-&gt;lexicalGlobalObject()-&gt;isHavingABadTime());
1335     ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
1336     RETURN(result);
1337 }
1338 
1339 SLOW_PATH_DECL(slow_path_spread)
1340 {
1341     BEGIN();
1342 
1343     auto bytecode = pc-&gt;as&lt;OpSpread&gt;();
1344     JSValue iterable = GET_C(bytecode.m_argument).jsValue();
1345 
1346     if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
1347         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
1348         if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
1349             // JSFixedArray::createFromArray does not consult the prototype chain,
1350             // so we must be sure that not consulting the prototype chain would
1351             // produce the same value during iteration.
1352             RETURN(JSFixedArray::createFromArray(exec, vm, array));
1353         }
1354     }
1355 
1356     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1357 
1358     JSArray* array;
1359     {
1360         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
1361         CallData callData;
1362         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
1363         ASSERT(callType != CallType::None);
1364 
1365         MarkedArgumentBuffer arguments;
1366         arguments.append(iterable);
1367         ASSERT(!arguments.hasOverflowed());
1368         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);
1369         CHECK_EXCEPTION();
1370         array = jsCast&lt;JSArray*&gt;(arrayResult);
1371     }
1372 
1373     RETURN(JSFixedArray::createFromArray(exec, vm, array));
1374 }
1375 
1376 } // namespace JSC
    </pre>
  </body>
</html>