<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Lookup.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">  3  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &quot;BatchedTransitionOptimizer.h&quot;
 24 #include &quot;CallFrame.h&quot;
 25 #include &quot;CustomGetterSetter.h&quot;
 26 #include &quot;DOMJITGetterSetter.h&quot;
 27 #include &quot;DOMJITSignature.h&quot;
 28 #include &quot;Identifier.h&quot;
 29 #include &quot;IdentifierInlines.h&quot;
 30 #include &quot;Intrinsic.h&quot;
 31 #include &quot;JSFunction.h&quot;
 32 #include &quot;JSGlobalObject.h&quot;
 33 #include &quot;LazyProperty.h&quot;
 34 #include &quot;PropertySlot.h&quot;
 35 #include &quot;PutPropertySlot.h&quot;
 36 #include &quot;TypeError.h&quot;
 37 #include &lt;wtf/Assertions.h&gt;
 38 
 39 namespace JSC {
 40 
 41 struct CompactHashIndex {
 42     const int16_t value;
 43     const int16_t next;
 44 };
 45 
 46 // FIXME: There is no reason this get function can&#39;t be simpler.
 47 // ie. typedef JSValue (*GetFunction)(ExecState*, JSObject* baseObject)
 48 typedef PropertySlot::GetValueFunc GetFunction;
 49 typedef PutPropertySlot::PutValueFunc PutFunction;
 50 typedef FunctionExecutable* (*BuiltinGenerator)(VM&amp;);
 51 typedef JSValue (*LazyPropertyCallback)(VM&amp;, JSObject*);
 52 
 53 // Hash table generated by the create_hash_table script.
 54 struct HashTableValue {
 55     const char* m_key; // property name
 56     unsigned m_attributes; // JSObject attributes
 57     Intrinsic m_intrinsic;
 58     union ValueStorage {
 59         constexpr ValueStorage(intptr_t value1, intptr_t value2)
 60             : value1(value1)
 61             , value2(value2)
 62         { }
 63         constexpr ValueStorage(long long constant)
 64             : constant(constant)
 65         { }
 66 
 67         struct {
 68             intptr_t value1;
 69             intptr_t value2;
 70         };
 71         long long constant;
 72     } m_values;
 73 
 74     unsigned attributes() const { return m_attributes; }
 75 
 76     Intrinsic intrinsic() const { ASSERT(m_attributes &amp; PropertyAttribute::Function); return m_intrinsic; }
 77     BuiltinGenerator builtinGenerator() const { ASSERT(m_attributes &amp; PropertyAttribute::Builtin); return reinterpret_cast&lt;BuiltinGenerator&gt;(m_values.value1); }
 78     NativeFunction function() const { ASSERT(m_attributes &amp; PropertyAttribute::Function); return NativeFunction(m_values.value1); }
 79     unsigned char functionLength() const
 80     {
 81         ASSERT(m_attributes &amp; PropertyAttribute::Function);
 82         if (m_attributes &amp; PropertyAttribute::DOMJITFunction)
 83             return signature()-&gt;argumentCount;
 84         return static_cast&lt;unsigned char&gt;(m_values.value2);
 85     }
 86 
 87     GetFunction propertyGetter() const { ASSERT(!(m_attributes &amp; PropertyAttribute::BuiltinOrFunctionOrAccessorOrLazyPropertyOrConstant)); return reinterpret_cast&lt;GetFunction&gt;(m_values.value1); }
 88     PutFunction propertyPutter() const { ASSERT(!(m_attributes &amp; PropertyAttribute::BuiltinOrFunctionOrAccessorOrLazyPropertyOrConstant)); return reinterpret_cast&lt;PutFunction&gt;(m_values.value2); }
 89 
 90     const DOMJIT::GetterSetter* domJIT() const { ASSERT(m_attributes &amp; PropertyAttribute::DOMJITAttribute); return reinterpret_cast&lt;const DOMJIT::GetterSetter*&gt;(m_values.value1); }
 91     const DOMJIT::Signature* signature() const { ASSERT(m_attributes &amp; PropertyAttribute::DOMJITFunction); return reinterpret_cast&lt;const DOMJIT::Signature*&gt;(m_values.value2); }
 92 
 93     NativeFunction accessorGetter() const { ASSERT(m_attributes &amp; PropertyAttribute::Accessor); return NativeFunction(m_values.value1); }
 94     NativeFunction accessorSetter() const { ASSERT(m_attributes &amp; PropertyAttribute::Accessor); return NativeFunction(m_values.value2); }
 95     BuiltinGenerator builtinAccessorGetterGenerator() const;
 96     BuiltinGenerator builtinAccessorSetterGenerator() const;
 97 
 98     long long constantInteger() const { ASSERT(m_attributes &amp; PropertyAttribute::ConstantInteger); return m_values.constant; }
 99 
100     intptr_t lexerValue() const { ASSERT(!m_attributes); return m_values.value1; }
101 
102     ptrdiff_t lazyCellPropertyOffset() const { ASSERT(m_attributes &amp; PropertyAttribute::CellProperty); return m_values.value1; }
103     ptrdiff_t lazyClassStructureOffset() const { ASSERT(m_attributes &amp; PropertyAttribute::ClassStructure); return m_values.value1; }
104     LazyPropertyCallback lazyPropertyCallback() const { ASSERT(m_attributes &amp; PropertyAttribute::PropertyCallback); return reinterpret_cast&lt;LazyPropertyCallback&gt;(m_values.value1); }
105 };
106 
107 struct HashTable {
108     int numberOfValues;
109     int indexMask;
110     bool hasSetterOrReadonlyProperties;
111     const ClassInfo* classForThis; // Used by DOMAttribute. Attribute accessors perform type check against this classInfo.
112 
113     const HashTableValue* values; // Fixed values generated by script.
114     const CompactHashIndex* index;
115 
116     // Find an entry in the table, and return the entry.
117     ALWAYS_INLINE const HashTableValue* entry(PropertyName propertyName) const
118     {
119         if (propertyName.isSymbol())
120             return nullptr;
121 
122         auto uid = propertyName.uid();
123         if (!uid)
124             return nullptr;
125 
126         int indexEntry = IdentifierRepHash::hash(uid) &amp; indexMask;
127         int valueIndex = index[indexEntry].value;
128         if (valueIndex == -1)
129             return nullptr;
130 
131         while (true) {
132             if (WTF::equal(uid, values[valueIndex].m_key))
133                 return &amp;values[valueIndex];
134 
135             indexEntry = index[indexEntry].next;
136             if (indexEntry == -1)
137                 return nullptr;
138             valueIndex = index[indexEntry].value;
139             ASSERT(valueIndex != -1);
140         };
141     }
142 
143     class ConstIterator {
144     public:
145         ConstIterator(const HashTable* table, int position)
146             : m_table(table)
147             , m_position(position)
148         {
149             skipInvalidKeys();
150         }
151 
152         const HashTableValue* value() const
153         {
154             return &amp;m_table-&gt;values[m_position];
155         }
156 
157         const HashTableValue&amp; operator*() const { return *value(); }
158 
159         const char* key() const
160         {
161             return m_table-&gt;values[m_position].m_key;
162         }
163 
164         const HashTableValue* operator-&gt;() const
165         {
166             return value();
167         }
168 
169         bool operator!=(const ConstIterator&amp; other) const
170         {
171             ASSERT(m_table == other.m_table);
172             return m_position != other.m_position;
173         }
174 
175         ConstIterator&amp; operator++()
176         {
177             ASSERT(m_position &lt; m_table-&gt;numberOfValues);
178             ++m_position;
179             skipInvalidKeys();
180             return *this;
181         }
182 
183     private:
184         void skipInvalidKeys()
185         {
186             ASSERT(m_position &lt;= m_table-&gt;numberOfValues);
187             while (m_position &lt; m_table-&gt;numberOfValues &amp;&amp; !m_table-&gt;values[m_position].m_key)
188                 ++m_position;
189             ASSERT(m_position &lt;= m_table-&gt;numberOfValues);
190         }
191 
192         const HashTable* m_table;
193         int m_position;
194     };
195 
196     ConstIterator begin() const
197     {
198         return ConstIterator(this, 0);
199     }
200     ConstIterator end() const
201     {
202         return ConstIterator(this, numberOfValues);
203     }
204 };
205 
206 JS_EXPORT_PRIVATE bool setUpStaticFunctionSlot(VM&amp;, const ClassInfo*, const HashTableValue*, JSObject* thisObject, PropertyName, PropertySlot&amp;);
207 JS_EXPORT_PRIVATE void reifyStaticAccessor(VM&amp;, const HashTableValue&amp;, JSObject&amp; thisObject, PropertyName);
208 
209 inline BuiltinGenerator HashTableValue::builtinAccessorGetterGenerator() const
210 {
211     ASSERT(m_attributes &amp; PropertyAttribute::Accessor);
212     ASSERT(m_attributes &amp; PropertyAttribute::Builtin);
213     return reinterpret_cast&lt;BuiltinGenerator&gt;(m_values.value1);
214 }
215 
216 inline BuiltinGenerator HashTableValue::builtinAccessorSetterGenerator() const
217 {
218     ASSERT(m_attributes &amp; PropertyAttribute::Accessor);
219     ASSERT(m_attributes &amp; PropertyAttribute::Builtin);
220     return reinterpret_cast&lt;BuiltinGenerator&gt;(m_values.value2);
221 }
222 
223 inline bool getStaticPropertySlotFromTable(VM&amp; vm, const ClassInfo* classInfo, const HashTable&amp; table, JSObject* thisObject, PropertyName propertyName, PropertySlot&amp; slot)
224 {
225     if (thisObject-&gt;staticPropertiesReified(vm))
226         return false;
227 
228     auto* entry = table.entry(propertyName);
229     if (!entry)
230         return false;
231 
232     if (entry-&gt;attributes() &amp; PropertyAttribute::BuiltinOrFunctionOrAccessorOrLazyProperty)
233         return setUpStaticFunctionSlot(vm, classInfo, entry, thisObject, propertyName, slot);
234 
235     if (entry-&gt;attributes() &amp; PropertyAttribute::ConstantInteger) {
236         slot.setValue(thisObject, attributesForStructure(entry-&gt;attributes()), jsNumber(entry-&gt;constantInteger()));
237         return true;
238     }
239 
240     if (entry-&gt;attributes() &amp; PropertyAttribute::DOMJITAttribute) {
241         const DOMJIT::GetterSetter* domJIT = entry-&gt;domJIT();
242         slot.setCacheableCustom(thisObject, attributesForStructure(entry-&gt;attributes()), domJIT-&gt;getter(), DOMAttributeAnnotation { classInfo, domJIT });
243         return true;
244     }
245 
246     if (entry-&gt;attributes() &amp; PropertyAttribute::DOMAttribute) {
247         slot.setCacheableCustom(thisObject, attributesForStructure(entry-&gt;attributes()), entry-&gt;propertyGetter(), DOMAttributeAnnotation { classInfo, nullptr });
248         return true;
249     }
250 
251     slot.setCacheableCustom(thisObject, attributesForStructure(entry-&gt;attributes()), entry-&gt;propertyGetter());
252     return true;
253 }
254 
255 inline bool replaceStaticPropertySlot(VM&amp; vm, JSObject* thisObject, PropertyName propertyName, JSValue value)
256 {
257     if (!thisObject-&gt;putDirect(vm, propertyName, value))
258         return false;
259 
260     if (!thisObject-&gt;staticPropertiesReified(vm))
261         thisObject-&gt;JSObject::setStructure(vm, Structure::attributeChangeTransition(vm, thisObject-&gt;structure(vm), propertyName, 0));
262 
263     return true;
264 }
265 
266 // &#39;base&#39; means the object holding the property (possibly in the prototype chain of the object put was called on).
267 // &#39;thisValue&#39; is the object that put is being applied to (in the case of a proxy, the proxy target).
268 // &#39;slot.thisValue()&#39; is the object the put was originally performed on (in the case of a proxy, the proxy itself).
269 inline bool putEntry(ExecState* exec, const ClassInfo*, const HashTableValue* entry, JSObject* base, JSObject* thisValue, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
270 {
271     VM&amp; vm = exec-&gt;vm();
272     auto scope = DECLARE_THROW_SCOPE(vm);
273 
274     if (entry-&gt;attributes() &amp; PropertyAttribute::BuiltinOrFunctionOrLazyProperty) {
275         if (!(entry-&gt;attributes() &amp; PropertyAttribute::ReadOnly)) {
276             // If this is a function or lazy property put then we just do the put because
277             // logically the object already had the property, so this is just a replace.
278             if (JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue))
279                 thisObject-&gt;putDirect(vm, propertyName, value);
280             return true;
281         }
282         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
283     }
284 
285     if (entry-&gt;attributes() &amp; PropertyAttribute::Accessor)
286         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
287 
288     if (!(entry-&gt;attributes() &amp; PropertyAttribute::ReadOnly)) {
289         ASSERT_WITH_MESSAGE(!(entry-&gt;attributes() &amp; PropertyAttribute::DOMJITAttribute), &quot;DOMJITAttribute supports readonly attributes currently.&quot;);
290         bool isAccessor = entry-&gt;attributes() &amp; PropertyAttribute::CustomAccessor;
291         JSValue updateThisValue = entry-&gt;attributes() &amp; PropertyAttribute::CustomAccessor ? slot.thisValue() : JSValue(base);
292         // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
293         if (isAccessor)
294             slot.setCustomAccessor(base, entry-&gt;propertyPutter());
295         else
296             slot.setCustomValue(base, entry-&gt;propertyPutter());
297 
298         bool result = callCustomSetter(exec, entry-&gt;propertyPutter(), isAccessor, updateThisValue, value);
299         RETURN_IF_EXCEPTION(scope, false);
300         return result;
301     }
302 
303     return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
304 }
305 
306 /**
307  * This one is for &quot;put&quot;.
308  * It looks up a hash entry for the property to be set.  If an entry
309  * is found it sets the value and returns true, else it returns false.
310  */
311 inline bool lookupPut(ExecState* exec, PropertyName propertyName, JSObject* base, JSValue value, const HashTable&amp; table, PutPropertySlot&amp; slot, bool&amp; putResult)
312 {
313     const HashTableValue* entry = table.entry(propertyName);
314 
315     if (!entry)
316         return false;
317 
318     putResult = putEntry(exec, table.classForThis, entry, base, base, propertyName, value, slot);
319     return true;
320 }
321 
322 inline void reifyStaticProperty(VM&amp; vm, const ClassInfo* classInfo, const PropertyName&amp; propertyName, const HashTableValue&amp; value, JSObject&amp; thisObj)
323 {
324     if (value.attributes() &amp; PropertyAttribute::Builtin) {
325         if (value.attributes() &amp; PropertyAttribute::Accessor)
326             reifyStaticAccessor(vm, value, thisObj, propertyName);
327         else
328             thisObj.putDirectBuiltinFunction(vm, thisObj.globalObject(vm), propertyName, value.builtinGenerator()(vm), attributesForStructure(value.attributes()));
329         return;
330     }
331 
332     if (value.attributes() &amp; PropertyAttribute::Function) {
333         if (value.attributes() &amp; PropertyAttribute::DOMJITFunction) {
334             thisObj.putDirectNativeFunction(
335                 vm, thisObj.globalObject(vm), propertyName, value.functionLength(),
336                 value.function(), value.intrinsic(), value.signature(), attributesForStructure(value.attributes()));
337             return;
338         }
339         thisObj.putDirectNativeFunction(
340             vm, thisObj.globalObject(vm), propertyName, value.functionLength(),
341             value.function(), value.intrinsic(), attributesForStructure(value.attributes()));
342         return;
343     }
344 
345     if (value.attributes() &amp; PropertyAttribute::ConstantInteger) {
346         thisObj.putDirect(vm, propertyName, jsNumber(value.constantInteger()), attributesForStructure(value.attributes()));
347         return;
348     }
349 
350     if (value.attributes() &amp; PropertyAttribute::Accessor) {
351         reifyStaticAccessor(vm, value, thisObj, propertyName);
352         return;
353     }
354 
355     if (value.attributes() &amp; PropertyAttribute::CellProperty) {
356         LazyCellProperty* property = bitwise_cast&lt;LazyCellProperty*&gt;(
357             bitwise_cast&lt;char*&gt;(&amp;thisObj) + value.lazyCellPropertyOffset());
358         JSCell* result = property-&gt;get(&amp;thisObj);
359         thisObj.putDirect(vm, propertyName, result, attributesForStructure(value.attributes()));
360         return;
361     }
362 
363     if (value.attributes() &amp; PropertyAttribute::ClassStructure) {
364         LazyClassStructure* structure = bitwise_cast&lt;LazyClassStructure*&gt;(
365             bitwise_cast&lt;char*&gt;(&amp;thisObj) + value.lazyClassStructureOffset());
366         structure-&gt;get(jsCast&lt;JSGlobalObject*&gt;(&amp;thisObj));
367         return;
368     }
369 
370     if (value.attributes() &amp; PropertyAttribute::PropertyCallback) {
371         JSValue result = value.lazyPropertyCallback()(vm, &amp;thisObj);
372         thisObj.putDirect(vm, propertyName, result, attributesForStructure(value.attributes()));
373         return;
374     }
375 
376     if (value.attributes() &amp; PropertyAttribute::DOMJITAttribute) {
377         ASSERT_WITH_MESSAGE(classInfo, &quot;DOMJITAttribute should have class info for type checking.&quot;);
378         const DOMJIT::GetterSetter* domJIT = value.domJIT();
379         auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), value.propertyPutter(), DOMAttributeAnnotation { classInfo, domJIT });
380         thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
381         return;
382     }
383 
384     if (value.attributes() &amp; PropertyAttribute::DOMAttribute) {
385         ASSERT_WITH_MESSAGE(classInfo, &quot;DOMAttribute should have class info for type checking.&quot;);
386         auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, value.propertyGetter(), value.propertyPutter(), DOMAttributeAnnotation { classInfo, nullptr });
387         thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
388         return;
389     }
390 
391     CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, value.propertyGetter(), value.propertyPutter());
392     thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
393 }
394 
395 template&lt;unsigned numberOfValues&gt;
396 inline void reifyStaticProperties(VM&amp; vm, const ClassInfo* classInfo, const HashTableValue (&amp;values)[numberOfValues], JSObject&amp; thisObj)
397 {
398     BatchedTransitionOptimizer transitionOptimizer(vm, &amp;thisObj);
399     for (auto&amp; value : values) {
400         if (!value.m_key)
401             continue;
<a name="2" id="anc2"></a><span class="line-modified">402         auto key = Identifier::fromString(&amp;vm, reinterpret_cast&lt;const LChar*&gt;(value.m_key), strlen(value.m_key));</span>
403         reifyStaticProperty(vm, classInfo, key, value, thisObj);
404     }
405 }
406 
407 template&lt;RawNativeFunction nativeFunction, int length&gt; EncodedJSValue nonCachingStaticFunctionGetter(ExecState* state, EncodedJSValue, PropertyName propertyName)
408 {
409     return JSValue::encode(JSFunction::create(state-&gt;vm(), state-&gt;lexicalGlobalObject(), length, propertyName.publicName(), nativeFunction));
410 }
411 
412 } // namespace JSC
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>