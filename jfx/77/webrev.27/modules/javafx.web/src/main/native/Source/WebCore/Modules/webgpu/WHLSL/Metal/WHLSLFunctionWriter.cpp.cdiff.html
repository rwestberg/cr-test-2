<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLEntryPointScaffolding.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLFunctionWriter.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,603 ***</span>
  #include &quot;config.h&quot;
  #include &quot;WHLSLFunctionWriter.h&quot;
  
  #if ENABLE(WEBGPU)
  
<span class="line-modified">! #include &quot;WHLSLArrayReferenceType.h&quot;</span>
<span class="line-modified">! #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLAssignmentExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLBooleanLiteral.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLBuiltInSemantic.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLCallExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLCommaExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLDereferenceExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLDoWhileLoop.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLEffectfulExpressionStatement.h&quot;</span>
  #include &quot;WHLSLEntryPointScaffolding.h&quot;
<span class="line-modified">! #include &quot;WHLSLEntryPointType.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLFloatLiteral.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLForLoop.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLFunctionDeclaration.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLFunctionDefinition.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLIfStatement.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLIntegerLiteral.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLLogicalExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLLogicalNotExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLMakePointerExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLNativeFunctionDeclaration.h&quot;</span>
  #include &quot;WHLSLNativeFunctionWriter.h&quot;
<span class="line-removed">- #include &quot;WHLSLNativeTypeDeclaration.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLPointerType.h&quot;</span>
  #include &quot;WHLSLProgram.h&quot;
<span class="line-removed">- #include &quot;WHLSLReturn.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLSwitchCase.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLSwitchStatement.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLTernaryExpression.h&quot;</span>
  #include &quot;WHLSLTypeNamer.h&quot;
<span class="line-removed">- #include &quot;WHLSLUnsignedIntegerLiteral.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLVariableDeclaration.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLVariableDeclarationsStatement.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLVariableReference.h&quot;</span>
  #include &quot;WHLSLVisitor.h&quot;
<span class="line-removed">- #include &quot;WHLSLWhileLoop.h&quot;</span>
  #include &lt;wtf/HashMap.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  namespace WHLSL {
  
  namespace Metal {
  
<span class="line-modified">! class FunctionDeclarationWriter : public Visitor {</span>
  public:
<span class="line-modified">!     FunctionDeclarationWriter(TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; functionMapping)</span>
<span class="line-modified">!         : m_typeNamer(typeNamer)</span>
          , m_functionMapping(functionMapping)
      {
      }
  
<span class="line-modified">!     virtual ~FunctionDeclarationWriter() = default;</span>
  
<span class="line-modified">!     String toString() { return m_stringBuilder.toString(); }</span>
<span class="line-modified">!     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (functionDeclaration.entryPointType())</span>
<span class="line-modified">!             return;</span>
  
<span class="line-modified">!         auto iterator = m_functionMapping.find(&amp;functionDeclaration);</span>
<span class="line-modified">!         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;));</span>
<span class="line-modified">!         for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {</span>
<span class="line-modified">!             if (i)</span>
<span class="line-removed">-                 m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-removed">-             m_stringBuilder.append(m_typeNamer.mangledNameForType(*functionDeclaration.parameters()[i].type()));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         m_stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">! private:</span>
<span class="line-removed">-     TypeNamer&amp; m_typeNamer;</span>
<span class="line-removed">-     HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; m_functionMapping;</span>
<span class="line-removed">-     StringBuilder m_stringBuilder;</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! class FunctionDefinitionWriter : public Visitor {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     FunctionDefinitionWriter(Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; functionMapping)</span>
<span class="line-modified">!         : m_intrinsics(intrinsics)</span>
<span class="line-modified">!         , m_typeNamer(typeNamer)</span>
<span class="line-modified">!         , m_functionMapping(functionMapping)</span>
      {
      }
  
<span class="line-modified">!     virtual ~FunctionDefinitionWriter() = default;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     String toString() { return m_stringBuilder.toString(); }</span>
  
<span class="line-modified">!     void visit(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration) override</span>
      {
<span class="line-modified">!         auto iterator = m_functionMapping.find(&amp;nativeFunctionDeclaration);</span>
<span class="line-modified">!         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified">!         m_stringBuilder.append(writeNativeFunction(nativeFunctionDeclaration, iterator-&gt;value, m_typeNamer));</span>
      }
  
<span class="line-modified">!     void visit(AST::FunctionDefinition&amp; functionDefinition) override</span>
      {
<span class="line-modified">!         auto iterator = m_functionMapping.find(&amp;functionDefinition);</span>
<span class="line-modified">!         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified">!         if (functionDefinition.entryPointType()) {</span>
<span class="line-modified">!             m_entryPointScaffolding = EntryPointScaffolding(functionDefinition, m_intrinsics);</span>
<span class="line-modified">!             m_stringBuilder.append(m_entryPointScaffolding-&gt;helperTypes());</span>
<span class="line-modified">!             m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">!             m_stringBuilder.append(makeString(m_entryPointScaffolding-&gt;signature(), &quot; {&quot;));</span>
<span class="line-modified">!             m_stringBuilder.append(m_entryPointScaffolding-&gt;unpack());</span>
<span class="line-modified">!             checkErrorAndVisit(functionDefinition.block());</span>
<span class="line-modified">!             ASSERT(m_stack.isEmpty());</span>
<span class="line-modified">!             m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             m_entryPointScaffolding = WTF::nullopt;</span>
<span class="line-modified">!             m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;));</span>
              for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<span class="line-modified">!                 auto&amp; parameter = functionDefinition.parameters()[i];</span>
<span class="line-removed">-                 if (i)</span>
<span class="line-removed">-                     m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-removed">-                 auto parameterName = generateNextVariableName();</span>
<span class="line-removed">-                 auto addResult = m_variableMapping.add(&amp;parameter, parameterName);</span>
                  ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-removed">-                 m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*parameter.type()), &#39; &#39;, parameterName));</span>
              }
<span class="line-removed">-             m_stringBuilder.append(&quot;) {\n&quot;);</span>
              checkErrorAndVisit(functionDefinition.block());
              ASSERT(m_stack.isEmpty());
<span class="line-removed">-             m_stringBuilder.append(&quot;}\n&quot;);</span>
          }
      }
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     void visit(AST::FunctionDeclaration&amp;) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::Statement&amp; statement) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Visitor::visit(statement);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::Block&amp; block) override</span>
      {
<span class="line-modified">!         m_stringBuilder.append(&quot;{\n&quot;);</span>
          for (auto&amp; statement : block.statements())
              checkErrorAndVisit(statement);
<span class="line-removed">-         m_stringBuilder.append(&quot;}\n&quot;);</span>
      }
  
<span class="line-modified">!     void visit(AST::Break&amp;) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         m_stringBuilder.append(&quot;break;\n&quot;);</span>
      }
  
<span class="line-modified">!     void visit(AST::Continue&amp;) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         // FIXME: Figure out which loop we&#39;re in, and run the increment code</span>
<span class="line-modified">!         CRASH();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::DoWhileLoop&amp; doWhileLoop) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         m_stringBuilder.append(&quot;do {\n&quot;);</span>
<span class="line-modified">!         checkErrorAndVisit(doWhileLoop.body());</span>
<span class="line-modified">!         checkErrorAndVisit(doWhileLoop.conditional());</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(&quot;} while(true);\n&quot;));</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());</span>
<span class="line-modified">!         m_stack.takeLast(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::Fallthrough&amp;) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         m_stringBuilder.append(&quot;[[clang::fallthrough]];\n&quot;); // FIXME: Make sure this is okay. Alternatively, we could do nothing and just return here instead.</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::ForLoop&amp; forLoop) override</span>
      {
<span class="line-modified">!         WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {</span>
<span class="line-modified">!             checkErrorAndVisit(variableDeclarationsStatement);</span>
<span class="line-modified">!         }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {</span>
<span class="line-modified">!             checkErrorAndVisit(expression);</span>
<span class="line-modified">!             m_stack.takeLast(); // We don&#39;t need to do anything with the result.</span>
<span class="line-modified">!         }), forLoop.initialization());</span>
<span class="line-modified">! </span>
<span class="line-removed">-         m_stringBuilder.append(&quot;for ( ; ; ) {\n&quot;);</span>
<span class="line-removed">-         if (forLoop.condition()) {</span>
<span class="line-removed">-             checkErrorAndVisit(*forLoop.condition());</span>
<span class="line-removed">-             m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
          }
<span class="line-modified">!         checkErrorAndVisit(forLoop.body());</span>
<span class="line-modified">!         if (forLoop.increment()) {</span>
<span class="line-modified">!             checkErrorAndVisit(*forLoop.increment());</span>
<span class="line-modified">!             m_stack.takeLast();</span>
          }
<span class="line-modified">!         m_stringBuilder.append(&quot;}\n&quot;);</span>
      }
  
<span class="line-modified">!     void visit(AST::IfStatement&amp; ifStatement) override</span>
      {
<span class="line-modified">!         checkErrorAndVisit(ifStatement.conditional());</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(&quot;if (&quot;, m_stack.takeLast(), &quot;) {\n&quot;));</span>
          checkErrorAndVisit(ifStatement.body());
<span class="line-modified">!         if (ifStatement.elseBody()) {</span>
<span class="line-modified">!             m_stringBuilder.append(&quot;} else {\n&quot;);</span>
              checkErrorAndVisit(*ifStatement.elseBody());
          }
<span class="line-removed">-         m_stringBuilder.append(&quot;}\n&quot;);</span>
      }
  
<span class="line-modified">!     void visit(AST::Return&amp; returnStatement) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (returnStatement.value()) {</span>
<span class="line-modified">!             checkErrorAndVisit(*returnStatement.value());</span>
<span class="line-modified">!             if (m_entryPointScaffolding) {</span>
<span class="line-modified">!                 auto variableName = generateNextVariableName();</span>
<span class="line-modified">!                 m_stringBuilder.append(m_entryPointScaffolding-&gt;pack(m_stack.takeLast(), variableName));</span>
<span class="line-modified">!                 m_stringBuilder.append(makeString(&quot;return &quot;, variableName, &quot;;\n&quot;));</span>
<span class="line-modified">!             } else</span>
<span class="line-removed">-                 m_stringBuilder.append(makeString(&quot;return &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
          } else
<span class="line-modified">!             m_stringBuilder.append(&quot;return;\n&quot;);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::SwitchStatement&amp; switchStatement) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(switchStatement.value());</span>
  
<span class="line-modified">!         m_stringBuilder.append(makeString(&quot;switch (&quot;, m_stack.takeLast(), &quot;) {&quot;));</span>
          for (auto&amp; switchCase : switchStatement.switchCases())
              checkErrorAndVisit(switchCase);
<span class="line-removed">-         m_stringBuilder.append(&quot;}\n&quot;);</span>
      }
  
<span class="line-modified">!     void visit(AST::SwitchCase&amp; switchCase) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (switchCase.value())</span>
<span class="line-modified">!             m_stringBuilder.append(makeString(&quot;case &quot;, constantExpressionString(*switchCase.value()), &quot;:\n&quot;));</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             m_stringBuilder.append(&quot;default:\n&quot;);</span>
<span class="line-modified">!         checkErrorAndVisit(switchCase.block());</span>
<span class="line-modified">!         // FIXME: Figure out whether we need to break or fallthrough.</span>
<span class="line-modified">!         CRASH();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::Trap&amp;) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         // FIXME: Implement this</span>
<span class="line-modified">!         CRASH();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Visitor::visit(variableDeclarationsStatement);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::WhileLoop&amp; whileLoop) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(&quot;while (true) {\n&quot;));</span>
<span class="line-modified">!         checkErrorAndVisit(whileLoop.conditional());</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
<span class="line-modified">!         checkErrorAndVisit(whileLoop.body());</span>
<span class="line-modified">!         m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::IntegerLiteral&amp; integerLiteral) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(integerLiteral.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         auto mangledTypeName = m_typeNamer.mangledNameForType(*integerLiteral.resolvedType());</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">!         m_stack.append(variableName);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         auto mangledTypeName = m_typeNamer.mangledNameForType(*unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">!         m_stack.append(variableName);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::FloatLiteral&amp; floatLiteral) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(floatLiteral.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         auto mangledTypeName = m_typeNamer.mangledNameForType(*floatLiteral.resolvedType());</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">!         m_stack.append(variableName);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::NullLiteral&amp; nullLiteral) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(nullLiteral.resolvedType());</span>
<span class="line-modified">!         auto&amp; unifyNode = nullLiteral.resolvedType()-&gt;unifyNode();</span>
<span class="line-modified">!         ASSERT(is&lt;AST::UnnamedType&gt;(unifyNode));</span>
<span class="line-modified">!         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">!         bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;));</span>
<span class="line-removed">-         if (isArrayReferenceType)</span>
<span class="line-removed">-             m_stringBuilder.append(&quot;{ nullptr, 0 }&quot;);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-removed">-         m_stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-removed">-         m_stack.append(variableName);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::BooleanLiteral&amp; booleanLiteral) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(booleanLiteral.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-removed">-         auto mangledTypeName = m_typeNamer.mangledNameForType(*booleanLiteral.resolvedType());</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;));</span>
<span class="line-removed">-         m_stack.append(variableName);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(enumerationMemberLiteral.resolvedType());</span>
<span class="line-modified">!         ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">!         ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         auto mangledTypeName = m_typeNamer.mangledNameForType(*enumerationMemberLiteral.resolvedType());</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &#39;.&#39;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;));</span>
<span class="line-removed">-         m_stack.append(variableName);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::Expression&amp; expression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Visitor::visit(expression);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::DotExpression&amp;) override</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         // This should be lowered already.</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::IndexExpression&amp;) override</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         // This should be lowered already.</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::PropertyAccessExpression&amp;) override</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::VariableDeclaration&amp; variableDeclaration) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(variableDeclaration.type());</span>
<span class="line-modified">!         if (variableDeclaration.initializer())</span>
<span class="line-modified">!             checkErrorAndVisit(*variableDeclaration.initializer());</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             // FIXME: Zero-fill the variable.</span>
<span class="line-modified">!             CRASH();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // FIXME: Implement qualifiers.</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);</span>
<span class="line-modified">!         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">!         m_stack.append(variableName);</span>
      }
  
<span class="line-modified">!     void visit(AST::AssignmentExpression&amp; assignmentExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(assignmentExpression.left());</span>
<span class="line-modified">!         auto leftName = m_stack.takeLast();</span>
<span class="line-modified">!         checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-removed">-         auto rightName = m_stack.takeLast();</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(leftName, &quot; = &quot;, rightName, &quot;;\n&quot;));</span>
      }
  
<span class="line-modified">!     void visit(AST::CallExpression&amp; callExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Vector&lt;String&gt; argumentNames;</span>
<span class="line-modified">!         for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-modified">!             checkErrorAndVisit(argument);</span>
<span class="line-modified">!             argumentNames.append(m_stack.takeLast());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         ASSERT(callExpression.resolvedType());</span>
<span class="line-modified">!         ASSERT(callExpression.function());</span>
<span class="line-modified">!         auto iterator = m_functionMapping.find(callExpression.function());</span>
          ASSERT(iterator != m_functionMapping.end());
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*callExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, iterator-&gt;value, &#39;(&#39;));</span>
          for (size_t i = 0; i &lt; argumentNames.size(); ++i) {
              if (i)
                  m_stringBuilder.append(&quot;, &quot;);
              m_stringBuilder.append(argumentNames[i]);
          }
          m_stringBuilder.append(&quot;);\n&quot;);
<span class="line-removed">-         m_stack.append(variableName);</span>
      }
  
<span class="line-modified">!     void visit(AST::CommaExpression&amp; commaExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         String result;</span>
<span class="line-removed">-         for (auto&amp; expression : commaExpression.list()) {</span>
<span class="line-removed">-             checkErrorAndVisit(expression);</span>
<span class="line-removed">-             result = m_stack.takeLast();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         m_stack.append(result);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::DereferenceExpression&amp; dereferenceExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(dereferenceExpression.pointer());</span>
<span class="line-modified">!         auto right = m_stack.takeLast();</span>
<span class="line-modified">!         ASSERT(dereferenceExpression.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*dereferenceExpression.resolvedType()), &#39; &#39;, variableName, &quot; = *&quot;, right, &quot;;\n&quot;));</span>
<span class="line-removed">-         m_stack.append(variableName);</span>
      }
  
<span class="line-modified">!     void visit(AST::LogicalExpression&amp; logicalExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(logicalExpression.left());</span>
<span class="line-modified">!         auto left = m_stack.takeLast();</span>
<span class="line-modified">!         checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-modified">!         auto right = m_stack.takeLast();</span>
<span class="line-modified">!         ASSERT(logicalExpression.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left));</span>
<span class="line-modified">!         switch (logicalExpression.type()) {</span>
<span class="line-modified">!         case AST::LogicalExpression::Type::And:</span>
<span class="line-modified">!             m_stringBuilder.append(&quot; &amp;&amp; &quot;);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!             ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
<span class="line-modified">!             m_stringBuilder.append(&quot; || &quot;);</span>
<span class="line-modified">!             break;</span>
          }
<span class="line-modified">!         m_stringBuilder.append(makeString(right, &quot;;\n&quot;));</span>
<span class="line-modified">!         m_stack.append(variableName);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::LogicalNotExpression&amp; logicalNotExpression) override</span>
      {
<span class="line-removed">-         checkErrorAndVisit(logicalNotExpression.operand());</span>
<span class="line-removed">-         auto operand = m_stack.takeLast();</span>
<span class="line-removed">-         ASSERT(logicalNotExpression.resolvedType());</span>
<span class="line-removed">-         auto variableName = generateNextVariableName();</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;));</span>
<span class="line-removed">-         m_stack.append(variableName);</span>
      }
  
<span class="line-modified">!     void visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         checkErrorAndVisit(makeArrayReferenceExpression.lValue());</span>
<span class="line-removed">-         auto lValue = m_stack.takeLast();</span>
<span class="line-removed">-         ASSERT(makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">-         auto variableName = generateNextVariableName();</span>
<span class="line-removed">-         auto mangledTypeName = m_typeNamer.mangledNameForType(*makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">-         if (is&lt;AST::PointerType&gt;(*makeArrayReferenceExpression.resolvedType()))</span>
<span class="line-removed">-             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;));</span>
<span class="line-removed">-         else if (is&lt;AST::ArrayType&gt;(*makeArrayReferenceExpression.resolvedType())) {</span>
<span class="line-removed">-             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(*makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">-             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &amp;(&quot;, lValue, &quot;[0]), &quot;, arrayType.numElements(), &quot; };\n&quot;));</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &amp;&quot;, lValue, &quot;, 1 };\n&quot;));</span>
<span class="line-removed">-         m_stack.append(variableName);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void visit(AST::MakePointerExpression&amp; makePointerExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(makePointerExpression.lValue());</span>
<span class="line-modified">!         auto lValue = m_stack.takeLast();</span>
<span class="line-modified">!         ASSERT(makePointerExpression.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &amp;&quot;, lValue, &quot;;\n&quot;));</span>
<span class="line-modified">!         m_stack.append(variableName);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void visit(AST::ReadModifyWriteExpression&amp;) override</span>
      {
<span class="line-removed">-         // This should be lowered already.</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
      }
  
<span class="line-modified">!     void visit(AST::TernaryExpression&amp; ternaryExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(ternaryExpression.predicate());</span>
<span class="line-modified">!         auto check = m_stack.takeLast();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         ASSERT(ternaryExpression.resolvedType());</span>
<span class="line-modified">!         auto variableName = generateNextVariableName();</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot;;\n&quot;));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         m_stringBuilder.append(makeString(&quot;if (&quot;, check, &quot;) {\n&quot;));</span>
<span class="line-modified">!         checkErrorAndVisit(ternaryExpression.bodyExpression());</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">!         m_stringBuilder.append(&quot;} else {\n&quot;);</span>
<span class="line-modified">!         checkErrorAndVisit(ternaryExpression.elseExpression());</span>
<span class="line-modified">!         m_stringBuilder.append(makeString(variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">!         m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!         m_stack.append(variableName);</span>
      }
  
<span class="line-modified">!     void visit(AST::VariableReference&amp; variableReference) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(variableReference.variable());</span>
<span class="line-modified">!         auto iterator = m_variableMapping.find(variableReference.variable());</span>
<span class="line-modified">!         ASSERT(iterator != m_variableMapping.end());</span>
<span class="line-modified">!         m_stack.append(iterator-&gt;value);</span>
      }
  
<span class="line-modified">!     String constantExpressionString(AST::ConstantExpression&amp; constantExpression)</span>
      {
<span class="line-modified">!         String result;</span>
<span class="line-modified">!         constantExpression.visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">!             result = makeString(&quot;&quot;, integerLiteral.value());</span>
<span class="line-removed">-         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed">-             result = makeString(&quot;&quot;, unsignedIntegerLiteral.value());</span>
<span class="line-removed">-         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-removed">-             result = makeString(&quot;&quot;, floatLiteral.value());</span>
<span class="line-removed">-         }, [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-removed">-             result = &quot;nullptr&quot;_str;</span>
<span class="line-removed">-         }, [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {</span>
<span class="line-removed">-             result = booleanLiteral.value() ? &quot;true&quot;_str : &quot;false&quot;_str;</span>
<span class="line-removed">-         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
<span class="line-removed">-             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-removed">-             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-removed">-             result = makeString(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &#39;.&#39;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>
<span class="line-removed">-         }));</span>
<span class="line-removed">-         return result;</span>
      }
  
<span class="line-modified">!     String generateNextVariableName()</span>
      {
<span class="line-modified">!         return makeString(&quot;variable&quot;, m_variableCount++);</span>
      }
  
  private:
<span class="line-modified">!     Intrinsics&amp; m_intrinsics;</span>
<span class="line-removed">-     TypeNamer&amp; m_typeNamer;</span>
<span class="line-removed">-     HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; m_functionMapping;</span>
<span class="line-removed">-     HashMap&lt;AST::VariableDeclaration*, String&gt; m_variableMapping;</span>
<span class="line-removed">-     StringBuilder m_stringBuilder;</span>
<span class="line-removed">-     Vector&lt;String&gt; m_stack;</span>
<span class="line-removed">-     Optional&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;</span>
<span class="line-removed">-     unsigned m_variableCount { 0 };</span>
  };
  
<span class="line-modified">! String metalFunctions(Program&amp; program, TypeNamer&amp; typeNamer)</span>
  {
<span class="line-modified">!     StringBuilder stringBuilder;</span>
  
<span class="line-modified">!     unsigned numFunctions = 0;</span>
<span class="line-modified">!     HashMap&lt;AST::FunctionDeclaration*, String&gt; functionMapping;</span>
<span class="line-modified">!     for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations()) {</span>
<span class="line-modified">!         auto addResult = functionMapping.add(&amp;nativeFunctionDeclaration, makeString(&quot;function&quot;, numFunctions++));</span>
<span class="line-modified">!         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-modified">!     }</span>
      for (auto&amp; functionDefinition : program.functionDefinitions()) {
<span class="line-modified">!         auto addResult = functionMapping.add(&amp;functionDefinition, makeString(&quot;function&quot;, numFunctions++));</span>
<span class="line-modified">!         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
      }
  
<span class="line-modified">!     {</span>
<span class="line-modified">!         FunctionDeclarationWriter functionDeclarationWriter(typeNamer, functionMapping);</span>
<span class="line-removed">-         for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations())</span>
<span class="line-removed">-             functionDeclarationWriter.visit(nativeFunctionDeclaration);</span>
<span class="line-removed">-         for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-removed">-             if (!functionDefinition-&gt;entryPointType())</span>
<span class="line-removed">-                 functionDeclarationWriter.visit(functionDefinition);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         stringBuilder.append(functionDeclarationWriter.toString());</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     stringBuilder.append(&#39;\n&#39;);</span>
  
<span class="line-modified">!     {</span>
<span class="line-modified">!         FunctionDefinitionWriter functionDefinitionWriter(program.intrinsics(), typeNamer, functionMapping);</span>
<span class="line-modified">!         for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations())</span>
<span class="line-modified">!             functionDefinitionWriter.visit(nativeFunctionDeclaration);</span>
<span class="line-modified">!         for (auto&amp; functionDefinition : program.functionDefinitions())</span>
              functionDefinitionWriter.visit(functionDefinition);
<span class="line-removed">-         stringBuilder.append(functionDefinitionWriter.toString());</span>
      }
  
<span class="line-modified">!     return stringBuilder.toString();</span>
  }
  
  } // namespace Metal
  
  } // namespace WHLSL
<span class="line-new-header">--- 26,910 ---</span>
  #include &quot;config.h&quot;
  #include &quot;WHLSLFunctionWriter.h&quot;
  
  #if ENABLE(WEBGPU)
  
<span class="line-modified">! #include &quot;NotImplemented.h&quot;</span>
<span class="line-modified">! #include &quot;WHLSLAST.h&quot;</span>
  #include &quot;WHLSLEntryPointScaffolding.h&quot;
<span class="line-modified">! #include &quot;WHLSLInferTypes.h&quot;</span>
  #include &quot;WHLSLNativeFunctionWriter.h&quot;
  #include &quot;WHLSLProgram.h&quot;
  #include &quot;WHLSLTypeNamer.h&quot;
  #include &quot;WHLSLVisitor.h&quot;
  #include &lt;wtf/HashMap.h&gt;
<span class="line-added">+ #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/SetForScope.h&gt;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  namespace WHLSL {
  
  namespace Metal {
  
<span class="line-modified">! static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (functionDeclaration.entryPointType())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto iterator = functionMapping.find(&amp;functionDeclaration);</span>
<span class="line-added">+     ASSERT(iterator != functionMapping.end());</span>
<span class="line-added">+     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);</span>
<span class="line-added">+     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {</span>
<span class="line-added">+         if (i)</span>
<span class="line-added">+             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">+         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class FunctionDefinitionWriter : public Visitor {</span>
  public:
<span class="line-modified">!     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)</span>
<span class="line-modified">!         : m_stringBuilder(stringBuilder)</span>
<span class="line-added">+         , m_intrinsics(intrinsics)</span>
<span class="line-added">+         , m_typeNamer(typeNamer)</span>
          , m_functionMapping(functionMapping)
<span class="line-added">+         , m_layout(layout)</span>
      {
      }
  
<span class="line-modified">!     virtual ~FunctionDefinitionWriter() = default;</span>
  
<span class="line-modified">!     void visit(AST::NativeFunctionDeclaration&amp;) override;</span>
<span class="line-modified">!     void visit(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified">! </span>
<span class="line-modified">! protected:</span>
<span class="line-modified">!     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void visit(AST::FunctionDeclaration&amp;) override;</span>
<span class="line-added">+     void visit(AST::Statement&amp;) override;</span>
<span class="line-added">+     void visit(AST::Block&amp;) override;</span>
<span class="line-added">+     void visit(AST::Break&amp;) override;</span>
<span class="line-added">+     void visit(AST::Continue&amp;) override;</span>
<span class="line-added">+     void visit(AST::DoWhileLoop&amp;) override;</span>
<span class="line-added">+     void visit(AST::EffectfulExpressionStatement&amp;) override;</span>
<span class="line-added">+     void visit(AST::Fallthrough&amp;) override;</span>
<span class="line-added">+     void visit(AST::ForLoop&amp;) override;</span>
<span class="line-added">+     void visit(AST::IfStatement&amp;) override;</span>
<span class="line-added">+     void visit(AST::Return&amp;) override;</span>
<span class="line-added">+     void visit(AST::SwitchStatement&amp;) override;</span>
<span class="line-added">+     void visit(AST::SwitchCase&amp;) override;</span>
<span class="line-added">+     void visit(AST::VariableDeclarationsStatement&amp;) override;</span>
<span class="line-added">+     void visit(AST::WhileLoop&amp;) override;</span>
<span class="line-added">+     void visit(AST::IntegerLiteral&amp;) override;</span>
<span class="line-added">+     void visit(AST::UnsignedIntegerLiteral&amp;) override;</span>
<span class="line-added">+     void visit(AST::FloatLiteral&amp;) override;</span>
<span class="line-added">+     void visit(AST::NullLiteral&amp;) override;</span>
<span class="line-added">+     void visit(AST::BooleanLiteral&amp;) override;</span>
<span class="line-added">+     void visit(AST::EnumerationMemberLiteral&amp;) override;</span>
<span class="line-added">+     void visit(AST::Expression&amp;) override;</span>
<span class="line-added">+     void visit(AST::DotExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::GlobalVariableReference&amp;) override;</span>
<span class="line-added">+     void visit(AST::IndexExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::PropertyAccessExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::VariableDeclaration&amp;) override;</span>
<span class="line-added">+     void visit(AST::AssignmentExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::CallExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::CommaExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::DereferenceExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::LogicalExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::LogicalNotExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::MakeArrayReferenceExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::MakePointerExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::ReadModifyWriteExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::TernaryExpression&amp;) override;</span>
<span class="line-added">+     void visit(AST::VariableReference&amp;) override;</span>
  
<span class="line-modified">!     enum class LoopConditionLocation {</span>
<span class="line-modified">!         BeforeBody,</span>
<span class="line-modified">!         AfterBody</span>
<span class="line-modified">!     };</span>
<span class="line-modified">!     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);</span>
  
<span class="line-modified">!     void emitConstantExpressionString(AST::ConstantExpression&amp;);</span>
  
<span class="line-modified">!     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     enum class Nullability : uint8_t {</span>
<span class="line-modified">!         NotNull,</span>
<span class="line-modified">!         CanBeNull</span>
<span class="line-modified">!     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct StackItem {</span>
<span class="line-added">+         MangledVariableName value;</span>
<span class="line-added">+         MangledVariableName leftValue;</span>
<span class="line-added">+         Nullability valueNullability;</span>
<span class="line-added">+         Nullability leftValueNullability;</span>
<span class="line-added">+         std::function&lt;MangledVariableName()&gt; generateLeftValue;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct StackValue {</span>
<span class="line-added">+         MangledVariableName value;</span>
<span class="line-added">+         Nullability nullability;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This is the important data flow step where we can take the nullability of an lvalue</span>
<span class="line-added">+     // and transfer it into the nullability of an rvalue. This is conveyed in MakePointerExpression</span>
<span class="line-added">+     // and DereferenceExpression. MakePointerExpression will try to produce rvalues which are</span>
<span class="line-added">+     // non-null, and DereferenceExpression will take a non-null rvalue and try to produce</span>
<span class="line-added">+     // a non-null lvalue.</span>
<span class="line-added">+     void appendRightValueWithNullability(AST::Expression&amp;, MangledVariableName value, Nullability nullability)</span>
      {
<span class="line-added">+         m_stack.append({ WTFMove(value), { }, nullability, Nullability::CanBeNull, { } });</span>
      }
  
<span class="line-modified">!     void appendRightValue(AST::Expression&amp; expression, MangledVariableName value)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         appendRightValueWithNullability(expression, WTFMove(value), Nullability::CanBeNull);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     void appendLeftValue(AST::Expression&amp; expression, MangledVariableName value, MangledVariableName leftValue, Nullability nullability, std::function&lt;MangledVariableName()&gt; generateLeftValue = { })</span>
      {
<span class="line-modified">!         ASSERT_UNUSED(expression, expression.typeAnnotation().leftAddressSpace());</span>
<span class="line-modified">!         ASSERT(leftValue || generateLeftValue);</span>
<span class="line-modified">!         m_stack.append({ WTFMove(value), WTFMove(leftValue), Nullability::CanBeNull, nullability, WTFMove(generateLeftValue) });</span>
      }
  
<span class="line-modified">!     MangledVariableName takeLastValue()</span>
      {
<span class="line-modified">!         return m_stack.takeLast().value;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     StackValue takeLastValueAndNullability()</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto last = m_stack.takeLast();</span>
<span class="line-modified">!         return { last.value, last.valueNullability };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     StackValue takeLastLeftValue()</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto last = m_stack.takeLast();</span>
<span class="line-modified">!         if (!last.leftValue)</span>
<span class="line-modified">!             last.leftValue = last.generateLeftValue();</span>
<span class="line-added">+         return { last.leftValue, last.leftValueNullability };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     enum class BreakContext {</span>
<span class="line-added">+         Loop,</span>
<span class="line-added">+         Switch</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;BreakContext&gt; m_currentBreakContext;</span>
<span class="line-added">+ </span>
<span class="line-added">+     StringBuilder&amp; m_stringBuilder;</span>
<span class="line-added">+     Intrinsics&amp; m_intrinsics;</span>
<span class="line-added">+     TypeNamer&amp; m_typeNamer;</span>
<span class="line-added">+     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;</span>
<span class="line-added">+     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;StackItem&gt; m_stack;</span>
<span class="line-added">+     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;</span>
<span class="line-added">+     Layout&amp; m_layout;</span>
<span class="line-added">+     unsigned m_variableCount { 0 };</span>
<span class="line-added">+     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;</span>
<span class="line-added">+     Indentation&lt;4&gt; m_indent { 0 };</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // We inline native function calls.</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto iterator = m_functionMapping.find(&amp;functionDefinition);</span>
<span class="line-added">+     ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-added">+     if (functionDefinition.entryPointType()) {</span>
<span class="line-added">+         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);</span>
<span class="line-added">+         if (!entryPointScaffolding)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         m_entryPointScaffolding = WTFMove(entryPointScaffolding);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);</span>
<span class="line-added">+         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
<span class="line-added">+         {</span>
<span class="line-added">+             IndentationScope scope(m_indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);</span>
<span class="line-added">+ </span>
              for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<span class="line-modified">!                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);</span>
                  ASSERT_UNUSED(addResult, addResult.isNewEntry);
              }
              checkErrorAndVisit(functionDefinition.block());
              ASSERT(m_stack.isEmpty());
          }
<span class="line-added">+         m_stringBuilder.append(&quot;}\n\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_entryPointScaffolding = nullptr;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         ASSERT(m_entryPointScaffolding == nullptr);</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);</span>
<span class="line-added">+         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {</span>
<span class="line-added">+             auto&amp; parameter = functionDefinition.parameters()[i];</span>
<span class="line-added">+             if (i)</span>
<span class="line-added">+                 m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">+             auto parameterName = generateNextVariableName();</span>
<span class="line-added">+             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);</span>
<span class="line-added">+             ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">+             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         m_stringBuilder.append(&quot;)\n&quot;);</span>
<span class="line-added">+         checkErrorAndVisit(functionDefinition.block());</span>
<span class="line-added">+         ASSERT(m_stack.isEmpty());</span>
<span class="line-added">+         m_stringBuilder.append(&#39;\n&#39;);</span>
      }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT_NOT_REACHED();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Visitor::visit(statement);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::Block&amp; block)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
      {
<span class="line-modified">!         IndentationScope scope(m_indent);</span>
          for (auto&amp; statement : block.statements())
              checkErrorAndVisit(statement);
      }
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::Break&amp;)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(m_currentBreakContext);</span>
<span class="line-added">+     switch (*m_currentBreakContext) {</span>
<span class="line-added">+     case BreakContext::Switch:</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case BreakContext::Loop:</span>
<span class="line-added">+         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);</span>
<span class="line-added">+         m_stringBuilder.append(</span>
<span class="line-added">+             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,</span>
<span class="line-added">+             m_indent, &quot;break;\n&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+         break;</span>
      }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::Continue&amp;)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);</span>
<span class="line-modified">!     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());</span>
<span class="line-modified">!     takeLastValue(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());</span>
  
<span class="line-modified">!     m_stringBuilder.append(</span>
<span class="line-added">+         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,</span>
<span class="line-added">+         m_indent, &quot;while (true) {\n&quot;</span>
<span class="line-added">+     );</span>
      {
<span class="line-modified">!         IndentationScope whileScope(m_indent);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {</span>
<span class="line-modified">!             checkErrorAndVisit(*conditionExpression);</span>
<span class="line-modified">!             m_stringBuilder.append(</span>
<span class="line-modified">!                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-modified">!                 m_indent, &quot;    break;\n&quot;);</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);</span>
<span class="line-modified">!         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);</span>
<span class="line-modified">! </span>
<span class="line-added">+         {</span>
<span class="line-added">+             IndentationScope doScope(m_indent);</span>
<span class="line-added">+             checkErrorAndVisit(body);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_stringBuilder.append(</span>
<span class="line-added">+             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,</span>
<span class="line-added">+             m_indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (increment) {</span>
<span class="line-added">+             checkErrorAndVisit(*increment);</span>
<span class="line-added">+             // Expression results get pushed to m_stack. We don&#39;t use the result</span>
<span class="line-added">+             // of increment, so we dispense of that now.</span>
<span class="line-added">+             takeLastValue();</span>
          }
<span class="line-modified">! </span>
<span class="line-added">+         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {</span>
<span class="line-added">+             checkErrorAndVisit(*conditionExpression);</span>
<span class="line-added">+             m_stringBuilder.append(</span>
<span class="line-added">+                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-added">+                 m_indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;} \n&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
<span class="line-added">+     {</span>
<span class="line-added">+         IndentationScope scope(m_indent);</span>
<span class="line-added">+         checkErrorAndVisit(forLoop.initialization());</span>
<span class="line-added">+         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());</span>
      }
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     checkErrorAndVisit(ifStatement.conditional());</span>
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;if (&quot;, takeLastValue(), &quot;) {\n&quot;);</span>
      {
<span class="line-modified">!         IndentationScope ifScope(m_indent);</span>
          checkErrorAndVisit(ifStatement.body());
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (ifStatement.elseBody()) {</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);</span>
<span class="line-added">+         {</span>
<span class="line-added">+             IndentationScope elseScope(m_indent);</span>
              checkErrorAndVisit(*ifStatement.elseBody());
          }
      }
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (returnStatement.value()) {</span>
<span class="line-modified">!         checkErrorAndVisit(*returnStatement.value());</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (m_entryPointScaffolding) {</span>
<span class="line-modified">!             auto variableName = generateNextVariableName();</span>
<span class="line-modified">!             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, takeLastValue(), variableName, m_indent);</span>
<span class="line-modified">!             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);</span>
          } else
<span class="line-modified">!             m_stringBuilder.append(m_indent, &quot;return &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="line-modified">!     } else</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     checkErrorAndVisit(switchStatement.value());</span>
  
<span class="line-modified">!     m_stringBuilder.append(m_indent, &quot;switch (&quot;, takeLastValue(), &quot;) {&quot;);</span>
<span class="line-added">+     {</span>
<span class="line-added">+         IndentationScope switchScope(m_indent);</span>
          for (auto&amp; switchCase : switchStatement.switchCases())
              checkErrorAndVisit(switchCase);
      }
<span class="line-added">+     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (switchCase.value()) {</span>
<span class="line-modified">!         m_stringBuilder.append(m_indent, &quot;case &quot;);</span>
<span class="line-modified">!         emitConstantExpressionString(*switchCase.value());</span>
<span class="line-modified">!         m_stringBuilder.append(&quot;:\n&quot;);</span>
<span class="line-modified">!     } else</span>
<span class="line-modified">!         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);</span>
<span class="line-modified">!     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);</span>
<span class="line-modified">!     checkErrorAndVisit(switchCase.block());</span>
<span class="line-added">+     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Visitor::visit(variableDeclarationsStatement);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto variableName = generateNextVariableName();</span>
<span class="line-modified">!     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());</span>
<span class="line-added">+     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-added">+     appendRightValue(integerLiteral, variableName);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto variableName = generateNextVariableName();</span>
<span class="line-modified">!     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">!     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-modified">!     appendRightValue(unsignedIntegerLiteral, variableName);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto variableName = generateNextVariableName();</span>
<span class="line-modified">!     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());</span>
<span class="line-modified">!     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-modified">!     appendRightValue(floatLiteral, variableName);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto&amp; unifyNode = nullLiteral.resolvedType().unifyNode();</span>
<span class="line-modified">!     auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">!     bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto variableName = generateNextVariableName();</span>
<span class="line-modified">!     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;);</span>
<span class="line-added">+     if (isArrayReferenceType)</span>
<span class="line-added">+         m_stringBuilder.append(&quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_stringBuilder.append(&quot;nullptr;\n&quot;);</span>
<span class="line-added">+     appendRightValue(nullLiteral, variableName);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto variableName = generateNextVariableName();</span>
<span class="line-modified">!     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());</span>
<span class="line-modified">!     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;);</span>
<span class="line-modified">!     appendRightValue(booleanLiteral, variableName);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">!     ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">!     auto variableName = generateNextVariableName();</span>
<span class="line-modified">!     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());</span>
<span class="line-modified">!     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;);</span>
<span class="line-modified">!     appendRightValue(enumerationMemberLiteral, variableName);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Visitor::visit(expression);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     // This should be lowered already.</span>
<span class="line-modified">!     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">!     notImplemented();</span>
<span class="line-modified">!     appendRightValue(dotExpression, generateNextVariableName());</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto valueName = generateNextVariableName();</span>
<span class="line-modified">!     MangledTypeName mangledTypeName = m_typeNamer.mangledNameForType(globalVariableReference.resolvedType());</span>
  
<span class="line-modified">!     checkErrorAndVisit(globalVariableReference.base());</span>
<span class="line-modified">!     MangledVariableName structVariable = takeLastValue();</span>
  
<span class="line-modified">!     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>
  
<span class="line-modified">!     m_stringBuilder.append(</span>
<span class="line-modified">!         m_indent, mangledTypeName, &#39; &#39;, valueName, &quot; = &quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
  
<span class="line-modified">!     appendLeftValue(globalVariableReference, valueName, { }, Nullability::NotNull,</span>
<span class="line-modified">!         [this, mangledTypeName, structVariable, mangledFieldName] {</span>
<span class="line-modified">!             auto pointerName = generateNextVariableName();</span>
<span class="line-modified">!             m_stringBuilder.append(</span>
<span class="line-modified">!                 m_indent, &quot;thread &quot;, mangledTypeName, &quot;* &quot;, pointerName, &quot; = &amp;&quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
<span class="line-modified">!             return pointerName;</span>
<span class="line-modified">!         });</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     // This should be lowered already.</span>
<span class="line-modified">!     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">!     notImplemented();</span>
<span class="line-modified">!     appendRightValue(indexExpression, generateNextVariableName());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // This should be lowered already.</span>
<span class="line-added">+     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-added">+     notImplemented();</span>
<span class="line-added">+     appendRightValue(propertyAccessExpression, generateNextVariableName());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(variableDeclaration.type());</span>
<span class="line-added">+     auto variableName = generateNextVariableName();</span>
<span class="line-added">+     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);</span>
<span class="line-added">+     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">+     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.</span>
<span class="line-added">+     if (variableDeclaration.initializer()) {</span>
<span class="line-added">+         checkErrorAndVisit(*variableDeclaration.initializer());</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     checkErrorAndVisit(assignmentExpression.left());</span>
<span class="line-added">+     auto [pointerName, nullability] = takeLastLeftValue();</span>
<span class="line-added">+     checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-added">+     auto [rightName, rightNullability] = takeLastValueAndNullability();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (nullability == Nullability::CanBeNull)</span>
<span class="line-added">+         m_stringBuilder.append(</span>
<span class="line-added">+             m_indent, &quot;if (&quot;, pointerName, &quot;)\n&quot;,</span>
<span class="line-added">+             m_indent, &quot;    *&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, &quot;*&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-added">+     appendRightValueWithNullability(assignmentExpression, rightName, rightNullability);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;MangledVariableName&gt; argumentNames;</span>
<span class="line-added">+     for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-added">+         checkErrorAndVisit(argument);</span>
<span class="line-added">+         argumentNames.append(takeLastValue());</span>
      }
  
<span class="line-modified">!     bool isVoid = matches(callExpression.resolvedType(), m_intrinsics.voidType());</span>
<span class="line-modified">!     MangledVariableName returnName;</span>
<span class="line-modified">!     if (!isVoid) {</span>
<span class="line-modified">!         returnName = generateNextVariableName();</span>
<span class="line-modified">!         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(callExpression.resolvedType()), &#39; &#39;, returnName, &quot;;\n&quot;);</span>
      }
  
<span class="line-modified">!     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {</span>
<span class="line-modified">!         auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">!             return this-&gt;generateNextVariableName();</span>
<span class="line-modified">!         };</span>
<span class="line-modified">! </span>
<span class="line-modified">!         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">!         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), returnName, argumentNames, m_intrinsics, m_typeNamer, WTFMove(generateNextVariableName), m_indent);</span>
<span class="line-modified">!         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         m_stringBuilder.append(m_indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto iterator = m_functionMapping.find(&amp;callExpression.function());</span>
          ASSERT(iterator != m_functionMapping.end());
<span class="line-modified">!         if (!isVoid)</span>
<span class="line-modified">!             m_stringBuilder.append(returnName, &quot; = &quot;);</span>
<span class="line-added">+         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);</span>
          for (size_t i = 0; i &lt; argumentNames.size(); ++i) {
              if (i)
                  m_stringBuilder.append(&quot;, &quot;);
              m_stringBuilder.append(argumentNames[i]);
          }
          m_stringBuilder.append(&quot;);\n&quot;);
      }
  
<span class="line-modified">!     appendRightValue(callExpression, returnName);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Optional&lt;MangledVariableName&gt; result;</span>
<span class="line-modified">!     for (auto&amp; expression : commaExpression.list()) {</span>
<span class="line-modified">!         checkErrorAndVisit(expression);</span>
<span class="line-modified">!         result = takeLastValue();</span>
      }
<span class="line-added">+     ASSERT(result);</span>
<span class="line-added">+     appendRightValue(commaExpression, *result);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     checkErrorAndVisit(dereferenceExpression.pointer());</span>
<span class="line-modified">!     auto [inputPointer, nullability] = takeLastValueAndNullability();</span>
<span class="line-modified">!     auto resultValue = generateNextVariableName();</span>
<span class="line-modified">!     auto resultType = m_typeNamer.mangledNameForType(dereferenceExpression.resolvedType());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (nullability == Nullability::CanBeNull) {</span>
<span class="line-modified">!         m_stringBuilder.append(</span>
<span class="line-modified">!             m_indent, resultType , &#39; &#39;, resultValue, &quot; = &quot;, inputPointer, &quot; ? &quot;, &#39;*&#39;, inputPointer, &quot; : &quot;, resultType, &quot;{ };\n&quot;);</span>
<span class="line-modified">!     } else</span>
<span class="line-modified">!         m_stringBuilder.append(m_indent, resultValue, &quot; = *&quot;, inputPointer, &quot;;\n&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     appendLeftValue(dereferenceExpression, resultValue, inputPointer, nullability);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     checkErrorAndVisit(logicalExpression.left());</span>
<span class="line-added">+     auto left = takeLastValue();</span>
<span class="line-added">+     checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-added">+     auto right = takeLastValue();</span>
<span class="line-added">+     auto variableName = generateNextVariableName();</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_stringBuilder.append(</span>
<span class="line-added">+         m_indent, m_typeNamer.mangledNameForType(logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left);</span>
<span class="line-added">+     switch (logicalExpression.type()) {</span>
<span class="line-added">+     case AST::LogicalExpression::Type::And:</span>
<span class="line-added">+         m_stringBuilder.append(&quot; &amp;&amp; &quot;);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
<span class="line-added">+         m_stringBuilder.append(&quot; || &quot;);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     m_stringBuilder.append(right, &quot;;\n&quot;);</span>
<span class="line-added">+     appendRightValue(logicalExpression, variableName);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     checkErrorAndVisit(logicalNotExpression.operand());</span>
<span class="line-added">+     auto operand = takeLastValue();</span>
<span class="line-added">+     auto variableName = generateNextVariableName();</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_stringBuilder.append(</span>
<span class="line-added">+         m_indent, m_typeNamer.mangledNameForType(logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;);</span>
<span class="line-added">+     appendRightValue(logicalNotExpression, variableName);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-added">+     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.</span>
<span class="line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=198838</span>
<span class="line-added">+     auto variableName = generateNextVariableName();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());</span>
<span class="line-added">+     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {</span>
<span class="line-added">+         auto ptrValue = takeLastValue();</span>
<span class="line-added">+         m_stringBuilder.append(</span>
<span class="line-added">+             m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, ptrValue, &quot; ? &quot;, mangledTypeName, &quot;{ &quot;, ptrValue, &quot;, 1 } : &quot;, mangledTypeName, &quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-added">+     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {</span>
<span class="line-added">+         auto lValue = takeLastLeftValue().value;</span>
<span class="line-added">+         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;-&gt;data(), &quot;, arrayType.numElements(), &quot; };\n&quot;);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         auto lValue = takeLastLeftValue().value;</span>
<span class="line-added">+         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     appendRightValue(makeArrayReferenceExpression, variableName);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     checkErrorAndVisit(makePointerExpression.leftValue());</span>
<span class="line-added">+     auto [pointer, nullability] = takeLastLeftValue();</span>
<span class="line-added">+     auto variableName = generateNextVariableName();</span>
<span class="line-added">+     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, pointer, &quot;;\n&quot;);</span>
<span class="line-added">+     appendRightValueWithNullability(makePointerExpression, variableName, nullability);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // This should be lowered already.</span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     checkErrorAndVisit(ternaryExpression.predicate());</span>
<span class="line-added">+     auto check = takeLastValue();</span>
<span class="line-added">+     checkErrorAndVisit(ternaryExpression.bodyExpression());</span>
<span class="line-added">+     auto body = takeLastValue();</span>
<span class="line-added">+     checkErrorAndVisit(ternaryExpression.elseExpression());</span>
<span class="line-added">+     auto elseBody = takeLastValue();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto variableName = generateNextVariableName();</span>
<span class="line-added">+     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, check, &quot; ? &quot;, body, &quot; : &quot;, elseBody, &quot;;\n&quot;);</span>
<span class="line-added">+     appendRightValue(ternaryExpression, variableName);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(variableReference.variable());</span>
<span class="line-added">+     auto iterator = m_variableMapping.find(variableReference.variable());</span>
<span class="line-added">+     ASSERT(iterator != m_variableMapping.end());</span>
<span class="line-added">+ </span>
<span class="line-added">+     MangledVariableName variableName = iterator-&gt;value;</span>
<span class="line-added">+ </span>
<span class="line-added">+     appendLeftValue(variableReference, variableName, { }, Nullability::NotNull,</span>
<span class="line-added">+         [this, &amp;variableReference, variableName] {</span>
<span class="line-added">+             auto pointerName = generateNextVariableName();</span>
<span class="line-added">+             m_stringBuilder.append(m_indent, &quot;thread &quot;, m_typeNamer.mangledNameForType(variableReference.resolvedType()), &quot;* &quot;, pointerName, &quot; = &amp;&quot;, variableName, &quot;;\n&quot;);</span>
<span class="line-added">+             return pointerName;</span>
<span class="line-added">+         });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     constantExpression.visit(WTF::makeVisitor(</span>
<span class="line-added">+         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-added">+             m_stringBuilder.append(integerLiteral.value());</span>
<span class="line-added">+         },</span>
<span class="line-added">+         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-added">+             m_stringBuilder.append(unsignedIntegerLiteral.value());</span>
<span class="line-added">+         },</span>
<span class="line-added">+         [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-added">+             m_stringBuilder.append(floatLiteral.value());</span>
<span class="line-added">+         },</span>
<span class="line-added">+         [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-added">+             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-added">+         },</span>
<span class="line-added">+         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {</span>
<span class="line-added">+             if (booleanLiteral.value())</span>
<span class="line-added">+                 m_stringBuilder.append(&quot;true&quot;);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 m_stringBuilder.append(&quot;false&quot;);</span>
<span class="line-added">+         },</span>
<span class="line-added">+         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
<span class="line-added">+             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-added">+             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-added">+             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>
          }
<span class="line-modified">!     ));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">+         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)</span>
<span class="line-added">+         , m_matchedSemantics(WTFMove(matchedSemantics))</span>
      {
      }
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;</span>
  
<span class="line-modified">!     MatchedRenderSemantics m_matchedSemantics;</span>
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-modified">! std::unique_ptr&lt;EntryPointScaffolding&gt; RenderFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">!         return this-&gt;generateNextVariableName();</span>
<span class="line-modified">!     };</span>
<span class="line-modified">!     if (&amp;functionDefinition == m_matchedSemantics.vertexShader)</span>
<span class="line-added">+         return makeUnique&lt;VertexEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.vertexShaderEntryPointItems, m_matchedSemantics.vertexShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedVertexAttributes);</span>
<span class="line-added">+     if (&amp;functionDefinition == m_matchedSemantics.fragmentShader)</span>
<span class="line-added">+         return makeUnique&lt;FragmentEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.fragmentShaderEntryPointItems, m_matchedSemantics.fragmentShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedColorAttachments);</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! class ComputeFunctionDefinitionWriter final : public FunctionDefinitionWriter {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     ComputeFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">+         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)</span>
<span class="line-added">+         , m_matchedSemantics(WTFMove(matchedSemantics))</span>
      {
      }
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     MatchedComputeSemantics m_matchedSemantics;</span>
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-modified">! std::unique_ptr&lt;EntryPointScaffolding&gt; ComputeFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">!         return this-&gt;generateNextVariableName();</span>
<span class="line-modified">!     };</span>
<span class="line-modified">!     if (&amp;functionDefinition == m_matchedSemantics.shader)</span>
<span class="line-modified">!         return makeUnique&lt;ComputeEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.entryPointItems, m_matchedSemantics.resourceMap, m_layout, WTFMove(generateNextVariableName));</span>
<span class="line-modified">!     return nullptr;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; generateMetalFunctionsMapping(Program&amp; program)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     unsigned numFunctions = 0;</span>
<span class="line-added">+     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; functionMapping;</span>
<span class="line-added">+     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">+         auto addResult = functionMapping.add(&amp;functionDefinition, MangledFunctionName { numFunctions++ });</span>
<span class="line-added">+         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
      }
  
<span class="line-modified">!     return functionMapping;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void emitSharedMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, const HashSet&lt;AST::FunctionDeclaration*&gt;&amp; reachableFunctions, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">+         if (!functionDefinition-&gt;entryPointType() &amp;&amp; reachableFunctions.contains(&amp;functionDefinition))</span>
<span class="line-added">+             declareFunction(stringBuilder, functionDefinition, typeNamer, functionMapping);</span>
      }
  
<span class="line-modified">!     stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ReachableFunctionsGatherer final : public Visitor {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override</span>
      {
<span class="line-modified">!         auto result = m_reachableFunctions.add(&amp;functionDeclaration);</span>
<span class="line-modified">!         if (result.isNewEntry)</span>
<span class="line-modified">!             Visitor::visit(functionDeclaration);</span>
      }
  
<span class="line-modified">!     void visit(AST::CallExpression&amp; callExpression) override</span>
      {
<span class="line-modified">!         Visitor::visit(callExpression);</span>
<span class="line-added">+         if (is&lt;AST::FunctionDefinition&gt;(callExpression.function()))</span>
<span class="line-added">+             checkErrorAndVisit(downcast&lt;AST::FunctionDefinition&gt;(callExpression.function()));</span>
<span class="line-added">+         else</span>
<span class="line-added">+             checkErrorAndVisit(downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()));</span>
      }
  
<span class="line-added">+     HashSet&lt;AST::FunctionDeclaration*&gt; takeReachableFunctions() { return WTFMove(m_reachableFunctions); }</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     HashSet&lt;AST::FunctionDeclaration*&gt; m_reachableFunctions;</span>
  };
  
<span class="line-modified">! RenderMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
  {
<span class="line-modified">!     auto&amp; vertexShaderEntryPoint = *matchedSemantics.vertexShader;</span>
<span class="line-added">+     auto* fragmentShaderEntryPoint = matchedSemantics.fragmentShader;</span>
  
<span class="line-modified">!     ReachableFunctionsGatherer reachableFunctionsGatherer;</span>
<span class="line-modified">!     reachableFunctionsGatherer.Visitor::visit(vertexShaderEntryPoint);</span>
<span class="line-modified">!     if (fragmentShaderEntryPoint)</span>
<span class="line-modified">!         reachableFunctionsGatherer.Visitor::visit(*fragmentShaderEntryPoint);</span>
<span class="line-modified">!     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();</span>
<span class="line-modified">! </span>
<span class="line-added">+     auto functionMapping = generateMetalFunctionsMapping(program);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);</span>
<span class="line-added">+ </span>
<span class="line-added">+     RenderFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);</span>
      for (auto&amp; functionDefinition : program.functionDefinitions()) {
<span class="line-modified">!         if (reachableFunctions.contains(&amp;functionDefinition))</span>
<span class="line-modified">!             functionDefinitionWriter.visit(functionDefinition);</span>
      }
  
<span class="line-modified">!     return { functionMapping.get(&amp;vertexShaderEntryPoint), fragmentShaderEntryPoint ? functionMapping.get(fragmentShaderEntryPoint) : MangledFunctionName { 0 } };</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! ComputeMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; entryPoint = *matchedSemantics.shader;</span>
  
<span class="line-modified">!     ReachableFunctionsGatherer reachableFunctionsGatherer;</span>
<span class="line-modified">!     reachableFunctionsGatherer.Visitor::visit(entryPoint);</span>
<span class="line-modified">!     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto functionMapping = generateMetalFunctionsMapping(program);</span>
<span class="line-added">+     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ComputeFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);</span>
<span class="line-added">+     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">+         if (reachableFunctions.contains(&amp;functionDefinition))</span>
              functionDefinitionWriter.visit(functionDefinition);
      }
  
<span class="line-modified">!     return { functionMapping.get(&amp;entryPoint) };</span>
  }
  
  } // namespace Metal
  
  } // namespace WHLSL
</pre>
<center><a href="WHLSLEntryPointScaffolding.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLFunctionWriter.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>