<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGSpeculativeJIT.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;AtomicsObject.h&quot;
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  35 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  36 #include &quot;DFGDoesGC.h&quot;
  37 #include &quot;DFGOperations.h&quot;
  38 #include &quot;DFGSlowPathGenerator.h&quot;
  39 #include &quot;DirectArguments.h&quot;
  40 #include &quot;GetterSetter.h&quot;
  41 #include &quot;HasOwnPropertyCache.h&quot;
  42 #include &quot;JSCInlines.h&quot;
  43 #include &quot;JSLexicalEnvironment.h&quot;
  44 #include &quot;JSMap.h&quot;
  45 #include &quot;JSPropertyNameEnumerator.h&quot;
  46 #include &quot;JSSet.h&quot;
  47 #include &quot;ObjectPrototype.h&quot;
  48 #include &quot;SetupVarargsFrame.h&quot;
  49 #include &quot;SpillRegistersMode.h&quot;
  50 #include &quot;StringPrototype.h&quot;
  51 #include &quot;SuperSampler.h&quot;
  52 #include &quot;Watchdog.h&quot;
  53 
  54 namespace JSC { namespace DFG {
  55 
  56 #if USE(JSVALUE64)
  57 
  58 void SpeculativeJIT::boxInt52(GPRReg sourceGPR, GPRReg targetGPR, DataFormat format)
  59 {
  60     GPRReg tempGPR;
  61     if (sourceGPR == targetGPR)
  62         tempGPR = allocate();
  63     else
  64         tempGPR = targetGPR;
  65 
  66     FPRReg fpr = fprAllocate();
  67 
  68     if (format == DataFormatInt52)
  69         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), sourceGPR);
  70     else
  71         ASSERT(format == DataFormatStrictInt52);
  72 
  73     m_jit.boxInt52(sourceGPR, targetGPR, tempGPR, fpr);
  74 
  75     if (format == DataFormatInt52 &amp;&amp; sourceGPR != targetGPR)
  76         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), sourceGPR);
  77 
  78     if (tempGPR != targetGPR)
  79         unlock(tempGPR);
  80 
  81     unlock(fpr);
  82 }
  83 
  84 GPRReg SpeculativeJIT::fillJSValue(Edge edge)
  85 {
  86     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  87     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  88 
  89     switch (info.registerFormat()) {
  90     case DataFormatNone: {
  91         GPRReg gpr = allocate();
  92 
  93         if (edge-&gt;hasConstant()) {
  94             JSValue jsValue = edge-&gt;asJSValue();
  95             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
  96             info.fillJSValue(*m_stream, gpr, DataFormatJS);
  97             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
  98         } else {
  99             DataFormat spillFormat = info.spillFormat();
 100             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 101             switch (spillFormat) {
 102             case DataFormatInt32: {
 103                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 104                 m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);
 105                 spillFormat = DataFormatJSInt32;
 106                 break;
 107             }
 108 
 109             default:
 110                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 111                 DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat &amp; DataFormatJS, spillFormat);
 112                 break;
 113             }
 114             info.fillJSValue(*m_stream, gpr, spillFormat);
 115         }
 116         return gpr;
 117     }
 118 
 119     case DataFormatInt32: {
 120         GPRReg gpr = info.gpr();
 121         // If the register has already been locked we need to take a copy.
 122         // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 123         if (m_gprs.isLocked(gpr)) {
 124             GPRReg result = allocate();
 125             m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr, result);
 126             return result;
 127         }
 128         m_gprs.lock(gpr);
 129         m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);
 130         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 131         return gpr;
 132     }
 133 
 134     case DataFormatCell:
 135         // No retag required on JSVALUE64!
 136     case DataFormatJS:
 137     case DataFormatJSInt32:
 138     case DataFormatJSDouble:
 139     case DataFormatJSCell:
 140     case DataFormatJSBoolean: {
 141         GPRReg gpr = info.gpr();
 142         m_gprs.lock(gpr);
 143         return gpr;
 144     }
 145 
 146     case DataFormatBoolean:
 147     case DataFormatStorage:
 148     case DataFormatDouble:
 149     case DataFormatInt52:
 150         // this type currently never occurs
 151         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
 152 
 153     default:
 154         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
 155         return InvalidGPRReg;
 156     }
 157 }
 158 
 159 void SpeculativeJIT::cachedGetById(CodeOrigin origin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget , SpillRegistersMode mode, AccessType type)
 160 {
 161     cachedGetById(origin, base.gpr(), result.gpr(), identifierNumber, slowPathTarget, mode, type);
 162 }
 163 
 164 void SpeculativeJIT::cachedGetById(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg resultGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode, AccessType type)
 165 {
 166     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 167     RegisterSet usedRegisters = this-&gt;usedRegisters();
 168     if (spillMode == DontSpill) {
 169         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 170         usedRegisters.set(baseGPR, false);
 171         usedRegisters.set(resultGPR, false);
 172     }
 173     JITGetByIdGenerator gen(
 174         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 175         JSValueRegs(baseGPR), JSValueRegs(resultGPR), type);
 176     gen.generateFastPath(m_jit);
 177 
 178     JITCompiler::JumpList slowCases;
 179     slowCases.append(slowPathTarget);
 180     slowCases.append(gen.slowPathJump());
 181 
 182     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 183         slowCases, this, appropriateOptimizingGetByIdFunction(type),
 184         spillMode, ExceptionCheckRequirement::CheckNeeded,
 185         resultGPR, gen.stubInfo(), baseGPR, identifierUID(identifierNumber));
 186 
 187     m_jit.addGetById(gen, slowPath.get());
 188     addSlowPathGenerator(WTFMove(slowPath));
 189 }
 190 
 191 void SpeculativeJIT::cachedGetByIdWithThis(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 192 {
 193     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 194     RegisterSet usedRegisters = this-&gt;usedRegisters();
 195     // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 196     usedRegisters.set(baseGPR, false);
 197     usedRegisters.set(thisGPR, false);
 198     usedRegisters.set(resultGPR, false);
 199 
 200     JITGetByIdWithThisGenerator gen(
 201         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 202         JSValueRegs(resultGPR), JSValueRegs(baseGPR), JSValueRegs(thisGPR), AccessType::GetWithThis);
 203     gen.generateFastPath(m_jit);
 204 
 205     JITCompiler::JumpList slowCases;
 206     slowCases.append(slowPathTarget);
 207     slowCases.append(gen.slowPathJump());
 208 
 209     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 210         slowCases, this, operationGetByIdWithThisOptimize,
 211         DontSpill, ExceptionCheckRequirement::CheckNeeded,
 212         resultGPR, gen.stubInfo(), baseGPR, thisGPR, identifierUID(identifierNumber));
 213 
 214     m_jit.addGetByIdWithThis(gen, slowPath.get());
 215     addSlowPathGenerator(WTFMove(slowPath));
 216 }
 217 
 218 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 219 {
<a name="1" id="anc1"></a>

 220     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 221     GPRReg argGPR = arg.gpr();
 222 
 223     GPRTemporary result(this);
 224     GPRReg resultGPR = result.gpr();
 225 
 226     m_jit.move(TrustedImm32(0), resultGPR);
 227 
 228     JITCompiler::JumpList done;
 229     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 230         if (!isKnownNotCell(operand.node()))
 231             done.append(m_jit.branchIfCell(JSValueRegs(argGPR)));
 232     } else {
 233         GPRTemporary localGlobalObject(this);
 234         GPRTemporary remoteGlobalObject(this);
 235         GPRTemporary scratch(this);
 236 
 237         JITCompiler::Jump notCell;
 238         if (!isKnownCell(operand.node()))
 239             notCell = m_jit.branchIfNotCell(JSValueRegs(argGPR));
 240 
 241         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
 242             JITCompiler::Zero,
 243             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 244             JITCompiler::TrustedImm32(MasqueradesAsUndefined));
 245         done.append(isNotMasqueradesAsUndefined);
 246 
 247         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 248         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 249         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
<a name="2" id="anc2"></a><span class="line-modified"> 250         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());</span>
 251         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 252         m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, resultGPR);
 253         done.append(m_jit.jump());
 254         if (!isKnownCell(operand.node()))
 255             notCell.link(&amp;m_jit);
 256     }
 257 
 258     if (!isKnownNotOther(operand.node())) {
 259         m_jit.move(argGPR, resultGPR);
 260         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);
 261         m_jit.compare64(JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(ValueNull), resultGPR);
 262     }
 263 
 264     done.link(&amp;m_jit);
 265 
 266     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
 267     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
 268 }
 269 
 270 void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
 271 {
 272     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 273     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 274 
 275     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 276     GPRReg argGPR = arg.gpr();
 277 
 278     GPRTemporary result(this, Reuse, arg);
 279     GPRReg resultGPR = result.gpr();
 280 
 281     // First, handle the case where &quot;operand&quot; is a cell.
 282     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 283         if (!isKnownNotCell(operand.node())) {
 284             JITCompiler::Jump isCell = m_jit.branchIfCell(JSValueRegs(argGPR));
 285             addBranch(isCell, notTaken);
 286         }
 287     } else {
 288         GPRTemporary localGlobalObject(this);
 289         GPRTemporary remoteGlobalObject(this);
 290         GPRTemporary scratch(this);
 291 
 292         JITCompiler::Jump notCell;
 293         if (!isKnownCell(operand.node()))
 294             notCell = m_jit.branchIfNotCell(JSValueRegs(argGPR));
 295 
 296         branchTest8(JITCompiler::Zero,
 297             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 298             JITCompiler::TrustedImm32(MasqueradesAsUndefined), notTaken);
 299 
 300         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 301         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 302         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
<a name="3" id="anc3"></a><span class="line-modified"> 303         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());</span>
 304         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 305         branchPtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, taken);
 306 
 307         if (!isKnownCell(operand.node())) {
 308             jump(notTaken, ForceJump);
 309             notCell.link(&amp;m_jit);
 310         }
 311     }
 312 
 313     if (isKnownNotOther(operand.node()))
 314         jump(notTaken);
 315     else {
 316         JITCompiler::RelationalCondition condition = JITCompiler::Equal;
 317         if (taken == nextBlock()) {
 318             condition = JITCompiler::NotEqual;
 319             std::swap(taken, notTaken);
 320         }
 321         m_jit.move(argGPR, resultGPR);
 322         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);
 323         branch64(condition, resultGPR, JITCompiler::TrustedImm64(ValueNull), taken);
 324         jump(notTaken);
 325     }
 326 }
 327 
 328 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
 329 {
 330     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 331     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 332 
 333     // The branch instruction will branch to the taken block.
 334     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 335     if (taken == nextBlock()) {
 336         invert = !invert;
 337         BasicBlock* tmp = taken;
 338         taken = notTaken;
 339         notTaken = tmp;
 340     }
 341 
 342     JSValueOperand arg1(this, node-&gt;child1());
 343     JSValueOperand arg2(this, node-&gt;child2());
 344     GPRReg arg1GPR = arg1.gpr();
 345     GPRReg arg2GPR = arg2.gpr();
 346 
 347     GPRTemporary result(this);
 348     GPRReg resultGPR = result.gpr();
 349 
 350     arg1.use();
 351     arg2.use();
 352 
 353     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 354         // see if we get lucky: if the arguments are cells and they reference the same
 355         // cell, then they must be strictly equal.
 356         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 357 
 358         silentSpillAllRegisters(resultGPR);
 359         callOperation(operationCompareStrictEqCell, resultGPR, arg1GPR, arg2GPR);
 360         silentFillAllRegisters();
 361         m_jit.exceptionCheck();
 362 
 363         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 364     } else {
 365         m_jit.or64(arg1GPR, arg2GPR, resultGPR);
 366 
 367         JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 368 
 369         JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1GPR);
 370         JITCompiler::Jump leftDouble = m_jit.branchIfNumber(arg1GPR);
 371         leftOK.link(&amp;m_jit);
 372         JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2GPR);
 373         JITCompiler::Jump rightDouble = m_jit.branchIfNumber(arg2GPR);
 374         rightOK.link(&amp;m_jit);
 375 
 376         branch64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1GPR, arg2GPR, taken);
 377         jump(notTaken, ForceJump);
 378 
 379         twoCellsCase.link(&amp;m_jit);
 380         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 381 
 382         leftDouble.link(&amp;m_jit);
 383         rightDouble.link(&amp;m_jit);
 384 
 385         silentSpillAllRegisters(resultGPR);
 386         callOperation(operationCompareStrictEq, resultGPR, arg1GPR, arg2GPR);
 387         silentFillAllRegisters();
 388         m_jit.exceptionCheck();
 389 
 390         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 391     }
 392 
 393     jump(notTaken);
 394 }
 395 
 396 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 397 {
 398     JSValueOperand arg1(this, node-&gt;child1());
 399     JSValueOperand arg2(this, node-&gt;child2());
 400     JSValueRegs arg1Regs = arg1.jsValueRegs();
 401     JSValueRegs arg2Regs = arg2.jsValueRegs();
 402 
 403     GPRTemporary result(this);
 404     GPRReg resultGPR = result.gpr();
 405 
 406     arg1.use();
 407     arg2.use();
 408 
 409     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 410         // see if we get lucky: if the arguments are cells and they reference the same
 411         // cell, then they must be strictly equal.
 412         // FIXME: this should flush registers instead of silent spill/fill.
 413         JITCompiler::Jump notEqualCase = m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr());
 414 
 415         m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 416 
 417         JITCompiler::Jump done = m_jit.jump();
 418 
 419         notEqualCase.link(&amp;m_jit);
 420 
 421         silentSpillAllRegisters(resultGPR);
 422         callOperation(operationCompareStrictEqCell, resultGPR, arg1Regs, arg2Regs);
 423         silentFillAllRegisters();
 424         m_jit.exceptionCheck();
 425 
 426         done.link(&amp;m_jit);
 427         unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 428         return;
 429     }
 430 
 431     m_jit.or64(arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 432 
 433     JITCompiler::JumpList slowPathCases;
 434 
 435     JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 436 
 437     JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1Regs);
 438     slowPathCases.append(m_jit.branchIfNumber(arg1Regs, InvalidGPRReg));
 439     leftOK.link(&amp;m_jit);
 440     JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2Regs);
 441     slowPathCases.append(m_jit.branchIfNumber(arg2Regs, InvalidGPRReg));
 442     rightOK.link(&amp;m_jit);
 443 
 444     m_jit.compare64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 445 
 446     JITCompiler::Jump done = m_jit.jump();
 447 
 448     twoCellsCase.link(&amp;m_jit);
 449     slowPathCases.append(m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr()));
 450 
 451     m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 452 
 453     addSlowPathGenerator(slowPathCall(slowPathCases, this, operationCompareStrictEq, resultGPR, arg1Regs, arg2Regs));
 454 
 455     done.link(&amp;m_jit);
 456 
 457     unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 458 }
 459 
 460 void SpeculativeJIT::emitCall(Node* node)
 461 {
 462     CallLinkInfo::CallType callType;
 463     bool isVarargs = false;
 464     bool isForwardVarargs = false;
 465     bool isTail = false;
 466     bool isEmulatedTail = false;
 467     bool isDirect = false;
 468     switch (node-&gt;op()) {
 469     case Call:
 470     case CallEval:
 471         callType = CallLinkInfo::Call;
 472         break;
 473     case TailCall:
 474         callType = CallLinkInfo::TailCall;
 475         isTail = true;
 476         break;
 477     case TailCallInlinedCaller:
 478         callType = CallLinkInfo::Call;
 479         isEmulatedTail = true;
 480         break;
 481     case Construct:
 482         callType = CallLinkInfo::Construct;
 483         break;
 484     case CallVarargs:
 485         callType = CallLinkInfo::CallVarargs;
 486         isVarargs = true;
 487         break;
 488     case TailCallVarargs:
 489         callType = CallLinkInfo::TailCallVarargs;
 490         isVarargs = true;
 491         isTail = true;
 492         break;
 493     case TailCallVarargsInlinedCaller:
 494         callType = CallLinkInfo::CallVarargs;
 495         isVarargs = true;
 496         isEmulatedTail = true;
 497         break;
 498     case ConstructVarargs:
 499         callType = CallLinkInfo::ConstructVarargs;
 500         isVarargs = true;
 501         break;
 502     case CallForwardVarargs:
 503         callType = CallLinkInfo::CallVarargs;
 504         isForwardVarargs = true;
 505         break;
 506     case ConstructForwardVarargs:
 507         callType = CallLinkInfo::ConstructVarargs;
 508         isForwardVarargs = true;
 509         break;
 510     case TailCallForwardVarargs:
 511         callType = CallLinkInfo::TailCallVarargs;
 512         isTail = true;
 513         isForwardVarargs = true;
 514         break;
 515     case TailCallForwardVarargsInlinedCaller:
 516         callType = CallLinkInfo::CallVarargs;
 517         isEmulatedTail = true;
 518         isForwardVarargs = true;
 519         break;
 520     case DirectCall:
 521         callType = CallLinkInfo::DirectCall;
 522         isDirect = true;
 523         break;
 524     case DirectConstruct:
 525         callType = CallLinkInfo::DirectConstruct;
 526         isDirect = true;
 527         break;
 528     case DirectTailCall:
 529         callType = CallLinkInfo::DirectTailCall;
 530         isTail = true;
 531         isDirect = true;
 532         break;
 533     case DirectTailCallInlinedCaller:
 534         callType = CallLinkInfo::DirectCall;
 535         isEmulatedTail = true;
 536         isDirect = true;
 537         break;
 538     default:
 539         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 540         break;
 541     }
 542 
 543     GPRReg calleeGPR = InvalidGPRReg;
 544     CallFrameShuffleData shuffleData;
 545 
 546     ExecutableBase* executable = nullptr;
 547     FunctionExecutable* functionExecutable = nullptr;
 548     if (isDirect) {
 549         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
<a name="4" id="anc4"></a><span class="line-modified"> 550         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);</span>
 551     }
 552 
 553     unsigned numPassedArgs = 0;
 554     unsigned numAllocatedArgs = 0;
 555 
 556     // Gotta load the arguments somehow. Varargs is trickier.
 557     if (isVarargs || isForwardVarargs) {
 558         RELEASE_ASSERT(!isDirect);
 559         CallVarargsData* data = node-&gt;callVarargsData();
 560 
 561         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 562 
 563         if (isForwardVarargs) {
 564             flushRegisters();
 565             if (node-&gt;child3())
 566                 use(node-&gt;child3());
 567 
 568             GPRReg scratchGPR1;
 569             GPRReg scratchGPR2;
 570             GPRReg scratchGPR3;
 571 
 572             scratchGPR1 = JITCompiler::selectScratchGPR();
 573             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 574             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 575 
 576             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 577             JITCompiler::JumpList slowCase;
 578             InlineCallFrame* inlineCallFrame;
 579             if (node-&gt;child3())
<a name="5" id="anc5"></a><span class="line-modified"> 580                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();</span>
 581             else
<a name="6" id="anc6"></a><span class="line-modified"> 582                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
 583             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
<a name="7" id="anc7"></a><span class="line-modified"> 584             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);</span>
 585             JITCompiler::Jump done = m_jit.jump();
 586             slowCase.link(&amp;m_jit);
 587             callOperation(operationThrowStackOverflowForVarargs);
 588             m_jit.exceptionCheck();
 589             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 590             done.link(&amp;m_jit);
 591         } else {
 592             GPRReg argumentsGPR;
 593             GPRReg scratchGPR1;
 594             GPRReg scratchGPR2;
 595             GPRReg scratchGPR3;
 596 
 597             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 598                 if (reservedGPR != InvalidGPRReg)
 599                     lock(reservedGPR);
 600                 JSValueOperand arguments(this, node-&gt;child3());
 601                 argumentsGPR = arguments.gpr();
 602                 if (reservedGPR != InvalidGPRReg)
 603                     unlock(reservedGPR);
 604                 flushRegisters();
 605 
 606                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsGPR, reservedGPR);
 607                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, reservedGPR);
 608                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, scratchGPR2, reservedGPR);
 609             };
 610 
 611             loadArgumentsGPR(InvalidGPRReg);
 612 
 613             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 614 
 615             // Right now, arguments is in argumentsGPR and the register file is flushed.
 616             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, argumentsGPR, numUsedStackSlots, data-&gt;firstVarArgOffset);
 617             m_jit.exceptionCheck();
 618 
 619             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 620             // Reconstruct the arguments operand while preserving the callee frame.
 621             loadArgumentsGPR(GPRInfo::returnValueGPR);
 622             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 623             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 624             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 625 
 626             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, scratchGPR1, argumentsGPR, data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);
 627             m_jit.exceptionCheck();
 628             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 629         }
 630 
 631         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 632 
 633         // We don&#39;t need the arguments array anymore.
 634         if (isVarargs)
 635             use(node-&gt;child3());
 636 
 637         // Now set up the &quot;this&quot; argument.
 638         JSValueOperand thisArgument(this, node-&gt;child2());
 639         GPRReg thisArgumentGPR = thisArgument.gpr();
 640         thisArgument.use();
 641 
 642         m_jit.store64(thisArgumentGPR, JITCompiler::calleeArgumentSlot(0));
 643     } else {
 644         // The call instruction&#39;s first child is the function; the subsequent children are the
 645         // arguments.
 646         numPassedArgs = node-&gt;numChildren() - 1;
 647         numAllocatedArgs = numPassedArgs;
 648 
 649         if (functionExecutable) {
 650             // Allocate more args if this would let us avoid arity checks. This is throttled by
 651             // CallLinkInfo&#39;s limit. It&#39;s probably good to throttle it - if the callee wants a
 652             // ginormous amount of argument space then it&#39;s better for them to do it so that when we
 653             // make calls to other things, we don&#39;t waste space.
 654             unsigned desiredNumAllocatedArgs = static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1;
 655             if (desiredNumAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 656                 numAllocatedArgs = std::max(numAllocatedArgs, desiredNumAllocatedArgs);
 657 
 658                 // Whoever converts to DirectCall should do this adjustment. It&#39;s too late for us to
 659                 // do this adjustment now since we will have already emitted code that relied on the
 660                 // value of m_parameterSlots.
 661                 DFG_ASSERT(
 662                     m_jit.graph(), node,
 663                     Graph::parameterSlotsForArgCount(numAllocatedArgs)
 664                     &lt;= m_jit.graph().m_parameterSlots);
 665             }
 666         }
 667 
 668         if (isTail) {
 669             Edge calleeEdge = m_jit.graph().child(node, 0);
 670             JSValueOperand callee(this, calleeEdge);
 671             calleeGPR = callee.gpr();
 672             if (!isDirect)
 673                 callee.use();
 674 
 675             shuffleData.tagTypeNumber = GPRInfo::tagTypeNumberRegister;
 676             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 677             shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatJS);
 678             shuffleData.args.resize(numAllocatedArgs);
 679             shuffleData.numPassedArgs = numPassedArgs;
 680 
 681             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 682                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 683                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 684                 if (!isDirect)
 685                     use(argEdge);
 686                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 687             }
 688 
 689             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 690                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 691 
 692             shuffleData.setupCalleeSaveRegisters(m_jit.codeBlock());
 693         } else {
 694             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), JITCompiler::calleeFramePayloadSlot(CallFrameSlot::argumentCount));
 695 
 696             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 697                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 698                 JSValueOperand arg(this, argEdge);
 699                 GPRReg argGPR = arg.gpr();
 700                 use(argEdge);
 701 
 702                 m_jit.store64(argGPR, JITCompiler::calleeArgumentSlot(i));
 703             }
 704 
 705             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 706                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 707         }
 708     }
 709 
 710     if (!isTail || isVarargs || isForwardVarargs) {
 711         Edge calleeEdge = m_jit.graph().child(node, 0);
 712         JSValueOperand callee(this, calleeEdge);
 713         calleeGPR = callee.gpr();
 714         callee.use();
 715         m_jit.store64(calleeGPR, JITCompiler::calleeFrameSlot(CallFrameSlot::callee));
 716 
 717         flushRegisters();
 718     }
 719 
 720     CodeOrigin staticOrigin = node-&gt;origin.semantic;
<a name="8" id="anc8"></a><span class="line-modified"> 721     InlineCallFrame* staticInlineCallFrame = staticOrigin.inlineCallFrame();</span>
<span class="line-modified"> 722     ASSERT(!isTail || !staticInlineCallFrame || !staticInlineCallFrame-&gt;getCallerSkippingTailCalls());</span>
<span class="line-added"> 723     ASSERT(!isEmulatedTail || (staticInlineCallFrame &amp;&amp; staticInlineCallFrame-&gt;getCallerSkippingTailCalls()));</span>
 724     CodeOrigin dynamicOrigin =
<a name="9" id="anc9"></a><span class="line-modified"> 725         isEmulatedTail ? *staticInlineCallFrame-&gt;getCallerSkippingTailCalls() : staticOrigin;</span>
 726 
 727     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(dynamicOrigin, m_stream-&gt;size());
 728 
 729     auto setResultAndResetStack = [&amp;] () {
 730         GPRFlushedCallResult result(this);
 731         GPRReg resultGPR = result.gpr();
 732         m_jit.move(GPRInfo::returnValueGPR, resultGPR);
 733 
 734         jsValueResult(resultGPR, m_currentNode, DataFormatJS, UseChildrenCalledExplicitly);
 735 
 736         // After the calls are done, we need to reestablish our stack
 737         // pointer. We rely on this for varargs calls, calls with arity
 738         // mismatch (the callframe is slided) and tail calls.
 739         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 740     };
 741 
 742     CallLinkInfo* callLinkInfo = m_jit.codeBlock()-&gt;addCallLinkInfo();
 743     callLinkInfo-&gt;setUpCall(callType, m_currentNode-&gt;origin.semantic, calleeGPR);
 744 
 745     if (node-&gt;op() == CallEval) {
 746         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 747         // which we have created a prototypical eval call frame. This means that we have to
 748         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 749         // register file to ourselves.
 750 
 751         m_jit.emitStoreCallSiteIndex(callSite);
 752         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 753         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 754 
 755         // Now we need to make room for:
 756         // - The caller frame and PC of a call to operationCallEval.
 757         // - Potentially two arguments on the stack.
 758         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;
 759         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 760         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 761         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);
 762         prepareForExternalCall();
 763         m_jit.appendCall(operationCallEval);
 764         m_jit.exceptionCheck();
 765         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR);
 766 
 767         // This is the part where we meant to make a normal call. Oops.
 768         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 769         m_jit.load64(JITCompiler::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<a name="10" id="anc10"></a><span class="line-modified"> 770         m_jit.emitDumbVirtualCall(vm(), callLinkInfo);</span>
 771 
 772         done.link(&amp;m_jit);
 773         setResultAndResetStack();
 774         return;
 775     }
 776 
 777     if (isDirect) {
 778         callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 779         callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);
 780 
 781         if (isTail) {
 782             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 783 
 784             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 785             JITCompiler::Label mainPath = m_jit.label();
 786 
 787             m_jit.emitStoreCallSiteIndex(callSite);
 788 
 789             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 790             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 791 
 792             JITCompiler::Call call = m_jit.nearTailCall();
 793 
 794             JITCompiler::Label slowPath = m_jit.label();
 795             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 796 
 797             silentSpillAllRegisters(InvalidGPRReg);
 798             callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 799             silentFillAllRegisters();
 800             m_jit.exceptionCheck();
 801             m_jit.jump().linkTo(mainPath, &amp;m_jit);
 802 
 803             useChildren(node);
 804 
 805             m_jit.addJSDirectTailCall(patchableJump, call, slowPath, callLinkInfo);
 806             return;
 807         }
 808 
 809         JITCompiler::Label mainPath = m_jit.label();
 810 
 811         m_jit.emitStoreCallSiteIndex(callSite);
 812 
 813         JITCompiler::Call call = m_jit.nearCall();
 814         JITCompiler::Jump done = m_jit.jump();
 815 
 816         JITCompiler::Label slowPath = m_jit.label();
 817         if (isX86())
 818             m_jit.pop(JITCompiler::selectScratchGPR(calleeGPR));
 819 
 820         callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 821         m_jit.exceptionCheck();
 822         m_jit.jump().linkTo(mainPath, &amp;m_jit);
 823 
 824         done.link(&amp;m_jit);
 825 
 826         setResultAndResetStack();
 827 
 828         m_jit.addJSDirectCall(call, slowPath, callLinkInfo);
 829         return;
 830     }
 831 
 832     m_jit.emitStoreCallSiteIndex(callSite);
 833 
 834     JITCompiler::DataLabelPtr targetToCheck;
 835     JITCompiler::Jump slowPath = m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleeGPR, targetToCheck, TrustedImmPtr(nullptr));
 836 
 837     if (isTail) {
 838         if (node-&gt;op() == TailCall) {
 839             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 840             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 841         } else {
 842             m_jit.emitRestoreCalleeSaves();
 843             m_jit.prepareForTailCallSlow();
 844         }
 845     }
 846 
 847     JITCompiler::Call fastCall = isTail ? m_jit.nearTailCall() : m_jit.nearCall();
 848 
 849     JITCompiler::Jump done = m_jit.jump();
 850 
 851     slowPath.link(&amp;m_jit);
 852 
 853     if (node-&gt;op() == TailCall) {
 854         CallFrameShuffler callFrameShuffler(m_jit, shuffleData);
 855         callFrameShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 856         callFrameShuffler.prepareForSlowPath();
 857     } else {
 858         m_jit.move(calleeGPR, GPRInfo::regT0); // Callee needs to be in regT0
 859 
 860         if (isTail)
 861             m_jit.emitRestoreCalleeSaves(); // This needs to happen after we moved calleeGPR to regT0
 862     }
 863 
 864     m_jit.move(TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2
 865     JITCompiler::Call slowCall = m_jit.nearCall();
 866 
 867     done.link(&amp;m_jit);
 868 
 869     if (isTail)
 870         m_jit.abortWithReason(JITDidReturnFromTailCall);
 871     else
 872         setResultAndResetStack();
 873 
 874     m_jit.addJSCall(fastCall, slowCall, targetToCheck, callLinkInfo);
 875 }
 876 
 877 // Clang should allow unreachable [[clang::fallthrough]] in template functions if any template expansion uses it
 878 // http://llvm.org/bugs/show_bug.cgi?id=18619
 879 IGNORE_WARNINGS_BEGIN(&quot;implicit-fallthrough&quot;)
 880 template&lt;bool strict&gt;
 881 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 882 {
 883     AbstractValue&amp; value = m_state.forNode(edge);
 884     SpeculatedType type = value.m_type;
 885     ASSERT(edge.useKind() != KnownInt32Use || !(value.m_type &amp; ~SpecInt32Only));
 886 
 887     m_interpreter.filter(value, SpecInt32Only);
 888     if (value.isClear()) {
 889         if (mayHaveTypeCheck(edge.useKind()))
 890             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 891         returnFormat = DataFormatInt32;
 892         return allocate();
 893     }
 894 
 895     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
 896     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 897 
 898     switch (info.registerFormat()) {
 899     case DataFormatNone: {
 900         GPRReg gpr = allocate();
 901 
 902         if (edge-&gt;hasConstant()) {
 903             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
 904             ASSERT(edge-&gt;isInt32Constant());
 905             m_jit.move(MacroAssembler::Imm32(edge-&gt;asInt32()), gpr);
 906             info.fillInt32(*m_stream, gpr);
 907             returnFormat = DataFormatInt32;
 908             return gpr;
 909         }
 910 
 911         DataFormat spillFormat = info.spillFormat();
 912 
 913         DFG_ASSERT(m_jit.graph(), m_currentNode, (spillFormat &amp; DataFormatJS) || spillFormat == DataFormatInt32, spillFormat);
 914 
 915         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 916 
 917         if (spillFormat == DataFormatJSInt32 || spillFormat == DataFormatInt32) {
 918             // If we know this was spilled as an integer we can fill without checking.
 919             if (strict) {
 920                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 921                 info.fillInt32(*m_stream, gpr);
 922                 returnFormat = DataFormatInt32;
 923                 return gpr;
 924             }
 925             if (spillFormat == DataFormatInt32) {
 926                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 927                 info.fillInt32(*m_stream, gpr);
 928                 returnFormat = DataFormatInt32;
 929             } else {
 930                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 931                 info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 932                 returnFormat = DataFormatJSInt32;
 933             }
 934             return gpr;
 935         }
 936         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 937 
 938         // Fill as JSValue, and fall through.
 939         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 940         m_gprs.unlock(gpr);
 941         FALLTHROUGH;
 942     }
 943 
 944     case DataFormatJS: {
<a name="11" id="anc11"></a><span class="line-modified"> 945         DFG_ASSERT(m_jit.graph(), m_currentNode, !(type &amp; SpecInt52Any));</span>
 946         // Check the value is an integer.
 947         GPRReg gpr = info.gpr();
 948         m_gprs.lock(gpr);
 949         if (type &amp; ~SpecInt32Only)
 950             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotInt32(gpr));
 951         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 952         // If !strict we&#39;re done, return.
 953         if (!strict) {
 954             returnFormat = DataFormatJSInt32;
 955             return gpr;
 956         }
 957         // else fall through &amp; handle as DataFormatJSInt32.
 958         m_gprs.unlock(gpr);
 959         FALLTHROUGH;
 960     }
 961 
 962     case DataFormatJSInt32: {
 963         // In a strict fill we need to strip off the value tag.
 964         if (strict) {
 965             GPRReg gpr = info.gpr();
 966             GPRReg result;
 967             // If the register has already been locked we need to take a copy.
 968             // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 969             if (m_gprs.isLocked(gpr))
 970                 result = allocate();
 971             else {
 972                 m_gprs.lock(gpr);
 973                 info.fillInt32(*m_stream, gpr);
 974                 result = gpr;
 975             }
 976             m_jit.zeroExtend32ToPtr(gpr, result);
 977             returnFormat = DataFormatInt32;
 978             return result;
 979         }
 980 
 981         GPRReg gpr = info.gpr();
 982         m_gprs.lock(gpr);
 983         returnFormat = DataFormatJSInt32;
 984         return gpr;
 985     }
 986 
 987     case DataFormatInt32: {
 988         GPRReg gpr = info.gpr();
 989         m_gprs.lock(gpr);
 990         returnFormat = DataFormatInt32;
 991         return gpr;
 992     }
 993 
 994     case DataFormatJSDouble:
 995     case DataFormatCell:
 996     case DataFormatBoolean:
 997     case DataFormatJSCell:
 998     case DataFormatJSBoolean:
 999     case DataFormatDouble:
1000     case DataFormatStorage:
1001     case DataFormatInt52:
1002     case DataFormatStrictInt52:
1003         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1004 
1005     default:
1006         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1007         return InvalidGPRReg;
1008     }
1009 }
1010 IGNORE_WARNINGS_END
1011 
1012 GPRReg SpeculativeJIT::fillSpeculateInt32(Edge edge, DataFormat&amp; returnFormat)
1013 {
1014     return fillSpeculateInt32Internal&lt;false&gt;(edge, returnFormat);
1015 }
1016 
1017 GPRReg SpeculativeJIT::fillSpeculateInt32Strict(Edge edge)
1018 {
1019     DataFormat mustBeDataFormatInt32;
1020     GPRReg result = fillSpeculateInt32Internal&lt;true&gt;(edge, mustBeDataFormatInt32);
1021     DFG_ASSERT(m_jit.graph(), m_currentNode, mustBeDataFormatInt32 == DataFormatInt32, mustBeDataFormatInt32);
1022     return result;
1023 }
1024 
1025 GPRReg SpeculativeJIT::fillSpeculateInt52(Edge edge, DataFormat desiredFormat)
1026 {
1027     ASSERT(desiredFormat == DataFormatInt52 || desiredFormat == DataFormatStrictInt52);
1028     AbstractValue&amp; value = m_state.forNode(edge);
1029 
<a name="12" id="anc12"></a><span class="line-modified">1030     m_interpreter.filter(value, SpecInt52Any);</span>
1031     if (value.isClear()) {
1032         if (mayHaveTypeCheck(edge.useKind()))
1033             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1034         return allocate();
1035     }
1036 
1037     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1038     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1039 
1040     switch (info.registerFormat()) {
1041     case DataFormatNone: {
1042         GPRReg gpr = allocate();
1043 
1044         if (edge-&gt;hasConstant()) {
1045             JSValue jsValue = edge-&gt;asJSValue();
1046             ASSERT(jsValue.isAnyInt());
1047             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1048             int64_t value = jsValue.asAnyInt();
1049             if (desiredFormat == DataFormatInt52)
1050                 value = value &lt;&lt; JSValue::int52ShiftAmount;
1051             m_jit.move(MacroAssembler::Imm64(value), gpr);
1052             info.fillGPR(*m_stream, gpr, desiredFormat);
1053             return gpr;
1054         }
1055 
1056         DataFormat spillFormat = info.spillFormat();
1057 
1058         DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat == DataFormatInt52 || spillFormat == DataFormatStrictInt52, spillFormat);
1059 
1060         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1061 
1062         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1063         if (desiredFormat == DataFormatStrictInt52) {
1064             if (spillFormat == DataFormatInt52)
1065                 m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1066             info.fillStrictInt52(*m_stream, gpr);
1067             return gpr;
1068         }
1069         if (spillFormat == DataFormatStrictInt52)
1070             m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1071         info.fillInt52(*m_stream, gpr);
1072         return gpr;
1073     }
1074 
1075     case DataFormatStrictInt52: {
1076         GPRReg gpr = info.gpr();
1077         bool wasLocked = m_gprs.isLocked(gpr);
1078         lock(gpr);
1079         if (desiredFormat == DataFormatStrictInt52)
1080             return gpr;
1081         if (wasLocked) {
1082             GPRReg result = allocate();
1083             m_jit.move(gpr, result);
1084             unlock(gpr);
1085             gpr = result;
1086         } else
1087             info.fillInt52(*m_stream, gpr);
1088         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1089         return gpr;
1090     }
1091 
1092     case DataFormatInt52: {
1093         GPRReg gpr = info.gpr();
1094         bool wasLocked = m_gprs.isLocked(gpr);
1095         lock(gpr);
1096         if (desiredFormat == DataFormatInt52)
1097             return gpr;
1098         if (wasLocked) {
1099             GPRReg result = allocate();
1100             m_jit.move(gpr, result);
1101             unlock(gpr);
1102             gpr = result;
1103         } else
1104             info.fillStrictInt52(*m_stream, gpr);
1105         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1106         return gpr;
1107     }
1108 
1109     default:
1110         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1111         return InvalidGPRReg;
1112     }
1113 }
1114 
1115 FPRReg SpeculativeJIT::fillSpeculateDouble(Edge edge)
1116 {
1117     ASSERT(edge.useKind() == DoubleRepUse || edge.useKind() == DoubleRepRealUse || edge.useKind() == DoubleRepAnyIntUse);
1118     ASSERT(edge-&gt;hasDoubleResult());
1119     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1120     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1121 
1122     if (info.registerFormat() == DataFormatNone) {
1123         if (edge-&gt;hasConstant()) {
1124             if (edge-&gt;isNumberConstant()) {
1125                 FPRReg fpr = fprAllocate();
1126                 int64_t doubleAsInt = reinterpretDoubleToInt64(edge-&gt;asNumber());
1127                 if (!doubleAsInt)
1128                     m_jit.moveZeroToDouble(fpr);
1129                 else {
1130                     GPRReg gpr = allocate();
1131                     m_jit.move(MacroAssembler::Imm64(doubleAsInt), gpr);
1132                     m_jit.move64ToDouble(gpr, fpr);
1133                     unlock(gpr);
1134                 }
1135 
1136                 m_fprs.retain(fpr, virtualRegister, SpillOrderDouble);
1137                 info.fillDouble(*m_stream, fpr);
1138                 return fpr;
1139             }
1140             if (mayHaveTypeCheck(edge.useKind()))
1141                 terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1142             return fprAllocate();
1143         }
1144 
1145         DataFormat spillFormat = info.spillFormat();
1146         if (spillFormat != DataFormatDouble) {
1147             DFG_CRASH(
1148                 m_jit.graph(), m_currentNode, toCString(
1149                     &quot;Expected &quot;, edge, &quot; to have double format but instead it is spilled as &quot;,
1150                     dataFormatToString(spillFormat)).data());
1151         }
1152         DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat == DataFormatDouble, spillFormat);
1153         FPRReg fpr = fprAllocate();
1154         m_jit.loadDouble(JITCompiler::addressFor(virtualRegister), fpr);
1155         m_fprs.retain(fpr, virtualRegister, SpillOrderDouble);
1156         info.fillDouble(*m_stream, fpr);
1157         return fpr;
1158     }
1159 
1160     DFG_ASSERT(m_jit.graph(), m_currentNode, info.registerFormat() == DataFormatDouble, info.registerFormat());
1161     FPRReg fpr = info.fpr();
1162     m_fprs.lock(fpr);
1163     return fpr;
1164 }
1165 
1166 GPRReg SpeculativeJIT::fillSpeculateCell(Edge edge)
1167 {
1168     AbstractValue&amp; value = m_state.forNode(edge);
1169     SpeculatedType type = value.m_type;
1170     ASSERT((edge.useKind() != KnownCellUse &amp;&amp; edge.useKind() != KnownStringUse) || !(value.m_type &amp; ~SpecCellCheck));
1171 
1172     m_interpreter.filter(value, SpecCellCheck);
1173     if (value.isClear()) {
1174         if (mayHaveTypeCheck(edge.useKind()))
1175             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1176         return allocate();
1177     }
1178 
1179     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1180     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1181 
1182     switch (info.registerFormat()) {
1183     case DataFormatNone: {
1184         GPRReg gpr = allocate();
1185 
1186         if (edge-&gt;hasConstant()) {
1187             JSValue jsValue = edge-&gt;asJSValue();
1188             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1189             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1190             info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1191             return gpr;
1192         }
1193 
1194         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1195         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1196 
1197         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1198         if (type &amp; ~SpecCellCheck)
1199             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1200         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1201         return gpr;
1202     }
1203 
1204     case DataFormatCell:
1205     case DataFormatJSCell: {
1206         GPRReg gpr = info.gpr();
1207         m_gprs.lock(gpr);
1208         if (!ASSERT_DISABLED) {
1209             MacroAssembler::Jump checkCell = m_jit.branchIfCell(JSValueRegs(gpr));
1210             m_jit.abortWithReason(DFGIsNotCell);
1211             checkCell.link(&amp;m_jit);
1212         }
1213         return gpr;
1214     }
1215 
1216     case DataFormatJS: {
1217         GPRReg gpr = info.gpr();
1218         m_gprs.lock(gpr);
1219         if (type &amp; ~SpecCellCheck)
1220             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1221         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1222         return gpr;
1223     }
1224 
1225     case DataFormatJSInt32:
1226     case DataFormatInt32:
1227     case DataFormatJSDouble:
1228     case DataFormatJSBoolean:
1229     case DataFormatBoolean:
1230     case DataFormatDouble:
1231     case DataFormatStorage:
1232     case DataFormatInt52:
1233     case DataFormatStrictInt52:
1234         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1235 
1236     default:
1237         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1238         return InvalidGPRReg;
1239     }
1240 }
1241 
1242 GPRReg SpeculativeJIT::fillSpeculateBoolean(Edge edge)
1243 {
1244     AbstractValue&amp; value = m_state.forNode(edge);
1245     SpeculatedType type = value.m_type;
1246     ASSERT(edge.useKind() != KnownBooleanUse || !(value.m_type &amp; ~SpecBoolean));
1247 
1248     m_interpreter.filter(value, SpecBoolean);
1249     if (value.isClear()) {
1250         if (mayHaveTypeCheck(edge.useKind()))
1251             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1252         return allocate();
1253     }
1254 
1255     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1256     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1257 
1258     switch (info.registerFormat()) {
1259     case DataFormatNone: {
1260         GPRReg gpr = allocate();
1261 
1262         if (edge-&gt;hasConstant()) {
1263             JSValue jsValue = edge-&gt;asJSValue();
1264             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1265             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1266             info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1267             return gpr;
1268         }
1269         DFG_ASSERT(m_jit.graph(), m_currentNode, info.spillFormat() &amp; DataFormatJS, info.spillFormat());
1270         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1271         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1272 
1273         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1274         if (type &amp; ~SpecBoolean) {
1275             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1276             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
1277             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1278         }
1279         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1280         return gpr;
1281     }
1282 
1283     case DataFormatBoolean:
1284     case DataFormatJSBoolean: {
1285         GPRReg gpr = info.gpr();
1286         m_gprs.lock(gpr);
1287         return gpr;
1288     }
1289 
1290     case DataFormatJS: {
1291         GPRReg gpr = info.gpr();
1292         m_gprs.lock(gpr);
1293         if (type &amp; ~SpecBoolean) {
1294             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1295             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
1296             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1297         }
1298         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1299         return gpr;
1300     }
1301 
1302     case DataFormatJSInt32:
1303     case DataFormatInt32:
1304     case DataFormatJSDouble:
1305     case DataFormatJSCell:
1306     case DataFormatCell:
1307     case DataFormatDouble:
1308     case DataFormatStorage:
1309     case DataFormatInt52:
1310     case DataFormatStrictInt52:
1311         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1312 
1313     default:
1314         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1315         return InvalidGPRReg;
1316     }
1317 }
1318 
1319 void SpeculativeJIT::compileObjectStrictEquality(Edge objectChild, Edge otherChild)
1320 {
1321     SpeculateCellOperand op1(this, objectChild);
1322     JSValueOperand op2(this, otherChild);
1323     GPRTemporary result(this);
1324 
1325     GPRReg op1GPR = op1.gpr();
1326     GPRReg op2GPR = op2.gpr();
1327     GPRReg resultGPR = result.gpr();
1328 
1329     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1330 
1331     // At this point we know that we can perform a straight-forward equality comparison on pointer
1332     // values because we are doing strict equality.
1333     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
1334     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
1335     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1336 }
1337 
1338 void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
1339 {
1340     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1341     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1342 
1343     SpeculateCellOperand op1(this, objectChild);
1344     JSValueOperand op2(this, otherChild);
1345 
1346     GPRReg op1GPR = op1.gpr();
1347     GPRReg op2GPR = op2.gpr();
1348 
1349     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1350 
1351     if (taken == nextBlock()) {
1352         branchPtr(MacroAssembler::NotEqual, op1GPR, op2GPR, notTaken);
1353         jump(taken);
1354     } else {
1355         branchPtr(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1356         jump(notTaken);
1357     }
1358 }
1359 
1360 void SpeculativeJIT::compileObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild)
1361 {
1362     SpeculateCellOperand op1(this, leftChild);
1363     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1364     GPRTemporary result(this);
1365 
1366     GPRReg op1GPR = op1.gpr();
1367     GPRReg op2GPR = op2.gpr();
1368     GPRReg resultGPR = result.gpr();
1369 
1370     bool masqueradesAsUndefinedWatchpointValid =
1371         masqueradesAsUndefinedWatchpointIsStillValid();
1372 
1373     if (masqueradesAsUndefinedWatchpointValid) {
1374         DFG_TYPE_CHECK(
1375             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1376     } else {
1377         DFG_TYPE_CHECK(
1378             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1379         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1380             m_jit.branchTest8(
1381                 MacroAssembler::NonZero,
1382                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1383                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1384     }
1385 
1386     // It seems that most of the time when programs do a == b where b may be either null/undefined
1387     // or an object, b is usually an object. Balance the branches to make that case fast.
1388     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(JSValueRegs(op2GPR));
1389 
1390     // We know that within this branch, rightChild must be a cell.
1391     if (masqueradesAsUndefinedWatchpointValid) {
1392         DFG_TYPE_CHECK(
1393             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1394     } else {
1395         DFG_TYPE_CHECK(
1396             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1397         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1398             m_jit.branchTest8(
1399                 MacroAssembler::NonZero,
1400                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1401                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1402     }
1403 
1404     // At this point we know that we can perform a straight-forward equality comparison on pointer
1405     // values because both left and right are pointers to objects that have no special equality
1406     // protocols.
1407     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
1408     MacroAssembler::Jump done = m_jit.jump();
1409 
1410     rightNotCell.link(&amp;m_jit);
1411 
1412     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1413     // prove that it is either null or undefined.
1414     if (needsTypeCheck(rightChild, SpecCellCheck | SpecOther)) {
1415         m_jit.move(op2GPR, resultGPR);
1416         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);
1417 
1418         typeCheck(
1419             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther,
1420             m_jit.branch64(
1421                 MacroAssembler::NotEqual, resultGPR,
1422                 MacroAssembler::TrustedImm64(ValueNull)));
1423     }
1424     m_jit.move(TrustedImm32(0), result.gpr());
1425 
1426     done.link(&amp;m_jit);
1427     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
1428     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1429 }
1430 
1431 void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
1432 {
1433     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1434     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1435 
1436     SpeculateCellOperand op1(this, leftChild);
1437     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1438     GPRTemporary result(this);
1439 
1440     GPRReg op1GPR = op1.gpr();
1441     GPRReg op2GPR = op2.gpr();
1442     GPRReg resultGPR = result.gpr();
1443 
1444     bool masqueradesAsUndefinedWatchpointValid =
1445         masqueradesAsUndefinedWatchpointIsStillValid();
1446 
1447     if (masqueradesAsUndefinedWatchpointValid) {
1448         DFG_TYPE_CHECK(
1449             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1450     } else {
1451         DFG_TYPE_CHECK(
1452             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1453         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1454             m_jit.branchTest8(
1455                 MacroAssembler::NonZero,
1456                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1457                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1458     }
1459 
1460     // It seems that most of the time when programs do a == b where b may be either null/undefined
1461     // or an object, b is usually an object. Balance the branches to make that case fast.
1462     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(JSValueRegs(op2GPR));
1463 
1464     // We know that within this branch, rightChild must be a cell.
1465     if (masqueradesAsUndefinedWatchpointValid) {
1466         DFG_TYPE_CHECK(
1467             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1468     } else {
1469         DFG_TYPE_CHECK(
1470             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1471         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1472             m_jit.branchTest8(
1473                 MacroAssembler::NonZero,
1474                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1475                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1476     }
1477 
1478     // At this point we know that we can perform a straight-forward equality comparison on pointer
1479     // values because both left and right are pointers to objects that have no special equality
1480     // protocols.
1481     branch64(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1482 
1483     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1484     // prove that it is either null or undefined.
1485     if (!needsTypeCheck(rightChild, SpecCellCheck | SpecOther))
1486         rightNotCell.link(&amp;m_jit);
1487     else {
1488         jump(notTaken, ForceJump);
1489 
1490         rightNotCell.link(&amp;m_jit);
1491         m_jit.move(op2GPR, resultGPR);
1492         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);
1493 
1494         typeCheck(
1495             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther, m_jit.branch64(
1496                 MacroAssembler::NotEqual, resultGPR,
1497                 MacroAssembler::TrustedImm64(ValueNull)));
1498     }
1499 
1500     jump(notTaken);
1501 }
1502 
1503 void SpeculativeJIT::compileSymbolUntypedEquality(Node* node, Edge symbolEdge, Edge untypedEdge)
1504 {
1505     SpeculateCellOperand symbol(this, symbolEdge);
1506     JSValueOperand untyped(this, untypedEdge);
1507     GPRTemporary result(this, Reuse, symbol, untyped);
1508 
1509     GPRReg symbolGPR = symbol.gpr();
1510     GPRReg untypedGPR = untyped.gpr();
1511     GPRReg resultGPR = result.gpr();
1512 
1513     speculateSymbol(symbolEdge, symbolGPR);
1514 
1515     // At this point we know that we can perform a straight-forward equality comparison on pointer
1516     // values because we are doing strict equality.
1517     m_jit.compare64(MacroAssembler::Equal, symbolGPR, untypedGPR, resultGPR);
1518     unblessedBooleanResult(resultGPR, node);
1519 }
1520 
1521 void SpeculativeJIT::compileInt52Compare(Node* node, MacroAssembler::RelationalCondition condition)
1522 {
1523     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1524     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1525     GPRTemporary result(this, Reuse, op1, op2);
1526 
1527     m_jit.compare64(condition, op1.gpr(), op2.gpr(), result.gpr());
1528 
1529     // If we add a DataFormatBool, we should use it here.
1530     m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
1531     jsValueResult(result.gpr(), m_currentNode, DataFormatJSBoolean);
1532 }
1533 
1534 void SpeculativeJIT::compilePeepHoleInt52Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
1535 {
1536     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1537     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1538 
1539     // The branch instruction will branch to the taken block.
1540     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
1541     if (taken == nextBlock()) {
1542         condition = JITCompiler::invert(condition);
1543         BasicBlock* tmp = taken;
1544         taken = notTaken;
1545         notTaken = tmp;
1546     }
1547 
1548     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1549     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1550 
1551     branch64(condition, op1.gpr(), op2.gpr(), taken);
1552     jump(notTaken);
1553 }
1554 
1555 void SpeculativeJIT::compileCompareEqPtr(Node* node)
1556 {
1557     JSValueOperand value(this, node-&gt;child1());
1558     GPRTemporary result(this);
1559     GPRReg valueGPR = value.gpr();
1560     GPRReg resultGPR = result.gpr();
1561 
1562     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), node-&gt;cellOperand()-&gt;cell()), resultGPR);
1563     m_jit.compare64(MacroAssembler::Equal, valueGPR, resultGPR, resultGPR);
1564     unblessedBooleanResult(resultGPR, node);
1565 }
1566 
1567 void SpeculativeJIT::compileObjectOrOtherLogicalNot(Edge nodeUse)
1568 {
1569     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1570     GPRTemporary result(this);
1571     GPRReg valueGPR = value.gpr();
1572     GPRReg resultGPR = result.gpr();
1573     GPRTemporary structure;
1574     GPRReg structureGPR = InvalidGPRReg;
1575     GPRTemporary scratch;
1576     GPRReg scratchGPR = InvalidGPRReg;
1577 
1578     bool masqueradesAsUndefinedWatchpointValid =
1579         masqueradesAsUndefinedWatchpointIsStillValid();
1580 
1581     if (!masqueradesAsUndefinedWatchpointValid) {
1582         // The masquerades as undefined case will use the structure register, so allocate it here.
1583         // Do this at the top of the function to avoid branching around a register allocation.
1584         GPRTemporary realStructure(this);
1585         GPRTemporary realScratch(this);
1586         structure.adopt(realStructure);
1587         scratch.adopt(realScratch);
1588         structureGPR = structure.gpr();
1589         scratchGPR = scratch.gpr();
1590     }
1591 
1592     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(JSValueRegs(valueGPR));
1593     if (masqueradesAsUndefinedWatchpointValid) {
1594         DFG_TYPE_CHECK(
1595             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1596     } else {
1597         DFG_TYPE_CHECK(
1598             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1599 
1600         MacroAssembler::Jump isNotMasqueradesAsUndefined =
1601             m_jit.branchTest8(
1602                 MacroAssembler::Zero,
1603                 MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1604                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined));
1605 
<a name="13" id="anc13"></a><span class="line-modified">1606         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);</span>
1607         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1608             m_jit.branchPtr(
1609                 MacroAssembler::Equal,
1610                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1611                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1612 
1613         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1614     }
1615     m_jit.move(TrustedImm32(ValueFalse), resultGPR);
1616     MacroAssembler::Jump done = m_jit.jump();
1617 
1618     notCell.link(&amp;m_jit);
1619 
1620     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1621         m_jit.move(valueGPR, resultGPR);
1622         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);
1623         typeCheck(
1624             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
1625                 MacroAssembler::NotEqual,
1626                 resultGPR,
1627                 MacroAssembler::TrustedImm64(ValueNull)));
1628     }
1629     m_jit.move(TrustedImm32(ValueTrue), resultGPR);
1630 
1631     done.link(&amp;m_jit);
1632 
1633     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1634 }
1635 
1636 void SpeculativeJIT::compileLogicalNot(Node* node)
1637 {
1638     switch (node-&gt;child1().useKind()) {
1639     case ObjectOrOtherUse: {
1640         compileObjectOrOtherLogicalNot(node-&gt;child1());
1641         return;
1642     }
1643 
1644     case Int32Use: {
1645         SpeculateInt32Operand value(this, node-&gt;child1());
1646         GPRTemporary result(this, Reuse, value);
1647         m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), result.gpr());
1648         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
1649         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1650         return;
1651     }
1652 
1653     case DoubleRepUse: {
1654         SpeculateDoubleOperand value(this, node-&gt;child1());
1655         FPRTemporary scratch(this);
1656         GPRTemporary result(this);
1657         m_jit.move(TrustedImm32(ValueFalse), result.gpr());
1658         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1659         m_jit.xor32(TrustedImm32(true), result.gpr());
1660         nonZero.link(&amp;m_jit);
1661         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1662         return;
1663     }
1664 
1665     case BooleanUse:
1666     case KnownBooleanUse: {
1667         if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1668             SpeculateBooleanOperand value(this, node-&gt;child1());
1669             GPRTemporary result(this, Reuse, value);
1670 
1671             m_jit.move(value.gpr(), result.gpr());
1672             m_jit.xor64(TrustedImm32(true), result.gpr());
1673 
1674             jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1675             return;
1676         }
1677 
1678         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1679         GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
1680 
1681         m_jit.move(value.gpr(), result.gpr());
1682         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());
1683         typeCheck(
1684             JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
1685                 JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
1686         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueTrue)), result.gpr());
1687 
1688         // If we add a DataFormatBool, we should use it here.
1689         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1690         return;
1691     }
1692 
1693     case UntypedUse: {
1694         JSValueOperand arg1(this, node-&gt;child1());
1695         GPRTemporary result(this);
1696 
1697         GPRReg arg1GPR = arg1.gpr();
1698         GPRReg resultGPR = result.gpr();
1699 
1700         FPRTemporary valueFPR(this);
1701         FPRTemporary tempFPR(this);
1702 
1703         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1704         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1705         Optional&lt;GPRTemporary&gt; scratch;
1706         GPRReg scratchGPR = InvalidGPRReg;
1707         if (shouldCheckMasqueradesAsUndefined) {
1708             scratch.emplace(this);
1709             scratchGPR = scratch-&gt;gpr();
1710         }
1711         bool negateResult = true;
<a name="14" id="anc14"></a><span class="line-modified">1712         m_jit.emitConvertValueToBoolean(vm(), JSValueRegs(arg1GPR), resultGPR, scratchGPR, valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);</span>
1713         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
1714         jsValueResult(resultGPR, node, DataFormatJSBoolean);
1715         return;
1716     }
1717     case StringUse:
1718         return compileStringZeroLength(node);
1719 
1720     case StringOrOtherUse:
1721         return compileLogicalNotStringOrOther(node);
1722 
1723     default:
1724         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
1725         break;
1726     }
1727 }
1728 
1729 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1730 {
1731     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1732     GPRTemporary scratch(this);
1733     GPRTemporary structure;
1734     GPRReg valueGPR = value.gpr();
1735     GPRReg scratchGPR = scratch.gpr();
1736     GPRReg structureGPR = InvalidGPRReg;
1737 
1738     if (!masqueradesAsUndefinedWatchpointIsStillValid()) {
1739         GPRTemporary realStructure(this);
1740         structure.adopt(realStructure);
1741         structureGPR = structure.gpr();
1742     }
1743 
1744     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(JSValueRegs(valueGPR));
1745     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
1746         DFG_TYPE_CHECK(
1747             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1748     } else {
1749         DFG_TYPE_CHECK(
1750             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1751 
1752         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
1753             JITCompiler::Zero,
1754             MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1755             TrustedImm32(MasqueradesAsUndefined));
1756 
<a name="15" id="anc15"></a><span class="line-modified">1757         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);</span>
1758         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1759             m_jit.branchPtr(
1760                 MacroAssembler::Equal,
1761                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1762                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1763 
1764         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1765     }
1766     jump(taken, ForceJump);
1767 
1768     notCell.link(&amp;m_jit);
1769 
1770     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1771         m_jit.move(valueGPR, scratchGPR);
1772         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), scratchGPR);
1773         typeCheck(
1774             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
1775                 MacroAssembler::NotEqual, scratchGPR, MacroAssembler::TrustedImm64(ValueNull)));
1776     }
1777     jump(notTaken);
1778 
1779     noResult(m_currentNode);
1780 }
1781 
1782 void SpeculativeJIT::emitBranch(Node* node)
1783 {
1784     BasicBlock* taken = node-&gt;branchData()-&gt;taken.block;
1785     BasicBlock* notTaken = node-&gt;branchData()-&gt;notTaken.block;
1786 
1787     switch (node-&gt;child1().useKind()) {
1788     case ObjectOrOtherUse: {
1789         emitObjectOrOtherBranch(node-&gt;child1(), taken, notTaken);
1790         return;
1791     }
1792 
1793     case Int32Use:
1794     case DoubleRepUse: {
1795         if (node-&gt;child1().useKind() == Int32Use) {
1796             bool invert = false;
1797 
1798             if (taken == nextBlock()) {
1799                 invert = true;
1800                 BasicBlock* tmp = taken;
1801                 taken = notTaken;
1802                 notTaken = tmp;
1803             }
1804 
1805             SpeculateInt32Operand value(this, node-&gt;child1());
1806             branchTest32(invert ? MacroAssembler::Zero : MacroAssembler::NonZero, value.gpr(), taken);
1807         } else {
1808             SpeculateDoubleOperand value(this, node-&gt;child1());
1809             FPRTemporary scratch(this);
1810             branchDoubleNonZero(value.fpr(), scratch.fpr(), taken);
1811         }
1812 
1813         jump(notTaken);
1814 
1815         noResult(node);
1816         return;
1817     }
1818 
1819     case StringUse: {
1820         emitStringBranch(node-&gt;child1(), taken, notTaken);
1821         return;
1822     }
1823 
1824     case StringOrOtherUse: {
1825         emitStringOrOtherBranch(node-&gt;child1(), taken, notTaken);
1826         return;
1827     }
1828 
1829     case UntypedUse:
1830     case BooleanUse:
1831     case KnownBooleanUse: {
1832         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1833         GPRReg valueGPR = value.gpr();
1834 
1835         if (node-&gt;child1().useKind() == BooleanUse || node-&gt;child1().useKind() == KnownBooleanUse) {
1836             if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1837                 MacroAssembler::ResultCondition condition = MacroAssembler::NonZero;
1838 
1839                 if (taken == nextBlock()) {
1840                     condition = MacroAssembler::Zero;
1841                     BasicBlock* tmp = taken;
1842                     taken = notTaken;
1843                     notTaken = tmp;
1844                 }
1845 
1846                 branchTest32(condition, valueGPR, TrustedImm32(true), taken);
1847                 jump(notTaken);
1848             } else {
1849                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1850                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1851 
1852                 typeCheck(JSValueRegs(valueGPR), node-&gt;child1(), SpecBoolean, m_jit.jump());
1853             }
1854             value.use();
1855         } else {
1856             GPRTemporary result(this);
1857             FPRTemporary fprValue(this);
1858             FPRTemporary fprTemp(this);
1859             Optional&lt;GPRTemporary&gt; scratch;
1860 
1861             GPRReg scratchGPR = InvalidGPRReg;
1862             bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1863             if (shouldCheckMasqueradesAsUndefined) {
1864                 scratch.emplace(this);
1865                 scratchGPR = scratch-&gt;gpr();
1866             }
1867 
1868             GPRReg resultGPR = result.gpr();
1869             FPRReg valueFPR = fprValue.fpr();
1870             FPRReg tempFPR = fprTemp.fpr();
1871 
1872             if (node-&gt;child1()-&gt;prediction() &amp; SpecInt32Only) {
1873                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsNumber(0))), notTaken);
1874                 branch64(MacroAssembler::AboveOrEqual, valueGPR, GPRInfo::tagTypeNumberRegister, taken);
1875             }
1876 
1877             if (node-&gt;child1()-&gt;prediction() &amp; SpecBoolean) {
1878                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1879                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1880             }
1881 
1882             value.use();
1883 
1884             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
<a name="16" id="anc16"></a><span class="line-modified">1885             auto truthy = m_jit.branchIfTruthy(vm(), JSValueRegs(valueGPR), resultGPR, scratchGPR, valueFPR, tempFPR, shouldCheckMasqueradesAsUndefined, globalObject);</span>
1886             addBranch(truthy, taken);
1887             jump(notTaken);
1888         }
1889 
1890         noResult(node, UseChildrenCalledExplicitly);
1891         return;
1892     }
1893 
1894     default:
1895         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad use kind&quot;);
1896     }
1897 }
1898 
1899 void SpeculativeJIT::compile(Node* node)
1900 {
1901     NodeType op = node-&gt;op();
1902 
1903     if (validateDFGDoesGC) {
1904         bool expectDoesGC = doesGC(m_jit.graph(), node);
<a name="17" id="anc17"></a><span class="line-modified">1905         m_jit.store8(TrustedImm32(expectDoesGC), vm().heap.addressOfExpectDoesGC());</span>
1906     }
1907 
1908 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1909     m_jit.clearRegisterAllocationOffsets();
1910 #endif
1911 
1912     switch (op) {
1913     case JSConstant:
1914     case DoubleConstant:
1915     case Int52Constant:
1916     case PhantomDirectArguments:
1917     case PhantomClonedArguments:
1918         initConstantInfo(node);
1919         break;
1920 
1921     case LazyJSConstant:
1922         compileLazyJSConstant(node);
1923         break;
1924 
1925     case Identity: {
1926         compileIdentity(node);
1927         break;
1928     }
1929 
1930     case GetLocal: {
1931         AbstractValue&amp; value = m_state.operand(node-&gt;local());
1932 
1933         // If the CFA is tracking this variable and it found that the variable
1934         // cannot have been assigned, then don&#39;t attempt to proceed.
1935         if (value.isClear()) {
1936             m_compileOkay = false;
1937             break;
1938         }
1939 
1940         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1941         case FlushedDouble: {
1942             FPRTemporary result(this);
1943             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1944             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1945             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1946             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1947             break;
1948         }
1949 
1950         case FlushedInt32: {
1951             GPRTemporary result(this);
1952             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1953 
1954             // Like int32Result, but don&#39;t useChildren - our children are phi nodes,
1955             // and don&#39;t represent values within this dataflow with virtual registers.
1956             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1957             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderInteger);
1958             generationInfoFromVirtualRegister(virtualRegister).initInt32(node, node-&gt;refCount(), result.gpr());
1959             break;
1960         }
1961 
1962         case FlushedInt52: {
1963             GPRTemporary result(this);
1964             m_jit.load64(JITCompiler::addressFor(node-&gt;machineLocal()), result.gpr());
1965 
1966             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1967             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1968             generationInfoFromVirtualRegister(virtualRegister).initInt52(node, node-&gt;refCount(), result.gpr());
1969             break;
1970         }
1971 
1972         default:
1973             GPRTemporary result(this);
1974             m_jit.load64(JITCompiler::addressFor(node-&gt;machineLocal()), result.gpr());
1975 
1976             // Like jsValueResult, but don&#39;t useChildren - our children are phi nodes,
1977             // and don&#39;t represent values within this dataflow with virtual registers.
1978             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1979             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1980 
1981             DataFormat format;
1982             if (isCellSpeculation(value.m_type))
1983                 format = DataFormatJSCell;
1984             else if (isBooleanSpeculation(value.m_type))
1985                 format = DataFormatJSBoolean;
1986             else
1987                 format = DataFormatJS;
1988 
1989             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), result.gpr(), format);
1990             break;
1991         }
1992         break;
1993     }
1994 
1995     case MovHint: {
1996         compileMovHint(m_currentNode);
1997         noResult(node);
1998         break;
1999     }
2000 
2001     case ZombieHint: {
2002         recordSetLocal(m_currentNode-&gt;unlinkedLocal(), VirtualRegister(), DataFormatDead);
2003         noResult(node);
2004         break;
2005     }
2006 
2007     case ExitOK: {
2008         noResult(node);
2009         break;
2010     }
2011 
2012     case SetLocal: {
2013         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
2014         case FlushedDouble: {
2015             SpeculateDoubleOperand value(this, node-&gt;child1());
2016             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2017             noResult(node);
2018             // Indicate that it&#39;s no longer necessary to retrieve the value of
2019             // this bytecode variable from registers or other locations in the stack,
2020             // but that it is stored as a double.
2021             recordSetLocal(DataFormatDouble);
2022             break;
2023         }
2024 
2025         case FlushedInt32: {
2026             SpeculateInt32Operand value(this, node-&gt;child1());
2027             m_jit.store32(value.gpr(), JITCompiler::payloadFor(node-&gt;machineLocal()));
2028             noResult(node);
2029             recordSetLocal(DataFormatInt32);
2030             break;
2031         }
2032 
2033         case FlushedInt52: {
2034             SpeculateInt52Operand value(this, node-&gt;child1());
2035             m_jit.store64(value.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2036             noResult(node);
2037             recordSetLocal(DataFormatInt52);
2038             break;
2039         }
2040 
2041         case FlushedCell: {
2042             SpeculateCellOperand cell(this, node-&gt;child1());
2043             GPRReg cellGPR = cell.gpr();
2044             m_jit.store64(cellGPR, JITCompiler::addressFor(node-&gt;machineLocal()));
2045             noResult(node);
2046             recordSetLocal(DataFormatCell);
2047             break;
2048         }
2049 
2050         case FlushedBoolean: {
2051             SpeculateBooleanOperand boolean(this, node-&gt;child1());
2052             m_jit.store64(boolean.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2053             noResult(node);
2054             recordSetLocal(DataFormatBoolean);
2055             break;
2056         }
2057 
2058         case FlushedJSValue: {
2059             JSValueOperand value(this, node-&gt;child1());
2060             m_jit.store64(value.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2061             noResult(node);
2062             recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
2063             break;
2064         }
2065 
2066         default:
2067             DFG_CRASH(m_jit.graph(), node, &quot;Bad flush format&quot;);
2068             break;
2069         }
2070 
2071         break;
2072     }
2073 
<a name="18" id="anc18"></a><span class="line-modified">2074     case SetArgumentDefinitely:</span>
<span class="line-added">2075     case SetArgumentMaybe:</span>
2076         // This is a no-op; it just marks the fact that the argument is being used.
2077         // But it may be profitable to use this as a hook to run speculation checks
2078         // on arguments, thereby allowing us to trivially eliminate such checks if
2079         // the argument is not used.
2080         recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
2081         break;
2082 
<a name="19" id="anc19"></a><span class="line-added">2083     case ValueBitNot:</span>
<span class="line-added">2084         compileValueBitNot(node);</span>
<span class="line-added">2085         break;</span>
<span class="line-added">2086 </span>
2087     case ArithBitNot:
2088         compileBitwiseNot(node);
2089         break;
2090 
2091     case ValueBitAnd:
2092     case ValueBitXor:
2093     case ValueBitOr:
2094         compileValueBitwiseOp(node);
2095         break;
2096 
2097     case ArithBitAnd:
2098     case ArithBitOr:
2099     case ArithBitXor:
2100         compileBitwiseOp(node);
2101         break;
2102 
<a name="20" id="anc20"></a><span class="line-added">2103     case ValueBitLShift:</span>
<span class="line-added">2104         compileValueLShiftOp(node);</span>
<span class="line-added">2105         break;</span>
<span class="line-added">2106 </span>
2107     case BitRShift:
<a name="21" id="anc21"></a><span class="line-modified">2108     case ArithBitLShift:</span>
2109     case BitURShift:
2110         compileShiftOp(node);
2111         break;
2112 
2113     case UInt32ToNumber: {
2114         compileUInt32ToNumber(node);
2115         break;
2116     }
2117 
2118     case DoubleAsInt32: {
2119         compileDoubleAsInt32(node);
2120         break;
2121     }
2122 
2123     case ValueToInt32: {
2124         compileValueToInt32(node);
2125         break;
2126     }
2127 
2128     case DoubleRep: {
2129         compileDoubleRep(node);
2130         break;
2131     }
2132 
2133     case ValueRep: {
2134         compileValueRep(node);
2135         break;
2136     }
2137 
2138     case Int52Rep: {
2139         switch (node-&gt;child1().useKind()) {
2140         case Int32Use: {
2141             SpeculateInt32Operand operand(this, node-&gt;child1());
2142             GPRTemporary result(this, Reuse, operand);
2143 
2144             m_jit.signExtend32ToPtr(operand.gpr(), result.gpr());
2145 
2146             strictInt52Result(result.gpr(), node);
2147             break;
2148         }
2149 
2150         case AnyIntUse: {
2151             GPRTemporary result(this);
2152             GPRReg resultGPR = result.gpr();
2153 
2154             convertAnyInt(node-&gt;child1(), resultGPR);
2155 
2156             strictInt52Result(resultGPR, node);
2157             break;
2158         }
2159 
2160         case DoubleRepAnyIntUse: {
2161             SpeculateDoubleOperand value(this, node-&gt;child1());
2162             FPRReg valueFPR = value.fpr();
2163 
2164             flushRegisters();
2165             GPRFlushedCallResult result(this);
2166             GPRReg resultGPR = result.gpr();
2167             callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
2168 
2169             DFG_TYPE_CHECK_WITH_EXIT_KIND(Int52Overflow,
2170                 JSValueRegs(), node-&gt;child1(), SpecAnyIntAsDouble,
2171                 m_jit.branch64(
2172                     JITCompiler::Equal, resultGPR,
2173                     JITCompiler::TrustedImm64(JSValue::notInt52)));
2174 
2175             strictInt52Result(resultGPR, node);
2176             break;
2177         }
2178 
2179         default:
2180             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
2181         }
2182         break;
2183     }
2184 
2185     case ValueNegate:
2186         compileValueNegate(node);
2187         break;
2188 
2189     case ValueAdd:
2190         compileValueAdd(node);
2191         break;
2192 
2193     case ValueSub:
2194         compileValueSub(node);
2195         break;
2196 
2197     case StrCat: {
2198         compileStrCat(node);
2199         break;
2200     }
2201 
2202     case ArithAdd:
2203         compileArithAdd(node);
2204         break;
2205 
2206     case ArithClz32:
2207         compileArithClz32(node);
2208         break;
2209 
2210     case MakeRope:
2211         compileMakeRope(node);
2212         break;
2213 
2214     case ArithSub:
2215         compileArithSub(node);
2216         break;
2217 
2218     case ArithNegate:
2219         compileArithNegate(node);
2220         break;
2221 
2222     case ArithMul:
2223         compileArithMul(node);
2224         break;
2225 
2226     case ValueMul:
2227         compileValueMul(node);
2228         break;
2229 
2230     case ValueDiv: {
2231         compileValueDiv(node);
2232         break;
2233     }
2234 
2235     case ArithDiv: {
2236         compileArithDiv(node);
2237         break;
2238     }
2239 
<a name="22" id="anc22"></a><span class="line-added">2240     case ValueMod: {</span>
<span class="line-added">2241         compileValueMod(node);</span>
<span class="line-added">2242         break;</span>
<span class="line-added">2243     }</span>
<span class="line-added">2244 </span>
2245     case ArithMod: {
2246         compileArithMod(node);
2247         break;
2248     }
2249 
2250     case ArithAbs:
2251         compileArithAbs(node);
2252         break;
2253 
2254     case ArithMin:
2255     case ArithMax: {
2256         compileArithMinMax(node);
2257         break;
2258     }
2259 
<a name="23" id="anc23"></a><span class="line-added">2260     case ValuePow:</span>
<span class="line-added">2261         compileValuePow(node);</span>
<span class="line-added">2262         break;</span>
<span class="line-added">2263 </span>
2264     case ArithPow:
2265         compileArithPow(node);
2266         break;
2267 
2268     case ArithSqrt:
2269         compileArithSqrt(node);
2270         break;
2271 
2272     case ArithFRound:
2273         compileArithFRound(node);
2274         break;
2275 
2276     case ArithRandom:
2277         compileArithRandom(node);
2278         break;
2279 
2280     case ArithRound:
2281     case ArithFloor:
2282     case ArithCeil:
2283     case ArithTrunc:
2284         compileArithRounding(node);
2285         break;
2286 
2287     case ArithUnary:
2288         compileArithUnary(node);
2289         break;
2290 
2291     case LogicalNot:
2292         compileLogicalNot(node);
2293         break;
2294 
2295     case CompareLess:
2296         if (compare(node, JITCompiler::LessThan, JITCompiler::DoubleLessThan, operationCompareLess))
2297             return;
2298         break;
2299 
2300     case CompareLessEq:
2301         if (compare(node, JITCompiler::LessThanOrEqual, JITCompiler::DoubleLessThanOrEqual, operationCompareLessEq))
2302             return;
2303         break;
2304 
2305     case CompareGreater:
2306         if (compare(node, JITCompiler::GreaterThan, JITCompiler::DoubleGreaterThan, operationCompareGreater))
2307             return;
2308         break;
2309 
2310     case CompareGreaterEq:
2311         if (compare(node, JITCompiler::GreaterThanOrEqual, JITCompiler::DoubleGreaterThanOrEqual, operationCompareGreaterEq))
2312             return;
2313         break;
2314 
2315     case CompareBelow:
2316         compileCompareUnsigned(node, JITCompiler::Below);
2317         break;
2318 
2319     case CompareBelowEq:
2320         compileCompareUnsigned(node, JITCompiler::BelowOrEqual);
2321         break;
2322 
2323     case CompareEq:
2324         if (compare(node, JITCompiler::Equal, JITCompiler::DoubleEqual, operationCompareEq))
2325             return;
2326         break;
2327 
2328     case CompareStrictEq:
2329         if (compileStrictEq(node))
2330             return;
2331         break;
2332 
2333     case CompareEqPtr:
2334         compileCompareEqPtr(node);
2335         break;
2336 
2337     case SameValue:
2338         compileSameValue(node);
2339         break;
2340 
2341     case StringCharCodeAt: {
2342         compileGetCharCodeAt(node);
2343         break;
2344     }
2345 
2346     case StringCharAt: {
2347         // Relies on StringCharAt node having same basic layout as GetByVal
2348         compileGetByValOnString(node);
2349         break;
2350     }
2351 
2352     case StringFromCharCode: {
2353         compileFromCharCode(node);
2354         break;
2355     }
2356 
2357     case CheckArray: {
2358         checkArray(node);
2359         break;
2360     }
2361 
2362     case Arrayify:
2363     case ArrayifyToStructure: {
2364         arrayify(node);
2365         break;
2366     }
2367 
2368     case GetByVal: {
2369         switch (node-&gt;arrayMode().type()) {
2370         case Array::AnyTypedArray:
2371         case Array::ForceExit:
2372         case Array::SelectUsingArguments:
2373         case Array::SelectUsingPredictions:
2374         case Array::Unprofiled:
2375             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2376             break;
2377         case Array::Undecided: {
2378             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2379             GPRTemporary result(this, Reuse, index);
2380             GPRReg indexGPR = index.gpr();
2381             GPRReg resultGPR = result.gpr();
2382 
2383             speculationCheck(OutOfBounds, JSValueRegs(), node,
2384                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2385 
2386             use(m_graph.varArgChild(node, 0));
2387             index.use();
2388 
2389             m_jit.move(MacroAssembler::TrustedImm64(ValueUndefined), resultGPR);
2390             jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
2391             break;
2392         }
2393         case Array::Generic: {
2394             if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {
2395                 if (m_graph.varArgChild(node, 1).useKind() == StringUse) {
2396                     compileGetByValForObjectWithString(node);
2397                     break;
2398                 }
2399 
2400                 if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {
2401                     compileGetByValForObjectWithSymbol(node);
2402                     break;
2403                 }
2404             }
2405             JSValueOperand base(this, m_graph.varArgChild(node, 0));
2406             JSValueOperand property(this, m_graph.varArgChild(node, 1));
2407             GPRReg baseGPR = base.gpr();
2408             GPRReg propertyGPR = property.gpr();
2409 
2410             flushRegisters();
2411             GPRFlushedCallResult result(this);
2412             callOperation(operationGetByVal, result.gpr(), baseGPR, propertyGPR);
2413             m_jit.exceptionCheck();
2414 
2415             jsValueResult(result.gpr(), node);
2416             break;
2417         }
2418         case Array::Int32:
2419         case Array::Contiguous: {
2420             if (node-&gt;arrayMode().isInBounds()) {
2421                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2422                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2423 
2424                 GPRReg propertyReg = property.gpr();
2425                 GPRReg storageReg = storage.gpr();
2426 
2427                 if (!m_compileOkay)
2428                     return;
2429 
2430                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2431 
2432                 GPRTemporary result(this);
2433 
2434                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.gpr());
2435                 if (node-&gt;arrayMode().isSaneChain()) {
2436                     ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
2437                     JITCompiler::Jump notHole = m_jit.branchIfNotEmpty(result.gpr());
2438                     m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), result.gpr());
2439                     notHole.link(&amp;m_jit);
2440                 } else {
2441                     speculationCheck(
2442                         LoadFromHole, JSValueRegs(), 0,
2443                         m_jit.branchIfEmpty(result.gpr()));
2444                 }
2445                 jsValueResult(result.gpr(), node, node-&gt;arrayMode().type() == Array::Int32 ? DataFormatJSInt32 : DataFormatJS);
2446                 break;
2447             }
2448 
2449             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2450             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2451             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2452 
2453             GPRReg baseReg = base.gpr();
2454             GPRReg propertyReg = property.gpr();
2455             GPRReg storageReg = storage.gpr();
2456 
2457             if (!m_compileOkay)
2458                 return;
2459 
2460             GPRTemporary result(this);
2461             GPRReg resultReg = result.gpr();
2462 
2463             MacroAssembler::JumpList slowCases;
2464 
2465             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2466 
2467             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2468             slowCases.append(m_jit.branchIfEmpty(resultReg));
2469 
2470             addSlowPathGenerator(
2471                 slowPathCall(
2472                     slowCases, this, operationGetByValObjectInt,
2473                     result.gpr(), baseReg, propertyReg));
2474 
2475             jsValueResult(resultReg, node);
2476             break;
2477         }
2478 
2479         case Array::Double: {
2480             if (node-&gt;arrayMode().isInBounds()) {
2481                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2482                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2483 
2484                 GPRReg propertyReg = property.gpr();
2485                 GPRReg storageReg = storage.gpr();
2486 
2487                 if (!m_compileOkay)
2488                     return;
2489 
2490                 FPRTemporary result(this);
2491                 FPRReg resultReg = result.fpr();
2492 
2493                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2494 
2495                 m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2496                 if (!node-&gt;arrayMode().isSaneChain())
2497                     speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfNaN(resultReg));
2498                 doubleResult(resultReg, node);
2499                 break;
2500             }
2501 
2502             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2503             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2504             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2505 
2506             GPRReg baseReg = base.gpr();
2507             GPRReg propertyReg = property.gpr();
2508             GPRReg storageReg = storage.gpr();
2509 
2510             if (!m_compileOkay)
2511                 return;
2512 
2513             GPRTemporary result(this);
2514             FPRTemporary temp(this);
2515             GPRReg resultReg = result.gpr();
2516             FPRReg tempReg = temp.fpr();
2517 
2518             MacroAssembler::JumpList slowCases;
2519 
2520             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2521 
2522             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2523             slowCases.append(m_jit.branchIfNaN(tempReg));
2524             boxDouble(tempReg, resultReg);
2525 
2526             addSlowPathGenerator(
2527                 slowPathCall(
2528                     slowCases, this, operationGetByValObjectInt,
2529                     result.gpr(), baseReg, propertyReg));
2530 
2531             jsValueResult(resultReg, node);
2532             break;
2533         }
2534 
2535         case Array::ArrayStorage:
2536         case Array::SlowPutArrayStorage: {
2537             if (node-&gt;arrayMode().isInBounds()) {
2538                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2539                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2540 
2541                 GPRReg propertyReg = property.gpr();
2542                 GPRReg storageReg = storage.gpr();
2543 
2544                 if (!m_compileOkay)
2545                     return;
2546 
2547                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2548 
2549                 GPRTemporary result(this);
2550                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), result.gpr());
2551                 speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfEmpty(result.gpr()));
2552 
2553                 jsValueResult(result.gpr(), node);
2554                 break;
2555             }
2556 
2557             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2558             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2559             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2560 
2561             GPRReg baseReg = base.gpr();
2562             GPRReg propertyReg = property.gpr();
2563             GPRReg storageReg = storage.gpr();
2564 
2565             if (!m_compileOkay)
2566                 return;
2567 
2568             GPRTemporary result(this);
2569             GPRReg resultReg = result.gpr();
2570 
2571             MacroAssembler::JumpList slowCases;
2572 
2573             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2574 
2575             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), resultReg);
2576             slowCases.append(m_jit.branchIfEmpty(resultReg));
2577 
2578             addSlowPathGenerator(
2579                 slowPathCall(
2580                     slowCases, this, operationGetByValObjectInt,
2581                     result.gpr(), baseReg, propertyReg));
2582 
2583             jsValueResult(resultReg, node);
2584             break;
2585         }
2586         case Array::String:
2587             compileGetByValOnString(node);
2588             break;
2589         case Array::DirectArguments:
2590             compileGetByValOnDirectArguments(node);
2591             break;
2592         case Array::ScopedArguments:
2593             compileGetByValOnScopedArguments(node);
2594             break;
2595         case Array::Int8Array:
2596         case Array::Int16Array:
2597         case Array::Int32Array:
2598         case Array::Uint8Array:
2599         case Array::Uint8ClampedArray:
2600         case Array::Uint16Array:
2601         case Array::Uint32Array:
2602         case Array::Float32Array:
2603         case Array::Float64Array: {
2604             TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2605             if (isInt(type))
2606                 compileGetByValOnIntTypedArray(node, type);
2607             else
2608                 compileGetByValOnFloatTypedArray(node, type);
2609         } }
2610         break;
2611     }
2612 
2613     case GetByValWithThis: {
2614         compileGetByValWithThis(node);
2615         break;
2616     }
2617 
2618     case PutByValDirect:
2619     case PutByVal:
2620     case PutByValAlias: {
2621         Edge child1 = m_jit.graph().varArgChild(node, 0);
2622         Edge child2 = m_jit.graph().varArgChild(node, 1);
2623         Edge child3 = m_jit.graph().varArgChild(node, 2);
2624         Edge child4 = m_jit.graph().varArgChild(node, 3);
2625 
2626         ArrayMode arrayMode = node-&gt;arrayMode().modeForPut();
2627         bool alreadyHandled = false;
2628 
2629         switch (arrayMode.type()) {
2630         case Array::SelectUsingPredictions:
2631         case Array::ForceExit:
2632             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2633             break;
2634         case Array::Generic: {
2635             DFG_ASSERT(m_jit.graph(), node, node-&gt;op() == PutByVal || node-&gt;op() == PutByValDirect, node-&gt;op());
2636 
2637             if (child1.useKind() == CellUse) {
2638                 if (child2.useKind() == StringUse) {
2639                     compilePutByValForCellWithString(node, child1, child2, child3);
2640                     alreadyHandled = true;
2641                     break;
2642                 }
2643 
2644                 if (child2.useKind() == SymbolUse) {
2645                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2646                     alreadyHandled = true;
2647                     break;
2648                 }
2649             }
2650 
2651             JSValueOperand arg1(this, child1);
2652             JSValueOperand arg2(this, child2);
2653             JSValueOperand arg3(this, child3);
2654             GPRReg arg1GPR = arg1.gpr();
2655             GPRReg arg2GPR = arg2.gpr();
2656             GPRReg arg3GPR = arg3.gpr();
2657             flushRegisters();
2658             if (node-&gt;op() == PutByValDirect)
2659                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict, arg1GPR, arg2GPR, arg3GPR);
2660             else
2661                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict, arg1GPR, arg2GPR, arg3GPR);
2662             m_jit.exceptionCheck();
2663 
2664             noResult(node);
2665             alreadyHandled = true;
2666             break;
2667         }
2668         default:
2669             break;
2670         }
2671 
2672         if (alreadyHandled)
2673             break;
2674 
2675         SpeculateCellOperand base(this, child1);
2676         SpeculateStrictInt32Operand property(this, child2);
2677 
2678         GPRReg baseReg = base.gpr();
2679         GPRReg propertyReg = property.gpr();
2680 
2681         switch (arrayMode.type()) {
2682         case Array::Int32:
2683         case Array::Contiguous: {
2684             JSValueOperand value(this, child3, ManualOperandSpeculation);
2685 
2686             GPRReg valueReg = value.gpr();
2687 
2688             if (!m_compileOkay)
2689                 return;
2690 
2691             if (arrayMode.type() == Array::Int32) {
2692                 DFG_TYPE_CHECK(
2693                     JSValueRegs(valueReg), child3, SpecInt32Only,
2694                     m_jit.branchIfNotInt32(valueReg));
2695             }
2696 
2697             StorageOperand storage(this, child4);
2698             GPRReg storageReg = storage.gpr();
2699 
2700             if (node-&gt;op() == PutByValAlias) {
2701                 // Store the value to the array.
2702                 GPRReg propertyReg = property.gpr();
2703                 GPRReg valueReg = value.gpr();
2704                 m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2705 
2706                 noResult(node);
2707                 break;
2708             }
2709 
2710             GPRTemporary temporary;
2711             GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
2712 
2713             MacroAssembler::Jump slowCase;
2714 
2715             if (arrayMode.isInBounds()) {
2716                 speculationCheck(
2717                     OutOfBounds, JSValueRegs(), 0,
2718                     m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2719             } else {
2720                 MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2721 
2722                 slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
2723 
2724                 if (!arrayMode.isOutOfBounds())
2725                     speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
2726 
2727                 m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2728                 m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2729 
2730                 inBounds.link(&amp;m_jit);
2731             }
2732 
2733             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2734 
2735             base.use();
2736             property.use();
2737             value.use();
2738             storage.use();
2739 
2740             if (arrayMode.isOutOfBounds()) {
2741                 addSlowPathGenerator(slowPathCall(
2742                     slowCase, this,
<a name="24" id="anc24"></a><span class="line-modified">2743                     m_jit.isStrictModeFor(node-&gt;origin.semantic)</span>
2744                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2745                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
2746                     NoResult, baseReg, propertyReg, valueReg));
2747             }
2748 
2749             noResult(node, UseChildrenCalledExplicitly);
2750             break;
2751         }
2752 
2753         case Array::Double: {
2754             compileDoublePutByVal(node, base, property);
2755             break;
2756         }
2757 
2758         case Array::ArrayStorage:
2759         case Array::SlowPutArrayStorage: {
2760             JSValueOperand value(this, child3);
2761 
2762             GPRReg valueReg = value.gpr();
2763 
2764             if (!m_compileOkay)
2765                 return;
2766 
2767             StorageOperand storage(this, child4);
2768             GPRReg storageReg = storage.gpr();
2769 
2770             if (node-&gt;op() == PutByValAlias) {
2771                 // Store the value to the array.
2772                 GPRReg propertyReg = property.gpr();
2773                 GPRReg valueReg = value.gpr();
2774                 m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2775 
2776                 noResult(node);
2777                 break;
2778             }
2779 
2780             GPRTemporary temporary;
2781             GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
2782 
2783             MacroAssembler::JumpList slowCases;
2784 
2785             MacroAssembler::Jump beyondArrayBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2786             if (!arrayMode.isOutOfBounds())
2787                 speculationCheck(OutOfBounds, JSValueRegs(), 0, beyondArrayBounds);
2788             else
2789                 slowCases.append(beyondArrayBounds);
2790 
2791             // Check if we&#39;re writing to a hole; if so increment m_numValuesInVector.
2792             if (arrayMode.isInBounds()) {
2793                 speculationCheck(
2794                     StoreToHole, JSValueRegs(), 0,
2795                     m_jit.branchTest64(MacroAssembler::Zero, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset())));
2796             } else {
2797                 MacroAssembler::Jump notHoleValue = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2798                 if (arrayMode.isSlowPut()) {
2799                     // This is sort of strange. If we wanted to optimize this code path, we would invert
2800                     // the above branch. But it&#39;s simply not worth it since this only happens if we&#39;re
2801                     // already having a bad time.
2802                     slowCases.append(m_jit.jump());
2803                 } else {
2804                     m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageReg, ArrayStorage::numValuesInVectorOffset()));
2805 
2806                     // If we&#39;re writing to a hole we might be growing the array;
2807                     MacroAssembler::Jump lengthDoesNotNeedUpdate = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2808                     m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2809                     m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2810 
2811                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2812                 }
2813                 notHoleValue.link(&amp;m_jit);
2814             }
2815 
2816             // Store the value to the array.
2817             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2818 
2819             base.use();
2820             property.use();
2821             value.use();
2822             storage.use();
2823 
2824             if (!slowCases.empty()) {
2825                 addSlowPathGenerator(slowPathCall(
2826                     slowCases, this,
<a name="25" id="anc25"></a><span class="line-modified">2827                     m_jit.isStrictModeFor(node-&gt;origin.semantic)</span>
2828                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2829                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
2830                     NoResult, baseReg, propertyReg, valueReg));
2831             }
2832 
2833             noResult(node, UseChildrenCalledExplicitly);
2834             break;
2835         }
2836 
2837         case Array::Int8Array:
2838         case Array::Int16Array:
2839         case Array::Int32Array:
2840         case Array::Uint8Array:
2841         case Array::Uint8ClampedArray:
2842         case Array::Uint16Array:
2843         case Array::Uint32Array:
2844         case Array::Float32Array:
2845         case Array::Float64Array: {
2846             TypedArrayType type = arrayMode.typedArrayType();
2847             if (isInt(type))
2848                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2849             else
2850                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2851             break;
2852         }
2853 
2854         case Array::AnyTypedArray:
2855         case Array::String:
2856         case Array::DirectArguments:
2857         case Array::ForceExit:
2858         case Array::Generic:
2859         case Array::ScopedArguments:
2860         case Array::SelectUsingArguments:
2861         case Array::SelectUsingPredictions:
2862         case Array::Undecided:
2863         case Array::Unprofiled:
2864             RELEASE_ASSERT_NOT_REACHED();
2865         }
2866         break;
2867     }
2868 
2869     case AtomicsAdd:
2870     case AtomicsAnd:
2871     case AtomicsCompareExchange:
2872     case AtomicsExchange:
2873     case AtomicsLoad:
2874     case AtomicsOr:
2875     case AtomicsStore:
2876     case AtomicsSub:
2877     case AtomicsXor: {
2878         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2879         Edge baseEdge = m_jit.graph().child(node, 0);
2880         Edge indexEdge = m_jit.graph().child(node, 1);
2881         Edge argEdges[maxNumExtraAtomicsArgs];
2882         for (unsigned i = numExtraArgs; i--;)
2883             argEdges[i] = m_jit.graph().child(node, 2 + i);
2884         Edge storageEdge = m_jit.graph().child(node, 2 + numExtraArgs);
2885 
2886         GPRReg baseGPR;
2887         GPRReg indexGPR;
2888         GPRReg argGPRs[2];
2889         GPRReg resultGPR;
2890 
2891         auto callSlowPath = [&amp;] () {
2892             switch (node-&gt;op()) {
2893             case AtomicsAdd:
2894                 callOperation(operationAtomicsAdd, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2895                 break;
2896             case AtomicsAnd:
2897                 callOperation(operationAtomicsAnd, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2898                 break;
2899             case AtomicsCompareExchange:
2900                 callOperation(operationAtomicsCompareExchange, resultGPR, baseGPR, indexGPR, argGPRs[0], argGPRs[1]);
2901                 break;
2902             case AtomicsExchange:
2903                 callOperation(operationAtomicsExchange, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2904                 break;
2905             case AtomicsLoad:
2906                 callOperation(operationAtomicsLoad, resultGPR, baseGPR, indexGPR);
2907                 break;
2908             case AtomicsOr:
2909                 callOperation(operationAtomicsOr, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2910                 break;
2911             case AtomicsStore:
2912                 callOperation(operationAtomicsStore, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2913                 break;
2914             case AtomicsSub:
2915                 callOperation(operationAtomicsSub, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2916                 break;
2917             case AtomicsXor:
2918                 callOperation(operationAtomicsXor, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2919                 break;
2920             default:
2921                 RELEASE_ASSERT_NOT_REACHED();
2922                 break;
2923             }
2924         };
2925 
2926         if (!storageEdge) {
2927             // We are in generic mode!
2928             JSValueOperand base(this, baseEdge);
2929             JSValueOperand index(this, indexEdge);
2930             Optional&lt;JSValueOperand&gt; args[2];
2931             baseGPR = base.gpr();
2932             indexGPR = index.gpr();
2933             for (unsigned i = numExtraArgs; i--;) {
2934                 args[i].emplace(this, argEdges[i]);
2935                 argGPRs[i] = args[i]-&gt;gpr();
2936             }
2937 
2938             flushRegisters();
2939             GPRFlushedCallResult result(this);
2940             resultGPR = result.gpr();
2941             callSlowPath();
2942             m_jit.exceptionCheck();
2943 
2944             jsValueResult(resultGPR, node);
2945             break;
2946         }
2947 
2948         TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2949 
2950         SpeculateCellOperand base(this, baseEdge);
2951         SpeculateStrictInt32Operand index(this, indexEdge);
2952 
2953         baseGPR = base.gpr();
2954         indexGPR = index.gpr();
2955 
2956         emitTypedArrayBoundsCheck(node, baseGPR, indexGPR);
2957 
2958         GPRTemporary args[2];
2959 
2960         JITCompiler::JumpList slowPathCases;
2961 
2962         bool ok = true;
2963         for (unsigned i = numExtraArgs; i--;) {
2964             if (!getIntTypedArrayStoreOperand(args[i], indexGPR, argEdges[i], slowPathCases)) {
2965                 noResult(node);
2966                 ok = false;
2967             }
2968             argGPRs[i] = args[i].gpr();
2969         }
2970         if (!ok)
2971             break;
2972 
2973         StorageOperand storage(this, storageEdge);
2974         GPRTemporary oldValue(this);
2975         GPRTemporary result(this);
2976         GPRTemporary newValue(this);
2977         GPRReg storageGPR = storage.gpr();
2978         GPRReg oldValueGPR = oldValue.gpr();
2979         resultGPR = result.gpr();
2980         GPRReg newValueGPR = newValue.gpr();
2981 
2982         // FIXME: It shouldn&#39;t be necessary to nop-pad between register allocation and a jump label.
2983         // https://bugs.webkit.org/show_bug.cgi?id=170974
2984         m_jit.nop();
2985 
2986         JITCompiler::Label loop = m_jit.label();
2987 
2988         loadFromIntTypedArray(storageGPR, indexGPR, oldValueGPR, type);
2989         m_jit.move(oldValueGPR, newValueGPR);
2990         m_jit.move(oldValueGPR, resultGPR);
2991 
2992         switch (node-&gt;op()) {
2993         case AtomicsAdd:
2994             m_jit.add32(argGPRs[0], newValueGPR);
2995             break;
2996         case AtomicsAnd:
2997             m_jit.and32(argGPRs[0], newValueGPR);
2998             break;
2999         case AtomicsCompareExchange: {
3000             switch (elementSize(type)) {
3001             case 1:
3002                 if (isSigned(type))
3003                     m_jit.signExtend8To32(argGPRs[0], argGPRs[0]);
3004                 else
3005                     m_jit.and32(TrustedImm32(0xff), argGPRs[0]);
3006                 break;
3007             case 2:
3008                 if (isSigned(type))
3009                     m_jit.signExtend16To32(argGPRs[0], argGPRs[0]);
3010                 else
3011                     m_jit.and32(TrustedImm32(0xffff), argGPRs[0]);
3012                 break;
3013             case 4:
3014                 break;
3015             default:
3016                 RELEASE_ASSERT_NOT_REACHED();
3017                 break;
3018             }
3019             JITCompiler::Jump fail = m_jit.branch32(JITCompiler::NotEqual, oldValueGPR, argGPRs[0]);
3020             m_jit.move(argGPRs[1], newValueGPR);
3021             fail.link(&amp;m_jit);
3022             break;
3023         }
3024         case AtomicsExchange:
3025             m_jit.move(argGPRs[0], newValueGPR);
3026             break;
3027         case AtomicsLoad:
3028             break;
3029         case AtomicsOr:
3030             m_jit.or32(argGPRs[0], newValueGPR);
3031             break;
3032         case AtomicsStore:
3033             m_jit.move(argGPRs[0], newValueGPR);
3034             m_jit.move(argGPRs[0], resultGPR);
3035             break;
3036         case AtomicsSub:
3037             m_jit.sub32(argGPRs[0], newValueGPR);
3038             break;
3039         case AtomicsXor:
3040             m_jit.xor32(argGPRs[0], newValueGPR);
3041             break;
3042         default:
3043             RELEASE_ASSERT_NOT_REACHED();
3044             break;
3045         }
3046 
3047         JITCompiler::JumpList success;
3048         switch (elementSize(type)) {
3049         case 1:
3050             success = m_jit.branchAtomicWeakCAS8(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesOne));
3051             break;
3052         case 2:
3053             success = m_jit.branchAtomicWeakCAS16(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesTwo));
3054             break;
3055         case 4:
3056             success = m_jit.branchAtomicWeakCAS32(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesFour));
3057             break;
3058         default:
3059             RELEASE_ASSERT_NOT_REACHED();
3060             break;
3061         }
3062         m_jit.jump().linkTo(loop, &amp;m_jit);
3063 
3064         if (!slowPathCases.empty()) {
3065             slowPathCases.link(&amp;m_jit);
3066             silentSpillAllRegisters(resultGPR);
3067             // Since we spilled, we can do things to registers.
3068             m_jit.boxCell(baseGPR, JSValueRegs(baseGPR));
3069             m_jit.boxInt32(indexGPR, JSValueRegs(indexGPR));
3070             for (unsigned i = numExtraArgs; i--;)
3071                 m_jit.boxInt32(argGPRs[i], JSValueRegs(argGPRs[i]));
3072             callSlowPath();
3073             silentFillAllRegisters();
3074             m_jit.exceptionCheck();
3075         }
3076 
3077         success.link(&amp;m_jit);
3078         setIntTypedArrayLoadResult(node, resultGPR, type);
3079         break;
3080     }
3081 
3082     case AtomicsIsLockFree: {
3083         if (node-&gt;child1().useKind() != Int32Use) {
3084             JSValueOperand operand(this, node-&gt;child1());
3085             GPRReg operandGPR = operand.gpr();
3086             flushRegisters();
3087             GPRFlushedCallResult result(this);
3088             GPRReg resultGPR = result.gpr();
3089             callOperation(operationAtomicsIsLockFree, resultGPR, operandGPR);
3090             m_jit.exceptionCheck();
3091             jsValueResult(resultGPR, node);
3092             break;
3093         }
3094 
3095         SpeculateInt32Operand operand(this, node-&gt;child1());
3096         GPRTemporary result(this);
3097         GPRReg operandGPR = operand.gpr();
3098         GPRReg resultGPR = result.gpr();
3099         m_jit.move(TrustedImm32(ValueTrue), resultGPR);
3100         JITCompiler::JumpList done;
3101         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(4)));
3102         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(1)));
3103         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(2)));
3104         m_jit.move(TrustedImm32(ValueFalse), resultGPR);
3105         done.link(&amp;m_jit);
3106         jsValueResult(resultGPR, node);
3107         break;
3108     }
3109 
3110     case RegExpExec: {
3111         compileRegExpExec(node);
3112         break;
3113     }
3114 
3115     case RegExpExecNonGlobalOrSticky: {
3116         compileRegExpExecNonGlobalOrSticky(node);
3117         break;
3118     }
3119 
3120     case RegExpMatchFastGlobal: {
3121         compileRegExpMatchFastGlobal(node);
3122         break;
3123     }
3124 
3125     case RegExpTest: {
3126         compileRegExpTest(node);
3127         break;
3128     }
3129 
3130     case RegExpMatchFast: {
3131         compileRegExpMatchFast(node);
3132         break;
3133     }
3134 
3135     case StringReplace:
3136     case StringReplaceRegExp: {
3137         compileStringReplace(node);
3138         break;
3139     }
3140 
3141     case GetRegExpObjectLastIndex: {
3142         compileGetRegExpObjectLastIndex(node);
3143         break;
3144     }
3145 
3146     case SetRegExpObjectLastIndex: {
3147         compileSetRegExpObjectLastIndex(node);
3148         break;
3149     }
3150 
3151     case RecordRegExpCachedResult: {
3152         compileRecordRegExpCachedResult(node);
3153         break;
3154     }
3155 
3156     case ArrayPush: {
3157         compileArrayPush(node);
3158         break;
3159     }
3160 
3161     case ArraySlice: {
3162         compileArraySlice(node);
3163         break;
3164     }
3165 
3166     case ArrayIndexOf: {
3167         compileArrayIndexOf(node);
3168         break;
3169     }
3170 
3171     case ArrayPop: {
3172         ASSERT(node-&gt;arrayMode().isJSArray());
3173 
3174         SpeculateCellOperand base(this, node-&gt;child1());
3175         StorageOperand storage(this, node-&gt;child2());
3176         GPRTemporary value(this);
3177         GPRTemporary storageLength(this);
3178         FPRTemporary temp(this); // This is kind of lame, since we don&#39;t always need it. I&#39;m relying on the fact that we don&#39;t have FPR pressure, especially in code that uses pop().
3179 
3180         GPRReg baseGPR = base.gpr();
3181         GPRReg storageGPR = storage.gpr();
3182         GPRReg valueGPR = value.gpr();
3183         GPRReg storageLengthGPR = storageLength.gpr();
3184         FPRReg tempFPR = temp.fpr();
3185 
3186         switch (node-&gt;arrayMode().type()) {
3187         case Array::Int32:
3188         case Array::Double:
3189         case Array::Contiguous: {
3190             m_jit.load32(
3191                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
3192             MacroAssembler::Jump undefinedCase =
3193                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3194             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3195             m_jit.store32(
3196                 storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
3197             MacroAssembler::Jump slowCase;
3198             if (node-&gt;arrayMode().type() == Array::Double) {
3199                 m_jit.loadDouble(
3200                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3201                     tempFPR);
3202                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3203                 // length and the new length.
3204                 m_jit.store64(
3205                     MacroAssembler::TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3206                 slowCase = m_jit.branchIfNaN(tempFPR);
3207                 boxDouble(tempFPR, valueGPR);
3208             } else {
3209                 m_jit.load64(
3210                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3211                     valueGPR);
3212                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3213                 // length and the new length.
3214                 m_jit.store64(
3215                 MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3216                 slowCase = m_jit.branchIfEmpty(valueGPR);
3217             }
3218 
3219             addSlowPathGenerator(
3220                 slowPathMove(
3221                     undefinedCase, this,
3222                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3223             addSlowPathGenerator(
3224                 slowPathCall(
3225                     slowCase, this, operationArrayPopAndRecoverLength, valueGPR, baseGPR));
3226 
3227             // We can&#39;t know for sure that the result is an int because of the slow paths. :-/
3228             jsValueResult(valueGPR, node);
3229             break;
3230         }
3231 
3232         case Array::ArrayStorage: {
3233             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
3234 
3235             JITCompiler::Jump undefinedCase =
3236                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3237 
3238             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3239 
3240             JITCompiler::JumpList slowCases;
3241             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset())));
3242 
3243             m_jit.load64(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), valueGPR);
3244             slowCases.append(m_jit.branchIfEmpty(valueGPR));
3245 
3246             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
3247 
3248             m_jit.store64(MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight,  ArrayStorage::vectorOffset()));
3249             m_jit.sub32(MacroAssembler::TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
3250 
3251             addSlowPathGenerator(
3252                 slowPathMove(
3253                     undefinedCase, this,
3254                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3255 
3256             addSlowPathGenerator(
3257                 slowPathCall(
3258                     slowCases, this, operationArrayPop, valueGPR, baseGPR));
3259 
3260             jsValueResult(valueGPR, node);
3261             break;
3262         }
3263 
3264         default:
3265             CRASH();
3266             break;
3267         }
3268         break;
3269     }
3270 
3271     case DFG::Jump: {
3272         jump(node-&gt;targetBlock());
3273         noResult(node);
3274         break;
3275     }
3276 
3277     case Branch:
3278         emitBranch(node);
3279         break;
3280 
3281     case Switch:
3282         emitSwitch(node);
3283         break;
3284 
3285     case Return: {
3286         ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT1);
3287         ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);
3288         ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);
3289 
3290         // Return the result in returnValueGPR.
3291         JSValueOperand op1(this, node-&gt;child1());
3292         m_jit.move(op1.gpr(), GPRInfo::returnValueGPR);
3293 
3294         m_jit.emitRestoreCalleeSaves();
3295         m_jit.emitFunctionEpilogue();
3296         m_jit.ret();
3297 
3298         noResult(node);
3299         break;
3300     }
3301 
3302     case Throw: {
3303         compileThrow(node);
3304         break;
3305     }
3306 
3307     case ThrowStaticError: {
3308         compileThrowStaticError(node);
3309         break;
3310     }
3311 
3312     case BooleanToNumber: {
3313         switch (node-&gt;child1().useKind()) {
3314         case BooleanUse: {
3315             JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
3316             GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
3317 
3318             m_jit.move(value.gpr(), result.gpr());
3319             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());
3320             DFG_TYPE_CHECK(
3321                 JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
3322                     JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
3323 
3324             int32Result(result.gpr(), node);
3325             break;
3326         }
3327 
3328         case UntypedUse: {
3329             JSValueOperand value(this, node-&gt;child1());
3330             GPRTemporary result(this);
3331 
3332             if (!m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
3333                 m_jit.move(value.gpr(), result.gpr());
3334                 m_jit.and32(TrustedImm32(1), result.gpr());
3335                 int32Result(result.gpr(), node);
3336                 break;
3337             }
3338 
3339             m_jit.move(value.gpr(), result.gpr());
3340             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());
3341             JITCompiler::Jump isBoolean = m_jit.branchTest64(
3342                 JITCompiler::Zero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
3343             m_jit.move(value.gpr(), result.gpr());
3344             JITCompiler::Jump done = m_jit.jump();
3345             isBoolean.link(&amp;m_jit);
3346             m_jit.or64(GPRInfo::tagTypeNumberRegister, result.gpr());
3347             done.link(&amp;m_jit);
3348 
3349             jsValueResult(result.gpr(), node);
3350             break;
3351         }
3352 
3353         default:
3354             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
3355             break;
3356         }
3357         break;
3358     }
3359 
3360     case ToPrimitive: {
3361         compileToPrimitive(node);
3362         break;
3363     }
3364 
3365     case ToNumber: {
3366         JSValueOperand argument(this, node-&gt;child1());
3367         GPRTemporary result(this, Reuse, argument);
3368 
3369         GPRReg argumentGPR = argument.gpr();
3370         GPRReg resultGPR = result.gpr();
3371 
3372         argument.use();
3373 
3374         // We have several attempts to remove ToNumber. But ToNumber still exists.
3375         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3376         // Instead of the slow path generator, we emit callOperation here.
3377         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3378             flushRegisters();
3379             callOperation(operationToNumber, resultGPR, argumentGPR);
3380             m_jit.exceptionCheck();
3381         } else {
3382             MacroAssembler::Jump notNumber = m_jit.branchIfNotNumber(argumentGPR);
3383             m_jit.move(argumentGPR, resultGPR);
3384             MacroAssembler::Jump done = m_jit.jump();
3385 
3386             notNumber.link(&amp;m_jit);
3387             silentSpillAllRegisters(resultGPR);
3388             callOperation(operationToNumber, resultGPR, argumentGPR);
3389             silentFillAllRegisters();
3390             m_jit.exceptionCheck();
3391 
3392             done.link(&amp;m_jit);
3393         }
3394 
3395         jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
3396         break;
3397     }
3398 
3399     case ToString:
3400     case CallStringConstructor:
3401     case StringValueOf: {
3402         compileToStringOrCallStringConstructorOrStringValueOf(node);
3403         break;
3404     }
3405 
3406     case NewStringObject: {
3407         compileNewStringObject(node);
3408         break;
3409     }
3410 
3411     case NewSymbol: {
3412         compileNewSymbol(node);
3413         break;
3414     }
3415 
3416     case NewArray: {
3417         compileNewArray(node);
3418         break;
3419     }
3420 
3421     case NewArrayWithSpread: {
3422         compileNewArrayWithSpread(node);
3423         break;
3424     }
3425 
3426     case Spread: {
3427         compileSpread(node);
3428         break;
3429     }
3430 
3431     case NewArrayWithSize: {
3432         compileNewArrayWithSize(node);
3433         break;
3434     }
3435 
3436     case NewArrayBuffer: {
3437         compileNewArrayBuffer(node);
3438         break;
3439     }
3440 
3441     case NewTypedArray: {
3442         compileNewTypedArray(node);
3443         break;
3444     }
3445 
3446     case NewRegexp: {
3447         compileNewRegexp(node);
3448         break;
3449     }
3450 
3451     case ToObject:
3452     case CallObjectConstructor: {
3453         compileToObjectOrCallObjectConstructor(node);
3454         break;
3455     }
3456 
3457     case ToThis: {
3458         compileToThis(node);
3459         break;
3460     }
3461 
3462     case ObjectCreate: {
3463         compileObjectCreate(node);
3464         break;
3465     }
3466 
3467     case ObjectKeys: {
3468         compileObjectKeys(node);
3469         break;
3470     }
3471 
3472     case CreateThis: {
3473         compileCreateThis(node);
3474         break;
3475     }
3476 
3477     case NewObject: {
3478         compileNewObject(node);
3479         break;
3480     }
3481 
3482     case GetCallee: {
3483         compileGetCallee(node);
3484         break;
3485     }
3486 
3487     case SetCallee: {
3488         compileSetCallee(node);
3489         break;
3490     }
3491 
3492     case GetArgumentCountIncludingThis: {
3493         compileGetArgumentCountIncludingThis(node);
3494         break;
3495     }
3496 
3497     case SetArgumentCountIncludingThis:
3498         compileSetArgumentCountIncludingThis(node);
3499         break;
3500 
3501     case GetRestLength: {
3502         compileGetRestLength(node);
3503         break;
3504     }
3505 
3506     case GetScope:
3507         compileGetScope(node);
3508         break;
3509 
3510     case SkipScope:
3511         compileSkipScope(node);
3512         break;
3513 
3514     case GetGlobalObject:
3515         compileGetGlobalObject(node);
3516         break;
3517 
3518     case GetGlobalThis:
3519         compileGetGlobalThis(node);
3520         break;
3521 
3522     case GetClosureVar: {
3523         compileGetClosureVar(node);
3524         break;
3525     }
3526     case PutClosureVar: {
3527         compilePutClosureVar(node);
3528         break;
3529     }
3530 
3531     case TryGetById: {
3532         compileGetById(node, AccessType::TryGet);
3533         break;
3534     }
3535 
3536     case GetByIdDirect: {
3537         compileGetById(node, AccessType::GetDirect);
3538         break;
3539     }
3540 
3541     case GetByIdDirectFlush: {
3542         compileGetByIdFlush(node, AccessType::GetDirect);
3543         break;
3544     }
3545 
3546     case GetById: {
3547         compileGetById(node, AccessType::Get);
3548         break;
3549     }
3550 
3551     case GetByIdFlush: {
3552         compileGetByIdFlush(node, AccessType::Get);
3553         break;
3554     }
3555 
3556     case GetByIdWithThis: {
3557         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3558             SpeculateCellOperand base(this, node-&gt;child1());
3559             GPRReg baseGPR = base.gpr();
3560             SpeculateCellOperand thisValue(this, node-&gt;child2());
3561             GPRReg thisValueGPR = thisValue.gpr();
3562 
3563             GPRFlushedCallResult result(this);
3564             GPRReg resultGPR = result.gpr();
3565 
3566             flushRegisters();
3567 
3568             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), JITCompiler::JumpList());
3569 
3570             jsValueResult(resultGPR, node);
3571 
3572         } else {
3573             JSValueOperand base(this, node-&gt;child1());
3574             GPRReg baseGPR = base.gpr();
3575             JSValueOperand thisValue(this, node-&gt;child2());
3576             GPRReg thisValueGPR = thisValue.gpr();
3577 
3578             GPRFlushedCallResult result(this);
3579             GPRReg resultGPR = result.gpr();
3580 
3581             flushRegisters();
3582 
3583             JITCompiler::JumpList notCellList;
3584             notCellList.append(m_jit.branchIfNotCell(JSValueRegs(baseGPR)));
3585             notCellList.append(m_jit.branchIfNotCell(JSValueRegs(thisValueGPR)));
3586 
3587             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), notCellList);
3588 
3589             jsValueResult(resultGPR, node);
3590         }
3591 
3592         break;
3593     }
3594 
3595     case GetArrayLength:
3596         compileGetArrayLength(node);
3597         break;
3598 
3599     case DeleteById: {
3600         compileDeleteById(node);
3601         break;
3602     }
3603 
3604     case DeleteByVal: {
3605         compileDeleteByVal(node);
3606         break;
3607     }
3608 
3609     case CheckCell: {
3610         compileCheckCell(node);
3611         break;
3612     }
3613 
3614     case CheckNotEmpty: {
3615         compileCheckNotEmpty(node);
3616         break;
3617     }
3618 
3619     case AssertNotEmpty: {
3620         if (validationEnabled()) {
3621             JSValueOperand operand(this, node-&gt;child1());
3622             GPRReg input = operand.gpr();
3623             auto done = m_jit.branchIfNotEmpty(input);
3624             m_jit.breakpoint();
3625             done.link(&amp;m_jit);
3626         }
3627         noResult(node);
3628         break;
3629     }
3630 
3631     case CheckStringIdent:
3632         compileCheckStringIdent(node);
3633         break;
3634 
3635     case GetExecutable: {
3636         compileGetExecutable(node);
3637         break;
3638     }
3639 
3640     case CheckStructureOrEmpty: {
3641         SpeculateCellOperand cell(this, node-&gt;child1());
3642         GPRReg cellGPR = cell.gpr();
3643 
3644         GPRReg tempGPR = InvalidGPRReg;
3645         Optional&lt;GPRTemporary&gt; temp;
3646         if (node-&gt;structureSet().size() &gt; 1) {
3647             temp.emplace(this);
3648             tempGPR = temp-&gt;gpr();
3649         }
3650 
3651         MacroAssembler::Jump isEmpty;
3652         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
3653             isEmpty = m_jit.branchIfEmpty(cellGPR);
3654 
3655         emitStructureCheck(node, cellGPR, tempGPR);
3656 
3657         if (isEmpty.isSet())
3658             isEmpty.link(&amp;m_jit);
3659 
3660         noResult(node);
3661         break;
3662     }
3663 
3664     case CheckStructure: {
3665         compileCheckStructure(node);
3666         break;
3667     }
3668 
3669     case PutStructure: {
3670         RegisteredStructure oldStructure = node-&gt;transition()-&gt;previous;
3671         RegisteredStructure newStructure = node-&gt;transition()-&gt;next;
3672 
3673         m_jit.jitCode()-&gt;common.notifyCompilingStructureTransition(m_jit.graph().m_plan, m_jit.codeBlock(), node);
3674 
3675         SpeculateCellOperand base(this, node-&gt;child1());
3676         GPRReg baseGPR = base.gpr();
3677 
3678         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
3679         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
3680         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
3681         m_jit.store32(MacroAssembler::TrustedImm32(newStructure-&gt;id()), MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()));
3682 
3683         noResult(node);
3684         break;
3685     }
3686 
3687     case AllocatePropertyStorage:
3688         compileAllocatePropertyStorage(node);
3689         break;
3690 
3691     case ReallocatePropertyStorage:
3692         compileReallocatePropertyStorage(node);
3693         break;
3694 
3695     case NukeStructureAndSetButterfly:
3696         compileNukeStructureAndSetButterfly(node);
3697         break;
3698 
3699     case GetButterfly:
3700         compileGetButterfly(node);
3701         break;
3702 
3703     case GetIndexedPropertyStorage: {
3704         compileGetIndexedPropertyStorage(node);
3705         break;
3706     }
3707 
3708     case ConstantStoragePointer: {
3709         compileConstantStoragePointer(node);
3710         break;
3711     }
3712 
3713     case GetTypedArrayByteOffset: {
3714         compileGetTypedArrayByteOffset(node);
3715         break;
3716     }
3717 
3718     case GetPrototypeOf: {
3719         compileGetPrototypeOf(node);
3720         break;
3721     }
3722 
3723     case GetByOffset:
3724     case GetGetterSetterByOffset: {
3725         compileGetByOffset(node);
3726         break;
3727     }
3728 
3729     case MatchStructure: {
3730         compileMatchStructure(node);
3731         break;
3732     }
3733 
3734     case GetGetter: {
3735         compileGetGetter(node);
3736         break;
3737     }
3738 
3739     case GetSetter: {
3740         compileGetSetter(node);
3741         break;
3742     }
3743 
3744     case PutByOffset: {
3745         compilePutByOffset(node);
3746         break;
3747     }
3748 
3749     case PutByIdFlush: {
3750         compilePutByIdFlush(node);
3751         break;
3752     }
3753 
3754     case PutById: {
3755         compilePutById(node);
3756         break;
3757     }
3758 
3759     case PutByIdWithThis: {
3760         compilePutByIdWithThis(node);
3761         break;
3762     }
3763 
3764     case PutByValWithThis: {
3765         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
3766         GPRReg baseGPR = base.gpr();
3767         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
3768         GPRReg thisValueGPR = thisValue.gpr();
3769         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
3770         GPRReg propertyGPR = property.gpr();
3771         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
3772         GPRReg valueGPR = value.gpr();
3773 
3774         flushRegisters();
3775         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis, NoResult, baseGPR, thisValueGPR, propertyGPR, valueGPR);
3776         m_jit.exceptionCheck();
3777 
3778         noResult(node);
3779         break;
3780     }
3781 
3782     case PutByIdDirect: {
3783         compilePutByIdDirect(node);
3784         break;
3785     }
3786 
3787     case PutGetterById:
3788     case PutSetterById: {
3789         compilePutAccessorById(node);
3790         break;
3791     }
3792 
3793     case PutGetterSetterById: {
3794         compilePutGetterSetterById(node);
3795         break;
3796     }
3797 
3798     case PutGetterByVal:
3799     case PutSetterByVal: {
3800         compilePutAccessorByVal(node);
3801         break;
3802     }
3803 
3804     case DefineDataProperty: {
3805         compileDefineDataProperty(node);
3806         break;
3807     }
3808 
3809     case DefineAccessorProperty: {
3810         compileDefineAccessorProperty(node);
3811         break;
3812     }
3813 
3814     case GetGlobalLexicalVariable:
3815     case GetGlobalVar: {
3816         compileGetGlobalVariable(node);
3817         break;
3818     }
3819 
3820     case PutGlobalVariable: {
3821         compilePutGlobalVariable(node);
3822         break;
3823     }
3824 
3825     case PutDynamicVar: {
3826         compilePutDynamicVar(node);
3827         break;
3828     }
3829 
3830     case GetDynamicVar: {
3831         compileGetDynamicVar(node);
3832         break;
3833     }
3834 
3835     case ResolveScopeForHoistingFuncDeclInEval: {
3836         compileResolveScopeForHoistingFuncDeclInEval(node);
3837         break;
3838     }
3839 
3840     case ResolveScope: {
3841         compileResolveScope(node);
3842         break;
3843     }
3844 
3845     case NotifyWrite: {
3846         compileNotifyWrite(node);
3847         break;
3848     }
3849 
3850     case CheckTypeInfoFlags: {
3851         compileCheckTypeInfoFlags(node);
3852         break;
3853     }
3854 
3855     case ParseInt: {
3856         compileParseInt(node);
3857         break;
3858     }
3859 
3860     case OverridesHasInstance: {
3861         compileOverridesHasInstance(node);
3862         break;
3863     }
3864 
3865     case InstanceOf: {
3866         compileInstanceOf(node);
3867         break;
3868     }
3869 
3870     case InstanceOfCustom: {
3871         compileInstanceOfCustom(node);
3872         break;
3873     }
3874 
3875     case IsEmpty: {
3876         JSValueOperand value(this, node-&gt;child1());
3877         GPRTemporary result(this, Reuse, value);
3878 
3879         m_jit.comparePtr(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::encode(JSValue())), result.gpr());
3880         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3881 
3882         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3883         break;
3884     }
3885 
3886     case IsUndefined: {
3887         JSValueOperand value(this, node-&gt;child1());
3888         GPRTemporary result(this);
3889         GPRTemporary localGlobalObject(this);
3890         GPRTemporary remoteGlobalObject(this);
3891         GPRTemporary scratch(this);
3892 
3893         JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
3894 
3895         m_jit.compare64(JITCompiler::Equal, value.gpr(), TrustedImm32(ValueUndefined), result.gpr());
3896         JITCompiler::Jump done = m_jit.jump();
3897 
3898         isCell.link(&amp;m_jit);
3899         JITCompiler::Jump notMasqueradesAsUndefined;
3900         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
3901             m_jit.move(TrustedImm32(0), result.gpr());
3902             notMasqueradesAsUndefined = m_jit.jump();
3903         } else {
3904             JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
3905                 JITCompiler::NonZero,
3906                 JITCompiler::Address(value.gpr(), JSCell::typeInfoFlagsOffset()),
3907                 TrustedImm32(MasqueradesAsUndefined));
3908             m_jit.move(TrustedImm32(0), result.gpr());
3909             notMasqueradesAsUndefined = m_jit.jump();
3910 
3911             isMasqueradesAsUndefined.link(&amp;m_jit);
3912             GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
3913             GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
3914             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)), localGlobalObjectGPR);
<a name="26" id="anc26"></a><span class="line-modified">3915             m_jit.emitLoadStructure(vm(), value.gpr(), result.gpr(), scratch.gpr());</span>
3916             m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), remoteGlobalObjectGPR);
3917             m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
3918         }
3919 
3920         notMasqueradesAsUndefined.link(&amp;m_jit);
3921         done.link(&amp;m_jit);
3922         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3923         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3924         break;
3925     }
3926 
3927     case IsUndefinedOrNull: {
3928         JSValueOperand value(this, node-&gt;child1());
3929         GPRTemporary result(this, Reuse, value);
3930 
3931         GPRReg valueGPR = value.gpr();
3932         GPRReg resultGPR = result.gpr();
3933 
3934         m_jit.move(valueGPR, resultGPR);
3935         m_jit.and64(CCallHelpers::TrustedImm32(~TagBitUndefined), resultGPR);
3936         m_jit.compare64(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(ValueNull), resultGPR);
3937 
3938         unblessedBooleanResult(resultGPR, node);
3939         break;
3940     }
3941 
3942     case IsBoolean: {
3943         JSValueOperand value(this, node-&gt;child1());
3944         GPRTemporary result(this, Reuse, value);
3945 
3946         m_jit.move(value.gpr(), result.gpr());
3947         m_jit.xor64(JITCompiler::TrustedImm32(ValueFalse), result.gpr());
3948         m_jit.test64(JITCompiler::Zero, result.gpr(), JITCompiler::TrustedImm32(static_cast&lt;int32_t&gt;(~1)), result.gpr());
3949         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3950         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3951         break;
3952     }
3953 
3954     case IsNumber: {
3955         JSValueOperand value(this, node-&gt;child1());
3956         GPRTemporary result(this, Reuse, value);
3957 
3958         m_jit.test64(JITCompiler::NonZero, value.gpr(), GPRInfo::tagTypeNumberRegister, result.gpr());
3959         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3960         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3961         break;
3962     }
3963 
3964     case NumberIsInteger: {
3965         JSValueOperand value(this, node-&gt;child1());
3966         GPRTemporary result(this, Reuse, value);
3967 
3968         FPRTemporary temp1(this);
3969         FPRTemporary temp2(this);
3970 
3971         JSValueRegs valueRegs = JSValueRegs(value.gpr());
3972         GPRReg resultGPR = result.gpr();
3973 
3974         FPRReg tempFPR1 = temp1.fpr();
3975         FPRReg tempFPR2 = temp2.fpr();
3976 
3977         MacroAssembler::JumpList done;
3978 
3979         auto isInt32 = m_jit.branchIfInt32(valueRegs);
3980         auto notNumber = m_jit.branchIfNotDoubleKnownNotInt32(valueRegs);
3981 
3982         // We&#39;re a double here.
3983         m_jit.unboxDouble(valueRegs.gpr(), resultGPR, tempFPR1);
3984         m_jit.urshift64(TrustedImm32(52), resultGPR);
3985         m_jit.and32(TrustedImm32(0x7ff), resultGPR);
3986         auto notNanNorInfinity = m_jit.branch32(JITCompiler::NotEqual, TrustedImm32(0x7ff), resultGPR);
3987         m_jit.move(TrustedImm32(ValueFalse), resultGPR);
3988         done.append(m_jit.jump());
3989 
3990         notNanNorInfinity.link(&amp;m_jit);
3991         m_jit.roundTowardZeroDouble(tempFPR1, tempFPR2);
3992         m_jit.compareDouble(JITCompiler::DoubleEqual, tempFPR1, tempFPR2, resultGPR);
3993         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
3994         done.append(m_jit.jump());
3995 
3996         isInt32.link(&amp;m_jit);
3997         m_jit.move(TrustedImm32(ValueTrue), resultGPR);
3998         done.append(m_jit.jump());
3999 
4000         notNumber.link(&amp;m_jit);
4001         m_jit.move(TrustedImm32(ValueFalse), resultGPR);
4002 
4003         done.link(&amp;m_jit);
4004         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4005         break;
4006     }
4007 
4008     case MapHash: {
4009         switch (node-&gt;child1().useKind()) {
4010         case BooleanUse:
4011         case Int32Use:
4012         case SymbolUse:
4013         case ObjectUse: {
4014             JSValueOperand input(this, node-&gt;child1(), ManualOperandSpeculation);
4015             GPRTemporary result(this, Reuse, input);
4016             GPRTemporary temp(this);
4017 
4018             GPRReg inputGPR = input.gpr();
4019             GPRReg resultGPR = result.gpr();
4020             GPRReg tempGPR = temp.gpr();
4021 
4022             speculate(node, node-&gt;child1());
4023 
4024             m_jit.move(inputGPR, resultGPR);
4025             m_jit.wangsInt64Hash(resultGPR, tempGPR);
4026             int32Result(resultGPR, node);
4027             break;
4028         }
4029         case CellUse:
4030         case StringUse: {
4031             SpeculateCellOperand input(this, node-&gt;child1());
4032             GPRTemporary result(this);
4033             Optional&lt;GPRTemporary&gt; temp;
4034 
4035             GPRReg tempGPR = InvalidGPRReg;
4036             if (node-&gt;child1().useKind() == CellUse) {
4037                 temp.emplace(this);
4038                 tempGPR = temp-&gt;gpr();
4039             }
4040 
4041             GPRReg inputGPR = input.gpr();
4042             GPRReg resultGPR = result.gpr();
4043 
4044             MacroAssembler::JumpList slowPath;
4045             MacroAssembler::JumpList done;
4046 
4047             if (node-&gt;child1().useKind() == StringUse)
4048                 speculateString(node-&gt;child1(), inputGPR);
4049             else {
4050                 auto isString = m_jit.branchIfString(inputGPR);
4051                 m_jit.move(inputGPR, resultGPR);
4052                 m_jit.wangsInt64Hash(resultGPR, tempGPR);
4053                 done.append(m_jit.jump());
4054                 isString.link(&amp;m_jit);
4055             }
4056 
4057             m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4058             slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4059             m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4060             m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4061             slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4062             done.append(m_jit.jump());
4063 
4064             slowPath.link(&amp;m_jit);
4065             silentSpillAllRegisters(resultGPR);
4066             callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));
4067             silentFillAllRegisters();
4068             m_jit.exceptionCheck();
4069 
4070             done.link(&amp;m_jit);
4071             int32Result(resultGPR, node);
4072             break;
4073         }
4074         default:
4075             RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
4076             break;
4077         }
4078 
4079         if (node-&gt;child1().useKind() != UntypedUse)
4080             break;
4081 
4082         JSValueOperand input(this, node-&gt;child1());
4083         GPRTemporary temp(this);
4084         GPRTemporary result(this);
4085 
4086         GPRReg inputGPR = input.gpr();
4087         GPRReg resultGPR = result.gpr();
4088         GPRReg tempGPR = temp.gpr();
4089 
4090         MacroAssembler::JumpList straightHash;
4091         MacroAssembler::JumpList done;
4092         straightHash.append(m_jit.branchIfNotCell(inputGPR));
4093         MacroAssembler::JumpList slowPath;
4094         straightHash.append(m_jit.branchIfNotString(inputGPR));
4095         m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4096         slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4097         m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4098         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4099         slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4100         done.append(m_jit.jump());
4101 
4102         straightHash.link(&amp;m_jit);
4103         m_jit.move(inputGPR, resultGPR);
4104         m_jit.wangsInt64Hash(resultGPR, tempGPR);
4105         done.append(m_jit.jump());
4106 
4107         slowPath.link(&amp;m_jit);
4108         silentSpillAllRegisters(resultGPR);
4109         callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));
4110         silentFillAllRegisters();
4111         m_jit.exceptionCheck();
4112 
4113         done.link(&amp;m_jit);
4114         int32Result(resultGPR, node);
4115         break;
4116     }
4117 
4118     case NormalizeMapKey: {
4119         compileNormalizeMapKey(node);
4120         break;
4121     }
4122 
4123     case GetMapBucket: {
4124         SpeculateCellOperand map(this, node-&gt;child1());
4125         JSValueOperand key(this, node-&gt;child2(), ManualOperandSpeculation);
4126         SpeculateInt32Operand hash(this, node-&gt;child3());
4127         GPRTemporary mask(this);
4128         GPRTemporary index(this);
4129         GPRTemporary buffer(this);
4130         GPRTemporary bucket(this);
4131         GPRTemporary result(this);
4132 
4133         GPRReg hashGPR = hash.gpr();
4134         GPRReg mapGPR = map.gpr();
4135         GPRReg maskGPR = mask.gpr();
4136         GPRReg indexGPR = index.gpr();
4137         GPRReg bufferGPR = buffer.gpr();
4138         GPRReg bucketGPR = bucket.gpr();
4139         GPRReg keyGPR = key.gpr();
4140         GPRReg resultGPR = result.gpr();
4141 
4142         if (node-&gt;child1().useKind() == MapObjectUse)
4143             speculateMapObject(node-&gt;child1(), mapGPR);
4144         else if (node-&gt;child1().useKind() == SetObjectUse)
4145             speculateSetObject(node-&gt;child1(), mapGPR);
4146         else
4147             RELEASE_ASSERT_NOT_REACHED();
4148 
4149         if (node-&gt;child2().useKind() != UntypedUse)
4150             speculate(node, node-&gt;child2());
4151 
4152         m_jit.load32(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfCapacity()), maskGPR);
4153         m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfBuffer()), bufferGPR);
4154         m_jit.sub32(TrustedImm32(1), maskGPR);
4155         m_jit.move(hashGPR, indexGPR);
4156 
4157         MacroAssembler::Label loop = m_jit.label();
4158         MacroAssembler::JumpList done;
4159         MacroAssembler::JumpList slowPathCases;
4160         MacroAssembler::JumpList loopAround;
4161 
4162         m_jit.and32(maskGPR, indexGPR);
4163         m_jit.loadPtr(MacroAssembler::BaseIndex(bufferGPR, indexGPR, MacroAssembler::TimesEight), bucketGPR);
4164         m_jit.move(bucketGPR, resultGPR);
4165         auto notPresentInTable = m_jit.branchPtr(MacroAssembler::Equal,
4166             bucketGPR, TrustedImmPtr(bitwise_cast&lt;size_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::emptyValue())));
4167         loopAround.append(m_jit.branchPtr(MacroAssembler::Equal,
4168             bucketGPR, TrustedImmPtr(bitwise_cast&lt;size_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::deletedValue()))));
4169 
4170         m_jit.load64(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey()), bucketGPR);
4171 
4172         // Perform Object.is()
4173         switch (node-&gt;child2().useKind()) {
4174         case BooleanUse:
4175         case Int32Use:
4176         case SymbolUse:
4177         case ObjectUse: {
4178             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4179             // Otherwise, loop around.
4180             break;
4181         }
4182         case CellUse: {
4183             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR));
4184             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4185             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4186             loopAround.append(m_jit.branchIfNotString(keyGPR));
4187             // They&#39;re both strings.
4188             slowPathCases.append(m_jit.jump());
4189             break;
4190         }
4191         case StringUse: {
4192             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4193             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4194             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4195             slowPathCases.append(m_jit.jump());
4196             break;
4197         }
4198         case UntypedUse: {
4199             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4200             // The input key and bucket&#39;s key are already normalized. So if 64-bit compare fails and one is not a cell, they&#39;re definitely not equal.
4201             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4202             // first is a cell here.
4203             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(keyGPR)));
4204             // Both are cells here.
4205             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4206             // The first is a string here.
4207             slowPathCases.append(m_jit.branchIfString(keyGPR));
4208             // The first is a string, but the second is not, we continue to loop around.
4209             loopAround.append(m_jit.jump());
4210             break;
4211         }
4212         default:
4213             RELEASE_ASSERT_NOT_REACHED();
4214         }
4215 
4216 
4217         if (!loopAround.empty())
4218             loopAround.link(&amp;m_jit);
4219 
4220         m_jit.add32(TrustedImm32(1), indexGPR);
4221         m_jit.jump().linkTo(loop, &amp;m_jit);
4222 
4223         if (!slowPathCases.empty()) {
4224             slowPathCases.link(&amp;m_jit);
4225             silentSpillAllRegisters(indexGPR);
4226             if (node-&gt;child1().useKind() == MapObjectUse)
4227                 callOperation(operationJSMapFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);
4228             else
4229                 callOperation(operationJSSetFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);
4230             silentFillAllRegisters();
4231             m_jit.exceptionCheck();
4232             done.append(m_jit.jump());
4233         }
4234 
4235         notPresentInTable.link(&amp;m_jit);
4236         if (node-&gt;child1().useKind() == MapObjectUse)
<a name="27" id="anc27"></a><span class="line-modified">4237             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelMapBucket()), resultGPR);</span>
4238         else
<a name="28" id="anc28"></a><span class="line-modified">4239             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelSetBucket()), resultGPR);</span>
4240         done.link(&amp;m_jit);
4241         cellResult(resultGPR, node);
4242         break;
4243     }
4244 
4245     case GetMapBucketHead:
4246         compileGetMapBucketHead(node);
4247         break;
4248 
4249     case GetMapBucketNext:
4250         compileGetMapBucketNext(node);
4251         break;
4252 
4253     case LoadKeyFromMapBucket:
4254         compileLoadKeyFromMapBucket(node);
4255         break;
4256 
4257     case LoadValueFromMapBucket:
4258         compileLoadValueFromMapBucket(node);
4259         break;
4260 
4261     case ExtractValueFromWeakMapGet:
4262         compileExtractValueFromWeakMapGet(node);
4263         break;
4264 
4265     case SetAdd:
4266         compileSetAdd(node);
4267         break;
4268 
4269     case MapSet:
4270         compileMapSet(node);
4271         break;
4272 
4273     case WeakMapGet:
4274         compileWeakMapGet(node);
4275         break;
4276 
4277     case WeakSetAdd:
4278         compileWeakSetAdd(node);
4279         break;
4280 
4281     case WeakMapSet:
4282         compileWeakMapSet(node);
4283         break;
4284 
4285     case StringSlice: {
4286         compileStringSlice(node);
4287         break;
4288     }
4289 
4290     case ToLowerCase: {
4291         compileToLowerCase(node);
4292         break;
4293     }
4294 
4295     case NumberToStringWithRadix: {
4296         compileNumberToStringWithRadix(node);
4297         break;
4298     }
4299 
4300     case NumberToStringWithValidRadixConstant: {
4301         compileNumberToStringWithValidRadixConstant(node);
4302         break;
4303     }
4304 
4305     case IsObject: {
4306         compileIsObject(node);
4307         break;
4308     }
4309 
4310     case IsObjectOrNull: {
4311         compileIsObjectOrNull(node);
4312         break;
4313     }
4314 
4315     case IsFunction: {
4316         compileIsFunction(node);
4317         break;
4318     }
4319 
4320     case IsCellWithType: {
4321         compileIsCellWithType(node);
4322         break;
4323     }
4324 
4325     case IsTypedArrayView: {
4326         compileIsTypedArrayView(node);
4327         break;
4328     }
4329 
4330     case TypeOf: {
4331         compileTypeOf(node);
4332         break;
4333     }
4334 
4335     case Flush:
4336         break;
4337 
4338     case Call:
4339     case TailCall:
4340     case TailCallInlinedCaller:
4341     case Construct:
4342     case CallVarargs:
4343     case TailCallVarargs:
4344     case TailCallVarargsInlinedCaller:
4345     case CallForwardVarargs:
4346     case ConstructVarargs:
4347     case ConstructForwardVarargs:
4348     case TailCallForwardVarargs:
4349     case TailCallForwardVarargsInlinedCaller:
4350     case CallEval:
4351     case DirectCall:
4352     case DirectConstruct:
4353     case DirectTailCall:
4354     case DirectTailCallInlinedCaller:
4355         emitCall(node);
4356         break;
4357 
4358     case LoadVarargs: {
4359         compileLoadVarargs(node);
4360         break;
4361     }
4362 
4363     case ForwardVarargs: {
4364         compileForwardVarargs(node);
4365         break;
4366     }
4367 
4368     case CreateActivation: {
4369         compileCreateActivation(node);
4370         break;
4371     }
4372 
4373     case PushWithScope: {
4374         compilePushWithScope(node);
4375         break;
4376     }
4377 
4378     case CreateDirectArguments: {
4379         compileCreateDirectArguments(node);
4380         break;
4381     }
4382 
4383     case GetFromArguments: {
4384         compileGetFromArguments(node);
4385         break;
4386     }
4387 
4388     case PutToArguments: {
4389         compilePutToArguments(node);
4390         break;
4391     }
4392 
4393     case GetArgument: {
4394         compileGetArgument(node);
4395         break;
4396     }
4397 
4398     case CreateScopedArguments: {
4399         compileCreateScopedArguments(node);
4400         break;
4401     }
4402 
4403     case CreateClonedArguments: {
4404         compileCreateClonedArguments(node);
4405         break;
4406     }
4407     case CreateRest: {
4408         compileCreateRest(node);
4409         break;
4410     }
4411 
4412     case NewFunction:
4413     case NewGeneratorFunction:
4414     case NewAsyncGeneratorFunction:
4415     case NewAsyncFunction:
4416         compileNewFunction(node);
4417         break;
4418 
4419     case SetFunctionName:
4420         compileSetFunctionName(node);
4421         break;
4422 
4423     case InById:
4424         compileInById(node);
4425         break;
4426 
4427     case InByVal:
4428         compileInByVal(node);
4429         break;
4430 
4431     case HasOwnProperty: {
4432         SpeculateCellOperand object(this, node-&gt;child1());
4433         GPRTemporary uniquedStringImpl(this);
4434         GPRTemporary temp(this);
4435         GPRTemporary hash(this);
4436         GPRTemporary structureID(this);
4437         GPRTemporary result(this);
4438 
4439         Optional&lt;SpeculateCellOperand&gt; keyAsCell;
4440         Optional&lt;JSValueOperand&gt; keyAsValue;
4441         GPRReg keyGPR;
4442         if (node-&gt;child2().useKind() == UntypedUse) {
4443             keyAsValue.emplace(this, node-&gt;child2());
4444             keyGPR = keyAsValue-&gt;gpr();
4445         } else {
4446             ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == SymbolUse);
4447             keyAsCell.emplace(this, node-&gt;child2());
4448             keyGPR = keyAsCell-&gt;gpr();
4449         }
4450 
4451         GPRReg objectGPR = object.gpr();
4452         GPRReg implGPR = uniquedStringImpl.gpr();
4453         GPRReg tempGPR = temp.gpr();
4454         GPRReg hashGPR = hash.gpr();
4455         GPRReg structureIDGPR = structureID.gpr();
4456         GPRReg resultGPR = result.gpr();
4457 
4458         speculateObject(node-&gt;child1());
4459 
4460         MacroAssembler::JumpList slowPath;
4461         switch (node-&gt;child2().useKind()) {
4462         case SymbolUse: {
4463             speculateSymbol(node-&gt;child2(), keyGPR);
4464             m_jit.loadPtr(MacroAssembler::Address(keyGPR, Symbol::offsetOfSymbolImpl()), implGPR);
4465             break;
4466         }
4467         case StringUse: {
4468             speculateString(node-&gt;child2(), keyGPR);
4469             m_jit.loadPtr(MacroAssembler::Address(keyGPR, JSString::offsetOfValue()), implGPR);
4470             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
4471             slowPath.append(m_jit.branchTest32(
4472                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<a name="29" id="anc29"></a><span class="line-modified">4473                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
4474             break;
4475         }
4476         case UntypedUse: {
4477             slowPath.append(m_jit.branchIfNotCell(JSValueRegs(keyGPR)));
4478             auto isNotString = m_jit.branchIfNotString(keyGPR);
4479             m_jit.loadPtr(MacroAssembler::Address(keyGPR, JSString::offsetOfValue()), implGPR);
4480             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
4481             slowPath.append(m_jit.branchTest32(
4482                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<a name="30" id="anc30"></a><span class="line-modified">4483                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
4484             auto hasUniquedImpl = m_jit.jump();
4485 
4486             isNotString.link(&amp;m_jit);
4487             slowPath.append(m_jit.branchIfNotSymbol(keyGPR));
4488             m_jit.loadPtr(MacroAssembler::Address(keyGPR, Symbol::offsetOfSymbolImpl()), implGPR);
4489 
4490             hasUniquedImpl.link(&amp;m_jit);
4491             break;
4492         }
4493         default:
4494             RELEASE_ASSERT_NOT_REACHED();
4495         }
4496 
<a name="31" id="anc31"></a><span class="line-modified">4497         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero</span>
4498         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
4499         // ever load the result from the cache if the cache entry matches what we are querying for.
4500         // So we either get super lucky and use zero for the hash and somehow collide with the entity
4501         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
4502         // slow path anyways.
4503         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
4504         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
4505         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
4506         m_jit.add32(structureIDGPR, hashGPR);
4507         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
4508         if (hasOneBitSet(sizeof(HasOwnPropertyCache::Entry))) // is a power of 2
4509             m_jit.lshift32(TrustedImm32(getLSBSet(sizeof(HasOwnPropertyCache::Entry))), hashGPR);
4510         else
4511             m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
<a name="32" id="anc32"></a><span class="line-modified">4512         ASSERT(vm().hasOwnPropertyCache());</span>
<span class="line-modified">4513         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);</span>
4514         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
4515             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
4516         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
4517         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
4518         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
4519         auto done = m_jit.jump();
4520 
4521         slowPath.link(&amp;m_jit);
4522         silentSpillAllRegisters(resultGPR);
4523         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyGPR);
4524         silentFillAllRegisters();
4525         m_jit.exceptionCheck();
4526 
4527         done.link(&amp;m_jit);
4528         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
4529         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4530         break;
4531     }
4532 
4533     case CountExecution:
4534         m_jit.add64(TrustedImm32(1), MacroAssembler::AbsoluteAddress(node-&gt;executionCounter()-&gt;address()));
4535         break;
4536 
4537     case SuperSamplerBegin:
4538         m_jit.add32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4539         break;
4540 
4541     case SuperSamplerEnd:
4542         m_jit.sub32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4543         break;
4544 
4545     case ForceOSRExit: {
4546         terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
4547         break;
4548     }
4549 
4550     case InvalidationPoint:
4551         emitInvalidationPoint(node);
4552         break;
4553 
4554     case CheckTraps:
4555         compileCheckTraps(node);
4556         break;
4557 
4558     case Phantom:
4559     case Check:
4560     case CheckVarargs:
4561         DFG_NODE_DO_TO_CHILDREN(m_jit.graph(), node, speculate);
4562         noResult(node);
4563         break;
4564 
4565     case PhantomLocal:
4566     case LoopHint:
4567         // This is a no-op.
4568         noResult(node);
4569         break;
4570 
4571     case Unreachable:
4572         unreachable(node);
4573         break;
4574 
4575     case StoreBarrier:
4576     case FencedStoreBarrier: {
4577         compileStoreBarrier(node);
4578         break;
4579     }
4580 
4581     case GetEnumerableLength: {
4582         compileGetEnumerableLength(node);
4583         break;
4584     }
4585     case HasGenericProperty: {
4586         compileHasGenericProperty(node);
4587         break;
4588     }
4589     case HasStructureProperty: {
4590         compileHasStructureProperty(node);
4591         break;
4592     }
4593     case HasIndexedProperty: {
4594         compileHasIndexedProperty(node);
4595         break;
4596     }
4597     case GetDirectPname: {
4598         compileGetDirectPname(node);
4599         break;
4600     }
4601     case GetPropertyEnumerator: {
4602         compileGetPropertyEnumerator(node);
4603         break;
4604     }
4605     case GetEnumeratorStructurePname:
4606     case GetEnumeratorGenericPname: {
4607         compileGetEnumeratorPname(node);
4608         break;
4609     }
4610     case ToIndexString: {
4611         compileToIndexString(node);
4612         break;
4613     }
4614     case ProfileType: {
4615         compileProfileType(node);
4616         break;
4617     }
4618     case ProfileControlFlow: {
4619         BasicBlockLocation* basicBlockLocation = node-&gt;basicBlockLocation();
4620         basicBlockLocation-&gt;emitExecuteCode(m_jit);
4621         noResult(node);
4622         break;
4623     }
4624 
4625     case LogShadowChickenPrologue: {
4626         compileLogShadowChickenPrologue(node);
4627         break;
4628     }
4629 
4630     case LogShadowChickenTail: {
4631         compileLogShadowChickenTail(node);
4632         break;
4633     }
4634 
4635     case MaterializeNewObject:
4636         compileMaterializeNewObject(node);
4637         break;
4638 
4639     case CallDOM:
4640         compileCallDOM(node);
4641         break;
4642 
4643     case CallDOMGetter:
4644         compileCallDOMGetter(node);
4645         break;
4646 
4647     case CheckSubClass:
4648         compileCheckSubClass(node);
4649         break;
4650 
4651     case ExtractCatchLocal: {
4652         compileExtractCatchLocal(node);
4653         break;
4654     }
4655 
4656     case ClearCatchLocals:
4657         compileClearCatchLocals(node);
4658         break;
4659 
4660     case DataViewGetFloat:
4661     case DataViewGetInt: {
4662         SpeculateCellOperand dataView(this, node-&gt;child1());
4663         GPRReg dataViewGPR = dataView.gpr();
4664         speculateDataViewObject(node-&gt;child1(), dataViewGPR);
4665 
4666         SpeculateInt32Operand index(this, node-&gt;child2());
4667         GPRReg indexGPR = index.gpr();
4668 
4669         GPRTemporary temp1(this);
4670         GPRReg t1 = temp1.gpr();
4671         GPRTemporary temp2(this);
4672         GPRReg t2 = temp2.gpr();
4673 
4674         Optional&lt;SpeculateBooleanOperand&gt; isLittleEndianOperand;
4675         if (node-&gt;child3())
4676             isLittleEndianOperand.emplace(this, node-&gt;child3());
4677         GPRReg isLittleEndianGPR = isLittleEndianOperand ? isLittleEndianOperand-&gt;gpr() : InvalidGPRReg;
4678 
4679         DataViewData data = node-&gt;dataViewData();
4680 
4681         m_jit.zeroExtend32ToPtr(indexGPR, t2);
4682         if (data.byteSize &gt; 1)
4683             m_jit.add64(TrustedImm32(data.byteSize - 1), t2);
4684         m_jit.load32(MacroAssembler::Address(dataViewGPR, JSArrayBufferView::offsetOfLength()), t1);
4685         speculationCheck(OutOfBounds, JSValueRegs(), node,
4686             m_jit.branch64(MacroAssembler::AboveOrEqual, t2, t1));
4687 
4688         m_jit.loadPtr(JITCompiler::Address(dataViewGPR, JSArrayBufferView::offsetOfVector()), t2);
<a name="33" id="anc33"></a><span class="line-modified">4689         cageTypedArrayStorage(dataViewGPR, t2);</span>
4690 
4691         m_jit.zeroExtend32ToPtr(indexGPR, t1);
4692         auto baseIndex = JITCompiler::BaseIndex(t2, t1, MacroAssembler::TimesOne);
4693 
4694         if (node-&gt;op() == DataViewGetInt) {
4695             switch (data.byteSize) {
4696             case 1:
4697                 if (data.isSigned)
4698                     m_jit.load8SignedExtendTo32(baseIndex, t2);
4699                 else
4700                     m_jit.load8(baseIndex, t2);
4701                 int32Result(t2, node);
4702                 break;
4703             case 2: {
4704                 auto emitLittleEndianLoad = [&amp;] {
4705                     if (data.isSigned)
4706                         m_jit.load16SignedExtendTo32(baseIndex, t2);
4707                     else
4708                         m_jit.load16(baseIndex, t2);
4709                 };
4710                 auto emitBigEndianLoad = [&amp;] {
4711                     m_jit.load16(baseIndex, t2);
4712                     m_jit.byteSwap16(t2);
4713                     if (data.isSigned)
4714                         m_jit.signExtend16To32(t2, t2);
4715                 };
4716 
4717                 if (data.isLittleEndian == FalseTriState)
4718                     emitBigEndianLoad();
4719                 else if (data.isLittleEndian == TrueTriState)
4720                     emitLittleEndianLoad();
4721                 else {
4722                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4723                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4724                     emitLittleEndianLoad();
4725                     auto done = m_jit.jump();
4726                     isBigEndian.link(&amp;m_jit);
4727                     emitBigEndianLoad();
4728                     done.link(&amp;m_jit);
4729                 }
4730                 int32Result(t2, node);
4731                 break;
4732             }
4733             case 4: {
4734                 m_jit.load32(baseIndex, t2);
4735 
4736                 if (data.isLittleEndian == FalseTriState)
4737                     m_jit.byteSwap32(t2);
4738                 else if (data.isLittleEndian == MixedTriState) {
4739                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4740                     auto isLittleEndian = m_jit.branchTest32(MacroAssembler::NonZero, isLittleEndianGPR, TrustedImm32(1));
4741                     m_jit.byteSwap32(t2);
4742                     isLittleEndian.link(&amp;m_jit);
4743                 }
4744 
4745                 if (data.isSigned)
4746                     int32Result(t2, node);
4747                 else
4748                     strictInt52Result(t2, node);
4749                 break;
4750             }
4751             default:
4752                 RELEASE_ASSERT_NOT_REACHED();
4753             }
4754         } else {
4755             FPRTemporary result(this);
4756             FPRReg resultFPR = result.fpr();
4757 
4758             switch (data.byteSize) {
4759             case 4: {
4760                 auto emitLittleEndianCode = [&amp;] {
4761                     m_jit.loadFloat(baseIndex, resultFPR);
4762                     m_jit.convertFloatToDouble(resultFPR, resultFPR);
4763                 };
4764 
4765                 auto emitBigEndianCode = [&amp;] {
4766                     m_jit.load32(baseIndex, t2);
4767                     m_jit.byteSwap32(t2);
4768                     m_jit.move32ToFloat(t2, resultFPR);
4769                     m_jit.convertFloatToDouble(resultFPR, resultFPR);
4770                 };
4771 
4772                 if (data.isLittleEndian == TrueTriState)
4773                     emitLittleEndianCode();
4774                 else if (data.isLittleEndian == FalseTriState)
4775                     emitBigEndianCode();
4776                 else {
4777                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4778                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4779                     emitLittleEndianCode();
4780                     auto done = m_jit.jump();
4781                     isBigEndian.link(&amp;m_jit);
4782                     emitBigEndianCode();
4783                     done.link(&amp;m_jit);
4784                 }
4785 
4786                 break;
4787             }
4788             case 8: {
4789                 auto emitLittleEndianCode = [&amp;] {
4790                     m_jit.loadDouble(baseIndex, resultFPR);
4791                 };
4792 
4793                 auto emitBigEndianCode = [&amp;] {
4794                     m_jit.load64(baseIndex, t2);
4795                     m_jit.byteSwap64(t2);
4796                     m_jit.move64ToDouble(t2, resultFPR);
4797                 };
4798 
4799                 if (data.isLittleEndian == TrueTriState)
4800                     emitLittleEndianCode();
4801                 else if (data.isLittleEndian == FalseTriState)
4802                     emitBigEndianCode();
4803                 else {
4804                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4805                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4806                     emitLittleEndianCode();
4807                     auto done = m_jit.jump();
4808                     isBigEndian.link(&amp;m_jit);
4809                     emitBigEndianCode();
4810                     done.link(&amp;m_jit);
4811                 }
4812 
4813                 break;
4814             }
4815             default:
4816                 RELEASE_ASSERT_NOT_REACHED();
4817             }
4818 
4819             doubleResult(resultFPR, node);
4820         }
4821 
4822         break;
4823     }
4824 
4825     case DataViewSet: {
4826         SpeculateCellOperand dataView(this, m_graph.varArgChild(node, 0));
4827         GPRReg dataViewGPR = dataView.gpr();
4828         speculateDataViewObject(m_graph.varArgChild(node, 0), dataViewGPR);
4829 
4830         SpeculateInt32Operand index(this, m_graph.varArgChild(node, 1));
4831         GPRReg indexGPR = index.gpr();
4832 
4833         Optional&lt;SpeculateStrictInt52Operand&gt; int52Value;
4834         Optional&lt;SpeculateDoubleOperand&gt; doubleValue;
4835         Optional&lt;SpeculateInt32Operand&gt; int32Value;
4836         Optional&lt;FPRTemporary&gt; fprTemporary;
4837         GPRReg valueGPR = InvalidGPRReg;
4838         FPRReg valueFPR = InvalidFPRReg;
4839         FPRReg tempFPR = InvalidFPRReg;
4840 
4841         DataViewData data = node-&gt;dataViewData();
4842 
4843         Edge&amp; valueEdge = m_graph.varArgChild(node, 2);
4844         switch (valueEdge.useKind()) {
4845         case Int32Use:
4846             int32Value.emplace(this, valueEdge);
4847             valueGPR = int32Value-&gt;gpr();
4848             break;
4849         case DoubleRepUse:
4850             doubleValue.emplace(this, valueEdge);
4851             valueFPR = doubleValue-&gt;fpr();
4852             if (data.byteSize == 4) {
4853                 fprTemporary.emplace(this);
4854                 tempFPR = fprTemporary-&gt;fpr();
4855             }
4856             break;
4857         case Int52RepUse:
4858             int52Value.emplace(this, valueEdge);
4859             valueGPR = int52Value-&gt;gpr();
4860             break;
4861         default:
4862             RELEASE_ASSERT_NOT_REACHED();
4863         }
4864 
4865         GPRTemporary temp1(this);
4866         GPRReg t1 = temp1.gpr();
4867         GPRTemporary temp2(this);
4868         GPRReg t2 = temp2.gpr();
4869         GPRTemporary temp3(this);
4870         GPRReg t3 = temp3.gpr();
4871 
4872         Optional&lt;SpeculateBooleanOperand&gt; isLittleEndianOperand;
4873         if (m_graph.varArgChild(node, 3))
4874             isLittleEndianOperand.emplace(this, m_graph.varArgChild(node, 3));
4875         GPRReg isLittleEndianGPR = isLittleEndianOperand ? isLittleEndianOperand-&gt;gpr() : InvalidGPRReg;
4876 
4877         m_jit.zeroExtend32ToPtr(indexGPR, t2);
4878         if (data.byteSize &gt; 1)
4879             m_jit.add64(TrustedImm32(data.byteSize - 1), t2);
4880         m_jit.load32(MacroAssembler::Address(dataViewGPR, JSArrayBufferView::offsetOfLength()), t1);
4881         speculationCheck(OutOfBounds, JSValueRegs(), node,
4882             m_jit.branch64(MacroAssembler::AboveOrEqual, t2, t1));
4883 
4884         m_jit.loadPtr(JITCompiler::Address(dataViewGPR, JSArrayBufferView::offsetOfVector()), t2);
<a name="34" id="anc34"></a><span class="line-modified">4885         cageTypedArrayStorage(dataViewGPR, t2);</span>
4886 
4887         m_jit.zeroExtend32ToPtr(indexGPR, t1);
4888         auto baseIndex = JITCompiler::BaseIndex(t2, t1, MacroAssembler::TimesOne);
4889 
4890         if (data.isFloatingPoint) {
4891             RELEASE_ASSERT(valueFPR != InvalidFPRReg);
4892             if (data.byteSize == 4) {
4893                 RELEASE_ASSERT(tempFPR != InvalidFPRReg);
4894                 m_jit.convertDoubleToFloat(valueFPR, tempFPR);
4895 
4896                 auto emitLittleEndianCode = [&amp;] {
4897                     m_jit.storeFloat(tempFPR, baseIndex);
4898                 };
4899 
4900                 auto emitBigEndianCode = [&amp;] {
4901                     m_jit.moveFloatTo32(tempFPR, t3);
4902                     m_jit.byteSwap32(t3);
4903                     m_jit.store32(t3, baseIndex);
4904                 };
4905 
4906                 if (data.isLittleEndian == FalseTriState)
4907                     emitBigEndianCode();
4908                 else if (data.isLittleEndian == TrueTriState)
4909                     emitLittleEndianCode();
4910                 else {
4911                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4912                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4913                     emitLittleEndianCode();
4914                     auto done = m_jit.jump();
4915                     isBigEndian.link(&amp;m_jit);
4916                     emitBigEndianCode();
4917                     done.link(&amp;m_jit);
4918                 }
4919             } else {
4920                 RELEASE_ASSERT(data.byteSize == 8);
4921                 RELEASE_ASSERT(valueFPR != InvalidFPRReg);
4922 
4923                 auto emitLittleEndianCode = [&amp;] {
4924                     m_jit.storeDouble(valueFPR, baseIndex);
4925                 };
4926                 auto emitBigEndianCode = [&amp;] {
4927                     m_jit.moveDoubleTo64(valueFPR, t3);
4928                     m_jit.byteSwap64(t3);
4929                     m_jit.store64(t3, baseIndex);
4930                 };
4931 
4932                 if (data.isLittleEndian == FalseTriState)
4933                     emitBigEndianCode();
4934                 else if (data.isLittleEndian == TrueTriState)
4935                     emitLittleEndianCode();
4936                 else {
4937                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4938                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4939                     emitLittleEndianCode();
4940                     auto done = m_jit.jump();
4941                     isBigEndian.link(&amp;m_jit);
4942                     emitBigEndianCode();
4943                     done.link(&amp;m_jit);
4944                 }
4945             }
4946         } else {
4947             switch (data.byteSize) {
4948             case 1:
4949                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
4950                 RELEASE_ASSERT(valueGPR != InvalidGPRReg);
4951                 m_jit.store8(valueGPR, baseIndex);
4952                 break;
4953             case 2: {
4954                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
4955                 RELEASE_ASSERT(valueGPR != InvalidGPRReg);
4956 
4957                 auto emitLittleEndianCode = [&amp;] {
4958                     m_jit.store16(valueGPR, baseIndex);
4959                 };
4960                 auto emitBigEndianCode = [&amp;] {
4961                     m_jit.move(valueGPR, t3);
4962                     m_jit.byteSwap16(t3);
4963                     m_jit.store16(t3, baseIndex);
4964                 };
4965 
4966                 if (data.isLittleEndian == FalseTriState)
4967                     emitBigEndianCode();
4968                 else if (data.isLittleEndian == TrueTriState)
4969                     emitLittleEndianCode();
4970                 else {
4971                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4972                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4973                     emitLittleEndianCode();
4974                     auto done = m_jit.jump();
4975                     isBigEndian.link(&amp;m_jit);
4976                     emitBigEndianCode();
4977                     done.link(&amp;m_jit);
4978                 }
4979                 break;
4980             }
4981             case 4: {
4982                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use || valueEdge.useKind() == Int52RepUse);
4983 
4984                 auto emitLittleEndianCode = [&amp;] {
4985                     m_jit.store32(valueGPR, baseIndex);
4986                 };
4987 
4988                 auto emitBigEndianCode = [&amp;] {
4989                     m_jit.zeroExtend32ToPtr(valueGPR, t3);
4990                     m_jit.byteSwap32(t3);
4991                     m_jit.store32(t3, baseIndex);
4992                 };
4993 
4994                 if (data.isLittleEndian == FalseTriState)
4995                     emitBigEndianCode();
4996                 else if (data.isLittleEndian == TrueTriState)
4997                     emitLittleEndianCode();
4998                 else {
4999                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
5000                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
5001                     emitLittleEndianCode();
5002                     auto done = m_jit.jump();
5003                     isBigEndian.link(&amp;m_jit);
5004                     emitBigEndianCode();
5005                     done.link(&amp;m_jit);
5006                 }
5007 
5008                 break;
5009             }
5010             default:
5011                 RELEASE_ASSERT_NOT_REACHED();
5012             }
5013         }
5014 
5015         noResult(node);
5016         break;
5017     }
5018 
5019 #if ENABLE(FTL_JIT)
5020     case CheckTierUpInLoop: {
5021         MacroAssembler::Jump callTierUp = m_jit.branchAdd32(
5022             MacroAssembler::PositiveOrZero,
5023             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5024             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5025 
5026         MacroAssembler::Label toNextOperation = m_jit.label();
5027 
5028         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5029         silentSpillAllRegistersImpl(false, savePlans, InvalidGPRReg);
<a name="35" id="anc35"></a><span class="line-modified">5030         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5031 
5032         addSlowPathGeneratorLambda([=]() {
5033             callTierUp.link(&amp;m_jit);
5034 
5035             silentSpill(savePlans);
5036             callOperation(triggerTierUpNowInLoop, TrustedImm32(bytecodeIndex));
5037             silentFill(savePlans);
5038 
5039             m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5040         });
5041         break;
5042     }
5043 
5044     case CheckTierUpAtReturn: {
5045         MacroAssembler::Jump done = m_jit.branchAdd32(
5046             MacroAssembler::Signed,
5047             TrustedImm32(Options::ftlTierUpCounterIncrementForReturn()),
5048             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5049 
5050         silentSpillAllRegisters(InvalidGPRReg);
5051         callOperation(triggerTierUpNow);
5052         silentFillAllRegisters();
5053 
5054         done.link(&amp;m_jit);
5055         break;
5056     }
5057 
5058     case CheckTierUpAndOSREnter: {
<a name="36" id="anc36"></a><span class="line-modified">5059         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());</span>
5060 
5061         GPRTemporary temp(this);
5062         GPRReg tempGPR = temp.gpr();
5063 
<a name="37" id="anc37"></a><span class="line-modified">5064         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5065         auto triggerIterator = m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex);
5066         DFG_ASSERT(m_jit.graph(), node, triggerIterator != m_jit.jitCode()-&gt;tierUpEntryTriggers.end());
5067         JITCode::TriggerReason* forceEntryTrigger = &amp;(m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex)-&gt;value);
5068         static_assert(!static_cast&lt;uint8_t&gt;(JITCode::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
5069         static_assert(sizeof(JITCode::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
5070 
5071         MacroAssembler::Jump forceOSREntry = m_jit.branchTest8(MacroAssembler::NonZero, MacroAssembler::AbsoluteAddress(forceEntryTrigger));
5072         MacroAssembler::Jump overflowedCounter = m_jit.branchAdd32(
5073             MacroAssembler::PositiveOrZero,
5074             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5075             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5076         MacroAssembler::Label toNextOperation = m_jit.label();
5077 
5078         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5079         silentSpillAllRegistersImpl(false, savePlans, tempGPR);
5080 
5081         unsigned streamIndex = m_stream-&gt;size();
5082         m_jit.jitCode()-&gt;bytecodeIndexToStreamIndex.add(bytecodeIndex, streamIndex);
5083 
5084         addSlowPathGeneratorLambda([=]() {
5085             forceOSREntry.link(&amp;m_jit);
5086             overflowedCounter.link(&amp;m_jit);
5087 
5088             silentSpill(savePlans);
5089             callOperation(triggerOSREntryNow, tempGPR, TrustedImm32(bytecodeIndex));
5090 
5091             if (savePlans.isEmpty())
5092                 m_jit.branchTestPtr(MacroAssembler::Zero, tempGPR).linkTo(toNextOperation, &amp;m_jit);
5093             else {
5094                 MacroAssembler::Jump osrEnter = m_jit.branchTestPtr(MacroAssembler::NonZero, tempGPR);
5095                 silentFill(savePlans);
5096                 m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5097                 osrEnter.link(&amp;m_jit);
5098             }
5099             m_jit.emitRestoreCalleeSaves();
<a name="38" id="anc38"></a><span class="line-modified">5100             m_jit.farJump(tempGPR, GPRInfo::callFrameRegister);</span>
5101         });
5102         break;
5103     }
5104 
5105 #else // ENABLE(FTL_JIT)
5106     case CheckTierUpInLoop:
5107     case CheckTierUpAtReturn:
5108     case CheckTierUpAndOSREnter:
5109         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected tier-up node&quot;);
5110         break;
5111 #endif // ENABLE(FTL_JIT)
5112 
5113     case FilterCallLinkStatus:
5114     case FilterGetByIdStatus:
5115     case FilterPutByIdStatus:
5116     case FilterInByIdStatus:
5117         m_interpreter.filterICStatus(node);
5118         noResult(node);
5119         break;
5120 
5121     case LastNodeType:
5122     case EntrySwitch:
5123     case InitializeEntrypointArguments:
5124     case Phi:
5125     case Upsilon:
5126     case ExtractOSREntryLocal:
5127     case CheckInBounds:
5128     case ArithIMul:
5129     case MultiGetByOffset:
5130     case MultiPutByOffset:
5131     case FiatInt52:
5132     case CheckBadCell:
5133     case BottomValue:
5134     case PhantomNewObject:
5135     case PhantomNewFunction:
5136     case PhantomNewGeneratorFunction:
5137     case PhantomNewAsyncFunction:
5138     case PhantomNewAsyncGeneratorFunction:
5139     case PhantomCreateActivation:
5140     case PhantomNewRegexp:
5141     case GetMyArgumentByVal:
5142     case GetMyArgumentByValOutOfBounds:
5143     case GetVectorLength:
5144     case PutHint:
5145     case CheckStructureImmediate:
5146     case MaterializeCreateActivation:
5147     case PutStack:
5148     case KillStack:
5149     case GetStack:
5150     case PhantomCreateRest:
5151     case PhantomSpread:
5152     case PhantomNewArrayWithSpread:
5153     case PhantomNewArrayBuffer:
5154     case IdentityWithProfile:
5155     case CPUIntrinsic:
5156         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected node&quot;);
5157         break;
5158     }
5159 
5160     if (!m_compileOkay)
5161         return;
5162 
5163     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
5164         use(node);
5165 }
5166 
5167 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
5168 {
5169     m_jit.move(TrustedImm32(ValueTrue), gpr);
5170 }
5171 
5172 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
5173 {
5174     m_jit.move(TrustedImm32(ValueFalse), gpr);
5175 }
5176 
5177 void SpeculativeJIT::blessBoolean(GPRReg gpr)
5178 {
5179     m_jit.or32(TrustedImm32(ValueFalse), gpr);
5180 }
5181 
5182 void SpeculativeJIT::convertAnyInt(Edge valueEdge, GPRReg resultGPR)
5183 {
5184     JSValueOperand value(this, valueEdge, ManualOperandSpeculation);
5185     GPRReg valueGPR = value.gpr();
5186 
5187     JITCompiler::Jump notInt32 = m_jit.branchIfNotInt32(valueGPR);
5188 
5189     m_jit.signExtend32ToPtr(valueGPR, resultGPR);
5190     JITCompiler::Jump done = m_jit.jump();
5191 
5192     notInt32.link(&amp;m_jit);
5193     silentSpillAllRegisters(resultGPR);
5194     callOperation(operationConvertBoxedDoubleToInt52, resultGPR, valueGPR);
5195     silentFillAllRegisters();
5196 
5197     DFG_TYPE_CHECK(
5198         JSValueRegs(valueGPR), valueEdge, SpecInt32Only | SpecAnyIntAsDouble,
5199         m_jit.branch64(
5200             JITCompiler::Equal, resultGPR,
5201             JITCompiler::TrustedImm64(JSValue::notInt52)));
5202     done.link(&amp;m_jit);
5203 }
5204 
5205 void SpeculativeJIT::speculateAnyInt(Edge edge)
5206 {
5207     if (!needsTypeCheck(edge, SpecInt32Only | SpecAnyIntAsDouble))
5208         return;
5209 
5210     GPRTemporary temp(this);
5211     convertAnyInt(edge, temp.gpr());
5212 }
5213 
5214 void SpeculativeJIT::speculateInt32(Edge edge, JSValueRegs regs)
5215 {
5216     DFG_TYPE_CHECK(regs, edge, SpecInt32Only, m_jit.branchIfNotInt32(regs));
5217 }
5218 
5219 void SpeculativeJIT::speculateDoubleRepAnyInt(Edge edge)
5220 {
5221     if (!needsTypeCheck(edge, SpecAnyIntAsDouble))
5222         return;
5223 
5224     SpeculateDoubleOperand value(this, edge);
5225     FPRReg valueFPR = value.fpr();
5226 
5227     flushRegisters();
5228     GPRFlushedCallResult result(this);
5229     GPRReg resultGPR = result.gpr();
5230     callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
5231 
5232     DFG_TYPE_CHECK(
5233         JSValueRegs(), edge, SpecAnyIntAsDouble,
5234         m_jit.branch64(
5235             JITCompiler::Equal, resultGPR,
5236             JITCompiler::TrustedImm64(JSValue::notInt52)));
5237 }
5238 
5239 void SpeculativeJIT::compileArithRandom(Node* node)
5240 {
5241     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
5242     GPRTemporary temp1(this);
5243     GPRTemporary temp2(this);
5244     GPRTemporary temp3(this);
5245     FPRTemporary result(this);
5246     m_jit.emitRandomThunk(globalObject, temp1.gpr(), temp2.gpr(), temp3.gpr(), result.fpr());
5247     doubleResult(result.fpr(), node);
5248 }
5249 
5250 #endif
5251 
5252 } } // namespace JSC::DFG
5253 
5254 #endif
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>