<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_8.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;testb3.h&quot;
  28 
  29 #if ENABLE(B3_JIT)
  30 
  31 template&lt;typename T&gt;
  32 void testAtomicWeakCAS()
  33 {
  34     constexpr Type type = NativeTraits&lt;T&gt;::type;
  35     constexpr Width width = NativeTraits&lt;T&gt;::width;
  36 
  37     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
  38         if (isX86()) {
  39             checkUsesInstruction(compilation, &quot;lock&quot;);
  40             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
  41         } else {
  42             if (fenced) {
  43                 checkUsesInstruction(compilation, &quot;ldax&quot;);
  44                 checkUsesInstruction(compilation, &quot;stlx&quot;);
  45             } else {
  46                 checkUsesInstruction(compilation, &quot;ldx&quot;);
  47                 checkUsesInstruction(compilation, &quot;stx&quot;);
  48             }
  49         }
  50     };
  51 
  52     {
  53         Procedure proc;
  54         BasicBlock* root = proc.addBlock();
  55         BasicBlock* reloop = proc.addBlock();
  56         BasicBlock* done = proc.addBlock();
  57 
  58         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  59         root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
  60         root-&gt;setSuccessors(reloop);
  61 
  62         reloop-&gt;appendNew&lt;Value&gt;(
  63             proc, Branch, Origin(),
  64             reloop-&gt;appendNew&lt;AtomicValue&gt;(
  65                 proc, AtomicWeakCAS, Origin(), width,
  66                 reloop-&gt;appendIntConstant(proc, Origin(), type, 42),
  67                 reloop-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
  68                 ptr));
  69         reloop-&gt;setSuccessors(done, reloop);
  70 
  71         done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
  72 
  73         auto code = compileProc(proc);
  74         T value[2];
  75         value[0] = 42;
  76         value[1] = 13;
  77         invoke&lt;void&gt;(*code, value);
  78         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
  79         CHECK_EQ(value[1], 13);
  80         checkMyDisassembly(*code, true);
  81     }
  82 
  83     {
  84         Procedure proc;
  85         BasicBlock* root = proc.addBlock();
  86         BasicBlock* reloop = proc.addBlock();
  87         BasicBlock* done = proc.addBlock();
  88 
  89         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  90         root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
  91         root-&gt;setSuccessors(reloop);
  92 
  93         reloop-&gt;appendNew&lt;Value&gt;(
  94             proc, Branch, Origin(),
  95             reloop-&gt;appendNew&lt;AtomicValue&gt;(
  96                 proc, AtomicWeakCAS, Origin(), width,
  97                 reloop-&gt;appendIntConstant(proc, Origin(), type, 42),
  98                 reloop-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
  99                 ptr, 0, HeapRange(42), HeapRange()));
 100         reloop-&gt;setSuccessors(done, reloop);
 101 
 102         done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 103 
 104         auto code = compileProc(proc);
 105         T value[2];
 106         value[0] = 42;
 107         value[1] = 13;
 108         invoke&lt;void&gt;(*code, value);
 109         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 110         CHECK_EQ(value[1], 13);
 111         checkMyDisassembly(*code, false);
 112     }
 113 
 114     {
 115         Procedure proc;
 116         BasicBlock* root = proc.addBlock();
 117         BasicBlock* succ = proc.addBlock();
 118         BasicBlock* fail = proc.addBlock();
 119 
 120         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 121         root-&gt;appendNew&lt;Value&gt;(
 122             proc, Branch, Origin(),
 123             root-&gt;appendNew&lt;AtomicValue&gt;(
 124                 proc, AtomicWeakCAS, Origin(), width,
 125                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 126                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 127                 ptr));
 128         root-&gt;setSuccessors(succ, fail);
 129 
 130         succ-&gt;appendNew&lt;MemoryValue&gt;(
 131             proc, storeOpcode(GP, width), Origin(),
 132             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 133             ptr);
 134         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 135 
 136         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 137 
 138         auto code = compileProc(proc);
 139         T value[2];
 140         value[0] = 42;
 141         value[1] = 13;
 142         while (value[0] == 42)
 143             invoke&lt;void&gt;(*code, value);
 144         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 145         CHECK_EQ(value[1], 13);
 146         value[0] = static_cast&lt;T&gt;(300);
 147         invoke&lt;void&gt;(*code, value);
 148         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 149         CHECK_EQ(value[1], 13);
 150         checkMyDisassembly(*code, true);
 151     }
 152 
 153     {
 154         Procedure proc;
 155         BasicBlock* root = proc.addBlock();
 156         BasicBlock* succ = proc.addBlock();
 157         BasicBlock* fail = proc.addBlock();
 158 
 159         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 160         root-&gt;appendNew&lt;Value&gt;(
 161             proc, Branch, Origin(),
 162             root-&gt;appendNew&lt;Value&gt;(
 163                 proc, Equal, Origin(),
 164                 root-&gt;appendNew&lt;AtomicValue&gt;(
 165                     proc, AtomicWeakCAS, Origin(), width,
 166                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 167                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 168                     ptr),
 169                 root-&gt;appendIntConstant(proc, Origin(), Int32, 0)));
 170         root-&gt;setSuccessors(fail, succ);
 171 
 172         succ-&gt;appendNew&lt;MemoryValue&gt;(
 173             proc, storeOpcode(GP, width), Origin(),
 174             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 175             ptr);
 176         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 177 
 178         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 179 
 180         auto code = compileProc(proc);
 181         T value[2];
 182         value[0] = 42;
 183         value[1] = 13;
 184         while (value[0] == 42)
 185             invoke&lt;void&gt;(*code, value);
 186         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 187         CHECK_EQ(value[1], 13);
 188         value[0] = static_cast&lt;T&gt;(300);
 189         invoke&lt;void&gt;(*code, value);
 190         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 191         CHECK_EQ(value[1], 13);
 192         checkMyDisassembly(*code, true);
 193     }
 194 
 195     {
 196         Procedure proc;
 197         BasicBlock* root = proc.addBlock();
 198         root-&gt;appendNew&lt;Value&gt;(
 199             proc, Return, Origin(),
 200             root-&gt;appendNew&lt;AtomicValue&gt;(
 201                 proc, AtomicWeakCAS, Origin(), width,
 202                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 203                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 204                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 205 
 206         auto code = compileProc(proc);
 207         T value[2];
 208         value[0] = 42;
 209         value[1] = 13;
 210         while (!invoke&lt;bool&gt;(*code, value)) { }
 211         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 212         CHECK_EQ(value[1], 13);
 213 
 214         value[0] = static_cast&lt;T&gt;(300);
 215         CHECK(!invoke&lt;bool&gt;(*code, value));
 216         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 217         CHECK_EQ(value[1], 13);
 218         checkMyDisassembly(*code, true);
 219     }
 220 
 221     {
 222         Procedure proc;
 223         BasicBlock* root = proc.addBlock();
 224         root-&gt;appendNew&lt;Value&gt;(
 225             proc, Return, Origin(),
 226             root-&gt;appendNew&lt;Value&gt;(
 227                 proc, Equal, Origin(),
 228                 root-&gt;appendNew&lt;AtomicValue&gt;(
 229                     proc, AtomicWeakCAS, Origin(), width,
 230                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 231                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 232                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 233                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
 234 
 235         auto code = compileProc(proc);
 236         T value[2];
 237         value[0] = 42;
 238         value[1] = 13;
 239         while (invoke&lt;bool&gt;(*code, value)) { }
 240         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 241         CHECK_EQ(value[1], 13);
 242 
 243         value[0] = static_cast&lt;T&gt;(300);
 244         CHECK(invoke&lt;bool&gt;(*code, value));
 245         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 246         CHECK_EQ(value[1], 13);
 247         checkMyDisassembly(*code, true);
 248     }
 249 
 250     {
 251         Procedure proc;
 252         BasicBlock* root = proc.addBlock();
 253         root-&gt;appendNew&lt;Value&gt;(
 254             proc, Return, Origin(),
 255             root-&gt;appendNew&lt;AtomicValue&gt;(
 256                 proc, AtomicWeakCAS, Origin(), width,
 257                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 258                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 259                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 260                 42));
 261 
 262         auto code = compileProc(proc);
 263         T value[2];
 264         value[0] = 42;
 265         value[1] = 13;
 266         while (!invoke&lt;bool&gt;(*code, bitwise_cast&lt;intptr_t&gt;(value) - 42)) { }
 267         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 268         CHECK_EQ(value[1], 13);
 269 
 270         value[0] = static_cast&lt;T&gt;(300);
 271         CHECK(!invoke&lt;bool&gt;(*code, bitwise_cast&lt;intptr_t&gt;(value) - 42));
 272         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 273         CHECK_EQ(value[1], 13);
 274         checkMyDisassembly(*code, true);
 275     }
 276 }
 277 
 278 template&lt;typename T&gt;
 279 void testAtomicStrongCAS()
 280 {
 281     constexpr Type type = NativeTraits&lt;T&gt;::type;
 282     constexpr Width width = NativeTraits&lt;T&gt;::width;
 283 
 284     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
 285         if (isX86()) {
 286             checkUsesInstruction(compilation, &quot;lock&quot;);
 287             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
 288         } else {
 289             if (fenced) {
 290                 checkUsesInstruction(compilation, &quot;ldax&quot;);
 291                 checkUsesInstruction(compilation, &quot;stlx&quot;);
 292             } else {
 293                 checkUsesInstruction(compilation, &quot;ldx&quot;);
 294                 checkUsesInstruction(compilation, &quot;stx&quot;);
 295             }
 296         }
 297     };
 298 
 299     {
 300         Procedure proc;
 301         BasicBlock* root = proc.addBlock();
 302         BasicBlock* succ = proc.addBlock();
 303         BasicBlock* fail = proc.addBlock();
 304 
 305         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 306         root-&gt;appendNew&lt;Value&gt;(
 307             proc, Branch, Origin(),
 308             root-&gt;appendNew&lt;Value&gt;(
 309                 proc, Equal, Origin(),
 310                 root-&gt;appendNew&lt;AtomicValue&gt;(
 311                     proc, AtomicStrongCAS, Origin(), width,
 312                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 313                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 314                     ptr),
 315                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 316         root-&gt;setSuccessors(succ, fail);
 317 
 318         succ-&gt;appendNew&lt;MemoryValue&gt;(
 319             proc, storeOpcode(GP, width), Origin(),
 320             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 321             ptr);
 322         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 323 
 324         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 325 
 326         auto code = compileProc(proc);
 327         T value[2];
 328         value[0] = 42;
 329         value[1] = 13;
 330         invoke&lt;void&gt;(*code, value);
 331         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 332         CHECK_EQ(value[1], 13);
 333         value[0] = static_cast&lt;T&gt;(300);
 334         invoke&lt;void&gt;(*code, value);
 335         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 336         CHECK_EQ(value[1], 13);
 337         checkMyDisassembly(*code, true);
 338     }
 339 
 340     {
 341         Procedure proc;
 342         BasicBlock* root = proc.addBlock();
 343         BasicBlock* succ = proc.addBlock();
 344         BasicBlock* fail = proc.addBlock();
 345 
 346         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 347         root-&gt;appendNew&lt;Value&gt;(
 348             proc, Branch, Origin(),
 349             root-&gt;appendNew&lt;Value&gt;(
 350                 proc, Equal, Origin(),
 351                 root-&gt;appendNew&lt;AtomicValue&gt;(
 352                     proc, AtomicStrongCAS, Origin(), width,
 353                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 354                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 355                     ptr, 0, HeapRange(42), HeapRange()),
 356                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 357         root-&gt;setSuccessors(succ, fail);
 358 
 359         succ-&gt;appendNew&lt;MemoryValue&gt;(
 360             proc, storeOpcode(GP, width), Origin(),
 361             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 362             ptr);
 363         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 364 
 365         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 366 
 367         auto code = compileProc(proc);
 368         T value[2];
 369         value[0] = 42;
 370         value[1] = 13;
 371         invoke&lt;void&gt;(*code, value);
 372         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 373         CHECK_EQ(value[1], 13);
 374         value[0] = static_cast&lt;T&gt;(300);
 375         invoke&lt;void&gt;(*code, value);
 376         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 377         CHECK_EQ(value[1], 13);
 378         checkMyDisassembly(*code, false);
 379     }
 380 
 381     {
 382         Procedure proc;
 383         BasicBlock* root = proc.addBlock();
 384         BasicBlock* succ = proc.addBlock();
 385         BasicBlock* fail = proc.addBlock();
 386 
 387         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 388         root-&gt;appendNew&lt;Value&gt;(
 389             proc, Branch, Origin(),
 390             root-&gt;appendNew&lt;Value&gt;(
 391                 proc, NotEqual, Origin(),
 392                 root-&gt;appendNew&lt;AtomicValue&gt;(
 393                     proc, AtomicStrongCAS, Origin(), width,
 394                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 395                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 396                     ptr),
 397                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 398         root-&gt;setSuccessors(fail, succ);
 399 
 400         succ-&gt;appendNew&lt;MemoryValue&gt;(
 401             proc, storeOpcode(GP, width), Origin(),
 402             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 403             ptr);
 404         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 405 
 406         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 407 
 408         auto code = compileProc(proc);
 409         T value[2];
 410         value[0] = 42;
 411         value[1] = 13;
 412         invoke&lt;void&gt;(*code, value);
 413         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 414         CHECK_EQ(value[1], 13);
 415         value[0] = static_cast&lt;T&gt;(300);
 416         invoke&lt;void&gt;(*code, value);
 417         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 418         CHECK_EQ(value[1], 13);
 419         checkMyDisassembly(*code, true);
 420     }
 421 
 422     {
 423         Procedure proc;
 424         BasicBlock* root = proc.addBlock();
 425         root-&gt;appendNew&lt;Value&gt;(
 426             proc, Return, Origin(),
 427             root-&gt;appendNew&lt;AtomicValue&gt;(
 428                 proc, AtomicStrongCAS, Origin(), width,
 429                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 430                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 431                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 432 
 433         auto code = compileProc(proc);
 434         T value[2];
 435         value[0] = 42;
 436         value[1] = 13;
 437         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), 42);
 438         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 439         CHECK_EQ(value[1], 13);
 440         value[0] = static_cast&lt;T&gt;(300);
 441         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(300)));
 442         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 443         CHECK_EQ(value[1], 13);
 444         value[0] = static_cast&lt;T&gt;(-1);
 445         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(-1)));
 446         CHECK_EQ(value[0], static_cast&lt;T&gt;(-1));
 447         CHECK_EQ(value[1], 13);
 448         checkMyDisassembly(*code, true);
 449     }
 450 
 451     {
 452         // Test for https://bugs.webkit.org/show_bug.cgi?id=169867.
 453 
 454         Procedure proc;
 455         BasicBlock* root = proc.addBlock();
 456         root-&gt;appendNew&lt;Value&gt;(
 457             proc, Return, Origin(),
 458             root-&gt;appendNew&lt;Value&gt;(
 459                 proc, BitXor, Origin(),
 460                 root-&gt;appendNew&lt;AtomicValue&gt;(
 461                     proc, AtomicStrongCAS, Origin(), width,
 462                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 463                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 464                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 465                 root-&gt;appendIntConstant(proc, Origin(), type, 1)));
 466 
 467         typename NativeTraits&lt;T&gt;::CanonicalType one = 1;
 468 
 469         auto code = compileProc(proc);
 470         T value[2];
 471         value[0] = 42;
 472         value[1] = 13;
 473         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), 42 ^ one);
 474         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 475         CHECK_EQ(value[1], 13);
 476         value[0] = static_cast&lt;T&gt;(300);
 477         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(300)) ^ one);
 478         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 479         CHECK_EQ(value[1], 13);
 480         value[0] = static_cast&lt;T&gt;(-1);
 481         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(-1)) ^ one);
 482         CHECK_EQ(value[0], static_cast&lt;T&gt;(-1));
 483         CHECK_EQ(value[1], 13);
 484         checkMyDisassembly(*code, true);
 485     }
 486 
 487     {
 488         Procedure proc;
 489         BasicBlock* root = proc.addBlock();
 490         root-&gt;appendNew&lt;Value&gt;(
 491             proc, Return, Origin(),
 492             root-&gt;appendNew&lt;Value&gt;(
 493                 proc, Equal, Origin(),
 494                 root-&gt;appendNew&lt;AtomicValue&gt;(
 495                     proc, AtomicStrongCAS, Origin(), width,
 496                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 497                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 498                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 499                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 500 
 501         auto code = compileProc(proc);
 502         T value[2];
 503         value[0] = 42;
 504         value[1] = 13;
 505         CHECK(invoke&lt;bool&gt;(*code, value));
 506         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 507         CHECK_EQ(value[1], 13);
 508         value[0] = static_cast&lt;T&gt;(300);
 509         CHECK(!invoke&lt;bool&gt;(*code, value));
 510         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 511         CHECK_EQ(value[1], 13);
 512         checkMyDisassembly(*code, true);
 513     }
 514 
 515     {
 516         Procedure proc;
 517         BasicBlock* root = proc.addBlock();
 518         root-&gt;appendNew&lt;Value&gt;(
 519             proc, Return, Origin(),
 520             root-&gt;appendNew&lt;Value&gt;(
 521                 proc, Equal, Origin(),
 522                 root-&gt;appendNew&lt;Value&gt;(
 523                     proc, NotEqual, Origin(),
 524                     root-&gt;appendNew&lt;AtomicValue&gt;(
 525                         proc, AtomicStrongCAS, Origin(), width,
 526                         root-&gt;appendIntConstant(proc, Origin(), type, 42),
 527                         root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 528                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 529                     root-&gt;appendIntConstant(proc, Origin(), type, 42)),
 530                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
 531 
 532         auto code = compileProc(proc);
 533         T value[2];
 534         value[0] = 42;
 535         value[1] = 13;
 536         CHECK(invoke&lt;bool&gt;(*code, value));
 537         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 538         CHECK_EQ(value[1], 13);
 539         value[0] = static_cast&lt;T&gt;(300);
 540         CHECK(!invoke&lt;bool&gt;(*code, &amp;value));
 541         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 542         CHECK_EQ(value[1], 13);
 543         checkMyDisassembly(*code, true);
 544     }
 545 }
 546 
 547 template&lt;typename T&gt;
 548 void testAtomicXchg(B3::Opcode opcode)
 549 {
 550     constexpr Type type = NativeTraits&lt;T&gt;::type;
 551     constexpr Width width = NativeTraits&lt;T&gt;::width;
 552 
 553     auto doTheMath = [&amp;] (T&amp; memory, T operand) -&gt; T {
 554         T oldValue = memory;
 555         switch (opcode) {
 556         case AtomicXchgAdd:
 557             memory += operand;
 558             break;
 559         case AtomicXchgAnd:
 560             memory &amp;= operand;
 561             break;
 562         case AtomicXchgOr:
 563             memory |= operand;
 564             break;
 565         case AtomicXchgSub:
 566             memory -= operand;
 567             break;
 568         case AtomicXchgXor:
 569             memory ^= operand;
 570             break;
 571         case AtomicXchg:
 572             memory = operand;
 573             break;
 574         default:
 575             RELEASE_ASSERT_NOT_REACHED();
 576         }
 577         return oldValue;
 578     };
 579 
 580     auto oldValue = [&amp;] (T memory, T operand) -&gt; T {
 581         return doTheMath(memory, operand);
 582     };
 583 
 584     auto newValue = [&amp;] (T memory, T operand) -&gt; T {
 585         doTheMath(memory, operand);
 586         return memory;
 587     };
 588 
 589     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
 590         if (isX86())
 591             checkUsesInstruction(compilation, &quot;lock&quot;);
 592         else {
 593             if (fenced) {
 594                 checkUsesInstruction(compilation, &quot;ldax&quot;);
 595                 checkUsesInstruction(compilation, &quot;stlx&quot;);
 596             } else {
 597                 checkUsesInstruction(compilation, &quot;ldx&quot;);
 598                 checkUsesInstruction(compilation, &quot;stx&quot;);
 599             }
 600         }
 601     };
 602 
 603     {
 604         Procedure proc;
 605         BasicBlock* root = proc.addBlock();
 606         root-&gt;appendNew&lt;Value&gt;(
 607             proc, Return, Origin(),
 608             root-&gt;appendNew&lt;AtomicValue&gt;(
 609                 proc, opcode, Origin(), width,
 610                 root-&gt;appendIntConstant(proc, Origin(), type, 1),
 611                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 612 
 613         auto code = compileProc(proc);
 614         T value[2];
 615         value[0] = 5;
 616         value[1] = 100;
 617         CHECK_EQ(invoke&lt;T&gt;(*code, value), oldValue(5, 1));
 618         CHECK_EQ(value[0], newValue(5, 1));
 619         CHECK_EQ(value[1], 100);
 620         checkMyDisassembly(*code, true);
 621     }
 622 
 623     {
 624         Procedure proc;
 625         BasicBlock* root = proc.addBlock();
 626         root-&gt;appendNew&lt;Value&gt;(
 627             proc, Return, Origin(),
 628             root-&gt;appendNew&lt;AtomicValue&gt;(
 629                 proc, opcode, Origin(), width,
 630                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 631                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 632 
 633         auto code = compileProc(proc);
 634         T value[2];
 635         value[0] = 5;
 636         value[1] = 100;
 637         CHECK_EQ(invoke&lt;T&gt;(*code, value), oldValue(5, 42));
 638         CHECK_EQ(value[0], newValue(5, 42));
 639         CHECK_EQ(value[1], 100);
 640         checkMyDisassembly(*code, true);
 641     }
 642 
 643     {
 644         Procedure proc;
 645         BasicBlock* root = proc.addBlock();
 646         root-&gt;appendNew&lt;AtomicValue&gt;(
 647             proc, opcode, Origin(), width,
 648             root-&gt;appendIntConstant(proc, Origin(), type, 42),
 649             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 650         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 651 
 652         auto code = compileProc(proc);
 653         T value[2];
 654         value[0] = 5;
 655         value[1] = 100;
 656         invoke&lt;T&gt;(*code, value);
 657         CHECK_EQ(value[0], newValue(5, 42));
 658         CHECK_EQ(value[1], 100);
 659         checkMyDisassembly(*code, true);
 660     }
 661 
 662     {
 663         Procedure proc;
 664         BasicBlock* root = proc.addBlock();
 665         root-&gt;appendNew&lt;AtomicValue&gt;(
 666             proc, opcode, Origin(), width,
 667             root-&gt;appendIntConstant(proc, Origin(), type, 42),
 668             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 669             0, HeapRange(42), HeapRange());
 670         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 671 
 672         auto code = compileProc(proc);
 673         T value[2];
 674         value[0] = 5;
 675         value[1] = 100;
 676         invoke&lt;T&gt;(*code, value);
 677         CHECK_EQ(value[0], newValue(5, 42));
 678         CHECK_EQ(value[1], 100);
 679         checkMyDisassembly(*code, false);
 680     }
 681 }
 682 
 683 void addAtomicTests(const char* filter, Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt;&amp; tasks)
 684 {
 685     RUN(testAtomicWeakCAS&lt;int8_t&gt;());
 686     RUN(testAtomicWeakCAS&lt;int16_t&gt;());
 687     RUN(testAtomicWeakCAS&lt;int32_t&gt;());
 688     RUN(testAtomicWeakCAS&lt;int64_t&gt;());
 689     RUN(testAtomicStrongCAS&lt;int8_t&gt;());
 690     RUN(testAtomicStrongCAS&lt;int16_t&gt;());
 691     RUN(testAtomicStrongCAS&lt;int32_t&gt;());
 692     RUN(testAtomicStrongCAS&lt;int64_t&gt;());
 693     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgAdd));
 694     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgAdd));
 695     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgAdd));
 696     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgAdd));
 697     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgAnd));
 698     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgAnd));
 699     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgAnd));
 700     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgAnd));
 701     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgOr));
 702     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgOr));
 703     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgOr));
 704     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgOr));
 705     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgSub));
 706     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgSub));
 707     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgSub));
 708     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgSub));
 709     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgXor));
 710     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgXor));
 711     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgXor));
 712     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgXor));
 713     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchg));
 714     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchg));
 715     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchg));
 716     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchg));
 717 }
 718 
 719 template&lt;typename CType, typename InputType&gt;
 720 void testLoad(B3::Type type, B3::Opcode opcode, InputType value)
 721 {
 722     // Simple load from an absolute address.
 723     {
 724         Procedure proc;
 725         BasicBlock* root = proc.addBlock();
 726 
 727         root-&gt;appendNewControlValue(
 728             proc, Return, Origin(),
 729             root-&gt;appendNew&lt;MemoryValue&gt;(
 730                 proc, opcode, type, Origin(),
 731                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;value)));
 732 
 733         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc), modelLoad&lt;CType&gt;(value)));
 734     }
 735 
 736     // Simple load from an address in a register.
 737     {
 738         Procedure proc;
 739         BasicBlock* root = proc.addBlock();
 740 
 741         root-&gt;appendNewControlValue(
 742             proc, Return, Origin(),
 743             root-&gt;appendNew&lt;MemoryValue&gt;(
 744                 proc, opcode, type, Origin(),
 745                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 746 
 747         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value), modelLoad&lt;CType&gt;(value)));
 748     }
 749 
 750     // Simple load from an address in a register, at an offset.
 751     {
 752         Procedure proc;
 753         BasicBlock* root = proc.addBlock();
 754 
 755         root-&gt;appendNewControlValue(
 756             proc, Return, Origin(),
 757             root-&gt;appendNew&lt;MemoryValue&gt;(
 758                 proc, opcode, type, Origin(),
 759                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 760                 static_cast&lt;int32_t&gt;(sizeof(InputType))));
 761 
 762         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 1), modelLoad&lt;CType&gt;(value)));
 763     }
 764 
 765     // Load from a simple base-index with various scales.
 766     for (unsigned logScale = 0; logScale &lt;= 3; ++logScale) {
 767         Procedure proc;
 768         BasicBlock* root = proc.addBlock();
 769 
 770         root-&gt;appendNewControlValue(
 771             proc, Return, Origin(),
 772             root-&gt;appendNew&lt;MemoryValue&gt;(
 773                 proc, opcode, type, Origin(),
 774                 root-&gt;appendNew&lt;Value&gt;(
 775                     proc, Add, Origin(),
 776                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 777                     root-&gt;appendNew&lt;Value&gt;(
 778                         proc, Shl, Origin(),
 779                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 780                         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), logScale)))));
 781 
 782         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 2, (sizeof(InputType) * 2) &gt;&gt; logScale), modelLoad&lt;CType&gt;(value)));
 783     }
 784 
 785     // Load from a simple base-index with various scales, but commuted.
 786     for (unsigned logScale = 0; logScale &lt;= 3; ++logScale) {
 787         Procedure proc;
 788         BasicBlock* root = proc.addBlock();
 789 
 790         root-&gt;appendNewControlValue(
 791             proc, Return, Origin(),
 792             root-&gt;appendNew&lt;MemoryValue&gt;(
 793                 proc, opcode, type, Origin(),
 794                 root-&gt;appendNew&lt;Value&gt;(
 795                     proc, Add, Origin(),
 796                     root-&gt;appendNew&lt;Value&gt;(
 797                         proc, Shl, Origin(),
 798                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 799                         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), logScale)),
 800                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 801 
 802         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 2, (sizeof(InputType) * 2) &gt;&gt; logScale), modelLoad&lt;CType&gt;(value)));
 803     }
 804 }
 805 
 806 template&lt;typename T&gt;
 807 void testLoad(B3::Opcode opcode, int32_t value)
 808 {
 809     return testLoad&lt;T&gt;(B3::Int32, opcode, value);
 810 }
 811 
 812 template&lt;typename T&gt;
 813 void testLoad(B3::Type type, T value)
 814 {
 815     return testLoad&lt;T&gt;(type, Load, value);
 816 }
 817 
 818 void addLoadTests(const char* filter, Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt;&amp; tasks)
 819 {
 820     RUN(testLoad(Int32, 60));
 821     RUN(testLoad(Int32, -60));
 822     RUN(testLoad(Int32, 1000));
 823     RUN(testLoad(Int32, -1000));
 824     RUN(testLoad(Int32, 1000000));
 825     RUN(testLoad(Int32, -1000000));
 826     RUN(testLoad(Int32, 1000000000));
 827     RUN(testLoad(Int32, -1000000000));
 828     RUN_BINARY(testLoad, { MAKE_OPERAND(Int64) }, int64Operands());
 829     RUN_BINARY(testLoad, { MAKE_OPERAND(Float) }, floatingPointOperands&lt;float&gt;());
 830     RUN_BINARY(testLoad, { MAKE_OPERAND(Double) }, floatingPointOperands&lt;double&gt;());
 831 
 832     RUN(testLoad&lt;int8_t&gt;(Load8S, 60));
 833     RUN(testLoad&lt;int8_t&gt;(Load8S, -60));
 834     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000));
 835     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000));
 836     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000000));
 837     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000000));
 838     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000000000));
 839     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000000000));
 840 
 841     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 60));
 842     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -60));
 843     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000));
 844     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000));
 845     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000000));
 846     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000000));
 847     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000000000));
 848     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000000000));
 849 
 850     RUN(testLoad&lt;int16_t&gt;(Load16S, 60));
 851     RUN(testLoad&lt;int16_t&gt;(Load16S, -60));
 852     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000));
 853     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000));
 854     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000000));
 855     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000));
 856     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000000000));
 857     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000000));
 858 
 859     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 60));
 860     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -60));
 861     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000));
 862     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000));
 863     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000));
 864     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000));
 865     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000000));
 866     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000000));
 867 }
 868 
 869 void testFastForwardCopy32()
 870 {
 871 #if CPU(X86_64)
 872     for (const bool aligned : { true, false }) {
 873         for (const bool overlap : { false, true }) {
 874             for (size_t arrsize : { 1, 4, 5, 6, 8, 10, 12, 16, 20, 40, 100, 1000}) {
 875                 size_t overlapAmount = 5;
 876 
 877                 uint32_t* arr1, *arr2;
 878 
 879                 if (overlap) {
 880                     arr1 = new uint32_t[arrsize * 2];
 881                     arr2 = arr1 + (arrsize - overlapAmount);
 882                 } else {
 883                     arr1 = new uint32_t[arrsize];
 884                     arr2 = new uint32_t[arrsize];
 885                 }
 886 
 887                 if (!aligned &amp;&amp; arrsize &lt; 3)
 888                     continue;
 889                 if (overlap &amp;&amp; arrsize &lt;= overlapAmount + 3)
 890                     continue;
 891 
 892                 if (!aligned) {
 893                     ++arr1;
 894                     ++arr2;
 895                     arrsize -= 1;
 896                     overlapAmount -= 1;
 897                 }
 898 
 899                 for (size_t i = 0; i &lt; arrsize; ++i)
 900                     arr1[i] = i;
 901 
 902                 fastForwardCopy32(arr2, arr1, arrsize);
 903 
 904                 if (overlap) {
 905                     for (size_t i = 0; i &lt; arrsize - overlapAmount; ++i)
 906                         CHECK(arr2[i] == i);
 907                     for (size_t i = arrsize - overlapAmount; i &lt; arrsize; ++i)
 908                         CHECK(arr2[i] == i - (arrsize - overlapAmount));
 909                 } else {
 910                     for (size_t i = 0; i &lt; arrsize; ++i)
 911                         CHECK(arr2[i] == i);
 912                 }
 913 
 914                 if (!aligned) {
 915                     --arr1;
 916                     --arr2;
 917                 }
 918 
 919                 if (!overlap) {
 920                     delete[] arr1;
 921                     delete[] arr2;
 922                 } else
 923                     delete[] arr1;
 924             }
 925         }
 926     }
 927 #endif
 928 }
 929 
 930 void testByteCopyLoop()
 931 {
 932     Procedure proc;
 933     BasicBlock* root = proc.addBlock();
 934     BasicBlock* head = proc.addBlock();
 935     BasicBlock* update = proc.addBlock();
 936     BasicBlock* continuation = proc.addBlock();
 937 
 938     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 939     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 940     auto* arraySize = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 941     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
 942     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
 943     UpsilonValue* startingIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 944     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
 945     root-&gt;setSuccessors(FrequentedBlock(head));
 946 
 947     auto* index = head-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 948     startingIndex-&gt;setPhi(index);
 949     auto* loadIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arraySrc,
 950         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
 951     auto* storeIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arrayDst,
 952         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
 953     head-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), head-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), loadIndex), storeIndex);
 954     auto* newIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
 955     auto* cmpValue = head-&gt;appendNew&lt;Value&gt;(proc, GreaterThan, Origin(), newIndex, arraySize);
 956     head-&gt;appendNew&lt;Value&gt;(proc, Branch, Origin(), cmpValue);
 957     head-&gt;setSuccessors(FrequentedBlock(continuation), FrequentedBlock(update));
 958 
 959     UpsilonValue* updateIndex = update-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newIndex);
 960     updateIndex-&gt;setPhi(index);
 961     update-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
 962     update-&gt;setSuccessors(FrequentedBlock(head));
 963 
 964     continuation-&gt;appendNewControlValue(proc, Return, Origin());
 965 
 966     int* arr1 = new int[3];
 967     int* arr2 = new int[3];
 968 
 969     arr1[0] = 0;
 970     arr1[1] = 0;
 971     arr1[2] = 0;
 972     arr2[0] = 1;
 973     arr2[1] = 2;
 974     arr2[2] = 3;
 975 
 976     compileAndRun&lt;void&gt;(proc, arr2, arr1, 3);
 977 
 978     CHECK_EQ(arr1[0], 1);
 979     CHECK_EQ(arr1[1], 2);
 980     CHECK_EQ(arr1[2], 3);
 981 
 982     delete[] arr1;
 983     delete [] arr2;
 984 }
 985 
 986 void testByteCopyLoopStartIsLoopDependent()
 987 {
 988     Procedure proc;
 989     BasicBlock* root = proc.addBlock();
 990     BasicBlock* head = proc.addBlock();
 991     BasicBlock* update = proc.addBlock();
 992     BasicBlock* continuation = proc.addBlock();
 993 
 994     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 995     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 996     auto* arraySize = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 997     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
 998     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
 999     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1000     root-&gt;setSuccessors(FrequentedBlock(head));
1001 
1002     UpsilonValue* startingIndex = head-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), head-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
1003     auto* index = head-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
1004     startingIndex-&gt;setPhi(index);
1005     auto* loadIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arraySrc,
1006         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1007     auto* storeIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arrayDst,
1008         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1009     head-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), head-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), loadIndex), storeIndex);
1010     auto* newIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
1011     auto* cmpValue = head-&gt;appendNew&lt;Value&gt;(proc, GreaterThan, Origin(), newIndex, arraySize);
1012     head-&gt;appendNew&lt;Value&gt;(proc, Branch, Origin(), cmpValue);
1013     head-&gt;setSuccessors(FrequentedBlock(continuation), FrequentedBlock(update));
1014 
1015     UpsilonValue* updateIndex = update-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newIndex);
1016     updateIndex-&gt;setPhi(index);
1017     update-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1018     update-&gt;setSuccessors(FrequentedBlock(head));
1019 
1020     continuation-&gt;appendNewControlValue(proc, Return, Origin());
1021 
1022     int* arr1 = new int[3];
1023     int* arr2 = new int[3];
1024 
1025     arr1[0] = 0;
1026     arr1[1] = 0;
1027     arr1[2] = 0;
1028     arr2[0] = 1;
1029     arr2[1] = 2;
1030     arr2[2] = 3;
1031 
1032     compileAndRun&lt;void&gt;(proc, arr2, arr1, 0);
1033 
1034     CHECK_EQ(arr1[0], 1);
1035     CHECK_EQ(arr1[1], 0);
1036     CHECK_EQ(arr1[2], 0);
1037 
1038     delete[] arr1;
1039     delete [] arr2;
1040 }
1041 
1042 void testByteCopyLoopBoundIsLoopDependent()
1043 {
1044     Procedure proc;
1045     BasicBlock* root = proc.addBlock();
1046     BasicBlock* head = proc.addBlock();
1047     BasicBlock* update = proc.addBlock();
1048     BasicBlock* continuation = proc.addBlock();
1049 
1050     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1051     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
1052     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
1053     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
1054     UpsilonValue* startingIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
1055     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1056     root-&gt;setSuccessors(FrequentedBlock(head));
1057 
1058     auto* index = head-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
1059     startingIndex-&gt;setPhi(index);
1060     auto* loadIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arraySrc,
1061         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1062     auto* storeIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arrayDst,
1063         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1064     head-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), head-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), loadIndex), storeIndex);
1065     auto* newIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
1066     auto* cmpValue = head-&gt;appendNew&lt;Value&gt;(proc, GreaterThan, Origin(), newIndex, index);
1067     head-&gt;appendNew&lt;Value&gt;(proc, Branch, Origin(), cmpValue);
1068     head-&gt;setSuccessors(FrequentedBlock(continuation), FrequentedBlock(update));
1069 
1070     UpsilonValue* updateIndex = update-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newIndex);
1071     updateIndex-&gt;setPhi(index);
1072     update-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1073     update-&gt;setSuccessors(FrequentedBlock(head));
1074 
1075     continuation-&gt;appendNewControlValue(proc, Return, Origin());
1076 
1077     int* arr1 = new int[3];
1078     int* arr2 = new int[3];
1079 
1080     arr1[0] = 0;
1081     arr1[1] = 0;
1082     arr1[2] = 0;
1083     arr2[0] = 1;
1084     arr2[1] = 2;
1085     arr2[2] = 3;
1086 
1087     compileAndRun&lt;void&gt;(proc, arr2, arr1, 3);
1088 
1089     CHECK_EQ(arr1[0], 1);
1090     CHECK_EQ(arr1[1], 0);
1091     CHECK_EQ(arr1[2], 0);
1092 
1093     delete[] arr1;
1094     delete [] arr2;
1095 }
1096 
1097 void addCopyTests(const char* filter, Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt;&amp; tasks)
1098 {
1099     RUN(testFastForwardCopy32());
1100     RUN(testByteCopyLoop());
1101     RUN(testByteCopyLoopStartIsLoopDependent());
1102     RUN(testByteCopyLoopBoundIsLoopDependent());
1103 }
1104 
1105 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>