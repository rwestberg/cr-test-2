<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyRangeData.h&quot;
  38 #include &quot;IDBResultData.h&quot;
  39 #include &quot;IDBServer.h&quot;
  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;Logging.h&quot;
  43 #include &quot;SerializedScriptValue.h&quot;
  44 #include &quot;StorageQuotaManager.h&quot;
  45 #include &quot;UniqueIDBDatabaseConnection.h&quot;
  46 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
  47 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  48 #include &lt;JavaScriptCore/StrongInlines.h&gt;
  49 #include &lt;wtf/MainThread.h&gt;
  50 #include &lt;wtf/NeverDestroyed.h&gt;
  51 #include &lt;wtf/Scope.h&gt;
  52 
  53 namespace WebCore {
  54 using namespace JSC;
  55 namespace IDBServer {
  56 
  57 static const uint64_t defaultWriteOperationCost = 4;
  58 
  59 static inline uint64_t estimateSize(const IDBKeyData&amp; keyData)
  60 {
  61     uint64_t size = 4;
  62     switch (keyData.type()) {
  63     case IndexedDB::KeyType::String:
  64         size += keyData.string().sizeInBytes();
  65         break;
  66     case IndexedDB::KeyType::Binary: {
  67         size += keyData.binary().size();
  68         break;
  69     }
  70     case IndexedDB::KeyType::Array:
  71         for (auto&amp; data : keyData.array())
  72             size += estimateSize(data);
  73         break;
  74     default:
  75         break;
  76     }
  77     return size;
  78 }
  79 
  80 static inline uint64_t estimateSize(const IDBValue&amp; value)
  81 {
  82     uint64_t size = 4;
  83     size += value.data().size();
  84     for (auto&amp; url : value.blobURLs())
  85         size += url.sizeInBytes();
  86     for (auto&amp; path : value.blobFilePaths())
  87         size += path.sizeInBytes();
  88     return size;
  89 }
  90 
  91 static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)
  92 {
  93     uint64_t size = 4;
  94     size += info.name().sizeInBytes();
  95     return size;
  96 }
  97 
  98 static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)
  99 {
 100     uint64_t size = 4;
 101     size += info.name().sizeInBytes();
 102     // FIXME: estimate keyPath.
 103     for (auto&amp; indexInfo : info.indexMap().values())
 104         size += estimateSize(indexInfo);
 105     return size;
 106 }
 107 
 108 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
 109     : m_server(server)
 110     , m_identifier(identifier)
 111     , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)
 112 {
 113     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
 114 }
 115 
 116 UniqueIDBDatabase::~UniqueIDBDatabase()
 117 {
 118     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
 119     ASSERT(isMainThread());
 120     ASSERT(!hasAnyPendingCallbacks());
 121     ASSERT(!hasUnfinishedTransactions());
 122     ASSERT(m_pendingTransactions.isEmpty());
 123     ASSERT(m_openDatabaseConnections.isEmpty());
 124     ASSERT(m_clientClosePendingDatabaseConnections.isEmpty());
 125     ASSERT(m_serverClosePendingDatabaseConnections.isEmpty());
 126 
 127     RELEASE_ASSERT(m_databaseQueue.isKilled());
 128     RELEASE_ASSERT(m_databaseReplyQueue.isKilled());
 129     RELEASE_ASSERT(!m_backingStore);
 130 }
 131 
 132 const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
 133 {
 134     RELEASE_ASSERT(m_databaseInfo);
 135     return *m_databaseInfo;
 136 }
 137 
 138 void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 139 {
 140     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
 141     ASSERT(!m_hardClosedForUserDelete);
 142     ASSERT(isMainThread());
 143 
 144     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 145 
 146     // An open operation is already in progress, so we can&#39;t possibly handle this one yet.
 147     if (m_isOpeningBackingStore)
 148         return;
 149 
 150     handleDatabaseOperations();
 151 }
 152 
 153 bool UniqueIDBDatabase::hasAnyPendingCallbacks() const
 154 {
 155     return !m_errorCallbacks.isEmpty()
 156         || !m_keyDataCallbacks.isEmpty()
 157         || !m_getResultCallbacks.isEmpty()
 158         || !m_getAllResultsCallbacks.isEmpty()
 159         || !m_countCallbacks.isEmpty();
 160 }
 161 
 162 bool UniqueIDBDatabase::isVersionChangeInProgress()
 163 {
 164 #if !LOG_DISABLED
 165     if (m_versionChangeTransaction)
 166         ASSERT(m_versionChangeDatabaseConnection);
 167 #endif
 168 
 169     return m_versionChangeDatabaseConnection;
 170 }
 171 
 172 static inline String quotaErrorMessageName(const char* taskName)
 173 {
 174     return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);
 175 }
 176 
 177 void UniqueIDBDatabase::requestSpace(uint64_t taskSize, const char* taskName, CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)
 178 {
 179     m_server-&gt;requestSpace(m_identifier.origin(), taskSize, [weakThis = makeWeakPtr(this), this, taskName, callback = WTFMove(callback)](auto decision) mutable {
 180         if (!weakThis) {
 181             callback(IDBError { UnknownError });
 182             return;
 183         }
 184 
 185         if (m_owningPointerForClose) {
 186             // We are closing the database, there is no point in trying to modify the database at that point.
 187             callback(IDBError { UnknownError });
 188             return;
 189         }
 190 
 191         switch (decision) {
 192         case StorageQuotaManager::Decision::Deny:
 193             callback(IDBError { QuotaExceededError, quotaErrorMessageName(taskName) });
 194             return;
 195         case StorageQuotaManager::Decision::Grant:
 196             callback({ });
 197         };
 198     });
 199 }
 200 
 201 void UniqueIDBDatabase::waitForRequestSpaceCompletion(CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)
 202 {
 203     requestSpace(0, &quot;&quot;, WTFMove(callback));
 204 }
 205 
 206 void UniqueIDBDatabase::performCurrentOpenOperation()
 207 {
 208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);
 209 
 210     ASSERT(m_currentOpenDBRequest);
 211     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 212 
 213     if (!m_databaseInfo) {
 214         if (!m_isOpeningBackingStore) {
 215             m_isOpeningBackingStore = true;
 216             // We do not know whether this is an existing or a new database.
 217             // We set a small cost so that it is not possible to open an infinite number of database.
 218             m_server-&gt;requestSpace(m_identifier.origin(), defaultWriteOperationCost, [this, weakThis = makeWeakPtr(this)](auto decision) mutable {
 219                 if (!weakThis)
 220                     return;
 221 
 222                 if (m_owningPointerForClose)
 223                     return;
 224 
 225                 switch (decision) {
 226                 case StorageQuotaManager::Decision::Deny: {
 227                     auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError { QuotaExceededError, quotaErrorMessageName(&quot;openDatabase&quot;) });
 228                     m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 229                     m_currentOpenDBRequest = nullptr;
 230                     m_isOpeningBackingStore = false;
 231                     break;
 232                 }
 233                 case StorageQuotaManager::Decision::Grant:
 234                     this-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));
 235                 };
 236             });
 237         }
 238         return;
 239     }
 240 
 241     // If we previously started a version change operation but were blocked by having open connections,
 242     // we might now be unblocked.
 243     if (m_versionChangeDatabaseConnection) {
 244         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 245             startVersionChangeTransaction();
 246         return;
 247     }
 248 
 249     // 3.3.1 Opening a database
 250     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 251     // or the current version of db otherwise.
 252     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 253     if (!requestedVersion)
 254         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 255 
 256     // 3.3.1 Opening a database
 257     // If the database version higher than the requested version, abort these steps and return a VersionError.
 258     if (requestedVersion &lt; m_databaseInfo-&gt;version()) {
 259         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError(VersionError));
 260         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 261         m_currentOpenDBRequest = nullptr;
 262 
 263         return;
 264     }
 265 
 266     if (!m_backingStoreOpenError.isNull()) {
 267         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), m_backingStoreOpenError);
 268         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 269         m_currentOpenDBRequest = nullptr;
 270 
 271         return;
 272     }
 273 
 274     Ref&lt;UniqueIDBDatabaseConnection&gt; connection = UniqueIDBDatabaseConnection::create(*this, *m_currentOpenDBRequest);
 275 
 276     if (requestedVersion == m_databaseInfo-&gt;version()) {
 277         auto* rawConnection = &amp;connection.get();
 278         addOpenDatabaseConnection(WTFMove(connection));
 279 
 280         auto result = IDBResultData::openDatabaseSuccess(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), *rawConnection);
 281         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 282         m_currentOpenDBRequest = nullptr;
 283 
 284         return;
 285     }
 286 
 287     ASSERT(!m_versionChangeDatabaseConnection);
 288     m_versionChangeDatabaseConnection = WTFMove(connection);
 289 
 290     // 3.3.7 &quot;versionchange&quot; transaction steps
 291     // If there&#39;s no other open connections to this database, the version change process can begin immediately.
 292     if (!hasAnyOpenConnections()) {
 293         startVersionChangeTransaction();
 294         return;
 295     }
 296 
 297     // Otherwise we have to notify all those open connections and wait for them to close.
 298     maybeNotifyConnectionsOfVersionChange();
 299 }
 300 
 301 void UniqueIDBDatabase::performCurrentDeleteOperation()
 302 {
 303     ASSERT(isMainThread());
 304     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.debugString().utf8().data());
 305 
 306     ASSERT(m_currentOpenDBRequest);
 307     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
 308 
 309     if (m_deleteBackingStoreInProgress)
 310         return;
 311 
 312     if (hasAnyOpenConnections()) {
 313         maybeNotifyConnectionsOfVersionChange();
 314         return;
 315     }
 316 
 317     if (hasUnfinishedTransactions())
 318         return;
 319 
 320     ASSERT(!hasAnyPendingCallbacks());
 321     ASSERT(m_pendingTransactions.isEmpty());
 322     ASSERT(m_openDatabaseConnections.isEmpty());
 323 
 324     // It&#39;s possible to have multiple delete requests queued up in a row.
 325     // In that scenario only the first request will actually have to delete the database.
 326     // Subsequent requests can immediately notify their completion.
 327 
 328     if (!m_deleteBackingStoreInProgress) {
 329         if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)
 330             didDeleteBackingStore(0);
 331         else {
 332             m_deleteBackingStoreInProgress = true;
 333             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::deleteBackingStore, m_identifier));
 334         }
 335     }
 336 }
 337 
 338 void UniqueIDBDatabase::deleteBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 339 {
 340     ASSERT(!isMainThread());
 341     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::deleteBackingStore&quot;);
 342 
 343     uint64_t deletedVersion = 0;
 344 
 345     if (m_backingStore) {
 346         m_backingStore-&gt;deleteBackingStore();
 347         m_newDatabaseSize = m_backingStore-&gt;databaseSize();
 348 
 349         m_backingStore = nullptr;
 350         m_backingStoreSupportsSimultaneousTransactions = false;
 351         m_backingStoreIsEphemeral = false;
 352     } else {
 353         auto backingStore = m_server-&gt;createBackingStore(identifier);
 354         m_currentDatabaseSize = backingStore-&gt;databaseSize();
 355 
 356         IDBDatabaseInfo databaseInfo;
 357         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 358         if (!error.isNull())
 359             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());
 360 
 361         deletedVersion = databaseInfo.version();
 362         backingStore-&gt;deleteBackingStore();
 363         m_newDatabaseSize = backingStore-&gt;databaseSize();
 364     }
 365 
 366     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));
 367 }
 368 
 369 void UniqueIDBDatabase::performUnconditionalDeleteBackingStore()
 370 {
 371     ASSERT(!isMainThread());
 372     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performUnconditionalDeleteBackingStore&quot;);
 373 
 374     if (m_backingStore)
 375         m_backingStore-&gt;deleteBackingStore();
 376 
 377     shutdownForClose();
 378 }
 379 
 380 void UniqueIDBDatabase::scheduleShutdownForClose()
 381 {
 382     ASSERT(isMainThread());
 383 
 384     m_operationAndTransactionTimer.stop();
 385 
 386     RELEASE_ASSERT(!m_owningPointerForClose);
 387     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);
 388 
 389     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 390 }
 391 
 392 void UniqueIDBDatabase::shutdownForClose()
 393 {
 394     ASSERT(!isMainThread());
 395     ASSERT(m_owningPointerForClose.get() == this);
 396 
 397     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);
 398 
 399     if (m_backingStore) {
 400         m_backingStore-&gt;close();
 401         m_newDatabaseSize = m_backingStore-&gt;databaseSize();
 402     }
 403 
 404     m_backingStore = nullptr;
 405     m_backingStoreSupportsSimultaneousTransactions = false;
 406     m_backingStoreIsEphemeral = false;
 407 
 408     if (!m_databaseQueue.isEmpty()) {
 409         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 410         return;
 411     }
 412     m_databaseQueue.kill();
 413 
 414     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didShutdownForClose));
 415 }
 416 
 417 void UniqueIDBDatabase::didShutdownForClose()
 418 {
 419     ASSERT(m_databaseReplyQueue.isEmpty());
 420     m_databaseReplyQueue.kill();
 421 
 422     updateSpaceUsedIfNeeded();
 423 }
 424 
 425 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 426 {
 427     ASSERT(isMainThread());
 428     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didDeleteBackingStore&quot;);
 429 
 430     ASSERT(!hasAnyPendingCallbacks());
 431     ASSERT(!hasUnfinishedTransactions());
 432     ASSERT(m_pendingTransactions.isEmpty());
 433     ASSERT(m_openDatabaseConnections.isEmpty());
 434     ASSERT(!m_backingStore);
 435 
 436     // It&#39;s possible that the openDBRequest was cancelled from client-side after the delete was already dispatched to the backingstore.
 437     // So it&#39;s okay if we don&#39;t have a currentOpenDBRequest, but if we do it has to be a deleteRequest.
 438     ASSERT(!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;isDeleteRequest());
 439 
 440     if (m_databaseInfo)
 441         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 442 
 443     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 444     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 445     // passed in deletedVersion argument.
 446     if (!m_mostRecentDeletedDatabaseInfo)
 447         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);
 448 
 449     if (m_currentOpenDBRequest) {
 450         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 451         m_currentOpenDBRequest = nullptr;
 452     }
 453 
 454     updateSpaceUsedIfNeeded();
 455 
 456     m_deleteBackingStoreInProgress = false;
 457 
 458     if (m_hardClosedForUserDelete)
 459         return;
 460 
 461     invokeOperationAndTransactionTimer();
 462 }
 463 
 464 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 465 {
 466     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 467         m_pendingOpenDBRequests.removeFirst();
 468 }
 469 
 470 void UniqueIDBDatabase::handleDatabaseOperations()
 471 {
 472     ASSERT(isMainThread());
 473     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());
 474     ASSERT(!m_hardClosedForUserDelete);
 475 
 476     if (m_deleteBackingStoreInProgress || m_isOpeningBackingStore)
 477         return;
 478 
 479     clearStalePendingOpenDBRequests();
 480 
 481     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {
 482         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
 483         if (!m_currentOpenDBRequest &amp;&amp; !m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())
 484             m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 485 
 486         // Some operations (such as the first open operation after a delete) require multiple passes to completely handle
 487         if (m_currentOpenDBRequest)
 488             handleCurrentOperation();
 489 
 490         return;
 491     }
 492 
 493     if (m_pendingOpenDBRequests.isEmpty()) {
 494         m_currentOpenDBRequest = nullptr;
 495         return;
 496     }
 497 
 498     m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 499     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - Popped an operation, now there are %u pending&quot;, m_pendingOpenDBRequests.size());
 500 
 501     handleCurrentOperation();
 502 }
 503 
 504 void UniqueIDBDatabase::handleCurrentOperation()
 505 {
 506     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleCurrentOperation&quot;);
 507     ASSERT(!m_hardClosedForUserDelete);
 508     ASSERT(m_currentOpenDBRequest);
 509 
 510     if (m_currentOpenDBRequest-&gt;isOpenRequest())
 511         performCurrentOpenOperation();
 512     else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
 513         performCurrentDeleteOperation();
 514     else
 515         ASSERT_NOT_REACHED();
 516 
 517     if (!m_currentOpenDBRequest)
 518         invokeOperationAndTransactionTimer();
 519 }
 520 
 521 bool UniqueIDBDatabase::hasAnyOpenConnections() const
 522 {
 523     return !m_openDatabaseConnections.isEmpty();
 524 }
 525 
 526 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 527 {
 528     for (auto&amp; connection : m_openDatabaseConnections) {
 529         if (!connection-&gt;connectionIsClosing())
 530             return false;
 531     }
 532 
 533     return true;
 534 }
 535 
 536 static uint64_t generateUniqueCallbackIdentifier()
 537 {
 538     ASSERT(isMainThread());
 539     static uint64_t currentID = 0;
 540     return ++currentID;
 541 }
 542 
 543 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback, uint64_t taskSize)
 544 {
 545     if (m_hardClosedForUserDelete) {
 546         callback(IDBError::userDeleteError());
 547         return 0;
 548     }
 549 
 550     uint64_t identifier = generateUniqueCallbackIdentifier();
 551     ASSERT(!m_errorCallbacks.contains(identifier));
 552     m_errorCallbacks.add(identifier, WTFMove(callback));
 553 
 554     if (taskSize) {
 555         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);
 556         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);
 557     }
 558 
 559     m_callbackQueue.append(identifier);
 560     return identifier;
 561 }
 562 
 563 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback, uint64_t taskSize)
 564 {
 565     if (m_hardClosedForUserDelete) {
 566         callback(IDBError::userDeleteError(), { });
 567         return 0;
 568     }
 569 
 570     uint64_t identifier = generateUniqueCallbackIdentifier();
 571     ASSERT(!m_keyDataCallbacks.contains(identifier));
 572     m_keyDataCallbacks.add(identifier, WTFMove(callback));
 573 
 574     if (taskSize) {
 575         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);
 576         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);
 577     }
 578 
 579     m_callbackQueue.append(identifier);
 580     return identifier;
 581 }
 582 
 583 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)
 584 {
 585     if (m_hardClosedForUserDelete) {
 586         callback(IDBError::userDeleteError(), { });
 587         return 0;
 588     }
 589 
 590     uint64_t identifier = generateUniqueCallbackIdentifier();
 591     ASSERT(!m_getResultCallbacks.contains(identifier));
 592     m_getResultCallbacks.add(identifier, WTFMove(callback));
 593     m_callbackQueue.append(identifier);
 594     return identifier;
 595 }
 596 
 597 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetAllResultsCallback&amp;&amp; callback)
 598 {
 599     if (m_hardClosedForUserDelete) {
 600         callback(IDBError::userDeleteError(), { });
 601         return 0;
 602     }
 603 
 604     uint64_t identifier = generateUniqueCallbackIdentifier();
 605     ASSERT(!m_getAllResultsCallbacks.contains(identifier));
 606     m_getAllResultsCallbacks.add(identifier, WTFMove(callback));
 607     m_callbackQueue.append(identifier);
 608     return identifier;
 609 }
 610 
 611 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(CountCallback&amp;&amp; callback)
 612 {
 613     if (m_hardClosedForUserDelete) {
 614         callback(IDBError::userDeleteError(), 0);
 615         return 0;
 616     }
 617 
 618     uint64_t identifier = generateUniqueCallbackIdentifier();
 619     ASSERT(!m_countCallbacks.contains(identifier));
 620     m_countCallbacks.add(identifier, WTFMove(callback));
 621     m_callbackQueue.append(identifier);
 622     return identifier;
 623 }
 624 
 625 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 626 {
 627     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDelete&quot;);
 628     ASSERT(!m_hardClosedForUserDelete);
 629 
 630     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 631     handleDatabaseOperations();
 632 }
 633 
 634 void UniqueIDBDatabase::startVersionChangeTransaction()
 635 {
 636     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::startVersionChangeTransaction&quot;);
 637 
 638     ASSERT(!m_versionChangeTransaction);
 639     ASSERT(m_currentOpenDBRequest);
 640     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 641     ASSERT(m_versionChangeDatabaseConnection);
 642 
 643     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 644     if (!requestedVersion)
 645         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 646 
 647     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
 648     m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);
 649 
 650     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performStartVersionChangeTransaction, m_versionChangeTransaction-&gt;info()));
 651 }
 652 
 653 void UniqueIDBDatabase::performStartVersionChangeTransaction(const IDBTransactionInfo&amp; info)
 654 {
 655     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performStartVersionChangeTransaction&quot;);
 656 
 657     IDBError error = m_backingStore-&gt;beginTransaction(info);
 658     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformStartVersionChangeTransaction, error));
 659 }
 660 
 661 void UniqueIDBDatabase::didPerformStartVersionChangeTransaction(const IDBError&amp; error)
 662 {
 663     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformStartVersionChangeTransaction&quot;);
 664 
 665     // Open request may already be canceled by client or user, or connection to client is lost.
 666     if (!m_versionChangeDatabaseConnection)
 667         return;
 668 
 669     ASSERT(m_currentOpenDBRequest);
 670     ASSERT(m_versionChangeTransaction);
 671     auto operation = WTFMove(m_currentOpenDBRequest);
 672     IDBResultData result;
 673     if (error.isNull()) {
 674         addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
 675         m_databaseInfo-&gt;setVersion(m_versionChangeTransaction-&gt;info().newVersion());
 676         result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);
 677         operation-&gt;connection().didOpenDatabase(result);
 678     } else {
 679         m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);
 680         m_versionChangeDatabaseConnection = nullptr;
 681         result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);
 682         operation-&gt;connection().didOpenDatabase(result);
 683     }
 684 
 685     invokeOperationAndTransactionTimer();
 686 }
 687 
 688 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 689 {
 690     ASSERT(m_currentOpenDBRequest);
 691 
 692     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 693         return;
 694 
 695     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 696     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 697 
 698     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);
 699 
 700     // 3.3.7 &quot;versionchange&quot; transaction steps
 701     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 702     // The event must not be fired on connections which has the closePending flag set.
 703     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 704     for (const auto&amp; connection : m_openDatabaseConnections) {
 705         if (connection-&gt;closePending())
 706             continue;
 707 
 708         connection-&gt;fireVersionChangeEvent(requestIdentifier, newVersion);
 709         connectionIdentifiers.add(connection-&gt;identifier());
 710     }
 711 
 712     if (!connectionIdentifiers.isEmpty())
 713         m_currentOpenDBRequest-&gt;notifiedConnectionsOfVersionChange(WTFMove(connectionIdentifiers));
 714     else
 715         m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 716 }
 717 
 718 void UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(uint64_t connectionIdentifier)
 719 {
 720     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent - %&quot; PRIu64, connectionIdentifier);
 721 
 722     ASSERT(m_currentOpenDBRequest);
 723 
 724     m_currentOpenDBRequest-&gt;connectionClosedOrFiredVersionChangeEvent(connectionIdentifier);
 725 
 726     if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
 727         return;
 728 
 729     if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
 730         invokeOperationAndTransactionTimer();
 731         return;
 732     }
 733 
 734     // Since all open connections have fired their version change events but not all of them have closed,
 735     // this request is officially blocked.
 736     m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 737 }
 738 
 739 void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier)
 740 {
 741     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
 742 
 743     if (!m_currentOpenDBRequest)
 744         return;
 745 
 746     ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
 747 
 748     notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 749 }
 750 
 751 void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
 752 {
 753     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDBRequestCancelled - %s&quot;, requestIdentifier.loggingString().utf8().data());
 754 
 755     if (m_currentOpenDBRequest &amp;&amp; m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier)
 756         m_currentOpenDBRequest = nullptr;
 757 
 758     if (m_versionChangeDatabaseConnection &amp;&amp; m_versionChangeDatabaseConnection-&gt;openRequestIdentifier() == requestIdentifier) {
 759         ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;databaseConnection().openRequestIdentifier() == requestIdentifier);
 760         ASSERT(!m_versionChangeTransaction || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 761 
 762         connectionClosedFromClient(*m_versionChangeDatabaseConnection);
 763     }
 764 
 765     for (auto&amp; request : m_pendingOpenDBRequests) {
 766         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 767             m_pendingOpenDBRequests.remove(request);
 768             return;
 769         }
 770     }
 771 }
 772 
 773 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 774 {
 775     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 776     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 777 }
 778 
 779 void UniqueIDBDatabase::openBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 780 {
 781     ASSERT(!isMainThread());
 782     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);
 783 
 784     ASSERT(!m_backingStore);
 785     m_backingStore = m_server-&gt;createBackingStore(identifier);
 786     m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();
 787     m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();
 788 
 789     // QuotaUser should have initiliazed storage usage, which contains the
 790     // size of this database.
 791     m_currentDatabaseSize = m_backingStore-&gt;databaseSize();
 792 
 793     IDBDatabaseInfo databaseInfo;
 794     auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 795 
 796     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));
 797 }
 798 
 799 void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)
 800 {
 801     ASSERT(isMainThread());
 802     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);
 803 
 804     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);
 805     m_backingStoreOpenError = error;
 806 
 807     ASSERT(m_isOpeningBackingStore);
 808     m_isOpeningBackingStore = false;
 809 
 810     updateSpaceUsedIfNeeded();
 811 
 812     if (m_hardClosedForUserDelete)
 813         return;
 814 
 815     handleDatabaseOperations();
 816 }
 817 
 818 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
 819 {
 820     ASSERT(isMainThread());
 821     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);
 822 
 823     auto taskSize = defaultWriteOperationCost + estimateSize(info);
 824     requestSpace(taskSize, &quot;createObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {
 825         if (error) {
 826             callback(WTFMove(*error));
 827             return;
 828         }
 829         if (!transaction) {
 830             callback(IDBError { UnknownError });
 831             return;
 832         }
 833         this-&gt;createObjectStoreAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));
 834     });
 835 }
 836 
 837 void UniqueIDBDatabase::createObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
 838 {
 839     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
 840     if (!callbackID)
 841         return;
 842 
 843     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));
 844 }
 845 
 846 void UniqueIDBDatabase::performCreateObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 847 {
 848     ASSERT(!isMainThread());
 849     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateObjectStore&quot;);
 850 
 851     ASSERT(m_backingStore);
 852     m_backingStore-&gt;createObjectStore(transactionIdentifier, info);
 853 
 854     IDBError error;
 855     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateObjectStore, callbackIdentifier, error, info));
 856 }
 857 
 858 void UniqueIDBDatabase::didPerformCreateObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBObjectStoreInfo&amp; info)
 859 {
 860     ASSERT(isMainThread());
 861     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateObjectStore&quot;);
 862 
 863     if (error.isNull())
 864         m_databaseInfo-&gt;addExistingObjectStore(info);
 865 
 866     performErrorCallback(callbackIdentifier, error);
 867 }
 868 
 869 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
 870 {
 871     ASSERT(isMainThread());
 872     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);
 873 
 874     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreName, callback = WTFMove(callback)](auto error) mutable {
 875         if (error) {
 876             callback(WTFMove(*error));
 877             return;
 878         }
 879         if (!transaction) {
 880             callback(IDBError { UnknownError });
 881             return;
 882         }
 883         this-&gt;deleteObjectStoreAfterQuotaCheck(*transaction, objectStoreName, WTFMove(callback));
 884     });
 885 }
 886 
 887 void UniqueIDBDatabase::deleteObjectStoreAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
 888 {
 889     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 890     if (!callbackID)
 891         return;
 892 
 893     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);
 894     if (!info) {
 895         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });
 896         return;
 897     }
 898 
 899     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteObjectStore, callbackID, transaction.info().identifier(), info-&gt;identifier()));
 900 }
 901 
 902 void UniqueIDBDatabase::performDeleteObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 903 {
 904     ASSERT(!isMainThread());
 905     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteObjectStore&quot;);
 906 
 907     ASSERT(m_backingStore);
 908     m_backingStore-&gt;deleteObjectStore(transactionIdentifier, objectStoreIdentifier);
 909 
 910     IDBError error;
 911     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteObjectStore, callbackIdentifier, error, objectStoreIdentifier));
 912 }
 913 
 914 void UniqueIDBDatabase::didPerformDeleteObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier)
 915 {
 916     ASSERT(isMainThread());
 917     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteObjectStore&quot;);
 918 
 919     if (error.isNull())
 920         m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
 921 
 922     performErrorCallback(callbackIdentifier, error);
 923 }
 924 
 925 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
 926 {
 927     ASSERT(isMainThread());
 928     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);
 929 
 930     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
 931     requestSpace(taskSize, &quot;renameObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {
 932         if (error) {
 933             callback(WTFMove(*error));
 934             return;
 935         }
 936         if (!transaction) {
 937             callback(IDBError { UnknownError });
 938             return;
 939         }
 940         this-&gt;renameObjectStoreAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, newName, WTFMove(callback));
 941     });
 942 }
 943 
 944 void UniqueIDBDatabase::renameObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
 945 {
 946     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
 947     if (!callbackID)
 948         return;
 949 
 950     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 951     if (!info) {
 952         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });
 953         return;
 954     }
 955 
 956     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier, newName));
 957 }
 958 
 959 void UniqueIDBDatabase::performRenameObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
 960 {
 961     ASSERT(!isMainThread());
 962     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameObjectStore&quot;);
 963 
 964     ASSERT(m_backingStore);
 965     m_backingStore-&gt;renameObjectStore(transactionIdentifier, objectStoreIdentifier, newName);
 966 
 967     IDBError error;
 968     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameObjectStore, callbackIdentifier, error, objectStoreIdentifier, newName));
 969 }
 970 
 971 void UniqueIDBDatabase::didPerformRenameObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, const String&amp; newName)
 972 {
 973     ASSERT(isMainThread());
 974     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameObjectStore&quot;);
 975 
 976     if (error.isNull())
 977         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
 978 
 979     performErrorCallback(callbackIdentifier, error);
 980 }
 981 
 982 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
 983 {
 984     ASSERT(isMainThread());
 985     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);
 986 
 987     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, callback = WTFMove(callback)](auto error) mutable {
 988         if (error) {
 989             callback(WTFMove(*error));
 990             return;
 991         }
 992         if (!transaction) {
 993             callback(IDBError { UnknownError });
 994             return;
 995         }
 996         this-&gt;clearObjectStoreAfetQuotaCheck(*transaction, objectStoreIdentifier, WTFMove(callback));
 997     });
 998 }
 999 
1000 void UniqueIDBDatabase::clearObjectStoreAfetQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
1001 {
1002     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1003     if (!callbackID)
1004         return;
1005     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));
1006 }
1007 
1008 void UniqueIDBDatabase::performClearObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
1009 {
1010     ASSERT(!isMainThread());
1011     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performClearObjectStore&quot;);
1012 
1013     ASSERT(m_backingStore);
1014     m_backingStore-&gt;clearObjectStore(transactionIdentifier, objectStoreIdentifier);
1015 
1016     IDBError error;
1017     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformClearObjectStore, callbackIdentifier, error));
1018 }
1019 
1020 void UniqueIDBDatabase::didPerformClearObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error)
1021 {
1022     ASSERT(isMainThread());
1023     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformClearObjectStore&quot;);
1024 
1025     performErrorCallback(callbackIdentifier, error);
1026 }
1027 
1028 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
1029 {
1030     ASSERT(isMainThread());
1031     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);
1032 
1033     auto taskSize = defaultWriteOperationCost + estimateSize(info);
1034     requestSpace(taskSize, &quot;createIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {
1035         if (error) {
1036             callback(WTFMove(*error));
1037             return;
1038         }
1039         if (!transaction) {
1040             callback(IDBError { UnknownError });
1041             return;
1042         }
1043         this-&gt;createIndexAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));
1044     });
1045 }
1046 
1047 void UniqueIDBDatabase::createIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
1048 {
1049     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
1050     if (!callbackID)
1051         return;
1052     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));
1053 }
1054 
1055 void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1056 {
1057     ASSERT(!isMainThread());
1058     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);
1059 
1060     IDBError error;
1061     ASSERT(m_backingStore);
1062     if (!m_backingStore) {
1063         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performCreateIndex: m_backingStore is null&quot;, this);
1064         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to create index&quot;_s);
1065         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
1066         return;
1067     }
1068 
1069     error = m_backingStore-&gt;createIndex(transactionIdentifier, info);
1070     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
1071 }
1072 
1073 void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)
1074 {
1075     ASSERT(isMainThread());
1076     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateIndex&quot;);
1077 
1078     if (error.isNull()) {
1079         ASSERT(m_databaseInfo);
1080         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1081         ASSERT(objectStoreInfo);
1082         objectStoreInfo-&gt;addExistingIndex(info);
1083     }
1084 
1085     performErrorCallback(callbackIdentifier, error);
1086 }
1087 
1088 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
1089 {
1090     ASSERT(isMainThread());
1091     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);
1092 
1093     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexName, callback = WTFMove(callback)](auto error) mutable {
1094         if (error) {
1095             callback(WTFMove(*error));
1096             return;
1097         }
1098         if (!transaction) {
1099             callback(IDBError { UnknownError });
1100             return;
1101         }
1102         this-&gt;deleteIndexAfterQuotaCheck(*transaction, objectStoreIdentifier, indexName, WTFMove(callback));
1103     });
1104 }
1105 
1106 void UniqueIDBDatabase::deleteIndexAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
1107 {
1108     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1109     if (!callbackID)
1110         return;
1111 
1112     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1113     if (!objectStoreInfo) {
1114         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });
1115         return;
1116     }
1117 
1118     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
1119     if (!indexInfo) {
1120         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });
1121         return;
1122     }
1123 
1124     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexInfo-&gt;identifier()));
1125 }
1126 
1127 void UniqueIDBDatabase::performDeleteIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const uint64_t indexIdentifier)
1128 {
1129     ASSERT(!isMainThread());
1130     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteIndex&quot;);
1131 
1132     ASSERT(m_backingStore);
1133     m_backingStore-&gt;deleteIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier);
1134 
1135     IDBError error;
1136     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier));
1137 }
1138 
1139 void UniqueIDBDatabase::didPerformDeleteIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1140 {
1141     ASSERT(isMainThread());
1142     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteIndex&quot;);
1143 
1144     if (error.isNull()) {
1145         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1146         if (objectStoreInfo)
1147             objectStoreInfo-&gt;deleteIndex(indexIdentifier);
1148     }
1149 
1150     performErrorCallback(callbackIdentifier, error);
1151 }
1152 
1153 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
1154 {
1155     ASSERT(isMainThread());
1156     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);
1157 
1158     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
1159     requestSpace(taskSize, &quot;renameIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {
1160         if (error) {
1161             callback(WTFMove(*error));
1162             return;
1163         }
1164         if (!transaction) {
1165             callback(IDBError { UnknownError });
1166             return;
1167         }
1168         this-&gt;renameIndexAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, indexIdentifier, newName, WTFMove(callback));
1169     });
1170 }
1171 
1172 void UniqueIDBDatabase::renameIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
1173 {
1174     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
1175     if (!callbackID)
1176         return;
1177 
1178     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1179     if (!objectStoreInfo) {
1180         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });
1181         return;
1182     }
1183 
1184     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1185     if (!indexInfo) {
1186         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });
1187         return;
1188     }
1189 
1190     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName));
1191 }
1192 
1193 void UniqueIDBDatabase::performRenameIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1194 {
1195     ASSERT(!isMainThread());
1196     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameIndex&quot;);
1197 
1198     ASSERT(m_backingStore);
1199     m_backingStore-&gt;renameIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier, newName);
1200 
1201     IDBError error;
1202     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier, newName));
1203 }
1204 
1205 void UniqueIDBDatabase::didPerformRenameIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1206 {
1207     ASSERT(isMainThread());
1208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameIndex&quot;);
1209 
1210     if (error.isNull()) {
1211         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1212         ASSERT(objectStoreInfo);
1213         if (objectStoreInfo) {
1214             auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1215             ASSERT(indexInfo);
1216             indexInfo-&gt;rename(newName);
1217         }
1218     }
1219 
1220     performErrorCallback(callbackIdentifier, error);
1221 }
1222 
1223 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
1224 {
1225     ASSERT(isMainThread());
1226     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);
1227 
1228     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);
1229     requestSpace(taskSize, &quot;putOrAdd&quot;, [this, taskSize, requestData, keyData, value, callback = WTFMove(callback), overwriteMode](auto error) mutable {
1230         if (error) {
1231             callback(WTFMove(*error), { });
1232             return;
1233         }
1234         this-&gt;putOrAddAfterQuotaCheck(taskSize, requestData, keyData, value, overwriteMode, WTFMove(callback));
1235     });
1236 }
1237 
1238 void UniqueIDBDatabase::putOrAddAfterQuotaCheck(uint64_t taskSize, const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
1239 {
1240     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
1241     if (!callbackID)
1242         return;
1243     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));
1244 }
1245 
1246 void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
1247 {
1248     ASSERT(!isMainThread());
1249     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPutOrAdd&quot;);
1250 
1251     ASSERT(m_backingStore);
1252     ASSERT(objectStoreIdentifier);
1253 
1254     IDBKeyData usedKey;
1255     IDBError error;
1256 
1257     if (!m_backingStore) {
1258         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performPutOrAdd: m_backingStore is null&quot;, this);
1259         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to put or add&quot;_s);
1260         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1261         return;
1262     }
1263 
1264     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);
1265     if (!objectStoreInfo) {
1266         error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);
1267         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1268         return;
1269     }
1270 
1271     bool usedKeyIsGenerated = false;
1272     uint64_t keyNumber;
1273     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
1274         if (usedKeyIsGenerated)
1275             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1276     });
1277     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
1278         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1279         if (!error.isNull()) {
1280             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1281             return;
1282         }
1283 
1284         usedKey.setNumberValue(keyNumber);
1285         usedKeyIsGenerated = true;
1286     } else
1287         usedKey = keyData;
1288 
1289     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
1290         bool keyExists;
1291         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
1292         if (error.isNull() &amp;&amp; keyExists)
1293             error = IDBError(ConstraintError, &quot;Key already exists in the object store&quot;_s);
1294 
1295         if (!error.isNull()) {
1296             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1297             return;
1298         }
1299     }
1300 
1301     // 3.4.1 Object Store Storage Operation
1302     // ...If a record already exists in store ...
1303     // then remove the record from store using the steps for deleting records from an object store...
1304     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
1305     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
1306     if (!error.isNull()) {
1307         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1308         return;
1309     }
1310 
1311     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);
1312 
1313     if (!error.isNull()) {
1314         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1315         return;
1316     }
1317 
1318     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
1319         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
1320 
1321     generatedKeyResetter.release();
1322     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1323 }
1324 
1325 void UniqueIDBDatabase::didPerformPutOrAdd(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
1326 {
1327     ASSERT(isMainThread());
1328     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformPutOrAdd&quot;);
1329 
1330     performKeyDataCallback(callbackIdentifier, error, resultKey);
1331 }
1332 
1333 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
1334 {
1335     ASSERT(isMainThread());
1336     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);
1337 
1338     waitForRequestSpaceCompletion([this, requestData, getRecordData, callback = WTFMove(callback)](auto error) mutable {
1339         if (error) {
1340             callback(WTFMove(*error), { });
1341             return;
1342         }
1343         this-&gt;getRecordAfterQuotaCheck(requestData, getRecordData, WTFMove(callback));
1344     });
1345 }
1346 
1347 void UniqueIDBDatabase::getRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
1348 {
1349     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1350     if (!callbackID)
1351         return;
1352 
1353     if (uint64_t indexIdentifier = requestData.indexIdentifier())
1354         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetIndexRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData));
1355     else
1356         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type));
1357 }
1358 
1359 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
1360 {
1361     ASSERT(isMainThread());
1362     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);
1363 
1364     waitForRequestSpaceCompletion([this, requestData, getAllRecordsData, callback = WTFMove(callback)](auto error) mutable {
1365         if (error) {
1366             callback(WTFMove(*error), { });
1367             return;
1368         }
1369         this-&gt;getAllRecordsAfterQuotaCheck(requestData, getAllRecordsData, WTFMove(callback));
1370     });
1371 }
1372 
1373 void UniqueIDBDatabase::getAllRecordsAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
1374 {
1375     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1376     if (!callbackID)
1377         return;
1378 
1379     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));
1380 }
1381 
1382 void UniqueIDBDatabase::performGetRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; keyRangeData, IDBGetRecordDataType type)
1383 {
1384     ASSERT(!isMainThread());
1385     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetRecord&quot;);
1386 
1387     ASSERT(m_backingStore);
1388 
1389     IDBGetResult result;
1390     IDBError error = m_backingStore-&gt;getRecord(transactionIdentifier, objectStoreIdentifier, keyRangeData, type, result);
1391 
1392     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1393 }
1394 
1395 void UniqueIDBDatabase::performGetIndexRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, IndexedDB::IndexRecordType recordType, const IDBKeyRangeData&amp; range)
1396 {
1397     ASSERT(!isMainThread());
1398     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetIndexRecord&quot;);
1399 
1400     ASSERT(m_backingStore);
1401 
1402     IDBGetResult result;
1403     IDBError error = m_backingStore-&gt;getIndexRecord(transactionIdentifier, objectStoreIdentifier, indexIdentifier, recordType, range, result);
1404 
1405     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1406 }
1407 
1408 void UniqueIDBDatabase::didPerformGetRecord(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1409 {
1410     ASSERT(isMainThread());
1411     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetRecord&quot;);
1412 
1413     performGetResultCallback(callbackIdentifier, error, result);
1414 }
1415 
1416 void UniqueIDBDatabase::performGetAllRecords(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData)
1417 {
1418     ASSERT(!isMainThread());
1419     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetAllRecords&quot;);
1420 
1421     ASSERT(m_backingStore);
1422 
1423     IDBGetAllResult result;
1424     IDBError error = m_backingStore-&gt;getAllRecords(transactionIdentifier, getAllRecordsData, result);
1425 
1426     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetAllRecords, callbackIdentifier, error, WTFMove(result)));
1427 }
1428 
1429 void UniqueIDBDatabase::didPerformGetAllRecords(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; result)
1430 {
1431     ASSERT(isMainThread());
1432     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetAllRecords&quot;);
1433 
1434     performGetAllResultsCallback(callbackIdentifier, error, result);
1435 }
1436 
1437 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
1438 {
1439     ASSERT(isMainThread());
1440     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);
1441 
1442     waitForRequestSpaceCompletion([this, requestData, range, callback = WTFMove(callback)](auto error) mutable {
1443         if (error) {
1444             callback(WTFMove(*error), { });
1445             return;
1446         }
1447         this-&gt;getCountAfterQuotaCheck(requestData, range, WTFMove(callback));
1448     });
1449 }
1450 
1451 void UniqueIDBDatabase::getCountAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
1452 {
1453     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1454     if (!callbackID)
1455         return;
1456     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));
1457 }
1458 
1459 void UniqueIDBDatabase::performGetCount(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; keyRangeData)
1460 {
1461     ASSERT(!isMainThread());
1462     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetCount&quot;);
1463 
1464     ASSERT(m_backingStore);
1465     ASSERT(objectStoreIdentifier);
1466 
1467     uint64_t count;
1468     IDBError error = m_backingStore-&gt;getCount(transactionIdentifier, objectStoreIdentifier, indexIdentifier, keyRangeData, count);
1469 
1470     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetCount, callbackIdentifier, error, count));
1471 }
1472 
1473 void UniqueIDBDatabase::didPerformGetCount(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
1474 {
1475     ASSERT(isMainThread());
1476     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetCount&quot;);
1477 
1478     performCountCallback(callbackIdentifier, error, count);
1479 }
1480 
1481 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
1482 {
1483     ASSERT(isMainThread());
1484     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);
1485 
1486     waitForRequestSpaceCompletion([this, requestData, keyRangeData, callback = WTFMove(callback)](auto error) mutable {
1487         if (error) {
1488             callback(WTFMove(*error));
1489             return;
1490         }
1491         this-&gt;deleteRecordAfterQuotaCheck(requestData, keyRangeData, WTFMove(callback));
1492     });
1493 }
1494 
1495 void UniqueIDBDatabase::deleteRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
1496 {
1497     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1498     if (!callbackID)
1499         return;
1500     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));
1501 }
1502 
1503 void UniqueIDBDatabase::performDeleteRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)
1504 {
1505     ASSERT(!isMainThread());
1506     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteRecord&quot;);
1507 
1508     IDBError error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, range);
1509 
1510     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteRecord, callbackIdentifier, error));
1511 }
1512 
1513 void UniqueIDBDatabase::didPerformDeleteRecord(uint64_t callbackIdentifier, const IDBError&amp; error)
1514 {
1515     ASSERT(isMainThread());
1516     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteRecord&quot;);
1517 
1518     performErrorCallback(callbackIdentifier, error);
1519 }
1520 
1521 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
1522 {
1523     ASSERT(isMainThread());
1524     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);
1525 
1526     waitForRequestSpaceCompletion([this, requestData, info, callback = WTFMove(callback)](auto error) mutable {
1527         if (error) {
1528             callback(WTFMove(*error), { });
1529             return;
1530         }
1531         this-&gt;openCursorAfterQuotaCheck(requestData, info, WTFMove(callback));
1532     });
1533 }
1534 
1535 void UniqueIDBDatabase::openCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
1536 {
1537     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1538     if (!callbackID)
1539         return;
1540     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));
1541 }
1542 
1543 void UniqueIDBDatabase::performOpenCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info)
1544 {
1545     ASSERT(!isMainThread());
1546     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performOpenCursor&quot;);
1547 
1548     IDBGetResult result;
1549     IDBError error = m_backingStore-&gt;openCursor(transactionIdentifier, info, result);
1550 
1551     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformOpenCursor, callbackIdentifier, error, result));
1552 }
1553 
1554 void UniqueIDBDatabase::didPerformOpenCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1555 {
1556     ASSERT(isMainThread());
1557     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformOpenCursor&quot;);
1558 
1559     performGetResultCallback(callbackIdentifier, error, result);
1560 }
1561 
1562 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
1563 {
1564     ASSERT(isMainThread());
1565     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);
1566 
1567     waitForRequestSpaceCompletion([this, requestData, data, callback = WTFMove(callback)](auto error) mutable {
1568         if (error) {
1569             callback(WTFMove(*error), { });
1570             return;
1571         }
1572         this-&gt;iterateCursorAfterQuotaCheck(requestData, data, WTFMove(callback));
1573     });
1574 }
1575 
1576 void UniqueIDBDatabase::iterateCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
1577 {
1578     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1579     if (!callbackID)
1580         return;
1581     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));
1582 }
1583 
1584 void UniqueIDBDatabase::performIterateCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data)
1585 {
1586     ASSERT(!isMainThread());
1587     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performIterateCursor&quot;);
1588 
1589     IDBGetResult result;
1590     IDBError error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);
1591 
1592     if (error.isNull()) {
1593         auto addResult = m_cursorPrefetches.add(cursorIdentifier);
1594         if (addResult.isNewEntry)
1595             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1596     }
1597 
1598     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformIterateCursor, callbackIdentifier, error, result));
1599 }
1600 
1601 void UniqueIDBDatabase::performPrefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
1602 {
1603     ASSERT(!isMainThread());
1604     ASSERT(m_cursorPrefetches.contains(cursorIdentifier));
1605     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPrefetchCursor&quot;);
1606 
1607     if (m_hardClosedForUserDelete || !m_backingStore-&gt;prefetchCursor(transactionIdentifier, cursorIdentifier))
1608         m_cursorPrefetches.remove(cursorIdentifier);
1609     else
1610         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1611 }
1612 
1613 void UniqueIDBDatabase::didPerformIterateCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1614 {
1615     ASSERT(isMainThread());
1616     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);
1617 
1618     performGetResultCallback(callbackIdentifier, error, result);
1619 }
1620 
1621 bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction, UniqueIDBDatabaseTransaction::State state)
1622 {
1623     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
1624     if (!takenTransaction)
1625         return false;
1626 
1627     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));
1628     takenTransaction-&gt;setState(state);
1629     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));
1630 
1631     return true;
1632 }
1633 
1634 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
1635 {
1636     ASSERT(isMainThread());
1637     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1638 
1639     ASSERT(transaction.databaseConnection().database() == this);
1640 
1641     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto error) mutable {
1642         if (error) {
1643             callback(WTFMove(*error));
1644             return;
1645         }
1646         if (!transaction) {
1647             callback(IDBError { UnknownError });
1648             return;
1649         }
1650         this-&gt;commitTransactionAfterQuotaCheck(*transaction, WTFMove(callback));
1651     });
1652 }
1653 
1654 void UniqueIDBDatabase::commitTransactionAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
1655 {
1656     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1657     if (!callbackID)
1658         return;
1659 
1660     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Committing)) {
1661         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1662             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.
1663             forgetErrorCallback(callbackID);
1664             return;
1665         }
1666 
1667         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to commit transaction that is already finishing&quot;_s });
1668         return;
1669     }
1670 
1671     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCommitTransaction, callbackID, transaction.info().identifier()));
1672 }
1673 
1674 void UniqueIDBDatabase::performCommitTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1675 {
1676     ASSERT(!isMainThread());
1677     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1678 
1679     IDBError error = m_backingStore-&gt;commitTransaction(transactionIdentifier);
1680     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCommitTransaction, callbackIdentifier, error, transactionIdentifier));
1681 }
1682 
1683 void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1684 {
1685     ASSERT(isMainThread());
1686     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1687 
1688     IDBError result = error;
1689     auto transaction = m_finishingTransactions.get(transactionIdentifier);
1690     switch (transaction-&gt;state()) {
1691     case UniqueIDBDatabaseTransaction::State::Aborted:
1692         result = IDBError { UnknownError, &quot;Transaction is already aborted&quot;_s };
1693         break;
1694     case UniqueIDBDatabaseTransaction::State::Committed:
1695         result = transaction-&gt;result();
1696         break;
1697     case UniqueIDBDatabaseTransaction::State::Committing:
1698         break;
1699     case UniqueIDBDatabaseTransaction::State::Running:
1700     case UniqueIDBDatabaseTransaction::State::Aborting:
1701         ASSERT_NOT_REACHED();
1702     }
1703 
1704     performErrorCallback(callbackIdentifier, result);
1705 
1706     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));
1707 }
1708 
1709 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, WaitForPendingTasks waitForPendingTasks, ErrorCallback callback)
1710 {
1711     ASSERT(isMainThread());
1712     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1713 
1714     ASSERT(transaction.databaseConnection().database() == this);
1715 
1716     if (waitForPendingTasks == WaitForPendingTasks::Yes) {
1717         waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto&amp;&amp; error) mutable {
1718             if (error) {
1719                 callback(WTFMove(*error));
1720                 return;
1721             }
1722             if (!transaction) {
1723                 callback(IDBError { UnknownError });
1724                 return;
1725             }
1726             this-&gt;abortTransaction(*transaction, WaitForPendingTasks::No, WTFMove(callback));
1727         });
1728         return;
1729     }
1730 
1731     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1732     if (!callbackID)
1733         return;
1734 
1735     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Aborting)) {
1736         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1737             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.
1738             forgetErrorCallback(callbackID);
1739             return;
1740         }
1741 
1742         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to abort transaction that is already finishing&quot;_s });
1743         return;
1744     }
1745 
1746     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performAbortTransaction, callbackID, transaction.info().identifier()));
1747 }
1748 
1749 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)
1750 {
1751     ASSERT(isMainThread());
1752     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);
1753 
1754     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);
1755     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);
1756 
1757     m_versionChangeTransaction = nullptr;
1758     m_versionChangeDatabaseConnection = nullptr;
1759 
1760     if (m_hardClosedForUserDelete) {
1761         maybeFinishHardClose();
1762         return;
1763     }
1764 
1765     invokeOperationAndTransactionTimer();
1766 }
1767 
1768 void UniqueIDBDatabase::performAbortTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1769 {
1770     ASSERT(!isMainThread());
1771     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1772 
1773     IDBError error = m_backingStore-&gt;abortTransaction(transactionIdentifier);
1774     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformAbortTransaction, callbackIdentifier, error, transactionIdentifier));
1775 }
1776 
1777 void UniqueIDBDatabase::didPerformAbortTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1778 {
1779     ASSERT(isMainThread());
1780     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1781 
1782     auto transaction = m_finishingTransactions.take(transactionIdentifier);
1783     ASSERT(transaction);
1784 
1785     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
1786         ASSERT(m_versionChangeTransaction == transaction);
1787         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
1788         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
1789         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());
1790     }
1791 
1792     IDBError result = transaction-&gt;state() == UniqueIDBDatabaseTransaction::State::Aborted ? transaction-&gt;result() : error;
1793     performErrorCallback(callbackIdentifier, result);
1794 
1795     transactionCompleted(WTFMove(transaction));
1796 }
1797 
1798 void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)
1799 {
1800     if (m_versionChangeTransaction == &amp;transaction)
1801         m_versionChangeTransaction = nullptr;
1802 }
1803 
1804 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
1805 {
1806     ASSERT(isMainThread());
1807     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1808 
1809     if (m_serverClosePendingDatabaseConnections.contains(&amp;connection)) {
1810         m_serverClosePendingDatabaseConnections.remove(&amp;connection);
1811         if (m_hardClosedForUserDelete)
1812             maybeFinishHardClose();
1813         return;
1814     }
1815 
1816     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1817     m_openDatabaseConnections.remove(&amp;connection);
1818 
1819     if (m_versionChangeDatabaseConnection == &amp;connection) {
1820         if (m_versionChangeTransaction) {
1821             m_clientClosePendingDatabaseConnections.add(WTFMove(m_versionChangeDatabaseConnection));
1822 
1823             auto transactionIdentifier = m_versionChangeTransaction-&gt;info().identifier();
1824             if (m_inProgressTransactions.contains(transactionIdentifier)) {
1825                 ASSERT(!m_finishingTransactions.contains(transactionIdentifier));
1826                 connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);
1827             }
1828 
1829             return;
1830         }
1831 
1832         m_versionChangeDatabaseConnection = nullptr;
1833     }
1834 
1835     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;
1836     while (!m_pendingTransactions.isEmpty()) {
1837         auto transaction = m_pendingTransactions.takeFirst();
1838         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)
1839             pendingTransactions.append(WTFMove(transaction));
1840     }
1841 
1842     if (!pendingTransactions.isEmpty())
1843         m_pendingTransactions.swap(pendingTransactions);
1844 
1845     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;
1846     for (auto&amp; transaction : m_inProgressTransactions.values()) {
1847         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)
1848             transactionsToAbort.append(transaction);
1849     }
1850 
1851     for (auto&amp; transaction : transactionsToAbort)
1852         transaction-&gt;abortWithoutCallback();
1853 
1854     if (m_currentOpenDBRequest)
1855         notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
1856 
1857     if (connection.hasNonFinishedTransactions()) {
1858         m_clientClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1859         return;
1860     }
1861 
1862     if (m_hardClosedForUserDelete) {
1863         maybeFinishHardClose();
1864         return;
1865     }
1866 
1867     // Now that a database connection has closed, previously blocked operations might be runnable.
1868     invokeOperationAndTransactionTimer();
1869 }
1870 
1871 void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
1872 {
1873     ASSERT(isMainThread());
1874     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1875 
1876     if (m_clientClosePendingDatabaseConnections.contains(&amp;connection)) {
1877         ASSERT(!m_openDatabaseConnections.contains(&amp;connection));
1878         ASSERT(!m_serverClosePendingDatabaseConnections.contains(&amp;connection));
1879         return;
1880     }
1881 
1882     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1883     m_openDatabaseConnections.remove(&amp;connection);
1884 
1885     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
1886 
1887     m_serverClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1888 }
1889 
1890 void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)
1891 {
1892     ASSERT(isMainThread());
1893     LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1894 
1895     if (!m_serverClosePendingDatabaseConnections.contains(&amp;connection))
1896         return;
1897     m_serverClosePendingDatabaseConnections.remove(&amp;connection);
1898 
1899     if (m_hardClosedForUserDelete)
1900         maybeFinishHardClose();
1901 }
1902 
1903 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1904 {
1905     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
1906     ASSERT(!m_hardClosedForUserDelete);
1907 
1908     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
1909 
1910     m_pendingTransactions.append(WTFMove(transaction));
1911 
1912     invokeOperationAndTransactionTimer();
1913 }
1914 
1915 bool UniqueIDBDatabase::isCurrentlyInUse() const
1916 {
1917     return !m_openDatabaseConnections.isEmpty() || !m_clientClosePendingDatabaseConnections.isEmpty() || !m_pendingOpenDBRequests.isEmpty() || m_currentOpenDBRequest || m_versionChangeDatabaseConnection || m_versionChangeTransaction || m_isOpeningBackingStore || m_deleteBackingStoreInProgress;
1918 }
1919 
1920 bool UniqueIDBDatabase::hasUnfinishedTransactions() const
1921 {
1922     return !m_inProgressTransactions.isEmpty() || !m_finishingTransactions.isEmpty();
1923 }
1924 
1925 void UniqueIDBDatabase::invokeOperationAndTransactionTimer()
1926 {
1927     LOG(IndexedDB, &quot;UniqueIDBDatabase::invokeOperationAndTransactionTimer()&quot;);
1928     RELEASE_ASSERT(!m_hardClosedForUserDelete);
1929     RELEASE_ASSERT(!m_owningPointerForClose);
1930 
1931     if (!m_operationAndTransactionTimer.isActive())
1932         m_operationAndTransactionTimer.startOneShot(0_s);
1933 }
1934 
1935 void UniqueIDBDatabase::operationAndTransactionTimerFired()
1936 {
1937     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::operationAndTransactionTimerFired&quot;);
1938     ASSERT(!m_hardClosedForUserDelete);
1939     ASSERT(isMainThread());
1940 
1941     // This UniqueIDBDatabase might be no longer in use by any web page.
1942     // Assuming it is not ephemeral, the server should now close it to free up resources.
1943     if (!m_backingStoreIsEphemeral &amp;&amp; !isCurrentlyInUse()) {
1944         ASSERT(m_pendingTransactions.isEmpty());
1945         ASSERT(!hasUnfinishedTransactions());
1946 
1947         scheduleShutdownForClose();
1948         return;
1949     }
1950 
1951     // The current operation might require multiple attempts to handle, so try to
1952     // make further progress on it now.
1953     if (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())
1954         handleCurrentOperation();
1955     else
1956         handleDatabaseOperations();
1957 
1958     bool hadDeferredTransactions = false;
1959     auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
1960 
1961     if (transaction) {
1962         m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
1963         for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1964             m_objectStoreTransactionCounts.add(objectStore);
1965             if (!transaction-&gt;isReadOnly()) {
1966                 m_objectStoreWriteTransactions.add(objectStore);
1967                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);
1968             }
1969         }
1970 
1971         activateTransactionInBackingStore(*transaction);
1972 
1973         // If no transactions were deferred, it&#39;s possible we can start another transaction right now.
1974         if (!hadDeferredTransactions)
1975             invokeOperationAndTransactionTimer();
1976     }
1977 }
1978 
1979 void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
1980 {
1981     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::activateTransactionInBackingStore&quot;);
1982     ASSERT(isMainThread());
1983 
1984     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; refTransaction(&amp;transaction);
1985 
1986     ErrorCallback callback = [refTransaction](const IDBError&amp; error) {
1987         refTransaction-&gt;didActivateInBackingStore(error);
1988     };
1989 
1990     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1991     if (!callbackID)
1992         return;
1993     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performActivateTransactionInBackingStore, callbackID, transaction.info()));
1994 }
1995 
1996 void UniqueIDBDatabase::performActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBTransactionInfo&amp; info)
1997 {
1998     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performActivateTransactionInBackingStore&quot;);
1999 
2000     IDBError error = m_backingStore-&gt;beginTransaction(info);
2001     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformActivateTransactionInBackingStore, callbackIdentifier, error));
2002 }
2003 
2004 void UniqueIDBDatabase::didPerformActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBError&amp; error)
2005 {
2006     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformActivateTransactionInBackingStore&quot;);
2007 
2008     if (m_hardClosedForUserDelete)
2009         return;
2010 
2011     invokeOperationAndTransactionTimer();
2012 
2013     performErrorCallback(callbackIdentifier, error);
2014 }
2015 
2016 template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
2017 {
2018     for (auto scope : bScopes) {
2019         if (aScopes.contains(scope))
2020             return true;
2021     }
2022 
2023     return false;
2024 }
2025 
2026 RefPtr&lt;UniqueIDBDatabaseTransaction&gt; UniqueIDBDatabase::takeNextRunnableTransaction(bool&amp; hadDeferredTransactions)
2027 {
2028     hadDeferredTransactions = false;
2029 
2030     if (m_pendingTransactions.isEmpty())
2031         return nullptr;
2032 
2033     if (!m_backingStoreSupportsSimultaneousTransactions &amp;&amp; hasUnfinishedTransactions()) {
2034         LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
2035         return nullptr;
2036     }
2037 
2038     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
2039     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; currentTransaction;
2040 
2041     HashSet&lt;uint64_t&gt; deferredReadWriteScopes;
2042 
2043     while (!m_pendingTransactions.isEmpty()) {
2044         currentTransaction = m_pendingTransactions.takeFirst();
2045 
2046         switch (currentTransaction-&gt;info().mode()) {
2047         case IDBTransactionMode::Readonly: {
2048             bool hasOverlappingScopes = scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
2049             hasOverlappingScopes |= scopesOverlap(m_objectStoreWriteTransactions, currentTransaction-&gt;objectStoreIdentifiers());
2050 
2051             if (hasOverlappingScopes)
2052                 deferredTransactions.append(WTFMove(currentTransaction));
2053 
2054             break;
2055         }
2056         case IDBTransactionMode::Readwrite: {
2057             bool hasOverlappingScopes = scopesOverlap(m_objectStoreTransactionCounts, currentTransaction-&gt;objectStoreIdentifiers());
2058             hasOverlappingScopes |= scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
2059 
2060             if (hasOverlappingScopes) {
2061                 for (auto objectStore : currentTransaction-&gt;objectStoreIdentifiers())
2062                     deferredReadWriteScopes.add(objectStore);
2063                 deferredTransactions.append(WTFMove(currentTransaction));
2064             }
2065 
2066             break;
2067         }
2068         case IDBTransactionMode::Versionchange:
2069             // Version change transactions should never be scheduled in the traditional manner.
2070             RELEASE_ASSERT_NOT_REACHED();
2071         }
2072 
2073         // If we didn&#39;t defer the currentTransaction above, it can be run now.
2074         if (currentTransaction)
2075             break;
2076     }
2077 
2078     hadDeferredTransactions = !deferredTransactions.isEmpty();
2079     if (!hadDeferredTransactions)
2080         return currentTransaction;
2081 
2082     // Prepend the deferred transactions back on the beginning of the deque for future scheduling passes.
2083     while (!deferredTransactions.isEmpty())
2084         m_pendingTransactions.prepend(deferredTransactions.takeLast());
2085 
2086     return currentTransaction;
2087 }
2088 
2089 void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
2090 {
2091     ASSERT(transaction);
2092     ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
2093     ASSERT(!m_finishingTransactions.contains(transaction-&gt;info().identifier()));
2094     ASSERT(isMainThread());
2095 
2096     for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
2097         if (!transaction-&gt;isReadOnly()) {
2098             m_objectStoreWriteTransactions.remove(objectStore);
2099             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);
2100         }
2101         m_objectStoreTransactionCounts.remove(objectStore);
2102     }
2103 
2104     if (!transaction-&gt;databaseConnection().hasNonFinishedTransactions())
2105         m_clientClosePendingDatabaseConnections.remove(&amp;transaction-&gt;databaseConnection());
2106 
2107     if (m_versionChangeTransaction == transaction)
2108         m_versionChangeTransaction = nullptr;
2109 
2110     // It&#39;s possible that this database had its backing store deleted but there were a few outstanding asynchronous operations.
2111     // If this transaction completing was the last of those operations, we can finally delete this UniqueIDBDatabase.
2112     if (m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_pendingOpenDBRequests.isEmpty() &amp;&amp; !m_databaseInfo) {
2113         scheduleShutdownForClose();
2114         return;
2115     }
2116 
2117     // Previously blocked operations might be runnable.
2118     if (!m_hardClosedForUserDelete)
2119         invokeOperationAndTransactionTimer();
2120     else
2121         maybeFinishHardClose();
2122 }
2123 
2124 void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)
2125 {
2126     m_databaseQueue.append(WTFMove(task));
2127     m_server-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));
2128 }
2129 
2130 void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
2131 {
2132     if (m_backingStore)
2133         m_newDatabaseSize = m_backingStore-&gt;databaseSize();
2134 
2135     m_databaseReplyQueue.append(WTFMove(task));
2136     m_server-&gt;postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));
2137 }
2138 
2139 void UniqueIDBDatabase::executeNextDatabaseTask()
2140 {
2141     ASSERT(!isMainThread());
2142     ASSERT(!m_databaseQueue.isKilled());
2143 
2144     auto task = m_databaseQueue.tryGetMessage();
2145     ASSERT(task);
2146 
2147     task-&gt;performTask();
2148 }
2149 
2150 void UniqueIDBDatabase::executeNextDatabaseTaskReply()
2151 {
2152     ASSERT(isMainThread());
2153     ASSERT(!m_databaseReplyQueue.isKilled());
2154 
2155     auto task = m_databaseReplyQueue.tryGetMessage();
2156     ASSERT(task);
2157 
2158     task-&gt;performTask();
2159 
2160     // If this database was force closed (e.g. for a user delete) and there are no more
2161     // cleanup tasks left, delete this.
2162     maybeFinishHardClose();
2163 }
2164 
2165 void UniqueIDBDatabase::maybeFinishHardClose()
2166 {
2167     if (m_owningPointerForClose &amp;&amp; isDoneWithHardClose()) {
2168         if (m_owningPointerReleaseScheduled)
2169             return;
2170         m_owningPointerReleaseScheduled = true;
2171 
2172         callOnMainThread([this] {
2173             ASSERT(isDoneWithHardClose());
2174             m_owningPointerForClose = nullptr;
2175         });
2176     }
2177 }
2178 
2179 bool UniqueIDBDatabase::isDoneWithHardClose()
2180 {
2181     return m_databaseReplyQueue.isKilled() &amp;&amp; m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_serverClosePendingDatabaseConnections.isEmpty();
2182 }
2183 
2184 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
2185 {
2186     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
2187     if (request.isOpenRequest())
2188         request.connection().didOpenDatabase(result);
2189     else
2190         request.connection().didDeleteDatabase(result);
2191 }
2192 
2193 void UniqueIDBDatabase::immediateCloseForUserDelete()
2194 {
2195     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());
2196 
2197     ASSERT(isMainThread());
2198 
2199     m_pendingSpaceIncreasingTasks.clear();
2200     m_server-&gt;resetSpaceUsed(m_identifier.origin());
2201 
2202     // Error out all transactions
2203     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
2204         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
2205 
2206     ASSERT(m_inProgressTransactions.isEmpty());
2207 
2208     for (auto&amp; transaction : m_pendingTransactions)
2209         transaction-&gt;databaseConnection().deleteTransaction(*transaction);
2210     m_pendingTransactions.clear();
2211     m_objectStoreTransactionCounts.clear();
2212     m_objectStoreWriteTransactions.clear();
2213 
2214     // Error out all pending callbacks
2215     IDBError error = IDBError::userDeleteError();
2216     IDBKeyData keyData;
2217     IDBGetResult getResult;
2218     IDBGetAllResult getAllResult;
2219 
2220     while (!m_callbackQueue.isEmpty()) {
2221         auto identifier = m_callbackQueue.first();
2222         if (m_errorCallbacks.contains(identifier))
2223             performErrorCallback(identifier, error);
2224         else if (m_keyDataCallbacks.contains(identifier))
2225             performKeyDataCallback(identifier, error, keyData);
2226         else if (m_getResultCallbacks.contains(identifier))
2227             performGetResultCallback(identifier, error, getResult);
2228         else if (m_countCallbacks.contains(identifier))
2229             performCountCallback(identifier, error, 0);
2230         else if (m_getAllResultsCallbacks.contains(identifier))
2231             performGetAllResultsCallback(identifier, error, getAllResult);
2232         else
2233             ASSERT_NOT_REACHED();
2234     }
2235 
2236     // Error out all IDBOpenDBRequests
2237     if (m_currentOpenDBRequest) {
2238         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
2239         m_currentOpenDBRequest = nullptr;
2240     }
2241 
2242     for (auto&amp; request : m_pendingOpenDBRequests)
2243         errorOpenDBRequestForUserDelete(*request);
2244 
2245     m_pendingOpenDBRequests.clear();
2246 
2247     // Close all open connections
2248     auto openDatabaseConnections = m_openDatabaseConnections;
2249     for (auto&amp; connection : openDatabaseConnections)
2250         connectionClosedFromServer(*connection);
2251 
2252     if (m_versionChangeDatabaseConnection) {
2253         connectionClosedFromServer(*m_versionChangeDatabaseConnection);
2254         m_versionChangeDatabaseConnection = nullptr;
2255     }
2256 
2257     // Cancel the operation timer
2258     m_operationAndTransactionTimer.stop();
2259 
2260     // Set up the database to remain alive-but-inert until all of its background activity finishes and all
2261     // database connections confirm that they have closed.
2262     m_hardClosedForUserDelete = true;
2263 
2264     // If this database already owns itself, it is already closing on the background thread.
2265     // After that close completes, the next database thread task will be &quot;delete all currently closed databases&quot;
2266     // which will also cover this database.
2267     if (m_owningPointerForClose)
2268         return;
2269 
2270     // Otherwise, this database is still potentially active.
2271     // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.
2272     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);
2273     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));
2274 }
2275 
2276 void UniqueIDBDatabase::updateSpaceUsedIfNeeded(Optional&lt;uint64_t&gt; optionalCallbackIdentifier)
2277 {
2278     ASSERT(isMainThread());
2279 
2280     if (optionalCallbackIdentifier) {
2281         uint64_t callbackIdentifier = optionalCallbackIdentifier.value();
2282         auto iterator = m_pendingSpaceIncreasingTasks.find(callbackIdentifier);
2283         if (iterator != m_pendingSpaceIncreasingTasks.end()) {
2284             m_server-&gt;decreasePotentialSpaceUsed(m_identifier.origin(), iterator-&gt;value);
2285             m_pendingSpaceIncreasingTasks.remove(iterator);
2286         }
2287     }
2288 
2289     uint64_t databaseSize = m_newDatabaseSize;
2290     if (databaseSize != m_currentDatabaseSize) {
2291         if (databaseSize &gt; m_currentDatabaseSize)
2292             m_server-&gt;increaseSpaceUsed(m_identifier.origin(), databaseSize - m_currentDatabaseSize);
2293         else
2294             m_server-&gt;decreaseSpaceUsed(m_identifier.origin(), m_currentDatabaseSize - databaseSize);
2295         m_currentDatabaseSize = databaseSize;
2296     }
2297 }
2298 
2299 void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)
2300 {
2301     updateSpaceUsedIfNeeded(callbackIdentifier);
2302 
2303     auto callback = m_errorCallbacks.take(callbackIdentifier);
2304     ASSERT(callback || m_hardClosedForUserDelete);
2305     if (callback) {
2306         callback(error);
2307         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2308         m_callbackQueue.removeFirst();
2309     }
2310 }
2311 
2312 void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
2313 {
2314     updateSpaceUsedIfNeeded(callbackIdentifier);
2315 
2316     auto callback = m_keyDataCallbacks.take(callbackIdentifier);
2317     ASSERT(callback || m_hardClosedForUserDelete);
2318     if (callback) {
2319         callback(error, resultKey);
2320         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2321         m_callbackQueue.removeFirst();
2322     }
2323 }
2324 
2325 void UniqueIDBDatabase::performGetResultCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; resultData)
2326 {
2327     auto callback = m_getResultCallbacks.take(callbackIdentifier);
2328     ASSERT(callback || m_hardClosedForUserDelete);
2329     if (callback) {
2330         callback(error, resultData);
2331         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2332         m_callbackQueue.removeFirst();
2333     }
2334 }
2335 
2336 void UniqueIDBDatabase::performGetAllResultsCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; resultData)
2337 {
2338     auto callback = m_getAllResultsCallbacks.take(callbackIdentifier);
2339     ASSERT(callback || m_hardClosedForUserDelete);
2340     if (callback) {
2341         callback(error, resultData);
2342         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2343         m_callbackQueue.removeFirst();
2344     }
2345 }
2346 
2347 void UniqueIDBDatabase::performCountCallback(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
2348 {
2349     auto callback = m_countCallbacks.take(callbackIdentifier);
2350     ASSERT(callback || m_hardClosedForUserDelete);
2351     if (callback) {
2352         callback(error, count);
2353         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2354         m_callbackQueue.removeFirst();
2355     }
2356 }
2357 
2358 void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)
2359 {
2360     updateSpaceUsedIfNeeded(callbackIdentifier);
2361 
2362     ASSERT(m_errorCallbacks.contains(callbackIdentifier));
2363     ASSERT(m_callbackQueue.last() == callbackIdentifier);
2364     m_callbackQueue.removeLast();
2365     m_errorCallbacks.remove(callbackIdentifier);
2366 }
2367 
2368 void UniqueIDBDatabase::abortTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)
2369 {
2370     transaction.setResult(m_backingStore-&gt;abortTransaction(transaction.info().identifier()));
2371     transaction.setState(UniqueIDBDatabaseTransaction::State::Aborted);
2372 }
2373 
2374 void UniqueIDBDatabase::commitTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)
2375 {
2376     transaction.setResult(m_backingStore-&gt;commitTransaction(transaction.info().identifier()));
2377     transaction.setState(UniqueIDBDatabaseTransaction::State::Committed);
2378 }
2379 
2380 void UniqueIDBDatabase::finishActiveTransactions()
2381 {
2382     ASSERT(isMainThread());
2383 
2384     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {
2385         auto transaction = m_inProgressTransactions.get(identifier);
2386         abortTransactionOnMainThread(*transaction);
2387     }
2388 
2389     for (auto&amp; identifier : copyToVector(m_finishingTransactions.keys())) {
2390         if (!m_backingStore-&gt;hasTransaction(identifier))
2391             continue;
2392 
2393         auto transaction = m_finishingTransactions.get(identifier);
2394         switch (transaction-&gt;state()) {
2395         case UniqueIDBDatabaseTransaction::State::Aborting:
2396             abortTransactionOnMainThread(*transaction);
2397             break;
2398         case UniqueIDBDatabaseTransaction::State::Committing:
2399             commitTransactionOnMainThread(*transaction);
2400             break;
2401         case UniqueIDBDatabaseTransaction::State::Running:
2402         case UniqueIDBDatabaseTransaction::State::Aborted:
2403         case UniqueIDBDatabaseTransaction::State::Committed:
2404             ASSERT_NOT_REACHED();
2405         }
2406     }
2407 }
2408 
2409 } // namespace IDBServer
2410 } // namespace WebCore
2411 
2412 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>