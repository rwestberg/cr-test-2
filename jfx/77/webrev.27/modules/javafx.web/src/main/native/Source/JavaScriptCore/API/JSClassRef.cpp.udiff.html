<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSClassRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCallbackObjectFunctions.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSClassRef.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -33,14 +33,12 @@</span>
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;JSObjectRef.h&quot;
  #include &quot;ObjectPrototype.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &lt;wtf/text/StringHash.h&gt;
<span class="udiff-line-removed">- #include &lt;wtf/unicode/UTF8Conversion.h&gt;</span>
  
  using namespace JSC;
<span class="udiff-line-removed">- using namespace WTF::Unicode;</span>
  
  const JSClassDefinition kJSClassDefinitionEmpty = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  
  OpaqueJSClass::OpaqueJSClass(const JSClassDefinition* definition, OpaqueJSClass* protoClass)
      : parentClass(definition-&gt;parentClass)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59,25 +57,25 @@</span>
      , m_className(String::fromUTF8(definition-&gt;className))
  {
      initializeThreading();
  
      if (const JSStaticValue* staticValue = definition-&gt;staticValues) {
<span class="udiff-line-modified-removed">-         m_staticValues = std::make_unique&lt;OpaqueJSClassStaticValuesTable&gt;();</span>
<span class="udiff-line-modified-added">+         m_staticValues = makeUnique&lt;OpaqueJSClassStaticValuesTable&gt;();</span>
          while (staticValue-&gt;name) {
              String valueName = String::fromUTF8(staticValue-&gt;name);
              if (!valueName.isNull())
<span class="udiff-line-modified-removed">-                 m_staticValues-&gt;set(valueName.impl(), std::make_unique&lt;StaticValueEntry&gt;(staticValue-&gt;getProperty, staticValue-&gt;setProperty, staticValue-&gt;attributes, valueName));</span>
<span class="udiff-line-modified-added">+                 m_staticValues-&gt;set(valueName.impl(), makeUnique&lt;StaticValueEntry&gt;(staticValue-&gt;getProperty, staticValue-&gt;setProperty, staticValue-&gt;attributes, valueName));</span>
              ++staticValue;
          }
      }
  
      if (const JSStaticFunction* staticFunction = definition-&gt;staticFunctions) {
<span class="udiff-line-modified-removed">-         m_staticFunctions = std::make_unique&lt;OpaqueJSClassStaticFunctionsTable&gt;();</span>
<span class="udiff-line-modified-added">+         m_staticFunctions = makeUnique&lt;OpaqueJSClassStaticFunctionsTable&gt;();</span>
          while (staticFunction-&gt;name) {
              String functionName = String::fromUTF8(staticFunction-&gt;name);
              if (!functionName.isNull())
<span class="udiff-line-modified-removed">-                 m_staticFunctions-&gt;set(functionName.impl(), std::make_unique&lt;StaticFunctionEntry&gt;(staticFunction-&gt;callAsFunction, staticFunction-&gt;attributes));</span>
<span class="udiff-line-modified-added">+                 m_staticFunctions-&gt;set(functionName.impl(), makeUnique&lt;StaticFunctionEntry&gt;(staticFunction-&gt;callAsFunction, staticFunction-&gt;attributes));</span>
              ++staticFunction;
          }
      }
  
      if (protoClass)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -85,23 +83,23 @@</span>
  }
  
  OpaqueJSClass::~OpaqueJSClass()
  {
      // The empty string is shared across threads &amp; is an identifier, in all other cases we should have done a deep copy in className(), below.
<span class="udiff-line-modified-removed">-     ASSERT(!m_className.length() || !m_className.impl()-&gt;isAtomic());</span>
<span class="udiff-line-modified-added">+     ASSERT(!m_className.length() || !m_className.impl()-&gt;isAtom());</span>
  
  #ifndef NDEBUG
      if (m_staticValues) {
          OpaqueJSClassStaticValuesTable::const_iterator end = m_staticValues-&gt;end();
          for (OpaqueJSClassStaticValuesTable::const_iterator it = m_staticValues-&gt;begin(); it != end; ++it)
<span class="udiff-line-modified-removed">-             ASSERT(!it-&gt;key-&gt;isAtomic());</span>
<span class="udiff-line-modified-added">+             ASSERT(!it-&gt;key-&gt;isAtom());</span>
      }
  
      if (m_staticFunctions) {
          OpaqueJSClassStaticFunctionsTable::const_iterator end = m_staticFunctions-&gt;end();
          for (OpaqueJSClassStaticFunctionsTable::const_iterator it = m_staticFunctions-&gt;begin(); it != end; ++it)
<span class="udiff-line-modified-removed">-             ASSERT(!it-&gt;key-&gt;isAtomic());</span>
<span class="udiff-line-modified-added">+             ASSERT(!it-&gt;key-&gt;isAtom());</span>
      }
  #endif
  
      if (prototypeClass)
          JSClassRelease(prototypeClass);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -128,40 +126,40 @@</span>
  
  OpaqueJSClassContextData::OpaqueJSClassContextData(JSC::VM&amp;, OpaqueJSClass* jsClass)
      : m_class(jsClass)
  {
      if (jsClass-&gt;m_staticValues) {
<span class="udiff-line-modified-removed">-         staticValues = std::make_unique&lt;OpaqueJSClassStaticValuesTable&gt;();</span>
<span class="udiff-line-modified-added">+         staticValues = makeUnique&lt;OpaqueJSClassStaticValuesTable&gt;();</span>
          OpaqueJSClassStaticValuesTable::const_iterator end = jsClass-&gt;m_staticValues-&gt;end();
          for (OpaqueJSClassStaticValuesTable::const_iterator it = jsClass-&gt;m_staticValues-&gt;begin(); it != end; ++it) {
<span class="udiff-line-modified-removed">-             ASSERT(!it-&gt;key-&gt;isAtomic());</span>
<span class="udiff-line-modified-added">+             ASSERT(!it-&gt;key-&gt;isAtom());</span>
              String valueName = it-&gt;key-&gt;isolatedCopy();
<span class="udiff-line-modified-removed">-             staticValues-&gt;add(valueName.impl(), std::make_unique&lt;StaticValueEntry&gt;(it-&gt;value-&gt;getProperty, it-&gt;value-&gt;setProperty, it-&gt;value-&gt;attributes, valueName));</span>
<span class="udiff-line-modified-added">+             staticValues-&gt;add(valueName.impl(), makeUnique&lt;StaticValueEntry&gt;(it-&gt;value-&gt;getProperty, it-&gt;value-&gt;setProperty, it-&gt;value-&gt;attributes, valueName));</span>
          }
      }
  
      if (jsClass-&gt;m_staticFunctions) {
<span class="udiff-line-modified-removed">-         staticFunctions = std::make_unique&lt;OpaqueJSClassStaticFunctionsTable&gt;();</span>
<span class="udiff-line-modified-added">+         staticFunctions = makeUnique&lt;OpaqueJSClassStaticFunctionsTable&gt;();</span>
          OpaqueJSClassStaticFunctionsTable::const_iterator end = jsClass-&gt;m_staticFunctions-&gt;end();
          for (OpaqueJSClassStaticFunctionsTable::const_iterator it = jsClass-&gt;m_staticFunctions-&gt;begin(); it != end; ++it) {
<span class="udiff-line-modified-removed">-             ASSERT(!it-&gt;key-&gt;isAtomic());</span>
<span class="udiff-line-modified-removed">-             staticFunctions-&gt;add(it-&gt;key-&gt;isolatedCopy(), std::make_unique&lt;StaticFunctionEntry&gt;(it-&gt;value-&gt;callAsFunction, it-&gt;value-&gt;attributes));</span>
<span class="udiff-line-modified-added">+             ASSERT(!it-&gt;key-&gt;isAtom());</span>
<span class="udiff-line-modified-added">+             staticFunctions-&gt;add(it-&gt;key-&gt;isolatedCopy(), makeUnique&lt;StaticFunctionEntry&gt;(it-&gt;value-&gt;callAsFunction, it-&gt;value-&gt;attributes));</span>
          }
      }
  }
  
  OpaqueJSClassContextData&amp; OpaqueJSClass::contextData(ExecState* exec)
  {
      std::unique_ptr&lt;OpaqueJSClassContextData&gt;&amp; contextData = exec-&gt;lexicalGlobalObject()-&gt;opaqueJSClassData().add(this, nullptr).iterator-&gt;value;
      if (!contextData)
<span class="udiff-line-modified-removed">-         contextData = std::make_unique&lt;OpaqueJSClassContextData&gt;(exec-&gt;vm(), this);</span>
<span class="udiff-line-modified-added">+         contextData = makeUnique&lt;OpaqueJSClassContextData&gt;(exec-&gt;vm(), this);</span>
      return *contextData;
  }
  
  String OpaqueJSClass::className()
  {
<span class="udiff-line-modified-removed">-     // Make a deep copy, so that the caller has no chance to put the original into AtomicStringTable.</span>
<span class="udiff-line-modified-added">+     // Make a deep copy, so that the caller has no chance to put the original into AtomStringTable.</span>
      return m_className.isolatedCopy();
  }
  
  OpaqueJSClassStaticValuesTable* OpaqueJSClass::staticValues(JSC::ExecState* exec)
  {
</pre>
<center><a href="JSCallbackObjectFunctions.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>