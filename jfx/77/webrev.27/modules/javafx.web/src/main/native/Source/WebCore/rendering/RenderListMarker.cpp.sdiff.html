<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderListMarker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderListBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderMarquee.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderListMarker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
<span class="line-modified">   4  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.</span>
   5  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   6  * Copyright (C) 2010 Daniel Bates (dbates@intudata.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderListMarker.h&quot;
  27 
  28 #include &quot;Document.h&quot;
  29 #include &quot;FontCascade.h&quot;
  30 #include &quot;GraphicsContext.h&quot;
  31 #include &quot;InlineElementBox.h&quot;
  32 #include &quot;RenderLayer.h&quot;
  33 #include &quot;RenderListItem.h&quot;
  34 #include &quot;RenderView.h&quot;
  35 #include &lt;wtf/IsoMallocInlines.h&gt;
  36 #include &lt;wtf/StackStats.h&gt;
<span class="line-modified">  37 #include &lt;wtf/text/StringBuilder.h&gt;</span>
  38 #include &lt;wtf/unicode/CharacterNames.h&gt;
  39 
  40 namespace WebCore {
  41 
  42 using namespace WTF::Unicode;
  43 
  44 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderListMarker);
  45 
  46 const int cMarkerPadding = 7;
  47 
<span class="line-modified">  48 enum SequenceType { NumericSequence, AlphabeticSequence };</span>

  49 
<span class="line-modified">  50 static NEVER_INLINE void toRoman(StringBuilder&amp; builder, int number, bool upper)</span>
  51 {
  52     // FIXME: CSS3 describes how to make this work for much larger numbers,
  53     // using overbars and special characters. It also specifies the characters
  54     // in the range U+2160 to U+217F instead of standard ASCII ones.
  55     ASSERT(number &gt;= 1 &amp;&amp; number &lt;= 3999);
  56 
  57     // Big enough to store largest roman number less than 3999 which
  58     // is 3888 (MMMDCCCLXXXVIII)
<span class="line-modified">  59     const int lettersSize = 15;</span>
  60     LChar letters[lettersSize];
  61 
<span class="line-modified">  62     int length = 0;</span>
  63     const LChar ldigits[] = { &#39;i&#39;, &#39;v&#39;, &#39;x&#39;, &#39;l&#39;, &#39;c&#39;, &#39;d&#39;, &#39;m&#39; };
  64     const LChar udigits[] = { &#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39; };
<span class="line-modified">  65     const LChar* digits = upper ? udigits : ldigits;</span>
  66     int d = 0;
  67     do {
  68         int num = number % 10;
  69         if (num % 5 &lt; 4)
  70             for (int i = num % 5; i &gt; 0; i--)
  71                 letters[lettersSize - ++length] = digits[d];
  72         if (num &gt;= 4 &amp;&amp; num &lt;= 8)
  73             letters[lettersSize - ++length] = digits[d + 1];
  74         if (num == 9)
  75             letters[lettersSize - ++length] = digits[d + 2];
  76         if (num % 5 == 4)
  77             letters[lettersSize - ++length] = digits[d];
  78         number /= 10;
  79         d += 2;
  80     } while (number);
  81 
  82     ASSERT(length &lt;= lettersSize);
<span class="line-modified">  83     builder.append(&amp;letters[lettersSize - length], length);</span>
  84 }
  85 
<span class="line-modified">  86 template &lt;typename CharacterType&gt;</span>
<span class="line-modified">  87 static inline void toAlphabeticOrNumeric(StringBuilder&amp; builder, int number, const CharacterType* sequence, unsigned sequenceSize, SequenceType type)</span>
  88 {
  89     ASSERT(sequenceSize &gt;= 2);
  90 
  91     // Taking sizeof(number) in the expression below doesn&#39;t work with some compilers.
<span class="line-modified">  92     const int lettersSize = sizeof(int) * 8 + 1; // Binary is the worst case; requires one character per bit plus a minus sign.</span>
  93 
  94     CharacterType letters[lettersSize];
  95 
  96     bool isNegativeNumber = false;
  97     unsigned numberShadow = number;
<span class="line-modified">  98     if (type == AlphabeticSequence) {</span>
  99         ASSERT(number &gt; 0);
 100         --numberShadow;
 101     } else if (number &lt; 0) {
 102         numberShadow = -number;
 103         isNegativeNumber = true;
 104     }
 105     letters[lettersSize - 1] = sequence[numberShadow % sequenceSize];
<span class="line-modified"> 106     int length = 1;</span>
 107 
<span class="line-modified"> 108     if (type == AlphabeticSequence) {</span>
 109         while ((numberShadow /= sequenceSize) &gt; 0) {
 110             --numberShadow;
 111             letters[lettersSize - ++length] = sequence[numberShadow % sequenceSize];
 112         }
 113     } else {
 114         while ((numberShadow /= sequenceSize) &gt; 0)
 115             letters[lettersSize - ++length] = sequence[numberShadow % sequenceSize];
 116     }
 117     if (isNegativeNumber)
 118         letters[lettersSize - ++length] = hyphenMinus;
 119 
 120     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 121     builder.append(&amp;letters[lettersSize - length], length);</span>
 122 }
 123 
<span class="line-modified"> 124 template &lt;typename CharacterType&gt;</span>
<span class="line-modified"> 125 static NEVER_INLINE void toSymbolic(StringBuilder&amp; builder, int number, const CharacterType* symbols, unsigned symbolsSize)</span>
 126 {
 127     ASSERT(number &gt; 0);
 128     ASSERT(symbolsSize &gt;= 1);
<span class="line-removed"> 129     unsigned numberShadow = number;</span>
<span class="line-removed"> 130     --numberShadow;</span>
 131 
<span class="line-modified"> 132     // The asterisks list-style-type is the worst case; we show |numberShadow| asterisks.</span>
<span class="line-modified"> 133     builder.append(symbols[numberShadow % symbolsSize]);</span>
<span class="line-modified"> 134     unsigned numSymbols = numberShadow / symbolsSize;</span>
<span class="line-modified"> 135     while (numSymbols--)</span>
<span class="line-modified"> 136         builder.append(symbols[numberShadow % symbolsSize]);</span>




 137 }
 138 
<span class="line-modified"> 139 template &lt;typename CharacterType&gt;</span>
<span class="line-modified"> 140 static NEVER_INLINE void toAlphabetic(StringBuilder&amp; builder, int number, const CharacterType* alphabet, unsigned alphabetSize)</span>
 141 {
<span class="line-modified"> 142     toAlphabeticOrNumeric(builder, number, alphabet, alphabetSize, AlphabeticSequence);</span>
 143 }
 144 
<span class="line-modified"> 145 template &lt;typename CharacterType&gt;</span>
<span class="line-modified"> 146 static NEVER_INLINE void toNumeric(StringBuilder&amp; builder, int number, const CharacterType* numerals, unsigned numeralsSize)</span>
 147 {
<span class="line-modified"> 148     toAlphabeticOrNumeric(builder, number, numerals, numeralsSize, NumericSequence);</span>
 149 }
 150 
<span class="line-modified"> 151 template &lt;typename CharacterType, size_t size&gt;</span>
<span class="line-modified"> 152 static inline void toAlphabetic(StringBuilder&amp; builder, int number, const CharacterType(&amp;alphabet)[size])</span>
 153 {
<span class="line-modified"> 154     toAlphabetic(builder, number, alphabet, size);</span>
 155 }
 156 
<span class="line-modified"> 157 template &lt;typename CharacterType, size_t size&gt;</span>
<span class="line-modified"> 158 static inline void toNumeric(StringBuilder&amp; builder, int number, const CharacterType(&amp;alphabet)[size])</span>
 159 {
<span class="line-modified"> 160     toNumeric(builder, number, alphabet, size);</span>
 161 }
 162 
<span class="line-modified"> 163 template &lt;typename CharacterType, size_t size&gt;</span>
<span class="line-modified"> 164 static inline void toSymbolic(StringBuilder&amp; builder, int number, const CharacterType(&amp;alphabet)[size])</span>
 165 {
<span class="line-modified"> 166     toSymbolic(builder, number, alphabet, size);</span>
 167 }
 168 
 169 static NEVER_INLINE int toHebrewUnder1000(int number, UChar letters[5])
 170 {
 171     // FIXME: CSS3 mentions various refinements not implemented here.
 172     // FIXME: Should take a look at Mozilla&#39;s HebrewToText function (in nsBulletFrame).
 173     ASSERT(number &gt;= 0 &amp;&amp; number &lt; 1000);
 174     int length = 0;
 175     int fourHundreds = number / 400;
 176     for (int i = 0; i &lt; fourHundreds; i++)
 177         letters[length++] = 1511 + 3;
 178     number %= 400;
 179     if (number / 100)
 180         letters[length++] = 1511 + (number / 100) - 1;
 181     number %= 100;
 182     if (number == 15 || number == 16) {
 183         letters[length++] = 1487 + 9;
 184         letters[length++] = 1487 + number - 9;
 185     } else {
 186         if (int tens = number / 10) {
 187             static const UChar hebrewTens[9] = { 1497, 1499, 1500, 1502, 1504, 1505, 1506, 1508, 1510 };
 188             letters[length++] = hebrewTens[tens - 1];
 189         }
 190         if (int ones = number % 10)
 191             letters[length++] = 1487 + ones;
 192     }
 193     ASSERT(length &lt;= 5);
 194     return length;
 195 }
 196 
<span class="line-modified"> 197 static NEVER_INLINE void toHebrew(StringBuilder&amp; builder, int number)</span>
 198 {
 199     // FIXME: CSS3 mentions ways to make this work for much larger numbers.
 200     ASSERT(number &gt;= 0 &amp;&amp; number &lt;= 999999);
 201 
 202     if (number == 0) {
 203         static const UChar hebrewZero[3] = { 0x05D0, 0x05E4, 0x05E1 };
<span class="line-modified"> 204         builder.append(hebrewZero, 3);</span>
<span class="line-removed"> 205         return;</span>
 206     }
 207 
<span class="line-modified"> 208     const int lettersSize = 11; // big enough for two 5-digit sequences plus a quote mark between</span>
 209     UChar letters[lettersSize];
 210 
<span class="line-modified"> 211     int length;</span>
 212     if (number &lt; 1000)
 213         length = 0;
 214     else {
 215         length = toHebrewUnder1000(number / 1000, letters);
 216         letters[length++] = &#39;\&#39;&#39;;
 217         number = number % 1000;
 218     }
 219     length += toHebrewUnder1000(number, letters + length);
 220 
 221     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 222     builder.append(letters, length);</span>
 223 }
 224 
<span class="line-modified"> 225 static NEVER_INLINE int toArmenianUnder10000(int number, bool upper, bool addCircumflex, UChar letters[9])</span>
 226 {
 227     ASSERT(number &gt;= 0 &amp;&amp; number &lt; 10000);
<span class="line-modified"> 228     int length = 0;</span>
 229 
<span class="line-modified"> 230     int lowerOffset = upper ? 0 : 0x0030;</span>
 231 
 232     if (int thousands = number / 1000) {
 233         if (thousands == 7) {
 234             letters[length++] = 0x0552 + lowerOffset;
 235             if (addCircumflex)
 236                 letters[length++] = 0x0302;
 237         } else {
 238             letters[length++] = (0x054C - 1 + lowerOffset) + thousands;
 239             if (addCircumflex)
 240                 letters[length++] = 0x0302;
 241         }
 242     }
 243 
 244     if (int hundreds = (number / 100) % 10) {
 245         letters[length++] = (0x0543 - 1 + lowerOffset) + hundreds;
 246         if (addCircumflex)
 247             letters[length++] = 0x0302;
 248     }
 249 
 250     if (int tens = (number / 10) % 10) {
 251         letters[length++] = (0x053A - 1 + lowerOffset) + tens;
 252         if (addCircumflex)
 253             letters[length++] = 0x0302;
 254     }
 255 
 256     if (int ones = number % 10) {
 257         letters[length++] = (0x531 - 1 + lowerOffset) + ones;
 258         if (addCircumflex)
 259             letters[length++] = 0x0302;
 260     }
 261 
 262     return length;
 263 }
 264 
<span class="line-modified"> 265 static NEVER_INLINE void toArmenian(StringBuilder&amp; builder, int number, bool upper)</span>
 266 {
 267     ASSERT(number &gt;= 1 &amp;&amp; number &lt;= 99999999);
 268 
<span class="line-modified"> 269     const int lettersSize = 18; // twice what toArmenianUnder10000 needs</span>
 270     UChar letters[lettersSize];
 271 
<span class="line-modified"> 272     int length = toArmenianUnder10000(number / 10000, upper, true, letters);</span>
<span class="line-modified"> 273     length += toArmenianUnder10000(number % 10000, upper, false, letters + length);</span>
 274 
 275     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 276     builder.append(letters, length);</span>
 277 }
 278 
<span class="line-modified"> 279 static NEVER_INLINE void toGeorgian(StringBuilder&amp; builder, int number)</span>
 280 {
 281     ASSERT(number &gt;= 1 &amp;&amp; number &lt;= 19999);
 282 
<span class="line-modified"> 283     const int lettersSize = 5;</span>
 284     UChar letters[lettersSize];
 285 
<span class="line-modified"> 286     int length = 0;</span>
 287 
 288     if (number &gt; 9999)
 289         letters[length++] = 0x10F5;
 290 
 291     if (int thousands = (number / 1000) % 10) {
 292         static const UChar georgianThousands[9] = {
 293             0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10F4, 0x10EF, 0x10F0
 294         };
 295         letters[length++] = georgianThousands[thousands - 1];
 296     }
 297 
 298     if (int hundreds = (number / 100) % 10) {
 299         static const UChar georgianHundreds[9] = {
 300             0x10E0, 0x10E1, 0x10E2, 0x10F3, 0x10E4, 0x10E5, 0x10E6, 0x10E7, 0x10E8
 301         };
 302         letters[length++] = georgianHundreds[hundreds - 1];
 303     }
 304 
 305     if (int tens = (number / 10) % 10) {
 306         static const UChar georgianTens[9] = {
 307             0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10F2, 0x10DD, 0x10DE, 0x10DF
 308         };
 309         letters[length++] = georgianTens[tens - 1];
 310     }
 311 
 312     if (int ones = number % 10) {
 313         static const UChar georgianOnes[9] = {
 314             0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6, 0x10F1, 0x10D7
 315         };
 316         letters[length++] = georgianOnes[ones - 1];
 317     }
 318 
 319     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 320     builder.append(letters, length);</span>
 321 }
 322 
 323 // The table uses the order from the CSS3 specification:
 324 // first 3 group markers, then 3 digit markers, then ten digits.
<span class="line-modified"> 325 static NEVER_INLINE void toCJKIdeographic(StringBuilder&amp; builder, int number, const UChar table[16])</span>
 326 {
 327     ASSERT(number &gt;= 0);
 328 
 329     enum AbstractCJKChar {
 330         noChar,
 331         secondGroupMarker, thirdGroupMarker, fourthGroupMarker,
 332         secondDigitMarker, thirdDigitMarker, fourthDigitMarker,
 333         digit0, digit1, digit2, digit3, digit4,
 334         digit5, digit6, digit7, digit8, digit9
 335     };
 336 
<span class="line-modified"> 337     if (number == 0) {</span>
<span class="line-modified"> 338         builder.append(table[digit0 - 1]);</span>
<span class="line-removed"> 339         return;</span>
<span class="line-removed"> 340     }</span>
 341 
<span class="line-modified"> 342     const int groupLength = 8; // 4 digits, 3 digit markers, and a group marker</span>
<span class="line-modified"> 343     const int bufferLength = 4 * groupLength;</span>
 344     AbstractCJKChar buffer[bufferLength] = { noChar };
 345 
 346     for (int i = 0; i &lt; 4; ++i) {
 347         int groupValue = number % 10000;
 348         number /= 10000;
 349 
 350         // Process least-significant group first, but put it in the buffer last.
 351         AbstractCJKChar* group = &amp;buffer[(3 - i) * groupLength];
 352 
 353         if (groupValue &amp;&amp; i)
 354             group[7] = static_cast&lt;AbstractCJKChar&gt;(secondGroupMarker - 1 + i);
 355 
 356         // Put in the four digits and digit markers for any non-zero digits.
 357         group[6] = static_cast&lt;AbstractCJKChar&gt;(digit0 + (groupValue % 10));
 358         if (number != 0 || groupValue &gt; 9) {
 359             int digitValue = ((groupValue / 10) % 10);
 360             group[4] = static_cast&lt;AbstractCJKChar&gt;(digit0 + digitValue);
 361             if (digitValue)
 362                 group[5] = secondDigitMarker;
 363         }
 364         if (number != 0 || groupValue &gt; 99) {
 365             int digitValue = ((groupValue / 100) % 10);
 366             group[2] = static_cast&lt;AbstractCJKChar&gt;(digit0 + digitValue);
 367             if (digitValue)
 368                 group[3] = thirdDigitMarker;
 369         }
 370         if (number != 0 || groupValue &gt; 999) {
 371             int digitValue = groupValue / 1000;
 372             group[0] = static_cast&lt;AbstractCJKChar&gt;(digit0 + digitValue);
 373             if (digitValue)
 374                 group[1] = fourthDigitMarker;
 375         }
 376 
 377         // Remove the tens digit, but leave the marker, for any group that has
 378         // a value of less than 20.
 379         if (groupValue &lt; 20) {
 380             ASSERT(group[4] == noChar || group[4] == digit0 || group[4] == digit1);
 381             group[4] = noChar;
 382         }
 383 
<span class="line-modified"> 384         if (number == 0)</span>
 385             break;
 386     }
 387 
<span class="line-modified"> 388     // Convert into characters, omitting consecutive runs of digit0 and</span>
<span class="line-modified"> 389     // any trailing digit0.</span>
<span class="line-removed"> 390     int length = 0;</span>
 391     UChar characters[bufferLength];
 392     AbstractCJKChar last = noChar;
<span class="line-modified"> 393     for (int i = 0; i &lt; bufferLength; ++i) {</span>
 394         AbstractCJKChar a = buffer[i];
 395         if (a != noChar) {
 396             if (a != digit0 || last != digit0)
 397                 characters[length++] = table[a - 1];
 398             last = a;
 399         }
 400     }
 401     if (last == digit0)
 402         --length;
 403 
<span class="line-modified"> 404     builder.append(characters, length);</span>
 405 }
 406 
 407 static ListStyleType effectiveListMarkerType(ListStyleType type, int value)
 408 {
 409     // Note, the following switch statement has been explicitly grouped
 410     // by list-style-type ordinal range.
 411     switch (type) {
 412     case ListStyleType::ArabicIndic:
 413     case ListStyleType::Bengali:
 414     case ListStyleType::Binary:
 415     case ListStyleType::Cambodian:
 416     case ListStyleType::Circle:
 417     case ListStyleType::DecimalLeadingZero:
 418     case ListStyleType::Decimal:
 419     case ListStyleType::Devanagari:
 420     case ListStyleType::Disc:
 421     case ListStyleType::Gujarati:
 422     case ListStyleType::Gurmukhi:
 423     case ListStyleType::Kannada:
 424     case ListStyleType::Khmer:
</pre>
<hr />
<pre>
 489     case ListStyleType::Tigre:
 490     case ListStyleType::TigrinyaEr:
 491     case ListStyleType::TigrinyaErAbegede:
 492     case ListStyleType::TigrinyaEt:
 493     case ListStyleType::TigrinyaEtAbegede:
 494     case ListStyleType::UpperAlpha:
 495     case ListStyleType::UpperArmenian:
 496     case ListStyleType::UpperGreek:
 497     case ListStyleType::UpperLatin:
 498     case ListStyleType::UpperNorwegian:
 499         return (value &lt; 1) ? ListStyleType::Decimal : type;
 500     }
 501 
 502     ASSERT_NOT_REACHED();
 503     return type;
 504 }
 505 
 506 static UChar listMarkerSuffix(ListStyleType type, int value)
 507 {
 508     // If the list-style-type cannot represent |value| because it&#39;s outside its
<span class="line-modified"> 509     // ordinal range then we fall back to some list style that can represent |value|.</span>
 510     ListStyleType effectiveType = effectiveListMarkerType(type, value);
 511 
 512     // Note, the following switch statement has been explicitly
 513     // grouped by list-style-type suffix.
 514     switch (effectiveType) {
 515     case ListStyleType::Asterisks:
 516     case ListStyleType::Circle:
 517     case ListStyleType::Disc:
 518     case ListStyleType::Footnotes:
 519     case ListStyleType::None:
 520     case ListStyleType::Square:
 521         return &#39; &#39;;
 522     case ListStyleType::Afar:
 523     case ListStyleType::Amharic:
 524     case ListStyleType::AmharicAbegede:
 525     case ListStyleType::Ethiopic:
 526     case ListStyleType::EthiopicAbegede:
 527     case ListStyleType::EthiopicAbegedeAmEt:
 528     case ListStyleType::EthiopicAbegedeGez:
 529     case ListStyleType::EthiopicAbegedeTiEr:
</pre>
<hr />
<pre>
 587     case ListStyleType::Telugu:
 588     case ListStyleType::Thai:
 589     case ListStyleType::Tibetan:
 590     case ListStyleType::UpperAlpha:
 591     case ListStyleType::UpperArmenian:
 592     case ListStyleType::UpperGreek:
 593     case ListStyleType::UpperHexadecimal:
 594     case ListStyleType::UpperLatin:
 595     case ListStyleType::UpperNorwegian:
 596     case ListStyleType::UpperRoman:
 597     case ListStyleType::Urdu:
 598         return &#39;.&#39;;
 599     }
 600 
 601     ASSERT_NOT_REACHED();
 602     return &#39;.&#39;;
 603 }
 604 
 605 String listMarkerText(ListStyleType type, int value)
 606 {
<span class="line-modified"> 607     StringBuilder builder;</span>
<span class="line-modified"> 608 </span>
<span class="line-removed"> 609     // If the list-style-type, say hebrew, cannot represent |value| because it&#39;s outside</span>
<span class="line-removed"> 610     // its ordinal range then we fallback to some list style that can represent |value|.</span>
 611     switch (effectiveListMarkerType(type, value)) {
 612     case ListStyleType::None:
 613         return emptyString();
 614 
 615     case ListStyleType::Asterisks: {
 616         static const LChar asterisksSymbols[1] = { 0x2A };
<span class="line-modified"> 617         toSymbolic(builder, value, asterisksSymbols);</span>
<span class="line-removed"> 618         break;</span>
 619     }
 620     // We use the same characters for text security.
 621     // See RenderText::setInternalString.
 622     case ListStyleType::Circle:
<span class="line-modified"> 623         builder.append(whiteBullet);</span>
<span class="line-removed"> 624         break;</span>
 625     case ListStyleType::Disc:
<span class="line-modified"> 626         builder.append(bullet);</span>
<span class="line-removed"> 627         break;</span>
 628     case ListStyleType::Footnotes: {
 629         static const UChar footnotesSymbols[4] = { 0x002A, 0x2051, 0x2020, 0x2021 };
<span class="line-modified"> 630         toSymbolic(builder, value, footnotesSymbols);</span>
<span class="line-removed"> 631         break;</span>
 632     }
 633     case ListStyleType::Square:
<span class="line-modified"> 634         // The CSS 2.1 test suite uses U+25EE BLACK MEDIUM SMALL SQUARE</span>
<span class="line-modified"> 635         // instead, but I think this looks better.</span>
<span class="line-modified"> 636         builder.append(blackSquare);</span>
<span class="line-removed"> 637         break;</span>
 638 
 639     case ListStyleType::Decimal:
<span class="line-modified"> 640         builder.appendNumber(value);</span>
<span class="line-removed"> 641         break;</span>
 642 
 643     case ListStyleType::DecimalLeadingZero:
<span class="line-modified"> 644         if (value &lt; -9 || value &gt; 9) {</span>
<span class="line-modified"> 645             builder.appendNumber(value);</span>
<span class="line-modified"> 646             break;</span>
 647         }
<span class="line-modified"> 648         if (value &lt; 0) {</span>
<span class="line-modified"> 649             builder.appendLiteral(&quot;-0&quot;);</span>
<span class="line-modified"> 650             builder.appendNumber(-value); // -01 to -09</span>
<span class="line-removed"> 651             break;</span>
 652         }
<span class="line-modified"> 653         builder.append(&#39;0&#39;);</span>
<span class="line-removed"> 654         builder.appendNumber(value); // 00 to 09</span>
<span class="line-removed"> 655         break;</span>
 656 
 657     case ListStyleType::ArabicIndic: {
 658         static const UChar arabicIndicNumerals[10] = {
 659             0x0660, 0x0661, 0x0662, 0x0663, 0x0664, 0x0665, 0x0666, 0x0667, 0x0668, 0x0669
 660         };
<span class="line-modified"> 661         toNumeric(builder, value, arabicIndicNumerals);</span>
<span class="line-removed"> 662         break;</span>
 663     }
 664 
 665     case ListStyleType::Binary: {
 666         static const LChar binaryNumerals[2] = { &#39;0&#39;, &#39;1&#39; };
<span class="line-modified"> 667         toNumeric(builder, value, binaryNumerals);</span>
<span class="line-removed"> 668         break;</span>
 669     }
 670 
 671     case ListStyleType::Bengali: {
 672         static const UChar bengaliNumerals[10] = {
 673             0x09E6, 0x09E7, 0x09E8, 0x09E9, 0x09EA, 0x09EB, 0x09EC, 0x09ED, 0x09EE, 0x09EF
 674         };
<span class="line-modified"> 675         toNumeric(builder, value, bengaliNumerals);</span>
<span class="line-removed"> 676         break;</span>
 677     }
 678 
 679     case ListStyleType::Cambodian:
 680     case ListStyleType::Khmer: {
 681         static const UChar khmerNumerals[10] = {
 682             0x17E0, 0x17E1, 0x17E2, 0x17E3, 0x17E4, 0x17E5, 0x17E6, 0x17E7, 0x17E8, 0x17E9
 683         };
<span class="line-modified"> 684         toNumeric(builder, value, khmerNumerals);</span>
<span class="line-removed"> 685         break;</span>
 686     }
 687     case ListStyleType::Devanagari: {
 688         static const UChar devanagariNumerals[10] = {
 689             0x0966, 0x0967, 0x0968, 0x0969, 0x096A, 0x096B, 0x096C, 0x096D, 0x096E, 0x096F
 690         };
<span class="line-modified"> 691         toNumeric(builder, value, devanagariNumerals);</span>
<span class="line-removed"> 692         break;</span>
 693     }
 694     case ListStyleType::Gujarati: {
 695         static const UChar gujaratiNumerals[10] = {
 696             0x0AE6, 0x0AE7, 0x0AE8, 0x0AE9, 0x0AEA, 0x0AEB, 0x0AEC, 0x0AED, 0x0AEE, 0x0AEF
 697         };
<span class="line-modified"> 698         toNumeric(builder, value, gujaratiNumerals);</span>
<span class="line-removed"> 699         break;</span>
 700     }
 701     case ListStyleType::Gurmukhi: {
 702         static const UChar gurmukhiNumerals[10] = {
 703             0x0A66, 0x0A67, 0x0A68, 0x0A69, 0x0A6A, 0x0A6B, 0x0A6C, 0x0A6D, 0x0A6E, 0x0A6F
 704         };
<span class="line-modified"> 705         toNumeric(builder, value, gurmukhiNumerals);</span>
<span class="line-removed"> 706         break;</span>
 707     }
 708     case ListStyleType::Kannada: {
 709         static const UChar kannadaNumerals[10] = {
 710             0x0CE6, 0x0CE7, 0x0CE8, 0x0CE9, 0x0CEA, 0x0CEB, 0x0CEC, 0x0CED, 0x0CEE, 0x0CEF
 711         };
<span class="line-modified"> 712         toNumeric(builder, value, kannadaNumerals);</span>
<span class="line-removed"> 713         break;</span>
 714     }
 715     case ListStyleType::LowerHexadecimal: {
 716         static const LChar lowerHexadecimalNumerals[16] = {
 717             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;
 718         };
<span class="line-modified"> 719         toNumeric(builder, value, lowerHexadecimalNumerals);</span>
<span class="line-removed"> 720         break;</span>
 721     }
 722     case ListStyleType::Lao: {
 723         static const UChar laoNumerals[10] = {
 724             0x0ED0, 0x0ED1, 0x0ED2, 0x0ED3, 0x0ED4, 0x0ED5, 0x0ED6, 0x0ED7, 0x0ED8, 0x0ED9
 725         };
<span class="line-modified"> 726         toNumeric(builder, value, laoNumerals);</span>
<span class="line-removed"> 727         break;</span>
 728     }
 729     case ListStyleType::Malayalam: {
 730         static const UChar malayalamNumerals[10] = {
 731             0x0D66, 0x0D67, 0x0D68, 0x0D69, 0x0D6A, 0x0D6B, 0x0D6C, 0x0D6D, 0x0D6E, 0x0D6F
 732         };
<span class="line-modified"> 733         toNumeric(builder, value, malayalamNumerals);</span>
<span class="line-removed"> 734         break;</span>
 735     }
 736     case ListStyleType::Mongolian: {
 737         static const UChar mongolianNumerals[10] = {
 738             0x1810, 0x1811, 0x1812, 0x1813, 0x1814, 0x1815, 0x1816, 0x1817, 0x1818, 0x1819
 739         };
<span class="line-modified"> 740         toNumeric(builder, value, mongolianNumerals);</span>
<span class="line-removed"> 741         break;</span>
 742     }
 743     case ListStyleType::Myanmar: {
 744         static const UChar myanmarNumerals[10] = {
 745             0x1040, 0x1041, 0x1042, 0x1043, 0x1044, 0x1045, 0x1046, 0x1047, 0x1048, 0x1049
 746         };
<span class="line-modified"> 747         toNumeric(builder, value, myanmarNumerals);</span>
<span class="line-removed"> 748         break;</span>
 749     }
 750     case ListStyleType::Octal: {
 751         static const LChar octalNumerals[8] = {
 752             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;
 753         };
<span class="line-modified"> 754         toNumeric(builder, value, octalNumerals);</span>
<span class="line-removed"> 755         break;</span>
 756     }
 757     case ListStyleType::Oriya: {
 758         static const UChar oriyaNumerals[10] = {
 759             0x0B66, 0x0B67, 0x0B68, 0x0B69, 0x0B6A, 0x0B6B, 0x0B6C, 0x0B6D, 0x0B6E, 0x0B6F
 760         };
<span class="line-modified"> 761         toNumeric(builder, value, oriyaNumerals);</span>
<span class="line-removed"> 762         break;</span>
 763     }
 764     case ListStyleType::Persian:
 765     case ListStyleType::Urdu: {
 766         static const UChar urduNumerals[10] = {
 767             0x06F0, 0x06F1, 0x06F2, 0x06F3, 0x06F4, 0x06F5, 0x06F6, 0x06F7, 0x06F8, 0x06F9
 768         };
<span class="line-modified"> 769         toNumeric(builder, value, urduNumerals);</span>
<span class="line-removed"> 770         break;</span>
 771     }
 772     case ListStyleType::Telugu: {
 773         static const UChar teluguNumerals[10] = {
 774             0x0C66, 0x0C67, 0x0C68, 0x0C69, 0x0C6A, 0x0C6B, 0x0C6C, 0x0C6D, 0x0C6E, 0x0C6F
 775         };
<span class="line-modified"> 776         toNumeric(builder, value, teluguNumerals);</span>
<span class="line-removed"> 777         break;</span>
 778     }
 779     case ListStyleType::Tibetan: {
 780         static const UChar tibetanNumerals[10] = {
 781             0x0F20, 0x0F21, 0x0F22, 0x0F23, 0x0F24, 0x0F25, 0x0F26, 0x0F27, 0x0F28, 0x0F29
 782         };
<span class="line-modified"> 783         toNumeric(builder, value, tibetanNumerals);</span>
<span class="line-removed"> 784         break;</span>
 785     }
 786     case ListStyleType::Thai: {
 787         static const UChar thaiNumerals[10] = {
 788             0x0E50, 0x0E51, 0x0E52, 0x0E53, 0x0E54, 0x0E55, 0x0E56, 0x0E57, 0x0E58, 0x0E59
 789         };
<span class="line-modified"> 790         toNumeric(builder, value, thaiNumerals);</span>
<span class="line-removed"> 791         break;</span>
 792     }
 793     case ListStyleType::UpperHexadecimal: {
 794         static const LChar upperHexadecimalNumerals[16] = {
 795             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
 796         };
<span class="line-modified"> 797         toNumeric(builder, value, upperHexadecimalNumerals);</span>
<span class="line-removed"> 798         break;</span>
 799     }
 800 
 801     case ListStyleType::LowerAlpha:
 802     case ListStyleType::LowerLatin: {
 803         static const LChar lowerLatinAlphabet[26] = {
 804             &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
 805             &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;
 806         };
<span class="line-modified"> 807         toAlphabetic(builder, value, lowerLatinAlphabet);</span>
<span class="line-removed"> 808         break;</span>
 809     }
 810     case ListStyleType::UpperAlpha:
 811     case ListStyleType::UpperLatin: {
 812         static const LChar upperLatinAlphabet[26] = {
 813             &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
 814             &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;
 815         };
<span class="line-modified"> 816         toAlphabetic(builder, value, upperLatinAlphabet);</span>
<span class="line-removed"> 817         break;</span>
 818     }
 819     case ListStyleType::LowerGreek: {
 820         static const UChar lowerGreekAlphabet[24] = {
 821             0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8,
 822             0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0,
 823             0x03C1, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8, 0x03C9
 824         };
<span class="line-modified"> 825         toAlphabetic(builder, value, lowerGreekAlphabet);</span>
<span class="line-removed"> 826         break;</span>
 827     }
 828 
 829     case ListStyleType::Hiragana: {
 830         // FIXME: This table comes from the CSS3 draft, and is probably
 831         // incorrect, given the comments in that draft.
 832         static const UChar hiraganaAlphabet[48] = {
 833             0x3042, 0x3044, 0x3046, 0x3048, 0x304A, 0x304B, 0x304D, 0x304F,
 834             0x3051, 0x3053, 0x3055, 0x3057, 0x3059, 0x305B, 0x305D, 0x305F,
 835             0x3061, 0x3064, 0x3066, 0x3068, 0x306A, 0x306B, 0x306C, 0x306D,
 836             0x306E, 0x306F, 0x3072, 0x3075, 0x3078, 0x307B, 0x307E, 0x307F,
 837             0x3080, 0x3081, 0x3082, 0x3084, 0x3086, 0x3088, 0x3089, 0x308A,
 838             0x308B, 0x308C, 0x308D, 0x308F, 0x3090, 0x3091, 0x3092, 0x3093
 839         };
<span class="line-modified"> 840         toAlphabetic(builder, value, hiraganaAlphabet);</span>
<span class="line-removed"> 841         break;</span>
 842     }
 843     case ListStyleType::HiraganaIroha: {
 844         // FIXME: This table comes from the CSS3 draft, and is probably
 845         // incorrect, given the comments in that draft.
 846         static const UChar hiraganaIrohaAlphabet[47] = {
 847             0x3044, 0x308D, 0x306F, 0x306B, 0x307B, 0x3078, 0x3068, 0x3061,
 848             0x308A, 0x306C, 0x308B, 0x3092, 0x308F, 0x304B, 0x3088, 0x305F,
 849             0x308C, 0x305D, 0x3064, 0x306D, 0x306A, 0x3089, 0x3080, 0x3046,
 850             0x3090, 0x306E, 0x304A, 0x304F, 0x3084, 0x307E, 0x3051, 0x3075,
 851             0x3053, 0x3048, 0x3066, 0x3042, 0x3055, 0x304D, 0x3086, 0x3081,
 852             0x307F, 0x3057, 0x3091, 0x3072, 0x3082, 0x305B, 0x3059
 853         };
<span class="line-modified"> 854         toAlphabetic(builder, value, hiraganaIrohaAlphabet);</span>
<span class="line-removed"> 855         break;</span>
 856     }
 857     case ListStyleType::Katakana: {
 858         // FIXME: This table comes from the CSS3 draft, and is probably
 859         // incorrect, given the comments in that draft.
 860         static const UChar katakanaAlphabet[48] = {
 861             0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD, 0x30AF,
 862             0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD, 0x30BF,
 863             0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC, 0x30CD,
 864             0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE, 0x30DF,
 865             0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9, 0x30EA,
 866             0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F0, 0x30F1, 0x30F2, 0x30F3
 867         };
<span class="line-modified"> 868         toAlphabetic(builder, value, katakanaAlphabet);</span>
<span class="line-removed"> 869         break;</span>
 870     }
 871     case ListStyleType::KatakanaIroha: {
 872         // FIXME: This table comes from the CSS3 draft, and is probably
 873         // incorrect, given the comments in that draft.
 874         static const UChar katakanaIrohaAlphabet[47] = {
 875             0x30A4, 0x30ED, 0x30CF, 0x30CB, 0x30DB, 0x30D8, 0x30C8, 0x30C1,
 876             0x30EA, 0x30CC, 0x30EB, 0x30F2, 0x30EF, 0x30AB, 0x30E8, 0x30BF,
 877             0x30EC, 0x30BD, 0x30C4, 0x30CD, 0x30CA, 0x30E9, 0x30E0, 0x30A6,
 878             0x30F0, 0x30CE, 0x30AA, 0x30AF, 0x30E4, 0x30DE, 0x30B1, 0x30D5,
 879             0x30B3, 0x30A8, 0x30C6, 0x30A2, 0x30B5, 0x30AD, 0x30E6, 0x30E1,
 880             0x30DF, 0x30B7, 0x30F1, 0x30D2, 0x30E2, 0x30BB, 0x30B9
 881         };
<span class="line-modified"> 882         toAlphabetic(builder, value, katakanaIrohaAlphabet);</span>
<span class="line-removed"> 883         break;</span>
 884     }
 885 
 886     case ListStyleType::Afar:
 887     case ListStyleType::EthiopicHalehameAaEt:
 888     case ListStyleType::EthiopicHalehameAaEr: {
 889         static const UChar ethiopicHalehameAaErAlphabet[18] = {
 890             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1260, 0x1270, 0x1290,
 891             0x12A0, 0x12A8, 0x12C8, 0x12D0, 0x12E8, 0x12F0, 0x1308, 0x1338, 0x1348
 892         };
<span class="line-modified"> 893         toAlphabetic(builder, value, ethiopicHalehameAaErAlphabet);</span>
<span class="line-removed"> 894         break;</span>
 895     }
 896     case ListStyleType::Amharic:
 897     case ListStyleType::EthiopicHalehameAmEt: {
 898         static const UChar ethiopicHalehameAmEtAlphabet[33] = {
 899             0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228, 0x1230, 0x1238, 0x1240,
 900             0x1260, 0x1270, 0x1278, 0x1280, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12B8,
 901             0x12C8, 0x12D0, 0x12D8, 0x12E0, 0x12E8, 0x12F0, 0x1300, 0x1308, 0x1320,
 902             0x1328, 0x1330, 0x1338, 0x1340, 0x1348, 0x1350
 903         };
<span class="line-modified"> 904         toAlphabetic(builder, value, ethiopicHalehameAmEtAlphabet);</span>
<span class="line-removed"> 905         break;</span>
 906     }
 907     case ListStyleType::AmharicAbegede:
 908     case ListStyleType::EthiopicAbegedeAmEt: {
 909         static const UChar ethiopicAbegedeAmEtAlphabet[33] = {
 910             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1300, 0x1200, 0x12C8, 0x12D8, 0x12E0,
 911             0x1210, 0x1320, 0x1328, 0x12E8, 0x12A8, 0x12B8, 0x1208, 0x1218, 0x1290,
 912             0x1298, 0x1220, 0x12D0, 0x1348, 0x1338, 0x1240, 0x1228, 0x1230, 0x1238,
 913             0x1270, 0x1278, 0x1280, 0x1340, 0x1330, 0x1350
 914         };
<span class="line-modified"> 915         toAlphabetic(builder, value, ethiopicAbegedeAmEtAlphabet);</span>
<span class="line-removed"> 916         break;</span>
 917     }
 918     case ListStyleType::CjkEarthlyBranch: {
 919         static const UChar cjkEarthlyBranchAlphabet[12] = {
 920             0x5B50, 0x4E11, 0x5BC5, 0x536F, 0x8FB0, 0x5DF3, 0x5348, 0x672A, 0x7533,
 921             0x9149, 0x620C, 0x4EA5
 922         };
<span class="line-modified"> 923         toAlphabetic(builder, value, cjkEarthlyBranchAlphabet);</span>
<span class="line-removed"> 924         break;</span>
 925     }
 926     case ListStyleType::CjkHeavenlyStem: {
 927         static const UChar cjkHeavenlyStemAlphabet[10] = {
 928             0x7532, 0x4E59, 0x4E19, 0x4E01, 0x620A, 0x5DF1, 0x5E9A, 0x8F9B, 0x58EC,
 929             0x7678
 930         };
<span class="line-modified"> 931         toAlphabetic(builder, value, cjkHeavenlyStemAlphabet);</span>
<span class="line-removed"> 932         break;</span>
 933     }
 934     case ListStyleType::Ethiopic:
 935     case ListStyleType::EthiopicHalehameGez: {
 936         static const UChar ethiopicHalehameGezAlphabet[26] = {
 937             0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228, 0x1230, 0x1240, 0x1260,
 938             0x1270, 0x1280, 0x1290, 0x12A0, 0x12A8, 0x12C8, 0x12D0, 0x12D8, 0x12E8,
 939             0x12F0, 0x1308, 0x1320, 0x1330, 0x1338, 0x1340, 0x1348, 0x1350
 940         };
<span class="line-modified"> 941         toAlphabetic(builder, value, ethiopicHalehameGezAlphabet);</span>
<span class="line-removed"> 942         break;</span>
 943     }
 944     case ListStyleType::EthiopicAbegede:
 945     case ListStyleType::EthiopicAbegedeGez: {
 946         static const UChar ethiopicAbegedeGezAlphabet[26] = {
 947             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1200, 0x12C8, 0x12D8, 0x1210, 0x1320,
 948             0x12E8, 0x12A8, 0x1208, 0x1218, 0x1290, 0x1220, 0x12D0, 0x1348, 0x1338,
 949             0x1240, 0x1228, 0x1230, 0x1270, 0x1280, 0x1340, 0x1330, 0x1350
 950         };
<span class="line-modified"> 951         toAlphabetic(builder, value, ethiopicAbegedeGezAlphabet);</span>
<span class="line-removed"> 952         break;</span>
 953     }
 954     case ListStyleType::HangulConsonant: {
 955         static const UChar hangulConsonantAlphabet[14] = {
 956             0x3131, 0x3134, 0x3137, 0x3139, 0x3141, 0x3142, 0x3145, 0x3147, 0x3148,
 957             0x314A, 0x314B, 0x314C, 0x314D, 0x314E
 958         };
<span class="line-modified"> 959         toAlphabetic(builder, value, hangulConsonantAlphabet);</span>
<span class="line-removed"> 960         break;</span>
 961     }
 962     case ListStyleType::Hangul: {
 963         static const UChar hangulAlphabet[14] = {
 964             0xAC00, 0xB098, 0xB2E4, 0xB77C, 0xB9C8, 0xBC14, 0xC0AC, 0xC544, 0xC790,
 965             0xCC28, 0xCE74, 0xD0C0, 0xD30C, 0xD558
 966         };
<span class="line-modified"> 967         toAlphabetic(builder, value, hangulAlphabet);</span>
<span class="line-removed"> 968         break;</span>
 969     }
 970     case ListStyleType::Oromo:
 971     case ListStyleType::EthiopicHalehameOmEt: {
 972         static const UChar ethiopicHalehameOmEtAlphabet[25] = {
 973             0x1200, 0x1208, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260, 0x1270,
 974             0x1278, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12C8, 0x12E8, 0x12F0, 0x12F8,
 975             0x1300, 0x1308, 0x1320, 0x1328, 0x1338, 0x1330, 0x1348
 976         };
<span class="line-modified"> 977         toAlphabetic(builder, value, ethiopicHalehameOmEtAlphabet);</span>
<span class="line-removed"> 978         break;</span>
 979     }
 980     case ListStyleType::Sidama:
 981     case ListStyleType::EthiopicHalehameSidEt: {
 982         static const UChar ethiopicHalehameSidEtAlphabet[26] = {
 983             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260,
 984             0x1270, 0x1278, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12C8, 0x12E8, 0x12F0,
 985             0x12F8, 0x1300, 0x1308, 0x1320, 0x1328, 0x1338, 0x1330, 0x1348
 986         };
<span class="line-modified"> 987         toAlphabetic(builder, value, ethiopicHalehameSidEtAlphabet);</span>
<span class="line-removed"> 988         break;</span>
 989     }
 990     case ListStyleType::Somali:
 991     case ListStyleType::EthiopicHalehameSoEt: {
 992         static const UChar ethiopicHalehameSoEtAlphabet[22] = {
 993             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260,
 994             0x1270, 0x1290, 0x12A0, 0x12A8, 0x12B8, 0x12C8, 0x12D0, 0x12E8, 0x12F0,
 995             0x1300, 0x1308, 0x1338, 0x1348
 996         };
<span class="line-modified"> 997         toAlphabetic(builder, value, ethiopicHalehameSoEtAlphabet);</span>
<span class="line-removed"> 998         break;</span>
 999     }
1000     case ListStyleType::Tigre:
1001     case ListStyleType::EthiopicHalehameTig: {
1002         static const UChar ethiopicHalehameTigAlphabet[27] = {
1003             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260,
1004             0x1270, 0x1278, 0x1290, 0x12A0, 0x12A8, 0x12C8, 0x12D0, 0x12D8, 0x12E8,
1005             0x12F0, 0x1300, 0x1308, 0x1320, 0x1328, 0x1338, 0x1330, 0x1348, 0x1350
1006         };
<span class="line-modified">1007         toAlphabetic(builder, value, ethiopicHalehameTigAlphabet);</span>
<span class="line-removed">1008         break;</span>
1009     }
1010     case ListStyleType::TigrinyaEr:
1011     case ListStyleType::EthiopicHalehameTiEr: {
1012         static const UChar ethiopicHalehameTiErAlphabet[31] = {
1013             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1250,
1014             0x1260, 0x1270, 0x1278, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12B8, 0x12C8,
1015             0x12D0, 0x12D8, 0x12E0, 0x12E8, 0x12F0, 0x1300, 0x1308, 0x1320, 0x1328,
1016             0x1330, 0x1338, 0x1348, 0x1350
1017         };
<span class="line-modified">1018         toAlphabetic(builder, value, ethiopicHalehameTiErAlphabet);</span>
<span class="line-removed">1019         break;</span>
1020     }
1021     case ListStyleType::TigrinyaErAbegede:
1022     case ListStyleType::EthiopicAbegedeTiEr: {
1023         static const UChar ethiopicAbegedeTiErAlphabet[31] = {
1024             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1300, 0x1200, 0x12C8, 0x12D8, 0x12E0,
1025             0x1210, 0x1320, 0x1328, 0x12E8, 0x12A8, 0x12B8, 0x1208, 0x1218, 0x1290,
1026             0x1298, 0x12D0, 0x1348, 0x1338, 0x1240, 0x1250, 0x1228, 0x1230, 0x1238,
1027             0x1270, 0x1278, 0x1330, 0x1350
1028         };
<span class="line-modified">1029         toAlphabetic(builder, value, ethiopicAbegedeTiErAlphabet);</span>
<span class="line-removed">1030         break;</span>
1031     }
1032     case ListStyleType::TigrinyaEt:
1033     case ListStyleType::EthiopicHalehameTiEt: {
1034         static const UChar ethiopicHalehameTiEtAlphabet[34] = {
1035             0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228, 0x1230, 0x1238, 0x1240,
1036             0x1250, 0x1260, 0x1270, 0x1278, 0x1280, 0x1290, 0x1298, 0x12A0, 0x12A8,
1037             0x12B8, 0x12C8, 0x12D0, 0x12D8, 0x12E0, 0x12E8, 0x12F0, 0x1300, 0x1308,
1038             0x1320, 0x1328, 0x1330, 0x1338, 0x1340, 0x1348, 0x1350
1039         };
<span class="line-modified">1040         toAlphabetic(builder, value, ethiopicHalehameTiEtAlphabet);</span>
<span class="line-removed">1041         break;</span>
1042     }
1043     case ListStyleType::TigrinyaEtAbegede:
1044     case ListStyleType::EthiopicAbegedeTiEt: {
1045         static const UChar ethiopicAbegedeTiEtAlphabet[34] = {
1046             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1300, 0x1200, 0x12C8, 0x12D8, 0x12E0,
1047             0x1210, 0x1320, 0x1328, 0x12E8, 0x12A8, 0x12B8, 0x1208, 0x1218, 0x1290,
1048             0x1298, 0x1220, 0x12D0, 0x1348, 0x1338, 0x1240, 0x1250, 0x1228, 0x1230,
1049             0x1238, 0x1270, 0x1278, 0x1280, 0x1340, 0x1330, 0x1350
1050         };
<span class="line-modified">1051         toAlphabetic(builder, value, ethiopicAbegedeTiEtAlphabet);</span>
<span class="line-removed">1052         break;</span>
1053     }
1054     case ListStyleType::UpperGreek: {
1055         static const UChar upperGreekAlphabet[24] = {
1056             0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399,
1057             0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0, 0x03A1, 0x03A3,
1058             0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9
1059         };
<span class="line-modified">1060         toAlphabetic(builder, value, upperGreekAlphabet);</span>
<span class="line-removed">1061         break;</span>
1062     }
1063     case ListStyleType::LowerNorwegian: {
1064         static const LChar lowerNorwegianAlphabet[29] = {
1065             0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
1066             0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
1067             0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xE6,
1068             0xF8, 0xE5
1069         };
<span class="line-modified">1070         toAlphabetic(builder, value, lowerNorwegianAlphabet);</span>
<span class="line-removed">1071         break;</span>
1072     }
1073     case ListStyleType::UpperNorwegian: {
1074         static const LChar upperNorwegianAlphabet[29] = {
1075             0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
1076             0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
1077             0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xC6,
1078             0xD8, 0xC5
1079         };
<span class="line-modified">1080         toAlphabetic(builder, value, upperNorwegianAlphabet);</span>
<span class="line-removed">1081         break;</span>
1082     }
1083     case ListStyleType::CJKIdeographic: {
1084         static const UChar traditionalChineseInformalTable[16] = {
1085             0x842C, 0x5104, 0x5146,
1086             0x5341, 0x767E, 0x5343,
1087             0x96F6, 0x4E00, 0x4E8C, 0x4E09, 0x56DB,
1088             0x4E94, 0x516D, 0x4E03, 0x516B, 0x4E5D
1089         };
<span class="line-modified">1090         toCJKIdeographic(builder, value, traditionalChineseInformalTable);</span>
<span class="line-removed">1091         break;</span>
1092     }
1093 
1094     case ListStyleType::LowerRoman:
<span class="line-modified">1095         toRoman(builder, value, false);</span>
<span class="line-removed">1096         break;</span>
1097     case ListStyleType::UpperRoman:
<span class="line-modified">1098         toRoman(builder, value, true);</span>
<span class="line-removed">1099         break;</span>
1100 


1101     case ListStyleType::Armenian:
1102     case ListStyleType::UpperArmenian:
<span class="line-modified">1103         // CSS3 says &quot;armenian&quot; means &quot;lower-armenian&quot;.</span>
<span class="line-removed">1104         // But the CSS2.1 test suite contains uppercase test results for &quot;armenian&quot;,</span>
<span class="line-removed">1105         // so we&#39;ll match the test suite.</span>
<span class="line-removed">1106         toArmenian(builder, value, true);</span>
<span class="line-removed">1107         break;</span>
1108     case ListStyleType::LowerArmenian:
<span class="line-modified">1109         toArmenian(builder, value, false);</span>
<span class="line-modified">1110         break;</span>
1111     case ListStyleType::Georgian:
<span class="line-modified">1112         toGeorgian(builder, value);</span>
<span class="line-removed">1113         break;</span>
1114     case ListStyleType::Hebrew:
<span class="line-modified">1115         toHebrew(builder, value);</span>
<span class="line-removed">1116         break;</span>
1117     }
1118 
<span class="line-modified">1119     return builder.toString();</span>

1120 }
1121 
1122 RenderListMarker::RenderListMarker(RenderListItem&amp; listItem, RenderStyle&amp;&amp; style)
1123     : RenderBox(listItem.document(), WTFMove(style), 0)
1124     , m_listItem(makeWeakPtr(listItem))
1125 {
1126     // init RenderObject attributes
1127     setInline(true);   // our object is Inline
1128     setReplaced(true); // pretend to be replaced
1129 }
1130 
1131 RenderListMarker::~RenderListMarker()
1132 {
1133     // Do not add any code here. Add it to willBeDestroyed() instead.
1134 }
1135 
1136 void RenderListMarker::willBeDestroyed()
1137 {
1138     if (m_image)
1139         m_image-&gt;removeClient(this);
1140     RenderBox::willBeDestroyed();
1141 }
1142 
1143 void RenderListMarker::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
1144 {
1145     RenderBox::styleDidChange(diff, oldStyle);
1146 
1147     if (oldStyle) {
1148         if (style().listStylePosition() != oldStyle-&gt;listStylePosition() || style().listStyleType() != oldStyle-&gt;listStyleType())
<span class="line-modified">1149         setNeedsLayoutAndPrefWidthsRecalc();</span>
1150         if (oldStyle-&gt;isDisplayInlineType() &amp;&amp; !style().isDisplayInlineType()) {
1151             delete m_inlineBoxWrapper;
1152             m_inlineBoxWrapper = nullptr;
1153         }
1154     }
1155 
1156     if (m_image != style().listStyleImage()) {
1157         if (m_image)
1158             m_image-&gt;removeClient(this);
1159         m_image = style().listStyleImage();
1160         if (m_image)
1161             m_image-&gt;addClient(this);
1162     }
1163 }
1164 
1165 std::unique_ptr&lt;InlineElementBox&gt; RenderListMarker::createInlineBox()
1166 {
1167     auto box = RenderBox::createInlineBox();
1168     box-&gt;setBehavesLikeText(isText());
1169     return box;
1170 }
1171 
1172 bool RenderListMarker::isImage() const
1173 {
1174     return m_image &amp;&amp; !m_image-&gt;errorOccurred();
1175 }
1176 
1177 LayoutRect RenderListMarker::localSelectionRect()
1178 {
1179     InlineBox* box = inlineBoxWrapper();
1180     if (!box)
1181         return LayoutRect(LayoutPoint(), size());
1182     const RootInlineBox&amp; rootBox = m_inlineBoxWrapper-&gt;root();
<span class="line-modified">1183     LayoutUnit newLogicalTop = rootBox.blockFlow().style().isFlippedBlocksWritingMode() ? m_inlineBoxWrapper-&gt;logicalBottom() - rootBox.selectionBottom() : rootBox.selectionTop() - m_inlineBoxWrapper-&gt;logicalTop();</span>
1184     if (rootBox.blockFlow().style().isHorizontalWritingMode())
1185         return LayoutRect(0_lu, newLogicalTop, width(), rootBox.selectionHeight());
1186     return LayoutRect(newLogicalTop, 0_lu, rootBox.selectionHeight(), height());
1187 }
1188 
1189 void RenderListMarker::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1190 {
1191     if (paintInfo.phase != PaintPhase::Foreground)
1192         return;
1193 
1194     if (style().visibility() != Visibility::Visible)
1195         return;
1196 
1197     LayoutPoint boxOrigin(paintOffset + location());
1198     LayoutRect overflowRect(visualOverflowRect());
1199     overflowRect.moveBy(boxOrigin);
1200     if (!paintInfo.rect.intersects(overflowRect))
1201         return;
1202 
1203     LayoutRect box(boxOrigin, size());
</pre>
<hr />
<pre>
1333 
1334     GraphicsContextStateSaver stateSaver(context, false);
1335     if (!style().isHorizontalWritingMode()) {
1336         markerRect.moveBy(-boxOrigin);
1337         markerRect = markerRect.transposedRect();
1338         markerRect.moveBy(FloatPoint(box.x(), box.y() - logicalHeight()));
1339         stateSaver.save();
1340         context.translate(markerRect.x(), markerRect.maxY());
1341         context.rotate(static_cast&lt;float&gt;(deg2rad(90.)));
1342         context.translate(-markerRect.x(), -markerRect.maxY());
1343     }
1344 
1345     FloatPoint textOrigin = FloatPoint(markerRect.x(), markerRect.y() + style().fontMetrics().ascent());
1346     textOrigin = roundPointToDevicePixels(LayoutPoint(textOrigin), document().deviceScaleFactor(), style().isLeftToRightDirection());
1347 
1348     if (type == ListStyleType::Asterisks || type == ListStyleType::Footnotes)
1349         context.drawText(font, textRun, textOrigin);
1350     else {
1351         const UChar suffix = listMarkerSuffix(type, m_listItem-&gt;value());
1352 
<span class="line-modified">1353         // Text is not arbitrary. We can judge whether it&#39;s RTL from the first character,</span>
<span class="line-modified">1354         // and we only need to handle the direction U_RIGHT_TO_LEFT for now.</span>
<span class="line-modified">1355         bool textNeedsReversing = u_charDirection(m_text[0]) == U_RIGHT_TO_LEFT;</span>
<span class="line-modified">1356         String toDraw;</span>
<span class="line-modified">1357         if (textNeedsReversing) {</span>




1358             unsigned length = m_text.length();
<span class="line-modified">1359             StringBuilder buffer;</span>
<span class="line-modified">1360             buffer.reserveCapacity(length + 2);</span>
1361             if (!style().isLeftToRightDirection()) {
<span class="line-modified">1362                 buffer.append(space);</span>
<span class="line-modified">1363                 buffer.append(suffix);</span>
1364             }
1365             for (unsigned i = 0; i &lt; length; ++i)
<span class="line-modified">1366                 buffer.append(m_text[length - i - 1]);</span>
1367             if (style().isLeftToRightDirection()) {
<span class="line-modified">1368                 buffer.append(suffix);</span>
<span class="line-modified">1369                 buffer.append(space);</span>
1370             }
<span class="line-removed">1371             toDraw = buffer.toString();</span>
1372         } else {
1373             if (style().isLeftToRightDirection())
<span class="line-modified">1374                 toDraw = m_text + String(&amp;suffix, 1) + String(&amp;space, 1);</span>
1375             else
<span class="line-modified">1376                 toDraw = String(&amp;space, 1) + String(&amp;suffix, 1) + m_text;</span>
1377         }
<span class="line-modified">1378         textRun.setText(StringView(toDraw));</span>
1379 
1380         context.drawText(font, textRun, textOrigin);
1381     }
1382 }
1383 
1384 void RenderListMarker::layout()
1385 {
1386     StackStats::LayoutCheckPoint layoutCheckPoint;
1387     ASSERT(needsLayout());
1388 
1389     LayoutUnit blockOffset;
1390     for (auto* ancestor = parentBox(); ancestor &amp;&amp; ancestor != m_listItem.get(); ancestor = ancestor-&gt;parentBox())
1391         blockOffset += ancestor-&gt;logicalTop();
1392     if (style().isLeftToRightDirection())
1393         m_lineOffsetForListItem = m_listItem-&gt;logicalLeftOffsetForLine(blockOffset, DoNotIndentText, 0_lu);
1394     else
1395         m_lineOffsetForListItem = m_listItem-&gt;logicalRightOffsetForLine(blockOffset, DoNotIndentText, 0_lu);
1396 
1397     if (isImage()) {
1398         updateMarginsAndContent();
1399         setWidth(m_image-&gt;imageSize(this, style().effectiveZoom()).width());
1400         setHeight(m_image-&gt;imageSize(this, style().effectiveZoom()).height());
1401     } else {
1402         setLogicalWidth(minPreferredLogicalWidth());
1403         setLogicalHeight(style().fontMetrics().height());
1404     }
1405 
1406     setMarginStart(0);
1407     setMarginEnd(0);
1408 
1409     Length startMargin = style().marginStart();
1410     Length endMargin = style().marginEnd();
1411     if (startMargin.isFixed())
<span class="line-modified">1412         setMarginStart(startMargin.value());</span>
1413     if (endMargin.isFixed())
<span class="line-modified">1414         setMarginEnd(endMargin.value());</span>
1415 
1416     clearNeedsLayout();
1417 }
1418 
1419 void RenderListMarker::imageChanged(WrappedImagePtr o, const IntRect*)
1420 {
1421     // A list marker can&#39;t have a background or border image, so no need to call the base class method.
1422     if (o != m_image-&gt;data())
1423         return;
1424 
1425     if (width() != m_image-&gt;imageSize(this, style().effectiveZoom()).width() || height() != m_image-&gt;imageSize(this, style().effectiveZoom()).height() || m_image-&gt;errorOccurred())
1426         setNeedsLayoutAndPrefWidthsRecalc();
1427     else
1428         repaint();
1429 }
1430 
1431 void RenderListMarker::updateMarginsAndContent()
1432 {
1433     updateContent();
1434     updateMargins();
</pre>
<hr />
<pre>
1551 
1552     if (isImage()) {
1553         LayoutSize imageSize = LayoutSize(m_image-&gt;imageSize(this, style().effectiveZoom()));
1554         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = style().isHorizontalWritingMode() ? imageSize.width() : imageSize.height();
1555         setPreferredLogicalWidthsDirty(false);
1556         updateMargins();
1557         return;
1558     }
1559 
1560     const FontCascade&amp; font = style().fontCascade();
1561 
1562     LayoutUnit logicalWidth;
1563     ListStyleType type = style().listStyleType();
1564     switch (type) {
1565     case ListStyleType::None:
1566         break;
1567     case ListStyleType::Asterisks:
1568     case ListStyleType::Footnotes: {
1569         TextRun run = RenderBlock::constructTextRun(m_text, style());
1570         logicalWidth = font.width(run); // no suffix for these types
<span class="line-removed">1571     }</span>
1572         break;

1573     case ListStyleType::Circle:
1574     case ListStyleType::Disc:
1575     case ListStyleType::Square:
1576         logicalWidth = (font.fontMetrics().ascent() * 2 / 3 + 1) / 2 + 2;
1577         break;
1578     case ListStyleType::Afar:
1579     case ListStyleType::Amharic:
1580     case ListStyleType::AmharicAbegede:
1581     case ListStyleType::ArabicIndic:
1582     case ListStyleType::Armenian:
1583     case ListStyleType::Binary:
1584     case ListStyleType::Bengali:
1585     case ListStyleType::Cambodian:
1586     case ListStyleType::CJKIdeographic:
1587     case ListStyleType::CjkEarthlyBranch:
1588     case ListStyleType::CjkHeavenlyStem:
1589     case ListStyleType::DecimalLeadingZero:
1590     case ListStyleType::Decimal:
1591     case ListStyleType::Devanagari:
1592     case ListStyleType::Ethiopic:
</pre>
<hr />
<pre>
1637     case ListStyleType::Telugu:
1638     case ListStyleType::Thai:
1639     case ListStyleType::Tibetan:
1640     case ListStyleType::Tigre:
1641     case ListStyleType::TigrinyaEr:
1642     case ListStyleType::TigrinyaErAbegede:
1643     case ListStyleType::TigrinyaEt:
1644     case ListStyleType::TigrinyaEtAbegede:
1645     case ListStyleType::UpperAlpha:
1646     case ListStyleType::UpperArmenian:
1647     case ListStyleType::UpperGreek:
1648     case ListStyleType::UpperHexadecimal:
1649     case ListStyleType::UpperLatin:
1650     case ListStyleType::UpperNorwegian:
1651     case ListStyleType::UpperRoman:
1652     case ListStyleType::Urdu:
1653         if (m_text.isEmpty())
1654             logicalWidth = 0;
1655         else {
1656             TextRun run = RenderBlock::constructTextRun(m_text, style());
<span class="line-modified">1657             LayoutUnit itemWidth = font.width(run);</span>
1658             UChar suffixSpace[2] = { listMarkerSuffix(type, m_listItem-&gt;value()), &#39; &#39; };
<span class="line-modified">1659             LayoutUnit suffixSpaceWidth = font.width(RenderBlock::constructTextRun(suffixSpace, 2, style()));</span>
1660             logicalWidth = itemWidth + suffixSpaceWidth;
1661         }
1662         break;
1663     }
1664 
1665     m_minPreferredLogicalWidth = logicalWidth;
1666     m_maxPreferredLogicalWidth = logicalWidth;
1667 
1668     setPreferredLogicalWidthsDirty(false);
1669 
1670     updateMargins();
1671 }
1672 
1673 void RenderListMarker::updateMargins()
1674 {
1675     const FontMetrics&amp; fontMetrics = style().fontMetrics();
1676 
1677     LayoutUnit marginStart;
1678     LayoutUnit marginEnd;
1679 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
<span class="line-modified">   4  * Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   6  * Copyright (C) 2010 Daniel Bates (dbates@intudata.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderListMarker.h&quot;
  27 
  28 #include &quot;Document.h&quot;
  29 #include &quot;FontCascade.h&quot;
  30 #include &quot;GraphicsContext.h&quot;
  31 #include &quot;InlineElementBox.h&quot;
  32 #include &quot;RenderLayer.h&quot;
  33 #include &quot;RenderListItem.h&quot;
  34 #include &quot;RenderView.h&quot;
  35 #include &lt;wtf/IsoMallocInlines.h&gt;
  36 #include &lt;wtf/StackStats.h&gt;
<span class="line-modified">  37 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;</span>
  38 #include &lt;wtf/unicode/CharacterNames.h&gt;
  39 
  40 namespace WebCore {
  41 
  42 using namespace WTF::Unicode;
  43 
  44 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderListMarker);
  45 
  46 const int cMarkerPadding = 7;
  47 
<span class="line-modified">  48 enum class LetterCase { Lower, Upper };</span>
<span class="line-added">  49 enum class SequenceType { Numeric, Alphabetic };</span>
  50 
<span class="line-modified">  51 static NEVER_INLINE String toRoman(int number, LetterCase letterCase)</span>
  52 {
  53     // FIXME: CSS3 describes how to make this work for much larger numbers,
  54     // using overbars and special characters. It also specifies the characters
  55     // in the range U+2160 to U+217F instead of standard ASCII ones.
  56     ASSERT(number &gt;= 1 &amp;&amp; number &lt;= 3999);
  57 
  58     // Big enough to store largest roman number less than 3999 which
  59     // is 3888 (MMMDCCCLXXXVIII)
<span class="line-modified">  60     constexpr unsigned lettersSize = 15;</span>
  61     LChar letters[lettersSize];
  62 
<span class="line-modified">  63     unsigned length = 0;</span>
  64     const LChar ldigits[] = { &#39;i&#39;, &#39;v&#39;, &#39;x&#39;, &#39;l&#39;, &#39;c&#39;, &#39;d&#39;, &#39;m&#39; };
  65     const LChar udigits[] = { &#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39; };
<span class="line-modified">  66     const LChar* digits = letterCase == LetterCase::Upper ? udigits : ldigits;</span>
  67     int d = 0;
  68     do {
  69         int num = number % 10;
  70         if (num % 5 &lt; 4)
  71             for (int i = num % 5; i &gt; 0; i--)
  72                 letters[lettersSize - ++length] = digits[d];
  73         if (num &gt;= 4 &amp;&amp; num &lt;= 8)
  74             letters[lettersSize - ++length] = digits[d + 1];
  75         if (num == 9)
  76             letters[lettersSize - ++length] = digits[d + 2];
  77         if (num % 5 == 4)
  78             letters[lettersSize - ++length] = digits[d];
  79         number /= 10;
  80         d += 2;
  81     } while (number);
  82 
  83     ASSERT(length &lt;= lettersSize);
<span class="line-modified">  84     return String { &amp;letters[lettersSize - length], length };</span>
  85 }
  86 
<span class="line-modified">  87 template&lt;typename CharacterType&gt;</span>
<span class="line-modified">  88 static inline String toAlphabeticOrNumeric(int number, const CharacterType* sequence, unsigned sequenceSize, SequenceType type)</span>
  89 {
  90     ASSERT(sequenceSize &gt;= 2);
  91 
  92     // Taking sizeof(number) in the expression below doesn&#39;t work with some compilers.
<span class="line-modified">  93     constexpr unsigned lettersSize = sizeof(int) * 8 + 1; // Binary is the worst case; requires one character per bit plus a minus sign.</span>
  94 
  95     CharacterType letters[lettersSize];
  96 
  97     bool isNegativeNumber = false;
  98     unsigned numberShadow = number;
<span class="line-modified">  99     if (type == SequenceType::Alphabetic) {</span>
 100         ASSERT(number &gt; 0);
 101         --numberShadow;
 102     } else if (number &lt; 0) {
 103         numberShadow = -number;
 104         isNegativeNumber = true;
 105     }
 106     letters[lettersSize - 1] = sequence[numberShadow % sequenceSize];
<span class="line-modified"> 107     unsigned length = 1;</span>
 108 
<span class="line-modified"> 109     if (type == SequenceType::Alphabetic) {</span>
 110         while ((numberShadow /= sequenceSize) &gt; 0) {
 111             --numberShadow;
 112             letters[lettersSize - ++length] = sequence[numberShadow % sequenceSize];
 113         }
 114     } else {
 115         while ((numberShadow /= sequenceSize) &gt; 0)
 116             letters[lettersSize - ++length] = sequence[numberShadow % sequenceSize];
 117     }
 118     if (isNegativeNumber)
 119         letters[lettersSize - ++length] = hyphenMinus;
 120 
 121     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 122     return String { &amp;letters[lettersSize - length], length };</span>
 123 }
 124 
<span class="line-modified"> 125 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 126 static NEVER_INLINE String toSymbolic(int number, const CharacterType* symbols, unsigned symbolsSize)</span>
 127 {
 128     ASSERT(number &gt; 0);
 129     ASSERT(symbolsSize &gt;= 1);


 130 
<span class="line-modified"> 131     // The asterisks list-style-type is the worst case; we show |number| asterisks.</span>
<span class="line-modified"> 132     CharacterType symbol = symbols[(number - 1) % symbolsSize];</span>
<span class="line-modified"> 133     unsigned count = (number - 1) / symbolsSize + 1;</span>
<span class="line-modified"> 134 </span>
<span class="line-modified"> 135     CharacterType* characters;</span>
<span class="line-added"> 136     String result = String::createUninitialized(count, characters);</span>
<span class="line-added"> 137     for (unsigned i = 0; i &lt; count; ++i)</span>
<span class="line-added"> 138         characters[i] = symbol;</span>
<span class="line-added"> 139     return result;</span>
 140 }
 141 
<span class="line-modified"> 142 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 143 static NEVER_INLINE String toAlphabetic(int number, const CharacterType* alphabet, unsigned alphabetSize)</span>
 144 {
<span class="line-modified"> 145     return toAlphabeticOrNumeric(number, alphabet, alphabetSize, SequenceType::Alphabetic);</span>
 146 }
 147 
<span class="line-modified"> 148 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 149 static NEVER_INLINE String toNumeric(int number, const CharacterType* numerals, unsigned numeralsSize)</span>
 150 {
<span class="line-modified"> 151     return toAlphabeticOrNumeric(number, numerals, numeralsSize, SequenceType::Numeric);</span>
 152 }
 153 
<span class="line-modified"> 154 template&lt;typename CharacterType, size_t size&gt;</span>
<span class="line-modified"> 155 static inline String toAlphabetic(int number, const CharacterType(&amp;alphabet)[size])</span>
 156 {
<span class="line-modified"> 157     return toAlphabetic(number, alphabet, size);</span>
 158 }
 159 
<span class="line-modified"> 160 template&lt;typename CharacterType, size_t size&gt;</span>
<span class="line-modified"> 161 static inline String toNumeric(int number, const CharacterType(&amp;alphabet)[size])</span>
 162 {
<span class="line-modified"> 163     return toNumeric(number, alphabet, size);</span>
 164 }
 165 
<span class="line-modified"> 166 template&lt;typename CharacterType, size_t size&gt;</span>
<span class="line-modified"> 167 static inline String toSymbolic(int number, const CharacterType(&amp;alphabet)[size])</span>
 168 {
<span class="line-modified"> 169     return toSymbolic(number, alphabet, size);</span>
 170 }
 171 
 172 static NEVER_INLINE int toHebrewUnder1000(int number, UChar letters[5])
 173 {
 174     // FIXME: CSS3 mentions various refinements not implemented here.
 175     // FIXME: Should take a look at Mozilla&#39;s HebrewToText function (in nsBulletFrame).
 176     ASSERT(number &gt;= 0 &amp;&amp; number &lt; 1000);
 177     int length = 0;
 178     int fourHundreds = number / 400;
 179     for (int i = 0; i &lt; fourHundreds; i++)
 180         letters[length++] = 1511 + 3;
 181     number %= 400;
 182     if (number / 100)
 183         letters[length++] = 1511 + (number / 100) - 1;
 184     number %= 100;
 185     if (number == 15 || number == 16) {
 186         letters[length++] = 1487 + 9;
 187         letters[length++] = 1487 + number - 9;
 188     } else {
 189         if (int tens = number / 10) {
 190             static const UChar hebrewTens[9] = { 1497, 1499, 1500, 1502, 1504, 1505, 1506, 1508, 1510 };
 191             letters[length++] = hebrewTens[tens - 1];
 192         }
 193         if (int ones = number % 10)
 194             letters[length++] = 1487 + ones;
 195     }
 196     ASSERT(length &lt;= 5);
 197     return length;
 198 }
 199 
<span class="line-modified"> 200 static NEVER_INLINE String toHebrew(int number)</span>
 201 {
 202     // FIXME: CSS3 mentions ways to make this work for much larger numbers.
 203     ASSERT(number &gt;= 0 &amp;&amp; number &lt;= 999999);
 204 
 205     if (number == 0) {
 206         static const UChar hebrewZero[3] = { 0x05D0, 0x05E4, 0x05E1 };
<span class="line-modified"> 207         return String { hebrewZero, 3 };</span>

 208     }
 209 
<span class="line-modified"> 210     constexpr unsigned lettersSize = 11; // big enough for two 5-digit sequences plus a quote mark between</span>
 211     UChar letters[lettersSize];
 212 
<span class="line-modified"> 213     unsigned length;</span>
 214     if (number &lt; 1000)
 215         length = 0;
 216     else {
 217         length = toHebrewUnder1000(number / 1000, letters);
 218         letters[length++] = &#39;\&#39;&#39;;
 219         number = number % 1000;
 220     }
 221     length += toHebrewUnder1000(number, letters + length);
 222 
 223     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 224     return String { letters, length };</span>
 225 }
 226 
<span class="line-modified"> 227 static NEVER_INLINE unsigned toArmenianUnder10000(int number, LetterCase letterCase, bool addCircumflex, UChar letters[9])</span>
 228 {
 229     ASSERT(number &gt;= 0 &amp;&amp; number &lt; 10000);
<span class="line-modified"> 230     unsigned length = 0;</span>
 231 
<span class="line-modified"> 232     int lowerOffset = letterCase == LetterCase::Upper ? 0 : 0x0030;</span>
 233 
 234     if (int thousands = number / 1000) {
 235         if (thousands == 7) {
 236             letters[length++] = 0x0552 + lowerOffset;
 237             if (addCircumflex)
 238                 letters[length++] = 0x0302;
 239         } else {
 240             letters[length++] = (0x054C - 1 + lowerOffset) + thousands;
 241             if (addCircumflex)
 242                 letters[length++] = 0x0302;
 243         }
 244     }
 245 
 246     if (int hundreds = (number / 100) % 10) {
 247         letters[length++] = (0x0543 - 1 + lowerOffset) + hundreds;
 248         if (addCircumflex)
 249             letters[length++] = 0x0302;
 250     }
 251 
 252     if (int tens = (number / 10) % 10) {
 253         letters[length++] = (0x053A - 1 + lowerOffset) + tens;
 254         if (addCircumflex)
 255             letters[length++] = 0x0302;
 256     }
 257 
 258     if (int ones = number % 10) {
 259         letters[length++] = (0x531 - 1 + lowerOffset) + ones;
 260         if (addCircumflex)
 261             letters[length++] = 0x0302;
 262     }
 263 
 264     return length;
 265 }
 266 
<span class="line-modified"> 267 static NEVER_INLINE String toArmenian(int number, LetterCase letterCase)</span>
 268 {
 269     ASSERT(number &gt;= 1 &amp;&amp; number &lt;= 99999999);
 270 
<span class="line-modified"> 271     constexpr unsigned lettersSize = 18; // twice what toArmenianUnder10000 needs</span>
 272     UChar letters[lettersSize];
 273 
<span class="line-modified"> 274     unsigned length = toArmenianUnder10000(number / 10000, letterCase, true, letters);</span>
<span class="line-modified"> 275     length += toArmenianUnder10000(number % 10000, letterCase, false, letters + length);</span>
 276 
 277     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 278     return String { letters, length };</span>
 279 }
 280 
<span class="line-modified"> 281 static NEVER_INLINE String toGeorgian(int number)</span>
 282 {
 283     ASSERT(number &gt;= 1 &amp;&amp; number &lt;= 19999);
 284 
<span class="line-modified"> 285     constexpr unsigned lettersSize = 5;</span>
 286     UChar letters[lettersSize];
 287 
<span class="line-modified"> 288     unsigned length = 0;</span>
 289 
 290     if (number &gt; 9999)
 291         letters[length++] = 0x10F5;
 292 
 293     if (int thousands = (number / 1000) % 10) {
 294         static const UChar georgianThousands[9] = {
 295             0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10F4, 0x10EF, 0x10F0
 296         };
 297         letters[length++] = georgianThousands[thousands - 1];
 298     }
 299 
 300     if (int hundreds = (number / 100) % 10) {
 301         static const UChar georgianHundreds[9] = {
 302             0x10E0, 0x10E1, 0x10E2, 0x10F3, 0x10E4, 0x10E5, 0x10E6, 0x10E7, 0x10E8
 303         };
 304         letters[length++] = georgianHundreds[hundreds - 1];
 305     }
 306 
 307     if (int tens = (number / 10) % 10) {
 308         static const UChar georgianTens[9] = {
 309             0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10F2, 0x10DD, 0x10DE, 0x10DF
 310         };
 311         letters[length++] = georgianTens[tens - 1];
 312     }
 313 
 314     if (int ones = number % 10) {
 315         static const UChar georgianOnes[9] = {
 316             0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6, 0x10F1, 0x10D7
 317         };
 318         letters[length++] = georgianOnes[ones - 1];
 319     }
 320 
 321     ASSERT(length &lt;= lettersSize);
<span class="line-modified"> 322     return String { letters, length };</span>
 323 }
 324 
 325 // The table uses the order from the CSS3 specification:
 326 // first 3 group markers, then 3 digit markers, then ten digits.
<span class="line-modified"> 327 static NEVER_INLINE String toCJKIdeographic(int number, const UChar table[16])</span>
 328 {
 329     ASSERT(number &gt;= 0);
 330 
 331     enum AbstractCJKChar {
 332         noChar,
 333         secondGroupMarker, thirdGroupMarker, fourthGroupMarker,
 334         secondDigitMarker, thirdDigitMarker, fourthDigitMarker,
 335         digit0, digit1, digit2, digit3, digit4,
 336         digit5, digit6, digit7, digit8, digit9
 337     };
 338 
<span class="line-modified"> 339     if (!number)</span>
<span class="line-modified"> 340         return String { &amp;table[digit0 - 1] , 1 };</span>


 341 
<span class="line-modified"> 342     constexpr unsigned groupLength = 8; // 4 digits, 3 digit markers, and a group marker</span>
<span class="line-modified"> 343     constexpr unsigned bufferLength = 4 * groupLength;</span>
 344     AbstractCJKChar buffer[bufferLength] = { noChar };
 345 
 346     for (int i = 0; i &lt; 4; ++i) {
 347         int groupValue = number % 10000;
 348         number /= 10000;
 349 
 350         // Process least-significant group first, but put it in the buffer last.
 351         AbstractCJKChar* group = &amp;buffer[(3 - i) * groupLength];
 352 
 353         if (groupValue &amp;&amp; i)
 354             group[7] = static_cast&lt;AbstractCJKChar&gt;(secondGroupMarker - 1 + i);
 355 
 356         // Put in the four digits and digit markers for any non-zero digits.
 357         group[6] = static_cast&lt;AbstractCJKChar&gt;(digit0 + (groupValue % 10));
 358         if (number != 0 || groupValue &gt; 9) {
 359             int digitValue = ((groupValue / 10) % 10);
 360             group[4] = static_cast&lt;AbstractCJKChar&gt;(digit0 + digitValue);
 361             if (digitValue)
 362                 group[5] = secondDigitMarker;
 363         }
 364         if (number != 0 || groupValue &gt; 99) {
 365             int digitValue = ((groupValue / 100) % 10);
 366             group[2] = static_cast&lt;AbstractCJKChar&gt;(digit0 + digitValue);
 367             if (digitValue)
 368                 group[3] = thirdDigitMarker;
 369         }
 370         if (number != 0 || groupValue &gt; 999) {
 371             int digitValue = groupValue / 1000;
 372             group[0] = static_cast&lt;AbstractCJKChar&gt;(digit0 + digitValue);
 373             if (digitValue)
 374                 group[1] = fourthDigitMarker;
 375         }
 376 
 377         // Remove the tens digit, but leave the marker, for any group that has
 378         // a value of less than 20.
 379         if (groupValue &lt; 20) {
 380             ASSERT(group[4] == noChar || group[4] == digit0 || group[4] == digit1);
 381             group[4] = noChar;
 382         }
 383 
<span class="line-modified"> 384         if (!number)</span>
 385             break;
 386     }
 387 
<span class="line-modified"> 388     // Convert into characters, omitting consecutive runs of digit0 and trailing digit0.</span>
<span class="line-modified"> 389     unsigned length = 0;</span>

 390     UChar characters[bufferLength];
 391     AbstractCJKChar last = noChar;
<span class="line-modified"> 392     for (unsigned i = 0; i &lt; bufferLength; ++i) {</span>
 393         AbstractCJKChar a = buffer[i];
 394         if (a != noChar) {
 395             if (a != digit0 || last != digit0)
 396                 characters[length++] = table[a - 1];
 397             last = a;
 398         }
 399     }
 400     if (last == digit0)
 401         --length;
 402 
<span class="line-modified"> 403     return String { characters, length };</span>
 404 }
 405 
 406 static ListStyleType effectiveListMarkerType(ListStyleType type, int value)
 407 {
 408     // Note, the following switch statement has been explicitly grouped
 409     // by list-style-type ordinal range.
 410     switch (type) {
 411     case ListStyleType::ArabicIndic:
 412     case ListStyleType::Bengali:
 413     case ListStyleType::Binary:
 414     case ListStyleType::Cambodian:
 415     case ListStyleType::Circle:
 416     case ListStyleType::DecimalLeadingZero:
 417     case ListStyleType::Decimal:
 418     case ListStyleType::Devanagari:
 419     case ListStyleType::Disc:
 420     case ListStyleType::Gujarati:
 421     case ListStyleType::Gurmukhi:
 422     case ListStyleType::Kannada:
 423     case ListStyleType::Khmer:
</pre>
<hr />
<pre>
 488     case ListStyleType::Tigre:
 489     case ListStyleType::TigrinyaEr:
 490     case ListStyleType::TigrinyaErAbegede:
 491     case ListStyleType::TigrinyaEt:
 492     case ListStyleType::TigrinyaEtAbegede:
 493     case ListStyleType::UpperAlpha:
 494     case ListStyleType::UpperArmenian:
 495     case ListStyleType::UpperGreek:
 496     case ListStyleType::UpperLatin:
 497     case ListStyleType::UpperNorwegian:
 498         return (value &lt; 1) ? ListStyleType::Decimal : type;
 499     }
 500 
 501     ASSERT_NOT_REACHED();
 502     return type;
 503 }
 504 
 505 static UChar listMarkerSuffix(ListStyleType type, int value)
 506 {
 507     // If the list-style-type cannot represent |value| because it&#39;s outside its
<span class="line-modified"> 508     // ordinal range then we fall back to another list style that can represent |value|.</span>
 509     ListStyleType effectiveType = effectiveListMarkerType(type, value);
 510 
 511     // Note, the following switch statement has been explicitly
 512     // grouped by list-style-type suffix.
 513     switch (effectiveType) {
 514     case ListStyleType::Asterisks:
 515     case ListStyleType::Circle:
 516     case ListStyleType::Disc:
 517     case ListStyleType::Footnotes:
 518     case ListStyleType::None:
 519     case ListStyleType::Square:
 520         return &#39; &#39;;
 521     case ListStyleType::Afar:
 522     case ListStyleType::Amharic:
 523     case ListStyleType::AmharicAbegede:
 524     case ListStyleType::Ethiopic:
 525     case ListStyleType::EthiopicAbegede:
 526     case ListStyleType::EthiopicAbegedeAmEt:
 527     case ListStyleType::EthiopicAbegedeGez:
 528     case ListStyleType::EthiopicAbegedeTiEr:
</pre>
<hr />
<pre>
 586     case ListStyleType::Telugu:
 587     case ListStyleType::Thai:
 588     case ListStyleType::Tibetan:
 589     case ListStyleType::UpperAlpha:
 590     case ListStyleType::UpperArmenian:
 591     case ListStyleType::UpperGreek:
 592     case ListStyleType::UpperHexadecimal:
 593     case ListStyleType::UpperLatin:
 594     case ListStyleType::UpperNorwegian:
 595     case ListStyleType::UpperRoman:
 596     case ListStyleType::Urdu:
 597         return &#39;.&#39;;
 598     }
 599 
 600     ASSERT_NOT_REACHED();
 601     return &#39;.&#39;;
 602 }
 603 
 604 String listMarkerText(ListStyleType type, int value)
 605 {
<span class="line-modified"> 606     // If the list-style-type cannot represent |value| because it&#39;s outside its</span>
<span class="line-modified"> 607     // ordinal range then we fall back to another list style that can represent |value|.</span>


 608     switch (effectiveListMarkerType(type, value)) {
 609     case ListStyleType::None:
 610         return emptyString();
 611 
 612     case ListStyleType::Asterisks: {
 613         static const LChar asterisksSymbols[1] = { 0x2A };
<span class="line-modified"> 614         return toSymbolic(value, asterisksSymbols);</span>

 615     }
 616     // We use the same characters for text security.
 617     // See RenderText::setInternalString.
 618     case ListStyleType::Circle:
<span class="line-modified"> 619         return String { &amp;whiteBullet, 1 };</span>

 620     case ListStyleType::Disc:
<span class="line-modified"> 621         return String { &amp;bullet, 1 };</span>

 622     case ListStyleType::Footnotes: {
 623         static const UChar footnotesSymbols[4] = { 0x002A, 0x2051, 0x2020, 0x2021 };
<span class="line-modified"> 624         return toSymbolic(value, footnotesSymbols);</span>

 625     }
 626     case ListStyleType::Square:
<span class="line-modified"> 627         // The CSS 2.1 test suite uses U+25EE BLACK MEDIUM SMALL SQUARE instead,</span>
<span class="line-modified"> 628         // but we used this because we thought it looked better.</span>
<span class="line-modified"> 629         return String { &amp;blackSquare, 1 };</span>

 630 
 631     case ListStyleType::Decimal:
<span class="line-modified"> 632         return String::number(value);</span>

 633 
 634     case ListStyleType::DecimalLeadingZero:
<span class="line-modified"> 635         if (value &gt;= 0 &amp;&amp; value &lt;= 9) {</span>
<span class="line-modified"> 636             LChar characters[2] = { &#39;0&#39;, static_cast&lt;LChar&gt;(&#39;0&#39; + value) }; // 00 to 09</span>
<span class="line-modified"> 637             return String { characters, 2 };</span>
 638         }
<span class="line-modified"> 639         if (value &gt;= -9 &amp;&amp; value &lt;= -1) {</span>
<span class="line-modified"> 640             LChar characters[3] = { &#39;-&#39;, &#39;0&#39;, static_cast&lt;LChar&gt;(&#39;0&#39; - value) }; // -01 to -09</span>
<span class="line-modified"> 641             return String { characters, 3 };</span>

 642         }
<span class="line-modified"> 643         return String::number(value);</span>


 644 
 645     case ListStyleType::ArabicIndic: {
 646         static const UChar arabicIndicNumerals[10] = {
 647             0x0660, 0x0661, 0x0662, 0x0663, 0x0664, 0x0665, 0x0666, 0x0667, 0x0668, 0x0669
 648         };
<span class="line-modified"> 649         return toNumeric(value, arabicIndicNumerals);</span>

 650     }
 651 
 652     case ListStyleType::Binary: {
 653         static const LChar binaryNumerals[2] = { &#39;0&#39;, &#39;1&#39; };
<span class="line-modified"> 654         return toNumeric(value, binaryNumerals);</span>

 655     }
 656 
 657     case ListStyleType::Bengali: {
 658         static const UChar bengaliNumerals[10] = {
 659             0x09E6, 0x09E7, 0x09E8, 0x09E9, 0x09EA, 0x09EB, 0x09EC, 0x09ED, 0x09EE, 0x09EF
 660         };
<span class="line-modified"> 661         return toNumeric(value, bengaliNumerals);</span>

 662     }
 663 
 664     case ListStyleType::Cambodian:
 665     case ListStyleType::Khmer: {
 666         static const UChar khmerNumerals[10] = {
 667             0x17E0, 0x17E1, 0x17E2, 0x17E3, 0x17E4, 0x17E5, 0x17E6, 0x17E7, 0x17E8, 0x17E9
 668         };
<span class="line-modified"> 669         return toNumeric(value, khmerNumerals);</span>

 670     }
 671     case ListStyleType::Devanagari: {
 672         static const UChar devanagariNumerals[10] = {
 673             0x0966, 0x0967, 0x0968, 0x0969, 0x096A, 0x096B, 0x096C, 0x096D, 0x096E, 0x096F
 674         };
<span class="line-modified"> 675         return toNumeric(value, devanagariNumerals);</span>

 676     }
 677     case ListStyleType::Gujarati: {
 678         static const UChar gujaratiNumerals[10] = {
 679             0x0AE6, 0x0AE7, 0x0AE8, 0x0AE9, 0x0AEA, 0x0AEB, 0x0AEC, 0x0AED, 0x0AEE, 0x0AEF
 680         };
<span class="line-modified"> 681         return toNumeric(value, gujaratiNumerals);</span>

 682     }
 683     case ListStyleType::Gurmukhi: {
 684         static const UChar gurmukhiNumerals[10] = {
 685             0x0A66, 0x0A67, 0x0A68, 0x0A69, 0x0A6A, 0x0A6B, 0x0A6C, 0x0A6D, 0x0A6E, 0x0A6F
 686         };
<span class="line-modified"> 687         return toNumeric(value, gurmukhiNumerals);</span>

 688     }
 689     case ListStyleType::Kannada: {
 690         static const UChar kannadaNumerals[10] = {
 691             0x0CE6, 0x0CE7, 0x0CE8, 0x0CE9, 0x0CEA, 0x0CEB, 0x0CEC, 0x0CED, 0x0CEE, 0x0CEF
 692         };
<span class="line-modified"> 693         return toNumeric(value, kannadaNumerals);</span>

 694     }
 695     case ListStyleType::LowerHexadecimal: {
 696         static const LChar lowerHexadecimalNumerals[16] = {
 697             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;
 698         };
<span class="line-modified"> 699         return toNumeric(value, lowerHexadecimalNumerals);</span>

 700     }
 701     case ListStyleType::Lao: {
 702         static const UChar laoNumerals[10] = {
 703             0x0ED0, 0x0ED1, 0x0ED2, 0x0ED3, 0x0ED4, 0x0ED5, 0x0ED6, 0x0ED7, 0x0ED8, 0x0ED9
 704         };
<span class="line-modified"> 705         return toNumeric(value, laoNumerals);</span>

 706     }
 707     case ListStyleType::Malayalam: {
 708         static const UChar malayalamNumerals[10] = {
 709             0x0D66, 0x0D67, 0x0D68, 0x0D69, 0x0D6A, 0x0D6B, 0x0D6C, 0x0D6D, 0x0D6E, 0x0D6F
 710         };
<span class="line-modified"> 711         return toNumeric(value, malayalamNumerals);</span>

 712     }
 713     case ListStyleType::Mongolian: {
 714         static const UChar mongolianNumerals[10] = {
 715             0x1810, 0x1811, 0x1812, 0x1813, 0x1814, 0x1815, 0x1816, 0x1817, 0x1818, 0x1819
 716         };
<span class="line-modified"> 717         return toNumeric(value, mongolianNumerals);</span>

 718     }
 719     case ListStyleType::Myanmar: {
 720         static const UChar myanmarNumerals[10] = {
 721             0x1040, 0x1041, 0x1042, 0x1043, 0x1044, 0x1045, 0x1046, 0x1047, 0x1048, 0x1049
 722         };
<span class="line-modified"> 723         return toNumeric(value, myanmarNumerals);</span>

 724     }
 725     case ListStyleType::Octal: {
 726         static const LChar octalNumerals[8] = {
 727             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;
 728         };
<span class="line-modified"> 729         return toNumeric(value, octalNumerals);</span>

 730     }
 731     case ListStyleType::Oriya: {
 732         static const UChar oriyaNumerals[10] = {
 733             0x0B66, 0x0B67, 0x0B68, 0x0B69, 0x0B6A, 0x0B6B, 0x0B6C, 0x0B6D, 0x0B6E, 0x0B6F
 734         };
<span class="line-modified"> 735         return toNumeric(value, oriyaNumerals);</span>

 736     }
 737     case ListStyleType::Persian:
 738     case ListStyleType::Urdu: {
 739         static const UChar urduNumerals[10] = {
 740             0x06F0, 0x06F1, 0x06F2, 0x06F3, 0x06F4, 0x06F5, 0x06F6, 0x06F7, 0x06F8, 0x06F9
 741         };
<span class="line-modified"> 742         return toNumeric(value, urduNumerals);</span>

 743     }
 744     case ListStyleType::Telugu: {
 745         static const UChar teluguNumerals[10] = {
 746             0x0C66, 0x0C67, 0x0C68, 0x0C69, 0x0C6A, 0x0C6B, 0x0C6C, 0x0C6D, 0x0C6E, 0x0C6F
 747         };
<span class="line-modified"> 748         return toNumeric(value, teluguNumerals);</span>

 749     }
 750     case ListStyleType::Tibetan: {
 751         static const UChar tibetanNumerals[10] = {
 752             0x0F20, 0x0F21, 0x0F22, 0x0F23, 0x0F24, 0x0F25, 0x0F26, 0x0F27, 0x0F28, 0x0F29
 753         };
<span class="line-modified"> 754         return toNumeric(value, tibetanNumerals);</span>

 755     }
 756     case ListStyleType::Thai: {
 757         static const UChar thaiNumerals[10] = {
 758             0x0E50, 0x0E51, 0x0E52, 0x0E53, 0x0E54, 0x0E55, 0x0E56, 0x0E57, 0x0E58, 0x0E59
 759         };
<span class="line-modified"> 760         return toNumeric(value, thaiNumerals);</span>

 761     }
 762     case ListStyleType::UpperHexadecimal: {
 763         static const LChar upperHexadecimalNumerals[16] = {
 764             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
 765         };
<span class="line-modified"> 766         return toNumeric(value, upperHexadecimalNumerals);</span>

 767     }
 768 
 769     case ListStyleType::LowerAlpha:
 770     case ListStyleType::LowerLatin: {
 771         static const LChar lowerLatinAlphabet[26] = {
 772             &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
 773             &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;
 774         };
<span class="line-modified"> 775         return toAlphabetic(value, lowerLatinAlphabet);</span>

 776     }
 777     case ListStyleType::UpperAlpha:
 778     case ListStyleType::UpperLatin: {
 779         static const LChar upperLatinAlphabet[26] = {
 780             &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
 781             &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;
 782         };
<span class="line-modified"> 783         return toAlphabetic(value, upperLatinAlphabet);</span>

 784     }
 785     case ListStyleType::LowerGreek: {
 786         static const UChar lowerGreekAlphabet[24] = {
 787             0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8,
 788             0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0,
 789             0x03C1, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8, 0x03C9
 790         };
<span class="line-modified"> 791         return toAlphabetic(value, lowerGreekAlphabet);</span>

 792     }
 793 
 794     case ListStyleType::Hiragana: {
 795         // FIXME: This table comes from the CSS3 draft, and is probably
 796         // incorrect, given the comments in that draft.
 797         static const UChar hiraganaAlphabet[48] = {
 798             0x3042, 0x3044, 0x3046, 0x3048, 0x304A, 0x304B, 0x304D, 0x304F,
 799             0x3051, 0x3053, 0x3055, 0x3057, 0x3059, 0x305B, 0x305D, 0x305F,
 800             0x3061, 0x3064, 0x3066, 0x3068, 0x306A, 0x306B, 0x306C, 0x306D,
 801             0x306E, 0x306F, 0x3072, 0x3075, 0x3078, 0x307B, 0x307E, 0x307F,
 802             0x3080, 0x3081, 0x3082, 0x3084, 0x3086, 0x3088, 0x3089, 0x308A,
 803             0x308B, 0x308C, 0x308D, 0x308F, 0x3090, 0x3091, 0x3092, 0x3093
 804         };
<span class="line-modified"> 805         return toAlphabetic(value, hiraganaAlphabet);</span>

 806     }
 807     case ListStyleType::HiraganaIroha: {
 808         // FIXME: This table comes from the CSS3 draft, and is probably
 809         // incorrect, given the comments in that draft.
 810         static const UChar hiraganaIrohaAlphabet[47] = {
 811             0x3044, 0x308D, 0x306F, 0x306B, 0x307B, 0x3078, 0x3068, 0x3061,
 812             0x308A, 0x306C, 0x308B, 0x3092, 0x308F, 0x304B, 0x3088, 0x305F,
 813             0x308C, 0x305D, 0x3064, 0x306D, 0x306A, 0x3089, 0x3080, 0x3046,
 814             0x3090, 0x306E, 0x304A, 0x304F, 0x3084, 0x307E, 0x3051, 0x3075,
 815             0x3053, 0x3048, 0x3066, 0x3042, 0x3055, 0x304D, 0x3086, 0x3081,
 816             0x307F, 0x3057, 0x3091, 0x3072, 0x3082, 0x305B, 0x3059
 817         };
<span class="line-modified"> 818         return toAlphabetic(value, hiraganaIrohaAlphabet);</span>

 819     }
 820     case ListStyleType::Katakana: {
 821         // FIXME: This table comes from the CSS3 draft, and is probably
 822         // incorrect, given the comments in that draft.
 823         static const UChar katakanaAlphabet[48] = {
 824             0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD, 0x30AF,
 825             0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD, 0x30BF,
 826             0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC, 0x30CD,
 827             0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE, 0x30DF,
 828             0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9, 0x30EA,
 829             0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F0, 0x30F1, 0x30F2, 0x30F3
 830         };
<span class="line-modified"> 831         return toAlphabetic(value, katakanaAlphabet);</span>

 832     }
 833     case ListStyleType::KatakanaIroha: {
 834         // FIXME: This table comes from the CSS3 draft, and is probably
 835         // incorrect, given the comments in that draft.
 836         static const UChar katakanaIrohaAlphabet[47] = {
 837             0x30A4, 0x30ED, 0x30CF, 0x30CB, 0x30DB, 0x30D8, 0x30C8, 0x30C1,
 838             0x30EA, 0x30CC, 0x30EB, 0x30F2, 0x30EF, 0x30AB, 0x30E8, 0x30BF,
 839             0x30EC, 0x30BD, 0x30C4, 0x30CD, 0x30CA, 0x30E9, 0x30E0, 0x30A6,
 840             0x30F0, 0x30CE, 0x30AA, 0x30AF, 0x30E4, 0x30DE, 0x30B1, 0x30D5,
 841             0x30B3, 0x30A8, 0x30C6, 0x30A2, 0x30B5, 0x30AD, 0x30E6, 0x30E1,
 842             0x30DF, 0x30B7, 0x30F1, 0x30D2, 0x30E2, 0x30BB, 0x30B9
 843         };
<span class="line-modified"> 844         return toAlphabetic(value, katakanaIrohaAlphabet);</span>

 845     }
 846 
 847     case ListStyleType::Afar:
 848     case ListStyleType::EthiopicHalehameAaEt:
 849     case ListStyleType::EthiopicHalehameAaEr: {
 850         static const UChar ethiopicHalehameAaErAlphabet[18] = {
 851             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1260, 0x1270, 0x1290,
 852             0x12A0, 0x12A8, 0x12C8, 0x12D0, 0x12E8, 0x12F0, 0x1308, 0x1338, 0x1348
 853         };
<span class="line-modified"> 854         return toAlphabetic(value, ethiopicHalehameAaErAlphabet);</span>

 855     }
 856     case ListStyleType::Amharic:
 857     case ListStyleType::EthiopicHalehameAmEt: {
 858         static const UChar ethiopicHalehameAmEtAlphabet[33] = {
 859             0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228, 0x1230, 0x1238, 0x1240,
 860             0x1260, 0x1270, 0x1278, 0x1280, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12B8,
 861             0x12C8, 0x12D0, 0x12D8, 0x12E0, 0x12E8, 0x12F0, 0x1300, 0x1308, 0x1320,
 862             0x1328, 0x1330, 0x1338, 0x1340, 0x1348, 0x1350
 863         };
<span class="line-modified"> 864         return toAlphabetic(value, ethiopicHalehameAmEtAlphabet);</span>

 865     }
 866     case ListStyleType::AmharicAbegede:
 867     case ListStyleType::EthiopicAbegedeAmEt: {
 868         static const UChar ethiopicAbegedeAmEtAlphabet[33] = {
 869             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1300, 0x1200, 0x12C8, 0x12D8, 0x12E0,
 870             0x1210, 0x1320, 0x1328, 0x12E8, 0x12A8, 0x12B8, 0x1208, 0x1218, 0x1290,
 871             0x1298, 0x1220, 0x12D0, 0x1348, 0x1338, 0x1240, 0x1228, 0x1230, 0x1238,
 872             0x1270, 0x1278, 0x1280, 0x1340, 0x1330, 0x1350
 873         };
<span class="line-modified"> 874         return toAlphabetic(value, ethiopicAbegedeAmEtAlphabet);</span>

 875     }
 876     case ListStyleType::CjkEarthlyBranch: {
 877         static const UChar cjkEarthlyBranchAlphabet[12] = {
 878             0x5B50, 0x4E11, 0x5BC5, 0x536F, 0x8FB0, 0x5DF3, 0x5348, 0x672A, 0x7533,
 879             0x9149, 0x620C, 0x4EA5
 880         };
<span class="line-modified"> 881         return toAlphabetic(value, cjkEarthlyBranchAlphabet);</span>

 882     }
 883     case ListStyleType::CjkHeavenlyStem: {
 884         static const UChar cjkHeavenlyStemAlphabet[10] = {
 885             0x7532, 0x4E59, 0x4E19, 0x4E01, 0x620A, 0x5DF1, 0x5E9A, 0x8F9B, 0x58EC,
 886             0x7678
 887         };
<span class="line-modified"> 888         return toAlphabetic(value, cjkHeavenlyStemAlphabet);</span>

 889     }
 890     case ListStyleType::Ethiopic:
 891     case ListStyleType::EthiopicHalehameGez: {
 892         static const UChar ethiopicHalehameGezAlphabet[26] = {
 893             0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228, 0x1230, 0x1240, 0x1260,
 894             0x1270, 0x1280, 0x1290, 0x12A0, 0x12A8, 0x12C8, 0x12D0, 0x12D8, 0x12E8,
 895             0x12F0, 0x1308, 0x1320, 0x1330, 0x1338, 0x1340, 0x1348, 0x1350
 896         };
<span class="line-modified"> 897         return toAlphabetic(value, ethiopicHalehameGezAlphabet);</span>

 898     }
 899     case ListStyleType::EthiopicAbegede:
 900     case ListStyleType::EthiopicAbegedeGez: {
 901         static const UChar ethiopicAbegedeGezAlphabet[26] = {
 902             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1200, 0x12C8, 0x12D8, 0x1210, 0x1320,
 903             0x12E8, 0x12A8, 0x1208, 0x1218, 0x1290, 0x1220, 0x12D0, 0x1348, 0x1338,
 904             0x1240, 0x1228, 0x1230, 0x1270, 0x1280, 0x1340, 0x1330, 0x1350
 905         };
<span class="line-modified"> 906         return toAlphabetic(value, ethiopicAbegedeGezAlphabet);</span>

 907     }
 908     case ListStyleType::HangulConsonant: {
 909         static const UChar hangulConsonantAlphabet[14] = {
 910             0x3131, 0x3134, 0x3137, 0x3139, 0x3141, 0x3142, 0x3145, 0x3147, 0x3148,
 911             0x314A, 0x314B, 0x314C, 0x314D, 0x314E
 912         };
<span class="line-modified"> 913         return toAlphabetic(value, hangulConsonantAlphabet);</span>

 914     }
 915     case ListStyleType::Hangul: {
 916         static const UChar hangulAlphabet[14] = {
 917             0xAC00, 0xB098, 0xB2E4, 0xB77C, 0xB9C8, 0xBC14, 0xC0AC, 0xC544, 0xC790,
 918             0xCC28, 0xCE74, 0xD0C0, 0xD30C, 0xD558
 919         };
<span class="line-modified"> 920         return toAlphabetic(value, hangulAlphabet);</span>

 921     }
 922     case ListStyleType::Oromo:
 923     case ListStyleType::EthiopicHalehameOmEt: {
 924         static const UChar ethiopicHalehameOmEtAlphabet[25] = {
 925             0x1200, 0x1208, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260, 0x1270,
 926             0x1278, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12C8, 0x12E8, 0x12F0, 0x12F8,
 927             0x1300, 0x1308, 0x1320, 0x1328, 0x1338, 0x1330, 0x1348
 928         };
<span class="line-modified"> 929         return toAlphabetic(value, ethiopicHalehameOmEtAlphabet);</span>

 930     }
 931     case ListStyleType::Sidama:
 932     case ListStyleType::EthiopicHalehameSidEt: {
 933         static const UChar ethiopicHalehameSidEtAlphabet[26] = {
 934             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260,
 935             0x1270, 0x1278, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12C8, 0x12E8, 0x12F0,
 936             0x12F8, 0x1300, 0x1308, 0x1320, 0x1328, 0x1338, 0x1330, 0x1348
 937         };
<span class="line-modified"> 938         return toAlphabetic(value, ethiopicHalehameSidEtAlphabet);</span>

 939     }
 940     case ListStyleType::Somali:
 941     case ListStyleType::EthiopicHalehameSoEt: {
 942         static const UChar ethiopicHalehameSoEtAlphabet[22] = {
 943             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260,
 944             0x1270, 0x1290, 0x12A0, 0x12A8, 0x12B8, 0x12C8, 0x12D0, 0x12E8, 0x12F0,
 945             0x1300, 0x1308, 0x1338, 0x1348
 946         };
<span class="line-modified"> 947         return toAlphabetic(value, ethiopicHalehameSoEtAlphabet);</span>

 948     }
 949     case ListStyleType::Tigre:
 950     case ListStyleType::EthiopicHalehameTig: {
 951         static const UChar ethiopicHalehameTigAlphabet[27] = {
 952             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1260,
 953             0x1270, 0x1278, 0x1290, 0x12A0, 0x12A8, 0x12C8, 0x12D0, 0x12D8, 0x12E8,
 954             0x12F0, 0x1300, 0x1308, 0x1320, 0x1328, 0x1338, 0x1330, 0x1348, 0x1350
 955         };
<span class="line-modified"> 956         return toAlphabetic(value, ethiopicHalehameTigAlphabet);</span>

 957     }
 958     case ListStyleType::TigrinyaEr:
 959     case ListStyleType::EthiopicHalehameTiEr: {
 960         static const UChar ethiopicHalehameTiErAlphabet[31] = {
 961             0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230, 0x1238, 0x1240, 0x1250,
 962             0x1260, 0x1270, 0x1278, 0x1290, 0x1298, 0x12A0, 0x12A8, 0x12B8, 0x12C8,
 963             0x12D0, 0x12D8, 0x12E0, 0x12E8, 0x12F0, 0x1300, 0x1308, 0x1320, 0x1328,
 964             0x1330, 0x1338, 0x1348, 0x1350
 965         };
<span class="line-modified"> 966         return toAlphabetic(value, ethiopicHalehameTiErAlphabet);</span>

 967     }
 968     case ListStyleType::TigrinyaErAbegede:
 969     case ListStyleType::EthiopicAbegedeTiEr: {
 970         static const UChar ethiopicAbegedeTiErAlphabet[31] = {
 971             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1300, 0x1200, 0x12C8, 0x12D8, 0x12E0,
 972             0x1210, 0x1320, 0x1328, 0x12E8, 0x12A8, 0x12B8, 0x1208, 0x1218, 0x1290,
 973             0x1298, 0x12D0, 0x1348, 0x1338, 0x1240, 0x1250, 0x1228, 0x1230, 0x1238,
 974             0x1270, 0x1278, 0x1330, 0x1350
 975         };
<span class="line-modified"> 976         return toAlphabetic(value, ethiopicAbegedeTiErAlphabet);</span>

 977     }
 978     case ListStyleType::TigrinyaEt:
 979     case ListStyleType::EthiopicHalehameTiEt: {
 980         static const UChar ethiopicHalehameTiEtAlphabet[34] = {
 981             0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228, 0x1230, 0x1238, 0x1240,
 982             0x1250, 0x1260, 0x1270, 0x1278, 0x1280, 0x1290, 0x1298, 0x12A0, 0x12A8,
 983             0x12B8, 0x12C8, 0x12D0, 0x12D8, 0x12E0, 0x12E8, 0x12F0, 0x1300, 0x1308,
 984             0x1320, 0x1328, 0x1330, 0x1338, 0x1340, 0x1348, 0x1350
 985         };
<span class="line-modified"> 986         return toAlphabetic(value, ethiopicHalehameTiEtAlphabet);</span>

 987     }
 988     case ListStyleType::TigrinyaEtAbegede:
 989     case ListStyleType::EthiopicAbegedeTiEt: {
 990         static const UChar ethiopicAbegedeTiEtAlphabet[34] = {
 991             0x12A0, 0x1260, 0x1308, 0x12F0, 0x1300, 0x1200, 0x12C8, 0x12D8, 0x12E0,
 992             0x1210, 0x1320, 0x1328, 0x12E8, 0x12A8, 0x12B8, 0x1208, 0x1218, 0x1290,
 993             0x1298, 0x1220, 0x12D0, 0x1348, 0x1338, 0x1240, 0x1250, 0x1228, 0x1230,
 994             0x1238, 0x1270, 0x1278, 0x1280, 0x1340, 0x1330, 0x1350
 995         };
<span class="line-modified"> 996         return toAlphabetic(value, ethiopicAbegedeTiEtAlphabet);</span>

 997     }
 998     case ListStyleType::UpperGreek: {
 999         static const UChar upperGreekAlphabet[24] = {
1000             0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399,
1001             0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0, 0x03A1, 0x03A3,
1002             0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9
1003         };
<span class="line-modified">1004         return toAlphabetic(value, upperGreekAlphabet);</span>

1005     }
1006     case ListStyleType::LowerNorwegian: {
1007         static const LChar lowerNorwegianAlphabet[29] = {
1008             0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
1009             0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
1010             0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xE6,
1011             0xF8, 0xE5
1012         };
<span class="line-modified">1013         return toAlphabetic(value, lowerNorwegianAlphabet);</span>

1014     }
1015     case ListStyleType::UpperNorwegian: {
1016         static const LChar upperNorwegianAlphabet[29] = {
1017             0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
1018             0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
1019             0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xC6,
1020             0xD8, 0xC5
1021         };
<span class="line-modified">1022         return toAlphabetic(value, upperNorwegianAlphabet);</span>

1023     }
1024     case ListStyleType::CJKIdeographic: {
1025         static const UChar traditionalChineseInformalTable[16] = {
1026             0x842C, 0x5104, 0x5146,
1027             0x5341, 0x767E, 0x5343,
1028             0x96F6, 0x4E00, 0x4E8C, 0x4E09, 0x56DB,
1029             0x4E94, 0x516D, 0x4E03, 0x516B, 0x4E5D
1030         };
<span class="line-modified">1031         return toCJKIdeographic(value, traditionalChineseInformalTable);</span>

1032     }
1033 
1034     case ListStyleType::LowerRoman:
<span class="line-modified">1035         return toRoman(value, LetterCase::Lower);</span>

1036     case ListStyleType::UpperRoman:
<span class="line-modified">1037         return toRoman(value, LetterCase::Upper);</span>

1038 
<span class="line-added">1039     // A CSS3 draft said that &quot;armenian&quot; means &quot;lower-armenian&quot;. But the CSS2.1 test</span>
<span class="line-added">1040     // suite contains uppercase test results for &quot;armenian&quot;; our behavior matches that.</span>
1041     case ListStyleType::Armenian:
1042     case ListStyleType::UpperArmenian:
<span class="line-modified">1043         return toArmenian(value, LetterCase::Upper);</span>




1044     case ListStyleType::LowerArmenian:
<span class="line-modified">1045         return toArmenian(value, LetterCase::Lower);</span>
<span class="line-modified">1046 </span>
1047     case ListStyleType::Georgian:
<span class="line-modified">1048         return toGeorgian(value);</span>

1049     case ListStyleType::Hebrew:
<span class="line-modified">1050         return toHebrew(value);</span>

1051     }
1052 
<span class="line-modified">1053     ASSERT_NOT_REACHED();</span>
<span class="line-added">1054     return emptyString();</span>
1055 }
1056 
1057 RenderListMarker::RenderListMarker(RenderListItem&amp; listItem, RenderStyle&amp;&amp; style)
1058     : RenderBox(listItem.document(), WTFMove(style), 0)
1059     , m_listItem(makeWeakPtr(listItem))
1060 {
1061     // init RenderObject attributes
1062     setInline(true);   // our object is Inline
1063     setReplaced(true); // pretend to be replaced
1064 }
1065 
1066 RenderListMarker::~RenderListMarker()
1067 {
1068     // Do not add any code here. Add it to willBeDestroyed() instead.
1069 }
1070 
1071 void RenderListMarker::willBeDestroyed()
1072 {
1073     if (m_image)
1074         m_image-&gt;removeClient(this);
1075     RenderBox::willBeDestroyed();
1076 }
1077 
1078 void RenderListMarker::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
1079 {
1080     RenderBox::styleDidChange(diff, oldStyle);
1081 
1082     if (oldStyle) {
1083         if (style().listStylePosition() != oldStyle-&gt;listStylePosition() || style().listStyleType() != oldStyle-&gt;listStyleType())
<span class="line-modified">1084             setNeedsLayoutAndPrefWidthsRecalc();</span>
1085         if (oldStyle-&gt;isDisplayInlineType() &amp;&amp; !style().isDisplayInlineType()) {
1086             delete m_inlineBoxWrapper;
1087             m_inlineBoxWrapper = nullptr;
1088         }
1089     }
1090 
1091     if (m_image != style().listStyleImage()) {
1092         if (m_image)
1093             m_image-&gt;removeClient(this);
1094         m_image = style().listStyleImage();
1095         if (m_image)
1096             m_image-&gt;addClient(this);
1097     }
1098 }
1099 
1100 std::unique_ptr&lt;InlineElementBox&gt; RenderListMarker::createInlineBox()
1101 {
1102     auto box = RenderBox::createInlineBox();
1103     box-&gt;setBehavesLikeText(isText());
1104     return box;
1105 }
1106 
1107 bool RenderListMarker::isImage() const
1108 {
1109     return m_image &amp;&amp; !m_image-&gt;errorOccurred();
1110 }
1111 
1112 LayoutRect RenderListMarker::localSelectionRect()
1113 {
1114     InlineBox* box = inlineBoxWrapper();
1115     if (!box)
1116         return LayoutRect(LayoutPoint(), size());
1117     const RootInlineBox&amp; rootBox = m_inlineBoxWrapper-&gt;root();
<span class="line-modified">1118     LayoutUnit newLogicalTop { rootBox.blockFlow().style().isFlippedBlocksWritingMode() ? m_inlineBoxWrapper-&gt;logicalBottom() - rootBox.selectionBottom() : rootBox.selectionTop() - m_inlineBoxWrapper-&gt;logicalTop() };</span>
1119     if (rootBox.blockFlow().style().isHorizontalWritingMode())
1120         return LayoutRect(0_lu, newLogicalTop, width(), rootBox.selectionHeight());
1121     return LayoutRect(newLogicalTop, 0_lu, rootBox.selectionHeight(), height());
1122 }
1123 
1124 void RenderListMarker::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1125 {
1126     if (paintInfo.phase != PaintPhase::Foreground)
1127         return;
1128 
1129     if (style().visibility() != Visibility::Visible)
1130         return;
1131 
1132     LayoutPoint boxOrigin(paintOffset + location());
1133     LayoutRect overflowRect(visualOverflowRect());
1134     overflowRect.moveBy(boxOrigin);
1135     if (!paintInfo.rect.intersects(overflowRect))
1136         return;
1137 
1138     LayoutRect box(boxOrigin, size());
</pre>
<hr />
<pre>
1268 
1269     GraphicsContextStateSaver stateSaver(context, false);
1270     if (!style().isHorizontalWritingMode()) {
1271         markerRect.moveBy(-boxOrigin);
1272         markerRect = markerRect.transposedRect();
1273         markerRect.moveBy(FloatPoint(box.x(), box.y() - logicalHeight()));
1274         stateSaver.save();
1275         context.translate(markerRect.x(), markerRect.maxY());
1276         context.rotate(static_cast&lt;float&gt;(deg2rad(90.)));
1277         context.translate(-markerRect.x(), -markerRect.maxY());
1278     }
1279 
1280     FloatPoint textOrigin = FloatPoint(markerRect.x(), markerRect.y() + style().fontMetrics().ascent());
1281     textOrigin = roundPointToDevicePixels(LayoutPoint(textOrigin), document().deviceScaleFactor(), style().isLeftToRightDirection());
1282 
1283     if (type == ListStyleType::Asterisks || type == ListStyleType::Footnotes)
1284         context.drawText(font, textRun, textOrigin);
1285     else {
1286         const UChar suffix = listMarkerSuffix(type, m_listItem-&gt;value());
1287 
<span class="line-modified">1288         // FIXME: Could use a Vector with inline capacity instead of String to avoid</span>
<span class="line-modified">1289         // memory allocation here.</span>
<span class="line-modified">1290         String textToDraw;</span>
<span class="line-modified">1291 </span>
<span class="line-modified">1292         // Since marker text is not arbitrary, we can judge its direction just by</span>
<span class="line-added">1293         // checking the first character, and only need to handle U_RIGHT_TO_LEFT.</span>
<span class="line-added">1294         // FIXME: Could check more efficiently than u_charDirection, since we know</span>
<span class="line-added">1295         // only certain characters are used and only need to check for U_RIGHT_TO_LEFT.</span>
<span class="line-added">1296         if (u_charDirection(m_text[0]) == U_RIGHT_TO_LEFT) {</span>
1297             unsigned length = m_text.length();
<span class="line-modified">1298             UChar* characters;</span>
<span class="line-modified">1299             textToDraw = String::createUninitialized(length + 2, characters);</span>
1300             if (!style().isLeftToRightDirection()) {
<span class="line-modified">1301                 *characters++ = space;</span>
<span class="line-modified">1302                 *characters++ = suffix;</span>
1303             }
1304             for (unsigned i = 0; i &lt; length; ++i)
<span class="line-modified">1305                 *characters++ = m_text[length - i - 1];</span>
1306             if (style().isLeftToRightDirection()) {
<span class="line-modified">1307                 *characters++ = suffix;</span>
<span class="line-modified">1308                 *characters++ = space;</span>
1309             }

1310         } else {
1311             if (style().isLeftToRightDirection())
<span class="line-modified">1312                 textToDraw = makeString(m_text, suffix, space);</span>
1313             else
<span class="line-modified">1314                 textToDraw = makeString(space, suffix, m_text);</span>
1315         }
<span class="line-modified">1316         textRun.setText(textToDraw);</span>
1317 
1318         context.drawText(font, textRun, textOrigin);
1319     }
1320 }
1321 
1322 void RenderListMarker::layout()
1323 {
1324     StackStats::LayoutCheckPoint layoutCheckPoint;
1325     ASSERT(needsLayout());
1326 
1327     LayoutUnit blockOffset;
1328     for (auto* ancestor = parentBox(); ancestor &amp;&amp; ancestor != m_listItem.get(); ancestor = ancestor-&gt;parentBox())
1329         blockOffset += ancestor-&gt;logicalTop();
1330     if (style().isLeftToRightDirection())
1331         m_lineOffsetForListItem = m_listItem-&gt;logicalLeftOffsetForLine(blockOffset, DoNotIndentText, 0_lu);
1332     else
1333         m_lineOffsetForListItem = m_listItem-&gt;logicalRightOffsetForLine(blockOffset, DoNotIndentText, 0_lu);
1334 
1335     if (isImage()) {
1336         updateMarginsAndContent();
1337         setWidth(m_image-&gt;imageSize(this, style().effectiveZoom()).width());
1338         setHeight(m_image-&gt;imageSize(this, style().effectiveZoom()).height());
1339     } else {
1340         setLogicalWidth(minPreferredLogicalWidth());
1341         setLogicalHeight(style().fontMetrics().height());
1342     }
1343 
1344     setMarginStart(0);
1345     setMarginEnd(0);
1346 
1347     Length startMargin = style().marginStart();
1348     Length endMargin = style().marginEnd();
1349     if (startMargin.isFixed())
<span class="line-modified">1350         setMarginStart(LayoutUnit(startMargin.value()));</span>
1351     if (endMargin.isFixed())
<span class="line-modified">1352         setMarginEnd(LayoutUnit(endMargin.value()));</span>
1353 
1354     clearNeedsLayout();
1355 }
1356 
1357 void RenderListMarker::imageChanged(WrappedImagePtr o, const IntRect*)
1358 {
1359     // A list marker can&#39;t have a background or border image, so no need to call the base class method.
1360     if (o != m_image-&gt;data())
1361         return;
1362 
1363     if (width() != m_image-&gt;imageSize(this, style().effectiveZoom()).width() || height() != m_image-&gt;imageSize(this, style().effectiveZoom()).height() || m_image-&gt;errorOccurred())
1364         setNeedsLayoutAndPrefWidthsRecalc();
1365     else
1366         repaint();
1367 }
1368 
1369 void RenderListMarker::updateMarginsAndContent()
1370 {
1371     updateContent();
1372     updateMargins();
</pre>
<hr />
<pre>
1489 
1490     if (isImage()) {
1491         LayoutSize imageSize = LayoutSize(m_image-&gt;imageSize(this, style().effectiveZoom()));
1492         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = style().isHorizontalWritingMode() ? imageSize.width() : imageSize.height();
1493         setPreferredLogicalWidthsDirty(false);
1494         updateMargins();
1495         return;
1496     }
1497 
1498     const FontCascade&amp; font = style().fontCascade();
1499 
1500     LayoutUnit logicalWidth;
1501     ListStyleType type = style().listStyleType();
1502     switch (type) {
1503     case ListStyleType::None:
1504         break;
1505     case ListStyleType::Asterisks:
1506     case ListStyleType::Footnotes: {
1507         TextRun run = RenderBlock::constructTextRun(m_text, style());
1508         logicalWidth = font.width(run); // no suffix for these types

1509         break;
<span class="line-added">1510     }</span>
1511     case ListStyleType::Circle:
1512     case ListStyleType::Disc:
1513     case ListStyleType::Square:
1514         logicalWidth = (font.fontMetrics().ascent() * 2 / 3 + 1) / 2 + 2;
1515         break;
1516     case ListStyleType::Afar:
1517     case ListStyleType::Amharic:
1518     case ListStyleType::AmharicAbegede:
1519     case ListStyleType::ArabicIndic:
1520     case ListStyleType::Armenian:
1521     case ListStyleType::Binary:
1522     case ListStyleType::Bengali:
1523     case ListStyleType::Cambodian:
1524     case ListStyleType::CJKIdeographic:
1525     case ListStyleType::CjkEarthlyBranch:
1526     case ListStyleType::CjkHeavenlyStem:
1527     case ListStyleType::DecimalLeadingZero:
1528     case ListStyleType::Decimal:
1529     case ListStyleType::Devanagari:
1530     case ListStyleType::Ethiopic:
</pre>
<hr />
<pre>
1575     case ListStyleType::Telugu:
1576     case ListStyleType::Thai:
1577     case ListStyleType::Tibetan:
1578     case ListStyleType::Tigre:
1579     case ListStyleType::TigrinyaEr:
1580     case ListStyleType::TigrinyaErAbegede:
1581     case ListStyleType::TigrinyaEt:
1582     case ListStyleType::TigrinyaEtAbegede:
1583     case ListStyleType::UpperAlpha:
1584     case ListStyleType::UpperArmenian:
1585     case ListStyleType::UpperGreek:
1586     case ListStyleType::UpperHexadecimal:
1587     case ListStyleType::UpperLatin:
1588     case ListStyleType::UpperNorwegian:
1589     case ListStyleType::UpperRoman:
1590     case ListStyleType::Urdu:
1591         if (m_text.isEmpty())
1592             logicalWidth = 0;
1593         else {
1594             TextRun run = RenderBlock::constructTextRun(m_text, style());
<span class="line-modified">1595             LayoutUnit itemWidth { font.width(run) };</span>
1596             UChar suffixSpace[2] = { listMarkerSuffix(type, m_listItem-&gt;value()), &#39; &#39; };
<span class="line-modified">1597             LayoutUnit suffixSpaceWidth { font.width(RenderBlock::constructTextRun(suffixSpace, 2, style())) };</span>
1598             logicalWidth = itemWidth + suffixSpaceWidth;
1599         }
1600         break;
1601     }
1602 
1603     m_minPreferredLogicalWidth = logicalWidth;
1604     m_maxPreferredLogicalWidth = logicalWidth;
1605 
1606     setPreferredLogicalWidthsDirty(false);
1607 
1608     updateMargins();
1609 }
1610 
1611 void RenderListMarker::updateMargins()
1612 {
1613     const FontMetrics&amp; fontMetrics = style().fontMetrics();
1614 
1615     LayoutUnit marginStart;
1616     LayoutUnit marginEnd;
1617 
</pre>
</td>
</tr>
</table>
<center><a href="RenderListBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderMarquee.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>