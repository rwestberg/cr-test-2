<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSONObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Library General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Library General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Library General Public License
  18  *  along with this library; see the file COPYING.LIB.  If not, write to
  19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  *  Boston, MA 02110-1301, USA.
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;JSObject.h&quot;
  26 
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;CustomGetterSetter.h&quot;
  30 #include &quot;DatePrototype.h&quot;
  31 #include &quot;ErrorConstructor.h&quot;
  32 #include &quot;Exception.h&quot;

  33 #include &quot;GetterSetter.h&quot;
<span class="line-modified">  34 #include &quot;HeapSnapshotBuilder.h&quot;</span>
  35 #include &quot;IndexingHeaderInlines.h&quot;
  36 #include &quot;JSCInlines.h&quot;
  37 #include &quot;JSCustomGetterSetterFunction.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSGlobalObject.h&quot;
  40 #include &quot;JSImmutableButterfly.h&quot;
  41 #include &quot;Lookup.h&quot;
  42 #include &quot;NativeErrorConstructor.h&quot;
  43 #include &quot;ObjectPrototype.h&quot;
  44 #include &quot;PropertyDescriptor.h&quot;
  45 #include &quot;PropertyNameArray.h&quot;
  46 #include &quot;ProxyObject.h&quot;
  47 #include &quot;SlotVisitorInlines.h&quot;
  48 #include &quot;TypeError.h&quot;
  49 #include &quot;VMInlines.h&quot;
  50 #include &lt;math.h&gt;
  51 #include &lt;wtf/Assertions.h&gt;
  52 
  53 namespace JSC {
  54 
</pre>
<hr />
<pre>
  69 const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError { &quot;Attempting to change configurable attribute of unconfigurable property.&quot;_s };
  70 const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError { &quot;Attempting to change enumerable attribute of unconfigurable property.&quot;_s };
  71 const ASCIILiteral UnconfigurablePropertyChangeWritabilityError { &quot;Attempting to change writable attribute of unconfigurable property.&quot;_s };
  72 
  73 const ClassInfo JSObject::s_info = { &quot;Object&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSObject) };
  74 
  75 const ClassInfo JSFinalObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFinalObject) };
  76 
  77 static inline void getClassPropertyNames(ExecState* exec, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
  78 {
  79     VM&amp; vm = exec-&gt;vm();
  80 
  81     // Add properties from the static hashtables of properties
  82     for (; classInfo; classInfo = classInfo-&gt;parentClass) {
  83         const HashTable* table = classInfo-&gt;staticPropHashTable;
  84         if (!table)
  85             continue;
  86 
  87         for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
  88             if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
<span class="line-modified">  89                 propertyNames.add(Identifier::fromString(&amp;vm, iter.key()));</span>
  90         }
  91     }
  92 }
  93 
  94 ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset lastOffset)
  95 {
  96     // We call this when we found everything without races.
  97     ASSERT(structure);
  98 
  99     if (!butterfly)
 100         return;
 101 
 102     if (isCopyOnWrite(structure-&gt;indexingMode())) {
 103         visitor.append(bitwise_cast&lt;WriteBarrier&lt;JSCell&gt;&gt;(JSImmutableButterfly::fromButterfly(butterfly)));
 104         return;
 105     }
 106 
 107     bool hasIndexingHeader = structure-&gt;hasIndexingHeader(this);
 108     size_t preCapacity;
 109     if (hasIndexingHeader)
</pre>
<hr />
<pre>
 432 }
 433 
 434 void JSObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 435 {
 436     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 437     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 438 #if !ASSERT_DISABLED
 439     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 440     visitor.m_isCheckingForDefaultMarkViolation = false;
 441 #endif
 442 
 443     JSCell::visitChildren(thisObject, visitor);
 444 
 445     thisObject-&gt;visitButterfly(visitor);
 446 
 447 #if !ASSERT_DISABLED
 448     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 449 #endif
 450 }
 451 
<span class="line-modified"> 452 void JSObject::heapSnapshot(JSCell* cell, HeapSnapshotBuilder&amp; builder)</span>
 453 {
 454     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<span class="line-modified"> 455     Base::heapSnapshot(cell, builder);</span>
 456 
 457     Structure* structure = thisObject-&gt;structure();
 458     for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
 459         JSValue toValue = thisObject-&gt;getDirect(entry.offset);
 460         if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified"> 461             builder.appendPropertyNameEdge(thisObject, toValue.asCell(), entry.key);</span>
 462     }
 463 
 464     Butterfly* butterfly = thisObject-&gt;butterfly();
 465     if (butterfly) {
 466         WriteBarrier&lt;Unknown&gt;* data = nullptr;
 467         uint32_t count = 0;
 468 
 469         switch (thisObject-&gt;indexingType()) {
 470         case ALL_CONTIGUOUS_INDEXING_TYPES:
 471             data = butterfly-&gt;contiguous().data();
 472             count = butterfly-&gt;publicLength();
 473             break;
 474         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 475             data = butterfly-&gt;arrayStorage()-&gt;m_vector;
 476             count = butterfly-&gt;arrayStorage()-&gt;vectorLength();
 477             break;
 478         default:
 479             break;
 480         }
 481 
 482         for (uint32_t i = 0; i &lt; count; ++i) {
 483             JSValue toValue = data[i].get();
 484             if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified"> 485                 builder.appendIndexEdge(thisObject, toValue.asCell(), i);</span>
 486         }
 487     }
 488 }
 489 
 490 void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 491 {
 492     JSFinalObject* thisObject = jsCast&lt;JSFinalObject*&gt;(cell);
 493     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 494 #if !ASSERT_DISABLED
 495     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 496     visitor.m_isCheckingForDefaultMarkViolation = false;
 497 #endif
 498 
 499     JSCell::visitChildren(thisObject, visitor);
 500 
 501     if (Structure* structure = thisObject-&gt;visitButterfly(visitor)) {
 502         if (unsigned storageSize = structure-&gt;inlineSize())
 503             visitor.appendValuesHidden(thisObject-&gt;inlineStorage(), storageSize);
 504     }
 505 
</pre>
<hr />
<pre>
 508 #endif
 509 }
 510 
 511 String JSObject::className(const JSObject* object, VM&amp; vm)
 512 {
 513     const ClassInfo* info = object-&gt;classInfo(vm);
 514     ASSERT(info);
 515     return info-&gt;className;
 516 }
 517 
 518 String JSObject::toStringName(const JSObject* object, ExecState* exec)
 519 {
 520     VM&amp; vm = exec-&gt;vm();
 521     const ClassInfo* info = object-&gt;classInfo(vm);
 522     ASSERT(info);
 523     return info-&gt;className;
 524 }
 525 
 526 String JSObject::calculatedClassName(JSObject* object)
 527 {
<span class="line-modified"> 528     String prototypeFunctionName;</span>
<span class="line-modified"> 529     auto globalObject = object-&gt;globalObject();</span>

 530     VM&amp; vm = globalObject-&gt;vm();
 531     auto scope = DECLARE_CATCH_SCOPE(vm);

 532 
<span class="line-modified"> 533     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-modified"> 534     PropertySlot slot(object-&gt;getPrototypeDirect(vm), PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-modified"> 535     PropertyName constructor(vm.propertyNames-&gt;constructor);</span>
<span class="line-modified"> 536     if (object-&gt;getPropertySlot(exec, constructor, slot)) {</span>
 537         EXCEPTION_ASSERT(!scope.exception());
 538         if (slot.isValue()) {
<span class="line-modified"> 539             JSValue constructorValue = slot.getValue(exec, constructor);</span>
<span class="line-modified"> 540             if (constructorValue.isCell()) {</span>
<span class="line-modified"> 541                 if (JSCell* constructorCell = constructorValue.asCell()) {</span>
<span class="line-modified"> 542                     if (JSObject* ctorObject = constructorCell-&gt;getObject()) {</span>
<span class="line-modified"> 543                         if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified"> 544                             prototypeFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-modified"> 545                         else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified"> 546                             prototypeFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>























 547                     }
 548                 }
 549             }
 550         }
 551     }
<span class="line-modified"> 552     EXCEPTION_ASSERT(!scope.exception() || prototypeFunctionName.isNull());</span>

 553     if (UNLIKELY(scope.exception()))
 554         scope.clearException();
 555 
<span class="line-modified"> 556     if (prototypeFunctionName.isNull() || prototypeFunctionName == &quot;Object&quot;) {</span>
 557         String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
 558         if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
 559             return tableClassName;
 560 
 561         String classInfoName = object-&gt;classInfo(vm)-&gt;className;
 562         if (!classInfoName.isNull())
 563             return classInfoName;
 564 
<span class="line-modified"> 565         if (prototypeFunctionName.isNull())</span>
 566             return &quot;Object&quot;_s;
 567     }
 568 
<span class="line-modified"> 569     return prototypeFunctionName;</span>
 570 }
 571 
 572 bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, ExecState* exec, unsigned i, PropertySlot&amp; slot)
 573 {


 574     // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
 575     // legal for anyone to override getOwnPropertySlot() without also overriding
 576     // getOwnPropertySlotByIndex().
 577 
 578     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified"> 579         return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;getOwnPropertySlot(thisObject, exec, Identifier::from(exec, i), slot);</span>
 580 
 581     switch (thisObject-&gt;indexingType()) {
 582     case ALL_BLANK_INDEXING_TYPES:
 583     case ALL_UNDECIDED_INDEXING_TYPES:
 584         break;
 585 
 586     case ALL_INT32_INDEXING_TYPES:
 587     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 588         Butterfly* butterfly = thisObject-&gt;butterfly();
 589         if (i &gt;= butterfly-&gt;vectorLength())
 590             return false;
 591 
 592         JSValue value = butterfly-&gt;contiguous().at(thisObject, i).get();
 593         if (value) {
 594             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 595             return true;
 596         }
 597 
 598         return false;
 599     }
</pre>
<hr />
<pre>
 638         break;
 639     }
 640 
 641     return false;
 642 }
 643 
 644 // https://tc39.github.io/ecma262/#sec-ordinaryset
 645 bool ordinarySetSlow(ExecState* exec, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)
 646 {
 647     // If we find the receiver is not the same to the object, we fall to this slow path.
 648     // Currently, there are 3 candidates.
 649     // 1. Reflect.set can alter the receiver with an arbitrary value.
 650     // 2. Window Proxy.
 651     // 3. ES6 Proxy.
 652 
 653     VM&amp; vm = exec-&gt;vm();
 654     auto scope = DECLARE_THROW_SCOPE(vm);
 655     JSObject* current = object;
 656     PropertyDescriptor ownDescriptor;
 657     while (true) {
<span class="line-modified"> 658         if (current-&gt;type() == ProxyObjectType &amp;&amp; propertyName != vm.propertyNames-&gt;underscoreProto) {</span>
 659             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
 660             PutPropertySlot slot(receiver, shouldThrow);
 661             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
 662         }
 663 
 664         // 9.1.9.1-2 Let ownDesc be ? O.[[GetOwnProperty]](P).
 665         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(exec, propertyName, ownDescriptor);
 666         RETURN_IF_EXCEPTION(scope, false);
 667 
 668         if (!ownDescriptorFound) {
 669             // 9.1.9.1-3-a Let parent be ? O.[[GetPrototypeOf]]().
 670             JSValue prototype = current-&gt;getPrototype(vm, exec);
 671             RETURN_IF_EXCEPTION(scope, false);
 672 
 673             // 9.1.9.1-3-b If parent is not null, then
 674             if (!prototype.isNull()) {
 675                 // 9.1.9.1-3-b-i Return ? parent.[[Set]](P, V, Receiver).
 676                 current = asObject(prototype);
 677                 continue;
 678             }
</pre>
<hr />
<pre>
 746 
 747     // 9.1.9.1-9 Return true.
 748     return true;
 749 }
 750 
 751 // ECMA 8.6.2.2
 752 bool JSObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 753 {
 754     return putInlineForJSObject(cell, exec, propertyName, value, slot);
 755 }
 756 
 757 bool JSObject::putInlineSlow(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 758 {
 759     ASSERT(!isThisValueAltered(slot, this));
 760 
 761     VM&amp; vm = exec-&gt;vm();
 762     auto scope = DECLARE_THROW_SCOPE(vm);
 763 
 764     JSObject* obj = this;
 765     for (;;) {





 766         unsigned attributes;
<span class="line-modified"> 767         PropertyOffset offset = obj-&gt;structure(vm)-&gt;get(vm, propertyName, attributes);</span>
 768         if (isValidOffset(offset)) {
 769             if (attributes &amp; PropertyAttribute::ReadOnly) {
 770                 ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
 771                 return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 772             }
 773 
 774             JSValue gs = obj-&gt;getDirect(offset);
 775             if (gs.isGetterSetter()) {
 776                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
<span class="line-modified"> 777                 if (!structure(vm)-&gt;isDictionary())</span>
 778                     slot.setCacheableSetter(obj, offset);
 779 
 780                 bool result = callSetter(exec, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);
 781                 RETURN_IF_EXCEPTION(scope, false);
 782                 return result;
 783             }
 784             if (gs.isCustomGetterSetter()) {
 785                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 786                 if (attributes &amp; PropertyAttribute::CustomAccessor)
 787                     slot.setCustomAccessor(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 788                 else
 789                     slot.setCustomValue(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 790 
 791                 bool result = callCustomSetter(exec, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);
 792                 RETURN_IF_EXCEPTION(scope, false);
 793                 return result;
 794             }
 795             ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
 796 
<span class="line-modified"> 797             // If there&#39;s an existing property on the object or one of its</span>
<span class="line-modified"> 798             // prototypes it should be replaced, so break here.</span>
 799             break;
 800         }
 801         if (!obj-&gt;staticPropertiesReified(vm)) {
 802             if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
 803                 if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
 804                     RELEASE_AND_RETURN(scope, putEntry(exec, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));
 805             }
 806         }
<span class="line-modified"> 807         if (obj-&gt;type() == ProxyObjectType &amp;&amp; propertyName != vm.propertyNames-&gt;underscoreProto) {</span>
 808             // FIXME: We shouldn&#39;t unconditionally perform [[Set]] here.
 809             // We need to do more because this is observable behavior.
 810             // https://bugs.webkit.org/show_bug.cgi?id=155012
 811             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
 812             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
 813         }
 814         JSValue prototype = obj-&gt;getPrototype(vm, exec);
 815         RETURN_IF_EXCEPTION(scope, false);
 816         if (prototype.isNull())
 817             break;
 818         obj = asObject(prototype);
 819     }
 820 
 821     if (!putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
 822         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 823     return true;
 824 }
 825 
 826 bool JSObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 827 {
 828     VM&amp; vm = exec-&gt;vm();
 829     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 830 
 831     if (propertyName &gt; MAX_ARRAY_INDEX) {
 832         PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified"> 833         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, exec, Identifier::from(exec, propertyName), value, slot);</span>
 834     }
 835 
 836     thisObject-&gt;ensureWritable(vm);
 837 
 838     switch (thisObject-&gt;indexingType()) {
 839     case ALL_BLANK_INDEXING_TYPES:
 840         break;
 841 
 842     case ALL_UNDECIDED_INDEXING_TYPES: {
 843         thisObject-&gt;convertUndecidedForValue(vm, value);
 844         // Reloop.
 845         return putByIndex(cell, exec, propertyName, value, shouldThrow);
 846     }
 847 
 848     case ALL_INT32_INDEXING_TYPES: {
 849         if (!value.isInt32()) {
 850             thisObject-&gt;convertInt32ForValue(vm, value);
 851             return putByIndex(cell, exec, propertyName, value, shouldThrow);
 852         }
 853         FALLTHROUGH;
</pre>
<hr />
<pre>
 900             length = propertyName + 1;
 901             storage-&gt;setLength(length);
 902             ++storage-&gt;m_numValuesInVector;
 903         } else if (!valueSlot)
 904             ++storage-&gt;m_numValuesInVector;
 905 
 906         valueSlot.set(vm, thisObject, value);
 907         return true;
 908     }
 909 
 910     case NonArrayWithSlowPutArrayStorage:
 911     case ArrayWithSlowPutArrayStorage: {
 912         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 913 
 914         if (propertyName &gt;= storage-&gt;vectorLength())
 915             break;
 916 
 917         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 918         unsigned length = storage-&gt;length();
 919 


 920         // Update length &amp; m_numValuesInVector as necessary.
 921         if (propertyName &gt;= length) {
 922             bool putResult = false;
<span class="line-modified"> 923             if (thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult))</span>


 924                 return putResult;
 925             length = propertyName + 1;
 926             storage-&gt;setLength(length);
 927             ++storage-&gt;m_numValuesInVector;
 928         } else if (!valueSlot) {
 929             bool putResult = false;
<span class="line-modified"> 930             if (thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult))</span>


 931                 return putResult;
 932             ++storage-&gt;m_numValuesInVector;
 933         }
 934 
 935         valueSlot.set(vm, thisObject, value);
 936         return true;
 937     }
 938 
 939     default:
 940         RELEASE_ASSERT_NOT_REACHED();
 941     }
 942 
 943     return thisObject-&gt;putByIndexBeyondVectorLength(exec, propertyName, value, shouldThrow);
 944 }
 945 
 946 ArrayStorage* JSObject::enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp; vm, ArrayStorage* storage)
 947 {
 948     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
 949 
 950     if (!map)
</pre>
<hr />
<pre>
1880     if (attributes &amp; PropertyAttribute::ReadOnly)
1881         structure-&gt;setContainsReadOnlyProperties();
1882     structure-&gt;setHasCustomGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1883     return result;
1884 }
1885 
1886 bool JSObject::putDirectNonIndexAccessor(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1887 {
1888     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1889     PutPropertySlot slot(this);
1890     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, accessor, attributes, slot);
1891 
1892     Structure* structure = this-&gt;structure(vm);
1893     if (attributes &amp; PropertyAttribute::ReadOnly)
1894         structure-&gt;setContainsReadOnlyProperties();
1895 
1896     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1897     return result;
1898 }
1899 













1900 // HasProperty(O, P) from Section 7.3.10 of the spec.
1901 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
1902 bool JSObject::hasProperty(ExecState* exec, PropertyName propertyName) const
1903 {
1904     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);
1905 }
1906 
1907 bool JSObject::hasProperty(ExecState* exec, unsigned propertyName) const
1908 {
1909     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);
1910 }
1911 
1912 bool JSObject::hasPropertyGeneric(ExecState* exec, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const
1913 {
1914     PropertySlot slot(this, internalMethodType);
1915     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);
1916 }
1917 
1918 bool JSObject::hasPropertyGeneric(ExecState* exec, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const
1919 {
</pre>
<hr />
<pre>
1954 
1955         PropertyOffset offset;
1956         if (structure-&gt;isUncacheableDictionary())
1957             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });
1958         else
1959             thisObject-&gt;setStructure(vm, Structure::removePropertyTransition(vm, structure, propertyName, offset));
1960 
1961         if (offset != invalidOffset)
1962             thisObject-&gt;locationForOffset(offset)-&gt;clear();
1963     }
1964 
1965     return true;
1966 }
1967 
1968 bool JSObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned i)
1969 {
1970     VM&amp; vm = exec-&gt;vm();
1971     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
1972 
1973     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">1974         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(exec, i));</span>
1975 
1976     switch (thisObject-&gt;indexingMode()) {
1977     case ALL_BLANK_INDEXING_TYPES:
1978     case ALL_UNDECIDED_INDEXING_TYPES:
1979         return true;
1980 
1981     case CopyOnWriteArrayWithInt32:
1982     case CopyOnWriteArrayWithContiguous: {
1983         Butterfly* butterfly = thisObject-&gt;butterfly();
1984         if (i &gt;= butterfly-&gt;vectorLength())
1985             return true;
1986         thisObject-&gt;convertFromCopyOnWrite(vm);
1987         FALLTHROUGH;
1988     }
1989 
1990     case ALL_WRITABLE_INT32_INDEXING_TYPES:
1991     case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES: {
1992         Butterfly* butterfly = thisObject-&gt;butterfly();
1993         if (i &gt;= butterfly-&gt;vectorLength())
1994             return true;
</pre>
<hr />
<pre>
2378     if (!mode.includeJSObjectProperties())
2379         return;
2380 
2381     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
2382 }
2383 
2384 double JSObject::toNumber(ExecState* exec) const
2385 {
2386     VM&amp; vm = exec-&gt;vm();
2387     auto scope = DECLARE_THROW_SCOPE(vm);
2388     JSValue primitive = toPrimitive(exec, PreferNumber);
2389     RETURN_IF_EXCEPTION(scope, 0.0); // should be picked up soon in Nodes.cpp
2390     RELEASE_AND_RETURN(scope, primitive.toNumber(exec));
2391 }
2392 
2393 JSString* JSObject::toString(ExecState* exec) const
2394 {
2395     VM&amp; vm = exec-&gt;vm();
2396     auto scope = DECLARE_THROW_SCOPE(vm);
2397     JSValue primitive = toPrimitive(exec, PreferString);
<span class="line-modified">2398     RETURN_IF_EXCEPTION(scope, jsEmptyString(exec));</span>
<span class="line-modified">2399     return primitive.toString(exec);</span>
2400 }
2401 
2402 JSValue JSObject::toThis(JSCell* cell, ExecState*, ECMAMode)
2403 {
2404     return jsCast&lt;JSObject*&gt;(cell);
2405 }
2406 
2407 void JSObject::seal(VM&amp; vm)
2408 {
2409     if (isSealed(vm))
2410         return;
2411     enterDictionaryIndexingMode(vm);
2412     setStructure(vm, Structure::sealTransition(vm, structure(vm)));
2413 }
2414 
2415 void JSObject::freeze(VM&amp; vm)
2416 {
2417     if (isFrozen(vm))
2418         return;
2419     enterDictionaryIndexingMode(vm);
</pre>
<hr />
<pre>
2451     VM&amp; vm = exec-&gt;vm();
2452     ASSERT(!staticPropertiesReified(vm));
2453 
2454     // If this object&#39;s ClassInfo has no static properties, then nothing to reify!
2455     // We can safely set the flag to avoid the expensive check again in the future.
2456     if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {
2457         structure(vm)-&gt;setStaticPropertiesReified(true);
2458         return;
2459     }
2460 
2461     if (!structure(vm)-&gt;isDictionary())
2462         setStructure(vm, Structure::toCacheableDictionaryTransition(vm, structure(vm)));
2463 
2464     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {
2465         const HashTable* hashTable = info-&gt;staticPropHashTable;
2466         if (!hashTable)
2467             continue;
2468 
2469         for (auto&amp; value : *hashTable) {
2470             unsigned attributes;
<span class="line-modified">2471             auto key = Identifier::fromString(&amp;vm, value.m_key);</span>
2472             PropertyOffset offset = getDirectOffset(vm, key, attributes);
2473             if (!isValidOffset(offset))
2474                 reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
2475         }
2476     }
2477 
2478     structure(vm)-&gt;setStaticPropertiesReified(true);
2479 }
2480 
2481 NEVER_INLINE void JSObject::fillGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, JSCell* getterSetter, unsigned attributes, PropertyOffset offset)
2482 {
2483     if (structure(vm)-&gt;isUncacheableDictionary()) {
2484         slot.setGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter));
2485         return;
2486     }
2487 
2488     // This access is cacheable because Structure requires an attributeChangedTransition
2489     // if this property stops being an accessor.
2490     slot.setCacheableGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter), offset);
2491 }
</pre>
<hr />
<pre>
2659     // 13. Return true.
2660     return true;
2661 }
2662 
2663 SparseArrayValueMap* JSObject::allocateSparseIndexMap(VM&amp; vm)
2664 {
2665     SparseArrayValueMap* result = SparseArrayValueMap::create(vm);
2666     arrayStorage()-&gt;m_sparseMap.set(vm, this, result);
2667     return result;
2668 }
2669 
2670 void JSObject::deallocateSparseIndexMap()
2671 {
2672     if (ArrayStorage* arrayStorage = arrayStorageOrNull())
2673         arrayStorage-&gt;m_sparseMap.clear();
2674 }
2675 
2676 bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(ExecState* exec, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2677 {
2678     VM&amp; vm = exec-&gt;vm();


2679     for (JSObject* current = this; ;) {
2680         // This has the same behavior with respect to prototypes as JSObject::put(). It only
2681         // allows a prototype to intercept a put if (a) the prototype declares the property
2682         // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
2683         // (b) that property is declared as ReadOnly or Accessor.
2684 
2685         ArrayStorage* storage = current-&gt;arrayStorageOrNull();
2686         if (storage &amp;&amp; storage-&gt;m_sparseMap) {
2687             SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
2688             if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {

2689                 putResult = iter-&gt;value.put(exec, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);
2690                 return true;
2691             }
2692         }
2693 
2694         if (current-&gt;type() == ProxyObjectType) {

2695             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
2696             putResult = proxy-&gt;putByIndexCommon(exec, thisValue, i, value, shouldThrow);
2697             return true;
2698         }
2699 
<span class="line-modified">2700         JSValue prototypeValue = current-&gt;getPrototypeDirect(vm);</span>

2701         if (prototypeValue.isNull())
2702             return false;
2703 
2704         current = asObject(prototypeValue);
2705     }
2706 }
2707 
2708 bool JSObject::attemptToInterceptPutByIndexOnHole(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2709 {
<span class="line-modified">2710     JSValue prototypeValue = getPrototypeDirect(exec-&gt;vm());</span>




2711     if (prototypeValue.isNull())
2712         return false;
2713 
<span class="line-modified">2714     return asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(exec, this, i, value, shouldThrow, putResult);</span>
2715 }
2716 
2717 template&lt;IndexingType indexingShape&gt;
2718 bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(ExecState* exec, unsigned i, JSValue value)
2719 {
2720     VM&amp; vm = exec-&gt;vm();
2721     auto scope = DECLARE_THROW_SCOPE(vm);
2722 
2723     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2724     ASSERT((indexingType() &amp; IndexingShapeMask) == indexingShape);
2725     ASSERT(!indexingShouldBeSparse(vm));
2726 
2727     Butterfly* butterfly = m_butterfly.get();
2728 
2729     // For us to get here, the index is either greater than the public length, or greater than
2730     // or equal to the vector length.
2731     ASSERT(i &gt;= butterfly-&gt;vectorLength());
2732 
2733     if (i &gt; MAX_STORAGE_VECTOR_INDEX
2734         || (i &gt;= MIN_SPARSE_ARRAY_INDEX &amp;&amp; !isDenseEnoughForVector(i, countElements&lt;indexingShape&gt;(butterfly)))
</pre>
<hr />
<pre>
2836     storage-&gt;m_numValuesInVector = numValuesInArray;
2837 
2838     // Copy all values from the map into the vector, and delete the map.
2839     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
2840     SparseArrayValueMap::const_iterator end = map-&gt;end();
2841     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2842         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2843     deallocateSparseIndexMap();
2844 
2845     // Store the new property into the vector.
2846     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2847     if (!valueSlot)
2848         ++storage-&gt;m_numValuesInVector;
2849     valueSlot.set(vm, this, value);
2850     return true;
2851 }
2852 
2853 bool JSObject::putByIndexBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, bool shouldThrow)
2854 {
2855     VM&amp; vm = exec-&gt;vm();

2856 
2857     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2858 
2859     // i should be a valid array index that is outside of the current vector.
2860     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2861 
2862     switch (indexingType()) {
2863     case ALL_BLANK_INDEXING_TYPES: {
2864         if (indexingShouldBeSparse(vm)) {
<span class="line-modified">2865             return putByIndexBeyondVectorLengthWithArrayStorage(</span>
2866                 exec, i, value, shouldThrow,
<span class="line-modified">2867                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
2868         }
2869         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">2870             return putByIndexBeyondVectorLengthWithArrayStorage(</span>
<span class="line-removed">2871                 exec, i, value, shouldThrow, createArrayStorage(vm, 0, 0));</span>
2872         }
2873         if (needsSlowPutIndexing(vm)) {
2874             // Convert the indexing type to the SlowPutArrayStorage and retry.
2875             createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="line-modified">2876             return putByIndex(this, exec, i, value, shouldThrow);</span>
2877         }
2878 
2879         createInitialForValueAndSet(vm, i, value);
2880         return true;
2881     }
2882 
2883     case ALL_UNDECIDED_INDEXING_TYPES: {
2884         CRASH();
2885         break;
2886     }
2887 
2888     case ALL_INT32_INDEXING_TYPES:
<span class="line-modified">2889         return putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value);</span>
2890 
2891     case ALL_DOUBLE_INDEXING_TYPES:
<span class="line-modified">2892         return putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value);</span>
2893 
2894     case ALL_CONTIGUOUS_INDEXING_TYPES:
<span class="line-modified">2895         return putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value);</span>
2896 
2897     case NonArrayWithSlowPutArrayStorage:
2898     case ArrayWithSlowPutArrayStorage: {
2899         // No own property present in the vector, but there might be in the sparse map!
2900         SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
2901         bool putResult = false;
<span class="line-modified">2902         if (!(map &amp;&amp; map-&gt;contains(i)) &amp;&amp; attemptToInterceptPutByIndexOnHole(exec, i, value, shouldThrow, putResult))</span>
<span class="line-modified">2903             return putResult;</span>




2904         FALLTHROUGH;
2905     }
2906 
2907     case NonArrayWithArrayStorage:
2908     case ArrayWithArrayStorage:
<span class="line-modified">2909         return putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, arrayStorage());</span>
2910 
2911     default:
2912         RELEASE_ASSERT_NOT_REACHED();
2913     }
2914     return false;
2915 }
2916 
2917 bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)
2918 {
2919     VM&amp; vm = exec-&gt;vm();
2920     auto scope = DECLARE_THROW_SCOPE(vm);
2921 
2922     // i should be a valid array index that is outside of the current vector.
2923     ASSERT(hasAnyArrayStorage(indexingType()));
2924     ASSERT(arrayStorage() == storage);
2925     ASSERT(i &gt;= storage-&gt;vectorLength() || attributes);
2926     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2927 
2928     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2929 
</pre>
<hr />
<pre>
2983     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2984         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2985     deallocateSparseIndexMap();
2986 
2987     // Store the new property into the vector.
2988     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2989     if (!valueSlot)
2990         ++storage-&gt;m_numValuesInVector;
2991     valueSlot.set(vm, this, value);
2992     return true;
2993 }
2994 
2995 bool JSObject::putDirectIndexSlowOrBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)
2996 {
2997     VM&amp; vm = exec-&gt;vm();
2998     ASSERT(!value.isCustomGetterSetter());
2999 
3000     if (!canDoFastPutDirectIndex(vm, this)) {
3001         PropertyDescriptor descriptor;
3002         descriptor.setDescriptor(value, attributes);
<span class="line-modified">3003         return methodTable(vm)-&gt;defineOwnProperty(this, exec, Identifier::from(exec, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
3004     }
3005 
3006     // i should be a valid array index that is outside of the current vector.
3007     ASSERT(i &lt;= MAX_ARRAY_INDEX);
3008 
3009     if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3010         notifyPresenceOfIndexedAccessors(vm);
3011 
3012     switch (indexingType()) {
3013     case ALL_BLANK_INDEXING_TYPES: {
3014         if (indexingShouldBeSparse(vm) || attributes) {
3015             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3016                 exec, i, value, attributes, mode,
3017                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3018         }
<span class="line-modified">3019         if (i &gt;= MIN_SPARSE_ARRAY_INDEX) {</span>
3020             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3021                 exec, i, value, attributes, mode, createArrayStorage(vm, 0, 0));
3022         }
3023         if (needsSlowPutIndexing(vm)) {
3024             ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
3025             storage-&gt;m_vector[i].set(vm, this, value);
3026             storage-&gt;m_numValuesInVector++;
3027             return true;
3028         }
3029 
3030         createInitialForValueAndSet(vm, i, value);
3031         return true;
3032     }
3033 
3034     case ALL_UNDECIDED_INDEXING_TYPES: {
3035         convertUndecidedForValue(vm, value);
3036         // Reloop.
3037         return putDirectIndex(exec, i, value, attributes, mode);
3038     }
3039 
</pre>
<hr />
<pre>
3075     }
3076 
3077     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
3078         if (attributes)
3079             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3080         return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, arrayStorage());
3081 
3082     default:
3083         RELEASE_ASSERT_NOT_REACHED();
3084         return false;
3085     }
3086 }
3087 
3088 bool JSObject::putDirectNativeIntrinsicGetter(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3089 {
3090     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3091     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3092     return putDirectNonIndexAccessor(vm, name, accessor, attributes);
3093 }
3094 







3095 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3096 {
3097     StringImpl* name = propertyName.publicName();
3098     if (!name)
3099         name = vm.propertyNames-&gt;anonymous.impl();
3100     ASSERT(name);
3101 
3102     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic);
3103     return putDirect(vm, propertyName, function, attributes);
3104 }
3105 
3106 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, const DOMJIT::Signature* signature, unsigned attributes)
3107 {
3108     StringImpl* name = propertyName.publicName();
3109     if (!name)
3110         name = vm.propertyNames-&gt;anonymous.impl();
3111     ASSERT(name);
3112 
3113     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic, callHostFunctionAsConstructor, signature);
3114     return putDirect(vm, propertyName, function, attributes);
</pre>
<hr />
<pre>
3294 bool JSObject::ensureLengthSlow(VM&amp; vm, unsigned length)
3295 {
3296     if (isCopyOnWrite(indexingMode())) {
3297         convertFromCopyOnWrite(vm);
3298         if (m_butterfly-&gt;vectorLength() &gt;= length)
3299             return true;
3300     }
3301 
3302     Butterfly* butterfly = this-&gt;butterfly();
3303 
3304     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3305     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3306     ASSERT(length &gt; butterfly-&gt;vectorLength());
3307 
3308     unsigned oldVectorLength = butterfly-&gt;vectorLength();
3309     unsigned newVectorLength;
3310 
3311     Structure* structure = this-&gt;structure(vm);
3312     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
3313 


3314     unsigned availableOldLength =
3315         Butterfly::availableContiguousVectorLength(propertyCapacity, oldVectorLength);
3316     Butterfly* newButterfly = nullptr;
3317     if (availableOldLength &gt;= length) {
3318         // This is the case where someone else selected a vector length that caused internal
3319         // fragmentation. If we did our jobs right, this would never happen. But I bet we will mess
3320         // this up, so this defense should stay.
3321         newVectorLength = availableOldLength;
3322     } else {
3323         newVectorLength = Butterfly::optimalContiguousVectorLength(
3324             propertyCapacity, std::min(length * 2, MAX_STORAGE_VECTOR_LENGTH));
<span class="line-modified">3325         butterfly = butterfly-&gt;growArrayRight(</span>
<span class="line-modified">3326             vm, this, structure, propertyCapacity, true,</span>
3327             oldVectorLength * sizeof(EncodedJSValue),
3328             newVectorLength * sizeof(EncodedJSValue));
3329         if (!butterfly)
3330             return false;
3331         newButterfly = butterfly;
3332     }
3333 
3334     if (hasDouble(indexingType())) {
3335         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3336             butterfly-&gt;indexingPayload&lt;double&gt;()[i] = PNaN;
3337     } else {
3338         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3339             butterfly-&gt;indexingPayload&lt;WriteBarrier&lt;Unknown&gt;&gt;()[i].clear();
3340     }
3341 
3342     if (newButterfly) {
3343         butterfly-&gt;setVectorLength(newVectorLength);
3344         WTF::storeStoreFence();
3345         m_butterfly.set(vm, this, newButterfly);
3346     } else {
</pre>
<hr />
<pre>
3375     // capacity, since we might have already mutated the structure in-place.
3376 
3377     return Butterfly::createOrGrowPropertyStorage(butterfly(), vm, this, structure(vm), oldSize, newSize);
3378 }
3379 
3380 static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(ExecState* exec, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)
3381 {
3382     VM&amp; vm = exec-&gt;vm();
3383     auto key = std::make_pair(getterSetter, (int)type);
3384     JSCustomGetterSetterFunction* customGetterSetterFunction = vm.customGetterSetterFunctionMap.get(key);
3385     if (!customGetterSetterFunction) {
3386         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, exec-&gt;lexicalGlobalObject(), getterSetter, type, propertyName.publicName());
3387         vm.customGetterSetterFunctionMap.set(key, customGetterSetterFunction);
3388     }
3389     return customGetterSetterFunction;
3390 }
3391 
3392 bool JSObject::getOwnPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)
3393 {
3394     VM&amp; vm = exec-&gt;vm();

3395     JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">3396     if (!methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot))</span>



3397         return false;
3398 





3399     // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
3400     // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
3401     // the property is not an own property.
3402     if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
3403         JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
3404         if (!jsProxy || jsProxy-&gt;target() != slot.slotBase()) {
3405             // Try ProxyObject.
3406             ProxyObject* proxyObject = jsDynamicCast&lt;ProxyObject*&gt;(vm, this);
3407             if (!proxyObject || proxyObject-&gt;target() != slot.slotBase())
3408                 return false;
3409         }
3410     }
3411 
3412     if (slot.isAccessor())
3413         descriptor.setAccessorDescriptor(slot.getterSetter(), slot.attributes());
3414     else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
3415         descriptor.setCustomDescriptor(slot.attributes());
3416 
3417         JSObject* thisObject = this;
3418         if (auto* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this))
</pre>
<hr />
<pre>
3422         if (slot.isCustomAccessor())
3423             getterSetter = slot.customGetterSetter();
3424         else {
3425             JSValue maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3426             if (!maybeGetterSetter) {
3427                 thisObject-&gt;reifyAllStaticProperties(exec);
3428                 maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3429             }
3430 
3431             ASSERT(maybeGetterSetter);
3432             getterSetter = jsDynamicCast&lt;CustomGetterSetter*&gt;(vm, maybeGetterSetter);
3433         }
3434         ASSERT(getterSetter);
3435         if (!getterSetter)
3436             return false;
3437 
3438         if (getterSetter-&gt;getter())
3439             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));
3440         if (getterSetter-&gt;setter())
3441             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));
<span class="line-modified">3442     } else</span>
<span class="line-modified">3443         descriptor.setDescriptor(slot.getValue(exec, propertyName), slot.attributes());</span>




3444     return true;
3445 }
3446 
3447 static bool putDescriptor(ExecState* exec, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)
3448 {
3449     VM&amp; vm = exec-&gt;vm();
3450     if (descriptor.isGenericDescriptor() || descriptor.isDataDescriptor()) {
3451         if (descriptor.isGenericDescriptor() &amp;&amp; oldDescriptor.isAccessorDescriptor()) {
3452             JSObject* getter = oldDescriptor.getterPresent() ? oldDescriptor.getterObject() : nullptr;
3453             JSObject* setter = oldDescriptor.setterPresent() ? oldDescriptor.setterObject() : nullptr;
3454             GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
3455             target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);
3456             return true;
3457         }
3458         JSValue newValue = jsUndefined();
3459         if (descriptor.value())
3460             newValue = descriptor.value();
3461         else if (oldDescriptor.value())
3462             newValue = oldDescriptor.value();
3463         target-&gt;putDirect(vm, propertyName, newValue, attributes &amp; ~PropertyAttribute::Accessor);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Library General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Library General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Library General Public License
  18  *  along with this library; see the file COPYING.LIB.  If not, write to
  19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  *  Boston, MA 02110-1301, USA.
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;JSObject.h&quot;
  26 
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;CustomGetterSetter.h&quot;
  30 #include &quot;DatePrototype.h&quot;
  31 #include &quot;ErrorConstructor.h&quot;
  32 #include &quot;Exception.h&quot;
<span class="line-added">  33 #include &quot;GCDeferralContextInlines.h&quot;</span>
  34 #include &quot;GetterSetter.h&quot;
<span class="line-modified">  35 #include &quot;HeapAnalyzer.h&quot;</span>
  36 #include &quot;IndexingHeaderInlines.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;JSCustomGetterSetterFunction.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSGlobalObject.h&quot;
  41 #include &quot;JSImmutableButterfly.h&quot;
  42 #include &quot;Lookup.h&quot;
  43 #include &quot;NativeErrorConstructor.h&quot;
  44 #include &quot;ObjectPrototype.h&quot;
  45 #include &quot;PropertyDescriptor.h&quot;
  46 #include &quot;PropertyNameArray.h&quot;
  47 #include &quot;ProxyObject.h&quot;
  48 #include &quot;SlotVisitorInlines.h&quot;
  49 #include &quot;TypeError.h&quot;
  50 #include &quot;VMInlines.h&quot;
  51 #include &lt;math.h&gt;
  52 #include &lt;wtf/Assertions.h&gt;
  53 
  54 namespace JSC {
  55 
</pre>
<hr />
<pre>
  70 const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError { &quot;Attempting to change configurable attribute of unconfigurable property.&quot;_s };
  71 const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError { &quot;Attempting to change enumerable attribute of unconfigurable property.&quot;_s };
  72 const ASCIILiteral UnconfigurablePropertyChangeWritabilityError { &quot;Attempting to change writable attribute of unconfigurable property.&quot;_s };
  73 
  74 const ClassInfo JSObject::s_info = { &quot;Object&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSObject) };
  75 
  76 const ClassInfo JSFinalObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFinalObject) };
  77 
  78 static inline void getClassPropertyNames(ExecState* exec, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
  79 {
  80     VM&amp; vm = exec-&gt;vm();
  81 
  82     // Add properties from the static hashtables of properties
  83     for (; classInfo; classInfo = classInfo-&gt;parentClass) {
  84         const HashTable* table = classInfo-&gt;staticPropHashTable;
  85         if (!table)
  86             continue;
  87 
  88         for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
  89             if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
<span class="line-modified">  90                 propertyNames.add(Identifier::fromString(vm, iter.key()));</span>
  91         }
  92     }
  93 }
  94 
  95 ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset lastOffset)
  96 {
  97     // We call this when we found everything without races.
  98     ASSERT(structure);
  99 
 100     if (!butterfly)
 101         return;
 102 
 103     if (isCopyOnWrite(structure-&gt;indexingMode())) {
 104         visitor.append(bitwise_cast&lt;WriteBarrier&lt;JSCell&gt;&gt;(JSImmutableButterfly::fromButterfly(butterfly)));
 105         return;
 106     }
 107 
 108     bool hasIndexingHeader = structure-&gt;hasIndexingHeader(this);
 109     size_t preCapacity;
 110     if (hasIndexingHeader)
</pre>
<hr />
<pre>
 433 }
 434 
 435 void JSObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 436 {
 437     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 438     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 439 #if !ASSERT_DISABLED
 440     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 441     visitor.m_isCheckingForDefaultMarkViolation = false;
 442 #endif
 443 
 444     JSCell::visitChildren(thisObject, visitor);
 445 
 446     thisObject-&gt;visitButterfly(visitor);
 447 
 448 #if !ASSERT_DISABLED
 449     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 450 #endif
 451 }
 452 
<span class="line-modified"> 453 void JSObject::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)</span>
 454 {
 455     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<span class="line-modified"> 456     Base::analyzeHeap(cell, analyzer);</span>
 457 
 458     Structure* structure = thisObject-&gt;structure();
 459     for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
 460         JSValue toValue = thisObject-&gt;getDirect(entry.offset);
 461         if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified"> 462             analyzer.analyzePropertyNameEdge(thisObject, toValue.asCell(), entry.key);</span>
 463     }
 464 
 465     Butterfly* butterfly = thisObject-&gt;butterfly();
 466     if (butterfly) {
 467         WriteBarrier&lt;Unknown&gt;* data = nullptr;
 468         uint32_t count = 0;
 469 
 470         switch (thisObject-&gt;indexingType()) {
 471         case ALL_CONTIGUOUS_INDEXING_TYPES:
 472             data = butterfly-&gt;contiguous().data();
 473             count = butterfly-&gt;publicLength();
 474             break;
 475         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 476             data = butterfly-&gt;arrayStorage()-&gt;m_vector;
 477             count = butterfly-&gt;arrayStorage()-&gt;vectorLength();
 478             break;
 479         default:
 480             break;
 481         }
 482 
 483         for (uint32_t i = 0; i &lt; count; ++i) {
 484             JSValue toValue = data[i].get();
 485             if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified"> 486                 analyzer.analyzeIndexEdge(thisObject, toValue.asCell(), i);</span>
 487         }
 488     }
 489 }
 490 
 491 void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 492 {
 493     JSFinalObject* thisObject = jsCast&lt;JSFinalObject*&gt;(cell);
 494     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 495 #if !ASSERT_DISABLED
 496     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 497     visitor.m_isCheckingForDefaultMarkViolation = false;
 498 #endif
 499 
 500     JSCell::visitChildren(thisObject, visitor);
 501 
 502     if (Structure* structure = thisObject-&gt;visitButterfly(visitor)) {
 503         if (unsigned storageSize = structure-&gt;inlineSize())
 504             visitor.appendValuesHidden(thisObject-&gt;inlineStorage(), storageSize);
 505     }
 506 
</pre>
<hr />
<pre>
 509 #endif
 510 }
 511 
 512 String JSObject::className(const JSObject* object, VM&amp; vm)
 513 {
 514     const ClassInfo* info = object-&gt;classInfo(vm);
 515     ASSERT(info);
 516     return info-&gt;className;
 517 }
 518 
 519 String JSObject::toStringName(const JSObject* object, ExecState* exec)
 520 {
 521     VM&amp; vm = exec-&gt;vm();
 522     const ClassInfo* info = object-&gt;classInfo(vm);
 523     ASSERT(info);
 524     return info-&gt;className;
 525 }
 526 
 527 String JSObject::calculatedClassName(JSObject* object)
 528 {
<span class="line-modified"> 529     String constructorFunctionName;</span>
<span class="line-modified"> 530     auto* structure = object-&gt;structure();</span>
<span class="line-added"> 531     auto* globalObject = structure-&gt;globalObject();</span>
 532     VM&amp; vm = globalObject-&gt;vm();
 533     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-added"> 534     auto* exec = globalObject-&gt;globalExec();</span>
 535 
<span class="line-modified"> 536     // Check for a display name of obj.constructor.</span>
<span class="line-modified"> 537     // This is useful to get `Foo` for the `(class Foo).prototype` object.</span>
<span class="line-modified"> 538     PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-modified"> 539     if (object-&gt;getOwnPropertySlot(object, exec, vm.propertyNames-&gt;constructor, slot)) {</span>
 540         EXCEPTION_ASSERT(!scope.exception());
 541         if (slot.isValue()) {
<span class="line-modified"> 542             if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
<span class="line-modified"> 543                 if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified"> 544                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-modified"> 545                 else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified"> 546                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-modified"> 547             }</span>
<span class="line-modified"> 548         }</span>
<span class="line-modified"> 549     }</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());</span>
<span class="line-added"> 552     if (UNLIKELY(scope.exception()))</span>
<span class="line-added"> 553         scope.clearException();</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555     // Get the display name of obj.__proto__.constructor.</span>
<span class="line-added"> 556     // This is useful to get `Foo` for a `new Foo` object.</span>
<span class="line-added"> 557     if (constructorFunctionName.isNull()) {</span>
<span class="line-added"> 558         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;</span>
<span class="line-added"> 559         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype)) {</span>
<span class="line-added"> 560             JSValue protoValue = object-&gt;getPrototypeDirect(vm);</span>
<span class="line-added"> 561             if (protoValue.isObject()) {</span>
<span class="line-added"> 562                 JSObject* protoObject = asObject(protoValue);</span>
<span class="line-added"> 563                 PropertySlot slot(protoValue, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-added"> 564                 if (protoObject-&gt;getPropertySlot(exec, vm.propertyNames-&gt;constructor, slot)) {</span>
<span class="line-added"> 565                     EXCEPTION_ASSERT(!scope.exception());</span>
<span class="line-added"> 566                     if (slot.isValue()) {</span>
<span class="line-added"> 567                         if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
<span class="line-added"> 568                             if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))</span>
<span class="line-added"> 569                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-added"> 570                             else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))</span>
<span class="line-added"> 571                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-added"> 572                         }</span>
 573                     }
 574                 }
 575             }
 576         }
 577     }
<span class="line-modified"> 578 </span>
<span class="line-added"> 579     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());</span>
 580     if (UNLIKELY(scope.exception()))
 581         scope.clearException();
 582 
<span class="line-modified"> 583     if (constructorFunctionName.isNull() || constructorFunctionName == &quot;Object&quot;) {</span>
 584         String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
 585         if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
 586             return tableClassName;
 587 
 588         String classInfoName = object-&gt;classInfo(vm)-&gt;className;
 589         if (!classInfoName.isNull())
 590             return classInfoName;
 591 
<span class="line-modified"> 592         if (constructorFunctionName.isNull())</span>
 593             return &quot;Object&quot;_s;
 594     }
 595 
<span class="line-modified"> 596     return constructorFunctionName;</span>
 597 }
 598 
 599 bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, ExecState* exec, unsigned i, PropertySlot&amp; slot)
 600 {
<span class="line-added"> 601     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added"> 602 </span>
 603     // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
 604     // legal for anyone to override getOwnPropertySlot() without also overriding
 605     // getOwnPropertySlotByIndex().
 606 
 607     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified"> 608         return thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, Identifier::from(vm, i), slot);</span>
 609 
 610     switch (thisObject-&gt;indexingType()) {
 611     case ALL_BLANK_INDEXING_TYPES:
 612     case ALL_UNDECIDED_INDEXING_TYPES:
 613         break;
 614 
 615     case ALL_INT32_INDEXING_TYPES:
 616     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 617         Butterfly* butterfly = thisObject-&gt;butterfly();
 618         if (i &gt;= butterfly-&gt;vectorLength())
 619             return false;
 620 
 621         JSValue value = butterfly-&gt;contiguous().at(thisObject, i).get();
 622         if (value) {
 623             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 624             return true;
 625         }
 626 
 627         return false;
 628     }
</pre>
<hr />
<pre>
 667         break;
 668     }
 669 
 670     return false;
 671 }
 672 
 673 // https://tc39.github.io/ecma262/#sec-ordinaryset
 674 bool ordinarySetSlow(ExecState* exec, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)
 675 {
 676     // If we find the receiver is not the same to the object, we fall to this slow path.
 677     // Currently, there are 3 candidates.
 678     // 1. Reflect.set can alter the receiver with an arbitrary value.
 679     // 2. Window Proxy.
 680     // 3. ES6 Proxy.
 681 
 682     VM&amp; vm = exec-&gt;vm();
 683     auto scope = DECLARE_THROW_SCOPE(vm);
 684     JSObject* current = object;
 685     PropertyDescriptor ownDescriptor;
 686     while (true) {
<span class="line-modified"> 687         if (current-&gt;type() == ProxyObjectType) {</span>
 688             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
 689             PutPropertySlot slot(receiver, shouldThrow);
 690             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
 691         }
 692 
 693         // 9.1.9.1-2 Let ownDesc be ? O.[[GetOwnProperty]](P).
 694         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(exec, propertyName, ownDescriptor);
 695         RETURN_IF_EXCEPTION(scope, false);
 696 
 697         if (!ownDescriptorFound) {
 698             // 9.1.9.1-3-a Let parent be ? O.[[GetPrototypeOf]]().
 699             JSValue prototype = current-&gt;getPrototype(vm, exec);
 700             RETURN_IF_EXCEPTION(scope, false);
 701 
 702             // 9.1.9.1-3-b If parent is not null, then
 703             if (!prototype.isNull()) {
 704                 // 9.1.9.1-3-b-i Return ? parent.[[Set]](P, V, Receiver).
 705                 current = asObject(prototype);
 706                 continue;
 707             }
</pre>
<hr />
<pre>
 775 
 776     // 9.1.9.1-9 Return true.
 777     return true;
 778 }
 779 
 780 // ECMA 8.6.2.2
 781 bool JSObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 782 {
 783     return putInlineForJSObject(cell, exec, propertyName, value, slot);
 784 }
 785 
 786 bool JSObject::putInlineSlow(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 787 {
 788     ASSERT(!isThisValueAltered(slot, this));
 789 
 790     VM&amp; vm = exec-&gt;vm();
 791     auto scope = DECLARE_THROW_SCOPE(vm);
 792 
 793     JSObject* obj = this;
 794     for (;;) {
<span class="line-added"> 795         Structure* structure = obj-&gt;structure(vm);</span>
<span class="line-added"> 796         if (UNLIKELY(structure-&gt;typeInfo().hasPutPropertySecurityCheck())) {</span>
<span class="line-added"> 797             obj-&gt;methodTable(vm)-&gt;doPutPropertySecurityCheck(obj, exec, propertyName, slot);</span>
<span class="line-added"> 798             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added"> 799         }</span>
 800         unsigned attributes;
<span class="line-modified"> 801         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);</span>
 802         if (isValidOffset(offset)) {
 803             if (attributes &amp; PropertyAttribute::ReadOnly) {
 804                 ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
 805                 return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 806             }
 807 
 808             JSValue gs = obj-&gt;getDirect(offset);
 809             if (gs.isGetterSetter()) {
 810                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
<span class="line-modified"> 811                 if (!this-&gt;structure(vm)-&gt;isDictionary())</span>
 812                     slot.setCacheableSetter(obj, offset);
 813 
 814                 bool result = callSetter(exec, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);
 815                 RETURN_IF_EXCEPTION(scope, false);
 816                 return result;
 817             }
 818             if (gs.isCustomGetterSetter()) {
 819                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 820                 if (attributes &amp; PropertyAttribute::CustomAccessor)
 821                     slot.setCustomAccessor(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 822                 else
 823                     slot.setCustomValue(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 824 
 825                 bool result = callCustomSetter(exec, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);
 826                 RETURN_IF_EXCEPTION(scope, false);
 827                 return result;
 828             }
 829             ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
 830 
<span class="line-modified"> 831             // If there&#39;s an existing property on the base object, or on one of its</span>
<span class="line-modified"> 832             // prototypes, we should store the property on the *base* object.</span>
 833             break;
 834         }
 835         if (!obj-&gt;staticPropertiesReified(vm)) {
 836             if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
 837                 if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
 838                     RELEASE_AND_RETURN(scope, putEntry(exec, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));
 839             }
 840         }
<span class="line-modified"> 841         if (obj-&gt;type() == ProxyObjectType) {</span>
 842             // FIXME: We shouldn&#39;t unconditionally perform [[Set]] here.
 843             // We need to do more because this is observable behavior.
 844             // https://bugs.webkit.org/show_bug.cgi?id=155012
 845             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
 846             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
 847         }
 848         JSValue prototype = obj-&gt;getPrototype(vm, exec);
 849         RETURN_IF_EXCEPTION(scope, false);
 850         if (prototype.isNull())
 851             break;
 852         obj = asObject(prototype);
 853     }
 854 
 855     if (!putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
 856         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 857     return true;
 858 }
 859 
 860 bool JSObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 861 {
 862     VM&amp; vm = exec-&gt;vm();
 863     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 864 
 865     if (propertyName &gt; MAX_ARRAY_INDEX) {
 866         PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified"> 867         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, exec, Identifier::from(vm, propertyName), value, slot);</span>
 868     }
 869 
 870     thisObject-&gt;ensureWritable(vm);
 871 
 872     switch (thisObject-&gt;indexingType()) {
 873     case ALL_BLANK_INDEXING_TYPES:
 874         break;
 875 
 876     case ALL_UNDECIDED_INDEXING_TYPES: {
 877         thisObject-&gt;convertUndecidedForValue(vm, value);
 878         // Reloop.
 879         return putByIndex(cell, exec, propertyName, value, shouldThrow);
 880     }
 881 
 882     case ALL_INT32_INDEXING_TYPES: {
 883         if (!value.isInt32()) {
 884             thisObject-&gt;convertInt32ForValue(vm, value);
 885             return putByIndex(cell, exec, propertyName, value, shouldThrow);
 886         }
 887         FALLTHROUGH;
</pre>
<hr />
<pre>
 934             length = propertyName + 1;
 935             storage-&gt;setLength(length);
 936             ++storage-&gt;m_numValuesInVector;
 937         } else if (!valueSlot)
 938             ++storage-&gt;m_numValuesInVector;
 939 
 940         valueSlot.set(vm, thisObject, value);
 941         return true;
 942     }
 943 
 944     case NonArrayWithSlowPutArrayStorage:
 945     case ArrayWithSlowPutArrayStorage: {
 946         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 947 
 948         if (propertyName &gt;= storage-&gt;vectorLength())
 949             break;
 950 
 951         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 952         unsigned length = storage-&gt;length();
 953 
<span class="line-added"> 954         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 955 </span>
 956         // Update length &amp; m_numValuesInVector as necessary.
 957         if (propertyName &gt;= length) {
 958             bool putResult = false;
<span class="line-modified"> 959             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
<span class="line-added"> 960             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added"> 961             if (result)</span>
 962                 return putResult;
 963             length = propertyName + 1;
 964             storage-&gt;setLength(length);
 965             ++storage-&gt;m_numValuesInVector;
 966         } else if (!valueSlot) {
 967             bool putResult = false;
<span class="line-modified"> 968             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
<span class="line-added"> 969             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added"> 970             if (result)</span>
 971                 return putResult;
 972             ++storage-&gt;m_numValuesInVector;
 973         }
 974 
 975         valueSlot.set(vm, thisObject, value);
 976         return true;
 977     }
 978 
 979     default:
 980         RELEASE_ASSERT_NOT_REACHED();
 981     }
 982 
 983     return thisObject-&gt;putByIndexBeyondVectorLength(exec, propertyName, value, shouldThrow);
 984 }
 985 
 986 ArrayStorage* JSObject::enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp; vm, ArrayStorage* storage)
 987 {
 988     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
 989 
 990     if (!map)
</pre>
<hr />
<pre>
1920     if (attributes &amp; PropertyAttribute::ReadOnly)
1921         structure-&gt;setContainsReadOnlyProperties();
1922     structure-&gt;setHasCustomGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1923     return result;
1924 }
1925 
1926 bool JSObject::putDirectNonIndexAccessor(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1927 {
1928     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1929     PutPropertySlot slot(this);
1930     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, accessor, attributes, slot);
1931 
1932     Structure* structure = this-&gt;structure(vm);
1933     if (attributes &amp; PropertyAttribute::ReadOnly)
1934         structure-&gt;setContainsReadOnlyProperties();
1935 
1936     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1937     return result;
1938 }
1939 
<span class="line-added">1940 void JSObject::putDirectNonIndexAccessorWithoutTransition(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)</span>
<span class="line-added">1941 {</span>
<span class="line-added">1942     ASSERT(attributes &amp; PropertyAttribute::Accessor);</span>
<span class="line-added">1943     StructureID structureID = this-&gt;structureID();</span>
<span class="line-added">1944     Structure* structure = vm.heap.structureIDTable().get(structureID);</span>
<span class="line-added">1945     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);</span>
<span class="line-added">1946     putDirect(vm, offset, accessor);</span>
<span class="line-added">1947     if (attributes &amp; PropertyAttribute::ReadOnly)</span>
<span class="line-added">1948         structure-&gt;setContainsReadOnlyProperties();</span>
<span class="line-added">1949 </span>
<span class="line-added">1950     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);</span>
<span class="line-added">1951 }</span>
<span class="line-added">1952 </span>
1953 // HasProperty(O, P) from Section 7.3.10 of the spec.
1954 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
1955 bool JSObject::hasProperty(ExecState* exec, PropertyName propertyName) const
1956 {
1957     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);
1958 }
1959 
1960 bool JSObject::hasProperty(ExecState* exec, unsigned propertyName) const
1961 {
1962     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);
1963 }
1964 
1965 bool JSObject::hasPropertyGeneric(ExecState* exec, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const
1966 {
1967     PropertySlot slot(this, internalMethodType);
1968     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);
1969 }
1970 
1971 bool JSObject::hasPropertyGeneric(ExecState* exec, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const
1972 {
</pre>
<hr />
<pre>
2007 
2008         PropertyOffset offset;
2009         if (structure-&gt;isUncacheableDictionary())
2010             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });
2011         else
2012             thisObject-&gt;setStructure(vm, Structure::removePropertyTransition(vm, structure, propertyName, offset));
2013 
2014         if (offset != invalidOffset)
2015             thisObject-&gt;locationForOffset(offset)-&gt;clear();
2016     }
2017 
2018     return true;
2019 }
2020 
2021 bool JSObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned i)
2022 {
2023     VM&amp; vm = exec-&gt;vm();
2024     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
2025 
2026     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">2027         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(vm, i));</span>
2028 
2029     switch (thisObject-&gt;indexingMode()) {
2030     case ALL_BLANK_INDEXING_TYPES:
2031     case ALL_UNDECIDED_INDEXING_TYPES:
2032         return true;
2033 
2034     case CopyOnWriteArrayWithInt32:
2035     case CopyOnWriteArrayWithContiguous: {
2036         Butterfly* butterfly = thisObject-&gt;butterfly();
2037         if (i &gt;= butterfly-&gt;vectorLength())
2038             return true;
2039         thisObject-&gt;convertFromCopyOnWrite(vm);
2040         FALLTHROUGH;
2041     }
2042 
2043     case ALL_WRITABLE_INT32_INDEXING_TYPES:
2044     case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES: {
2045         Butterfly* butterfly = thisObject-&gt;butterfly();
2046         if (i &gt;= butterfly-&gt;vectorLength())
2047             return true;
</pre>
<hr />
<pre>
2431     if (!mode.includeJSObjectProperties())
2432         return;
2433 
2434     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
2435 }
2436 
2437 double JSObject::toNumber(ExecState* exec) const
2438 {
2439     VM&amp; vm = exec-&gt;vm();
2440     auto scope = DECLARE_THROW_SCOPE(vm);
2441     JSValue primitive = toPrimitive(exec, PreferNumber);
2442     RETURN_IF_EXCEPTION(scope, 0.0); // should be picked up soon in Nodes.cpp
2443     RELEASE_AND_RETURN(scope, primitive.toNumber(exec));
2444 }
2445 
2446 JSString* JSObject::toString(ExecState* exec) const
2447 {
2448     VM&amp; vm = exec-&gt;vm();
2449     auto scope = DECLARE_THROW_SCOPE(vm);
2450     JSValue primitive = toPrimitive(exec, PreferString);
<span class="line-modified">2451     RETURN_IF_EXCEPTION(scope, jsEmptyString(vm));</span>
<span class="line-modified">2452     RELEASE_AND_RETURN(scope, primitive.toString(exec));</span>
2453 }
2454 
2455 JSValue JSObject::toThis(JSCell* cell, ExecState*, ECMAMode)
2456 {
2457     return jsCast&lt;JSObject*&gt;(cell);
2458 }
2459 
2460 void JSObject::seal(VM&amp; vm)
2461 {
2462     if (isSealed(vm))
2463         return;
2464     enterDictionaryIndexingMode(vm);
2465     setStructure(vm, Structure::sealTransition(vm, structure(vm)));
2466 }
2467 
2468 void JSObject::freeze(VM&amp; vm)
2469 {
2470     if (isFrozen(vm))
2471         return;
2472     enterDictionaryIndexingMode(vm);
</pre>
<hr />
<pre>
2504     VM&amp; vm = exec-&gt;vm();
2505     ASSERT(!staticPropertiesReified(vm));
2506 
2507     // If this object&#39;s ClassInfo has no static properties, then nothing to reify!
2508     // We can safely set the flag to avoid the expensive check again in the future.
2509     if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {
2510         structure(vm)-&gt;setStaticPropertiesReified(true);
2511         return;
2512     }
2513 
2514     if (!structure(vm)-&gt;isDictionary())
2515         setStructure(vm, Structure::toCacheableDictionaryTransition(vm, structure(vm)));
2516 
2517     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {
2518         const HashTable* hashTable = info-&gt;staticPropHashTable;
2519         if (!hashTable)
2520             continue;
2521 
2522         for (auto&amp; value : *hashTable) {
2523             unsigned attributes;
<span class="line-modified">2524             auto key = Identifier::fromString(vm, value.m_key);</span>
2525             PropertyOffset offset = getDirectOffset(vm, key, attributes);
2526             if (!isValidOffset(offset))
2527                 reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
2528         }
2529     }
2530 
2531     structure(vm)-&gt;setStaticPropertiesReified(true);
2532 }
2533 
2534 NEVER_INLINE void JSObject::fillGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, JSCell* getterSetter, unsigned attributes, PropertyOffset offset)
2535 {
2536     if (structure(vm)-&gt;isUncacheableDictionary()) {
2537         slot.setGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter));
2538         return;
2539     }
2540 
2541     // This access is cacheable because Structure requires an attributeChangedTransition
2542     // if this property stops being an accessor.
2543     slot.setCacheableGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter), offset);
2544 }
</pre>
<hr />
<pre>
2712     // 13. Return true.
2713     return true;
2714 }
2715 
2716 SparseArrayValueMap* JSObject::allocateSparseIndexMap(VM&amp; vm)
2717 {
2718     SparseArrayValueMap* result = SparseArrayValueMap::create(vm);
2719     arrayStorage()-&gt;m_sparseMap.set(vm, this, result);
2720     return result;
2721 }
2722 
2723 void JSObject::deallocateSparseIndexMap()
2724 {
2725     if (ArrayStorage* arrayStorage = arrayStorageOrNull())
2726         arrayStorage-&gt;m_sparseMap.clear();
2727 }
2728 
2729 bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(ExecState* exec, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2730 {
2731     VM&amp; vm = exec-&gt;vm();
<span class="line-added">2732     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2733 </span>
2734     for (JSObject* current = this; ;) {
2735         // This has the same behavior with respect to prototypes as JSObject::put(). It only
2736         // allows a prototype to intercept a put if (a) the prototype declares the property
2737         // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
2738         // (b) that property is declared as ReadOnly or Accessor.
2739 
2740         ArrayStorage* storage = current-&gt;arrayStorageOrNull();
2741         if (storage &amp;&amp; storage-&gt;m_sparseMap) {
2742             SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
2743             if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
<span class="line-added">2744                 scope.release();</span>
2745                 putResult = iter-&gt;value.put(exec, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);
2746                 return true;
2747             }
2748         }
2749 
2750         if (current-&gt;type() == ProxyObjectType) {
<span class="line-added">2751             scope.release();</span>
2752             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
2753             putResult = proxy-&gt;putByIndexCommon(exec, thisValue, i, value, shouldThrow);
2754             return true;
2755         }
2756 
<span class="line-modified">2757         JSValue prototypeValue = current-&gt;getPrototype(vm, exec);</span>
<span class="line-added">2758         RETURN_IF_EXCEPTION(scope, false);</span>
2759         if (prototypeValue.isNull())
2760             return false;
2761 
2762         current = asObject(prototypeValue);
2763     }
2764 }
2765 
2766 bool JSObject::attemptToInterceptPutByIndexOnHole(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2767 {
<span class="line-modified">2768     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2769     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2770 </span>
<span class="line-added">2771     JSValue prototypeValue = getPrototype(vm, exec);</span>
<span class="line-added">2772     RETURN_IF_EXCEPTION(scope, false);</span>
2773     if (prototypeValue.isNull())
2774         return false;
2775 
<span class="line-modified">2776     RELEASE_AND_RETURN(scope, asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(exec, this, i, value, shouldThrow, putResult));</span>
2777 }
2778 
2779 template&lt;IndexingType indexingShape&gt;
2780 bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(ExecState* exec, unsigned i, JSValue value)
2781 {
2782     VM&amp; vm = exec-&gt;vm();
2783     auto scope = DECLARE_THROW_SCOPE(vm);
2784 
2785     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2786     ASSERT((indexingType() &amp; IndexingShapeMask) == indexingShape);
2787     ASSERT(!indexingShouldBeSparse(vm));
2788 
2789     Butterfly* butterfly = m_butterfly.get();
2790 
2791     // For us to get here, the index is either greater than the public length, or greater than
2792     // or equal to the vector length.
2793     ASSERT(i &gt;= butterfly-&gt;vectorLength());
2794 
2795     if (i &gt; MAX_STORAGE_VECTOR_INDEX
2796         || (i &gt;= MIN_SPARSE_ARRAY_INDEX &amp;&amp; !isDenseEnoughForVector(i, countElements&lt;indexingShape&gt;(butterfly)))
</pre>
<hr />
<pre>
2898     storage-&gt;m_numValuesInVector = numValuesInArray;
2899 
2900     // Copy all values from the map into the vector, and delete the map.
2901     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
2902     SparseArrayValueMap::const_iterator end = map-&gt;end();
2903     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2904         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2905     deallocateSparseIndexMap();
2906 
2907     // Store the new property into the vector.
2908     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2909     if (!valueSlot)
2910         ++storage-&gt;m_numValuesInVector;
2911     valueSlot.set(vm, this, value);
2912     return true;
2913 }
2914 
2915 bool JSObject::putByIndexBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, bool shouldThrow)
2916 {
2917     VM&amp; vm = exec-&gt;vm();
<span class="line-added">2918     auto scope = DECLARE_THROW_SCOPE(vm);</span>
2919 
2920     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2921 
2922     // i should be a valid array index that is outside of the current vector.
2923     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2924 
2925     switch (indexingType()) {
2926     case ALL_BLANK_INDEXING_TYPES: {
2927         if (indexingShouldBeSparse(vm)) {
<span class="line-modified">2928             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(</span>
2929                 exec, i, value, shouldThrow,
<span class="line-modified">2930                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm)));</span>
2931         }
2932         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">2933             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, createArrayStorage(vm, 0, 0)));</span>

2934         }
2935         if (needsSlowPutIndexing(vm)) {
2936             // Convert the indexing type to the SlowPutArrayStorage and retry.
2937             createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="line-modified">2938             RELEASE_AND_RETURN(scope, putByIndex(this, exec, i, value, shouldThrow));</span>
2939         }
2940 
2941         createInitialForValueAndSet(vm, i, value);
2942         return true;
2943     }
2944 
2945     case ALL_UNDECIDED_INDEXING_TYPES: {
2946         CRASH();
2947         break;
2948     }
2949 
2950     case ALL_INT32_INDEXING_TYPES:
<span class="line-modified">2951         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value));</span>
2952 
2953     case ALL_DOUBLE_INDEXING_TYPES:
<span class="line-modified">2954         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value));</span>
2955 
2956     case ALL_CONTIGUOUS_INDEXING_TYPES:
<span class="line-modified">2957         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value));</span>
2958 
2959     case NonArrayWithSlowPutArrayStorage:
2960     case ArrayWithSlowPutArrayStorage: {
2961         // No own property present in the vector, but there might be in the sparse map!
2962         SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
2963         bool putResult = false;
<span class="line-modified">2964         if (!(map &amp;&amp; map-&gt;contains(i))) {</span>
<span class="line-modified">2965             bool result = attemptToInterceptPutByIndexOnHole(exec, i, value, shouldThrow, putResult);</span>
<span class="line-added">2966             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">2967             if (result)</span>
<span class="line-added">2968                 return putResult;</span>
<span class="line-added">2969         }</span>
2970         FALLTHROUGH;
2971     }
2972 
2973     case NonArrayWithArrayStorage:
2974     case ArrayWithArrayStorage:
<span class="line-modified">2975         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, arrayStorage()));</span>
2976 
2977     default:
2978         RELEASE_ASSERT_NOT_REACHED();
2979     }
2980     return false;
2981 }
2982 
2983 bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)
2984 {
2985     VM&amp; vm = exec-&gt;vm();
2986     auto scope = DECLARE_THROW_SCOPE(vm);
2987 
2988     // i should be a valid array index that is outside of the current vector.
2989     ASSERT(hasAnyArrayStorage(indexingType()));
2990     ASSERT(arrayStorage() == storage);
2991     ASSERT(i &gt;= storage-&gt;vectorLength() || attributes);
2992     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2993 
2994     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2995 
</pre>
<hr />
<pre>
3049     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
3050         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
3051     deallocateSparseIndexMap();
3052 
3053     // Store the new property into the vector.
3054     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
3055     if (!valueSlot)
3056         ++storage-&gt;m_numValuesInVector;
3057     valueSlot.set(vm, this, value);
3058     return true;
3059 }
3060 
3061 bool JSObject::putDirectIndexSlowOrBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)
3062 {
3063     VM&amp; vm = exec-&gt;vm();
3064     ASSERT(!value.isCustomGetterSetter());
3065 
3066     if (!canDoFastPutDirectIndex(vm, this)) {
3067         PropertyDescriptor descriptor;
3068         descriptor.setDescriptor(value, attributes);
<span class="line-modified">3069         return methodTable(vm)-&gt;defineOwnProperty(this, exec, Identifier::from(vm, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
3070     }
3071 
3072     // i should be a valid array index that is outside of the current vector.
3073     ASSERT(i &lt;= MAX_ARRAY_INDEX);
3074 
3075     if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3076         notifyPresenceOfIndexedAccessors(vm);
3077 
3078     switch (indexingType()) {
3079     case ALL_BLANK_INDEXING_TYPES: {
3080         if (indexingShouldBeSparse(vm) || attributes) {
3081             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3082                 exec, i, value, attributes, mode,
3083                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3084         }
<span class="line-modified">3085         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {</span>
3086             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3087                 exec, i, value, attributes, mode, createArrayStorage(vm, 0, 0));
3088         }
3089         if (needsSlowPutIndexing(vm)) {
3090             ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
3091             storage-&gt;m_vector[i].set(vm, this, value);
3092             storage-&gt;m_numValuesInVector++;
3093             return true;
3094         }
3095 
3096         createInitialForValueAndSet(vm, i, value);
3097         return true;
3098     }
3099 
3100     case ALL_UNDECIDED_INDEXING_TYPES: {
3101         convertUndecidedForValue(vm, value);
3102         // Reloop.
3103         return putDirectIndex(exec, i, value, attributes, mode);
3104     }
3105 
</pre>
<hr />
<pre>
3141     }
3142 
3143     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
3144         if (attributes)
3145             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3146         return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, arrayStorage());
3147 
3148     default:
3149         RELEASE_ASSERT_NOT_REACHED();
3150         return false;
3151     }
3152 }
3153 
3154 bool JSObject::putDirectNativeIntrinsicGetter(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3155 {
3156     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3157     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3158     return putDirectNonIndexAccessor(vm, name, accessor, attributes);
3159 }
3160 
<span class="line-added">3161 void JSObject::putDirectNativeIntrinsicGetterWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)</span>
<span class="line-added">3162 {</span>
<span class="line-added">3163     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);</span>
<span class="line-added">3164     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);</span>
<span class="line-added">3165     putDirectNonIndexAccessorWithoutTransition(vm, name, accessor, attributes);</span>
<span class="line-added">3166 }</span>
<span class="line-added">3167 </span>
3168 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3169 {
3170     StringImpl* name = propertyName.publicName();
3171     if (!name)
3172         name = vm.propertyNames-&gt;anonymous.impl();
3173     ASSERT(name);
3174 
3175     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic);
3176     return putDirect(vm, propertyName, function, attributes);
3177 }
3178 
3179 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, const DOMJIT::Signature* signature, unsigned attributes)
3180 {
3181     StringImpl* name = propertyName.publicName();
3182     if (!name)
3183         name = vm.propertyNames-&gt;anonymous.impl();
3184     ASSERT(name);
3185 
3186     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic, callHostFunctionAsConstructor, signature);
3187     return putDirect(vm, propertyName, function, attributes);
</pre>
<hr />
<pre>
3367 bool JSObject::ensureLengthSlow(VM&amp; vm, unsigned length)
3368 {
3369     if (isCopyOnWrite(indexingMode())) {
3370         convertFromCopyOnWrite(vm);
3371         if (m_butterfly-&gt;vectorLength() &gt;= length)
3372             return true;
3373     }
3374 
3375     Butterfly* butterfly = this-&gt;butterfly();
3376 
3377     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3378     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3379     ASSERT(length &gt; butterfly-&gt;vectorLength());
3380 
3381     unsigned oldVectorLength = butterfly-&gt;vectorLength();
3382     unsigned newVectorLength;
3383 
3384     Structure* structure = this-&gt;structure(vm);
3385     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
3386 
<span class="line-added">3387     GCDeferralContext deferralContext(vm.heap);</span>
<span class="line-added">3388     DisallowGC disallowGC;</span>
3389     unsigned availableOldLength =
3390         Butterfly::availableContiguousVectorLength(propertyCapacity, oldVectorLength);
3391     Butterfly* newButterfly = nullptr;
3392     if (availableOldLength &gt;= length) {
3393         // This is the case where someone else selected a vector length that caused internal
3394         // fragmentation. If we did our jobs right, this would never happen. But I bet we will mess
3395         // this up, so this defense should stay.
3396         newVectorLength = availableOldLength;
3397     } else {
3398         newVectorLength = Butterfly::optimalContiguousVectorLength(
3399             propertyCapacity, std::min(length * 2, MAX_STORAGE_VECTOR_LENGTH));
<span class="line-modified">3400         butterfly = butterfly-&gt;reallocArrayRightIfPossible(</span>
<span class="line-modified">3401             vm, deferralContext, this, structure, propertyCapacity, true,</span>
3402             oldVectorLength * sizeof(EncodedJSValue),
3403             newVectorLength * sizeof(EncodedJSValue));
3404         if (!butterfly)
3405             return false;
3406         newButterfly = butterfly;
3407     }
3408 
3409     if (hasDouble(indexingType())) {
3410         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3411             butterfly-&gt;indexingPayload&lt;double&gt;()[i] = PNaN;
3412     } else {
3413         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3414             butterfly-&gt;indexingPayload&lt;WriteBarrier&lt;Unknown&gt;&gt;()[i].clear();
3415     }
3416 
3417     if (newButterfly) {
3418         butterfly-&gt;setVectorLength(newVectorLength);
3419         WTF::storeStoreFence();
3420         m_butterfly.set(vm, this, newButterfly);
3421     } else {
</pre>
<hr />
<pre>
3450     // capacity, since we might have already mutated the structure in-place.
3451 
3452     return Butterfly::createOrGrowPropertyStorage(butterfly(), vm, this, structure(vm), oldSize, newSize);
3453 }
3454 
3455 static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(ExecState* exec, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)
3456 {
3457     VM&amp; vm = exec-&gt;vm();
3458     auto key = std::make_pair(getterSetter, (int)type);
3459     JSCustomGetterSetterFunction* customGetterSetterFunction = vm.customGetterSetterFunctionMap.get(key);
3460     if (!customGetterSetterFunction) {
3461         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, exec-&gt;lexicalGlobalObject(), getterSetter, type, propertyName.publicName());
3462         vm.customGetterSetterFunctionMap.set(key, customGetterSetterFunction);
3463     }
3464     return customGetterSetterFunction;
3465 }
3466 
3467 bool JSObject::getOwnPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)
3468 {
3469     VM&amp; vm = exec-&gt;vm();
<span class="line-added">3470     auto scope = DECLARE_THROW_SCOPE(vm);</span>
3471     JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">3472 </span>
<span class="line-added">3473     bool result = methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot);</span>
<span class="line-added">3474     EXCEPTION_ASSERT(!scope.exception() || !result);</span>
<span class="line-added">3475     if (!result)</span>
3476         return false;
3477 
<span class="line-added">3478 </span>
<span class="line-added">3479     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200560</span>
<span class="line-added">3480     // This breaks the assumption that getOwnPropertySlot should return &quot;own&quot; property.</span>
<span class="line-added">3481     // We should fix DebuggerScope, ProxyObject etc. to remove this.</span>
<span class="line-added">3482     //</span>
3483     // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
3484     // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
3485     // the property is not an own property.
3486     if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
3487         JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
3488         if (!jsProxy || jsProxy-&gt;target() != slot.slotBase()) {
3489             // Try ProxyObject.
3490             ProxyObject* proxyObject = jsDynamicCast&lt;ProxyObject*&gt;(vm, this);
3491             if (!proxyObject || proxyObject-&gt;target() != slot.slotBase())
3492                 return false;
3493         }
3494     }
3495 
3496     if (slot.isAccessor())
3497         descriptor.setAccessorDescriptor(slot.getterSetter(), slot.attributes());
3498     else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
3499         descriptor.setCustomDescriptor(slot.attributes());
3500 
3501         JSObject* thisObject = this;
3502         if (auto* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this))
</pre>
<hr />
<pre>
3506         if (slot.isCustomAccessor())
3507             getterSetter = slot.customGetterSetter();
3508         else {
3509             JSValue maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3510             if (!maybeGetterSetter) {
3511                 thisObject-&gt;reifyAllStaticProperties(exec);
3512                 maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3513             }
3514 
3515             ASSERT(maybeGetterSetter);
3516             getterSetter = jsDynamicCast&lt;CustomGetterSetter*&gt;(vm, maybeGetterSetter);
3517         }
3518         ASSERT(getterSetter);
3519         if (!getterSetter)
3520             return false;
3521 
3522         if (getterSetter-&gt;getter())
3523             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));
3524         if (getterSetter-&gt;setter())
3525             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));
<span class="line-modified">3526     } else {</span>
<span class="line-modified">3527         JSValue value = slot.getValue(exec, propertyName);</span>
<span class="line-added">3528         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">3529         descriptor.setDescriptor(value, slot.attributes());</span>
<span class="line-added">3530     }</span>
<span class="line-added">3531 </span>
3532     return true;
3533 }
3534 
3535 static bool putDescriptor(ExecState* exec, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)
3536 {
3537     VM&amp; vm = exec-&gt;vm();
3538     if (descriptor.isGenericDescriptor() || descriptor.isDataDescriptor()) {
3539         if (descriptor.isGenericDescriptor() &amp;&amp; oldDescriptor.isAccessorDescriptor()) {
3540             JSObject* getter = oldDescriptor.getterPresent() ? oldDescriptor.getterObject() : nullptr;
3541             JSObject* setter = oldDescriptor.setterPresent() ? oldDescriptor.setterObject() : nullptr;
3542             GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
3543             target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);
3544             return true;
3545         }
3546         JSValue newValue = jsUndefined();
3547         if (descriptor.value())
3548             newValue = descriptor.value();
3549         else if (oldDescriptor.value())
3550             newValue = oldDescriptor.value();
3551         target-&gt;putDirect(vm, propertyName, newValue, attributes &amp; ~PropertyAttribute::Accessor);
</pre>
</td>
</tr>
</table>
<center><a href="JSONObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>