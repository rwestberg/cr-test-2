<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSectionParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;WasmSectionParser.h&quot;
 29 
 30 #if ENABLE(WEBASSEMBLY)
 31 
 32 #include &quot;IdentifierInlines.h&quot;

 33 #include &quot;WasmMemoryInformation.h&quot;
 34 #include &quot;WasmNameSectionParser.h&quot;
 35 #include &quot;WasmOps.h&quot;
 36 #include &quot;WasmSections.h&quot;
 37 #include &quot;WasmSignatureInlines.h&quot;

 38 
 39 namespace JSC { namespace Wasm {
 40 
 41 auto SectionParser::parseType() -&gt; PartialResult
 42 {
 43     uint32_t count;
 44 
 45     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Type section&#39;s count&quot;);
 46     WASM_PARSER_FAIL_IF(count &gt; maxTypes, &quot;Type section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxTypes);
 47     WASM_PARSER_FAIL_IF(!m_info-&gt;usedSignatures.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, count, &quot; entries&quot;);
 48 
 49     for (uint32_t i = 0; i &lt; count; ++i) {
 50         int8_t type;
 51         uint32_t argumentCount;
 52         Vector&lt;Type&gt; argumentTypes;
 53 
 54         WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s type&quot;);
 55         WASM_PARSER_FAIL_IF(type != Func, i, &quot;th Type is non-Func &quot;, type);
 56         WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s argument count&quot;);
 57         WASM_PARSER_FAIL_IF(argumentCount &gt; maxFunctionParams, i, &quot;th argument count is too big &quot;, argumentCount, &quot; maximum &quot;, maxFunctionParams);
</pre>
<hr />
<pre>
100 
101         WASM_PARSER_FAIL_IF(!parseVarUInt32(moduleLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s module name length&quot;);
102         WASM_PARSER_FAIL_IF(!consumeUTF8String(moduleString, moduleLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s module name of length &quot;, moduleLen);
103 
104         WASM_PARSER_FAIL_IF(!parseVarUInt32(fieldLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s field name length in module &#39;&quot;, moduleString, &quot;&#39;&quot;);
105         WASM_PARSER_FAIL_IF(!consumeUTF8String(fieldString, fieldLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s field name of length &quot;, moduleLen, &quot; in module &#39;&quot;, moduleString, &quot;&#39;&quot;);
106 
107         WASM_PARSER_FAIL_IF(!parseExternalKind(kind), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s kind in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
108         switch (kind) {
109         case ExternalKind::Function: {
110             uint32_t functionSignatureIndex;
111             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSignatureIndex), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s function signature in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
112             WASM_PARSER_FAIL_IF(functionSignatureIndex &gt;= m_info-&gt;usedSignatures.size(), &quot;invalid function signature for &quot;, importNumber, &quot;th Import, &quot;, functionSignatureIndex, &quot; is out of range of &quot;, m_info-&gt;usedSignatures.size(), &quot; in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
113             kindIndex = m_info-&gt;importFunctionSignatureIndices.size();
114             SignatureIndex signatureIndex = SignatureInformation::get(m_info-&gt;usedSignatures[functionSignatureIndex]);
115             m_info-&gt;importFunctionSignatureIndices.uncheckedAppend(signatureIndex);
116             break;
117         }
118         case ExternalKind::Table: {
119             bool isImport = true;

120             PartialResult result = parseTableHelper(isImport);
121             if (UNLIKELY(!result))
122                 return makeUnexpected(WTFMove(result.error()));
123             break;
124         }
125         case ExternalKind::Memory: {
126             bool isImport = true;
127             PartialResult result = parseMemoryHelper(isImport);
128             if (UNLIKELY(!result))
129                 return makeUnexpected(WTFMove(result.error()));
130             break;
131         }
132         case ExternalKind::Global: {
133             Global global;
134             WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
135             WASM_PARSER_FAIL_IF(global.mutability == Global::Mutable, &quot;Mutable Globals aren&#39;t supported&quot;);
136 
137             kindIndex = m_info-&gt;globals.size();
138             m_info-&gt;globals.uncheckedAppend(WTFMove(global));
139             break;
</pre>
<hr />
<pre>
165         size_t start = 0;
166         size_t end = 0;
167         m_info-&gt;internalFunctionSignatureIndices.uncheckedAppend(signatureIndex);
168         m_info-&gt;functions.uncheckedAppend({ start, end, Vector&lt;uint8_t&gt;() });
169     }
170 
171     return { };
172 }
173 
174 auto SectionParser::parseResizableLimits(uint32_t&amp; initial, Optional&lt;uint32_t&gt;&amp; maximum) -&gt; PartialResult
175 {
176     ASSERT(!maximum);
177 
178     uint8_t flags;
179     WASM_PARSER_FAIL_IF(!parseVarUInt1(flags), &quot;can&#39;t parse resizable limits flags&quot;);
180     WASM_PARSER_FAIL_IF(!parseVarUInt32(initial), &quot;can&#39;t parse resizable limits initial page count&quot;);
181 
182     if (flags) {
183         uint32_t maximumInt;
184         WASM_PARSER_FAIL_IF(!parseVarUInt32(maximumInt), &quot;can&#39;t parse resizable limits maximum page count&quot;);
<span class="line-modified">185         WASM_PARSER_FAIL_IF(initial &gt; maximumInt, &quot;resizable limits has a initial page count of &quot;, initial, &quot; which is greater than its maximum &quot;, maximumInt);</span>
186         maximum = maximumInt;
187     }
188 
189     return { };
190 }
191 
192 auto SectionParser::parseTableHelper(bool isImport) -&gt; PartialResult
193 {
<span class="line-modified">194     WASM_PARSER_FAIL_IF(m_info-&gt;tableCount() &gt; 0, &quot;Cannot have more than one Table for now&quot;);</span>
195 
196     int8_t type;
197     WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t parse Table type&quot;);
<span class="line-modified">198     WASM_PARSER_FAIL_IF(type != Wasm::Anyfunc, &quot;Table type should be anyfunc, got &quot;, type);</span>
199 
200     uint32_t initial;
201     Optional&lt;uint32_t&gt; maximum;
202     PartialResult limits = parseResizableLimits(initial, maximum);
203     if (UNLIKELY(!limits))
204         return makeUnexpected(WTFMove(limits.error()));
205     WASM_PARSER_FAIL_IF(initial &gt; maxTableEntries, &quot;Table&#39;s initial page count of &quot;, initial, &quot; is too big, maximum &quot;, maxTableEntries);
206 
207     ASSERT(!maximum || *maximum &gt;= initial);
208 
<span class="line-modified">209     m_info-&gt;tableInformation = TableInformation(initial, maximum, isImport);</span>

210 
211     return { };
212 }
213 
214 auto SectionParser::parseTable() -&gt; PartialResult
215 {
216     uint32_t count;
217     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Table&#39;s count&quot;);
<span class="line-removed">218     WASM_PARSER_FAIL_IF(count &gt; 1, &quot;Table count of &quot;, count, &quot; is invalid, at most 1 is allowed for now&quot;);</span>
219 
<span class="line-modified">220     if (!count)</span>
<span class="line-modified">221         return { };</span>
<span class="line-modified">222 </span>
<span class="line-modified">223     bool isImport = false;</span>
<span class="line-modified">224     PartialResult result = parseTableHelper(isImport);</span>
<span class="line-modified">225     if (UNLIKELY(!result))</span>
<span class="line-removed">226         return makeUnexpected(WTFMove(result.error()));</span>
227 
228     return { };
229 }
230 
231 auto SectionParser::parseMemoryHelper(bool isImport) -&gt; PartialResult
232 {
233     WASM_PARSER_FAIL_IF(m_info-&gt;memoryCount(), &quot;there can at most be one Memory section for now&quot;);
234 
235     PageCount initialPageCount;
236     PageCount maximumPageCount;
237     {
238         uint32_t initial;
239         Optional&lt;uint32_t&gt; maximum;
240         PartialResult limits = parseResizableLimits(initial, maximum);
241         if (UNLIKELY(!limits))
242             return makeUnexpected(WTFMove(limits.error()));
243         ASSERT(!maximum || *maximum &gt;= initial);
244         WASM_PARSER_FAIL_IF(!PageCount::isValid(initial), &quot;Memory&#39;s initial page count of &quot;, initial, &quot; is invalid&quot;);
245 
246         initialPageCount = PageCount(initial);
</pre>
<hr />
<pre>
271     return parseMemoryHelper(isImport);
272 }
273 
274 auto SectionParser::parseGlobal() -&gt; PartialResult
275 {
276     uint32_t globalCount;
277     WASM_PARSER_FAIL_IF(!parseVarUInt32(globalCount), &quot;can&#39;t get Global section&#39;s count&quot;);
278     WASM_PARSER_FAIL_IF(globalCount &gt; maxGlobals, &quot;Global section&#39;s count is too big &quot;, globalCount, &quot; maximum &quot;, maxGlobals);
279     size_t totalBytes = globalCount + m_info-&gt;firstInternalGlobal;
280     WASM_PARSER_FAIL_IF((static_cast&lt;uint32_t&gt;(totalBytes) &lt; globalCount) || !m_info-&gt;globals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; globals&quot;);
281 
282     for (uint32_t globalIndex = 0; globalIndex &lt; globalCount; ++globalIndex) {
283         Global global;
284         uint8_t initOpcode;
285 
286         WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
287         Type typeForInitOpcode;
288         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
289         if (initOpcode == GetGlobal)
290             global.initializationType = Global::FromGlobalImport;


291         else
292             global.initializationType = Global::FromExpression;
<span class="line-modified">293         WASM_PARSER_FAIL_IF(typeForInitOpcode != global.type, &quot;Global init_expr opcode of type &quot;, typeForInitOpcode, &quot; doesn&#39;t match global&#39;s type &quot;, global.type);</span>
294 
295         m_info-&gt;globals.uncheckedAppend(WTFMove(global));
296     }
297 
298     return { };
299 }
300 
301 auto SectionParser::parseExport() -&gt; PartialResult
302 {
303     uint32_t exportCount;
304     WASM_PARSER_FAIL_IF(!parseVarUInt32(exportCount), &quot;can&#39;t get Export section&#39;s count&quot;);
305     WASM_PARSER_FAIL_IF(exportCount &gt; maxExports, &quot;Export section&#39;s count is too big &quot;, exportCount, &quot; maximum &quot;, maxExports);
306     WASM_PARSER_FAIL_IF(!m_info-&gt;exports.tryReserveCapacity(exportCount), &quot;can&#39;t allocate enough memory for &quot;, exportCount, &quot; exports&quot;);
307 
308     HashSet&lt;String&gt; exportNames;
309     for (uint32_t exportNumber = 0; exportNumber &lt; exportCount; ++exportNumber) {
310         uint32_t fieldLen;
311         Name fieldString;
312         ExternalKind kind;
313         unsigned kindIndex;
</pre>
<hr />
<pre>
355     SignatureIndex signatureIndex = m_info-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndex);
356     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
357     WASM_PARSER_FAIL_IF(signature.argumentCount(), &quot;Start function can&#39;t have arguments&quot;);
358     WASM_PARSER_FAIL_IF(signature.returnType() != Void, &quot;Start function can&#39;t return a value&quot;);
359     m_info-&gt;startFunctionIndexSpace = startFunctionIndex;
360     return { };
361 }
362 
363 auto SectionParser::parseElement() -&gt; PartialResult
364 {
365     uint32_t elementCount;
366     WASM_PARSER_FAIL_IF(!parseVarUInt32(elementCount), &quot;can&#39;t get Element section&#39;s count&quot;);
367     WASM_PARSER_FAIL_IF(elementCount &gt; maxTableEntries, &quot;Element section&#39;s count is too big &quot;, elementCount, &quot; maximum &quot;, maxTableEntries);
368     WASM_PARSER_FAIL_IF(!m_info-&gt;elements.tryReserveCapacity(elementCount), &quot;can&#39;t allocate memory for &quot;, elementCount, &quot; Elements&quot;);
369     for (unsigned elementNum = 0; elementNum &lt; elementCount; ++elementNum) {
370         uint32_t tableIndex;
371         uint64_t initExprBits;
372         uint8_t initOpcode;
373         uint32_t indexCount;
374 
<span class="line-modified">375         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get &quot;, elementNum, &quot;th Element table index&quot;);</span>







376         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info-&gt;tableCount(), &quot;Element section for Table &quot;, tableIndex, &quot; exceeds available Table &quot;, m_info-&gt;tableCount());

377         Type initExprType;
378         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, initExprBits, initExprType));
379         WASM_PARSER_FAIL_IF(initExprType != I32, &quot;Element init_expr must produce an i32&quot;);
380         WASM_PARSER_FAIL_IF(!parseVarUInt32(indexCount), &quot;can&#39;t get &quot;, elementNum, &quot;th index count for Element section&quot;);
381         WASM_PARSER_FAIL_IF(indexCount == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Element section&#39;s &quot;, elementNum, &quot;th index count is too big &quot;, indexCount);
382 
<span class="line-modified">383         ASSERT(!!m_info-&gt;tableInformation);</span>
384 
<span class="line-modified">385         Element element(makeI32InitExpr(initOpcode, initExprBits));</span>
386         WASM_PARSER_FAIL_IF(!element.functionIndices.tryReserveCapacity(indexCount), &quot;can&#39;t allocate memory for &quot;, indexCount, &quot; Element indices&quot;);
387 
388         for (unsigned index = 0; index &lt; indexCount; ++index) {
389             uint32_t functionIndex;
390             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t get Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index&quot;);
391             WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index is &quot;, functionIndex, &quot; which exceeds the function index space size of &quot;, m_info-&gt;functionIndexSpaceSize());
392 
393             element.functionIndices.uncheckedAppend(functionIndex);
394         }
395 
396         m_info-&gt;elements.uncheckedAppend(WTFMove(element));
397     }
398 
399     return { };
400 }
401 
402 // This function will be changed to be RELEASE_ASSERT_NOT_REACHED once we switch our parsing infrastructure to the streaming parser.
403 auto SectionParser::parseCode() -&gt; PartialResult
404 {

405     uint32_t count;
406     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Code section&#39;s count&quot;);
407     WASM_PARSER_FAIL_IF(count == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, count);
408     WASM_PARSER_FAIL_IF(count != m_info-&gt;functions.size(), &quot;Code section count &quot;, count, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());
409 
410     for (uint32_t i = 0; i &lt; count; ++i) {
411         uint32_t functionSize;
412         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSize), &quot;can&#39;t get &quot;, i, &quot;th Code function&#39;s size&quot;);
413         WASM_PARSER_FAIL_IF(functionSize &gt; length(), &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s size &quot;, length());
414         WASM_PARSER_FAIL_IF(functionSize &gt; length() - m_offset, &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s remaining size&quot;, length() - m_offset);
415         WASM_PARSER_FAIL_IF(functionSize &gt; maxFunctionSize, &quot;Code function&#39;s size &quot;, functionSize, &quot; is too big&quot;);
416 
417         Vector&lt;uint8_t&gt; data(functionSize);
418         std::memcpy(data.data(), source() + m_offset, functionSize);
419         m_info-&gt;functions[i].start = m_offsetInSource + m_offset;
420         m_info-&gt;functions[i].end = m_offsetInSource + m_offset + functionSize;
421         m_info-&gt;functions[i].data = WTFMove(data);
422         m_offset += functionSize;
423     }
424 
</pre>
<hr />
<pre>
458         uint64_t constant;
459         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s f64.const&quot;);
460         bitsOrImportNumber = constant;
461         resultType = F64;
462         break;
463     }
464 
465     case GetGlobal: {
466         uint32_t index;
467         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
468 
469         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;globals.size(), &quot;get_global&#39;s index &quot;, index, &quot; exceeds the number of globals &quot;, m_info-&gt;globals.size());
470         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;firstInternalGlobal, &quot;get_global import kind index &quot;, index, &quot; exceeds the first internal global &quot;, m_info-&gt;firstInternalGlobal);
471 
472         ASSERT(m_info-&gt;globals[index].mutability == Global::Immutable);
473         resultType = m_info-&gt;globals[index].type;
474         bitsOrImportNumber = index;
475         break;
476     }
477 
















478     default:
479         WASM_PARSER_FAIL_IF(true, &quot;unknown init_expr opcode &quot;, opcode);
480     }
481 
482     uint8_t endOpcode;
483     WASM_PARSER_FAIL_IF(!parseUInt8(endOpcode), &quot;can&#39;t get init_expr&#39;s end opcode&quot;);
484     WASM_PARSER_FAIL_IF(endOpcode != OpType::End, &quot;init_expr should end with end, ended with &quot;, endOpcode);
485 
486     return { };
487 }
488 
489 auto SectionParser::parseGlobalType(Global&amp; global) -&gt; PartialResult
490 {
491     uint8_t mutability;
492     WASM_PARSER_FAIL_IF(!parseValueType(global.type), &quot;can&#39;t get Global&#39;s value type&quot;);
493     WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), &quot;can&#39;t get Global type&#39;s mutability&quot;);
494     global.mutability = static_cast&lt;Global::Mutability&gt;(mutability);
495     return { };
496 }
497 
</pre>
</td>
<td>
<hr />
<pre>
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;WasmSectionParser.h&quot;
 29 
 30 #if ENABLE(WEBASSEMBLY)
 31 
 32 #include &quot;IdentifierInlines.h&quot;
<span class="line-added"> 33 #include &quot;JSCJSValueInlines.h&quot;</span>
 34 #include &quot;WasmMemoryInformation.h&quot;
 35 #include &quot;WasmNameSectionParser.h&quot;
 36 #include &quot;WasmOps.h&quot;
 37 #include &quot;WasmSections.h&quot;
 38 #include &quot;WasmSignatureInlines.h&quot;
<span class="line-added"> 39 #include &lt;wtf/Optional.h&gt;</span>
 40 
 41 namespace JSC { namespace Wasm {
 42 
 43 auto SectionParser::parseType() -&gt; PartialResult
 44 {
 45     uint32_t count;
 46 
 47     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Type section&#39;s count&quot;);
 48     WASM_PARSER_FAIL_IF(count &gt; maxTypes, &quot;Type section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxTypes);
 49     WASM_PARSER_FAIL_IF(!m_info-&gt;usedSignatures.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, count, &quot; entries&quot;);
 50 
 51     for (uint32_t i = 0; i &lt; count; ++i) {
 52         int8_t type;
 53         uint32_t argumentCount;
 54         Vector&lt;Type&gt; argumentTypes;
 55 
 56         WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s type&quot;);
 57         WASM_PARSER_FAIL_IF(type != Func, i, &quot;th Type is non-Func &quot;, type);
 58         WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s argument count&quot;);
 59         WASM_PARSER_FAIL_IF(argumentCount &gt; maxFunctionParams, i, &quot;th argument count is too big &quot;, argumentCount, &quot; maximum &quot;, maxFunctionParams);
</pre>
<hr />
<pre>
102 
103         WASM_PARSER_FAIL_IF(!parseVarUInt32(moduleLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s module name length&quot;);
104         WASM_PARSER_FAIL_IF(!consumeUTF8String(moduleString, moduleLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s module name of length &quot;, moduleLen);
105 
106         WASM_PARSER_FAIL_IF(!parseVarUInt32(fieldLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s field name length in module &#39;&quot;, moduleString, &quot;&#39;&quot;);
107         WASM_PARSER_FAIL_IF(!consumeUTF8String(fieldString, fieldLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s field name of length &quot;, moduleLen, &quot; in module &#39;&quot;, moduleString, &quot;&#39;&quot;);
108 
109         WASM_PARSER_FAIL_IF(!parseExternalKind(kind), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s kind in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
110         switch (kind) {
111         case ExternalKind::Function: {
112             uint32_t functionSignatureIndex;
113             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSignatureIndex), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s function signature in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
114             WASM_PARSER_FAIL_IF(functionSignatureIndex &gt;= m_info-&gt;usedSignatures.size(), &quot;invalid function signature for &quot;, importNumber, &quot;th Import, &quot;, functionSignatureIndex, &quot; is out of range of &quot;, m_info-&gt;usedSignatures.size(), &quot; in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
115             kindIndex = m_info-&gt;importFunctionSignatureIndices.size();
116             SignatureIndex signatureIndex = SignatureInformation::get(m_info-&gt;usedSignatures[functionSignatureIndex]);
117             m_info-&gt;importFunctionSignatureIndices.uncheckedAppend(signatureIndex);
118             break;
119         }
120         case ExternalKind::Table: {
121             bool isImport = true;
<span class="line-added">122             kindIndex = m_info-&gt;tables.size();</span>
123             PartialResult result = parseTableHelper(isImport);
124             if (UNLIKELY(!result))
125                 return makeUnexpected(WTFMove(result.error()));
126             break;
127         }
128         case ExternalKind::Memory: {
129             bool isImport = true;
130             PartialResult result = parseMemoryHelper(isImport);
131             if (UNLIKELY(!result))
132                 return makeUnexpected(WTFMove(result.error()));
133             break;
134         }
135         case ExternalKind::Global: {
136             Global global;
137             WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
138             WASM_PARSER_FAIL_IF(global.mutability == Global::Mutable, &quot;Mutable Globals aren&#39;t supported&quot;);
139 
140             kindIndex = m_info-&gt;globals.size();
141             m_info-&gt;globals.uncheckedAppend(WTFMove(global));
142             break;
</pre>
<hr />
<pre>
168         size_t start = 0;
169         size_t end = 0;
170         m_info-&gt;internalFunctionSignatureIndices.uncheckedAppend(signatureIndex);
171         m_info-&gt;functions.uncheckedAppend({ start, end, Vector&lt;uint8_t&gt;() });
172     }
173 
174     return { };
175 }
176 
177 auto SectionParser::parseResizableLimits(uint32_t&amp; initial, Optional&lt;uint32_t&gt;&amp; maximum) -&gt; PartialResult
178 {
179     ASSERT(!maximum);
180 
181     uint8_t flags;
182     WASM_PARSER_FAIL_IF(!parseVarUInt1(flags), &quot;can&#39;t parse resizable limits flags&quot;);
183     WASM_PARSER_FAIL_IF(!parseVarUInt32(initial), &quot;can&#39;t parse resizable limits initial page count&quot;);
184 
185     if (flags) {
186         uint32_t maximumInt;
187         WASM_PARSER_FAIL_IF(!parseVarUInt32(maximumInt), &quot;can&#39;t parse resizable limits maximum page count&quot;);
<span class="line-modified">188         WASM_PARSER_FAIL_IF(initial &gt; maximumInt, &quot;resizable limits has an initial page count of &quot;, initial, &quot; which is greater than its maximum &quot;, maximumInt);</span>
189         maximum = maximumInt;
190     }
191 
192     return { };
193 }
194 
195 auto SectionParser::parseTableHelper(bool isImport) -&gt; PartialResult
196 {
<span class="line-modified">197     WASM_PARSER_FAIL_IF(m_info-&gt;tableCount() &gt;= maxTables, &quot;Table count of &quot;, m_info-&gt;tableCount(), &quot; is too big, maximum &quot;, maxTables);</span>
198 
199     int8_t type;
200     WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t parse Table type&quot;);
<span class="line-modified">201     WASM_PARSER_FAIL_IF(type != Wasm::Funcref &amp;&amp; type != Wasm::Anyref, &quot;Table type should be funcref or anyref, got &quot;, type);</span>
202 
203     uint32_t initial;
204     Optional&lt;uint32_t&gt; maximum;
205     PartialResult limits = parseResizableLimits(initial, maximum);
206     if (UNLIKELY(!limits))
207         return makeUnexpected(WTFMove(limits.error()));
208     WASM_PARSER_FAIL_IF(initial &gt; maxTableEntries, &quot;Table&#39;s initial page count of &quot;, initial, &quot; is too big, maximum &quot;, maxTableEntries);
209 
210     ASSERT(!maximum || *maximum &gt;= initial);
211 
<span class="line-modified">212     TableElementType tableType = type == Wasm::Funcref ? TableElementType::Funcref : TableElementType::Anyref;</span>
<span class="line-added">213     m_info-&gt;tables.append(TableInformation(initial, maximum, isImport, tableType));</span>
214 
215     return { };
216 }
217 
218 auto SectionParser::parseTable() -&gt; PartialResult
219 {
220     uint32_t count;
221     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Table&#39;s count&quot;);

222 
<span class="line-modified">223     for (unsigned i = 0; i &lt; count; ++i) {</span>
<span class="line-modified">224         bool isImport = false;</span>
<span class="line-modified">225         PartialResult result = parseTableHelper(isImport);</span>
<span class="line-modified">226         if (UNLIKELY(!result))</span>
<span class="line-modified">227             return makeUnexpected(WTFMove(result.error()));</span>
<span class="line-modified">228     }</span>

229 
230     return { };
231 }
232 
233 auto SectionParser::parseMemoryHelper(bool isImport) -&gt; PartialResult
234 {
235     WASM_PARSER_FAIL_IF(m_info-&gt;memoryCount(), &quot;there can at most be one Memory section for now&quot;);
236 
237     PageCount initialPageCount;
238     PageCount maximumPageCount;
239     {
240         uint32_t initial;
241         Optional&lt;uint32_t&gt; maximum;
242         PartialResult limits = parseResizableLimits(initial, maximum);
243         if (UNLIKELY(!limits))
244             return makeUnexpected(WTFMove(limits.error()));
245         ASSERT(!maximum || *maximum &gt;= initial);
246         WASM_PARSER_FAIL_IF(!PageCount::isValid(initial), &quot;Memory&#39;s initial page count of &quot;, initial, &quot; is invalid&quot;);
247 
248         initialPageCount = PageCount(initial);
</pre>
<hr />
<pre>
273     return parseMemoryHelper(isImport);
274 }
275 
276 auto SectionParser::parseGlobal() -&gt; PartialResult
277 {
278     uint32_t globalCount;
279     WASM_PARSER_FAIL_IF(!parseVarUInt32(globalCount), &quot;can&#39;t get Global section&#39;s count&quot;);
280     WASM_PARSER_FAIL_IF(globalCount &gt; maxGlobals, &quot;Global section&#39;s count is too big &quot;, globalCount, &quot; maximum &quot;, maxGlobals);
281     size_t totalBytes = globalCount + m_info-&gt;firstInternalGlobal;
282     WASM_PARSER_FAIL_IF((static_cast&lt;uint32_t&gt;(totalBytes) &lt; globalCount) || !m_info-&gt;globals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; globals&quot;);
283 
284     for (uint32_t globalIndex = 0; globalIndex &lt; globalCount; ++globalIndex) {
285         Global global;
286         uint8_t initOpcode;
287 
288         WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
289         Type typeForInitOpcode;
290         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
291         if (initOpcode == GetGlobal)
292             global.initializationType = Global::FromGlobalImport;
<span class="line-added">293         else if (initOpcode == RefFunc)</span>
<span class="line-added">294             global.initializationType = Global::FromRefFunc;</span>
295         else
296             global.initializationType = Global::FromExpression;
<span class="line-modified">297         WASM_PARSER_FAIL_IF(!isSubtype(typeForInitOpcode, global.type), &quot;Global init_expr opcode of type &quot;, typeForInitOpcode, &quot; doesn&#39;t match global&#39;s type &quot;, global.type);</span>
298 
299         m_info-&gt;globals.uncheckedAppend(WTFMove(global));
300     }
301 
302     return { };
303 }
304 
305 auto SectionParser::parseExport() -&gt; PartialResult
306 {
307     uint32_t exportCount;
308     WASM_PARSER_FAIL_IF(!parseVarUInt32(exportCount), &quot;can&#39;t get Export section&#39;s count&quot;);
309     WASM_PARSER_FAIL_IF(exportCount &gt; maxExports, &quot;Export section&#39;s count is too big &quot;, exportCount, &quot; maximum &quot;, maxExports);
310     WASM_PARSER_FAIL_IF(!m_info-&gt;exports.tryReserveCapacity(exportCount), &quot;can&#39;t allocate enough memory for &quot;, exportCount, &quot; exports&quot;);
311 
312     HashSet&lt;String&gt; exportNames;
313     for (uint32_t exportNumber = 0; exportNumber &lt; exportCount; ++exportNumber) {
314         uint32_t fieldLen;
315         Name fieldString;
316         ExternalKind kind;
317         unsigned kindIndex;
</pre>
<hr />
<pre>
359     SignatureIndex signatureIndex = m_info-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndex);
360     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
361     WASM_PARSER_FAIL_IF(signature.argumentCount(), &quot;Start function can&#39;t have arguments&quot;);
362     WASM_PARSER_FAIL_IF(signature.returnType() != Void, &quot;Start function can&#39;t return a value&quot;);
363     m_info-&gt;startFunctionIndexSpace = startFunctionIndex;
364     return { };
365 }
366 
367 auto SectionParser::parseElement() -&gt; PartialResult
368 {
369     uint32_t elementCount;
370     WASM_PARSER_FAIL_IF(!parseVarUInt32(elementCount), &quot;can&#39;t get Element section&#39;s count&quot;);
371     WASM_PARSER_FAIL_IF(elementCount &gt; maxTableEntries, &quot;Element section&#39;s count is too big &quot;, elementCount, &quot; maximum &quot;, maxTableEntries);
372     WASM_PARSER_FAIL_IF(!m_info-&gt;elements.tryReserveCapacity(elementCount), &quot;can&#39;t allocate memory for &quot;, elementCount, &quot; Elements&quot;);
373     for (unsigned elementNum = 0; elementNum &lt; elementCount; ++elementNum) {
374         uint32_t tableIndex;
375         uint64_t initExprBits;
376         uint8_t initOpcode;
377         uint32_t indexCount;
378 
<span class="line-modified">379         uint8_t magic;</span>
<span class="line-added">380         WASM_PARSER_FAIL_IF(!parseUInt8(magic) || (magic &amp;&amp; magic != 2), &quot;can&#39;t get &quot;, elementNum, &quot;th Element reserved byte, which should be either 0x00 or 0x02 followed by a table index&quot;);</span>
<span class="line-added">381 </span>
<span class="line-added">382         if (magic == 2)</span>
<span class="line-added">383             WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get &quot;, elementNum, &quot;th Element table index&quot;);</span>
<span class="line-added">384         else</span>
<span class="line-added">385             tableIndex = 0;</span>
<span class="line-added">386 </span>
387         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info-&gt;tableCount(), &quot;Element section for Table &quot;, tableIndex, &quot; exceeds available Table &quot;, m_info-&gt;tableCount());
<span class="line-added">388         WASM_PARSER_FAIL_IF(m_info-&gt;tables[tableIndex].type() != TableElementType::Funcref, &quot;Table &quot;, tableIndex, &quot; must have type &#39;funcref&#39; to have an element section&quot;);</span>
389         Type initExprType;
390         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, initExprBits, initExprType));
391         WASM_PARSER_FAIL_IF(initExprType != I32, &quot;Element init_expr must produce an i32&quot;);
392         WASM_PARSER_FAIL_IF(!parseVarUInt32(indexCount), &quot;can&#39;t get &quot;, elementNum, &quot;th index count for Element section&quot;);
393         WASM_PARSER_FAIL_IF(indexCount == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Element section&#39;s &quot;, elementNum, &quot;th index count is too big &quot;, indexCount);
394 
<span class="line-modified">395         ASSERT(!!m_info-&gt;tables[tableIndex]);</span>
396 
<span class="line-modified">397         Element element(tableIndex, makeI32InitExpr(initOpcode, initExprBits));</span>
398         WASM_PARSER_FAIL_IF(!element.functionIndices.tryReserveCapacity(indexCount), &quot;can&#39;t allocate memory for &quot;, indexCount, &quot; Element indices&quot;);
399 
400         for (unsigned index = 0; index &lt; indexCount; ++index) {
401             uint32_t functionIndex;
402             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t get Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index&quot;);
403             WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index is &quot;, functionIndex, &quot; which exceeds the function index space size of &quot;, m_info-&gt;functionIndexSpaceSize());
404 
405             element.functionIndices.uncheckedAppend(functionIndex);
406         }
407 
408         m_info-&gt;elements.uncheckedAppend(WTFMove(element));
409     }
410 
411     return { };
412 }
413 
414 // This function will be changed to be RELEASE_ASSERT_NOT_REACHED once we switch our parsing infrastructure to the streaming parser.
415 auto SectionParser::parseCode() -&gt; PartialResult
416 {
<span class="line-added">417     m_info-&gt;codeSectionSize = length();</span>
418     uint32_t count;
419     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Code section&#39;s count&quot;);
420     WASM_PARSER_FAIL_IF(count == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, count);
421     WASM_PARSER_FAIL_IF(count != m_info-&gt;functions.size(), &quot;Code section count &quot;, count, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());
422 
423     for (uint32_t i = 0; i &lt; count; ++i) {
424         uint32_t functionSize;
425         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSize), &quot;can&#39;t get &quot;, i, &quot;th Code function&#39;s size&quot;);
426         WASM_PARSER_FAIL_IF(functionSize &gt; length(), &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s size &quot;, length());
427         WASM_PARSER_FAIL_IF(functionSize &gt; length() - m_offset, &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s remaining size&quot;, length() - m_offset);
428         WASM_PARSER_FAIL_IF(functionSize &gt; maxFunctionSize, &quot;Code function&#39;s size &quot;, functionSize, &quot; is too big&quot;);
429 
430         Vector&lt;uint8_t&gt; data(functionSize);
431         std::memcpy(data.data(), source() + m_offset, functionSize);
432         m_info-&gt;functions[i].start = m_offsetInSource + m_offset;
433         m_info-&gt;functions[i].end = m_offsetInSource + m_offset + functionSize;
434         m_info-&gt;functions[i].data = WTFMove(data);
435         m_offset += functionSize;
436     }
437 
</pre>
<hr />
<pre>
471         uint64_t constant;
472         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s f64.const&quot;);
473         bitsOrImportNumber = constant;
474         resultType = F64;
475         break;
476     }
477 
478     case GetGlobal: {
479         uint32_t index;
480         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
481 
482         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;globals.size(), &quot;get_global&#39;s index &quot;, index, &quot; exceeds the number of globals &quot;, m_info-&gt;globals.size());
483         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;firstInternalGlobal, &quot;get_global import kind index &quot;, index, &quot; exceeds the first internal global &quot;, m_info-&gt;firstInternalGlobal);
484 
485         ASSERT(m_info-&gt;globals[index].mutability == Global::Immutable);
486         resultType = m_info-&gt;globals[index].type;
487         bitsOrImportNumber = index;
488         break;
489     }
490 
<span class="line-added">491     case RefNull: {</span>
<span class="line-added">492         resultType = Funcref;</span>
<span class="line-added">493         bitsOrImportNumber = JSValue::encode(jsNull());</span>
<span class="line-added">494         break;</span>
<span class="line-added">495     }</span>
<span class="line-added">496 </span>
<span class="line-added">497     case RefFunc: {</span>
<span class="line-added">498         uint32_t index;</span>
<span class="line-added">499         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get ref.func index&quot;);</span>
<span class="line-added">500         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;functions.size(), &quot;ref.func index&quot;, index, &quot; exceeds the number of functions &quot;, m_info-&gt;functions.size());</span>
<span class="line-added">501 </span>
<span class="line-added">502         resultType = Funcref;</span>
<span class="line-added">503         bitsOrImportNumber = index;</span>
<span class="line-added">504         break;</span>
<span class="line-added">505     }</span>
<span class="line-added">506 </span>
507     default:
508         WASM_PARSER_FAIL_IF(true, &quot;unknown init_expr opcode &quot;, opcode);
509     }
510 
511     uint8_t endOpcode;
512     WASM_PARSER_FAIL_IF(!parseUInt8(endOpcode), &quot;can&#39;t get init_expr&#39;s end opcode&quot;);
513     WASM_PARSER_FAIL_IF(endOpcode != OpType::End, &quot;init_expr should end with end, ended with &quot;, endOpcode);
514 
515     return { };
516 }
517 
518 auto SectionParser::parseGlobalType(Global&amp; global) -&gt; PartialResult
519 {
520     uint8_t mutability;
521     WASM_PARSER_FAIL_IF(!parseValueType(global.type), &quot;can&#39;t get Global&#39;s value type&quot;);
522     WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), &quot;can&#39;t get Global type&#39;s mutability&quot;);
523     global.mutability = static_cast&lt;Global::Mutability&gt;(mutability);
524     return { };
525 }
526 
</pre>
</td>
</tr>
</table>
<center><a href="WasmParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSectionParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>