<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPreciseLocalClobberize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPureValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 139         if (!isFullNumberOrBooleanSpeculation(value))
 140             result |= SpecDoublePureNaN;
 141         return result;
 142     }
 143 
 144     SpeculatedType speculatedDoubleTypeForPredictions(SpeculatedType left, SpeculatedType right)
 145     {
 146         return speculatedDoubleTypeForPrediction(mergeSpeculations(left, right));
 147     }
 148 
 149     void propagate(Node* node)
 150     {
 151         NodeType op = node-&gt;op();
 152 
 153         bool changed = false;
 154 
 155         switch (op) {
 156         case GetLocal: {
 157             VariableAccessData* variable = node-&gt;variableAccessData();
 158             SpeculatedType prediction = variable-&gt;prediction();
<span class="line-modified"> 159             if (!variable-&gt;couldRepresentInt52() &amp;&amp; (prediction &amp; SpecInt52Only))</span>
<span class="line-modified"> 160                 prediction = (prediction | SpecAnyIntAsDouble) &amp; ~SpecInt52Only;</span>
 161             if (prediction)
 162                 changed |= mergePrediction(prediction);
 163             break;
 164         }
 165 
 166         case SetLocal: {
 167             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 168             changed |= variableAccessData-&gt;predict(node-&gt;child1()-&gt;prediction());
 169             break;
 170         }
 171 
 172         case UInt32ToNumber: {
 173             if (node-&gt;canSpeculateInt32(m_pass))
 174                 changed |= mergePrediction(SpecInt32Only);
 175             else if (enableInt52())
<span class="line-modified"> 176                 changed |= mergePrediction(SpecAnyInt);</span>
 177             else
 178                 changed |= mergePrediction(SpecBytecodeNumber);
 179             break;
 180         }
 181 
















 182         case ValueAdd: {
 183             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 184             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 185 
 186             if (left &amp;&amp; right) {
 187                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 188                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 189                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 190                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 191                     else if (m_graph.addShouldSpeculateAnyInt(node))</span>
<span class="line-modified"> 192                         changed |= mergePrediction(SpecInt52Only);</span>
 193                     else
 194                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 195                 } else if (isStringOrStringObjectSpeculation(left) || isStringOrStringObjectSpeculation(right)) {
 196                     // left or right is definitely something other than a number.
 197                     changed |= mergePrediction(SpecString);
 198                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 199                     changed |= mergePrediction(SpecBigInt);
 200                 else {
 201                     changed |= mergePrediction(SpecInt32Only);
 202                     if (node-&gt;mayHaveDoubleResult())
 203                         changed |= mergePrediction(SpecBytecodeDouble);
 204                     if (node-&gt;mayHaveBigIntResult())
 205                         changed |= mergePrediction(SpecBigInt);
 206                     if (node-&gt;mayHaveNonNumericResult())
 207                         changed |= mergePrediction(SpecString);
 208                 }
 209             }
 210             break;
 211         }
 212 
 213         case ArithAdd: {
 214             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 215             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 216 
 217             if (left &amp;&amp; right) {
 218                 if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 219                     changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 220                 else if (m_graph.addShouldSpeculateAnyInt(node))</span>
<span class="line-modified"> 221                     changed |= mergePrediction(SpecInt52Only);</span>
 222                 else if (isFullNumberOrBooleanSpeculation(left) &amp;&amp; isFullNumberOrBooleanSpeculation(right))
 223                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 224                 else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 225                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 226                 else
 227                     changed |= mergePrediction(SpecInt32Only);
 228             }
 229             break;
 230         }
 231 
 232         case ArithSub: {
 233             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 234             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 235 
 236             if (left &amp;&amp; right) {
 237                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 238                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 239                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 240                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 241                     else if (m_graph.addShouldSpeculateAnyInt(node))</span>
<span class="line-modified"> 242                         changed |= mergePrediction(SpecInt52Only);</span>
 243                     else
 244                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 245                 } else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 246                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 247                 else
 248                     changed |= mergePrediction(SpecInt32Only);
 249             }
 250             break;
 251         }
 252 
 253         case ValueSub: {
 254             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 255             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 256 
 257             if (left &amp;&amp; right) {
 258                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 259                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 260                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 261                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 262                     else if (m_graph.addShouldSpeculateAnyInt(node))</span>
<span class="line-modified"> 263                         changed |= mergePrediction(SpecInt52Only);</span>
 264                     else
 265                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 266                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 267                     changed |= mergePrediction(SpecBigInt);
 268                 else {
 269                     changed |= mergePrediction(SpecInt32Only);
 270                     if (node-&gt;mayHaveDoubleResult())
 271                         changed |= mergePrediction(SpecBytecodeDouble);
 272                     if (node-&gt;mayHaveBigIntResult())
 273                         changed |= mergePrediction(SpecBigInt);
 274                 }
 275             }
 276 
 277             break;
 278         }
 279 
















 280         case ValueNegate:
 281         case ArithNegate: {
 282             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 283             if (prediction) {
 284                 if (isInt32OrBooleanSpeculation(prediction) &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 285                     changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 286                 else if (m_graph.unaryArithShouldSpeculateAnyInt(node, m_pass))</span>
<span class="line-modified"> 287                     changed |= mergePrediction(SpecInt52Only);</span>
 288                 else if (isBytecodeNumberSpeculation(prediction))
 289                     changed |= mergePrediction(speculatedDoubleTypeForPrediction(node-&gt;child1()-&gt;prediction()));
 290                 else {
 291                     changed |= mergePrediction(SpecInt32Only);
 292                     if (node-&gt;op() == ValueNegate &amp;&amp; node-&gt;mayHaveBigIntResult())
 293                         changed |= mergePrediction(SpecBigInt);
 294                     if (node-&gt;mayHaveDoubleResult())
 295                         changed |= mergePrediction(SpecBytecodeDouble);
 296                 }
 297             }
 298             break;
 299         }
 300         case ArithMin:
 301         case ArithMax: {
 302             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 303             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 304 
 305             if (left &amp;&amp; right) {
 306                 if (Node::shouldSpeculateInt32OrBooleanForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())
 307                     &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
</pre>
<hr />
<pre>
 309                 else
 310                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 311             }
 312             break;
 313         }
 314 
 315         case ValueMul:
 316         case ArithMul: {
 317             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 318             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 319 
 320             if (left &amp;&amp; right) {
 321                 // FIXME: We&#39;re currently relying on prediction propagation and backwards propagation
 322                 // whenever we can, and only falling back on result flags if that fails. And the result
 323                 // flags logic doesn&#39;t know how to use backwards propagation. We should get rid of the
 324                 // prediction propagation logic and rely solely on the result type.
 325                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 326                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 327                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 328                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 329                     else if (m_graph.binaryArithShouldSpeculateAnyInt(node, m_pass))</span>
<span class="line-modified"> 330                         changed |= mergePrediction(SpecInt52Only);</span>
 331                     else
 332                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 333                 } else if (op == ValueMul &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 334                     changed |= mergePrediction(SpecBigInt);
 335                 else {
 336                     changed |= mergePrediction(SpecInt32Only);
 337                     if (node-&gt;mayHaveDoubleResult()
 338                         || (left &amp; SpecBytecodeDouble)
 339                         || (right &amp; SpecBytecodeDouble))
 340                         changed |= mergePrediction(SpecBytecodeDouble);
 341                     if ((op == ValueMul &amp;&amp; node-&gt;mayHaveBigIntResult())
 342                         || (left &amp; SpecBigInt)
 343                         || (right &amp; SpecBigInt))
 344                         changed |= mergePrediction(SpecBigInt);
 345                 }
 346             }
 347             break;
 348         }
 349 
 350         case ValueDiv:

 351         case ArithDiv:
 352         case ArithMod: {
 353             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 354             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 355 
 356             if (left &amp;&amp; right) {
 357                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 358                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 359                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 360                         changed |= mergePrediction(SpecInt32Only);
 361                     else
 362                         changed |= mergePrediction(SpecBytecodeDouble);
<span class="line-modified"> 363                 } else if (op == ValueDiv &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))</span>
 364                     changed |= mergePrediction(SpecBigInt);
 365                 else {
 366                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
<span class="line-modified"> 367                     if (op == ValueDiv &amp;&amp; (node-&gt;mayHaveBigIntResult()</span>
 368                         || (left &amp; SpecBigInt)
 369                         || (right &amp; SpecBigInt)))
 370                         changed |= mergePrediction(SpecBigInt);
 371                 }
 372             }
 373             break;
 374         }
 375 
 376         case ArithAbs: {
 377             SpeculatedType childPrediction = node-&gt;child1()-&gt;prediction();
 378             if (isInt32OrBooleanSpeculation(childPrediction)
 379                 &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 380                 changed |= mergePrediction(SpecInt32Only);
 381             else
 382                 changed |= mergePrediction(SpecBytecodeDouble);
 383             break;
 384         }
 385 
 386         case GetByVal:
 387         case AtomicsAdd:
</pre>
<hr />
<pre>
 410                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecInt32Only);
 411                 else
 412                     changed |= mergePrediction(SpecInt32Only);
 413                 break;
 414             case Array::Double:
 415                 if (arrayMode.isOutOfBounds())
 416                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecDoubleReal);
 417                 else if (node-&gt;getHeapPrediction() &amp; SpecNonIntAsDouble)
 418                     changed |= mergePrediction(SpecDoubleReal);
 419                 else
 420                     changed |= mergePrediction(SpecAnyIntAsDouble);
 421                 break;
 422             case Array::Float32Array:
 423             case Array::Float64Array:
 424                 changed |= mergePrediction(SpecFullDouble);
 425                 break;
 426             case Array::Uint32Array:
 427                 if (isInt32SpeculationForArithmetic(node-&gt;getHeapPrediction()) &amp;&amp; node-&gt;op() == GetByVal)
 428                     changed |= mergePrediction(SpecInt32Only);
 429                 else if (enableInt52())
<span class="line-modified"> 430                     changed |= mergePrediction(SpecAnyInt);</span>
 431                 else
 432                     changed |= mergePrediction(SpecInt32Only | SpecAnyIntAsDouble);
 433                 break;
 434             case Array::Int8Array:
 435             case Array::Uint8Array:
 436             case Array::Int16Array:
 437             case Array::Uint16Array:
 438             case Array::Int32Array:
 439                 changed |= mergePrediction(SpecInt32Only);
 440                 break;
 441             default:
 442                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 443                 break;
 444             }
 445             break;
 446         }
 447 
 448         case ToThis: {
 449             // ToThis in methods for primitive types should speculate primitive types in strict mode.
<span class="line-modified"> 450             ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode() ? StrictMode : NotStrictMode;</span>
<span class="line-modified"> 451             if (ecmaMode == StrictMode) {</span>
 452                 if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
 453                     changed |= mergePrediction(SpecBoolean);
 454                     break;
 455                 }
 456 
 457                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 458                     changed |= mergePrediction(SpecInt32Only);
 459                     break;
 460                 }
 461 
<span class="line-modified"> 462                 if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
<span class="line-modified"> 463                     changed |= mergePrediction(SpecAnyInt);</span>
 464                     break;
 465                 }
 466 
 467                 if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
 468                     changed |= mergePrediction(SpecBytecodeNumber);
 469                     break;
 470                 }
 471 
 472                 if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
 473                     changed |= mergePrediction(SpecSymbol);
 474                     break;
 475                 }
 476 
 477                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
 478                     changed |= mergePrediction(SpecBigInt);
 479                     break;
 480                 }
 481 
 482                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
 483                     changed |= mergePrediction(SpecStringIdent);
 484                     break;
 485                 }
 486 
 487                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 488                     changed |= mergePrediction(SpecString);
 489                     break;
 490                 }
 491             } else {
 492                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 493                     changed |= mergePrediction(SpecStringObject);
 494                     break;
 495                 }
 496             }
 497 
 498             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
<span class="line-modified"> 499             if (ecmaMode == StrictMode)</span>
 500                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 501             else if (prediction) {
 502                 if (prediction &amp; ~SpecObject) {
 503                     // Wrapper objects are created only in sloppy mode.
 504                     prediction &amp;= SpecObject;
 505                     prediction = mergeSpeculations(prediction, SpecObjectOther);
 506                 }
 507                 changed |= mergePrediction(prediction);
 508             }
 509             break;
 510         }
 511 
 512         case ToPrimitive: {
 513             SpeculatedType child = node-&gt;child1()-&gt;prediction();
 514             if (child)
 515                 changed |= mergePrediction(resultOfToPrimitive(child));
 516             break;
 517         }
 518 
 519         case NormalizeMapKey: {
</pre>
<hr />
<pre>
 550     {
 551         // Loop pre-headers created by OSR entrypoint creation may have NaN weight to indicate
 552         // that we actually don&#39;t know they weight. Assume that they execute once. This turns
 553         // out to be an OK assumption since the pre-header doesn&#39;t have any meaningful code.
 554         if (weight != weight)
 555             weight = 1;
 556 
 557         switch (node-&gt;op()) {
 558         case ValueAdd:
 559         case ValueSub:
 560         case ArithAdd:
 561         case ArithSub: {
 562             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 563             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 564 
 565             DoubleBallot ballot;
 566 
 567             if (isFullNumberSpeculation(left)
 568                 &amp;&amp; isFullNumberSpeculation(right)
 569                 &amp;&amp; !m_graph.addShouldSpeculateInt32(node, m_pass)
<span class="line-modified"> 570                 &amp;&amp; !m_graph.addShouldSpeculateAnyInt(node))</span>
 571                 ballot = VoteDouble;
 572             else
 573                 ballot = VoteValue;
 574 
 575             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 576             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 577             break;
 578         }
 579 
 580         case ValueMul:
 581         case ArithMul: {
 582             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 583             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 584 
 585             DoubleBallot ballot;
 586 
 587             if (isFullNumberSpeculation(left)
 588                 &amp;&amp; isFullNumberSpeculation(right)
 589                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass)
<span class="line-modified"> 590                 &amp;&amp; !m_graph.binaryArithShouldSpeculateAnyInt(node, m_pass))</span>
 591                 ballot = VoteDouble;
 592             else
 593                 ballot = VoteValue;
 594 
 595             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 596             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 597             break;
 598         }
 599 
 600         case ArithMin:
 601         case ArithMax:
 602         case ArithMod:
 603         case ValueDiv:

 604         case ArithDiv: {
 605             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 606             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 607 
 608             DoubleBallot ballot;
 609 
 610             if (isFullNumberSpeculation(left)
 611                 &amp;&amp; isFullNumberSpeculation(right)
 612                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 613                 ballot = VoteDouble;
 614             else
 615                 ballot = VoteValue;
 616 
 617             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 618             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 619             break;
 620         }
 621 
 622         case ArithAbs:
 623             DoubleBallot ballot;
</pre>
<hr />
<pre>
 625                 &amp;&amp; !m_graph.unaryArithShouldSpeculateInt32(node, m_pass))
 626                 ballot = VoteDouble;
 627             else
 628                 ballot = VoteValue;
 629 
 630             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 631             break;
 632 
 633         case ArithSqrt:
 634         case ArithUnary:
 635             if (node-&gt;child1()-&gt;shouldSpeculateNumber())
 636                 m_graph.voteNode(node-&gt;child1(), VoteDouble, weight);
 637             else
 638                 m_graph.voteNode(node-&gt;child1(), VoteValue, weight);
 639             break;
 640 
 641         case SetLocal: {
 642             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 643             if (isDoubleSpeculation(prediction))
 644                 node-&gt;variableAccessData()-&gt;vote(VoteDouble, weight);
<span class="line-modified"> 645             else if (!isFullNumberSpeculation(prediction)</span>
<span class="line-removed"> 646                 || isInt32Speculation(prediction) || isAnyIntSpeculation(prediction))</span>
 647                 node-&gt;variableAccessData()-&gt;vote(VoteValue, weight);
 648             break;
 649         }
 650 
 651         case PutByValDirect:
 652         case PutByVal:
 653         case PutByValAlias: {
 654             Edge child1 = m_graph.varArgChild(node, 0);
 655             Edge child2 = m_graph.varArgChild(node, 1);
 656             Edge child3 = m_graph.varArgChild(node, 2);
 657             m_graph.voteNode(child1, VoteValue, weight);
 658             m_graph.voteNode(child2, VoteValue, weight);
 659             switch (node-&gt;arrayMode().type()) {
 660             case Array::Double:
 661                 m_graph.voteNode(child3, VoteDouble, weight);
 662                 break;
 663             default:
 664                 m_graph.voteNode(child3, VoteValue, weight);
 665                 break;
 666             }
</pre>
<hr />
<pre>
 719             m_changed |= m_graph.m_argumentPositions[i].mergeArgumentPredictionAwareness();
 720     }
 721 
 722     // Sets any predictions that do not depends on other nodes.
 723     void processInvariants()
 724     {
 725         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 726             for (Node* node : *block) {
 727                 m_currentNode = node;
 728                 processInvariantsForNode();
 729             }
 730         }
 731     }
 732 
 733     void processInvariantsForNode()
 734     {
 735         switch (m_currentNode-&gt;op()) {
 736         case JSConstant: {
 737             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 738             if (type == SpecAnyIntAsDouble &amp;&amp; enableInt52())
<span class="line-modified"> 739                 type = SpecInt52Only;</span>
 740             setPrediction(type);
 741             break;
 742         }
 743         case DoubleConstant: {
 744             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 745             setPrediction(type);
 746             break;
 747         }
 748 
 749         case ArithBitNot:
 750         case ArithBitAnd:
 751         case ArithBitOr:
 752         case ArithBitXor:
 753         case BitRShift:
<span class="line-modified"> 754         case BitLShift:</span>
 755         case BitURShift:
 756         case ArithIMul:
 757         case ArithClz32: {
 758             setPrediction(SpecInt32Only);
 759             break;
 760         }
 761 
 762         case ArrayPop:
 763         case ArrayPush:
 764         case RegExpExec:
 765         case RegExpExecNonGlobalOrSticky:
 766         case RegExpTest:
 767         case RegExpMatchFast:
 768         case RegExpMatchFastGlobal:
 769         case StringReplace:
 770         case StringReplaceRegExp:
 771         case GetById:
 772         case GetByIdFlush:
 773         case GetByIdWithThis:
 774         case GetByIdDirect:
</pre>
<hr />
<pre>
 785         case Construct:
 786         case DirectConstruct:
 787         case CallVarargs:
 788         case CallEval:
 789         case TailCallVarargsInlinedCaller:
 790         case ConstructVarargs:
 791         case CallForwardVarargs:
 792         case ConstructForwardVarargs:
 793         case TailCallForwardVarargsInlinedCaller:
 794         case GetGlobalVar:
 795         case GetGlobalLexicalVariable:
 796         case GetClosureVar:
 797         case GetFromArguments:
 798         case LoadKeyFromMapBucket:
 799         case LoadValueFromMapBucket:
 800         case ToNumber:
 801         case ToObject:
 802         case ValueBitAnd:
 803         case ValueBitXor:
 804         case ValueBitOr:

 805         case CallObjectConstructor:
 806         case GetArgument:
 807         case CallDOMGetter:
 808         case GetDynamicVar:
 809         case GetPrototypeOf:
 810         case ExtractValueFromWeakMapGet:
 811         case DataViewGetInt:
 812         case DataViewGetFloat: {
 813             setPrediction(m_currentNode-&gt;getHeapPrediction());
 814             break;
 815         }
 816 
 817         case WeakMapGet:
 818         case ResolveScopeForHoistingFuncDeclInEval: {
 819             setPrediction(SpecBytecodeTop);
 820             break;
 821         }
 822 
 823         case GetGetterSetterByOffset:
 824         case GetExecutable: {
</pre>
<hr />
<pre>
1030             break;
1031         }
1032 
1033         case CreateDirectArguments: {
1034             setPrediction(SpecDirectArguments);
1035             break;
1036         }
1037 
1038         case CreateScopedArguments: {
1039             setPrediction(SpecScopedArguments);
1040             break;
1041         }
1042 
1043         case CreateClonedArguments: {
1044             setPrediction(SpecObjectOther);
1045             break;
1046         }
1047 
1048         case FiatInt52: {
1049             RELEASE_ASSERT(enableInt52());
<span class="line-modified">1050             setPrediction(SpecAnyInt);</span>
1051             break;
1052         }
1053 
1054         case GetScope:
1055             setPrediction(SpecObjectOther);
1056             break;
1057 
1058         case InByVal:
1059         case InById:
1060             setPrediction(SpecBoolean);
1061             break;
1062 
1063         case HasOwnProperty:
1064             setPrediction(SpecBoolean);
1065             break;
1066 
1067         case GetEnumerableLength: {
1068             setPrediction(SpecInt32Only);
1069             break;
1070         }
</pre>
<hr />
<pre>
1100         }
1101 
1102         case IdentityWithProfile: {
1103             setPrediction(m_currentNode-&gt;getForcedPrediction());
1104             break;
1105         }
1106 
1107         case ExtractCatchLocal: {
1108             setPrediction(m_currentNode-&gt;catchLocalPrediction());
1109             break;
1110         }
1111 
1112         case GetLocal:
1113         case SetLocal:
1114         case UInt32ToNumber:
1115         case ValueNegate:
1116         case ValueAdd:
1117         case ValueSub:
1118         case ValueMul:
1119         case ValueDiv:



1120         case ArithAdd:
1121         case ArithSub:
1122         case ArithNegate:
1123         case ArithMin:
1124         case ArithMax:
1125         case ArithMul:
1126         case ArithDiv:
1127         case ArithMod:
1128         case ArithAbs:
1129         case GetByVal:
1130         case ToThis:
1131         case ToPrimitive:
1132         case NormalizeMapKey:
1133         case AtomicsAdd:
1134         case AtomicsAnd:
1135         case AtomicsCompareExchange:
1136         case AtomicsExchange:
1137         case AtomicsLoad:
1138         case AtomicsOr:
1139         case AtomicsStore:
</pre>
<hr />
<pre>
1236         case TailCallVarargs:
1237         case TailCallForwardVarargs:
1238         case PutById:
1239         case PutByIdFlush:
1240         case PutByIdDirect:
1241         case PutByOffset:
1242         case MultiPutByOffset:
1243         case PutGetterById:
1244         case PutSetterById:
1245         case PutGetterSetterById:
1246         case PutGetterByVal:
1247         case PutSetterByVal:
1248         case DefineDataProperty:
1249         case DefineAccessorProperty:
1250         case DFG::Jump:
1251         case Branch:
1252         case Switch:
1253         case ProfileType:
1254         case ProfileControlFlow:
1255         case ForceOSRExit:
<span class="line-modified">1256         case SetArgument:</span>

1257         case SetFunctionName:
1258         case CheckStructure:
1259         case CheckCell:
1260         case CheckNotEmpty:
1261         case AssertNotEmpty:
1262         case CheckStringIdent:
1263         case CheckBadCell:
1264         case PutStructure:
1265         case Phantom:
1266         case Check:
1267         case CheckVarargs:
1268         case PutGlobalVariable:
1269         case CheckTraps:
1270         case LogShadowChickenPrologue:
1271         case LogShadowChickenTail:
1272         case Unreachable:
1273         case LoopHint:
1274         case NotifyWrite:
1275         case ConstantStoragePointer:
1276         case MovHint:
</pre>
</td>
<td>
<hr />
<pre>
 139         if (!isFullNumberOrBooleanSpeculation(value))
 140             result |= SpecDoublePureNaN;
 141         return result;
 142     }
 143 
 144     SpeculatedType speculatedDoubleTypeForPredictions(SpeculatedType left, SpeculatedType right)
 145     {
 146         return speculatedDoubleTypeForPrediction(mergeSpeculations(left, right));
 147     }
 148 
 149     void propagate(Node* node)
 150     {
 151         NodeType op = node-&gt;op();
 152 
 153         bool changed = false;
 154 
 155         switch (op) {
 156         case GetLocal: {
 157             VariableAccessData* variable = node-&gt;variableAccessData();
 158             SpeculatedType prediction = variable-&gt;prediction();
<span class="line-modified"> 159             if (!variable-&gt;couldRepresentInt52() &amp;&amp; (prediction &amp; SpecNonInt32AsInt52))</span>
<span class="line-modified"> 160                 prediction = (prediction | SpecAnyIntAsDouble) &amp; ~SpecNonInt32AsInt52;</span>
 161             if (prediction)
 162                 changed |= mergePrediction(prediction);
 163             break;
 164         }
 165 
 166         case SetLocal: {
 167             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 168             changed |= variableAccessData-&gt;predict(node-&gt;child1()-&gt;prediction());
 169             break;
 170         }
 171 
 172         case UInt32ToNumber: {
 173             if (node-&gt;canSpeculateInt32(m_pass))
 174                 changed |= mergePrediction(SpecInt32Only);
 175             else if (enableInt52())
<span class="line-modified"> 176                 changed |= mergePrediction(SpecInt52Any);</span>
 177             else
 178                 changed |= mergePrediction(SpecBytecodeNumber);
 179             break;
 180         }
 181 
<span class="line-added"> 182         case ValueBitLShift: {</span>
<span class="line-added"> 183             SpeculatedType left = node-&gt;child1()-&gt;prediction();</span>
<span class="line-added"> 184             SpeculatedType right = node-&gt;child2()-&gt;prediction();</span>
<span class="line-added"> 185 </span>
<span class="line-added"> 186             if (left &amp;&amp; right) {</span>
<span class="line-added"> 187                 if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))</span>
<span class="line-added"> 188                     changed |= mergePrediction(SpecBigInt);</span>
<span class="line-added"> 189                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left) &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))</span>
<span class="line-added"> 190                     changed |= mergePrediction(SpecInt32Only);</span>
<span class="line-added"> 191                 else</span>
<span class="line-added"> 192                     changed |= mergePrediction(node-&gt;getHeapPrediction());</span>
<span class="line-added"> 193             }</span>
<span class="line-added"> 194 </span>
<span class="line-added"> 195             break;</span>
<span class="line-added"> 196         }</span>
<span class="line-added"> 197 </span>
 198         case ValueAdd: {
 199             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 200             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 201 
 202             if (left &amp;&amp; right) {
 203                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 204                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 205                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 206                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 207                     else if (m_graph.addShouldSpeculateInt52(node))</span>
<span class="line-modified"> 208                         changed |= mergePrediction(SpecInt52Any);</span>
 209                     else
 210                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 211                 } else if (isStringOrStringObjectSpeculation(left) || isStringOrStringObjectSpeculation(right)) {
 212                     // left or right is definitely something other than a number.
 213                     changed |= mergePrediction(SpecString);
 214                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 215                     changed |= mergePrediction(SpecBigInt);
 216                 else {
 217                     changed |= mergePrediction(SpecInt32Only);
 218                     if (node-&gt;mayHaveDoubleResult())
 219                         changed |= mergePrediction(SpecBytecodeDouble);
 220                     if (node-&gt;mayHaveBigIntResult())
 221                         changed |= mergePrediction(SpecBigInt);
 222                     if (node-&gt;mayHaveNonNumericResult())
 223                         changed |= mergePrediction(SpecString);
 224                 }
 225             }
 226             break;
 227         }
 228 
 229         case ArithAdd: {
 230             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 231             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 232 
 233             if (left &amp;&amp; right) {
 234                 if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 235                     changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 236                 else if (m_graph.addShouldSpeculateInt52(node))</span>
<span class="line-modified"> 237                     changed |= mergePrediction(SpecInt52Any);</span>
 238                 else if (isFullNumberOrBooleanSpeculation(left) &amp;&amp; isFullNumberOrBooleanSpeculation(right))
 239                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 240                 else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 241                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 242                 else
 243                     changed |= mergePrediction(SpecInt32Only);
 244             }
 245             break;
 246         }
 247 
 248         case ArithSub: {
 249             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 250             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 251 
 252             if (left &amp;&amp; right) {
 253                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 254                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 255                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 256                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 257                     else if (m_graph.addShouldSpeculateInt52(node))</span>
<span class="line-modified"> 258                         changed |= mergePrediction(SpecInt52Any);</span>
 259                     else
 260                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 261                 } else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 262                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 263                 else
 264                     changed |= mergePrediction(SpecInt32Only);
 265             }
 266             break;
 267         }
 268 
 269         case ValueSub: {
 270             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 271             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 272 
 273             if (left &amp;&amp; right) {
 274                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 275                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 276                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 277                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 278                     else if (m_graph.addShouldSpeculateInt52(node))</span>
<span class="line-modified"> 279                         changed |= mergePrediction(SpecInt52Any);</span>
 280                     else
 281                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 282                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 283                     changed |= mergePrediction(SpecBigInt);
 284                 else {
 285                     changed |= mergePrediction(SpecInt32Only);
 286                     if (node-&gt;mayHaveDoubleResult())
 287                         changed |= mergePrediction(SpecBytecodeDouble);
 288                     if (node-&gt;mayHaveBigIntResult())
 289                         changed |= mergePrediction(SpecBigInt);
 290                 }
 291             }
 292 
 293             break;
 294         }
 295 
<span class="line-added"> 296         case ValuePow: {</span>
<span class="line-added"> 297             SpeculatedType left = node-&gt;child1()-&gt;prediction();</span>
<span class="line-added"> 298             SpeculatedType right = node-&gt;child2()-&gt;prediction();</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300             if (left &amp;&amp; right) {</span>
<span class="line-added"> 301                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateBigInt())</span>
<span class="line-added"> 302                     changed |= mergePrediction(SpecBigInt);</span>
<span class="line-added"> 303                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left)</span>
<span class="line-added"> 304                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))</span>
<span class="line-added"> 305                     changed |= mergePrediction(SpecBytecodeDouble);</span>
<span class="line-added"> 306                 else</span>
<span class="line-added"> 307                     changed |= mergePrediction(SpecBytecodeDouble | SpecBigInt);</span>
<span class="line-added"> 308             }</span>
<span class="line-added"> 309             break;</span>
<span class="line-added"> 310         }</span>
<span class="line-added"> 311 </span>
 312         case ValueNegate:
 313         case ArithNegate: {
 314             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 315             if (prediction) {
 316                 if (isInt32OrBooleanSpeculation(prediction) &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 317                     changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 318                 else if (m_graph.unaryArithShouldSpeculateInt52(node, m_pass))</span>
<span class="line-modified"> 319                     changed |= mergePrediction(SpecInt52Any);</span>
 320                 else if (isBytecodeNumberSpeculation(prediction))
 321                     changed |= mergePrediction(speculatedDoubleTypeForPrediction(node-&gt;child1()-&gt;prediction()));
 322                 else {
 323                     changed |= mergePrediction(SpecInt32Only);
 324                     if (node-&gt;op() == ValueNegate &amp;&amp; node-&gt;mayHaveBigIntResult())
 325                         changed |= mergePrediction(SpecBigInt);
 326                     if (node-&gt;mayHaveDoubleResult())
 327                         changed |= mergePrediction(SpecBytecodeDouble);
 328                 }
 329             }
 330             break;
 331         }
 332         case ArithMin:
 333         case ArithMax: {
 334             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 335             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 336 
 337             if (left &amp;&amp; right) {
 338                 if (Node::shouldSpeculateInt32OrBooleanForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())
 339                     &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
</pre>
<hr />
<pre>
 341                 else
 342                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 343             }
 344             break;
 345         }
 346 
 347         case ValueMul:
 348         case ArithMul: {
 349             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 350             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 351 
 352             if (left &amp;&amp; right) {
 353                 // FIXME: We&#39;re currently relying on prediction propagation and backwards propagation
 354                 // whenever we can, and only falling back on result flags if that fails. And the result
 355                 // flags logic doesn&#39;t know how to use backwards propagation. We should get rid of the
 356                 // prediction propagation logic and rely solely on the result type.
 357                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 358                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 359                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 360                         changed |= mergePrediction(SpecInt32Only);
<span class="line-modified"> 361                     else if (m_graph.binaryArithShouldSpeculateInt52(node, m_pass))</span>
<span class="line-modified"> 362                         changed |= mergePrediction(SpecInt52Any);</span>
 363                     else
 364                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 365                 } else if (op == ValueMul &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 366                     changed |= mergePrediction(SpecBigInt);
 367                 else {
 368                     changed |= mergePrediction(SpecInt32Only);
 369                     if (node-&gt;mayHaveDoubleResult()
 370                         || (left &amp; SpecBytecodeDouble)
 371                         || (right &amp; SpecBytecodeDouble))
 372                         changed |= mergePrediction(SpecBytecodeDouble);
 373                     if ((op == ValueMul &amp;&amp; node-&gt;mayHaveBigIntResult())
 374                         || (left &amp; SpecBigInt)
 375                         || (right &amp; SpecBigInt))
 376                         changed |= mergePrediction(SpecBigInt);
 377                 }
 378             }
 379             break;
 380         }
 381 
 382         case ValueDiv:
<span class="line-added"> 383         case ValueMod:</span>
 384         case ArithDiv:
 385         case ArithMod: {
 386             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 387             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 388 
 389             if (left &amp;&amp; right) {
 390                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 391                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 392                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 393                         changed |= mergePrediction(SpecInt32Only);
 394                     else
 395                         changed |= mergePrediction(SpecBytecodeDouble);
<span class="line-modified"> 396                 } else if ((op == ValueDiv || op == ValueMod) &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))</span>
 397                     changed |= mergePrediction(SpecBigInt);
 398                 else {
 399                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
<span class="line-modified"> 400                     if ((op == ValueDiv || op == ValueMod) &amp;&amp; (node-&gt;mayHaveBigIntResult()</span>
 401                         || (left &amp; SpecBigInt)
 402                         || (right &amp; SpecBigInt)))
 403                         changed |= mergePrediction(SpecBigInt);
 404                 }
 405             }
 406             break;
 407         }
 408 
 409         case ArithAbs: {
 410             SpeculatedType childPrediction = node-&gt;child1()-&gt;prediction();
 411             if (isInt32OrBooleanSpeculation(childPrediction)
 412                 &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 413                 changed |= mergePrediction(SpecInt32Only);
 414             else
 415                 changed |= mergePrediction(SpecBytecodeDouble);
 416             break;
 417         }
 418 
 419         case GetByVal:
 420         case AtomicsAdd:
</pre>
<hr />
<pre>
 443                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecInt32Only);
 444                 else
 445                     changed |= mergePrediction(SpecInt32Only);
 446                 break;
 447             case Array::Double:
 448                 if (arrayMode.isOutOfBounds())
 449                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecDoubleReal);
 450                 else if (node-&gt;getHeapPrediction() &amp; SpecNonIntAsDouble)
 451                     changed |= mergePrediction(SpecDoubleReal);
 452                 else
 453                     changed |= mergePrediction(SpecAnyIntAsDouble);
 454                 break;
 455             case Array::Float32Array:
 456             case Array::Float64Array:
 457                 changed |= mergePrediction(SpecFullDouble);
 458                 break;
 459             case Array::Uint32Array:
 460                 if (isInt32SpeculationForArithmetic(node-&gt;getHeapPrediction()) &amp;&amp; node-&gt;op() == GetByVal)
 461                     changed |= mergePrediction(SpecInt32Only);
 462                 else if (enableInt52())
<span class="line-modified"> 463                     changed |= mergePrediction(SpecInt52Any);</span>
 464                 else
 465                     changed |= mergePrediction(SpecInt32Only | SpecAnyIntAsDouble);
 466                 break;
 467             case Array::Int8Array:
 468             case Array::Uint8Array:
 469             case Array::Int16Array:
 470             case Array::Uint16Array:
 471             case Array::Int32Array:
 472                 changed |= mergePrediction(SpecInt32Only);
 473                 break;
 474             default:
 475                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 476                 break;
 477             }
 478             break;
 479         }
 480 
 481         case ToThis: {
 482             // ToThis in methods for primitive types should speculate primitive types in strict mode.
<span class="line-modified"> 483             bool isStrictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);</span>
<span class="line-modified"> 484             if (isStrictMode) {</span>
 485                 if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
 486                     changed |= mergePrediction(SpecBoolean);
 487                     break;
 488                 }
 489 
 490                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 491                     changed |= mergePrediction(SpecInt32Only);
 492                     break;
 493                 }
 494 
<span class="line-modified"> 495                 if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
<span class="line-modified"> 496                     changed |= mergePrediction(SpecInt52Any);</span>
 497                     break;
 498                 }
 499 
 500                 if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
 501                     changed |= mergePrediction(SpecBytecodeNumber);
 502                     break;
 503                 }
 504 
 505                 if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
 506                     changed |= mergePrediction(SpecSymbol);
 507                     break;
 508                 }
 509 
 510                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
 511                     changed |= mergePrediction(SpecBigInt);
 512                     break;
 513                 }
 514 
 515                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
 516                     changed |= mergePrediction(SpecStringIdent);
 517                     break;
 518                 }
 519 
 520                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 521                     changed |= mergePrediction(SpecString);
 522                     break;
 523                 }
 524             } else {
 525                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 526                     changed |= mergePrediction(SpecStringObject);
 527                     break;
 528                 }
 529             }
 530 
 531             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
<span class="line-modified"> 532             if (isStrictMode)</span>
 533                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 534             else if (prediction) {
 535                 if (prediction &amp; ~SpecObject) {
 536                     // Wrapper objects are created only in sloppy mode.
 537                     prediction &amp;= SpecObject;
 538                     prediction = mergeSpeculations(prediction, SpecObjectOther);
 539                 }
 540                 changed |= mergePrediction(prediction);
 541             }
 542             break;
 543         }
 544 
 545         case ToPrimitive: {
 546             SpeculatedType child = node-&gt;child1()-&gt;prediction();
 547             if (child)
 548                 changed |= mergePrediction(resultOfToPrimitive(child));
 549             break;
 550         }
 551 
 552         case NormalizeMapKey: {
</pre>
<hr />
<pre>
 583     {
 584         // Loop pre-headers created by OSR entrypoint creation may have NaN weight to indicate
 585         // that we actually don&#39;t know they weight. Assume that they execute once. This turns
 586         // out to be an OK assumption since the pre-header doesn&#39;t have any meaningful code.
 587         if (weight != weight)
 588             weight = 1;
 589 
 590         switch (node-&gt;op()) {
 591         case ValueAdd:
 592         case ValueSub:
 593         case ArithAdd:
 594         case ArithSub: {
 595             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 596             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 597 
 598             DoubleBallot ballot;
 599 
 600             if (isFullNumberSpeculation(left)
 601                 &amp;&amp; isFullNumberSpeculation(right)
 602                 &amp;&amp; !m_graph.addShouldSpeculateInt32(node, m_pass)
<span class="line-modified"> 603                 &amp;&amp; !m_graph.addShouldSpeculateInt52(node))</span>
 604                 ballot = VoteDouble;
 605             else
 606                 ballot = VoteValue;
 607 
 608             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 609             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 610             break;
 611         }
 612 
 613         case ValueMul:
 614         case ArithMul: {
 615             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 616             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 617 
 618             DoubleBallot ballot;
 619 
 620             if (isFullNumberSpeculation(left)
 621                 &amp;&amp; isFullNumberSpeculation(right)
 622                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass)
<span class="line-modified"> 623                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt52(node, m_pass))</span>
 624                 ballot = VoteDouble;
 625             else
 626                 ballot = VoteValue;
 627 
 628             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 629             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 630             break;
 631         }
 632 
 633         case ArithMin:
 634         case ArithMax:
 635         case ArithMod:
 636         case ValueDiv:
<span class="line-added"> 637         case ValueMod:</span>
 638         case ArithDiv: {
 639             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 640             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 641 
 642             DoubleBallot ballot;
 643 
 644             if (isFullNumberSpeculation(left)
 645                 &amp;&amp; isFullNumberSpeculation(right)
 646                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 647                 ballot = VoteDouble;
 648             else
 649                 ballot = VoteValue;
 650 
 651             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 652             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 653             break;
 654         }
 655 
 656         case ArithAbs:
 657             DoubleBallot ballot;
</pre>
<hr />
<pre>
 659                 &amp;&amp; !m_graph.unaryArithShouldSpeculateInt32(node, m_pass))
 660                 ballot = VoteDouble;
 661             else
 662                 ballot = VoteValue;
 663 
 664             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 665             break;
 666 
 667         case ArithSqrt:
 668         case ArithUnary:
 669             if (node-&gt;child1()-&gt;shouldSpeculateNumber())
 670                 m_graph.voteNode(node-&gt;child1(), VoteDouble, weight);
 671             else
 672                 m_graph.voteNode(node-&gt;child1(), VoteValue, weight);
 673             break;
 674 
 675         case SetLocal: {
 676             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 677             if (isDoubleSpeculation(prediction))
 678                 node-&gt;variableAccessData()-&gt;vote(VoteDouble, weight);
<span class="line-modified"> 679             else if (!isFullNumberSpeculation(prediction) || isInt32OrInt52Speculation(prediction))</span>

 680                 node-&gt;variableAccessData()-&gt;vote(VoteValue, weight);
 681             break;
 682         }
 683 
 684         case PutByValDirect:
 685         case PutByVal:
 686         case PutByValAlias: {
 687             Edge child1 = m_graph.varArgChild(node, 0);
 688             Edge child2 = m_graph.varArgChild(node, 1);
 689             Edge child3 = m_graph.varArgChild(node, 2);
 690             m_graph.voteNode(child1, VoteValue, weight);
 691             m_graph.voteNode(child2, VoteValue, weight);
 692             switch (node-&gt;arrayMode().type()) {
 693             case Array::Double:
 694                 m_graph.voteNode(child3, VoteDouble, weight);
 695                 break;
 696             default:
 697                 m_graph.voteNode(child3, VoteValue, weight);
 698                 break;
 699             }
</pre>
<hr />
<pre>
 752             m_changed |= m_graph.m_argumentPositions[i].mergeArgumentPredictionAwareness();
 753     }
 754 
 755     // Sets any predictions that do not depends on other nodes.
 756     void processInvariants()
 757     {
 758         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 759             for (Node* node : *block) {
 760                 m_currentNode = node;
 761                 processInvariantsForNode();
 762             }
 763         }
 764     }
 765 
 766     void processInvariantsForNode()
 767     {
 768         switch (m_currentNode-&gt;op()) {
 769         case JSConstant: {
 770             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 771             if (type == SpecAnyIntAsDouble &amp;&amp; enableInt52())
<span class="line-modified"> 772                 type = int52AwareSpeculationFromValue(m_currentNode-&gt;asJSValue());</span>
 773             setPrediction(type);
 774             break;
 775         }
 776         case DoubleConstant: {
 777             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 778             setPrediction(type);
 779             break;
 780         }
 781 
 782         case ArithBitNot:
 783         case ArithBitAnd:
 784         case ArithBitOr:
 785         case ArithBitXor:
 786         case BitRShift:
<span class="line-modified"> 787         case ArithBitLShift:</span>
 788         case BitURShift:
 789         case ArithIMul:
 790         case ArithClz32: {
 791             setPrediction(SpecInt32Only);
 792             break;
 793         }
 794 
 795         case ArrayPop:
 796         case ArrayPush:
 797         case RegExpExec:
 798         case RegExpExecNonGlobalOrSticky:
 799         case RegExpTest:
 800         case RegExpMatchFast:
 801         case RegExpMatchFastGlobal:
 802         case StringReplace:
 803         case StringReplaceRegExp:
 804         case GetById:
 805         case GetByIdFlush:
 806         case GetByIdWithThis:
 807         case GetByIdDirect:
</pre>
<hr />
<pre>
 818         case Construct:
 819         case DirectConstruct:
 820         case CallVarargs:
 821         case CallEval:
 822         case TailCallVarargsInlinedCaller:
 823         case ConstructVarargs:
 824         case CallForwardVarargs:
 825         case ConstructForwardVarargs:
 826         case TailCallForwardVarargsInlinedCaller:
 827         case GetGlobalVar:
 828         case GetGlobalLexicalVariable:
 829         case GetClosureVar:
 830         case GetFromArguments:
 831         case LoadKeyFromMapBucket:
 832         case LoadValueFromMapBucket:
 833         case ToNumber:
 834         case ToObject:
 835         case ValueBitAnd:
 836         case ValueBitXor:
 837         case ValueBitOr:
<span class="line-added"> 838         case ValueBitNot:</span>
 839         case CallObjectConstructor:
 840         case GetArgument:
 841         case CallDOMGetter:
 842         case GetDynamicVar:
 843         case GetPrototypeOf:
 844         case ExtractValueFromWeakMapGet:
 845         case DataViewGetInt:
 846         case DataViewGetFloat: {
 847             setPrediction(m_currentNode-&gt;getHeapPrediction());
 848             break;
 849         }
 850 
 851         case WeakMapGet:
 852         case ResolveScopeForHoistingFuncDeclInEval: {
 853             setPrediction(SpecBytecodeTop);
 854             break;
 855         }
 856 
 857         case GetGetterSetterByOffset:
 858         case GetExecutable: {
</pre>
<hr />
<pre>
1064             break;
1065         }
1066 
1067         case CreateDirectArguments: {
1068             setPrediction(SpecDirectArguments);
1069             break;
1070         }
1071 
1072         case CreateScopedArguments: {
1073             setPrediction(SpecScopedArguments);
1074             break;
1075         }
1076 
1077         case CreateClonedArguments: {
1078             setPrediction(SpecObjectOther);
1079             break;
1080         }
1081 
1082         case FiatInt52: {
1083             RELEASE_ASSERT(enableInt52());
<span class="line-modified">1084             setPrediction(SpecInt52Any);</span>
1085             break;
1086         }
1087 
1088         case GetScope:
1089             setPrediction(SpecObjectOther);
1090             break;
1091 
1092         case InByVal:
1093         case InById:
1094             setPrediction(SpecBoolean);
1095             break;
1096 
1097         case HasOwnProperty:
1098             setPrediction(SpecBoolean);
1099             break;
1100 
1101         case GetEnumerableLength: {
1102             setPrediction(SpecInt32Only);
1103             break;
1104         }
</pre>
<hr />
<pre>
1134         }
1135 
1136         case IdentityWithProfile: {
1137             setPrediction(m_currentNode-&gt;getForcedPrediction());
1138             break;
1139         }
1140 
1141         case ExtractCatchLocal: {
1142             setPrediction(m_currentNode-&gt;catchLocalPrediction());
1143             break;
1144         }
1145 
1146         case GetLocal:
1147         case SetLocal:
1148         case UInt32ToNumber:
1149         case ValueNegate:
1150         case ValueAdd:
1151         case ValueSub:
1152         case ValueMul:
1153         case ValueDiv:
<span class="line-added">1154         case ValueMod:</span>
<span class="line-added">1155         case ValuePow:</span>
<span class="line-added">1156         case ValueBitLShift:</span>
1157         case ArithAdd:
1158         case ArithSub:
1159         case ArithNegate:
1160         case ArithMin:
1161         case ArithMax:
1162         case ArithMul:
1163         case ArithDiv:
1164         case ArithMod:
1165         case ArithAbs:
1166         case GetByVal:
1167         case ToThis:
1168         case ToPrimitive:
1169         case NormalizeMapKey:
1170         case AtomicsAdd:
1171         case AtomicsAnd:
1172         case AtomicsCompareExchange:
1173         case AtomicsExchange:
1174         case AtomicsLoad:
1175         case AtomicsOr:
1176         case AtomicsStore:
</pre>
<hr />
<pre>
1273         case TailCallVarargs:
1274         case TailCallForwardVarargs:
1275         case PutById:
1276         case PutByIdFlush:
1277         case PutByIdDirect:
1278         case PutByOffset:
1279         case MultiPutByOffset:
1280         case PutGetterById:
1281         case PutSetterById:
1282         case PutGetterSetterById:
1283         case PutGetterByVal:
1284         case PutSetterByVal:
1285         case DefineDataProperty:
1286         case DefineAccessorProperty:
1287         case DFG::Jump:
1288         case Branch:
1289         case Switch:
1290         case ProfileType:
1291         case ProfileControlFlow:
1292         case ForceOSRExit:
<span class="line-modified">1293         case SetArgumentDefinitely:</span>
<span class="line-added">1294         case SetArgumentMaybe:</span>
1295         case SetFunctionName:
1296         case CheckStructure:
1297         case CheckCell:
1298         case CheckNotEmpty:
1299         case AssertNotEmpty:
1300         case CheckStringIdent:
1301         case CheckBadCell:
1302         case PutStructure:
1303         case Phantom:
1304         case Check:
1305         case CheckVarargs:
1306         case PutGlobalVariable:
1307         case CheckTraps:
1308         case LogShadowChickenPrologue:
1309         case LogShadowChickenTail:
1310         case Unreachable:
1311         case LoopHint:
1312         case NotifyWrite:
1313         case ConstantStoragePointer:
1314         case MovHint:
</pre>
</td>
</tr>
</table>
<center><a href="DFGPreciseLocalClobberize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPureValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>