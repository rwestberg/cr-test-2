<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LegacyCDMSession.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  88 #include &quot;MediaPlayerPrivateJava.h&quot;
  89 #define PlatformMediaEngineClassName MediaPlayerPrivate
  90 #endif  // PLATFORM(JAVA)
  91 
  92 #if USE(EXTERNAL_HOLEPUNCH)
  93 #include &quot;MediaPlayerPrivateHolePunch.h&quot;
  94 #endif
  95 
  96 namespace WebCore {
  97 
  98 #if !RELEASE_LOG_DISABLED
  99 static RefPtr&lt;Logger&gt;&amp; nullLogger()
 100 {
 101     static NeverDestroyed&lt;RefPtr&lt;Logger&gt;&gt; logger;
 102     return logger;
 103 }
 104 #endif
 105 
 106 // a null player to make MediaPlayer logic simpler
 107 
<span class="line-modified"> 108 class NullMediaPlayerPrivate : public MediaPlayerPrivateInterface {</span>
 109 public:
 110     explicit NullMediaPlayerPrivate(MediaPlayer*) { }
 111 
<span class="line-modified"> 112     void load(const String&amp;) override { }</span>
 113 #if ENABLE(MEDIA_SOURCE)
<span class="line-modified"> 114     void load(const String&amp;, MediaSourcePrivateClient*) override { }</span>
 115 #endif
 116 #if ENABLE(MEDIA_STREAM)
<span class="line-modified"> 117     void load(MediaStreamPrivate&amp;) override { }</span>
 118 #endif
<span class="line-modified"> 119     void cancelLoad() override { }</span>
 120 
<span class="line-modified"> 121     void prepareToPlay() override { }</span>
<span class="line-modified"> 122     void play() override { }</span>
<span class="line-modified"> 123     void pause() override { }</span>
 124 
<span class="line-modified"> 125     PlatformLayer* platformLayer() const override { return 0; }</span>
 126 
<span class="line-modified"> 127     FloatSize naturalSize() const override { return FloatSize(); }</span>
 128 
<span class="line-modified"> 129     bool hasVideo() const override { return false; }</span>
<span class="line-modified"> 130     bool hasAudio() const override { return false; }</span>
 131 
<span class="line-modified"> 132     void setVisible(bool) override { }</span>
 133 
<span class="line-modified"> 134     double durationDouble() const override { return 0; }</span>
 135 
<span class="line-modified"> 136     double currentTimeDouble() const override { return 0; }</span>
<span class="line-modified"> 137     void seekDouble(double) override { }</span>
<span class="line-modified"> 138     bool seeking() const override { return false; }</span>
 139 
<span class="line-modified"> 140     void setRateDouble(double) override { }</span>
<span class="line-modified"> 141     void setPreservesPitch(bool) override { }</span>
<span class="line-modified"> 142     bool paused() const override { return true; }</span>
 143 
<span class="line-modified"> 144     void setVolumeDouble(double) override { }</span>
 145 
<span class="line-modified"> 146     bool supportsMuting() const override { return false; }</span>
<span class="line-removed"> 147     void setMuted(bool) override { }</span>
 148 
<span class="line-modified"> 149     bool hasClosedCaptions() const override { return false; }</span>
<span class="line-modified"> 150     void setClosedCaptionsVisible(bool) override { };</span>
 151 
<span class="line-modified"> 152     MediaPlayer::NetworkState networkState() const override { return MediaPlayer::Empty; }</span>
<span class="line-modified"> 153     MediaPlayer::ReadyState readyState() const override { return MediaPlayer::HaveNothing; }</span>
 154 
<span class="line-modified"> 155     float maxTimeSeekable() const override { return 0; }</span>
<span class="line-modified"> 156     double minTimeSeekable() const override { return 0; }</span>
<span class="line-modified"> 157     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const override { return std::make_unique&lt;PlatformTimeRanges&gt;(); }</span>
 158 
<span class="line-modified"> 159     double seekableTimeRangesLastModifiedTime() const override { return 0; }</span>
<span class="line-modified"> 160     double liveUpdateInterval() const override { return 0; }</span>
 161 
<span class="line-modified"> 162     unsigned long long totalBytes() const override { return 0; }</span>
<span class="line-modified"> 163     bool didLoadingProgress() const override { return false; }</span>
 164 
<span class="line-modified"> 165     void setSize(const IntSize&amp;) override { }</span>
 166 
<span class="line-modified"> 167     void paint(GraphicsContext&amp;, const FloatRect&amp;) override { }</span>
 168 
<span class="line-modified"> 169     bool canLoadPoster() const override { return false; }</span>
<span class="line-modified"> 170     void setPoster(const String&amp;) override { }</span>
 171 
<span class="line-modified"> 172     bool hasSingleSecurityOrigin() const override { return true; }</span>
 173 };
 174 
 175 class NullMediaPlayerClient : public MediaPlayerClient {
 176 public:
 177 #if !RELEASE_LOG_DISABLED
 178     const Logger&amp; mediaPlayerLogger() final
 179     {
 180         if (!nullLogger().get()) {
 181             nullLogger() = Logger::create(this);
 182             nullLogger()-&gt;setEnabled(this, false);
 183         }
 184 
 185         return *nullLogger().get();
 186     }
 187 #endif
 188 };
 189 
 190 const Vector&lt;ContentType&gt;&amp; MediaPlayerClient::mediaContentTypesRequiringHardwareSupport() const
 191 {
 192     static NeverDestroyed&lt;Vector&lt;ContentType&gt;&gt; contentTypes;
</pre>
<hr />
<pre>
 275 {
 276     {
 277         auto locker = holdLock(mediaEngineVectorLock);
 278         if (!haveMediaEnginesVector())
 279             buildMediaEnginesVector();
 280     }
 281 
 282     return mutableInstalledMediaEnginesVector();
 283 }
 284 
 285 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp; constructor, MediaEngineSupportedTypes getSupportedTypes, MediaEngineSupportsType supportsType,
 286     MediaEngineOriginsInMediaCache originsInMediaCache, MediaEngineClearMediaCache clearMediaCache, MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins, MediaEngineSupportsKeySystem supportsKeySystem)
 287 {
 288     ASSERT(constructor);
 289     ASSERT(getSupportedTypes);
 290     ASSERT(supportsType);
 291 
 292     mutableInstalledMediaEnginesVector().append(MediaPlayerFactory { WTFMove(constructor), getSupportedTypes, supportsType, originsInMediaCache, clearMediaCache, clearMediaCacheForOrigins, supportsKeySystem });
 293 }
 294 
<span class="line-modified"> 295 static const AtomicString&amp; applicationOctetStream()</span>
 296 {
<span class="line-modified"> 297     static NeverDestroyed&lt;const AtomicString&gt; applicationOctetStream(&quot;application/octet-stream&quot;, AtomicString::ConstructFromLiteral);</span>
 298     return applicationOctetStream;
 299 }
 300 
<span class="line-modified"> 301 static const AtomicString&amp; textPlain()</span>
 302 {
<span class="line-modified"> 303     static NeverDestroyed&lt;const AtomicString&gt; textPlain(&quot;text/plain&quot;, AtomicString::ConstructFromLiteral);</span>
 304     return textPlain;
 305 }
 306 
 307 static const MediaPlayerFactory* bestMediaEngineForSupportParameters(const MediaEngineSupportParameters&amp; parameters, const MediaPlayerFactory* current = nullptr)
 308 {
 309     if (parameters.type.isEmpty() &amp;&amp; !parameters.isMediaSource &amp;&amp; !parameters.isMediaStream)
 310         return nullptr;
 311 
 312     // 4.8.10.3 MIME types - In the absence of a specification to the contrary, the MIME type &quot;application/octet-stream&quot;
 313     // when used with parameters, e.g. &quot;application/octet-stream;codecs=theora&quot;, is a type that the user agent knows
 314     // it cannot render.
 315     if (parameters.type.containerType() == applicationOctetStream()) {
 316         if (!parameters.type.codecs().isEmpty())
 317             return nullptr;
 318     }
 319 
 320     const MediaPlayerFactory* foundEngine = nullptr;
 321     MediaPlayer::SupportsType supported = MediaPlayer::IsNotSupported;
 322     for (auto&amp; engine : installedMediaEngines()) {
 323         if (current) {
</pre>
<hr />
<pre>
 344     if (!current)
 345         return &amp;engines.first();
 346 
 347     size_t currentIndex = current - &amp;engines.first();
 348     if (currentIndex + 1 &gt;= engines.size())
 349         return nullptr;
 350 
 351     return &amp;engines[currentIndex + 1];
 352 }
 353 
 354 // media player
 355 
 356 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client)
 357 {
 358     return adoptRef(*new MediaPlayer(client));
 359 }
 360 
 361 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client)
 362     : m_client(&amp;client)
 363     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
<span class="line-modified"> 364     , m_private(std::make_unique&lt;NullMediaPlayerPrivate&gt;(this))</span>
 365 {
 366 }
 367 
 368 MediaPlayer::~MediaPlayer()
 369 {
 370     ASSERT(!m_initializingMediaEngine);
 371 }
 372 
 373 void MediaPlayer::invalidate()
 374 {
 375     m_client = &amp;nullMediaPlayerClient();
 376 }
 377 
 378 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, const String&amp; keySystem)
 379 {
 380     ASSERT(!m_reloadTimer.isActive());
 381 
 382     // Protect against MediaPlayer being destroyed during a MediaPlayerClient callback.
 383     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 384 
 385     m_contentType = contentType;
 386     m_url = url;
 387     m_keySystem = keySystem.convertToASCIILowercase();
 388     m_contentMIMETypeWasInferredFromExtension = false;
 389 
 390 #if ENABLE(MEDIA_SOURCE)
 391     m_mediaSource = nullptr;
 392 #endif
 393 #if ENABLE(MEDIA_STREAM)
 394     m_mediaStream = nullptr;
 395 #endif
 396 
 397     // If the MIME type is missing or is not meaningful, try to figure it out from the URL.
<span class="line-modified"> 398     AtomicString containerType = m_contentType.containerType();</span>
 399     if (containerType.isEmpty() || containerType == applicationOctetStream() || containerType == textPlain()) {
 400         if (m_url.protocolIsData())
 401             m_contentType = ContentType(mimeTypeFromDataURL(m_url.string()));
 402         else {
 403             String lastPathComponent = url.lastPathComponent();
 404             size_t pos = lastPathComponent.reverseFind(&#39;.&#39;);
 405             if (pos != notFound) {
 406                 String extension = lastPathComponent.substring(pos + 1);
 407                 String mediaType = MIMETypeRegistry::getMediaMIMETypeForExtension(extension);
 408                 if (!mediaType.isEmpty()) {
 409                     m_contentType = ContentType { WTFMove(mediaType) };
 410                     m_contentMIMETypeWasInferredFromExtension = true;
 411                 }
 412             }
 413         }
 414     }
 415 
 416     loadWithNextMediaEngine(nullptr);
 417     return m_currentMediaEngine;
 418 }
</pre>
<hr />
<pre>
 500         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
 501         m_private-&gt;setPreload(m_preload);
 502         m_private-&gt;setPreservesPitch(preservesPitch());
 503         if (m_shouldPrepareToRender)
 504             m_private-&gt;prepareForRendering();
 505     }
 506 
 507     if (m_private) {
 508 #if ENABLE(MEDIA_SOURCE)
 509         if (m_mediaSource)
 510             m_private-&gt;load(m_url.string(), m_mediaSource.get());
 511         else
 512 #endif
 513 #if ENABLE(MEDIA_STREAM)
 514         if (m_mediaStream)
 515             m_private-&gt;load(*m_mediaStream);
 516         else
 517 #endif
 518         m_private-&gt;load(m_url.string());
 519     } else {
<span class="line-modified"> 520         m_private = std::make_unique&lt;NullMediaPlayerPrivate&gt;(this);</span>
 521         client().mediaPlayerEngineUpdated(this);
 522         client().mediaPlayerResourceNotSupported(this);
 523     }
 524 
 525     m_initializingMediaEngine = false;
 526 }
 527 
 528 bool MediaPlayer::hasAvailableVideoFrame() const
 529 {
 530     return m_private-&gt;hasAvailableVideoFrame();
 531 }
 532 
 533 void MediaPlayer::prepareForRendering()
 534 {
 535     m_shouldPrepareToRender = true;
 536     m_private-&gt;prepareForRendering();
 537 }
 538 
 539 bool MediaPlayer::canLoadPoster() const
 540 {
</pre>
<hr />
<pre>
 551     m_private-&gt;cancelLoad();
 552 }
 553 
 554 void MediaPlayer::prepareToPlay()
 555 {
 556     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 557 
 558     m_private-&gt;prepareToPlay();
 559 }
 560 
 561 void MediaPlayer::play()
 562 {
 563     m_private-&gt;play();
 564 }
 565 
 566 void MediaPlayer::pause()
 567 {
 568     m_private-&gt;pause();
 569 }
 570 
<span class="line-modified"> 571 void MediaPlayer::setShouldBufferData(bool shouldBuffer)</span>
 572 {
<span class="line-modified"> 573     m_private-&gt;setShouldBufferData(shouldBuffer);</span>
 574 }
 575 
 576 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 577 
 578 std::unique_ptr&lt;LegacyCDMSession&gt; MediaPlayer::createSession(const String&amp; keySystem, LegacyCDMSessionClient* client)
 579 {
 580     return m_private-&gt;createSession(keySystem, client);
 581 }
 582 
 583 void MediaPlayer::setCDMSession(LegacyCDMSession* session)
 584 {
 585     m_private-&gt;setCDMSession(session);
 586 }
 587 
 588 void MediaPlayer::keyAdded()
 589 {
 590     m_private-&gt;keyAdded();
 591 }
 592 
 593 #endif
</pre>
<hr />
<pre>
 765 #endif
 766 
 767 MediaPlayer::NetworkState MediaPlayer::networkState()
 768 {
 769     return m_private-&gt;networkState();
 770 }
 771 
 772 MediaPlayer::ReadyState MediaPlayer::readyState()
 773 {
 774     return m_private-&gt;readyState();
 775 }
 776 
 777 double MediaPlayer::volume() const
 778 {
 779     return m_volume;
 780 }
 781 
 782 void MediaPlayer::setVolume(double volume)
 783 {
 784     m_volume = volume;
<span class="line-modified"> 785 </span>
<span class="line-removed"> 786     if (m_private-&gt;supportsMuting() || !m_muted)</span>
<span class="line-removed"> 787         m_private-&gt;setVolumeDouble(volume);</span>
 788 }
 789 
 790 bool MediaPlayer::muted() const
 791 {
 792     return m_muted;
 793 }
 794 
 795 void MediaPlayer::setMuted(bool muted)
 796 {
 797     m_muted = muted;
 798 
<span class="line-modified"> 799     if (m_private-&gt;supportsMuting())</span>
<span class="line-removed"> 800         m_private-&gt;setMuted(muted);</span>
<span class="line-removed"> 801     else</span>
<span class="line-removed"> 802         m_private-&gt;setVolume(muted ? 0 : m_volume);</span>
 803 }
 804 
 805 bool MediaPlayer::hasClosedCaptions() const
 806 {
 807     return m_private-&gt;hasClosedCaptions();
 808 }
 809 
 810 void MediaPlayer::setClosedCaptionsVisible(bool closedCaptionsVisible)
 811 {
 812     m_private-&gt;setClosedCaptionsVisible(closedCaptionsVisible);
 813 }
 814 
 815 double MediaPlayer::rate() const
 816 {
 817     return m_private-&gt;rate();
 818 }
 819 
 820 void MediaPlayer::setRate(double rate)
 821 {
 822     m_private-&gt;setRateDouble(rate);
</pre>
<hr />
<pre>
 908 
 909 void MediaPlayer::paintCurrentFrameInContext(GraphicsContext&amp; p, const FloatRect&amp; r)
 910 {
 911     m_private-&gt;paintCurrentFrameInContext(p, r);
 912 }
 913 
 914 bool MediaPlayer::copyVideoTextureToPlatformTexture(GraphicsContext3D* context, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)
 915 {
 916     return m_private-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 917 }
 918 
 919 NativeImagePtr MediaPlayer::nativeImageForCurrentTime()
 920 {
 921     return m_private-&gt;nativeImageForCurrentTime();
 922 }
 923 
 924 MediaPlayer::SupportsType MediaPlayer::supportsType(const MediaEngineSupportParameters&amp; parameters)
 925 {
 926     // 4.8.10.3 MIME types - The canPlayType(type) method must return the empty string if type is a type that the
 927     // user agent knows it cannot render or is the type &quot;application/octet-stream&quot;
<span class="line-modified"> 928     AtomicString containerType = parameters.type.containerType();</span>
 929     if (containerType == applicationOctetStream())
 930         return IsNotSupported;
 931 
 932     const MediaPlayerFactory* engine = bestMediaEngineForSupportParameters(parameters);
 933     if (!engine)
 934         return IsNotSupported;
 935 
 936     return engine-&gt;supportsTypeAndCodecs(parameters);
 937 }
 938 
 939 void MediaPlayer::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
 940 {
 941     for (auto&amp; engine : installedMediaEngines()) {
 942         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; engineTypes;
 943         engine.getSupportedTypes(engineTypes);
 944         types.add(engineTypes.begin(), engineTypes.end());
 945     }
 946 }
 947 
 948 bool MediaPlayer::isAvailable()
</pre>
<hr />
<pre>
1486 void MediaPlayer::handlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command)
1487 {
1488     client().mediaPlayerHandlePlaybackCommand(command);
1489 }
1490 
1491 String MediaPlayer::sourceApplicationIdentifier() const
1492 {
1493     return client().mediaPlayerSourceApplicationIdentifier();
1494 }
1495 
1496 Vector&lt;String&gt; MediaPlayer::preferredAudioCharacteristics() const
1497 {
1498     return client().mediaPlayerPreferredAudioCharacteristics();
1499 }
1500 
1501 void MediaPlayerFactorySupport::callRegisterMediaEngine(MediaEngineRegister registerMediaEngine)
1502 {
1503     registerMediaEngine(addMediaEngine);
1504 }
1505 
<span class="line-modified">1506 bool MediaPlayer::doesHaveAttribute(const AtomicString&amp; attribute, AtomicString* value) const</span>
1507 {
1508     return client().doesHaveAttribute(attribute, value);
1509 }
1510 
1511 #if PLATFORM(IOS_FAMILY)
1512 String MediaPlayer::mediaPlayerNetworkInterfaceName() const
1513 {
1514     return client().mediaPlayerNetworkInterfaceName();
1515 }
1516 
1517 bool MediaPlayer::getRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
1518 {
1519     return client().mediaPlayerGetRawCookies(url, cookies);
1520 }
1521 #endif
1522 
1523 void MediaPlayer::setShouldDisableSleep(bool flag)
1524 {
1525     if (m_private)
1526         m_private-&gt;setShouldDisableSleep(flag);
</pre>
<hr />
<pre>
1628     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MetaData) == 1, &quot;MediaPlayerEnums::MetaData is not 1 as expected&quot;);
1629     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Auto) == 2, &quot;MediaPlayerEnums::Auto is not 2 as expected&quot;);
1630     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1631     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1632 }
1633 
1634 String convertEnumerationToString(MediaPlayerEnums::SupportsType enumerationValue)
1635 {
1636     static const NeverDestroyed&lt;String&gt; values[] = {
1637         MAKE_STATIC_STRING_IMPL(&quot;IsNotSupported&quot;),
1638         MAKE_STATIC_STRING_IMPL(&quot;IsSupported&quot;),
1639         MAKE_STATIC_STRING_IMPL(&quot;MayBeSupported&quot;),
1640     };
1641     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::IsNotSupported), &quot;MediaPlayerEnums::IsNotSupported is not 0 as expected&quot;);
1642     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::IsSupported) == 1, &quot;MediaPlayerEnums::IsSupported is not 1 as expected&quot;);
1643     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MayBeSupported) == 2, &quot;MediaPlayerEnums::MayBeSupported is not 2 as expected&quot;);
1644     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1645     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1646 }
1647 
















1648 }
1649 
1650 #endif
</pre>
</td>
<td>
<hr />
<pre>
  88 #include &quot;MediaPlayerPrivateJava.h&quot;
  89 #define PlatformMediaEngineClassName MediaPlayerPrivate
  90 #endif  // PLATFORM(JAVA)
  91 
  92 #if USE(EXTERNAL_HOLEPUNCH)
  93 #include &quot;MediaPlayerPrivateHolePunch.h&quot;
  94 #endif
  95 
  96 namespace WebCore {
  97 
  98 #if !RELEASE_LOG_DISABLED
  99 static RefPtr&lt;Logger&gt;&amp; nullLogger()
 100 {
 101     static NeverDestroyed&lt;RefPtr&lt;Logger&gt;&gt; logger;
 102     return logger;
 103 }
 104 #endif
 105 
 106 // a null player to make MediaPlayer logic simpler
 107 
<span class="line-modified"> 108 class NullMediaPlayerPrivate final : public MediaPlayerPrivateInterface {</span>
 109 public:
 110     explicit NullMediaPlayerPrivate(MediaPlayer*) { }
 111 
<span class="line-modified"> 112     void load(const String&amp;) final { }</span>
 113 #if ENABLE(MEDIA_SOURCE)
<span class="line-modified"> 114     void load(const String&amp;, MediaSourcePrivateClient*) final { }</span>
 115 #endif
 116 #if ENABLE(MEDIA_STREAM)
<span class="line-modified"> 117     void load(MediaStreamPrivate&amp;) final { }</span>
 118 #endif
<span class="line-modified"> 119     void cancelLoad() final { }</span>
 120 
<span class="line-modified"> 121     void prepareToPlay() final { }</span>
<span class="line-modified"> 122     void play() final { }</span>
<span class="line-modified"> 123     void pause() final { }</span>
 124 
<span class="line-modified"> 125     PlatformLayer* platformLayer() const final { return 0; }</span>
 126 
<span class="line-modified"> 127     FloatSize naturalSize() const final { return FloatSize(); }</span>
 128 
<span class="line-modified"> 129     bool hasVideo() const final { return false; }</span>
<span class="line-modified"> 130     bool hasAudio() const final { return false; }</span>
 131 
<span class="line-modified"> 132     void setVisible(bool) final { }</span>
 133 
<span class="line-modified"> 134     double durationDouble() const final { return 0; }</span>
 135 
<span class="line-modified"> 136     double currentTimeDouble() const final { return 0; }</span>
<span class="line-modified"> 137     void seekDouble(double) final { }</span>
<span class="line-modified"> 138     bool seeking() const final { return false; }</span>
 139 
<span class="line-modified"> 140     void setRateDouble(double) final { }</span>
<span class="line-modified"> 141     void setPreservesPitch(bool) final { }</span>
<span class="line-modified"> 142     bool paused() const final { return true; }</span>
 143 
<span class="line-modified"> 144     void setVolumeDouble(double) final { }</span>
 145 
<span class="line-modified"> 146     void setMuted(bool) final { }</span>

 147 
<span class="line-modified"> 148     bool hasClosedCaptions() const final { return false; }</span>
<span class="line-modified"> 149     void setClosedCaptionsVisible(bool) final { };</span>
 150 
<span class="line-modified"> 151     MediaPlayer::NetworkState networkState() const final { return MediaPlayer::Empty; }</span>
<span class="line-modified"> 152     MediaPlayer::ReadyState readyState() const final { return MediaPlayer::HaveNothing; }</span>
 153 
<span class="line-modified"> 154     float maxTimeSeekable() const final { return 0; }</span>
<span class="line-modified"> 155     double minTimeSeekable() const final { return 0; }</span>
<span class="line-modified"> 156     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const final { return makeUnique&lt;PlatformTimeRanges&gt;(); }</span>
 157 
<span class="line-modified"> 158     double seekableTimeRangesLastModifiedTime() const final { return 0; }</span>
<span class="line-modified"> 159     double liveUpdateInterval() const final { return 0; }</span>
 160 
<span class="line-modified"> 161     unsigned long long totalBytes() const final { return 0; }</span>
<span class="line-modified"> 162     bool didLoadingProgress() const final { return false; }</span>
 163 
<span class="line-modified"> 164     void setSize(const IntSize&amp;) final { }</span>
 165 
<span class="line-modified"> 166     void paint(GraphicsContext&amp;, const FloatRect&amp;) final { }</span>
 167 
<span class="line-modified"> 168     bool canLoadPoster() const final { return false; }</span>
<span class="line-modified"> 169     void setPoster(const String&amp;) final { }</span>
 170 
<span class="line-modified"> 171     bool hasSingleSecurityOrigin() const final { return true; }</span>
 172 };
 173 
 174 class NullMediaPlayerClient : public MediaPlayerClient {
 175 public:
 176 #if !RELEASE_LOG_DISABLED
 177     const Logger&amp; mediaPlayerLogger() final
 178     {
 179         if (!nullLogger().get()) {
 180             nullLogger() = Logger::create(this);
 181             nullLogger()-&gt;setEnabled(this, false);
 182         }
 183 
 184         return *nullLogger().get();
 185     }
 186 #endif
 187 };
 188 
 189 const Vector&lt;ContentType&gt;&amp; MediaPlayerClient::mediaContentTypesRequiringHardwareSupport() const
 190 {
 191     static NeverDestroyed&lt;Vector&lt;ContentType&gt;&gt; contentTypes;
</pre>
<hr />
<pre>
 274 {
 275     {
 276         auto locker = holdLock(mediaEngineVectorLock);
 277         if (!haveMediaEnginesVector())
 278             buildMediaEnginesVector();
 279     }
 280 
 281     return mutableInstalledMediaEnginesVector();
 282 }
 283 
 284 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp; constructor, MediaEngineSupportedTypes getSupportedTypes, MediaEngineSupportsType supportsType,
 285     MediaEngineOriginsInMediaCache originsInMediaCache, MediaEngineClearMediaCache clearMediaCache, MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins, MediaEngineSupportsKeySystem supportsKeySystem)
 286 {
 287     ASSERT(constructor);
 288     ASSERT(getSupportedTypes);
 289     ASSERT(supportsType);
 290 
 291     mutableInstalledMediaEnginesVector().append(MediaPlayerFactory { WTFMove(constructor), getSupportedTypes, supportsType, originsInMediaCache, clearMediaCache, clearMediaCacheForOrigins, supportsKeySystem });
 292 }
 293 
<span class="line-modified"> 294 static const AtomString&amp; applicationOctetStream()</span>
 295 {
<span class="line-modified"> 296     static NeverDestroyed&lt;const AtomString&gt; applicationOctetStream(&quot;application/octet-stream&quot;, AtomString::ConstructFromLiteral);</span>
 297     return applicationOctetStream;
 298 }
 299 
<span class="line-modified"> 300 static const AtomString&amp; textPlain()</span>
 301 {
<span class="line-modified"> 302     static NeverDestroyed&lt;const AtomString&gt; textPlain(&quot;text/plain&quot;, AtomString::ConstructFromLiteral);</span>
 303     return textPlain;
 304 }
 305 
 306 static const MediaPlayerFactory* bestMediaEngineForSupportParameters(const MediaEngineSupportParameters&amp; parameters, const MediaPlayerFactory* current = nullptr)
 307 {
 308     if (parameters.type.isEmpty() &amp;&amp; !parameters.isMediaSource &amp;&amp; !parameters.isMediaStream)
 309         return nullptr;
 310 
 311     // 4.8.10.3 MIME types - In the absence of a specification to the contrary, the MIME type &quot;application/octet-stream&quot;
 312     // when used with parameters, e.g. &quot;application/octet-stream;codecs=theora&quot;, is a type that the user agent knows
 313     // it cannot render.
 314     if (parameters.type.containerType() == applicationOctetStream()) {
 315         if (!parameters.type.codecs().isEmpty())
 316             return nullptr;
 317     }
 318 
 319     const MediaPlayerFactory* foundEngine = nullptr;
 320     MediaPlayer::SupportsType supported = MediaPlayer::IsNotSupported;
 321     for (auto&amp; engine : installedMediaEngines()) {
 322         if (current) {
</pre>
<hr />
<pre>
 343     if (!current)
 344         return &amp;engines.first();
 345 
 346     size_t currentIndex = current - &amp;engines.first();
 347     if (currentIndex + 1 &gt;= engines.size())
 348         return nullptr;
 349 
 350     return &amp;engines[currentIndex + 1];
 351 }
 352 
 353 // media player
 354 
 355 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client)
 356 {
 357     return adoptRef(*new MediaPlayer(client));
 358 }
 359 
 360 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client)
 361     : m_client(&amp;client)
 362     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
<span class="line-modified"> 363     , m_private(makeUnique&lt;NullMediaPlayerPrivate&gt;(this))</span>
 364 {
 365 }
 366 
 367 MediaPlayer::~MediaPlayer()
 368 {
 369     ASSERT(!m_initializingMediaEngine);
 370 }
 371 
 372 void MediaPlayer::invalidate()
 373 {
 374     m_client = &amp;nullMediaPlayerClient();
 375 }
 376 
 377 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, const String&amp; keySystem)
 378 {
 379     ASSERT(!m_reloadTimer.isActive());
 380 
 381     // Protect against MediaPlayer being destroyed during a MediaPlayerClient callback.
 382     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 383 
 384     m_contentType = contentType;
 385     m_url = url;
 386     m_keySystem = keySystem.convertToASCIILowercase();
 387     m_contentMIMETypeWasInferredFromExtension = false;
 388 
 389 #if ENABLE(MEDIA_SOURCE)
 390     m_mediaSource = nullptr;
 391 #endif
 392 #if ENABLE(MEDIA_STREAM)
 393     m_mediaStream = nullptr;
 394 #endif
 395 
 396     // If the MIME type is missing or is not meaningful, try to figure it out from the URL.
<span class="line-modified"> 397     AtomString containerType = m_contentType.containerType();</span>
 398     if (containerType.isEmpty() || containerType == applicationOctetStream() || containerType == textPlain()) {
 399         if (m_url.protocolIsData())
 400             m_contentType = ContentType(mimeTypeFromDataURL(m_url.string()));
 401         else {
 402             String lastPathComponent = url.lastPathComponent();
 403             size_t pos = lastPathComponent.reverseFind(&#39;.&#39;);
 404             if (pos != notFound) {
 405                 String extension = lastPathComponent.substring(pos + 1);
 406                 String mediaType = MIMETypeRegistry::getMediaMIMETypeForExtension(extension);
 407                 if (!mediaType.isEmpty()) {
 408                     m_contentType = ContentType { WTFMove(mediaType) };
 409                     m_contentMIMETypeWasInferredFromExtension = true;
 410                 }
 411             }
 412         }
 413     }
 414 
 415     loadWithNextMediaEngine(nullptr);
 416     return m_currentMediaEngine;
 417 }
</pre>
<hr />
<pre>
 499         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
 500         m_private-&gt;setPreload(m_preload);
 501         m_private-&gt;setPreservesPitch(preservesPitch());
 502         if (m_shouldPrepareToRender)
 503             m_private-&gt;prepareForRendering();
 504     }
 505 
 506     if (m_private) {
 507 #if ENABLE(MEDIA_SOURCE)
 508         if (m_mediaSource)
 509             m_private-&gt;load(m_url.string(), m_mediaSource.get());
 510         else
 511 #endif
 512 #if ENABLE(MEDIA_STREAM)
 513         if (m_mediaStream)
 514             m_private-&gt;load(*m_mediaStream);
 515         else
 516 #endif
 517         m_private-&gt;load(m_url.string());
 518     } else {
<span class="line-modified"> 519         m_private = makeUnique&lt;NullMediaPlayerPrivate&gt;(this);</span>
 520         client().mediaPlayerEngineUpdated(this);
 521         client().mediaPlayerResourceNotSupported(this);
 522     }
 523 
 524     m_initializingMediaEngine = false;
 525 }
 526 
 527 bool MediaPlayer::hasAvailableVideoFrame() const
 528 {
 529     return m_private-&gt;hasAvailableVideoFrame();
 530 }
 531 
 532 void MediaPlayer::prepareForRendering()
 533 {
 534     m_shouldPrepareToRender = true;
 535     m_private-&gt;prepareForRendering();
 536 }
 537 
 538 bool MediaPlayer::canLoadPoster() const
 539 {
</pre>
<hr />
<pre>
 550     m_private-&gt;cancelLoad();
 551 }
 552 
 553 void MediaPlayer::prepareToPlay()
 554 {
 555     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 556 
 557     m_private-&gt;prepareToPlay();
 558 }
 559 
 560 void MediaPlayer::play()
 561 {
 562     m_private-&gt;play();
 563 }
 564 
 565 void MediaPlayer::pause()
 566 {
 567     m_private-&gt;pause();
 568 }
 569 
<span class="line-modified"> 570 void MediaPlayer::setBufferingPolicy(BufferingPolicy policy)</span>
 571 {
<span class="line-modified"> 572     m_private-&gt;setBufferingPolicy(policy);</span>
 573 }
 574 
 575 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 576 
 577 std::unique_ptr&lt;LegacyCDMSession&gt; MediaPlayer::createSession(const String&amp; keySystem, LegacyCDMSessionClient* client)
 578 {
 579     return m_private-&gt;createSession(keySystem, client);
 580 }
 581 
 582 void MediaPlayer::setCDMSession(LegacyCDMSession* session)
 583 {
 584     m_private-&gt;setCDMSession(session);
 585 }
 586 
 587 void MediaPlayer::keyAdded()
 588 {
 589     m_private-&gt;keyAdded();
 590 }
 591 
 592 #endif
</pre>
<hr />
<pre>
 764 #endif
 765 
 766 MediaPlayer::NetworkState MediaPlayer::networkState()
 767 {
 768     return m_private-&gt;networkState();
 769 }
 770 
 771 MediaPlayer::ReadyState MediaPlayer::readyState()
 772 {
 773     return m_private-&gt;readyState();
 774 }
 775 
 776 double MediaPlayer::volume() const
 777 {
 778     return m_volume;
 779 }
 780 
 781 void MediaPlayer::setVolume(double volume)
 782 {
 783     m_volume = volume;
<span class="line-modified"> 784     m_private-&gt;setVolumeDouble(volume);</span>


 785 }
 786 
 787 bool MediaPlayer::muted() const
 788 {
 789     return m_muted;
 790 }
 791 
 792 void MediaPlayer::setMuted(bool muted)
 793 {
 794     m_muted = muted;
 795 
<span class="line-modified"> 796     m_private-&gt;setMuted(muted);</span>



 797 }
 798 
 799 bool MediaPlayer::hasClosedCaptions() const
 800 {
 801     return m_private-&gt;hasClosedCaptions();
 802 }
 803 
 804 void MediaPlayer::setClosedCaptionsVisible(bool closedCaptionsVisible)
 805 {
 806     m_private-&gt;setClosedCaptionsVisible(closedCaptionsVisible);
 807 }
 808 
 809 double MediaPlayer::rate() const
 810 {
 811     return m_private-&gt;rate();
 812 }
 813 
 814 void MediaPlayer::setRate(double rate)
 815 {
 816     m_private-&gt;setRateDouble(rate);
</pre>
<hr />
<pre>
 902 
 903 void MediaPlayer::paintCurrentFrameInContext(GraphicsContext&amp; p, const FloatRect&amp; r)
 904 {
 905     m_private-&gt;paintCurrentFrameInContext(p, r);
 906 }
 907 
 908 bool MediaPlayer::copyVideoTextureToPlatformTexture(GraphicsContext3D* context, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)
 909 {
 910     return m_private-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 911 }
 912 
 913 NativeImagePtr MediaPlayer::nativeImageForCurrentTime()
 914 {
 915     return m_private-&gt;nativeImageForCurrentTime();
 916 }
 917 
 918 MediaPlayer::SupportsType MediaPlayer::supportsType(const MediaEngineSupportParameters&amp; parameters)
 919 {
 920     // 4.8.10.3 MIME types - The canPlayType(type) method must return the empty string if type is a type that the
 921     // user agent knows it cannot render or is the type &quot;application/octet-stream&quot;
<span class="line-modified"> 922     AtomString containerType = parameters.type.containerType();</span>
 923     if (containerType == applicationOctetStream())
 924         return IsNotSupported;
 925 
 926     const MediaPlayerFactory* engine = bestMediaEngineForSupportParameters(parameters);
 927     if (!engine)
 928         return IsNotSupported;
 929 
 930     return engine-&gt;supportsTypeAndCodecs(parameters);
 931 }
 932 
 933 void MediaPlayer::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
 934 {
 935     for (auto&amp; engine : installedMediaEngines()) {
 936         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; engineTypes;
 937         engine.getSupportedTypes(engineTypes);
 938         types.add(engineTypes.begin(), engineTypes.end());
 939     }
 940 }
 941 
 942 bool MediaPlayer::isAvailable()
</pre>
<hr />
<pre>
1480 void MediaPlayer::handlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command)
1481 {
1482     client().mediaPlayerHandlePlaybackCommand(command);
1483 }
1484 
1485 String MediaPlayer::sourceApplicationIdentifier() const
1486 {
1487     return client().mediaPlayerSourceApplicationIdentifier();
1488 }
1489 
1490 Vector&lt;String&gt; MediaPlayer::preferredAudioCharacteristics() const
1491 {
1492     return client().mediaPlayerPreferredAudioCharacteristics();
1493 }
1494 
1495 void MediaPlayerFactorySupport::callRegisterMediaEngine(MediaEngineRegister registerMediaEngine)
1496 {
1497     registerMediaEngine(addMediaEngine);
1498 }
1499 
<span class="line-modified">1500 bool MediaPlayer::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const</span>
1501 {
1502     return client().doesHaveAttribute(attribute, value);
1503 }
1504 
1505 #if PLATFORM(IOS_FAMILY)
1506 String MediaPlayer::mediaPlayerNetworkInterfaceName() const
1507 {
1508     return client().mediaPlayerNetworkInterfaceName();
1509 }
1510 
1511 bool MediaPlayer::getRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
1512 {
1513     return client().mediaPlayerGetRawCookies(url, cookies);
1514 }
1515 #endif
1516 
1517 void MediaPlayer::setShouldDisableSleep(bool flag)
1518 {
1519     if (m_private)
1520         m_private-&gt;setShouldDisableSleep(flag);
</pre>
<hr />
<pre>
1622     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MetaData) == 1, &quot;MediaPlayerEnums::MetaData is not 1 as expected&quot;);
1623     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Auto) == 2, &quot;MediaPlayerEnums::Auto is not 2 as expected&quot;);
1624     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1625     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1626 }
1627 
1628 String convertEnumerationToString(MediaPlayerEnums::SupportsType enumerationValue)
1629 {
1630     static const NeverDestroyed&lt;String&gt; values[] = {
1631         MAKE_STATIC_STRING_IMPL(&quot;IsNotSupported&quot;),
1632         MAKE_STATIC_STRING_IMPL(&quot;IsSupported&quot;),
1633         MAKE_STATIC_STRING_IMPL(&quot;MayBeSupported&quot;),
1634     };
1635     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::IsNotSupported), &quot;MediaPlayerEnums::IsNotSupported is not 0 as expected&quot;);
1636     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::IsSupported) == 1, &quot;MediaPlayerEnums::IsSupported is not 1 as expected&quot;);
1637     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MayBeSupported) == 2, &quot;MediaPlayerEnums::MayBeSupported is not 2 as expected&quot;);
1638     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1639     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1640 }
1641 
<span class="line-added">1642 String convertEnumerationToString(MediaPlayerEnums::BufferingPolicy enumerationValue)</span>
<span class="line-added">1643 {</span>
<span class="line-added">1644     static const NeverDestroyed&lt;String&gt; values[] = {</span>
<span class="line-added">1645         MAKE_STATIC_STRING_IMPL(&quot;Default&quot;),</span>
<span class="line-added">1646         MAKE_STATIC_STRING_IMPL(&quot;LimitReadAhead&quot;),</span>
<span class="line-added">1647         MAKE_STATIC_STRING_IMPL(&quot;MakeResourcesPurgeable&quot;),</span>
<span class="line-added">1648         MAKE_STATIC_STRING_IMPL(&quot;PurgeResources&quot;),</span>
<span class="line-added">1649     };</span>
<span class="line-added">1650     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::Default), &quot;MediaPlayerEnums::Default is not 0 as expected&quot;);</span>
<span class="line-added">1651     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::LimitReadAhead) == 1, &quot;MediaPlayerEnums::LimitReadAhead is not 1 as expected&quot;);</span>
<span class="line-added">1652     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::MakeResourcesPurgeable) == 2, &quot;MediaPlayerEnums::MakeResourcesPurgeable is not 2 as expected&quot;);</span>
<span class="line-added">1653     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::PurgeResources) == 3, &quot;MediaPlayerEnums::PurgeResources is not 3 as expected&quot;);</span>
<span class="line-added">1654     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));</span>
<span class="line-added">1655     return values[static_cast&lt;size_t&gt;(enumerationValue)];</span>
<span class="line-added">1656 }</span>
<span class="line-added">1657 </span>
1658 }
1659 
1660 #endif
</pre>
</td>
</tr>
</table>
<center><a href="LegacyCDMSession.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>