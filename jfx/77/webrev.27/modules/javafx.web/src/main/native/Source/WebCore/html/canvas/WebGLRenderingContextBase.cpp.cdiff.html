<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 96,29 ***</span>
  #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  #include &lt;JavaScriptCore/Uint32Array.h&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
  #include &lt;wtf/HexNumber.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/UniqueArray.h&gt;
  #include &lt;wtf/text/CString.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  static const Seconds secondsBetweenRestoreAttempts { 1_s };
  const int maxGLErrorsAllowedToConsole = 256;
  static const Seconds checkContextLossHandlingDelay { 3_s };
  
  namespace {
  
<span class="line-removed">-     Platform3DObject objectOrZero(WebGLObject* object)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return object ? object-&gt;object() : 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)
      {
          if (value &lt; min)
              value = min;
          if (value &gt; max)
<span class="line-new-header">--- 96,29 ---</span>
  #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  #include &lt;JavaScriptCore/Uint32Array.h&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-added">+ #include &lt;wtf/HashMap.h&gt;</span>
  #include &lt;wtf/HexNumber.h&gt;
<span class="line-added">+ #include &lt;wtf/IsoMallocInlines.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/Lock.h&gt;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/UniqueArray.h&gt;
  #include &lt;wtf/text/CString.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
<span class="line-added">+ WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);</span>
<span class="line-added">+ </span>
  static const Seconds secondsBetweenRestoreAttempts { 1_s };
  const int maxGLErrorsAllowedToConsole = 256;
  static const Seconds checkContextLossHandlingDelay { 3_s };
  
  namespace {
  
      GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)
      {
          if (value &lt; min)
              value = min;
          if (value &gt; max)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 560,13 ***</span>
                  LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
                  isPendingPolicyResolution = true;
              }
          }
  
<span class="line-removed">-         if (frame-&gt;settings().forceSoftwareWebGLRendering())</span>
<span class="line-removed">-             attributes.forceSoftwareRenderer = true;</span>
<span class="line-removed">- </span>
          if (frame-&gt;settings().forceWebGLUsesLowPower()) {
              if (attributes.powerPreference == GraphicsContext3DPowerPreference::HighPerformance)
                  LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
              attributes.powerPreference = GraphicsContext3DPowerPreference::LowPower;
          }
<span class="line-new-header">--- 560,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 657,11 ***</span>
      , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
  {
      m_contextGroup = WebGLContextGroup::create();
      m_contextGroup-&gt;addContext(*this);
  
<span class="line-modified">!     m_context-&gt;setWebGLContext(this);</span>
  
      m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);
  
      setupFlags();
      initializeNewContext();
<span class="line-new-header">--- 654,11 ---</span>
      , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
  {
      m_contextGroup = WebGLContextGroup::create();
      m_contextGroup-&gt;addContext(*this);
  
<span class="line-modified">!     m_context-&gt;addClient(*this);</span>
  
      m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);
  
      setupFlags();
      initializeNewContext();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 677,18 ***</span>
      if (is&lt;OffscreenCanvas&gt;(base))
          return &amp;downcast&lt;OffscreenCanvas&gt;(base);
      return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
  }
  
<span class="line-removed">- HTMLCanvasElement* WebGLRenderingContextBase::htmlCanvas()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; base = canvasBase();</span>
<span class="line-removed">-     if (!is&lt;HTMLCanvasElement&gt;(base))</span>
<span class="line-removed">-         return nullptr;</span>
<span class="line-removed">-     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
  {
      auto&amp; base = canvasBase();
      if (!is&lt;OffscreenCanvas&gt;(base))
          return nullptr;
<span class="line-new-header">--- 674,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 800,12 ***</span>
      IntSize canvasSize = clampedCanvasSize();
      m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
      m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
      m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
  
<span class="line-modified">!     m_context-&gt;setContextLostCallback(std::make_unique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="line-modified">!     m_context-&gt;setErrorMessageCallback(std::make_unique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
  }
  
  void WebGLRenderingContextBase::setupFlags()
  {
      ASSERT(m_context);
<span class="line-new-header">--- 789,12 ---</span>
      IntSize canvasSize = clampedCanvasSize();
      m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
      m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
      m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
  
<span class="line-modified">!     m_context-&gt;setContextLostCallback(makeUnique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="line-modified">!     m_context-&gt;setErrorMessageCallback(makeUnique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
  }
  
  void WebGLRenderingContextBase::setupFlags()
  {
      ASSERT(m_context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 889,20 ***</span>
<span class="line-new-header">--- 878,32 ---</span>
      if (!m_isPendingPolicyResolution) {
          detachAndRemoveAllObjects();
          destroyGraphicsContext3D();
          m_contextGroup-&gt;removeContext(*this);
      }
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+         LockHolder lock(WebGLProgram::instancesMutex());</span>
<span class="line-added">+         for (auto&amp; entry : WebGLProgram::instances(lock)) {</span>
<span class="line-added">+             if (entry.value == this) {</span>
<span class="line-added">+                 // Don&#39;t remove any WebGLProgram from the instances list, as they may still exist.</span>
<span class="line-added">+                 // Only remove the association with a WebGL context.</span>
<span class="line-added">+                 entry.value = nullptr;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  }
  
  void WebGLRenderingContextBase::destroyGraphicsContext3D()
  {
      if (m_isPendingPolicyResolution)
          return;
  
      removeActivityStateChangeObserver();
  
      if (m_context) {
<span class="line-added">+         m_context-&gt;removeClient(*this);</span>
          m_context-&gt;setContextLostCallback(nullptr);
          m_context-&gt;setErrorMessageCallback(nullptr);
          m_context = nullptr;
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1078,16 ***</span>
      GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);
      width = clamp(width, 1, maxWidth);
      height = clamp(height, 1, maxHeight);
  
      if (m_needsUpdate) {
<span class="line-modified">!         auto* canvas = htmlCanvas();</span>
<span class="line-removed">-         if (canvas) {</span>
<span class="line-removed">-             RenderBox* renderBox = htmlCanvas()-&gt;renderBox();</span>
<span class="line-removed">-             if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())</span>
<span class="line-removed">-                 renderBox-&gt;contentChanged(CanvasChanged);</span>
<span class="line-removed">-         }</span>
          m_needsUpdate = false;
      }
  
      // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
      // clear (and this matches what reshape will do).
<span class="line-new-header">--- 1079,11 ---</span>
      GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);
      width = clamp(width, 1, maxWidth);
      height = clamp(height, 1, maxHeight);
  
      if (m_needsUpdate) {
<span class="line-modified">!         notifyCanvasContentChanged();</span>
          m_needsUpdate = false;
      }
  
      // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
      // clear (and this matches what reshape will do).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,11 ***</span>
  
      if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
          Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
  
          for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
<span class="line-modified">!             canvas-&gt;document().addConsoleMessage(std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));</span>
      }
  }
  
  void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)
  {
<span class="line-new-header">--- 1564,11 ---</span>
  
      if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
          Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
  
          for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
<span class="line-modified">!             canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));</span>
      }
  }
  
  void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1728,29 ***</span>
  {
      if (isContextLostOrPending())
          return nullptr;
      auto buffer = WebGLBuffer::create(*this);
      addSharedObject(buffer.get());
<span class="line-modified">!     return WTFMove(buffer);</span>
  }
  
  RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
  {
      if (isContextLostOrPending())
          return nullptr;
      auto buffer = WebGLFramebuffer::create(*this);
      addContextObject(buffer.get());
<span class="line-modified">!     return WTFMove(buffer);</span>
  }
  
  RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
  {
      if (isContextLostOrPending())
          return nullptr;
      auto texture = WebGLTexture::create(*this);
      addSharedObject(texture.get());
<span class="line-modified">!     return WTFMove(texture);</span>
  }
  
  RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
  {
      if (isContextLostOrPending())
<span class="line-new-header">--- 1724,29 ---</span>
  {
      if (isContextLostOrPending())
          return nullptr;
      auto buffer = WebGLBuffer::create(*this);
      addSharedObject(buffer.get());
<span class="line-modified">!     return buffer;</span>
  }
  
  RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
  {
      if (isContextLostOrPending())
          return nullptr;
      auto buffer = WebGLFramebuffer::create(*this);
      addContextObject(buffer.get());
<span class="line-modified">!     return buffer;</span>
  }
  
  RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
  {
      if (isContextLostOrPending())
          return nullptr;
      auto texture = WebGLTexture::create(*this);
      addSharedObject(texture.get());
<span class="line-modified">!     return texture;</span>
  }
  
  RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
  {
      if (isContextLostOrPending())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1758,20 ***</span>
      auto program = WebGLProgram::create(*this);
      addSharedObject(program.get());
  
      InspectorInstrumentation::didCreateProgram(*this, program.get());
  
<span class="line-modified">!     return WTFMove(program);</span>
  }
  
  RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
  {
      if (isContextLostOrPending())
          return nullptr;
      auto buffer = WebGLRenderbuffer::create(*this);
      addSharedObject(buffer.get());
<span class="line-modified">!     return WTFMove(buffer);</span>
  }
  
  RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)
  {
      if (isContextLostOrPending())
<span class="line-new-header">--- 1754,20 ---</span>
      auto program = WebGLProgram::create(*this);
      addSharedObject(program.get());
  
      InspectorInstrumentation::didCreateProgram(*this, program.get());
  
<span class="line-modified">!     return program;</span>
  }
  
  RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
  {
      if (isContextLostOrPending())
          return nullptr;
      auto buffer = WebGLRenderbuffer::create(*this);
      addSharedObject(buffer.get());
<span class="line-modified">!     return buffer;</span>
  }
  
  RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)
  {
      if (isContextLostOrPending())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1781,11 ***</span>
          return nullptr;
      }
  
      auto shader = WebGLShader::create(*this, type);
      addSharedObject(shader.get());
<span class="line-modified">!     return WTFMove(shader);</span>
  }
  
  void WebGLRenderingContextBase::cullFace(GC3Denum mode)
  {
      if (isContextLostOrPending())
<span class="line-new-header">--- 1777,11 ---</span>
          return nullptr;
      }
  
      auto shader = WebGLShader::create(*this, type);
      addSharedObject(shader.get());
<span class="line-modified">!     return shader;</span>
  }
  
  void WebGLRenderingContextBase::cullFace(GC3Denum mode)
  {
      if (isContextLostOrPending())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2044,10 ***</span>
<span class="line-new-header">--- 2040,11 ---</span>
      return true;
  }
  
  bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
  {
<span class="line-added">+ #if !USE(ANGLE)</span>
      if (!m_currentProgram)
          return false;
  
      // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
      for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2111,10 ***</span>
<span class="line-new-header">--- 2108,11 ---</span>
                  }
              }
              return false;
          }
      }
<span class="line-added">+ #endif</span>
  
      return true;
  }
  
  bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2627,11 ***</span>
      auto attributes = m_context-&gt;getContextAttributes();
      if (!m_attributes.depth)
          attributes.depth = false;
      if (!m_attributes.stencil)
          attributes.stencil = false;
<span class="line-modified">!     return WTFMove(attributes);</span>
  }
  
  GC3Denum WebGLRenderingContextBase::getError()
  {
      if (m_isPendingPolicyResolution)
<span class="line-new-header">--- 2625,11 ---</span>
      auto attributes = m_context-&gt;getContextAttributes();
      if (!m_attributes.depth)
          attributes.depth = false;
      if (!m_attributes.stencil)
          attributes.stencil = false;
<span class="line-modified">!     return attributes;</span>
  }
  
  GC3Denum WebGLRenderingContextBase::getError()
  {
      if (m_isPendingPolicyResolution)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2656,11 ***</span>
<span class="line-new-header">--- 2654,15 ---</span>
      case GraphicsContext3D::ATTACHED_SHADERS:
          m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
          return value;
      case GraphicsContext3D::ACTIVE_ATTRIBUTES:
      case GraphicsContext3D::ACTIVE_UNIFORMS:
<span class="line-added">+ #if USE(ANGLE)</span>
<span class="line-added">+         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);</span>
<span class="line-added">+ #else</span>
          m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
<span class="line-added">+ #endif // USE(ANGLE)</span>
          return value;
      default:
          synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);
          return nullptr;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2943,11 ***</span>
              m_context-&gt;getUniformiv(objectOrZero(program), location, value);
          if (length &gt; 1) {
              Vector&lt;bool&gt; vector(length);
              for (unsigned j = 0; j &lt; length; j++)
                  vector[j] = value[j];
<span class="line-modified">!             return WTFMove(vector);</span>
          }
          return static_cast&lt;bool&gt;(value[0]);
      }
      default:
          notImplemented();
<span class="line-new-header">--- 2945,11 ---</span>
              m_context-&gt;getUniformiv(objectOrZero(program), location, value);
          if (length &gt; 1) {
              Vector&lt;bool&gt; vector(length);
              for (unsigned j = 0; j &lt; length; j++)
                  vector[j] = value[j];
<span class="line-modified">!             return vector;</span>
          }
          return static_cast&lt;bool&gt;(value[0]);
      }
      default:
          notImplemented();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2975,11 ***</span>
<span class="line-new-header">--- 2977,15 ---</span>
      GC3Dint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);
      if (uniformLocation == -1)
          return nullptr;
  
      GC3Dint activeUniforms = 0;
<span class="line-added">+ #if USE(ANGLE)</span>
<span class="line-added">+     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
<span class="line-added">+ #else</span>
      m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);
<span class="line-added">+ #endif</span>
      for (GC3Dint i = 0; i &lt; activeUniforms; i++) {
          ActiveInfo info;
          if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
              return nullptr;
          // Strip &quot;[0]&quot; from the name if it&#39;s an array.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3189,15 ***</span>
      if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
          return false;
  
      RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);
      RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);
<span class="line-modified">!     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid() || !m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get())) || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {</span>
          program-&gt;setLinkStatus(false);
          return false;
      }
  
      m_context-&gt;linkProgram(objectOrZero(program));
      return true;
  }
  
  void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)
<span class="line-new-header">--- 3195,23 ---</span>
      if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
          return false;
  
      RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);
      RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);
<span class="line-modified">!     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {</span>
          program-&gt;setLinkStatus(false);
          return false;
      }
  
<span class="line-added">+ #if !USE(ANGLE)</span>
<span class="line-added">+     if (!m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))</span>
<span class="line-added">+         || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {</span>
<span class="line-added">+         program-&gt;setLinkStatus(false);</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      m_context-&gt;linkProgram(objectOrZero(program));
      return true;
  }
  
  void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3433,13 ***</span>
          }
          // FIXME: readBuffer() should affect this
          internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
      } else {
          if (m_attributes.alpha)
<span class="line-removed">-             internalFormat = GraphicsContext3D::RGB8;</span>
<span class="line-removed">-         else</span>
              internalFormat = GraphicsContext3D::RGBA8;
      }
  
      if (!internalFormat) {
          synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
          return;
<span class="line-new-header">--- 3447,13 ---</span>
          }
          // FIXME: readBuffer() should affect this
          internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
      } else {
          if (m_attributes.alpha)
              internalFormat = GraphicsContext3D::RGBA8;
<span class="line-added">+         else</span>
<span class="line-added">+             internalFormat = GraphicsContext3D::RGB8;</span>
      }
  
      if (!internalFormat) {
          synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3459,16 ***</span>
          case GraphicsContext3D::UNSIGNED_BYTE:
          case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
          case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
          case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
              break;
          default:
              synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
              return;
          }
<span class="line-modified">!         if (format != GraphicsContext3D::RGBA || type != GraphicsContext3D::UNSIGNED_BYTE) {</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE&quot;);</span>
              return;
          }
      }
  
      InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
<span class="line-new-header">--- 3473,22 ---</span>
          case GraphicsContext3D::UNSIGNED_BYTE:
          case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
          case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
          case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
              break;
<span class="line-added">+         case GraphicsContext3D::FLOAT:</span>
<span class="line-added">+             if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {</span>
<span class="line-added">+                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
          default:
              synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
              return;
          }
<span class="line-modified">!         if (format != GraphicsContext3D::RGBA || (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::FLOAT)) {</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
              return;
          }
      }
  
      InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3476,75 ***</span>
      if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
          synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
          return;
      }
  
<span class="line-modified">! #define INTERNAL_FORMAT_CHECK(themeMacro, typeMacro, pixelTypeMacro) case InternalFormatTheme::themeMacro: \</span>
<span class="line-modified">!         if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">!             return; \</span>
<span class="line-modified">!         } \</span>
<span class="line-removed">-         if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="line-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-removed">-             return; \</span>
<span class="line-removed">-         } \</span>
<span class="line-removed">-         if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-removed">-             return; \</span>
<span class="line-removed">-         } \</span>
<span class="line-removed">-         break;</span>
  
<span class="line-modified">! #define INTERNAL_FORMAT_INTEGER_CHECK(themeMacro, typeMacro, pixelTypeMacro) case InternalFormatTheme::themeMacro: \</span>
<span class="line-modified">!         if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">!             return; \</span>
<span class="line-modified">!         } \</span>
<span class="line-modified">!         if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">!             return; \</span>
<span class="line-modified">!         } \</span>
<span class="line-modified">!         if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-removed">-             return; \</span>
<span class="line-removed">-         } \</span>
<span class="line-removed">-         break;</span>
  
<span class="line-modified">! #define PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-modified">!         if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-modified">!             &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">!             return; \</span>
<span class="line-modified">!         } \</span>
<span class="line-modified">!         if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
<span class="line-modified">!             return; \</span>
<span class="line-modified">!         } \</span>
<span class="line-modified">!         break;</span>
  
      switch (internalFormatTheme) {
<span class="line-modified">!     INTERNAL_FORMAT_CHECK        (NormalizedFixedPoint      , UNSIGNED_BYTE, TypeUint8  );</span>
<span class="line-modified">!     INTERNAL_FORMAT_CHECK        (SignedNormalizedFixedPoint, BYTE         , TypeInt8   );</span>
<span class="line-modified">!     INTERNAL_FORMAT_CHECK        (FloatingPoint             , FLOAT        , TypeFloat32);</span>
<span class="line-modified">!     INTERNAL_FORMAT_INTEGER_CHECK(SignedInteger             , INT          , TypeInt32  );</span>
<span class="line-modified">!     INTERNAL_FORMAT_INTEGER_CHECK(UnsignedInteger           , UNSIGNED_INT , TypeUint32 );</span>
      case InternalFormatTheme::Packed:
          switch (internalFormat) {
<span class="line-modified">!         PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">!         PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">!         PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">!         PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );</span>
<span class="line-modified">!         PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
<span class="line-modified">!         PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);</span>
<span class="line-modified">!         PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
          }
          break;
      case InternalFormatTheme::None:
          ASSERT_NOT_REACHED();
      }
  #undef INTERNAL_FORMAT_CHECK
  #undef INTERNAL_FORMAT_INTEGER_CHECK
<span class="line-modified">! #undef PACKED_INTERNAL_FORMAT_CHECK</span>
  
      // Calculate array size, taking into consideration of PACK_ALIGNMENT.
      unsigned totalBytesRequired = 0;
      unsigned padding = 0;
      if (!m_isRobustnessEXTSupported) {
<span class="line-new-header">--- 3496,88 ---</span>
      if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
          synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
          return;
      }
  
<span class="line-modified">! #define CHECK_COMPONENT_COUNT \</span>
<span class="line-modified">!     if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-modified">!         return; \</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">! #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \</span>
<span class="line-modified">!     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">!         return; \</span>
<span class="line-modified">!     } \</span>
<span class="line-modified">!     if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">!         return; \</span>
<span class="line-modified">!     } \</span>
<span class="line-modified">!     CHECK_COMPONENT_COUNT</span>
  
<span class="line-modified">! #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \</span>
<span class="line-modified">!     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">!         return; \</span>
<span class="line-modified">!     } \</span>
<span class="line-modified">!     if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">!         return; \</span>
<span class="line-modified">!     } \</span>
<span class="line-modified">!     CHECK_COMPONENT_COUNT</span>
<span class="line-modified">! </span>
<span class="line-added">+ #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-added">+     if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-added">+         &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-added">+         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-added">+         return; \</span>
<span class="line-added">+     } \</span>
<span class="line-added">+     if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-added">+         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
<span class="line-added">+         return; \</span>
<span class="line-added">+     } \</span>
<span class="line-added">+     break;</span>
  
      switch (internalFormatTheme) {
<span class="line-modified">!     case InternalFormatTheme::NormalizedFixedPoint:</span>
<span class="line-modified">!         if (type == GraphicsContext3D::FLOAT) {</span>
<span class="line-modified">!             INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case InternalFormatTheme::SignedNormalizedFixedPoint:</span>
<span class="line-added">+         INTERNAL_FORMAT_CHECK(BYTE, TypeInt8);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case InternalFormatTheme::FloatingPoint:</span>
<span class="line-added">+         INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case InternalFormatTheme::SignedInteger:</span>
<span class="line-added">+         INTERNAL_FORMAT_INTEGER_CHECK(INT, TypeInt32);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case InternalFormatTheme::UnsignedInteger:</span>
<span class="line-added">+         INTERNAL_FORMAT_INTEGER_CHECK(UNSIGNED_INT, TypeUint32);</span>
<span class="line-added">+         break;</span>
      case InternalFormatTheme::Packed:
          switch (internalFormat) {
<span class="line-modified">!             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">!             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">!             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">!             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );</span>
<span class="line-modified">!             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
<span class="line-modified">!             CASE_PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);</span>
<span class="line-modified">!             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
          }
          break;
      case InternalFormatTheme::None:
          ASSERT_NOT_REACHED();
      }
<span class="line-added">+ #undef CHECK_COMPONENT_COUNT</span>
  #undef INTERNAL_FORMAT_CHECK
  #undef INTERNAL_FORMAT_INTEGER_CHECK
<span class="line-modified">! #undef CASE_PACKED_INTERNAL_FORMAT_CHECK</span>
  
      // Calculate array size, taking into consideration of PACK_ALIGNMENT.
      unsigned totalBytesRequired = 0;
      unsigned padding = 0;
      if (!m_isRobustnessEXTSupported) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4996,11 ***</span>
      }
      if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
          synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);
          return;
      }
<span class="line-modified">!     if (!m_boundArrayBuffer) {</span>
          synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);
          return;
      }
      // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
      auto typeSize = sizeInBytes(type);
<span class="line-new-header">--- 5029,11 ---</span>
      }
      if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
          synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);
          return;
      }
<span class="line-modified">!     if (!m_boundArrayBuffer &amp;&amp; offset) {</span>
          synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);
          return;
      }
      // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
      auto typeSize = sizeInBytes(type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5012,11 ***</span>
          synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);
          return;
      }
      GC3Dsizei bytesPerElement = size * typeSize;
  
<span class="line-modified">!     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), *m_boundArrayBuffer);</span>
      m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));
  }
  
  void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
  {
<span class="line-new-header">--- 5045,11 ---</span>
          synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);
          return;
      }
      GC3Dsizei bytesPerElement = size * typeSize;
  
<span class="line-modified">!     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), m_boundArrayBuffer.get());</span>
      m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));
  }
  
  void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5035,19 ***</span>
      }
  
      m_contextGroup-&gt;loseContextGroup(mode);
  }
  
<span class="line-removed">- void WebGLRenderingContextBase::recycleContext()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);</span>
<span class="line-removed">-     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration</span>
<span class="line-removed">-     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.</span>
<span class="line-removed">-     forceLostContext(SyntheticLostContext);</span>
<span class="line-removed">-     destroyGraphicsContext3D();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
  {
      if (isContextLost())
          return;
  
<span class="line-new-header">--- 5068,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5771,13 ***</span>
      std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
  
      // Error messages can occur during function calls, so show stack traces for them.
      if (level == MessageLevel::Error) {
          Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
<span class="line-modified">!         consoleMessage = std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));</span>
      } else
<span class="line-modified">!         consoleMessage = std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);</span>
  
      auto* canvas = htmlCanvas();
      if (canvas)
          canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
  
<span class="line-new-header">--- 5795,13 ---</span>
      std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
  
      // Error messages can occur during function calls, so show stack traces for them.
      if (level == MessageLevel::Error) {
          Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
<span class="line-modified">!         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));</span>
      } else
<span class="line-modified">!         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);</span>
  
      auto* canvas = htmlCanvas();
      if (canvas)
          canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6218,19 ***</span>
      initializeNewContext();
      initializeVertexArrayObjects();
      canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
  }
  
<span class="line-removed">- void WebGLRenderingContextBase::dispatchContextChangedEvent()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto* canvas = htmlCanvas();</span>
<span class="line-removed">-     if (!canvas)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void WebGLRenderingContextBase::simulateContextChanged()
  {
      if (m_context)
          m_context-&gt;simulateContextChanged();
  }
<span class="line-new-header">--- 6242,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6506,8 ***</span>
<span class="line-new-header">--- 6521,38 ---</span>
          return;
  
      m_context-&gt;setFailNextGPUStatusCheck();
  }
  
<span class="line-added">+ void WebGLRenderingContextBase::didComposite()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (UNLIKELY(callTracingActive()))</span>
<span class="line-added">+         InspectorInstrumentation::didFinishRecordingCanvasFrame(*this);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WebGLRenderingContextBase::forceContextLost()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     forceLostContext(WebGLRenderingContextBase::RealLostContext);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WebGLRenderingContextBase::recycleContext()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);</span>
<span class="line-added">+     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration</span>
<span class="line-added">+     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.</span>
<span class="line-added">+     forceLostContext(SyntheticLostContext);</span>
<span class="line-added">+     destroyGraphicsContext3D();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WebGLRenderingContextBase::dispatchContextChangedNotification()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* canvas = htmlCanvas();</span>
<span class="line-added">+     if (!canvas)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #endif // ENABLE(WEBGL)
</pre>
<center><a href="WebGLRenderingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>