<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
   3     Copyright (C) 2001 Dirk Mueller (mueller@kde.org)
   4     Copyright (C) 2002 Waldo Bastian (bastian@kde.org)
   5     Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   6     Copyright (C) 2009 Torch Mobile Inc. http://www.torchmobile.com/
   7 
   8     This library is free software; you can redistribute it and/or
   9     modify it under the terms of the GNU Library General Public
  10     License as published by the Free Software Foundation; either
  11     version 2 of the License, or (at your option) any later version.
  12 
  13     This library is distributed in the hope that it will be useful,
  14     but WITHOUT ANY WARRANTY; without even the implied warranty of
  15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16     Library General Public License for more details.
  17 
  18     You should have received a copy of the GNU Library General Public License
  19     along with this library; see the file COPYING.LIB.  If not, write to
  20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21     Boston, MA 02110-1301, USA.
  22 
  23     This class provides all functionality needed for loading images, style sheets and html
  24     pages from the web. It has a memory cache for these objects.
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;CachedResourceLoader.h&quot;
  29 
  30 #include &quot;CachedCSSStyleSheet.h&quot;
  31 #include &quot;CachedFont.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;CachedRawResource.h&quot;
  34 #include &quot;CachedResourceRequest.h&quot;
  35 #include &quot;CachedSVGDocument.h&quot;
  36 #include &quot;CachedSVGFont.h&quot;
  37 #include &quot;CachedScript.h&quot;
  38 #include &quot;CachedXSLStyleSheet.h&quot;
  39 #include &quot;Chrome.h&quot;
  40 #include &quot;ChromeClient.h&quot;
  41 #include &quot;ContentExtensionError.h&quot;
  42 #include &quot;ContentExtensionRule.h&quot;
  43 #include &quot;ContentRuleListResults.h&quot;
  44 #include &quot;ContentSecurityPolicy.h&quot;
  45 #include &quot;CrossOriginAccessControl.h&quot;
  46 #include &quot;CustomHeaderFields.h&quot;
  47 #include &quot;DOMWindow.h&quot;
  48 #include &quot;DiagnosticLoggingClient.h&quot;
  49 #include &quot;DiagnosticLoggingKeys.h&quot;
  50 #include &quot;Document.h&quot;
  51 #include &quot;DocumentLoader.h&quot;
  52 #include &quot;Frame.h&quot;
  53 #include &quot;FrameLoader.h&quot;
  54 #include &quot;FrameLoaderClient.h&quot;
  55 #include &quot;HTMLElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;
  57 #include &quot;HTTPHeaderField.h&quot;
  58 #include &quot;LoaderStrategy.h&quot;
  59 #include &quot;LocalizedStrings.h&quot;
  60 #include &quot;Logging.h&quot;
  61 #include &quot;MemoryCache.h&quot;
  62 #include &quot;Page.h&quot;
  63 #include &quot;PingLoader.h&quot;
  64 #include &quot;PlatformStrategies.h&quot;
  65 #include &quot;RenderElement.h&quot;
  66 #include &quot;ResourceLoadInfo.h&quot;
  67 #include &quot;ResourceTiming.h&quot;
  68 #include &quot;RuntimeEnabledFeatures.h&quot;
  69 #include &quot;ScriptController.h&quot;
  70 #include &quot;SecurityOrigin.h&quot;
  71 #include &quot;SecurityPolicy.h&quot;
  72 #include &quot;ServiceWorker.h&quot;
  73 #include &quot;Settings.h&quot;
  74 #include &quot;StyleSheetContents.h&quot;
  75 #include &quot;SubresourceLoader.h&quot;
  76 #include &quot;UserContentController.h&quot;
  77 #include &quot;UserStyleSheet.h&quot;
  78 #include &lt;pal/SessionID.h&gt;
  79 #include &lt;wtf/text/CString.h&gt;
  80 #include &lt;wtf/text/WTFString.h&gt;
  81 
  82 #if ENABLE(APPLICATION_MANIFEST)
  83 #include &quot;CachedApplicationManifest.h&quot;
  84 #endif
  85 
  86 #if ENABLE(VIDEO_TRACK)
  87 #include &quot;CachedTextTrack.h&quot;
  88 #endif
  89 
  90 #undef RELEASE_LOG_IF_ALLOWED
  91 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResourceLoader::&quot; fmt, this, ##__VA_ARGS__)
  92 
  93 namespace WebCore {
  94 
  95 // Timeout for link preloads to be used after window.onload
  96 static const Seconds unusedPreloadTimeout { 3_s };
  97 
  98 template &lt;typename T, typename U&gt;
  99 static inline ResourceErrorOr&lt;CachedResourceHandle&lt;T&gt;&gt; castCachedResourceTo(ResourceErrorOr&lt;CachedResourceHandle&lt;U&gt;&gt;&amp;&amp; cachedResource)
 100 {
 101     if (cachedResource)
 102         return CachedResourceHandle&lt;T&gt; { static_cast&lt;T*&gt;(cachedResource.value().get()) };
 103     return makeUnexpected(cachedResource.error());
 104 }
 105 
 106 static CachedResource* createResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 107 {
 108     switch (type) {
 109     case CachedResource::Type::ImageResource:
 110         return new CachedImage(WTFMove(request), sessionID, cookieJar);
 111     case CachedResource::Type::CSSStyleSheet:
 112         return new CachedCSSStyleSheet(WTFMove(request), sessionID, cookieJar);
 113     case CachedResource::Type::Script:
 114         return new CachedScript(WTFMove(request), sessionID, cookieJar);
 115     case CachedResource::Type::SVGDocumentResource:
 116         return new CachedSVGDocument(WTFMove(request), sessionID, cookieJar);
 117 #if ENABLE(SVG_FONTS)
 118     case CachedResource::Type::SVGFontResource:
 119         return new CachedSVGFont(WTFMove(request), sessionID, cookieJar);
 120 #endif
 121     case CachedResource::Type::FontResource:
 122         return new CachedFont(WTFMove(request), sessionID, cookieJar);
 123     case CachedResource::Type::Beacon:
 124     case CachedResource::Type::Ping:
 125     case CachedResource::Type::MediaResource:
 126     case CachedResource::Type::RawResource:
 127     case CachedResource::Type::Icon:
 128     case CachedResource::Type::MainResource:
 129         return new CachedRawResource(WTFMove(request), type, sessionID, cookieJar);
 130 #if ENABLE(XSLT)
 131     case CachedResource::Type::XSLStyleSheet:
 132         return new CachedXSLStyleSheet(WTFMove(request), sessionID, cookieJar);
 133 #endif
 134     case CachedResource::Type::LinkPrefetch:
 135         return new CachedResource(WTFMove(request), CachedResource::Type::LinkPrefetch, sessionID, cookieJar);
 136 #if ENABLE(VIDEO_TRACK)
 137     case CachedResource::Type::TextTrackResource:
 138         return new CachedTextTrack(WTFMove(request), sessionID, cookieJar);
 139 #endif
 140 #if ENABLE(APPLICATION_MANIFEST)
 141     case CachedResource::Type::ApplicationManifest:
 142         return new CachedApplicationManifest(WTFMove(request), sessionID, cookieJar);
 143 #endif
 144     }
 145     ASSERT_NOT_REACHED();
 146     return nullptr;
 147 }
 148 
 149 CachedResourceLoader::CachedResourceLoader(DocumentLoader* documentLoader)
 150     : m_document(nullptr)
 151     , m_documentLoader(documentLoader)
 152     , m_requestCount(0)
 153     , m_unusedPreloadsTimer(*this, &amp;CachedResourceLoader::warnUnusedPreloads)
 154     , m_garbageCollectDocumentResourcesTimer(*this, &amp;CachedResourceLoader::garbageCollectDocumentResources)
 155     , m_autoLoadImages(true)
 156     , m_imagesEnabled(true)
 157     , m_allowStaleResources(false)
 158 {
 159 }
 160 
 161 CachedResourceLoader::~CachedResourceLoader()
 162 {
 163     m_documentLoader = nullptr;
 164     m_document = nullptr;
 165 
 166     clearPreloads(ClearPreloadsMode::ClearAllPreloads);
 167 
 168     // Make sure no requests still point to this CachedResourceLoader
 169     ASSERT(m_requestCount == 0);
 170     m_unusedPreloadsTimer.stop();
 171 }
 172 
 173 CachedResource* CachedResourceLoader::cachedResource(const String&amp; resourceURL) const
 174 {
 175     ASSERT(!resourceURL.isNull());
 176     return cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(m_document-&gt;completeURL(resourceURL)));
 177 }
 178 
 179 CachedResource* CachedResourceLoader::cachedResource(const URL&amp; url) const
 180 {
 181     ASSERT(!MemoryCache::shouldRemoveFragmentIdentifier(url));
 182     return m_documentResources.get(url).get();
 183 }
 184 
 185 Frame* CachedResourceLoader::frame() const
 186 {
 187     return m_documentLoader ? m_documentLoader-&gt;frame() : nullptr;
 188 }
 189 
 190 PAL::SessionID CachedResourceLoader::sessionID() const
 191 {
 192     auto sessionID = PAL::SessionID::defaultSessionID();
 193     if (auto* frame = this-&gt;frame()) {
 194         if (auto* page = frame-&gt;page())
 195             sessionID = page-&gt;sessionID();
 196     }
 197     return sessionID;
 198 }
 199 
 200 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedImage&gt;&gt; CachedResourceLoader::requestImage(CachedResourceRequest&amp;&amp; request)
 201 {
 202     if (Frame* frame = this-&gt;frame()) {
 203         if (frame-&gt;loader().pageDismissalEventBeingDispatched() != FrameLoader::PageDismissalType::None) {
 204             if (Document* document = frame-&gt;document())
 205                 request.upgradeInsecureRequestIfNeeded(*document);
 206             URL requestURL = request.resourceRequest().url();
 207             if (requestURL.isValid() &amp;&amp; canRequest(CachedResource::Type::ImageResource, requestURL, request, ForPreload::No))
 208                 PingLoader::loadImage(*frame, requestURL);
 209             return CachedResourceHandle&lt;CachedImage&gt; { };
 210         }
 211     }
 212 
 213     auto defer = clientDefersImage(request.resourceRequest().url()) ? DeferOption::DeferredByClient : DeferOption::NoDefer;
 214     return castCachedResourceTo&lt;CachedImage&gt;(requestResource(CachedResource::Type::ImageResource, WTFMove(request), ForPreload::No, defer));
 215 }
 216 
 217 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; CachedResourceLoader::requestFont(CachedResourceRequest&amp;&amp; request, bool isSVG)
 218 {
 219 #if ENABLE(SVG_FONTS)
 220     if (isSVG)
 221         return castCachedResourceTo&lt;CachedFont&gt;(requestResource(CachedResource::Type::SVGFontResource, WTFMove(request)));
 222 #else
 223     UNUSED_PARAM(isSVG);
 224 #endif
 225     return castCachedResourceTo&lt;CachedFont&gt;(requestResource(CachedResource::Type::FontResource, WTFMove(request)));
 226 }
 227 
 228 #if ENABLE(VIDEO_TRACK)
 229 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedTextTrack&gt;&gt; CachedResourceLoader::requestTextTrack(CachedResourceRequest&amp;&amp; request)
 230 {
 231     return castCachedResourceTo&lt;CachedTextTrack&gt;(requestResource(CachedResource::Type::TextTrackResource, WTFMove(request)));
 232 }
 233 #endif
 234 
 235 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedCSSStyleSheet&gt;&gt; CachedResourceLoader::requestCSSStyleSheet(CachedResourceRequest&amp;&amp; request)
 236 {
 237     return castCachedResourceTo&lt;CachedCSSStyleSheet&gt;(requestResource(CachedResource::Type::CSSStyleSheet, WTFMove(request)));
 238 }
 239 
 240 CachedResourceHandle&lt;CachedCSSStyleSheet&gt; CachedResourceLoader::requestUserCSSStyleSheet(Page&amp; page, CachedResourceRequest&amp;&amp; request)
 241 {
 242     request.setDestinationIfNotSet(FetchOptions::Destination::Style);
 243 
 244     ASSERT(document());
 245     request.setDomainForCachePartition(*document());
 246 
 247     auto&amp; memoryCache = MemoryCache::singleton();
 248     if (request.allowsCaching()) {
 249         if (CachedResource* existing = memoryCache.resourceForRequest(request.resourceRequest(), sessionID())) {
 250             if (is&lt;CachedCSSStyleSheet&gt;(*existing))
 251                 return downcast&lt;CachedCSSStyleSheet&gt;(existing);
 252             memoryCache.remove(*existing);
 253         }
 254     }
 255 
 256     request.removeFragmentIdentifierIfNeeded();
 257 
 258     CachedResourceHandle&lt;CachedCSSStyleSheet&gt; userSheet = new CachedCSSStyleSheet(WTFMove(request), page.sessionID(), &amp;page.cookieJar());
 259 
 260     if (userSheet-&gt;allowsCaching())
 261         memoryCache.add(*userSheet);
 262 
 263     userSheet-&gt;load(*this);
 264     return userSheet;
 265 }
 266 
 267 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedScript&gt;&gt; CachedResourceLoader::requestScript(CachedResourceRequest&amp;&amp; request)
 268 {
 269     return castCachedResourceTo&lt;CachedScript&gt;(requestResource(CachedResource::Type::Script, WTFMove(request)));
 270 }
 271 
 272 #if ENABLE(XSLT)
 273 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedXSLStyleSheet&gt;&gt; CachedResourceLoader::requestXSLStyleSheet(CachedResourceRequest&amp;&amp; request)
 274 {
 275     return castCachedResourceTo&lt;CachedXSLStyleSheet&gt;(requestResource(CachedResource::Type::XSLStyleSheet, WTFMove(request)));
 276 }
 277 #endif
 278 
 279 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedSVGDocument&gt;&gt; CachedResourceLoader::requestSVGDocument(CachedResourceRequest&amp;&amp; request)
 280 {
 281     return castCachedResourceTo&lt;CachedSVGDocument&gt;(requestResource(CachedResource::Type::SVGDocumentResource, WTFMove(request)));
 282 }
 283 
 284 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestLinkResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
 285 {
 286     ASSERT(frame());
 287     ASSERT(type == CachedResource::Type::LinkPrefetch);
 288     return requestResource(type, WTFMove(request));
 289 }
 290 
 291 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMedia(CachedResourceRequest&amp;&amp; request)
 292 {
 293     // FIXME: Assert request.options().destination is FetchOptions::Destination::{Audio, Video}.
 294     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MediaResource, WTFMove(request)));
 295 }
 296 
 297 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestIcon(CachedResourceRequest&amp;&amp; request)
 298 {
 299     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Icon, WTFMove(request)));
 300 }
 301 
 302 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestRawResource(CachedResourceRequest&amp;&amp; request)
 303 {
 304     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::RawResource, WTFMove(request)));
 305 }
 306 
 307 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestBeaconResource(CachedResourceRequest&amp;&amp; request)
 308 {
 309     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);
 310     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Beacon, WTFMove(request)));
 311 }
 312 
 313 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestPingResource(CachedResourceRequest&amp;&amp; request)
 314 {
 315     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);
 316     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Ping, WTFMove(request)));
 317 }
 318 
 319 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMainResource(CachedResourceRequest&amp;&amp; request)
 320 {
 321     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MainResource, WTFMove(request)));
 322 }
 323 
 324 #if ENABLE(APPLICATION_MANIFEST)
 325 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedApplicationManifest&gt;&gt; CachedResourceLoader::requestApplicationManifest(CachedResourceRequest&amp;&amp; request)
 326 {
 327     return castCachedResourceTo&lt;CachedApplicationManifest&gt;(requestResource(CachedResource::Type::ApplicationManifest, WTFMove(request)));
 328 }
 329 #endif // ENABLE(APPLICATION_MANIFEST)
 330 
 331 static MixedContentChecker::ContentType contentTypeFromResourceType(CachedResource::Type type)
 332 {
 333     switch (type) {
 334     // https://w3c.github.io/webappsec-mixed-content/#category-optionally-blockable
 335     // Editor&#39;s Draft, 11 February 2016
 336     // 3.1. Optionally-blockable Content
 337     case CachedResource::Type::ImageResource:
 338     case CachedResource::Type::MediaResource:
 339             return MixedContentChecker::ContentType::ActiveCanWarn;
 340 
 341     case CachedResource::Type::CSSStyleSheet:
 342     case CachedResource::Type::Script:
 343     case CachedResource::Type::FontResource:
 344         return MixedContentChecker::ContentType::Active;
 345 
 346 #if ENABLE(SVG_FONTS)
 347     case CachedResource::Type::SVGFontResource:
 348         return MixedContentChecker::ContentType::Active;
 349 #endif
 350 
 351     case CachedResource::Type::Beacon:
 352     case CachedResource::Type::Ping:
 353     case CachedResource::Type::RawResource:
 354     case CachedResource::Type::Icon:
 355     case CachedResource::Type::SVGDocumentResource:
 356         return MixedContentChecker::ContentType::Active;
 357 #if ENABLE(XSLT)
 358     case CachedResource::Type::XSLStyleSheet:
 359         return MixedContentChecker::ContentType::Active;
 360 #endif
 361 
 362     case CachedResource::Type::LinkPrefetch:
 363         return MixedContentChecker::ContentType::Active;
 364 
 365 #if ENABLE(VIDEO_TRACK)
 366     case CachedResource::Type::TextTrackResource:
 367         return MixedContentChecker::ContentType::Active;
 368 #endif
 369 #if ENABLE(APPLICATION_MANIFEST)
 370     case CachedResource::Type::ApplicationManifest:
 371         return MixedContentChecker::ContentType::Active;
 372 #endif
 373     default:
 374         ASSERT_NOT_REACHED();
 375         return MixedContentChecker::ContentType::Active;
 376     }
 377 }
 378 
 379 bool CachedResourceLoader::checkInsecureContent(CachedResource::Type type, const URL&amp; url) const
 380 {
 381     if (!canRequestInContentDispositionAttachmentSandbox(type, url))
 382         return false;
 383 
 384     switch (type) {
 385     case CachedResource::Type::Script:
 386 #if ENABLE(XSLT)
 387     case CachedResource::Type::XSLStyleSheet:
 388 #endif
 389     case CachedResource::Type::SVGDocumentResource:
 390     case CachedResource::Type::CSSStyleSheet:
 391         // These resource can inject script into the current document (Script,
 392         // XSL) or exfiltrate the content of the current document (CSS).
 393         if (Frame* frame = this-&gt;frame()) {
 394             if (!frame-&gt;loader().mixedContentChecker().canRunInsecureContent(m_document-&gt;securityOrigin(), url))
 395                 return false;
 396             Frame&amp; top = frame-&gt;tree().top();
 397             if (&amp;top != frame &amp;&amp; !top.loader().mixedContentChecker().canRunInsecureContent(top.document()-&gt;securityOrigin(), url))
 398                 return false;
 399         }
 400         break;
 401 #if ENABLE(VIDEO_TRACK)
 402     case CachedResource::Type::TextTrackResource:
 403 #endif
 404     case CachedResource::Type::MediaResource:
 405     case CachedResource::Type::RawResource:
 406     case CachedResource::Type::Icon:
 407     case CachedResource::Type::ImageResource:
 408 #if ENABLE(SVG_FONTS)
 409     case CachedResource::Type::SVGFontResource:
 410 #endif
 411     case CachedResource::Type::FontResource: {
 412         // These resources can corrupt only the frame&#39;s pixels.
 413         if (Frame* frame = this-&gt;frame()) {
 414             if (!frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_document-&gt;securityOrigin(), contentTypeFromResourceType(type), url, MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes))
 415                 return false;
 416             Frame&amp; topFrame = frame-&gt;tree().top();
 417             if (!topFrame.loader().mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), contentTypeFromResourceType(type), url))
 418                 return false;
 419         }
 420         break;
 421     }
 422     case CachedResource::Type::MainResource:
 423     case CachedResource::Type::Beacon:
 424     case CachedResource::Type::Ping:
 425     case CachedResource::Type::LinkPrefetch:
 426         // Prefetch cannot affect the current document.
 427 #if ENABLE(APPLICATION_MANIFEST)
 428     case CachedResource::Type::ApplicationManifest:
 429 #endif
 430         break;
 431     }
 432     return true;
 433 }
 434 
 435 bool CachedResourceLoader::allowedByContentSecurityPolicy(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived) const
 436 {
 437     if (options.contentSecurityPolicyImposition == ContentSecurityPolicyImposition::SkipPolicyCheck)
 438         return true;
 439 
 440     ASSERT(m_document);
 441     ASSERT(m_document-&gt;contentSecurityPolicy());
 442 
 443     switch (type) {
 444 #if ENABLE(XSLT)
 445     case CachedResource::Type::XSLStyleSheet:
 446 #endif
 447     case CachedResource::Type::Script:
 448         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowScriptFromSource(url, redirectResponseReceived))
 449             return false;
 450         break;
 451     case CachedResource::Type::CSSStyleSheet:
 452         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowStyleFromSource(url, redirectResponseReceived))
 453             return false;
 454         break;
 455     case CachedResource::Type::SVGDocumentResource:
 456     case CachedResource::Type::Icon:
 457     case CachedResource::Type::ImageResource:
 458         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowImageFromSource(url, redirectResponseReceived))
 459             return false;
 460         break;
 461 #if ENABLE(SVG_FONTS)
 462     case CachedResource::Type::SVGFontResource:
 463 #endif
 464     case CachedResource::Type::FontResource:
 465         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowFontFromSource(url, redirectResponseReceived))
 466             return false;
 467         break;
 468     case CachedResource::Type::MediaResource:
 469 #if ENABLE(VIDEO_TRACK)
 470     case CachedResource::Type::TextTrackResource:
 471 #endif
 472         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowMediaFromSource(url, redirectResponseReceived))
 473             return false;
 474         break;
 475     case CachedResource::Type::Beacon:
 476     case CachedResource::Type::Ping:
 477     case CachedResource::Type::RawResource:
 478         return true;
 479 #if ENABLE(APPLICATION_MANIFEST)
 480     case CachedResource::Type::ApplicationManifest:
 481         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowManifestFromSource(url, redirectResponseReceived))
 482             return false;
 483         break;
 484 #endif
 485     default:
 486         ASSERT_NOT_REACHED();
 487     }
 488 
 489     return true;
 490 }
 491 
 492 static inline bool isSameOriginDataURL(const URL&amp; url, const ResourceLoaderOptions&amp; options)
 493 {
 494     // FIXME: Remove same-origin data URL flag since it was removed from fetch spec (https://github.com/whatwg/fetch/issues/381).
 495     return url.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
 496 }
 497 
 498 // Security checks defined in https://fetch.spec.whatwg.org/#main-fetch step 2 and 5.
 499 bool CachedResourceLoader::canRequest(CachedResource::Type type, const URL&amp; url, const CachedResourceRequest&amp; request, ForPreload forPreload)
 500 {
 501     auto&amp; options = request.options();
 502 
 503     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 504         if (forPreload == ForPreload::No)
 505             FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 506         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 507         return false;
 508     }
 509 
 510     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; !isSameOriginDataURL(url, options)) {
 511         printAccessDeniedMessage(url);
 512         return false;
 513     }
 514 
 515     if (options.mode == FetchOptions::Mode::NoCors &amp;&amp; options.redirect != FetchOptions::Redirect::Follow &amp;&amp; type != CachedResource::Type::Ping) {
 516         ASSERT(type != CachedResource::Type::MainResource);
 517         frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;No-Cors mode requires follow redirect mode&quot;_s);
 518         return false;
 519     }
 520 
 521     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::No))
 522         return false;
 523 
 524     // SVG Images have unique security rules that prevent all subresource requests except for data urls.
 525     if (type != CachedResource::Type::MainResource &amp;&amp; frame() &amp;&amp; frame()-&gt;page()) {
 526         if (frame()-&gt;page()-&gt;chrome().client().isSVGImageChromeClient() &amp;&amp; !url.protocolIsData())
 527             return false;
 528     }
 529 
 530     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 531     // They&#39;ll still get a warning in the console about CSP blocking the load.
 532 
 533     // FIXME: Should we consider whether the request is for preload here?
 534     if (!checkInsecureContent(type, url))
 535         return false;
 536 
 537     return true;
 538 }
 539 
 540 // FIXME: Should we find a way to know whether the redirection is for a preload request like we do for CachedResourceLoader::canRequest?
 541 bool CachedResourceLoader::canRequestAfterRedirection(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options) const
 542 {
 543     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 544         FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 545         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 546         return false;
 547     }
 548 
 549     // FIXME: According to https://fetch.spec.whatwg.org/#http-redirect-fetch, we should check that the URL is HTTP(s) except if in navigation mode.
 550     // But we currently allow at least data URLs to be loaded.
 551 
 552     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url)) {
 553         printAccessDeniedMessage(url);
 554         return false;
 555     }
 556 
 557     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::Yes))
 558         return false;
 559 
 560     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 561     // They&#39;ll still get a warning in the console about CSP blocking the load.
 562     if (!checkInsecureContent(type, url))
 563         return false;
 564 
 565     return true;
 566 }
 567 
 568 bool CachedResourceLoader::updateRequestAfterRedirection(CachedResource::Type type, ResourceRequest&amp; request, const ResourceLoaderOptions&amp; options)
 569 {
 570     ASSERT(m_documentLoader);
 571     if (auto* document = m_documentLoader-&gt;cachedResourceLoader().document())
 572         upgradeInsecureResourceRequestIfNeeded(request, *document);
 573 
 574     // FIXME: We might want to align the checks done here with the ones done in CachedResourceLoader::requestResource, content extensions blocking in particular.
 575 
 576     return canRequestAfterRedirection(type, request.url(), options);
 577 }
 578 
 579 bool CachedResourceLoader::canRequestInContentDispositionAttachmentSandbox(CachedResource::Type type, const URL&amp; url) const
 580 {
 581     Document* document;
 582 
 583     // FIXME: Do we want to expand this to all resource types that the mixed content checker would consider active content?
 584     switch (type) {
 585     case CachedResource::Type::MainResource:
 586         if (auto ownerElement = frame() ? frame()-&gt;ownerElement() : nullptr) {
 587             document = &amp;ownerElement-&gt;document();
 588             break;
 589         }
 590         return true;
 591     case CachedResource::Type::CSSStyleSheet:
 592         document = m_document.get();
 593         break;
 594     default:
 595         return true;
 596     }
 597 
 598     if (!document-&gt;shouldEnforceContentDispositionAttachmentSandbox() || document-&gt;securityOrigin().canRequest(url))
 599         return true;
 600 
 601     String message = &quot;Unsafe attempt to load URL &quot; + url.stringCenterEllipsizedToLength() + &quot; from document with Content-Disposition: attachment at URL &quot; + document-&gt;url().stringCenterEllipsizedToLength() + &quot;.&quot;;
 602     document-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 603     return false;
 604 }
 605 
 606 bool CachedResourceLoader::shouldContinueAfterNotifyingLoadedFromMemoryCache(const CachedResourceRequest&amp; request, CachedResource&amp; resource, ResourceError&amp; error)
 607 {
 608     if (!frame() || resource.status() != CachedResource::Cached)
 609         return true;
 610 
 611     ResourceRequest newRequest = ResourceRequest(resource.url());
 612     newRequest.setInitiatorIdentifier(request.resourceRequest().initiatorIdentifier());
 613     if (auto inspectorInitiatorNodeIdentifier = request.resourceRequest().inspectorInitiatorNodeIdentifier())
 614         newRequest.setInspectorInitiatorNodeIdentifier(*inspectorInitiatorNodeIdentifier);
 615     if (request.resourceRequest().hiddenFromInspector())
 616         newRequest.setHiddenFromInspector(true);
 617     frame()-&gt;loader().loadedResourceFromMemoryCache(resource, newRequest, error);
 618 
 619     // FIXME &lt;http://webkit.org/b/113251&gt;: If the delegate modifies the request&#39;s
 620     // URL, it is no longer appropriate to use this CachedResource.
 621     return !newRequest.isNull();
 622 }
 623 
 624 bool CachedResourceLoader::shouldUpdateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 625 {
 626     // WebKit is not supporting CORS for fonts (https://bugs.webkit.org/show_bug.cgi?id=86817), no need to update the resource before reusing it.
 627     if (resource.type() == CachedResource::Type::FontResource)
 628         return false;
 629 
 630 #if ENABLE(SVG_FONTS)
 631     if (resource.type() == CachedResource::Type::SVGFontResource)
 632         return false;
 633 #endif
 634 
 635 #if ENABLE(XSLT)
 636     // Load is same-origin, we do not check for CORS.
 637     if (resource.type() == CachedResource::Type::XSLStyleSheet)
 638         return false;
 639 #endif
 640 
 641     // FIXME: We should enable resource reuse for these resource types
 642     switch (resource.type()) {
 643     case CachedResource::Type::SVGDocumentResource:
 644         return false;
 645     case CachedResource::Type::MainResource:
 646         return false;
 647     case CachedResource::Type::LinkPrefetch:
 648         return false;
 649     default:
 650         break;
 651     }
 652 
 653     if (resource.options().mode != request.options().mode || !serializedOriginsMatch(request.origin(), resource.origin()))
 654         return true;
 655 
 656     if (resource.options().redirect != request.options().redirect &amp;&amp; resource.hasRedirections())
 657         return true;
 658 
 659     return false;
 660 }
 661 
 662 static inline bool isResourceSuitableForDirectReuse(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 663 {
 664     // FIXME: For being loaded requests, the response tainting may not be correctly computed if the fetch mode is not the same.
 665     // Even if the fetch mode is the same, we are not sure that the resource can be reused (Vary: Origin header for instance).
 666     // We should find a way to improve this.
 667     if (resource.status() != CachedResource::Cached)
 668         return false;
 669 
 670     // If the cached resource has not followed redirections, it is incomplete and we should not use it.
 671     // Let&#39;s make sure the memory cache has no such resource.
 672     ASSERT(resource.response().type() != ResourceResponse::Type::Opaqueredirect);
 673 
 674     // We could support redirect modes other than Follow in case of a redirected resource.
 675     // This case is rare and is not worth optimizing currently.
 676     if (request.options().redirect != FetchOptions::Redirect::Follow &amp;&amp; resource.hasRedirections())
 677         return false;
 678 
 679     // FIXME: Implement reuse of cached raw resources.
 680     if (resource.type() == CachedResource::Type::RawResource || resource.type() == CachedResource::Type::MediaResource)
 681         return false;
 682 
 683     if (resource.type() == CachedResource::Type::Beacon || resource.type() == CachedResource::Type::Ping)
 684         return false;
 685 
 686     return true;
 687 }
 688 
 689 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::updateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 690 {
 691     if (!isResourceSuitableForDirectReuse(resource, request)) {
 692         request.setCachingPolicy(CachingPolicy::DisallowCaching);
 693         return loadResource(resource.type(), WTFMove(request), cookieJar);
 694     }
 695 
 696     auto resourceHandle = createResource(resource.type(), WTFMove(request), sessionID, cookieJar);
 697     resourceHandle-&gt;loadFrom(resource);
 698     return resourceHandle;
 699 }
 700 
 701 static inline void logMemoryCacheResourceRequest(Frame* frame, const String&amp; key, const String&amp; description)
 702 {
 703     if (!frame || !frame-&gt;page())
 704         return;
 705     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(key, description, ShouldSample::Yes);
 706 }
 707 
 708 void CachedResourceLoader::prepareFetch(CachedResource::Type type, CachedResourceRequest&amp; request)
 709 {
 710     // Implementing step 1 to 7 of https://fetch.spec.whatwg.org/#fetching
 711     auto* document = this-&gt;document();
 712 
 713     if (document) {
 714         if (!request.origin())
 715             request.setOrigin(document-&gt;securityOrigin());
 716 #if ENABLE(SERVICE_WORKER)
 717         request.setClientIdentifierIfNeeded(document-&gt;identifier());
 718         if (auto* activeServiceWorker = document-&gt;activeServiceWorker())
 719             request.setSelectedServiceWorkerRegistrationIdentifierIfNeeded(activeServiceWorker-&gt;registrationIdentifier());
 720 #endif
 721     }
 722 
 723     request.setAcceptHeaderIfNone(type);
 724 
 725     // Accept-Language value is handled in underlying port-specific code.
 726     // FIXME: Decide whether to support client hints
 727 }
 728 
 729 void CachedResourceLoader::updateHTTPRequestHeaders(CachedResource::Type type, CachedResourceRequest&amp; request)
 730 {
 731     // Implementing steps 7 to 12 of https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
 732 
 733     // FIXME: We should reconcile handling of MainResource with other resources.
 734     if (type != CachedResource::Type::MainResource) {
 735         // In some cases we may try to load resources in frameless documents. Such loads always fail.
 736         // FIXME: We shouldn&#39;t need to do the check on frame.
 737         if (auto* frame = this-&gt;frame())
 738             request.updateReferrerOriginAndUserAgentHeaders(frame-&gt;loader());
 739     }
 740 
 741     request.updateAccordingCacheMode();
 742     request.updateAcceptEncodingHeader();
 743 }
 744 
 745 static FetchOptions::Destination destinationForType(CachedResource::Type type)
 746 {
 747     switch (type) {
 748     case CachedResource::Type::MainResource:
 749     case CachedResource::Type::SVGDocumentResource:
 750         return FetchOptions::Destination::Document;
 751     case CachedResource::Type::ImageResource:
 752     case CachedResource::Type::Icon:
 753         return FetchOptions::Destination::Image;
 754     case CachedResource::Type::CSSStyleSheet:
 755         return FetchOptions::Destination::Style;
 756     case CachedResource::Type::Script:
 757         return FetchOptions::Destination::Script;
 758     case CachedResource::Type::FontResource:
 759 #if ENABLE(SVG_FONTS)
 760     case CachedResource::Type::SVGFontResource:
 761 #endif
 762         return FetchOptions::Destination::Font;
 763 #if ENABLE(XSLT)
 764     case CachedResource::Type::XSLStyleSheet:
 765         return FetchOptions::Destination::Xslt;
 766 #endif
 767 #if ENABLE(VIDEO_TRACK)
 768     case CachedResource::Type::TextTrackResource:
 769         return FetchOptions::Destination::Track;
 770 #endif
 771 #if ENABLE(APPLICATION_MANIFEST)
 772     case CachedResource::Type::ApplicationManifest:
 773         return FetchOptions::Destination::Manifest;
 774 #endif
 775     case CachedResource::Type::Beacon:
 776     case CachedResource::Type::Ping:
 777     case CachedResource::Type::LinkPrefetch:
 778     case CachedResource::Type::RawResource:
 779     case CachedResource::Type::MediaResource:
 780         // The caller is responsible for setting the appropriate destination.
 781         return FetchOptions::Destination::EmptyString;
 782     }
 783     ASSERT_NOT_REACHED();
 784     return FetchOptions::Destination::EmptyString;
 785 }
 786 
 787 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, ForPreload forPreload, DeferOption defer)
 788 {
 789     request.setDestinationIfNotSet(destinationForType(type));
 790 
 791     // Entry point to https://fetch.spec.whatwg.org/#main-fetch.
 792     std::unique_ptr&lt;ResourceRequest&gt; originalRequest;
 793     if (CachedResource::shouldUsePingLoad(type) || request.options().destination == FetchOptions::Destination::EmptyString) {
 794         originalRequest = makeUnique&lt;ResourceRequest&gt;(request.resourceRequest());
 795         originalRequest-&gt;clearHTTPReferrer();
 796         originalRequest-&gt;clearHTTPOrigin();
 797     }
 798 
 799     if (Document* document = this-&gt;document())
 800         request.upgradeInsecureRequestIfNeeded(*document);
 801 
 802     request.updateReferrerPolicy(document() ? document()-&gt;referrerPolicy() : ReferrerPolicy::NoReferrerWhenDowngrade);
 803     URL url = request.resourceRequest().url();
 804 
 805     LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource &#39;%.255s&#39;, charset &#39;%s&#39;, priority=%d, forPreload=%u&quot;, url.stringCenterEllipsizedToLength().latin1().data(), request.charset().latin1().data(), request.priority() ? static_cast&lt;int&gt;(request.priority().value()) : -1, forPreload == ForPreload::Yes);
 806 
 807     if (!url.isValid()) {
 808         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: URL is invalid (frame = %p)&quot;, frame());
 809         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;URL is invalid&quot;_s });
 810     }
 811 
 812     prepareFetch(type, request);
 813 
 814     // We are passing url as well as request, as request url may contain a fragment identifier.
 815     if (!canRequest(type, url, request, forPreload)) {
 816         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Not allowed to request resource (frame = %p)&quot;, frame());
 817         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Not allowed to request resource&quot;_s, ResourceError::Type::AccessControl });
 818     }
 819 
 820 #if ENABLE(CONTENT_EXTENSIONS)
 821     if (frame() &amp;&amp; frame()-&gt;page() &amp;&amp; m_documentLoader) {
 822         const auto&amp; resourceRequest = request.resourceRequest();
 823         auto* page = frame()-&gt;page();
 824         auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(resourceRequest.url(), ContentExtensions::toResourceType(type), *m_documentLoader);
 825         bool blockedLoad = results.summary.blockedLoad;
 826         bool madeHTTPS = results.summary.madeHTTPS;
 827         request.applyResults(WTFMove(results), page);
 828         if (blockedLoad) {
 829             RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Resource blocked by content blocker (frame = %p)&quot;, frame());
 830             if (type == CachedResource::Type::MainResource) {
 831                 CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());
 832                 ASSERT(resource);
 833                 resource-&gt;error(CachedResource::Status::LoadError);
 834                 resource-&gt;setResourceError(ResourceError(ContentExtensions::WebKitContentBlockerDomain, 0, resourceRequest.url(), WEB_UI_STRING(&quot;The URL was blocked by a content blocker&quot;, &quot;WebKitErrorBlockedByContentBlocker description&quot;)));
 835                 return resource;
 836             }
 837             return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Resource blocked by content blocker&quot;_s, ResourceError::Type::AccessControl });
 838         }
 839         if (madeHTTPS
 840             &amp;&amp; type == CachedResource::Type::MainResource
 841             &amp;&amp; m_documentLoader-&gt;isLoadingMainResource()) {
 842             // This is to make sure the correct &#39;new&#39; URL shows in the location bar.
 843             m_documentLoader-&gt;frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 844         }
 845         url = request.resourceRequest().url(); // The content extension could have changed it from http to https.
 846         url = MemoryCache::removeFragmentIdentifierIfNeeded(url); // Might need to remove fragment identifier again.
 847     }
 848 #endif
 849 
 850     if (frame() &amp;&amp; m_documentLoader &amp;&amp; !m_documentLoader-&gt;customHeaderFields().isEmpty()) {
 851         bool sameOriginRequest = false;
 852         auto requestedOrigin = SecurityOrigin::create(url);
 853         if (type == CachedResource::Type::MainResource) {
 854             if (frame()-&gt;isMainFrame())
 855                 sameOriginRequest = true;
 856             else if (auto* topDocument = frame()-&gt;mainFrame().document())
 857                 sameOriginRequest = topDocument-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 858         } else if (document()) {
 859             sameOriginRequest = document()-&gt;topDocument().securityOrigin().isSameSchemeHostPort(requestedOrigin.get())
 860                 &amp;&amp; document()-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 861         }
 862         for (auto&amp; fields : m_documentLoader-&gt;customHeaderFields()) {
 863             if (sameOriginRequest || fields.thirdPartyDomainsMatch(url)) {
 864                 for (auto&amp; field : fields.fields)
 865                     request.resourceRequest().setHTTPHeaderField(field.name(), field.value());
 866             }
 867         }
 868     }
 869 
 870     LoadTiming loadTiming;
 871     loadTiming.markStartTimeAndFetchStart();
 872     InitiatorContext initiatorContext = request.options().initiatorContext;
 873 
 874     if (request.resourceRequest().url().protocolIsInHTTPFamily())
 875         updateHTTPRequestHeaders(type, request);
 876 
 877     auto&amp; memoryCache = MemoryCache::singleton();
 878     if (request.allowsCaching() &amp;&amp; memoryCache.disabled())
 879         m_documentResources.remove(url.string());
 880 
 881     // See if we can use an existing resource from the cache.
 882     CachedResourceHandle&lt;CachedResource&gt; resource;
 883     if (document())
 884         request.setDomainForCachePartition(*document());
 885 
 886     if (request.allowsCaching())
 887         resource = memoryCache.resourceForRequest(request.resourceRequest(), sessionID());
 888 
 889     if (resource &amp;&amp; request.isLinkPreload() &amp;&amp; !resource-&gt;isLinkPreload())
 890         resource-&gt;setLinkPreload();
 891 
 892     logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheUsageKey(), resource ? DiagnosticLoggingKeys::inMemoryCacheKey() : DiagnosticLoggingKeys::notInMemoryCacheKey());
 893 
 894     auto* cookieJar = document() &amp;&amp; document()-&gt;page() ? &amp;document()-&gt;page()-&gt;cookieJar() : nullptr;
 895 
 896     RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);
 897     switch (policy) {
 898     case Reload:
 899         memoryCache.remove(*resource);
 900         FALLTHROUGH;
 901     case Load:
 902         if (resource)
 903             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());
 904         resource = loadResource(type, WTFMove(request), cookieJar);
 905         break;
 906     case Revalidate:
 907         if (resource)
 908             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());
 909         resource = revalidateResource(WTFMove(request), *resource);
 910         break;
 911     case Use:
 912         ASSERT(resource);
 913         if (request.options().mode == FetchOptions::Mode::NoCors) {
 914             if (auto error = validateCrossOriginResourcePolicy(*request.origin(), request.resourceRequest().url(), resource-&gt;response()))
 915                 return makeUnexpected(WTFMove(*error));
 916         }
 917         if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) {
 918             resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request), document()-&gt;page()-&gt;sessionID(), cookieJar);
 919             if (resource-&gt;status() != CachedResource::Status::Cached)
 920                 policy = Load;
 921         } else {
 922             ResourceError error;
 923             if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))
 924                 return makeUnexpected(WTFMove(error));
 925             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());
 926             loadTiming.setResponseEnd(MonotonicTime::now());
 927 
 928             memoryCache.resourceAccessed(*resource);
 929 
 930             if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) {
 931                 auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());
 932                 if (initiatorContext == InitiatorContext::Worker) {
 933                     ASSERT(is&lt;CachedRawResource&gt;(resource.get()));
 934                     downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));
 935                 } else {
 936                     ASSERT(initiatorContext == InitiatorContext::Document);
 937                     m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());
 938                     m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));
 939                 }
 940             }
 941 
 942             if (forPreload == ForPreload::No)
 943                 resource-&gt;setLoadPriority(request.priority());
 944         }
 945         break;
 946     }
 947     ASSERT(resource);
 948     resource-&gt;setOriginalRequest(WTFMove(originalRequest));
 949 
 950     if (forPreload == ForPreload::No &amp;&amp; resource-&gt;loader() &amp;&amp; resource-&gt;ignoreForRequestCount()) {
 951         resource-&gt;setIgnoreForRequestCount(false);
 952         incrementRequestCount(*resource);
 953     }
 954 
 955     if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; defer == DeferOption::NoDefer) {
 956         resource-&gt;load(*this);
 957 
 958         // We don&#39;t support immediate loads, but we do support immediate failure.
 959         if (resource-&gt;errorOccurred()) {
 960             if (resource-&gt;allowsCaching() &amp;&amp; resource-&gt;inCache())
 961                 memoryCache.remove(*resource);
 962 
 963             auto resourceError = resource-&gt;resourceError();
 964             // Synchronous cancellations are likely due to access control.
 965             if (resourceError.isNull() || resourceError.isCancellation())
 966                 return makeUnexpected(ResourceError { String(), 0, url, String(), ResourceError::Type::AccessControl });
 967             return makeUnexpected(resourceError);
 968         }
 969     }
 970 
 971     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; !resource-&gt;resourceRequest().url().protocolIsData())
 972         m_validatedURLs.add(resource-&gt;resourceRequest().url());
 973 
 974     ASSERT(resource-&gt;url() == url.string());
 975     m_documentResources.set(resource-&gt;url(), resource);
 976     return resource;
 977 }
 978 
 979 void CachedResourceLoader::documentDidFinishLoadEvent()
 980 {
 981     m_validatedURLs.clear();
 982 
 983     // If m_preloads is not empty here, it&#39;s full of link preloads,
 984     // as speculative preloads were cleared at DCL.
 985     if (m_preloads &amp;&amp; m_preloads-&gt;size() &amp;&amp; !m_unusedPreloadsTimer.isActive())
 986         m_unusedPreloadsTimer.startOneShot(unusedPreloadTimeout);
 987 }
 988 
 989 void CachedResourceLoader::stopUnusedPreloadsTimer()
 990 {
 991     m_unusedPreloadsTimer.stop();
 992 }
 993 
 994 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::revalidateResource(CachedResourceRequest&amp;&amp; request, CachedResource&amp; resource)
 995 {
 996     ASSERT(resource.inCache());
 997     auto&amp; memoryCache = MemoryCache::singleton();
 998     ASSERT(!memoryCache.disabled());
 999     ASSERT(resource.canUseCacheValidator());
1000     ASSERT(!resource.resourceToRevalidate());
1001     ASSERT(resource.sessionID() == sessionID());
1002     ASSERT(resource.allowsCaching());
1003 
1004     CachedResourceHandle&lt;CachedResource&gt; newResource = createResource(resource.type(), WTFMove(request), resource.sessionID(), resource.cookieJar());
1005 
1006     LOG(ResourceLoading, &quot;Resource %p created to revalidate %p&quot;, newResource.get(), &amp;resource);
1007     newResource-&gt;setResourceToRevalidate(&amp;resource);
1008 
1009     memoryCache.remove(resource);
1010     memoryCache.add(*newResource);
1011 
1012     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1013         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(newResource, newResource-&gt;initiatorName(), frame());
1014 
1015     return newResource;
1016 }
1017 
1018 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::loadResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const CookieJar* cookieJar)
1019 {
1020     auto&amp; memoryCache = MemoryCache::singleton();
1021     ASSERT(!request.allowsCaching() || !memoryCache.resourceForRequest(request.resourceRequest(), sessionID())
1022         || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData);
1023 
1024     LOG(ResourceLoading, &quot;Loading CachedResource for &#39;%s&#39;.&quot;, request.resourceRequest().url().stringCenterEllipsizedToLength().latin1().data());
1025 
1026     CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), sessionID(), cookieJar);
1027 
1028     if (resource-&gt;allowsCaching())
1029         memoryCache.add(*resource);
1030 
1031     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1032         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, resource-&gt;initiatorName(), frame());
1033 
1034     return resource;
1035 }
1036 
1037 static void logRevalidation(const String&amp; reason, DiagnosticLoggingClient&amp; logClient)
1038 {
1039     logClient.logDiagnosticMessage(DiagnosticLoggingKeys::cachedResourceRevalidationReasonKey(), reason, ShouldSample::Yes);
1040 }
1041 
1042 static void logResourceRevalidationDecision(CachedResource::RevalidationDecision reason, const Frame* frame)
1043 {
1044     if (!frame || !frame-&gt;page())
1045         return;
1046     auto&amp; logClient = frame-&gt;page()-&gt;diagnosticLoggingClient();
1047     switch (reason) {
1048     case CachedResource::RevalidationDecision::No:
1049         break;
1050     case CachedResource::RevalidationDecision::YesDueToExpired:
1051         logRevalidation(DiagnosticLoggingKeys::isExpiredKey(), logClient);
1052         break;
1053     case CachedResource::RevalidationDecision::YesDueToNoStore:
1054         logRevalidation(DiagnosticLoggingKeys::noStoreKey(), logClient);
1055         break;
1056     case CachedResource::RevalidationDecision::YesDueToNoCache:
1057         logRevalidation(DiagnosticLoggingKeys::noCacheKey(), logClient);
1058         break;
1059     case CachedResource::RevalidationDecision::YesDueToCachePolicy:
1060         logRevalidation(DiagnosticLoggingKeys::reloadKey(), logClient);
1061         break;
1062     }
1063 }
1064 
1065 CachedResourceLoader::RevalidationPolicy CachedResourceLoader::determineRevalidationPolicy(CachedResource::Type type, CachedResourceRequest&amp; cachedResourceRequest, CachedResource* existingResource, ForPreload forPreload, DeferOption defer) const
1066 {
1067     auto&amp; request = cachedResourceRequest.resourceRequest();
1068 
1069     if (!existingResource)
1070         return Load;
1071 
1072     if (request.cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData)
1073         return Load;
1074 
1075     if (request.cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData)
1076         return Reload;
1077 
1078 #if ENABLE(SERVICE_WORKER)
1079     // FIXME: We should validate/specify this behavior.
1080     if (cachedResourceRequest.options().serviceWorkerRegistrationIdentifier != existingResource-&gt;options().serviceWorkerRegistrationIdentifier) {
1081         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading because selected service worker differs&quot;);
1082         return Reload;
1083     }
1084 #endif
1085 
1086     // We already have a preload going for this URL.
1087     if (forPreload == ForPreload::Yes &amp;&amp; existingResource-&gt;isPreloaded())
1088         return Use;
1089 
1090     // If the same URL has been loaded as a different type, we need to reload.
1091     if (existingResource-&gt;type() != type) {
1092         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to type mismatch.&quot;);
1093         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonTypeMismatchKey());
1094         return Reload;
1095     }
1096 
1097     if (!existingResource-&gt;varyHeaderValuesMatch(request))
1098         return Reload;
1099 
1100     auto* textDecoder = existingResource-&gt;textResourceDecoder();
1101     if (textDecoder &amp;&amp; !textDecoder-&gt;hasEqualEncodingForCharset(cachedResourceRequest.charset())) {
1102         if (!existingResource-&gt;hasUnknownEncoding())
1103             return Reload;
1104         existingResource-&gt;setHasUnknownEncoding(false);
1105         existingResource-&gt;setEncoding(cachedResourceRequest.charset());
1106     }
1107 
1108     // FIXME: We should use the same cache policy for all resource types. The raw resource policy is overly strict
1109     //        while the normal subresource policy is too loose.
1110     if (existingResource-&gt;isMainOrMediaOrIconOrRawResource() &amp;&amp; frame()) {
1111         bool strictPolicyDisabled = frame()-&gt;loader().isStrictRawResourceValidationPolicyDisabledForTesting();
1112         bool canReuseRawResource = strictPolicyDisabled || downcast&lt;CachedRawResource&gt;(*existingResource).canReuse(request);
1113         if (!canReuseRawResource)
1114             return Reload;
1115     }
1116 
1117     // Conditional requests should have failed canReuse check.
1118     ASSERT(!request.isConditional());
1119 
1120     // Do not load from cache if images are not enabled. The load for this image will be blocked in CachedImage::load.
1121     if (defer == DeferOption::DeferredByClient)
1122         return Reload;
1123 
1124     // Don&#39;t reload resources while pasting or if cache mode allows stale resources.
1125     if (m_allowStaleResources || cachedResourceRequest.options().cache == FetchOptions::Cache::ForceCache || cachedResourceRequest.options().cache == FetchOptions::Cache::OnlyIfCached)
1126         return Use;
1127 
1128     ASSERT(cachedResourceRequest.options().cache == FetchOptions::Cache::Default || cachedResourceRequest.options().cache == FetchOptions::Cache::NoCache);
1129 
1130     // Always use preloads.
1131     if (existingResource-&gt;isPreloaded())
1132         return Use;
1133 
1134     // We can find resources that are being validated from cache only when validation is just successfully completing.
1135     if (existingResource-&gt;validationCompleting())
1136         return Use;
1137     ASSERT(!existingResource-&gt;validationInProgress());
1138 
1139     auto cachePolicy = this-&gt;cachePolicy(type, request.url());
1140 
1141     // Validate the redirect chain.
1142     bool cachePolicyIsHistoryBuffer = cachePolicy == CachePolicyHistoryBuffer;
1143     if (!existingResource-&gt;redirectChainAllowsReuse(cachePolicyIsHistoryBuffer ? ReuseExpiredRedirection : DoNotReuseExpiredRedirection)) {
1144         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to not cached or expired redirections.&quot;);
1145         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonRedirectChainKey());
1146         return Reload;
1147     }
1148 
1149     // CachePolicyHistoryBuffer uses the cache except if this is a main resource with &quot;cache-control: no-store&quot;.
1150     if (cachePolicyIsHistoryBuffer) {
1151         // FIXME: Ignoring &quot;cache-control: no-cache&quot; for sub-resources on history navigation but not the main
1152         // resource is inconsistent. We should probably harmonize this.
1153         if (!existingResource-&gt;response().cacheControlContainsNoStore() || type != CachedResource::Type::MainResource)
1154             return Use;
1155     }
1156 
1157     // Don&#39;t reuse resources with Cache-control: no-store.
1158     if (existingResource-&gt;response().cacheControlContainsNoStore()) {
1159         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to Cache-control: no-store.&quot;);
1160         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonNoStoreKey());
1161         return Reload;
1162     }
1163 
1164     // If credentials were sent with the previous request and won&#39;t be
1165     // with this one, or vice versa, re-fetch the resource.
1166     //
1167     // This helps with the case where the server sends back
1168     // &quot;Access-Control-Allow-Origin: *&quot; all the time, but some of the
1169     // client&#39;s requests are made without CORS and some with.
1170     if (existingResource-&gt;resourceRequest().allowCookies() != request.allowCookies() || existingResource-&gt;options().credentials != cachedResourceRequest.options().credentials) {
1171         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to difference in credentials settings.&quot;);
1172         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonCredentialSettingsKey());
1173         return Reload;
1174     }
1175 
1176     // During the initial load, avoid loading the same resource multiple times for a single document, even if the cache policies would tell us to.
1177     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; m_validatedURLs.contains(existingResource-&gt;url()))
1178         return Use;
1179 
1180     // CachePolicyReload always reloads
1181     if (cachePolicy == CachePolicyReload) {
1182         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to CachePolicyReload.&quot;);
1183         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonReloadKey());
1184         return Reload;
1185     }
1186 
1187     // We&#39;ll try to reload the resource if it failed last time.
1188     if (existingResource-&gt;errorOccurred()) {
1189         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicye reloading due to resource being in the error state&quot;);
1190         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonErrorKey());
1191         return Reload;
1192     }
1193 
1194     if (existingResource-&gt;isLoading()) {
1195         // Do not use cached main resources that are still loading because sharing
1196         // loading CachedResources in this case causes issues with regards to cancellation.
1197         // If one of the DocumentLoader clients decides to cancel the load, then the load
1198         // would be cancelled for all other DocumentLoaders as well.
1199         if (type == CachedResource::Type::MainResource)
1200             return Reload;
1201         // For cached subresources that are still loading we ignore the cache policy.
1202         return Use;
1203     }
1204 
1205     auto revalidationDecision = existingResource-&gt;makeRevalidationDecision(cachePolicy);
1206     logResourceRevalidationDecision(revalidationDecision, frame());
1207 
1208     // Check if the cache headers requires us to revalidate (cache expiration for example).
1209     if (revalidationDecision != CachedResource::RevalidationDecision::No) {
1210         // See if the resource has usable ETag or Last-modified headers.
1211         if (existingResource-&gt;canUseCacheValidator())
1212             return Revalidate;
1213 
1214         // No, must reload.
1215         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to missing cache validators.&quot;);
1216         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonMustRevalidateNoValidatorKey());
1217         return Reload;
1218     }
1219 
1220     return Use;
1221 }
1222 
1223 void CachedResourceLoader::printAccessDeniedMessage(const URL&amp; url) const
1224 {
1225     if (url.isNull())
1226         return;
1227 
1228     if (!frame())
1229         return;
1230 
1231     String message;
1232     if (!m_document || m_document-&gt;url().isNull())
1233         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &#39;.&#39;);
1234     else
1235         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &quot; from origin &quot;, m_document-&gt;origin(), &quot;. Domains, protocols and ports must match.\n&quot;);
1236 
1237     frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
1238 }
1239 
1240 void CachedResourceLoader::setAutoLoadImages(bool enable)
1241 {
1242     if (enable == m_autoLoadImages)
1243         return;
1244 
1245     m_autoLoadImages = enable;
1246 
1247     if (!m_autoLoadImages)
1248         return;
1249 
1250     reloadImagesIfNotDeferred();
1251 }
1252 
1253 void CachedResourceLoader::setImagesEnabled(bool enable)
1254 {
1255     if (enable == m_imagesEnabled)
1256         return;
1257 
1258     m_imagesEnabled = enable;
1259 
1260     if (!m_imagesEnabled)
1261         return;
1262 
1263     reloadImagesIfNotDeferred();
1264 }
1265 
1266 bool CachedResourceLoader::clientDefersImage(const URL&amp;) const
1267 {
1268     return !m_imagesEnabled;
1269 }
1270 
1271 bool CachedResourceLoader::shouldPerformImageLoad(const URL&amp; url) const
1272 {
1273     return m_autoLoadImages || url.protocolIsData();
1274 }
1275 
1276 bool CachedResourceLoader::shouldDeferImageLoad(const URL&amp; url) const
1277 {
1278     return clientDefersImage(url) || !shouldPerformImageLoad(url);
1279 }
1280 
1281 void CachedResourceLoader::reloadImagesIfNotDeferred()
1282 {
1283     for (auto&amp; resource : m_documentResources.values()) {
1284         if (is&lt;CachedImage&gt;(*resource) &amp;&amp; resource-&gt;stillNeedsLoad() &amp;&amp; !clientDefersImage(resource-&gt;url()))
1285             downcast&lt;CachedImage&gt;(*resource).load(*this);
1286     }
1287 }
1288 
1289 CachePolicy CachedResourceLoader::cachePolicy(CachedResource::Type type, const URL&amp; url) const
1290 {
1291     Frame* frame = this-&gt;frame();
1292     if (!frame)
1293         return CachePolicyVerify;
1294 
1295     if (type != CachedResource::Type::MainResource)
1296         return frame-&gt;loader().subresourceCachePolicy(url);
1297 
1298     if (Page* page = frame-&gt;page()) {
1299         if (page-&gt;isResourceCachingDisabled())
1300             return CachePolicyReload;
1301     }
1302 
1303     switch (frame-&gt;loader().loadType()) {
1304     case FrameLoadType::ReloadFromOrigin:
1305     case FrameLoadType::Reload:
1306         return CachePolicyReload;
1307     case FrameLoadType::Back:
1308     case FrameLoadType::Forward:
1309     case FrameLoadType::IndexedBackForward:
1310         // Do not revalidate cached main resource on back/forward navigation.
1311         return CachePolicyHistoryBuffer;
1312     default:
1313         return CachePolicyVerify;
1314     }
1315 }
1316 
1317 void CachedResourceLoader::loadDone(LoadCompletionType type, bool shouldPerformPostLoadActions)
1318 {
1319     RefPtr&lt;DocumentLoader&gt; protectDocumentLoader(m_documentLoader);
1320     RefPtr&lt;Document&gt; protectDocument(m_document.get());
1321 
1322     ASSERT(shouldPerformPostLoadActions || type == LoadCompletionType::Cancel);
1323 
1324     if (frame())
1325         frame()-&gt;loader().loadDone(type);
1326 
1327     if (shouldPerformPostLoadActions)
1328         performPostLoadActions();
1329 
1330     if (!m_garbageCollectDocumentResourcesTimer.isActive())
1331         m_garbageCollectDocumentResourcesTimer.startOneShot(0_s);
1332 }
1333 
1334 // Garbage collecting m_documentResources is a workaround for the
1335 // CachedResourceHandles on the RHS being strong references. Ideally this
1336 // would be a weak map, however CachedResourceHandles perform additional
1337 // bookkeeping on CachedResources, so instead pseudo-GC them -- when the
1338 // reference count reaches 1, m_documentResources is the only reference, so
1339 // remove it from the map.
1340 void CachedResourceLoader::garbageCollectDocumentResources()
1341 {
1342     LOG(ResourceLoading, &quot;CachedResourceLoader %p garbageCollectDocumentResources&quot;, this);
1343 
1344     typedef Vector&lt;String, 10&gt; StringVector;
1345     StringVector resourcesToDelete;
1346 
1347     for (auto&amp; resource : m_documentResources) {
1348         LOG(ResourceLoading, &quot;  cached resource %p - hasOneHandle %d&quot;, resource.value.get(), resource.value-&gt;hasOneHandle());
1349 
1350         if (resource.value-&gt;hasOneHandle())
1351             resourcesToDelete.append(resource.key);
1352     }
1353 
1354     for (auto&amp; resource : resourcesToDelete)
1355         m_documentResources.remove(resource);
1356 }
1357 
1358 void CachedResourceLoader::performPostLoadActions()
1359 {
1360     platformStrategies()-&gt;loaderStrategy()-&gt;servePendingRequests();
1361 }
1362 
1363 void CachedResourceLoader::incrementRequestCount(const CachedResource&amp; resource)
1364 {
1365     if (resource.ignoreForRequestCount())
1366         return;
1367 
1368     ++m_requestCount;
1369 }
1370 
1371 void CachedResourceLoader::decrementRequestCount(const CachedResource&amp; resource)
1372 {
1373     if (resource.ignoreForRequestCount())
1374         return;
1375 
1376     --m_requestCount;
1377     ASSERT(m_requestCount &gt; -1);
1378 }
1379 
1380 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::preload(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
1381 {
1382     if (request.charset().isEmpty() &amp;&amp; (type == CachedResource::Type::Script || type == CachedResource::Type::CSSStyleSheet))
1383         request.setCharset(m_document-&gt;charset());
1384 
1385     auto resource = requestResource(type, WTFMove(request), ForPreload::Yes);
1386     if (resource &amp;&amp; (!m_preloads || !m_preloads-&gt;contains(resource.value().get()))) {
1387         auto resourceValue = resource.value();
1388         // Fonts need special treatment since just creating the resource doesn&#39;t trigger a load.
1389         if (type == CachedResource::Type::FontResource)
1390             downcast&lt;CachedFont&gt;(resourceValue.get())-&gt;beginLoadIfNeeded(*this);
1391         resourceValue-&gt;increasePreloadCount();
1392 
1393         if (!m_preloads)
1394             m_preloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1395         m_preloads-&gt;add(resourceValue.get());
1396     }
1397     return resource;
1398 }
1399 
1400 void CachedResourceLoader::warnUnusedPreloads()
1401 {
1402     if (!m_preloads)
1403         return;
1404     for (const auto&amp; resource : *m_preloads) {
1405         if (resource &amp;&amp; resource-&gt;isLinkPreload() &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced &amp;&amp; document()) {
1406             document()-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Warning,
1407                 &quot;The resource &quot; + resource-&gt;url().string() +
1408                 &quot; was preloaded using link preload but not used within a few seconds from the window&#39;s load event. Please make sure it wasn&#39;t preloaded for nothing.&quot;);
1409         }
1410     }
1411 }
1412 
1413 bool CachedResourceLoader::isPreloaded(const String&amp; urlString) const
1414 {
1415     const URL&amp; url = m_document-&gt;completeURL(urlString);
1416 
1417     if (m_preloads) {
1418         for (auto&amp; resource : *m_preloads) {
1419             if (resource-&gt;url() == url)
1420                 return true;
1421         }
1422     }
1423     return false;
1424 }
1425 
1426 void CachedResourceLoader::clearPreloads(ClearPreloadsMode mode)
1427 {
1428     if (!m_preloads)
1429         return;
1430 
1431     std::unique_ptr&lt;ListHashSet&lt;CachedResource*&gt;&gt; remainingLinkPreloads;
1432     for (auto* resource : *m_preloads) {
1433         ASSERT(resource);
1434         if (mode == ClearPreloadsMode::ClearSpeculativePreloads &amp;&amp; resource-&gt;isLinkPreload()) {
1435             if (!remainingLinkPreloads)
1436                 remainingLinkPreloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1437             remainingLinkPreloads-&gt;add(resource);
1438             continue;
1439         }
1440         resource-&gt;decreasePreloadCount();
1441         bool deleted = resource-&gt;deleteIfPossible();
1442         if (!deleted &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced)
1443             MemoryCache::singleton().remove(*resource);
1444     }
1445     m_preloads = WTFMove(remainingLinkPreloads);
1446 }
1447 
1448 const ResourceLoaderOptions&amp; CachedResourceLoader::defaultCachedResourceOptions()
1449 {
1450     static NeverDestroyed&lt;ResourceLoaderOptions&gt; options(
1451         SendCallbackPolicy::SendCallbacks,
1452         ContentSniffingPolicy::SniffContent,
1453         DataBufferingPolicy::BufferData,
1454         StoredCredentialsPolicy::Use,
1455         ClientCredentialPolicy::MayAskClientForCredentials,
1456         FetchOptions::Credentials::Include,
1457         SecurityCheckPolicy::DoSecurityCheck,
1458         FetchOptions::Mode::NoCors,
1459         CertificateInfoPolicy::DoNotIncludeCertificateInfo,
1460         ContentSecurityPolicyImposition::DoPolicyCheck,
1461         DefersLoadingPolicy::AllowDefersLoading,
1462         CachingPolicy::AllowCaching);
1463     return options;
1464 }
1465 
1466 bool CachedResourceLoader::isAlwaysOnLoggingAllowed() const
1467 {
1468     return m_documentLoader ? m_documentLoader-&gt;isAlwaysOnLoggingAllowed() : true;
1469 }
1470 
1471 }
    </pre>
  </body>
</html>