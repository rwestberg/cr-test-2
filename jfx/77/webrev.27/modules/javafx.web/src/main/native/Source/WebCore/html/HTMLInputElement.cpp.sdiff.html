<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLInputElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLImageLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLInputElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLInputElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  66 #include &quot;TextControlInnerElements.h&quot;
  67 #include &lt;wtf/IsoMallocInlines.h&gt;
  68 #include &lt;wtf/Language.h&gt;
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/Ref.h&gt;
  71 
  72 #if ENABLE(TOUCH_EVENTS)
  73 #include &quot;TouchEvent.h&quot;
  74 #endif
  75 
  76 namespace WebCore {
  77 
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLInputElement);
  79 
  80 using namespace HTMLNames;
  81 
  82 #if ENABLE(DATALIST_ELEMENT)
  83 class ListAttributeTargetObserver : IdTargetObserver {
  84     WTF_MAKE_FAST_ALLOCATED;
  85 public:
<span class="line-modified">  86     ListAttributeTargetObserver(const AtomicString&amp; id, HTMLInputElement*);</span>
  87 
  88     void idTargetChanged() override;
  89 
  90 private:
  91     HTMLInputElement* m_element;
  92 };
  93 #endif
  94 
  95 // FIXME: According to HTML4, the length attribute&#39;s value can be arbitrarily
  96 // large. However, due to https://bugs.webkit.org/show_bug.cgi?id=14536 things
  97 // get rather sluggish when a text field has a larger number of characters than
  98 // this, even when just clicking in the text field.
  99 const unsigned HTMLInputElement::maxEffectiveLength = 524288;
 100 const int defaultSize = 20;
 101 const int maxSavedResults = 256;
 102 
 103 HTMLInputElement::HTMLInputElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 104     : HTMLTextFormControlElement(tagName, document, form)
 105     , m_size(defaultSize)
 106     , m_isChecked(false)
 107     , m_dirtyCheckednessFlag(false)
 108     , m_isIndeterminate(false)
 109     , m_hasType(false)
 110     , m_isActivatedSubmit(false)
 111     , m_autocomplete(Uninitialized)
 112     , m_isAutoFilled(false)

 113     , m_autoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 114     , m_lastAutoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 115     , m_isAutoFillAvailable(false)
 116 #if ENABLE(DATALIST_ELEMENT)
 117     , m_hasNonEmptyList(false)
 118 #endif
 119     , m_stateRestored(false)
 120     , m_parsingInProgress(createdByParser)
 121     , m_valueAttributeWasUpdatedAfterParsing(false)
 122     , m_wasModifiedByUser(false)
 123     , m_canReceiveDroppedFiles(false)
 124 #if ENABLE(TOUCH_EVENTS)
 125     , m_hasTouchEventHandler(false)
 126 #endif
 127     , m_isSpellcheckDisabledExceptTextReplacement(false)
 128 {
 129     // m_inputType is lazily created when constructed by the parser to avoid constructing unnecessarily a text inputType and
 130     // its shadow subtree, just to destroy them when the |type| attribute gets set by the parser to something else than &#39;text&#39;.
 131     if (!createdByParser)
 132         m_inputType = InputType::createText(*this);
 133 
 134     ASSERT(hasTagName(inputTag));
 135     setHasCustomStyleResolveCallbacks();
 136 }
 137 
 138 Ref&lt;HTMLInputElement&gt; HTMLInputElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 139 {
 140     bool shouldCreateShadowRootLazily = createdByParser;
 141     Ref&lt;HTMLInputElement&gt; inputElement = adoptRef(*new HTMLInputElement(tagName, document, form, createdByParser));
 142     if (!shouldCreateShadowRootLazily)
 143         inputElement-&gt;ensureUserAgentShadowRoot();
 144     return inputElement;
 145 }
 146 
 147 HTMLImageLoader&amp; HTMLInputElement::ensureImageLoader()
 148 {
 149     if (!m_imageLoader)
<span class="line-modified"> 150         m_imageLoader = std::make_unique&lt;HTMLImageLoader&gt;(*this);</span>
 151     return *m_imageLoader;
 152 }
 153 
 154 void HTMLInputElement::didAddUserAgentShadowRoot(ShadowRoot&amp;)
 155 {
 156     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 157     protectedInputType-&gt;createShadowSubtree();
 158     updateInnerTextElementEditability();
 159 }
 160 
 161 HTMLInputElement::~HTMLInputElement()
 162 {
 163     if (needsSuspensionCallback())
 164         document().unregisterForDocumentSuspensionCallbacks(*this);
 165 
 166     // Need to remove form association while this is still an HTMLInputElement
 167     // so that virtual functions are called correctly.
<span class="line-modified"> 168     setForm(0);</span>
<span class="line-modified"> 169     // setForm(0) may register this to a document-level radio button group.</span>
<span class="line-modified"> 170     // We should unregister it to avoid accessing a deleted object.</span>



 171     if (isRadioButton())
 172         document().formController().radioButtonGroups().removeButton(*this);

 173 #if ENABLE(TOUCH_EVENTS)
 174     if (m_hasTouchEventHandler)
 175         document().didRemoveEventTargetNode(*this);
 176 #endif
 177 }
 178 
<span class="line-modified"> 179 const AtomicString&amp; HTMLInputElement::name() const</span>
 180 {
 181     return m_name.isNull() ? emptyAtom() : m_name;
 182 }
 183 
 184 Vector&lt;FileChooserFileInfo&gt; HTMLInputElement::filesFromFileInputFormControlState(const FormControlState&amp; state)
 185 {
 186     return FileInputType::filesFromFormControlState(state);
 187 }
 188 
 189 HTMLElement* HTMLInputElement::containerElement() const
 190 {
 191     return m_inputType-&gt;containerElement();
 192 }
 193 
 194 RefPtr&lt;TextControlInnerTextElement&gt; HTMLInputElement::innerTextElement() const
 195 {
 196     return m_inputType-&gt;innerTextElement();
 197 }
 198 
 199 HTMLElement* HTMLInputElement::innerBlockElement() const
</pre>
<hr />
<pre>
 413 ExceptionOr&lt;void&gt; HTMLInputElement::stepDown(int n)
 414 {
 415     return m_inputType-&gt;stepUp(-n);
 416 }
 417 
 418 void HTMLInputElement::blur()
 419 {
 420     m_inputType-&gt;blur();
 421 }
 422 
 423 void HTMLInputElement::defaultBlur()
 424 {
 425     HTMLTextFormControlElement::blur();
 426 }
 427 
 428 bool HTMLInputElement::hasCustomFocusLogic() const
 429 {
 430     return m_inputType-&gt;hasCustomFocusLogic();
 431 }
 432 





 433 bool HTMLInputElement::isKeyboardFocusable(KeyboardEvent* event) const
 434 {
 435     return m_inputType-&gt;isKeyboardFocusable(event);
 436 }
 437 
 438 bool HTMLInputElement::isMouseFocusable() const
 439 {
 440     return m_inputType-&gt;isMouseFocusable();
 441 }
 442 





 443 bool HTMLInputElement::isTextFormControlFocusable() const
 444 {
 445     return HTMLTextFormControlElement::isFocusable();
 446 }
 447 
 448 bool HTMLInputElement::isTextFormControlKeyboardFocusable(KeyboardEvent* event) const
 449 {
 450     return HTMLTextFormControlElement::isKeyboardFocusable(event);
 451 }
 452 
 453 bool HTMLInputElement::isTextFormControlMouseFocusable() const
 454 {
 455     return HTMLTextFormControlElement::isMouseFocusable();
 456 }
 457 
 458 void HTMLInputElement::updateFocusAppearance(SelectionRestorationMode restorationMode, SelectionRevealMode revealMode)
 459 {
 460     if (isTextField()) {
 461         if (restorationMode == SelectionRestorationMode::SetDefault || !hasCachedSelection())
 462             setDefaultSelectionAfterFocus(revealMode);
</pre>
<hr />
<pre>
 486 
 487     if (RefPtr&lt;Frame&gt; frame = document().frame())
 488         frame-&gt;editor().textFieldDidEndEditing(this);
 489 }
 490 
 491 bool HTMLInputElement::shouldUseInputMethod()
 492 {
 493     return m_inputType-&gt;shouldUseInputMethod();
 494 }
 495 
 496 void HTMLInputElement::handleFocusEvent(Node* oldFocusedNode, FocusDirection direction)
 497 {
 498     m_inputType-&gt;handleFocusEvent(oldFocusedNode, direction);
 499 }
 500 
 501 void HTMLInputElement::handleBlurEvent()
 502 {
 503     m_inputType-&gt;handleBlurEvent();
 504 }
 505 
<span class="line-modified"> 506 void HTMLInputElement::setType(const AtomicString&amp; type)</span>
 507 {
 508     setAttributeWithoutSynchronization(typeAttr, type);
 509 }
 510 
 511 void HTMLInputElement::resignStrongPasswordAppearance()
 512 {
 513     if (!hasAutoFillStrongPasswordButton())
 514         return;
 515     setAutoFilled(false);

 516     setShowAutoFillButton(AutoFillButtonType::None);
 517     if (auto* page = document().page())
 518         page-&gt;chrome().client().inputElementDidResignStrongPasswordAppearance(*this);
 519 }
 520 
 521 void HTMLInputElement::updateType()
 522 {
 523     ASSERT(m_inputType);
 524     auto newType = InputType::create(*this, attributeWithoutSynchronization(typeAttr));
 525     m_hasType = true;
 526     if (m_inputType-&gt;formControlType() == newType-&gt;formControlType())
 527         return;
 528 
 529     removeFromRadioButtonGroup();
 530     resignStrongPasswordAppearance();
 531 
 532     bool didStoreValue = m_inputType-&gt;storesValueSeparateFromAttribute();
 533     bool willStoreValue = newType-&gt;storesValueSeparateFromAttribute();
 534     bool neededSuspensionCallback = needsSuspensionCallback();
 535     bool didRespectHeightAndWidth = m_inputType-&gt;shouldRespectHeightAndWidthAttributes();
</pre>
<hr />
<pre>
 598     if (renderer())
 599         invalidateStyleAndRenderersForSubtree();
 600 
 601     if (document().focusedElement() == this)
 602         updateFocusAppearance(SelectionRestorationMode::Restore, SelectionRevealMode::Reveal);
 603 
 604     setChangedSinceLastFormControlChangeEvent(false);
 605 
 606     addToRadioButtonGroup();
 607 
 608     updateValidity();
 609 }
 610 
 611 void HTMLInputElement::subtreeHasChanged()
 612 {
 613     m_inputType-&gt;subtreeHasChanged();
 614     // When typing in an input field, childrenChanged is not called, so we need to force the directionality check.
 615     calculateAndAdjustDirectionality();
 616 }
 617 
<span class="line-modified"> 618 const AtomicString&amp; HTMLInputElement::formControlType() const</span>
 619 {
 620     return m_inputType-&gt;formControlType();
 621 }
 622 
 623 bool HTMLInputElement::shouldSaveAndRestoreFormControlState() const
 624 {
 625     if (!m_inputType-&gt;shouldSaveAndRestoreFormControlState())
 626         return false;
 627     return HTMLTextFormControlElement::shouldSaveAndRestoreFormControlState();
 628 }
 629 
 630 FormControlState HTMLInputElement::saveFormControlState() const
 631 {
 632     return m_inputType-&gt;saveFormControlState();
 633 }
 634 
 635 void HTMLInputElement::restoreFormControlState(const FormControlState&amp; state)
 636 {
 637     m_inputType-&gt;restoreFormControlState(state);
 638     m_stateRestored = true;
</pre>
<hr />
<pre>
 646 }
 647 
 648 bool HTMLInputElement::canHaveSelection() const
 649 {
 650     return isTextField();
 651 }
 652 
 653 void HTMLInputElement::accessKeyAction(bool sendMouseEvents)
 654 {
 655     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 656     protectedInputType-&gt;accessKeyAction(sendMouseEvents);
 657 }
 658 
 659 bool HTMLInputElement::isPresentationAttribute(const QualifiedName&amp; name) const
 660 {
 661     if (name == vspaceAttr || name == hspaceAttr || name == widthAttr || name == heightAttr || (name == borderAttr &amp;&amp; isImageButton()))
 662         return true;
 663     return HTMLTextFormControlElement::isPresentationAttribute(name);
 664 }
 665 
<span class="line-modified"> 666 void HTMLInputElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
 667 {
 668     if (name == vspaceAttr) {
 669         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
 670         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
 671     } else if (name == hspaceAttr) {
 672         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
 673         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
 674     } else if (name == alignAttr) {
 675         if (m_inputType-&gt;shouldRespectAlignAttribute())
 676             applyAlignmentAttributeToStyle(value, style);
 677     } else if (name == widthAttr) {
 678         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 679             addHTMLLengthToStyle(style, CSSPropertyWidth, value);
 680     } else if (name == heightAttr) {
 681         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 682             addHTMLLengthToStyle(style, CSSPropertyHeight, value);
 683     } else if (name == borderAttr &amp;&amp; isImageButton())
 684         applyBorderAttributeToStyle(value, style);
 685     else
 686         HTMLTextFormControlElement::collectStyleForPresentationAttribute(name, value, style);
 687 }
 688 
 689 inline void HTMLInputElement::initializeInputType()
 690 {
 691     ASSERT(m_parsingInProgress);
 692     ASSERT(!m_inputType);
 693 
<span class="line-modified"> 694     const AtomicString&amp; type = attributeWithoutSynchronization(typeAttr);</span>
 695     if (type.isNull()) {
 696         m_inputType = InputType::createText(*this);
 697         ensureUserAgentShadowRoot();
 698         setNeedsWillValidateCheck();
 699         return;
 700     }
 701 
 702     m_hasType = true;
 703     m_inputType = InputType::create(*this, type);
 704     ensureUserAgentShadowRoot();
 705     setNeedsWillValidateCheck();
 706     registerForSuspensionCallbackIfNeeded();
 707     runPostTypeUpdateTasks();
 708 }
 709 
<span class="line-modified"> 710 void HTMLInputElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 711 {
 712     ASSERT(m_inputType);
 713     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 714 
 715     if (name == nameAttr) {
 716         removeFromRadioButtonGroup();
 717         m_name = value;
 718         addToRadioButtonGroup();
 719         HTMLTextFormControlElement::parseAttribute(name, value);
 720     } else if (name == autocompleteAttr) {
 721         if (equalLettersIgnoringASCIICase(value, &quot;off&quot;)) {
 722             m_autocomplete = Off;
 723             registerForSuspensionCallbackIfNeeded();
 724         } else {
 725             bool needsToUnregister = m_autocomplete == Off;
 726 
 727             if (value.isEmpty())
 728                 m_autocomplete = Uninitialized;
 729             else
 730                 m_autocomplete = On;
</pre>
<hr />
<pre>
 894     return m_isActivatedSubmit;
 895 }
 896 
 897 void HTMLInputElement::setActivatedSubmit(bool flag)
 898 {
 899     m_isActivatedSubmit = flag;
 900 }
 901 
 902 bool HTMLInputElement::appendFormData(DOMFormData&amp; formData, bool multipart)
 903 {
 904     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 905     return m_inputType-&gt;isFormDataAppendable() &amp;&amp; m_inputType-&gt;appendFormData(formData, multipart);
 906 }
 907 
 908 void HTMLInputElement::reset()
 909 {
 910     if (m_inputType-&gt;storesValueSeparateFromAttribute())
 911         setValue(String());
 912 
 913     setAutoFilled(false);

 914     setShowAutoFillButton(AutoFillButtonType::None);
 915     setChecked(hasAttributeWithoutSynchronization(checkedAttr));
 916     m_dirtyCheckednessFlag = false;
 917 }
 918 
 919 bool HTMLInputElement::isTextField() const
 920 {
 921     return m_inputType-&gt;isTextField();
 922 }
 923 
 924 bool HTMLInputElement::isTextType() const
 925 {
 926     return m_inputType-&gt;isTextType();
 927 }
 928 
 929 void HTMLInputElement::setChecked(bool nowChecked)
 930 {
 931     if (checked() == nowChecked)
 932         return;
 933 
</pre>
<hr />
<pre>
1132     m_inputType-&gt;elementDidBlur();
1133 }
1134 
1135 void HTMLInputElement::defaultEventHandler(Event&amp; event)
1136 {
1137     if (is&lt;MouseEvent&gt;(event) &amp;&amp; event.type() == eventNames().clickEvent &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1138         m_inputType-&gt;handleClickEvent(downcast&lt;MouseEvent&gt;(event));
1139         if (event.defaultHandled())
1140             return;
1141     }
1142 
1143 #if ENABLE(TOUCH_EVENTS)
1144     if (is&lt;TouchEvent&gt;(event)) {
1145         m_inputType-&gt;handleTouchEvent(downcast&lt;TouchEvent&gt;(event));
1146         if (event.defaultHandled())
1147             return;
1148     }
1149 #endif
1150 
1151     if (is&lt;KeyboardEvent&gt;(event) &amp;&amp; event.type() == eventNames().keydownEvent) {
<span class="line-modified">1152         m_inputType-&gt;handleKeydownEvent(downcast&lt;KeyboardEvent&gt;(event));</span>
<span class="line-modified">1153         if (event.defaultHandled())</span>
1154             return;
1155     }
1156 
1157     // Call the base event handler before any of our own event handling for almost all events in text fields.
1158     // Makes editing keyboard handling take precedence over the keydown and keypress handling in this function.
1159     bool callBaseClassEarly = isTextField() &amp;&amp; (event.type() == eventNames().keydownEvent || event.type() == eventNames().keypressEvent);
1160     if (callBaseClassEarly) {
1161         HTMLTextFormControlElement::defaultEventHandler(event);
1162         if (event.defaultHandled())
1163             return;
1164     }
1165 
1166     // DOMActivate events cause the input to be &quot;activated&quot; - in the case of image and submit inputs, this means
1167     // actually submitting the form. For reset inputs, the form is reset. These events are sent when the user clicks
1168     // on the element, or presses enter while it is the active element. JavaScript code wishing to activate the element
1169     // must dispatch a DOMActivate event - a click event will not do the job.
1170     if (event.type() == eventNames().DOMActivateEvent) {
1171         m_inputType-&gt;handleDOMActivateEvent(event);
1172         if (event.defaultHandled())
1173             return;
</pre>
<hr />
<pre>
1322     if (!size)
1323         return Exception { IndexSizeError };
1324     setUnsignedIntegralAttribute(sizeAttr, limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(size, defaultSize));
1325     return { };
1326 }
1327 
1328 URL HTMLInputElement::src() const
1329 {
1330     return document().completeURL(attributeWithoutSynchronization(srcAttr));
1331 }
1332 
1333 void HTMLInputElement::setAutoFilled(bool autoFilled)
1334 {
1335     if (autoFilled == m_isAutoFilled)
1336         return;
1337 
1338     m_isAutoFilled = autoFilled;
1339     invalidateStyleForSubtree();
1340 }
1341 









1342 void HTMLInputElement::setShowAutoFillButton(AutoFillButtonType autoFillButtonType)
1343 {
1344     if (static_cast&lt;uint8_t&gt;(autoFillButtonType) == m_autoFillButtonType)
1345         return;
1346 
1347     m_lastAutoFillButtonType = m_autoFillButtonType;
1348     m_autoFillButtonType = static_cast&lt;uint8_t&gt;(autoFillButtonType);
1349     m_inputType-&gt;updateAutoFillButton();
1350     updateInnerTextElementEditability();
1351     invalidateStyleForSubtree();
1352 }
1353 
1354 FileList* HTMLInputElement::files()
1355 {
1356     return m_inputType-&gt;files();
1357 }
1358 
1359 void HTMLInputElement::setFiles(RefPtr&lt;FileList&gt;&amp;&amp; files)
1360 {
1361     m_inputType-&gt;setFiles(WTFMove(files));
</pre>
<hr />
<pre>
1468     // The type of the input element could have changed during event handling. If we are no longer
1469     // a search field, don&#39;t try to do search things.
1470     if (!isSearchField())
1471         return;
1472 
1473     if (m_inputType)
1474         downcast&lt;SearchInputType&gt;(*m_inputType.get()).stopSearchEventTimer();
1475     dispatchEvent(Event::create(eventNames().searchEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
1476 }
1477 
1478 void HTMLInputElement::resumeFromDocumentSuspension()
1479 {
1480     ASSERT(needsSuspensionCallback());
1481 
1482 #if ENABLE(INPUT_TYPE_COLOR)
1483     // &lt;input type=color&gt; uses prepareForDocumentSuspension to detach the color picker UI,
1484     // so it should not be reset when being loaded from page cache.
1485     if (isColorControl())
1486         return;
1487 #endif // ENABLE(INPUT_TYPE_COLOR)
<span class="line-modified">1488     reset();</span>


1489 }
1490 
1491 #if ENABLE(INPUT_TYPE_COLOR)
1492 void HTMLInputElement::prepareForDocumentSuspension()
1493 {
1494     if (!isColorControl())
1495         return;
1496     m_inputType-&gt;detach();
1497 }
1498 #endif // ENABLE(INPUT_TYPE_COLOR)
1499 
1500 
1501 void HTMLInputElement::willChangeForm()
1502 {
1503     removeFromRadioButtonGroup();
1504     HTMLTextFormControlElement::willChangeForm();
1505 }
1506 
1507 void HTMLInputElement::didChangeForm()
1508 {
</pre>
<hr />
<pre>
1530 {
1531     if (removalType.disconnectedFromDocument &amp;&amp; !form())
1532         removeFromRadioButtonGroup();
1533     HTMLTextFormControlElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
1534     ASSERT(!isConnected());
1535 #if ENABLE(DATALIST_ELEMENT)
1536     resetListAttributeTargetObserver();
1537 #endif
1538 }
1539 
1540 void HTMLInputElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
1541 {
1542     if (imageLoader())
1543         imageLoader()-&gt;elementDidMoveToNewDocument();
1544 
1545     // Always unregister for cache callbacks when leaving a document, even if we would otherwise like to be registered
1546     if (needsSuspensionCallback()) {
1547         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
1548         newDocument.registerForDocumentSuspensionCallbacks(*this);
1549     }



1550     if (isRadioButton())
1551         oldDocument.formController().radioButtonGroups().removeButton(*this);

1552 #if ENABLE(TOUCH_EVENTS)
1553     if (m_hasTouchEventHandler) {
1554         oldDocument.didRemoveEventTargetNode(*this);
1555         newDocument.didAddTouchEventHandler(*this);
1556     }
1557 #endif
1558 
1559     HTMLTextFormControlElement::didMoveToNewDocument(oldDocument, newDocument);
1560 }
1561 
1562 void HTMLInputElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1563 {
1564     HTMLTextFormControlElement::addSubresourceAttributeURLs(urls);
1565 
1566     addSubresourceURL(urls, src());
1567 }
1568 
1569 bool HTMLInputElement::computeWillValidate() const
1570 {
1571     return m_inputType-&gt;supportsValidation() &amp;&amp; HTMLTextFormControlElement::computeWillValidate();
</pre>
<hr />
<pre>
1602 }
1603 
1604 RefPtr&lt;HTMLDataListElement&gt; HTMLInputElement::dataList() const
1605 {
1606     if (!m_hasNonEmptyList)
1607         return nullptr;
1608 
1609     if (!m_inputType-&gt;shouldRespectListAttribute())
1610         return nullptr;
1611 
1612     RefPtr&lt;Element&gt; element = treeScope().getElementById(attributeWithoutSynchronization(listAttr));
1613     if (!is&lt;HTMLDataListElement&gt;(element))
1614         return nullptr;
1615 
1616     return downcast&lt;HTMLDataListElement&gt;(element.get());
1617 }
1618 
1619 void HTMLInputElement::resetListAttributeTargetObserver()
1620 {
1621     if (isConnected())
<span class="line-modified">1622         m_listAttributeTargetObserver = std::make_unique&lt;ListAttributeTargetObserver&gt;(attributeWithoutSynchronization(listAttr), this);</span>
1623     else
1624         m_listAttributeTargetObserver = nullptr;
1625 }
1626 
1627 void HTMLInputElement::listAttributeTargetChanged()
1628 {
1629     m_inputType-&gt;listAttributeTargetChanged();
1630 }
1631 
1632 #endif // ENABLE(DATALIST_ELEMENT)
1633 
1634 bool HTMLInputElement::isPresentingAttachedView() const
1635 {
1636     return m_inputType-&gt;isPresentingAttachedView();
1637 }
1638 
1639 bool HTMLInputElement::isSteppable() const
1640 {
1641     return m_inputType-&gt;isSteppable();
1642 }
</pre>
<hr />
<pre>
1773 bool HTMLInputElement::shouldAppearChecked() const
1774 {
1775     return checked() &amp;&amp; m_inputType-&gt;isCheckable();
1776 }
1777 
1778 bool HTMLInputElement::supportsPlaceholder() const
1779 {
1780     return m_inputType-&gt;supportsPlaceholder();
1781 }
1782 
1783 void HTMLInputElement::updatePlaceholderText()
1784 {
1785     return m_inputType-&gt;updatePlaceholderText();
1786 }
1787 
1788 bool HTMLInputElement::isEmptyValue() const
1789 {
1790     return m_inputType-&gt;isEmptyValue();
1791 }
1792 
<span class="line-modified">1793 void HTMLInputElement::maxLengthAttributeChanged(const AtomicString&amp; newValue)</span>
1794 {
1795     unsigned oldEffectiveMaxLength = effectiveMaxLength();
1796     internalSetMaxLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1797     if (oldEffectiveMaxLength != effectiveMaxLength())
1798         updateValueIfNeeded();
1799 
1800     // FIXME: Do we really need to do this if the effective maxLength has not changed?
1801     invalidateStyleForSubtree();
1802     updateValidity();
1803 }
1804 
<span class="line-modified">1805 void HTMLInputElement::minLengthAttributeChanged(const AtomicString&amp; newValue)</span>
1806 {
1807     int oldMinLength = minLength();
1808     internalSetMinLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1809     if (oldMinLength != minLength())
1810         updateValueIfNeeded();
1811 
1812     // FIXME: Do we really need to do this if the effective minLength has not changed?
1813     invalidateStyleForSubtree();
1814     updateValidity();
1815 }
1816 
1817 void HTMLInputElement::updateValueIfNeeded()
1818 {
1819     String newValue = sanitizeValue(m_valueIfDirty);
1820     ASSERT(!m_valueIfDirty.isNull() || newValue.isNull());
1821     if (newValue != m_valueIfDirty)
1822         setValue(newValue);
1823 }
1824 
1825 String HTMLInputElement::defaultToolTip() const
</pre>
<hr />
<pre>
1864 bool HTMLInputElement::isInRequiredRadioButtonGroup()
1865 {
1866     ASSERT(isRadioButton());
1867     if (RadioButtonGroups* buttons = radioButtonGroups())
1868         return buttons-&gt;isInRequiredGroup(*this);
1869     return false;
1870 }
1871 
1872 Vector&lt;HTMLInputElement*&gt; HTMLInputElement::radioButtonGroup() const
1873 {
1874     RadioButtonGroups* buttons = radioButtonGroups();
1875     if (!buttons)
1876         return { };
1877     return buttons-&gt;groupMembers(*this);
1878 }
1879 
1880 HTMLInputElement* HTMLInputElement::checkedRadioButtonForGroup() const
1881 {
1882     if (RadioButtonGroups* buttons = radioButtonGroups())
1883         return buttons-&gt;checkedButtonForGroup(name());
<span class="line-modified">1884     return 0;</span>
1885 }
1886 
1887 RadioButtonGroups* HTMLInputElement::radioButtonGroups() const
1888 {
1889     if (!isRadioButton())
1890         return nullptr;
1891     if (auto* formElement = form())
1892         return &amp;formElement-&gt;radioButtonGroups();
1893     if (isConnected())
1894         return &amp;document().formController().radioButtonGroups();
1895     return nullptr;
1896 }
1897 
1898 inline void HTMLInputElement::addToRadioButtonGroup()
1899 {
1900     if (auto* buttons = radioButtonGroups())
1901         buttons-&gt;addButton(*this);
1902 }
1903 
1904 inline void HTMLInputElement::removeFromRadioButtonGroup()
</pre>
<hr />
<pre>
1911 {
1912     return m_inputType-&gt;height();
1913 }
1914 
1915 unsigned HTMLInputElement::width() const
1916 {
1917     return m_inputType-&gt;width();
1918 }
1919 
1920 void HTMLInputElement::setHeight(unsigned height)
1921 {
1922     setUnsignedIntegralAttribute(heightAttr, height);
1923 }
1924 
1925 void HTMLInputElement::setWidth(unsigned width)
1926 {
1927     setUnsignedIntegralAttribute(widthAttr, width);
1928 }
1929 
1930 #if ENABLE(DATALIST_ELEMENT)
<span class="line-modified">1931 ListAttributeTargetObserver::ListAttributeTargetObserver(const AtomicString&amp; id, HTMLInputElement* element)</span>
1932     : IdTargetObserver(element-&gt;treeScope().idTargetObserverRegistry(), id)
1933     , m_element(element)
1934 {
1935 }
1936 
1937 void ListAttributeTargetObserver::idTargetChanged()
1938 {
1939     m_element-&gt;listAttributeTargetChanged();
1940 }
1941 #endif
1942 
1943 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement)
1944 {
1945     if (!m_inputType-&gt;supportsSelectionAPI())
1946         return Exception { InvalidStateError };
1947 
1948     return HTMLTextFormControlElement::setRangeText(replacement);
1949 }
1950 
1951 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement, unsigned start, unsigned end, const String&amp; selectionMode)
</pre>
<hr />
<pre>
2069     if (textBlockStyle.fontMetrics().lineSpacing() &gt; style.computedLineHeight())
2070         textBlockStyle.setLineHeight(RenderStyle::initialLineHeight());
2071 
2072     return textBlockStyle;
2073 }
2074 
2075 #if ENABLE(DATE_AND_TIME_INPUT_TYPES)
2076 bool HTMLInputElement::setupDateTimeChooserParameters(DateTimeChooserParameters&amp; parameters)
2077 {
2078     if (!document().view())
2079         return false;
2080 
2081     parameters.type = type();
2082     parameters.minimum = minimum();
2083     parameters.maximum = maximum();
2084     parameters.required = isRequired();
2085 
2086     if (!document().settings().langAttributeAwareFormControlUIEnabled())
2087         parameters.locale = defaultLanguage();
2088     else {
<span class="line-modified">2089         AtomicString computedLocale = computeInheritedLanguage();</span>
<span class="line-modified">2090         parameters.locale = computedLocale.isEmpty() ? AtomicString(defaultLanguage()) : computedLocale;</span>
2091     }
2092 
2093     StepRange stepRange = createStepRange(RejectAny);
2094     if (stepRange.hasStep()) {
2095         parameters.step = stepRange.step().toDouble();
2096         parameters.stepBase = stepRange.stepBase().toDouble();
2097     } else {
2098         parameters.step = 1.0;
2099         parameters.stepBase = 0;
2100     }
2101 
2102     if (RenderElement* renderer = this-&gt;renderer())
2103         parameters.anchorRectInRootView = document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
2104     else
2105         parameters.anchorRectInRootView = IntRect();
2106     parameters.currentValue = value();
2107     parameters.isAnchorElementRTL = computedStyle()-&gt;direction() == TextDirection::RTL;
2108 #if ENABLE(DATALIST_ELEMENT)
2109     if (auto dataList = this-&gt;dataList()) {
2110         Ref&lt;HTMLCollection&gt; options = dataList-&gt;options();
</pre>
</td>
<td>
<hr />
<pre>
  66 #include &quot;TextControlInnerElements.h&quot;
  67 #include &lt;wtf/IsoMallocInlines.h&gt;
  68 #include &lt;wtf/Language.h&gt;
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/Ref.h&gt;
  71 
  72 #if ENABLE(TOUCH_EVENTS)
  73 #include &quot;TouchEvent.h&quot;
  74 #endif
  75 
  76 namespace WebCore {
  77 
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLInputElement);
  79 
  80 using namespace HTMLNames;
  81 
  82 #if ENABLE(DATALIST_ELEMENT)
  83 class ListAttributeTargetObserver : IdTargetObserver {
  84     WTF_MAKE_FAST_ALLOCATED;
  85 public:
<span class="line-modified">  86     ListAttributeTargetObserver(const AtomString&amp; id, HTMLInputElement*);</span>
  87 
  88     void idTargetChanged() override;
  89 
  90 private:
  91     HTMLInputElement* m_element;
  92 };
  93 #endif
  94 
  95 // FIXME: According to HTML4, the length attribute&#39;s value can be arbitrarily
  96 // large. However, due to https://bugs.webkit.org/show_bug.cgi?id=14536 things
  97 // get rather sluggish when a text field has a larger number of characters than
  98 // this, even when just clicking in the text field.
  99 const unsigned HTMLInputElement::maxEffectiveLength = 524288;
 100 const int defaultSize = 20;
 101 const int maxSavedResults = 256;
 102 
 103 HTMLInputElement::HTMLInputElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 104     : HTMLTextFormControlElement(tagName, document, form)
 105     , m_size(defaultSize)
 106     , m_isChecked(false)
 107     , m_dirtyCheckednessFlag(false)
 108     , m_isIndeterminate(false)
 109     , m_hasType(false)
 110     , m_isActivatedSubmit(false)
 111     , m_autocomplete(Uninitialized)
 112     , m_isAutoFilled(false)
<span class="line-added"> 113     , m_isAutoFilledAndViewable(false)</span>
 114     , m_autoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 115     , m_lastAutoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 116     , m_isAutoFillAvailable(false)
 117 #if ENABLE(DATALIST_ELEMENT)
 118     , m_hasNonEmptyList(false)
 119 #endif
 120     , m_stateRestored(false)
 121     , m_parsingInProgress(createdByParser)
 122     , m_valueAttributeWasUpdatedAfterParsing(false)
 123     , m_wasModifiedByUser(false)
 124     , m_canReceiveDroppedFiles(false)
 125 #if ENABLE(TOUCH_EVENTS)
 126     , m_hasTouchEventHandler(false)
 127 #endif
 128     , m_isSpellcheckDisabledExceptTextReplacement(false)
 129 {
 130     // m_inputType is lazily created when constructed by the parser to avoid constructing unnecessarily a text inputType and
 131     // its shadow subtree, just to destroy them when the |type| attribute gets set by the parser to something else than &#39;text&#39;.
 132     if (!createdByParser)
 133         m_inputType = InputType::createText(*this);
 134 
 135     ASSERT(hasTagName(inputTag));
 136     setHasCustomStyleResolveCallbacks();
 137 }
 138 
 139 Ref&lt;HTMLInputElement&gt; HTMLInputElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 140 {
 141     bool shouldCreateShadowRootLazily = createdByParser;
 142     Ref&lt;HTMLInputElement&gt; inputElement = adoptRef(*new HTMLInputElement(tagName, document, form, createdByParser));
 143     if (!shouldCreateShadowRootLazily)
 144         inputElement-&gt;ensureUserAgentShadowRoot();
 145     return inputElement;
 146 }
 147 
 148 HTMLImageLoader&amp; HTMLInputElement::ensureImageLoader()
 149 {
 150     if (!m_imageLoader)
<span class="line-modified"> 151         m_imageLoader = makeUnique&lt;HTMLImageLoader&gt;(*this);</span>
 152     return *m_imageLoader;
 153 }
 154 
 155 void HTMLInputElement::didAddUserAgentShadowRoot(ShadowRoot&amp;)
 156 {
 157     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 158     protectedInputType-&gt;createShadowSubtree();
 159     updateInnerTextElementEditability();
 160 }
 161 
 162 HTMLInputElement::~HTMLInputElement()
 163 {
 164     if (needsSuspensionCallback())
 165         document().unregisterForDocumentSuspensionCallbacks(*this);
 166 
 167     // Need to remove form association while this is still an HTMLInputElement
 168     // so that virtual functions are called correctly.
<span class="line-modified"> 169     setForm(nullptr);</span>
<span class="line-modified"> 170 </span>
<span class="line-modified"> 171     // This is needed for a radio button that was not in a form, and also for</span>
<span class="line-added"> 172     // a radio button that was in a form. The call to setForm(nullptr) above</span>
<span class="line-added"> 173     // actually adds the button to the document groups in the latter case.</span>
<span class="line-added"> 174     // That is inelegant, but harmless since we remove it here.</span>
 175     if (isRadioButton())
 176         document().formController().radioButtonGroups().removeButton(*this);
<span class="line-added"> 177 </span>
 178 #if ENABLE(TOUCH_EVENTS)
 179     if (m_hasTouchEventHandler)
 180         document().didRemoveEventTargetNode(*this);
 181 #endif
 182 }
 183 
<span class="line-modified"> 184 const AtomString&amp; HTMLInputElement::name() const</span>
 185 {
 186     return m_name.isNull() ? emptyAtom() : m_name;
 187 }
 188 
 189 Vector&lt;FileChooserFileInfo&gt; HTMLInputElement::filesFromFileInputFormControlState(const FormControlState&amp; state)
 190 {
 191     return FileInputType::filesFromFormControlState(state);
 192 }
 193 
 194 HTMLElement* HTMLInputElement::containerElement() const
 195 {
 196     return m_inputType-&gt;containerElement();
 197 }
 198 
 199 RefPtr&lt;TextControlInnerTextElement&gt; HTMLInputElement::innerTextElement() const
 200 {
 201     return m_inputType-&gt;innerTextElement();
 202 }
 203 
 204 HTMLElement* HTMLInputElement::innerBlockElement() const
</pre>
<hr />
<pre>
 418 ExceptionOr&lt;void&gt; HTMLInputElement::stepDown(int n)
 419 {
 420     return m_inputType-&gt;stepUp(-n);
 421 }
 422 
 423 void HTMLInputElement::blur()
 424 {
 425     m_inputType-&gt;blur();
 426 }
 427 
 428 void HTMLInputElement::defaultBlur()
 429 {
 430     HTMLTextFormControlElement::blur();
 431 }
 432 
 433 bool HTMLInputElement::hasCustomFocusLogic() const
 434 {
 435     return m_inputType-&gt;hasCustomFocusLogic();
 436 }
 437 
<span class="line-added"> 438 int HTMLInputElement::defaultTabIndex() const</span>
<span class="line-added"> 439 {</span>
<span class="line-added"> 440     return 0;</span>
<span class="line-added"> 441 }</span>
<span class="line-added"> 442 </span>
 443 bool HTMLInputElement::isKeyboardFocusable(KeyboardEvent* event) const
 444 {
 445     return m_inputType-&gt;isKeyboardFocusable(event);
 446 }
 447 
 448 bool HTMLInputElement::isMouseFocusable() const
 449 {
 450     return m_inputType-&gt;isMouseFocusable();
 451 }
 452 
<span class="line-added"> 453 bool HTMLInputElement::isInteractiveContent() const</span>
<span class="line-added"> 454 {</span>
<span class="line-added"> 455     return m_inputType-&gt;isInteractiveContent();</span>
<span class="line-added"> 456 }</span>
<span class="line-added"> 457 </span>
 458 bool HTMLInputElement::isTextFormControlFocusable() const
 459 {
 460     return HTMLTextFormControlElement::isFocusable();
 461 }
 462 
 463 bool HTMLInputElement::isTextFormControlKeyboardFocusable(KeyboardEvent* event) const
 464 {
 465     return HTMLTextFormControlElement::isKeyboardFocusable(event);
 466 }
 467 
 468 bool HTMLInputElement::isTextFormControlMouseFocusable() const
 469 {
 470     return HTMLTextFormControlElement::isMouseFocusable();
 471 }
 472 
 473 void HTMLInputElement::updateFocusAppearance(SelectionRestorationMode restorationMode, SelectionRevealMode revealMode)
 474 {
 475     if (isTextField()) {
 476         if (restorationMode == SelectionRestorationMode::SetDefault || !hasCachedSelection())
 477             setDefaultSelectionAfterFocus(revealMode);
</pre>
<hr />
<pre>
 501 
 502     if (RefPtr&lt;Frame&gt; frame = document().frame())
 503         frame-&gt;editor().textFieldDidEndEditing(this);
 504 }
 505 
 506 bool HTMLInputElement::shouldUseInputMethod()
 507 {
 508     return m_inputType-&gt;shouldUseInputMethod();
 509 }
 510 
 511 void HTMLInputElement::handleFocusEvent(Node* oldFocusedNode, FocusDirection direction)
 512 {
 513     m_inputType-&gt;handleFocusEvent(oldFocusedNode, direction);
 514 }
 515 
 516 void HTMLInputElement::handleBlurEvent()
 517 {
 518     m_inputType-&gt;handleBlurEvent();
 519 }
 520 
<span class="line-modified"> 521 void HTMLInputElement::setType(const AtomString&amp; type)</span>
 522 {
 523     setAttributeWithoutSynchronization(typeAttr, type);
 524 }
 525 
 526 void HTMLInputElement::resignStrongPasswordAppearance()
 527 {
 528     if (!hasAutoFillStrongPasswordButton())
 529         return;
 530     setAutoFilled(false);
<span class="line-added"> 531     setAutoFilledAndViewable(false);</span>
 532     setShowAutoFillButton(AutoFillButtonType::None);
 533     if (auto* page = document().page())
 534         page-&gt;chrome().client().inputElementDidResignStrongPasswordAppearance(*this);
 535 }
 536 
 537 void HTMLInputElement::updateType()
 538 {
 539     ASSERT(m_inputType);
 540     auto newType = InputType::create(*this, attributeWithoutSynchronization(typeAttr));
 541     m_hasType = true;
 542     if (m_inputType-&gt;formControlType() == newType-&gt;formControlType())
 543         return;
 544 
 545     removeFromRadioButtonGroup();
 546     resignStrongPasswordAppearance();
 547 
 548     bool didStoreValue = m_inputType-&gt;storesValueSeparateFromAttribute();
 549     bool willStoreValue = newType-&gt;storesValueSeparateFromAttribute();
 550     bool neededSuspensionCallback = needsSuspensionCallback();
 551     bool didRespectHeightAndWidth = m_inputType-&gt;shouldRespectHeightAndWidthAttributes();
</pre>
<hr />
<pre>
 614     if (renderer())
 615         invalidateStyleAndRenderersForSubtree();
 616 
 617     if (document().focusedElement() == this)
 618         updateFocusAppearance(SelectionRestorationMode::Restore, SelectionRevealMode::Reveal);
 619 
 620     setChangedSinceLastFormControlChangeEvent(false);
 621 
 622     addToRadioButtonGroup();
 623 
 624     updateValidity();
 625 }
 626 
 627 void HTMLInputElement::subtreeHasChanged()
 628 {
 629     m_inputType-&gt;subtreeHasChanged();
 630     // When typing in an input field, childrenChanged is not called, so we need to force the directionality check.
 631     calculateAndAdjustDirectionality();
 632 }
 633 
<span class="line-modified"> 634 const AtomString&amp; HTMLInputElement::formControlType() const</span>
 635 {
 636     return m_inputType-&gt;formControlType();
 637 }
 638 
 639 bool HTMLInputElement::shouldSaveAndRestoreFormControlState() const
 640 {
 641     if (!m_inputType-&gt;shouldSaveAndRestoreFormControlState())
 642         return false;
 643     return HTMLTextFormControlElement::shouldSaveAndRestoreFormControlState();
 644 }
 645 
 646 FormControlState HTMLInputElement::saveFormControlState() const
 647 {
 648     return m_inputType-&gt;saveFormControlState();
 649 }
 650 
 651 void HTMLInputElement::restoreFormControlState(const FormControlState&amp; state)
 652 {
 653     m_inputType-&gt;restoreFormControlState(state);
 654     m_stateRestored = true;
</pre>
<hr />
<pre>
 662 }
 663 
 664 bool HTMLInputElement::canHaveSelection() const
 665 {
 666     return isTextField();
 667 }
 668 
 669 void HTMLInputElement::accessKeyAction(bool sendMouseEvents)
 670 {
 671     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 672     protectedInputType-&gt;accessKeyAction(sendMouseEvents);
 673 }
 674 
 675 bool HTMLInputElement::isPresentationAttribute(const QualifiedName&amp; name) const
 676 {
 677     if (name == vspaceAttr || name == hspaceAttr || name == widthAttr || name == heightAttr || (name == borderAttr &amp;&amp; isImageButton()))
 678         return true;
 679     return HTMLTextFormControlElement::isPresentationAttribute(name);
 680 }
 681 
<span class="line-modified"> 682 void HTMLInputElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 683 {
 684     if (name == vspaceAttr) {
 685         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
 686         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
 687     } else if (name == hspaceAttr) {
 688         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
 689         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
 690     } else if (name == alignAttr) {
 691         if (m_inputType-&gt;shouldRespectAlignAttribute())
 692             applyAlignmentAttributeToStyle(value, style);
 693     } else if (name == widthAttr) {
 694         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 695             addHTMLLengthToStyle(style, CSSPropertyWidth, value);
 696     } else if (name == heightAttr) {
 697         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 698             addHTMLLengthToStyle(style, CSSPropertyHeight, value);
 699     } else if (name == borderAttr &amp;&amp; isImageButton())
 700         applyBorderAttributeToStyle(value, style);
 701     else
 702         HTMLTextFormControlElement::collectStyleForPresentationAttribute(name, value, style);
 703 }
 704 
 705 inline void HTMLInputElement::initializeInputType()
 706 {
 707     ASSERT(m_parsingInProgress);
 708     ASSERT(!m_inputType);
 709 
<span class="line-modified"> 710     const AtomString&amp; type = attributeWithoutSynchronization(typeAttr);</span>
 711     if (type.isNull()) {
 712         m_inputType = InputType::createText(*this);
 713         ensureUserAgentShadowRoot();
 714         setNeedsWillValidateCheck();
 715         return;
 716     }
 717 
 718     m_hasType = true;
 719     m_inputType = InputType::create(*this, type);
 720     ensureUserAgentShadowRoot();
 721     setNeedsWillValidateCheck();
 722     registerForSuspensionCallbackIfNeeded();
 723     runPostTypeUpdateTasks();
 724 }
 725 
<span class="line-modified"> 726 void HTMLInputElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
 727 {
 728     ASSERT(m_inputType);
 729     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 730 
 731     if (name == nameAttr) {
 732         removeFromRadioButtonGroup();
 733         m_name = value;
 734         addToRadioButtonGroup();
 735         HTMLTextFormControlElement::parseAttribute(name, value);
 736     } else if (name == autocompleteAttr) {
 737         if (equalLettersIgnoringASCIICase(value, &quot;off&quot;)) {
 738             m_autocomplete = Off;
 739             registerForSuspensionCallbackIfNeeded();
 740         } else {
 741             bool needsToUnregister = m_autocomplete == Off;
 742 
 743             if (value.isEmpty())
 744                 m_autocomplete = Uninitialized;
 745             else
 746                 m_autocomplete = On;
</pre>
<hr />
<pre>
 910     return m_isActivatedSubmit;
 911 }
 912 
 913 void HTMLInputElement::setActivatedSubmit(bool flag)
 914 {
 915     m_isActivatedSubmit = flag;
 916 }
 917 
 918 bool HTMLInputElement::appendFormData(DOMFormData&amp; formData, bool multipart)
 919 {
 920     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 921     return m_inputType-&gt;isFormDataAppendable() &amp;&amp; m_inputType-&gt;appendFormData(formData, multipart);
 922 }
 923 
 924 void HTMLInputElement::reset()
 925 {
 926     if (m_inputType-&gt;storesValueSeparateFromAttribute())
 927         setValue(String());
 928 
 929     setAutoFilled(false);
<span class="line-added"> 930     setAutoFilledAndViewable(false);</span>
 931     setShowAutoFillButton(AutoFillButtonType::None);
 932     setChecked(hasAttributeWithoutSynchronization(checkedAttr));
 933     m_dirtyCheckednessFlag = false;
 934 }
 935 
 936 bool HTMLInputElement::isTextField() const
 937 {
 938     return m_inputType-&gt;isTextField();
 939 }
 940 
 941 bool HTMLInputElement::isTextType() const
 942 {
 943     return m_inputType-&gt;isTextType();
 944 }
 945 
 946 void HTMLInputElement::setChecked(bool nowChecked)
 947 {
 948     if (checked() == nowChecked)
 949         return;
 950 
</pre>
<hr />
<pre>
1149     m_inputType-&gt;elementDidBlur();
1150 }
1151 
1152 void HTMLInputElement::defaultEventHandler(Event&amp; event)
1153 {
1154     if (is&lt;MouseEvent&gt;(event) &amp;&amp; event.type() == eventNames().clickEvent &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1155         m_inputType-&gt;handleClickEvent(downcast&lt;MouseEvent&gt;(event));
1156         if (event.defaultHandled())
1157             return;
1158     }
1159 
1160 #if ENABLE(TOUCH_EVENTS)
1161     if (is&lt;TouchEvent&gt;(event)) {
1162         m_inputType-&gt;handleTouchEvent(downcast&lt;TouchEvent&gt;(event));
1163         if (event.defaultHandled())
1164             return;
1165     }
1166 #endif
1167 
1168     if (is&lt;KeyboardEvent&gt;(event) &amp;&amp; event.type() == eventNames().keydownEvent) {
<span class="line-modified">1169         auto shouldCallBaseEventHandler = m_inputType-&gt;handleKeydownEvent(downcast&lt;KeyboardEvent&gt;(event));</span>
<span class="line-modified">1170         if (event.defaultHandled() || shouldCallBaseEventHandler == InputType::ShouldCallBaseEventHandler::No)</span>
1171             return;
1172     }
1173 
1174     // Call the base event handler before any of our own event handling for almost all events in text fields.
1175     // Makes editing keyboard handling take precedence over the keydown and keypress handling in this function.
1176     bool callBaseClassEarly = isTextField() &amp;&amp; (event.type() == eventNames().keydownEvent || event.type() == eventNames().keypressEvent);
1177     if (callBaseClassEarly) {
1178         HTMLTextFormControlElement::defaultEventHandler(event);
1179         if (event.defaultHandled())
1180             return;
1181     }
1182 
1183     // DOMActivate events cause the input to be &quot;activated&quot; - in the case of image and submit inputs, this means
1184     // actually submitting the form. For reset inputs, the form is reset. These events are sent when the user clicks
1185     // on the element, or presses enter while it is the active element. JavaScript code wishing to activate the element
1186     // must dispatch a DOMActivate event - a click event will not do the job.
1187     if (event.type() == eventNames().DOMActivateEvent) {
1188         m_inputType-&gt;handleDOMActivateEvent(event);
1189         if (event.defaultHandled())
1190             return;
</pre>
<hr />
<pre>
1339     if (!size)
1340         return Exception { IndexSizeError };
1341     setUnsignedIntegralAttribute(sizeAttr, limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(size, defaultSize));
1342     return { };
1343 }
1344 
1345 URL HTMLInputElement::src() const
1346 {
1347     return document().completeURL(attributeWithoutSynchronization(srcAttr));
1348 }
1349 
1350 void HTMLInputElement::setAutoFilled(bool autoFilled)
1351 {
1352     if (autoFilled == m_isAutoFilled)
1353         return;
1354 
1355     m_isAutoFilled = autoFilled;
1356     invalidateStyleForSubtree();
1357 }
1358 
<span class="line-added">1359 void HTMLInputElement::setAutoFilledAndViewable(bool autoFilledAndViewable)</span>
<span class="line-added">1360 {</span>
<span class="line-added">1361     if (autoFilledAndViewable == m_isAutoFilledAndViewable)</span>
<span class="line-added">1362         return;</span>
<span class="line-added">1363 </span>
<span class="line-added">1364     m_isAutoFilledAndViewable = autoFilledAndViewable;</span>
<span class="line-added">1365     invalidateStyleForSubtree();</span>
<span class="line-added">1366 }</span>
<span class="line-added">1367 </span>
1368 void HTMLInputElement::setShowAutoFillButton(AutoFillButtonType autoFillButtonType)
1369 {
1370     if (static_cast&lt;uint8_t&gt;(autoFillButtonType) == m_autoFillButtonType)
1371         return;
1372 
1373     m_lastAutoFillButtonType = m_autoFillButtonType;
1374     m_autoFillButtonType = static_cast&lt;uint8_t&gt;(autoFillButtonType);
1375     m_inputType-&gt;updateAutoFillButton();
1376     updateInnerTextElementEditability();
1377     invalidateStyleForSubtree();
1378 }
1379 
1380 FileList* HTMLInputElement::files()
1381 {
1382     return m_inputType-&gt;files();
1383 }
1384 
1385 void HTMLInputElement::setFiles(RefPtr&lt;FileList&gt;&amp;&amp; files)
1386 {
1387     m_inputType-&gt;setFiles(WTFMove(files));
</pre>
<hr />
<pre>
1494     // The type of the input element could have changed during event handling. If we are no longer
1495     // a search field, don&#39;t try to do search things.
1496     if (!isSearchField())
1497         return;
1498 
1499     if (m_inputType)
1500         downcast&lt;SearchInputType&gt;(*m_inputType.get()).stopSearchEventTimer();
1501     dispatchEvent(Event::create(eventNames().searchEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
1502 }
1503 
1504 void HTMLInputElement::resumeFromDocumentSuspension()
1505 {
1506     ASSERT(needsSuspensionCallback());
1507 
1508 #if ENABLE(INPUT_TYPE_COLOR)
1509     // &lt;input type=color&gt; uses prepareForDocumentSuspension to detach the color picker UI,
1510     // so it should not be reset when being loaded from page cache.
1511     if (isColorControl())
1512         return;
1513 #endif // ENABLE(INPUT_TYPE_COLOR)
<span class="line-modified">1514     document().postTask([inputElement = makeRef(*this)] (ScriptExecutionContext&amp;) {</span>
<span class="line-added">1515         inputElement-&gt;reset();</span>
<span class="line-added">1516     });</span>
1517 }
1518 
1519 #if ENABLE(INPUT_TYPE_COLOR)
1520 void HTMLInputElement::prepareForDocumentSuspension()
1521 {
1522     if (!isColorControl())
1523         return;
1524     m_inputType-&gt;detach();
1525 }
1526 #endif // ENABLE(INPUT_TYPE_COLOR)
1527 
1528 
1529 void HTMLInputElement::willChangeForm()
1530 {
1531     removeFromRadioButtonGroup();
1532     HTMLTextFormControlElement::willChangeForm();
1533 }
1534 
1535 void HTMLInputElement::didChangeForm()
1536 {
</pre>
<hr />
<pre>
1558 {
1559     if (removalType.disconnectedFromDocument &amp;&amp; !form())
1560         removeFromRadioButtonGroup();
1561     HTMLTextFormControlElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
1562     ASSERT(!isConnected());
1563 #if ENABLE(DATALIST_ELEMENT)
1564     resetListAttributeTargetObserver();
1565 #endif
1566 }
1567 
1568 void HTMLInputElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
1569 {
1570     if (imageLoader())
1571         imageLoader()-&gt;elementDidMoveToNewDocument();
1572 
1573     // Always unregister for cache callbacks when leaving a document, even if we would otherwise like to be registered
1574     if (needsSuspensionCallback()) {
1575         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
1576         newDocument.registerForDocumentSuspensionCallbacks(*this);
1577     }
<span class="line-added">1578 </span>
<span class="line-added">1579     // We call this even for radio buttons in forms; it&#39;s harmless because the</span>
<span class="line-added">1580     // removeButton function is written to be safe for buttons not in any group.</span>
1581     if (isRadioButton())
1582         oldDocument.formController().radioButtonGroups().removeButton(*this);
<span class="line-added">1583 </span>
1584 #if ENABLE(TOUCH_EVENTS)
1585     if (m_hasTouchEventHandler) {
1586         oldDocument.didRemoveEventTargetNode(*this);
1587         newDocument.didAddTouchEventHandler(*this);
1588     }
1589 #endif
1590 
1591     HTMLTextFormControlElement::didMoveToNewDocument(oldDocument, newDocument);
1592 }
1593 
1594 void HTMLInputElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1595 {
1596     HTMLTextFormControlElement::addSubresourceAttributeURLs(urls);
1597 
1598     addSubresourceURL(urls, src());
1599 }
1600 
1601 bool HTMLInputElement::computeWillValidate() const
1602 {
1603     return m_inputType-&gt;supportsValidation() &amp;&amp; HTMLTextFormControlElement::computeWillValidate();
</pre>
<hr />
<pre>
1634 }
1635 
1636 RefPtr&lt;HTMLDataListElement&gt; HTMLInputElement::dataList() const
1637 {
1638     if (!m_hasNonEmptyList)
1639         return nullptr;
1640 
1641     if (!m_inputType-&gt;shouldRespectListAttribute())
1642         return nullptr;
1643 
1644     RefPtr&lt;Element&gt; element = treeScope().getElementById(attributeWithoutSynchronization(listAttr));
1645     if (!is&lt;HTMLDataListElement&gt;(element))
1646         return nullptr;
1647 
1648     return downcast&lt;HTMLDataListElement&gt;(element.get());
1649 }
1650 
1651 void HTMLInputElement::resetListAttributeTargetObserver()
1652 {
1653     if (isConnected())
<span class="line-modified">1654         m_listAttributeTargetObserver = makeUnique&lt;ListAttributeTargetObserver&gt;(attributeWithoutSynchronization(listAttr), this);</span>
1655     else
1656         m_listAttributeTargetObserver = nullptr;
1657 }
1658 
1659 void HTMLInputElement::listAttributeTargetChanged()
1660 {
1661     m_inputType-&gt;listAttributeTargetChanged();
1662 }
1663 
1664 #endif // ENABLE(DATALIST_ELEMENT)
1665 
1666 bool HTMLInputElement::isPresentingAttachedView() const
1667 {
1668     return m_inputType-&gt;isPresentingAttachedView();
1669 }
1670 
1671 bool HTMLInputElement::isSteppable() const
1672 {
1673     return m_inputType-&gt;isSteppable();
1674 }
</pre>
<hr />
<pre>
1805 bool HTMLInputElement::shouldAppearChecked() const
1806 {
1807     return checked() &amp;&amp; m_inputType-&gt;isCheckable();
1808 }
1809 
1810 bool HTMLInputElement::supportsPlaceholder() const
1811 {
1812     return m_inputType-&gt;supportsPlaceholder();
1813 }
1814 
1815 void HTMLInputElement::updatePlaceholderText()
1816 {
1817     return m_inputType-&gt;updatePlaceholderText();
1818 }
1819 
1820 bool HTMLInputElement::isEmptyValue() const
1821 {
1822     return m_inputType-&gt;isEmptyValue();
1823 }
1824 
<span class="line-modified">1825 void HTMLInputElement::maxLengthAttributeChanged(const AtomString&amp; newValue)</span>
1826 {
1827     unsigned oldEffectiveMaxLength = effectiveMaxLength();
1828     internalSetMaxLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1829     if (oldEffectiveMaxLength != effectiveMaxLength())
1830         updateValueIfNeeded();
1831 
1832     // FIXME: Do we really need to do this if the effective maxLength has not changed?
1833     invalidateStyleForSubtree();
1834     updateValidity();
1835 }
1836 
<span class="line-modified">1837 void HTMLInputElement::minLengthAttributeChanged(const AtomString&amp; newValue)</span>
1838 {
1839     int oldMinLength = minLength();
1840     internalSetMinLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1841     if (oldMinLength != minLength())
1842         updateValueIfNeeded();
1843 
1844     // FIXME: Do we really need to do this if the effective minLength has not changed?
1845     invalidateStyleForSubtree();
1846     updateValidity();
1847 }
1848 
1849 void HTMLInputElement::updateValueIfNeeded()
1850 {
1851     String newValue = sanitizeValue(m_valueIfDirty);
1852     ASSERT(!m_valueIfDirty.isNull() || newValue.isNull());
1853     if (newValue != m_valueIfDirty)
1854         setValue(newValue);
1855 }
1856 
1857 String HTMLInputElement::defaultToolTip() const
</pre>
<hr />
<pre>
1896 bool HTMLInputElement::isInRequiredRadioButtonGroup()
1897 {
1898     ASSERT(isRadioButton());
1899     if (RadioButtonGroups* buttons = radioButtonGroups())
1900         return buttons-&gt;isInRequiredGroup(*this);
1901     return false;
1902 }
1903 
1904 Vector&lt;HTMLInputElement*&gt; HTMLInputElement::radioButtonGroup() const
1905 {
1906     RadioButtonGroups* buttons = radioButtonGroups();
1907     if (!buttons)
1908         return { };
1909     return buttons-&gt;groupMembers(*this);
1910 }
1911 
1912 HTMLInputElement* HTMLInputElement::checkedRadioButtonForGroup() const
1913 {
1914     if (RadioButtonGroups* buttons = radioButtonGroups())
1915         return buttons-&gt;checkedButtonForGroup(name());
<span class="line-modified">1916     return nullptr;</span>
1917 }
1918 
1919 RadioButtonGroups* HTMLInputElement::radioButtonGroups() const
1920 {
1921     if (!isRadioButton())
1922         return nullptr;
1923     if (auto* formElement = form())
1924         return &amp;formElement-&gt;radioButtonGroups();
1925     if (isConnected())
1926         return &amp;document().formController().radioButtonGroups();
1927     return nullptr;
1928 }
1929 
1930 inline void HTMLInputElement::addToRadioButtonGroup()
1931 {
1932     if (auto* buttons = radioButtonGroups())
1933         buttons-&gt;addButton(*this);
1934 }
1935 
1936 inline void HTMLInputElement::removeFromRadioButtonGroup()
</pre>
<hr />
<pre>
1943 {
1944     return m_inputType-&gt;height();
1945 }
1946 
1947 unsigned HTMLInputElement::width() const
1948 {
1949     return m_inputType-&gt;width();
1950 }
1951 
1952 void HTMLInputElement::setHeight(unsigned height)
1953 {
1954     setUnsignedIntegralAttribute(heightAttr, height);
1955 }
1956 
1957 void HTMLInputElement::setWidth(unsigned width)
1958 {
1959     setUnsignedIntegralAttribute(widthAttr, width);
1960 }
1961 
1962 #if ENABLE(DATALIST_ELEMENT)
<span class="line-modified">1963 ListAttributeTargetObserver::ListAttributeTargetObserver(const AtomString&amp; id, HTMLInputElement* element)</span>
1964     : IdTargetObserver(element-&gt;treeScope().idTargetObserverRegistry(), id)
1965     , m_element(element)
1966 {
1967 }
1968 
1969 void ListAttributeTargetObserver::idTargetChanged()
1970 {
1971     m_element-&gt;listAttributeTargetChanged();
1972 }
1973 #endif
1974 
1975 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement)
1976 {
1977     if (!m_inputType-&gt;supportsSelectionAPI())
1978         return Exception { InvalidStateError };
1979 
1980     return HTMLTextFormControlElement::setRangeText(replacement);
1981 }
1982 
1983 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement, unsigned start, unsigned end, const String&amp; selectionMode)
</pre>
<hr />
<pre>
2101     if (textBlockStyle.fontMetrics().lineSpacing() &gt; style.computedLineHeight())
2102         textBlockStyle.setLineHeight(RenderStyle::initialLineHeight());
2103 
2104     return textBlockStyle;
2105 }
2106 
2107 #if ENABLE(DATE_AND_TIME_INPUT_TYPES)
2108 bool HTMLInputElement::setupDateTimeChooserParameters(DateTimeChooserParameters&amp; parameters)
2109 {
2110     if (!document().view())
2111         return false;
2112 
2113     parameters.type = type();
2114     parameters.minimum = minimum();
2115     parameters.maximum = maximum();
2116     parameters.required = isRequired();
2117 
2118     if (!document().settings().langAttributeAwareFormControlUIEnabled())
2119         parameters.locale = defaultLanguage();
2120     else {
<span class="line-modified">2121         AtomString computedLocale = computeInheritedLanguage();</span>
<span class="line-modified">2122         parameters.locale = computedLocale.isEmpty() ? AtomString(defaultLanguage()) : computedLocale;</span>
2123     }
2124 
2125     StepRange stepRange = createStepRange(RejectAny);
2126     if (stepRange.hasStep()) {
2127         parameters.step = stepRange.step().toDouble();
2128         parameters.stepBase = stepRange.stepBase().toDouble();
2129     } else {
2130         parameters.step = 1.0;
2131         parameters.stepBase = 0;
2132     }
2133 
2134     if (RenderElement* renderer = this-&gt;renderer())
2135         parameters.anchorRectInRootView = document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
2136     else
2137         parameters.anchorRectInRootView = IntRect();
2138     parameters.currentValue = value();
2139     parameters.isAnchorElementRTL = computedStyle()-&gt;direction() == TextDirection::RTL;
2140 #if ENABLE(DATALIST_ELEMENT)
2141     if (auto dataList = this-&gt;dataList()) {
2142         Ref&lt;HTMLCollection&gt; options = dataList-&gt;options();
</pre>
</td>
</tr>
</table>
<center><a href="HTMLImageLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLInputElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>