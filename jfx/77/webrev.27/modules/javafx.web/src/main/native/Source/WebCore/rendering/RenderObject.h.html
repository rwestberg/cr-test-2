<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2004 Allan Sandfeld Jensen (kde@carewolf.com)
   6  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2012 Apple Inc. All rights reserved.
   7  * Copyright (C) 2009 Google Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;CachedImageClient.h&quot;
  29 #include &quot;Element.h&quot;
  30 #include &quot;FloatQuad.h&quot;
  31 #include &quot;Frame.h&quot;
  32 #include &quot;LayoutRect.h&quot;
  33 #include &quot;Page.h&quot;
  34 #include &quot;RenderObjectEnums.h&quot;
  35 #include &quot;RenderStyle.h&quot;
  36 #include &quot;ScrollAlignment.h&quot;
  37 #include &quot;StyleImage.h&quot;
  38 #include &quot;TextAffinity.h&quot;
  39 #include &lt;wtf/IsoMalloc.h&gt;
  40 #include &lt;wtf/WeakPtr.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 class AffineTransform;
  45 class CSSAnimationController;
  46 class Color;
  47 class Cursor;
  48 class Document;
  49 class DocumentTimeline;
  50 class HitTestLocation;
  51 class HitTestRequest;
  52 class HitTestResult;
  53 class InlineBox;
  54 class Path;
  55 class Position;
  56 class PseudoStyleRequest;
  57 class RenderBoxModelObject;
  58 class RenderInline;
  59 class RenderBlock;
  60 class RenderElement;
  61 class RenderFragmentedFlow;
  62 class RenderGeometryMap;
  63 class RenderLayer;
  64 class RenderLayerModelObject;
  65 class RenderFragmentContainer;
  66 class RenderTheme;
  67 class RenderTreeBuilder;
  68 class SelectionRangeData;
  69 class TransformState;
  70 class VisiblePosition;
  71 
  72 #if PLATFORM(IOS_FAMILY)
  73 class SelectionRect;
  74 #endif
  75 
  76 struct PaintInfo;
  77 
  78 #if PLATFORM(IOS_FAMILY)
  79 const int caretWidth = 2; // This value should be kept in sync with UIKit. See &lt;rdar://problem/15580601&gt;.
  80 #else
  81 const int caretWidth = 1;
  82 #endif
  83 
  84 enum class ShouldAllowCrossOriginScrolling { No, Yes };
  85 
  86 struct ScrollRectToVisibleOptions;
  87 
  88 // Base class for all rendering tree objects.
  89 class RenderObject : public CachedImageClient, public CanMakeWeakPtr&lt;RenderObject&gt; {
  90     WTF_MAKE_ISO_ALLOCATED(RenderObject);
  91     friend class RenderBlock;
  92     friend class RenderBlockFlow;
  93     friend class RenderElement;
  94     friend class RenderLayer;
  95 public:
  96     // Anonymous objects should pass the document as their node, and they will then automatically be
  97     // marked as anonymous in the constructor.
  98     explicit RenderObject(Node&amp;);
  99     virtual ~RenderObject();
 100 
 101     RenderTheme&amp; theme() const;
 102 
 103     virtual const char* renderName() const = 0;
 104 
 105     RenderElement* parent() const { return m_parent; }
 106     bool isDescendantOf(const RenderObject*) const;
 107 
 108     RenderObject* previousSibling() const { return m_previous; }
 109     RenderObject* nextSibling() const { return m_next; }
 110 
 111     // Use RenderElement versions instead.
 112     virtual RenderObject* firstChildSlow() const { return nullptr; }
 113     virtual RenderObject* lastChildSlow() const { return nullptr; }
 114 
 115     RenderObject* nextInPreOrder() const;
 116     RenderObject* nextInPreOrder(const RenderObject* stayWithin) const;
 117     RenderObject* nextInPreOrderAfterChildren() const;
 118     RenderObject* nextInPreOrderAfterChildren(const RenderObject* stayWithin) const;
 119     RenderObject* previousInPreOrder() const;
 120     RenderObject* previousInPreOrder(const RenderObject* stayWithin) const;
 121     WEBCORE_EXPORT RenderObject* childAt(unsigned) const;
 122 
 123     RenderObject* firstLeafChild() const;
 124     RenderObject* lastLeafChild() const;
 125 
 126 #if ENABLE(TEXT_AUTOSIZING)
 127     // Minimal distance between the block with fixed height and overflowing content and the text block to apply text autosizing.
 128     // The greater this constant is the more potential places we have where autosizing is turned off.
 129     // So it should be as low as possible. There are sites that break at 2.
 130     static const int TextAutoSizingFixedHeightDepth = 3;
 131 
 132     enum BlockContentHeightType {
 133         FixedHeight,
 134         FlexibleHeight,
 135         OverflowHeight
 136     };
 137 
 138     typedef BlockContentHeightType (*HeightTypeTraverseNextInclusionFunction)(const RenderObject&amp;);
 139     RenderObject* traverseNext(const RenderObject* stayWithin, HeightTypeTraverseNextInclusionFunction, int&amp; currentDepth, int&amp; newFixedDepth) const;
 140 #endif
 141 
 142     WEBCORE_EXPORT RenderLayer* enclosingLayer() const;
 143 
 144     // Scrolling is a RenderBox concept, however some code just cares about recursively scrolling our enclosing ScrollableArea(s).
 145     WEBCORE_EXPORT bool scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 146 
 147     // Convenience function for getting to the nearest enclosing box of a RenderObject.
 148     WEBCORE_EXPORT RenderBox&amp; enclosingBox() const;
 149     RenderBoxModelObject&amp; enclosingBoxModelObject() const;
 150     const RenderBox* enclosingScrollableContainerForSnapping() const;
 151 
 152     // Function to return our enclosing flow thread if we are contained inside one. This
 153     // function follows the containing block chain.
 154     RenderFragmentedFlow* enclosingFragmentedFlow() const
 155     {
 156         if (fragmentedFlowState() == NotInsideFragmentedFlow)
 157             return nullptr;
 158 
 159         return locateEnclosingFragmentedFlow();
 160     }
 161 
 162     WEBCORE_EXPORT bool useDarkAppearance() const;
 163     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
 164 
 165 #ifndef NDEBUG
 166     void setHasAXObject(bool flag) { m_hasAXObject = flag; }
 167     bool hasAXObject() const { return m_hasAXObject; }
 168 
 169     // Helper class forbidding calls to setNeedsLayout() during its lifetime.
 170     class SetLayoutNeededForbiddenScope {
 171     public:
 172         explicit SetLayoutNeededForbiddenScope(RenderObject*, bool isForbidden = true);
 173         ~SetLayoutNeededForbiddenScope();
 174     private:
 175         RenderObject* m_renderObject;
 176         bool m_preexistingForbidden;
 177     };
 178 #endif
 179 
 180     // Obtains the nearest enclosing block (including this block) that contributes a first-line style to our inline
 181     // children.
 182     virtual RenderBlock* firstLineBlock() const;
 183 
 184     // RenderObject tree manipulation
 185     //////////////////////////////////////////
 186     virtual bool canHaveChildren() const = 0;
 187     virtual bool canHaveGeneratedChildren() const;
 188     virtual bool createsAnonymousWrapper() const { return false; }
 189     //////////////////////////////////////////
 190 
 191 #if ENABLE(TREE_DEBUGGING)
 192     void showNodeTreeForThis() const;
 193     void showRenderTreeForThis() const;
 194     void showLineTreeForThis() const;
 195 
 196     void outputRenderObject(WTF::TextStream&amp;, bool mark, int depth) const;
 197     void outputRenderSubTreeAndMark(WTF::TextStream&amp;, const RenderObject* markedObject, int depth) const;
 198     void outputRegionsInformation(WTF::TextStream&amp;) const;
 199 #endif
 200 
 201     bool isPseudoElement() const { return node() &amp;&amp; node()-&gt;isPseudoElement(); }
 202 
 203     bool isRenderElement() const { return !isText(); }
 204     bool isRenderReplaced() const;
 205     bool isBoxModelObject() const;
 206     bool isRenderBlock() const;
 207     bool isRenderBlockFlow() const;
 208     bool isRenderInline() const;
 209     bool isRenderLayerModelObject() const;
 210 
 211     virtual bool isCounter() const { return false; }
 212     virtual bool isQuote() const { return false; }
 213 
 214     virtual bool isDetailsMarker() const { return false; }
 215     virtual bool isEmbeddedObject() const { return false; }
 216     bool isFieldset() const;
 217     virtual bool isFileUploadControl() const { return false; }
 218     virtual bool isFrame() const { return false; }
 219     virtual bool isFrameSet() const { return false; }
 220     virtual bool isImage() const { return false; }
 221     virtual bool isInlineBlockOrInlineTable() const { return false; }
 222     virtual bool isListBox() const { return false; }
 223     virtual bool isListItem() const { return false; }
 224     virtual bool isListMarker() const { return false; }
 225     virtual bool isMedia() const { return false; }
 226     virtual bool isMenuList() const { return false; }
 227 #if ENABLE(METER_ELEMENT)
 228     virtual bool isMeter() const { return false; }
 229 #endif
 230     virtual bool isSnapshottedPlugIn() const { return false; }
 231     virtual bool isProgress() const { return false; }
 232     virtual bool isRenderButton() const { return false; }
 233     virtual bool isRenderIFrame() const { return false; }
 234     virtual bool isRenderImage() const { return false; }
 235     virtual bool isRenderFragmentContainer() const { return false; }
 236     virtual bool isReplica() const { return false; }
 237 
 238     virtual bool isRubyInline() const { return false; }
 239     virtual bool isRubyBlock() const { return false; }
 240     virtual bool isRubyBase() const { return false; }
 241     virtual bool isRubyRun() const { return false; }
 242     virtual bool isRubyText() const { return false; }
 243 
 244     virtual bool isSlider() const { return false; }
 245     virtual bool isSliderThumb() const { return false; }
 246     virtual bool isTable() const { return false; }
 247     virtual bool isTableCell() const { return false; }
 248     virtual bool isRenderTableCol() const { return false; }
 249     virtual bool isTableCaption() const { return false; }
 250     virtual bool isTableRow() const { return false; }
 251     virtual bool isTableSection() const { return false; }
 252     virtual bool isTextControl() const { return false; }
 253     virtual bool isTextArea() const { return false; }
 254     virtual bool isTextField() const { return false; }
 255     virtual bool isSearchField() const { return false; }
 256     virtual bool isTextControlInnerBlock() const { return false; }
 257     virtual bool isVideo() const { return false; }
 258     virtual bool isWidget() const { return false; }
 259     virtual bool isCanvas() const { return false; }
 260 #if ENABLE(ATTACHMENT_ELEMENT)
 261     virtual bool isAttachment() const { return false; }
 262 #endif
 263 #if ENABLE(FULLSCREEN_API)
 264     virtual bool isRenderFullScreen() const { return false; }
 265     virtual bool isRenderFullScreenPlaceholder() const { return false; }
 266 #endif
 267     virtual bool isRenderGrid() const { return false; }
 268     bool isInFlowRenderFragmentedFlow() const { return isRenderFragmentedFlow() &amp;&amp; !isOutOfFlowPositioned(); }
 269     bool isOutOfFlowRenderFragmentedFlow() const { return isRenderFragmentedFlow() &amp;&amp; isOutOfFlowPositioned(); }
 270 
 271     virtual bool isMultiColumnBlockFlow() const { return false; }
 272     virtual bool isRenderMultiColumnSet() const { return false; }
 273     virtual bool isRenderMultiColumnFlow() const { return false; }
 274     virtual bool isRenderMultiColumnSpannerPlaceholder() const { return false; }
 275 
 276     virtual bool isRenderScrollbarPart() const { return false; }
 277 
 278     bool isDocumentElementRenderer() const { return document().documentElement() == &amp;m_node; }
 279     bool isBody() const { return node() &amp;&amp; node()-&gt;hasTagName(HTMLNames::bodyTag); }
 280     bool isHR() const { return node() &amp;&amp; node()-&gt;hasTagName(HTMLNames::hrTag); }
 281     bool isLegend() const;
 282 
 283     bool isHTMLMarquee() const;
 284 
 285     bool isTablePart() const { return isTableCell() || isRenderTableCol() || isTableCaption() || isTableRow() || isTableSection(); }
 286 
 287     inline bool isBeforeContent() const;
 288     inline bool isAfterContent() const;
 289     inline bool isBeforeOrAfterContent() const;
 290     static inline bool isBeforeContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isBeforeContent(); }
 291     static inline bool isAfterContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isAfterContent(); }
 292     static inline bool isBeforeOrAfterContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isBeforeOrAfterContent(); }
 293 
 294     bool beingDestroyed() const { return m_bitfields.beingDestroyed(); }
 295 
 296     bool everHadLayout() const { return m_bitfields.everHadLayout(); }
 297 
 298     bool childrenInline() const { return m_bitfields.childrenInline(); }
 299     void setChildrenInline(bool b) { m_bitfields.setChildrenInline(b); }
 300 
 301     enum FragmentedFlowState {
 302         NotInsideFragmentedFlow = 0,
 303         InsideInFragmentedFlow = 1,
 304     };
 305 
 306     void setFragmentedFlowStateIncludingDescendants(FragmentedFlowState);
 307 
 308     FragmentedFlowState fragmentedFlowState() const { return m_bitfields.fragmentedFlowState(); }
 309     void setFragmentedFlowState(FragmentedFlowState state) { m_bitfields.setFragmentedFlowState(state); }
 310 
 311 #if ENABLE(MATHML)
 312     virtual bool isRenderMathMLBlock() const { return false; }
 313     virtual bool isRenderMathMLTable() const { return false; }
 314     virtual bool isRenderMathMLOperator() const { return false; }
 315     virtual bool isRenderMathMLRow() const { return false; }
 316     virtual bool isRenderMathMLMath() const { return false; }
 317     virtual bool isRenderMathMLMenclose() const { return false; }
 318     virtual bool isRenderMathMLFenced() const { return false; }
 319     virtual bool isRenderMathMLFencedOperator() const { return false; }
 320     virtual bool isRenderMathMLFraction() const { return false; }
 321     virtual bool isRenderMathMLPadded() const { return false; }
 322     virtual bool isRenderMathMLRoot() const { return false; }
 323     virtual bool isRenderMathMLSpace() const { return false; }
 324     virtual bool isRenderMathMLSquareRoot() const { return false; }
 325     virtual bool isRenderMathMLScripts() const { return false; }
 326     virtual bool isRenderMathMLToken() const { return false; }
 327     virtual bool isRenderMathMLUnderOver() const { return false; }
 328 #endif // ENABLE(MATHML)
 329 
 330     // FIXME: Until all SVG renders can be subclasses of RenderSVGModelObject we have
 331     // to add SVG renderer methods to RenderObject with an ASSERT_NOT_REACHED() default implementation.
 332     virtual bool isRenderSVGModelObject() const { return false; }
 333     virtual bool isRenderSVGBlock() const { return false; };
 334     virtual bool isSVGRoot() const { return false; }
 335     virtual bool isSVGContainer() const { return false; }
 336     virtual bool isSVGTransformableContainer() const { return false; }
 337     virtual bool isSVGViewportContainer() const { return false; }
 338     virtual bool isSVGGradientStop() const { return false; }
 339     virtual bool isSVGHiddenContainer() const { return false; }
 340     virtual bool isSVGPath() const { return false; }
 341     virtual bool isSVGShape() const { return false; }
 342     virtual bool isSVGText() const { return false; }
 343     virtual bool isSVGTextPath() const { return false; }
 344     virtual bool isSVGTSpan() const { return false; }
 345     virtual bool isSVGInline() const { return false; }
 346     virtual bool isSVGInlineText() const { return false; }
 347     virtual bool isSVGImage() const { return false; }
 348     virtual bool isSVGForeignObject() const { return false; }
 349     virtual bool isSVGResourceContainer() const { return false; }
 350     virtual bool isSVGResourceFilter() const { return false; }
 351     virtual bool isSVGResourceClipper() const { return false; }
 352     virtual bool isSVGResourceFilterPrimitive() const { return false; }
 353 
 354     // FIXME: Those belong into a SVG specific base-class for all renderers (see above)
 355     // Unfortunately we don&#39;t have such a class yet, because it&#39;s not possible for all renderers
 356     // to inherit from RenderSVGObject -&gt; RenderObject (some need RenderBlock inheritance for instance)
 357     virtual void setNeedsTransformUpdate() { }
 358     virtual void setNeedsBoundariesUpdate();
 359     virtual bool needsBoundariesUpdate() { return false; }
 360 
 361     // Per SVG 1.1 objectBoundingBox ignores clipping, masking, filter effects, opacity and stroke-width.
 362     // This is used for all computation of objectBoundingBox relative units and by SVGLocatable::getBBox().
 363     // NOTE: Markers are not specifically ignored here by SVG 1.1 spec, but we ignore them
 364     // since stroke-width is ignored (and marker size can depend on stroke-width).
 365     // objectBoundingBox is returned local coordinates.
 366     // The name objectBoundingBox is taken from the SVG 1.1 spec.
 367     virtual FloatRect objectBoundingBox() const;
 368     virtual FloatRect strokeBoundingBox() const;
 369 
 370     // Returns the smallest rectangle enclosing all of the painted content
 371     // respecting clipping, masking, filters, opacity, stroke-width and markers
 372     virtual FloatRect repaintRectInLocalCoordinates() const;
 373 
 374     // This only returns the transform=&quot;&quot; value from the element
 375     // most callsites want localToParentTransform() instead.
 376     virtual AffineTransform localTransform() const;
 377 
 378     // Returns the full transform mapping from local coordinates to local coords for the parent SVG renderer
 379     // This includes any viewport transforms and x/y offsets as well as the transform=&quot;&quot; value off the element.
 380     virtual const AffineTransform&amp; localToParentTransform() const;
 381 
 382     // SVG uses FloatPoint precise hit testing, and passes the point in parent
 383     // coordinates instead of in repaint container coordinates.  Eventually the
 384     // rest of the rendering tree will move to a similar model.
 385     virtual bool nodeAtFloatPoint(const HitTestRequest&amp;, HitTestResult&amp;, const FloatPoint&amp; pointInParent, HitTestAction);
 386 
 387     bool hasAspectRatio() const { return isReplaced() &amp;&amp; (isImage() || isVideo() || isCanvas()); }
 388     bool isAnonymous() const { return m_bitfields.isAnonymous(); }
 389     bool isAnonymousBlock() const
 390     {
 391         // This function is kept in sync with anonymous block creation conditions in
 392         // RenderBlock::createAnonymousBlock(). This includes creating an anonymous
 393         // RenderBlock having a DisplayType::Block or DisplayType::Box display. Other classes such as RenderTextFragment
 394         // are not RenderBlocks and will return false. See https://bugs.webkit.org/show_bug.cgi?id=56709.
 395         return isAnonymous() &amp;&amp; (style().display() == DisplayType::Block || style().display() == DisplayType::Box) &amp;&amp; style().styleType() == PseudoId::None &amp;&amp; isRenderBlock() &amp;&amp; !isListMarker() &amp;&amp; !isRenderFragmentedFlow() &amp;&amp; !isRenderMultiColumnSet() &amp;&amp; !isRenderView()
 396 #if ENABLE(FULLSCREEN_API)
 397             &amp;&amp; !isRenderFullScreen()
 398             &amp;&amp; !isRenderFullScreenPlaceholder()
 399 #endif
 400 #if ENABLE(MATHML)
 401             &amp;&amp; !isRenderMathMLBlock()
 402 #endif
 403             ;
 404     }
 405 
 406     bool isFloating() const { return m_bitfields.floating(); }
 407 
 408     bool isPositioned() const { return m_bitfields.isPositioned(); }
 409     bool isInFlowPositioned() const { return m_bitfields.isRelativelyPositioned() || m_bitfields.isStickilyPositioned(); }
 410     bool isOutOfFlowPositioned() const { return m_bitfields.isOutOfFlowPositioned(); } // absolute or fixed positioning
 411     bool isFixedPositioned() const { return isOutOfFlowPositioned() &amp;&amp; style().position() == PositionType::Fixed; }
 412     bool isAbsolutelyPositioned() const { return isOutOfFlowPositioned() &amp;&amp; style().position() == PositionType::Absolute; }
 413     bool isRelativelyPositioned() const { return m_bitfields.isRelativelyPositioned(); }
 414     bool isStickilyPositioned() const { return m_bitfields.isStickilyPositioned(); }
 415 
 416     bool isText() const  { return !m_bitfields.isBox() &amp;&amp; m_bitfields.isTextOrRenderView(); }
 417     bool isLineBreak() const { return m_bitfields.isLineBreak(); }
 418     bool isBR() const { return isLineBreak() &amp;&amp; !isWBR(); }
 419     bool isLineBreakOpportunity() const { return isLineBreak() &amp;&amp; isWBR(); }
 420     bool isTextOrLineBreak() const { return isText() || isLineBreak(); }
 421     bool isBox() const { return m_bitfields.isBox(); }
 422     bool isRenderView() const  { return m_bitfields.isBox() &amp;&amp; m_bitfields.isTextOrRenderView(); }
 423     bool isInline() const { return m_bitfields.isInline(); } // inline object
 424     bool isReplaced() const { return m_bitfields.isReplaced(); } // a &quot;replaced&quot; element (see CSS)
 425     bool isHorizontalWritingMode() const { return m_bitfields.horizontalWritingMode(); }
 426 
 427     bool isDragging() const { return m_bitfields.hasRareData() &amp;&amp; rareData().isDragging(); }
 428     bool hasReflection() const { return m_bitfields.hasRareData() &amp;&amp; rareData().hasReflection(); }
 429     bool isRenderFragmentedFlow() const { return m_bitfields.hasRareData() &amp;&amp; rareData().isRenderFragmentedFlow(); }
 430     bool hasOutlineAutoAncestor() const { return m_bitfields.hasRareData() &amp;&amp; rareData().hasOutlineAutoAncestor(); }
 431 
 432     bool isExcludedFromNormalLayout() const { return m_bitfields.isExcludedFromNormalLayout(); }
 433     void setIsExcludedFromNormalLayout(bool excluded) { m_bitfields.setIsExcludedFromNormalLayout(excluded); }
 434     bool isExcludedAndPlacedInBorder() const { return isExcludedFromNormalLayout() &amp;&amp; isLegend(); }
 435 
 436     bool hasLayer() const { return m_bitfields.hasLayer(); }
 437 
 438     enum BoxDecorationState {
 439         NoBoxDecorations,
 440         HasBoxDecorationsAndBackgroundObscurationStatusInvalid,
 441         HasBoxDecorationsAndBackgroundIsKnownToBeObscured,
 442         HasBoxDecorationsAndBackgroundMayBeVisible,
 443     };
 444     bool hasVisibleBoxDecorations() const { return m_bitfields.boxDecorationState() != NoBoxDecorations; }
 445     bool backgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset);
 446 
 447     bool needsLayout() const
 448     {
 449         return m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()
 450             || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();
 451     }
 452 
 453     bool selfNeedsLayout() const { return m_bitfields.needsLayout(); }
 454     bool needsPositionedMovementLayout() const { return m_bitfields.needsPositionedMovementLayout(); }
 455     bool needsPositionedMovementLayoutOnly() const
 456     {
 457         return m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()
 458             &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();
 459     }
 460 
 461     bool posChildNeedsLayout() const { return m_bitfields.posChildNeedsLayout(); }
 462     bool needsSimplifiedNormalFlowLayout() const { return m_bitfields.needsSimplifiedNormalFlowLayout(); }
 463     bool needsSimplifiedNormalFlowLayoutOnly() const;
 464     bool normalChildNeedsLayout() const { return m_bitfields.normalChildNeedsLayout(); }
 465 
 466     bool preferredLogicalWidthsDirty() const { return m_bitfields.preferredLogicalWidthsDirty(); }
 467 
 468     bool isSelectionBorder() const;
 469 
 470     bool hasOverflowClip() const { return m_bitfields.hasOverflowClip(); }
 471 
 472     bool hasTransformRelatedProperty() const { return m_bitfields.hasTransformRelatedProperty(); } // Transform, perspective or transform-style: preserve-3d.
 473     bool hasTransform() const { return hasTransformRelatedProperty() &amp;&amp; style().hasTransform(); }
 474 
 475     inline bool preservesNewline() const;
 476 
 477     virtual void updateDragState(bool dragOn);
 478 
 479     RenderView&amp; view() const { return *document().renderView(); };
 480 
 481     // Returns true if this renderer is rooted.
 482     bool isRooted() const;
 483 
 484     Node* node() const { return isAnonymous() ? nullptr : &amp;m_node; }
 485     Node* nonPseudoNode() const { return isPseudoElement() ? nullptr : node(); }
 486 
 487     // Returns the styled node that caused the generation of this renderer.
 488     // This is the same as node() except for renderers of :before and :after
 489     // pseudo elements for which their parent node is returned.
 490     Node* generatingNode() const { return isPseudoElement() ? generatingPseudoHostElement() : node(); }
 491 
 492     Document&amp; document() const { return m_node.document(); }
 493     Frame&amp; frame() const;
 494     Page&amp; page() const;
 495     Settings&amp; settings() const { return page().settings(); }
 496 
 497     // Returns the object containing this one. Can be different from parent for positioned elements.
 498     // If repaintContainer and repaintContainerSkipped are not null, on return *repaintContainerSkipped
 499     // is true if the renderer returned is an ancestor of repaintContainer.
 500     RenderElement* container() const;
 501     RenderElement* container(const RenderLayerModelObject* repaintContainer, bool&amp; repaintContainerSkipped) const;
 502 
 503     RenderBoxModelObject* offsetParent() const;
 504 
 505     void markContainingBlocksForLayout(ScheduleRelayout = ScheduleRelayout::Yes, RenderElement* newRoot = nullptr);
 506     void setNeedsLayout(MarkingBehavior = MarkContainingBlockChain);
 507     void clearNeedsLayout();
 508     void setPreferredLogicalWidthsDirty(bool, MarkingBehavior = MarkContainingBlockChain);
 509     void invalidateContainerPreferredLogicalWidths();
 510 
 511     void setNeedsLayoutAndPrefWidthsRecalc()
 512     {
 513         setNeedsLayout();
 514         setPreferredLogicalWidthsDirty(true);
 515     }
 516 
 517     void setPositionState(PositionType position)
 518     {
 519         ASSERT((position != PositionType::Absolute &amp;&amp; position != PositionType::Fixed) || isBox());
 520         m_bitfields.setPositionedState(static_cast&lt;int&gt;(position));
 521     }
 522     void clearPositionedState() { m_bitfields.clearPositionedState(); }
 523 
 524     void setFloating(bool b = true) { m_bitfields.setFloating(b); }
 525     void setInline(bool b = true) { m_bitfields.setIsInline(b); }
 526 
 527     void setHasVisibleBoxDecorations(bool = true);
 528     void invalidateBackgroundObscurationStatus();
 529     virtual bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp;) { return false; }
 530 
 531     void setIsText() { ASSERT(!isBox()); m_bitfields.setIsTextOrRenderView(true); }
 532     void setIsLineBreak() { m_bitfields.setIsLineBreak(true); }
 533     void setIsBox() { m_bitfields.setIsBox(true); }
 534     void setIsRenderView() { ASSERT(isBox()); m_bitfields.setIsTextOrRenderView(true); }
 535     void setReplaced(bool b = true) { m_bitfields.setIsReplaced(b); }
 536     void setHorizontalWritingMode(bool b = true) { m_bitfields.setHorizontalWritingMode(b); }
 537     void setHasOverflowClip(bool b = true) { m_bitfields.setHasOverflowClip(b); }
 538     void setHasLayer(bool b = true) { m_bitfields.setHasLayer(b); }
 539     void setHasTransformRelatedProperty(bool b = true) { m_bitfields.setHasTransformRelatedProperty(b); }
 540 
 541     void setIsDragging(bool);
 542     void setHasReflection(bool = true);
 543     void setIsRenderFragmentedFlow(bool = true);
 544     void setHasOutlineAutoAncestor(bool = true);
 545 
 546     // Hook so that RenderTextControl can return the line height of its inner renderer.
 547     // For other renderers, the value is the same as lineHeight(false).
 548     virtual int innerLineHeight() const;
 549 
 550     // used for element state updates that cannot be fixed with a
 551     // repaint and do not need a relayout
 552     virtual void updateFromElement() { }
 553 
 554     bool isComposited() const;
 555 
 556     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestFilter = HitTestAll);
 557     virtual void updateHitTestResult(HitTestResult&amp;, const LayoutPoint&amp;);
 558     virtual bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction);
 559 
 560     virtual Position positionForPoint(const LayoutPoint&amp;);
 561     virtual VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*);
 562     VisiblePosition createVisiblePosition(int offset, EAffinity) const;
 563     VisiblePosition createVisiblePosition(const Position&amp;) const;
 564 
 565     // returns the containing block level element for this element.
 566     WEBCORE_EXPORT RenderBlock* containingBlock() const;
 567     RenderBlock* containingBlockForObjectInFlow() const;
 568 
 569     // Convert the given local point to absolute coordinates. If MapCoordinatesFlags includes UseTransforms, take transforms into account.
 570     WEBCORE_EXPORT FloatPoint localToAbsolute(const FloatPoint&amp; localPoint = FloatPoint(), MapCoordinatesFlags = 0, bool* wasFixed = nullptr) const;
 571     FloatPoint absoluteToLocal(const FloatPoint&amp;, MapCoordinatesFlags = 0) const;
 572 
 573     // Convert a local quad to absolute coordinates, taking transforms into account.
 574     FloatQuad localToAbsoluteQuad(const FloatQuad&amp; quad, MapCoordinatesFlags mode = UseTransforms, bool* wasFixed = nullptr) const
 575     {
 576         return localToContainerQuad(quad, nullptr, mode, wasFixed);
 577     }
 578     // Convert an absolute quad to local coordinates.
 579     FloatQuad absoluteToLocalQuad(const FloatQuad&amp;, MapCoordinatesFlags mode = UseTransforms) const;
 580 
 581     // Convert a local quad into the coordinate system of container, taking transforms into account.
 582     WEBCORE_EXPORT FloatQuad localToContainerQuad(const FloatQuad&amp;, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags = UseTransforms, bool* wasFixed = nullptr) const;
 583     WEBCORE_EXPORT FloatPoint localToContainerPoint(const FloatPoint&amp;, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags = UseTransforms, bool* wasFixed = nullptr) const;
 584 
 585     // Return the offset from the container() renderer (excluding transforms). In multi-column layout,
 586     // different offsets apply at different points, so return the offset that applies to the given point.
 587     virtual LayoutSize offsetFromContainer(RenderElement&amp;, const LayoutPoint&amp;, bool* offsetDependsOnPoint = nullptr) const;
 588     // Return the offset from an object up the container() chain. Asserts that none of the intermediate objects have transforms.
 589     LayoutSize offsetFromAncestorContainer(RenderElement&amp;) const;
 590 
 591 #if PLATFORM(IOS_FAMILY)
 592     virtual void collectSelectionRects(Vector&lt;SelectionRect&gt;&amp;, unsigned startOffset = 0, unsigned endOffset = std::numeric_limits&lt;unsigned&gt;::max());
 593     virtual void absoluteQuadsForSelection(Vector&lt;FloatQuad&gt;&amp; quads) const { absoluteQuads(quads); }
 594 #endif
 595 
 596     virtual void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp;) const { }
 597 
 598     // FIXME: useTransforms should go away eventually
 599     WEBCORE_EXPORT IntRect absoluteBoundingBoxRect(bool useTransform = true, bool* wasFixed = nullptr) const;
 600     IntRect absoluteBoundingBoxRectIgnoringTransforms() const { return absoluteBoundingBoxRect(false); }
 601 
 602     // Build an array of quads in absolute coords for line boxes
 603     virtual void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* /*wasFixed*/ = nullptr) const { }
 604 
 605     virtual void absoluteFocusRingQuads(Vector&lt;FloatQuad&gt;&amp;);
 606 
 607     static FloatRect absoluteBoundingBoxRectForRange(const Range*);
 608 
 609     // the rect that will be painted if this object is passed as the paintingRoot
 610     WEBCORE_EXPORT LayoutRect paintingRootRect(LayoutRect&amp; topLevelRect);
 611 
 612     virtual LayoutUnit minPreferredLogicalWidth() const { return 0; }
 613     virtual LayoutUnit maxPreferredLogicalWidth() const { return 0; }
 614 
 615     const RenderStyle&amp; style() const;
 616     const RenderStyle&amp; firstLineStyle() const;
 617 
 618     // Anonymous blocks that are part of of a continuation chain will return their inline continuation&#39;s outline style instead.
 619     // This is typically only relevant when repainting.
 620     virtual const RenderStyle&amp; outlineStyleForRepaint() const { return style(); }
 621 
 622     virtual CursorDirective getCursor(const LayoutPoint&amp;, Cursor&amp;) const;
 623 
 624     // Return the RenderLayerModelObject in the container chain which is responsible for painting this object, or nullptr
 625     // if painting is root-relative. This is the container that should be passed to the &#39;forRepaint&#39;
 626     // methods.
 627     RenderLayerModelObject* containerForRepaint() const;
 628     // Actually do the repaint of rect r for this object which has been computed in the coordinate space
 629     // of repaintContainer. If repaintContainer is nullptr, repaint via the view.
 630     void repaintUsingContainer(const RenderLayerModelObject* repaintContainer, const LayoutRect&amp;, bool shouldClipToLayer = true) const;
 631 
 632     // Repaint the entire object.  Called when, e.g., the color of a border changes, or when a border
 633     // style changes.
 634     void repaint() const;
 635 
 636     // Repaint a specific subrectangle within a given object.  The rect |r| is in the object&#39;s coordinate space.
 637     WEBCORE_EXPORT void repaintRectangle(const LayoutRect&amp;, bool shouldClipToLayer = true) const;
 638 
 639     // Repaint a slow repaint object, which, at this time, means we are repainting an object with background-attachment:fixed.
 640     void repaintSlowRepaintObject() const;
 641 
 642     // Returns the rect that should be repainted whenever this object changes.  The rect is in the view&#39;s
 643     // coordinate space.  This method deals with outlines and overflow.
 644     LayoutRect absoluteClippedOverflowRect() const
 645     {
 646         return clippedOverflowRectForRepaint(nullptr);
 647     }
 648     WEBCORE_EXPORT IntRect pixelSnappedAbsoluteClippedOverflowRect() const;
 649     virtual LayoutRect clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const;
 650     virtual LayoutRect rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const;
 651     virtual LayoutRect outlineBoundsForRepaint(const RenderLayerModelObject* /*repaintContainer*/, const RenderGeometryMap* = nullptr) const { return LayoutRect(); }
 652 
 653     // Given a rect in the object&#39;s coordinate space, compute a rect suitable for repainting
 654     // that rect in view coordinates.
 655     LayoutRect computeAbsoluteRepaintRect(const LayoutRect&amp; r) const
 656     {
 657         return computeRectForRepaint(r, nullptr);
 658     }
 659     // Given a rect in the object&#39;s coordinate space, compute a rect suitable for repainting
 660     // that rect in the coordinate space of repaintContainer.
 661     LayoutRect computeRectForRepaint(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer) const;
 662     FloatRect computeFloatRectForRepaint(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer) const;
 663 
 664     // Given a rect in the object&#39;s coordinate space, compute the location in container space where this rect is visible,
 665     // when clipping and scrolling as specified by the context. When using edge-inclusive intersection, return WTF::nullopt
 666     // rather than an empty rect if the rect is completely clipped out in container space.
 667     enum class VisibleRectContextOption {
 668         UseEdgeInclusiveIntersection = 1 &lt;&lt; 0,
 669         ApplyCompositedClips = 1 &lt;&lt; 1,
 670         ApplyCompositedContainerScrolls  = 1 &lt;&lt; 2,
 671         ApplyContainerClip = 1 &lt;&lt; 3,
 672     };
 673     struct VisibleRectContext {
 674         VisibleRectContext(bool hasPositionFixedDescendant = false, bool dirtyRectIsFlipped = false, OptionSet&lt;VisibleRectContextOption&gt; options = { })
 675             : m_hasPositionFixedDescendant(hasPositionFixedDescendant)
 676             , m_dirtyRectIsFlipped(dirtyRectIsFlipped)
 677             , m_options(options)
 678             {
 679             }
 680         bool m_hasPositionFixedDescendant;
 681         bool m_dirtyRectIsFlipped;
 682         OptionSet&lt;VisibleRectContextOption&gt; m_options;
 683     };
 684     virtual Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 685     virtual Optional&lt;FloatRect&gt; computeFloatVisibleRectInContainer(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 686 
 687     virtual unsigned int length() const { return 1; }
 688 
 689     bool isFloatingOrOutOfFlowPositioned() const { return (isFloating() || isOutOfFlowPositioned()); }
 690 
 691     enum SelectionState {
 692         SelectionNone, // The object is not selected.
 693         SelectionStart, // The object either contains the start of a selection run or is the start of a run
 694         SelectionInside, // The object is fully encompassed by a selection run
 695         SelectionEnd, // The object either contains the end of a selection run or is the end of a run
 696         SelectionBoth // The object contains an entire run or is the sole selected object in that run
 697     };
 698 
 699     // The current selection state for an object.  For blocks, the state refers to the state of the leaf
 700     // descendants (as described above in the SelectionState enum declaration).
 701     SelectionState selectionState() const { return m_bitfields.selectionState(); }
 702     virtual void setSelectionState(SelectionState state) { m_bitfields.setSelectionState(state); }
 703     inline void setSelectionStateIfNeeded(SelectionState);
 704     bool canUpdateSelectionOnRootLineBoxes();
 705 
 706     // A single rectangle that encompasses all of the selected objects within this object.  Used to determine the tightest
 707     // possible bounding box for the selection.
 708     LayoutRect selectionRect(bool clipToVisibleContent = true) { return selectionRectForRepaint(nullptr, clipToVisibleContent); }
 709     virtual LayoutRect selectionRectForRepaint(const RenderLayerModelObject* /*repaintContainer*/, bool /*clipToVisibleContent*/ = true) { return LayoutRect(); }
 710 
 711     virtual bool canBeSelectionLeaf() const { return false; }
 712 
 713     // Whether or not a given block needs to paint selection gaps.
 714     virtual bool shouldPaintSelectionGaps() const { return false; }
 715 
 716     /**
 717      * Returns the local coordinates of the caret within this render object.
 718      * @param caretOffset zero-based offset determining position within the render object.
 719      * @param extraWidthToEndOfLine optional out arg to give extra width to end of line -
 720      * useful for character range rect computations
 721      */
 722     virtual LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = nullptr);
 723 
 724     // When performing a global document tear-down, or when going into the page cache, the renderer of the document is cleared.
 725     bool renderTreeBeingDestroyed() const;
 726 
 727     void destroy();
 728 
 729     // Virtual function helpers for the deprecated Flexible Box Layout (display: -webkit-box).
 730     virtual bool isDeprecatedFlexibleBox() const { return false; }
 731 
 732     // Virtual function helper for the new FlexibleBox Layout (display: -webkit-flex).
 733     virtual bool isFlexibleBox() const { return false; }
 734 
 735     bool isFlexibleBoxIncludingDeprecated() const
 736     {
 737         return isFlexibleBox() || isDeprecatedFlexibleBox();
 738     }
 739 
 740     virtual bool isCombineText() const { return false; }
 741 
 742     virtual int caretMinOffset() const;
 743     virtual int caretMaxOffset() const;
 744 
 745     virtual int previousOffset(int current) const;
 746     virtual int previousOffsetForBackwardDeletion(int current) const;
 747     virtual int nextOffset(int current) const;
 748 
 749     void imageChanged(CachedImage*, const IntRect* = nullptr) override;
 750     virtual void imageChanged(WrappedImagePtr, const IntRect* = nullptr) { }
 751 
 752     CSSAnimationController&amp; animation() const;
 753     DocumentTimeline* documentTimeline() const;
 754 
 755     // Map points and quads through elements, potentially via 3d transforms. You should never need to call these directly; use
 756     // localToAbsolute/absoluteToLocal methods instead.
 757     virtual void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed = nullptr) const;
 758     virtual void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const;
 759 
 760     // Pushes state onto RenderGeometryMap about how to map coordinates from this renderer to its container, or ancestorToStopAt (whichever is encountered first).
 761     // Returns the renderer which was mapped to (container or ancestorToStopAt).
 762     virtual const RenderObject* pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp;) const;
 763 
 764     bool shouldUseTransformFromContainer(const RenderObject* container) const;
 765     void getTransformFromContainer(const RenderObject* container, const LayoutSize&amp; offsetInContainer, TransformationMatrix&amp;) const;
 766 
 767     virtual void addFocusRingRects(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp; /* additionalOffset */, const RenderLayerModelObject* /* paintContainer */ = nullptr) { };
 768 
 769     LayoutRect absoluteOutlineBounds() const
 770     {
 771         return outlineBoundsForRepaint(nullptr);
 772     }
 773 
 774     virtual void willBeRemovedFromTree();
 775     void resetFragmentedFlowStateOnRemoval();
 776     void initializeFragmentedFlowStateOnInsertion();
 777     virtual void insertedIntoTree();
 778 
 779 protected:
 780     //////////////////////////////////////////
 781     // Helper functions. Dangerous to use!
 782     void setPreviousSibling(RenderObject* previous) { m_previous = previous; }
 783     void setNextSibling(RenderObject* next) { m_next = next; }
 784     void setParent(RenderElement*);
 785     //////////////////////////////////////////
 786     void addPDFURLRect(PaintInfo&amp;, const LayoutPoint&amp;);
 787     Node&amp; nodeForNonAnonymous() const { ASSERT(!isAnonymous()); return m_node; }
 788 
 789     void adjustRectForOutlineAndShadow(LayoutRect&amp;) const;
 790 
 791     virtual void willBeDestroyed();
 792 
 793     void setNeedsPositionedMovementLayoutBit(bool b) { m_bitfields.setNeedsPositionedMovementLayout(b); }
 794     void setNormalChildNeedsLayoutBit(bool b) { m_bitfields.setNormalChildNeedsLayout(b); }
 795     void setPosChildNeedsLayoutBit(bool b) { m_bitfields.setPosChildNeedsLayout(b); }
 796     void setNeedsSimplifiedNormalFlowLayoutBit(bool b) { m_bitfields.setNeedsSimplifiedNormalFlowLayout(b); }
 797 
 798     virtual RenderFragmentedFlow* locateEnclosingFragmentedFlow() const;
 799     static void calculateBorderStyleColor(const BorderStyle&amp;, const BoxSide&amp;, Color&amp;);
 800 
 801     static FragmentedFlowState computedFragmentedFlowState(const RenderObject&amp;);
 802 
 803     static bool shouldApplyCompositedContainerScrollsForRepaint();
 804 
 805     static VisibleRectContext visibleRectContextForRepaint()
 806     {
 807         return VisibleRectContext(false, false, { VisibleRectContextOption::ApplyContainerClip, VisibleRectContextOption::ApplyCompositedContainerScrolls });
 808     }
 809 
 810 private:
 811 #ifndef NDEBUG
 812     bool isSetNeedsLayoutForbidden() const { return m_setNeedsLayoutForbidden; }
 813     void setNeedsLayoutIsForbidden(bool flag) { m_setNeedsLayoutForbidden = flag; }
 814 #endif
 815 
 816     void addAbsoluteRectForLayer(LayoutRect&amp; result);
 817     void setLayerNeedsFullRepaint();
 818     void setLayerNeedsFullRepaintForPositionedMovementLayout();
 819 
 820     Node* generatingPseudoHostElement() const;
 821 
 822     void propagateRepaintToParentWithOutlineAutoIfNeeded(const RenderLayerModelObject&amp; repaintContainer, const LayoutRect&amp; repaintRect) const;
 823 
 824     virtual bool isWBR() const { ASSERT_NOT_REACHED(); return false; }
 825 
 826     void setEverHadLayout(bool b) { m_bitfields.setEverHadLayout(b); }
 827 
 828     bool hasRareData() const { return m_bitfields.hasRareData(); }
 829     void setHasRareData(bool b) { m_bitfields.setHasRareData(b); }
 830 
 831 #ifndef NDEBUG
 832     void checkBlockPositionedObjectsNeedLayout();
 833 #endif
 834 
 835     Node&amp; m_node;
 836 
 837     RenderElement* m_parent;
 838     RenderObject* m_previous;
 839     RenderObject* m_next;
 840 
 841 #ifndef NDEBUG
 842     bool m_hasAXObject             : 1;
 843     bool m_setNeedsLayoutForbidden : 1;
 844 #endif
 845 
 846 #define ADD_BOOLEAN_BITFIELD(name, Name) \
 847     private:\
 848         unsigned m_##name : 1;\
 849     public:\
 850         bool name() const { return m_##name; }\
 851         void set##Name(bool name) { m_##name = name; }\
 852 
 853 #define ADD_ENUM_BITFIELD(name, Name, Type, width) \
 854     private:\
 855         unsigned m_##name : width;\
 856     public:\
 857         Type name() const { return static_cast&lt;Type&gt;(m_##name); }\
 858         void set##Name(Type name) { m_##name = static_cast&lt;unsigned&gt;(name); }\
 859 
 860     class RenderObjectBitfields {
 861         enum PositionedState {
 862             IsStaticallyPositioned = 0,
 863             IsRelativelyPositioned = 1,
 864             IsOutOfFlowPositioned = 2,
 865             IsStickilyPositioned = 3
 866         };
 867 
 868     public:
 869         RenderObjectBitfields(const Node&amp; node)
 870             : m_hasRareData(false)
 871             , m_beingDestroyed(false)
 872             , m_needsLayout(false)
 873             , m_needsPositionedMovementLayout(false)
 874             , m_normalChildNeedsLayout(false)
 875             , m_posChildNeedsLayout(false)
 876             , m_needsSimplifiedNormalFlowLayout(false)
 877             , m_preferredLogicalWidthsDirty(false)
 878             , m_floating(false)
 879             , m_isAnonymous(node.isDocumentNode())
 880             , m_isTextOrRenderView(false)
 881             , m_isBox(false)
 882             , m_isInline(true)
 883             , m_isReplaced(false)
 884             , m_isLineBreak(false)
 885             , m_horizontalWritingMode(true)
 886             , m_hasLayer(false)
 887             , m_hasOverflowClip(false)
 888             , m_hasTransformRelatedProperty(false)
 889             , m_everHadLayout(false)
 890             , m_childrenInline(false)
 891             , m_isExcludedFromNormalLayout(false)
 892             , m_positionedState(IsStaticallyPositioned)
 893             , m_selectionState(SelectionNone)
 894             , m_fragmentedFlowState(NotInsideFragmentedFlow)
 895             , m_boxDecorationState(NoBoxDecorations)
 896         {
 897         }
 898 
 899         ADD_BOOLEAN_BITFIELD(hasRareData, HasRareData);
 900 
 901         ADD_BOOLEAN_BITFIELD(beingDestroyed, BeingDestroyed);
 902         ADD_BOOLEAN_BITFIELD(needsLayout, NeedsLayout);
 903         ADD_BOOLEAN_BITFIELD(needsPositionedMovementLayout, NeedsPositionedMovementLayout);
 904         ADD_BOOLEAN_BITFIELD(normalChildNeedsLayout, NormalChildNeedsLayout);
 905         ADD_BOOLEAN_BITFIELD(posChildNeedsLayout, PosChildNeedsLayout);
 906         ADD_BOOLEAN_BITFIELD(needsSimplifiedNormalFlowLayout, NeedsSimplifiedNormalFlowLayout);
 907         ADD_BOOLEAN_BITFIELD(preferredLogicalWidthsDirty, PreferredLogicalWidthsDirty);
 908         ADD_BOOLEAN_BITFIELD(floating, Floating);
 909 
 910         ADD_BOOLEAN_BITFIELD(isAnonymous, IsAnonymous);
 911         ADD_BOOLEAN_BITFIELD(isTextOrRenderView, IsTextOrRenderView);
 912         ADD_BOOLEAN_BITFIELD(isBox, IsBox);
 913         ADD_BOOLEAN_BITFIELD(isInline, IsInline);
 914         ADD_BOOLEAN_BITFIELD(isReplaced, IsReplaced);
 915         ADD_BOOLEAN_BITFIELD(isLineBreak, IsLineBreak);
 916         ADD_BOOLEAN_BITFIELD(horizontalWritingMode, HorizontalWritingMode);
 917 
 918         ADD_BOOLEAN_BITFIELD(hasLayer, HasLayer);
 919         ADD_BOOLEAN_BITFIELD(hasOverflowClip, HasOverflowClip); // Set in the case of overflow:auto/scroll/hidden
 920         ADD_BOOLEAN_BITFIELD(hasTransformRelatedProperty, HasTransformRelatedProperty);
 921         ADD_BOOLEAN_BITFIELD(unused, Unused);
 922 
 923         ADD_BOOLEAN_BITFIELD(everHadLayout, EverHadLayout);
 924 
 925         // from RenderBlock
 926         ADD_BOOLEAN_BITFIELD(childrenInline, ChildrenInline);
 927 
 928         ADD_BOOLEAN_BITFIELD(isExcludedFromNormalLayout, IsExcludedFromNormalLayout);
 929 
 930     private:
 931         unsigned m_positionedState : 2; // PositionedState
 932         unsigned m_selectionState : 3; // SelectionState
 933         unsigned m_fragmentedFlowState : 2; // FragmentedFlowState
 934         unsigned m_boxDecorationState : 2; // BoxDecorationState
 935 
 936     public:
 937         bool isOutOfFlowPositioned() const { return m_positionedState == IsOutOfFlowPositioned; }
 938         bool isRelativelyPositioned() const { return m_positionedState == IsRelativelyPositioned; }
 939         bool isStickilyPositioned() const { return m_positionedState == IsStickilyPositioned; }
 940         bool isPositioned() const { return m_positionedState != IsStaticallyPositioned; }
 941 
 942         void setPositionedState(int positionState)
 943         {
 944             // This mask maps PositionType::Fixed and PositionType::Absolute to IsOutOfFlowPositioned, saving one bit.
 945             m_positionedState = static_cast&lt;PositionedState&gt;(positionState &amp; 0x3);
 946         }
 947         void clearPositionedState() { m_positionedState = static_cast&lt;unsigned&gt;(PositionType::Static); }
 948 
 949         ALWAYS_INLINE SelectionState selectionState() const { return static_cast&lt;SelectionState&gt;(m_selectionState); }
 950         ALWAYS_INLINE void setSelectionState(SelectionState selectionState) { m_selectionState = selectionState; }
 951 
 952         ALWAYS_INLINE FragmentedFlowState fragmentedFlowState() const { return static_cast&lt;FragmentedFlowState&gt;(m_fragmentedFlowState); }
 953         ALWAYS_INLINE void setFragmentedFlowState(FragmentedFlowState fragmentedFlowState) { m_fragmentedFlowState = fragmentedFlowState; }
 954 
 955         ALWAYS_INLINE BoxDecorationState boxDecorationState() const { return static_cast&lt;BoxDecorationState&gt;(m_boxDecorationState); }
 956         ALWAYS_INLINE void setBoxDecorationState(BoxDecorationState boxDecorationState) { m_boxDecorationState = boxDecorationState; }
 957     };
 958 
 959     RenderObjectBitfields m_bitfields;
 960 
 961     // FIXME: This should be RenderElementRareData.
 962     class RenderObjectRareData {
 963         WTF_MAKE_FAST_ALLOCATED;
 964     public:
 965         RenderObjectRareData()
 966             : m_isDragging(false)
 967             , m_hasReflection(false)
 968             , m_isRenderFragmentedFlow(false)
 969             , m_hasOutlineAutoAncestor(false)
 970         {
 971         }
 972         ADD_BOOLEAN_BITFIELD(isDragging, IsDragging);
 973         ADD_BOOLEAN_BITFIELD(hasReflection, HasReflection);
 974         ADD_BOOLEAN_BITFIELD(isRenderFragmentedFlow, IsRenderFragmentedFlow);
 975         ADD_BOOLEAN_BITFIELD(hasOutlineAutoAncestor, HasOutlineAutoAncestor);
 976 
 977         // From RenderElement
 978         std::unique_ptr&lt;RenderStyle&gt; cachedFirstLineStyle;
 979     };
 980 
 981     const RenderObject::RenderObjectRareData&amp; rareData() const;
 982     RenderObjectRareData&amp; ensureRareData();
 983     void removeRareData();
 984 
 985     typedef HashMap&lt;const RenderObject*, std::unique_ptr&lt;RenderObjectRareData&gt;&gt; RareDataMap;
 986 
 987     static RareDataMap&amp; rareDataMap();
 988 
 989 #undef ADD_BOOLEAN_BITFIELD
 990 };
 991 
 992 inline Frame&amp; RenderObject::frame() const
 993 {
 994     return *document().frame();
 995 }
 996 
 997 inline Page&amp; RenderObject::page() const
 998 {
 999     // The render tree will always be torn down before Frame is disconnected from Page,
1000     // so it&#39;s safe to assume Frame::page() is non-null as long as there are live RenderObjects.
1001     ASSERT(frame().page());
1002     return *frame().page();
1003 }
1004 
1005 inline CSSAnimationController&amp; RenderObject::animation() const
1006 {
1007     return frame().animation();
1008 }
1009 
1010 inline DocumentTimeline* RenderObject::documentTimeline() const
1011 {
1012     return document().existingTimeline();
1013 }
1014 
1015 inline bool RenderObject::renderTreeBeingDestroyed() const
1016 {
1017     return document().renderTreeBeingDestroyed();
1018 }
1019 
1020 inline bool RenderObject::isBeforeContent() const
1021 {
1022     // Text nodes don&#39;t have their own styles, so ignore the style on a text node.
1023     if (isText())
1024         return false;
1025     if (style().styleType() != PseudoId::Before)
1026         return false;
1027     return true;
1028 }
1029 
1030 inline bool RenderObject::isAfterContent() const
1031 {
1032     // Text nodes don&#39;t have their own styles, so ignore the style on a text node.
1033     if (isText())
1034         return false;
1035     if (style().styleType() != PseudoId::After)
1036         return false;
1037     return true;
1038 }
1039 
1040 inline bool RenderObject::isBeforeOrAfterContent() const
1041 {
1042     return isBeforeContent() || isAfterContent();
1043 }
1044 
1045 inline void RenderObject::setNeedsLayout(MarkingBehavior markParents)
1046 {
1047     ASSERT(!isSetNeedsLayoutForbidden());
1048     if (m_bitfields.needsLayout())
1049         return;
1050     m_bitfields.setNeedsLayout(true);
1051     if (markParents == MarkContainingBlockChain)
1052         markContainingBlocksForLayout();
1053     if (hasLayer())
1054         setLayerNeedsFullRepaint();
1055 }
1056 
1057 inline bool RenderObject::preservesNewline() const
1058 {
1059     if (isSVGInlineText())
1060         return false;
1061 
1062     return style().preserveNewline();
1063 }
1064 
1065 inline void RenderObject::setSelectionStateIfNeeded(SelectionState state)
1066 {
1067     if (selectionState() == state)
1068         return;
1069 
1070     setSelectionState(state);
1071 }
1072 
1073 inline void RenderObject::setHasVisibleBoxDecorations(bool b)
1074 {
1075     if (!b) {
1076         m_bitfields.setBoxDecorationState(NoBoxDecorations);
1077         return;
1078     }
1079     if (hasVisibleBoxDecorations())
1080         return;
1081     m_bitfields.setBoxDecorationState(HasBoxDecorationsAndBackgroundObscurationStatusInvalid);
1082 }
1083 
1084 inline void RenderObject::invalidateBackgroundObscurationStatus()
1085 {
1086     if (!hasVisibleBoxDecorations())
1087         return;
1088     m_bitfields.setBoxDecorationState(HasBoxDecorationsAndBackgroundObscurationStatusInvalid);
1089 }
1090 
1091 inline bool RenderObject::backgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
1092 {
1093     if (m_bitfields.boxDecorationState() == HasBoxDecorationsAndBackgroundObscurationStatusInvalid) {
1094         BoxDecorationState boxDecorationState = computeBackgroundIsKnownToBeObscured(paintOffset) ? HasBoxDecorationsAndBackgroundIsKnownToBeObscured : HasBoxDecorationsAndBackgroundMayBeVisible;
1095         m_bitfields.setBoxDecorationState(boxDecorationState);
1096     }
1097     return m_bitfields.boxDecorationState() == HasBoxDecorationsAndBackgroundIsKnownToBeObscured;
1098 }
1099 
1100 inline bool RenderObject::needsSimplifiedNormalFlowLayoutOnly() const
1101 {
1102     return m_bitfields.needsSimplifiedNormalFlowLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()
1103         &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsPositionedMovementLayout();
1104 }
1105 
1106 inline void Node::setRenderer(RenderObject* renderer) { m_rendererWithStyleFlags.setPointer(renderer); }
1107 
1108 #if ENABLE(TREE_DEBUGGING)
1109 void printRenderTreeForLiveDocuments();
1110 void printLayerTreeForLiveDocuments();
1111 void printGraphicsLayerTreeForLiveDocuments();
1112 #endif
1113 
1114 } // namespace WebCore
1115 
1116 #define SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(ToValueTypeName, predicate) \
1117 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
1118     static bool isType(const WebCore::RenderObject&amp; renderer) { return renderer.predicate; } \
1119 SPECIALIZE_TYPE_TRAITS_END()
1120 
1121 #if ENABLE(TREE_DEBUGGING)
1122 // Outside the WebCore namespace for ease of invocation from the debugger.
1123 void showNodeTree(const WebCore::RenderObject*);
1124 void showLineTree(const WebCore::RenderObject*);
1125 void showRenderTree(const WebCore::RenderObject*);
1126 #endif
    </pre>
  </body>
</html>