<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;B3SparseCollection.h&quot;
  31 #include &quot;BasicBlockLocation.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;DFGAdjacencyList.h&quot;
  34 #include &quot;DFGArithMode.h&quot;
  35 #include &quot;DFGArrayMode.h&quot;
  36 #include &quot;DFGCommon.h&quot;
  37 #include &quot;DFGEpoch.h&quot;
  38 #include &quot;DFGLazyJSValue.h&quot;
  39 #include &quot;DFGMultiGetByOffsetData.h&quot;
  40 #include &quot;DFGNodeFlags.h&quot;
  41 #include &quot;DFGNodeOrigin.h&quot;
  42 #include &quot;DFGNodeType.h&quot;
  43 #include &quot;DFGObjectMaterializationData.h&quot;
  44 #include &quot;DFGOpInfo.h&quot;
  45 #include &quot;DFGRegisteredStructure.h&quot;
  46 #include &quot;DFGRegisteredStructureSet.h&quot;
  47 #include &quot;DFGTransition.h&quot;
  48 #include &quot;DFGUseKind.h&quot;
  49 #include &quot;DFGVariableAccessData.h&quot;
  50 #include &quot;GetByIdVariant.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;Operands.h&quot;
  53 #include &quot;PutByIdVariant.h&quot;
  54 #include &quot;SpeculatedType.h&quot;
  55 #include &quot;TypeLocation.h&quot;
  56 #include &quot;ValueProfile.h&quot;
  57 #include &lt;type_traits&gt;
  58 #include &lt;wtf/ListDump.h&gt;
  59 #include &lt;wtf/LoggingHashSet.h&gt;
  60 
  61 namespace JSC {
  62 
  63 namespace DOMJIT {
  64 class GetterSetter;
  65 class CallDOMGetterSnippet;
  66 class Signature;
  67 }
  68 
  69 namespace Profiler {
  70 class ExecutionCounter;
  71 }
  72 
  73 class Snippet;
  74 
  75 namespace DFG {
  76 
  77 class Graph;
  78 class PromotedLocationDescriptor;
  79 struct BasicBlock;
  80 
  81 struct StorageAccessData {
  82     PropertyOffset offset;
  83     unsigned identifierNumber;
  84 };
  85 
  86 struct MultiPutByOffsetData {
  87     unsigned identifierNumber;
  88     Vector&lt;PutByIdVariant, 2&gt; variants;
  89 
  90     bool writesStructures() const;
  91     bool reallocatesStorage() const;
  92 };
  93 
  94 struct MatchStructureVariant {
  95     RegisteredStructure structure;
  96     bool result;
  97 };
  98 
  99 struct MatchStructureData {
 100     Vector&lt;MatchStructureVariant, 2&gt; variants;
 101 };
 102 
 103 struct NewArrayBufferData {
 104     union {
 105         struct {
 106             unsigned vectorLengthHint;
 107             unsigned indexingMode;
 108         };
 109         uint64_t asQuadWord;
 110     };
 111 };
 112 static_assert(sizeof(IndexingType) &lt;= sizeof(unsigned), &quot;&quot;);
 113 static_assert(sizeof(NewArrayBufferData) == sizeof(uint64_t), &quot;&quot;);
 114 
 115 struct DataViewData {
 116     union {
 117         struct {
 118             uint8_t byteSize;
 119             bool isSigned;
 120             bool isFloatingPoint; // Used for the DataViewSet node.
 121             TriState isLittleEndian;
 122         };
 123         uint64_t asQuadWord;
 124     };
 125 };
 126 static_assert(sizeof(DataViewData) == sizeof(uint64_t), &quot;&quot;);
 127 
 128 struct BranchTarget {
 129     BranchTarget()
 130         : block(0)
 131         , count(PNaN)
 132     {
 133     }
 134 
 135     explicit BranchTarget(BasicBlock* block)
 136         : block(block)
 137         , count(PNaN)
 138     {
 139     }
 140 
 141     void setBytecodeIndex(unsigned bytecodeIndex)
 142     {
 143         block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(bytecodeIndex));
 144     }
 145     unsigned bytecodeIndex() const { return bitwise_cast&lt;uintptr_t&gt;(block); }
 146 
 147     void dump(PrintStream&amp;) const;
 148 
 149     BasicBlock* block;
 150     float count;
 151 };
 152 
 153 struct BranchData {
 154     static BranchData withBytecodeIndices(
 155         unsigned takenBytecodeIndex, unsigned notTakenBytecodeIndex)
 156     {
 157         BranchData result;
 158         result.taken.block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(takenBytecodeIndex));
 159         result.notTaken.block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(notTakenBytecodeIndex));
 160         return result;
 161     }
 162 
 163     unsigned takenBytecodeIndex() const { return taken.bytecodeIndex(); }
 164     unsigned notTakenBytecodeIndex() const { return notTaken.bytecodeIndex(); }
 165 
 166     BasicBlock*&amp; forCondition(bool condition)
 167     {
 168         if (condition)
 169             return taken.block;
 170         return notTaken.block;
 171     }
 172 
 173     BranchTarget taken;
 174     BranchTarget notTaken;
 175 };
 176 
 177 // The SwitchData and associated data structures duplicate the information in
 178 // JumpTable. The DFG may ultimately end up using the JumpTable, though it may
 179 // instead decide to do something different - this is entirely up to the DFG.
 180 // These data structures give the DFG a higher-level semantic description of
 181 // what is going on, which will allow it to make the right decision.
 182 //
 183 // Note that there will never be multiple SwitchCases in SwitchData::cases that
 184 // have the same SwitchCase::value, since the bytecode&#39;s JumpTables never have
 185 // duplicates - since the JumpTable maps a value to a target. It&#39;s a
 186 // one-to-many mapping. So we may have duplicate targets, but never duplicate
 187 // values.
 188 struct SwitchCase {
 189     SwitchCase()
 190     {
 191     }
 192 
 193     SwitchCase(LazyJSValue value, BasicBlock* target)
 194         : value(value)
 195         , target(target)
 196     {
 197     }
 198 
 199     static SwitchCase withBytecodeIndex(LazyJSValue value, unsigned bytecodeIndex)
 200     {
 201         SwitchCase result;
 202         result.value = value;
 203         result.target.setBytecodeIndex(bytecodeIndex);
 204         return result;
 205     }
 206 
 207     LazyJSValue value;
 208     BranchTarget target;
 209 };
 210 
 211 struct SwitchData {
 212     // Initializes most fields to obviously invalid values. Anyone
 213     // constructing this should make sure to initialize everything they
 214     // care about manually.
 215     SwitchData()
<a name="1" id="anc1"></a><span class="line-modified"> 216         : switchTableIndex(UINT_MAX)</span>
<span class="line-modified"> 217         , kind(static_cast&lt;SwitchKind&gt;(-1))</span>
 218         , didUseJumpTable(false)
 219     {
 220     }
 221 
 222     Vector&lt;SwitchCase&gt; cases;
 223     BranchTarget fallThrough;
<a name="2" id="anc2"></a>
 224     size_t switchTableIndex;
<a name="3" id="anc3"></a><span class="line-added"> 225     SwitchKind kind;</span>
 226     bool didUseJumpTable;
 227 };
 228 
 229 struct EntrySwitchData {
 230     Vector&lt;BasicBlock*&gt; cases;
 231 };
 232 
 233 struct CallVarargsData {
 234     int firstVarArgOffset;
 235 };
 236 
 237 struct LoadVarargsData {
 238     VirtualRegister start; // Local for the first element. This is the first actual argument, not this.
 239     VirtualRegister count; // Local for the count.
 240     VirtualRegister machineStart;
 241     VirtualRegister machineCount;
 242     unsigned offset; // Which array element to start with. Usually this is 0.
 243     unsigned mandatoryMinimum; // The number of elements on the stack that must be initialized; if the array is too short then the missing elements must get undefined. Does not include &quot;this&quot;.
 244     unsigned limit; // Maximum number of elements to load. Includes &quot;this&quot;.
 245 };
 246 
 247 struct StackAccessData {
 248     StackAccessData()
 249         : format(DeadFlush)
 250     {
 251     }
 252 
 253     StackAccessData(VirtualRegister local, FlushFormat format)
 254         : local(local)
 255         , format(format)
 256     {
 257     }
 258 
 259     VirtualRegister local;
 260     VirtualRegister machineLocal;
 261     FlushFormat format;
 262 
 263     FlushedAt flushedAt() { return FlushedAt(format, machineLocal); }
 264 };
 265 
 266 struct CallDOMGetterData {
 267     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter;
 268     const DOMJIT::GetterSetter* domJIT { nullptr };
 269     DOMJIT::CallDOMGetterSnippet* snippet { nullptr };
 270     unsigned identifierNumber { 0 };
 271 };
 272 
 273 enum class BucketOwnerType : uint32_t {
 274     Map,
 275     Set
 276 };
 277 
 278 // === Node ===
 279 //
 280 // Node represents a single operation in the data flow graph.
 281 struct Node {
 282     WTF_MAKE_FAST_ALLOCATED;
 283 public:
 284     static const char HashSetTemplateInstantiationString[];
 285 
 286     enum VarArgTag { VarArg };
 287 
 288     Node() { }
 289 
 290     Node(NodeType op, NodeOrigin nodeOrigin, const AdjacencyList&amp; children)
 291         : origin(nodeOrigin)
 292         , children(children)
 293         , m_virtualRegister(VirtualRegister())
 294         , m_refCount(1)
 295         , m_prediction(SpecNone)
 296         , owner(nullptr)
 297     {
 298         m_misc.replacement = nullptr;
 299         setOpAndDefaultFlags(op);
 300     }
 301 
 302     // Construct a node with up to 3 children, no immediate value.
 303     Node(NodeType op, NodeOrigin nodeOrigin, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 304         : origin(nodeOrigin)
 305         , children(AdjacencyList::Fixed, child1, child2, child3)
 306         , m_virtualRegister(VirtualRegister())
 307         , m_refCount(1)
 308         , m_prediction(SpecNone)
 309         , owner(nullptr)
 310     {
 311         m_misc.replacement = nullptr;
 312         setOpAndDefaultFlags(op);
 313         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 314     }
 315 
 316     // Construct a node with up to 3 children, no immediate value.
 317     Node(NodeFlags result, NodeType op, NodeOrigin nodeOrigin, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 318         : origin(nodeOrigin)
 319         , children(AdjacencyList::Fixed, child1, child2, child3)
 320         , m_virtualRegister(VirtualRegister())
 321         , m_refCount(1)
 322         , m_prediction(SpecNone)
 323         , owner(nullptr)
 324     {
 325         m_misc.replacement = nullptr;
 326         setOpAndDefaultFlags(op);
 327         setResult(result);
 328         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 329     }
 330 
 331     // Construct a node with up to 3 children and an immediate value.
 332     Node(NodeType op, NodeOrigin nodeOrigin, OpInfo imm, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 333         : origin(nodeOrigin)
 334         , children(AdjacencyList::Fixed, child1, child2, child3)
 335         , m_virtualRegister(VirtualRegister())
 336         , m_refCount(1)
 337         , m_prediction(SpecNone)
 338         , m_opInfo(imm.m_value)
 339         , owner(nullptr)
 340     {
 341         m_misc.replacement = nullptr;
 342         setOpAndDefaultFlags(op);
 343         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 344     }
 345 
 346     // Construct a node with up to 3 children and an immediate value.
 347     Node(NodeFlags result, NodeType op, NodeOrigin nodeOrigin, OpInfo imm, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 348         : origin(nodeOrigin)
 349         , children(AdjacencyList::Fixed, child1, child2, child3)
 350         , m_virtualRegister(VirtualRegister())
 351         , m_refCount(1)
 352         , m_prediction(SpecNone)
 353         , m_opInfo(imm.m_value)
 354         , owner(nullptr)
 355     {
 356         m_misc.replacement = nullptr;
 357         setOpAndDefaultFlags(op);
 358         setResult(result);
 359         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 360     }
 361 
 362     // Construct a node with up to 3 children and two immediate values.
 363     Node(NodeType op, NodeOrigin nodeOrigin, OpInfo imm1, OpInfo imm2, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 364         : origin(nodeOrigin)
 365         , children(AdjacencyList::Fixed, child1, child2, child3)
 366         , m_virtualRegister(VirtualRegister())
 367         , m_refCount(1)
 368         , m_prediction(SpecNone)
 369         , m_opInfo(imm1.m_value)
 370         , m_opInfo2(imm2.m_value)
 371         , owner(nullptr)
 372     {
 373         m_misc.replacement = nullptr;
 374         setOpAndDefaultFlags(op);
 375         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 376     }
 377 
 378     // Construct a node with a variable number of children and two immediate values.
 379     Node(VarArgTag, NodeType op, NodeOrigin nodeOrigin, OpInfo imm1, OpInfo imm2, unsigned firstChild, unsigned numChildren)
 380         : origin(nodeOrigin)
 381         , children(AdjacencyList::Variable, firstChild, numChildren)
 382         , m_virtualRegister(VirtualRegister())
 383         , m_refCount(1)
 384         , m_prediction(SpecNone)
 385         , m_opInfo(imm1.m_value)
 386         , m_opInfo2(imm2.m_value)
 387         , owner(nullptr)
 388     {
 389         m_misc.replacement = nullptr;
 390         setOpAndDefaultFlags(op);
 391         ASSERT(m_flags &amp; NodeHasVarArgs);
 392     }
 393 
 394     NodeType op() const { return static_cast&lt;NodeType&gt;(m_op); }
 395     NodeFlags flags() const { return m_flags; }
 396 
 397     unsigned index() const { return m_index; }
 398 
 399     void setOp(NodeType op)
 400     {
 401         m_op = op;
 402     }
 403 
 404     void setFlags(NodeFlags flags)
 405     {
 406         m_flags = flags;
 407     }
 408 
 409     bool mergeFlags(NodeFlags flags)
 410     {
 411         NodeFlags newFlags = m_flags | flags;
 412         if (newFlags == m_flags)
 413             return false;
 414         m_flags = newFlags;
 415         return true;
 416     }
 417 
 418     bool filterFlags(NodeFlags flags)
 419     {
 420         NodeFlags newFlags = m_flags &amp; flags;
 421         if (newFlags == m_flags)
 422             return false;
 423         m_flags = newFlags;
 424         return true;
 425     }
 426 
 427     bool clearFlags(NodeFlags flags)
 428     {
 429         return filterFlags(~flags);
 430     }
 431 
 432     void setResult(NodeFlags result)
 433     {
 434         ASSERT(!(result &amp; ~NodeResultMask));
 435         clearFlags(NodeResultMask);
 436         mergeFlags(result);
 437     }
 438 
 439     NodeFlags result() const
 440     {
 441         return flags() &amp; NodeResultMask;
 442     }
 443 
 444     void setOpAndDefaultFlags(NodeType op)
 445     {
 446         m_op = op;
 447         m_flags = defaultFlags(op);
 448     }
 449 
 450     void remove(Graph&amp;);
 451     void removeWithoutChecks();
 452 
 453     void convertToCheckStructure(RegisteredStructureSet* set)
 454     {
 455         setOpAndDefaultFlags(CheckStructure);
 456         m_opInfo = set;
 457     }
 458 
 459     void convertToCheckStructureOrEmpty(RegisteredStructureSet* set)
 460     {
 461         if (SpecCellCheck &amp; SpecEmpty)
 462             setOpAndDefaultFlags(CheckStructureOrEmpty);
 463         else
 464             setOpAndDefaultFlags(CheckStructure);
 465         m_opInfo = set;
 466     }
 467 
 468     void convertCheckStructureOrEmptyToCheckStructure()
 469     {
 470         ASSERT(op() == CheckStructureOrEmpty);
 471         setOpAndDefaultFlags(CheckStructure);
 472     }
 473 
 474     void convertToCheckStructureImmediate(Node* structure)
 475     {
 476         ASSERT(op() == CheckStructure || op() == CheckStructureOrEmpty);
 477         m_op = CheckStructureImmediate;
 478         children.setChild1(Edge(structure, CellUse));
 479     }
 480 
 481     void replaceWith(Graph&amp;, Node* other);
 482     void replaceWithWithoutChecks(Node* other);
 483 
 484     void convertToIdentity();
 485     void convertToIdentityOn(Node*);
 486 
 487     bool mustGenerate()
 488     {
 489         return m_flags &amp; NodeMustGenerate;
 490     }
 491 
 492     bool isConstant()
 493     {
 494         switch (op()) {
 495         case JSConstant:
 496         case DoubleConstant:
 497         case Int52Constant:
 498             return true;
 499         default:
 500             return false;
 501         }
 502     }
 503 
 504     bool hasConstant()
 505     {
 506         switch (op()) {
 507         case JSConstant:
 508         case DoubleConstant:
 509         case Int52Constant:
 510             return true;
 511 
 512         case PhantomDirectArguments:
 513         case PhantomClonedArguments:
 514             // These pretend to be the empty value constant for the benefit of the DFG backend, which
 515             // otherwise wouldn&#39;t take kindly to a node that doesn&#39;t compute a value.
 516             return true;
 517 
 518         default:
 519             return false;
 520         }
 521     }
 522 
 523     FrozenValue* constant()
 524     {
 525         ASSERT(hasConstant());
 526 
 527         if (op() == PhantomDirectArguments || op() == PhantomClonedArguments) {
 528             // These pretend to be the empty value constant for the benefit of the DFG backend, which
 529             // otherwise wouldn&#39;t take kindly to a node that doesn&#39;t compute a value.
 530             return FrozenValue::emptySingleton();
 531         }
 532 
 533         return m_opInfo.as&lt;FrozenValue*&gt;();
 534     }
 535 
 536     // Don&#39;t call this directly - use Graph::convertToConstant() instead!
 537     void convertToConstant(FrozenValue* value)
 538     {
 539         if (hasDoubleResult())
 540             m_op = DoubleConstant;
 541         else if (hasInt52Result())
 542             m_op = Int52Constant;
 543         else
 544             m_op = JSConstant;
 545         m_flags &amp;= ~(NodeMustGenerate | NodeHasVarArgs);
 546         m_opInfo = value;
 547         children.reset();
 548     }
 549 
 550     void convertToLazyJSConstant(Graph&amp;, LazyJSValue);
 551 
 552     void convertToConstantStoragePointer(void* pointer)
 553     {
 554         ASSERT(op() == GetIndexedPropertyStorage);
 555         m_op = ConstantStoragePointer;
 556         m_opInfo = pointer;
 557         children.reset();
 558     }
 559 
 560     void convertToPutStack(StackAccessData* data)
 561     {
 562         m_op = PutStack;
 563         m_flags |= NodeMustGenerate;
 564         m_opInfo = data;
 565         m_opInfo2 = OpInfoWrapper();
 566     }
 567 
 568     void convertToGetStack(StackAccessData* data)
 569     {
 570         m_op = GetStack;
 571         m_flags &amp;= ~NodeMustGenerate;
 572         m_opInfo = data;
 573         m_opInfo2 = OpInfoWrapper();
 574         children.reset();
 575     }
 576 
 577     void convertToGetByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 578     {
 579         ASSERT(m_op == GetById || m_op == GetByIdFlush || m_op == GetByIdDirect || m_op == GetByIdDirectFlush || m_op == MultiGetByOffset);
 580         m_opInfo = &amp;data;
 581         children.setChild1(storage);
 582         children.setChild2(base);
 583         m_op = GetByOffset;
 584         m_flags &amp;= ~NodeMustGenerate;
 585     }
 586 
 587     void convertToMultiGetByOffset(MultiGetByOffsetData* data)
 588     {
 589         RELEASE_ASSERT(m_op == GetById || m_op == GetByIdFlush || m_op == GetByIdDirect || m_op == GetByIdDirectFlush);
 590         m_opInfo = data;
 591         child1().setUseKind(CellUse);
 592         m_op = MultiGetByOffset;
 593         RELEASE_ASSERT(m_flags &amp; NodeMustGenerate);
 594     }
 595 
 596     void convertToPutByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 597     {
 598         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush || m_op == MultiPutByOffset);
 599         m_opInfo = &amp;data;
 600         children.setChild3(children.child2());
 601         children.setChild2(base);
 602         children.setChild1(storage);
 603         m_op = PutByOffset;
 604     }
 605 
 606     void convertToMultiPutByOffset(MultiPutByOffsetData* data)
 607     {
 608         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush);
 609         m_opInfo = data;
 610         m_op = MultiPutByOffset;
 611     }
 612 
 613     void convertToPhantomNewObject()
 614     {
 615         ASSERT(m_op == NewObject || m_op == MaterializeNewObject);
 616         m_op = PhantomNewObject;
 617         m_flags &amp;= ~NodeHasVarArgs;
 618         m_flags |= NodeMustGenerate;
 619         m_opInfo = OpInfoWrapper();
 620         m_opInfo2 = OpInfoWrapper();
 621         children = AdjacencyList();
 622     }
 623 
 624     void convertToPhantomNewFunction()
 625     {
 626         ASSERT(m_op == NewFunction || m_op == NewGeneratorFunction || m_op == NewAsyncFunction || m_op == NewAsyncGeneratorFunction);
 627         m_op = PhantomNewFunction;
 628         m_flags |= NodeMustGenerate;
 629         m_opInfo = OpInfoWrapper();
 630         m_opInfo2 = OpInfoWrapper();
 631         children = AdjacencyList();
 632     }
 633 
 634     void convertToPhantomNewGeneratorFunction()
 635     {
 636         ASSERT(m_op == NewGeneratorFunction);
 637         m_op = PhantomNewGeneratorFunction;
 638         m_flags |= NodeMustGenerate;
 639         m_opInfo = OpInfoWrapper();
 640         m_opInfo2 = OpInfoWrapper();
 641         children = AdjacencyList();
 642     }
 643 
 644     void convertToPhantomNewAsyncFunction()
 645     {
 646         ASSERT(m_op == NewAsyncFunction);
 647         m_op = PhantomNewAsyncFunction;
 648         m_flags |= NodeMustGenerate;
 649         m_opInfo = OpInfoWrapper();
 650         m_opInfo2 = OpInfoWrapper();
 651         children = AdjacencyList();
 652     }
 653 
 654     void convertToPhantomNewAsyncGeneratorFunction()
 655     {
 656         ASSERT(m_op == NewAsyncGeneratorFunction);
 657         m_op = PhantomNewAsyncGeneratorFunction;
 658         m_flags |= NodeMustGenerate;
 659         m_opInfo = OpInfoWrapper();
 660         m_opInfo2 = OpInfoWrapper();
 661         children = AdjacencyList();
 662     }
 663 
 664     void convertToPhantomCreateActivation()
 665     {
 666         ASSERT(m_op == CreateActivation || m_op == MaterializeCreateActivation);
 667         m_op = PhantomCreateActivation;
 668         m_flags &amp;= ~NodeHasVarArgs;
 669         m_flags |= NodeMustGenerate;
 670         m_opInfo = OpInfoWrapper();
 671         m_opInfo2 = OpInfoWrapper();
 672         children = AdjacencyList();
 673     }
 674 
 675     void convertToPhantomNewRegexp()
 676     {
 677         ASSERT(m_op == NewRegexp);
 678         setOpAndDefaultFlags(PhantomNewRegexp);
 679         m_opInfo = OpInfoWrapper();
 680         m_opInfo2 = OpInfoWrapper();
 681         children = AdjacencyList();
 682     }
 683 
 684     void convertPhantomToPhantomLocal()
 685     {
<a name="4" id="anc4"></a><span class="line-modified"> 686         ASSERT(m_op == Phantom &amp;&amp; (child1()-&gt;op() == Phi || child1()-&gt;op() == SetLocal || child1()-&gt;op() == SetArgumentDefinitely));</span>
 687         m_op = PhantomLocal;
 688         m_opInfo = child1()-&gt;m_opInfo; // Copy the variableAccessData.
 689         children.setChild1(Edge());
 690     }
 691 
 692     void convertFlushToPhantomLocal()
 693     {
 694         ASSERT(m_op == Flush);
 695         m_op = PhantomLocal;
 696         children = AdjacencyList();
 697     }
 698 
 699     void convertToToString()
 700     {
 701         ASSERT(m_op == ToPrimitive || m_op == StringValueOf);
 702         m_op = ToString;
 703     }
 704 
 705     void convertToArithNegate()
 706     {
 707         ASSERT(m_op == ArithAbs &amp;&amp; child1().useKind() == Int32Use);
 708         m_op = ArithNegate;
 709     }
 710 
 711     void convertToCompareEqPtr(FrozenValue* cell, Edge node)
 712     {
<a name="5" id="anc5"></a><span class="line-modified"> 713         ASSERT(m_op == CompareStrictEq || m_op == SameValue);</span>
 714         setOpAndDefaultFlags(CompareEqPtr);
 715         children.setChild1(node);
 716         children.setChild2(Edge());
 717         m_opInfo = cell;
 718     }
 719 
 720     void convertToNumberToStringWithValidRadixConstant(int32_t radix)
 721     {
 722         ASSERT(m_op == NumberToStringWithRadix);
 723         ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
 724         setOpAndDefaultFlags(NumberToStringWithValidRadixConstant);
 725         children.setChild2(Edge());
 726         m_opInfo = radix;
 727     }
 728 
 729     void convertToGetGlobalThis()
 730     {
 731         ASSERT(m_op == ToThis);
 732         setOpAndDefaultFlags(GetGlobalThis);
 733         children.setChild1(Edge());
 734     }
 735 
 736     void convertToCallObjectConstructor(FrozenValue* globalObject)
 737     {
 738         ASSERT(m_op == ToObject);
 739         setOpAndDefaultFlags(CallObjectConstructor);
 740         m_opInfo = globalObject;
 741     }
 742 
 743     void convertToNewStringObject(RegisteredStructure structure)
 744     {
 745         ASSERT(m_op == CallObjectConstructor || m_op == ToObject);
 746         setOpAndDefaultFlags(NewStringObject);
 747         m_opInfo = structure;
 748         m_opInfo2 = OpInfoWrapper();
 749     }
 750 
 751     void convertToNewObject(RegisteredStructure structure)
 752     {
 753         ASSERT(m_op == CallObjectConstructor || m_op == CreateThis || m_op == ObjectCreate);
 754         setOpAndDefaultFlags(NewObject);
 755         children.reset();
 756         m_opInfo = structure;
 757         m_opInfo2 = OpInfoWrapper();
 758     }
 759 
 760     void convertToNewArrayBuffer(FrozenValue* immutableButterfly);
 761 
 762     void convertToDirectCall(FrozenValue*);
 763 
 764     void convertToCallDOM(Graph&amp;);
 765 
 766     void convertToRegExpExecNonGlobalOrStickyWithoutChecks(FrozenValue* regExp);
 767     void convertToRegExpMatchFastGlobalWithoutChecks(FrozenValue* regExp);
 768 
 769     void convertToSetRegExpObjectLastIndex()
 770     {
 771         setOp(SetRegExpObjectLastIndex);
 772         m_opInfo = false;
 773     }
 774 
 775     void convertToInById(unsigned identifierNumber)
 776     {
 777         ASSERT(m_op == InByVal);
 778         setOpAndDefaultFlags(InById);
 779         children.setChild2(Edge());
 780         m_opInfo = identifierNumber;
 781         m_opInfo2 = OpInfoWrapper();
 782     }
 783 
 784     JSValue asJSValue()
 785     {
 786         return constant()-&gt;value();
 787     }
 788 
 789     bool isInt32Constant()
 790     {
 791         return isConstant() &amp;&amp; constant()-&gt;value().isInt32();
 792     }
 793 
 794     int32_t asInt32()
 795     {
 796         return asJSValue().asInt32();
 797     }
 798 
 799     uint32_t asUInt32()
 800     {
 801         return asInt32();
 802     }
 803 
 804     bool isDoubleConstant()
 805     {
 806         return isConstant() &amp;&amp; constant()-&gt;value().isDouble();
 807     }
 808 
 809     bool isNumberConstant()
 810     {
 811         return isConstant() &amp;&amp; constant()-&gt;value().isNumber();
 812     }
 813 
 814     double asNumber()
 815     {
 816         return asJSValue().asNumber();
 817     }
 818 
 819     bool isAnyIntConstant()
 820     {
 821         return isConstant() &amp;&amp; constant()-&gt;value().isAnyInt();
 822     }
 823 
 824     int64_t asAnyInt()
 825     {
 826         return asJSValue().asAnyInt();
 827     }
 828 
 829     bool isBooleanConstant()
 830     {
 831         return isConstant() &amp;&amp; constant()-&gt;value().isBoolean();
 832     }
 833 
 834     bool asBoolean()
 835     {
 836         return constant()-&gt;value().asBoolean();
 837     }
 838 
 839     bool isUndefinedOrNullConstant()
 840     {
 841         return isConstant() &amp;&amp; constant()-&gt;value().isUndefinedOrNull();
 842     }
 843 
 844     bool isCellConstant()
 845     {
 846         return isConstant() &amp;&amp; constant()-&gt;value() &amp;&amp; constant()-&gt;value().isCell();
 847     }
 848 
 849     JSCell* asCell()
 850     {
 851         return constant()-&gt;value().asCell();
 852     }
 853 
 854     template&lt;typename T&gt;
 855     T dynamicCastConstant(VM&amp; vm)
 856     {
 857         if (!isCellConstant())
 858             return nullptr;
 859         return jsDynamicCast&lt;T&gt;(vm, asCell());
 860     }
 861 
<a name="6" id="anc6"></a>







 862     bool hasLazyJSValue()
 863     {
 864         return op() == LazyJSConstant;
 865     }
 866 
 867     LazyJSValue lazyJSValue()
 868     {
 869         ASSERT(hasLazyJSValue());
 870         return *m_opInfo.as&lt;LazyJSValue*&gt;();
 871     }
 872 
 873     String tryGetString(Graph&amp;);
 874 
 875     JSValue initializationValueForActivation() const
 876     {
 877         ASSERT(op() == CreateActivation);
 878         return m_opInfo2.as&lt;FrozenValue*&gt;()-&gt;value();
 879     }
 880 
 881     bool hasArgumentsChild()
 882     {
 883         switch (op()) {
 884         case GetMyArgumentByVal:
 885         case GetMyArgumentByValOutOfBounds:
 886         case LoadVarargs:
 887         case ForwardVarargs:
 888         case CallVarargs:
 889         case CallForwardVarargs:
 890         case ConstructVarargs:
 891         case ConstructForwardVarargs:
 892         case TailCallVarargs:
 893         case TailCallForwardVarargs:
 894         case TailCallVarargsInlinedCaller:
 895         case TailCallForwardVarargsInlinedCaller:
 896             return true;
 897         default:
 898             return false;
 899         }
 900     }
 901 
 902     Edge&amp; argumentsChild()
 903     {
 904         switch (op()) {
 905         case GetMyArgumentByVal:
 906         case GetMyArgumentByValOutOfBounds:
 907         case LoadVarargs:
 908         case ForwardVarargs:
 909             return child1();
 910         case CallVarargs:
 911         case CallForwardVarargs:
 912         case ConstructVarargs:
 913         case ConstructForwardVarargs:
 914         case TailCallVarargs:
 915         case TailCallForwardVarargs:
 916         case TailCallVarargsInlinedCaller:
 917         case TailCallForwardVarargsInlinedCaller:
 918             return child3();
 919         default:
 920             RELEASE_ASSERT_NOT_REACHED();
 921             return child1();
 922         }
 923     }
 924 
 925     bool containsMovHint()
 926     {
 927         switch (op()) {
 928         case MovHint:
 929         case ZombieHint:
 930             return true;
 931         default:
 932             return false;
 933         }
 934     }
 935 
 936     bool hasVariableAccessData(Graph&amp;);
 937     bool accessesStack(Graph&amp; graph)
 938     {
 939         return hasVariableAccessData(graph);
 940     }
 941 
 942     // This is useful for debugging code, where a node that should have a variable
 943     // access data doesn&#39;t have one because it hasn&#39;t been initialized yet.
 944     VariableAccessData* tryGetVariableAccessData()
 945     {
 946         VariableAccessData* result = m_opInfo.as&lt;VariableAccessData*&gt;();
 947         if (!result)
 948             return 0;
 949         return result-&gt;find();
 950     }
 951 
 952     VariableAccessData* variableAccessData()
 953     {
 954         return m_opInfo.as&lt;VariableAccessData*&gt;()-&gt;find();
 955     }
 956 
 957     VirtualRegister local()
 958     {
 959         return variableAccessData()-&gt;local();
 960     }
 961 
 962     VirtualRegister machineLocal()
 963     {
 964         return variableAccessData()-&gt;machineLocal();
 965     }
 966 
 967     bool hasUnlinkedLocal()
 968     {
 969         switch (op()) {
 970         case ExtractOSREntryLocal:
 971         case MovHint:
 972         case ZombieHint:
 973         case KillStack:
 974             return true;
 975         default:
 976             return false;
 977         }
 978     }
 979 
 980     VirtualRegister unlinkedLocal()
 981     {
 982         ASSERT(hasUnlinkedLocal());
 983         return VirtualRegister(m_opInfo.as&lt;int32_t&gt;());
 984     }
 985 
 986     bool hasStackAccessData()
 987     {
 988         switch (op()) {
 989         case PutStack:
 990         case GetStack:
 991             return true;
 992         default:
 993             return false;
 994         }
 995     }
 996 
 997     StackAccessData* stackAccessData()
 998     {
 999         ASSERT(hasStackAccessData());
1000         return m_opInfo.as&lt;StackAccessData*&gt;();
1001     }
1002 
1003     unsigned argumentCountIncludingThis()
1004     {
1005         ASSERT(op() == SetArgumentCountIncludingThis);
1006         return m_opInfo.as&lt;unsigned&gt;();
1007     }
1008 
1009     bool hasPhi()
1010     {
1011         return op() == Upsilon;
1012     }
1013 
1014     Node* phi()
1015     {
1016         ASSERT(hasPhi());
1017         return m_opInfo.as&lt;Node*&gt;();
1018     }
1019 
1020     bool isStoreBarrier()
1021     {
1022         return op() == StoreBarrier || op() == FencedStoreBarrier;
1023     }
1024 
1025     bool hasIdentifier()
1026     {
1027         switch (op()) {
1028         case TryGetById:
1029         case GetById:
1030         case GetByIdFlush:
1031         case GetByIdWithThis:
1032         case GetByIdDirect:
1033         case GetByIdDirectFlush:
1034         case PutById:
1035         case PutByIdFlush:
1036         case PutByIdDirect:
1037         case PutByIdWithThis:
1038         case PutGetterById:
1039         case PutSetterById:
1040         case PutGetterSetterById:
1041         case DeleteById:
1042         case InById:
1043         case GetDynamicVar:
1044         case PutDynamicVar:
1045         case ResolveScopeForHoistingFuncDeclInEval:
1046         case ResolveScope:
1047         case ToObject:
1048             return true;
1049         default:
1050             return false;
1051         }
1052     }
1053 
1054     unsigned identifierNumber()
1055     {
1056         ASSERT(hasIdentifier());
1057         return m_opInfo.as&lt;unsigned&gt;();
1058     }
1059 
1060     bool hasGetPutInfo()
1061     {
1062         switch (op()) {
1063         case GetDynamicVar:
1064         case PutDynamicVar:
1065             return true;
1066         default:
1067             return false;
1068         }
1069     }
1070 
1071     unsigned getPutInfo()
1072     {
1073         ASSERT(hasGetPutInfo());
1074         return static_cast&lt;unsigned&gt;(m_opInfo.as&lt;uint64_t&gt;() &gt;&gt; 32);
1075     }
1076 
1077     bool hasAccessorAttributes()
1078     {
1079         switch (op()) {
1080         case PutGetterById:
1081         case PutSetterById:
1082         case PutGetterSetterById:
1083         case PutGetterByVal:
1084         case PutSetterByVal:
1085             return true;
1086         default:
1087             return false;
1088         }
1089     }
1090 
1091     int32_t accessorAttributes()
1092     {
1093         ASSERT(hasAccessorAttributes());
1094         switch (op()) {
1095         case PutGetterById:
1096         case PutSetterById:
1097         case PutGetterSetterById:
1098             return m_opInfo2.as&lt;int32_t&gt;();
1099         case PutGetterByVal:
1100         case PutSetterByVal:
1101             return m_opInfo.as&lt;int32_t&gt;();
1102         default:
1103             RELEASE_ASSERT_NOT_REACHED();
1104             return 0;
1105         }
1106     }
1107 
1108     bool hasPromotedLocationDescriptor()
1109     {
1110         return op() == PutHint;
1111     }
1112 
1113     PromotedLocationDescriptor promotedLocationDescriptor();
1114 
1115     // This corrects the arithmetic node flags, so that irrelevant bits are
1116     // ignored. In particular, anything other than ArithMul or ValueMul does not need
1117     // to know if it can speculate on negative zero.
1118     NodeFlags arithNodeFlags()
1119     {
1120         NodeFlags result = m_flags &amp; NodeArithFlagsMask;
1121         if (op() == ArithMul || op() == ArithDiv || op() == ValueDiv || op() == ArithMod || op() == ArithNegate || op() == ArithPow || op() == ArithRound || op() == ArithFloor || op() == ArithCeil || op() == ArithTrunc || op() == DoubleAsInt32 || op() == ValueNegate || op() == ValueMul || op() == ValueDiv)
1122             return result;
1123         return result &amp; ~NodeBytecodeNeedsNegZero;
1124     }
1125 
1126     bool mayHaveNonIntResult()
1127     {
1128         return m_flags &amp; NodeMayHaveNonIntResult;
1129     }
1130 
1131     bool mayHaveDoubleResult()
1132     {
1133         return m_flags &amp; NodeMayHaveDoubleResult;
1134     }
1135 
1136     bool mayHaveNonNumericResult()
1137     {
1138         return m_flags &amp; NodeMayHaveNonNumericResult;
1139     }
1140 
1141     bool mayHaveBigIntResult()
1142     {
1143         return m_flags &amp; NodeMayHaveBigIntResult;
1144     }
1145 
1146     bool hasNewArrayBufferData()
1147     {
1148         return op() == NewArrayBuffer || op() == PhantomNewArrayBuffer;
1149     }
1150 
1151     NewArrayBufferData newArrayBufferData()
1152     {
1153         ASSERT(hasNewArrayBufferData());
1154         return m_opInfo2.asNewArrayBufferData();
1155     }
1156 
1157     unsigned hasVectorLengthHint()
1158     {
1159         switch (op()) {
1160         case NewArray:
1161         case NewArrayBuffer:
1162         case PhantomNewArrayBuffer:
1163             return true;
1164         default:
1165             return false;
1166         }
1167     }
1168 
1169     unsigned vectorLengthHint()
1170     {
1171         ASSERT(hasVectorLengthHint());
1172         if (op() == NewArray)
1173             return m_opInfo2.as&lt;unsigned&gt;();
1174         return newArrayBufferData().vectorLengthHint;
1175     }
1176 
1177     bool hasIndexingType()
1178     {
1179         switch (op()) {
1180         case NewArray:
1181         case NewArrayWithSize:
1182         case NewArrayBuffer:
1183         case PhantomNewArrayBuffer:
1184             return true;
1185         default:
1186             return false;
1187         }
1188     }
1189 
1190     BitVector* bitVector()
1191     {
1192         ASSERT(op() == NewArrayWithSpread || op() == PhantomNewArrayWithSpread);
1193         return m_opInfo.as&lt;BitVector*&gt;();
1194     }
1195 
1196     // Return the indexing type that an array allocation *wants* to use. It may end up using a different
1197     // type if we&#39;re having a bad time. You can determine the actual indexing type by asking the global
1198     // object:
1199     //
1200     //     m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())
1201     //
1202     // This will give you a Structure*, and that will have some indexing type that may be different from
1203     // the this one.
1204     IndexingType indexingType()
1205     {
1206         ASSERT(hasIndexingType());
1207         if (op() == NewArrayBuffer || op() == PhantomNewArrayBuffer)
1208             return static_cast&lt;IndexingType&gt;(newArrayBufferData().indexingMode) &amp; IndexingTypeMask;
1209         return static_cast&lt;IndexingType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1210     }
1211 
1212     IndexingType indexingMode()
1213     {
1214         ASSERT(hasIndexingType());
1215         if (op() == NewArrayBuffer || op() == PhantomNewArrayBuffer)
1216             return static_cast&lt;IndexingType&gt;(newArrayBufferData().indexingMode);
1217         return static_cast&lt;IndexingType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1218     }
1219 
1220     bool hasTypedArrayType()
1221     {
1222         switch (op()) {
1223         case NewTypedArray:
1224             return true;
1225         default:
1226             return false;
1227         }
1228     }
1229 
1230     TypedArrayType typedArrayType()
1231     {
1232         ASSERT(hasTypedArrayType());
1233         TypedArrayType result = static_cast&lt;TypedArrayType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1234         ASSERT(isTypedView(result));
1235         return result;
1236     }
1237 
1238     bool hasInlineCapacity()
1239     {
1240         return op() == CreateThis;
1241     }
1242 
1243     unsigned inlineCapacity()
1244     {
1245         ASSERT(hasInlineCapacity());
1246         return m_opInfo.as&lt;unsigned&gt;();
1247     }
1248 
1249     void setIndexingType(IndexingType indexingType)
1250     {
1251         ASSERT(hasIndexingType());
1252         m_opInfo = indexingType;
1253     }
1254 
1255     bool hasScopeOffset()
1256     {
1257         return op() == GetClosureVar || op() == PutClosureVar;
1258     }
1259 
1260     ScopeOffset scopeOffset()
1261     {
1262         ASSERT(hasScopeOffset());
1263         return ScopeOffset(m_opInfo.as&lt;uint32_t&gt;());
1264     }
1265 
1266     bool hasDirectArgumentsOffset()
1267     {
1268         return op() == GetFromArguments || op() == PutToArguments;
1269     }
1270 
1271     DirectArgumentsOffset capturedArgumentsOffset()
1272     {
1273         ASSERT(hasDirectArgumentsOffset());
1274         return DirectArgumentsOffset(m_opInfo.as&lt;uint32_t&gt;());
1275     }
1276 
1277     bool hasRegisterPointer()
1278     {
1279         return op() == GetGlobalVar || op() == GetGlobalLexicalVariable || op() == PutGlobalVariable;
1280     }
1281 
1282     WriteBarrier&lt;Unknown&gt;* variablePointer()
1283     {
1284         return m_opInfo.as&lt;WriteBarrier&lt;Unknown&gt;*&gt;();
1285     }
1286 
1287     bool hasCallVarargsData()
1288     {
1289         switch (op()) {
1290         case CallVarargs:
1291         case CallForwardVarargs:
1292         case TailCallVarargs:
1293         case TailCallForwardVarargs:
1294         case TailCallVarargsInlinedCaller:
1295         case TailCallForwardVarargsInlinedCaller:
1296         case ConstructVarargs:
1297         case ConstructForwardVarargs:
1298             return true;
1299         default:
1300             return false;
1301         }
1302     }
1303 
1304     CallVarargsData* callVarargsData()
1305     {
1306         ASSERT(hasCallVarargsData());
1307         return m_opInfo.as&lt;CallVarargsData*&gt;();
1308     }
1309 
1310     bool hasLoadVarargsData()
1311     {
1312         return op() == LoadVarargs || op() == ForwardVarargs;
1313     }
1314 
1315     LoadVarargsData* loadVarargsData()
1316     {
1317         ASSERT(hasLoadVarargsData());
1318         return m_opInfo.as&lt;LoadVarargsData*&gt;();
1319     }
1320 
1321     InlineCallFrame* argumentsInlineCallFrame()
1322     {
1323         ASSERT(op() == GetArgumentCountIncludingThis);
1324         return m_opInfo.as&lt;InlineCallFrame*&gt;();
1325     }
1326 
1327     bool hasQueriedType()
1328     {
1329         return op() == IsCellWithType;
1330     }
1331 
1332     JSType queriedType()
1333     {
1334         static_assert(std::is_same&lt;uint8_t, std::underlying_type&lt;JSType&gt;::type&gt;::value, &quot;Ensure that uint8_t is the underlying type for JSType.&quot;);
1335         return static_cast&lt;JSType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1336     }
1337 
1338     bool hasSpeculatedTypeForQuery()
1339     {
1340         return op() == IsCellWithType;
1341     }
1342 
1343     SpeculatedType speculatedTypeForQuery()
1344     {
1345         return speculationFromJSType(queriedType());
1346     }
1347 
1348     bool hasResult()
1349     {
1350         return !!result();
1351     }
1352 
1353     bool hasInt32Result()
1354     {
1355         return result() == NodeResultInt32;
1356     }
1357 
1358     bool hasInt52Result()
1359     {
1360         return result() == NodeResultInt52;
1361     }
1362 
1363     bool hasNumberResult()
1364     {
1365         return result() == NodeResultNumber;
1366     }
1367 
1368     bool hasNumberOrAnyIntResult()
1369     {
1370         return hasNumberResult() || hasInt32Result() || hasInt52Result();
1371     }
1372 
1373     bool hasNumericResult()
1374     {
1375         switch (op()) {
1376         case ValueSub:
1377         case ValueMul:
1378         case ValueBitAnd:
1379         case ValueBitOr:
1380         case ValueBitXor:
1381         case ValueNegate:
1382             return true;
1383         default:
1384             return false;
1385         }
1386     }
1387 
1388     bool hasDoubleResult()
1389     {
1390         return result() == NodeResultDouble;
1391     }
1392 
1393     bool hasJSResult()
1394     {
1395         return result() == NodeResultJS;
1396     }
1397 
1398     bool hasBooleanResult()
1399     {
1400         return result() == NodeResultBoolean;
1401     }
1402 
1403     bool hasStorageResult()
1404     {
1405         return result() == NodeResultStorage;
1406     }
1407 
1408     UseKind defaultUseKind()
1409     {
1410         return useKindForResult(result());
1411     }
1412 
1413     Edge defaultEdge()
1414     {
1415         return Edge(this, defaultUseKind());
1416     }
1417 
1418     bool isJump()
1419     {
1420         return op() == Jump;
1421     }
1422 
1423     bool isBranch()
1424     {
1425         return op() == Branch;
1426     }
1427 
1428     bool isSwitch() const
1429     {
1430         return op() == Switch;
1431     }
1432 
1433     bool isEntrySwitch() const
1434     {
1435         return op() == EntrySwitch;
1436     }
1437 
1438     bool isTerminal()
1439     {
1440         switch (op()) {
1441         case Jump:
1442         case Branch:
1443         case Switch:
1444         case EntrySwitch:
1445         case Return:
1446         case TailCall:
1447         case DirectTailCall:
1448         case TailCallVarargs:
1449         case TailCallForwardVarargs:
1450         case Unreachable:
1451         case Throw:
1452         case ThrowStaticError:
1453             return true;
1454         default:
1455             return false;
1456         }
1457     }
1458 
1459     bool isFunctionTerminal()
1460     {
1461         if (isTerminal() &amp;&amp; !numSuccessors())
1462             return true;
1463 
1464         return false;
1465     }
1466 
1467     // As is described in DFGNodeType.h&#39;s ForceOSRExit, this is a pseudo-terminal.
1468     // It means that execution should fall out of DFG at this point, but execution
1469     // does continue in the basic block - just in a different compiler.
1470     // FIXME: This is used for lightweight reachability decision. But this should
1471     // be replaced with AI-based reachability ideally.
1472     bool isPseudoTerminal()
1473     {
1474         switch (op()) {
1475         case ForceOSRExit:
1476         case CheckBadCell:
1477             return true;
1478         default:
1479             return false;
1480         }
1481     }
1482 
1483     unsigned targetBytecodeOffsetDuringParsing()
1484     {
1485         ASSERT(isJump());
1486         return m_opInfo.as&lt;unsigned&gt;();
1487     }
1488 
1489     BasicBlock*&amp; targetBlock()
1490     {
1491         ASSERT(isJump());
1492         return *bitwise_cast&lt;BasicBlock**&gt;(&amp;m_opInfo.u.pointer);
1493     }
1494 
1495     BranchData* branchData()
1496     {
1497         ASSERT(isBranch());
1498         return m_opInfo.as&lt;BranchData*&gt;();
1499     }
1500 
1501     SwitchData* switchData()
1502     {
1503         ASSERT(isSwitch());
1504         return m_opInfo.as&lt;SwitchData*&gt;();
1505     }
1506 
1507     EntrySwitchData* entrySwitchData()
1508     {
1509         ASSERT(isEntrySwitch());
1510         return m_opInfo.as&lt;EntrySwitchData*&gt;();
1511     }
1512 
1513     Intrinsic intrinsic()
1514     {
1515         RELEASE_ASSERT(op() == CPUIntrinsic);
1516         return m_opInfo.as&lt;Intrinsic&gt;();
1517     }
1518 
1519     unsigned numSuccessors()
1520     {
1521         switch (op()) {
1522         case Jump:
1523             return 1;
1524         case Branch:
1525             return 2;
1526         case Switch:
1527             return switchData()-&gt;cases.size() + 1;
1528         case EntrySwitch:
1529             return entrySwitchData()-&gt;cases.size();
1530         default:
1531             return 0;
1532         }
1533     }
1534 
1535     BasicBlock*&amp; successor(unsigned index)
1536     {
1537         if (isSwitch()) {
1538             if (index &lt; switchData()-&gt;cases.size())
1539                 return switchData()-&gt;cases[index].target.block;
1540             RELEASE_ASSERT(index == switchData()-&gt;cases.size());
1541             return switchData()-&gt;fallThrough.block;
1542         } else if (isEntrySwitch())
1543             return entrySwitchData()-&gt;cases[index];
1544 
1545         switch (index) {
1546         case 0:
1547             if (isJump())
1548                 return targetBlock();
1549             return branchData()-&gt;taken.block;
1550         case 1:
1551             return branchData()-&gt;notTaken.block;
1552         default:
1553             RELEASE_ASSERT_NOT_REACHED();
1554             return targetBlock();
1555         }
1556     }
1557 
1558     class SuccessorsIterable {
1559     public:
1560         SuccessorsIterable()
1561             : m_terminal(nullptr)
1562         {
1563         }
1564 
1565         SuccessorsIterable(Node* terminal)
1566             : m_terminal(terminal)
1567         {
1568         }
1569 
1570         class iterator {
1571         public:
1572             iterator()
1573                 : m_terminal(nullptr)
1574                 , m_index(UINT_MAX)
1575             {
1576             }
1577 
1578             iterator(Node* terminal, unsigned index)
1579                 : m_terminal(terminal)
1580                 , m_index(index)
1581             {
1582             }
1583 
1584             BasicBlock* operator*()
1585             {
1586                 return m_terminal-&gt;successor(m_index);
1587             }
1588 
1589             iterator&amp; operator++()
1590             {
1591                 m_index++;
1592                 return *this;
1593             }
1594 
1595             bool operator==(const iterator&amp; other) const
1596             {
1597                 return m_index == other.m_index;
1598             }
1599 
1600             bool operator!=(const iterator&amp; other) const
1601             {
1602                 return !(*this == other);
1603             }
1604         private:
1605             Node* m_terminal;
1606             unsigned m_index;
1607         };
1608 
1609         iterator begin()
1610         {
1611             return iterator(m_terminal, 0);
1612         }
1613 
1614         iterator end()
1615         {
1616             return iterator(m_terminal, m_terminal-&gt;numSuccessors());
1617         }
1618 
1619         size_t size() const { return m_terminal-&gt;numSuccessors(); }
1620         BasicBlock* at(size_t index) const { return m_terminal-&gt;successor(index); }
1621         BasicBlock* operator[](size_t index) const { return at(index); }
1622 
1623     private:
1624         Node* m_terminal;
1625     };
1626 
1627     SuccessorsIterable successors()
1628     {
1629         return SuccessorsIterable(this);
1630     }
1631 
1632     BasicBlock*&amp; successorForCondition(bool condition)
1633     {
1634         return branchData()-&gt;forCondition(condition);
1635     }
1636 
1637     bool hasHeapPrediction()
1638     {
1639         switch (op()) {
1640         case ArithAbs:
1641         case ArithRound:
1642         case ArithFloor:
1643         case ArithCeil:
1644         case ArithTrunc:
1645         case GetDirectPname:
1646         case GetById:
1647         case GetByIdFlush:
1648         case GetByIdWithThis:
1649         case GetByIdDirect:
1650         case GetByIdDirectFlush:
1651         case GetPrototypeOf:
1652         case TryGetById:
1653         case GetByVal:
1654         case GetByValWithThis:
1655         case Call:
1656         case DirectCall:
1657         case TailCallInlinedCaller:
1658         case DirectTailCallInlinedCaller:
1659         case Construct:
1660         case DirectConstruct:
1661         case CallVarargs:
1662         case CallEval:
1663         case TailCallVarargsInlinedCaller:
1664         case ConstructVarargs:
1665         case CallForwardVarargs:
1666         case TailCallForwardVarargsInlinedCaller:
1667         case GetByOffset:
1668         case MultiGetByOffset:
1669         case GetClosureVar:
1670         case GetFromArguments:
1671         case GetArgument:
1672         case ArrayPop:
1673         case ArrayPush:
1674         case RegExpExec:
1675         case RegExpExecNonGlobalOrSticky:
1676         case RegExpTest:
1677         case RegExpMatchFast:
1678         case RegExpMatchFastGlobal:
1679         case GetGlobalVar:
1680         case GetGlobalLexicalVariable:
1681         case StringReplace:
1682         case StringReplaceRegExp:
1683         case ToNumber:
1684         case ToObject:
1685         case ValueBitAnd:
1686         case ValueBitOr:
1687         case ValueBitXor:
<a name="7" id="anc7"></a><span class="line-added">1688         case ValueBitNot:</span>
<span class="line-added">1689         case ValueBitLShift:</span>
1690         case CallObjectConstructor:
1691         case LoadKeyFromMapBucket:
1692         case LoadValueFromMapBucket:
1693         case CallDOMGetter:
1694         case CallDOM:
1695         case ParseInt:
1696         case AtomicsAdd:
1697         case AtomicsAnd:
1698         case AtomicsCompareExchange:
1699         case AtomicsExchange:
1700         case AtomicsLoad:
1701         case AtomicsOr:
1702         case AtomicsStore:
1703         case AtomicsSub:
1704         case AtomicsXor:
1705         case GetDynamicVar:
1706         case ExtractValueFromWeakMapGet:
1707         case ToThis:
1708         case DataViewGetInt:
1709         case DataViewGetFloat:
1710             return true;
1711         default:
1712             return false;
1713         }
1714     }
1715 
1716     SpeculatedType getHeapPrediction()
1717     {
1718         ASSERT(hasHeapPrediction());
1719         return m_opInfo2.as&lt;SpeculatedType&gt;();
1720     }
1721 
1722     void setHeapPrediction(SpeculatedType prediction)
1723     {
1724         ASSERT(hasHeapPrediction());
1725         m_opInfo2 = prediction;
1726     }
1727 
1728     SpeculatedType getForcedPrediction()
1729     {
1730         ASSERT(op() == IdentityWithProfile);
1731         return m_opInfo.as&lt;SpeculatedType&gt;();
1732     }
1733 
1734     uint32_t catchOSREntryIndex() const
1735     {
1736         ASSERT(op() == ExtractCatchLocal);
1737         return m_opInfo.as&lt;uint32_t&gt;();
1738     }
1739 
1740     SpeculatedType catchLocalPrediction()
1741     {
1742         ASSERT(op() == ExtractCatchLocal);
1743         return m_opInfo2.as&lt;SpeculatedType&gt;();
1744     }
1745 
1746     bool hasCellOperand()
1747     {
1748         switch (op()) {
1749         case CheckCell:
1750         case OverridesHasInstance:
1751         case NewFunction:
1752         case NewGeneratorFunction:
1753         case NewAsyncFunction:
1754         case NewAsyncGeneratorFunction:
1755         case CreateActivation:
1756         case MaterializeCreateActivation:
1757         case NewRegexp:
1758         case NewArrayBuffer:
1759         case PhantomNewArrayBuffer:
1760         case CompareEqPtr:
1761         case CallObjectConstructor:
1762         case DirectCall:
1763         case DirectTailCall:
1764         case DirectConstruct:
1765         case DirectTailCallInlinedCaller:
1766         case RegExpExecNonGlobalOrSticky:
1767         case RegExpMatchFastGlobal:
1768             return true;
1769         default:
1770             return false;
1771         }
1772     }
1773 
1774     FrozenValue* cellOperand()
1775     {
1776         ASSERT(hasCellOperand());
1777         return m_opInfo.as&lt;FrozenValue*&gt;();
1778     }
1779 
1780     template&lt;typename T&gt;
1781     T castOperand()
1782     {
1783         return cellOperand()-&gt;cast&lt;T&gt;();
1784     }
1785 
1786     void setCellOperand(FrozenValue* value)
1787     {
1788         ASSERT(hasCellOperand());
1789         m_opInfo = value;
1790     }
1791 
1792     bool hasWatchpointSet()
1793     {
1794         return op() == NotifyWrite;
1795     }
1796 
1797     WatchpointSet* watchpointSet()
1798     {
1799         ASSERT(hasWatchpointSet());
1800         return m_opInfo.as&lt;WatchpointSet*&gt;();
1801     }
1802 
1803     bool hasStoragePointer()
1804     {
1805         return op() == ConstantStoragePointer;
1806     }
1807 
1808     void* storagePointer()
1809     {
1810         ASSERT(hasStoragePointer());
1811         return m_opInfo.as&lt;void*&gt;();
1812     }
1813 
1814     bool hasUidOperand()
1815     {
1816         return op() == CheckStringIdent;
1817     }
1818 
1819     UniquedStringImpl* uidOperand()
1820     {
1821         ASSERT(hasUidOperand());
1822         return m_opInfo.as&lt;UniquedStringImpl*&gt;();
1823     }
1824 
1825     bool hasTypeInfoOperand()
1826     {
1827         return op() == CheckTypeInfoFlags;
1828     }
1829 
1830     unsigned typeInfoOperand()
1831     {
1832         ASSERT(hasTypeInfoOperand() &amp;&amp; m_opInfo.as&lt;uint32_t&gt;() &lt;= static_cast&lt;uint32_t&gt;(UCHAR_MAX));
1833         return m_opInfo.as&lt;uint32_t&gt;();
1834     }
1835 
1836     bool hasTransition()
1837     {
1838         switch (op()) {
1839         case PutStructure:
1840         case AllocatePropertyStorage:
1841         case ReallocatePropertyStorage:
1842             return true;
1843         default:
1844             return false;
1845         }
1846     }
1847 
1848     Transition* transition()
1849     {
1850         ASSERT(hasTransition());
1851         return m_opInfo.as&lt;Transition*&gt;();
1852     }
1853 
1854     bool hasStructureSet()
1855     {
1856         switch (op()) {
1857         case CheckStructure:
1858         case CheckStructureOrEmpty:
1859         case CheckStructureImmediate:
1860         case MaterializeNewObject:
1861             return true;
1862         default:
1863             return false;
1864         }
1865     }
1866 
1867     const RegisteredStructureSet&amp; structureSet()
1868     {
1869         ASSERT(hasStructureSet());
1870         return *m_opInfo.as&lt;RegisteredStructureSet*&gt;();
1871     }
1872 
1873     bool hasStructure()
1874     {
1875         switch (op()) {
1876         case ArrayifyToStructure:
1877         case NewObject:
1878         case NewStringObject:
1879             return true;
1880         default:
1881             return false;
1882         }
1883     }
1884 
1885     RegisteredStructure structure()
1886     {
1887         ASSERT(hasStructure());
1888         return m_opInfo.asRegisteredStructure();
1889     }
1890 
1891     bool hasStorageAccessData()
1892     {
1893         switch (op()) {
1894         case GetByOffset:
1895         case PutByOffset:
1896         case GetGetterSetterByOffset:
1897             return true;
1898         default:
1899             return false;
1900         }
1901     }
1902 
1903     StorageAccessData&amp; storageAccessData()
1904     {
1905         ASSERT(hasStorageAccessData());
1906         return *m_opInfo.as&lt;StorageAccessData*&gt;();
1907     }
1908 
1909     bool hasMultiGetByOffsetData()
1910     {
1911         return op() == MultiGetByOffset;
1912     }
1913 
1914     MultiGetByOffsetData&amp; multiGetByOffsetData()
1915     {
1916         ASSERT(hasMultiGetByOffsetData());
1917         return *m_opInfo.as&lt;MultiGetByOffsetData*&gt;();
1918     }
1919 
1920     bool hasMultiPutByOffsetData()
1921     {
1922         return op() == MultiPutByOffset;
1923     }
1924 
1925     MultiPutByOffsetData&amp; multiPutByOffsetData()
1926     {
1927         ASSERT(hasMultiPutByOffsetData());
1928         return *m_opInfo.as&lt;MultiPutByOffsetData*&gt;();
1929     }
1930 
1931     bool hasMatchStructureData()
1932     {
1933         return op() == MatchStructure;
1934     }
1935 
1936     MatchStructureData&amp; matchStructureData()
1937     {
1938         ASSERT(hasMatchStructureData());
1939         return *m_opInfo.as&lt;MatchStructureData*&gt;();
1940     }
1941 
1942     bool hasObjectMaterializationData()
1943     {
1944         switch (op()) {
1945         case MaterializeNewObject:
1946         case MaterializeCreateActivation:
1947             return true;
1948 
1949         default:
1950             return false;
1951         }
1952     }
1953 
1954     ObjectMaterializationData&amp; objectMaterializationData()
1955     {
1956         ASSERT(hasObjectMaterializationData());
1957         return *m_opInfo2.as&lt;ObjectMaterializationData*&gt;();
1958     }
1959 
1960     bool isObjectAllocation()
1961     {
1962         switch (op()) {
1963         case NewObject:
1964         case MaterializeNewObject:
1965             return true;
1966         default:
1967             return false;
1968         }
1969     }
1970 
1971     bool isPhantomObjectAllocation()
1972     {
1973         switch (op()) {
1974         case PhantomNewObject:
1975             return true;
1976         default:
1977             return false;
1978         }
1979     }
1980 
1981     bool isActivationAllocation()
1982     {
1983         switch (op()) {
1984         case CreateActivation:
1985         case MaterializeCreateActivation:
1986             return true;
1987         default:
1988             return false;
1989         }
1990     }
1991 
1992     bool isPhantomActivationAllocation()
1993     {
1994         switch (op()) {
1995         case PhantomCreateActivation:
1996             return true;
1997         default:
1998             return false;
1999         }
2000     }
2001 
2002     bool isFunctionAllocation()
2003     {
2004         switch (op()) {
2005         case NewFunction:
2006         case NewGeneratorFunction:
2007         case NewAsyncGeneratorFunction:
2008         case NewAsyncFunction:
2009             return true;
2010         default:
2011             return false;
2012         }
2013     }
2014 
2015     bool isPhantomFunctionAllocation()
2016     {
2017         switch (op()) {
2018         case PhantomNewFunction:
2019         case PhantomNewGeneratorFunction:
2020         case PhantomNewAsyncFunction:
2021         case PhantomNewAsyncGeneratorFunction:
2022             return true;
2023         default:
2024             return false;
2025         }
2026     }
2027 
2028     bool isPhantomAllocation()
2029     {
2030         switch (op()) {
2031         case PhantomNewObject:
2032         case PhantomDirectArguments:
2033         case PhantomCreateRest:
2034         case PhantomSpread:
2035         case PhantomNewArrayWithSpread:
2036         case PhantomNewArrayBuffer:
2037         case PhantomClonedArguments:
2038         case PhantomNewFunction:
2039         case PhantomNewGeneratorFunction:
2040         case PhantomNewAsyncFunction:
2041         case PhantomNewAsyncGeneratorFunction:
2042         case PhantomCreateActivation:
2043         case PhantomNewRegexp:
2044             return true;
2045         default:
2046             return false;
2047         }
2048     }
2049 
2050     bool hasArrayMode()
2051     {
2052         switch (op()) {
2053         case GetIndexedPropertyStorage:
2054         case GetArrayLength:
2055         case GetVectorLength:
2056         case InByVal:
2057         case PutByValDirect:
2058         case PutByVal:
2059         case PutByValAlias:
2060         case GetByVal:
2061         case StringCharAt:
2062         case StringCharCodeAt:
2063         case CheckArray:
2064         case Arrayify:
2065         case ArrayifyToStructure:
2066         case ArrayPush:
2067         case ArrayPop:
2068         case ArrayIndexOf:
2069         case HasIndexedProperty:
2070         case AtomicsAdd:
2071         case AtomicsAnd:
2072         case AtomicsCompareExchange:
2073         case AtomicsExchange:
2074         case AtomicsLoad:
2075         case AtomicsOr:
2076         case AtomicsStore:
2077         case AtomicsSub:
2078         case AtomicsXor:
2079             return true;
2080         default:
2081             return false;
2082         }
2083     }
2084 
2085     ArrayMode arrayMode()
2086     {
2087         ASSERT(hasArrayMode());
2088         if (op() == ArrayifyToStructure)
2089             return ArrayMode::fromWord(m_opInfo2.as&lt;uint32_t&gt;());
2090         return ArrayMode::fromWord(m_opInfo.as&lt;uint32_t&gt;());
2091     }
2092 
2093     bool setArrayMode(ArrayMode arrayMode)
2094     {
2095         ASSERT(hasArrayMode());
2096         if (this-&gt;arrayMode() == arrayMode)
2097             return false;
2098         m_opInfo = arrayMode.asWord();
2099         return true;
2100     }
2101 
2102     bool hasArithMode()
2103     {
2104         switch (op()) {
2105         case ArithAbs:
2106         case ArithAdd:
2107         case ArithSub:
2108         case ArithNegate:
2109         case ArithMul:
2110         case ArithDiv:
2111         case ArithMod:
2112         case UInt32ToNumber:
2113         case DoubleAsInt32:
2114             return true;
2115         default:
2116             return false;
2117         }
2118     }
2119 
2120     Arith::Mode arithMode()
2121     {
2122         ASSERT(hasArithMode());
2123         return static_cast&lt;Arith::Mode&gt;(m_opInfo.as&lt;uint32_t&gt;());
2124     }
2125 
2126     void setArithMode(Arith::Mode mode)
2127     {
2128         m_opInfo = mode;
2129     }
2130 
2131     bool hasArithRoundingMode()
2132     {
2133         return op() == ArithRound || op() == ArithFloor || op() == ArithCeil || op() == ArithTrunc;
2134     }
2135 
2136     Arith::RoundingMode arithRoundingMode()
2137     {
2138         ASSERT(hasArithRoundingMode());
2139         return static_cast&lt;Arith::RoundingMode&gt;(m_opInfo.as&lt;uint32_t&gt;());
2140     }
2141 
2142     void setArithRoundingMode(Arith::RoundingMode mode)
2143     {
2144         ASSERT(hasArithRoundingMode());
2145         m_opInfo = static_cast&lt;uint32_t&gt;(mode);
2146     }
2147 
2148     bool hasArithUnaryType()
2149     {
2150         return op() == ArithUnary;
2151     }
2152 
2153     Arith::UnaryType arithUnaryType()
2154     {
2155         ASSERT(hasArithUnaryType());
2156         return static_cast&lt;Arith::UnaryType&gt;(m_opInfo.as&lt;uint32_t&gt;());
2157     }
2158 
2159     bool hasVirtualRegister()
2160     {
2161         return m_virtualRegister.isValid();
2162     }
2163 
2164     VirtualRegister virtualRegister()
2165     {
2166         ASSERT(hasResult());
2167         ASSERT(m_virtualRegister.isValid());
2168         return m_virtualRegister;
2169     }
2170 
2171     void setVirtualRegister(VirtualRegister virtualRegister)
2172     {
2173         ASSERT(hasResult());
2174         ASSERT(!m_virtualRegister.isValid());
2175         m_virtualRegister = virtualRegister;
2176     }
2177 
2178     bool hasExecutionCounter()
2179     {
2180         return op() == CountExecution;
2181     }
2182 
2183     Profiler::ExecutionCounter* executionCounter()
2184     {
2185         return m_opInfo.as&lt;Profiler::ExecutionCounter*&gt;();
2186     }
2187 
2188     unsigned entrypointIndex()
2189     {
2190         ASSERT(op() == InitializeEntrypointArguments);
2191         return m_opInfo.as&lt;unsigned&gt;();
2192     }
2193 
2194     DataViewData dataViewData()
2195     {
2196         ASSERT(op() == DataViewGetInt || op() == DataViewGetFloat || op() == DataViewSet);
2197         return bitwise_cast&lt;DataViewData&gt;(m_opInfo.as&lt;uint64_t&gt;());
2198     }
2199 
2200     bool shouldGenerate()
2201     {
2202         return m_refCount;
2203     }
2204 
2205     // Return true if the execution of this Node does not affect our ability to OSR to the FTL.
2206     // FIXME: Isn&#39;t this just like checking if the node has effects?
2207     bool isSemanticallySkippable()
2208     {
2209         return op() == CountExecution || op() == InvalidationPoint;
2210     }
2211 
2212     unsigned refCount()
2213     {
2214         return m_refCount;
2215     }
2216 
2217     unsigned postfixRef()
2218     {
2219         return m_refCount++;
2220     }
2221 
2222     unsigned adjustedRefCount()
2223     {
2224         return mustGenerate() ? m_refCount - 1 : m_refCount;
2225     }
2226 
2227     void setRefCount(unsigned refCount)
2228     {
2229         m_refCount = refCount;
2230     }
2231 
2232     Edge&amp; child1()
2233     {
2234         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2235         return children.child1();
2236     }
2237 
2238     // This is useful if you want to do a fast check on the first child
2239     // before also doing a check on the opcode. Use this with care and
2240     // avoid it if possible.
2241     Edge child1Unchecked()
2242     {
2243         return children.child1Unchecked();
2244     }
2245 
2246     Edge&amp; child2()
2247     {
2248         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2249         return children.child2();
2250     }
2251 
2252     Edge&amp; child3()
2253     {
2254         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2255         return children.child3();
2256     }
2257 
2258     unsigned firstChild()
2259     {
2260         ASSERT(m_flags &amp; NodeHasVarArgs);
2261         return children.firstChild();
2262     }
2263 
2264     unsigned numChildren()
2265     {
2266         ASSERT(m_flags &amp; NodeHasVarArgs);
2267         return children.numChildren();
2268     }
2269 
2270     UseKind binaryUseKind()
2271     {
2272         ASSERT(child1().useKind() == child2().useKind());
2273         return child1().useKind();
2274     }
2275 
2276     bool isBinaryUseKind(UseKind left, UseKind right)
2277     {
2278         return child1().useKind() == left &amp;&amp; child2().useKind() == right;
2279     }
2280 
2281     bool isBinaryUseKind(UseKind useKind)
2282     {
2283         return isBinaryUseKind(useKind, useKind);
2284     }
2285 
2286     Edge childFor(UseKind useKind)
2287     {
2288         if (child1().useKind() == useKind)
2289             return child1();
2290         if (child2().useKind() == useKind)
2291             return child2();
2292         if (child3().useKind() == useKind)
2293             return child3();
2294         return Edge();
2295     }
2296 
2297     SpeculatedType prediction()
2298     {
2299         return m_prediction;
2300     }
2301 
2302     bool predict(SpeculatedType prediction)
2303     {
2304         return mergeSpeculation(m_prediction, prediction);
2305     }
2306 
2307     bool shouldSpeculateInt32()
2308     {
2309         return isInt32Speculation(prediction());
2310     }
2311 
2312     bool shouldSpeculateNotInt32()
2313     {
2314         return isNotInt32Speculation(prediction());
2315     }
2316 
2317     bool sawBooleans()
2318     {
2319         return !!(prediction() &amp; SpecBoolean);
2320     }
2321 
2322     bool shouldSpeculateInt32OrBoolean()
2323     {
2324         return isInt32OrBooleanSpeculation(prediction());
2325     }
2326 
2327     bool shouldSpeculateInt32ForArithmetic()
2328     {
2329         return isInt32SpeculationForArithmetic(prediction());
2330     }
2331 
2332     bool shouldSpeculateInt32OrBooleanForArithmetic()
2333     {
2334         return isInt32OrBooleanSpeculationForArithmetic(prediction());
2335     }
2336 
2337     bool shouldSpeculateInt32OrBooleanExpectingDefined()
2338     {
2339         return isInt32OrBooleanSpeculationExpectingDefined(prediction());
2340     }
2341 
<a name="8" id="anc8"></a><span class="line-modified">2342     bool shouldSpeculateInt52()</span>
<span class="line-modified">2343     {</span>
<span class="line-modified">2344         // We have to include SpecInt32Only here for two reasons:</span>
<span class="line-added">2345         // 1. We diligently write code that first checks if we should speculate Int32.</span>
<span class="line-added">2346         // For example:</span>
<span class="line-added">2347         // if (shouldSpeculateInt32()) ...</span>
<span class="line-added">2348         // else if (shouldSpeculateInt52()) ...</span>
<span class="line-added">2349         // This means we it&#39;s totally valid to speculate Int52 when we&#39;re dealing</span>
<span class="line-added">2350         // with a type that&#39;s the union of Int32 and Int52.</span>
<span class="line-added">2351         //</span>
<span class="line-added">2352         // It would be a performance mistake to not include Int32 here because we obviously</span>
<span class="line-added">2353         // have variables that are the union of Int32 and Int52 values, and it&#39;s better</span>
<span class="line-added">2354         // to speculate Int52 than double in that situation.</span>
<span class="line-added">2355         //</span>
<span class="line-added">2356         // 2. We also write code where we ask if the inputs can be Int52, like if</span>
<span class="line-added">2357         // we know via profiling that an Add overflows, we may not emit an Int32 add.</span>
<span class="line-added">2358         // However, we only emit such an add if both inputs can be Int52, and Int32</span>
<span class="line-added">2359         // can trivially become Int52.</span>
<span class="line-added">2360         //</span>
<span class="line-added">2361         return enableInt52() &amp;&amp; isInt32OrInt52Speculation(prediction());</span>
2362     }
2363 
2364     bool shouldSpeculateDouble()
2365     {
2366         return isDoubleSpeculation(prediction());
2367     }
2368 
2369     bool shouldSpeculateDoubleReal()
2370     {
2371         return isDoubleRealSpeculation(prediction());
2372     }
2373 
2374     bool shouldSpeculateNumber()
2375     {
2376         return isFullNumberSpeculation(prediction());
2377     }
2378 
2379     bool shouldSpeculateNumberOrBoolean()
2380     {
2381         return isFullNumberOrBooleanSpeculation(prediction());
2382     }
2383 
2384     bool shouldSpeculateNumberOrBooleanExpectingDefined()
2385     {
2386         return isFullNumberOrBooleanSpeculationExpectingDefined(prediction());
2387     }
2388 
2389     bool shouldSpeculateBoolean()
2390     {
2391         return isBooleanSpeculation(prediction());
2392     }
2393 
2394     bool shouldSpeculateNotBoolean()
2395     {
2396         return isNotBooleanSpeculation(prediction());
2397     }
2398 
2399     bool shouldSpeculateOther()
2400     {
2401         return isOtherSpeculation(prediction());
2402     }
2403 
2404     bool shouldSpeculateMisc()
2405     {
2406         return isMiscSpeculation(prediction());
2407     }
2408 
2409     bool shouldSpeculateStringIdent()
2410     {
2411         return isStringIdentSpeculation(prediction());
2412     }
2413 
2414     bool shouldSpeculateNotStringVar()
2415     {
2416         return isNotStringVarSpeculation(prediction());
2417     }
2418 
2419     bool shouldSpeculateString()
2420     {
2421         return isStringSpeculation(prediction());
2422     }
2423 
2424     bool shouldSpeculateNotString()
2425     {
2426         return isNotStringSpeculation(prediction());
2427     }
2428 
2429     bool shouldSpeculateStringOrOther()
2430     {
2431         return isStringOrOtherSpeculation(prediction());
2432     }
2433 
2434     bool shouldSpeculateStringObject()
2435     {
2436         return isStringObjectSpeculation(prediction());
2437     }
2438 
2439     bool shouldSpeculateStringOrStringObject()
2440     {
2441         return isStringOrStringObjectSpeculation(prediction());
2442     }
2443 
2444     bool shouldSpeculateRegExpObject()
2445     {
2446         return isRegExpObjectSpeculation(prediction());
2447     }
2448 
2449     bool shouldSpeculateSymbol()
2450     {
2451         return isSymbolSpeculation(prediction());
2452     }
2453 
2454     bool shouldSpeculateBigInt()
2455     {
2456         return isBigIntSpeculation(prediction());
2457     }
2458 
2459     bool shouldSpeculateFinalObject()
2460     {
2461         return isFinalObjectSpeculation(prediction());
2462     }
2463 
2464     bool shouldSpeculateFinalObjectOrOther()
2465     {
2466         return isFinalObjectOrOtherSpeculation(prediction());
2467     }
2468 
2469     bool shouldSpeculateArray()
2470     {
2471         return isArraySpeculation(prediction());
2472     }
2473 
2474     bool shouldSpeculateFunction()
2475     {
2476         return isFunctionSpeculation(prediction());
2477     }
2478 
2479     bool shouldSpeculateProxyObject()
2480     {
2481         return isProxyObjectSpeculation(prediction());
2482     }
2483 
2484     bool shouldSpeculateDerivedArray()
2485     {
2486         return isDerivedArraySpeculation(prediction());
2487     }
2488 
2489     bool shouldSpeculateDirectArguments()
2490     {
2491         return isDirectArgumentsSpeculation(prediction());
2492     }
2493 
2494     bool shouldSpeculateScopedArguments()
2495     {
2496         return isScopedArgumentsSpeculation(prediction());
2497     }
2498 
2499     bool shouldSpeculateInt8Array()
2500     {
2501         return isInt8ArraySpeculation(prediction());
2502     }
2503 
2504     bool shouldSpeculateInt16Array()
2505     {
2506         return isInt16ArraySpeculation(prediction());
2507     }
2508 
2509     bool shouldSpeculateInt32Array()
2510     {
2511         return isInt32ArraySpeculation(prediction());
2512     }
2513 
2514     bool shouldSpeculateUint8Array()
2515     {
2516         return isUint8ArraySpeculation(prediction());
2517     }
2518 
2519     bool shouldSpeculateUint8ClampedArray()
2520     {
2521         return isUint8ClampedArraySpeculation(prediction());
2522     }
2523 
2524     bool shouldSpeculateUint16Array()
2525     {
2526         return isUint16ArraySpeculation(prediction());
2527     }
2528 
2529     bool shouldSpeculateUint32Array()
2530     {
2531         return isUint32ArraySpeculation(prediction());
2532     }
2533 
2534     bool shouldSpeculateFloat32Array()
2535     {
2536         return isFloat32ArraySpeculation(prediction());
2537     }
2538 
2539     bool shouldSpeculateFloat64Array()
2540     {
2541         return isFloat64ArraySpeculation(prediction());
2542     }
2543 
2544     bool shouldSpeculateArrayOrOther()
2545     {
2546         return isArrayOrOtherSpeculation(prediction());
2547     }
2548 
2549     bool shouldSpeculateObject()
2550     {
2551         return isObjectSpeculation(prediction());
2552     }
2553 
2554     bool shouldSpeculateObjectOrOther()
2555     {
2556         return isObjectOrOtherSpeculation(prediction());
2557     }
2558 
2559     bool shouldSpeculateCell()
2560     {
2561         return isCellSpeculation(prediction());
2562     }
2563 
2564     bool shouldSpeculateCellOrOther()
2565     {
2566         return isCellOrOtherSpeculation(prediction());
2567     }
2568 
2569     bool shouldSpeculateNotCell()
2570     {
2571         return isNotCellSpeculation(prediction());
2572     }
2573 
2574     bool shouldSpeculateUntypedForArithmetic()
2575     {
2576         return isUntypedSpeculationForArithmetic(prediction());
2577     }
2578 
2579     static bool shouldSpeculateUntypedForArithmetic(Node* op1, Node* op2)
2580     {
2581         return op1-&gt;shouldSpeculateUntypedForArithmetic() || op2-&gt;shouldSpeculateUntypedForArithmetic();
2582     }
2583 
2584     bool shouldSpeculateUntypedForBitOps()
2585     {
2586         return isUntypedSpeculationForBitOps(prediction());
2587     }
2588 
2589     static bool shouldSpeculateUntypedForBitOps(Node* op1, Node* op2)
2590     {
2591         return op1-&gt;shouldSpeculateUntypedForBitOps() || op2-&gt;shouldSpeculateUntypedForBitOps();
2592     }
2593 
2594     static bool shouldSpeculateBoolean(Node* op1, Node* op2)
2595     {
2596         return op1-&gt;shouldSpeculateBoolean() &amp;&amp; op2-&gt;shouldSpeculateBoolean();
2597     }
2598 
2599     static bool shouldSpeculateInt32(Node* op1, Node* op2)
2600     {
2601         return op1-&gt;shouldSpeculateInt32() &amp;&amp; op2-&gt;shouldSpeculateInt32();
2602     }
2603 
2604     static bool shouldSpeculateInt32OrBoolean(Node* op1, Node* op2)
2605     {
2606         return op1-&gt;shouldSpeculateInt32OrBoolean()
2607             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBoolean();
2608     }
2609 
2610     static bool shouldSpeculateInt32OrBooleanForArithmetic(Node* op1, Node* op2)
2611     {
2612         return op1-&gt;shouldSpeculateInt32OrBooleanForArithmetic()
2613             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBooleanForArithmetic();
2614     }
2615 
2616     static bool shouldSpeculateInt32OrBooleanExpectingDefined(Node* op1, Node* op2)
2617     {
2618         return op1-&gt;shouldSpeculateInt32OrBooleanExpectingDefined()
2619             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBooleanExpectingDefined();
2620     }
2621 
<a name="9" id="anc9"></a><span class="line-modified">2622     static bool shouldSpeculateInt52(Node* op1, Node* op2)</span>
2623     {
<a name="10" id="anc10"></a><span class="line-modified">2624         return enableInt52() &amp;&amp; op1-&gt;shouldSpeculateInt52() &amp;&amp; op2-&gt;shouldSpeculateInt52();</span>
2625     }
2626 
2627     static bool shouldSpeculateNumber(Node* op1, Node* op2)
2628     {
2629         return op1-&gt;shouldSpeculateNumber() &amp;&amp; op2-&gt;shouldSpeculateNumber();
2630     }
2631 
2632     static bool shouldSpeculateNumberOrBoolean(Node* op1, Node* op2)
2633     {
2634         return op1-&gt;shouldSpeculateNumberOrBoolean()
2635             &amp;&amp; op2-&gt;shouldSpeculateNumberOrBoolean();
2636     }
2637 
2638     static bool shouldSpeculateNumberOrBooleanExpectingDefined(Node* op1, Node* op2)
2639     {
2640         return op1-&gt;shouldSpeculateNumberOrBooleanExpectingDefined()
2641             &amp;&amp; op2-&gt;shouldSpeculateNumberOrBooleanExpectingDefined();
2642     }
2643 
2644     static bool shouldSpeculateSymbol(Node* op1, Node* op2)
2645     {
2646         return op1-&gt;shouldSpeculateSymbol() &amp;&amp; op2-&gt;shouldSpeculateSymbol();
2647     }
2648 
2649     static bool shouldSpeculateBigInt(Node* op1, Node* op2)
2650     {
2651         return op1-&gt;shouldSpeculateBigInt() &amp;&amp; op2-&gt;shouldSpeculateBigInt();
2652     }
2653 
2654     static bool shouldSpeculateFinalObject(Node* op1, Node* op2)
2655     {
2656         return op1-&gt;shouldSpeculateFinalObject() &amp;&amp; op2-&gt;shouldSpeculateFinalObject();
2657     }
2658 
2659     static bool shouldSpeculateArray(Node* op1, Node* op2)
2660     {
2661         return op1-&gt;shouldSpeculateArray() &amp;&amp; op2-&gt;shouldSpeculateArray();
2662     }
2663 
2664     bool canSpeculateInt32(RareCaseProfilingSource source)
2665     {
2666         return nodeCanSpeculateInt32(arithNodeFlags(), source);
2667     }
2668 
2669     bool canSpeculateInt52(RareCaseProfilingSource source)
2670     {
2671         return nodeCanSpeculateInt52(arithNodeFlags(), source);
2672     }
2673 
2674     RareCaseProfilingSource sourceFor(PredictionPass pass)
2675     {
2676         if (pass == PrimaryPass || child1()-&gt;sawBooleans() || (child2() &amp;&amp; child2()-&gt;sawBooleans()))
2677             return DFGRareCase;
2678         return AllRareCases;
2679     }
2680 
2681     bool canSpeculateInt32(PredictionPass pass)
2682     {
2683         return canSpeculateInt32(sourceFor(pass));
2684     }
2685 
2686     bool canSpeculateInt52(PredictionPass pass)
2687     {
2688         return canSpeculateInt52(sourceFor(pass));
2689     }
2690 
2691     bool hasTypeLocation()
2692     {
2693         return op() == ProfileType;
2694     }
2695 
2696     TypeLocation* typeLocation()
2697     {
2698         ASSERT(hasTypeLocation());
2699         return m_opInfo.as&lt;TypeLocation*&gt;();
2700     }
2701 
2702     bool hasBasicBlockLocation()
2703     {
2704         return op() == ProfileControlFlow;
2705     }
2706 
2707     BasicBlockLocation* basicBlockLocation()
2708     {
2709         ASSERT(hasBasicBlockLocation());
2710         return m_opInfo.as&lt;BasicBlockLocation*&gt;();
2711     }
2712 
2713     bool hasCallDOMGetterData() const
2714     {
2715         return op() == CallDOMGetter;
2716     }
2717 
2718     CallDOMGetterData* callDOMGetterData()
2719     {
2720         ASSERT(hasCallDOMGetterData());
2721         return m_opInfo.as&lt;CallDOMGetterData*&gt;();
2722     }
2723 
2724     bool hasClassInfo() const
2725     {
2726         return op() == CheckSubClass;
2727     }
2728 
2729     const ClassInfo* classInfo()
2730     {
2731         return m_opInfo.as&lt;const ClassInfo*&gt;();
2732     }
2733 
2734     bool hasSignature() const
2735     {
2736         // Note that this does not include TailCall node types intentionally.
2737         // CallDOM node types are always converted from Call.
2738         return op() == Call || op() == CallDOM;
2739     }
2740 
2741     const DOMJIT::Signature* signature()
2742     {
2743         return m_opInfo.as&lt;const DOMJIT::Signature*&gt;();
2744     }
2745 
2746     bool hasInternalMethodType() const
2747     {
2748         return op() == HasIndexedProperty;
2749     }
2750 
2751     PropertySlot::InternalMethodType internalMethodType() const
2752     {
2753         ASSERT(hasInternalMethodType());
2754         return static_cast&lt;PropertySlot::InternalMethodType&gt;(m_opInfo2.as&lt;uint32_t&gt;());
2755     }
2756 
2757     void setInternalMethodType(PropertySlot::InternalMethodType type)
2758     {
2759         ASSERT(hasInternalMethodType());
2760         m_opInfo2 = static_cast&lt;uint32_t&gt;(type);
2761     }
2762 
2763     Node* replacement() const
2764     {
2765         return m_misc.replacement;
2766     }
2767 
2768     void setReplacement(Node* replacement)
2769     {
2770         m_misc.replacement = replacement;
2771     }
2772 
2773     Epoch epoch() const
2774     {
2775         return Epoch::fromUnsigned(m_misc.epoch);
2776     }
2777 
2778     void setEpoch(Epoch epoch)
2779     {
2780         m_misc.epoch = epoch.toUnsigned();
2781     }
2782 
2783     bool hasNumberOfArgumentsToSkip()
2784     {
2785         return op() == CreateRest || op() == PhantomCreateRest || op() == GetRestLength || op() == GetMyArgumentByVal || op() == GetMyArgumentByValOutOfBounds;
2786     }
2787 
2788     unsigned numberOfArgumentsToSkip()
2789     {
2790         ASSERT(hasNumberOfArgumentsToSkip());
2791         return m_opInfo.as&lt;unsigned&gt;();
2792     }
2793 
2794     bool hasArgumentIndex()
2795     {
2796         return op() == GetArgument;
2797     }
2798 
2799     unsigned argumentIndex()
2800     {
2801         ASSERT(hasArgumentIndex());
2802         return m_opInfo.as&lt;unsigned&gt;();
2803     }
2804 
2805     bool hasBucketOwnerType()
2806     {
2807         return op() == GetMapBucketNext || op() == LoadKeyFromMapBucket || op() == LoadValueFromMapBucket;
2808     }
2809 
2810     BucketOwnerType bucketOwnerType()
2811     {
2812         ASSERT(hasBucketOwnerType());
2813         return m_opInfo.as&lt;BucketOwnerType&gt;();
2814     }
2815 
2816     bool hasValidRadixConstant()
2817     {
2818         return op() == NumberToStringWithValidRadixConstant;
2819     }
2820 
2821     int32_t validRadixConstant()
2822     {
2823         ASSERT(hasValidRadixConstant());
2824         return m_opInfo.as&lt;int32_t&gt;();
2825     }
2826 
2827     bool hasIgnoreLastIndexIsWritable()
2828     {
2829         return op() == SetRegExpObjectLastIndex;
2830     }
2831 
2832     bool ignoreLastIndexIsWritable()
2833     {
2834         ASSERT(hasIgnoreLastIndexIsWritable());
2835         return m_opInfo.as&lt;uint32_t&gt;();
2836     }
2837 
2838     uint32_t errorType()
2839     {
2840         ASSERT(op() == ThrowStaticError);
2841         return m_opInfo.as&lt;uint32_t&gt;();
2842     }
2843 
2844     bool hasCallLinkStatus()
2845     {
2846         return op() == FilterCallLinkStatus;
2847     }
2848 
2849     CallLinkStatus* callLinkStatus()
2850     {
2851         ASSERT(hasCallLinkStatus());
2852         return m_opInfo.as&lt;CallLinkStatus*&gt;();
2853     }
2854 
2855     bool hasGetByIdStatus()
2856     {
2857         return op() == FilterGetByIdStatus;
2858     }
2859 
2860     GetByIdStatus* getByIdStatus()
2861     {
2862         ASSERT(hasGetByIdStatus());
2863         return m_opInfo.as&lt;GetByIdStatus*&gt;();
2864     }
2865 
2866     bool hasInByIdStatus()
2867     {
2868         return op() == FilterInByIdStatus;
2869     }
2870 
2871     InByIdStatus* inByIdStatus()
2872     {
2873         ASSERT(hasInByIdStatus());
2874         return m_opInfo.as&lt;InByIdStatus*&gt;();
2875     }
2876 
2877     bool hasPutByIdStatus()
2878     {
2879         return op() == FilterPutByIdStatus;
2880     }
2881 
2882     PutByIdStatus* putByIdStatus()
2883     {
2884         ASSERT(hasPutByIdStatus());
2885         return m_opInfo.as&lt;PutByIdStatus*&gt;();
2886     }
2887 
2888     void dumpChildren(PrintStream&amp; out)
2889     {
2890         if (!child1())
2891             return;
2892         out.printf(&quot;@%u&quot;, child1()-&gt;index());
2893         if (!child2())
2894             return;
2895         out.printf(&quot;, @%u&quot;, child2()-&gt;index());
2896         if (!child3())
2897             return;
2898         out.printf(&quot;, @%u&quot;, child3()-&gt;index());
2899     }
2900 
<a name="11" id="anc11"></a>

2901     NodeOrigin origin;
2902 
2903     // References to up to 3 children, or links to a variable length set of children.
2904     AdjacencyList children;
2905 
2906 private:
2907     friend class B3::SparseCollection&lt;Node&gt;;
2908 
2909     unsigned m_index { std::numeric_limits&lt;unsigned&gt;::max() };
2910     unsigned m_op : 10; // real type is NodeType
2911     unsigned m_flags : 21;
2912     // The virtual register number (spill location) associated with this .
2913     VirtualRegister m_virtualRegister;
2914     // The number of uses of the result of this operation (+1 for &#39;must generate&#39; nodes, which have side-effects).
2915     unsigned m_refCount;
2916     // The prediction ascribed to this node after propagation.
2917     SpeculatedType m_prediction { SpecNone };
2918     // Immediate values, accesses type-checked via accessors above.
2919     struct OpInfoWrapper {
2920         OpInfoWrapper()
2921         {
2922             u.int64 = 0;
2923         }
2924         OpInfoWrapper(uint32_t intValue)
2925         {
2926             u.int64 = 0;
2927             u.int32 = intValue;
2928         }
2929         OpInfoWrapper(uint64_t intValue)
2930         {
2931             u.int64 = intValue;
2932         }
2933         OpInfoWrapper(void* pointer)
2934         {
2935             u.int64 = 0;
2936             u.pointer = pointer;
2937         }
2938         OpInfoWrapper(const void* constPointer)
2939         {
2940             u.int64 = 0;
2941             u.constPointer = constPointer;
2942         }
2943         OpInfoWrapper(RegisteredStructure structure)
2944         {
2945             u.int64 = 0;
2946             u.pointer = bitwise_cast&lt;void*&gt;(structure);
2947         }
2948         OpInfoWrapper&amp; operator=(uint32_t int32)
2949         {
2950             u.int64 = 0;
2951             u.int32 = int32;
2952             return *this;
2953         }
2954         OpInfoWrapper&amp; operator=(int32_t int32)
2955         {
2956             u.int64 = 0;
2957             u.int32 = int32;
2958             return *this;
2959         }
2960         OpInfoWrapper&amp; operator=(uint64_t int64)
2961         {
2962             u.int64 = int64;
2963             return *this;
2964         }
2965         OpInfoWrapper&amp; operator=(void* pointer)
2966         {
2967             u.int64 = 0;
2968             u.pointer = pointer;
2969             return *this;
2970         }
2971         OpInfoWrapper&amp; operator=(const void* constPointer)
2972         {
2973             u.int64 = 0;
2974             u.constPointer = constPointer;
2975             return *this;
2976         }
2977         OpInfoWrapper&amp; operator=(RegisteredStructure structure)
2978         {
2979             u.int64 = 0;
2980             u.pointer = bitwise_cast&lt;void*&gt;(structure);
2981             return *this;
2982         }
2983         OpInfoWrapper&amp; operator=(NewArrayBufferData newArrayBufferData)
2984         {
2985             u.int64 = bitwise_cast&lt;uint64_t&gt;(newArrayBufferData);
2986             return *this;
2987         }
2988         template &lt;typename T&gt;
2989         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value &amp;&amp; !std::is_const&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type
2990         {
2991             return static_cast&lt;T&gt;(u.pointer);
2992         }
2993         template &lt;typename T&gt;
2994         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value &amp;&amp; std::is_const&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type
2995         {
2996             return static_cast&lt;T&gt;(u.constPointer);
2997         }
2998         template &lt;typename T&gt;
2999         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value) &amp;&amp; sizeof(T) &lt;= 4, T&gt;::type
3000         {
3001             return static_cast&lt;T&gt;(u.int32);
3002         }
3003         template &lt;typename T&gt;
3004         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value) &amp;&amp; sizeof(T) == 8, T&gt;::type
3005         {
3006             return static_cast&lt;T&gt;(u.int64);
3007         }
3008         ALWAYS_INLINE RegisteredStructure asRegisteredStructure() const
3009         {
3010             return bitwise_cast&lt;RegisteredStructure&gt;(u.pointer);
3011         }
3012         ALWAYS_INLINE NewArrayBufferData asNewArrayBufferData() const
3013         {
3014             return bitwise_cast&lt;NewArrayBufferData&gt;(u.int64);
3015         }
3016 
3017         union {
3018             uint32_t int32;
3019             uint64_t int64;
3020             void* pointer;
3021             const void* constPointer;
3022         } u;
3023     };
3024     OpInfoWrapper m_opInfo;
3025     OpInfoWrapper m_opInfo2;
3026 
3027     // Miscellaneous data that is usually meaningless, but can hold some analysis results
3028     // if you ask right. For example, if you do Graph::initializeNodeOwners(), Node::owner
3029     // will tell you which basic block a node belongs to. You cannot rely on this persisting
3030     // across transformations unless you do the maintenance work yourself. Other phases use
3031     // Node::replacement, but they do so manually: first you do Graph::clearReplacements()
3032     // and then you set, and use, replacement&#39;s yourself. Same thing for epoch.
3033     //
3034     // Bottom line: don&#39;t use these fields unless you initialize them yourself, or by
3035     // calling some appropriate methods that initialize them the way you want. Otherwise,
3036     // these fields are meaningless.
3037 private:
3038     union {
3039         Node* replacement;
3040         unsigned epoch;
3041     } m_misc;
3042 public:
3043     BasicBlock* owner;
3044 };
3045 
3046 // Uncomment this to log NodeSet operations.
3047 // typedef LoggingHashSet&lt;Node::HashSetTemplateInstantiationString, Node*&gt; NodeSet;
3048 typedef HashSet&lt;Node*&gt; NodeSet;
3049 
3050 struct NodeComparator {
3051     template&lt;typename NodePtrType&gt;
3052     bool operator()(NodePtrType a, NodePtrType b) const
3053     {
3054         return a-&gt;index() &lt; b-&gt;index();
3055     }
3056 };
3057 
3058 template&lt;typename T&gt;
3059 CString nodeListDump(const T&amp; nodeList)
3060 {
3061     return sortedListDump(nodeList, NodeComparator());
3062 }
3063 
3064 template&lt;typename T&gt;
3065 CString nodeMapDump(const T&amp; nodeMap, DumpContext* context = 0)
3066 {
3067     Vector&lt;typename T::KeyType&gt; keys;
3068     for (
3069         typename T::const_iterator iter = nodeMap.begin();
3070         iter != nodeMap.end(); ++iter)
3071         keys.append(iter-&gt;key);
3072     std::sort(keys.begin(), keys.end(), NodeComparator());
3073     StringPrintStream out;
3074     CommaPrinter comma;
3075     for(unsigned i = 0; i &lt; keys.size(); ++i)
3076         out.print(comma, keys[i], &quot;=&gt;&quot;, inContext(nodeMap.get(keys[i]), context));
3077     return out.toCString();
3078 }
3079 
3080 template&lt;typename T&gt;
3081 CString nodeValuePairListDump(const T&amp; nodeValuePairList, DumpContext* context = 0)
3082 {
3083     using V = typename T::ValueType;
3084     T sortedList = nodeValuePairList;
3085     std::sort(sortedList.begin(), sortedList.end(), [](const V&amp; a, const V&amp; b) {
3086         return NodeComparator()(a.node, b.node);
3087     });
3088 
3089     StringPrintStream out;
3090     CommaPrinter comma;
3091     for (const auto&amp; pair : sortedList)
3092         out.print(comma, pair.node, &quot;=&gt;&quot;, inContext(pair.value, context));
3093     return out.toCString();
3094 }
3095 
3096 } } // namespace JSC::DFG
3097 
3098 namespace WTF {
3099 
3100 void printInternal(PrintStream&amp;, JSC::DFG::SwitchKind);
3101 void printInternal(PrintStream&amp;, JSC::DFG::Node*);
3102 
3103 inline JSC::DFG::Node* inContext(JSC::DFG::Node* node, JSC::DumpContext*) { return node; }
3104 
3105 template&lt;&gt;
3106 struct LoggingHashKeyTraits&lt;JSC::DFG::Node*&gt; {
3107     static void print(PrintStream&amp; out, JSC::DFG::Node* key)
3108     {
3109         out.print(&quot;bitwise_cast&lt;::JSC::DFG::Node*&gt;(&quot;, RawPointer(key), &quot;lu)&quot;);
3110     }
3111 };
3112 
3113 } // namespace WTF
3114 
3115 using WTF::inContext;
3116 
3117 #endif
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>