<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   3  *
   4  *  This library is free software; you can redistribute it and/or
   5  *  modify it under the terms of the GNU Library General Public
   6  *  License as published by the Free Software Foundation; either
   7  *  version 2 of the License, or (at your option) any later version.
   8  *
   9  *  This library is distributed in the hope that it will be useful,
  10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  *  Library General Public License for more details.
  13  *
  14  *  You should have received a copy of the GNU Library General Public License
  15  *  along with this library; see the file COPYING.LIB.  If not, write to
  16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  *  Boston, MA 02110-1301, USA.
  18  *
  19  */
  20 
  21 #pragma once
  22 
  23 #include &lt;initializer_list&gt;
  24 #include &lt;limits&gt;
  25 #include &lt;string.h&gt;
  26 #include &lt;type_traits&gt;
  27 #include &lt;utility&gt;
  28 #include &lt;wtf/CheckedArithmetic.h&gt;
  29 #include &lt;wtf/FastMalloc.h&gt;
  30 #include &lt;wtf/Forward.h&gt;
  31 #include &lt;wtf/MallocPtr.h&gt;
  32 #include &lt;wtf/MathExtras.h&gt;
  33 #include &lt;wtf/Noncopyable.h&gt;
  34 #include &lt;wtf/NotFound.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/ValueCheck.h&gt;
  37 #include &lt;wtf/VectorTraits.h&gt;
  38 
  39 #if ASAN_ENABLED
  40 extern &quot;C&quot; void __sanitizer_annotate_contiguous_container(const void* begin, const void* end, const void* old_mid, const void* new_mid);
  41 #endif
  42 
  43 namespace JSC {
  44 class LLIntOffsetsExtractor;
  45 }
  46 
  47 namespace WTF {
  48 
  49 template &lt;bool needsDestruction, typename T&gt;
  50 struct VectorDestructor;
  51 
  52 template&lt;typename T&gt;
  53 struct VectorDestructor&lt;false, T&gt;
  54 {
  55     static void destruct(T*, T*) {}
  56 };
  57 
  58 template&lt;typename T&gt;
  59 struct VectorDestructor&lt;true, T&gt;
  60 {
  61     static void destruct(T* begin, T* end)
  62     {
  63         for (T* cur = begin; cur != end; ++cur)
  64             cur-&gt;~T();
  65     }
  66 };
  67 
  68 template &lt;bool needsInitialization, bool canInitializeWithMemset, typename T&gt;
  69 struct VectorInitializer;
  70 
  71 template&lt;bool canInitializeWithMemset, typename T&gt;
  72 struct VectorInitializer&lt;false, canInitializeWithMemset, T&gt;
  73 {
  74     static void initializeIfNonPOD(T*, T*) { }
  75 
  76     static void initialize(T* begin, T* end)
  77     {
  78         VectorInitializer&lt;true, canInitializeWithMemset, T&gt;::initialize(begin, end);
  79     }
  80 };
  81 
  82 template&lt;typename T&gt;
  83 struct VectorInitializer&lt;true, false, T&gt;
  84 {
  85     static void initializeIfNonPOD(T* begin, T* end)
  86     {
  87         for (T* cur = begin; cur != end; ++cur)
  88             new (NotNull, cur) T();
  89     }
  90 
  91     static void initialize(T* begin, T* end)
  92     {
  93         initializeIfNonPOD(begin, end);
  94     }
  95 };
  96 
  97 template&lt;typename T&gt;
  98 struct VectorInitializer&lt;true, true, T&gt;
  99 {
 100     static void initializeIfNonPOD(T* begin, T* end)
 101     {
 102         memset(static_cast&lt;void*&gt;(begin), 0, reinterpret_cast&lt;char*&gt;(end) - reinterpret_cast&lt;char*&gt;(begin));
 103     }
 104 
 105     static void initialize(T* begin, T* end)
 106     {
 107         initializeIfNonPOD(begin, end);
 108     }
 109 };
 110 
 111 template &lt;bool canMoveWithMemcpy, typename T&gt;
 112 struct VectorMover;
 113 
 114 template&lt;typename T&gt;
 115 struct VectorMover&lt;false, T&gt;
 116 {
 117     static void move(T* src, T* srcEnd, T* dst)
 118     {
 119         while (src != srcEnd) {
 120             new (NotNull, dst) T(WTFMove(*src));
 121             src-&gt;~T();
 122             ++dst;
 123             ++src;
 124         }
 125     }
 126     static void moveOverlapping(T* src, T* srcEnd, T* dst)
 127     {
 128         if (src &gt; dst)
 129             move(src, srcEnd, dst);
 130         else {
 131             T* dstEnd = dst + (srcEnd - src);
 132             while (src != srcEnd) {
 133                 --srcEnd;
 134                 --dstEnd;
 135                 new (NotNull, dstEnd) T(WTFMove(*srcEnd));
 136                 srcEnd-&gt;~T();
 137             }
 138         }
 139     }
 140 };
 141 
 142 template&lt;typename T&gt;
 143 struct VectorMover&lt;true, T&gt;
 144 {
 145     static void move(const T* src, const T* srcEnd, T* dst)
 146     {
 147         memcpy(static_cast&lt;void*&gt;(dst), static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(src)), reinterpret_cast&lt;const char*&gt;(srcEnd) - reinterpret_cast&lt;const char*&gt;(src));
 148     }
 149     static void moveOverlapping(const T* src, const T* srcEnd, T* dst)
 150     {
 151         memmove(static_cast&lt;void*&gt;(dst), static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(src)), reinterpret_cast&lt;const char*&gt;(srcEnd) - reinterpret_cast&lt;const char*&gt;(src));
 152     }
 153 };
 154 
 155 template &lt;bool canCopyWithMemcpy, typename T&gt;
 156 struct VectorCopier;
 157 
 158 template&lt;typename T&gt;
 159 struct VectorCopier&lt;false, T&gt;
 160 {
 161     template&lt;typename U&gt;
 162     static void uninitializedCopy(const T* src, const T* srcEnd, U* dst)
 163     {
 164         while (src != srcEnd) {
 165             new (NotNull, dst) U(*src);
 166             ++dst;
 167             ++src;
 168         }
 169     }
 170 };
 171 
 172 template&lt;typename T&gt;
 173 struct VectorCopier&lt;true, T&gt;
 174 {
 175     static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
 176     {
 177         memcpy(static_cast&lt;void*&gt;(dst), static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(src)), reinterpret_cast&lt;const char*&gt;(srcEnd) - reinterpret_cast&lt;const char*&gt;(src));
 178     }
 179     template&lt;typename U&gt;
 180     static void uninitializedCopy(const T* src, const T* srcEnd, U* dst)
 181     {
 182         VectorCopier&lt;false, T&gt;::uninitializedCopy(src, srcEnd, dst);
 183     }
 184 };
 185 
 186 template &lt;bool canFillWithMemset, typename T&gt;
 187 struct VectorFiller;
 188 
 189 template&lt;typename T&gt;
 190 struct VectorFiller&lt;false, T&gt;
 191 {
 192     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 193     {
 194         while (dst != dstEnd) {
 195             new (NotNull, dst) T(val);
 196             ++dst;
 197         }
 198     }
 199 };
 200 
 201 template&lt;typename T&gt;
 202 struct VectorFiller&lt;true, T&gt;
 203 {
 204     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 205     {
 206         static_assert(sizeof(T) == 1, &quot;Size of type T should be equal to one!&quot;);
 207 #if COMPILER(GCC_COMPATIBLE) &amp;&amp; defined(_FORTIFY_SOURCE)
 208         if (!__builtin_constant_p(dstEnd - dst) || (!(dstEnd - dst)))
 209 #endif
 210             memset(dst, val, dstEnd - dst);
 211     }
 212 };
 213 
 214 template&lt;bool canCompareWithMemcmp, typename T&gt;
 215 struct VectorComparer;
 216 
 217 template&lt;typename T&gt;
 218 struct VectorComparer&lt;false, T&gt;
 219 {
 220     static bool compare(const T* a, const T* b, size_t size)
 221     {
 222         for (size_t i = 0; i &lt; size; ++i)
 223             if (!(a[i] == b[i]))
 224                 return false;
 225         return true;
 226     }
 227 };
 228 
 229 template&lt;typename T&gt;
 230 struct VectorComparer&lt;true, T&gt;
 231 {
 232     static bool compare(const T* a, const T* b, size_t size)
 233     {
 234         return memcmp(a, b, sizeof(T) * size) == 0;
 235     }
 236 };
 237 
 238 template&lt;typename T&gt;
 239 struct VectorTypeOperations
 240 {
 241     static void destruct(T* begin, T* end)
 242     {
 243         VectorDestructor&lt;!std::is_trivially_destructible&lt;T&gt;::value, T&gt;::destruct(begin, end);
 244     }
 245 
 246     static void initializeIfNonPOD(T* begin, T* end)
 247     {
 248         VectorInitializer&lt;VectorTraits&lt;T&gt;::needsInitialization, VectorTraits&lt;T&gt;::canInitializeWithMemset, T&gt;::initializeIfNonPOD(begin, end);
 249     }
 250 
 251     static void initialize(T* begin, T* end)
 252     {
 253         VectorInitializer&lt;VectorTraits&lt;T&gt;::needsInitialization, VectorTraits&lt;T&gt;::canInitializeWithMemset, T&gt;::initialize(begin, end);
 254     }
 255 
 256     static void move(T* src, T* srcEnd, T* dst)
 257     {
 258         VectorMover&lt;VectorTraits&lt;T&gt;::canMoveWithMemcpy, T&gt;::move(src, srcEnd, dst);
 259     }
 260 
 261     static void moveOverlapping(T* src, T* srcEnd, T* dst)
 262     {
 263         VectorMover&lt;VectorTraits&lt;T&gt;::canMoveWithMemcpy, T&gt;::moveOverlapping(src, srcEnd, dst);
 264     }
 265 
 266     static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
 267     {
 268         VectorCopier&lt;VectorTraits&lt;T&gt;::canCopyWithMemcpy, T&gt;::uninitializedCopy(src, srcEnd, dst);
 269     }
 270 
 271     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 272     {
 273         VectorFiller&lt;VectorTraits&lt;T&gt;::canFillWithMemset, T&gt;::uninitializedFill(dst, dstEnd, val);
 274     }
 275 
 276     static bool compare(const T* a, const T* b, size_t size)
 277     {
 278         return VectorComparer&lt;VectorTraits&lt;T&gt;::canCompareWithMemcmp, T&gt;::compare(a, b, size);
 279     }
 280 };
 281 
 282 template&lt;typename T&gt;
 283 class VectorBufferBase {
 284     WTF_MAKE_NONCOPYABLE(VectorBufferBase);
 285 public:
 286     void allocateBuffer(size_t newCapacity)
 287     {
 288         ASSERT(newCapacity);
 289         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 290             CRASH();
 291         size_t sizeToAllocate = newCapacity * sizeof(T);
 292         m_capacity = sizeToAllocate / sizeof(T);
 293         m_buffer = static_cast&lt;T*&gt;(fastMalloc(sizeToAllocate));
 294     }
 295 
 296     bool tryAllocateBuffer(size_t newCapacity)
 297     {
 298         ASSERT(newCapacity);
 299         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 300             return false;
 301 
 302         size_t sizeToAllocate = newCapacity * sizeof(T);
 303         T* newBuffer;
 304         if (tryFastMalloc(sizeToAllocate).getValue(newBuffer)) {
 305             m_capacity = sizeToAllocate / sizeof(T);
 306             m_buffer = newBuffer;
 307             return true;
 308         }
 309         return false;
 310     }
 311 
 312     bool shouldReallocateBuffer(size_t newCapacity) const
 313     {
 314         return VectorTraits&lt;T&gt;::canMoveWithMemcpy &amp;&amp; m_capacity &amp;&amp; newCapacity;
 315     }
 316 
 317     void reallocateBuffer(size_t newCapacity)
 318     {
 319         ASSERT(shouldReallocateBuffer(newCapacity));
 320         if (newCapacity &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
 321             CRASH();
 322         size_t sizeToAllocate = newCapacity * sizeof(T);
 323         m_capacity = sizeToAllocate / sizeof(T);
 324         m_buffer = static_cast&lt;T*&gt;(fastRealloc(m_buffer, sizeToAllocate));
 325     }
 326 
 327     void deallocateBuffer(T* bufferToDeallocate)
 328     {
 329         if (!bufferToDeallocate)
 330             return;
 331 
 332         if (m_buffer == bufferToDeallocate) {
 333             m_buffer = 0;
 334             m_capacity = 0;
 335         }
 336 
 337         fastFree(bufferToDeallocate);
 338     }
 339 
 340     T* buffer() { return m_buffer; }
 341     const T* buffer() const { return m_buffer; }
 342     static ptrdiff_t bufferMemoryOffset() { return OBJECT_OFFSETOF(VectorBufferBase, m_buffer); }
 343     size_t capacity() const { return m_capacity; }
 344 
 345     MallocPtr&lt;T&gt; releaseBuffer()
 346     {
 347         T* buffer = m_buffer;
 348         m_buffer = 0;
 349         m_capacity = 0;
 350         return adoptMallocPtr(buffer);
 351     }
 352 
 353 protected:
 354     VectorBufferBase()
 355         : m_buffer(0)
 356         , m_capacity(0)
 357         , m_size(0)
 358     {
 359     }
 360 
 361     VectorBufferBase(T* buffer, size_t capacity, size_t size)
 362         : m_buffer(buffer)
 363         , m_capacity(capacity)
 364         , m_size(size)
 365     {
 366     }
 367 
 368     ~VectorBufferBase()
 369     {
 370         // FIXME: It would be nice to find a way to ASSERT that m_buffer hasn&#39;t leaked here.
 371     }
 372 
 373     T* m_buffer;
 374     unsigned m_capacity;
 375     unsigned m_size; // Only used by the Vector subclass, but placed here to avoid padding the struct.
 376 };
 377 
 378 template&lt;typename T, size_t inlineCapacity&gt;
 379 class VectorBuffer;
 380 
 381 template&lt;typename T&gt;
 382 class VectorBuffer&lt;T, 0&gt; : private VectorBufferBase&lt;T&gt; {
 383 private:
 384     typedef VectorBufferBase&lt;T&gt; Base;
 385 public:
 386     VectorBuffer()
 387     {
 388     }
 389 
 390     VectorBuffer(size_t capacity, size_t size = 0)
 391     {
 392         m_size = size;
 393         // Calling malloc(0) might take a lock and may actually do an
 394         // allocation on some systems.
 395         if (capacity)
 396             allocateBuffer(capacity);
 397     }
 398 
 399     ~VectorBuffer()
 400     {
 401         deallocateBuffer(buffer());
 402     }
 403 
 404     void swap(VectorBuffer&lt;T, 0&gt;&amp; other, size_t, size_t)
 405     {
 406         std::swap(m_buffer, other.m_buffer);
 407         std::swap(m_capacity, other.m_capacity);
 408     }
 409 
 410     void restoreInlineBufferIfNeeded() { }
 411 
 412 #if ASAN_ENABLED
 413     void* endOfBuffer()
 414     {
 415         return buffer() + capacity();
 416     }
 417 #endif
 418 
 419     using Base::allocateBuffer;
 420     using Base::tryAllocateBuffer;
 421     using Base::shouldReallocateBuffer;
 422     using Base::reallocateBuffer;
 423     using Base::deallocateBuffer;
 424 
 425     using Base::buffer;
 426     using Base::capacity;
 427     using Base::bufferMemoryOffset;
 428 
 429     using Base::releaseBuffer;
 430 
 431 protected:
 432     using Base::m_size;
 433 
 434 private:
 435     friend class JSC::LLIntOffsetsExtractor;
 436     using Base::m_buffer;
 437     using Base::m_capacity;
 438 };
 439 
 440 template&lt;typename T, size_t inlineCapacity&gt;
 441 class VectorBuffer : private VectorBufferBase&lt;T&gt; {
 442     WTF_MAKE_NONCOPYABLE(VectorBuffer);
 443 private:
 444     typedef VectorBufferBase&lt;T&gt; Base;
 445 public:
 446     VectorBuffer()
 447         : Base(inlineBuffer(), inlineCapacity, 0)
 448     {
 449     }
 450 
 451     VectorBuffer(size_t capacity, size_t size = 0)
 452         : Base(inlineBuffer(), inlineCapacity, size)
 453     {
 454         if (capacity &gt; inlineCapacity)
 455             Base::allocateBuffer(capacity);
 456     }
 457 
 458     ~VectorBuffer()
 459     {
 460         deallocateBuffer(buffer());
 461     }
 462 
 463     void allocateBuffer(size_t newCapacity)
 464     {
 465         // FIXME: This should ASSERT(!m_buffer) to catch misuse/leaks.
 466         if (newCapacity &gt; inlineCapacity)
 467             Base::allocateBuffer(newCapacity);
 468         else {
 469             m_buffer = inlineBuffer();
 470             m_capacity = inlineCapacity;
 471         }
 472     }
 473 
 474     bool tryAllocateBuffer(size_t newCapacity)
 475     {
 476         if (newCapacity &gt; inlineCapacity)
 477             return Base::tryAllocateBuffer(newCapacity);
 478         m_buffer = inlineBuffer();
 479         m_capacity = inlineCapacity;
 480         return true;
 481     }
 482 
 483     void deallocateBuffer(T* bufferToDeallocate)
 484     {
 485         if (bufferToDeallocate == inlineBuffer())
 486             return;
 487         Base::deallocateBuffer(bufferToDeallocate);
 488     }
 489 
 490     bool shouldReallocateBuffer(size_t newCapacity) const
 491     {
 492         // We cannot reallocate the inline buffer.
 493         return Base::shouldReallocateBuffer(newCapacity) &amp;&amp; std::min(static_cast&lt;size_t&gt;(m_capacity), newCapacity) &gt; inlineCapacity;
 494     }
 495 
 496     void reallocateBuffer(size_t newCapacity)
 497     {
 498         ASSERT(shouldReallocateBuffer(newCapacity));
 499         Base::reallocateBuffer(newCapacity);
 500     }
 501 
 502     void swap(VectorBuffer&amp; other, size_t mySize, size_t otherSize)
 503     {
 504         if (buffer() == inlineBuffer() &amp;&amp; other.buffer() == other.inlineBuffer()) {
 505             swapInlineBuffer(other, mySize, otherSize);
 506             std::swap(m_capacity, other.m_capacity);
 507         } else if (buffer() == inlineBuffer()) {
 508             m_buffer = other.m_buffer;
 509             other.m_buffer = other.inlineBuffer();
 510             swapInlineBuffer(other, mySize, 0);
 511             std::swap(m_capacity, other.m_capacity);
 512         } else if (other.buffer() == other.inlineBuffer()) {
 513             other.m_buffer = m_buffer;
 514             m_buffer = inlineBuffer();
 515             swapInlineBuffer(other, 0, otherSize);
 516             std::swap(m_capacity, other.m_capacity);
 517         } else {
 518             std::swap(m_buffer, other.m_buffer);
 519             std::swap(m_capacity, other.m_capacity);
 520         }
 521     }
 522 
 523     void restoreInlineBufferIfNeeded()
 524     {
 525         if (m_buffer)
 526             return;
 527         m_buffer = inlineBuffer();
 528         m_capacity = inlineCapacity;
 529     }
 530 
 531 #if ASAN_ENABLED
 532     void* endOfBuffer()
 533     {
 534         ASSERT(buffer());
 535 
 536         IGNORE_GCC_WARNINGS_BEGIN(&quot;invalid-offsetof&quot;)
 537         static_assert((offsetof(VectorBuffer, m_inlineBuffer) + sizeof(m_inlineBuffer)) % 8 == 0, &quot;Inline buffer end needs to be on 8 byte boundary for ASan annotations to work.&quot;);
 538         IGNORE_GCC_WARNINGS_END
 539 
 540         if (buffer() == inlineBuffer())
 541             return reinterpret_cast&lt;char*&gt;(m_inlineBuffer) + sizeof(m_inlineBuffer);
 542 
 543         return buffer() + capacity();
 544     }
 545 #endif
 546 
 547     using Base::buffer;
 548     using Base::capacity;
 549     using Base::bufferMemoryOffset;
 550 
 551     MallocPtr&lt;T&gt; releaseBuffer()
 552     {
 553         if (buffer() == inlineBuffer())
 554             return nullptr;
 555         return Base::releaseBuffer();
 556     }
 557 
 558 protected:
 559     using Base::m_size;
 560 
 561 private:
 562     using Base::m_buffer;
 563     using Base::m_capacity;
 564 
 565     void swapInlineBuffer(VectorBuffer&amp; other, size_t mySize, size_t otherSize)
 566     {
 567         // FIXME: We could make swap part of VectorTypeOperations
 568         // https://bugs.webkit.org/show_bug.cgi?id=128863
 569         swapInlineBuffers(inlineBuffer(), other.inlineBuffer(), mySize, otherSize);
 570     }
 571 
 572     static void swapInlineBuffers(T* left, T* right, size_t leftSize, size_t rightSize)
 573     {
 574         if (left == right)
 575             return;
 576 
 577         ASSERT(leftSize &lt;= inlineCapacity);
 578         ASSERT(rightSize &lt;= inlineCapacity);
 579 
 580         size_t swapBound = std::min(leftSize, rightSize);
 581         for (unsigned i = 0; i &lt; swapBound; ++i)
 582             std::swap(left[i], right[i]);
 583         VectorTypeOperations&lt;T&gt;::move(left + swapBound, left + leftSize, right + swapBound);
 584         VectorTypeOperations&lt;T&gt;::move(right + swapBound, right + rightSize, left + swapBound);
 585     }
 586 
 587     T* inlineBuffer() { return reinterpret_cast_ptr&lt;T*&gt;(m_inlineBuffer); }
 588     const T* inlineBuffer() const { return reinterpret_cast_ptr&lt;const T*&gt;(m_inlineBuffer); }
 589 
 590 #if ASAN_ENABLED
 591     // ASan needs the buffer to begin and end on 8-byte boundaries for annotations to work.
 592     // FIXME: Add a redzone before the buffer to catch off by one accesses. We don&#39;t need a guard after, because the buffer is the last member variable.
 593     static const size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;
 594     static const size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);
 595     typename std::aligned_storage&lt;sizeof(T), asanInlineBufferAlignment&gt;::type m_inlineBuffer[asanAdjustedInlineCapacity];
 596 #else
 597     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_inlineBuffer[inlineCapacity];
 598 #endif
 599 };
 600 
 601 struct UnsafeVectorOverflow {
 602     static NO_RETURN_DUE_TO_ASSERT void overflowed()
 603     {
 604         ASSERT_NOT_REACHED();
 605     }
 606 };
 607 
 608 // Template default values are in Forward.h.
 609 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 610 class Vector : private VectorBuffer&lt;T, inlineCapacity&gt; {
 611     WTF_MAKE_FAST_ALLOCATED;
 612 private:
 613     typedef VectorBuffer&lt;T, inlineCapacity&gt; Base;
 614     typedef VectorTypeOperations&lt;T&gt; TypeOperations;
 615     friend class JSC::LLIntOffsetsExtractor;
 616 
 617 public:
 618     typedef T ValueType;
 619 
 620     typedef T* iterator;
 621     typedef const T* const_iterator;
 622     typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
 623     typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
 624 
 625     Vector()
 626     {
 627     }
 628 
 629     // Unlike in std::vector, this constructor does not initialize POD types.
 630     explicit Vector(size_t size)
 631         : Base(size, size)
 632     {
 633         asanSetInitialBufferSizeTo(size);
 634 
 635         if (begin())
 636             TypeOperations::initializeIfNonPOD(begin(), end());
 637     }
 638 
 639     Vector(size_t size, const T&amp; val)
 640         : Base(size, size)
 641     {
 642         asanSetInitialBufferSizeTo(size);
 643 
 644         if (begin())
 645             TypeOperations::uninitializedFill(begin(), end(), val);
 646     }
 647 
 648     Vector(std::initializer_list&lt;T&gt; initializerList)
 649     {
 650         reserveInitialCapacity(initializerList.size());
 651 
 652         asanSetInitialBufferSizeTo(initializerList.size());
 653 
 654         for (const auto&amp; element : initializerList)
 655             uncheckedAppend(element);
 656     }
 657 
 658     template&lt;typename... Items&gt;
 659     static Vector from(Items&amp;&amp;... items)
 660     {
 661         Vector result;
 662         auto size = sizeof...(items);
 663 
 664         result.reserveInitialCapacity(size);
 665         result.asanSetInitialBufferSizeTo(size);
 666         result.m_size = size;
 667 
 668         result.uncheckedInitialize&lt;0&gt;(std::forward&lt;Items&gt;(items)...);
 669         return result;
 670     }
 671 
 672     ~Vector()
 673     {
 674         if (m_size)
 675             TypeOperations::destruct(begin(), end());
 676 
 677         asanSetBufferSizeToFullCapacity(0);
 678     }
 679 
 680     Vector(const Vector&amp;);
 681     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;
 682     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);
 683 
 684     Vector&amp; operator=(const Vector&amp;);
 685     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;
 686     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);
 687 
 688     Vector(Vector&amp;&amp;);
 689     Vector&amp; operator=(Vector&amp;&amp;);
 690 
 691     size_t size() const { return m_size; }
 692     static ptrdiff_t sizeMemoryOffset() { return OBJECT_OFFSETOF(Vector, m_size); }
 693     size_t capacity() const { return Base::capacity(); }
 694     bool isEmpty() const { return !size(); }
 695 
 696     T&amp; at(size_t i)
 697     {
 698         if (UNLIKELY(i &gt;= size()))
 699             OverflowHandler::overflowed();
 700         return Base::buffer()[i];
 701     }
 702     const T&amp; at(size_t i) const
 703     {
 704         if (UNLIKELY(i &gt;= size()))
 705             OverflowHandler::overflowed();
 706         return Base::buffer()[i];
 707     }
 708     T&amp; at(Checked&lt;size_t&gt; i)
 709     {
 710         RELEASE_ASSERT(i &lt; size());
 711         return Base::buffer()[i];
 712     }
 713     const T&amp; at(Checked&lt;size_t&gt; i) const
 714     {
 715         RELEASE_ASSERT(i &lt; size());
 716         return Base::buffer()[i];
 717     }
 718 
 719     T&amp; operator[](size_t i) { return at(i); }
 720     const T&amp; operator[](size_t i) const { return at(i); }
 721     T&amp; operator[](Checked&lt;size_t&gt; i) { return at(i); }
 722     const T&amp; operator[](Checked&lt;size_t&gt; i) const { return at(i); }
 723 
 724     T* data() { return Base::buffer(); }
 725     const T* data() const { return Base::buffer(); }
 726     static ptrdiff_t dataMemoryOffset() { return Base::bufferMemoryOffset(); }
 727 
 728     iterator begin() { return data(); }
 729     iterator end() { return begin() + m_size; }
 730     const_iterator begin() const { return data(); }
 731     const_iterator end() const { return begin() + m_size; }
 732 
 733     reverse_iterator rbegin() { return reverse_iterator(end()); }
 734     reverse_iterator rend() { return reverse_iterator(begin()); }
 735     const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
 736     const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
 737 
 738     T&amp; first() { return at(0); }
 739     const T&amp; first() const { return at(0); }
 740     T&amp; last() { return at(size() - 1); }
 741     const T&amp; last() const { return at(size() - 1); }
 742 
 743     T takeLast()
 744     {
 745         T result = WTFMove(last());
 746         removeLast();
 747         return result;
 748     }
 749 
 750     template&lt;typename U&gt; bool contains(const U&amp;) const;
 751     template&lt;typename U&gt; size_t find(const U&amp;) const;
 752     template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const;
 753     template&lt;typename U&gt; size_t reverseFind(const U&amp;) const;
 754 
 755     template&lt;typename U&gt; bool appendIfNotContains(const U&amp;);
 756 
 757     void shrink(size_t size);
 758     void grow(size_t size);
 759     void resize(size_t size);
 760     void resizeToFit(size_t size);
 761     void reserveCapacity(size_t newCapacity);
 762     bool tryReserveCapacity(size_t newCapacity);
 763     void reserveInitialCapacity(size_t initialCapacity);
 764     void shrinkCapacity(size_t newCapacity);
 765     void shrinkToFit() { shrinkCapacity(size()); }
 766 
 767     void clear() { shrinkCapacity(0); }
 768 
 769     template&lt;typename U = T&gt; Vector&lt;U&gt; isolatedCopy() const;
 770 
 771     ALWAYS_INLINE void append(ValueType&amp;&amp; value) { append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 772     template&lt;typename U&gt; void append(U&amp;&amp;);
 773     template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);
 774     template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);
 775 
 776     void uncheckedAppend(ValueType&amp;&amp; value) { uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 777     template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);
<a name="1" id="anc1"></a>
 778 
 779     template&lt;typename U&gt; void append(const U*, size_t);
 780     template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);
 781     template&lt;typename U&gt; bool tryAppend(const U*, size_t);
 782 
 783     template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
 784     template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
 785     template&lt;typename U, size_t c, typename OH&gt; void insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp;);
 786 
 787     void remove(size_t position);
 788     void remove(size_t position, size_t length);
 789     template&lt;typename U&gt; bool removeFirst(const U&amp;);
 790     template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);
 791     template&lt;typename U&gt; unsigned removeAll(const U&amp;);
 792     template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);
 793 
 794     void removeLast()
 795     {
 796         if (UNLIKELY(isEmpty()))
 797             OverflowHandler::overflowed();
 798         shrink(size() - 1);
 799     }
 800 
 801     void fill(const T&amp;, size_t);
 802     void fill(const T&amp; val) { fill(val, size()); }
 803 
 804     template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);
 805 
 806     MallocPtr&lt;T&gt; releaseBuffer();
 807 
 808     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)
 809     {
 810 #if ASAN_ENABLED
 811         if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.
 812             return;
 813 #endif
 814 
 815         // Make it possible to copy inline buffers.
 816         asanSetBufferSizeToFullCapacity();
 817         other.asanSetBufferSizeToFullCapacity();
 818 
 819         Base::swap(other, m_size, other.m_size);
 820         std::swap(m_size, other.m_size);
 821 
 822         asanSetInitialBufferSizeTo(m_size);
 823         other.asanSetInitialBufferSizeTo(other.m_size);
 824     }
 825 
 826     void reverse();
 827 
 828     void checkConsistency();
 829 
 830     template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;
 831 
 832 private:
 833     void expandCapacity(size_t newMinCapacity);
 834     T* expandCapacity(size_t newMinCapacity, T*);
 835     bool tryExpandCapacity(size_t newMinCapacity);
 836     const T* tryExpandCapacity(size_t newMinCapacity, const T*);
 837     template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*);
 838     template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);
 839     template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);
 840     template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);
 841 
 842     template&lt;size_t position, typename U, typename... Items&gt;
 843     void uncheckedInitialize(U&amp;&amp; item, Items&amp;&amp;... items)
 844     {
 845         uncheckedInitialize&lt;position&gt;(std::forward&lt;U&gt;(item));
 846         uncheckedInitialize&lt;position + 1&gt;(std::forward&lt;Items&gt;(items)...);
 847     }
 848     template&lt;size_t position, typename U&gt;
 849     void uncheckedInitialize(U&amp;&amp; value)
 850     {
 851         ASSERT(position &lt; size());
 852         ASSERT(position &lt; capacity());
 853         new (NotNull, begin() + position) T(std::forward&lt;U&gt;(value));
 854     }
 855 
 856     void asanSetInitialBufferSizeTo(size_t);
 857     void asanSetBufferSizeToFullCapacity(size_t);
 858     void asanSetBufferSizeToFullCapacity() { asanSetBufferSizeToFullCapacity(size()); }
 859 
 860     void asanBufferSizeWillChangeTo(size_t);
 861 
 862     using Base::m_size;
 863     using Base::buffer;
 864     using Base::capacity;
 865     using Base::swap;
 866     using Base::allocateBuffer;
 867     using Base::deallocateBuffer;
 868     using Base::tryAllocateBuffer;
 869     using Base::shouldReallocateBuffer;
 870     using Base::reallocateBuffer;
 871     using Base::restoreInlineBufferIfNeeded;
 872     using Base::releaseBuffer;
 873 #if ASAN_ENABLED
 874     using Base::endOfBuffer;
 875 #endif
 876 };
 877 
 878 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 879 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&amp; other)
 880     : Base(other.capacity(), other.size())
 881 {
 882     asanSetInitialBufferSizeTo(other.size());
 883 
 884     if (begin())
 885         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 886 }
 887 
 888 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 889 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;
 890 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)
 891     : Base(other.capacity(), other.size())
 892 {
 893     asanSetInitialBufferSizeTo(other.size());
 894 
 895     if (begin())
 896         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 897 }
 898 
 899 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 900 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)
 901 {
 902     if (&amp;other == this)
 903         return *this;
 904 
 905     if (size() &gt; other.size())
 906         shrink(other.size());
 907     else if (other.size() &gt; capacity()) {
 908         clear();
 909         reserveCapacity(other.size());
 910         ASSERT(begin());
 911     }
 912 
 913     asanBufferSizeWillChangeTo(other.size());
 914 
 915     std::copy(other.begin(), other.begin() + size(), begin());
 916     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 917     m_size = other.size();
 918 
 919     return *this;
 920 }
 921 
 922 inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }
 923 
 924 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 925 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;
 926 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)
 927 {
 928     // If the inline capacities match, we should call the more specific
 929     // template.  If the inline capacities don&#39;t match, the two objects
 930     // shouldn&#39;t be allocated the same address.
 931     ASSERT(!typelessPointersAreEqual(&amp;other, this));
 932 
 933     if (size() &gt; other.size())
 934         shrink(other.size());
 935     else if (other.size() &gt; capacity()) {
 936         clear();
 937         reserveCapacity(other.size());
 938         ASSERT(begin());
 939     }
 940 
 941     asanBufferSizeWillChangeTo(other.size());
 942 
 943     std::copy(other.begin(), other.begin() + size(), begin());
 944     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 945     m_size = other.size();
 946 
 947     return *this;
 948 }
 949 
 950 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 951 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)
 952 {
 953     swap(other);
 954 }
 955 
 956 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 957 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)
 958 {
 959     swap(other);
 960     return *this;
 961 }
 962 
 963 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 964 template&lt;typename U&gt;
 965 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::contains(const U&amp; value) const
 966 {
 967     return find(value) != notFound;
 968 }
 969 
 970 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 971 template&lt;typename MatchFunction&gt;
 972 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::findMatching(const MatchFunction&amp; matches) const
 973 {
 974     for (size_t i = 0; i &lt; size(); ++i) {
 975         if (matches(at(i)))
 976             return i;
 977     }
 978     return notFound;
 979 }
 980 
 981 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 982 template&lt;typename U&gt;
 983 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::find(const U&amp; value) const
 984 {
 985     return findMatching([&amp;](auto&amp; item) {
 986         return item == value;
 987     });
 988 }
 989 
 990 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 991 template&lt;typename U&gt;
 992 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverseFind(const U&amp; value) const
 993 {
 994     for (size_t i = 1; i &lt;= size(); ++i) {
 995         const size_t index = size() - i;
 996         if (at(index) == value)
 997             return index;
 998     }
 999     return notFound;
1000 }
1001 
1002 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1003 template&lt;typename U&gt;
1004 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendIfNotContains(const U&amp; value)
1005 {
1006     if (contains(value))
1007         return false;
1008     append(value);
1009     return true;
1010 }
1011 
1012 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1013 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::fill(const T&amp; val, size_t newSize)
1014 {
1015     if (size() &gt; newSize)
1016         shrink(newSize);
1017     else if (newSize &gt; capacity()) {
1018         clear();
1019         reserveCapacity(newSize);
1020         ASSERT(begin());
1021     }
1022 
1023     asanBufferSizeWillChangeTo(newSize);
1024 
1025     std::fill(begin(), end(), val);
1026     TypeOperations::uninitializedFill(end(), begin() + newSize, val);
1027     m_size = newSize;
1028 }
1029 
1030 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1031 template&lt;typename Iterator&gt;
1032 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendRange(Iterator start, Iterator end)
1033 {
1034     for (Iterator it = start; it != end; ++it)
1035         append(*it);
1036 }
1037 
1038 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1039 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity)
1040 {
1041     reserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1042 }
1043 
1044 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1045 NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, T* ptr)
1046 {
1047     if (ptr &lt; begin() || ptr &gt;= end()) {
1048         expandCapacity(newMinCapacity);
1049         return ptr;
1050     }
1051     size_t index = ptr - begin();
1052     expandCapacity(newMinCapacity);
1053     return begin() + index;
1054 }
1055 
1056 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1057 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity)
1058 {
1059     return tryReserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1060 }
1061 
1062 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1063 const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)
1064 {
1065     if (ptr &lt; begin() || ptr &gt;= end()) {
1066         if (!tryExpandCapacity(newMinCapacity))
1067             return 0;
1068         return ptr;
1069     }
1070     size_t index = ptr - begin();
1071     if (!tryExpandCapacity(newMinCapacity))
1072         return 0;
1073     return begin() + index;
1074 }
1075 
1076 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1077 template&lt;typename U&gt;
1078 inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, U* ptr)
1079 {
1080     expandCapacity(newMinCapacity);
1081     return ptr;
1082 }
1083 
1084 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1085 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resize(size_t size)
1086 {
1087     if (size &lt;= m_size) {
1088         TypeOperations::destruct(begin() + size, end());
1089         asanBufferSizeWillChangeTo(size);
1090     } else {
1091         if (size &gt; capacity())
1092             expandCapacity(size);
1093         asanBufferSizeWillChangeTo(size);
1094         if (begin())
1095             TypeOperations::initializeIfNonPOD(end(), begin() + size);
1096     }
1097 
1098     m_size = size;
1099 }
1100 
1101 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1102 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resizeToFit(size_t size)
1103 {
1104     reserveCapacity(size);
1105     resize(size);
1106 }
1107 
1108 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1109 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrink(size_t size)
1110 {
1111     ASSERT(size &lt;= m_size);
1112     TypeOperations::destruct(begin() + size, end());
1113     asanBufferSizeWillChangeTo(size);
1114     m_size = size;
1115 }
1116 
1117 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1118 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::grow(size_t size)
1119 {
1120     ASSERT(size &gt;= m_size);
1121     if (size &gt; capacity())
1122         expandCapacity(size);
1123     asanBufferSizeWillChangeTo(size);
1124     if (begin())
1125         TypeOperations::initializeIfNonPOD(end(), begin() + size);
1126     m_size = size;
1127 }
1128 
1129 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1130 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetInitialBufferSizeTo(size_t size)
1131 {
1132 #if ASAN_ENABLED
1133     if (!buffer())
1134         return;
1135 
1136     // This function resticts buffer access to only elements in [begin(), end()) range, making ASan detect an error
1137     // when accessing elements in [end(), endOfBuffer()) range.
1138     // A newly allocated buffer can be accessed without restrictions, so &quot;old_mid&quot; argument equals &quot;end&quot; argument.
1139     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), endOfBuffer(), buffer() + size);
1140 #else
1141     UNUSED_PARAM(size);
1142 #endif
1143 }
1144 
1145 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1146 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetBufferSizeToFullCapacity(size_t size)
1147 {
1148 #if ASAN_ENABLED
1149     if (!buffer())
1150         return;
1151 
1152     // ASan requires that the annotation is returned to its initial state before deallocation.
1153     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size, endOfBuffer());
1154 #else
1155     UNUSED_PARAM(size);
1156 #endif
1157 }
1158 
1159 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1160 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanBufferSizeWillChangeTo(size_t newSize)
1161 {
1162 #if ASAN_ENABLED
1163     if (!buffer())
1164         return;
1165 
1166     // Change allowed range.
1167     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size(), buffer() + newSize);
1168 #else
1169     UNUSED_PARAM(newSize);
1170 #endif
1171 }
1172 
1173 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1174 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveCapacity(size_t newCapacity)
1175 {
1176     if (newCapacity &lt;= capacity())
1177         return;
1178     T* oldBuffer = begin();
1179     T* oldEnd = end();
1180 
1181     asanSetBufferSizeToFullCapacity();
1182 
1183     Base::allocateBuffer(newCapacity);
1184     ASSERT(begin());
1185 
1186     asanSetInitialBufferSizeTo(size());
1187 
1188     TypeOperations::move(oldBuffer, oldEnd, begin());
1189     Base::deallocateBuffer(oldBuffer);
1190 }
1191 
1192 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1193 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryReserveCapacity(size_t newCapacity)
1194 {
1195     if (newCapacity &lt;= capacity())
1196         return true;
1197     T* oldBuffer = begin();
1198     T* oldEnd = end();
1199 
1200     asanSetBufferSizeToFullCapacity();
1201 
1202     if (!Base::tryAllocateBuffer(newCapacity)) {
1203         asanSetInitialBufferSizeTo(size());
1204         return false;
1205     }
1206     ASSERT(begin());
1207 
1208     asanSetInitialBufferSizeTo(size());
1209 
1210     TypeOperations::move(oldBuffer, oldEnd, begin());
1211     Base::deallocateBuffer(oldBuffer);
1212     return true;
1213 }
1214 
1215 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1216 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveInitialCapacity(size_t initialCapacity)
1217 {
1218     ASSERT(!m_size);
1219     ASSERT(capacity() == inlineCapacity);
1220     if (initialCapacity &gt; inlineCapacity)
1221         Base::allocateBuffer(initialCapacity);
1222 }
1223 
1224 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1225 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrinkCapacity(size_t newCapacity)
1226 {
1227     if (newCapacity &gt;= capacity())
1228         return;
1229 
1230     if (newCapacity &lt; size())
1231         shrink(newCapacity);
1232 
1233     asanSetBufferSizeToFullCapacity();
1234 
1235     T* oldBuffer = begin();
1236     if (newCapacity &gt; 0) {
1237         if (Base::shouldReallocateBuffer(newCapacity)) {
1238             Base::reallocateBuffer(newCapacity);
1239             asanSetInitialBufferSizeTo(size());
1240             return;
1241         }
1242 
1243         T* oldEnd = end();
1244         Base::allocateBuffer(newCapacity);
1245         if (begin() != oldBuffer)
1246             TypeOperations::move(oldBuffer, oldEnd, begin());
1247     }
1248 
1249     Base::deallocateBuffer(oldBuffer);
1250     Base::restoreInlineBufferIfNeeded();
1251 
1252     asanSetInitialBufferSizeTo(size());
1253 }
1254 
1255 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1256 template&lt;typename U&gt;
1257 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(const U* data, size_t dataSize)
1258 {
1259     size_t newSize = m_size + dataSize;
1260     if (newSize &gt; capacity()) {
1261         data = expandCapacity(newSize, data);
1262         ASSERT(begin());
1263     }
1264     if (newSize &lt; m_size)
1265         CRASH();
1266     asanBufferSizeWillChangeTo(newSize);
1267     T* dest = end();
1268     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1269     m_size = newSize;
1270 }
1271 
1272 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1273 template&lt;typename U&gt;
1274 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryAppend(const U* data, size_t dataSize)
1275 {
1276     size_t newSize = m_size + dataSize;
1277     if (newSize &gt; capacity()) {
1278         data = tryExpandCapacity(newSize, data);
1279         if (!data)
1280             return false;
1281         ASSERT(begin());
1282     }
1283     if (newSize &lt; m_size)
1284         return false;
1285     asanBufferSizeWillChangeTo(newSize);
1286     T* dest = end();
1287     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1288     m_size = newSize;
1289     return true;
1290 }
1291 
1292 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1293 template&lt;typename U&gt;
1294 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(U&amp;&amp; value)
1295 {
1296     if (size() != capacity()) {
1297         asanBufferSizeWillChangeTo(m_size + 1);
1298         new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1299         ++m_size;
1300         return;
1301     }
1302 
1303     appendSlowCase(std::forward&lt;U&gt;(value));
1304 }
1305 
1306 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1307 template&lt;typename... Args&gt;
1308 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppend(Args&amp;&amp;... args)
1309 {
1310     if (size() != capacity()) {
1311         asanBufferSizeWillChangeTo(m_size + 1);
1312         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1313         ++m_size;
1314         return;
1315     }
1316 
1317     constructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1318 }
1319 
1320 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1321 template&lt;typename... Args&gt;
1322 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppend(Args&amp;&amp;... args)
1323 {
1324     if (size() != capacity()) {
1325         asanBufferSizeWillChangeTo(m_size + 1);
1326         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1327         ++m_size;
1328         return true;
1329     }
1330 
1331     return tryConstructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1332 }
1333 
1334 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1335 template&lt;typename U&gt;
1336 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendSlowCase(U&amp;&amp; value)
1337 {
1338     ASSERT(size() == capacity());
1339 
1340     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1341     ptr = expandCapacity(size() + 1, ptr);
1342     ASSERT(begin());
1343 
1344     asanBufferSizeWillChangeTo(m_size + 1);
1345     new (NotNull, end()) T(std::forward&lt;U&gt;(*ptr));
1346     ++m_size;
1347 }
1348 
1349 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1350 template&lt;typename... Args&gt;
1351 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)
1352 {
1353     ASSERT(size() == capacity());
1354 
1355     expandCapacity(size() + 1);
1356     ASSERT(begin());
1357 
1358     asanBufferSizeWillChangeTo(m_size + 1);
1359     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1360     ++m_size;
1361 }
1362 
1363 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1364 template&lt;typename... Args&gt;
1365 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)
1366 {
1367     ASSERT(size() == capacity());
1368 
1369     if (UNLIKELY(!tryExpandCapacity(size() + 1)))
1370         return false;
1371     ASSERT(begin());
1372 
1373     asanBufferSizeWillChangeTo(m_size + 1);
1374     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1375     ++m_size;
1376     return true;
1377 }
1378 
1379 // This version of append saves a branch in the case where you know that the
1380 // vector&#39;s capacity is large enough for the append to succeed.
1381 
1382 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1383 template&lt;typename U&gt;
1384 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::uncheckedAppend(U&amp;&amp; value)
1385 {
1386     ASSERT(size() &lt; capacity());
1387 
1388     asanBufferSizeWillChangeTo(m_size + 1);
1389 
1390     new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1391     ++m_size;
1392 }
1393 
1394 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
<a name="2" id="anc2"></a>











1395 template&lt;typename U, size_t otherCapacity&gt;
1396 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)
1397 {
1398     append(val.begin(), val.size());
1399 }
1400 
1401 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1402 template&lt;typename U&gt;
1403 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, const U* data, size_t dataSize)
1404 {
1405     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1406     size_t newSize = m_size + dataSize;
1407     if (newSize &gt; capacity()) {
1408         data = expandCapacity(newSize, data);
1409         ASSERT(begin());
1410     }
1411     if (newSize &lt; m_size)
1412         CRASH();
1413     asanBufferSizeWillChangeTo(newSize);
1414     T* spot = begin() + position;
1415     TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
1416     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), spot);
1417     m_size = newSize;
1418 }
1419 
1420 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1421 template&lt;typename U&gt;
1422 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, U&amp;&amp; value)
1423 {
1424     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1425 
1426     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1427     if (size() == capacity()) {
1428         ptr = expandCapacity(size() + 1, ptr);
1429         ASSERT(begin());
1430     }
1431 
1432     asanBufferSizeWillChangeTo(m_size + 1);
1433 
1434     T* spot = begin() + position;
1435     TypeOperations::moveOverlapping(spot, end(), spot + 1);
1436     new (NotNull, spot) T(std::forward&lt;U&gt;(*ptr));
1437     ++m_size;
1438 }
1439 
1440 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1441 template&lt;typename U, size_t c, typename OH&gt;
1442 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp; val)
1443 {
1444     insert(position, val.begin(), val.size());
1445 }
1446 
1447 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1448 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position)
1449 {
1450     ASSERT_WITH_SECURITY_IMPLICATION(position &lt; size());
1451     T* spot = begin() + position;
1452     spot-&gt;~T();
1453     TypeOperations::moveOverlapping(spot + 1, end(), spot);
1454     asanBufferSizeWillChangeTo(m_size - 1);
1455     --m_size;
1456 }
1457 
1458 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1459 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position, size_t length)
1460 {
1461     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1462     ASSERT_WITH_SECURITY_IMPLICATION(position + length &lt;= size());
1463     T* beginSpot = begin() + position;
1464     T* endSpot = beginSpot + length;
1465     TypeOperations::destruct(beginSpot, endSpot);
1466     TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
1467     asanBufferSizeWillChangeTo(m_size - length);
1468     m_size -= length;
1469 }
1470 
1471 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1472 template&lt;typename U&gt;
1473 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirst(const U&amp; value)
1474 {
1475     return removeFirstMatching([&amp;value] (const T&amp; current) {
1476         return current == value;
1477     });
1478 }
1479 
1480 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1481 template&lt;typename MatchFunction&gt;
1482 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)
1483 {
1484     for (size_t i = startIndex; i &lt; size(); ++i) {
1485         if (matches(at(i))) {
1486             remove(i);
1487             return true;
1488         }
1489     }
1490     return false;
1491 }
1492 
1493 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1494 template&lt;typename U&gt;
1495 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAll(const U&amp; value)
1496 {
1497     return removeAllMatching([&amp;value] (const T&amp; current) {
1498         return current == value;
1499     });
1500 }
1501 
1502 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1503 template&lt;typename MatchFunction&gt;
1504 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)
1505 {
1506     iterator holeBegin = end();
1507     iterator holeEnd = end();
1508     unsigned matchCount = 0;
1509     for (auto it = begin() + startIndex, itEnd = end(); it &lt; itEnd; ++it) {
1510         if (matches(*it)) {
1511             if (holeBegin == end())
1512                 holeBegin = it;
1513             else if (holeEnd != it) {
1514                 TypeOperations::moveOverlapping(holeEnd, it, holeBegin);
1515                 holeBegin += it - holeEnd;
1516             }
1517             holeEnd = it + 1;
1518             it-&gt;~T();
1519             ++matchCount;
1520         }
1521     }
1522     if (holeEnd != end())
1523         TypeOperations::moveOverlapping(holeEnd, end(), holeBegin);
1524     asanBufferSizeWillChangeTo(m_size - matchCount);
1525     m_size -= matchCount;
1526     return matchCount;
1527 }
1528 
1529 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1530 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverse()
1531 {
1532     for (size_t i = 0; i &lt; m_size / 2; ++i)
1533         std::swap(at(i), at(m_size - 1 - i));
1534 }
1535 
1536 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1537 template&lt;typename MapFunction, typename R&gt;
1538 inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::map(MapFunction mapFunction) const
1539 {
1540     Vector&lt;R&gt; result;
1541     result.reserveInitialCapacity(size());
1542     for (size_t i = 0; i &lt; size(); ++i)
1543         result.uncheckedAppend(mapFunction(at(i)));
1544     return result;
1545 }
1546 
1547 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1548 inline MallocPtr&lt;T&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::releaseBuffer()
1549 {
1550     // FIXME: Find a way to preserve annotations on the returned buffer.
1551     // ASan requires that all annotations are removed before deallocation,
1552     // and MallocPtr doesn&#39;t implement that.
1553     asanSetBufferSizeToFullCapacity();
1554 
1555     auto buffer = Base::releaseBuffer();
1556     if (inlineCapacity &amp;&amp; !buffer &amp;&amp; m_size) {
1557         // If the vector had some data, but no buffer to release,
1558         // that means it was using the inline buffer. In that case,
1559         // we create a brand new buffer so the caller always gets one.
1560         size_t bytes = m_size * sizeof(T);
1561         buffer = adoptMallocPtr(static_cast&lt;T*&gt;(fastMalloc(bytes)));
1562         memcpy(buffer.get(), data(), bytes);
1563     }
1564     m_size = 0;
1565     // FIXME: Should we call Base::restoreInlineBufferIfNeeded() here?
1566     return buffer;
1567 }
1568 
1569 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1570 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::checkConsistency()
1571 {
1572 #if !ASSERT_DISABLED
1573     for (size_t i = 0; i &lt; size(); ++i)
1574         ValueCheck&lt;T&gt;::checkConsistency(at(i));
1575 #endif
1576 }
1577 
1578 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1579 inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)
1580 {
1581     a.swap(b);
1582 }
1583 
1584 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1585 bool operator==(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)
1586 {
1587     if (a.size() != b.size())
1588         return false;
1589 
1590     return VectorTypeOperations&lt;T&gt;::compare(a.data(), b.data(), a.size());
1591 }
1592 
1593 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1594 inline bool operator!=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)
1595 {
1596     return !(a == b);
1597 }
1598 
1599 #if !ASSERT_DISABLED
1600 template&lt;typename T&gt; struct ValueCheck&lt;Vector&lt;T&gt;&gt; {
1601     typedef Vector&lt;T&gt; TraitType;
1602     static void checkConsistency(const Vector&lt;T&gt;&amp; v)
1603     {
1604         v.checkConsistency();
1605     }
1606 };
1607 #endif
1608 
1609 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1610 template&lt;typename U&gt;
1611 inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::isolatedCopy() const
1612 {
1613     Vector&lt;U&gt; copy;
1614     copy.reserveInitialCapacity(size());
1615     for (const auto&amp; element : *this)
1616         copy.uncheckedAppend(element.isolatedCopy());
1617     return copy;
1618 }
1619 
1620 template&lt;typename VectorType, typename Func&gt;
1621 size_t removeRepeatedElements(VectorType&amp; vector, const Func&amp; func)
1622 {
1623     auto end = std::unique(vector.begin(), vector.end(), func);
1624     size_t newSize = end - vector.begin();
1625     vector.shrink(newSize);
1626     return newSize;
1627 }
1628 
1629 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
1630 size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; vector)
1631 {
1632     return removeRepeatedElements(vector, [] (T&amp; a, T&amp; b) { return a == b; });
1633 }
1634 
1635 template&lt;typename SourceType&gt;
1636 struct CollectionInspector {
1637     using RealSourceType = typename std::remove_reference&lt;SourceType&gt;::type;
1638     using IteratorType = decltype(std::begin(std::declval&lt;RealSourceType&gt;()));
1639     using SourceItemType = typename std::iterator_traits&lt;IteratorType&gt;::value_type;
1640 };
1641 
1642 template&lt;typename MapFunction, typename SourceType, typename Enable = void&gt;
1643 struct Mapper {
1644     using SourceItemType = typename CollectionInspector&lt;SourceType&gt;::SourceItemType;
1645     using DestinationItemType = typename std::result_of&lt;MapFunction(SourceItemType&amp;)&gt;::type;
1646 
1647     static Vector&lt;DestinationItemType&gt; map(SourceType source, const MapFunction&amp; mapFunction)
1648     {
1649         Vector&lt;DestinationItemType&gt; result;
1650         // FIXME: Use std::size when available on all compilers.
1651         result.reserveInitialCapacity(source.size());
1652         for (auto&amp; item : source)
1653             result.uncheckedAppend(mapFunction(item));
1654         return result;
1655     }
1656 };
1657 
1658 template&lt;typename MapFunction, typename SourceType&gt;
1659 struct Mapper&lt;MapFunction, SourceType, typename std::enable_if&lt;std::is_rvalue_reference&lt;SourceType&amp;&amp;&gt;::value&gt;::type&gt; {
1660     using SourceItemType = typename CollectionInspector&lt;SourceType&gt;::SourceItemType;
1661     using DestinationItemType = typename std::result_of&lt;MapFunction(SourceItemType&amp;&amp;)&gt;::type;
1662 
1663     static Vector&lt;DestinationItemType&gt; map(SourceType&amp;&amp; source, const MapFunction&amp; mapFunction)
1664     {
1665         Vector&lt;DestinationItemType&gt; result;
1666         // FIXME: Use std::size when available on all compilers.
1667         result.reserveInitialCapacity(source.size());
1668         for (auto&amp; item : source)
1669             result.uncheckedAppend(mapFunction(WTFMove(item)));
1670         return result;
1671     }
1672 };
1673 
1674 template&lt;typename MapFunction, typename SourceType&gt;
1675 Vector&lt;typename Mapper&lt;MapFunction, SourceType&gt;::DestinationItemType&gt; map(SourceType&amp;&amp; source, MapFunction&amp;&amp; mapFunction)
1676 {
1677     return Mapper&lt;MapFunction, SourceType&gt;::map(std::forward&lt;SourceType&gt;(source), std::forward&lt;MapFunction&gt;(mapFunction));
1678 }
1679 
1680 template&lt;typename DestinationVector, typename Collection&gt;
1681 inline auto copyToVectorSpecialization(const Collection&amp; collection) -&gt; DestinationVector
1682 {
1683     DestinationVector result;
1684     // FIXME: Use std::size when available on all compilers.
1685     result.reserveInitialCapacity(collection.size());
1686     for (auto&amp; item : collection)
1687         result.uncheckedAppend(item);
1688     return result;
1689 }
1690 
1691 template&lt;typename DestinationItemType, typename Collection&gt;
1692 inline auto copyToVectorOf(const Collection&amp; collection) -&gt; Vector&lt;DestinationItemType&gt;
1693 {
1694     return WTF::map(collection, [] (const auto&amp; v) -&gt; DestinationItemType { return v; });
1695 }
1696 
1697 template&lt;typename Collection&gt;
1698 struct CopyToVectorResult {
1699     using Type = typename std::remove_cv&lt;typename CollectionInspector&lt;Collection&gt;::SourceItemType&gt;::type;
1700 };
1701 
1702 template&lt;typename Collection&gt;
1703 inline auto copyToVector(const Collection&amp; collection) -&gt; Vector&lt;typename CopyToVectorResult&lt;Collection&gt;::Type&gt;
1704 {
1705     return copyToVectorOf&lt;typename CopyToVectorResult&lt;Collection&gt;::Type&gt;(collection);
1706 }
1707 
1708 } // namespace WTF
1709 
1710 using WTF::UnsafeVectorOverflow;
1711 using WTF::Vector;
1712 using WTF::copyToVector;
1713 using WTF::copyToVectorOf;
1714 using WTF::copyToVectorSpecialization;
1715 using WTF::removeRepeatedElements;
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>