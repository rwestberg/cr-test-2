<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineFormattingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingState.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextLineLayout.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,578 ***</span>
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;FloatingContext.h&quot;
  #include &quot;FloatingState.h&quot;
  #include &quot;InlineFormattingState.h&quot;
  #include &quot;InlineLineBreaker.h&quot;
<span class="line-removed">- #include &quot;InlineRunProvider.h&quot;</span>
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutState.h&quot;
  #include &quot;TextUtil.h&quot;
  
  namespace WebCore {
  namespace Layout {
  
<span class="line-modified">! class Line {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     void init(const LayoutPoint&amp; topLeft, LayoutUnit availableWidth, LayoutUnit minimalHeight);</span>
<span class="line-modified">!     void close();</span>
  
<span class="line-modified">!     void appendContent(const InlineRunProvider::Run&amp;, const LayoutSize&amp;);</span>
  
<span class="line-modified">!     void adjustLogicalLeft(LayoutUnit delta);</span>
<span class="line-modified">!     void adjustLogicalRight(LayoutUnit delta);</span>
  
<span class="line-modified">!     bool hasContent() const { return !m_inlineRuns.isEmpty(); }</span>
<span class="line-modified">!     bool isClosed() const { return m_closed; }</span>
<span class="line-removed">-     bool isFirstLine() const { return m_isFirstLine; }</span>
<span class="line-removed">-     Vector&lt;InlineRun&gt;&amp; runs() { return m_inlineRuns; }</span>
  
<span class="line-modified">!     LayoutUnit contentLogicalRight() const;</span>
<span class="line-modified">!     LayoutUnit contentLogicalLeft() const { return m_logicalRect.left(); }</span>
<span class="line-removed">-     LayoutUnit availableWidth() const { return m_availableWidth; }</span>
<span class="line-removed">-     Optional&lt;InlineRunProvider::Run::Type&gt; lastRunType() const { return m_lastRunType; }</span>
  
<span class="line-modified">!     LayoutUnit logicalTop() const { return m_logicalRect.top(); }</span>
<span class="line-modified">!     LayoutUnit logicalBottom() const { return m_logicalRect.bottom(); }</span>
<span class="line-removed">-     LayoutUnit logicalHeight() const { return logicalBottom() - logicalTop(); }</span>
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     struct TrailingTrimmableContent {</span>
<span class="line-removed">-         LayoutUnit width;</span>
<span class="line-removed">-         unsigned length;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     Optional&lt;TrailingTrimmableContent&gt; m_trailingTrimmableContent;</span>
<span class="line-removed">-     Optional&lt;InlineRunProvider::Run::Type&gt; m_lastRunType;</span>
<span class="line-removed">-     bool m_lastRunCanExpand { false };</span>
  
<span class="line-modified">!     Display::Box::Rect m_logicalRect;</span>
<span class="line-modified">!     LayoutUnit m_availableWidth;</span>
  
<span class="line-modified">!     Vector&lt;InlineRun&gt; m_inlineRuns;</span>
<span class="line-modified">!     bool m_isFirstLine { true };</span>
<span class="line-modified">!     bool m_closed { true };</span>
  };
  
<span class="line-modified">! void Line::init(const LayoutPoint&amp; topLeft, LayoutUnit availableWidth, LayoutUnit minimalHeight)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     m_logicalRect.setTopLeft(topLeft);</span>
<span class="line-removed">-     m_logicalRect.setWidth(availableWidth);</span>
<span class="line-removed">-     m_logicalRect.setHeight(minimalHeight);</span>
<span class="line-removed">-     m_availableWidth = availableWidth;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_inlineRuns.clear();</span>
<span class="line-removed">-     m_lastRunType = { };</span>
<span class="line-removed">-     m_lastRunCanExpand = false;</span>
<span class="line-removed">-     m_trailingTrimmableContent = { };</span>
<span class="line-removed">-     m_closed = false;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void Line::adjustLogicalLeft(LayoutUnit delta)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(delta &gt; 0);</span>
  
<span class="line-modified">!     m_availableWidth -= delta;</span>
<span class="line-modified">!     m_logicalRect.shiftLeftTo(m_logicalRect.left() + delta);</span>
  
<span class="line-modified">!     for (auto&amp; inlineRun : m_inlineRuns)</span>
<span class="line-modified">!         inlineRun.moveHorizontally(delta);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Line::adjustLogicalRight(LayoutUnit delta)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(delta &gt; 0);</span>
  
<span class="line-modified">!     m_availableWidth -= delta;</span>
<span class="line-modified">!     m_logicalRect.shiftRightTo(m_logicalRect.right() - delta);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static bool isTrimmableContent(const InlineRunProvider::Run&amp; inlineRun)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     return inlineRun.isWhitespace() &amp;&amp; inlineRun.style().collapseWhiteSpace();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! LayoutUnit Line::contentLogicalRight() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (m_inlineRuns.isEmpty())</span>
<span class="line-modified">!         return m_logicalRect.left();</span>
  
<span class="line-modified">!     return m_inlineRuns.last().logicalRight();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Line::appendContent(const InlineRunProvider::Run&amp; run, const LayoutSize&amp; runSize)</span>
  {
<span class="line-modified">!     ASSERT(!isClosed());</span>
<span class="line-modified">! </span>
<span class="line-removed">-     // Append this text run to the end of the last text run, if the last run is continuous.</span>
<span class="line-removed">-     Optional&lt;InlineRun::TextContext&gt; textRun;</span>
<span class="line-removed">-     if (run.isText()) {</span>
<span class="line-removed">-         auto textContext = run.textContext();</span>
<span class="line-removed">-         auto runLength = textContext-&gt;isCollapsed() ? 1 : textContext-&gt;length();</span>
<span class="line-removed">-         textRun = InlineRun::TextContext { textContext-&gt;start(), runLength };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto requiresNewInlineRun = !hasContent() || !run.isText() || !m_lastRunCanExpand;</span>
<span class="line-removed">-     if (requiresNewInlineRun) {</span>
<span class="line-removed">-         // FIXME: This needs proper baseline handling</span>
<span class="line-removed">-         auto inlineRun = InlineRun { { logicalTop(), contentLogicalRight(), runSize.width(), runSize.height() }, run.inlineItem() };</span>
<span class="line-removed">-         if (textRun)</span>
<span class="line-removed">-             inlineRun.setTextContext({ textRun-&gt;start(), textRun-&gt;length() });</span>
<span class="line-removed">-         m_inlineRuns.append(inlineRun);</span>
<span class="line-removed">-         m_logicalRect.setHeight(std::max(runSize.height(), m_logicalRect.height()));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         // Non-text runs always require new inline run.</span>
<span class="line-removed">-         ASSERT(textRun);</span>
<span class="line-removed">-         auto&amp; inlineRun = m_inlineRuns.last();</span>
<span class="line-removed">-         ASSERT(runSize.height() == inlineRun.logicalHeight());</span>
<span class="line-removed">-         inlineRun.setLogicalWidth(inlineRun.logicalWidth() + runSize.width());</span>
<span class="line-removed">-         inlineRun.textContext()-&gt;setLength(inlineRun.textContext()-&gt;length() + textRun-&gt;length());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_availableWidth -= runSize.width();</span>
<span class="line-removed">-     m_lastRunType = run.type();</span>
<span class="line-removed">-     m_lastRunCanExpand = run.isText() &amp;&amp; !run.textContext()-&gt;isCollapsed();</span>
<span class="line-removed">-     m_trailingTrimmableContent = { };</span>
<span class="line-removed">-     if (isTrimmableContent(run))</span>
<span class="line-removed">-         m_trailingTrimmableContent = TrailingTrimmableContent { runSize.width(), textRun-&gt;length() };</span>
  }
  
<span class="line-modified">! void Line::close()</span>
  {
<span class="line-modified">!     auto trimTrailingContent = [&amp;] {</span>
<span class="line-modified">!         if (!m_trailingTrimmableContent)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         auto&amp; lastInlineRun = m_inlineRuns.last();</span>
<span class="line-removed">-         lastInlineRun.setLogicalWidth(lastInlineRun.logicalWidth() - m_trailingTrimmableContent-&gt;width);</span>
<span class="line-removed">-         lastInlineRun.textContext()-&gt;setLength(lastInlineRun.textContext()-&gt;length() - m_trailingTrimmableContent-&gt;length);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!lastInlineRun.textContext()-&gt;length())</span>
<span class="line-removed">-             m_inlineRuns.removeLast();</span>
<span class="line-removed">-         m_availableWidth += m_trailingTrimmableContent-&gt;width;</span>
<span class="line-removed">-         m_trailingTrimmableContent = { };</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!hasContent())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     trimTrailingContent();</span>
<span class="line-removed">-     m_isFirstLine = false;</span>
<span class="line-removed">-     m_closed = true;</span>
  }
  
<span class="line-modified">! InlineFormattingContext::LineLayout::LineLayout(const InlineFormattingContext&amp; inlineFormattingContext)</span>
<span class="line-modified">!     : m_formattingContext(inlineFormattingContext)</span>
<span class="line-modified">!     , m_formattingState(m_formattingContext.formattingState())</span>
<span class="line-modified">!     , m_floatingState(m_formattingState.floatingState())</span>
<span class="line-modified">!     , m_formattingRoot(downcast&lt;Container&gt;(m_formattingContext.root()))</span>
  {
  }
  
<span class="line-modified">! static bool isTrimmableContent(const InlineLineBreaker::Run&amp; run)</span>
  {
<span class="line-modified">!     return run.content.isWhitespace() &amp;&amp; run.content.style().collapseWhiteSpace();</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::layout(const InlineRunProvider&amp; inlineRunProvider) const</span>
  {
<span class="line-modified">!     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">!     auto floatingContext = FloatingContext { m_floatingState };</span>
  
<span class="line-modified">!     Line line;</span>
<span class="line-modified">!     initializeNewLine(line);</span>
  
<span class="line-modified">!     InlineLineBreaker lineBreaker(layoutState, m_formattingState.inlineContent(), inlineRunProvider.runs());</span>
<span class="line-modified">!     while (auto run = lineBreaker.nextRun(line.contentLogicalRight(), line.availableWidth(), !line.hasContent())) {</span>
<span class="line-modified">!         auto isFirstRun = run-&gt;position == InlineLineBreaker::Run::Position::LineBegin;</span>
<span class="line-removed">-         auto isLastRun = run-&gt;position == InlineLineBreaker::Run::Position::LineEnd;</span>
<span class="line-removed">-         auto generatesInlineRun = true;</span>
  
<span class="line-modified">!         // Position float and adjust the runs on line.</span>
<span class="line-modified">!         if (run-&gt;content.isFloat()) {</span>
<span class="line-modified">!             auto&amp; floatBox = run-&gt;content.inlineItem().layoutBox();</span>
<span class="line-modified">!             computeFloatPosition(floatingContext, line, floatBox);</span>
<span class="line-modified">!             m_floatingState.append(floatBox);</span>
  
<span class="line-modified">!             auto floatBoxWidth = layoutState.displayBoxForLayoutBox(floatBox).marginBox().width();</span>
<span class="line-modified">!             // Shrink availble space for current line and move existing inline runs.</span>
<span class="line-modified">!             floatBox.isLeftFloatingPositioned() ? line.adjustLogicalLeft(floatBoxWidth) : line.adjustLogicalRight(floatBoxWidth);</span>
  
<span class="line-modified">!             generatesInlineRun = false;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // 1. Initialize new line if needed.</span>
<span class="line-modified">!         // 2. Append inline run unless it is skipped.</span>
<span class="line-removed">-         // 3. Close current line if needed.</span>
<span class="line-removed">-         if (isFirstRun) {</span>
<span class="line-removed">-             // When the first run does not generate an actual inline run, the next run comes in first-run as well.</span>
<span class="line-removed">-             // No need to spend time on closing/initializing.</span>
<span class="line-removed">-             // Skip leading whitespace.</span>
<span class="line-removed">-             if (!generatesInlineRun || isTrimmableContent(*run))</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (line.hasContent()) {</span>
<span class="line-removed">-                 // Previous run ended up being at the line end. Adjust the line accordingly.</span>
<span class="line-removed">-                 if (!line.isClosed())</span>
<span class="line-removed">-                     closeLine(line, IsLastLine::No);</span>
<span class="line-removed">-                 initializeNewLine(line);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         if (generatesInlineRun) {</span>
<span class="line-modified">!             auto width = run-&gt;width;</span>
<span class="line-modified">!             auto height = run-&gt;content.isText() ? LayoutUnit(m_formattingRoot.style().computedLineHeight()) : layoutState.displayBoxForLayoutBox(run-&gt;content.inlineItem().layoutBox()).height();</span>
<span class="line-modified">!             appendContentToLine(line, run-&gt;content, { width, height });</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (isLastRun)</span>
<span class="line-modified">!             closeLine(line, IsLastLine::No);</span>
      }
  
<span class="line-modified">!     closeLine(line, IsLastLine::Yes);</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::initializeNewLine(Line&amp; line) const</span>
  {
<span class="line-modified">!     auto&amp; formattingRootDisplayBox = m_formattingContext.layoutState().displayBoxForLayoutBox(m_formattingRoot);</span>
  
      auto lineLogicalLeft = formattingRootDisplayBox.contentBoxLeft();
<span class="line-removed">-     auto lineLogicalTop = line.isFirstLine() ? formattingRootDisplayBox.contentBoxTop() : line.logicalBottom();</span>
<span class="line-removed">-     auto availableWidth = formattingRootDisplayBox.contentBoxWidth();</span>
  
<span class="line-modified">!     // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-modified">!     if (!m_floatingState.isEmpty()) {</span>
<span class="line-modified">!         auto floatConstraints = m_floatingState.constraints({ lineLogicalTop }, m_formattingRoot);</span>
          // Check if these constraints actually put limitation on the line.
<span class="line-modified">!         if (floatConstraints.left &amp;&amp; *floatConstraints.left &lt;= formattingRootDisplayBox.contentBoxLeft())</span>
              floatConstraints.left = { };
  
<span class="line-modified">!         if (floatConstraints.right &amp;&amp; *floatConstraints.right &gt;= formattingRootDisplayBox.contentBoxRight())</span>
              floatConstraints.right = { };
  
          if (floatConstraints.left &amp;&amp; floatConstraints.right) {
<span class="line-modified">!             ASSERT(*floatConstraints.left &lt; *floatConstraints.right);</span>
<span class="line-modified">!             availableWidth = *floatConstraints.right - *floatConstraints.left;</span>
<span class="line-modified">!             lineLogicalLeft = *floatConstraints.left;</span>
          } else if (floatConstraints.left) {
<span class="line-modified">!             ASSERT(*floatConstraints.left &gt; lineLogicalLeft);</span>
<span class="line-modified">!             availableWidth -= (*floatConstraints.left - lineLogicalLeft);</span>
<span class="line-modified">!             lineLogicalLeft = *floatConstraints.left;</span>
          } else if (floatConstraints.right) {
<span class="line-modified">!             ASSERT(*floatConstraints.right &gt; lineLogicalLeft);</span>
<span class="line-modified">!             availableWidth = *floatConstraints.right - lineLogicalLeft;</span>
          }
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-removed">-     line.init({ lineLogicalLeft, lineLogicalTop }, availableWidth, m_formattingRoot.style().computedLineHeight());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InlineFormattingContext::LineLayout::splitInlineRunIfNeeded(const InlineRun&amp; inlineRun, InlineRuns&amp; splitRuns) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(inlineRun.textContext());</span>
<span class="line-removed">-     ASSERT(inlineRun.overlapsMultipleInlineItems());</span>
<span class="line-removed">-     // In certain cases, a run can overlap multiple inline elements like this:</span>
<span class="line-removed">-     // &lt;span&gt;normal text content&lt;/span&gt;&lt;span style=&quot;position: relative; left: 10px;&quot;&gt;but this one needs a dedicated run&lt;/span&gt;&lt;span&gt;end of text&lt;/span&gt;</span>
<span class="line-removed">-     // The content above generates one long run &lt;normal text contentbut this one needs dedicated runend of text&gt;</span>
<span class="line-removed">-     // However, since the middle run is positioned, it needs to be moved independently from the rest of the content, hence it needs a dedicated inline run.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 1. Start with the first inline item (element) and travers the list until</span>
<span class="line-removed">-     // 2. either find an inline item that needs a dedicated run or we reach the end of the run</span>
<span class="line-removed">-     // 3. Create dedicate inline runs.</span>
<span class="line-removed">-     auto&amp; inlineContent = m_formattingState.inlineContent();</span>
<span class="line-removed">-     auto contentStart = inlineRun.logicalLeft();</span>
<span class="line-removed">-     auto startPosition = inlineRun.textContext()-&gt;start();</span>
<span class="line-removed">-     auto remaningLength = inlineRun.textContext()-&gt;length();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     struct Uncommitted {</span>
<span class="line-removed">-         const InlineItem* firstInlineItem { nullptr };</span>
<span class="line-removed">-         const InlineItem* lastInlineItem { nullptr };</span>
<span class="line-removed">-         unsigned length { 0 };</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     Optional&lt;Uncommitted&gt; uncommitted;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto commit = [&amp;] {</span>
<span class="line-removed">-         if (!uncommitted)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         contentStart += uncommitted-&gt;firstInlineItem-&gt;nonBreakableStart();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto runWidth = this-&gt;runWidth(inlineContent, *uncommitted-&gt;firstInlineItem, startPosition, uncommitted-&gt;length, contentStart);</span>
<span class="line-removed">-         auto run = InlineRun { { inlineRun.logicalTop(), contentStart, runWidth, inlineRun.logicalHeight() }, *uncommitted-&gt;firstInlineItem };</span>
<span class="line-removed">-         run.setTextContext({ startPosition, uncommitted-&gt;length });</span>
<span class="line-removed">-         splitRuns.append(run);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         contentStart += runWidth + uncommitted-&gt;lastInlineItem-&gt;nonBreakableEnd();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         startPosition = 0;</span>
<span class="line-removed">-         uncommitted = { };</span>
      };
  
<span class="line-modified">!     for (auto iterator = inlineContent.find(const_cast&lt;InlineItem*&gt;(&amp;inlineRun.inlineItem())); iterator != inlineContent.end() &amp;&amp; remaningLength &gt; 0; ++iterator) {</span>
<span class="line-modified">!         auto&amp; inlineItem = **iterator;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Skip all non-inflow boxes (floats, out-of-flow positioned elements). They don&#39;t participate in the inline run context.</span>
<span class="line-modified">!         if (!inlineItem.layoutBox().isInFlow())</span>
<span class="line-modified">!             continue;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto currentLength = [&amp;] {</span>
<span class="line-modified">!             return std::min(remaningLength, inlineItem.textContent().length() - startPosition);</span>
<span class="line-modified">!         };</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // 1. Break before/after -&gt; requires dedicated run -&gt; commit what we&#39;ve got so far and also commit the current inline element as a separate inline run.</span>
<span class="line-modified">!         // 2. Break at the beginning of the inline element -&gt; commit what we&#39;ve got so far. Current element becomes the first uncommitted.</span>
<span class="line-modified">!         // 3. Break at the end of the inline element -&gt; commit what we&#39;ve got so far including the current element.</span>
<span class="line-removed">-         // 4. Inline element does not require run breaking -&gt; add current inline element to uncommitted. Jump to the next element.</span>
<span class="line-removed">-         auto detachingRules = inlineItem.detachingRules();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // #1</span>
<span class="line-removed">-         if (detachingRules.containsAll({ InlineItem::DetachingRule::BreakAtStart, InlineItem::DetachingRule::BreakAtEnd })) {</span>
<span class="line-removed">-             commit();</span>
<span class="line-removed">-             auto contentLength = currentLength();</span>
<span class="line-removed">-             uncommitted = Uncommitted { &amp;inlineItem, &amp;inlineItem, contentLength };</span>
<span class="line-removed">-             remaningLength -= contentLength;</span>
<span class="line-removed">-             commit();</span>
<span class="line-removed">-             continue;</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         // #2</span>
<span class="line-removed">-         if (detachingRules.contains(InlineItem::DetachingRule::BreakAtStart))</span>
<span class="line-removed">-             commit();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Add current inline item to uncommitted.</span>
<span class="line-removed">-         // #3 and #4</span>
<span class="line-removed">-         auto contentLength = currentLength();</span>
<span class="line-removed">-         if (!uncommitted)</span>
<span class="line-removed">-             uncommitted = Uncommitted { &amp;inlineItem, &amp;inlineItem, 0 };</span>
<span class="line-removed">-         uncommitted-&gt;length += contentLength;</span>
<span class="line-removed">-         uncommitted-&gt;lastInlineItem = &amp;inlineItem;</span>
<span class="line-removed">-         remaningLength -= contentLength;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // #3</span>
<span class="line-removed">-         if (detachingRules.contains(InlineItem::DetachingRule::BreakAtEnd))</span>
<span class="line-removed">-             commit();</span>
      }
<span class="line-removed">-     // Either all inline elements needed dedicated runs or neither of them.</span>
<span class="line-removed">-     if (!remaningLength || remaningLength == inlineRun.textContext()-&gt;length())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     commit();</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::createFinalRuns(Line&amp; line) const</span>
  {
<span class="line-modified">!     for (auto&amp; inlineRun : line.runs()) {</span>
<span class="line-modified">!         if (inlineRun.overlapsMultipleInlineItems()) {</span>
<span class="line-modified">!             InlineRuns splitRuns;</span>
<span class="line-modified">!             splitInlineRunIfNeeded(inlineRun, splitRuns);</span>
<span class="line-modified">!             for (auto&amp; splitRun : splitRuns)</span>
<span class="line-modified">!                 m_formattingState.appendInlineRun(splitRun);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (!splitRuns.isEmpty())</span>
<span class="line-modified">!                 continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto finalRun = [&amp;] {</span>
<span class="line-removed">-             auto&amp; inlineItem = inlineRun.inlineItem();</span>
<span class="line-removed">-             if (inlineItem.detachingRules().isEmpty())</span>
<span class="line-removed">-                 return inlineRun;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             InlineRun adjustedRun = inlineRun;</span>
<span class="line-removed">-             auto width = inlineRun.logicalWidth() - inlineItem.nonBreakableStart() - inlineItem.nonBreakableEnd();</span>
<span class="line-removed">-             adjustedRun.setLogicalLeft(inlineRun.logicalLeft() + inlineItem.nonBreakableStart());</span>
<span class="line-removed">-             adjustedRun.setLogicalWidth(width);</span>
<span class="line-removed">-             return adjustedRun;</span>
<span class="line-removed">-         };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         m_formattingState.appendInlineRun(finalRun());</span>
      }
  }
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::postProcessInlineRuns(Line&amp; line, IsLastLine isLastLine) const</span>
  {
<span class="line-modified">!     alignRuns(m_formattingRoot.style().textAlign(), line, isLastLine);</span>
<span class="line-modified">!     auto firstRunIndex = m_formattingState.inlineRuns().size();</span>
<span class="line-modified">!     createFinalRuns(line);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     placeInFlowPositionedChildren(firstRunIndex);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::closeLine(Line&amp; line, IsLastLine isLastLine) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     line.close();</span>
<span class="line-modified">!     if (!line.hasContent())</span>
          return;
  
<span class="line-modified">!     postProcessInlineRuns(line, isLastLine);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void InlineFormattingContext::LineLayout::appendContentToLine(Line&amp; line, const InlineRunProvider::Run&amp; run, const LayoutSize&amp; runSize) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto lastRunType = line.lastRunType();</span>
<span class="line-modified">!     line.appendContent(run, runSize);</span>
  
<span class="line-modified">!     if (m_formattingRoot.style().textAlign() == TextAlignMode::Justify)</span>
<span class="line-modified">!         computeExpansionOpportunities(line, run, lastRunType.valueOr(InlineRunProvider::Run::Type::NonWhitespace));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::computeFloatPosition(const FloatingContext&amp; floatingContext, Line&amp; line, const Box&amp; floatBox) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">!     ASSERT(layoutState.hasDisplayBox(floatBox));</span>
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(floatBox);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     // Set static position first.</span>
<span class="line-removed">-     displayBox.setTopLeft({ line.contentLogicalRight(), line.logicalTop() });</span>
<span class="line-removed">-     // Float it.</span>
<span class="line-removed">-     displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::placeInFlowPositionedChildren(unsigned fistRunIndex) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">!     auto&amp; inlineRuns = m_formattingState.inlineRuns();</span>
<span class="line-modified">!     for (auto runIndex = fistRunIndex; runIndex &lt; inlineRuns.size(); ++runIndex) {</span>
<span class="line-modified">!         auto&amp; inlineRun = inlineRuns[runIndex];</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto positionOffset = [&amp;](auto&amp; layoutBox) {</span>
<span class="line-removed">-             // FIXME: Need to figure out whether in-flow offset should stick. This might very well be temporary.</span>
<span class="line-removed">-             Optional&lt;LayoutSize&gt; offset;</span>
<span class="line-removed">-             for (auto* box = &amp;layoutBox; box != &amp;m_formattingRoot; box = box-&gt;parent()) {</span>
<span class="line-removed">-                 if (!box-&gt;isInFlowPositioned())</span>
<span class="line-removed">-                     continue;</span>
<span class="line-removed">-                 offset = offset.valueOr(LayoutSize()) + Geometry::inFlowPositionedPositionOffset(layoutState, *box);</span>
              }
<span class="line-modified">!             return offset;</span>
<span class="line-modified">!         };</span>
  
<span class="line-modified">!         if (auto offset = positionOffset(inlineRun.inlineItem().layoutBox())) {</span>
<span class="line-modified">!             inlineRun.moveVertically(offset-&gt;height());</span>
<span class="line-modified">!             inlineRun.moveHorizontally(offset-&gt;width());</span>
          }
      }
  }
  
<span class="line-modified">! static LayoutUnit adjustedLineLogicalLeft(TextAlignMode align, LayoutUnit lineLogicalLeft, LayoutUnit remainingWidth)</span>
  {
      switch (align) {
      case TextAlignMode::Left:
      case TextAlignMode::WebKitLeft:
      case TextAlignMode::Start:
<span class="line-modified">!         return lineLogicalLeft;</span>
      case TextAlignMode::Right:
      case TextAlignMode::WebKitRight:
      case TextAlignMode::End:
<span class="line-modified">!         return lineLogicalLeft + std::max(remainingWidth, 0_lu);</span>
      case TextAlignMode::Center:
      case TextAlignMode::WebKitCenter:
<span class="line-modified">!         return lineLogicalLeft + std::max(remainingWidth / 2, 0_lu);</span>
      case TextAlignMode::Justify:
          ASSERT_NOT_REACHED();
          break;
      }
      ASSERT_NOT_REACHED();
<span class="line-modified">!     return lineLogicalLeft;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InlineFormattingContext::LineLayout::justifyRuns(Line&amp; line)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; inlineRuns = line.runs();</span>
<span class="line-removed">-     auto&amp; lastInlineRun = inlineRuns.last();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Adjust (forbid) trailing expansion for the last text run on line.</span>
<span class="line-removed">-     auto expansionBehavior = lastInlineRun.expansionOpportunity().behavior;</span>
<span class="line-removed">-     // Remove allow and add forbid.</span>
<span class="line-removed">-     expansionBehavior ^= AllowTrailingExpansion;</span>
<span class="line-removed">-     expansionBehavior |= ForbidTrailingExpansion;</span>
<span class="line-removed">-     lastInlineRun.expansionOpportunity().behavior = expansionBehavior;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Collect expansion opportunities and justify the runs.</span>
<span class="line-removed">-     auto widthToDistribute = line.availableWidth();</span>
<span class="line-removed">-     if (widthToDistribute &lt;= 0)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto expansionOpportunities = 0;</span>
<span class="line-removed">-     for (auto&amp; inlineRun : inlineRuns)</span>
<span class="line-removed">-         expansionOpportunities += inlineRun.expansionOpportunity().count;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!expansionOpportunities)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     float expansion = widthToDistribute.toFloat() / expansionOpportunities;</span>
<span class="line-removed">-     LayoutUnit accumulatedExpansion;</span>
<span class="line-removed">-     for (auto&amp; inlineRun : inlineRuns) {</span>
<span class="line-removed">-         auto expansionForRun = inlineRun.expansionOpportunity().count * expansion;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         inlineRun.expansionOpportunity().expansion = expansionForRun;</span>
<span class="line-removed">-         inlineRun.setLogicalLeft(inlineRun.logicalLeft() + accumulatedExpansion);</span>
<span class="line-removed">-         inlineRun.setLogicalWidth(inlineRun.logicalWidth() + expansionForRun);</span>
<span class="line-removed">-         accumulatedExpansion += expansionForRun;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InlineFormattingContext::LineLayout::computeExpansionOpportunities(Line&amp; line, const InlineRunProvider::Run&amp; run, InlineRunProvider::Run::Type lastRunType) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto isExpansionOpportunity = [](auto currentRunIsWhitespace, auto lastRunIsWhitespace) {</span>
<span class="line-removed">-         return currentRunIsWhitespace || (!currentRunIsWhitespace &amp;&amp; !lastRunIsWhitespace);</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto expansionBehavior = [](auto isAtExpansionOpportunity) {</span>
<span class="line-removed">-         ExpansionBehavior expansionBehavior = AllowTrailingExpansion;</span>
<span class="line-removed">-         expansionBehavior |= isAtExpansionOpportunity ? ForbidLeadingExpansion : AllowLeadingExpansion;</span>
<span class="line-removed">-         return expansionBehavior;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto isAtExpansionOpportunity = isExpansionOpportunity(run.isWhitespace(), lastRunType == InlineRunProvider::Run::Type::Whitespace);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto&amp; currentInlineRun = line.runs().last();</span>
<span class="line-removed">-     auto&amp; expansionOpportunity = currentInlineRun.expansionOpportunity();</span>
<span class="line-removed">-     if (isAtExpansionOpportunity)</span>
<span class="line-removed">-         ++expansionOpportunity.count;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     expansionOpportunity.behavior = expansionBehavior(isAtExpansionOpportunity);</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::LineLayout::alignRuns(TextAlignMode textAlign, Line&amp; line,  IsLastLine isLastLine) const</span>
  {
<span class="line-modified">!     auto adjutedTextAlignment = textAlign != TextAlignMode::Justify ? textAlign : isLastLine == IsLastLine::No ? TextAlignMode::Justify : TextAlignMode::Left;</span>
<span class="line-modified">!     if (adjutedTextAlignment == TextAlignMode::Justify) {</span>
<span class="line-removed">-         justifyRuns(line);</span>
          return;
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto lineLogicalLeft = line.contentLogicalLeft();</span>
<span class="line-removed">-     auto adjustedLogicalLeft = adjustedLineLogicalLeft(adjutedTextAlignment, lineLogicalLeft, line.availableWidth());</span>
<span class="line-removed">-     if (adjustedLogicalLeft == lineLogicalLeft)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto delta = adjustedLogicalLeft - lineLogicalLeft;</span>
<span class="line-removed">-     for (auto&amp; inlineRun : line.runs())</span>
<span class="line-removed">-         inlineRun.setLogicalLeft(inlineRun.logicalLeft() + delta);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! LayoutUnit InlineFormattingContext::LineLayout::runWidth(const InlineContent&amp; inlineContent, const InlineItem&amp; inlineItem, ItemPosition from, unsigned length, LayoutUnit contentLogicalLeft) const</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     LayoutUnit width;</span>
<span class="line-removed">-     auto startPosition = from;</span>
<span class="line-removed">-     auto iterator = inlineContent.find(const_cast&lt;InlineItem*&gt;(&amp;inlineItem));</span>
<span class="line-removed">- #if !ASSERT_DISABLED</span>
<span class="line-removed">-     auto inlineItemEnd = inlineContent.end();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     while (length) {</span>
<span class="line-removed">-         ASSERT(iterator != inlineItemEnd);</span>
<span class="line-removed">-         auto&amp; currentInlineItem = **iterator;</span>
<span class="line-removed">-         auto endPosition = std::min&lt;ItemPosition&gt;(startPosition + length, currentInlineItem.textContent().length());</span>
<span class="line-removed">-         auto textWidth = TextUtil::width(currentInlineItem, startPosition, endPosition, contentLogicalLeft);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         contentLogicalLeft += textWidth;</span>
<span class="line-removed">-         width += textWidth;</span>
<span class="line-removed">-         length -= (endPosition - startPosition);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         startPosition = 0;</span>
<span class="line-removed">-         ++iterator;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return width;</span>
  }
  
  }
  }
  
<span class="line-new-header">--- 29,476 ---</span>
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;FloatingContext.h&quot;
  #include &quot;FloatingState.h&quot;
  #include &quot;InlineFormattingState.h&quot;
<span class="line-added">+ #include &quot;InlineLine.h&quot;</span>
  #include &quot;InlineLineBreaker.h&quot;
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutState.h&quot;
  #include &quot;TextUtil.h&quot;
  
  namespace WebCore {
  namespace Layout {
  
<span class="line-modified">! static LayoutUnit inlineItemWidth(const LayoutState&amp; layoutState, const InlineItem&amp; inlineItem, LayoutUnit contentLogicalLeft)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (inlineItem.isLineBreak())</span>
<span class="line-modified">!         return 0;</span>
  
<span class="line-modified">!     if (is&lt;InlineTextItem&gt;(inlineItem)) {</span>
<span class="line-added">+         auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="line-added">+         auto end = inlineTextItem.isCollapsed() ? inlineTextItem.start() + 1 : inlineTextItem.end();</span>
<span class="line-added">+         return TextUtil::width(inlineTextItem.layoutBox(), inlineTextItem.start(), end, contentLogicalLeft);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     auto&amp; layoutBox = inlineItem.layoutBox();</span>
<span class="line-modified">!     ASSERT(layoutState.hasDisplayBox(layoutBox));</span>
<span class="line-added">+     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
  
<span class="line-modified">!     if (layoutBox.isFloatingPositioned())</span>
<span class="line-modified">!         return displayBox.marginBoxWidth();</span>
  
<span class="line-modified">!     if (layoutBox.replaced())</span>
<span class="line-modified">!         return displayBox.width();</span>
  
<span class="line-modified">!     if (inlineItem.isContainerStart())</span>
<span class="line-modified">!         return displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0);</span>
  
<span class="line-modified">!     if (inlineItem.isContainerEnd())</span>
<span class="line-modified">!         return displayBox.marginEnd() + displayBox.borderRight() + displayBox.paddingRight().valueOr(0);</span>
  
<span class="line-modified">!     // Non-replaced inline box (e.g. inline-block)</span>
<span class="line-modified">!     return displayBox.width();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! struct IndexAndRange {</span>
<span class="line-modified">!     unsigned index { 0 };</span>
<span class="line-modified">!     struct Range {</span>
<span class="line-added">+         unsigned start { 0 };</span>
<span class="line-added">+         unsigned length { 0 };</span>
<span class="line-added">+     };</span>
<span class="line-added">+     Optional&lt;Range&gt; partialContext;</span>
  };
  
<span class="line-modified">! struct LineInput {</span>
<span class="line-modified">!     LineInput(const Line::InitialConstraints&amp; initialLineConstraints, Line::SkipVerticalAligment, IndexAndRange firstToProcess, const InlineItems&amp;);</span>
  
<span class="line-modified">!     Line::InitialConstraints initialConstraints;</span>
<span class="line-modified">!     // FIXME Alternatively we could just have a second pass with vertical positioning (preferred width computation opts out)</span>
<span class="line-modified">!     Line::SkipVerticalAligment skipVerticalAligment;</span>
<span class="line-added">+     IndexAndRange firstInlineItem;</span>
<span class="line-added">+     const InlineItems&amp; inlineItems;</span>
<span class="line-added">+     Optional&lt;LayoutUnit&gt; floatMinimumLogicalBottom;</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! struct LineContent {</span>
<span class="line-modified">!     Optional&lt;IndexAndRange&gt; lastCommitted;</span>
<span class="line-added">+     Vector&lt;WeakPtr&lt;InlineItem&gt;&gt; floats;</span>
<span class="line-added">+     std::unique_ptr&lt;Line::Content&gt; runs;</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! class LineLayout {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     LineLayout(const LayoutState&amp;, const LineInput&amp;);</span>
  
<span class="line-modified">!     LineContent layout();</span>
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     const LayoutState&amp; layoutState() const { return m_layoutState; }</span>
<span class="line-modified">!     enum class IsEndOfLine { No, Yes };</span>
<span class="line-added">+     IsEndOfLine placeInlineItem(const InlineItem&amp;);</span>
<span class="line-added">+     void commitPendingContent();</span>
<span class="line-added">+     LineContent close();</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct UncommittedContent {</span>
<span class="line-added">+         struct Run {</span>
<span class="line-added">+             const InlineItem&amp; inlineItem;</span>
<span class="line-added">+             LayoutUnit logicalWidth;</span>
<span class="line-added">+         };</span>
<span class="line-added">+         void add(const InlineItem&amp;, LayoutUnit logicalWidth);</span>
<span class="line-added">+         void reset();</span>
  
<span class="line-modified">!         Vector&lt;Run&gt; runs() { return m_uncommittedRuns; }</span>
<span class="line-modified">!         bool isEmpty() const { return m_uncommittedRuns.isEmpty(); }</span>
<span class="line-modified">!         unsigned size() const { return m_uncommittedRuns.size(); }</span>
<span class="line-modified">!         LayoutUnit width() const { return m_width; }</span>
  
<span class="line-modified">!     private:</span>
<span class="line-modified">!         Vector&lt;Run&gt; m_uncommittedRuns;</span>
<span class="line-modified">!         LayoutUnit m_width;</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     const LayoutState&amp; m_layoutState;</span>
<span class="line-modified">!     const LineInput&amp; m_lineInput;</span>
<span class="line-added">+     Line m_line;</span>
<span class="line-added">+     LineBreaker m_lineBreaker;</span>
<span class="line-added">+     bool m_lineHasFloatBox { false };</span>
<span class="line-added">+     UncommittedContent m_uncommittedContent;</span>
<span class="line-added">+     unsigned m_committedInlineItemCount { 0 };</span>
<span class="line-added">+     Vector&lt;WeakPtr&lt;InlineItem&gt;&gt; m_floats;</span>
<span class="line-added">+     std::unique_ptr&lt;InlineTextItem&gt; m_leadingPartialInlineTextItem;</span>
<span class="line-added">+     std::unique_ptr&lt;InlineTextItem&gt; m_trailingPartialInlineTextItem;</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! void LineLayout::UncommittedContent::add(const InlineItem&amp; inlineItem, LayoutUnit logicalWidth)</span>
  {
<span class="line-modified">!     m_uncommittedRuns.append({ inlineItem, logicalWidth });</span>
<span class="line-modified">!     m_width += logicalWidth;</span>
  }
  
<span class="line-modified">! void LineLayout::UncommittedContent::reset()</span>
  {
<span class="line-modified">!     m_uncommittedRuns.clear();</span>
<span class="line-modified">!     m_width = 0;</span>
  }
  
<span class="line-modified">! LineLayout::LineLayout(const LayoutState&amp; layoutState, const LineInput&amp; lineInput)</span>
<span class="line-modified">!     : m_layoutState(layoutState)</span>
<span class="line-modified">!     , m_lineInput(lineInput)</span>
<span class="line-modified">!     , m_line(layoutState, lineInput.initialConstraints, lineInput.skipVerticalAligment)</span>
<span class="line-modified">!     , m_lineHasFloatBox(lineInput.floatMinimumLogicalBottom.hasValue())</span>
  {
  }
  
<span class="line-modified">! void LineLayout::commitPendingContent()</span>
  {
<span class="line-modified">!     if (m_uncommittedContent.isEmpty())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     m_committedInlineItemCount += m_uncommittedContent.size();</span>
<span class="line-added">+     for (auto&amp; uncommittedRun : m_uncommittedContent.runs())</span>
<span class="line-added">+         m_line.append(uncommittedRun.inlineItem, uncommittedRun.logicalWidth);</span>
<span class="line-added">+     m_uncommittedContent.reset();</span>
  }
  
<span class="line-modified">! LineContent LineLayout::close()</span>
  {
<span class="line-modified">!     ASSERT(m_committedInlineItemCount || m_lineHasFloatBox);</span>
<span class="line-modified">!     if (!m_committedInlineItemCount)</span>
<span class="line-added">+         return LineContent { WTF::nullopt, WTFMove(m_floats), m_line.close() };</span>
  
<span class="line-modified">!     auto lastInlineItemIndex = m_lineInput.firstInlineItem.index + m_committedInlineItemCount - 1;</span>
<span class="line-modified">!     Optional&lt;IndexAndRange::Range&gt; partialContext;</span>
<span class="line-added">+     if (m_trailingPartialInlineTextItem)</span>
<span class="line-added">+         partialContext = IndexAndRange::Range { m_trailingPartialInlineTextItem-&gt;start(), m_trailingPartialInlineTextItem-&gt;length() };</span>
  
<span class="line-modified">!     auto lastCommitedItem = IndexAndRange { lastInlineItemIndex, partialContext };</span>
<span class="line-modified">!     return LineContent { lastCommitedItem, WTFMove(m_floats), m_line.close() };</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! LineLayout::IsEndOfLine LineLayout::placeInlineItem(const InlineItem&amp; inlineItem)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto availableWidth = m_line.availableWidth() - m_uncommittedContent.width();</span>
<span class="line-modified">!     auto currentLogicalRight = m_line.contentLogicalRight() + m_uncommittedContent.width();</span>
<span class="line-modified">!     auto itemLogicalWidth = inlineItemWidth(layoutState(), inlineItem, currentLogicalRight);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: Ensure LineContext::trimmableWidth includes uncommitted content if needed.</span>
<span class="line-added">+     auto lineIsConsideredEmpty = !m_line.hasContent() &amp;&amp; !m_lineHasFloatBox;</span>
<span class="line-added">+     auto breakingContext = m_lineBreaker.breakingContext(inlineItem, itemLogicalWidth, { availableWidth, currentLogicalRight, m_line.trailingTrimmableWidth(), lineIsConsideredEmpty });</span>
<span class="line-added">+     if (breakingContext.isAtBreakingOpportunity)</span>
<span class="line-added">+         commitPendingContent();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Content does not fit the current line.</span>
<span class="line-added">+     if (breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Wrap)</span>
<span class="line-added">+         return IsEndOfLine::Yes;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Partial content stays on the current line.</span>
<span class="line-added">+     if (breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Split) {</span>
<span class="line-added">+         ASSERT(inlineItem.isText());</span>
<span class="line-added">+         auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="line-added">+         auto splitData = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), inlineTextItem.length(), itemLogicalWidth, availableWidth, currentLogicalRight);</span>
<span class="line-added">+         // Construct a partial trailing inline item.</span>
<span class="line-added">+         ASSERT(!m_trailingPartialInlineTextItem);</span>
<span class="line-added">+         m_trailingPartialInlineTextItem = inlineTextItem.split(splitData.start, splitData.length);</span>
<span class="line-added">+         m_uncommittedContent.add(*m_trailingPartialInlineTextItem, splitData.logicalWidth);</span>
<span class="line-added">+         commitPendingContent();</span>
<span class="line-added">+         return IsEndOfLine::Yes;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     ASSERT(breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Keep);</span>
<span class="line-modified">!     if (inlineItem.isFloat()) {</span>
<span class="line-modified">!         auto&amp; floatBox = inlineItem.layoutBox();</span>
<span class="line-added">+         ASSERT(layoutState().hasDisplayBox(floatBox));</span>
<span class="line-added">+         // Shrink available space for current line and move existing inline runs.</span>
<span class="line-added">+         auto floatBoxWidth = layoutState().displayBoxForLayoutBox(floatBox).marginBoxWidth();</span>
<span class="line-added">+         floatBox.isLeftFloatingPositioned() ? m_line.moveLogicalLeft(floatBoxWidth) : m_line.moveLogicalRight(floatBoxWidth);</span>
<span class="line-added">+         m_floats.append(makeWeakPtr(inlineItem));</span>
<span class="line-added">+         ++m_committedInlineItemCount;</span>
<span class="line-added">+         m_lineHasFloatBox = true;</span>
<span class="line-added">+         return IsEndOfLine::No;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     m_uncommittedContent.add(inlineItem, itemLogicalWidth);</span>
<span class="line-modified">!     if (breakingContext.isAtBreakingOpportunity)</span>
<span class="line-added">+         commitPendingContent();</span>
  
<span class="line-modified">!     return inlineItem.isHardLineBreak() ? IsEndOfLine::Yes : IsEndOfLine::No;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! LineContent LineLayout::layout()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     // Iterate through the inline content and place the inline boxes on the current line.</span>
<span class="line-modified">!     // Start with the partial text from the previous line.</span>
<span class="line-modified">!     auto firstInlineItem = m_lineInput.firstInlineItem;</span>
<span class="line-added">+     unsigned firstNonPartialIndex = firstInlineItem.index;</span>
<span class="line-added">+     if (firstInlineItem.partialContext) {</span>
<span class="line-added">+         // Handle partial inline item (split text from the previous line).</span>
<span class="line-added">+         auto&amp; originalTextItem = m_lineInput.inlineItems[firstInlineItem.index];</span>
<span class="line-added">+         RELEASE_ASSERT(originalTextItem-&gt;isText());</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto textRange = *firstInlineItem.partialContext;</span>
<span class="line-added">+         // Construct a partial leading inline item.</span>
<span class="line-added">+         ASSERT(!m_leadingPartialInlineTextItem);</span>
<span class="line-added">+         m_leadingPartialInlineTextItem = downcast&lt;InlineTextItem&gt;(*originalTextItem).split(textRange.start, textRange.length);</span>
<span class="line-added">+         if (placeInlineItem(*m_leadingPartialInlineTextItem) == IsEndOfLine::Yes)</span>
<span class="line-added">+             return close();</span>
<span class="line-added">+         ++firstNonPartialIndex;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     for (auto inlineItemIndex = firstNonPartialIndex; inlineItemIndex &lt; m_lineInput.inlineItems.size(); ++inlineItemIndex) {</span>
<span class="line-modified">!         if (placeInlineItem(*m_lineInput.inlineItems[inlineItemIndex]) == IsEndOfLine::Yes)</span>
<span class="line-added">+             return close();</span>
      }
<span class="line-added">+     commitPendingContent();</span>
<span class="line-added">+     return close();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ LineInput::LineInput(const Line::InitialConstraints&amp; initialLineConstraints, Line::SkipVerticalAligment skipVerticalAligment, IndexAndRange firstToProcess, const InlineItems&amp; inlineItems)</span>
<span class="line-added">+     : initialConstraints(initialLineConstraints)</span>
<span class="line-added">+     , skipVerticalAligment(skipVerticalAligment)</span>
<span class="line-added">+     , firstInlineItem(firstToProcess)</span>
<span class="line-added">+     , inlineItems(inlineItems)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! InlineFormattingContext::InlineLayout::InlineLayout(const InlineFormattingContext&amp; inlineFormattingContext)</span>
<span class="line-added">+     : m_layoutState(inlineFormattingContext.layoutState())</span>
<span class="line-added">+     , m_formattingRoot(downcast&lt;Container&gt;(inlineFormattingContext.root()))</span>
<span class="line-added">+ {</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::InlineLayout::layout(const InlineItems&amp; inlineItems, LayoutUnit widthConstraint) const</span>
  {
<span class="line-modified">!     auto&amp; formattingRootDisplayBox = layoutState().displayBoxForLayoutBox(m_formattingRoot);</span>
<span class="line-added">+     auto&amp; floatingState = layoutState().establishedFormattingState(m_formattingRoot).floatingState();</span>
  
<span class="line-added">+     auto lineLogicalTop = formattingRootDisplayBox.contentBoxTop();</span>
      auto lineLogicalLeft = formattingRootDisplayBox.contentBoxLeft();
  
<span class="line-modified">!     auto applyFloatConstraint = [&amp;](auto&amp; lineInput) {</span>
<span class="line-modified">!         // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-modified">!         if (floatingState.isEmpty())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         auto availableWidth = lineInput.initialConstraints.availableLogicalWidth;</span>
<span class="line-added">+         auto lineLogicalLeft = lineInput.initialConstraints.logicalTopLeft.x();</span>
<span class="line-added">+         auto floatConstraints = floatingState.constraints({ lineLogicalTop }, m_formattingRoot);</span>
          // Check if these constraints actually put limitation on the line.
<span class="line-modified">!         if (floatConstraints.left &amp;&amp; floatConstraints.left-&gt;x &lt;= formattingRootDisplayBox.contentBoxLeft())</span>
              floatConstraints.left = { };
  
<span class="line-modified">!         if (floatConstraints.right &amp;&amp; floatConstraints.right-&gt;x &gt;= formattingRootDisplayBox.contentBoxRight())</span>
              floatConstraints.right = { };
  
<span class="line-added">+         // Set the minimum float bottom value as a hint for the next line if needed.</span>
<span class="line-added">+         static auto inifitePoint = PointInContextRoot::max();</span>
<span class="line-added">+         auto floatMinimumLogicalBottom = std::min(floatConstraints.left.valueOr(inifitePoint).y, floatConstraints.right.valueOr(inifitePoint).y);</span>
<span class="line-added">+         if (floatMinimumLogicalBottom != inifitePoint.y)</span>
<span class="line-added">+             lineInput.floatMinimumLogicalBottom = floatMinimumLogicalBottom;</span>
<span class="line-added">+ </span>
          if (floatConstraints.left &amp;&amp; floatConstraints.right) {
<span class="line-modified">!             ASSERT(floatConstraints.left-&gt;x &lt;= floatConstraints.right-&gt;x);</span>
<span class="line-modified">!             availableWidth = floatConstraints.right-&gt;x - floatConstraints.left-&gt;x;</span>
<span class="line-modified">!             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
          } else if (floatConstraints.left) {
<span class="line-modified">!             ASSERT(floatConstraints.left-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-modified">!             availableWidth -= (floatConstraints.left-&gt;x - lineLogicalLeft);</span>
<span class="line-modified">!             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
          } else if (floatConstraints.right) {
<span class="line-modified">!             ASSERT(floatConstraints.right-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-modified">!             availableWidth = floatConstraints.right-&gt;x - lineLogicalLeft;</span>
          }
<span class="line-modified">!         lineInput.initialConstraints.availableLogicalWidth = availableWidth;</span>
<span class="line-modified">!         lineInput.initialConstraints.logicalTopLeft.setX(lineLogicalLeft);</span>
      };
  
<span class="line-modified">!     IndexAndRange currentInlineItem;</span>
<span class="line-modified">!     while (currentInlineItem.index &lt; inlineItems.size()) {</span>
<span class="line-modified">!         auto lineInput = LineInput { { { lineLogicalLeft, lineLogicalTop }, widthConstraint, Quirks::lineHeightConstraints(layoutState(), m_formattingRoot) }, Line::SkipVerticalAligment::No, currentInlineItem, inlineItems };</span>
<span class="line-modified">!         applyFloatConstraint(lineInput);</span>
<span class="line-modified">!         auto lineContent = LineLayout(layoutState(), lineInput).layout();</span>
<span class="line-modified">!         createDisplayRuns(*lineContent.runs, lineContent.floats, widthConstraint);</span>
<span class="line-modified">!         if (!lineContent.lastCommitted) {</span>
<span class="line-modified">!             // Floats prevented us putting any content on the line.</span>
<span class="line-modified">!             ASSERT(lineInput.floatMinimumLogicalBottom);</span>
<span class="line-modified">!             ASSERT(lineContent.runs-&gt;isEmpty());</span>
<span class="line-modified">!             lineLogicalTop = *lineInput.floatMinimumLogicalBottom;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             currentInlineItem = { lineContent.lastCommitted-&gt;index + 1, WTF::nullopt };</span>
<span class="line-modified">!             lineLogicalTop = lineContent.runs-&gt;logicalBottom();</span>
          }
      }
  }
  
<span class="line-modified">! LayoutUnit InlineFormattingContext::InlineLayout::computedIntrinsicWidth(const InlineItems&amp; inlineItems, LayoutUnit widthConstraint) const</span>
  {
<span class="line-modified">!     LayoutUnit maximumLineWidth;</span>
<span class="line-modified">!     IndexAndRange currentInlineItem;</span>
<span class="line-modified">!     while (currentInlineItem.index &lt; inlineItems.size()) {</span>
<span class="line-modified">!         auto lineContent = LineLayout(layoutState(), { { { }, widthConstraint, Quirks::lineHeightConstraints(layoutState(), m_formattingRoot) }, Line::SkipVerticalAligment::Yes, currentInlineItem, inlineItems }).layout();</span>
<span class="line-modified">!         currentInlineItem = { lineContent.lastCommitted-&gt;index + 1, WTF::nullopt };</span>
<span class="line-modified">!         LayoutUnit floatsWidth;</span>
<span class="line-modified">!         for (auto&amp; floatItem : lineContent.floats)</span>
<span class="line-modified">!             floatsWidth += layoutState().displayBoxForLayoutBox(floatItem-&gt;layoutBox()).marginBoxWidth();</span>
<span class="line-modified">!         maximumLineWidth = std::max(maximumLineWidth, floatsWidth + lineContent.runs-&gt;logicalWidth());</span>
      }
<span class="line-added">+     return maximumLineWidth;</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::InlineLayout::createDisplayRuns(const Line::Content&amp; lineContent, const Vector&lt;WeakPtr&lt;InlineItem&gt;&gt;&amp; floats, LayoutUnit widthConstraint) const</span>
  {
<span class="line-modified">!     auto&amp; formattingState = downcast&lt;InlineFormattingState&gt;(layoutState().establishedFormattingState(m_formattingRoot));</span>
<span class="line-modified">!     auto&amp; floatingState = formattingState.floatingState();</span>
<span class="line-modified">!     auto floatingContext = FloatingContext { floatingState };</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Move floats to their final position.</span>
<span class="line-modified">!     for (auto floatItem : floats) {</span>
<span class="line-added">+         auto&amp; floatBox = floatItem-&gt;layoutBox();</span>
<span class="line-added">+         ASSERT(layoutState().hasDisplayBox(floatBox));</span>
<span class="line-added">+         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(floatBox);</span>
<span class="line-added">+         // Set static position first.</span>
<span class="line-added">+         displayBox.setTopLeft({ lineContent.logicalLeft(), lineContent.logicalTop() });</span>
<span class="line-added">+         // Float it.</span>
<span class="line-added">+         displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-added">+         floatingState.append(floatBox);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (lineContent.isEmpty()) {</span>
<span class="line-modified">!         // Spec tells us to create a zero height, empty line box.</span>
<span class="line-modified">!         auto lineBoxRect = Display::Rect { lineContent.logicalTop(), lineContent.logicalLeft(), 0 , 0 };</span>
<span class="line-modified">!         formattingState.addLineBox({ lineBoxRect, lineContent.baseline(), lineContent.baselineOffset() });</span>
          return;
<span class="line-added">+     }</span>
  
<span class="line-modified">!     auto&amp; inlineDisplayRuns = formattingState.inlineRuns();</span>
<span class="line-modified">!     Optional&lt;unsigned&gt; previousLineLastRunIndex = inlineDisplayRuns.isEmpty() ? Optional&lt;unsigned&gt;() : inlineDisplayRuns.size() - 1;</span>
<span class="line-modified">!     // 9.4.2 Inline formatting contexts</span>
<span class="line-modified">!     // A line box is always tall enough for all of the boxes it contains.</span>
<span class="line-modified">!     auto lineBoxRect = Display::Rect { lineContent.logicalTop(), lineContent.logicalLeft(), 0, lineContent.logicalHeight()};</span>
<span class="line-modified">!     // Create final display runs.</span>
<span class="line-modified">!     auto&amp; lineRuns = lineContent.runs();</span>
<span class="line-added">+     for (unsigned index = 0; index &lt; lineRuns.size(); ++index) {</span>
<span class="line-added">+         auto&amp; lineRun = lineRuns.at(index);</span>
<span class="line-added">+         auto&amp; logicalRect = lineRun-&gt;logicalRect();</span>
<span class="line-added">+         auto&amp; layoutBox = lineRun-&gt;layoutBox();</span>
<span class="line-added">+         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (lineRun-&gt;isLineBreak()) {</span>
<span class="line-added">+             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-added">+             displayBox.setContentBoxWidth(logicalRect.width());</span>
<span class="line-added">+             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">+             formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Inline level box (replaced or inline-block)</span>
<span class="line-modified">!         if (lineRun-&gt;isBox()) {</span>
<span class="line-modified">!             auto topLeft = logicalRect.topLeft();</span>
<span class="line-added">+             if (layoutBox.isInFlowPositioned())</span>
<span class="line-added">+                 topLeft += Geometry::inFlowPositionedPositionOffset(layoutState(), layoutBox);</span>
<span class="line-added">+             displayBox.setTopLeft(topLeft);</span>
<span class="line-added">+             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">+             formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Inline level container start (&lt;span&gt;)</span>
<span class="line-modified">!         if (lineRun-&gt;isContainerStart()) {</span>
<span class="line-modified">!             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-modified">!             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-modified">!             continue;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // Inline level container end (&lt;/span&gt;)</span>
<span class="line-modified">!         if (lineRun-&gt;isContainerEnd()) {</span>
<span class="line-modified">!             if (layoutBox.isInFlowPositioned()) {</span>
<span class="line-modified">!                 auto inflowOffset = Geometry::inFlowPositionedPositionOffset(layoutState(), layoutBox);</span>
<span class="line-modified">!                 displayBox.moveHorizontally(inflowOffset.width());</span>
<span class="line-modified">!                 displayBox.moveVertically(inflowOffset.height());</span>
              }
<span class="line-modified">!             auto marginBoxWidth = logicalRect.left() - displayBox.left();</span>
<span class="line-modified">!             auto contentBoxWidth = marginBoxWidth - (displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0));</span>
<span class="line-added">+             // FIXME fix it for multiline.</span>
<span class="line-added">+             displayBox.setContentBoxWidth(contentBoxWidth);</span>
<span class="line-added">+             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">+             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Text content. Try to join multiple text runs when possible.</span>
<span class="line-modified">!         ASSERT(lineRun-&gt;isText());</span>
<span class="line-modified">!         auto textContext = lineRun-&gt;textContext();</span>
<span class="line-added">+         const Line::Content::Run* previousLineRun = !index ? nullptr : lineRuns[index - 1].get();</span>
<span class="line-added">+         if (!textContext-&gt;isCollapsed) {</span>
<span class="line-added">+             auto previousRunCanBeExtended = previousLineRun &amp;&amp; previousLineRun-&gt;textContext() ? previousLineRun-&gt;textContext()-&gt;canBeExtended : false;</span>
<span class="line-added">+             auto requiresNewRun = !index || !previousRunCanBeExtended || &amp;layoutBox != &amp;previousLineRun-&gt;layoutBox();</span>
<span class="line-added">+             if (requiresNewRun)</span>
<span class="line-added">+                 formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect, Display::Run::TextContext { textContext-&gt;start, textContext-&gt;length }));</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 auto&amp; lastDisplayRun = formattingState.inlineRuns().last();</span>
<span class="line-added">+                 lastDisplayRun-&gt;expandHorizontally(logicalRect.width());</span>
<span class="line-added">+                 lastDisplayRun-&gt;textContext()-&gt;expand(textContext-&gt;length);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // FIXME take content breaking into account when part of the layout box is on the previous line.</span>
<span class="line-added">+         auto firstInlineRunForLayoutBox = !previousLineRun || &amp;previousLineRun-&gt;layoutBox() != &amp;layoutBox;</span>
<span class="line-added">+         if (firstInlineRunForLayoutBox) {</span>
<span class="line-added">+             // Setup display box for the associated layout box.</span>
<span class="line-added">+             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-added">+             displayBox.setContentBoxWidth(textContext-&gt;isCollapsed ? LayoutUnit() : logicalRect.width());</span>
<span class="line-added">+             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">+         } else if (!textContext-&gt;isCollapsed) {</span>
<span class="line-added">+             // FIXME fix it for multirun/multiline.</span>
<span class="line-added">+             displayBox.setContentBoxWidth(displayBox.contentBoxWidth() + logicalRect.width());</span>
          }
      }
<span class="line-added">+     // FIXME linebox needs to be ajusted after content alignment.</span>
<span class="line-added">+     formattingState.addLineBox({ lineBoxRect, lineContent.baseline(), lineContent.baselineOffset() });</span>
<span class="line-added">+     alignRuns(m_formattingRoot.style().textAlign(), inlineDisplayRuns, previousLineLastRunIndex.valueOr(-1) + 1, widthConstraint - lineContent.logicalWidth());</span>
  }
  
<span class="line-modified">! static Optional&lt;LayoutUnit&gt; horizontalAdjustmentForAlignment(TextAlignMode align, LayoutUnit remainingWidth)</span>
  {
      switch (align) {
      case TextAlignMode::Left:
      case TextAlignMode::WebKitLeft:
      case TextAlignMode::Start:
<span class="line-modified">!         return { };</span>
      case TextAlignMode::Right:
      case TextAlignMode::WebKitRight:
      case TextAlignMode::End:
<span class="line-modified">!         return std::max(remainingWidth, 0_lu);</span>
      case TextAlignMode::Center:
      case TextAlignMode::WebKitCenter:
<span class="line-modified">!         return std::max(remainingWidth / 2, 0_lu);</span>
      case TextAlignMode::Justify:
          ASSERT_NOT_REACHED();
          break;
      }
      ASSERT_NOT_REACHED();
<span class="line-modified">!     return { };</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::InlineLayout::alignRuns(TextAlignMode textAlign, InlineRuns&amp; inlineDisplayRuns, unsigned firstRunIndex, LayoutUnit availableWidth) const</span>
  {
<span class="line-modified">!     auto adjustment = horizontalAdjustmentForAlignment(textAlign, availableWidth);</span>
<span class="line-modified">!     if (!adjustment)</span>
          return;
  
<span class="line-modified">!     for (unsigned index = firstRunIndex; index &lt; inlineDisplayRuns.size(); ++index)</span>
<span class="line-modified">!         inlineDisplayRuns[index]-&gt;moveHorizontally(*adjustment);</span>
  }
  
  }
  }
  
</pre>
<center><a href="InlineFormattingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingState.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>