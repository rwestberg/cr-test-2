<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../config.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2 *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
   3 *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4 *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   5 *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6 *  Copyright (C) 2007 Maks Orlovich
   7 *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2012 Igalia, S.L.
   9 *
  10 *  This library is free software; you can redistribute it and/or
  11 *  modify it under the terms of the GNU Library General Public
  12 *  License as published by the Free Software Foundation; either
  13 *  version 2 of the License, or (at your option) any later version.
  14 *
  15 *  This library is distributed in the hope that it will be useful,
  16 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  17 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18 *  Library General Public License for more details.
  19 *
  20 *  You should have received a copy of the GNU Library General Public License
  21 *  along with this library; see the file COPYING.LIB.  If not, write to
  22 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23 *  Boston, MA 02110-1301, USA.
  24 *
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;NodeConstructors.h&quot;
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;JIT.h&quot;
  35 #include &quot;JSCInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSGeneratorFunction.h&quot;
  38 #include &quot;JSGlobalObject.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 #include &quot;LabelScope.h&quot;
  41 #include &quot;Lexer.h&quot;
  42 #include &quot;Parser.h&quot;
  43 #include &quot;StackAlignment.h&quot;


  44 #include &lt;wtf/Assertions.h&gt;
  45 #include &lt;wtf/Threading.h&gt;
  46 #include &lt;wtf/text/StringBuilder.h&gt;
  47 
  48 namespace JSC {
  49 
  50 /*
  51     Details of the emitBytecode function.
  52 
  53     Return value: The register holding the production&#39;s value.
  54              dst: An optional parameter specifying the most efficient destination at
  55                   which to store the production&#39;s value. The callee must honor dst.
  56 
  57     The dst argument provides for a crude form of copy propagation. For example,
  58 
  59         x = 1
  60 
  61     becomes
  62 
  63         load r[x], 1
</pre>
<hr />
<pre>
 124 JSValue BigIntNode::jsValue(BytecodeGenerator&amp; generator) const
 125 {
 126     return generator.addBigIntConstant(m_value, m_radix, m_sign);
 127 }
 128 
 129 // ------------------------------ NumberNode ----------------------------------
 130 
 131 RegisterID* NumberNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 132 {
 133     if (dst == generator.ignoredResult())
 134         return nullptr;
 135     return generator.emitLoad(dst, jsValue(generator), isIntegerNode() ? SourceCodeRepresentation::Integer : SourceCodeRepresentation::Double);
 136 }
 137 
 138 // ------------------------------ RegExpNode -----------------------------------
 139 
 140 RegisterID* RegExpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 141 {
 142     if (dst == generator.ignoredResult())
 143         return nullptr;
<span class="line-modified"> 144     RegExp* regExp = RegExp::create(*generator.vm(), m_pattern.string(), regExpFlags(m_flags.string()));</span>



 145     if (regExp-&gt;isValid())
 146         return generator.emitNewRegExp(generator.finalDestination(dst), regExp);

 147     const char* messageCharacters = regExp-&gt;errorMessage();
 148     const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
 149     generator.emitThrowStaticError(ErrorType::SyntaxError, message);
 150     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
 151 }
 152 
 153 // ------------------------------ ThisNode -------------------------------------
 154 
 155 RegisterID* ThisNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 156 {
 157     generator.ensureThis();
 158     if (dst == generator.ignoredResult())
 159         return 0;
 160 
 161     RegisterID* result = generator.move(dst, generator.thisRegister());
 162     static const unsigned thisLength = 4;
 163     generator.emitProfileType(generator.thisRegister(), position(), JSTextPosition(-1, position().offset + thisLength, -1));
 164     return result;
 165 }
 166 
</pre>
<hr />
<pre>
 387 {
 388     bool hadVariableExpression = false;
 389     unsigned length = 0;
 390 
 391     IndexingType recommendedIndexingType = ArrayWithUndecided;
 392     ElementNode* firstPutElement;
 393     for (firstPutElement = m_element; firstPutElement; firstPutElement = firstPutElement-&gt;next()) {
 394         if (firstPutElement-&gt;elision() || firstPutElement-&gt;value()-&gt;isSpreadExpression())
 395             break;
 396         if (!firstPutElement-&gt;value()-&gt;isConstant())
 397             hadVariableExpression = true;
 398         else
 399             recommendedIndexingType = leastUpperBoundOfIndexingTypeAndValue(recommendedIndexingType, static_cast&lt;ConstantNode*&gt;(firstPutElement-&gt;value())-&gt;jsValue(generator));
 400 
 401         ++length;
 402     }
 403 
 404     auto newArray = [&amp;] (RegisterID* dst, ElementNode* elements, unsigned length, bool hadVariableExpression) {
 405         if (length &amp;&amp; !hadVariableExpression) {
 406             recommendedIndexingType |= CopyOnWrite;
<span class="line-modified"> 407             ASSERT(generator.vm()-&gt;heap.isDeferred()); // We run bytecode generator under a DeferGC. If we stopped doing that, we&#39;d need to put a DeferGC here as we filled in these slots.</span>
<span class="line-modified"> 408             auto* array = JSImmutableButterfly::create(*generator.vm(), recommendedIndexingType, length);</span>
 409             unsigned index = 0;
 410             for (ElementNode* element = elements; index &lt; length; element = element-&gt;next()) {
 411                 ASSERT(element-&gt;value()-&gt;isConstant());
<span class="line-modified"> 412                 array-&gt;setIndex(*generator.vm(), index++, static_cast&lt;ConstantNode*&gt;(element-&gt;value())-&gt;jsValue(generator));</span>
 413             }
 414             return generator.emitNewArrayBuffer(dst, array, recommendedIndexingType);
 415         }
 416         return generator.emitNewArray(dst, elements, length, recommendedIndexingType);
 417     };
 418 
 419     if (!firstPutElement &amp;&amp; !m_elision)
 420         return newArray(generator.finalDestination(dst), m_element, length, hadVariableExpression);
 421 
 422     if (firstPutElement &amp;&amp; firstPutElement-&gt;value()-&gt;isSpreadExpression()) {
 423         bool hasElision = m_elision;
 424         if (!hasElision) {
 425             for (ElementNode* node = firstPutElement; node; node = node-&gt;next()) {
 426                 if (node-&gt;elision()) {
 427                     hasElision = true;
 428                     break;
 429                 }
 430             }
 431         }
 432 
</pre>
<hr />
<pre>
 721         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 722         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
 723 
 724         if (isNonIndexStringElement(*m_subscript)) {
 725             const Identifier&amp; id = static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value();
 726             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 727             generator.emitGetById(finalDest.get(), superBase.get(), thisValue.get(), id);
 728         } else  {
 729             RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(m_subscript);
 730             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 731             generator.emitGetByVal(finalDest.get(), superBase.get(), thisValue.get(), subscript.get());
 732         }
 733 
 734         generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 735         return finalDest.get();
 736     }
 737 
 738     RegisterID* ret;
 739     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 740 
<span class="line-modified"> 741     if (isNonIndexStringElement(*m_subscript)) {</span>
<span class="line-modified"> 742         RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>







 743         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 744         ret = generator.emitGetById(finalDest.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
 745     } else {
<span class="line-removed"> 746         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));</span>
 747         RegisterID* property = generator.emitNodeForProperty(m_subscript);
 748         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 749         ret = generator.emitGetByVal(finalDest.get(), base.get(), property);
 750     }
 751 
 752     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 753     return ret;
 754 }
 755 
 756 // ------------------------------ DotAccessorNode --------------------------------
 757 
 758 RegisterID* DotAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 759 {

 760     bool baseIsSuper = m_base-&gt;isSuperNode();
<span class="line-modified"> 761     RefPtr&lt;RegisterID&gt; base = baseIsSuper ? emitSuperBaseForCallee(generator) : generator.emitNode(m_base);</span>









 762     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-removed"> 763     RegisterID* finalDest = generator.finalDestination(dst);</span>
 764     RegisterID* ret;
 765     if (baseIsSuper) {
 766         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
<span class="line-modified"> 767         ret = generator.emitGetById(finalDest, base.get(), thisValue.get(), m_ident);</span>
 768     } else
<span class="line-modified"> 769         ret = generator.emitGetById(finalDest, base.get(), m_ident);</span>
<span class="line-modified"> 770     generator.emitProfileType(finalDest, divotStart(), divotEnd());</span>
 771     return ret;
 772 }
 773 
 774 // ------------------------------ ArgumentListNode -----------------------------
 775 
 776 RegisterID* ArgumentListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 777 {
 778     ASSERT(m_expr);
 779     return generator.emitNode(dst, m_expr);
 780 }
 781 
 782 // ------------------------------ NewExprNode ----------------------------------
 783 
 784 RegisterID* NewExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 785 {
 786     ExpectedFunction expectedFunction;
 787     if (m_expr-&gt;isResolveNode())
 788         expectedFunction = generator.expectedFunctionForIdentifier(static_cast&lt;ResolveNode*&gt;(m_expr)-&gt;identifier());
 789     else
 790         expectedFunction = NoExpectedFunction;
</pre>
<hr />
<pre>
 825 // ------------------------------ EvalFunctionCallNode ----------------------------------
 826 
 827 RegisterID* EvalFunctionCallNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 828 {
 829     // We need try to load &#39;this&#39; before call eval in constructor, because &#39;this&#39; can created by &#39;super&#39; in some of the arrow function
 830     // var A = class A {
 831     //   constructor () { this.id = &#39;A&#39;; }
 832     // }
 833     //
 834     // var B = class B extend A {
 835     //    constructor () {
 836     //       var arrow = () =&gt; super();
 837     //       arrow();
 838     //       eval(&quot;this.id = &#39;B&#39;&quot;);
 839     //    }
 840     // }
 841     if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isThisUsedInInnerArrowFunction())
 842         generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 843 
 844     Variable var = generator.variable(generator.propertyNames().eval);
<span class="line-modified"> 845     if (RegisterID* local = var.local()) {</span>
<span class="line-modified"> 846         generator.emitTDZCheckIfNecessary(var, local, nullptr);</span>
<span class="line-modified"> 847         RefPtr&lt;RegisterID&gt; func = generator.move(generator.tempDestination(dst), local);</span>
<span class="line-modified"> 848         CallArguments callArguments(generator, m_args);</span>






 849         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
<span class="line-modified"> 850         return generator.emitCallEval(generator.finalDestination(dst, func.get()), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>







 851     }
 852 
<span class="line-modified"> 853     RefPtr&lt;RegisterID&gt; func = generator.newTemporary();</span>
<span class="line-modified"> 854     CallArguments callArguments(generator, m_args);</span>
<span class="line-modified"> 855     JSTextPosition newDivot = divotStart() + 4;</span>
<span class="line-modified"> 856     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-modified"> 857     generator.move(</span>
<span class="line-removed"> 858         callArguments.thisRegister(),</span>
<span class="line-removed"> 859         generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-removed"> 860     generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-removed"> 861     generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
<span class="line-removed"> 862     return generator.emitCallEval(generator.finalDestination(dst, func.get()), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>
 863 }
 864 
 865 // ------------------------------ FunctionCallValueNode ----------------------------------
 866 
 867 RegisterID* FunctionCallValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 868 {
 869     if (m_expr-&gt;isSuperNode()) {
 870         RefPtr&lt;RegisterID&gt; func = emitGetSuperFunctionForConstruct(generator);
 871         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 872         CallArguments callArguments(generator, m_args);
 873 
 874         ASSERT(generator.isConstructor() || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 875         ASSERT(generator.constructorKind() == ConstructorKind::Extends || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 876         RegisterID* ret = generator.emitConstruct(returnValue.get(), func.get(), generator.newTarget(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd());
 877 
 878         bool isConstructorKindDerived = generator.constructorKind() == ConstructorKind::Extends;
 879         bool doWeUseArrowFunctionInConstructor = isConstructorKindDerived &amp;&amp; generator.needsToUpdateArrowFunctionContext();
 880 
 881         if (generator.isDerivedConstructorContext() || (doWeUseArrowFunctionInConstructor &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction()))
 882             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 883 
 884         Ref&lt;Label&gt; thisIsEmptyLabel = generator.newLabel();
 885         generator.emitJumpIfTrue(generator.emitIsEmpty(generator.newTemporary(), generator.thisRegister()), thisIsEmptyLabel.get());
 886         generator.emitThrowReferenceError(&quot;&#39;super()&#39; can&#39;t be called more than once in a constructor.&quot;_s);
 887         generator.emitLabel(thisIsEmptyLabel.get());
 888 
 889         generator.move(generator.thisRegister(), ret);
 890 
 891         if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
 892             generator.emitPutThisToArrowFunctionContextScope();
 893 
 894         return ret;
 895     }

 896     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 897     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());



 898     CallArguments callArguments(generator, m_args);
 899     generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 900     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 901     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 902     return ret;
 903 }
 904 
 905 // ------------------------------ FunctionCallResolveNode ----------------------------------
 906 
 907 RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 908 {
<span class="line-modified"> 909     if (UNLIKELY(m_ident == generator.vm()-&gt;propertyNames-&gt;builtinNames().assertPrivateName())) {</span>
 910         if (ASSERT_DISABLED)
 911             return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
 912     }
 913 
 914     ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
 915 
 916     Variable var = generator.variable(m_ident);
<span class="line-modified"> 917     if (RegisterID* local = var.local()) {</span>
<span class="line-modified"> 918         generator.emitTDZCheckIfNecessary(var, local, nullptr);</span>
<span class="line-modified"> 919         RefPtr&lt;RegisterID&gt; func = generator.move(generator.tempDestination(dst), local);</span>
<span class="line-modified"> 920         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());</span>
<span class="line-modified"> 921         CallArguments callArguments(generator, m_args);</span>





 922         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 923         // This passes NoExpectedFunction because we expect that if the function is in a
 924         // local variable, then it&#39;s not one of our built-in constructors.
<span class="line-modified"> 925         RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);</span>
<span class="line-modified"> 926         generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());</span>
<span class="line-modified"> 927         return ret;</span>






 928     }
 929 
<span class="line-removed"> 930     RefPtr&lt;RegisterID&gt; func = generator.newTemporary();</span>
 931     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<span class="line-modified"> 932     CallArguments callArguments(generator, m_args);</span>

 933 
<span class="line-removed"> 934     JSTextPosition newDivot = divotStart() + m_ident.length();</span>
<span class="line-removed"> 935     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-removed"> 936     generator.move(</span>
<span class="line-removed"> 937         callArguments.thisRegister(),</span>
<span class="line-removed"> 938         generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-removed"> 939     generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-removed"> 940     generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
 941     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 942     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 943     return ret;
 944 }
 945 
 946 // ------------------------------ BytecodeIntrinsicNode ----------------------------------
 947 
 948 RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 949 {
 950     return (this-&gt;*m_emitter)(generator, dst);
 951 }
 952 
 953 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
 954 {
 955     ArgumentListNode* node = m_args-&gt;m_listNode;
 956     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
 957     node = node-&gt;m_next;
 958     ASSERT(node-&gt;m_expr-&gt;isString());
 959     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
 960     ASSERT(!node-&gt;m_next);
 961     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), ident);
 962 }
 963 
 964 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
 965 {
 966     ArgumentListNode* node = m_args-&gt;m_listNode;
 967     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
 968     node = node-&gt;m_next;
 969     ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified"> 970     SymbolImpl* symbol = generator.vm()-&gt;propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
 971     ASSERT(symbol);
 972     ASSERT(!node-&gt;m_next);
 973     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
 974 }
 975 
 976 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
 977 {
 978     ArgumentListNode* node = m_args-&gt;m_listNode;
 979     ASSERT(node-&gt;m_expr-&gt;isNumber());
 980     double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
 981     int32_t index = static_cast&lt;int32_t&gt;(value);
 982     ASSERT(value == index);
 983     ASSERT(index &gt;= 0);
 984     ASSERT(!node-&gt;m_next);
 985 
 986     // The body functions of generator and async have different mechanism for arguments.
 987     ASSERT(generator.parseMode() != SourceParseMode::GeneratorBodyMode);
 988     ASSERT(!isAsyncFunctionBodyParseMode(generator.parseMode()));
 989 
 990     return generator.emitGetArgument(generator.finalDestination(dst), index);
</pre>
<hr />
<pre>
1001 {
1002     ArgumentListNode* node = m_args-&gt;m_listNode;
1003     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1004     node = node-&gt;m_next;
1005     ASSERT(node-&gt;m_expr-&gt;isString());
1006     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1007     node = node-&gt;m_next;
1008     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1009 
1010     ASSERT(!node-&gt;m_next);
1011 
1012     return generator.move(dst, generator.emitDirectPutById(base.get(), ident, value.get(), PropertyNode::KnownDirect));
1013 }
1014 
1015 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1016 {
1017     ArgumentListNode* node = m_args-&gt;m_listNode;
1018     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1019     node = node-&gt;m_next;
1020     ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified">1021     SymbolImpl* symbol = generator.vm()-&gt;propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
1022     ASSERT(symbol);
1023     node = node-&gt;m_next;
1024     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1025 
1026     ASSERT(!node-&gt;m_next);
1027 
1028     return generator.move(dst, generator.emitDirectPutById(base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol), value.get(), PropertyNode::KnownDirect));
1029 }
1030 
1031 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByValDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1032 {
1033     ArgumentListNode* node = m_args-&gt;m_listNode;
1034     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1035     node = node-&gt;m_next;
1036     RefPtr&lt;RegisterID&gt; index = generator.emitNodeForProperty(node);
1037     node = node-&gt;m_next;
1038     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1039 
1040     ASSERT(!node-&gt;m_next);
1041 
</pre>
<hr />
<pre>
1120     ArgumentListNode* node = m_args-&gt;m_listNode;
1121     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1122     ASSERT(!node-&gt;m_next);
1123 
1124     return generator.move(dst, generator.emitToString(generator.tempDestination(dst), src.get()));
1125 }
1126 
1127 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toObject(BytecodeGenerator&amp; generator, RegisterID* dst)
1128 {
1129     ArgumentListNode* node = m_args-&gt;m_listNode;
1130     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1131     node = node-&gt;m_next;
1132 
1133     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
1134     if (node) {
1135         ASSERT(node-&gt;m_expr-&gt;isString());
1136         const Identifier&amp; message = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1137         ASSERT(!node-&gt;m_next);
1138         return generator.move(dst, generator.emitToObject(temp.get(), src.get(), message));
1139     }
<span class="line-modified">1140     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm()-&gt;propertyNames-&gt;emptyIdentifier));</span>
1141 }
1142 
1143 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
1144 {
1145     ArgumentListNode* node = m_args-&gt;m_listNode;
1146     RefPtr&lt;RegisterID&gt; idValue = generator.newTemporary();
1147     generator.emitNode(idValue.get(), node);
1148     SpeculatedType speculation = SpecNone;
1149     while (node-&gt;m_next) {
1150         node = node-&gt;m_next;
1151         ASSERT(node-&gt;m_expr-&gt;isString());
1152         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1153         speculation |= speculationFromString(ident.utf8().data());
1154     }
1155 
1156     return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
1157 }
1158 
1159 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isJSArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1160 {
</pre>
<hr />
<pre>
1243 {
1244     ArgumentListNode* node = m_args-&gt;m_listNode;
1245     RefPtr&lt;RegisterID&gt; newObj = generator.emitNode(node);
1246     node = node-&gt;m_next;
1247     RefPtr&lt;RegisterID&gt; propertyNameRegister = generator.emitNode(node);
1248     node = node-&gt;m_next;
1249     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1250     ASSERT(!node-&gt;m_next);
1251 
1252     generator.emitCallDefineProperty(newObj.get(), propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);
1253     return dst;
1254 }
1255 
1256 #define JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS(name) \
1257     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##name(BytecodeGenerator&amp; generator, RegisterID* dst) \
1258     { \
1259         ASSERT(!m_args); \
1260         ASSERT(type() == Type::Constant); \
1261         if (dst == generator.ignoredResult()) \
1262             return nullptr; \
<span class="line-modified">1263         return generator.emitLoad(dst, generator.vm()-&gt;bytecodeIntrinsicRegistry().name##Value(generator)); \</span>
1264     }
1265     JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS)
1266 #undef JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS
1267 
1268 // ------------------------------ FunctionCallBracketNode ----------------------------------
1269 
1270 RegisterID* FunctionCallBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1271 {


1272     bool baseIsSuper = m_base-&gt;isSuperNode();
1273     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
1274 
1275     RefPtr&lt;RegisterID&gt; base;
1276     if (baseIsSuper)
1277         base = emitSuperBaseForCallee(generator);
1278     else {
1279         if (subscriptIsNonIndexString)
1280             base = generator.emitNode(m_base);
1281         else
1282             base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));



1283     }
1284 
<span class="line-removed">1285     RefPtr&lt;RegisterID&gt; function;</span>
1286     RefPtr&lt;RegisterID&gt; thisRegister;
1287     if (baseIsSuper) {
1288         // Note that we only need to do this once because we either have a non-TDZ this or we throw. Once we have a non-TDZ this, we can&#39;t change its value back to TDZ.
1289         thisRegister = generator.ensureThis();
1290     }
1291     if (subscriptIsNonIndexString) {
1292         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1293         if (baseIsSuper)
<span class="line-modified">1294             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisRegister.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
1295         else
<span class="line-modified">1296             function = generator.emitGetById(generator.tempDestination(dst), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
1297     } else {
1298         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(m_subscript);
1299         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1300         if (baseIsSuper)
<span class="line-modified">1301             function = generator.emitGetByVal(generator.tempDestination(dst), base.get(), thisRegister.get(), property.get());</span>
1302         else
<span class="line-modified">1303             function = generator.emitGetByVal(generator.tempDestination(dst), base.get(), property.get());</span>
1304     }


1305 
<span class="line-removed">1306     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());</span>
1307     CallArguments callArguments(generator, m_args);
1308     if (baseIsSuper) {
1309         generator.emitTDZCheck(generator.thisRegister());
1310         generator.move(callArguments.thisRegister(), thisRegister.get());
1311     } else
1312         generator.move(callArguments.thisRegister(), base.get());
1313     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1314     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1315     return ret;
1316 }
1317 
1318 // ------------------------------ FunctionCallDotNode ----------------------------------
1319 
1320 RegisterID* FunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1321 {
1322     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);
1323     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
1324     CallArguments callArguments(generator, m_args);
1325     bool baseIsSuper = m_base-&gt;isSuperNode();
1326     if (baseIsSuper)
1327         generator.move(callArguments.thisRegister(), generator.ensureThis());
<span class="line-modified">1328     else</span>
1329         generator.emitNode(callArguments.thisRegister(), m_base);



1330     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1331     if (baseIsSuper) {
1332         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
1333         generator.emitGetById(function.get(), superBase.get(), callArguments.thisRegister(), m_ident);
1334     } else
1335         generator.emitGetById(function.get(), callArguments.thisRegister(), m_ident);




1336     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1337     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1338     return ret;
1339 }
1340 
1341 static constexpr size_t maxDistanceToInnermostCallOrApply = 2;
1342 
1343 RegisterID* CallFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1344 {

1345     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);




1346     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
<span class="line-removed">1347     RefPtr&lt;RegisterID&gt; function;</span>
<span class="line-removed">1348     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);</span>
1349 

1350     auto makeFunction = [&amp;] {
1351         if (m_base-&gt;isSuperNode()) {
1352             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1353             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().callPublicName());
1354         } else
1355             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().callPublicName());



1356     };
1357 
1358     bool emitCallCheck = !generator.isBuiltinFunction();
1359     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1360         makeFunction();
1361         CallArguments callArguments(generator, m_args);
1362         generator.move(callArguments.thisRegister(), base.get());
1363         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1364         generator.move(dst, returnValue.get());
1365         return returnValue.get();
1366     }
1367 
1368     Ref&lt;Label&gt; realCall = generator.newLabel();
1369     Ref&lt;Label&gt; end = generator.newLabel();
1370 
1371     if (emitCallCheck) {
1372         makeFunction();
1373         generator.emitJumpIfNotFunctionCall(function.get(), realCall.get());
1374     }
1375     {
</pre>
<hr />
<pre>
1407         }
1408         generator.emitLabel(end.get());
1409     }
1410     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1411     return returnValue.get();
1412 }
1413 
1414 static bool areTrivialApplyArguments(ArgumentsNode* args)
1415 {
1416     return !args-&gt;m_listNode || !args-&gt;m_listNode-&gt;m_expr || !args-&gt;m_listNode-&gt;m_next
1417         || (!args-&gt;m_listNode-&gt;m_next-&gt;m_next &amp;&amp; args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1418 }
1419 
1420 RegisterID* ApplyFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1421 {
1422     // A few simple cases can be trivially handled as ordinary function calls.
1423     // function.apply(), function.apply(arg) -&gt; identical to function.call
1424     // function.apply(thisArg, [arg0, arg1, ...]) -&gt; can be trivially coerced into function.call(thisArg, arg0, arg1, ...) and saves object allocation
1425     bool mayBeCall = areTrivialApplyArguments(m_args);
1426 
<span class="line-removed">1427     RefPtr&lt;RegisterID&gt; function;</span>
<span class="line-removed">1428     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>
1429     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);






1430     auto makeFunction = [&amp;] {
1431         if (m_base-&gt;isSuperNode()) {
1432             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1433             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().applyPublicName());
1434         } else
1435             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().applyPublicName());



1436     };
1437 
1438     bool emitCallCheck = !generator.isBuiltinFunction();
1439     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1440         makeFunction();
1441         CallArguments callArguments(generator, m_args);
1442         generator.move(callArguments.thisRegister(), base.get());
1443         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1444         generator.move(dst, returnValue.get());
1445         return returnValue.get();
1446     }
1447 
1448     Ref&lt;Label&gt; realCall = generator.newLabel();
1449     Ref&lt;Label&gt; end = generator.newLabel();
1450     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1451     if (emitCallCheck) {
1452         makeFunction();
1453         ASSERT(!m_base-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(m_base)-&gt;identifier() != &quot;Reflect&quot;);
1454         generator.emitJumpIfNotFunctionApply(function.get(), realCall.get());
1455     }
</pre>
<hr />
<pre>
1643     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1644     if (baseIsSuper)
1645         generator.emitPutById(base.get(), thisValue.get(), ident, value.get());
1646     else
1647         generator.emitPutById(base.get(), ident, value.get());
1648     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1649     return generator.move(dst, oldValue);
1650 }
1651 
1652 RegisterID* PostfixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1653 {
1654     if (m_expr-&gt;isResolveNode())
1655         return emitResolve(generator, dst);
1656 
1657     if (m_expr-&gt;isBracketAccessorNode())
1658         return emitBracket(generator, dst);
1659 
1660     if (m_expr-&gt;isDotAccessorNode())
1661         return emitDot(generator, dst);
1662 

1663     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1664         ? &quot;Postfix ++ operator applied to value that is not a reference.&quot;_s
1665         : &quot;Postfix -- operator applied to value that is not a reference.&quot;_s);
1666 }
1667 
1668 // ------------------------------ DeleteResolveNode -----------------------------------
1669 
1670 RegisterID* DeleteResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1671 {
1672     Variable var = generator.variable(m_ident);
1673     if (var.local()) {
1674         generator.emitTDZCheckIfNecessary(var, var.local(), nullptr);
1675         return generator.emitLoad(generator.finalDestination(dst), false);
1676     }
1677 
1678     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1679     RefPtr&lt;RegisterID&gt; base = generator.emitResolveScope(dst, var);
1680     generator.emitTDZCheckIfNecessary(var, nullptr, base.get());
1681     return generator.emitDeleteById(generator.finalDestination(dst, base.get()), base.get(), m_ident);
1682 }
1683 
1684 // ------------------------------ DeleteBracketNode -----------------------------------
1685 
1686 RegisterID* DeleteBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1687 {

1688     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
<span class="line-removed">1689     RefPtr&lt;RegisterID&gt; r1 = generator.emitNode(m_subscript);</span>
1690 




1691     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1692     if (m_base-&gt;isSuperNode())
1693         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">1694     return generator.emitDeleteByVal(generator.finalDestination(dst), r0.get(), r1.get());</span>
1695 }
1696 
1697 // ------------------------------ DeleteDotNode -----------------------------------
1698 
1699 RegisterID* DeleteDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1700 {

1701     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
1702 



1703     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1704     if (m_base-&gt;isSuperNode())
1705         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">1706     return generator.emitDeleteById(generator.finalDestination(dst), r0.get(), m_ident);</span>
1707 }
1708 
1709 // ------------------------------ DeleteValueNode -----------------------------------
1710 
1711 RegisterID* DeleteValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1712 {
1713     generator.emitNode(generator.ignoredResult(), m_expr);
1714 
1715     // delete on a non-location expression ignores the value and returns true
1716     return generator.emitLoad(generator.finalDestination(dst), true);
1717 }
1718 
1719 // ------------------------------ VoidNode -------------------------------------
1720 
1721 RegisterID* VoidNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1722 {
1723     if (dst == generator.ignoredResult()) {
1724         generator.emitNode(generator.ignoredResult(), m_expr);
1725         return 0;
1726     }
</pre>
<hr />
<pre>
1758     }
1759     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1760     return generator.emitTypeOf(generator.finalDestination(dst), src.get());
1761 }
1762 
1763 // ------------------------------ PrefixNode ----------------------------------
1764 
1765 RegisterID* PrefixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1766 {
1767     ASSERT(m_expr-&gt;isResolveNode());
1768     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1769     const Identifier&amp; ident = resolve-&gt;identifier();
1770 
1771     Variable var = generator.variable(ident);
1772     if (RegisterID* local = var.local()) {
1773         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1774         RefPtr&lt;RegisterID&gt; localReg = local;
1775         if (var.isReadOnly()) {
1776             generator.emitReadOnlyExceptionIfNeeded(var);
1777             localReg = generator.move(generator.tempDestination(dst), localReg.get());
<span class="line-modified">1778         } else if (generator.vm()-&gt;typeProfiler()) {</span>
1779             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
1780             generator.move(tempDst.get(), localReg.get());
1781             emitIncOrDec(generator, tempDst.get(), m_operator);
1782             generator.move(localReg.get(), tempDst.get());
1783             generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
1784             return generator.move(dst, tempDst.get());
1785         }
1786         emitIncOrDec(generator, localReg.get(), m_operator);
1787         return generator.move(dst, localReg.get());
1788     }
1789 
1790     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1791     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
1792     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
1793     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1794     if (var.isReadOnly()) {
1795         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
1796         if (threwException)
1797             return value.get();
1798     }
</pre>
<hr />
<pre>
1856     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1857     if (baseNode-&gt;isSuperNode())
1858         generator.emitPutById(base.get(), thisValue.get(), ident, value);
1859     else
1860         generator.emitPutById(base.get(), ident, value);
1861     generator.emitProfileType(value, divotStart(), divotEnd());
1862     return generator.move(dst, propDst.get());
1863 }
1864 
1865 RegisterID* PrefixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1866 {
1867     if (m_expr-&gt;isResolveNode())
1868         return emitResolve(generator, dst);
1869 
1870     if (m_expr-&gt;isBracketAccessorNode())
1871         return emitBracket(generator, dst);
1872 
1873     if (m_expr-&gt;isDotAccessorNode())
1874         return emitDot(generator, dst);
1875 

1876     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1877         ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
1878         : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
1879 }
1880 
1881 // ------------------------------ Unary Operation Nodes -----------------------------------
1882 
1883 RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1884 {
1885     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1886     generator.emitExpressionInfo(position(), position(), position());
1887     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), OperandTypes(m_expr-&gt;resultDescriptor()));
1888 }
1889 
1890 // ------------------------------ UnaryPlusNode -----------------------------------
1891 
1892 RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1893 {
1894     ASSERT(opcodeID() == op_to_number);
1895     RefPtr&lt;RegisterID&gt; src = generator.emitNode(expr());
</pre>
<hr />
<pre>
2234 }
2235 
2236 RegisterID* InstanceOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2237 {
2238     RefPtr&lt;RegisterID&gt; hasInstanceValue = generator.newTemporary();
2239     RefPtr&lt;RegisterID&gt; isObject = generator.newTemporary();
2240     RefPtr&lt;RegisterID&gt; isCustom = generator.newTemporary();
2241     RefPtr&lt;RegisterID&gt; prototype = generator.newTemporary();
2242     RefPtr&lt;RegisterID&gt; value = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2243     RefPtr&lt;RegisterID&gt; constructor = generator.emitNode(m_expr2);
2244     RefPtr&lt;RegisterID&gt; dstReg = generator.finalDestination(dst, value.get());
2245     Ref&lt;Label&gt; custom = generator.newLabel();
2246     Ref&lt;Label&gt; done = generator.newLabel();
2247     Ref&lt;Label&gt; typeError = generator.newLabel();
2248 
2249     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2250     generator.emitIsObject(isObject.get(), constructor.get());
2251     generator.emitJumpIfFalse(isObject.get(), typeError.get());
2252 
2253     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">2254     generator.emitGetById(hasInstanceValue.get(), constructor.get(), generator.vm()-&gt;propertyNames-&gt;hasInstanceSymbol);</span>
2255 
2256     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2257     generator.emitOverridesHasInstance(isCustom.get(), constructor.get(), hasInstanceValue.get());
2258 
2259     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2260     generator.emitJumpIfTrue(isCustom.get(), custom.get());
2261 
2262     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">2263     generator.emitGetById(prototype.get(), constructor.get(), generator.vm()-&gt;propertyNames-&gt;prototype);</span>
2264 
2265     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2266     generator.emitInstanceOf(dstReg.get(), value.get(), prototype.get());
2267 
2268     generator.emitJump(done.get());
2269 
2270     generator.emitLabel(typeError.get());
2271     generator.emitThrowTypeError(&quot;Right hand side of instanceof is not an object&quot;);
2272 
2273     generator.emitLabel(custom.get());
2274 
2275     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2276     generator.emitInstanceOfCustom(dstReg.get(), value.get(), constructor.get(), hasInstanceValue.get());
2277 
2278     generator.emitLabel(done.get());
2279 
2280     return dstReg.get();
2281 }
2282 
2283 // ------------------------------ InNode ----------------------------
</pre>
<hr />
<pre>
2313     generator.emitLabel(target.get());
2314 
2315     return generator.move(dst, temp.get());
2316 }
2317 
2318 void LogicalOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2319 {
2320     if (UNLIKELY(needsDebugHook()))
2321         generator.emitDebugHook(this);
2322 
2323     Ref&lt;Label&gt; afterExpr1 = generator.newLabel();
2324     if (m_operator == OpLogicalAnd)
2325         generator.emitNodeInConditionContext(m_expr1, afterExpr1.get(), falseTarget, FallThroughMeansTrue);
2326     else
2327         generator.emitNodeInConditionContext(m_expr1, trueTarget, afterExpr1.get(), FallThroughMeansFalse);
2328     generator.emitLabel(afterExpr1.get());
2329 
2330     generator.emitNodeInConditionContext(m_expr2, trueTarget, falseTarget, fallThroughMode);
2331 }
2332 



































2333 // ------------------------------ ConditionalNode ------------------------------
2334 
2335 RegisterID* ConditionalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2336 {
2337     RefPtr&lt;RegisterID&gt; newDst = generator.finalDestination(dst);
2338     Ref&lt;Label&gt; beforeElse = generator.newLabel();
2339     Ref&lt;Label&gt; afterElse = generator.newLabel();
2340 
2341     Ref&lt;Label&gt; beforeThen = generator.newLabel();
2342     generator.emitNodeInConditionContext(m_logical, beforeThen.get(), beforeElse.get(), FallThroughMeansTrue);
2343     generator.emitLabel(beforeThen.get());
2344 
2345     generator.emitProfileControlFlow(m_expr1-&gt;startOffset());
2346     generator.emitNodeInTailPosition(newDst.get(), m_expr1);
2347     generator.emitJump(afterElse.get());
2348 
2349     generator.emitLabel(beforeElse.get());
2350     generator.emitProfileControlFlow(m_expr1-&gt;endOffset() + 1);
2351     generator.emitNodeInTailPosition(newDst.get(), m_expr2);
2352 
</pre>
<hr />
<pre>
2703 
2704 void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2705 {
2706     ASSERT(m_expr);
2707     generator.emitNode(dst, m_expr);
2708 }
2709 
2710 // ------------------------------ DeclarationStatement ----------------------------
2711 
2712 void DeclarationStatement::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2713 {
2714     ASSERT(m_expr);
2715     generator.emitNode(m_expr);
2716 }
2717 
2718 // ------------------------------ EmptyVarExpression ----------------------------
2719 
2720 RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2721 {
2722     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
<span class="line-modified">2723     if (!generator.vm()-&gt;typeProfiler())</span>
2724         return nullptr;
2725 
2726     Variable var = generator.variable(m_ident);
2727     if (RegisterID* local = var.local())
2728         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2729     else {
2730         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2731         RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
2732         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2733     }
2734 
2735     return nullptr;
2736 }
2737 
2738 // ------------------------------ EmptyLetExpression ----------------------------
2739 
2740 RegisterID* EmptyLetExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2741 {
2742     // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
2743     // get TDZ errors for situations like this: `let x; x;`
</pre>
<hr />
<pre>
3333         dst = 0;
3334 
3335     RefPtr&lt;RegisterID&gt; returnRegister = m_value ? generator.emitNodeInTailPosition(dst, m_value) : generator.emitLoad(dst, jsUndefined());
3336 
3337     generator.emitProfileType(returnRegister.get(), ProfileTypeBytecodeFunctionReturnStatement, divotStart(), divotEnd());
3338 
3339     bool hasFinally = generator.emitReturnViaFinallyIfNeeded(returnRegister.get());
3340     if (!hasFinally) {
3341         if (generator.parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
3342             returnRegister = generator.move(generator.newTemporary(), returnRegister.get());
3343             generator.emitAwait(returnRegister.get());
3344         }
3345 
3346         generator.emitWillLeaveCallFrameDebugHook();
3347         generator.emitReturn(returnRegister.get());
3348     }
3349 
3350     generator.emitProfileControlFlow(endOffset());
3351     // Emitting an unreachable return here is needed in case this op_profile_control_flow is the
3352     // last opcode in a CodeBlock because a CodeBlock&#39;s instructions must end with a terminal opcode.
<span class="line-modified">3353     if (generator.vm()-&gt;controlFlowProfiler())</span>
3354         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3355 }
3356 
3357 // ------------------------------ WithNode -------------------------------------
3358 
3359 void WithNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3360 {
3361     RefPtr&lt;RegisterID&gt; scope = generator.emitNode(m_expr);
3362     generator.emitExpressionInfo(m_divot, m_divot - m_expressionLength, m_divot);
3363     generator.emitPushWithScope(scope.get());
3364     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3365         generator.emitLoad(dst, jsUndefined());
3366     generator.emitNodeInTailPosition(dst, m_statement);
3367     generator.emitPopWithScope();
3368 }
3369 
3370 // ------------------------------ CaseClauseNode --------------------------------
3371 
3372 inline void CaseClauseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3373 {
</pre>
<hr />
<pre>
3565     if (dst == generator.ignoredResult())
3566         dst = 0;
3567     RefPtr&lt;RegisterID&gt; expr = generator.emitNode(m_expr);
3568     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3569     generator.emitThrow(expr.get());
3570 
3571     generator.emitProfileControlFlow(endOffset());
3572 }
3573 
3574 // ------------------------------ TryNode --------------------------------------
3575 
3576 void TryNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3577 {
3578     // NOTE: The catch and finally blocks must be labeled explicitly, so the
3579     // optimizer knows they may be jumped to from anywhere.
3580 
3581     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_tryBlock-&gt;hasEarlyBreakOrContinue())
3582         generator.emitLoad(dst, jsUndefined());
3583 
3584     ASSERT(m_catchBlock || m_finallyBlock);
<span class="line-removed">3585     BytecodeGenerator::CompletionRecordScope completionRecordScope(generator, m_finallyBlock);</span>
3586 
3587     RefPtr&lt;Label&gt; catchLabel;
3588     RefPtr&lt;Label&gt; catchEndLabel;
<span class="line-removed">3589     RefPtr&lt;Label&gt; finallyViaThrowLabel;</span>
3590     RefPtr&lt;Label&gt; finallyLabel;
3591     RefPtr&lt;Label&gt; finallyEndLabel;
<span class="line-modified">3592 </span>
<span class="line-removed">3593     Ref&lt;Label&gt; tryStartLabel = generator.newLabel();</span>
<span class="line-removed">3594     generator.emitLabel(tryStartLabel.get());</span>
3595 
3596     if (m_finallyBlock) {
<span class="line-removed">3597         finallyViaThrowLabel = generator.newLabel();</span>
3598         finallyLabel = generator.newLabel();
3599         finallyEndLabel = generator.newLabel();
3600 
<span class="line-modified">3601         generator.pushFinallyControlFlowScope(*finallyLabel);</span>

3602     }
3603     if (m_catchBlock) {
3604         catchLabel = generator.newLabel();
3605         catchEndLabel = generator.newLabel();
3606     }
3607 
<span class="line-modified">3608     Label&amp; tryHandlerLabel = m_catchBlock ? *catchLabel : *finallyViaThrowLabel;</span>

3609     HandlerType tryHandlerType = m_catchBlock ? HandlerType::Catch : HandlerType::Finally;
<span class="line-modified">3610     TryData* tryData = generator.pushTry(tryStartLabel.get(), tryHandlerLabel, tryHandlerType);</span>
3611     TryData* finallyTryData = nullptr;
3612     if (!m_catchBlock &amp;&amp; m_finallyBlock)
3613         finallyTryData = tryData;
3614 
3615     generator.emitNode(dst, m_tryBlock);
3616 
3617     if (m_finallyBlock)
3618         generator.emitJump(*finallyLabel);
3619     else
3620         generator.emitJump(*catchEndLabel);
3621 
<span class="line-modified">3622     Ref&lt;Label&gt; endTryLabel = generator.newEmittedLabel();</span>
<span class="line-modified">3623     generator.popTry(tryData, endTryLabel.get());</span>
3624 
3625     if (m_catchBlock) {
3626         // Uncaught exception path: the catch block.
3627         generator.emitLabel(*catchLabel);
3628         RefPtr&lt;RegisterID&gt; thrownValueRegister = generator.newTemporary();
<span class="line-modified">3629         RegisterID* unused = generator.newTemporary();</span>
<span class="line-modified">3630         generator.emitCatch(unused, thrownValueRegister.get(), tryData);</span>
3631         generator.restoreScopeRegister();
3632 
3633         if (m_finallyBlock) {
3634             // If the catch block throws an exception and we have a finally block, then the finally
3635             // block should &quot;catch&quot; that exception.
<span class="line-modified">3636             finallyTryData = generator.pushTry(*catchLabel, *finallyViaThrowLabel, HandlerType::Finally);</span>
3637         }
3638 
3639         if (m_catchPattern) {
3640             generator.emitPushCatchScope(m_lexicalVariables);
3641             m_catchPattern-&gt;bindValue(generator, thrownValueRegister.get());
3642         }
3643 
3644         generator.emitProfileControlFlow(m_tryBlock-&gt;endOffset() + 1);
3645         if (m_finallyBlock)
3646             generator.emitNode(dst, m_catchBlock);
3647         else
3648             generator.emitNodeInTailPosition(dst, m_catchBlock);
3649         generator.emitLoad(thrownValueRegister.get(), jsUndefined());
3650 
3651         if (m_catchPattern)
3652             generator.emitPopCatchScope(m_lexicalVariables);
3653 
3654         if (m_finallyBlock) {
<span class="line-modified">3655             generator.emitSetCompletionType(CompletionType::Normal);</span>
3656             generator.emitJump(*finallyLabel);
<span class="line-modified">3657             generator.popTry(finallyTryData, *finallyViaThrowLabel);</span>
3658         }
3659 
3660         generator.emitLabel(*catchEndLabel);
3661         generator.emitProfileControlFlow(m_catchBlock-&gt;endOffset() + 1);
3662     }
3663 
3664     if (m_finallyBlock) {
<span class="line-modified">3665         FinallyContext finallyContext = generator.popFinallyControlFlowScope();</span>
3666 
<span class="line-modified">3667         // Entry to the finally block for CompletionType::Throw.</span>
<span class="line-modified">3668         generator.emitLabel(*finallyViaThrowLabel);</span>
<span class="line-removed">3669         RegisterID* unused = generator.newTemporary();</span>
<span class="line-removed">3670         generator.emitCatch(generator.completionValueRegister(), unused, finallyTryData);</span>
<span class="line-removed">3671         generator.emitSetCompletionType(CompletionType::Throw);</span>
3672 
3673         // Entry to the finally block for CompletionTypes other than Throw.
3674         generator.emitLabel(*finallyLabel);
3675         generator.restoreScopeRegister();
3676 
<span class="line-removed">3677         RefPtr&lt;RegisterID&gt; savedCompletionTypeRegister = generator.newTemporary();</span>
<span class="line-removed">3678         generator.move(savedCompletionTypeRegister.get(), generator.completionTypeRegister());</span>
<span class="line-removed">3679 </span>
3680         int finallyStartOffset = m_catchBlock ? m_catchBlock-&gt;endOffset() + 1 : m_tryBlock-&gt;endOffset() + 1;
3681         generator.emitProfileControlFlow(finallyStartOffset);
3682         generator.emitNodeInTailPosition(m_finallyBlock);
3683 
<span class="line-modified">3684         generator.emitFinallyCompletion(finallyContext, savedCompletionTypeRegister.get(), *finallyEndLabel);</span>
3685         generator.emitLabel(*finallyEndLabel);
3686         generator.emitProfileControlFlow(m_finallyBlock-&gt;endOffset() + 1);
3687     }
3688 }
3689 
3690 // ------------------------------ ScopeNode -----------------------------
3691 
3692 inline void ScopeNode::emitStatementsBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3693 {
3694     if (!m_statements)
3695         return;
3696     m_statements-&gt;emitBytecode(generator, dst);
3697 }
3698 
3699 static void emitProgramNodeBytecode(BytecodeGenerator&amp; generator, ScopeNode&amp; scopeNode)
3700 {
3701     generator.emitDebugHook(WillExecuteProgram, scopeNode.startLine(), scopeNode.startStartOffset(), scopeNode.startLineStartOffset());
3702 
3703     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3704     generator.emitLoad(dstRegister.get(), jsUndefined());
</pre>
<hr />
<pre>
3724 }
3725 
3726 // ------------------------------ EvalNode -----------------------------
3727 
3728 void EvalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3729 {
3730     generator.emitDebugHook(WillExecuteProgram, startLine(), startStartOffset(), startLineStartOffset());
3731 
3732     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3733     generator.emitLoad(dstRegister.get(), jsUndefined());
3734     emitStatementsBytecode(generator, dstRegister.get());
3735 
3736     generator.emitDebugHook(DidExecuteProgram, lastLine(), startOffset(), lineStartOffset());
3737     generator.emitEnd(dstRegister.get());
3738 }
3739 
3740 // ------------------------------ FunctionNode -----------------------------
3741 
3742 void FunctionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3743 {
<span class="line-modified">3744     if (generator.vm()-&gt;typeProfiler()) {</span>
3745         // If the parameter list is non simple one, it is handled in bindValue&#39;s code.
3746         if (m_parameters-&gt;isSimpleParameterList()) {
3747             for (size_t i = 0; i &lt; m_parameters-&gt;size(); i++) {
3748                 BindingNode* bindingNode = static_cast&lt;BindingNode*&gt;(m_parameters-&gt;at(i).first);
3749                 RegisterID reg(CallFrame::argumentOffset(i));
3750                 generator.emitProfileType(&amp;reg, ProfileTypeBytecodeFunctionArgument, bindingNode-&gt;divotStart(), bindingNode-&gt;divotEnd());
3751             }
3752         }
3753     }
3754 
3755     generator.emitProfileControlFlow(startStartOffset());
3756     generator.emitDebugHook(DidEnterCallFrame, startLine(), startStartOffset(), startLineStartOffset());
3757 
3758     switch (generator.parseMode()) {
3759     case SourceParseMode::GeneratorWrapperFunctionMode:
3760     case SourceParseMode::GeneratorWrapperMethodMode:
3761     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
3762     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
3763         StatementNode* singleStatement = this-&gt;singleStatement();
3764         ASSERT(singleStatement-&gt;isExprStatement());
</pre>
<hr />
<pre>
4288 void ObjectPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4289 {
4290     generator.emitRequireObjectCoercible(rhs, &quot;Right side of assignment cannot be destructured&quot;_s);
4291 
4292     RefPtr&lt;RegisterID&gt; excludedList;
4293     IdentifierSet excludedSet;
4294     RefPtr&lt;RegisterID&gt; addMethod;
4295     if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
4296         auto var = generator.variable(generator.propertyNames().builtinNames().SetPrivateName());
4297 
4298         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4299         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4300         RefPtr&lt;RegisterID&gt; setConstructor = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4301 
4302         CallArguments args(generator, nullptr, 0);
4303         excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
4304 
4305         addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
4306     }
4307 



4308     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4309         const auto&amp; target = m_targetPatterns[i];
4310         if (target.bindingType == BindingType::Element) {
4311             RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4312             RefPtr&lt;RegisterID&gt; propertyName;
4313             if (!target.propertyExpression) {
4314                 Optional&lt;uint32_t&gt; optionalIndex = parseIndex(target.propertyName);
4315                 if (!optionalIndex)
4316                     generator.emitGetById(temp.get(), rhs, target.propertyName);
4317                 else {
4318                     RefPtr&lt;RegisterID&gt; propertyIndex = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
4319                     generator.emitGetByVal(temp.get(), rhs, propertyIndex.get());
4320                 }
4321             } else {
4322                 propertyName = generator.emitNodeForProperty(target.propertyExpression);
4323                 generator.emitGetByVal(temp.get(), rhs, propertyName.get());
4324             }
4325 
4326             if (m_containsRestElement) {
4327                 if (m_containsComputedProperty) {
</pre>
<hr />
<pre>
4350             RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4351             generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4352             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4353 
4354             CallArguments args(generator, nullptr, 3);
4355             generator.emitLoad(args.thisRegister(), jsUndefined());
4356             generator.move(args.argumentRegister(0), newObject.get());
4357             generator.move(args.argumentRegister(1), rhs);
4358             if (m_containsComputedProperty)
4359                 generator.move(args.argumentRegister(2), excludedList.get());
4360             else {
4361                 RefPtr&lt;RegisterID&gt; excludedSetReg = generator.emitLoad(generator.newTemporary(), excludedSet);
4362                 generator.move(args.argumentRegister(2), excludedSetReg.get());
4363             }
4364 
4365             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4366             generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4367             target.pattern-&gt;bindValue(generator, result.get());
4368         }
4369     }


4370 }
4371 
4372 void ObjectPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4373 {
4374     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++)
4375         m_targetPatterns[i].pattern-&gt;collectBoundIdentifiers(identifiers);
4376 }
4377 
4378 void BindingNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4379 {
4380     Variable var = generator.variable(m_boundProperty);
4381     bool isReadOnly = var.isReadOnly() &amp;&amp; m_bindingContext != AssignmentContext::ConstDeclarationStatement;
4382     if (RegisterID* local = var.local()) {
4383         if (m_bindingContext == AssignmentContext::AssignmentExpression)
4384             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4385         if (isReadOnly) {
4386             generator.emitReadOnlyExceptionIfNeeded(var);
4387             return;
4388         }
4389         generator.move(local, value);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2 *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
   3 *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4 *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5 *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6 *  Copyright (C) 2007 Maks Orlovich
   7 *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2012 Igalia, S.L.
   9 *
  10 *  This library is free software; you can redistribute it and/or
  11 *  modify it under the terms of the GNU Library General Public
  12 *  License as published by the Free Software Foundation; either
  13 *  version 2 of the License, or (at your option) any later version.
  14 *
  15 *  This library is distributed in the hope that it will be useful,
  16 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  17 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18 *  Library General Public License for more details.
  19 *
  20 *  You should have received a copy of the GNU Library General Public License
  21 *  along with this library; see the file COPYING.LIB.  If not, write to
  22 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23 *  Boston, MA 02110-1301, USA.
  24 *
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;NodeConstructors.h&quot;
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;JIT.h&quot;
  35 #include &quot;JSCInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSGeneratorFunction.h&quot;
  38 #include &quot;JSGlobalObject.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 #include &quot;LabelScope.h&quot;
  41 #include &quot;Lexer.h&quot;
  42 #include &quot;Parser.h&quot;
  43 #include &quot;StackAlignment.h&quot;
<span class="line-added">  44 #include &quot;UnlinkedMetadataTableInlines.h&quot;</span>
<span class="line-added">  45 #include &quot;YarrFlags.h&quot;</span>
  46 #include &lt;wtf/Assertions.h&gt;
  47 #include &lt;wtf/Threading.h&gt;
  48 #include &lt;wtf/text/StringBuilder.h&gt;
  49 
  50 namespace JSC {
  51 
  52 /*
  53     Details of the emitBytecode function.
  54 
  55     Return value: The register holding the production&#39;s value.
  56              dst: An optional parameter specifying the most efficient destination at
  57                   which to store the production&#39;s value. The callee must honor dst.
  58 
  59     The dst argument provides for a crude form of copy propagation. For example,
  60 
  61         x = 1
  62 
  63     becomes
  64 
  65         load r[x], 1
</pre>
<hr />
<pre>
 126 JSValue BigIntNode::jsValue(BytecodeGenerator&amp; generator) const
 127 {
 128     return generator.addBigIntConstant(m_value, m_radix, m_sign);
 129 }
 130 
 131 // ------------------------------ NumberNode ----------------------------------
 132 
 133 RegisterID* NumberNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 134 {
 135     if (dst == generator.ignoredResult())
 136         return nullptr;
 137     return generator.emitLoad(dst, jsValue(generator), isIntegerNode() ? SourceCodeRepresentation::Integer : SourceCodeRepresentation::Double);
 138 }
 139 
 140 // ------------------------------ RegExpNode -----------------------------------
 141 
 142 RegisterID* RegExpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 143 {
 144     if (dst == generator.ignoredResult())
 145         return nullptr;
<span class="line-modified"> 146 </span>
<span class="line-added"> 147     auto flags = Yarr::parseFlags(m_flags.string());</span>
<span class="line-added"> 148     ASSERT(flags.hasValue());</span>
<span class="line-added"> 149     RegExp* regExp = RegExp::create(generator.vm(), m_pattern.string(), flags.value());</span>
 150     if (regExp-&gt;isValid())
 151         return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
<span class="line-added"> 152 </span>
 153     const char* messageCharacters = regExp-&gt;errorMessage();
 154     const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
 155     generator.emitThrowStaticError(ErrorType::SyntaxError, message);
 156     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
 157 }
 158 
 159 // ------------------------------ ThisNode -------------------------------------
 160 
 161 RegisterID* ThisNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 162 {
 163     generator.ensureThis();
 164     if (dst == generator.ignoredResult())
 165         return 0;
 166 
 167     RegisterID* result = generator.move(dst, generator.thisRegister());
 168     static const unsigned thisLength = 4;
 169     generator.emitProfileType(generator.thisRegister(), position(), JSTextPosition(-1, position().offset + thisLength, -1));
 170     return result;
 171 }
 172 
</pre>
<hr />
<pre>
 393 {
 394     bool hadVariableExpression = false;
 395     unsigned length = 0;
 396 
 397     IndexingType recommendedIndexingType = ArrayWithUndecided;
 398     ElementNode* firstPutElement;
 399     for (firstPutElement = m_element; firstPutElement; firstPutElement = firstPutElement-&gt;next()) {
 400         if (firstPutElement-&gt;elision() || firstPutElement-&gt;value()-&gt;isSpreadExpression())
 401             break;
 402         if (!firstPutElement-&gt;value()-&gt;isConstant())
 403             hadVariableExpression = true;
 404         else
 405             recommendedIndexingType = leastUpperBoundOfIndexingTypeAndValue(recommendedIndexingType, static_cast&lt;ConstantNode*&gt;(firstPutElement-&gt;value())-&gt;jsValue(generator));
 406 
 407         ++length;
 408     }
 409 
 410     auto newArray = [&amp;] (RegisterID* dst, ElementNode* elements, unsigned length, bool hadVariableExpression) {
 411         if (length &amp;&amp; !hadVariableExpression) {
 412             recommendedIndexingType |= CopyOnWrite;
<span class="line-modified"> 413             ASSERT(generator.vm().heap.isDeferred()); // We run bytecode generator under a DeferGC. If we stopped doing that, we&#39;d need to put a DeferGC here as we filled in these slots.</span>
<span class="line-modified"> 414             auto* array = JSImmutableButterfly::create(generator.vm(), recommendedIndexingType, length);</span>
 415             unsigned index = 0;
 416             for (ElementNode* element = elements; index &lt; length; element = element-&gt;next()) {
 417                 ASSERT(element-&gt;value()-&gt;isConstant());
<span class="line-modified"> 418                 array-&gt;setIndex(generator.vm(), index++, static_cast&lt;ConstantNode*&gt;(element-&gt;value())-&gt;jsValue(generator));</span>
 419             }
 420             return generator.emitNewArrayBuffer(dst, array, recommendedIndexingType);
 421         }
 422         return generator.emitNewArray(dst, elements, length, recommendedIndexingType);
 423     };
 424 
 425     if (!firstPutElement &amp;&amp; !m_elision)
 426         return newArray(generator.finalDestination(dst), m_element, length, hadVariableExpression);
 427 
 428     if (firstPutElement &amp;&amp; firstPutElement-&gt;value()-&gt;isSpreadExpression()) {
 429         bool hasElision = m_elision;
 430         if (!hasElision) {
 431             for (ElementNode* node = firstPutElement; node; node = node-&gt;next()) {
 432                 if (node-&gt;elision()) {
 433                     hasElision = true;
 434                     break;
 435                 }
 436             }
 437         }
 438 
</pre>
<hr />
<pre>
 727         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 728         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
 729 
 730         if (isNonIndexStringElement(*m_subscript)) {
 731             const Identifier&amp; id = static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value();
 732             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 733             generator.emitGetById(finalDest.get(), superBase.get(), thisValue.get(), id);
 734         } else  {
 735             RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(m_subscript);
 736             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 737             generator.emitGetByVal(finalDest.get(), superBase.get(), thisValue.get(), subscript.get());
 738         }
 739 
 740         generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 741         return finalDest.get();
 742     }
 743 
 744     RegisterID* ret;
 745     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 746 
<span class="line-modified"> 747     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);</span>
<span class="line-modified"> 748     RefPtr&lt;RegisterID&gt; base = subscriptIsNonIndexString</span>
<span class="line-added"> 749         ? generator.emitNode(m_base)</span>
<span class="line-added"> 750         : generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added"> 753         generator.emitOptionalCheck(base.get());</span>
<span class="line-added"> 754 </span>
<span class="line-added"> 755     if (subscriptIsNonIndexString) {</span>
 756         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 757         ret = generator.emitGetById(finalDest.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
 758     } else {

 759         RegisterID* property = generator.emitNodeForProperty(m_subscript);
 760         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 761         ret = generator.emitGetByVal(finalDest.get(), base.get(), property);
 762     }
 763 
 764     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 765     return ret;
 766 }
 767 
 768 // ------------------------------ DotAccessorNode --------------------------------
 769 
 770 RegisterID* DotAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 771 {
<span class="line-added"> 772     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
 773     bool baseIsSuper = m_base-&gt;isSuperNode();
<span class="line-modified"> 774 </span>
<span class="line-added"> 775     RefPtr&lt;RegisterID&gt; base;</span>
<span class="line-added"> 776     if (baseIsSuper)</span>
<span class="line-added"> 777         base = emitSuperBaseForCallee(generator);</span>
<span class="line-added"> 778     else {</span>
<span class="line-added"> 779         base = generator.emitNode(m_base);</span>
<span class="line-added"> 780         if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added"> 781             generator.emitOptionalCheck(base.get());</span>
<span class="line-added"> 782     }</span>
<span class="line-added"> 783 </span>
 784     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());

 785     RegisterID* ret;
 786     if (baseIsSuper) {
 787         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
<span class="line-modified"> 788         ret = generator.emitGetById(finalDest.get(), base.get(), thisValue.get(), m_ident);</span>
 789     } else
<span class="line-modified"> 790         ret = generator.emitGetById(finalDest.get(), base.get(), m_ident);</span>
<span class="line-modified"> 791     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());</span>
 792     return ret;
 793 }
 794 
 795 // ------------------------------ ArgumentListNode -----------------------------
 796 
 797 RegisterID* ArgumentListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 798 {
 799     ASSERT(m_expr);
 800     return generator.emitNode(dst, m_expr);
 801 }
 802 
 803 // ------------------------------ NewExprNode ----------------------------------
 804 
 805 RegisterID* NewExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 806 {
 807     ExpectedFunction expectedFunction;
 808     if (m_expr-&gt;isResolveNode())
 809         expectedFunction = generator.expectedFunctionForIdentifier(static_cast&lt;ResolveNode*&gt;(m_expr)-&gt;identifier());
 810     else
 811         expectedFunction = NoExpectedFunction;
</pre>
<hr />
<pre>
 846 // ------------------------------ EvalFunctionCallNode ----------------------------------
 847 
 848 RegisterID* EvalFunctionCallNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 849 {
 850     // We need try to load &#39;this&#39; before call eval in constructor, because &#39;this&#39; can created by &#39;super&#39; in some of the arrow function
 851     // var A = class A {
 852     //   constructor () { this.id = &#39;A&#39;; }
 853     // }
 854     //
 855     // var B = class B extend A {
 856     //    constructor () {
 857     //       var arrow = () =&gt; super();
 858     //       arrow();
 859     //       eval(&quot;this.id = &#39;B&#39;&quot;);
 860     //    }
 861     // }
 862     if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isThisUsedInInnerArrowFunction())
 863         generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 864 
 865     Variable var = generator.variable(generator.propertyNames().eval);
<span class="line-modified"> 866     RefPtr&lt;RegisterID&gt; local = var.local();</span>
<span class="line-modified"> 867     RefPtr&lt;RegisterID&gt; func;</span>
<span class="line-modified"> 868     if (local) {</span>
<span class="line-modified"> 869         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);</span>
<span class="line-added"> 870         func = generator.move(generator.tempDestination(dst), local.get());</span>
<span class="line-added"> 871     } else</span>
<span class="line-added"> 872         func = generator.newTemporary();</span>
<span class="line-added"> 873     CallArguments callArguments(generator, m_args);</span>
<span class="line-added"> 874 </span>
<span class="line-added"> 875     if (local)</span>
 876         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
<span class="line-modified"> 877     else {</span>
<span class="line-added"> 878         JSTextPosition newDivot = divotStart() + 4;</span>
<span class="line-added"> 879         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-added"> 880         generator.move(</span>
<span class="line-added"> 881             callArguments.thisRegister(),</span>
<span class="line-added"> 882             generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-added"> 883         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-added"> 884         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
 885     }
 886 
<span class="line-modified"> 887     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());</span>
<span class="line-modified"> 888     if (isOptionalChainBase())</span>
<span class="line-modified"> 889         generator.emitOptionalCheck(func.get());</span>
<span class="line-modified"> 890 </span>
<span class="line-modified"> 891     return generator.emitCallEval(returnValue.get(), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>





 892 }
 893 
 894 // ------------------------------ FunctionCallValueNode ----------------------------------
 895 
 896 RegisterID* FunctionCallValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 897 {
 898     if (m_expr-&gt;isSuperNode()) {
 899         RefPtr&lt;RegisterID&gt; func = emitGetSuperFunctionForConstruct(generator);
 900         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 901         CallArguments callArguments(generator, m_args);
 902 
 903         ASSERT(generator.isConstructor() || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 904         ASSERT(generator.constructorKind() == ConstructorKind::Extends || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 905         RegisterID* ret = generator.emitConstruct(returnValue.get(), func.get(), generator.newTarget(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd());
 906 
 907         bool isConstructorKindDerived = generator.constructorKind() == ConstructorKind::Extends;
 908         bool doWeUseArrowFunctionInConstructor = isConstructorKindDerived &amp;&amp; generator.needsToUpdateArrowFunctionContext();
 909 
 910         if (generator.isDerivedConstructorContext() || (doWeUseArrowFunctionInConstructor &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction()))
 911             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 912 
 913         Ref&lt;Label&gt; thisIsEmptyLabel = generator.newLabel();
 914         generator.emitJumpIfTrue(generator.emitIsEmpty(generator.newTemporary(), generator.thisRegister()), thisIsEmptyLabel.get());
 915         generator.emitThrowReferenceError(&quot;&#39;super()&#39; can&#39;t be called more than once in a constructor.&quot;_s);
 916         generator.emitLabel(thisIsEmptyLabel.get());
 917 
 918         generator.move(generator.thisRegister(), ret);
 919 
 920         if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
 921             generator.emitPutThisToArrowFunctionContextScope();
 922 
 923         return ret;
 924     }
<span class="line-added"> 925 </span>
 926     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 927     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<span class="line-added"> 928     if (isOptionalChainBase())</span>
<span class="line-added"> 929         generator.emitOptionalCheck(func.get());</span>
<span class="line-added"> 930 </span>
 931     CallArguments callArguments(generator, m_args);
 932     generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 933     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 934     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 935     return ret;
 936 }
 937 
 938 // ------------------------------ FunctionCallResolveNode ----------------------------------
 939 
 940 RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 941 {
<span class="line-modified"> 942     if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName())) {</span>
 943         if (ASSERT_DISABLED)
 944             return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
 945     }
 946 
 947     ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
 948 
 949     Variable var = generator.variable(m_ident);
<span class="line-modified"> 950     RefPtr&lt;RegisterID&gt; local = var.local();</span>
<span class="line-modified"> 951     RefPtr&lt;RegisterID&gt; func;</span>
<span class="line-modified"> 952     if (local) {</span>
<span class="line-modified"> 953         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);</span>
<span class="line-modified"> 954         func = generator.move(generator.tempDestination(dst), local.get());</span>
<span class="line-added"> 955     } else</span>
<span class="line-added"> 956         func = generator.newTemporary();</span>
<span class="line-added"> 957     CallArguments callArguments(generator, m_args);</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959     if (local) {</span>
 960         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 961         // This passes NoExpectedFunction because we expect that if the function is in a
 962         // local variable, then it&#39;s not one of our built-in constructors.
<span class="line-modified"> 963         expectedFunction = NoExpectedFunction;</span>
<span class="line-modified"> 964     } else {</span>
<span class="line-modified"> 965         JSTextPosition newDivot = divotStart() + m_ident.length();</span>
<span class="line-added"> 966         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-added"> 967         generator.move(</span>
<span class="line-added"> 968             callArguments.thisRegister(),</span>
<span class="line-added"> 969             generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-added"> 970         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-added"> 971         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
 972     }
 973 

 974     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<span class="line-modified"> 975     if (isOptionalChainBase())</span>
<span class="line-added"> 976         generator.emitOptionalCheck(func.get());</span>
 977 







 978     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 979     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 980     return ret;
 981 }
 982 
 983 // ------------------------------ BytecodeIntrinsicNode ----------------------------------
 984 
 985 RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 986 {
 987     return (this-&gt;*m_emitter)(generator, dst);
 988 }
 989 
 990 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
 991 {
 992     ArgumentListNode* node = m_args-&gt;m_listNode;
 993     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
 994     node = node-&gt;m_next;
 995     ASSERT(node-&gt;m_expr-&gt;isString());
 996     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
 997     ASSERT(!node-&gt;m_next);
 998     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), ident);
 999 }
1000 
1001 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1002 {
1003     ArgumentListNode* node = m_args-&gt;m_listNode;
1004     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1005     node = node-&gt;m_next;
1006     ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified">1007     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
1008     ASSERT(symbol);
1009     ASSERT(!node-&gt;m_next);
1010     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
1011 }
1012 
1013 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
1014 {
1015     ArgumentListNode* node = m_args-&gt;m_listNode;
1016     ASSERT(node-&gt;m_expr-&gt;isNumber());
1017     double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
1018     int32_t index = static_cast&lt;int32_t&gt;(value);
1019     ASSERT(value == index);
1020     ASSERT(index &gt;= 0);
1021     ASSERT(!node-&gt;m_next);
1022 
1023     // The body functions of generator and async have different mechanism for arguments.
1024     ASSERT(generator.parseMode() != SourceParseMode::GeneratorBodyMode);
1025     ASSERT(!isAsyncFunctionBodyParseMode(generator.parseMode()));
1026 
1027     return generator.emitGetArgument(generator.finalDestination(dst), index);
</pre>
<hr />
<pre>
1038 {
1039     ArgumentListNode* node = m_args-&gt;m_listNode;
1040     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1041     node = node-&gt;m_next;
1042     ASSERT(node-&gt;m_expr-&gt;isString());
1043     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1044     node = node-&gt;m_next;
1045     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1046 
1047     ASSERT(!node-&gt;m_next);
1048 
1049     return generator.move(dst, generator.emitDirectPutById(base.get(), ident, value.get(), PropertyNode::KnownDirect));
1050 }
1051 
1052 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1053 {
1054     ArgumentListNode* node = m_args-&gt;m_listNode;
1055     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1056     node = node-&gt;m_next;
1057     ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified">1058     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
1059     ASSERT(symbol);
1060     node = node-&gt;m_next;
1061     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1062 
1063     ASSERT(!node-&gt;m_next);
1064 
1065     return generator.move(dst, generator.emitDirectPutById(base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol), value.get(), PropertyNode::KnownDirect));
1066 }
1067 
1068 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByValDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1069 {
1070     ArgumentListNode* node = m_args-&gt;m_listNode;
1071     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1072     node = node-&gt;m_next;
1073     RefPtr&lt;RegisterID&gt; index = generator.emitNodeForProperty(node);
1074     node = node-&gt;m_next;
1075     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1076 
1077     ASSERT(!node-&gt;m_next);
1078 
</pre>
<hr />
<pre>
1157     ArgumentListNode* node = m_args-&gt;m_listNode;
1158     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1159     ASSERT(!node-&gt;m_next);
1160 
1161     return generator.move(dst, generator.emitToString(generator.tempDestination(dst), src.get()));
1162 }
1163 
1164 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toObject(BytecodeGenerator&amp; generator, RegisterID* dst)
1165 {
1166     ArgumentListNode* node = m_args-&gt;m_listNode;
1167     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1168     node = node-&gt;m_next;
1169 
1170     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
1171     if (node) {
1172         ASSERT(node-&gt;m_expr-&gt;isString());
1173         const Identifier&amp; message = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1174         ASSERT(!node-&gt;m_next);
1175         return generator.move(dst, generator.emitToObject(temp.get(), src.get(), message));
1176     }
<span class="line-modified">1177     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm().propertyNames-&gt;emptyIdentifier));</span>
1178 }
1179 
1180 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
1181 {
1182     ArgumentListNode* node = m_args-&gt;m_listNode;
1183     RefPtr&lt;RegisterID&gt; idValue = generator.newTemporary();
1184     generator.emitNode(idValue.get(), node);
1185     SpeculatedType speculation = SpecNone;
1186     while (node-&gt;m_next) {
1187         node = node-&gt;m_next;
1188         ASSERT(node-&gt;m_expr-&gt;isString());
1189         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1190         speculation |= speculationFromString(ident.utf8().data());
1191     }
1192 
1193     return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
1194 }
1195 
1196 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isJSArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1197 {
</pre>
<hr />
<pre>
1280 {
1281     ArgumentListNode* node = m_args-&gt;m_listNode;
1282     RefPtr&lt;RegisterID&gt; newObj = generator.emitNode(node);
1283     node = node-&gt;m_next;
1284     RefPtr&lt;RegisterID&gt; propertyNameRegister = generator.emitNode(node);
1285     node = node-&gt;m_next;
1286     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1287     ASSERT(!node-&gt;m_next);
1288 
1289     generator.emitCallDefineProperty(newObj.get(), propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);
1290     return dst;
1291 }
1292 
1293 #define JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS(name) \
1294     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##name(BytecodeGenerator&amp; generator, RegisterID* dst) \
1295     { \
1296         ASSERT(!m_args); \
1297         ASSERT(type() == Type::Constant); \
1298         if (dst == generator.ignoredResult()) \
1299             return nullptr; \
<span class="line-modified">1300         return generator.emitLoad(dst, generator.vm().bytecodeIntrinsicRegistry().name##Value(generator)); \</span>
1301     }
1302     JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS)
1303 #undef JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS
1304 
1305 // ------------------------------ FunctionCallBracketNode ----------------------------------
1306 
1307 RegisterID* FunctionCallBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1308 {
<span class="line-added">1309     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);</span>
<span class="line-added">1310     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());</span>
1311     bool baseIsSuper = m_base-&gt;isSuperNode();
1312     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
1313 
1314     RefPtr&lt;RegisterID&gt; base;
1315     if (baseIsSuper)
1316         base = emitSuperBaseForCallee(generator);
1317     else {
1318         if (subscriptIsNonIndexString)
1319             base = generator.emitNode(m_base);
1320         else
1321             base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
<span class="line-added">1322 </span>
<span class="line-added">1323         if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">1324             generator.emitOptionalCheck(base.get());</span>
1325     }
1326 

1327     RefPtr&lt;RegisterID&gt; thisRegister;
1328     if (baseIsSuper) {
1329         // Note that we only need to do this once because we either have a non-TDZ this or we throw. Once we have a non-TDZ this, we can&#39;t change its value back to TDZ.
1330         thisRegister = generator.ensureThis();
1331     }
1332     if (subscriptIsNonIndexString) {
1333         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1334         if (baseIsSuper)
<span class="line-modified">1335             generator.emitGetById(function.get(), base.get(), thisRegister.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
1336         else
<span class="line-modified">1337             generator.emitGetById(function.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
1338     } else {
1339         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(m_subscript);
1340         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1341         if (baseIsSuper)
<span class="line-modified">1342             generator.emitGetByVal(function.get(), base.get(), thisRegister.get(), property.get());</span>
1343         else
<span class="line-modified">1344             generator.emitGetByVal(function.get(), base.get(), property.get());</span>
1345     }
<span class="line-added">1346     if (isOptionalChainBase())</span>
<span class="line-added">1347         generator.emitOptionalCheck(function.get());</span>
1348 

1349     CallArguments callArguments(generator, m_args);
1350     if (baseIsSuper) {
1351         generator.emitTDZCheck(generator.thisRegister());
1352         generator.move(callArguments.thisRegister(), thisRegister.get());
1353     } else
1354         generator.move(callArguments.thisRegister(), base.get());
1355     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1356     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1357     return ret;
1358 }
1359 
1360 // ------------------------------ FunctionCallDotNode ----------------------------------
1361 
1362 RegisterID* FunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1363 {
1364     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);
1365     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
1366     CallArguments callArguments(generator, m_args);
1367     bool baseIsSuper = m_base-&gt;isSuperNode();
1368     if (baseIsSuper)
1369         generator.move(callArguments.thisRegister(), generator.ensureThis());
<span class="line-modified">1370     else {</span>
1371         generator.emitNode(callArguments.thisRegister(), m_base);
<span class="line-added">1372         if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">1373             generator.emitOptionalCheck(callArguments.thisRegister());</span>
<span class="line-added">1374     }</span>
1375     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1376     if (baseIsSuper) {
1377         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
1378         generator.emitGetById(function.get(), superBase.get(), callArguments.thisRegister(), m_ident);
1379     } else
1380         generator.emitGetById(function.get(), callArguments.thisRegister(), m_ident);
<span class="line-added">1381 </span>
<span class="line-added">1382     if (isOptionalChainBase())</span>
<span class="line-added">1383         generator.emitOptionalCheck(function.get());</span>
<span class="line-added">1384 </span>
1385     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1386     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1387     return ret;
1388 }
1389 
1390 static constexpr size_t maxDistanceToInnermostCallOrApply = 2;
1391 
1392 RegisterID* CallFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1393 {
<span class="line-added">1394     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);</span>
1395     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
<span class="line-added">1396 </span>
<span class="line-added">1397     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">1398         generator.emitOptionalCheck(base.get());</span>
<span class="line-added">1399 </span>
1400     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());


1401 
<span class="line-added">1402     RefPtr&lt;RegisterID&gt; function;</span>
1403     auto makeFunction = [&amp;] {
1404         if (m_base-&gt;isSuperNode()) {
1405             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1406             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().callPublicName());
1407         } else
1408             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().callPublicName());
<span class="line-added">1409 </span>
<span class="line-added">1410         if (isOptionalChainBase())</span>
<span class="line-added">1411             generator.emitOptionalCheck(function.get());</span>
1412     };
1413 
1414     bool emitCallCheck = !generator.isBuiltinFunction();
1415     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1416         makeFunction();
1417         CallArguments callArguments(generator, m_args);
1418         generator.move(callArguments.thisRegister(), base.get());
1419         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1420         generator.move(dst, returnValue.get());
1421         return returnValue.get();
1422     }
1423 
1424     Ref&lt;Label&gt; realCall = generator.newLabel();
1425     Ref&lt;Label&gt; end = generator.newLabel();
1426 
1427     if (emitCallCheck) {
1428         makeFunction();
1429         generator.emitJumpIfNotFunctionCall(function.get(), realCall.get());
1430     }
1431     {
</pre>
<hr />
<pre>
1463         }
1464         generator.emitLabel(end.get());
1465     }
1466     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1467     return returnValue.get();
1468 }
1469 
1470 static bool areTrivialApplyArguments(ArgumentsNode* args)
1471 {
1472     return !args-&gt;m_listNode || !args-&gt;m_listNode-&gt;m_expr || !args-&gt;m_listNode-&gt;m_next
1473         || (!args-&gt;m_listNode-&gt;m_next-&gt;m_next &amp;&amp; args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1474 }
1475 
1476 RegisterID* ApplyFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1477 {
1478     // A few simple cases can be trivially handled as ordinary function calls.
1479     // function.apply(), function.apply(arg) -&gt; identical to function.call
1480     // function.apply(thisArg, [arg0, arg1, ...]) -&gt; can be trivially coerced into function.call(thisArg, arg0, arg1, ...) and saves object allocation
1481     bool mayBeCall = areTrivialApplyArguments(m_args);
1482 


1483     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
<span class="line-added">1484     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>
<span class="line-added">1485 </span>
<span class="line-added">1486     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">1487         generator.emitOptionalCheck(base.get());</span>
<span class="line-added">1488 </span>
<span class="line-added">1489     RefPtr&lt;RegisterID&gt; function;</span>
1490     auto makeFunction = [&amp;] {
1491         if (m_base-&gt;isSuperNode()) {
1492             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1493             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().applyPublicName());
1494         } else
1495             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().applyPublicName());
<span class="line-added">1496 </span>
<span class="line-added">1497         if (isOptionalChainBase())</span>
<span class="line-added">1498             generator.emitOptionalCheck(function.get());</span>
1499     };
1500 
1501     bool emitCallCheck = !generator.isBuiltinFunction();
1502     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1503         makeFunction();
1504         CallArguments callArguments(generator, m_args);
1505         generator.move(callArguments.thisRegister(), base.get());
1506         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1507         generator.move(dst, returnValue.get());
1508         return returnValue.get();
1509     }
1510 
1511     Ref&lt;Label&gt; realCall = generator.newLabel();
1512     Ref&lt;Label&gt; end = generator.newLabel();
1513     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1514     if (emitCallCheck) {
1515         makeFunction();
1516         ASSERT(!m_base-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(m_base)-&gt;identifier() != &quot;Reflect&quot;);
1517         generator.emitJumpIfNotFunctionApply(function.get(), realCall.get());
1518     }
</pre>
<hr />
<pre>
1706     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1707     if (baseIsSuper)
1708         generator.emitPutById(base.get(), thisValue.get(), ident, value.get());
1709     else
1710         generator.emitPutById(base.get(), ident, value.get());
1711     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1712     return generator.move(dst, oldValue);
1713 }
1714 
1715 RegisterID* PostfixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1716 {
1717     if (m_expr-&gt;isResolveNode())
1718         return emitResolve(generator, dst);
1719 
1720     if (m_expr-&gt;isBracketAccessorNode())
1721         return emitBracket(generator, dst);
1722 
1723     if (m_expr-&gt;isDotAccessorNode())
1724         return emitDot(generator, dst);
1725 
<span class="line-added">1726     ASSERT(m_expr-&gt;isFunctionCall());</span>
1727     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1728         ? &quot;Postfix ++ operator applied to value that is not a reference.&quot;_s
1729         : &quot;Postfix -- operator applied to value that is not a reference.&quot;_s);
1730 }
1731 
1732 // ------------------------------ DeleteResolveNode -----------------------------------
1733 
1734 RegisterID* DeleteResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1735 {
1736     Variable var = generator.variable(m_ident);
1737     if (var.local()) {
1738         generator.emitTDZCheckIfNecessary(var, var.local(), nullptr);
1739         return generator.emitLoad(generator.finalDestination(dst), false);
1740     }
1741 
1742     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1743     RefPtr&lt;RegisterID&gt; base = generator.emitResolveScope(dst, var);
1744     generator.emitTDZCheckIfNecessary(var, nullptr, base.get());
1745     return generator.emitDeleteById(generator.finalDestination(dst, base.get()), base.get(), m_ident);
1746 }
1747 
1748 // ------------------------------ DeleteBracketNode -----------------------------------
1749 
1750 RegisterID* DeleteBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1751 {
<span class="line-added">1752     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
1753     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);

1754 
<span class="line-added">1755     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">1756         generator.emitOptionalCheck(r0.get());</span>
<span class="line-added">1757 </span>
<span class="line-added">1758     RefPtr&lt;RegisterID&gt; r1 = generator.emitNode(m_subscript);</span>
1759     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1760     if (m_base-&gt;isSuperNode())
1761         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">1762     return generator.emitDeleteByVal(finalDest.get(), r0.get(), r1.get());</span>
1763 }
1764 
1765 // ------------------------------ DeleteDotNode -----------------------------------
1766 
1767 RegisterID* DeleteDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1768 {
<span class="line-added">1769     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
1770     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
1771 
<span class="line-added">1772     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">1773         generator.emitOptionalCheck(r0.get());</span>
<span class="line-added">1774 </span>
1775     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1776     if (m_base-&gt;isSuperNode())
1777         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">1778     return generator.emitDeleteById(finalDest.get(), r0.get(), m_ident);</span>
1779 }
1780 
1781 // ------------------------------ DeleteValueNode -----------------------------------
1782 
1783 RegisterID* DeleteValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1784 {
1785     generator.emitNode(generator.ignoredResult(), m_expr);
1786 
1787     // delete on a non-location expression ignores the value and returns true
1788     return generator.emitLoad(generator.finalDestination(dst), true);
1789 }
1790 
1791 // ------------------------------ VoidNode -------------------------------------
1792 
1793 RegisterID* VoidNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1794 {
1795     if (dst == generator.ignoredResult()) {
1796         generator.emitNode(generator.ignoredResult(), m_expr);
1797         return 0;
1798     }
</pre>
<hr />
<pre>
1830     }
1831     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1832     return generator.emitTypeOf(generator.finalDestination(dst), src.get());
1833 }
1834 
1835 // ------------------------------ PrefixNode ----------------------------------
1836 
1837 RegisterID* PrefixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1838 {
1839     ASSERT(m_expr-&gt;isResolveNode());
1840     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1841     const Identifier&amp; ident = resolve-&gt;identifier();
1842 
1843     Variable var = generator.variable(ident);
1844     if (RegisterID* local = var.local()) {
1845         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1846         RefPtr&lt;RegisterID&gt; localReg = local;
1847         if (var.isReadOnly()) {
1848             generator.emitReadOnlyExceptionIfNeeded(var);
1849             localReg = generator.move(generator.tempDestination(dst), localReg.get());
<span class="line-modified">1850         } else if (generator.shouldEmitTypeProfilerHooks()) {</span>
1851             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
1852             generator.move(tempDst.get(), localReg.get());
1853             emitIncOrDec(generator, tempDst.get(), m_operator);
1854             generator.move(localReg.get(), tempDst.get());
1855             generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
1856             return generator.move(dst, tempDst.get());
1857         }
1858         emitIncOrDec(generator, localReg.get(), m_operator);
1859         return generator.move(dst, localReg.get());
1860     }
1861 
1862     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1863     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
1864     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
1865     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1866     if (var.isReadOnly()) {
1867         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
1868         if (threwException)
1869             return value.get();
1870     }
</pre>
<hr />
<pre>
1928     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1929     if (baseNode-&gt;isSuperNode())
1930         generator.emitPutById(base.get(), thisValue.get(), ident, value);
1931     else
1932         generator.emitPutById(base.get(), ident, value);
1933     generator.emitProfileType(value, divotStart(), divotEnd());
1934     return generator.move(dst, propDst.get());
1935 }
1936 
1937 RegisterID* PrefixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1938 {
1939     if (m_expr-&gt;isResolveNode())
1940         return emitResolve(generator, dst);
1941 
1942     if (m_expr-&gt;isBracketAccessorNode())
1943         return emitBracket(generator, dst);
1944 
1945     if (m_expr-&gt;isDotAccessorNode())
1946         return emitDot(generator, dst);
1947 
<span class="line-added">1948     ASSERT(m_expr-&gt;isFunctionCall());</span>
1949     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1950         ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
1951         : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
1952 }
1953 
1954 // ------------------------------ Unary Operation Nodes -----------------------------------
1955 
1956 RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1957 {
1958     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1959     generator.emitExpressionInfo(position(), position(), position());
1960     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), OperandTypes(m_expr-&gt;resultDescriptor()));
1961 }
1962 
1963 // ------------------------------ UnaryPlusNode -----------------------------------
1964 
1965 RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1966 {
1967     ASSERT(opcodeID() == op_to_number);
1968     RefPtr&lt;RegisterID&gt; src = generator.emitNode(expr());
</pre>
<hr />
<pre>
2307 }
2308 
2309 RegisterID* InstanceOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2310 {
2311     RefPtr&lt;RegisterID&gt; hasInstanceValue = generator.newTemporary();
2312     RefPtr&lt;RegisterID&gt; isObject = generator.newTemporary();
2313     RefPtr&lt;RegisterID&gt; isCustom = generator.newTemporary();
2314     RefPtr&lt;RegisterID&gt; prototype = generator.newTemporary();
2315     RefPtr&lt;RegisterID&gt; value = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2316     RefPtr&lt;RegisterID&gt; constructor = generator.emitNode(m_expr2);
2317     RefPtr&lt;RegisterID&gt; dstReg = generator.finalDestination(dst, value.get());
2318     Ref&lt;Label&gt; custom = generator.newLabel();
2319     Ref&lt;Label&gt; done = generator.newLabel();
2320     Ref&lt;Label&gt; typeError = generator.newLabel();
2321 
2322     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2323     generator.emitIsObject(isObject.get(), constructor.get());
2324     generator.emitJumpIfFalse(isObject.get(), typeError.get());
2325 
2326     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">2327     generator.emitGetById(hasInstanceValue.get(), constructor.get(), generator.vm().propertyNames-&gt;hasInstanceSymbol);</span>
2328 
2329     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2330     generator.emitOverridesHasInstance(isCustom.get(), constructor.get(), hasInstanceValue.get());
2331 
2332     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2333     generator.emitJumpIfTrue(isCustom.get(), custom.get());
2334 
2335     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">2336     generator.emitGetById(prototype.get(), constructor.get(), generator.vm().propertyNames-&gt;prototype);</span>
2337 
2338     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2339     generator.emitInstanceOf(dstReg.get(), value.get(), prototype.get());
2340 
2341     generator.emitJump(done.get());
2342 
2343     generator.emitLabel(typeError.get());
2344     generator.emitThrowTypeError(&quot;Right hand side of instanceof is not an object&quot;);
2345 
2346     generator.emitLabel(custom.get());
2347 
2348     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2349     generator.emitInstanceOfCustom(dstReg.get(), value.get(), constructor.get(), hasInstanceValue.get());
2350 
2351     generator.emitLabel(done.get());
2352 
2353     return dstReg.get();
2354 }
2355 
2356 // ------------------------------ InNode ----------------------------
</pre>
<hr />
<pre>
2386     generator.emitLabel(target.get());
2387 
2388     return generator.move(dst, temp.get());
2389 }
2390 
2391 void LogicalOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2392 {
2393     if (UNLIKELY(needsDebugHook()))
2394         generator.emitDebugHook(this);
2395 
2396     Ref&lt;Label&gt; afterExpr1 = generator.newLabel();
2397     if (m_operator == OpLogicalAnd)
2398         generator.emitNodeInConditionContext(m_expr1, afterExpr1.get(), falseTarget, FallThroughMeansTrue);
2399     else
2400         generator.emitNodeInConditionContext(m_expr1, trueTarget, afterExpr1.get(), FallThroughMeansFalse);
2401     generator.emitLabel(afterExpr1.get());
2402 
2403     generator.emitNodeInConditionContext(m_expr2, trueTarget, falseTarget, fallThroughMode);
2404 }
2405 
<span class="line-added">2406 // ------------------------------ CoalesceNode ----------------------------</span>
<span class="line-added">2407 </span>
<span class="line-added">2408 RegisterID* CoalesceNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">2409 {</span>
<span class="line-added">2410     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);</span>
<span class="line-added">2411     Ref&lt;Label&gt; endLabel = generator.newLabel();</span>
<span class="line-added">2412 </span>
<span class="line-added">2413     if (m_hasAbsorbedOptionalChain)</span>
<span class="line-added">2414         generator.pushOptionalChainTarget();</span>
<span class="line-added">2415     generator.emitNode(temp.get(), m_expr1);</span>
<span class="line-added">2416     generator.emitJumpIfFalse(generator.emitIsUndefinedOrNull(generator.newTemporary(), temp.get()), endLabel.get());</span>
<span class="line-added">2417 </span>
<span class="line-added">2418     if (m_hasAbsorbedOptionalChain)</span>
<span class="line-added">2419         generator.popOptionalChainTarget();</span>
<span class="line-added">2420     generator.emitNodeInTailPosition(temp.get(), m_expr2);</span>
<span class="line-added">2421 </span>
<span class="line-added">2422     generator.emitLabel(endLabel.get());</span>
<span class="line-added">2423     return generator.move(dst, temp.get());</span>
<span class="line-added">2424 }</span>
<span class="line-added">2425 </span>
<span class="line-added">2426 // ------------------------------ OptionalChainNode ----------------------------</span>
<span class="line-added">2427 </span>
<span class="line-added">2428 RegisterID* OptionalChainNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">2429 {</span>
<span class="line-added">2430     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
<span class="line-added">2431 </span>
<span class="line-added">2432     if (m_isOutermost)</span>
<span class="line-added">2433         generator.pushOptionalChainTarget();</span>
<span class="line-added">2434     generator.emitNodeInTailPosition(finalDest.get(), m_expr);</span>
<span class="line-added">2435     if (m_isOutermost)</span>
<span class="line-added">2436         generator.popOptionalChainTarget(finalDest.get(), m_expr-&gt;isDeleteNode());</span>
<span class="line-added">2437 </span>
<span class="line-added">2438     return finalDest.get();</span>
<span class="line-added">2439 }</span>
<span class="line-added">2440 </span>
2441 // ------------------------------ ConditionalNode ------------------------------
2442 
2443 RegisterID* ConditionalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2444 {
2445     RefPtr&lt;RegisterID&gt; newDst = generator.finalDestination(dst);
2446     Ref&lt;Label&gt; beforeElse = generator.newLabel();
2447     Ref&lt;Label&gt; afterElse = generator.newLabel();
2448 
2449     Ref&lt;Label&gt; beforeThen = generator.newLabel();
2450     generator.emitNodeInConditionContext(m_logical, beforeThen.get(), beforeElse.get(), FallThroughMeansTrue);
2451     generator.emitLabel(beforeThen.get());
2452 
2453     generator.emitProfileControlFlow(m_expr1-&gt;startOffset());
2454     generator.emitNodeInTailPosition(newDst.get(), m_expr1);
2455     generator.emitJump(afterElse.get());
2456 
2457     generator.emitLabel(beforeElse.get());
2458     generator.emitProfileControlFlow(m_expr1-&gt;endOffset() + 1);
2459     generator.emitNodeInTailPosition(newDst.get(), m_expr2);
2460 
</pre>
<hr />
<pre>
2811 
2812 void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2813 {
2814     ASSERT(m_expr);
2815     generator.emitNode(dst, m_expr);
2816 }
2817 
2818 // ------------------------------ DeclarationStatement ----------------------------
2819 
2820 void DeclarationStatement::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2821 {
2822     ASSERT(m_expr);
2823     generator.emitNode(m_expr);
2824 }
2825 
2826 // ------------------------------ EmptyVarExpression ----------------------------
2827 
2828 RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2829 {
2830     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
<span class="line-modified">2831     if (!generator.shouldEmitTypeProfilerHooks())</span>
2832         return nullptr;
2833 
2834     Variable var = generator.variable(m_ident);
2835     if (RegisterID* local = var.local())
2836         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2837     else {
2838         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2839         RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
2840         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2841     }
2842 
2843     return nullptr;
2844 }
2845 
2846 // ------------------------------ EmptyLetExpression ----------------------------
2847 
2848 RegisterID* EmptyLetExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2849 {
2850     // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
2851     // get TDZ errors for situations like this: `let x; x;`
</pre>
<hr />
<pre>
3441         dst = 0;
3442 
3443     RefPtr&lt;RegisterID&gt; returnRegister = m_value ? generator.emitNodeInTailPosition(dst, m_value) : generator.emitLoad(dst, jsUndefined());
3444 
3445     generator.emitProfileType(returnRegister.get(), ProfileTypeBytecodeFunctionReturnStatement, divotStart(), divotEnd());
3446 
3447     bool hasFinally = generator.emitReturnViaFinallyIfNeeded(returnRegister.get());
3448     if (!hasFinally) {
3449         if (generator.parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
3450             returnRegister = generator.move(generator.newTemporary(), returnRegister.get());
3451             generator.emitAwait(returnRegister.get());
3452         }
3453 
3454         generator.emitWillLeaveCallFrameDebugHook();
3455         generator.emitReturn(returnRegister.get());
3456     }
3457 
3458     generator.emitProfileControlFlow(endOffset());
3459     // Emitting an unreachable return here is needed in case this op_profile_control_flow is the
3460     // last opcode in a CodeBlock because a CodeBlock&#39;s instructions must end with a terminal opcode.
<span class="line-modified">3461     if (generator.shouldEmitControlFlowProfilerHooks())</span>
3462         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3463 }
3464 
3465 // ------------------------------ WithNode -------------------------------------
3466 
3467 void WithNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3468 {
3469     RefPtr&lt;RegisterID&gt; scope = generator.emitNode(m_expr);
3470     generator.emitExpressionInfo(m_divot, m_divot - m_expressionLength, m_divot);
3471     generator.emitPushWithScope(scope.get());
3472     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3473         generator.emitLoad(dst, jsUndefined());
3474     generator.emitNodeInTailPosition(dst, m_statement);
3475     generator.emitPopWithScope();
3476 }
3477 
3478 // ------------------------------ CaseClauseNode --------------------------------
3479 
3480 inline void CaseClauseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3481 {
</pre>
<hr />
<pre>
3673     if (dst == generator.ignoredResult())
3674         dst = 0;
3675     RefPtr&lt;RegisterID&gt; expr = generator.emitNode(m_expr);
3676     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3677     generator.emitThrow(expr.get());
3678 
3679     generator.emitProfileControlFlow(endOffset());
3680 }
3681 
3682 // ------------------------------ TryNode --------------------------------------
3683 
3684 void TryNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3685 {
3686     // NOTE: The catch and finally blocks must be labeled explicitly, so the
3687     // optimizer knows they may be jumped to from anywhere.
3688 
3689     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_tryBlock-&gt;hasEarlyBreakOrContinue())
3690         generator.emitLoad(dst, jsUndefined());
3691 
3692     ASSERT(m_catchBlock || m_finallyBlock);

3693 
3694     RefPtr&lt;Label&gt; catchLabel;
3695     RefPtr&lt;Label&gt; catchEndLabel;

3696     RefPtr&lt;Label&gt; finallyLabel;
3697     RefPtr&lt;Label&gt; finallyEndLabel;
<span class="line-modified">3698     Optional&lt;FinallyContext&gt; finallyContext;</span>


3699 
3700     if (m_finallyBlock) {

3701         finallyLabel = generator.newLabel();
3702         finallyEndLabel = generator.newLabel();
3703 
<span class="line-modified">3704         finallyContext.emplace(generator, *finallyLabel);</span>
<span class="line-added">3705         generator.pushFinallyControlFlowScope(finallyContext.value());</span>
3706     }
3707     if (m_catchBlock) {
3708         catchLabel = generator.newLabel();
3709         catchEndLabel = generator.newLabel();
3710     }
3711 
<span class="line-modified">3712     Ref&lt;Label&gt; tryLabel = generator.newEmittedLabel();</span>
<span class="line-added">3713     Label&amp; tryHandlerLabel = m_catchBlock ? *catchLabel : *finallyLabel;</span>
3714     HandlerType tryHandlerType = m_catchBlock ? HandlerType::Catch : HandlerType::Finally;
<span class="line-modified">3715     TryData* tryData = generator.pushTry(tryLabel.get(), tryHandlerLabel, tryHandlerType);</span>
3716     TryData* finallyTryData = nullptr;
3717     if (!m_catchBlock &amp;&amp; m_finallyBlock)
3718         finallyTryData = tryData;
3719 
3720     generator.emitNode(dst, m_tryBlock);
3721 
3722     if (m_finallyBlock)
3723         generator.emitJump(*finallyLabel);
3724     else
3725         generator.emitJump(*catchEndLabel);
3726 
<span class="line-modified">3727     Ref&lt;Label&gt; tryEndLabel = generator.newEmittedLabel();</span>
<span class="line-modified">3728     generator.popTry(tryData, tryEndLabel.get());</span>
3729 
3730     if (m_catchBlock) {
3731         // Uncaught exception path: the catch block.
3732         generator.emitLabel(*catchLabel);
3733         RefPtr&lt;RegisterID&gt; thrownValueRegister = generator.newTemporary();
<span class="line-modified">3734         RegisterID* completionTypeRegister = m_finallyBlock ? finallyContext-&gt;completionTypeRegister() : nullptr;</span>
<span class="line-modified">3735         generator.emitOutOfLineCatchHandler(thrownValueRegister.get(), completionTypeRegister, tryData);</span>
3736         generator.restoreScopeRegister();
3737 
3738         if (m_finallyBlock) {
3739             // If the catch block throws an exception and we have a finally block, then the finally
3740             // block should &quot;catch&quot; that exception.
<span class="line-modified">3741             finallyTryData = generator.pushTry(*catchLabel, *finallyLabel, HandlerType::Finally);</span>
3742         }
3743 
3744         if (m_catchPattern) {
3745             generator.emitPushCatchScope(m_lexicalVariables);
3746             m_catchPattern-&gt;bindValue(generator, thrownValueRegister.get());
3747         }
3748 
3749         generator.emitProfileControlFlow(m_tryBlock-&gt;endOffset() + 1);
3750         if (m_finallyBlock)
3751             generator.emitNode(dst, m_catchBlock);
3752         else
3753             generator.emitNodeInTailPosition(dst, m_catchBlock);
3754         generator.emitLoad(thrownValueRegister.get(), jsUndefined());
3755 
3756         if (m_catchPattern)
3757             generator.emitPopCatchScope(m_lexicalVariables);
3758 
3759         if (m_finallyBlock) {
<span class="line-modified">3760             generator.emitLoad(finallyContext-&gt;completionTypeRegister(), CompletionType::Normal);</span>
3761             generator.emitJump(*finallyLabel);
<span class="line-modified">3762             generator.popTry(finallyTryData, *finallyLabel);</span>
3763         }
3764 
3765         generator.emitLabel(*catchEndLabel);
3766         generator.emitProfileControlFlow(m_catchBlock-&gt;endOffset() + 1);
3767     }
3768 
3769     if (m_finallyBlock) {
<span class="line-modified">3770         generator.popFinallyControlFlowScope();</span>
3771 
<span class="line-modified">3772         // Entry to the finally block for CompletionType::Throw to be generated later.</span>
<span class="line-modified">3773         generator.emitOutOfLineFinallyHandler(finallyContext-&gt;completionValueRegister(), finallyContext-&gt;completionTypeRegister(), finallyTryData);</span>



3774 
3775         // Entry to the finally block for CompletionTypes other than Throw.
3776         generator.emitLabel(*finallyLabel);
3777         generator.restoreScopeRegister();
3778 



3779         int finallyStartOffset = m_catchBlock ? m_catchBlock-&gt;endOffset() + 1 : m_tryBlock-&gt;endOffset() + 1;
3780         generator.emitProfileControlFlow(finallyStartOffset);
3781         generator.emitNodeInTailPosition(m_finallyBlock);
3782 
<span class="line-modified">3783         generator.emitFinallyCompletion(finallyContext.value(), *finallyEndLabel);</span>
3784         generator.emitLabel(*finallyEndLabel);
3785         generator.emitProfileControlFlow(m_finallyBlock-&gt;endOffset() + 1);
3786     }
3787 }
3788 
3789 // ------------------------------ ScopeNode -----------------------------
3790 
3791 inline void ScopeNode::emitStatementsBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3792 {
3793     if (!m_statements)
3794         return;
3795     m_statements-&gt;emitBytecode(generator, dst);
3796 }
3797 
3798 static void emitProgramNodeBytecode(BytecodeGenerator&amp; generator, ScopeNode&amp; scopeNode)
3799 {
3800     generator.emitDebugHook(WillExecuteProgram, scopeNode.startLine(), scopeNode.startStartOffset(), scopeNode.startLineStartOffset());
3801 
3802     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3803     generator.emitLoad(dstRegister.get(), jsUndefined());
</pre>
<hr />
<pre>
3823 }
3824 
3825 // ------------------------------ EvalNode -----------------------------
3826 
3827 void EvalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3828 {
3829     generator.emitDebugHook(WillExecuteProgram, startLine(), startStartOffset(), startLineStartOffset());
3830 
3831     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3832     generator.emitLoad(dstRegister.get(), jsUndefined());
3833     emitStatementsBytecode(generator, dstRegister.get());
3834 
3835     generator.emitDebugHook(DidExecuteProgram, lastLine(), startOffset(), lineStartOffset());
3836     generator.emitEnd(dstRegister.get());
3837 }
3838 
3839 // ------------------------------ FunctionNode -----------------------------
3840 
3841 void FunctionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3842 {
<span class="line-modified">3843     if (generator.shouldEmitTypeProfilerHooks()) {</span>
3844         // If the parameter list is non simple one, it is handled in bindValue&#39;s code.
3845         if (m_parameters-&gt;isSimpleParameterList()) {
3846             for (size_t i = 0; i &lt; m_parameters-&gt;size(); i++) {
3847                 BindingNode* bindingNode = static_cast&lt;BindingNode*&gt;(m_parameters-&gt;at(i).first);
3848                 RegisterID reg(CallFrame::argumentOffset(i));
3849                 generator.emitProfileType(&amp;reg, ProfileTypeBytecodeFunctionArgument, bindingNode-&gt;divotStart(), bindingNode-&gt;divotEnd());
3850             }
3851         }
3852     }
3853 
3854     generator.emitProfileControlFlow(startStartOffset());
3855     generator.emitDebugHook(DidEnterCallFrame, startLine(), startStartOffset(), startLineStartOffset());
3856 
3857     switch (generator.parseMode()) {
3858     case SourceParseMode::GeneratorWrapperFunctionMode:
3859     case SourceParseMode::GeneratorWrapperMethodMode:
3860     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
3861     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
3862         StatementNode* singleStatement = this-&gt;singleStatement();
3863         ASSERT(singleStatement-&gt;isExprStatement());
</pre>
<hr />
<pre>
4387 void ObjectPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4388 {
4389     generator.emitRequireObjectCoercible(rhs, &quot;Right side of assignment cannot be destructured&quot;_s);
4390 
4391     RefPtr&lt;RegisterID&gt; excludedList;
4392     IdentifierSet excludedSet;
4393     RefPtr&lt;RegisterID&gt; addMethod;
4394     if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
4395         auto var = generator.variable(generator.propertyNames().builtinNames().SetPrivateName());
4396 
4397         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4398         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4399         RefPtr&lt;RegisterID&gt; setConstructor = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4400 
4401         CallArguments args(generator, nullptr, 0);
4402         excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
4403 
4404         addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
4405     }
4406 
<span class="line-added">4407     BytecodeGenerator::PreservedTDZStack preservedTDZStack;</span>
<span class="line-added">4408     generator.preserveTDZStack(preservedTDZStack);</span>
<span class="line-added">4409 </span>
4410     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4411         const auto&amp; target = m_targetPatterns[i];
4412         if (target.bindingType == BindingType::Element) {
4413             RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4414             RefPtr&lt;RegisterID&gt; propertyName;
4415             if (!target.propertyExpression) {
4416                 Optional&lt;uint32_t&gt; optionalIndex = parseIndex(target.propertyName);
4417                 if (!optionalIndex)
4418                     generator.emitGetById(temp.get(), rhs, target.propertyName);
4419                 else {
4420                     RefPtr&lt;RegisterID&gt; propertyIndex = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
4421                     generator.emitGetByVal(temp.get(), rhs, propertyIndex.get());
4422                 }
4423             } else {
4424                 propertyName = generator.emitNodeForProperty(target.propertyExpression);
4425                 generator.emitGetByVal(temp.get(), rhs, propertyName.get());
4426             }
4427 
4428             if (m_containsRestElement) {
4429                 if (m_containsComputedProperty) {
</pre>
<hr />
<pre>
4452             RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4453             generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4454             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4455 
4456             CallArguments args(generator, nullptr, 3);
4457             generator.emitLoad(args.thisRegister(), jsUndefined());
4458             generator.move(args.argumentRegister(0), newObject.get());
4459             generator.move(args.argumentRegister(1), rhs);
4460             if (m_containsComputedProperty)
4461                 generator.move(args.argumentRegister(2), excludedList.get());
4462             else {
4463                 RefPtr&lt;RegisterID&gt; excludedSetReg = generator.emitLoad(generator.newTemporary(), excludedSet);
4464                 generator.move(args.argumentRegister(2), excludedSetReg.get());
4465             }
4466 
4467             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4468             generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4469             target.pattern-&gt;bindValue(generator, result.get());
4470         }
4471     }
<span class="line-added">4472 </span>
<span class="line-added">4473     generator.restoreTDZStack(preservedTDZStack);</span>
4474 }
4475 
4476 void ObjectPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4477 {
4478     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++)
4479         m_targetPatterns[i].pattern-&gt;collectBoundIdentifiers(identifiers);
4480 }
4481 
4482 void BindingNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4483 {
4484     Variable var = generator.variable(m_boundProperty);
4485     bool isReadOnly = var.isReadOnly() &amp;&amp; m_bindingContext != AssignmentContext::ConstDeclarationStatement;
4486     if (RegisterID* local = var.local()) {
4487         if (m_bindingContext == AssignmentContext::AssignmentExpression)
4488             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4489         if (isReadOnly) {
4490             generator.emitReadOnlyExceptionIfNeeded(var);
4491             return;
4492         }
4493         generator.move(local, value);
</pre>
</td>
</tr>
</table>
<center><a href="BytecodeGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../config.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>