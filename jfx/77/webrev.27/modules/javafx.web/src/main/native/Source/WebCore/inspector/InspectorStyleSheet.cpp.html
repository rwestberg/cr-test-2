<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorStyleSheet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010, Google Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1.  Redistributions of source code must retain the above copyright
   8  *     notice, this list of conditions and the following disclaimer.
   9  * 2.  Redistributions in binary form must reproduce the above copyright
  10  *     notice, this list of conditions and the following disclaimer in the
  11  *     documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;InspectorStyleSheet.h&quot;
  27 
  28 #include &quot;CSSImportRule.h&quot;
  29 #include &quot;CSSKeyframesRule.h&quot;
  30 #include &quot;CSSMediaRule.h&quot;
  31 #include &quot;CSSParser.h&quot;
  32 #include &quot;CSSParserObserver.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CSSPropertyParser.h&quot;
  35 #include &quot;CSSPropertySourceData.h&quot;
  36 #include &quot;CSSRule.h&quot;
  37 #include &quot;CSSRuleList.h&quot;
  38 #include &quot;CSSStyleRule.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CSSSupportsRule.h&quot;
  41 #include &quot;ContentSecurityPolicy.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;Element.h&quot;
  44 #include &quot;HTMLHeadElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLParserIdioms.h&quot;
  47 #include &quot;HTMLStyleElement.h&quot;
  48 #include &quot;InspectorCSSAgent.h&quot;
  49 #include &quot;InspectorDOMAgent.h&quot;
  50 #include &quot;InspectorPageAgent.h&quot;
  51 #include &quot;MediaList.h&quot;
  52 #include &quot;Node.h&quot;
  53 #include &quot;SVGElement.h&quot;
  54 #include &quot;SVGStyleElement.h&quot;
  55 #include &quot;StyleProperties.h&quot;
  56 #include &quot;StyleResolver.h&quot;
  57 #include &quot;StyleRule.h&quot;
  58 #include &quot;StyleRuleImport.h&quot;
  59 #include &quot;StyleSheetContents.h&quot;
  60 #include &quot;StyleSheetList.h&quot;
  61 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  62 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  63 #include &lt;wtf/text/StringBuilder.h&gt;
  64 
  65 using JSON::ArrayOf;
  66 using WebCore::RuleSourceDataList;
  67 using WebCore::CSSRuleSourceData;
  68 
  69 class ParsedStyleSheet {
  70     WTF_MAKE_FAST_ALLOCATED;
  71 public:
  72     ParsedStyleSheet();
  73 
  74     const String&amp; text() const { ASSERT(m_hasText); return m_text; }
  75     void setText(const String&amp; text);
  76     bool hasText() const { return m_hasText; }
  77     RuleSourceDataList* sourceData() const { return m_sourceData.get(); }
  78     void setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt;);
  79     bool hasSourceData() const { return m_sourceData != nullptr; }
  80     WebCore::CSSRuleSourceData* ruleSourceDataAt(unsigned) const;
  81 
  82 private:
  83 
  84     String m_text;
  85     bool m_hasText;
  86     std::unique_ptr&lt;RuleSourceDataList&gt; m_sourceData;
  87 };
  88 
  89 ParsedStyleSheet::ParsedStyleSheet()
  90     : m_hasText(false)
  91 {
  92 }
  93 
  94 void ParsedStyleSheet::setText(const String&amp; text)
  95 {
  96     m_hasText = true;
  97     m_text = text;
  98     setSourceData(nullptr);
  99 }
 100 
 101 static void flattenSourceData(RuleSourceDataList&amp; dataList, RuleSourceDataList&amp; target)
 102 {
 103     for (auto&amp; data : dataList) {
 104         if (data-&gt;type == WebCore::StyleRule::Style)
 105             target.append(data.copyRef());
 106         else if (data-&gt;type == WebCore::StyleRule::Media)
 107             flattenSourceData(data-&gt;childRules, target);
 108         else if (data-&gt;type == WebCore::StyleRule::Supports)
 109             flattenSourceData(data-&gt;childRules, target);
 110     }
 111 }
 112 
 113 void ParsedStyleSheet::setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt; sourceData)
 114 {
 115     if (!sourceData) {
 116         m_sourceData.reset();
 117         return;
 118     }
 119 
 120     m_sourceData = makeUnique&lt;RuleSourceDataList&gt;();
 121 
 122     // FIXME: This is a temporary solution to retain the original flat sourceData structure
 123     // containing only style rules, even though CSSParser now provides the full rule source data tree.
 124     // Normally, we should just assign m_sourceData = sourceData;
 125     flattenSourceData(*sourceData, *m_sourceData);
 126 }
 127 
 128 WebCore::CSSRuleSourceData* ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
 129 {
 130     if (!hasSourceData() || index &gt;= m_sourceData-&gt;size())
 131         return nullptr;
 132 
 133     return m_sourceData-&gt;at(index).ptr();
 134 }
 135 
 136 
 137 namespace WebCore {
 138 
 139 using namespace Inspector;
 140 
 141 static CSSParserContext parserContextForDocument(Document* document)
 142 {
 143     return document ? CSSParserContext(*document) : strictCSSParserContext();
 144 }
 145 
 146 class StyleSheetHandler : public CSSParserObserver {
 147 public:
 148     StyleSheetHandler(const String&amp; parsedText, Document* document, RuleSourceDataList* result)
 149         : m_parsedText(parsedText)
 150         , m_document(document)
 151         , m_ruleSourceDataResult(result)
 152     {
 153         ASSERT(m_ruleSourceDataResult);
 154     }
 155 
 156 private:
 157     void startRuleHeader(StyleRule::Type, unsigned) override;
 158     void endRuleHeader(unsigned) override;
 159     void observeSelector(unsigned startOffset, unsigned endOffset) override;
 160     void startRuleBody(unsigned) override;
 161     void endRuleBody(unsigned) override;
 162     void observeProperty(unsigned startOffset, unsigned endOffset, bool isImportant, bool isParsed) override;
 163     void observeComment(unsigned startOffset, unsigned endOffset) override;
 164 
 165     Ref&lt;CSSRuleSourceData&gt; popRuleData();
 166     template &lt;typename CharacterType&gt; inline void setRuleHeaderEnd(const CharacterType*, unsigned);
 167     void fixUnparsedPropertyRanges(CSSRuleSourceData*);
 168 
 169     const String&amp; m_parsedText;
 170     Document* m_document;
 171 
 172     RuleSourceDataList m_currentRuleDataStack;
 173     RefPtr&lt;CSSRuleSourceData&gt; m_currentRuleData;
 174     RuleSourceDataList* m_ruleSourceDataResult { nullptr };
 175 };
 176 
 177 void StyleSheetHandler::startRuleHeader(StyleRule::Type type, unsigned offset)
 178 {
 179     // Pop off data for a previous invalid rule.
 180     if (m_currentRuleData)
 181         m_currentRuleDataStack.removeLast();
 182 
 183     auto data = CSSRuleSourceData::create(type);
 184     data-&gt;ruleHeaderRange.start = offset;
 185     m_currentRuleData = data.copyRef();
 186     m_currentRuleDataStack.append(WTFMove(data));
 187 }
 188 
 189 template &lt;typename CharacterType&gt; inline void StyleSheetHandler::setRuleHeaderEnd(const CharacterType* dataStart, unsigned listEndOffset)
 190 {
 191     while (listEndOffset &gt; 1) {
 192         if (isHTMLSpace&lt;CharacterType&gt;(*(dataStart + listEndOffset - 1)))
 193             --listEndOffset;
 194         else
 195             break;
 196     }
 197 
 198     m_currentRuleDataStack.last()-&gt;ruleHeaderRange.end = listEndOffset;
 199     if (!m_currentRuleDataStack.last()-&gt;selectorRanges.isEmpty())
 200         m_currentRuleDataStack.last()-&gt;selectorRanges.last().end = listEndOffset;
 201 }
 202 
 203 void StyleSheetHandler::endRuleHeader(unsigned offset)
 204 {
 205     ASSERT(!m_currentRuleDataStack.isEmpty());
 206 
 207     if (m_parsedText.is8Bit())
 208         setRuleHeaderEnd&lt;LChar&gt;(m_parsedText.characters8(), offset);
 209     else
 210         setRuleHeaderEnd&lt;UChar&gt;(m_parsedText.characters16(), offset);
 211 }
 212 
 213 void StyleSheetHandler::observeSelector(unsigned startOffset, unsigned endOffset)
 214 {
 215     ASSERT(m_currentRuleDataStack.size());
 216     m_currentRuleDataStack.last()-&gt;selectorRanges.append(SourceRange(startOffset, endOffset));
 217 }
 218 
 219 void StyleSheetHandler::startRuleBody(unsigned offset)
 220 {
 221     m_currentRuleData = nullptr;
 222     ASSERT(!m_currentRuleDataStack.isEmpty());
 223 
 224     // Skip the rule body opening brace.
 225     if (m_parsedText[offset] == &#39;{&#39;)
 226         ++offset;
 227 
 228     m_currentRuleDataStack.last()-&gt;ruleBodyRange.start = offset;
 229 }
 230 
 231 void StyleSheetHandler::endRuleBody(unsigned offset)
 232 {
 233     ASSERT(!m_currentRuleDataStack.isEmpty());
 234     m_currentRuleDataStack.last()-&gt;ruleBodyRange.end = offset;
 235     auto rule = popRuleData();
 236     fixUnparsedPropertyRanges(rule.ptr());
 237     if (m_currentRuleDataStack.isEmpty())
 238         m_ruleSourceDataResult-&gt;append(WTFMove(rule));
 239     else
 240         m_currentRuleDataStack.last()-&gt;childRules.append(WTFMove(rule));
 241 }
 242 
 243 Ref&lt;CSSRuleSourceData&gt; StyleSheetHandler::popRuleData()
 244 {
 245     ASSERT(!m_currentRuleDataStack.isEmpty());
 246     m_currentRuleData = nullptr;
 247     auto data = WTFMove(m_currentRuleDataStack.last());
 248     m_currentRuleDataStack.removeLast();
 249     return data;
 250 }
 251 
 252 template &lt;typename CharacterType&gt;
 253 static inline void fixUnparsedProperties(const CharacterType* characters, CSSRuleSourceData* ruleData)
 254 {
 255     Vector&lt;CSSPropertySourceData&gt;&amp; propertyData = ruleData-&gt;styleSourceData-&gt;propertyData;
 256     unsigned size = propertyData.size();
 257     if (!size)
 258         return;
 259 
 260     unsigned styleStart = ruleData-&gt;ruleBodyRange.start;
 261 
 262     CSSPropertySourceData* nextData = &amp;(propertyData.at(0));
 263     for (unsigned i = 0; i &lt; size; ++i) {
 264         CSSPropertySourceData* currentData = nextData;
 265         nextData = i &lt; size - 1 ? &amp;(propertyData.at(i + 1)) : nullptr;
 266 
 267         if (currentData-&gt;parsedOk)
 268             continue;
 269         if (currentData-&gt;range.end &gt; 0 &amp;&amp; characters[styleStart + currentData-&gt;range.end - 1] == &#39;;&#39;)
 270             continue;
 271 
 272         unsigned propertyEnd;
 273         if (!nextData)
 274             propertyEnd = ruleData-&gt;ruleBodyRange.end - 1;
 275         else
 276             propertyEnd = styleStart + nextData-&gt;range.start - 1;
 277 
 278         while (isHTMLSpace&lt;CharacterType&gt;(characters[propertyEnd]))
 279             --propertyEnd;
 280 
 281         // propertyEnd points at the last property text character.
 282         unsigned newRangeEnd = (propertyEnd - styleStart) + 1;
 283         if (currentData-&gt;range.end != newRangeEnd) {
 284             currentData-&gt;range.end = newRangeEnd;
 285             unsigned valueStart = styleStart + currentData-&gt;range.start + currentData-&gt;name.length();
 286             while (valueStart &lt; propertyEnd &amp;&amp; characters[valueStart] != &#39;:&#39;)
 287                 ++valueStart;
 288 
 289             // Shift past the &#39;:&#39;.
 290             if (valueStart &lt; propertyEnd)
 291                 ++valueStart;
 292 
 293             while (valueStart &lt; propertyEnd &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(characters[valueStart]))
 294                 ++valueStart;
 295 
 296             // Need to exclude the trailing &#39;;&#39; from the property value.
 297             currentData-&gt;value = String(characters + valueStart, propertyEnd - valueStart + (characters[propertyEnd] == &#39;;&#39; ? 0 : 1));
 298         }
 299     }
 300 }
 301 
 302 void StyleSheetHandler::fixUnparsedPropertyRanges(CSSRuleSourceData* ruleData)
 303 {
 304     if (!ruleData-&gt;styleSourceData)
 305         return;
 306 
 307     if (m_parsedText.is8Bit()) {
 308         fixUnparsedProperties&lt;LChar&gt;(m_parsedText.characters8(), ruleData);
 309         return;
 310     }
 311 
 312     fixUnparsedProperties&lt;UChar&gt;(m_parsedText.characters16(), ruleData);
 313 }
 314 
 315 void StyleSheetHandler::observeProperty(unsigned startOffset, unsigned endOffset, bool isImportant, bool isParsed)
 316 {
 317     if (m_currentRuleDataStack.isEmpty() || !m_currentRuleDataStack.last()-&gt;styleSourceData)
 318         return;
 319 
 320     ASSERT(endOffset &lt;= m_parsedText.length());
 321 
 322     // Include semicolon in the property text.
 323     if (endOffset &lt; m_parsedText.length() &amp;&amp; m_parsedText[endOffset] == &#39;;&#39;)
 324         ++endOffset;
 325 
 326     ASSERT(startOffset &lt; endOffset);
 327     String propertyString = m_parsedText.substring(startOffset, endOffset - startOffset).stripWhiteSpace();
 328     if (propertyString.endsWith(&#39;;&#39;))
 329         propertyString = propertyString.left(propertyString.length() - 1);
 330     size_t colonIndex = propertyString.find(&#39;:&#39;);
 331     ASSERT(colonIndex != notFound);
 332 
 333     String name = propertyString.left(colonIndex).stripWhiteSpace();
 334     String value = propertyString.substring(colonIndex + 1, propertyString.length()).stripWhiteSpace();
 335 
 336     // FIXME-NEWPARSER: The property range is relative to the declaration start offset, but no
 337     // good reason for it, and it complicates fixUnparsedProperties.
 338     SourceRange&amp; topRuleBodyRange = m_currentRuleDataStack.last()-&gt;ruleBodyRange;
 339     m_currentRuleDataStack.last()-&gt;styleSourceData-&gt;propertyData.append(CSSPropertySourceData(name, value, isImportant, false, isParsed, SourceRange(startOffset - topRuleBodyRange.start, endOffset - topRuleBodyRange.start)));
 340 }
 341 
 342 void StyleSheetHandler::observeComment(unsigned startOffset, unsigned endOffset)
 343 {
 344     ASSERT(endOffset &lt;= m_parsedText.length());
 345 
 346     if (m_currentRuleDataStack.isEmpty() || !m_currentRuleDataStack.last()-&gt;ruleHeaderRange.end || !m_currentRuleDataStack.last()-&gt;styleSourceData)
 347         return;
 348 
 349     // The lexer is not inside a property AND it is scanning a declaration-aware
 350     // rule body.
 351     String commentText = m_parsedText.substring(startOffset, endOffset - startOffset);
 352 
 353     ASSERT(commentText.startsWith(&quot;/*&quot;));
 354     commentText = commentText.substring(2);
 355 
 356     // Require well-formed comments.
 357     if (!commentText.endsWith(&quot;*/&quot;))
 358         return;
 359     commentText = commentText.substring(0, commentText.length() - 2).stripWhiteSpace();
 360     if (commentText.isEmpty())
 361         return;
 362 
 363     // FIXME: Use the actual rule type rather than STYLE_RULE?
 364     RuleSourceDataList sourceData;
 365 
 366     StyleSheetHandler handler(commentText, m_document, &amp;sourceData);
 367     CSSParser::parseDeclarationForInspector(parserContextForDocument(m_document), commentText, handler);
 368     Vector&lt;CSSPropertySourceData&gt;&amp; commentPropertyData = sourceData.first()-&gt;styleSourceData-&gt;propertyData;
 369     if (commentPropertyData.size() != 1)
 370         return;
 371     CSSPropertySourceData&amp; propertyData = commentPropertyData.at(0);
 372     bool parsedOk = propertyData.parsedOk || propertyData.name.startsWith(&quot;-moz-&quot;) || propertyData.name.startsWith(&quot;-o-&quot;) || propertyData.name.startsWith(&quot;-webkit-&quot;) || propertyData.name.startsWith(&quot;-ms-&quot;);
 373     if (!parsedOk || propertyData.range.length() != commentText.length())
 374         return;
 375 
 376     // FIXME-NEWPARSER: The property range is relative to the declaration start offset, but no
 377     // good reason for it, and it complicates fixUnparsedProperties.
 378     SourceRange&amp; topRuleBodyRange = m_currentRuleDataStack.last()-&gt;ruleBodyRange;
 379     m_currentRuleDataStack.last()-&gt;styleSourceData-&gt;propertyData.append(CSSPropertySourceData(propertyData.name, propertyData.value, false, true, true, SourceRange(startOffset - topRuleBodyRange.start, endOffset - topRuleBodyRange.start)));
 380 }
 381 
 382 static RefPtr&lt;Inspector::Protocol::CSS::SourceRange&gt; buildSourceRangeObject(const SourceRange&amp; range, const Vector&lt;size_t&gt;&amp; lineEndings, int* endingLine = nullptr)
 383 {
 384     if (lineEndings.isEmpty())
 385         return nullptr;
 386 
 387     TextPosition start = ContentSearchUtilities::textPositionFromOffset(range.start, lineEndings);
 388     TextPosition end = ContentSearchUtilities::textPositionFromOffset(range.end, lineEndings);
 389 
 390     if (endingLine)
 391         *endingLine = end.m_line.zeroBasedInt();
 392 
 393     return Inspector::Protocol::CSS::SourceRange::create()
 394         .setStartLine(start.m_line.zeroBasedInt())
 395         .setStartColumn(start.m_column.zeroBasedInt())
 396         .setEndLine(end.m_line.zeroBasedInt())
 397         .setEndColumn(end.m_column.zeroBasedInt())
 398         .release();
 399 }
 400 
 401 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSStyleSheet* styleSheet)
 402 {
 403     if (!styleSheet)
 404         return nullptr;
 405 
 406     auto list = StaticCSSRuleList::create();
 407     Vector&lt;RefPtr&lt;CSSRule&gt;&gt;&amp; listRules = list-&gt;rules();
 408     for (unsigned i = 0, size = styleSheet-&gt;length(); i &lt; size; ++i)
 409         listRules.append(styleSheet-&gt;item(i));
 410     return list;
 411 }
 412 
 413 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSRule* rule)
 414 {
 415     if (!rule)
 416         return nullptr;
 417 
 418     if (is&lt;CSSMediaRule&gt;(*rule))
 419         return &amp;downcast&lt;CSSMediaRule&gt;(*rule).cssRules();
 420 
 421     if (is&lt;CSSKeyframesRule&gt;(*rule))
 422         return &amp;downcast&lt;CSSKeyframesRule&gt;(*rule).cssRules();
 423 
 424     if (is&lt;CSSSupportsRule&gt;(*rule))
 425         return &amp;downcast&lt;CSSSupportsRule&gt;(*rule).cssRules();
 426 
 427     return nullptr;
 428 }
 429 
 430 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::Grouping&gt;&gt; buildArrayForGroupings(CSSRule&amp; rule)
 431 {
 432     auto groupingsPayload = JSON::ArrayOf&lt;Inspector::Protocol::CSS::Grouping&gt;::create();
 433 
 434     auto* parentRule = &amp;rule;
 435     while (parentRule) {
 436         RefPtr&lt;Inspector::Protocol::CSS::Grouping&gt; ruleGroupingPayload;
 437 
 438         if (is&lt;CSSMediaRule&gt;(parentRule)) {
 439             auto* media = downcast&lt;CSSMediaRule&gt;(parentRule)-&gt;media();
 440             if (media &amp;&amp; media-&gt;length() &amp;&amp; media-&gt;mediaText() != &quot;all&quot;) {
 441                 ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 442                     .setText(media-&gt;mediaText())
 443                     .setType(Inspector::Protocol::CSS::Grouping::Type::MediaRule)
 444                     .release();
 445             }
 446         } else if (is&lt;CSSImportRule&gt;(parentRule)) {
 447             auto&amp; media = downcast&lt;CSSImportRule&gt;(parentRule)-&gt;media();
 448             if (media.length() &amp;&amp; media.mediaText() != &quot;all&quot;) {
 449                 ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 450                     .setText(media.mediaText())
 451                     .setType(Inspector::Protocol::CSS::Grouping::Type::MediaImportRule)
 452                     .release();
 453             }
 454         } else if (is&lt;CSSSupportsRule&gt;(parentRule)) {
 455             ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 456                 .setText(downcast&lt;CSSSupportsRule&gt;(parentRule)-&gt;conditionText())
 457                 .setType(Inspector::Protocol::CSS::Grouping::Type::SupportsRule)
 458                 .release();
 459         }
 460 
 461         if (ruleGroupingPayload) {
 462             if (auto* parentStyleSheet = parentRule-&gt;parentStyleSheet()) {
 463                 String sourceURL = parentStyleSheet-&gt;contents().baseURL();
 464                 if (sourceURL.isEmpty()) {
 465                     if (auto* ownerDocument = parentStyleSheet-&gt;ownerDocument())
 466                         sourceURL = InspectorDOMAgent::documentURLString(ownerDocument);
 467                 }
 468                 if (!sourceURL.isEmpty())
 469                     ruleGroupingPayload-&gt;setSourceURL(sourceURL);
 470             }
 471 
 472             groupingsPayload-&gt;addItem(WTFMove(ruleGroupingPayload));
 473         }
 474 
 475         if (parentRule-&gt;parentRule()) {
 476             parentRule = parentRule-&gt;parentRule();
 477             continue;
 478         }
 479 
 480         auto* styleSheet = parentRule-&gt;parentStyleSheet();
 481         while (styleSheet) {
 482             auto* media = styleSheet-&gt;media();
 483             if (media &amp;&amp; media-&gt;length() &amp;&amp; media-&gt;mediaText() != &quot;all&quot;) {
 484                 auto sheetGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 485                     .setText(media-&gt;mediaText())
 486                     .setType(is&lt;HTMLStyleElement&gt;(styleSheet-&gt;ownerNode()) ? Inspector::Protocol::CSS::Grouping::Type::MediaStyleNode: Inspector::Protocol::CSS::Grouping::Type::MediaLinkNode)
 487                     .release();
 488 
 489                 String sourceURL;
 490                 if (auto* ownerDocument = styleSheet-&gt;ownerDocument())
 491                     sourceURL = ownerDocument-&gt;url();
 492                 else if (!styleSheet-&gt;contents().baseURL().isEmpty())
 493                     sourceURL = styleSheet-&gt;contents().baseURL();
 494                 if (!sourceURL.isEmpty())
 495                     sheetGroupingPayload-&gt;setSourceURL(sourceURL);
 496 
 497                 groupingsPayload-&gt;addItem(WTFMove(sheetGroupingPayload));
 498             }
 499 
 500             parentRule = styleSheet-&gt;ownerRule();
 501             if (parentRule)
 502                 break;
 503 
 504             styleSheet = styleSheet-&gt;parentStyleSheet();
 505         }
 506     }
 507 
 508     return groupingsPayload;
 509 }
 510 
 511 Ref&lt;InspectorStyle&gt; InspectorStyle::create(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 512 {
 513     return adoptRef(*new InspectorStyle(styleId, WTFMove(style), parentStyleSheet));
 514 }
 515 
 516 InspectorStyle::InspectorStyle(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 517     : m_styleId(styleId)
 518     , m_style(WTFMove(style))
 519     , m_parentStyleSheet(parentStyleSheet)
 520 {
 521 }
 522 
 523 InspectorStyle::~InspectorStyle() = default;
 524 
 525 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::buildObjectForStyle() const
 526 {
 527     Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = styleWithProperties();
 528     if (!m_styleId.isEmpty())
 529         result-&gt;setStyleId(m_styleId.asProtocolValue&lt;Inspector::Protocol::CSS::CSSStyleId&gt;());
 530 
 531     result-&gt;setWidth(m_style-&gt;getPropertyValue(&quot;width&quot;));
 532     result-&gt;setHeight(m_style-&gt;getPropertyValue(&quot;height&quot;));
 533 
 534     RefPtr&lt;CSSRuleSourceData&gt; sourceData = extractSourceData();
 535     if (sourceData)
 536         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleBodyRange, m_parentStyleSheet-&gt;lineEndings()));
 537 
 538     return result;
 539 }
 540 
 541 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;&gt; InspectorStyle::buildArrayForComputedStyle() const
 542 {
 543     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;::create();
 544     Vector&lt;InspectorStyleProperty&gt; properties;
 545     populateAllProperties(&amp;properties);
 546 
 547     for (auto&amp; property : properties) {
 548         const CSSPropertySourceData&amp; propertyEntry = property.sourceData;
 549         auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
 550             .setName(propertyEntry.name)
 551             .setValue(propertyEntry.value)
 552             .release();
 553         result-&gt;addItem(WTFMove(entry));
 554     }
 555 
 556     return result;
 557 }
 558 
 559 ExceptionOr&lt;String&gt; InspectorStyle::text() const
 560 {
 561     // Precondition: m_parentStyleSheet-&gt;ensureParsedDataReady() has been called successfully.
 562     auto sourceData = extractSourceData();
 563     if (!sourceData)
 564         return Exception { NotFoundError };
 565 
 566     auto result = m_parentStyleSheet-&gt;text();
 567     if (result.hasException())
 568         return result.releaseException();
 569 
 570     auto&amp; bodyRange = sourceData-&gt;ruleBodyRange;
 571     return result.releaseReturnValue().substring(bodyRange.start, bodyRange.end - bodyRange.start);
 572 }
 573 
 574 static String lowercasePropertyName(const String&amp; name)
 575 {
 576     // Custom properties are case-sensitive.
 577     if (name.startsWith(&quot;--&quot;))
 578         return name;
 579     return name.convertToASCIILowercase();
 580 }
 581 
 582 void InspectorStyle::populateAllProperties(Vector&lt;InspectorStyleProperty&gt;* result) const
 583 {
 584     HashSet&lt;String&gt; sourcePropertyNames;
 585 
 586     auto sourceData = extractSourceData();
 587     auto* sourcePropertyData = sourceData ? &amp;sourceData-&gt;styleSourceData-&gt;propertyData : nullptr;
 588     if (sourcePropertyData) {
 589         auto styleDeclarationOrException = text();
 590         ASSERT(!styleDeclarationOrException.hasException());
 591         String styleDeclaration = styleDeclarationOrException.hasException() ? emptyString() : styleDeclarationOrException.releaseReturnValue();
 592         for (auto&amp; sourceData : *sourcePropertyData) {
 593             InspectorStyleProperty p(sourceData, true, sourceData.disabled);
 594             p.setRawTextFromStyleDeclaration(styleDeclaration);
 595             result-&gt;append(p);
 596             sourcePropertyNames.add(lowercasePropertyName(sourceData.name));
 597         }
 598     }
 599 
 600     for (int i = 0, size = m_style-&gt;length(); i &lt; size; ++i) {
 601         String name = m_style-&gt;item(i);
 602         if (sourcePropertyNames.add(lowercasePropertyName(name)))
 603             result-&gt;append(InspectorStyleProperty(CSSPropertySourceData(name, m_style-&gt;getPropertyValue(name), !m_style-&gt;getPropertyPriority(name).isEmpty(), false, true, SourceRange()), false, false));
 604     }
 605 }
 606 
 607 Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::styleWithProperties() const
 608 {
 609     Vector&lt;InspectorStyleProperty&gt; properties;
 610     populateAllProperties(&amp;properties);
 611 
 612     auto propertiesObject = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create();
 613     auto shorthandEntries = ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create();
 614     HashMap&lt;String, RefPtr&lt;Inspector::Protocol::CSS::CSSProperty&gt;&gt; propertyNameToPreviousActiveProperty;
 615     HashSet&lt;String&gt; foundShorthands;
 616     String previousPriority;
 617     String previousStatus;
 618     Vector&lt;size_t&gt; lineEndings = m_parentStyleSheet ? m_parentStyleSheet-&gt;lineEndings() : Vector&lt;size_t&gt; { };
 619     auto sourceData = extractSourceData();
 620     unsigned ruleBodyRangeStart = sourceData ? sourceData-&gt;ruleBodyRange.start : 0;
 621 
 622     for (Vector&lt;InspectorStyleProperty&gt;::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
 623         const CSSPropertySourceData&amp; propertyEntry = it-&gt;sourceData;
 624         const String&amp; name = propertyEntry.name;
 625 
 626         auto status = it-&gt;disabled ? Inspector::Protocol::CSS::CSSPropertyStatus::Disabled : Inspector::Protocol::CSS::CSSPropertyStatus::Active;
 627 
 628         auto property = Inspector::Protocol::CSS::CSSProperty::create()
 629             .setName(name.convertToASCIILowercase())
 630             .setValue(propertyEntry.value)
 631             .release();
 632 
 633         propertiesObject-&gt;addItem(property.copyRef());
 634 
 635         CSSPropertyID propertyId = cssPropertyID(name);
 636 
 637         // Default &quot;parsedOk&quot; == true.
 638         if (!propertyEntry.parsedOk || isInternalCSSProperty(propertyId))
 639             property-&gt;setParsedOk(false);
 640         if (it-&gt;hasRawText())
 641             property-&gt;setText(it-&gt;rawText);
 642 
 643         // Default &quot;priority&quot; == &quot;&quot;.
 644         if (propertyEntry.important)
 645             property-&gt;setPriority(&quot;important&quot;);
 646 
 647         if (it-&gt;hasSource) {
 648             // The property range is relative to the style body start.
 649             // Should be converted into an absolute range (relative to the stylesheet start)
 650             // for the proper conversion into line:column.
 651             SourceRange absolutePropertyRange = propertyEntry.range;
 652             absolutePropertyRange.start += ruleBodyRangeStart;
 653             absolutePropertyRange.end += ruleBodyRangeStart;
 654             property-&gt;setRange(buildSourceRangeObject(absolutePropertyRange, lineEndings));
 655         }
 656 
 657         if (!it-&gt;disabled) {
 658             if (it-&gt;hasSource) {
 659                 ASSERT(sourceData);
 660                 property-&gt;setImplicit(false);
 661 
 662                 // Parsed property overrides any property with the same name. Non-parsed property overrides
 663                 // previous non-parsed property with the same name (if any).
 664                 bool shouldInactivate = false;
 665 
 666                 // Canonicalize property names to treat non-prefixed and vendor-prefixed property names the same (opacity vs. -webkit-opacity).
 667                 String canonicalPropertyName = propertyId ? getPropertyNameString(propertyId) : name;
 668                 HashMap&lt;String, RefPtr&lt;Inspector::Protocol::CSS::CSSProperty&gt;&gt;::iterator activeIt = propertyNameToPreviousActiveProperty.find(canonicalPropertyName);
 669                 if (activeIt != propertyNameToPreviousActiveProperty.end()) {
 670                     if (propertyEntry.parsedOk) {
 671                         bool successPriority = activeIt-&gt;value-&gt;getString(Inspector::Protocol::CSS::CSSProperty::Priority, previousPriority);
 672                         bool successStatus = activeIt-&gt;value-&gt;getString(Inspector::Protocol::CSS::CSSProperty::Status, previousStatus);
 673                         if (successStatus &amp;&amp; previousStatus != &quot;inactive&quot;) {
 674                             if (propertyEntry.important || !successPriority) // Priority not set == &quot;not important&quot;.
 675                                 shouldInactivate = true;
 676                             else if (status == Inspector::Protocol::CSS::CSSPropertyStatus::Active) {
 677                                 // Inactivate a non-important property following the same-named important property.
 678                                 status = Inspector::Protocol::CSS::CSSPropertyStatus::Inactive;
 679                             }
 680                         }
 681                     } else {
 682                         bool previousParsedOk;
 683                         bool success = activeIt-&gt;value-&gt;getBoolean(Inspector::Protocol::CSS::CSSProperty::ParsedOk, previousParsedOk);
 684                         if (success &amp;&amp; !previousParsedOk)
 685                             shouldInactivate = true;
 686                     }
 687                 } else
 688                     propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property.copyRef());
 689 
 690                 if (shouldInactivate) {
 691                     activeIt-&gt;value-&gt;setStatus(Inspector::Protocol::CSS::CSSPropertyStatus::Inactive);
 692                     propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property.copyRef());
 693                 }
 694             } else {
 695                 bool implicit = m_style-&gt;isPropertyImplicit(name);
 696                 // Default &quot;implicit&quot; == false.
 697                 if (implicit)
 698                     property-&gt;setImplicit(true);
 699                 status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
 700 
 701                 String shorthand = m_style-&gt;getPropertyShorthand(name);
 702                 if (!shorthand.isEmpty()) {
 703                     if (!foundShorthands.contains(shorthand)) {
 704                         foundShorthands.add(shorthand);
 705                         auto entry = Inspector::Protocol::CSS::ShorthandEntry::create()
 706                             .setName(shorthand)
 707                             .setValue(shorthandValue(shorthand))
 708                             .release();
 709                         shorthandEntries-&gt;addItem(WTFMove(entry));
 710                     }
 711                 }
 712             }
 713         }
 714 
 715         // Default &quot;status&quot; == &quot;style&quot;.
 716         if (status != Inspector::Protocol::CSS::CSSPropertyStatus::Style)
 717             property-&gt;setStatus(status);
 718     }
 719 
 720     return Inspector::Protocol::CSS::CSSStyle::create()
 721         .setCssProperties(WTFMove(propertiesObject))
 722         .setShorthandEntries(WTFMove(shorthandEntries))
 723         .release();
 724 }
 725 
 726 RefPtr&lt;CSSRuleSourceData&gt; InspectorStyle::extractSourceData() const
 727 {
 728     if (!m_parentStyleSheet || !m_parentStyleSheet-&gt;ensureParsedDataReady())
 729         return nullptr;
 730     return m_parentStyleSheet-&gt;ruleSourceDataFor(m_style.ptr());
 731 }
 732 
 733 ExceptionOr&lt;void&gt; InspectorStyle::setText(const String&amp; text)
 734 {
 735     return m_parentStyleSheet-&gt;setStyleText(m_style.ptr(), text);
 736 }
 737 
 738 String InspectorStyle::shorthandValue(const String&amp; shorthandProperty) const
 739 {
 740     String value = m_style-&gt;getPropertyValue(shorthandProperty);
 741     if (!value.isEmpty())
 742         return value;
 743     StringBuilder builder;
 744     for (unsigned i = 0; i &lt; m_style-&gt;length(); ++i) {
 745         String individualProperty = m_style-&gt;item(i);
 746         if (m_style-&gt;getPropertyShorthand(individualProperty) != shorthandProperty)
 747             continue;
 748         if (m_style-&gt;isPropertyImplicit(individualProperty))
 749             continue;
 750         String individualValue = m_style-&gt;getPropertyValue(individualProperty);
 751         if (individualValue == &quot;initial&quot;)
 752             continue;
 753         if (!builder.isEmpty())
 754             builder.append(&#39; &#39;);
 755         builder.append(individualValue);
 756     }
 757     return builder.toString();
 758 }
 759 
 760 String InspectorStyle::shorthandPriority(const String&amp; shorthandProperty) const
 761 {
 762     String priority = m_style-&gt;getPropertyPriority(shorthandProperty);
 763     if (priority.isEmpty()) {
 764         for (unsigned i = 0; i &lt; m_style-&gt;length(); ++i) {
 765             String individualProperty = m_style-&gt;item(i);
 766             if (m_style-&gt;getPropertyShorthand(individualProperty) != shorthandProperty)
 767                 continue;
 768             priority = m_style-&gt;getPropertyPriority(individualProperty);
 769             break;
 770         }
 771     }
 772     return priority;
 773 }
 774 
 775 Vector&lt;String&gt; InspectorStyle::longhandProperties(const String&amp; shorthandProperty) const
 776 {
 777     Vector&lt;String&gt; properties;
 778     HashSet&lt;String&gt; foundProperties;
 779     for (unsigned i = 0; i &lt; m_style-&gt;length(); ++i) {
 780         String individualProperty = m_style-&gt;item(i);
 781         if (foundProperties.contains(individualProperty) || m_style-&gt;getPropertyShorthand(individualProperty) != shorthandProperty)
 782             continue;
 783 
 784         foundProperties.add(individualProperty);
 785         properties.append(individualProperty);
 786     }
 787     return properties;
 788 }
 789 
 790 Ref&lt;InspectorStyleSheet&gt; InspectorStyleSheet::create(InspectorPageAgent* pageAgent, const String&amp; id, RefPtr&lt;CSSStyleSheet&gt;&amp;&amp; pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin origin, const String&amp; documentURL, Listener* listener)
 791 {
 792     return adoptRef(*new InspectorStyleSheet(pageAgent, id, WTFMove(pageStyleSheet), origin, documentURL, listener));
 793 }
 794 
 795 String InspectorStyleSheet::styleSheetURL(CSSStyleSheet* pageStyleSheet)
 796 {
 797     if (pageStyleSheet &amp;&amp; !pageStyleSheet-&gt;contents().baseURL().isEmpty())
 798         return pageStyleSheet-&gt;contents().baseURL().string();
 799     return emptyString();
 800 }
 801 
 802 InspectorStyleSheet::InspectorStyleSheet(InspectorPageAgent* pageAgent, const String&amp; id, RefPtr&lt;CSSStyleSheet&gt;&amp;&amp; pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin origin, const String&amp; documentURL, Listener* listener)
 803     : m_pageAgent(pageAgent)
 804     , m_id(id)
 805     , m_pageStyleSheet(WTFMove(pageStyleSheet))
 806     , m_origin(origin)
 807     , m_documentURL(documentURL)
 808     , m_listener(listener)
 809 {
 810     m_parsedStyleSheet = new ParsedStyleSheet();
 811 }
 812 
 813 InspectorStyleSheet::~InspectorStyleSheet()
 814 {
 815     delete m_parsedStyleSheet;
 816 }
 817 
 818 String InspectorStyleSheet::finalURL() const
 819 {
 820     String url = styleSheetURL(m_pageStyleSheet.get());
 821     return url.isEmpty() ? m_documentURL : url;
 822 }
 823 
 824 void InspectorStyleSheet::reparseStyleSheet(const String&amp; text)
 825 {
 826     {
 827         // Have a separate scope for clearRules() (bug 95324).
 828         CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
 829         m_pageStyleSheet-&gt;contents().clearRules();
 830     }
 831     {
 832         CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
 833         m_pageStyleSheet-&gt;contents().parseString(text);
 834         m_pageStyleSheet-&gt;clearChildRuleCSSOMWrappers();
 835         fireStyleSheetChanged();
 836     }
 837 
 838     // We just wiped the entire contents of the stylesheet. Clear the mutation flag.
 839     m_pageStyleSheet-&gt;clearHadRulesMutation();
 840 }
 841 
 842 ExceptionOr&lt;void&gt; InspectorStyleSheet::setText(const String&amp; text)
 843 {
 844     if (!m_pageStyleSheet)
 845         return Exception { NotSupportedError };
 846 
 847     m_parsedStyleSheet-&gt;setText(text);
 848     m_flatRules.clear();
 849 
 850     return { };
 851 }
 852 
 853 ExceptionOr&lt;String&gt; InspectorStyleSheet::ruleSelector(const InspectorCSSId&amp; id)
 854 {
 855     CSSStyleRule* rule = ruleForId(id);
 856     if (!rule)
 857         return Exception { NotFoundError };
 858     return rule-&gt;selectorText();
 859 }
 860 
 861 static bool isValidSelectorListString(const String&amp; selector, Document* document)
 862 {
 863     CSSSelectorList selectorList;
 864     CSSParser parser(parserContextForDocument(document));
 865     parser.parseSelector(selector, selectorList);
 866     return selectorList.isValid();
 867 }
 868 
 869 ExceptionOr&lt;void&gt; InspectorStyleSheet::setRuleSelector(const InspectorCSSId&amp; id, const String&amp; selector)
 870 {
 871     if (!m_pageStyleSheet)
 872         return Exception { NotSupportedError };
 873 
 874     // If the selector is invalid, do not proceed any further.
 875     if (!isValidSelectorListString(selector, m_pageStyleSheet-&gt;ownerDocument()))
 876         return Exception { SyntaxError };
 877 
 878     CSSStyleRule* rule = ruleForId(id);
 879     if (!rule)
 880         return Exception { NotFoundError };
 881 
 882     CSSStyleSheet* styleSheet = rule-&gt;parentStyleSheet();
 883     if (!styleSheet || !ensureParsedDataReady())
 884         return Exception { NotFoundError };
 885 
 886     // If the stylesheet is already mutated at this point, that must mean that our data has been modified
 887     // elsewhere. This should never happen as ensureParsedDataReady would return false in that case.
 888     ASSERT(!styleSheetMutated());
 889 
 890     rule-&gt;setSelectorText(selector);
 891     auto sourceData = ruleSourceDataFor(&amp;rule-&gt;style());
 892     if (!sourceData)
 893         return Exception { NotFoundError };
 894 
 895     String sheetText = m_parsedStyleSheet-&gt;text();
 896     sheetText.replace(sourceData-&gt;ruleHeaderRange.start, sourceData-&gt;ruleHeaderRange.length(), selector);
 897     m_parsedStyleSheet-&gt;setText(sheetText);
 898     m_pageStyleSheet-&gt;clearHadRulesMutation();
 899     fireStyleSheetChanged();
 900     return { };
 901 }
 902 
 903 ExceptionOr&lt;CSSStyleRule*&gt; InspectorStyleSheet::addRule(const String&amp; selector)
 904 {
 905     if (!m_pageStyleSheet)
 906         return Exception { NotSupportedError };
 907 
 908     if (!isValidSelectorListString(selector, m_pageStyleSheet-&gt;ownerDocument()))
 909         return Exception { SyntaxError };
 910 
 911     auto text = this-&gt;text();
 912     if (text.hasException())
 913         return text.releaseException();
 914 
 915     auto addRuleResult = m_pageStyleSheet-&gt;addRule(selector, emptyString(), WTF::nullopt);
 916     if (addRuleResult.hasException())
 917         return addRuleResult.releaseException();
 918 
 919     StringBuilder styleSheetText;
 920     styleSheetText.append(text.releaseReturnValue());
 921 
 922     if (!styleSheetText.isEmpty())
 923         styleSheetText.append(&#39;\n&#39;);
 924 
 925     styleSheetText.append(selector);
 926     styleSheetText.appendLiteral(&quot; {}&quot;);
 927 
 928     // Using setText() as this operation changes the stylesheet rule set.
 929     setText(styleSheetText.toString());
 930 
 931     // Inspector Style Sheets are always treated as though their parsed data is ready.
 932     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Inspector)
 933         fireStyleSheetChanged();
 934     else
 935         reparseStyleSheet(styleSheetText.toString());
 936 
 937     ASSERT(m_pageStyleSheet-&gt;length());
 938     unsigned lastRuleIndex = m_pageStyleSheet-&gt;length() - 1;
 939     CSSRule* rule = m_pageStyleSheet-&gt;item(lastRuleIndex);
 940     ASSERT(rule);
 941 
 942     CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
 943     if (!styleRule) {
 944         // What we just added has to be a CSSStyleRule - we cannot handle other types of rules yet.
 945         // If it is not a style rule, pretend we never touched the stylesheet.
 946         m_pageStyleSheet-&gt;deleteRule(lastRuleIndex);
 947         return Exception { SyntaxError };
 948     }
 949 
 950     return styleRule;
 951 }
 952 
 953 ExceptionOr&lt;void&gt; InspectorStyleSheet::deleteRule(const InspectorCSSId&amp; id)
 954 {
 955     if (!m_pageStyleSheet)
 956         return Exception { NotSupportedError };
 957 
 958     RefPtr&lt;CSSStyleRule&gt; rule = ruleForId(id);
 959     if (!rule)
 960         return Exception { NotFoundError };
 961     CSSStyleSheet* styleSheet = rule-&gt;parentStyleSheet();
 962     if (!styleSheet || !ensureParsedDataReady())
 963         return Exception { NotFoundError };
 964 
 965     auto sourceData = ruleSourceDataFor(&amp;rule-&gt;style());
 966     if (!sourceData)
 967         return Exception { NotFoundError };
 968 
 969     auto deleteRuleResult = styleSheet-&gt;deleteRule(id.ordinal());
 970     if (deleteRuleResult.hasException())
 971         return deleteRuleResult.releaseException();
 972 
 973     // |rule| MAY NOT be addressed after this!
 974 
 975     String sheetText = m_parsedStyleSheet-&gt;text();
 976     sheetText.remove(sourceData-&gt;ruleHeaderRange.start, sourceData-&gt;ruleBodyRange.end - sourceData-&gt;ruleHeaderRange.start + 1);
 977     setText(sheetText);
 978     fireStyleSheetChanged();
 979     return { };
 980 }
 981 
 982 CSSStyleRule* InspectorStyleSheet::ruleForId(const InspectorCSSId&amp; id) const
 983 {
 984     if (!m_pageStyleSheet)
 985         return nullptr;
 986 
 987     ASSERT(!id.isEmpty());
 988     ensureFlatRules();
 989     return id.ordinal() &gt;= m_flatRules.size() ? nullptr : m_flatRules.at(id.ordinal()).get();
 990 }
 991 
 992 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetBody&gt; InspectorStyleSheet::buildObjectForStyleSheet()
 993 {
 994     CSSStyleSheet* styleSheet = pageStyleSheet();
 995     if (!styleSheet)
 996         return nullptr;
 997 
 998     RefPtr&lt;CSSRuleList&gt; cssRuleList = asCSSRuleList(styleSheet);
 999 
1000     auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
1001         .setStyleSheetId(id())
1002         .setRules(buildArrayForRuleList(cssRuleList.get()))
1003         .release();
1004 
1005     auto styleSheetText = text();
1006     if (!styleSheetText.hasException())
1007         result-&gt;setText(styleSheetText.releaseReturnValue());
1008 
1009     return result;
1010 }
1011 
1012 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetHeader&gt; InspectorStyleSheet::buildObjectForStyleSheetInfo()
1013 {
1014     CSSStyleSheet* styleSheet = pageStyleSheet();
1015     if (!styleSheet)
1016         return nullptr;
1017 
1018     Document* document = styleSheet-&gt;ownerDocument();
1019     Frame* frame = document ? document-&gt;frame() : nullptr;
1020     return Inspector::Protocol::CSS::CSSStyleSheetHeader::create()
1021         .setStyleSheetId(id())
1022         .setOrigin(m_origin)
1023         .setDisabled(styleSheet-&gt;disabled())
1024         .setSourceURL(finalURL())
1025         .setTitle(styleSheet-&gt;title())
1026         .setFrameId(m_pageAgent-&gt;frameId(frame))
1027         .setIsInline(styleSheet-&gt;isInline() &amp;&amp; styleSheet-&gt;startPosition() != TextPosition())
1028         .setStartLine(styleSheet-&gt;startPosition().m_line.zeroBasedInt())
1029         .setStartColumn(styleSheet-&gt;startPosition().m_column.zeroBasedInt())
1030         .release();
1031 }
1032 
1033 static bool hasDynamicSpecificity(const CSSSelector&amp; simpleSelector)
1034 {
1035     // It is possible that these can have a static specificity if each selector in the list has
1036     // equal specificity, but lets always report that they can be dynamic.
1037     for (const CSSSelector* selector = &amp;simpleSelector; selector; selector = selector-&gt;tagHistory()) {
1038         if (selector-&gt;match() == CSSSelector::PseudoClass) {
1039             CSSSelector::PseudoClassType pseudoClassType = selector-&gt;pseudoClassType();
1040             if (pseudoClassType == CSSSelector::PseudoClassMatches)
1041                 return true;
1042             if (pseudoClassType == CSSSelector::PseudoClassNthChild || pseudoClassType == CSSSelector::PseudoClassNthLastChild) {
1043                 if (selector-&gt;selectorList())
1044                     return true;
1045                 return false;
1046             }
1047         }
1048     }
1049 
1050     return false;
1051 }
1052 
1053 static Ref&lt;Inspector::Protocol::CSS::CSSSelector&gt; buildObjectForSelectorHelper(const String&amp; selectorText, const CSSSelector&amp; selector, Element* element)
1054 {
1055     auto inspectorSelector = Inspector::Protocol::CSS::CSSSelector::create()
1056         .setText(selectorText)
1057         .release();
1058 
1059     if (element) {
1060         bool dynamic = hasDynamicSpecificity(selector);
1061         if (dynamic)
1062             inspectorSelector-&gt;setDynamic(true);
1063 
1064         SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
1065         SelectorChecker selectorChecker(element-&gt;document());
1066 
1067         unsigned specificity;
1068         bool okay = selectorChecker.match(selector, *element, context, specificity);
1069         if (!okay)
1070             specificity = selector.staticSpecificity(okay);
1071 
1072         if (okay) {
1073             auto tuple = JSON::ArrayOf&lt;int&gt;::create();
1074             tuple-&gt;addItem(static_cast&lt;int&gt;((specificity &amp; CSSSelector::idMask) &gt;&gt; 16));
1075             tuple-&gt;addItem(static_cast&lt;int&gt;((specificity &amp; CSSSelector::classMask) &gt;&gt; 8));
1076             tuple-&gt;addItem(static_cast&lt;int&gt;(specificity &amp; CSSSelector::elementMask));
1077             inspectorSelector-&gt;setSpecificity(WTFMove(tuple));
1078         }
1079     }
1080 
1081     return inspectorSelector;
1082 }
1083 
1084 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;&gt; selectorsFromSource(const CSSRuleSourceData* sourceData, const String&amp; sheetText, const CSSSelectorList&amp; selectorList, Element* element)
1085 {
1086     static NeverDestroyed&lt;JSC::Yarr::RegularExpression&gt; comment(&quot;/\\*[^]*?\\*/&quot;, JSC::Yarr::TextCaseSensitive, JSC::Yarr::MultilineEnabled);
1087 
1088     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;::create();
1089     const CSSSelector* selector = selectorList.first();
1090     for (auto&amp; range : sourceData-&gt;selectorRanges) {
1091         // If we don&#39;t have a selector, that means the SourceData for this CSSStyleSheet
1092         // no longer matches up with the actual rules in the CSSStyleSheet.
1093         ASSERT(selector);
1094         if (!selector)
1095             break;
1096 
1097         String selectorText = sheetText.substring(range.start, range.length());
1098 
1099         // We don&#39;t want to see any comments in the selector components, only the meaningful parts.
1100         replace(selectorText, comment, String());
1101         result-&gt;addItem(buildObjectForSelectorHelper(selectorText.stripWhiteSpace(), *selector, element));
1102 
1103         selector = CSSSelectorList::next(selector);
1104     }
1105     return result;
1106 }
1107 
1108 Ref&lt;Inspector::Protocol::CSS::CSSSelector&gt; InspectorStyleSheet::buildObjectForSelector(const CSSSelector* selector, Element* element)
1109 {
1110     return buildObjectForSelectorHelper(selector-&gt;selectorText(), *selector, element);
1111 }
1112 
1113 Ref&lt;Inspector::Protocol::CSS::SelectorList&gt; InspectorStyleSheet::buildObjectForSelectorList(CSSStyleRule* rule, Element* element, int&amp; endingLine)
1114 {
1115     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1116     if (ensureParsedDataReady())
1117         sourceData = ruleSourceDataFor(&amp;rule-&gt;style());
1118     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;&gt; selectors;
1119 
1120     // This intentionally does not rely on the source data to avoid catching the trailing comments (before the declaration starting &#39;{&#39;).
1121     String selectorText = rule-&gt;selectorText();
1122 
1123     if (sourceData)
1124         selectors = selectorsFromSource(sourceData.get(), m_parsedStyleSheet-&gt;text(), rule-&gt;styleRule().selectorList(), element);
1125     else {
1126         selectors = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;::create();
1127         const CSSSelectorList&amp; selectorList = rule-&gt;styleRule().selectorList();
1128         for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
1129             selectors-&gt;addItem(buildObjectForSelector(selector, element));
1130     }
1131     auto result = Inspector::Protocol::CSS::SelectorList::create()
1132         .setSelectors(WTFMove(selectors))
1133         .setText(selectorText)
1134         .release();
1135     if (sourceData)
1136         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleHeaderRange, lineEndings(), &amp;endingLine));
1137     return result;
1138 }
1139 
1140 RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt; InspectorStyleSheet::buildObjectForRule(CSSStyleRule* rule, Element* element)
1141 {
1142     CSSStyleSheet* styleSheet = pageStyleSheet();
1143     if (!styleSheet)
1144         return nullptr;
1145 
1146     int endingLine = 0;
1147     auto result = Inspector::Protocol::CSS::CSSRule::create()
1148         .setSelectorList(buildObjectForSelectorList(rule, element, endingLine))
1149         .setSourceLine(endingLine)
1150         .setOrigin(m_origin)
1151         .setStyle(buildObjectForStyle(&amp;rule-&gt;style()))
1152         .release();
1153 
1154     // &quot;sourceURL&quot; is present only for regular rules, otherwise &quot;origin&quot; should be used in the frontend.
1155     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Regular)
1156         result-&gt;setSourceURL(finalURL());
1157 
1158     if (canBind()) {
1159         InspectorCSSId id(ruleId(rule));
1160         if (!id.isEmpty())
1161             result-&gt;setRuleId(id.asProtocolValue&lt;Inspector::Protocol::CSS::CSSRuleId&gt;());
1162     }
1163 
1164     auto groupingsPayload = buildArrayForGroupings(*rule);
1165     if (groupingsPayload-&gt;length())
1166         result-&gt;setGroupings(WTFMove(groupingsPayload));
1167 
1168     return result;
1169 }
1170 
1171 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
1172 {
1173     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1174     if (ensureParsedDataReady())
1175         sourceData = ruleSourceDataFor(style);
1176 
1177     InspectorCSSId id = ruleOrStyleId(style);
1178     if (id.isEmpty()) {
1179         return Inspector::Protocol::CSS::CSSStyle::create()
1180             .setCssProperties(ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create())
1181             .setShorthandEntries(ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create())
1182             .release();
1183     }
1184     RefPtr&lt;InspectorStyle&gt; inspectorStyle = inspectorStyleForId(id);
1185     RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = inspectorStyle-&gt;buildObjectForStyle();
1186 
1187     // Style text cannot be retrieved without stylesheet, so set cssText here.
1188     if (sourceData) {
1189         auto sheetText = text();
1190         if (!sheetText.hasException()) {
1191             auto&amp; bodyRange = sourceData-&gt;ruleBodyRange;
1192             result-&gt;setCssText(sheetText.releaseReturnValue().substring(bodyRange.start, bodyRange.end - bodyRange.start));
1193         }
1194     }
1195 
1196     return result;
1197 }
1198 
1199 ExceptionOr&lt;void&gt; InspectorStyleSheet::setStyleText(const InspectorCSSId&amp; id, const String&amp; text, String* oldText)
1200 {
1201     auto inspectorStyle = inspectorStyleForId(id);
1202     if (!inspectorStyle)
1203         return Exception { NotFoundError };
1204 
1205     if (oldText) {
1206         auto result = inspectorStyle-&gt;text();
1207         if (result.hasException())
1208             return result.releaseException();
1209         *oldText = result.releaseReturnValue();
1210     }
1211 
1212     auto result = inspectorStyle-&gt;setText(text);
1213     if (!result.hasException())
1214         fireStyleSheetChanged();
1215     return result;
1216 }
1217 
1218 ExceptionOr&lt;String&gt; InspectorStyleSheet::text() const
1219 {
1220     if (!ensureText())
1221         return Exception { NotFoundError };
1222     return String { m_parsedStyleSheet-&gt;text() };
1223 }
1224 
1225 CSSStyleDeclaration* InspectorStyleSheet::styleForId(const InspectorCSSId&amp; id) const
1226 {
1227     CSSStyleRule* rule = ruleForId(id);
1228     if (!rule)
1229         return nullptr;
1230 
1231     return &amp;rule-&gt;style();
1232 }
1233 
1234 void InspectorStyleSheet::fireStyleSheetChanged()
1235 {
1236     if (m_listener)
1237         m_listener-&gt;styleSheetChanged(this);
1238 }
1239 
1240 RefPtr&lt;InspectorStyle&gt; InspectorStyleSheet::inspectorStyleForId(const InspectorCSSId&amp; id)
1241 {
1242     CSSStyleDeclaration* style = styleForId(id);
1243     if (!style)
1244         return nullptr;
1245 
1246     return InspectorStyle::create(id, *style, this);
1247 }
1248 
1249 InspectorCSSId InspectorStyleSheet::ruleOrStyleId(CSSStyleDeclaration* style) const
1250 {
1251     unsigned index = ruleIndexByStyle(style);
1252     if (index != UINT_MAX)
1253         return InspectorCSSId(id(), index);
1254     return InspectorCSSId();
1255 }
1256 
1257 Document* InspectorStyleSheet::ownerDocument() const
1258 {
1259     return m_pageStyleSheet-&gt;ownerDocument();
1260 }
1261 
1262 RefPtr&lt;CSSRuleSourceData&gt; InspectorStyleSheet::ruleSourceDataFor(CSSStyleDeclaration* style) const
1263 {
1264     return m_parsedStyleSheet-&gt;ruleSourceDataAt(ruleIndexByStyle(style));
1265 }
1266 
1267 Vector&lt;size_t&gt; InspectorStyleSheet::lineEndings() const
1268 {
1269     if (!m_parsedStyleSheet-&gt;hasText())
1270         return { };
1271     return ContentSearchUtilities::lineEndings(m_parsedStyleSheet-&gt;text());
1272 }
1273 
1274 unsigned InspectorStyleSheet::ruleIndexByStyle(CSSStyleDeclaration* pageStyle) const
1275 {
1276     ensureFlatRules();
1277     unsigned index = 0;
1278     for (auto&amp; rule : m_flatRules) {
1279         if (&amp;rule-&gt;style() == pageStyle)
1280             return index;
1281 
1282         ++index;
1283     }
1284     return UINT_MAX;
1285 }
1286 
1287 bool InspectorStyleSheet::styleSheetMutated() const
1288 {
1289     return m_pageStyleSheet &amp;&amp; m_pageStyleSheet-&gt;hadRulesMutation();
1290 }
1291 
1292 bool InspectorStyleSheet::ensureParsedDataReady()
1293 {
1294     bool allowParsedData = m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Inspector || !styleSheetMutated();
1295     return allowParsedData &amp;&amp; ensureText() &amp;&amp; ensureSourceData();
1296 }
1297 
1298 bool InspectorStyleSheet::ensureText() const
1299 {
1300     if (!m_parsedStyleSheet)
1301         return false;
1302     if (m_parsedStyleSheet-&gt;hasText())
1303         return true;
1304 
1305     String text;
1306     bool success = originalStyleSheetText(&amp;text);
1307     if (success)
1308         m_parsedStyleSheet-&gt;setText(text);
1309     // No need to clear m_flatRules here - it&#39;s empty.
1310 
1311     return success;
1312 }
1313 
1314 bool InspectorStyleSheet::ensureSourceData()
1315 {
1316     if (m_parsedStyleSheet-&gt;hasSourceData())
1317         return true;
1318 
1319     if (!m_parsedStyleSheet-&gt;hasText())
1320         return false;
1321 
1322     auto newStyleSheet = StyleSheetContents::create();
1323     auto ruleSourceDataResult = makeUnique&lt;RuleSourceDataList&gt;();
1324 
1325     CSSParserContext context(parserContextForDocument(m_pageStyleSheet-&gt;ownerDocument()));
1326     StyleSheetHandler handler(m_parsedStyleSheet-&gt;text(), m_pageStyleSheet-&gt;ownerDocument(), ruleSourceDataResult.get());
1327     CSSParser::parseSheetForInspector(context, newStyleSheet.ptr(), m_parsedStyleSheet-&gt;text(), handler);
1328     m_parsedStyleSheet-&gt;setSourceData(WTFMove(ruleSourceDataResult));
1329     return m_parsedStyleSheet-&gt;hasSourceData();
1330 }
1331 
1332 void InspectorStyleSheet::ensureFlatRules() const
1333 {
1334     // We are fine with redoing this for empty stylesheets as this will run fast.
1335     if (m_flatRules.isEmpty())
1336         collectFlatRules(asCSSRuleList(pageStyleSheet()), &amp;m_flatRules);
1337 }
1338 
1339 ExceptionOr&lt;void&gt; InspectorStyleSheet::setStyleText(CSSStyleDeclaration* style, const String&amp; text)
1340 {
1341     if (!m_pageStyleSheet)
1342         return Exception { NotFoundError };
1343     if (!ensureParsedDataReady())
1344         return Exception { NotFoundError };
1345 
1346     String patchedStyleSheetText;
1347     bool success = styleSheetTextWithChangedStyle(style, text, &amp;patchedStyleSheetText);
1348     if (!success)
1349         return Exception { NotFoundError };
1350 
1351     InspectorCSSId id = ruleOrStyleId(style);
1352     if (id.isEmpty())
1353         return Exception { NotFoundError };
1354 
1355     auto setCssTextResult = style-&gt;setCssText(text);
1356     if (setCssTextResult.hasException())
1357         return setCssTextResult.releaseException();
1358 
1359     m_parsedStyleSheet-&gt;setText(patchedStyleSheetText);
1360     return { };
1361 }
1362 
1363 bool InspectorStyleSheet::styleSheetTextWithChangedStyle(CSSStyleDeclaration* style, const String&amp; newStyleText, String* result)
1364 {
1365     if (!style)
1366         return false;
1367 
1368     if (!ensureParsedDataReady())
1369         return false;
1370 
1371     RefPtr&lt;CSSRuleSourceData&gt; sourceData = ruleSourceDataFor(style);
1372     unsigned bodyStart = sourceData-&gt;ruleBodyRange.start;
1373     unsigned bodyEnd = sourceData-&gt;ruleBodyRange.end;
1374     ASSERT(bodyStart &lt;= bodyEnd);
1375 
1376     String text = m_parsedStyleSheet-&gt;text();
1377     ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd &lt;= text.length()); // bodyEnd is exclusive
1378 
1379     text.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
1380     *result = text;
1381     return true;
1382 }
1383 
1384 InspectorCSSId InspectorStyleSheet::ruleId(CSSStyleRule* rule) const
1385 {
1386     return ruleOrStyleId(&amp;rule-&gt;style());
1387 }
1388 
1389 bool InspectorStyleSheet::originalStyleSheetText(String* result) const
1390 {
1391     bool success = inlineStyleSheetText(result);
1392     if (!success)
1393         success = resourceStyleSheetText(result);
1394     return success;
1395 }
1396 
1397 bool InspectorStyleSheet::resourceStyleSheetText(String* result) const
1398 {
1399     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::User || m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent)
1400         return false;
1401 
1402     if (!m_pageStyleSheet || !ownerDocument() || !ownerDocument()-&gt;frame())
1403         return false;
1404 
1405     String error;
1406     bool base64Encoded;
1407     InspectorPageAgent::resourceContent(error, ownerDocument()-&gt;frame(), URL({ }, m_pageStyleSheet-&gt;href()), result, &amp;base64Encoded);
1408     return error.isEmpty() &amp;&amp; !base64Encoded;
1409 }
1410 
1411 bool InspectorStyleSheet::inlineStyleSheetText(String* result) const
1412 {
1413     if (!m_pageStyleSheet)
1414         return false;
1415 
1416     Node* ownerNode = m_pageStyleSheet-&gt;ownerNode();
1417     if (!is&lt;Element&gt;(ownerNode))
1418         return false;
1419     Element&amp; ownerElement = downcast&lt;Element&gt;(*ownerNode);
1420 
1421     if (!is&lt;HTMLStyleElement&gt;(ownerElement) &amp;&amp; !is&lt;SVGStyleElement&gt;(ownerElement))
1422         return false;
1423     *result = ownerElement.textContent();
1424     return true;
1425 }
1426 
1427 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;&gt; InspectorStyleSheet::buildArrayForRuleList(CSSRuleList* ruleList)
1428 {
1429     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;::create();
1430     if (!ruleList)
1431         return result;
1432 
1433     RefPtr&lt;CSSRuleList&gt; refRuleList = ruleList;
1434     CSSStyleRuleVector rules;
1435     collectFlatRules(WTFMove(refRuleList), &amp;rules);
1436 
1437     for (auto&amp; rule : rules)
1438         result-&gt;addItem(buildObjectForRule(rule.get(), nullptr));
1439 
1440     return result;
1441 }
1442 
1443 void InspectorStyleSheet::collectFlatRules(RefPtr&lt;CSSRuleList&gt;&amp;&amp; ruleList, CSSStyleRuleVector* result)
1444 {
1445     if (!ruleList)
1446         return;
1447 
1448     for (unsigned i = 0, size = ruleList-&gt;length(); i &lt; size; ++i) {
1449         CSSRule* rule = ruleList-&gt;item(i);
1450         CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
1451         if (styleRule)
1452             result-&gt;append(styleRule);
1453         else {
1454             RefPtr&lt;CSSRuleList&gt; childRuleList = asCSSRuleList(rule);
1455             if (childRuleList)
1456                 collectFlatRules(WTFMove(childRuleList), result);
1457         }
1458     }
1459 }
1460 
1461 Ref&lt;InspectorStyleSheetForInlineStyle&gt; InspectorStyleSheetForInlineStyle::create(InspectorPageAgent* pageAgent, const String&amp; id, Ref&lt;StyledElement&gt;&amp;&amp; element, Inspector::Protocol::CSS::StyleSheetOrigin origin, Listener* listener)
1462 {
1463     return adoptRef(*new InspectorStyleSheetForInlineStyle(pageAgent, id, WTFMove(element), origin, listener));
1464 }
1465 
1466 InspectorStyleSheetForInlineStyle::InspectorStyleSheetForInlineStyle(InspectorPageAgent* pageAgent, const String&amp; id, Ref&lt;StyledElement&gt;&amp;&amp; element, Inspector::Protocol::CSS::StyleSheetOrigin origin, Listener* listener)
1467     : InspectorStyleSheet(pageAgent, id, nullptr, origin, String(), listener)
1468     , m_element(WTFMove(element))
1469     , m_ruleSourceData(nullptr)
1470     , m_isStyleTextValid(false)
1471 {
1472     m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id, 0), inlineStyle(), this);
1473     m_styleText = m_element-&gt;getAttribute(&quot;style&quot;).string();
1474 }
1475 
1476 void InspectorStyleSheetForInlineStyle::didModifyElementAttribute()
1477 {
1478     m_isStyleTextValid = false;
1479     if (&amp;m_element-&gt;cssomStyle() != &amp;m_inspectorStyle-&gt;cssStyle())
1480         m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id(), 0), inlineStyle(), this);
1481     m_ruleSourceData = nullptr;
1482 }
1483 
1484 ExceptionOr&lt;String&gt; InspectorStyleSheetForInlineStyle::text() const
1485 {
1486     if (!m_isStyleTextValid) {
1487         m_styleText = elementStyleText();
1488         m_isStyleTextValid = true;
1489     }
1490     return String { m_styleText };
1491 }
1492 
1493 ExceptionOr&lt;void&gt; InspectorStyleSheetForInlineStyle::setStyleText(CSSStyleDeclaration* style, const String&amp; text)
1494 {
1495     ASSERT_UNUSED(style, style == &amp;inlineStyle());
1496 
1497     {
1498         InspectorCSSAgent::InlineStyleOverrideScope overrideScope(m_element-&gt;document());
1499         m_element-&gt;setAttribute(HTMLNames::styleAttr, text);
1500     }
1501 
1502     m_styleText = text;
1503     m_isStyleTextValid = true;
1504     m_ruleSourceData = nullptr;
1505 
1506     return { };
1507 }
1508 
1509 Vector&lt;size_t&gt; InspectorStyleSheetForInlineStyle::lineEndings() const
1510 {
1511     return ContentSearchUtilities::lineEndings(elementStyleText());
1512 }
1513 
1514 Document* InspectorStyleSheetForInlineStyle::ownerDocument() const
1515 {
1516     return &amp;m_element-&gt;document();
1517 }
1518 
1519 bool InspectorStyleSheetForInlineStyle::ensureParsedDataReady()
1520 {
1521     // The &quot;style&quot; property value can get changed indirectly, e.g. via element.style.borderWidth = &quot;2px&quot;.
1522     const String&amp; currentStyleText = elementStyleText();
1523     if (m_styleText != currentStyleText) {
1524         m_ruleSourceData = nullptr;
1525         m_styleText = currentStyleText;
1526         m_isStyleTextValid = true;
1527     }
1528 
1529     if (m_ruleSourceData)
1530         return true;
1531 
1532     m_ruleSourceData = ruleSourceData();
1533     return true;
1534 }
1535 
1536 RefPtr&lt;InspectorStyle&gt; InspectorStyleSheetForInlineStyle::inspectorStyleForId(const InspectorCSSId&amp; id)
1537 {
1538     ASSERT_UNUSED(id, !id.ordinal());
1539     return m_inspectorStyle.copyRef();
1540 }
1541 
1542 CSSStyleDeclaration&amp; InspectorStyleSheetForInlineStyle::inlineStyle() const
1543 {
1544     return m_element-&gt;cssomStyle();
1545 }
1546 
1547 const String&amp; InspectorStyleSheetForInlineStyle::elementStyleText() const
1548 {
1549     return m_element-&gt;getAttribute(&quot;style&quot;).string();
1550 }
1551 
1552 Ref&lt;CSSRuleSourceData&gt; InspectorStyleSheetForInlineStyle::ruleSourceData() const
1553 {
1554     if (m_styleText.isEmpty()) {
1555         auto result = CSSRuleSourceData::create(StyleRule::Style);
1556         result-&gt;ruleBodyRange.start = 0;
1557         result-&gt;ruleBodyRange.end = 0;
1558         return result;
1559     }
1560 
1561     CSSParserContext context(parserContextForDocument(&amp;m_element-&gt;document()));
1562     RuleSourceDataList ruleSourceDataResult;
1563     StyleSheetHandler handler(m_styleText, &amp;m_element-&gt;document(), &amp;ruleSourceDataResult);
1564     CSSParser::parseDeclarationForInspector(context, m_styleText, handler);
1565     return WTFMove(ruleSourceDataResult.first());
1566 }
1567 
1568 } // namespace WebCore
    </pre>
  </body>
</html>