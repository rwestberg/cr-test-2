<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VM.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,21 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;VM.h&quot;
  
  #include &quot;ArgList.h&quot;
<span class="line-modified">! #include &quot;ArrayBufferNeuteringWatchpoint.h&quot;</span>
  #include &quot;BuiltinExecutables.h&quot;
  #include &quot;BytecodeIntrinsicRegistry.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeCache.h&quot;
  #include &quot;CommonIdentifiers.h&quot;
  #include &quot;CommonSlowPaths.h&quot;
  #include &quot;CustomGetterSetter.h&quot;
  #include &quot;DFGWorklist.h&quot;
  #include &quot;DirectEvalExecutable.h&quot;
  #include &quot;Disassembler.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;ErrorConstructor.h&quot;
  #include &quot;ErrorInstance.h&quot;
  #include &quot;EvalCodeBlock.h&quot;
  #include &quot;Exception.h&quot;
<span class="line-new-header">--- 28,22 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;VM.h&quot;
  
  #include &quot;ArgList.h&quot;
<span class="line-modified">! #include &quot;ArrayBufferNeuteringWatchpointSet.h&quot;</span>
  #include &quot;BuiltinExecutables.h&quot;
  #include &quot;BytecodeIntrinsicRegistry.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeCache.h&quot;
  #include &quot;CommonIdentifiers.h&quot;
  #include &quot;CommonSlowPaths.h&quot;
  #include &quot;CustomGetterSetter.h&quot;
  #include &quot;DFGWorklist.h&quot;
  #include &quot;DirectEvalExecutable.h&quot;
  #include &quot;Disassembler.h&quot;
<span class="line-added">+ #include &quot;DoublePredictionFuzzerAgent.h&quot;</span>
  #include &quot;Error.h&quot;
  #include &quot;ErrorConstructor.h&quot;
  #include &quot;ErrorInstance.h&quot;
  #include &quot;EvalCodeBlock.h&quot;
  #include &quot;Exception.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,11 ***</span>
  #include &quot;HeapProfiler.h&quot;
  #include &quot;HostCallReturnValue.h&quot;
  #include &quot;Identifier.h&quot;
  #include &quot;IncrementalSweeper.h&quot;
  #include &quot;IndirectEvalExecutable.h&quot;
<span class="line-removed">- #include &quot;InferredValue.h&quot;</span>
  #include &quot;Interpreter.h&quot;
  #include &quot;IntlCollatorConstructor.h&quot;
  #include &quot;IntlDateTimeFormatConstructor.h&quot;
  #include &quot;IntlNumberFormatConstructor.h&quot;
  #include &quot;IntlPluralRulesConstructor.h&quot;
<span class="line-new-header">--- 62,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,19 ***</span>
  #include &quot;JSLock.h&quot;
  #include &quot;JSMap.h&quot;
  #include &quot;JSMapIterator.h&quot;
  #include &quot;JSPromiseDeferred.h&quot;
  #include &quot;JSPropertyNameEnumerator.h&quot;
<span class="line-removed">- #include &quot;JSSegmentedVariableObjectHeapCellType.h&quot;</span>
  #include &quot;JSScriptFetchParameters.h&quot;
  #include &quot;JSScriptFetcher.h&quot;
  #include &quot;JSSet.h&quot;
  #include &quot;JSSetIterator.h&quot;
  #include &quot;JSSourceCode.h&quot;
  #include &quot;JSStringHeapCellType.h&quot;
  #include &quot;JSTemplateObjectDescriptor.h&quot;
  #include &quot;JSWeakMap.h&quot;
  #include &quot;JSWeakSet.h&quot;
  #include &quot;JSWebAssembly.h&quot;
  #include &quot;JSWebAssemblyCodeBlock.h&quot;
  #include &quot;JSWebAssemblyCodeBlockHeapCellType.h&quot;
  #include &quot;JSWithScope.h&quot;
<span class="line-new-header">--- 89,19 ---</span>
  #include &quot;JSLock.h&quot;
  #include &quot;JSMap.h&quot;
  #include &quot;JSMapIterator.h&quot;
  #include &quot;JSPromiseDeferred.h&quot;
  #include &quot;JSPropertyNameEnumerator.h&quot;
  #include &quot;JSScriptFetchParameters.h&quot;
  #include &quot;JSScriptFetcher.h&quot;
  #include &quot;JSSet.h&quot;
  #include &quot;JSSetIterator.h&quot;
  #include &quot;JSSourceCode.h&quot;
  #include &quot;JSStringHeapCellType.h&quot;
  #include &quot;JSTemplateObjectDescriptor.h&quot;
  #include &quot;JSWeakMap.h&quot;
<span class="line-added">+ #include &quot;JSWeakObjectRef.h&quot;</span>
  #include &quot;JSWeakSet.h&quot;
  #include &quot;JSWebAssembly.h&quot;
  #include &quot;JSWebAssemblyCodeBlock.h&quot;
  #include &quot;JSWebAssemblyCodeBlockHeapCellType.h&quot;
  #include &quot;JSWithScope.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,10 ***</span>
<span class="line-new-header">--- 121,11 ---</span>
  #include &quot;ProgramCodeBlock.h&quot;
  #include &quot;ProgramExecutable.h&quot;
  #include &quot;PromiseDeferredTimer.h&quot;
  #include &quot;PropertyMapHashTable.h&quot;
  #include &quot;ProxyRevoke.h&quot;
<span class="line-added">+ #include &quot;RandomizingFuzzerAgent.h&quot;</span>
  #include &quot;RegExpCache.h&quot;
  #include &quot;RegExpObject.h&quot;
  #include &quot;RegisterAtOffsetList.h&quot;
  #include &quot;RuntimeType.h&quot;
  #include &quot;SamplingProfiler.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,17 ***</span>
  #include &quot;VariableEnvironment.h&quot;
  #include &quot;WasmWorklist.h&quot;
  #include &quot;Watchdog.h&quot;
  #include &quot;WeakGCMapInlines.h&quot;
  #include &quot;WebAssemblyFunction.h&quot;
  #include &quot;WebAssemblyWrapperFunction.h&quot;
  #include &lt;wtf/ProcessID.h&gt;
  #include &lt;wtf/ReadWriteLock.h&gt;
  #include &lt;wtf/SimpleStats.h&gt;
  #include &lt;wtf/StringPrintStream.h&gt;
  #include &lt;wtf/Threading.h&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomicStringTable.h&gt;</span>
  #include &lt;wtf/text/SymbolRegistry.h&gt;
  
  #if ENABLE(C_LOOP)
  #include &quot;CLoopStack.h&quot;
  #include &quot;CLoopStackInlines.h&quot;
<span class="line-new-header">--- 147,18 ---</span>
  #include &quot;VariableEnvironment.h&quot;
  #include &quot;WasmWorklist.h&quot;
  #include &quot;Watchdog.h&quot;
  #include &quot;WeakGCMapInlines.h&quot;
  #include &quot;WebAssemblyFunction.h&quot;
<span class="line-added">+ #include &quot;WebAssemblyFunctionHeapCellType.h&quot;</span>
  #include &quot;WebAssemblyWrapperFunction.h&quot;
  #include &lt;wtf/ProcessID.h&gt;
  #include &lt;wtf/ReadWriteLock.h&gt;
  #include &lt;wtf/SimpleStats.h&gt;
  #include &lt;wtf/StringPrintStream.h&gt;
  #include &lt;wtf/Threading.h&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomStringTable.h&gt;</span>
  #include &lt;wtf/text/SymbolRegistry.h&gt;
  
  #if ENABLE(C_LOOP)
  #include &quot;CLoopStack.h&quot;
  #include &quot;CLoopStackInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,33 ***</span>
  // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
  // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
  // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
  
  #if ENABLE(ASSEMBLER)
<span class="line-modified">! static bool enableAssembler(ExecutableAllocator&amp; executableAllocator)</span>
  {
<span class="line-modified">!     if (!Options::useJIT() &amp;&amp; !Options::useRegExpJIT())</span>
          return false;
  
<span class="line-modified">!     if (!executableAllocator.isValid()) {</span>
          if (Options::crashIfCantAllocateJITMemory())
              CRASH();
          return false;
      }
  
<span class="line-modified">!     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);</span>
<span class="line-removed">-     return !canUseJITString || atoi(canUseJITString);</span>
  }
  #endif // ENABLE(!ASSEMBLER)
  
  bool VM::canUseAssembler()
  {
  #if ENABLE(ASSEMBLER)
      static std::once_flag onceKey;
      static bool enabled = false;
      std::call_once(onceKey, [] {
<span class="line-modified">!         enabled = enableAssembler(ExecutableAllocator::singleton());</span>
      });
      return enabled;
  #else
      return false; // interpreter only
  #endif
<span class="line-new-header">--- 186,37 ---</span>
  // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
  // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
  // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
  
  #if ENABLE(ASSEMBLER)
<span class="line-modified">! static bool enableAssembler()</span>
  {
<span class="line-modified">!     if (!Options::useJIT())</span>
          return false;
  
<span class="line-modified">!     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);</span>
<span class="line-added">+     if (canUseJITString &amp;&amp; !atoi(canUseJITString))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ExecutableAllocator::initializeUnderlyingAllocator();</span>
<span class="line-added">+     if (!ExecutableAllocator::singleton().isValid()) {</span>
          if (Options::crashIfCantAllocateJITMemory())
              CRASH();
          return false;
      }
  
<span class="line-modified">!     return true;</span>
  }
  #endif // ENABLE(!ASSEMBLER)
  
  bool VM::canUseAssembler()
  {
  #if ENABLE(ASSEMBLER)
      static std::once_flag onceKey;
      static bool enabled = false;
      std::call_once(onceKey, [] {
<span class="line-modified">!         enabled = enableAssembler();</span>
      });
      return enabled;
  #else
      return false; // interpreter only
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,92 ***</span>
  #endif
      s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
  #endif
  }
  
<span class="line-removed">- bool VM::canUseRegExpJIT()</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #if ENABLE(YARR_JIT)</span>
<span class="line-removed">-     static std::once_flag onceKey;</span>
<span class="line-removed">-     static bool enabled = false;</span>
<span class="line-removed">-     std::call_once(onceKey, [] {</span>
<span class="line-removed">-         enabled = VM::canUseAssembler() &amp;&amp; Options::useRegExpJIT();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     return enabled;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     return false; // interpreter only</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool VM::isInMiniMode()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return !canUseJIT() || Options::forceMiniVMMode();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  inline unsigned VM::nextID()
  {
      for (;;) {
          unsigned currentNumberOfIDs = s_numberOfIDs.load();
          unsigned newID = currentNumberOfIDs + 1;
          if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
              return newID;
      }
  }
  
  
  VM::VM(VMType vmType, HeapType heapType)
      : m_id(nextID())
      , m_apiLock(adoptRef(new JSLock(this)))
  #if USE(CF)
      , m_runLoop(CFRunLoopGetCurrent())
  #endif // USE(CF)
<span class="line-modified">!     , heap(this, heapType)</span>
<span class="line-modified">!     , fastMallocAllocator(std::make_unique&lt;FastMallocAlignedMemoryAllocator&gt;())</span>
<span class="line-modified">!     , primitiveGigacageAllocator(std::make_unique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))</span>
<span class="line-modified">!     , jsValueGigacageAllocator(std::make_unique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))</span>
<span class="line-modified">!     , auxiliaryHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))</span>
<span class="line-modified">!     , immutableButterflyHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))</span>
<span class="line-modified">!     , cellHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))</span>
<span class="line-modified">!     , destructibleCellHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))</span>
<span class="line-modified">!     , stringHeapCellType(std::make_unique&lt;JSStringHeapCellType&gt;())</span>
<span class="line-modified">!     , destructibleObjectHeapCellType(std::make_unique&lt;JSDestructibleObjectHeapCellType&gt;())</span>
<span class="line-removed">-     , segmentedVariableObjectHeapCellType(std::make_unique&lt;JSSegmentedVariableObjectHeapCellType&gt;())</span>
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">!     , webAssemblyCodeBlockHeapCellType(std::make_unique&lt;JSWebAssemblyCodeBlockHeapCellType&gt;())</span>
  #endif
<span class="line-modified">!     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get())</span>
<span class="line-modified">!     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get())</span>
<span class="line-modified">!     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get())</span>
<span class="line-modified">!     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified">!     , jsValueGigacageCellSpace(&quot;JSValue Gigacage JSCell&quot;, heap, cellHeapCellType.get(), jsValueGigacageAllocator.get())</span>
<span class="line-modified">!     , destructibleCellSpace(&quot;Destructible JSCell&quot;, heap, destructibleCellHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified">!     , stringSpace(&quot;JSString&quot;, heap, stringHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified">!     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified">!     , eagerlySweptDestructibleObjectSpace(&quot;Eagerly Swept JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified">!     , segmentedVariableObjectSpace(&quot;JSSegmentedVariableObjectSpace&quot;, heap, segmentedVariableObjectHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified">!     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge)</span>
<span class="line-modified">!     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction)</span>
<span class="line-modified">!     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, destructibleObjectHeapCellType.get(), InternalFunction)</span>
<span class="line-modified">!     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable)</span>
<span class="line-modified">!     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable)</span>
<span class="line-modified">!     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData)</span>
<span class="line-modified">!     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure)</span>
      , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
      , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
<span class="line-modified">!     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock)</span>
<span class="line-modified">!     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable)</span>
<span class="line-modified">!     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable)</span>
<span class="line-modified">!     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable)</span>
      , vmType(vmType)
      , clientData(0)
      , topEntryFrame(nullptr)
      , topCallFrame(CallFrame::noCaller())
<span class="line-modified">!     , promiseDeferredTimer(std::make_unique&lt;PromiseDeferredTimer&gt;(*this))</span>
<span class="line-modified">!     , m_atomicStringTable(vmType == Default ? Thread::current().atomicStringTable() : new AtomicStringTable)</span>
      , propertyNames(nullptr)
      , emptyList(new ArgList)
<span class="line-modified">!     , machineCodeBytesPerBytecodeWordForBaselineJIT(std::make_unique&lt;SimpleStats&gt;())</span>
      , customGetterSetterFunctionMap(*this)
      , stringCache(*this)
      , symbolImplToSymbolMap(*this)
      , structureCache(*this)
      , interpreter(0)
<span class="line-new-header">--- 231,74 ---</span>
  #endif
      s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
  #endif
  }
  
  inline unsigned VM::nextID()
  {
      for (;;) {
          unsigned currentNumberOfIDs = s_numberOfIDs.load();
          unsigned newID = currentNumberOfIDs + 1;
          if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
              return newID;
      }
  }
  
<span class="line-added">+ static bool vmCreationShouldCrash = false;</span>
  
  VM::VM(VMType vmType, HeapType heapType)
      : m_id(nextID())
      , m_apiLock(adoptRef(new JSLock(this)))
  #if USE(CF)
      , m_runLoop(CFRunLoopGetCurrent())
  #endif // USE(CF)
<span class="line-modified">!     , heap(*this, heapType)</span>
<span class="line-modified">!     , fastMallocAllocator(makeUnique&lt;FastMallocAlignedMemoryAllocator&gt;())</span>
<span class="line-modified">!     , primitiveGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))</span>
<span class="line-modified">!     , jsValueGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))</span>
<span class="line-modified">!     , auxiliaryHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))</span>
<span class="line-modified">!     , immutableButterflyHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))</span>
<span class="line-modified">!     , cellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))</span>
<span class="line-modified">!     , destructibleCellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))</span>
<span class="line-modified">!     , stringHeapCellType(makeUnique&lt;JSStringHeapCellType&gt;())</span>
<span class="line-modified">!     , destructibleObjectHeapCellType(makeUnique&lt;JSDestructibleObjectHeapCellType&gt;())</span>
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">!     , webAssemblyCodeBlockHeapCellType(makeUnique&lt;JSWebAssemblyCodeBlockHeapCellType&gt;())</span>
<span class="line-added">+     , webAssemblyFunctionHeapCellType(makeUnique&lt;WebAssemblyFunctionHeapCellType&gt;())</span>
  #endif
<span class="line-modified">!     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get()) // Hash:0x3e7cd762</span>
<span class="line-modified">!     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x241e946</span>
<span class="line-modified">!     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x7a945300</span>
<span class="line-modified">!     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xadfb5a79</span>
<span class="line-modified">!     , jsValueGigacageCellSpace(&quot;JSValue Gigacage JSCell&quot;, heap, cellHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x2f5b102b</span>
<span class="line-modified">!     , destructibleCellSpace(&quot;Destructible JSCell&quot;, heap, destructibleCellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xbfff3d73</span>
<span class="line-modified">!     , stringSpace(&quot;JSString&quot;, heap, stringHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x90cf758f</span>
<span class="line-modified">!     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x4f5ed7a9</span>
<span class="line-modified">!     , eagerlySweptDestructibleObjectSpace(&quot;Eagerly Swept JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x6ebf28e2</span>
<span class="line-modified">!     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge) // Hash:0x7b730b20</span>
<span class="line-modified">!     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction) // Hash:0x800fca72</span>
<span class="line-modified">!     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, destructibleObjectHeapCellType.get(), InternalFunction) // Hash:0xf845c464</span>
<span class="line-modified">!     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable) // Hash:0x67567f95</span>
<span class="line-modified">!     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable) // Hash:0xc6bc9f12</span>
<span class="line-modified">!     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData) // Hash:0xaca4e62d</span>
<span class="line-modified">!     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure) // Hash:0x1f1bcdca</span>
<span class="line-modified">!     , symbolTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SymbolTable) // Hash:0xc5215afd</span>
      , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
      , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
<span class="line-modified">!     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock) // Hash:0x77e66ec9</span>
<span class="line-modified">!     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable) // Hash:0x5d158f3</span>
<span class="line-modified">!     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable) // Hash:0x527c77e7</span>
<span class="line-modified">!     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable) // Hash:0xf6b828d9</span>
      , vmType(vmType)
      , clientData(0)
      , topEntryFrame(nullptr)
      , topCallFrame(CallFrame::noCaller())
<span class="line-modified">!     , promiseDeferredTimer(PromiseDeferredTimer::create(*this))</span>
<span class="line-modified">!     , m_atomStringTable(vmType == Default ? Thread::current().atomStringTable() : new AtomStringTable)</span>
      , propertyNames(nullptr)
      , emptyList(new ArgList)
<span class="line-modified">!     , machineCodeBytesPerBytecodeWordForBaselineJIT(makeUnique&lt;SimpleStats&gt;())</span>
      , customGetterSetterFunctionMap(*this)
      , stringCache(*this)
      , symbolImplToSymbolMap(*this)
      , structureCache(*this)
      , interpreter(0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,33 ***</span>
  #endif
  #if ENABLE(GC_VALIDATION)
      , m_initializingObjectClass(0)
  #endif
      , m_stackPointerAtVMEntry(0)
<span class="line-modified">!     , m_codeCache(std::make_unique&lt;CodeCache&gt;())</span>
<span class="line-modified">!     , m_builtinExecutables(std::make_unique&lt;BuiltinExecutables&gt;(*this))</span>
      , m_typeProfilerEnabledCount(0)
      , m_primitiveGigacageEnabled(IsWatched)
      , m_controlFlowProfilerEnabledCount(0)
  {
      interpreter = new Interpreter(*this);
      StackBounds stack = Thread::current().stack();
      updateSoftReservedZoneSize(Options::softReservedZoneSize());
      setLastStackTop(stack.origin());
  
      JSRunLoopTimer::Manager::shared().registerVM(*this);
  
      // Need to be careful to keep everything consistent here
      JSLockHolder lock(this);
<span class="line-modified">!     AtomicStringTable* existingEntryAtomicStringTable = Thread::current().setCurrentAtomicStringTable(m_atomicStringTable);</span>
      structureStructure.set(*this, Structure::createStructure(*this));
      structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
      stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
  
      smallStrings.initializeCommonStrings(*this);
  
<span class="line-modified">!     propertyNames = new CommonIdentifiers(this);</span>
      terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
      propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));
      customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
      domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
      scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
<span class="line-new-header">--- 310,36 ---</span>
  #endif
  #if ENABLE(GC_VALIDATION)
      , m_initializingObjectClass(0)
  #endif
      , m_stackPointerAtVMEntry(0)
<span class="line-modified">!     , m_codeCache(makeUnique&lt;CodeCache&gt;())</span>
<span class="line-modified">!     , m_builtinExecutables(makeUnique&lt;BuiltinExecutables&gt;(*this))</span>
      , m_typeProfilerEnabledCount(0)
      , m_primitiveGigacageEnabled(IsWatched)
      , m_controlFlowProfilerEnabledCount(0)
  {
<span class="line-added">+     if (UNLIKELY(vmCreationShouldCrash))</span>
<span class="line-added">+         CRASH_WITH_INFO(0x4242424220202020, 0xbadbeef0badbeef, 0x1234123412341234, 0x1337133713371337);</span>
<span class="line-added">+ </span>
      interpreter = new Interpreter(*this);
      StackBounds stack = Thread::current().stack();
      updateSoftReservedZoneSize(Options::softReservedZoneSize());
      setLastStackTop(stack.origin());
  
      JSRunLoopTimer::Manager::shared().registerVM(*this);
  
      // Need to be careful to keep everything consistent here
      JSLockHolder lock(this);
<span class="line-modified">!     AtomStringTable* existingEntryAtomStringTable = Thread::current().setCurrentAtomStringTable(m_atomStringTable);</span>
      structureStructure.set(*this, Structure::createStructure(*this));
      structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
      stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
  
      smallStrings.initializeCommonStrings(*this);
  
<span class="line-modified">!     propertyNames = new CommonIdentifiers(*this);</span>
      terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
      propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));
      customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
      domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
      scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 374,19 ***</span>
      scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
      scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
      structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
      sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
      templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));
<span class="line-modified">!     arrayBufferNeuteringWatchpointStructure.set(*this, ArrayBufferNeuteringWatchpoint::createStructure(*this));</span>
      unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
      unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
      unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
      unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
      unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
      propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));
<span class="line-removed">-     if (VM::canUseJIT())</span>
<span class="line-removed">-         inferredValueStructure.set(*this, InferredValue::createStructure(*this, 0, jsNull()));</span>
      functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
      exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));
      promiseDeferredStructure.set(*this, JSPromiseDeferred::createStructure(*this, 0, jsNull()));
      internalPromiseDeferredStructure.set(*this, JSInternalPromiseDeferred::createStructure(*this, 0, jsNull()));
      nativeStdFunctionCellStructure.set(*this, NativeStdFunctionCell::createStructure(*this, 0, jsNull()));
<span class="line-new-header">--- 365,17 ---</span>
      scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
      scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
      structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
      sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
      templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));
<span class="line-modified">!     arrayBufferNeuteringWatchpointStructure.set(*this, ArrayBufferNeuteringWatchpointSet::createStructure(*this));</span>
      unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
      unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
      unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
      unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
      unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
      propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));
      functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
      exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));
      promiseDeferredStructure.set(*this, JSPromiseDeferred::createStructure(*this, 0, jsNull()));
      internalPromiseDeferredStructure.set(*this, JSInternalPromiseDeferred::createStructure(*this, 0, jsNull()));
      nativeStdFunctionCellStructure.set(*this, NativeStdFunctionCell::createStructure(*this, 0, jsNull()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,30 ***</span>
      moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
      evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
      functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
      hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
      hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));
<span class="line-removed">-     setIteratorStructure.set(*this, JSSetIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-removed">-     mapIteratorStructure.set(*this, JSMapIterator::createStructure(*this, 0, jsNull()));</span>
      bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
      executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
  
      // Eagerly initialize constant cells since the concurrent compiler can access them.
      if (canUseJIT()) {
          sentinelMapBucket();
          sentinelSetBucket();
      }
  
<span class="line-modified">!     Thread::current().setCurrentAtomicStringTable(existingEntryAtomicStringTable);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(JIT)</span>
<span class="line-removed">-     jitStubs = std::make_unique&lt;JITThunks&gt;();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(FTL_JIT)</span>
<span class="line-removed">-     ftlThunks = std::make_unique&lt;FTL::Thunks&gt;();</span>
<span class="line-removed">- #endif // ENABLE(FTL_JIT)</span>
  
  #if !ENABLE(C_LOOP)
      initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
  #endif
  
<span class="line-new-header">--- 383,20 ---</span>
      moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
      evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
      functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
      hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
      hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));
      bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
      executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
  
      // Eagerly initialize constant cells since the concurrent compiler can access them.
      if (canUseJIT()) {
          sentinelMapBucket();
          sentinelSetBucket();
      }
  
<span class="line-modified">!     Thread::current().setCurrentAtomStringTable(existingEntryAtomStringTable);</span>
  
  #if !ENABLE(C_LOOP)
      initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,11 ***</span>
      heap.notifyIsSafeToCollect();
  
      LLInt::Data::performAssertions(*this);
  
      if (UNLIKELY(Options::useProfiler())) {
<span class="line-modified">!         m_perBytecodeProfiler = std::make_unique&lt;Profiler::Database&gt;(*this);</span>
  
          StringPrintStream pathOut;
          const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
          if (profilerPath)
              pathOut.print(profilerPath, &quot;/&quot;);
<span class="line-new-header">--- 405,11 ---</span>
      heap.notifyIsSafeToCollect();
  
      LLInt::Data::performAssertions(*this);
  
      if (UNLIKELY(Options::useProfiler())) {
<span class="line-modified">!         m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(*this);</span>
  
          StringPrintStream pathOut;
          const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
          if (profilerPath)
              pathOut.print(profilerPath, &quot;/&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 442,11 ***</span>
  
      // Initialize this last, as a free way of asserting that VM initialization itself
      // won&#39;t use this.
      m_typedArrayController = adoptRef(new SimpleTypedArrayController());
  
<span class="line-modified">!     m_bytecodeIntrinsicRegistry = std::make_unique&lt;BytecodeIntrinsicRegistry&gt;(*this);</span>
  
      if (Options::useTypeProfiler())
          enableTypeProfiler();
      if (Options::useControlFlowProfiler())
          enableControlFlowProfiler();
<span class="line-new-header">--- 421,11 ---</span>
  
      // Initialize this last, as a free way of asserting that VM initialization itself
      // won&#39;t use this.
      m_typedArrayController = adoptRef(new SimpleTypedArrayController());
  
<span class="line-modified">!     m_bytecodeIntrinsicRegistry = makeUnique&lt;BytecodeIntrinsicRegistry&gt;(*this);</span>
  
      if (Options::useTypeProfiler())
          enableTypeProfiler();
      if (Options::useControlFlowProfiler())
          enableControlFlowProfiler();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,10 ***</span>
<span class="line-new-header">--- 439,15 ---</span>
              m_samplingProfiler-&gt;registerForReportAtExit();
          m_samplingProfiler-&gt;start();
      }
  #endif // ENABLE(SAMPLING_PROFILER)
  
<span class="line-added">+     if (Options::useRandomizingFuzzerAgent())</span>
<span class="line-added">+         setFuzzerAgent(makeUnique&lt;RandomizingFuzzerAgent&gt;(*this));</span>
<span class="line-added">+     else if (Options::useDoublePredictionFuzzerAgent())</span>
<span class="line-added">+         setFuzzerAgent(makeUnique&lt;DoublePredictionFuzzerAgent&gt;(*this));</span>
<span class="line-added">+ </span>
      if (Options::alwaysGeneratePCToCodeOriginMap())
          setShouldBuildPCToCodeOriginMapping();
  
      if (Options::watchdog()) {
          Watchdog&amp; watchdog = ensureWatchdog();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,18 ***</span>
      }
  
  #if ENABLE(JIT)
      // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
      if (canUseJIT()) {
          getCTIInternalFunctionTrampolineFor(CodeForCall);
          getCTIInternalFunctionTrampolineFor(CodeForConstruct);
      }
  #endif
  
<span class="line-removed">-     if (!canUseJIT())</span>
<span class="line-removed">-         noJITValueProfileSingleton = std::make_unique&lt;ValueProfile&gt;(0);</span>
<span class="line-removed">- </span>
      if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
          ensureShadowChicken();
  
      VMInspector::instance().add(this);
  }
<span class="line-new-header">--- 455,19 ---</span>
      }
  
  #if ENABLE(JIT)
      // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
      if (canUseJIT()) {
<span class="line-added">+         jitStubs = makeUnique&lt;JITThunks&gt;();</span>
<span class="line-added">+ #if ENABLE(FTL_JIT)</span>
<span class="line-added">+         ftlThunks = makeUnique&lt;FTL::Thunks&gt;();</span>
<span class="line-added">+ #endif // ENABLE(FTL_JIT)</span>
          getCTIInternalFunctionTrampolineFor(CodeForCall);
          getCTIInternalFunctionTrampolineFor(CodeForConstruct);
      }
  #endif
  
      if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
          ensureShadowChicken();
  
      VMInspector::instance().add(this);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 555,11 ***</span>
  
      delete emptyList;
  
      delete propertyNames;
      if (vmType != Default)
<span class="line-modified">!         delete m_atomicStringTable;</span>
  
      delete clientData;
      delete m_regExpCache;
  
  #if ENABLE(REGEXP_TRACING)
<span class="line-new-header">--- 540,11 ---</span>
  
      delete emptyList;
  
      delete propertyNames;
      if (vmType != Default)
<span class="line-modified">!         delete m_atomStringTable;</span>
  
      delete clientData;
      delete m_regExpCache;
  
  #if ENABLE(REGEXP_TRACING)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,11 ***</span>
  }
  
  HeapProfiler&amp; VM::ensureHeapProfiler()
  {
      if (!m_heapProfiler)
<span class="line-modified">!         m_heapProfiler = std::make_unique&lt;HeapProfiler&gt;(*this);</span>
      return *m_heapProfiler;
  }
  
  #if ENABLE(SAMPLING_PROFILER)
  SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
<span class="line-new-header">--- 617,11 ---</span>
  }
  
  HeapProfiler&amp; VM::ensureHeapProfiler()
  {
      if (!m_heapProfiler)
<span class="line-modified">!         m_heapProfiler = makeUnique&lt;HeapProfiler&gt;(*this);</span>
      return *m_heapProfiler;
  }
  
  #if ENABLE(SAMPLING_PROFILER)
  SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,31 ***</span>
  static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
  {
      static NativeJITCode* result;
      static std::once_flag onceKey;
      std::call_once(onceKey, [&amp;] {
<span class="line-modified">!         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITCode::HostCallThunk, NoIntrinsic);</span>
      });
      return makeRef(*result);
  }
  
  static Ref&lt;NativeJITCode&gt; jitCodeForConstructTrampoline()
  {
      static NativeJITCode* result;
      static std::once_flag onceKey;
      std::call_once(onceKey, [&amp;] {
<span class="line-modified">!         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITCode::HostCallThunk, NoIntrinsic);</span>
      });
      return makeRef(*result);
  }
  
  NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
  {
  #if ENABLE(JIT)
      if (canUseJIT()) {
          return jitStubs-&gt;hostFunctionStub(
<span class="line-modified">!             this, function, constructor,</span>
              intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
              intrinsic, signature, name);
      }
  #endif // ENABLE(JIT)
      UNUSED_PARAM(intrinsic);
<span class="line-new-header">--- 681,31 ---</span>
  static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
  {
      static NativeJITCode* result;
      static std::once_flag onceKey;
      std::call_once(onceKey, [&amp;] {
<span class="line-modified">!         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITType::HostCallThunk, NoIntrinsic);</span>
      });
      return makeRef(*result);
  }
  
  static Ref&lt;NativeJITCode&gt; jitCodeForConstructTrampoline()
  {
      static NativeJITCode* result;
      static std::once_flag onceKey;
      std::call_once(onceKey, [&amp;] {
<span class="line-modified">!         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITType::HostCallThunk, NoIntrinsic);</span>
      });
      return makeRef(*result);
  }
  
  NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
  {
  #if ENABLE(JIT)
      if (canUseJIT()) {
          return jitStubs-&gt;hostFunctionStub(
<span class="line-modified">!             *this, function, constructor,</span>
              intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
              intrinsic, signature, name);
      }
  #endif // ENABLE(JIT)
      UNUSED_PARAM(intrinsic);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,12 ***</span>
  MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
  {
  #if ENABLE(JIT)
      if (canUseJIT()) {
          if (kind == CodeForCall)
<span class="line-modified">!             return jitStubs-&gt;ctiInternalFunctionCall(this).retagged&lt;JSEntryPtrTag&gt;();</span>
<span class="line-modified">!         return jitStubs-&gt;ctiInternalFunctionConstruct(this).retagged&lt;JSEntryPtrTag&gt;();</span>
      }
  #endif
      if (kind == CodeForCall)
          return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
      return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
<span class="line-new-header">--- 716,12 ---</span>
  MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
  {
  #if ENABLE(JIT)
      if (canUseJIT()) {
          if (kind == CodeForCall)
<span class="line-modified">!             return jitStubs-&gt;ctiInternalFunctionCall(*this).retagged&lt;JSEntryPtrTag&gt;();</span>
<span class="line-modified">!         return jitStubs-&gt;ctiInternalFunctionConstruct(*this).retagged&lt;JSEntryPtrTag&gt;();</span>
      }
  #endif
      if (kind == CodeForCall)
          return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
      return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,10 ***</span>
<span class="line-new-header">--- 731,11 ---</span>
  {
  }
  
  void VM::resetDateCache()
  {
<span class="line-added">+     utcTimeOffsetCache.reset();</span>
      localTimeOffsetCache.reset();
      cachedDateString = String();
      cachedDateStringValue = std::numeric_limits&lt;double&gt;::quiet_NaN();
      dateInstanceCache.reset();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 783,11 ***</span>
  }
  
  void VM::shrinkFootprintWhenIdle()
  {
      whenIdle([=] () {
<span class="line-modified">!         sanitizeStackForVM(this);</span>
          deleteAllCode(DeleteAllCodeIfNotCollecting);
          heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
          // FIXME: Consider stopping various automatic threads here.
          // https://bugs.webkit.org/show_bug.cgi?id=185447
          WTF::releaseFastMallocFreeMemory();
<span class="line-new-header">--- 769,11 ---</span>
  }
  
  void VM::shrinkFootprintWhenIdle()
  {
      whenIdle([=] () {
<span class="line-modified">!         sanitizeStackForVM(*this);</span>
          deleteAllCode(DeleteAllCodeIfNotCollecting);
          heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
          // FIXME: Consider stopping various automatic threads here.
          // https://bugs.webkit.org/show_bug.cgi?id=185447
          WTF::releaseFastMallocFreeMemory();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
  void VM::clearSourceProviderCaches()
  {
      sourceProviderCacheMap.clear();
  }
  
<span class="line-modified">! void VM::throwException(ExecState* exec, Exception* exception)</span>
  {
      ASSERT(exec == topCallFrame || exec-&gt;isGlobalExec() || exec == exec-&gt;lexicalGlobalObject()-&gt;callFrameAtDebuggerEntry());
      CallFrame* throwOriginFrame = exec-&gt;isGlobalExec() ? exec : topJSCallFrame();
  
      if (Options::breakOnThrow()) {
<span class="line-new-header">--- 791,11 ---</span>
  void VM::clearSourceProviderCaches()
  {
      sourceProviderCacheMap.clear();
  }
  
<span class="line-modified">! Exception* VM::throwException(ExecState* exec, Exception* exception)</span>
  {
      ASSERT(exec == topCallFrame || exec-&gt;isGlobalExec() || exec == exec-&gt;lexicalGlobalObject()-&gt;callFrameAtDebuggerEntry());
      CallFrame* throwOriginFrame = exec-&gt;isGlobalExec() ? exec : topJSCallFrame();
  
      if (Options::breakOnThrow()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 824,26 ***</span>
  
  #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
      m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
      m_throwingThread = &amp;Thread::current();
  #endif
  }
  
<span class="line-modified">! JSValue VM::throwException(ExecState* exec, JSValue thrownValue)</span>
  {
      VM&amp; vm = *this;
      Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
      if (!exception)
          exception = Exception::create(*this, thrownValue);
  
<span class="line-modified">!     throwException(exec, exception);</span>
<span class="line-removed">-     return JSValue(exception);</span>
  }
  
<span class="line-modified">! JSObject* VM::throwException(ExecState* exec, JSObject* error)</span>
  {
<span class="line-modified">!     return asObject(throwException(exec, JSValue(error)));</span>
  }
  
  void VM::setStackPointerAtVMEntry(void* sp)
  {
      m_stackPointerAtVMEntry = sp;
<span class="line-new-header">--- 810,26 ---</span>
  
  #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
      m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
      m_throwingThread = &amp;Thread::current();
  #endif
<span class="line-added">+     return exception;</span>
  }
  
<span class="line-modified">! Exception* VM::throwException(ExecState* exec, JSValue thrownValue)</span>
  {
      VM&amp; vm = *this;
      Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
      if (!exception)
          exception = Exception::create(*this, thrownValue);
  
<span class="line-modified">!     return throwException(exec, exception);</span>
  }
  
<span class="line-modified">! Exception* VM::throwException(ExecState* exec, JSObject* error)</span>
  {
<span class="line-modified">!     return throwException(exec, JSValue(error));</span>
  }
  
  void VM::setStackPointerAtVMEntry(void* sp)
  {
      m_stackPointerAtVMEntry = sp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,20 ***</span>
          }
      }
  }
  #endif
  
<span class="line-modified">! void logSanitizeStack(VM* vm)</span>
  {
<span class="line-modified">!     if (Options::verboseSanitizeStack() &amp;&amp; vm-&gt;topCallFrame) {</span>
          int dummy;
          auto&amp; stackBounds = Thread::current().stack();
          dataLog(
<span class="line-modified">!             &quot;Sanitizing stack for VM = &quot;, RawPointer(vm), &quot; with top call frame at &quot;, RawPointer(vm-&gt;topCallFrame),</span>
              &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
<span class="line-modified">!             pointerDump(vm-&gt;topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,</span>
<span class="line-modified">!             vm-&gt;topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm-&gt;lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);</span>
      }
  }
  
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
  char* VM::acquireRegExpPatternContexBuffer()
<span class="line-new-header">--- 923,20 ---</span>
          }
      }
  }
  #endif
  
<span class="line-modified">! void logSanitizeStack(VM&amp; vm)</span>
  {
<span class="line-modified">!     if (Options::verboseSanitizeStack() &amp;&amp; vm.topCallFrame) {</span>
          int dummy;
          auto&amp; stackBounds = Thread::current().stack();
          dataLog(
<span class="line-modified">!             &quot;Sanitizing stack for VM = &quot;, RawPointer(&amp;vm), &quot; with top call frame at &quot;, RawPointer(vm.topCallFrame),</span>
              &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
<span class="line-modified">!             pointerDump(vm.topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,</span>
<span class="line-modified">!             vm.topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm.lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);</span>
      }
  }
  
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
  char* VM::acquireRegExpPatternContexBuffer()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,12 ***</span>
  }
  
  bool VM::enableTypeProfiler()
  {
      auto enableTypeProfiler = [this] () {
<span class="line-modified">!         this-&gt;m_typeProfiler = std::make_unique&lt;TypeProfiler&gt;();</span>
<span class="line-modified">!         this-&gt;m_typeProfilerLog = std::make_unique&lt;TypeProfilerLog&gt;(*this);</span>
      };
  
      return enableProfilerWithRespectToCount(m_typeProfilerEnabledCount, enableTypeProfiler);
  }
  
<span class="line-new-header">--- 1039,12 ---</span>
  }
  
  bool VM::enableTypeProfiler()
  {
      auto enableTypeProfiler = [this] () {
<span class="line-modified">!         this-&gt;m_typeProfiler = makeUnique&lt;TypeProfiler&gt;();</span>
<span class="line-modified">!         this-&gt;m_typeProfilerLog = makeUnique&lt;TypeProfilerLog&gt;(*this);</span>
      };
  
      return enableProfilerWithRespectToCount(m_typeProfilerEnabledCount, enableTypeProfiler);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1073,11 ***</span>
  }
  
  bool VM::enableControlFlowProfiler()
  {
      auto enableControlFlowProfiler = [this] () {
<span class="line-modified">!         this-&gt;m_controlFlowProfiler = std::make_unique&lt;ControlFlowProfiler&gt;();</span>
      };
  
      return enableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, enableControlFlowProfiler);
  }
  
<span class="line-new-header">--- 1059,11 ---</span>
  }
  
  bool VM::enableControlFlowProfiler()
  {
      auto enableControlFlowProfiler = [this] () {
<span class="line-modified">!         this-&gt;m_controlFlowProfiler = makeUnique&lt;ControlFlowProfiler&gt;();</span>
      };
  
      return enableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, enableControlFlowProfiler);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1099,39 ***</span>
      typeProfiler()-&gt;dumpTypeProfilerData(*this);
  }
  
  void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
  {
<span class="line-modified">!     m_microtaskQueue.append(std::make_unique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));</span>
  }
  
<span class="line-modified">! void VM::drainMicrotasks()</span>
  {
<span class="line-modified">!     while (!m_microtaskQueue.isEmpty()) {</span>
<span class="line-modified">!         m_microtaskQueue.takeFirst()-&gt;run();</span>
<span class="line-modified">!         if (m_onEachMicrotaskTick)</span>
<span class="line-modified">!             m_onEachMicrotaskTick(*this);</span>
      }
  }
  
  void QueuedTask::run()
  {
      m_microtask-&gt;run(m_globalObject-&gt;globalExec());
  }
  
<span class="line-modified">! void sanitizeStackForVM(VM* vm)</span>
  {
      logSanitizeStack(vm);
<span class="line-modified">!     if (vm-&gt;topCallFrame) {</span>
          auto&amp; stackBounds = Thread::current().stack();
<span class="line-modified">!         ASSERT(vm-&gt;currentThreadIsHoldingAPILock());</span>
<span class="line-modified">!         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm-&gt;lastStackTop()));</span>
      }
  #if ENABLE(C_LOOP)
<span class="line-modified">!     vm-&gt;interpreter-&gt;cloopStack().sanitizeStack();</span>
  #else
<span class="line-modified">!     sanitizeStackForVMImpl(vm);</span>
  #endif
  }
  
  size_t VM::committedStackByteCount()
  {
<span class="line-new-header">--- 1085,78 ---</span>
      typeProfiler()-&gt;dumpTypeProfilerData(*this);
  }
  
  void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
  {
<span class="line-modified">!     m_microtaskQueue.append(makeUnique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));</span>
  }
  
<span class="line-modified">! void VM::callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp; promise)</span>
  {
<span class="line-modified">!     JSObject* callback = promise-&gt;globalObject()-&gt;unhandledRejectionCallback();</span>
<span class="line-modified">!     if (!callback)</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-added">+     auto scope = DECLARE_CATCH_SCOPE(*this);</span>
<span class="line-added">+ </span>
<span class="line-added">+     CallData callData;</span>
<span class="line-added">+     CallType callType = getCallData(*this, callback, callData);</span>
<span class="line-added">+     ASSERT(callType != CallType::None);</span>
<span class="line-added">+ </span>
<span class="line-added">+     MarkedArgumentBuffer args;</span>
<span class="line-added">+     args.append(promise.get());</span>
<span class="line-added">+     args.append(promise-&gt;result(*this));</span>
<span class="line-added">+     call(promise-&gt;globalObject()-&gt;globalExec(), callback, callType, callData, jsNull(), args);</span>
<span class="line-added">+     scope.clearException();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void VM::didExhaustMicrotaskQueue()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto unhandledRejections = WTFMove(m_aboutToBeNotifiedRejectedPromises);</span>
<span class="line-added">+     for (auto&amp; promise : unhandledRejections) {</span>
<span class="line-added">+         if (promise-&gt;isHandled(*this))</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         callPromiseRejectionCallback(promise);</span>
      }
  }
  
<span class="line-added">+ void VM::promiseRejected(JSPromise* promise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_aboutToBeNotifiedRejectedPromises.constructAndAppend(*this, promise);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void VM::drainMicrotasks()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     do {</span>
<span class="line-added">+         while (!m_microtaskQueue.isEmpty()) {</span>
<span class="line-added">+             m_microtaskQueue.takeFirst()-&gt;run();</span>
<span class="line-added">+             if (m_onEachMicrotaskTick)</span>
<span class="line-added">+                 m_onEachMicrotaskTick(*this);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         didExhaustMicrotaskQueue();</span>
<span class="line-added">+     } while (!m_microtaskQueue.isEmpty());</span>
<span class="line-added">+     finalizeSynchronousJSExecution();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void QueuedTask::run()
  {
      m_microtask-&gt;run(m_globalObject-&gt;globalExec());
  }
  
<span class="line-modified">! void sanitizeStackForVM(VM&amp; vm)</span>
  {
      logSanitizeStack(vm);
<span class="line-modified">!     if (vm.topCallFrame) {</span>
          auto&amp; stackBounds = Thread::current().stack();
<span class="line-modified">!         ASSERT(vm.currentThreadIsHoldingAPILock());</span>
<span class="line-modified">!         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm.lastStackTop()));</span>
      }
  #if ENABLE(C_LOOP)
<span class="line-modified">!     vm.interpreter-&gt;cloopStack().sanitizeStack();</span>
  #else
<span class="line-modified">!     sanitizeStackForVMImpl(&amp;vm);</span>
  #endif
  }
  
  size_t VM::committedStackByteCount()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1155,10 ***</span>
<span class="line-new-header">--- 1180,15 ---</span>
  
  bool VM::isSafeToRecurseSoftCLoop() const
  {
      return interpreter-&gt;cloopStack().isSafeToRecurse();
  }
<span class="line-added">+ </span>
<span class="line-added">+ void* VM::currentCLoopStackPointer() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return interpreter-&gt;cloopStack().currentStackPointer();</span>
<span class="line-added">+ }</span>
  #endif // ENABLE(C_LOOP)
  
  #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
  void VM::verifyExceptionCheckNeedIsSatisfied(unsigned recursionDepth, ExceptionEventLocation&amp; location)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1236,59 ***</span>
  
  void VM::ensureShadowChicken()
  {
      if (m_shadowChicken)
          return;
<span class="line-modified">!     m_shadowChicken = std::make_unique&lt;ShadowChicken&gt;();</span>
  }
  
  #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
      IsoSubspace* VM::name##Slow() \
      { \
          ASSERT(!m_##name); \
<span class="line-modified">!         auto space = std::make_unique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
          WTF::storeStoreFence(); \
          m_##name = WTFMove(space); \
          return m_##name.get(); \
      }
  
  
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, destructibleObjectHeapCellType.get(), JSCallbackFunction)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, destructibleObjectHeapCellType.get(), ErrorInstance)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, cellHeapCellType.get(), JSNativeStdFunction)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, destructibleObjectHeapCellType.get(), ProxyRevoke)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, destructibleObjectHeapCellType.get(), JSWeakMap)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, destructibleObjectHeapCellType.get(), JSWeakSet)</span>
  #if JSC_OBJC_API_ENABLED
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, destructibleObjectHeapCellType.get(), ObjCCallbackFunction)</span>
  #endif
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, cellHeapCellType.get(), WebAssemblyFunction)</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction)</span>
  #endif
  
  #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
  
  #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
      IsoSubspace* VM::name##Slow() \
      { \
          ASSERT(!m_##name); \
<span class="line-modified">!         auto space = std::make_unique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
          WTF::storeStoreFence(); \
          m_##name = WTFMove(space); \
          return &amp;m_##name-&gt;space; \
      }
  
<span class="line-modified">! DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(inferredValueSpace, destructibleCellHeapCellType.get(), InferredValue)</span>
<span class="line-modified">! DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable)</span>
<span class="line-removed">- DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable)</span>
  
  #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
  
  
  JSCell* VM::sentinelSetBucketSlow()
  {
      ASSERT(!m_sentinelSetBucket);
      auto* sentinel = JSSet::BucketType::createSentinel(*this);
<span class="line-new-header">--- 1266,72 ---</span>
  
  void VM::ensureShadowChicken()
  {
      if (m_shadowChicken)
          return;
<span class="line-modified">!     m_shadowChicken = makeUnique&lt;ShadowChicken&gt;();</span>
  }
  
  #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
      IsoSubspace* VM::name##Slow() \
      { \
          ASSERT(!m_##name); \
<span class="line-modified">!         auto space = makeUnique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
          WTF::storeStoreFence(); \
          m_##name = WTFMove(space); \
          return m_##name.get(); \
      }
  
  
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction) // Hash:0xd7916d41</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, destructibleObjectHeapCellType.get(), JSCallbackFunction) // Hash:0xe7648ebc</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction) // Hash:0x18091000</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, destructibleObjectHeapCellType.get(), ErrorInstance) // Hash:0x3f40d4a</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, cellHeapCellType.get(), JSNativeStdFunction) // Hash:0x70ed61e4</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, destructibleObjectHeapCellType.get(), ProxyRevoke) // Hash:0xb506a939</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, destructibleObjectHeapCellType.get(), JSWeakMap) // Hash:0x662b12a3</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, destructibleObjectHeapCellType.get(), JSWeakSet) // Hash:0x4c781b30</span>
<span class="line-added">+ DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakObjectRefSpace, cellHeapCellType.get(), JSWeakObjectRef) // Hash:0x8ec68f1f</span>
  #if JSC_OBJC_API_ENABLED
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, destructibleObjectHeapCellType.get(), ObjCCallbackFunction) // Hash:0x10f610b8</span>
  #endif
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock) // Hash:0x9ad995cd</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, webAssemblyFunctionHeapCellType.get(), WebAssemblyFunction) // Hash:0x8b7c32db</span>
<span class="line-modified">! DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction) // Hash:0xd4a5ff01</span>
  #endif
  
  #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
  
  #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
      IsoSubspace* VM::name##Slow() \
      { \
          ASSERT(!m_##name); \
<span class="line-modified">!         auto space = makeUnique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
          WTF::storeStoreFence(); \
          m_##name = WTFMove(space); \
          return &amp;m_##name-&gt;space; \
      }
  
<span class="line-modified">! DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable) // Hash:0x958e3e9d</span>
<span class="line-modified">! DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable) // Hash:0x6506fa3c</span>
  
  #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
  
<span class="line-added">+ Structure* VM::setIteratorStructureSlow()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!m_setIteratorStructure);</span>
<span class="line-added">+     m_setIteratorStructure.set(*this, JSSetIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-added">+     return m_setIteratorStructure.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Structure* VM::mapIteratorStructureSlow()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!m_mapIteratorStructure);</span>
<span class="line-added">+     m_mapIteratorStructure.set(*this, JSMapIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-added">+     return m_mapIteratorStructure.get();</span>
<span class="line-added">+ }</span>
  
  JSCell* VM::sentinelSetBucketSlow()
  {
      ASSERT(!m_sentinelSetBucket);
      auto* sentinel = JSSet::BucketType::createSentinel(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1302,10 ***</span>
<span class="line-new-header">--- 1345,19 ---</span>
      auto* sentinel = JSMap::BucketType::createSentinel(*this);
      m_sentinelMapBucket.set(*this, sentinel);
      return sentinel;
  }
  
<span class="line-added">+ JSPropertyNameEnumerator* VM::emptyPropertyNameEnumeratorSlow()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!m_emptyPropertyNameEnumerator);</span>
<span class="line-added">+     PropertyNameArray propertyNames(*this, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);</span>
<span class="line-added">+     auto* enumerator = JSPropertyNameEnumerator::create(*this, nullptr, 0, 0, WTFMove(propertyNames));</span>
<span class="line-added">+     m_emptyPropertyNameEnumerator.set(*this, enumerator);</span>
<span class="line-added">+     return enumerator;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  JSGlobalObject* VM::vmEntryGlobalObject(const CallFrame* callFrame) const
  {
      if (callFrame &amp;&amp; callFrame-&gt;isGlobalExec()) {
          ASSERT(callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;isObject());
          ASSERT(callFrame == callFrame-&gt;lexicalGlobalObject()-&gt;globalExec());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1313,6 ***</span>
<span class="line-new-header">--- 1365,11 ---</span>
      }
      ASSERT(entryScope);
      return entryScope-&gt;globalObject();
  }
  
<span class="line-added">+ void VM::setCrashOnVMCreation(bool shouldCrash)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     vmCreationShouldCrash = shouldCrash;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="TypeSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VM.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>