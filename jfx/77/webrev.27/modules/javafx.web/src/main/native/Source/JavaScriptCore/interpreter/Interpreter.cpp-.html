<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Interpreter.h&quot;
  32 
  33 #include &quot;BatchedTransitionOptimizer.h&quot;
  34 #include &quot;Bytecodes.h&quot;
  35 #include &quot;CallFrameClosure.h&quot;
  36 #include &quot;CatchScope.h&quot;
  37 #include &quot;CodeBlock.h&quot;
  38 #include &quot;CodeCache.h&quot;
  39 #include &quot;DirectArguments.h&quot;
  40 #include &quot;ExecutableBaseInlines.h&quot;
  41 #include &quot;Heap.h&quot;
  42 #include &quot;Debugger.h&quot;
  43 #include &quot;DebuggerCallFrame.h&quot;
  44 #include &quot;DirectEvalCodeCache.h&quot;
  45 #include &quot;ErrorInstance.h&quot;
  46 #include &quot;EvalCodeBlock.h&quot;
  47 #include &quot;Exception.h&quot;
  48 #include &quot;ExceptionHelpers.h&quot;
  49 #include &quot;FrameTracers.h&quot;
  50 #include &quot;FunctionCodeBlock.h&quot;
  51 #include &quot;InterpreterInlines.h&quot;
  52 #include &quot;JITCodeInlines.h&quot;
  53 #include &quot;JSArrayInlines.h&quot;
  54 #include &quot;JSBoundFunction.h&quot;
  55 #include &quot;JSCInlines.h&quot;
  56 #include &quot;JSFixedArray.h&quot;
  57 #include &quot;JSImmutableButterfly.h&quot;
  58 #include &quot;JSLexicalEnvironment.h&quot;
  59 #include &quot;JSModuleEnvironment.h&quot;
  60 #include &quot;JSString.h&quot;
  61 #include &quot;JSWithScope.h&quot;
  62 #include &quot;LLIntCLoop.h&quot;
  63 #include &quot;LLIntThunks.h&quot;
  64 #include &quot;LiteralParser.h&quot;
  65 #include &quot;ModuleProgramCodeBlock.h&quot;
  66 #include &quot;ObjectPrototype.h&quot;
  67 #include &quot;Parser.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
  69 #include &quot;ProtoCallFrame.h&quot;
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;Register.h&quot;
  72 #include &quot;RegisterAtOffsetList.h&quot;
  73 #include &quot;ScopedArguments.h&quot;
  74 #include &quot;StackAlignment.h&quot;
  75 #include &quot;StackFrame.h&quot;
  76 #include &quot;StackVisitor.h&quot;
  77 #include &quot;StrictEvalActivation.h&quot;
  78 #include &quot;StrongInlines.h&quot;
  79 #include &quot;Symbol.h&quot;
  80 #include &quot;VMEntryScope.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;VMInspector.h&quot;
  83 #include &quot;VirtualRegister.h&quot;
  84 
  85 #include &lt;limits.h&gt;
  86 #include &lt;stdio.h&gt;
  87 #include &lt;wtf/NeverDestroyed.h&gt;
  88 #include &lt;wtf/StackStats.h&gt;
  89 #include &lt;wtf/StdLibExtras.h&gt;
  90 #include &lt;wtf/StringPrintStream.h&gt;
  91 #include &lt;wtf/Threading.h&gt;
  92 #include &lt;wtf/text/StringBuilder.h&gt;
  93 
  94 #if ENABLE(JIT)
  95 #include &quot;JIT.h&quot;
  96 #endif
  97 
  98 namespace JSC {
  99 
 100 JSValue eval(CallFrame* callFrame)
 101 {
 102     VM&amp; vm = callFrame-&gt;vm();
 103     auto scope = DECLARE_THROW_SCOPE(vm);
 104 
 105     if (!callFrame-&gt;argumentCount())
 106         return jsUndefined();
 107 
 108     JSValue program = callFrame-&gt;argument(0);
 109     if (!program.isString())
 110         return program;
 111 
 112     TopCallFrameSetter topCallFrame(vm, callFrame);
 113     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject();
 114     if (!globalObject-&gt;evalEnabled()) {
 115         throwException(callFrame, scope, createEvalError(callFrame, globalObject-&gt;evalDisabledErrorMessage()));
 116         return jsUndefined();
 117     }
 118     String programSource = asString(program)-&gt;value(callFrame);
 119     RETURN_IF_EXCEPTION(scope, JSValue());
 120 
 121     CallFrame* callerFrame = callFrame-&gt;callerFrame();
 122     CallSiteIndex callerCallSiteIndex = callerFrame-&gt;callSiteIndex();
 123     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
 124     JSScope* callerScopeChain = callerFrame-&gt;uncheckedR(callerCodeBlock-&gt;scopeRegister().offset()).Register::scope();
 125     UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock-&gt;unlinkedCodeBlock();
 126 
 127     bool isArrowFunctionContext = callerUnlinkedCodeBlock-&gt;isArrowFunction() || callerUnlinkedCodeBlock-&gt;isArrowFunctionContext();
 128 
 129     DerivedContextType derivedContextType = callerUnlinkedCodeBlock-&gt;derivedContextType();
 130     if (!isArrowFunctionContext &amp;&amp; callerUnlinkedCodeBlock-&gt;isClassContext()) {
 131         derivedContextType = callerUnlinkedCodeBlock-&gt;isConstructor()
 132             ? DerivedContextType::DerivedConstructorContext
 133             : DerivedContextType::DerivedMethodContext;
 134     }
 135 
 136     EvalContextType evalContextType;
 137     if (isFunctionParseMode(callerUnlinkedCodeBlock-&gt;parseMode()))
 138         evalContextType = EvalContextType::FunctionEvalContext;
 139     else if (callerUnlinkedCodeBlock-&gt;codeType() == EvalCode)
 140         evalContextType = callerUnlinkedCodeBlock-&gt;evalContextType();
 141     else
 142         evalContextType = EvalContextType::None;
 143 
 144     DirectEvalExecutable* eval = callerCodeBlock-&gt;directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
 145     if (!eval) {
 146         if (!callerCodeBlock-&gt;isStrictMode()) {
 147             if (programSource.is8Bit()) {
 148                 LiteralParser&lt;LChar&gt; preparser(callFrame, programSource.characters8(), programSource.length(), NonStrictJSON);
 149                 if (JSValue parsedObject = preparser.tryLiteralParse())
 150                     RELEASE_AND_RETURN(scope, parsedObject);
 151 
 152             } else {
 153                 LiteralParser&lt;UChar&gt; preparser(callFrame, programSource.characters16(), programSource.length(), NonStrictJSON);
 154                 if (JSValue parsedObject = preparser.tryLiteralParse())
 155                     RELEASE_AND_RETURN(scope, parsedObject);
 156 
 157             }
 158             RETURN_IF_EXCEPTION(scope, JSValue());
 159         }
 160 
 161         VariableEnvironment variablesUnderTDZ;
 162         JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
 163         eval = DirectEvalExecutable::create(callFrame, makeSource(programSource, callerCodeBlock-&gt;source().provider()-&gt;sourceOrigin()), callerCodeBlock-&gt;isStrictMode(), derivedContextType, isArrowFunctionContext, evalContextType, &amp;variablesUnderTDZ);
 164         EXCEPTION_ASSERT(!!scope.exception() == !eval);
 165         if (!eval)
 166             return jsUndefined();
 167 
 168         callerCodeBlock-&gt;directEvalCodeCache().set(callFrame, callerCodeBlock, programSource, callerCallSiteIndex, eval);
 169     }
 170 
 171     JSValue thisValue = callerFrame-&gt;thisValue();
 172     Interpreter* interpreter = vm.interpreter;
 173     RELEASE_AND_RETURN(scope, interpreter-&gt;execute(eval, callFrame, thisValue, callerScopeChain));
 174 }
 175 
 176 unsigned sizeOfVarargs(CallFrame* callFrame, JSValue arguments, uint32_t firstVarArgOffset)
 177 {
 178     VM&amp; vm = callFrame-&gt;vm();
 179     auto scope = DECLARE_THROW_SCOPE(vm);
 180 
 181     if (UNLIKELY(!arguments.isCell())) {
 182         if (arguments.isUndefinedOrNull())
 183             return 0;
 184 
 185         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame, arguments));
 186         return 0;
 187     }
 188 
 189     JSCell* cell = arguments.asCell();
 190     unsigned length;
 191     switch (cell-&gt;type()) {
 192     case DirectArgumentsType:
 193         length = jsCast&lt;DirectArguments*&gt;(cell)-&gt;length(callFrame);
 194         break;
 195     case ScopedArgumentsType:
 196         length = jsCast&lt;ScopedArguments*&gt;(cell)-&gt;length(callFrame);
 197         break;
 198     case JSFixedArrayType:
 199         length = jsCast&lt;JSFixedArray*&gt;(cell)-&gt;size();
 200         break;
 201     case JSImmutableButterflyType:
 202         length = jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;length();
 203         break;
 204     case StringType:
 205     case SymbolType:
 206     case BigIntType:
 207         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame,  arguments));
 208         return 0;
 209 
 210     default:
 211         RELEASE_ASSERT(arguments.isObject());
 212         length = clampToUnsigned(toLength(callFrame, jsCast&lt;JSObject*&gt;(cell)));
 213         break;
 214     }
 215     RETURN_IF_EXCEPTION(scope, 0);
 216 
 217     if (length &gt;= firstVarArgOffset)
 218         length -= firstVarArgOffset;
 219     else
 220         length = 0;
 221 
 222     return length;
 223 }
 224 
 225 unsigned sizeFrameForForwardArguments(CallFrame* callFrame, VM&amp; vm, unsigned numUsedStackSlots)
 226 {
 227     auto scope = DECLARE_THROW_SCOPE(vm);
 228 
 229     unsigned length = callFrame-&gt;argumentCount();
 230     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 231     if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame-&gt;registers())))
 232         throwStackOverflowError(callFrame, scope);
 233 
 234     return length;
 235 }
 236 
 237 unsigned sizeFrameForVarargs(CallFrame* callFrame, VM&amp; vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)
 238 {
 239     auto scope = DECLARE_THROW_SCOPE(vm);
 240 
 241     unsigned length = sizeOfVarargs(callFrame, arguments, firstVarArgOffset);
 242     RETURN_IF_EXCEPTION(scope, 0);
 243 
 244     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 245     if (UNLIKELY(length &gt; maxArguments || !vm.ensureStackCapacityFor(calleeFrame-&gt;registers()))) {
 246         throwStackOverflowError(callFrame, scope);
 247         return 0;
 248     }
 249 
 250     return length;
 251 }
 252 
 253 void loadVarargs(CallFrame* callFrame, VirtualRegister firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)
 254 {
 255     if (UNLIKELY(!arguments.isCell()) || !length)
 256         return;
 257 
 258     VM&amp; vm = callFrame-&gt;vm();
 259     auto scope = DECLARE_THROW_SCOPE(vm);
 260     JSCell* cell = arguments.asCell();
 261 
 262     switch (cell-&gt;type()) {
 263     case DirectArgumentsType:
 264         scope.release();
 265         jsCast&lt;DirectArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 266         return;
 267     case ScopedArgumentsType:
 268         scope.release();
 269         jsCast&lt;ScopedArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 270         return;
 271     case JSFixedArrayType:
 272         scope.release();
 273         jsCast&lt;JSFixedArray*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 274         return;
 275     case JSImmutableButterflyType:
 276         scope.release();
 277         jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 278         return;
 279     default: {
 280         ASSERT(arguments.isObject());
 281         JSObject* object = jsCast&lt;JSObject*&gt;(cell);
 282         if (isJSArray(object)) {
 283             scope.release();
 284             jsCast&lt;JSArray*&gt;(object)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);
 285             return;
 286         }
 287         unsigned i;
 288         for (i = 0; i &lt; length &amp;&amp; object-&gt;canGetIndexQuickly(i + offset); ++i)
 289             callFrame-&gt;r(firstElementDest + i) = object-&gt;getIndexQuickly(i + offset);
 290         for (; i &lt; length; ++i) {
 291             JSValue value = object-&gt;get(callFrame, i + offset);
 292             RETURN_IF_EXCEPTION(scope, void());
 293             callFrame-&gt;r(firstElementDest + i) = value;
 294         }
 295         return;
 296     } }
 297 }
 298 
 299 void setupVarargsFrame(CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)
 300 {
 301     VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
 302 
 303     loadVarargs(
 304         callFrame,
 305         calleeFrameOffset + CallFrame::argumentOffset(0),
 306         arguments, offset, length);
 307 
 308     newCallFrame-&gt;setArgumentCountIncludingThis(length + 1);
 309 }
 310 
 311 void setupVarargsFrameAndSetThis(CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)
 312 {
 313     setupVarargsFrame(callFrame, newCallFrame, arguments, firstVarArgOffset, length);
 314     newCallFrame-&gt;setThisValue(thisValue);
 315 }
 316 
 317 void setupForwardArgumentsFrame(CallFrame* execCaller, CallFrame* execCallee, uint32_t length)
 318 {
 319     ASSERT(length == execCaller-&gt;argumentCount());
 320     unsigned offset = execCaller-&gt;argumentOffset(0) * sizeof(Register);
 321     memcpy(reinterpret_cast&lt;char*&gt;(execCallee) + offset, reinterpret_cast&lt;char*&gt;(execCaller) + offset, length * sizeof(Register));
 322     execCallee-&gt;setArgumentCountIncludingThis(length + 1);
 323 }
 324 
 325 void setupForwardArgumentsFrameAndSetThis(CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)
 326 {
 327     setupForwardArgumentsFrame(execCaller, execCallee, length);
 328     execCallee-&gt;setThisValue(thisValue);
 329 }
 330 
 331 
 332 
 333 Interpreter::Interpreter(VM&amp; vm)
 334     : m_vm(vm)
 335 #if ENABLE(C_LOOP)
 336     , m_cloopStack(vm)
 337 #endif
 338 {
 339 #if !ASSERT_DISABLED
 340     static std::once_flag assertOnceKey;
 341     std::call_once(assertOnceKey, [] {
 342         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i) {
 343             OpcodeID opcodeID = static_cast&lt;OpcodeID&gt;(i);
 344             RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
 345         }
 346     });
 347 #endif // USE(LLINT_EMBEDDED_OPCODE_ID)
 348 }
 349 
 350 Interpreter::~Interpreter()
 351 {
 352 }
 353 
 354 #if ENABLE(COMPUTED_GOTO_OPCODES)
 355 #if !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED
 356 HashMap&lt;Opcode, OpcodeID&gt;&amp; Interpreter::opcodeIDTable()
 357 {
 358     static NeverDestroyed&lt;HashMap&lt;Opcode, OpcodeID&gt;&gt; opcodeIDTable;
 359 
 360     static std::once_flag initializeKey;
 361     std::call_once(initializeKey, [&amp;] {
 362         const Opcode* opcodeTable = LLInt::opcodeMap();
 363         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i)
 364             opcodeIDTable.get().add(opcodeTable[i], static_cast&lt;OpcodeID&gt;(i));
 365     });
 366 
 367     return opcodeIDTable;
 368 }
 369 #endif // !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED
 370 #endif // ENABLE(COMPUTED_GOTO_OPCODES)
 371 
 372 #if !ASSERT_DISABLED
 373 bool Interpreter::isOpcode(Opcode opcode)
 374 {
 375 #if ENABLE(COMPUTED_GOTO_OPCODES)
 376     return opcode != HashTraits&lt;Opcode&gt;::emptyValue()
 377         &amp;&amp; !HashTraits&lt;Opcode&gt;::isDeletedValue(opcode)
 378         &amp;&amp; opcodeIDTable().contains(opcode);
 379 #else
 380     return opcode &gt;= 0 &amp;&amp; opcode &lt;= op_end;
 381 #endif
 382 }
 383 #endif // !ASSERT_DISABLED
 384 
 385 class GetStackTraceFunctor {
 386 public:
 387     GetStackTraceFunctor(VM&amp; vm, JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t capacity)
 388         : m_vm(vm)
 389         , m_owner(owner)
 390         , m_results(results)
 391         , m_framesToSkip(framesToSkip)
 392         , m_remainingCapacityForFrameCapture(capacity)
 393     {
 394         m_results.reserveInitialCapacity(capacity);
 395     }
 396 
 397     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 398     {
 399         if (m_framesToSkip &gt; 0) {
 400             m_framesToSkip--;
 401             return StackVisitor::Continue;
 402         }
 403 
 404         if (m_remainingCapacityForFrameCapture) {
 405             if (visitor-&gt;isWasmFrame()) {
 406                 m_results.append(StackFrame(visitor-&gt;wasmFunctionIndexOrName()));
 407             } else if (!!visitor-&gt;codeBlock() &amp;&amp; !visitor-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;isBuiltinFunction()) {
 408                 m_results.append(
 409                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell(), visitor-&gt;codeBlock(), visitor-&gt;bytecodeOffset()));
 410             } else {
 411                 m_results.append(
 412                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell()));
 413             }
 414 
 415             m_remainingCapacityForFrameCapture--;
 416             return StackVisitor::Continue;
 417         }
 418         return StackVisitor::Done;
 419     }
 420 
 421 private:
 422     VM&amp; m_vm;
 423     JSCell* m_owner;
 424     Vector&lt;StackFrame&gt;&amp; m_results;
 425     mutable size_t m_framesToSkip;
 426     mutable size_t m_remainingCapacityForFrameCapture;
 427 };
 428 
 429 void Interpreter::getStackTrace(JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t maxStackSize)
 430 {
 431     DisallowGC disallowGC;
 432     VM&amp; vm = m_vm;
 433     CallFrame* callFrame = vm.topCallFrame;
 434     if (!callFrame || !maxStackSize)
 435         return;
 436 
 437     size_t framesCount = 0;
 438     size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
 439     StackVisitor::visit(callFrame, &amp;vm, [&amp;] (StackVisitor&amp;) -&gt; StackVisitor::Status {
 440         if (++framesCount &lt; maxFramesCountNeeded)
 441             return StackVisitor::Continue;
 442         return StackVisitor::Done;
 443     });
 444     if (framesCount &lt;= framesToSkip)
 445         return;
 446 
 447     framesCount -= framesToSkip;
 448     framesCount = std::min(maxStackSize, framesCount);
 449 
 450     GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
 451     StackVisitor::visit(callFrame, &amp;vm, functor);
 452     ASSERT(results.size() == results.capacity());
 453 }
 454 
 455 String Interpreter::stackTraceAsString(VM&amp; vm, const Vector&lt;StackFrame&gt;&amp; stackTrace)
 456 {
 457     // FIXME: JSStringJoiner could be more efficient than StringBuilder here.
 458     StringBuilder builder;
 459     for (unsigned i = 0; i &lt; stackTrace.size(); i++) {
 460         builder.append(String(stackTrace[i].toString(vm)));
 461         if (i != stackTrace.size() - 1)
 462             builder.append(&#39;\n&#39;);
 463     }
 464     return builder.toString();
 465 }
 466 
 467 ALWAYS_INLINE static HandlerInfo* findExceptionHandler(StackVisitor&amp; visitor, CodeBlock* codeBlock, RequiredHandler requiredHandler)
 468 {
 469     ASSERT(codeBlock);
 470 #if ENABLE(DFG_JIT)
 471     ASSERT(!visitor-&gt;isInlinedFrame());
 472 #endif
 473 
 474     CallFrame* callFrame = visitor-&gt;callFrame();
 475     unsigned exceptionHandlerIndex;
 476     if (JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
 477         exceptionHandlerIndex = callFrame-&gt;callSiteIndex().bits();
 478     else
 479         exceptionHandlerIndex = callFrame-&gt;bytecodeOffset();
 480 
 481     return codeBlock-&gt;handlerForIndex(exceptionHandlerIndex, requiredHandler);
 482 }
 483 
 484 class GetCatchHandlerFunctor {
 485 public:
 486     GetCatchHandlerFunctor()
 487         : m_handler(0)
 488     {
 489     }
 490 
 491     HandlerInfo* handler() { return m_handler; }
 492 
 493     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 494     {
 495         visitor.unwindToMachineCodeBlockFrame();
 496 
 497         CodeBlock* codeBlock = visitor-&gt;codeBlock();
 498         if (!codeBlock)
 499             return StackVisitor::Continue;
 500 
 501         m_handler = findExceptionHandler(visitor, codeBlock, RequiredHandler::CatchHandler);
 502         if (m_handler)
 503             return StackVisitor::Done;
 504 
 505         return StackVisitor::Continue;
 506     }
 507 
 508 private:
 509     mutable HandlerInfo* m_handler;
 510 };
 511 
 512 ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM&amp; vm, CallFrame* callFrame)
 513 {
 514     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 515     if (Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger()) {
 516         SuspendExceptionScope scope(&amp;vm);
 517         if (callFrame-&gt;isAnyWasmCallee()
 518             || (callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;inherits&lt;JSFunction&gt;(vm)))
 519             debugger-&gt;unwindEvent(callFrame);
 520         else
 521             debugger-&gt;didExecuteProgram(callFrame);
 522         catchScope.assertNoException();
 523     }
 524 }
 525 
 526 class UnwindFunctor {
 527 public:
 528     UnwindFunctor(VM&amp; vm, CallFrame*&amp; callFrame, bool isTermination, CodeBlock*&amp; codeBlock, HandlerInfo*&amp; handler)
 529         : m_vm(vm)
 530         , m_callFrame(callFrame)
 531         , m_isTermination(isTermination)
 532         , m_codeBlock(codeBlock)
 533         , m_handler(handler)
 534     {
 535     }
 536 
 537     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 538     {
 539         visitor.unwindToMachineCodeBlockFrame();
 540         m_callFrame = visitor-&gt;callFrame();
 541         m_codeBlock = visitor-&gt;codeBlock();
 542 
 543         m_handler = nullptr;
 544         if (!m_isTermination) {
 545             if (m_codeBlock) {
 546                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
 547                 if (m_handler)
 548                     return StackVisitor::Done;
 549             }
 550         }
 551 
 552         notifyDebuggerOfUnwinding(m_vm, m_callFrame);
 553 
 554         copyCalleeSavesToEntryFrameCalleeSavesBuffer(visitor);
 555 
 556         bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
 557         if (shouldStopUnwinding)
 558             return StackVisitor::Done;
 559 
 560         return StackVisitor::Continue;
 561     }
 562 
 563 private:
 564     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
 565     {
 566 #if !ENABLE(C_LOOP) &amp;&amp; NUMBER_OF_CALLEE_SAVES_REGISTERS &gt; 0
 567         const RegisterAtOffsetList* currentCalleeSaves = visitor-&gt;calleeSaveRegisters();
 568 
 569         if (!currentCalleeSaves)
 570             return;
 571 
 572         RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
 573         RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();
 574         CPURegister* frame = reinterpret_cast&lt;CPURegister*&gt;(m_callFrame-&gt;registers());
 575 
 576         unsigned registerCount = currentCalleeSaves-&gt;size();
 577         VMEntryRecord* record = vmEntryRecord(m_vm.topEntryFrame);
 578         for (unsigned i = 0; i &lt; registerCount; i++) {
 579             RegisterAtOffset currentEntry = currentCalleeSaves-&gt;at(i);
 580             if (dontCopyRegisters.get(currentEntry.reg()))
 581                 continue;
 582             RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
 583 
 584             record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()] = *(frame + currentEntry.offsetAsIndex());
 585         }
 586 #else
 587         UNUSED_PARAM(visitor);
 588 #endif
 589     }
 590 
 591     VM&amp; m_vm;
 592     CallFrame*&amp; m_callFrame;
 593     bool m_isTermination;
 594     CodeBlock*&amp; m_codeBlock;
 595     HandlerInfo*&amp; m_handler;
 596 };
 597 
 598 NEVER_INLINE HandlerInfo* Interpreter::unwind(VM&amp; vm, CallFrame*&amp; callFrame, Exception* exception)
 599 {
 600     auto scope = DECLARE_CATCH_SCOPE(vm);
 601 
 602     ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) != vm.topEntryFrame);
 603     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
 604 
 605     JSValue exceptionValue = exception-&gt;value();
 606     ASSERT(!exceptionValue.isEmpty());
 607     ASSERT(!exceptionValue.isCell() || exceptionValue.asCell());
 608     // This shouldn&#39;t be possible (hence the assertions), but we&#39;re already in the slowest of
 609     // slow cases, so let&#39;s harden against it anyway to be safe.
 610     if (exceptionValue.isEmpty() || (exceptionValue.isCell() &amp;&amp; !exceptionValue.asCell()))
 611         exceptionValue = jsNull();
 612 
 613     EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
 614 
 615     // Calculate an exception handler vPC, unwinding call frames as necessary.
 616     HandlerInfo* handler = nullptr;
 617     UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
 618     StackVisitor::visit&lt;StackVisitor::TerminateIfTopEntryFrameIsEmpty&gt;(callFrame, &amp;vm, functor);
 619     if (!handler)
 620         return nullptr;
 621 
 622     return handler;
 623 }
 624 
 625 void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM&amp; vm, CallFrame* callFrame, Exception* exception)
 626 {
 627     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();
 628     if (debugger &amp;&amp; debugger-&gt;needsExceptionCallbacks() &amp;&amp; !exception-&gt;didNotifyInspectorOfThrow()) {
 629         // This code assumes that if the debugger is enabled then there is no inlining.
 630         // If that assumption turns out to be false then we&#39;ll ignore the inlined call
 631         // frames.
 632         // https://bugs.webkit.org/show_bug.cgi?id=121754
 633 
 634         bool hasCatchHandler;
 635         bool isTermination = isTerminatedExecutionException(vm, exception);
 636         if (isTermination)
 637             hasCatchHandler = false;
 638         else {
 639             GetCatchHandlerFunctor functor;
 640             StackVisitor::visit(callFrame, &amp;vm, functor);
 641             HandlerInfo* handler = functor.handler();
 642             ASSERT(!handler || handler-&gt;isCatchHandler());
 643             hasCatchHandler = !!handler;
 644         }
 645 
 646         debugger-&gt;exception(callFrame, exception-&gt;value(), hasCatchHandler);
 647     }
 648     exception-&gt;setDidNotifyInspectorOfThrow();
 649 }
 650 
 651 JSValue Interpreter::executeProgram(const SourceCode&amp; source, CallFrame* callFrame, JSObject* thisObj)
 652 {
 653     JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
 654     VM&amp; vm = *scope-&gt;vm();
 655     auto throwScope = DECLARE_THROW_SCOPE(vm);
 656 
 657     ProgramExecutable* program = ProgramExecutable::create(callFrame, source);
 658     EXCEPTION_ASSERT(throwScope.exception() || program);
 659     RETURN_IF_EXCEPTION(throwScope, { });
 660 
 661     throwScope.assertNoException();
 662     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 663     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
 664     if (vm.isCollectorBusyOnCurrentThread())
 665         return jsNull();
 666 
 667     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 668         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 669 
 670     // First check if the &quot;program&quot; is actually just a JSON object. If so,
 671     // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
 672     // below at failedJSONP.
 673 
 674     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);
 675     Vector&lt;JSONPData&gt; JSONPData;
 676     bool parseResult;
 677     StringView programSource = program-&gt;source().view();
 678     if (programSource.isNull())
 679         return jsUndefined();
 680     if (programSource.is8Bit()) {
 681         LiteralParser&lt;LChar&gt; literalParser(callFrame, programSource.characters8(), programSource.length(), JSONP);
 682         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 683     } else {
 684         LiteralParser&lt;UChar&gt; literalParser(callFrame, programSource.characters16(), programSource.length(), JSONP);
 685         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 686     }
 687 
 688     RETURN_IF_EXCEPTION(throwScope, { });
 689     if (parseResult) {
 690         JSValue result;
 691         for (unsigned entry = 0; entry &lt; JSONPData.size(); entry++) {
 692             Vector&lt;JSONPPathEntry&gt; JSONPPath;
 693             JSONPPath.swap(JSONPData[entry].m_path);
 694             JSValue JSONPValue = JSONPData[entry].m_value.get();
 695             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
 696                 globalObject-&gt;addVar(callFrame, JSONPPath[0].m_pathEntryName);
 697                 RETURN_IF_EXCEPTION(throwScope, { });
 698                 PutPropertySlot slot(globalObject);
 699                 globalObject-&gt;methodTable(vm)-&gt;put(globalObject, callFrame, JSONPPath[0].m_pathEntryName, JSONPValue, slot);
 700                 RETURN_IF_EXCEPTION(throwScope, { });
 701                 result = jsUndefined();
 702                 continue;
 703             }
 704             JSValue baseObject(globalObject);
 705             for (unsigned i = 0; i &lt; JSONPPath.size() - 1; i++) {
 706                 ASSERT(JSONPPath[i].m_type != JSONPPathEntryTypeDeclareVar);
 707                 switch (JSONPPath[i].m_type) {
 708                 case JSONPPathEntryTypeDot: {
 709                     if (i == 0) {
 710                         RELEASE_ASSERT(baseObject == globalObject);
 711 
 712                         auto doGet = [&amp;] (JSSegmentedVariableObject* scope) {
 713                             PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
 714                             if (scope-&gt;getPropertySlot(callFrame, JSONPPath[i].m_pathEntryName, slot))
 715                                 return slot.getValue(callFrame, JSONPPath[i].m_pathEntryName);
 716                             return JSValue();
 717                         };
 718 
 719                         JSValue result = doGet(globalObject-&gt;globalLexicalEnvironment());
 720                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 721                         if (result) {
 722                             baseObject = result;
 723                             continue;
 724                         }
 725 
 726                         result = doGet(globalObject);
 727                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 728                         if (result) {
 729                             baseObject = result;
 730                             continue;
 731                         }
 732 
 733                         if (entry)
 734                             return throwException(callFrame, throwScope, createUndefinedVariableError(callFrame, JSONPPath[i].m_pathEntryName));
 735                         goto failedJSONP;
 736                     }
 737 
 738                     baseObject = baseObject.get(callFrame, JSONPPath[i].m_pathEntryName);
 739                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 740                     continue;
 741                 }
 742                 case JSONPPathEntryTypeLookup: {
 743                     baseObject = baseObject.get(callFrame, static_cast&lt;unsigned&gt;(JSONPPath[i].m_pathIndex));
 744                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 745                     continue;
 746                 }
 747                 default:
 748                     RELEASE_ASSERT_NOT_REACHED();
 749                     return jsUndefined();
 750                 }
 751             }
 752 
 753             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
 754                 RELEASE_ASSERT(baseObject == globalObject);
 755                 JSGlobalLexicalEnvironment* scope = globalObject-&gt;globalLexicalEnvironment();
 756                 if (scope-&gt;hasProperty(callFrame, JSONPPath.last().m_pathEntryName))
 757                     baseObject = scope;
 758                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 759             }
 760 
 761             PutPropertySlot slot(baseObject);
 762             switch (JSONPPath.last().m_type) {
 763             case JSONPPathEntryTypeCall: {
 764                 JSValue function = baseObject.get(callFrame, JSONPPath.last().m_pathEntryName);
 765                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 766                 CallData callData;
 767                 CallType callType = getCallData(vm, function, callData);
 768                 if (callType == CallType::None)
 769                     return throwException(callFrame, throwScope, createNotAFunctionError(callFrame, function));
 770                 MarkedArgumentBuffer jsonArg;
 771                 jsonArg.append(JSONPValue);
 772                 ASSERT(!jsonArg.hasOverflowed());
 773                 JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
 774                 JSONPValue = JSC::call(callFrame, function, callType, callData, thisValue, jsonArg);
 775                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 776                 break;
 777             }
 778             case JSONPPathEntryTypeDot: {
 779                 baseObject.put(callFrame, JSONPPath.last().m_pathEntryName, JSONPValue, slot);
 780                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 781                 break;
 782             }
 783             case JSONPPathEntryTypeLookup: {
 784                 baseObject.putByIndex(callFrame, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());
 785                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 786                 break;
 787             }
 788             default:
 789                 RELEASE_ASSERT_NOT_REACHED();
 790                 return jsUndefined();
 791             }
 792             result = JSONPValue;
 793         }
 794         return result;
 795     }
 796 failedJSONP:
 797     // If we get here, then we have already proven that the script is not a JSON
 798     // object.
 799 
 800     VMEntryScope entryScope(vm, globalObject);
 801 
 802     // Compile source to bytecode if necessary:
 803     JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope);
 804     EXCEPTION_ASSERT(!throwScope.exception() || !error);
 805     if (UNLIKELY(error))
 806         return checkedReturn(throwException(callFrame, throwScope, error));
 807 
 808     ProgramCodeBlock* codeBlock;
 809     {
 810         CodeBlock* tempCodeBlock;
 811         JSObject* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
 812         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));
 813         if (UNLIKELY(error))
 814             return checkedReturn(error);
 815         codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
 816     }
 817 
 818     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 819     if (UNLIKELY(vm.needTrapHandling(mask))) {
 820         vm.handleTraps(callFrame, mask);
 821         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 822     }
 823 
 824     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
 825         scope-&gt;flattenDictionaryObject(vm);
 826 
 827     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
 828 
 829     ProtoCallFrame protoCallFrame;
 830     protoCallFrame.init(codeBlock, JSCallee::create(vm, globalObject, scope), thisObj, 1);
 831 
 832     // Execute the code:
 833     throwScope.release();
 834     JSValue result = program-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 835     return checkedReturn(result);
 836 }
 837 
 838 JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData&amp; callData, JSValue thisValue, const ArgList&amp; args)
 839 {
 840     VM&amp; vm = callFrame-&gt;vm();
 841     auto throwScope = DECLARE_THROW_SCOPE(vm);
 842 
 843     throwScope.assertNoException();
 844     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 845     if (vm.isCollectorBusyOnCurrentThread())
 846         return jsNull();
 847 
 848     bool isJSCall = (callType == CallType::JS);
 849     JSScope* scope = nullptr;
 850     CodeBlock* newCodeBlock;
 851     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 852 
 853     JSGlobalObject* globalObject;
 854 
 855     if (isJSCall) {
 856         scope = callData.js.scope;
 857         globalObject = scope-&gt;globalObject(vm);
 858     } else {
 859         ASSERT(callType == CallType::Host);
 860         globalObject = function-&gt;globalObject(vm);
 861     }
 862 
 863     VMEntryScope entryScope(vm, globalObject);
 864     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 865         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 866 
 867     if (isJSCall) {
 868         // Compile the callee:
 869         JSObject* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);
 870         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));
 871         if (UNLIKELY(!!compileError))
 872             return checkedReturn(compileError);
 873 
 874         ASSERT(!!newCodeBlock);
 875         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 876     } else
 877         newCodeBlock = 0;
 878 
 879     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 880     if (UNLIKELY(vm.needTrapHandling(mask))) {
 881         vm.handleTraps(callFrame, mask);
 882         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 883     }
 884 
 885     ProtoCallFrame protoCallFrame;
 886     protoCallFrame.init(newCodeBlock, function, thisValue, argsCount, args.data());
 887 
 888     JSValue result;
 889     {
 890         // Execute the code:
 891         if (isJSCall) {
 892             throwScope.release();
 893             result = callData.js.functionExecutable-&gt;generatedJITCodeForCall()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 894         } else {
 895             result = JSValue::decode(vmEntryToNative(callData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 896             RETURN_IF_EXCEPTION(throwScope, JSValue());
 897         }
 898     }
 899 
 900     return checkedReturn(result);
 901 }
 902 
 903 JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)
 904 {
 905     VM&amp; vm = callFrame-&gt;vm();
 906     auto throwScope = DECLARE_THROW_SCOPE(vm);
 907 
 908     throwScope.assertNoException();
 909     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 910     // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
 911     // already in an invalid state.
 912     if (vm.isCollectorBusyOnCurrentThread())
 913         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 914 
 915     bool isJSConstruct = (constructType == ConstructType::JS);
 916     JSScope* scope = nullptr;
 917     CodeBlock* newCodeBlock;
 918     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 919 
 920     JSGlobalObject* globalObject;
 921 
 922     if (isJSConstruct) {
 923         scope = constructData.js.scope;
 924         globalObject = scope-&gt;globalObject(vm);
 925     } else {
 926         ASSERT(constructType == ConstructType::Host);
 927         globalObject = constructor-&gt;globalObject(vm);
 928     }
 929 
 930     VMEntryScope entryScope(vm, globalObject);
 931     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 932         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 933 
 934     if (isJSConstruct) {
 935         // Compile the callee:
 936         JSObject* compileError = constructData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(constructor), scope, CodeForConstruct, newCodeBlock);
 937         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));
 938         if (UNLIKELY(!!compileError))
 939             return checkedReturn(compileError);
 940 
 941         ASSERT(!!newCodeBlock);
 942         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 943     } else
 944         newCodeBlock = 0;
 945 
 946     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 947     if (UNLIKELY(vm.needTrapHandling(mask))) {
 948         vm.handleTraps(callFrame, mask);
 949         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 950     }
 951 
 952     ProtoCallFrame protoCallFrame;
 953     protoCallFrame.init(newCodeBlock, constructor, newTarget, argsCount, args.data());
 954 
 955     JSValue result;
 956     {
 957         // Execute the code.
 958         if (isJSConstruct)
 959             result = constructData.js.functionExecutable-&gt;generatedJITCodeForConstruct()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 960         else {
 961             result = JSValue::decode(vmEntryToNative(constructData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 962 
 963             if (LIKELY(!throwScope.exception()))
 964                 RELEASE_ASSERT(result.isObject());
 965         }
 966     }
 967 
 968     RETURN_IF_EXCEPTION(throwScope, 0);
 969     ASSERT(result.isObject());
 970     return checkedReturn(asObject(result));
 971 }
 972 
 973 CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* functionExecutable, CallFrame* callFrame, ProtoCallFrame* protoCallFrame, JSFunction* function, int argumentCountIncludingThis, JSScope* scope, const ArgList&amp; args)
 974 {
 975     VM&amp; vm = *scope-&gt;vm();
 976     auto throwScope = DECLARE_THROW_SCOPE(vm);
 977     throwScope.assertNoException();
 978 
 979     if (vm.isCollectorBusyOnCurrentThread())
 980         return CallFrameClosure();
 981 
 982     // Compile the callee:
 983     CodeBlock* newCodeBlock;
 984     JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, CodeForCall, newCodeBlock);
 985     EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));
 986     if (UNLIKELY(error))
 987         return CallFrameClosure();
 988     newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 989 
 990     size_t argsCount = argumentCountIncludingThis;
 991 
 992     protoCallFrame-&gt;init(newCodeBlock, function, jsUndefined(), argsCount, args.data());
 993     // Return the successful closure:
 994     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
 995     return result;
 996 }
 997 
 998 JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, JSScope* scope)
 999 {
1000     VM&amp; vm = *scope-&gt;vm();
1001     auto throwScope = DECLARE_THROW_SCOPE(vm);
1002 
1003     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1004     throwScope.assertNoException();
1005     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1006     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1007     if (vm.isCollectorBusyOnCurrentThread())
1008         return jsNull();
1009 
1010     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1011     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1012         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1013 
1014     unsigned numVariables = eval-&gt;numVariables();
1015     unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
1016     unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
1017 
1018     JSScope* variableObject;
1019     if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
1020         scope = StrictEvalActivation::create(callFrame, scope);
1021         variableObject = scope;
1022     } else {
1023         for (JSScope* node = scope; ; node = node-&gt;next()) {
1024             RELEASE_ASSERT(node);
1025             if (node-&gt;isGlobalObject()) {
1026                 variableObject = node;
1027                 break;
1028             }
1029             if (node-&gt;isJSLexicalEnvironment()) {
1030                 JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(node);
1031                 if (lexicalEnvironment-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope) {
1032                     variableObject = node;
1033                     break;
1034                 }
1035             }
1036         }
1037     }
1038 
1039     EvalCodeBlock* codeBlock;
1040     {
1041         CodeBlock* tempCodeBlock;
1042         JSObject* compileError = eval-&gt;prepareForExecution&lt;EvalExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1043         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));
1044         if (UNLIKELY(!!compileError))
1045             return checkedReturn(compileError);
1046         codeBlock = jsCast&lt;EvalCodeBlock*&gt;(tempCodeBlock);
1047     }
1048     UnlinkedEvalCodeBlock* unlinkedCodeBlock = codeBlock-&gt;unlinkedEvalCodeBlock();
1049 
1050     // We can&#39;t declare a &quot;var&quot;/&quot;function&quot; that overwrites a global &quot;let&quot;/&quot;const&quot;/&quot;class&quot; in a sloppy-mode eval.
1051     if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
1052         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
1053         for (unsigned i = 0; i &lt; numVariables; ++i) {
1054             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1055             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
1056             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, ident, slot)) {
1057                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));
1058             }
1059         }
1060 
1061         for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1062             FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1063             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
1064             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, function-&gt;name(), slot)) {
1065                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));
1066             }
1067         }
1068     }
1069 
1070     if (variableObject-&gt;structure(vm)-&gt;isUncacheableDictionary())
1071         variableObject-&gt;flattenDictionaryObject(vm);
1072 
1073     if (numVariables || numTopLevelFunctionDecls || numFunctionHoistingCandidates) {
1074         BatchedTransitionOptimizer optimizer(vm, variableObject);
1075         if (variableObject-&gt;next() &amp;&amp; !eval-&gt;isStrictMode())
1076             variableObject-&gt;globalObject(vm)-&gt;varInjectionWatchpoint()-&gt;fireAll(vm, &quot;Executed eval, fired VarInjection watchpoint&quot;);
1077 
1078         for (unsigned i = 0; i &lt; numVariables; ++i) {
1079             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1080             bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);
1081             RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1082             if (!hasProperty) {
1083                 PutPropertySlot slot(variableObject);
1084                 if (!variableObject-&gt;isExtensible(callFrame))
1085                     return checkedReturn(throwTypeError(callFrame, throwScope, NonExtensibleObjectPropertyDefineError));
1086                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);
1087                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1088             }
1089         }
1090 
1091         if (eval-&gt;isStrictMode()) {
1092             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1093                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1094                 PutPropertySlot slot(variableObject);
1095                 // We need create this variables because it will be used to emits code by bytecode generator
1096                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);
1097                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1098             }
1099         } else {
1100             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1101                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1102                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, function-&gt;name());
1103                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1104                 if (resolvedScope.isUndefined())
1105                     return checkedReturn(throwSyntaxError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));
1106                 PutPropertySlot slot(variableObject);
1107                 // We need create this variables because it will be used to emits code by bytecode generator
1108                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);
1109                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1110             }
1111 
1112             for (unsigned i = 0; i &lt; numFunctionHoistingCandidates; ++i) {
1113                 const Identifier&amp; ident = unlinkedCodeBlock-&gt;functionHoistingCandidate(i);
1114                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, ident);
1115                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1116                 if (!resolvedScope.isUndefined()) {
1117                     bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);
1118                     RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1119                     if (!hasProperty) {
1120                         PutPropertySlot slot(variableObject);
1121                         variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);
1122                         RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1123                     }
1124                 }
1125             }
1126         }
1127     }
1128 
1129     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1130     if (UNLIKELY(vm.needTrapHandling(mask))) {
1131         vm.handleTraps(callFrame, mask);
1132         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1133     }
1134 
1135     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1136 
1137     ProtoCallFrame protoCallFrame;
1138     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), thisValue, 1);
1139 
1140     // Execute the code:
1141     throwScope.release();
1142     JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1143 
1144     return checkedReturn(result);
1145 }
1146 
1147 JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, CallFrame* callFrame, JSModuleEnvironment* scope)
1148 {
1149     VM&amp; vm = *scope-&gt;vm();
1150     auto throwScope = DECLARE_THROW_SCOPE(vm);
1151 
1152     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1153     throwScope.assertNoException();
1154     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1155     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1156     if (vm.isCollectorBusyOnCurrentThread())
1157         return jsNull();
1158 
1159     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1160     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1161         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1162 
1163     ModuleProgramCodeBlock* codeBlock;
1164     {
1165         CodeBlock* tempCodeBlock;
1166         JSObject* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1167         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));
1168         if (UNLIKELY(!!compileError))
1169             return checkedReturn(compileError);
1170         codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
1171     }
1172 
1173     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1174     if (UNLIKELY(vm.needTrapHandling(mask))) {
1175         vm.handleTraps(callFrame, mask);
1176         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1177     }
1178 
1179     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
1180         scope-&gt;flattenDictionaryObject(vm);
1181 
1182     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1183 
1184     // The |this| of the module is always `undefined`.
1185     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
1186     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
1187     ProtoCallFrame protoCallFrame;
1188     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), jsUndefined(), 1);
1189 
1190     // Execute the code:
1191     throwScope.release();
1192     JSValue result = executable-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1193 
1194     return checkedReturn(result);
1195 }
1196 
1197 NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
1198 {
1199     VM&amp; vm = callFrame-&gt;vm();
1200     auto scope = DECLARE_CATCH_SCOPE(vm);
1201     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();
1202     if (!debugger)
1203         return;
1204 
1205     ASSERT(callFrame-&gt;codeBlock()-&gt;hasDebuggerRequests());
1206     scope.assertNoException();
1207 
1208     switch (debugHookType) {
1209         case DidEnterCallFrame:
1210             debugger-&gt;callEvent(callFrame);
1211             break;
1212         case WillLeaveCallFrame:
1213             debugger-&gt;returnEvent(callFrame);
1214             break;
1215         case WillExecuteStatement:
1216             debugger-&gt;atStatement(callFrame);
1217             break;
1218         case WillExecuteExpression:
1219             debugger-&gt;atExpression(callFrame);
1220             break;
1221         case WillExecuteProgram:
1222             debugger-&gt;willExecuteProgram(callFrame);
1223             break;
1224         case DidExecuteProgram:
1225             debugger-&gt;didExecuteProgram(callFrame);
1226             break;
1227         case DidReachBreakpoint:
1228             debugger-&gt;didReachBreakpoint(callFrame);
1229             break;
1230     }
1231     scope.assertNoException();
1232 }
1233 
1234 } // namespace JSC
1235 
1236 namespace WTF {
1237 
1238 void printInternal(PrintStream&amp; out, JSC::DebugHookType type)
1239 {
1240     switch (type) {
1241     case JSC::WillExecuteProgram:
1242         out.print(&quot;WillExecuteProgram&quot;);
1243         return;
1244     case JSC::DidExecuteProgram:
1245         out.print(&quot;DidExecuteProgram&quot;);
1246         return;
1247     case JSC::DidEnterCallFrame:
1248         out.print(&quot;DidEnterCallFrame&quot;);
1249         return;
1250     case JSC::DidReachBreakpoint:
1251         out.print(&quot;DidReachBreakpoint&quot;);
1252         return;
1253     case JSC::WillLeaveCallFrame:
1254         out.print(&quot;WillLeaveCallFrame&quot;);
1255         return;
1256     case JSC::WillExecuteStatement:
1257         out.print(&quot;WillExecuteStatement&quot;);
1258         return;
1259     case JSC::WillExecuteExpression:
1260         out.print(&quot;WillExecuteExpression&quot;);
1261         return;
1262     }
1263 }
1264 
1265 } // namespace WTF
    </pre>
  </body>
</html>