<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontCache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCascade.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;FontCascade.h&quot;
  26 
  27 #include &quot;CharacterProperties.h&quot;
  28 #include &quot;ComplexTextController.h&quot;
  29 #include &quot;DisplayListRecorder.h&quot;
  30 #include &quot;FloatRect.h&quot;
  31 #include &quot;FontCache.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;GraphicsContext.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &quot;SurrogatePairAwareTextIterator.h&quot;
  36 #include &quot;TextRun.h&quot;
  37 #include &quot;WidthIterator.h&quot;
  38 #include &lt;wtf/MainThread.h&gt;
  39 #include &lt;wtf/MathExtras.h&gt;
  40 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">  41 #include &lt;wtf/text/AtomicStringHash.h&gt;</span>
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 
  44 #if PLATFORM(WIN)
  45 #include &quot;UniscribeController.h&quot;
  46 #endif
  47 
  48 namespace WebCore {
  49 
  50 using namespace WTF::Unicode;
  51 
<span class="line-modified">  52 static bool useBackslashAsYenSignForFamily(const AtomicString&amp; family)</span>
  53 {
  54     if (family.isEmpty())
  55         return false;
  56     static const auto set = makeNeverDestroyed([] {
<span class="line-modified">  57         HashSet&lt;AtomicString&gt; set;</span>
  58         auto add = [&amp;set] (const char* name, std::initializer_list&lt;UChar&gt; unicodeName) {
  59             unsigned nameLength = strlen(name);
<span class="line-modified">  60             set.add(AtomicString { name, nameLength, AtomicString::ConstructFromLiteral });</span>
  61             unsigned unicodeNameLength = unicodeName.size();
<span class="line-modified">  62             set.add(AtomicString { unicodeName.begin(), unicodeNameLength });</span>
  63         };
  64         add(&quot;MS PGothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  65         add(&quot;MS PMincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x660E, 0x671D });
  66         add(&quot;MS Gothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  67         add(&quot;MS Mincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x660E, 0x671D });
  68         add(&quot;Meiryo&quot;, { 0x30E1, 0x30A4, 0x30EA, 0x30AA });
  69         return set;
  70     }());
  71     return set.get().contains(family);
  72 }
  73 
  74 FontCascade::CodePath FontCascade::s_codePath = Auto;
  75 
  76 // ============================================================================================
  77 // FontCascade Implementation (Cross-Platform Portion)
  78 // ============================================================================================
  79 
  80 FontCascade::FontCascade()
  81 {
  82 }
</pre>
<hr />
<pre>
 135         return false;
 136 
 137     if (m_fontDescription != other.m_fontDescription || m_letterSpacing != other.m_letterSpacing || m_wordSpacing != other.m_wordSpacing)
 138         return false;
 139     if (m_fonts == other.m_fonts)
 140         return true;
 141     if (!m_fonts || !other.m_fonts)
 142         return false;
 143     if (m_fonts-&gt;fontSelector() != other.m_fonts-&gt;fontSelector())
 144         return false;
 145     // Can these cases actually somehow occur? All fonts should get wiped out by full style recalc.
 146     if (m_fonts-&gt;fontSelectorVersion() != other.m_fonts-&gt;fontSelectorVersion())
 147         return false;
 148     if (m_fonts-&gt;generation() != other.m_fonts-&gt;generation())
 149         return false;
 150     return true;
 151 }
 152 
 153 struct FontCascadeCacheKey {
 154     FontDescriptionKey fontDescriptionKey; // Shared with the lower level FontCache (caching Font objects)
<span class="line-modified"> 155     Vector&lt;AtomicString, 3&gt; families;</span>
 156     unsigned fontSelectorId;
 157     unsigned fontSelectorVersion;
 158 };
 159 
 160 struct FontCascadeCacheEntry {
 161     WTF_MAKE_FAST_ALLOCATED;
 162 public:
 163     FontCascadeCacheEntry(FontCascadeCacheKey&amp;&amp; key, Ref&lt;FontCascadeFonts&gt;&amp;&amp; fonts)
 164         : key(WTFMove(key))
 165         , fonts(WTFMove(fonts))
 166     { }
 167     FontCascadeCacheKey key;
 168     Ref&lt;FontCascadeFonts&gt; fonts;
 169 };
 170 
 171 // FIXME: Should make hash traits for FontCascadeCacheKey instead of using a hash as the key (so we hash a hash).
 172 typedef HashMap&lt;unsigned, std::unique_ptr&lt;FontCascadeCacheEntry&gt;, AlreadyHashed&gt; FontCascadeCache;
 173 
 174 static bool keysMatch(const FontCascadeCacheKey&amp; a, const FontCascadeCacheKey&amp; b)
 175 {
</pre>
<hr />
<pre>
 237         return entry.value-&gt;fonts.get().hasOneRef();
 238     });
 239 }
 240 
 241 void pruneSystemFallbackFonts()
 242 {
 243     for (auto&amp; entry : fontCascadeCache().values())
 244         entry-&gt;fonts-&gt;pruneSystemFallbacks();
 245 }
 246 
 247 static Ref&lt;FontCascadeFonts&gt; retrieveOrAddCachedFonts(const FontCascadeDescription&amp; fontDescription, RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector)
 248 {
 249     auto key = makeFontCascadeCacheKey(fontDescription, fontSelector.get());
 250 
 251     unsigned hash = computeFontCascadeCacheHash(key);
 252     auto addResult = fontCascadeCache().add(hash, nullptr);
 253     if (!addResult.isNewEntry &amp;&amp; keysMatch(addResult.iterator-&gt;value-&gt;key, key))
 254         return addResult.iterator-&gt;value-&gt;fonts.get();
 255 
 256     auto&amp; newEntry = addResult.iterator-&gt;value;
<span class="line-modified"> 257     newEntry = std::make_unique&lt;FontCascadeCacheEntry&gt;(WTFMove(key), FontCascadeFonts::create(WTFMove(fontSelector)));</span>
 258     Ref&lt;FontCascadeFonts&gt; glyphs = newEntry-&gt;fonts.get();
 259 
 260     static const unsigned unreferencedPruneInterval = 50;
 261     static const int maximumEntries = 400;
 262     static unsigned pruneCounter;
 263     // Referenced FontCascadeFonts would exist anyway so pruning them saves little memory.
 264     if (!(++pruneCounter % unreferencedPruneInterval))
 265         pruneUnreferencedEntriesFromFontCascadeCache();
 266     // Prevent pathological growth.
 267     if (fontCascadeCache().size() &gt; maximumEntries)
 268         fontCascadeCache().remove(fontCascadeCache().random());
 269     return glyphs;
 270 }
 271 
 272 void FontCascade::update(RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector) const
 273 {
 274     m_fonts = retrieveOrAddCachedFonts(m_fontDescription, WTFMove(fontSelector));
 275     m_useBackslashAsYenSymbol = useBackslashAsYenSignForFamily(firstFamily());
 276     m_enableKerning = computeEnableKerning();
 277     m_requiresShaping = computeRequiresShaping();
</pre>
<hr />
<pre>
 281 {
 282     if (codePathToUse != Complex)
 283         return getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer);
 284     return getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer);
 285 }
 286 
 287 float FontCascade::drawText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 288 {
 289     unsigned destination = to.valueOr(run.length());
 290     GlyphBuffer glyphBuffer;
 291     float startX = point.x() + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);
 292     // We couldn&#39;t generate any glyphs for the run. Give up.
 293     if (glyphBuffer.isEmpty())
 294         return 0;
 295     // Draw the glyph buffer now at the starting point returned in startX.
 296     FloatPoint startPoint(startX, point.y());
 297     drawGlyphBuffer(context, glyphBuffer, startPoint, customFontNotReadyAction);
 298     return startPoint.x() - startX;
 299 }
 300 
<span class="line-modified"> 301 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to) const</span>
 302 {
 303     if (isLoadingCustomFonts())
 304         return;
 305 
 306     unsigned destination = to.valueOr(run.length());
 307     if (codePath(run, from, to) != Complex)
 308         drawEmphasisMarksForSimpleText(context, run, mark, point, from, destination);
 309     else
 310         drawEmphasisMarksForComplexText(context, run, mark, point, from, destination);
 311 }
 312 
 313 std::unique_ptr&lt;DisplayList::DisplayList&gt; FontCascade::displayListForTextRun(GraphicsContext&amp; context, const TextRun&amp; run, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 314 {
 315     ASSERT(!context.paintingDisabled());
 316     unsigned destination = to.valueOr(run.length());
 317 
 318     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 319     CodePath codePathToUse = codePath(run);
 320     if (codePathToUse != Complex &amp;&amp; (enableKerning() || requiresShaping()) &amp;&amp; (from || destination != run.length()))
 321         codePathToUse = Complex;
 322 
 323     GlyphBuffer glyphBuffer;
 324     float startX = glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer);
 325     // We couldn&#39;t generate any glyphs for the run. Give up.
 326     if (glyphBuffer.isEmpty())
 327         return nullptr;
 328 
<span class="line-modified"> 329     std::unique_ptr&lt;DisplayList::DisplayList&gt; displayList = std::make_unique&lt;DisplayList::DisplayList&gt;();</span>
 330     GraphicsContext recordingContext([&amp;](GraphicsContext&amp; displayListContext) {
<span class="line-modified"> 331         return std::make_unique&lt;DisplayList::Recorder&gt;(displayListContext, *displayList, context.state(), FloatRect(), AffineTransform());</span>
 332     });
 333 
 334     FloatPoint startPoint(startX, 0);
 335     drawGlyphBuffer(recordingContext, glyphBuffer, startPoint, customFontNotReadyAction);
 336     return displayList;
 337 }
 338 
 339 float FontCascade::widthOfTextRange(const TextRun&amp; run, unsigned from, unsigned to, HashSet&lt;const Font*&gt;* fallbackFonts, float* outWidthBeforeRange, float* outWidthAfterRange) const
 340 {
 341     ASSERT(from &lt;= to);
 342     ASSERT(to &lt;= run.length());
 343 
 344     if (!run.length())
 345         return 0;
 346 
 347     float offsetBeforeRange = 0;
 348     float offsetAfterRange = 0;
 349     float totalWidth = 0;
 350 
 351     auto codePathToUse = codePath(run);
 352     if (codePathToUse == Complex) {
 353 #if PLATFORM(WIN)
 354         UniscribeController it(this, run);
 355         it.advance(from);
 356         offsetBeforeRange = it.runWidthSoFar();
 357         it.advance(to);
 358         offsetAfterRange = it.runWidthSoFar();
 359         it.advance(to);
 360         totalWidth = it.runWidthSoFar();
 361 #else
 362         ComplexTextController complexIterator(*this, run, false, fallbackFonts);
 363         complexIterator.advance(from, nullptr, IncludePartialGlyphs, fallbackFonts);
 364         offsetBeforeRange = complexIterator.runWidthSoFar();
 365         complexIterator.advance(to, nullptr, IncludePartialGlyphs, fallbackFonts);
 366         offsetAfterRange = complexIterator.runWidthSoFar();
 367         complexIterator.advance(run.length(), nullptr, IncludePartialGlyphs, fallbackFonts);
 368         totalWidth = complexIterator.runWidthSoFar();
<span class="line-removed"> 369         fprintf(stderr, &quot;totalWidth:%f\n&quot;, totalWidth);</span>
 370 #endif
 371     } else {
 372         WidthIterator simpleIterator(this, run, fallbackFonts);
 373         simpleIterator.advance(from, nullptr);
 374         offsetBeforeRange = simpleIterator.runWidthSoFar();
 375         simpleIterator.advance(to, nullptr);
 376         offsetAfterRange = simpleIterator.runWidthSoFar();
 377         simpleIterator.advance(run.length(), nullptr);
 378         totalWidth = simpleIterator.runWidthSoFar();
 379     }
 380 
 381     if (outWidthBeforeRange)
 382         *outWidthBeforeRange = offsetBeforeRange;
 383 
 384     if (outWidthAfterRange)
 385         *outWidthAfterRange = totalWidth - offsetAfterRange;
 386 
 387     return offsetAfterRange - offsetBeforeRange;
 388 }
 389 
</pre>
<hr />
<pre>
 470                 variant = SmallCapsVariant;
 471             } else
 472                 variant = NormalVariant;
 473         } else
 474             variant = NormalVariant;
 475     }
 476 
 477     if (mirror)
 478         c = u_charMirror(c);
 479 
 480     return m_fonts-&gt;glyphDataForCharacter(c, m_fontDescription, variant);
 481 }
 482 
 483 // For font families where any of the fonts don&#39;t have a valid entry in the OS/2 table
 484 // for avgCharWidth, fallback to the legacy webkit behavior of getting the avgCharWidth
 485 // from the width of a &#39;0&#39;. This only seems to apply to a fixed number of Mac fonts,
 486 // but, in order to get similar rendering across platforms, we do this check for
 487 // all platforms.
 488 bool FontCascade::hasValidAverageCharWidth() const
 489 {
<span class="line-modified"> 490     const AtomicString&amp; family = firstFamily();</span>
 491     if (family.isEmpty())
 492         return false;
 493 
 494 #if PLATFORM(COCOA)
 495     // Internal fonts on macOS and iOS also have an invalid entry in the table for avgCharWidth.
 496     if (primaryFontIsSystemFont())
 497         return false;
 498 #endif
 499 
<span class="line-modified"> 500     static const auto map = makeNeverDestroyed(HashSet&lt;AtomicString&gt; {</span>
 501         &quot;American Typewriter&quot;,
 502         &quot;Arial Hebrew&quot;,
 503         &quot;Chalkboard&quot;,
 504         &quot;Cochin&quot;,
 505         &quot;Corsiva Hebrew&quot;,
 506         &quot;Courier&quot;,
 507         &quot;Euphemia UCAS&quot;,
 508         &quot;Geneva&quot;,
 509         &quot;Gill Sans&quot;,
 510         &quot;Hei&quot;,
 511         &quot;Helvetica&quot;,
 512         &quot;Hoefler Text&quot;,
 513         &quot;InaiMathi&quot;,
 514         &quot;Kai&quot;,
 515         &quot;Lucida Grande&quot;,
 516         &quot;Marker Felt&quot;,
 517         &quot;Monaco&quot;,
 518         &quot;Mshtakan&quot;,
 519         &quot;New Peninim MT&quot;,
 520         &quot;Osaka&quot;,
</pre>
<hr />
<pre>
1291     case UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS:
1292     case UBLOCK_LINEAR_B_IDEOGRAMS:
1293     case UBLOCK_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT:
1294     case UBLOCK_HIRAGANA:
1295     case UBLOCK_KATAKANA:
1296     case UBLOCK_BOPOMOFO:
1297     case UBLOCK_BOPOMOFO_EXTENDED:
1298     case UBLOCK_HANGUL_JAMO:
1299     case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
1300     case UBLOCK_HANGUL_SYLLABLES:
1301     case UBLOCK_HANGUL_JAMO_EXTENDED_A:
1302     case UBLOCK_HANGUL_JAMO_EXTENDED_B:
1303         return GlyphUnderlineType::DrawOverGlyph;
1304     default:
1305         return GlyphUnderlineType::SkipDescenders;
1306     }
1307 }
1308 
1309 // FIXME: This function may not work if the emphasis mark uses a complex script, but none of the
1310 // standard emphasis marks do so.
<span class="line-modified">1311 Optional&lt;GlyphData&gt; FontCascade::getEmphasisMarkGlyphData(const AtomicString&amp; mark) const</span>
1312 {
1313     if (mark.isEmpty())
1314         return WTF::nullopt;
1315 
1316     UChar32 character;
1317     if (!mark.is8Bit()) {
1318         SurrogatePairAwareTextIterator iterator(mark.characters16(), 0, mark.length(), mark.length());
1319         unsigned clusterLength;
1320         if (!iterator.consume(character, clusterLength))
1321             return WTF::nullopt;
1322     } else
1323         character = mark[0];
1324 
1325     Optional&lt;GlyphData&gt; glyphData(glyphDataForCharacter(character, false, EmphasisMarkVariant));
1326     return glyphData.value().isValid() ? glyphData : WTF::nullopt;
1327 }
1328 
<span class="line-modified">1329 int FontCascade::emphasisMarkAscent(const AtomicString&amp; mark) const</span>
1330 {
1331     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1332     if (!markGlyphData)
1333         return 0;
1334 
1335     const Font* markFontData = markGlyphData.value().font;
1336     ASSERT(markFontData);
1337     if (!markFontData)
1338         return 0;
1339 
1340     return markFontData-&gt;fontMetrics().ascent();
1341 }
1342 
<span class="line-modified">1343 int FontCascade::emphasisMarkDescent(const AtomicString&amp; mark) const</span>
1344 {
1345     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1346     if (!markGlyphData)
1347         return 0;
1348 
1349     const Font* markFontData = markGlyphData.value().font;
1350     ASSERT(markFontData);
1351     if (!markFontData)
1352         return 0;
1353 
1354     return markFontData-&gt;fontMetrics().descent();
1355 }
1356 
<span class="line-modified">1357 int FontCascade::emphasisMarkHeight(const AtomicString&amp; mark) const</span>
1358 {
1359     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1360     if (!markGlyphData)
1361         return 0;
1362 
1363     const Font* markFontData = markGlyphData.value().font;
1364     ASSERT(markFontData);
1365     if (!markFontData)
1366         return 0;
1367 
1368     return markFontData-&gt;fontMetrics().height();
1369 }
1370 
1371 float FontCascade::getGlyphsAndAdvancesForSimpleText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const
1372 {
1373     float initialAdvance;
1374 
1375     WidthIterator it(this, run, 0, false, forTextEmphasis);
1376     // FIXME: Using separate glyph buffers for the prefix and the suffix is incorrect when kerning or
1377     // ligatures are enabled.
</pre>
<hr />
<pre>
1413 
1414     if (run.rtl()) {
1415         // Exploit the fact that the sum of the paint advances is equal to
1416         // the sum of the layout advances.
1417         initialAdvance = controller.totalWidth();
1418         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
1419             initialAdvance -= dummyGlyphBuffer.advanceAt(i).width();
1420         for (unsigned i = 0; i &lt; glyphBuffer.size(); ++i)
1421             initialAdvance -= glyphBuffer.advanceAt(i).width();
1422         glyphBuffer.reverse(0, glyphBuffer.size());
1423     } else {
1424         initialAdvance = dummyGlyphBuffer.initialAdvance().width();
1425         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
1426             initialAdvance += dummyGlyphBuffer.advanceAt(i).width();
1427     }
1428 
1429     return initialAdvance;
1430 }
1431 #endif
1432 
<span class="line-modified">1433 void FontCascade::drawEmphasisMarksForSimpleText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const</span>
1434 {
1435     GlyphBuffer glyphBuffer;
1436     float initialAdvance = getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer, ForTextEmphasis);
1437 
1438     if (glyphBuffer.isEmpty())
1439         return;
1440 
1441     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1442 }
1443 
1444 inline bool shouldDrawIfLoading(const Font&amp; font, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
1445 {
1446     // Don&#39;t draw anything while we are using custom fonts that are in the process of loading,
1447     // except if the &#39;customFontNotReadyAction&#39; argument is set to UseFallbackIfFontNotReady
1448     // (in which case &quot;font&quot; will be a fallback font).
1449     return !font.isInterstitial() || font.visibility() == Font::Visibility::Visible || customFontNotReadyAction == FontCascade::CustomFontNotReadyAction::UseFallbackIfFontNotReady;
1450 }
1451 
1452 void FontCascade::drawGlyphBuffer(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, FloatPoint&amp; point, CustomFontNotReadyAction customFontNotReadyAction) const
1453 {
</pre>
<hr />
<pre>
1484     if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1485         context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1486     point.setX(nextX);
1487 }
1488 
1489 inline static float offsetToMiddleOfGlyph(const Font* fontData, Glyph glyph)
1490 {
1491     if (fontData-&gt;platformData().orientation() == FontOrientation::Horizontal) {
1492         FloatRect bounds = fontData-&gt;boundsForGlyph(glyph);
1493         return bounds.x() + bounds.width() / 2;
1494     }
1495     // FIXME: Use glyph bounds once they make sense for vertical fonts.
1496     return fontData-&gt;widthForGlyph(glyph) / 2;
1497 }
1498 
1499 inline static float offsetToMiddleOfGlyphAtIndex(const GlyphBuffer&amp; glyphBuffer, unsigned i)
1500 {
1501     return offsetToMiddleOfGlyph(glyphBuffer.fontAt(i), glyphBuffer.glyphAt(i));
1502 }
1503 
<span class="line-modified">1504 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, const AtomicString&amp; mark, const FloatPoint&amp; point) const</span>
1505 {
1506     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1507     if (!markGlyphData)
1508         return;
1509 
1510     const Font* markFontData = markGlyphData.value().font;
1511     ASSERT(markFontData);
1512     if (!markFontData)
1513         return;
1514 
1515     Glyph markGlyph = markGlyphData.value().glyph;
1516     Glyph spaceGlyph = markFontData-&gt;spaceGlyph();
1517 
1518     float middleOfLastGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, 0);
1519     FloatPoint startPoint(point.x() + middleOfLastGlyph - offsetToMiddleOfGlyph(markFontData, markGlyph), point.y());
1520 
1521     GlyphBuffer markBuffer;
1522     for (unsigned i = 0; i + 1 &lt; glyphBuffer.size(); ++i) {
1523         float middleOfNextGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, i + 1);
1524         float advance = glyphBuffer.advanceAt(i).width() - middleOfLastGlyph + middleOfNextGlyph;
</pre>
<hr />
<pre>
1645     ComplexTextController controller(*this, run);
1646     return controller.offsetForPosition(x, includePartialGlyphs);
1647 }
1648 #endif
1649 
1650 #if !PLATFORM(COCOA) &amp;&amp; !USE(HARFBUZZ)
1651 // FIXME: Unify this with the macOS and iOS implementation.
1652 const Font* FontCascade::fontForCombiningCharacterSequence(const UChar* characters, size_t length) const
1653 {
1654     UChar32 baseCharacter;
1655     size_t baseCharacterLength = 0;
1656     U16_NEXT(characters, baseCharacterLength, length, baseCharacter);
1657     GlyphData baseCharacterGlyphData = glyphDataForCharacter(baseCharacter, false, NormalVariant);
1658 
1659     if (!baseCharacterGlyphData.glyph)
1660         return nullptr;
1661     return baseCharacterGlyphData.font;
1662 }
1663 #endif
1664 
<span class="line-modified">1665 void FontCascade::drawEmphasisMarksForComplexText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const</span>
1666 {
1667     GlyphBuffer glyphBuffer;
1668     float initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);
1669 
1670     if (glyphBuffer.isEmpty())
1671         return;
1672 
1673     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1674 }
1675 
1676 struct GlyphIterationState {
1677     FloatPoint startingPoint;
1678     FloatPoint currentPoint;
1679     float y1;
1680     float y2;
1681     float minX;
1682     float maxX;
1683 };
1684 
1685 static Optional&lt;float&gt; findIntersectionPoint(float y, FloatPoint p1, FloatPoint p2)
</pre>
</td>
<td>
<hr />
<pre>
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;FontCascade.h&quot;
  26 
  27 #include &quot;CharacterProperties.h&quot;
  28 #include &quot;ComplexTextController.h&quot;
  29 #include &quot;DisplayListRecorder.h&quot;
  30 #include &quot;FloatRect.h&quot;
  31 #include &quot;FontCache.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;GraphicsContext.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &quot;SurrogatePairAwareTextIterator.h&quot;
  36 #include &quot;TextRun.h&quot;
  37 #include &quot;WidthIterator.h&quot;
  38 #include &lt;wtf/MainThread.h&gt;
  39 #include &lt;wtf/MathExtras.h&gt;
  40 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">  41 #include &lt;wtf/text/AtomStringHash.h&gt;</span>
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 
  44 #if PLATFORM(WIN)
  45 #include &quot;UniscribeController.h&quot;
  46 #endif
  47 
  48 namespace WebCore {
  49 
  50 using namespace WTF::Unicode;
  51 
<span class="line-modified">  52 static bool useBackslashAsYenSignForFamily(const AtomString&amp; family)</span>
  53 {
  54     if (family.isEmpty())
  55         return false;
  56     static const auto set = makeNeverDestroyed([] {
<span class="line-modified">  57         HashSet&lt;AtomString&gt; set;</span>
  58         auto add = [&amp;set] (const char* name, std::initializer_list&lt;UChar&gt; unicodeName) {
  59             unsigned nameLength = strlen(name);
<span class="line-modified">  60             set.add(AtomString { name, nameLength, AtomString::ConstructFromLiteral });</span>
  61             unsigned unicodeNameLength = unicodeName.size();
<span class="line-modified">  62             set.add(AtomString { unicodeName.begin(), unicodeNameLength });</span>
  63         };
  64         add(&quot;MS PGothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  65         add(&quot;MS PMincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x660E, 0x671D });
  66         add(&quot;MS Gothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  67         add(&quot;MS Mincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x660E, 0x671D });
  68         add(&quot;Meiryo&quot;, { 0x30E1, 0x30A4, 0x30EA, 0x30AA });
  69         return set;
  70     }());
  71     return set.get().contains(family);
  72 }
  73 
  74 FontCascade::CodePath FontCascade::s_codePath = Auto;
  75 
  76 // ============================================================================================
  77 // FontCascade Implementation (Cross-Platform Portion)
  78 // ============================================================================================
  79 
  80 FontCascade::FontCascade()
  81 {
  82 }
</pre>
<hr />
<pre>
 135         return false;
 136 
 137     if (m_fontDescription != other.m_fontDescription || m_letterSpacing != other.m_letterSpacing || m_wordSpacing != other.m_wordSpacing)
 138         return false;
 139     if (m_fonts == other.m_fonts)
 140         return true;
 141     if (!m_fonts || !other.m_fonts)
 142         return false;
 143     if (m_fonts-&gt;fontSelector() != other.m_fonts-&gt;fontSelector())
 144         return false;
 145     // Can these cases actually somehow occur? All fonts should get wiped out by full style recalc.
 146     if (m_fonts-&gt;fontSelectorVersion() != other.m_fonts-&gt;fontSelectorVersion())
 147         return false;
 148     if (m_fonts-&gt;generation() != other.m_fonts-&gt;generation())
 149         return false;
 150     return true;
 151 }
 152 
 153 struct FontCascadeCacheKey {
 154     FontDescriptionKey fontDescriptionKey; // Shared with the lower level FontCache (caching Font objects)
<span class="line-modified"> 155     Vector&lt;AtomString, 3&gt; families;</span>
 156     unsigned fontSelectorId;
 157     unsigned fontSelectorVersion;
 158 };
 159 
 160 struct FontCascadeCacheEntry {
 161     WTF_MAKE_FAST_ALLOCATED;
 162 public:
 163     FontCascadeCacheEntry(FontCascadeCacheKey&amp;&amp; key, Ref&lt;FontCascadeFonts&gt;&amp;&amp; fonts)
 164         : key(WTFMove(key))
 165         , fonts(WTFMove(fonts))
 166     { }
 167     FontCascadeCacheKey key;
 168     Ref&lt;FontCascadeFonts&gt; fonts;
 169 };
 170 
 171 // FIXME: Should make hash traits for FontCascadeCacheKey instead of using a hash as the key (so we hash a hash).
 172 typedef HashMap&lt;unsigned, std::unique_ptr&lt;FontCascadeCacheEntry&gt;, AlreadyHashed&gt; FontCascadeCache;
 173 
 174 static bool keysMatch(const FontCascadeCacheKey&amp; a, const FontCascadeCacheKey&amp; b)
 175 {
</pre>
<hr />
<pre>
 237         return entry.value-&gt;fonts.get().hasOneRef();
 238     });
 239 }
 240 
 241 void pruneSystemFallbackFonts()
 242 {
 243     for (auto&amp; entry : fontCascadeCache().values())
 244         entry-&gt;fonts-&gt;pruneSystemFallbacks();
 245 }
 246 
 247 static Ref&lt;FontCascadeFonts&gt; retrieveOrAddCachedFonts(const FontCascadeDescription&amp; fontDescription, RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector)
 248 {
 249     auto key = makeFontCascadeCacheKey(fontDescription, fontSelector.get());
 250 
 251     unsigned hash = computeFontCascadeCacheHash(key);
 252     auto addResult = fontCascadeCache().add(hash, nullptr);
 253     if (!addResult.isNewEntry &amp;&amp; keysMatch(addResult.iterator-&gt;value-&gt;key, key))
 254         return addResult.iterator-&gt;value-&gt;fonts.get();
 255 
 256     auto&amp; newEntry = addResult.iterator-&gt;value;
<span class="line-modified"> 257     newEntry = makeUnique&lt;FontCascadeCacheEntry&gt;(WTFMove(key), FontCascadeFonts::create(WTFMove(fontSelector)));</span>
 258     Ref&lt;FontCascadeFonts&gt; glyphs = newEntry-&gt;fonts.get();
 259 
 260     static const unsigned unreferencedPruneInterval = 50;
 261     static const int maximumEntries = 400;
 262     static unsigned pruneCounter;
 263     // Referenced FontCascadeFonts would exist anyway so pruning them saves little memory.
 264     if (!(++pruneCounter % unreferencedPruneInterval))
 265         pruneUnreferencedEntriesFromFontCascadeCache();
 266     // Prevent pathological growth.
 267     if (fontCascadeCache().size() &gt; maximumEntries)
 268         fontCascadeCache().remove(fontCascadeCache().random());
 269     return glyphs;
 270 }
 271 
 272 void FontCascade::update(RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector) const
 273 {
 274     m_fonts = retrieveOrAddCachedFonts(m_fontDescription, WTFMove(fontSelector));
 275     m_useBackslashAsYenSymbol = useBackslashAsYenSignForFamily(firstFamily());
 276     m_enableKerning = computeEnableKerning();
 277     m_requiresShaping = computeRequiresShaping();
</pre>
<hr />
<pre>
 281 {
 282     if (codePathToUse != Complex)
 283         return getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer);
 284     return getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer);
 285 }
 286 
 287 float FontCascade::drawText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 288 {
 289     unsigned destination = to.valueOr(run.length());
 290     GlyphBuffer glyphBuffer;
 291     float startX = point.x() + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);
 292     // We couldn&#39;t generate any glyphs for the run. Give up.
 293     if (glyphBuffer.isEmpty())
 294         return 0;
 295     // Draw the glyph buffer now at the starting point returned in startX.
 296     FloatPoint startPoint(startX, point.y());
 297     drawGlyphBuffer(context, glyphBuffer, startPoint, customFontNotReadyAction);
 298     return startPoint.x() - startX;
 299 }
 300 
<span class="line-modified"> 301 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to) const</span>
 302 {
 303     if (isLoadingCustomFonts())
 304         return;
 305 
 306     unsigned destination = to.valueOr(run.length());
 307     if (codePath(run, from, to) != Complex)
 308         drawEmphasisMarksForSimpleText(context, run, mark, point, from, destination);
 309     else
 310         drawEmphasisMarksForComplexText(context, run, mark, point, from, destination);
 311 }
 312 
 313 std::unique_ptr&lt;DisplayList::DisplayList&gt; FontCascade::displayListForTextRun(GraphicsContext&amp; context, const TextRun&amp; run, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 314 {
 315     ASSERT(!context.paintingDisabled());
 316     unsigned destination = to.valueOr(run.length());
 317 
 318     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 319     CodePath codePathToUse = codePath(run);
 320     if (codePathToUse != Complex &amp;&amp; (enableKerning() || requiresShaping()) &amp;&amp; (from || destination != run.length()))
 321         codePathToUse = Complex;
 322 
 323     GlyphBuffer glyphBuffer;
 324     float startX = glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer);
 325     // We couldn&#39;t generate any glyphs for the run. Give up.
 326     if (glyphBuffer.isEmpty())
 327         return nullptr;
 328 
<span class="line-modified"> 329     std::unique_ptr&lt;DisplayList::DisplayList&gt; displayList = makeUnique&lt;DisplayList::DisplayList&gt;();</span>
 330     GraphicsContext recordingContext([&amp;](GraphicsContext&amp; displayListContext) {
<span class="line-modified"> 331         return makeUnique&lt;DisplayList::Recorder&gt;(displayListContext, *displayList, context.state(), FloatRect(), AffineTransform());</span>
 332     });
 333 
 334     FloatPoint startPoint(startX, 0);
 335     drawGlyphBuffer(recordingContext, glyphBuffer, startPoint, customFontNotReadyAction);
 336     return displayList;
 337 }
 338 
 339 float FontCascade::widthOfTextRange(const TextRun&amp; run, unsigned from, unsigned to, HashSet&lt;const Font*&gt;* fallbackFonts, float* outWidthBeforeRange, float* outWidthAfterRange) const
 340 {
 341     ASSERT(from &lt;= to);
 342     ASSERT(to &lt;= run.length());
 343 
 344     if (!run.length())
 345         return 0;
 346 
 347     float offsetBeforeRange = 0;
 348     float offsetAfterRange = 0;
 349     float totalWidth = 0;
 350 
 351     auto codePathToUse = codePath(run);
 352     if (codePathToUse == Complex) {
 353 #if PLATFORM(WIN)
 354         UniscribeController it(this, run);
 355         it.advance(from);
 356         offsetBeforeRange = it.runWidthSoFar();
 357         it.advance(to);
 358         offsetAfterRange = it.runWidthSoFar();
 359         it.advance(to);
 360         totalWidth = it.runWidthSoFar();
 361 #else
 362         ComplexTextController complexIterator(*this, run, false, fallbackFonts);
 363         complexIterator.advance(from, nullptr, IncludePartialGlyphs, fallbackFonts);
 364         offsetBeforeRange = complexIterator.runWidthSoFar();
 365         complexIterator.advance(to, nullptr, IncludePartialGlyphs, fallbackFonts);
 366         offsetAfterRange = complexIterator.runWidthSoFar();
 367         complexIterator.advance(run.length(), nullptr, IncludePartialGlyphs, fallbackFonts);
 368         totalWidth = complexIterator.runWidthSoFar();

 369 #endif
 370     } else {
 371         WidthIterator simpleIterator(this, run, fallbackFonts);
 372         simpleIterator.advance(from, nullptr);
 373         offsetBeforeRange = simpleIterator.runWidthSoFar();
 374         simpleIterator.advance(to, nullptr);
 375         offsetAfterRange = simpleIterator.runWidthSoFar();
 376         simpleIterator.advance(run.length(), nullptr);
 377         totalWidth = simpleIterator.runWidthSoFar();
 378     }
 379 
 380     if (outWidthBeforeRange)
 381         *outWidthBeforeRange = offsetBeforeRange;
 382 
 383     if (outWidthAfterRange)
 384         *outWidthAfterRange = totalWidth - offsetAfterRange;
 385 
 386     return offsetAfterRange - offsetBeforeRange;
 387 }
 388 
</pre>
<hr />
<pre>
 469                 variant = SmallCapsVariant;
 470             } else
 471                 variant = NormalVariant;
 472         } else
 473             variant = NormalVariant;
 474     }
 475 
 476     if (mirror)
 477         c = u_charMirror(c);
 478 
 479     return m_fonts-&gt;glyphDataForCharacter(c, m_fontDescription, variant);
 480 }
 481 
 482 // For font families where any of the fonts don&#39;t have a valid entry in the OS/2 table
 483 // for avgCharWidth, fallback to the legacy webkit behavior of getting the avgCharWidth
 484 // from the width of a &#39;0&#39;. This only seems to apply to a fixed number of Mac fonts,
 485 // but, in order to get similar rendering across platforms, we do this check for
 486 // all platforms.
 487 bool FontCascade::hasValidAverageCharWidth() const
 488 {
<span class="line-modified"> 489     const AtomString&amp; family = firstFamily();</span>
 490     if (family.isEmpty())
 491         return false;
 492 
 493 #if PLATFORM(COCOA)
 494     // Internal fonts on macOS and iOS also have an invalid entry in the table for avgCharWidth.
 495     if (primaryFontIsSystemFont())
 496         return false;
 497 #endif
 498 
<span class="line-modified"> 499     static const auto map = makeNeverDestroyed(HashSet&lt;AtomString&gt; {</span>
 500         &quot;American Typewriter&quot;,
 501         &quot;Arial Hebrew&quot;,
 502         &quot;Chalkboard&quot;,
 503         &quot;Cochin&quot;,
 504         &quot;Corsiva Hebrew&quot;,
 505         &quot;Courier&quot;,
 506         &quot;Euphemia UCAS&quot;,
 507         &quot;Geneva&quot;,
 508         &quot;Gill Sans&quot;,
 509         &quot;Hei&quot;,
 510         &quot;Helvetica&quot;,
 511         &quot;Hoefler Text&quot;,
 512         &quot;InaiMathi&quot;,
 513         &quot;Kai&quot;,
 514         &quot;Lucida Grande&quot;,
 515         &quot;Marker Felt&quot;,
 516         &quot;Monaco&quot;,
 517         &quot;Mshtakan&quot;,
 518         &quot;New Peninim MT&quot;,
 519         &quot;Osaka&quot;,
</pre>
<hr />
<pre>
1290     case UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS:
1291     case UBLOCK_LINEAR_B_IDEOGRAMS:
1292     case UBLOCK_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT:
1293     case UBLOCK_HIRAGANA:
1294     case UBLOCK_KATAKANA:
1295     case UBLOCK_BOPOMOFO:
1296     case UBLOCK_BOPOMOFO_EXTENDED:
1297     case UBLOCK_HANGUL_JAMO:
1298     case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
1299     case UBLOCK_HANGUL_SYLLABLES:
1300     case UBLOCK_HANGUL_JAMO_EXTENDED_A:
1301     case UBLOCK_HANGUL_JAMO_EXTENDED_B:
1302         return GlyphUnderlineType::DrawOverGlyph;
1303     default:
1304         return GlyphUnderlineType::SkipDescenders;
1305     }
1306 }
1307 
1308 // FIXME: This function may not work if the emphasis mark uses a complex script, but none of the
1309 // standard emphasis marks do so.
<span class="line-modified">1310 Optional&lt;GlyphData&gt; FontCascade::getEmphasisMarkGlyphData(const AtomString&amp; mark) const</span>
1311 {
1312     if (mark.isEmpty())
1313         return WTF::nullopt;
1314 
1315     UChar32 character;
1316     if (!mark.is8Bit()) {
1317         SurrogatePairAwareTextIterator iterator(mark.characters16(), 0, mark.length(), mark.length());
1318         unsigned clusterLength;
1319         if (!iterator.consume(character, clusterLength))
1320             return WTF::nullopt;
1321     } else
1322         character = mark[0];
1323 
1324     Optional&lt;GlyphData&gt; glyphData(glyphDataForCharacter(character, false, EmphasisMarkVariant));
1325     return glyphData.value().isValid() ? glyphData : WTF::nullopt;
1326 }
1327 
<span class="line-modified">1328 int FontCascade::emphasisMarkAscent(const AtomString&amp; mark) const</span>
1329 {
1330     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1331     if (!markGlyphData)
1332         return 0;
1333 
1334     const Font* markFontData = markGlyphData.value().font;
1335     ASSERT(markFontData);
1336     if (!markFontData)
1337         return 0;
1338 
1339     return markFontData-&gt;fontMetrics().ascent();
1340 }
1341 
<span class="line-modified">1342 int FontCascade::emphasisMarkDescent(const AtomString&amp; mark) const</span>
1343 {
1344     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1345     if (!markGlyphData)
1346         return 0;
1347 
1348     const Font* markFontData = markGlyphData.value().font;
1349     ASSERT(markFontData);
1350     if (!markFontData)
1351         return 0;
1352 
1353     return markFontData-&gt;fontMetrics().descent();
1354 }
1355 
<span class="line-modified">1356 int FontCascade::emphasisMarkHeight(const AtomString&amp; mark) const</span>
1357 {
1358     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1359     if (!markGlyphData)
1360         return 0;
1361 
1362     const Font* markFontData = markGlyphData.value().font;
1363     ASSERT(markFontData);
1364     if (!markFontData)
1365         return 0;
1366 
1367     return markFontData-&gt;fontMetrics().height();
1368 }
1369 
1370 float FontCascade::getGlyphsAndAdvancesForSimpleText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const
1371 {
1372     float initialAdvance;
1373 
1374     WidthIterator it(this, run, 0, false, forTextEmphasis);
1375     // FIXME: Using separate glyph buffers for the prefix and the suffix is incorrect when kerning or
1376     // ligatures are enabled.
</pre>
<hr />
<pre>
1412 
1413     if (run.rtl()) {
1414         // Exploit the fact that the sum of the paint advances is equal to
1415         // the sum of the layout advances.
1416         initialAdvance = controller.totalWidth();
1417         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
1418             initialAdvance -= dummyGlyphBuffer.advanceAt(i).width();
1419         for (unsigned i = 0; i &lt; glyphBuffer.size(); ++i)
1420             initialAdvance -= glyphBuffer.advanceAt(i).width();
1421         glyphBuffer.reverse(0, glyphBuffer.size());
1422     } else {
1423         initialAdvance = dummyGlyphBuffer.initialAdvance().width();
1424         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
1425             initialAdvance += dummyGlyphBuffer.advanceAt(i).width();
1426     }
1427 
1428     return initialAdvance;
1429 }
1430 #endif
1431 
<span class="line-modified">1432 void FontCascade::drawEmphasisMarksForSimpleText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const</span>
1433 {
1434     GlyphBuffer glyphBuffer;
1435     float initialAdvance = getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer, ForTextEmphasis);
1436 
1437     if (glyphBuffer.isEmpty())
1438         return;
1439 
1440     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1441 }
1442 
1443 inline bool shouldDrawIfLoading(const Font&amp; font, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
1444 {
1445     // Don&#39;t draw anything while we are using custom fonts that are in the process of loading,
1446     // except if the &#39;customFontNotReadyAction&#39; argument is set to UseFallbackIfFontNotReady
1447     // (in which case &quot;font&quot; will be a fallback font).
1448     return !font.isInterstitial() || font.visibility() == Font::Visibility::Visible || customFontNotReadyAction == FontCascade::CustomFontNotReadyAction::UseFallbackIfFontNotReady;
1449 }
1450 
1451 void FontCascade::drawGlyphBuffer(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, FloatPoint&amp; point, CustomFontNotReadyAction customFontNotReadyAction) const
1452 {
</pre>
<hr />
<pre>
1483     if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1484         context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1485     point.setX(nextX);
1486 }
1487 
1488 inline static float offsetToMiddleOfGlyph(const Font* fontData, Glyph glyph)
1489 {
1490     if (fontData-&gt;platformData().orientation() == FontOrientation::Horizontal) {
1491         FloatRect bounds = fontData-&gt;boundsForGlyph(glyph);
1492         return bounds.x() + bounds.width() / 2;
1493     }
1494     // FIXME: Use glyph bounds once they make sense for vertical fonts.
1495     return fontData-&gt;widthForGlyph(glyph) / 2;
1496 }
1497 
1498 inline static float offsetToMiddleOfGlyphAtIndex(const GlyphBuffer&amp; glyphBuffer, unsigned i)
1499 {
1500     return offsetToMiddleOfGlyph(glyphBuffer.fontAt(i), glyphBuffer.glyphAt(i));
1501 }
1502 
<span class="line-modified">1503 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, const AtomString&amp; mark, const FloatPoint&amp; point) const</span>
1504 {
1505     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1506     if (!markGlyphData)
1507         return;
1508 
1509     const Font* markFontData = markGlyphData.value().font;
1510     ASSERT(markFontData);
1511     if (!markFontData)
1512         return;
1513 
1514     Glyph markGlyph = markGlyphData.value().glyph;
1515     Glyph spaceGlyph = markFontData-&gt;spaceGlyph();
1516 
1517     float middleOfLastGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, 0);
1518     FloatPoint startPoint(point.x() + middleOfLastGlyph - offsetToMiddleOfGlyph(markFontData, markGlyph), point.y());
1519 
1520     GlyphBuffer markBuffer;
1521     for (unsigned i = 0; i + 1 &lt; glyphBuffer.size(); ++i) {
1522         float middleOfNextGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, i + 1);
1523         float advance = glyphBuffer.advanceAt(i).width() - middleOfLastGlyph + middleOfNextGlyph;
</pre>
<hr />
<pre>
1644     ComplexTextController controller(*this, run);
1645     return controller.offsetForPosition(x, includePartialGlyphs);
1646 }
1647 #endif
1648 
1649 #if !PLATFORM(COCOA) &amp;&amp; !USE(HARFBUZZ)
1650 // FIXME: Unify this with the macOS and iOS implementation.
1651 const Font* FontCascade::fontForCombiningCharacterSequence(const UChar* characters, size_t length) const
1652 {
1653     UChar32 baseCharacter;
1654     size_t baseCharacterLength = 0;
1655     U16_NEXT(characters, baseCharacterLength, length, baseCharacter);
1656     GlyphData baseCharacterGlyphData = glyphDataForCharacter(baseCharacter, false, NormalVariant);
1657 
1658     if (!baseCharacterGlyphData.glyph)
1659         return nullptr;
1660     return baseCharacterGlyphData.font;
1661 }
1662 #endif
1663 
<span class="line-modified">1664 void FontCascade::drawEmphasisMarksForComplexText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const</span>
1665 {
1666     GlyphBuffer glyphBuffer;
1667     float initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);
1668 
1669     if (glyphBuffer.isEmpty())
1670         return;
1671 
1672     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1673 }
1674 
1675 struct GlyphIterationState {
1676     FloatPoint startingPoint;
1677     FloatPoint currentPoint;
1678     float y1;
1679     float y2;
1680     float minX;
1681     float maxX;
1682 };
1683 
1684 static Optional&lt;float&gt; findIntersectionPoint(float y, FloatPoint p1, FloatPoint p2)
</pre>
</td>
</tr>
</table>
<center><a href="FontCache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCascade.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>