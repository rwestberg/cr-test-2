<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;GraphicsLayer.h&quot;
  29 
  30 #include &quot;FloatPoint.h&quot;
  31 #include &quot;FloatRect.h&quot;
  32 #include &quot;GraphicsContext.h&quot;
  33 #include &quot;LayoutRect.h&quot;
  34 #include &quot;RotateTransformOperation.h&quot;
  35 #include &lt;wtf/HashMap.h&gt;
  36 #include &lt;wtf/NeverDestroyed.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/StringBuilder.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 #include &lt;wtf/text/WTFString.h&gt;
  41 
  42 #ifndef NDEBUG
  43 #include &lt;stdio.h&gt;
  44 #endif
  45 
  46 namespace WebCore {
  47 
  48 typedef HashMap&lt;const GraphicsLayer*, Vector&lt;FloatRect&gt;&gt; RepaintMap;
  49 static RepaintMap&amp; repaintRectMap()
  50 {
  51     static NeverDestroyed&lt;RepaintMap&gt; map;
  52     return map;
  53 }
  54 
  55 void KeyframeValueList::insert(std::unique_ptr&lt;const AnimationValue&gt; value)
  56 {
  57     for (size_t i = 0; i &lt; m_values.size(); ++i) {
  58         const AnimationValue* curValue = m_values[i].get();
  59         if (curValue-&gt;keyTime() == value-&gt;keyTime()) {
  60             ASSERT_NOT_REACHED();
  61             // insert after
  62             m_values.insert(i + 1, WTFMove(value));
  63             return;
  64         }
  65         if (curValue-&gt;keyTime() &gt; value-&gt;keyTime()) {
  66             // insert before
  67             m_values.insert(i, WTFMove(value));
  68             return;
  69         }
  70     }
  71 
  72     m_values.append(WTFMove(value));
  73 }
  74 
  75 #if !USE(CA)
  76 bool GraphicsLayer::supportsLayerType(Type type)
  77 {
  78     switch (type) {
  79     case Type::Normal:
  80     case Type::PageTiledBacking:
  81     case Type::ScrollContainer:
  82         return true;
  83     case Type::Shape:
  84         return false;
  85     }
  86     ASSERT_NOT_REACHED();
  87     return false;
  88 }
  89 
  90 bool GraphicsLayer::supportsBackgroundColorContent()
  91 {
  92 #if USE(TEXTURE_MAPPER)
  93     return true;
  94 #else
  95     return false;
  96 #endif
  97 }
  98 
  99 bool GraphicsLayer::supportsSubpixelAntialiasedLayerText()
 100 {
 101     return false;
 102 }
 103 #endif
 104 
 105 #if !USE(COORDINATED_GRAPHICS)
 106 bool GraphicsLayer::supportsContentsTiling()
 107 {
 108     // FIXME: Enable the feature on different ports.
 109     return false;
 110 }
 111 #endif
 112 
 113 // Singleton client used for layers on which clearClient has been called.
 114 class EmptyGraphicsLayerClient : public GraphicsLayerClient {
 115     WTF_MAKE_FAST_ALLOCATED;
 116 public:
 117     static EmptyGraphicsLayerClient&amp; singleton();
 118 };
 119 
 120 EmptyGraphicsLayerClient&amp; EmptyGraphicsLayerClient::singleton()
 121 {
 122     static NeverDestroyed&lt;EmptyGraphicsLayerClient&gt; client;
 123     return client;
 124 }
 125 
 126 GraphicsLayer::GraphicsLayer(Type type, GraphicsLayerClient&amp; layerClient)
 127     : m_client(&amp;layerClient)
 128     , m_type(type)
 129     , m_beingDestroyed(false)
 130     , m_contentsOpaque(false)
 131     , m_supportsSubpixelAntialiasedText(false)
 132     , m_preserves3D(false)
 133     , m_backfaceVisibility(true)
 134     , m_masksToBounds(false)
 135     , m_drawsContent(false)
 136     , m_contentsVisible(true)
 137     , m_acceleratesDrawing(false)
 138     , m_usesDisplayListDrawing(false)
 139     , m_appliesPageScale(false)
 140     , m_showDebugBorder(false)
 141     , m_showRepaintCounter(false)
 142     , m_isMaskLayer(false)
 143     , m_isTrackingDisplayListReplay(false)
 144     , m_userInteractionEnabled(true)
 145     , m_canDetachBackingStore(true)
 146 {
 147 #ifndef NDEBUG
 148     client().verifyNotPainting();
 149 #endif
 150 }
 151 
 152 GraphicsLayer::~GraphicsLayer()
 153 {
 154     resetTrackedRepaints();
 155     ASSERT(!m_parent); // willBeDestroyed should have been called already.
 156 }
 157 
 158 void GraphicsLayer::unparentAndClear(RefPtr&lt;GraphicsLayer&gt;&amp; layer)
 159 {
 160     if (layer) {
 161         layer-&gt;removeFromParent();
 162         layer-&gt;clearClient();
 163         layer = nullptr;
 164     }
 165 }
 166 
 167 void GraphicsLayer::clear(RefPtr&lt;GraphicsLayer&gt;&amp; layer)
 168 {
 169     if (layer) {
 170         layer-&gt;clearClient();
 171         layer = nullptr;
 172     }
 173 }
 174 
 175 void GraphicsLayer::willBeDestroyed()
 176 {
 177     m_beingDestroyed = true;
 178 #ifndef NDEBUG
 179     client().verifyNotPainting();
 180 #endif
 181     if (m_replicaLayer)
 182         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 183 
 184     if (m_replicatedLayer)
 185         m_replicatedLayer-&gt;setReplicatedByLayer(nullptr);
 186 
 187     if (m_maskLayer) {
 188         m_maskLayer-&gt;setParent(nullptr);
 189         m_maskLayer-&gt;setIsMaskLayer(false);
 190     }
 191 
 192     removeAllChildren();
 193     removeFromParent();
 194 }
 195 
 196 void GraphicsLayer::clearClient()
 197 {
 198     m_client = &amp;EmptyGraphicsLayerClient::singleton();
 199 }
 200 
 201 void GraphicsLayer::setClient(GraphicsLayerClient&amp; client)
 202 {
 203     m_client = &amp;client;
 204 }
 205 
 206 void GraphicsLayer::setParent(GraphicsLayer* layer)
 207 {
 208     ASSERT(!layer || !layer-&gt;hasAncestor(this));
 209     m_parent = layer;
 210 }
 211 
 212 bool GraphicsLayer::hasAncestor(GraphicsLayer* ancestor) const
 213 {
 214     for (GraphicsLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
 215         if (curr == ancestor)
 216             return true;
 217     }
 218 
 219     return false;
 220 }
 221 
 222 bool GraphicsLayer::setChildren(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;&amp; newChildren)
 223 {
 224     // If the contents of the arrays are the same, nothing to do.
 225     if (newChildren == m_children)
 226         return false;
 227 
 228     removeAllChildren();
 229 
 230     size_t listSize = newChildren.size();
 231     for (size_t i = 0; i &lt; listSize; ++i)
 232         addChild(WTFMove(newChildren[i]));
 233 
 234     return true;
 235 }
 236 
 237 void GraphicsLayer::addChild(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer)
 238 {
 239     ASSERT(childLayer.ptr() != this);
 240 
 241     childLayer-&gt;removeFromParent();
 242     childLayer-&gt;setParent(this);
 243     m_children.append(WTFMove(childLayer));
 244 }
 245 
 246 void GraphicsLayer::addChildAtIndex(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, int index)
 247 {
 248     ASSERT(childLayer.ptr() != this);
 249 
 250     childLayer-&gt;removeFromParent();
 251     childLayer-&gt;setParent(this);
 252     m_children.insert(index, WTFMove(childLayer));
 253 }
 254 
 255 void GraphicsLayer::addChildBelow(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, GraphicsLayer* sibling)
 256 {
 257     ASSERT(childLayer.ptr() != this);
 258     childLayer-&gt;removeFromParent();
 259 
 260     childLayer-&gt;setParent(this);
 261 
 262     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 263         if (sibling == m_children[i].ptr()) {
 264             m_children.insert(i, WTFMove(childLayer));
 265             return;
 266         }
 267     }
 268 
 269     m_children.append(WTFMove(childLayer));
 270 }
 271 
 272 void GraphicsLayer::addChildAbove(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, GraphicsLayer* sibling)
 273 {
 274     childLayer-&gt;removeFromParent();
 275     ASSERT(childLayer.ptr() != this);
 276 
 277     childLayer-&gt;setParent(this);
 278 
 279     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 280         if (sibling == m_children[i].ptr()) {
 281             m_children.insert(i + 1, WTFMove(childLayer));
 282             return;
 283         }
 284     }
 285 
 286     m_children.append(WTFMove(childLayer));
 287 }
 288 
 289 bool GraphicsLayer::replaceChild(GraphicsLayer* oldChild, Ref&lt;GraphicsLayer&gt;&amp;&amp; newChild)
 290 {
 291     ASSERT(!newChild-&gt;parent());
 292 
 293     GraphicsLayer* rawNewChild = newChild.ptr();
 294 
 295     bool found = false;
 296     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 297         if (oldChild == m_children[i].ptr()) {
 298             m_children[i] = WTFMove(newChild);
 299             found = true;
 300             break;
 301         }
 302     }
 303     if (found) {
 304         oldChild-&gt;setParent(nullptr);
 305 
 306         rawNewChild-&gt;removeFromParent();
 307         rawNewChild-&gt;setParent(this);
 308         return true;
 309     }
 310     return false;
 311 }
 312 
 313 void GraphicsLayer::removeAllChildren()
 314 {
 315     while (m_children.size()) {
 316         GraphicsLayer* curLayer = m_children[0].ptr();
 317         ASSERT(curLayer-&gt;parent());
 318         curLayer-&gt;removeFromParent();
 319         // curLayer may be destroyed here.
 320     }
 321 }
 322 
 323 void GraphicsLayer::removeFromParent()
 324 {
 325     if (m_parent) {
 326         GraphicsLayer* parent = m_parent;
 327         setParent(nullptr);
 328         parent-&gt;m_children.removeFirstMatching([this](auto&amp; layer) {
 329             return layer.ptr() == this;
 330         });
 331         // |this| may be destroyed here.
 332     }
 333 }
 334 
 335 const TransformationMatrix&amp; GraphicsLayer::transform() const
 336 {
 337     return m_transform ? *m_transform : TransformationMatrix::identity;
 338 }
 339 
 340 void GraphicsLayer::setTransform(const TransformationMatrix&amp; matrix)
 341 {
 342     if (m_transform)
 343         *m_transform = matrix;
 344     else
 345         m_transform = std::make_unique&lt;TransformationMatrix&gt;(matrix);
 346 }
 347 
 348 const TransformationMatrix&amp; GraphicsLayer::childrenTransform() const
 349 {
 350     return m_childrenTransform ? *m_childrenTransform : TransformationMatrix::identity;
 351 }
 352 
 353 void GraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; matrix)
 354 {
 355     if (m_childrenTransform)
 356         *m_childrenTransform = matrix;
 357     else
 358         m_childrenTransform = std::make_unique&lt;TransformationMatrix&gt;(matrix);
 359 }
 360 
 361 void GraphicsLayer::setMaskLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 362 {
 363     if (layer == m_maskLayer)
 364         return;
 365 
 366     if (layer) {
 367         layer-&gt;removeFromParent();
 368         layer-&gt;setParent(this);
 369         layer-&gt;setIsMaskLayer(true);
 370     } else if (m_maskLayer) {
 371         m_maskLayer-&gt;setParent(nullptr);
 372         m_maskLayer-&gt;setIsMaskLayer(false);
 373     }
 374 
 375     m_maskLayer = WTFMove(layer);
 376 }
 377 
 378 Path GraphicsLayer::shapeLayerPath() const
 379 {
 380 #if USE(CA)
 381     return m_shapeLayerPath;
 382 #else
 383     return Path();
 384 #endif
 385 }
 386 
 387 void GraphicsLayer::setShapeLayerPath(const Path&amp; path)
 388 {
 389 #if USE(CA)
 390     m_shapeLayerPath = path;
 391 #else
 392     UNUSED_PARAM(path);
 393 #endif
 394 }
 395 
 396 WindRule GraphicsLayer::shapeLayerWindRule() const
 397 {
 398 #if USE(CA)
 399     return m_shapeLayerWindRule;
 400 #else
 401     return WindRule::NonZero;
 402 #endif
 403 }
 404 
 405 void GraphicsLayer::setShapeLayerWindRule(WindRule windRule)
 406 {
 407 #if USE(CA)
 408     m_shapeLayerWindRule = windRule;
 409 #else
 410     UNUSED_PARAM(windRule);
 411 #endif
 412 }
 413 
 414 void GraphicsLayer::noteDeviceOrPageScaleFactorChangedIncludingDescendants()
 415 {
 416     deviceOrPageScaleFactorChanged();
 417 
 418     if (m_maskLayer)
 419         m_maskLayer-&gt;deviceOrPageScaleFactorChanged();
 420 
 421     if (m_replicaLayer)
 422         m_replicaLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 423 
 424     for (auto&amp; layer : children())
 425         layer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 426 }
 427 
 428 void GraphicsLayer::setIsInWindow(bool inWindow)
 429 {
 430     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
 431         tiledBacking-&gt;setIsInWindow(inWindow);
 432 }
 433 
 434 void GraphicsLayer::setReplicatedByLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 435 {
 436     if (m_replicaLayer == layer)
 437         return;
 438 
 439     if (m_replicaLayer)
 440         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 441 
 442     if (layer)
 443         layer-&gt;setReplicatedLayer(this);
 444 
 445     m_replicaLayer = WTFMove(layer);
 446 }
 447 
 448 void GraphicsLayer::setOffsetFromRenderer(const FloatSize&amp; offset, ShouldSetNeedsDisplay shouldSetNeedsDisplay)
 449 {
 450     if (offset == m_offsetFromRenderer)
 451         return;
 452 
 453     m_offsetFromRenderer = offset;
 454 
 455     // If the compositing layer offset changes, we need to repaint.
 456     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 457         setNeedsDisplay();
 458 }
 459 
 460 void GraphicsLayer::setScrollOffset(const ScrollOffset&amp; offset, ShouldSetNeedsDisplay shouldSetNeedsDisplay)
 461 {
 462     if (offset == m_scrollOffset)
 463         return;
 464 
 465     m_scrollOffset = offset;
 466 
 467     // If the compositing layer offset changes, we need to repaint.
 468     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 469         setNeedsDisplay();
 470 }
 471 
 472 void GraphicsLayer::setSize(const FloatSize&amp; size)
 473 {
 474     if (size == m_size)
 475         return;
 476 
 477     m_size = size;
 478 
 479     if (shouldRepaintOnSizeChange())
 480         setNeedsDisplay();
 481 }
 482 
 483 void GraphicsLayer::setBackgroundColor(const Color&amp; color)
 484 {
 485     m_backgroundColor = color;
 486 }
 487 
 488 void GraphicsLayer::paintGraphicsLayerContents(GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 489 {
 490     FloatSize offset = offsetFromRenderer() - toFloatSize(scrollOffset());
 491     context.translate(-offset);
 492 
 493     FloatRect clipRect(clip);
 494     clipRect.move(offset);
 495 
 496     client().paintContents(this, context, m_paintingPhase, clipRect, layerPaintBehavior);
 497 }
 498 
 499 String GraphicsLayer::animationNameForTransition(AnimatedPropertyID property)
 500 {
 501     // | is not a valid identifier character in CSS, so this can never conflict with a keyframe identifier.
 502     StringBuilder id;
 503     id.appendLiteral(&quot;-|transition&quot;);
 504     id.appendNumber(static_cast&lt;int&gt;(property));
 505     id.append(&#39;-&#39;);
 506     return id.toString();
 507 }
 508 
 509 void GraphicsLayer::suspendAnimations(MonotonicTime)
 510 {
 511 }
 512 
 513 void GraphicsLayer::resumeAnimations()
 514 {
 515 }
 516 
 517 void GraphicsLayer::getDebugBorderInfo(Color&amp; color, float&amp; width) const
 518 {
 519     width = 2;
 520 
 521     if (needsBackdrop()) {
 522         color = Color(255, 0, 255, 128); // has backdrop: magenta
 523         width = 12;
 524         return;
 525     }
 526 
 527     if (drawsContent()) {
 528         if (tiledBacking()) {
 529             color = Color(255, 128, 0, 128); // tiled layer: orange
 530             return;
 531         }
 532 
 533         color = Color(0, 128, 32, 128); // normal layer: green
 534         return;
 535     }
 536 
 537     if (usesContentsLayer()) {
 538         color = Color(0, 64, 128, 150); // non-painting layer with contents: blue
 539         width = 8;
 540         return;
 541     }
 542 
 543     if (masksToBounds()) {
 544         color = Color(128, 255, 255, 48); // masking layer: pale blue
 545         width = 16;
 546         return;
 547     }
 548 
 549     color = Color(255, 255, 0, 192); // container: yellow
 550 }
 551 
 552 void GraphicsLayer::updateDebugIndicators()
 553 {
 554     if (!isShowingDebugBorder())
 555         return;
 556 
 557     Color borderColor;
 558     float width = 0;
 559     getDebugBorderInfo(borderColor, width);
 560     setDebugBorder(borderColor, width);
 561 }
 562 
 563 void GraphicsLayer::setZPosition(float position)
 564 {
 565     m_zPosition = position;
 566 }
 567 
 568 float GraphicsLayer::accumulatedOpacity() const
 569 {
 570     if (!preserves3D())
 571         return 1;
 572 
 573     return m_opacity * (parent() ? parent()-&gt;accumulatedOpacity() : 1);
 574 }
 575 
 576 void GraphicsLayer::distributeOpacity(float accumulatedOpacity)
 577 {
 578     // If this is a transform layer we need to distribute our opacity to all our children
 579 
 580     // Incoming accumulatedOpacity is the contribution from our parent(s). We mutiply this by our own
 581     // opacity to get the total contribution
 582     accumulatedOpacity *= m_opacity;
 583 
 584     setOpacityInternal(accumulatedOpacity);
 585 
 586     if (preserves3D()) {
 587         for (auto&amp; layer : children())
 588             layer-&gt;distributeOpacity(accumulatedOpacity);
 589     }
 590 }
 591 
 592 static inline const FilterOperations&amp; filterOperationsAt(const KeyframeValueList&amp; valueList, size_t index)
 593 {
 594     return static_cast&lt;const FilterAnimationValue&amp;&gt;(valueList.at(index)).value();
 595 }
 596 
 597 int GraphicsLayer::validateFilterOperations(const KeyframeValueList&amp; valueList)
 598 {
 599 #if ENABLE(FILTERS_LEVEL_2)
 600     ASSERT(valueList.property() == AnimatedPropertyFilter || valueList.property() == AnimatedPropertyWebkitBackdropFilter);
 601 #else
 602     ASSERT(valueList.property() == AnimatedPropertyFilter);
 603 #endif
 604 
 605     if (valueList.size() &lt; 2)
 606         return -1;
 607 
 608     // Empty filters match anything, so find the first non-empty entry as the reference
 609     size_t firstIndex = 0;
 610     for ( ; firstIndex &lt; valueList.size(); ++firstIndex) {
 611         if (!filterOperationsAt(valueList, firstIndex).operations().isEmpty())
 612             break;
 613     }
 614 
 615     if (firstIndex &gt;= valueList.size())
 616         return -1;
 617 
 618     const FilterOperations&amp; firstVal = filterOperationsAt(valueList, firstIndex);
 619 
 620     for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 621         const FilterOperations&amp; val = filterOperationsAt(valueList, i);
 622 
 623         // An emtpy filter list matches anything.
 624         if (val.operations().isEmpty())
 625             continue;
 626 
 627         if (!firstVal.operationsMatch(val))
 628             return -1;
 629     }
 630 
 631     return firstIndex;
 632 }
 633 
 634 // An &quot;invalid&quot; list is one whose functions don&#39;t match, and therefore has to be animated as a Matrix
 635 // The hasBigRotation flag will always return false if isValid is false. Otherwise hasBigRotation is
 636 // true if the rotation between any two keyframes is &gt;= 180 degrees.
 637 
 638 static inline const TransformOperations&amp; operationsAt(const KeyframeValueList&amp; valueList, size_t index)
 639 {
 640     return static_cast&lt;const TransformAnimationValue&amp;&gt;(valueList.at(index)).value();
 641 }
 642 
 643 int GraphicsLayer::validateTransformOperations(const KeyframeValueList&amp; valueList, bool&amp; hasBigRotation)
 644 {
 645     ASSERT(valueList.property() == AnimatedPropertyTransform);
 646 
 647     hasBigRotation = false;
 648 
 649     if (valueList.size() &lt; 2)
 650         return -1;
 651 
 652     // Empty transforms match anything, so find the first non-empty entry as the reference.
 653     size_t firstIndex = 0;
 654     for ( ; firstIndex &lt; valueList.size(); ++firstIndex) {
 655         if (!operationsAt(valueList, firstIndex).operations().isEmpty())
 656             break;
 657     }
 658 
 659     if (firstIndex &gt;= valueList.size())
 660         return -1;
 661 
 662     const TransformOperations&amp; firstVal = operationsAt(valueList, firstIndex);
 663 
 664     // See if the keyframes are valid.
 665     for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 666         const TransformOperations&amp; val = operationsAt(valueList, i);
 667 
 668         // An empty transform list matches anything.
 669         if (val.operations().isEmpty())
 670             continue;
 671 
 672         if (!firstVal.operationsMatch(val))
 673             return -1;
 674     }
 675 
 676     // Keyframes are valid, check for big rotations.
 677     double lastRotationAngle = 0.0;
 678     double maxRotationAngle = -1.0;
 679 
 680     for (size_t j = 0; j &lt; firstVal.operations().size(); ++j) {
 681         TransformOperation::OperationType type = firstVal.operations().at(j)-&gt;type();
 682 
 683         // if this is a rotation entry, we need to see if any angle differences are &gt;= 180 deg
 684         if (type == TransformOperation::ROTATE_X ||
 685             type == TransformOperation::ROTATE_Y ||
 686             type == TransformOperation::ROTATE_Z ||
 687             type == TransformOperation::ROTATE_3D) {
 688             lastRotationAngle = downcast&lt;RotateTransformOperation&gt;(*firstVal.operations().at(j)).angle();
 689 
 690             if (maxRotationAngle &lt; 0)
 691                 maxRotationAngle = fabs(lastRotationAngle);
 692 
 693             for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 694                 const TransformOperations&amp; val = operationsAt(valueList, i);
 695                 double rotationAngle = val.operations().isEmpty() ? 0 : downcast&lt;RotateTransformOperation&gt;(*val.operations().at(j)).angle();
 696                 double diffAngle = fabs(rotationAngle - lastRotationAngle);
 697                 if (diffAngle &gt; maxRotationAngle)
 698                     maxRotationAngle = diffAngle;
 699                 lastRotationAngle = rotationAngle;
 700             }
 701         }
 702     }
 703 
 704     hasBigRotation = maxRotationAngle &gt;= 180.0;
 705 
 706     return firstIndex;
 707 }
 708 
 709 double GraphicsLayer::backingStoreMemoryEstimate() const
 710 {
 711     if (!drawsContent())
 712         return 0;
 713 
 714     // Effects of page and device scale are ignored; subclasses should override to take these into account.
 715     return static_cast&lt;double&gt;(4 * size().width()) * size().height();
 716 }
 717 
 718 void GraphicsLayer::resetTrackedRepaints()
 719 {
 720     repaintRectMap().remove(this);
 721 }
 722 
 723 void GraphicsLayer::addRepaintRect(const FloatRect&amp; repaintRect)
 724 {
 725     if (!client().isTrackingRepaints())
 726         return;
 727 
 728     FloatRect largestRepaintRect(FloatPoint(), m_size);
 729     largestRepaintRect.intersect(repaintRect);
 730     RepaintMap::iterator repaintIt = repaintRectMap().find(this);
 731     if (repaintIt == repaintRectMap().end()) {
 732         Vector&lt;FloatRect&gt; repaintRects;
 733         repaintRects.append(largestRepaintRect);
 734         repaintRectMap().set(this, repaintRects);
 735     } else {
 736         Vector&lt;FloatRect&gt;&amp; repaintRects = repaintIt-&gt;value;
 737         repaintRects.append(largestRepaintRect);
 738     }
 739 }
 740 
 741 void GraphicsLayer::traverse(GraphicsLayer&amp; layer, const WTF::Function&lt;void (GraphicsLayer&amp;)&gt;&amp; traversalFunc)
 742 {
 743     traversalFunc(layer);
 744 
 745     for (auto&amp; childLayer : layer.children())
 746         traverse(childLayer.get(), traversalFunc);
 747 
 748     if (auto* replicaLayer = layer.replicaLayer())
 749         traverse(*replicaLayer, traversalFunc);
 750 
 751     if (auto* maskLayer = layer.maskLayer())
 752         traverse(*maskLayer, traversalFunc);
 753 }
 754 
 755 GraphicsLayer::EmbeddedViewID GraphicsLayer::nextEmbeddedViewID()
 756 {
 757     static GraphicsLayer::EmbeddedViewID nextEmbeddedViewID;
 758     return ++nextEmbeddedViewID;
 759 }
 760 
 761 void GraphicsLayer::dumpLayer(TextStream&amp; ts, LayerTreeAsTextBehavior behavior) const
 762 {
 763     ts &lt;&lt; indent &lt;&lt; &quot;(&quot; &lt;&lt; &quot;GraphicsLayer&quot;;
 764 
 765     if (behavior &amp; LayerTreeAsTextDebug) {
 766         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;void*&gt;(const_cast&lt;GraphicsLayer*&gt;(this));
 767         ts &lt;&lt; &quot; \&quot;&quot; &lt;&lt; m_name &lt;&lt; &quot;\&quot;&quot;;
 768     }
 769 
 770     ts &lt;&lt; &quot;\n&quot;;
 771     dumpProperties(ts, behavior);
 772     ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 773 }
 774 
 775 static void dumpChildren(TextStream&amp; ts, const Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; children, unsigned&amp; totalChildCount, LayerTreeAsTextBehavior behavior)
 776 {
 777     totalChildCount += children.size();
 778     for (auto&amp; child : children) {
 779         if ((behavior &amp; LayerTreeAsTextDebug) || !child-&gt;client().shouldSkipLayerInDump(child.ptr(), behavior)) {
 780             TextStream::IndentScope indentScope(ts);
 781             child-&gt;dumpLayer(ts, behavior);
 782             continue;
 783         }
 784 
 785         totalChildCount--;
 786         dumpChildren(ts, child-&gt;children(), totalChildCount, behavior);
 787     }
 788 }
 789 
 790 void GraphicsLayer::dumpProperties(TextStream&amp; ts, LayerTreeAsTextBehavior behavior) const
 791 {
 792     TextStream::IndentScope indentScope(ts);
 793     if (!m_offsetFromRenderer.isZero())
 794         ts &lt;&lt; indent &lt;&lt; &quot;(offsetFromRenderer &quot; &lt;&lt; m_offsetFromRenderer &lt;&lt; &quot;)\n&quot;;
 795 
 796     if (!m_scrollOffset.isZero())
 797         ts &lt;&lt; indent &lt;&lt; &quot;(scrollOffset &quot; &lt;&lt; m_scrollOffset &lt;&lt; &quot;)\n&quot;;
 798 
 799     if (m_position != FloatPoint())
 800         ts &lt;&lt; indent &lt;&lt; &quot;(position &quot; &lt;&lt; m_position.x() &lt;&lt; &quot; &quot; &lt;&lt; m_position.y() &lt;&lt; &quot;)\n&quot;;
 801 
 802     if (m_approximatePosition)
 803         ts &lt;&lt; indent &lt;&lt; &quot;(approximate position &quot; &lt;&lt; m_approximatePosition.value().x() &lt;&lt; &quot; &quot; &lt;&lt; m_approximatePosition.value().y() &lt;&lt; &quot;)\n&quot;;
 804 
 805     if (m_boundsOrigin != FloatPoint())
 806         ts &lt;&lt; indent &lt;&lt; &quot;(bounds origin &quot; &lt;&lt; m_boundsOrigin.x() &lt;&lt; &quot; &quot; &lt;&lt; m_boundsOrigin.y() &lt;&lt; &quot;)\n&quot;;
 807 
 808     if (m_anchorPoint != FloatPoint3D(0.5f, 0.5f, 0)) {
 809         ts &lt;&lt; indent &lt;&lt; &quot;(anchor &quot; &lt;&lt; m_anchorPoint.x() &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.y();
 810         if (m_anchorPoint.z())
 811             ts &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.z();
 812         ts &lt;&lt; &quot;)\n&quot;;
 813     }
 814 
 815     if (m_size != IntSize())
 816         ts &lt;&lt; indent &lt;&lt; &quot;(bounds &quot; &lt;&lt; m_size.width() &lt;&lt; &quot; &quot; &lt;&lt; m_size.height() &lt;&lt; &quot;)\n&quot;;
 817 
 818     if (m_opacity != 1)
 819         ts &lt;&lt; indent &lt;&lt; &quot;(opacity &quot; &lt;&lt; m_opacity &lt;&lt; &quot;)\n&quot;;
 820 
 821 #if ENABLE(CSS_COMPOSITING)
 822     if (m_blendMode != BlendMode::Normal)
 823         ts &lt;&lt; indent &lt;&lt; &quot;(blendMode &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, m_blendMode) &lt;&lt; &quot;)\n&quot;;
 824 #endif
 825 
 826     if (type() == Type::Normal &amp;&amp; tiledBacking())
 827         ts &lt;&lt; indent &lt;&lt; &quot;(usingTiledLayer 1)\n&quot;;
 828 
 829     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack = client().needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(*this);
 830     if (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack)
 831         ts &lt;&lt; indent &lt;&lt; &quot;(contentsOpaque &quot; &lt;&lt; (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack) &lt;&lt; &quot;)\n&quot;;
 832 
 833     if (m_supportsSubpixelAntialiasedText)
 834         ts &lt;&lt; indent &lt;&lt; &quot;(supports subpixel antialiased text &quot; &lt;&lt; m_supportsSubpixelAntialiasedText &lt;&lt; &quot;)\n&quot;;
 835 
 836     if (m_preserves3D)
 837         ts &lt;&lt; indent &lt;&lt; &quot;(preserves3D &quot; &lt;&lt; m_preserves3D &lt;&lt; &quot;)\n&quot;;
 838 
 839     if (m_drawsContent &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;drawsContent&quot;, behavior))
 840         ts &lt;&lt; indent &lt;&lt; &quot;(drawsContent &quot; &lt;&lt; m_drawsContent &lt;&lt; &quot;)\n&quot;;
 841 
 842     if (!m_contentsVisible)
 843         ts &lt;&lt; indent &lt;&lt; &quot;(contentsVisible &quot; &lt;&lt; m_contentsVisible &lt;&lt; &quot;)\n&quot;;
 844 
 845     if (!m_backfaceVisibility)
 846         ts &lt;&lt; indent &lt;&lt; &quot;(backfaceVisibility &quot; &lt;&lt; (m_backfaceVisibility ? &quot;visible&quot; : &quot;hidden&quot;) &lt;&lt; &quot;)\n&quot;;
 847 
 848     if (behavior &amp; LayerTreeAsTextDebug) {
 849         ts &lt;&lt; indent &lt;&lt; &quot;(primary-layer-id &quot; &lt;&lt; primaryLayerID() &lt;&lt; &quot;)\n&quot;;
 850         ts &lt;&lt; indent &lt;&lt; &quot;(client &quot; &lt;&lt; static_cast&lt;void*&gt;(m_client) &lt;&lt; &quot;)\n&quot;;
 851     }
 852 
 853     if (m_backgroundColor.isValid() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;backgroundColor&quot;, behavior))
 854         ts &lt;&lt; indent &lt;&lt; &quot;(backgroundColor &quot; &lt;&lt; m_backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;)\n&quot;;
 855 
 856     if (behavior &amp; LayerTreeAsTextIncludeAcceleratesDrawing &amp;&amp; m_acceleratesDrawing)
 857         ts &lt;&lt; indent &lt;&lt; &quot;(acceleratesDrawing &quot; &lt;&lt; m_acceleratesDrawing &lt;&lt; &quot;)\n&quot;;
 858 
 859     if (behavior &amp; LayerTreeAsTextIncludeBackingStoreAttached)
 860         ts &lt;&lt; indent &lt;&lt; &quot;(backingStoreAttached &quot; &lt;&lt; backingStoreAttachedForTesting() &lt;&lt; &quot;)\n&quot;;
 861 
 862     if (m_transform &amp;&amp; !m_transform-&gt;isIdentity()) {
 863         ts &lt;&lt; indent &lt;&lt; &quot;(transform &quot;;
 864         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m14() &lt;&lt; &quot;] &quot;;
 865         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m24() &lt;&lt; &quot;] &quot;;
 866         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m34() &lt;&lt; &quot;] &quot;;
 867         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 868     }
 869 
 870     // Avoid dumping the sublayer transform on the root layer, because it&#39;s used for geometry flipping, whose behavior
 871     // differs between platforms.
 872     if (parent() &amp;&amp; m_childrenTransform &amp;&amp; !m_childrenTransform-&gt;isIdentity()) {
 873         ts &lt;&lt; indent &lt;&lt; &quot;(childrenTransform &quot;;
 874         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m14() &lt;&lt; &quot;] &quot;;
 875         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m24() &lt;&lt; &quot;] &quot;;
 876         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m34() &lt;&lt; &quot;] &quot;;
 877         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 878     }
 879 
 880     if (m_maskLayer) {
 881         ts &lt;&lt; indent &lt;&lt; &quot;(mask layer&quot;;
 882         if (behavior &amp; LayerTreeAsTextDebug)
 883             ts &lt;&lt; &quot; &quot; &lt;&lt; m_maskLayer;
 884         ts &lt;&lt; &quot;)\n&quot;;
 885 
 886         TextStream::IndentScope indentScope(ts);
 887         m_maskLayer-&gt;dumpLayer(ts, behavior);
 888     }
 889 
 890     if (m_replicaLayer) {
 891         ts &lt;&lt; indent &lt;&lt; &quot;(replica layer&quot;;
 892         if (behavior &amp; LayerTreeAsTextDebug)
 893             ts &lt;&lt; &quot; &quot; &lt;&lt; m_replicaLayer;
 894         ts &lt;&lt; &quot;)\n&quot;;
 895 
 896         TextStream::IndentScope indentScope(ts);
 897         m_replicaLayer-&gt;dumpLayer(ts, behavior);
 898     }
 899 
 900     if (m_replicatedLayer) {
 901         ts &lt;&lt; indent &lt;&lt; &quot;(replicated layer&quot;;
 902         if (behavior &amp; LayerTreeAsTextDebug)
 903             ts &lt;&lt; &quot; &quot; &lt;&lt; m_replicatedLayer;
 904         ts &lt;&lt; &quot;)\n&quot;;
 905     }
 906 
 907     if (behavior &amp; LayerTreeAsTextIncludeRepaintRects &amp;&amp; repaintRectMap().contains(this) &amp;&amp; !repaintRectMap().get(this).isEmpty() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;repaintRects&quot;, behavior)) {
 908         ts &lt;&lt; indent &lt;&lt; &quot;(repaint rects\n&quot;;
 909         for (size_t i = 0; i &lt; repaintRectMap().get(this).size(); ++i) {
 910             if (repaintRectMap().get(this)[i].isEmpty())
 911                 continue;
 912 
 913             TextStream::IndentScope indentScope(ts);
 914             ts &lt;&lt; indent &lt;&lt; &quot;(rect &quot;;
 915             ts &lt;&lt; repaintRectMap().get(this)[i].x() &lt;&lt; &quot; &quot;;
 916             ts &lt;&lt; repaintRectMap().get(this)[i].y() &lt;&lt; &quot; &quot;;
 917             ts &lt;&lt; repaintRectMap().get(this)[i].width() &lt;&lt; &quot; &quot;;
 918             ts &lt;&lt; repaintRectMap().get(this)[i].height();
 919             ts &lt;&lt; &quot;)\n&quot;;
 920         }
 921         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 922     }
 923 
 924     if (behavior &amp; LayerTreeAsTextIncludePaintingPhases &amp;&amp; paintingPhase()) {
 925         ts &lt;&lt; indent &lt;&lt; &quot;(paintingPhases\n&quot;;
 926         TextStream::IndentScope indentScope(ts);
 927         if (paintingPhase() &amp; GraphicsLayerPaintBackground)
 928             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintBackground\n&quot;;
 929 
 930         if (paintingPhase() &amp; GraphicsLayerPaintForeground)
 931             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintForeground\n&quot;;
 932 
 933         if (paintingPhase() &amp; GraphicsLayerPaintMask)
 934             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintMask\n&quot;;
 935 
 936         if (paintingPhase() &amp; GraphicsLayerPaintChildClippingMask)
 937             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintChildClippingMask\n&quot;;
 938 
 939         if (paintingPhase() &amp; GraphicsLayerPaintOverflowContents)
 940             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintOverflowContents\n&quot;;
 941 
 942         if (paintingPhase() &amp; GraphicsLayerPaintCompositedScroll)
 943             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintCompositedScroll\n&quot;;
 944 
 945         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 946     }
 947 
 948     dumpAdditionalProperties(ts, behavior);
 949 
 950     if (m_children.size()) {
 951         TextStream childrenStream;
 952 
 953         childrenStream.increaseIndent(ts.indent());
 954         unsigned totalChildCount = 0;
 955         dumpChildren(childrenStream, m_children, totalChildCount, behavior);
 956 
 957         if (totalChildCount) {
 958             ts &lt;&lt; indent &lt;&lt; &quot;(children &quot; &lt;&lt; totalChildCount &lt;&lt; &quot;\n&quot;;
 959             ts &lt;&lt; childrenStream.release();
 960             ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 961         }
 962     }
 963 }
 964 
 965 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp; layers)
 966 {
 967     for (size_t i = 0; i &lt; layers.size(); ++i) {
 968         if (i)
 969             ts &lt;&lt; &quot; &quot;;
 970         ts &lt;&lt; layers[i];
 971     }
 972 
 973     return ts;
 974 }
 975 
 976 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const WebCore::GraphicsLayer::CustomAppearance&amp; customAppearance)
 977 {
 978     switch (customAppearance) {
 979     case GraphicsLayer::CustomAppearance::None: ts &lt;&lt; &quot;none&quot;; break;
 980     case GraphicsLayer::CustomAppearance::ScrollingOverhang: ts &lt;&lt; &quot;scrolling-overhang&quot;; break;
 981     case GraphicsLayer::CustomAppearance::ScrollingShadow: ts &lt;&lt; &quot;scrolling-shadow&quot;; break;
 982     case GraphicsLayer::CustomAppearance::LightBackdrop: ts &lt;&lt; &quot;light-backdrop&quot;; break;
 983     case GraphicsLayer::CustomAppearance::DarkBackdrop: ts &lt;&lt; &quot;dark-backdrop&quot;; break;
 984     }
 985     return ts;
 986 }
 987 
 988 String GraphicsLayer::layerTreeAsText(LayerTreeAsTextBehavior behavior) const
 989 {
 990     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
 991 
 992     dumpLayer(ts, behavior);
 993     return ts.release();
 994 }
 995 
 996 } // namespace WebCore
 997 
 998 #if ENABLE(TREE_DEBUGGING)
 999 void showGraphicsLayerTree(const WebCore::GraphicsLayer* layer)
1000 {
1001     if (!layer)
1002         return;
1003 
1004     String output = layer-&gt;layerTreeAsText(WebCore::LayerTreeAsTextShowAll);
1005     WTFLogAlways(&quot;%s\n&quot;, output.utf8().data());
1006 }
1007 #endif
    </pre>
  </body>
</html>