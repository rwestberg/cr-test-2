<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;B3ReduceStrength.h&quot;
  28 
  29 #if ENABLE(B3_JIT)
  30 
  31 #include &quot;B3AtomicValue.h&quot;
  32 #include &quot;B3BasicBlockInlines.h&quot;
  33 #include &quot;B3BlockInsertionSet.h&quot;
  34 #include &quot;B3ComputeDivisionMagic.h&quot;
  35 #include &quot;B3Dominators.h&quot;
  36 #include &quot;B3InsertionSetInlines.h&quot;
  37 #include &quot;B3MemoryValueInlines.h&quot;
  38 #include &quot;B3PhaseScope.h&quot;
  39 #include &quot;B3PhiChildren.h&quot;
  40 #include &quot;B3ProcedureInlines.h&quot;
  41 #include &quot;B3PureCSE.h&quot;
  42 #include &quot;B3SlotBaseValue.h&quot;
  43 #include &quot;B3StackSlot.h&quot;
  44 #include &quot;B3UpsilonValue.h&quot;
  45 #include &quot;B3ValueKeyInlines.h&quot;
  46 #include &quot;B3ValueInlines.h&quot;
  47 #include &quot;B3Variable.h&quot;
  48 #include &quot;B3VariableValue.h&quot;
  49 #include &lt;wtf/GraphNodeWorklist.h&gt;
  50 #include &lt;wtf/HashMap.h&gt;
  51 #include &lt;wtf/IndexSet.h&gt;
  52 
  53 namespace JSC { namespace B3 {
  54 
  55 namespace {
  56 
  57 // The goal of this phase is to:
  58 //
  59 // - Replace operations with less expensive variants. This includes constant folding and classic
  60 //   strength reductions like turning Mul(x, 1 &lt;&lt; k) into Shl(x, k).
  61 //
  62 // - Reassociate constant operations. For example, Load(Add(x, c)) is turned into Load(x, offset = c)
  63 //   and Add(Add(x, c), d) is turned into Add(x, c + d).
  64 //
  65 // - Canonicalize operations. There are some cases where it&#39;s not at all obvious which kind of
  66 //   operation is less expensive, but it&#39;s useful for subsequent phases - particularly LowerToAir -
  67 //   to have only one way of representing things.
  68 //
  69 // This phase runs to fixpoint. Therefore, the canonicalizations must be designed to be monotonic.
  70 // For example, if we had a canonicalization that said that Add(x, -c) should be Sub(x, c) and
  71 // another canonicalization that said that Sub(x, d) should be Add(x, -d), then this phase would end
  72 // up running forever. We don&#39;t want that.
  73 //
  74 // Therefore, we need to prioritize certain canonical forms over others. Naively, we want strength
  75 // reduction to reduce the number of values, and so a form involving fewer total values is more
  76 // canonical. But we might break this, for example when reducing strength of Mul(x, 9). This could be
  77 // better written as Add(Shl(x, 3), x), which also happens to be representable using a single
  78 // instruction on x86.
  79 //
  80 // Here are some of the rules we have:
  81 //
  82 // Canonical form of logical not: BitXor(value, 1). We may have to avoid using this form if we don&#39;t
  83 // know for sure that &#39;value&#39; is 0-or-1 (i.e. returnsBool). In that case we fall back on
  84 // Equal(value, 0).
  85 //
  86 // Canonical form of commutative operations: if the operation involves a constant, the constant must
  87 // come second. Add(x, constant) is canonical, while Add(constant, x) is not. If there are no
  88 // constants then the canonical form involves the lower-indexed value first. Given Add(x, y), it&#39;s
  89 // canonical if x-&gt;index() &lt;= y-&gt;index().
  90 
  91 namespace B3ReduceStrengthInternal {
  92 static const bool verbose = false;
  93 }
  94 
  95 // FIXME: This IntRange stuff should be refactored into a general constant propagator. It&#39;s weird
  96 // that it&#39;s just sitting here in this file.
  97 class IntRange {
  98 public:
  99     IntRange()
 100     {
 101     }
 102 
 103     IntRange(int64_t min, int64_t max)
 104         : m_min(min)
 105         , m_max(max)
 106     {
 107     }
 108 
 109     template&lt;typename T&gt;
 110     static IntRange top()
 111     {
 112         return IntRange(std::numeric_limits&lt;T&gt;::min(), std::numeric_limits&lt;T&gt;::max());
 113     }
 114 
 115     static IntRange top(Type type)
 116     {
 117         switch (type) {
 118         case Int32:
 119             return top&lt;int32_t&gt;();
 120         case Int64:
 121             return top&lt;int64_t&gt;();
 122         default:
 123             RELEASE_ASSERT_NOT_REACHED();
 124             return IntRange();
 125         }
 126     }
 127 
 128     template&lt;typename T&gt;
 129     static IntRange rangeForMask(T mask)
 130     {
 131         if (!(mask + 1))
 132             return top&lt;T&gt;();
 133         return IntRange(0, mask);
 134     }
 135 
 136     static IntRange rangeForMask(int64_t mask, Type type)
 137     {
 138         switch (type) {
 139         case Int32:
 140             return rangeForMask&lt;int32_t&gt;(static_cast&lt;int32_t&gt;(mask));
 141         case Int64:
 142             return rangeForMask&lt;int64_t&gt;(mask);
 143         default:
 144             RELEASE_ASSERT_NOT_REACHED();
 145             return IntRange();
 146         }
 147     }
 148 
 149     template&lt;typename T&gt;
 150     static IntRange rangeForZShr(int32_t shiftAmount)
 151     {
 152         typename std::make_unsigned&lt;T&gt;::type mask = 0;
 153         mask--;
 154         mask &gt;&gt;= shiftAmount;
 155         return rangeForMask&lt;T&gt;(static_cast&lt;T&gt;(mask));
 156     }
 157 
 158     static IntRange rangeForZShr(int32_t shiftAmount, Type type)
 159     {
 160         switch (type) {
 161         case Int32:
 162             return rangeForZShr&lt;int32_t&gt;(shiftAmount);
 163         case Int64:
 164             return rangeForZShr&lt;int64_t&gt;(shiftAmount);
 165         default:
 166             RELEASE_ASSERT_NOT_REACHED();
 167             return IntRange();
 168         }
 169     }
 170 
 171     int64_t min() const { return m_min; }
 172     int64_t max() const { return m_max; }
 173 
 174     void dump(PrintStream&amp; out) const
 175     {
 176         out.print(&quot;[&quot;, m_min, &quot;,&quot;, m_max, &quot;]&quot;);
 177     }
 178 
 179     template&lt;typename T&gt;
 180     bool couldOverflowAdd(const IntRange&amp; other)
 181     {
 182         return sumOverflows&lt;T&gt;(m_min, other.m_min)
 183             || sumOverflows&lt;T&gt;(m_min, other.m_max)
 184             || sumOverflows&lt;T&gt;(m_max, other.m_min)
 185             || sumOverflows&lt;T&gt;(m_max, other.m_max);
 186     }
 187 
 188     bool couldOverflowAdd(const IntRange&amp; other, Type type)
 189     {
 190         switch (type) {
 191         case Int32:
 192             return couldOverflowAdd&lt;int32_t&gt;(other);
 193         case Int64:
 194             return couldOverflowAdd&lt;int64_t&gt;(other);
 195         default:
 196             return true;
 197         }
 198     }
 199 
 200     template&lt;typename T&gt;
 201     bool couldOverflowSub(const IntRange&amp; other)
 202     {
 203         return differenceOverflows&lt;T&gt;(m_min, other.m_min)
 204             || differenceOverflows&lt;T&gt;(m_min, other.m_max)
 205             || differenceOverflows&lt;T&gt;(m_max, other.m_min)
 206             || differenceOverflows&lt;T&gt;(m_max, other.m_max);
 207     }
 208 
 209     bool couldOverflowSub(const IntRange&amp; other, Type type)
 210     {
 211         switch (type) {
 212         case Int32:
 213             return couldOverflowSub&lt;int32_t&gt;(other);
 214         case Int64:
 215             return couldOverflowSub&lt;int64_t&gt;(other);
 216         default:
 217             return true;
 218         }
 219     }
 220 
 221     template&lt;typename T&gt;
 222     bool couldOverflowMul(const IntRange&amp; other)
 223     {
 224         return productOverflows&lt;T&gt;(m_min, other.m_min)
 225             || productOverflows&lt;T&gt;(m_min, other.m_max)
 226             || productOverflows&lt;T&gt;(m_max, other.m_min)
 227             || productOverflows&lt;T&gt;(m_max, other.m_max);
 228     }
 229 
 230     bool couldOverflowMul(const IntRange&amp; other, Type type)
 231     {
 232         switch (type) {
 233         case Int32:
 234             return couldOverflowMul&lt;int32_t&gt;(other);
 235         case Int64:
 236             return couldOverflowMul&lt;int64_t&gt;(other);
 237         default:
 238             return true;
 239         }
 240     }
 241 
 242     template&lt;typename T&gt;
 243     IntRange shl(int32_t shiftAmount)
 244     {
 245         T newMin = static_cast&lt;T&gt;(m_min) &lt;&lt; static_cast&lt;T&gt;(shiftAmount);
 246         T newMax = static_cast&lt;T&gt;(m_max) &lt;&lt; static_cast&lt;T&gt;(shiftAmount);
 247 
 248         if ((newMin &gt;&gt; shiftAmount) != static_cast&lt;T&gt;(m_min))
 249             newMin = std::numeric_limits&lt;T&gt;::min();
 250         if ((newMax &gt;&gt; shiftAmount) != static_cast&lt;T&gt;(m_max))
 251             newMax = std::numeric_limits&lt;T&gt;::max();
 252 
 253         return IntRange(newMin, newMax);
 254     }
 255 
 256     IntRange shl(int32_t shiftAmount, Type type)
 257     {
 258         switch (type) {
 259         case Int32:
 260             return shl&lt;int32_t&gt;(shiftAmount);
 261         case Int64:
 262             return shl&lt;int64_t&gt;(shiftAmount);
 263         default:
 264             RELEASE_ASSERT_NOT_REACHED();
 265             return IntRange();
 266         }
 267     }
 268 
 269     template&lt;typename T&gt;
 270     IntRange sShr(int32_t shiftAmount)
 271     {
 272         T newMin = static_cast&lt;T&gt;(m_min) &gt;&gt; static_cast&lt;T&gt;(shiftAmount);
 273         T newMax = static_cast&lt;T&gt;(m_max) &gt;&gt; static_cast&lt;T&gt;(shiftAmount);
 274 
 275         return IntRange(newMin, newMax);
 276     }
 277 
 278     IntRange sShr(int32_t shiftAmount, Type type)
 279     {
 280         switch (type) {
 281         case Int32:
 282             return sShr&lt;int32_t&gt;(shiftAmount);
 283         case Int64:
 284             return sShr&lt;int64_t&gt;(shiftAmount);
 285         default:
 286             RELEASE_ASSERT_NOT_REACHED();
 287             return IntRange();
 288         }
 289     }
 290 
 291     template&lt;typename T&gt;
 292     IntRange zShr(int32_t shiftAmount)
 293     {
 294         // This is an awkward corner case for all of the other logic.
 295         if (!shiftAmount)
 296             return *this;
 297 
 298         // If the input range may be negative, then all we can say about the output range is that it
 299         // will be masked. That&#39;s because -1 right shifted just produces that mask.
 300         if (m_min &lt; 0)
 301             return rangeForZShr&lt;T&gt;(shiftAmount);
 302 
 303         // If the input range is non-negative, then this just brings the range closer to zero.
 304         typedef typename std::make_unsigned&lt;T&gt;::type UnsignedT;
 305         UnsignedT newMin = static_cast&lt;UnsignedT&gt;(m_min) &gt;&gt; static_cast&lt;UnsignedT&gt;(shiftAmount);
 306         UnsignedT newMax = static_cast&lt;UnsignedT&gt;(m_max) &gt;&gt; static_cast&lt;UnsignedT&gt;(shiftAmount);
 307 
 308         return IntRange(newMin, newMax);
 309     }
 310 
 311     IntRange zShr(int32_t shiftAmount, Type type)
 312     {
 313         switch (type) {
 314         case Int32:
 315             return zShr&lt;int32_t&gt;(shiftAmount);
 316         case Int64:
 317             return zShr&lt;int64_t&gt;(shiftAmount);
 318         default:
 319             RELEASE_ASSERT_NOT_REACHED();
 320             return IntRange();
 321         }
 322     }
 323 
 324     template&lt;typename T&gt;
 325     IntRange add(const IntRange&amp; other)
 326     {
 327         if (couldOverflowAdd&lt;T&gt;(other))
 328             return top&lt;T&gt;();
 329         return IntRange(m_min + other.m_min, m_max + other.m_max);
 330     }
 331 
 332     IntRange add(const IntRange&amp; other, Type type)
 333     {
 334         switch (type) {
 335         case Int32:
 336             return add&lt;int32_t&gt;(other);
 337         case Int64:
 338             return add&lt;int64_t&gt;(other);
 339         default:
 340             RELEASE_ASSERT_NOT_REACHED();
 341             return IntRange();
 342         }
 343     }
 344 
 345     template&lt;typename T&gt;
 346     IntRange sub(const IntRange&amp; other)
 347     {
 348         if (couldOverflowSub&lt;T&gt;(other))
 349             return top&lt;T&gt;();
 350         return IntRange(m_min - other.m_max, m_max - other.m_min);
 351     }
 352 
 353     IntRange sub(const IntRange&amp; other, Type type)
 354     {
 355         switch (type) {
 356         case Int32:
 357             return sub&lt;int32_t&gt;(other);
 358         case Int64:
 359             return sub&lt;int64_t&gt;(other);
 360         default:
 361             RELEASE_ASSERT_NOT_REACHED();
 362             return IntRange();
 363         }
 364     }
 365 
 366     template&lt;typename T&gt;
 367     IntRange mul(const IntRange&amp; other)
 368     {
 369         if (couldOverflowMul&lt;T&gt;(other))
 370             return top&lt;T&gt;();
 371         return IntRange(
 372             std::min(
 373                 std::min(m_min * other.m_min, m_min * other.m_max),
 374                 std::min(m_max * other.m_min, m_max * other.m_max)),
 375             std::max(
 376                 std::max(m_min * other.m_min, m_min * other.m_max),
 377                 std::max(m_max * other.m_min, m_max * other.m_max)));
 378     }
 379 
 380     IntRange mul(const IntRange&amp; other, Type type)
 381     {
 382         switch (type) {
 383         case Int32:
 384             return mul&lt;int32_t&gt;(other);
 385         case Int64:
 386             return mul&lt;int64_t&gt;(other);
 387         default:
 388             RELEASE_ASSERT_NOT_REACHED();
 389             return IntRange();
 390         }
 391     }
 392 
 393 private:
 394     int64_t m_min { 0 };
 395     int64_t m_max { 0 };
 396 };
 397 
 398 class ReduceStrength {
 399 public:
 400     ReduceStrength(Procedure&amp; proc)
 401         : m_proc(proc)
 402         , m_insertionSet(proc)
 403         , m_blockInsertionSet(proc)
 404     {
 405     }
 406 
 407     bool run()
 408     {
 409         bool result = false;
 410         bool first = true;
 411         unsigned index = 0;
 412         do {
 413             m_changed = false;
 414             m_changedCFG = false;
 415             ++index;
 416 
 417             if (first)
 418                 first = false;
 419             else if (B3ReduceStrengthInternal::verbose) {
 420                 dataLog(&quot;B3 after iteration #&quot;, index - 1, &quot; of reduceStrength:\n&quot;);
 421                 dataLog(m_proc);
 422             }
 423 
 424             simplifyCFG();
 425 
 426             if (m_changedCFG) {
 427                 m_proc.resetReachability();
 428                 m_proc.invalidateCFG();
 429                 m_changed = true;
 430             }
 431 
 432             // We definitely want to do DCE before we do CSE so that we don&#39;t hoist things. For
 433             // example:
 434             //
 435             // @dead = Mul(@a, @b)
 436             // ... lots of control flow and stuff
 437             // @thing = Mul(@a, @b)
 438             //
 439             // If we do CSE before DCE, we will remove @thing and keep @dead. Effectively, we will
 440             // &quot;hoist&quot; @thing. On the other hand, if we run DCE before CSE, we will kill @dead and
 441             // keep @thing. That&#39;s better, since we usually want things to stay wherever the client
 442             // put them. We&#39;re not actually smart enough to move things around at random.
 443             killDeadCode();
 444 
 445             simplifySSA();
 446 
 447             if (m_proc.optLevel() &gt;= 2) {
 448                 m_proc.resetValueOwners();
 449                 m_dominators = &amp;m_proc.dominators(); // Recompute if necessary.
 450                 m_pureCSE.clear();
 451             }
 452 
 453             for (BasicBlock* block : m_proc.blocksInPreOrder()) {
 454                 m_block = block;
 455 
 456                 for (m_index = 0; m_index &lt; block-&gt;size(); ++m_index) {
 457                     if (B3ReduceStrengthInternal::verbose) {
 458                         dataLog(
 459                             &quot;Looking at &quot;, *block, &quot; #&quot;, m_index, &quot;: &quot;,
 460                             deepDump(m_proc, block-&gt;at(m_index)), &quot;\n&quot;);
 461                     }
 462                     m_value = m_block-&gt;at(m_index);
 463                     m_value-&gt;performSubstitution();
 464                     reduceValueStrength();
 465                     if (m_proc.optLevel() &gt;= 2)
 466                         replaceIfRedundant();
 467                 }
 468                 m_insertionSet.execute(m_block);
 469             }
 470 
 471             m_changedCFG |= m_blockInsertionSet.execute();
 472             handleChangedCFGIfNecessary();
 473 
 474             result |= m_changed;
 475         } while (m_changed &amp;&amp; m_proc.optLevel() &gt;= 2);
 476 
 477         if (m_proc.optLevel() &lt; 2) {
 478             m_changedCFG = false;
 479             simplifyCFG();
 480             handleChangedCFGIfNecessary();
 481         }
 482 
 483         return result;
 484     }
 485 
 486 private:
 487     void reduceValueStrength()
 488     {
 489         switch (m_value-&gt;opcode()) {
 490         case Opaque:
 491             // Turn this: Opaque(Opaque(value))
 492             // Into this: Opaque(value)
 493             if (m_value-&gt;child(0)-&gt;opcode() == Opaque) {
 494                 replaceWithIdentity(m_value-&gt;child(0));
 495                 break;
 496             }
 497             break;
 498 
 499         case Add:
 500             handleCommutativity();
 501 
 502             if (m_value-&gt;child(0)-&gt;opcode() == Add &amp;&amp; m_value-&gt;isInteger()) {
 503                 // Turn this: Add(Add(value, constant1), constant2)
 504                 // Into this: Add(value, constant1 + constant2)
 505                 Value* newSum = m_value-&gt;child(1)-&gt;addConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));
 506                 if (newSum) {
 507                     m_insertionSet.insertValue(m_index, newSum);
 508                     m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
 509                     m_value-&gt;child(1) = newSum;
 510                     m_changed = true;
 511                     break;
 512                 }
 513 
 514                 // Turn this: Add(Add(value, constant), otherValue)
 515                 // Into this: Add(Add(value, otherValue), constant)
 516                 if (!m_value-&gt;child(1)-&gt;hasInt() &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()) {
 517                     Value* value = m_value-&gt;child(0)-&gt;child(0);
 518                     Value* constant = m_value-&gt;child(0)-&gt;child(1);
 519                     Value* otherValue = m_value-&gt;child(1);
 520                     // This could create duplicate code if Add(value, constant) is used elsewhere.
 521                     // However, we already model adding a constant as if it was free in other places
 522                     // so let&#39;s just roll with it. The alternative would mean having to do good use
 523                     // counts, which reduceStrength() currently doesn&#39;t have.
 524                     m_value-&gt;child(0) =
 525                         m_insertionSet.insert&lt;Value&gt;(
 526                             m_index, Add, m_value-&gt;origin(), value, otherValue);
 527                     m_value-&gt;child(1) = constant;
 528                     m_changed = true;
 529                     break;
 530                 }
 531             }
 532 
 533             // Turn this: Add(otherValue, Add(value, constant))
 534             // Into this: Add(Add(value, otherValue), constant)
 535             if (m_value-&gt;isInteger()
 536                 &amp;&amp; !m_value-&gt;child(0)-&gt;hasInt()
 537                 &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == Add
 538                 &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;hasInt()) {
 539                 Value* value = m_value-&gt;child(1)-&gt;child(0);
 540                 Value* constant = m_value-&gt;child(1)-&gt;child(1);
 541                 Value* otherValue = m_value-&gt;child(0);
 542                 // This creates a duplicate add. That&#39;s dangerous but probably fine, see above.
 543                 m_value-&gt;child(0) =
 544                     m_insertionSet.insert&lt;Value&gt;(
 545                         m_index, Add, m_value-&gt;origin(), value, otherValue);
 546                 m_value-&gt;child(1) = constant;
 547                 m_changed = true;
 548                 break;
 549             }
 550 
 551             // Turn this: Add(constant1, constant2)
 552             // Into this: constant1 + constant2
 553             if (Value* constantAdd = m_value-&gt;child(0)-&gt;addConstant(m_proc, m_value-&gt;child(1))) {
 554                 replaceWithNewValue(constantAdd);
 555                 break;
 556             }
 557 
 558             // Turn this: Integer Add(value, value)
 559             // Into this: Shl(value, 1)
 560             // This is a useful canonicalization. It&#39;s not meant to be a strength reduction.
 561             if (m_value-&gt;isInteger() &amp;&amp; m_value-&gt;child(0) == m_value-&gt;child(1)) {
 562                 replaceWithNewValue(
 563                     m_proc.add&lt;Value&gt;(
 564                         Shl, m_value-&gt;origin(), m_value-&gt;child(0),
 565                         m_insertionSet.insert&lt;Const32Value&gt;(m_index, m_value-&gt;origin(), 1)));
 566                 break;
 567             }
 568 
 569             // Turn this: Add(value, zero)
 570             // Into an Identity.
 571             //
 572             // Addition is subtle with doubles. Zero is not the neutral value, negative zero is:
 573             //    0 + 0 = 0
 574             //    0 + -0 = 0
 575             //    -0 + 0 = 0
 576             //    -0 + -0 = -0
 577             if (m_value-&gt;child(1)-&gt;isInt(0) || m_value-&gt;child(1)-&gt;isNegativeZero()) {
 578                 replaceWithIdentity(m_value-&gt;child(0));
 579                 break;
 580             }
 581 
 582             if (m_value-&gt;isInteger()) {
 583                 // Turn this: Integer Add(value, Neg(otherValue))
 584                 // Into this: Sub(value, otherValue)
 585                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {
 586                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
 587                     break;
 588                 }
 589 
 590                 // Turn this: Integer Add(Neg(value), otherValue)
 591                 // Into this: Sub(otherValue, value)
 592                 if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
 593                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));
 594                     break;
 595                 }
 596 
 597                 // Turn this: Integer Add(Sub(0, value), -1)
 598                 // Into this: BitXor(value, -1)
 599                 if (m_value-&gt;child(0)-&gt;opcode() == Sub
 600                     &amp;&amp; m_value-&gt;child(1)-&gt;isInt(-1)
 601                     &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;isInt(0)) {
 602                     replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1));
 603                     break;
 604                 }
 605             }
 606 
 607             break;
 608 
 609         case Sub:
 610             // Turn this: Sub(constant1, constant2)
 611             // Into this: constant1 - constant2
 612             if (Value* constantSub = m_value-&gt;child(0)-&gt;subConstant(m_proc, m_value-&gt;child(1))) {
 613                 replaceWithNewValue(constantSub);
 614                 break;
 615             }
 616 
 617             if (m_value-&gt;isInteger()) {
 618                 // Turn this: Sub(value, constant)
 619                 // Into this: Add(value, -constant)
 620                 if (Value* negatedConstant = m_value-&gt;child(1)-&gt;negConstant(m_proc)) {
 621                     m_insertionSet.insertValue(m_index, negatedConstant);
 622                     replaceWithNew&lt;Value&gt;(
 623                         Add, m_value-&gt;origin(), m_value-&gt;child(0), negatedConstant);
 624                     break;
 625                 }
 626 
 627                 // Turn this: Sub(0, value)
 628                 // Into this: Neg(value)
 629                 if (m_value-&gt;child(0)-&gt;isInt(0)) {
 630                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(1));
 631                     break;
 632                 }
 633 
 634                 // Turn this: Sub(value, value)
 635                 // Into this: 0
 636                 if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
 637                     replaceWithNewValue(m_proc.addIntConstant(m_value, 0));
 638                     break;
 639                 }
 640 
 641                 // Turn this: Sub(value, Neg(otherValue))
 642                 // Into this: Add(value, otherValue)
 643                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {
 644                     replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
 645                     break;
 646                 }
 647             }
 648 
 649             break;
 650 
 651         case Neg:
 652             // Turn this: Neg(constant)
 653             // Into this: -constant
 654             if (Value* constant = m_value-&gt;child(0)-&gt;negConstant(m_proc)) {
 655                 replaceWithNewValue(constant);
 656                 break;
 657             }
 658 
 659             // Turn this: Neg(Neg(value))
 660             // Into this: value
 661             if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
 662                 replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
 663                 break;
 664             }
 665 
 666             // Turn this: Integer Neg(Sub(value, otherValue))
 667             // Into this: Sub(otherValue, value)
 668             if (m_value-&gt;isInteger() &amp;&amp; m_value-&gt;child(0)-&gt;opcode() == Sub) {
 669                 replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));
 670                 break;
 671             }
 672 
 673             break;
 674 
 675         case Mul:
 676             handleCommutativity();
 677 
 678             // Turn this: Mul(constant1, constant2)
 679             // Into this: constant1 * constant2
 680             if (Value* value = m_value-&gt;child(0)-&gt;mulConstant(m_proc, m_value-&gt;child(1))) {
 681                 replaceWithNewValue(value);
 682                 break;
 683             }
 684 
 685             if (m_value-&gt;child(1)-&gt;hasInt()) {
 686                 int64_t factor = m_value-&gt;child(1)-&gt;asInt();
 687 
 688                 // Turn this: Mul(value, 0)
 689                 // Into this: 0
 690                 // Note that we don&#39;t do this for doubles because that&#39;s wrong. For example, -1 * 0
 691                 // and 1 * 0 yield different results.
 692                 if (!factor) {
 693                     replaceWithIdentity(m_value-&gt;child(1));
 694                     break;
 695                 }
 696 
 697                 // Turn this: Mul(value, 1)
 698                 // Into this: value
 699                 if (factor == 1) {
 700                     replaceWithIdentity(m_value-&gt;child(0));
 701                     break;
 702                 }
 703 
 704                 // Turn this: Mul(value, -1)
 705                 // Into this: Sub(0, value)
 706                 if (factor == -1) {
 707                     replaceWithNewValue(
 708                         m_proc.add&lt;Value&gt;(
 709                             Sub, m_value-&gt;origin(),
 710                             m_insertionSet.insertIntConstant(m_index, m_value, 0),
 711                             m_value-&gt;child(0)));
 712                     break;
 713                 }
 714 
 715                 // Turn this: Mul(value, constant)
 716                 // Into this: Shl(value, log2(constant))
 717                 if (hasOneBitSet(factor)) {
 718                     unsigned shiftAmount = WTF::fastLog2(static_cast&lt;uint64_t&gt;(factor));
 719                     replaceWithNewValue(
 720                         m_proc.add&lt;Value&gt;(
 721                             Shl, m_value-&gt;origin(), m_value-&gt;child(0),
 722                             m_insertionSet.insert&lt;Const32Value&gt;(
 723                                 m_index, m_value-&gt;origin(), shiftAmount)));
 724                     break;
 725                 }
 726             } else if (m_value-&gt;child(1)-&gt;hasDouble()) {
 727                 double factor = m_value-&gt;child(1)-&gt;asDouble();
 728 
 729                 // Turn this: Mul(value, 1)
 730                 // Into this: value
 731                 if (factor == 1) {
 732                     replaceWithIdentity(m_value-&gt;child(0));
 733                     break;
 734                 }
 735             }
 736 
 737             break;
 738 
 739         case Div:
 740             // Turn this: Div(constant1, constant2)
 741             // Into this: constant1 / constant2
 742             // Note that this uses Div&lt;Chill&gt; semantics. That&#39;s fine, because the rules for Div
 743             // are strictly weaker: it has corner cases where it&#39;s allowed to do anything it
 744             // likes.
 745             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;divConstant(m_proc, m_value-&gt;child(1))))
 746                 break;
 747 
 748             if (m_value-&gt;child(1)-&gt;hasInt()) {
 749                 switch (m_value-&gt;child(1)-&gt;asInt()) {
 750                 case -1:
 751                     // Turn this: Div(value, -1)
 752                     // Into this: Neg(value)
 753                     replaceWithNewValue(
 754                         m_proc.add&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(0)));
 755                     break;
 756 
 757                 case 0:
 758                     // Turn this: Div(value, 0)
 759                     // Into this: 0
 760                     // We can do this because it&#39;s precisely correct for ChillDiv and for Div we
 761                     // are allowed to do whatever we want.
 762                     replaceWithIdentity(m_value-&gt;child(1));
 763                     break;
 764 
 765                 case 1:
 766                     // Turn this: Div(value, 1)
 767                     // Into this: value
 768                     replaceWithIdentity(m_value-&gt;child(0));
 769                     break;
 770 
 771                 default:
 772                     // Perform super comprehensive strength reduction of division. Currently we
 773                     // only do this for 32-bit divisions, since we need a high multiply
 774                     // operation. We emulate it using 64-bit multiply. We can&#39;t emulate 64-bit
 775                     // high multiply with a 128-bit multiply because we don&#39;t have a 128-bit
 776                     // multiply. We could do it with a patchpoint if we cared badly enough.
 777 
 778                     if (m_value-&gt;type() != Int32)
 779                         break;
 780 
 781                     if (m_proc.optLevel() &lt; 2)
 782                         break;
 783 
 784                     int32_t divisor = m_value-&gt;child(1)-&gt;asInt32();
 785                     DivisionMagic&lt;int32_t&gt; magic = computeDivisionMagic(divisor);
 786 
 787                     // Perform the &quot;high&quot; multiplication. We do it just to get the high bits.
 788                     // This is sort of like multiplying by the reciprocal, just more gnarly. It&#39;s
 789                     // from Hacker&#39;s Delight and I don&#39;t claim to understand it.
 790                     Value* magicQuotient = m_insertionSet.insert&lt;Value&gt;(
 791                         m_index, Trunc, m_value-&gt;origin(),
 792                         m_insertionSet.insert&lt;Value&gt;(
 793                             m_index, ZShr, m_value-&gt;origin(),
 794                             m_insertionSet.insert&lt;Value&gt;(
 795                                 m_index, Mul, m_value-&gt;origin(),
 796                                 m_insertionSet.insert&lt;Value&gt;(
 797                                     m_index, SExt32, m_value-&gt;origin(), m_value-&gt;child(0)),
 798                                 m_insertionSet.insert&lt;Const64Value&gt;(
 799                                     m_index, m_value-&gt;origin(), magic.magicMultiplier)),
 800                             m_insertionSet.insert&lt;Const32Value&gt;(
 801                                 m_index, m_value-&gt;origin(), 32)));
 802 
 803                     if (divisor &gt; 0 &amp;&amp; magic.magicMultiplier &lt; 0) {
 804                         magicQuotient = m_insertionSet.insert&lt;Value&gt;(
 805                             m_index, Add, m_value-&gt;origin(), magicQuotient, m_value-&gt;child(0));
 806                     }
 807                     if (divisor &lt; 0 &amp;&amp; magic.magicMultiplier &gt; 0) {
 808                         magicQuotient = m_insertionSet.insert&lt;Value&gt;(
 809                             m_index, Sub, m_value-&gt;origin(), magicQuotient, m_value-&gt;child(0));
 810                     }
 811                     if (magic.shift &gt; 0) {
 812                         magicQuotient = m_insertionSet.insert&lt;Value&gt;(
 813                             m_index, SShr, m_value-&gt;origin(), magicQuotient,
 814                             m_insertionSet.insert&lt;Const32Value&gt;(
 815                                 m_index, m_value-&gt;origin(), magic.shift));
 816                     }
 817                     replaceWithIdentity(
 818                         m_insertionSet.insert&lt;Value&gt;(
 819                             m_index, Add, m_value-&gt;origin(), magicQuotient,
 820                             m_insertionSet.insert&lt;Value&gt;(
 821                                 m_index, ZShr, m_value-&gt;origin(), magicQuotient,
 822                                 m_insertionSet.insert&lt;Const32Value&gt;(
 823                                     m_index, m_value-&gt;origin(), 31))));
 824                     break;
 825                 }
 826                 break;
 827             }
 828             break;
 829 
 830         case UDiv:
 831             // Turn this: UDiv(constant1, constant2)
 832             // Into this: constant1 / constant2
 833             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;uDivConstant(m_proc, m_value-&gt;child(1))))
 834                 break;
 835 
 836             if (m_value-&gt;child(1)-&gt;hasInt()) {
 837                 switch (m_value-&gt;child(1)-&gt;asInt()) {
 838                 case 0:
 839                     // Turn this: UDiv(value, 0)
 840                     // Into this: 0
 841                     // We can do whatever we want here so we might as well do the chill thing,
 842                     // in case we add chill versions of UDiv in the future.
 843                     replaceWithIdentity(m_value-&gt;child(1));
 844                     break;
 845 
 846                 case 1:
 847                     // Turn this: UDiv(value, 1)
 848                     // Into this: value
 849                     replaceWithIdentity(m_value-&gt;child(0));
 850                     break;
 851                 default:
 852                     // FIXME: We should do comprehensive strength reduction for unsigned numbers. Likely,
 853                     // we will just want copy what llvm does. https://bugs.webkit.org/show_bug.cgi?id=164809
 854                     break;
 855                 }
 856             }
 857             break;
 858 
 859         case Mod:
 860             // Turn this: Mod(constant1, constant2)
 861             // Into this: constant1 / constant2
 862             // Note that this uses Mod&lt;Chill&gt; semantics.
 863             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;modConstant(m_proc, m_value-&gt;child(1))))
 864                 break;
 865 
 866             // Modulo by constant is more efficient if we turn it into Div, and then let Div get
 867             // optimized.
 868             if (m_value-&gt;child(1)-&gt;hasInt()) {
 869                 switch (m_value-&gt;child(1)-&gt;asInt()) {
 870                 case 0:
 871                     // Turn this: Mod(value, 0)
 872                     // Into this: 0
 873                     // This is correct according to ChillMod semantics.
 874                     replaceWithIdentity(m_value-&gt;child(1));
 875                     break;
 876 
 877                 default:
 878                     if (m_proc.optLevel() &lt; 2)
 879                         break;
 880 
 881                     // Turn this: Mod(N, D)
 882                     // Into this: Sub(N, Mul(Div(N, D), D))
 883                     //
 884                     // This is a speed-up because we use our existing Div optimizations.
 885                     //
 886                     // Here&#39;s an easier way to look at it:
 887                     //     N % D = N - N / D * D
 888                     //
 889                     // Note that this does not work for D = 0 and ChillMod. The expected result is 0.
 890                     // That&#39;s why we have a special-case above.
 891                     //     X % 0 = X - X / 0 * 0 = X     (should be 0)
 892                     //
 893                     // This does work for the D = -1 special case.
 894                     //     -2^31 % -1 = -2^31 - -2^31 / -1 * -1
 895                     //                = -2^31 - -2^31 * -1
 896                     //                = -2^31 - -2^31
 897                     //                = 0
 898 
 899                     Kind divKind = Div;
 900                     divKind.setIsChill(m_value-&gt;isChill());
 901 
 902                     replaceWithIdentity(
 903                         m_insertionSet.insert&lt;Value&gt;(
 904                             m_index, Sub, m_value-&gt;origin(),
 905                             m_value-&gt;child(0),
 906                             m_insertionSet.insert&lt;Value&gt;(
 907                                 m_index, Mul, m_value-&gt;origin(),
 908                                 m_insertionSet.insert&lt;Value&gt;(
 909                                     m_index, divKind, m_value-&gt;origin(),
 910                                     m_value-&gt;child(0), m_value-&gt;child(1)),
 911                                 m_value-&gt;child(1))));
 912                     break;
 913                 }
 914                 break;
 915             }
 916 
 917             break;
 918 
 919         case UMod:
 920             // Turn this: UMod(constant1, constant2)
 921             // Into this: constant1 / constant2
 922             replaceWithNewValue(m_value-&gt;child(0)-&gt;uModConstant(m_proc, m_value-&gt;child(1)));
 923             // FIXME: We should do what we do for Mod since the same principle applies here.
 924             // https://bugs.webkit.org/show_bug.cgi?id=164809
 925             break;
 926 
 927         case BitAnd:
 928             handleCommutativity();
 929 
 930             // Turn this: BitAnd(constant1, constant2)
 931             // Into this: constant1 &amp; constant2
 932             if (Value* constantBitAnd = m_value-&gt;child(0)-&gt;bitAndConstant(m_proc, m_value-&gt;child(1))) {
 933                 replaceWithNewValue(constantBitAnd);
 934                 break;
 935             }
 936 
 937             // Turn this: BitAnd(BitAnd(value, constant1), constant2)
 938             // Into this: BitAnd(value, constant1 &amp; constant2).
 939             if (m_value-&gt;child(0)-&gt;opcode() == BitAnd) {
 940                 Value* newConstant = m_value-&gt;child(1)-&gt;bitAndConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));
 941                 if (newConstant) {
 942                     m_insertionSet.insertValue(m_index, newConstant);
 943                     m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
 944                     m_value-&gt;child(1) = newConstant;
 945                     m_changed = true;
 946                 }
 947             }
 948 
 949             // Turn this: BitAnd(valueX, valueX)
 950             // Into this: valueX.
 951             if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
 952                 replaceWithIdentity(m_value-&gt;child(0));
 953                 break;
 954             }
 955 
 956             // Turn this: BitAnd(value, zero-constant)
 957             // Into this: zero-constant.
 958             if (m_value-&gt;child(1)-&gt;isInt(0)) {
 959                 replaceWithIdentity(m_value-&gt;child(1));
 960                 break;
 961             }
 962 
 963             // Turn this: BitAnd(value, all-ones)
 964             // Into this: value.
 965             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))
 966                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max()))) {
 967                 replaceWithIdentity(m_value-&gt;child(0));
 968                 break;
 969             }
 970 
 971             // Turn this: BitAnd(64-bit value, 32 ones)
 972             // Into this: ZExt32(Trunc(64-bit value))
 973             if (m_value-&gt;child(1)-&gt;isInt64(0xffffffffllu)) {
 974                 Value* newValue = m_insertionSet.insert&lt;Value&gt;(
 975                     m_index, ZExt32, m_value-&gt;origin(),
 976                     m_insertionSet.insert&lt;Value&gt;(m_index, Trunc, m_value-&gt;origin(), m_value-&gt;child(0)));
 977                 replaceWithIdentity(newValue);
 978                 break;
 979             }
 980 
 981             // Turn this: BitAnd(SExt8(value), mask) where (mask &amp; 0xffffff00) == 0
 982             // Into this: BitAnd(value, mask)
 983             if (m_value-&gt;child(0)-&gt;opcode() == SExt8 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt32()
 984                 &amp;&amp; !(m_value-&gt;child(1)-&gt;asInt32() &amp; 0xffffff00)) {
 985                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
 986                 m_changed = true;
 987                 break;
 988             }
 989 
 990             // Turn this: BitAnd(SExt16(value), mask) where (mask &amp; 0xffff0000) == 0
 991             // Into this: BitAnd(value, mask)
 992             if (m_value-&gt;child(0)-&gt;opcode() == SExt16 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt32()
 993                 &amp;&amp; !(m_value-&gt;child(1)-&gt;asInt32() &amp; 0xffff0000)) {
 994                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
 995                 m_changed = true;
 996                 break;
 997             }
 998 
 999             // Turn this: BitAnd(SExt32(value), mask) where (mask &amp; 0xffffffff00000000) == 0
1000             // Into this: BitAnd(ZExt32(value), mask)
1001             if (m_value-&gt;child(0)-&gt;opcode() == SExt32 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt32()
1002                 &amp;&amp; !(m_value-&gt;child(1)-&gt;asInt32() &amp; 0xffffffff00000000llu)) {
1003                 m_value-&gt;child(0) = m_insertionSet.insert&lt;Value&gt;(
1004                     m_index, ZExt32, m_value-&gt;origin(),
1005                     m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(0)-&gt;child(1));
1006                 m_changed = true;
1007                 break;
1008             }
1009 
1010             // Turn this: BitAnd(Op(value, constant1), constant2)
1011             //     where !(constant1 &amp; constant2)
1012             //       and Op is BitOr or BitXor
1013             // into this: BitAnd(value, constant2)
1014             if (m_value-&gt;child(1)-&gt;hasInt()) {
1015                 int64_t constant2 = m_value-&gt;child(1)-&gt;asInt();
1016                 switch (m_value-&gt;child(0)-&gt;opcode()) {
1017                 case BitOr:
1018                 case BitXor:
1019                     if (m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()
1020                         &amp;&amp; !(m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() &amp; constant2)) {
1021                         m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1022                         m_changed = true;
1023                         break;
1024                     }
1025                     break;
1026                 default:
1027                     break;
1028                 }
1029                 break;
1030             }
1031 
1032             // Turn this: BitAnd(BitXor(x1, allOnes), BitXor(x2, allOnes)
1033             // Into this: BitXor(BitOr(x1, x2), allOnes)
1034             // By applying De Morgan laws
1035             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1036                 &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
1037                 &amp;&amp; ((m_value-&gt;type() == Int64
1038                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max())
1039                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))
1040                     || (m_value-&gt;type() == Int32
1041                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())
1042                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {
1043                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
1044                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(1)-&gt;child(1));
1045                 break;
1046             }
1047 
1048             // Turn this: BitAnd(BitXor(x, allOnes), c)
1049             // Into this: BitXor(BitOr(x, ~c), allOnes)
1050             // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
1051             // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
1052             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1053                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
1054                 &amp;&amp; ((m_value-&gt;type() == Int64
1055                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))
1056                     || (m_value-&gt;type() == Int32
1057                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {
1058                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1)));
1059                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(0)-&gt;child(1));
1060                 break;
1061             }
1062 
1063             break;
1064 
1065         case BitOr:
1066             handleCommutativity();
1067 
1068             // Turn this: BitOr(constant1, constant2)
1069             // Into this: constant1 | constant2
1070             if (Value* constantBitOr = m_value-&gt;child(0)-&gt;bitOrConstant(m_proc, m_value-&gt;child(1))) {
1071                 replaceWithNewValue(constantBitOr);
1072                 break;
1073             }
1074 
1075             // Turn this: BitOr(BitOr(value, constant1), constant2)
1076             // Into this: BitOr(value, constant1 &amp; constant2).
1077             if (m_value-&gt;child(0)-&gt;opcode() == BitOr) {
1078                 Value* newConstant = m_value-&gt;child(1)-&gt;bitOrConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));
1079                 if (newConstant) {
1080                     m_insertionSet.insertValue(m_index, newConstant);
1081                     m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1082                     m_value-&gt;child(1) = newConstant;
1083                     m_changed = true;
1084                 }
1085             }
1086 
1087             // Turn this: BitOr(valueX, valueX)
1088             // Into this: valueX.
1089             if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
1090                 replaceWithIdentity(m_value-&gt;child(0));
1091                 break;
1092             }
1093 
1094             // Turn this: BitOr(value, zero-constant)
1095             // Into this: value.
1096             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1097                 replaceWithIdentity(m_value-&gt;child(0));
1098                 break;
1099             }
1100 
1101             // Turn this: BitOr(value, all-ones)
1102             // Into this: all-ones.
1103             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))
1104                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max()))) {
1105                 replaceWithIdentity(m_value-&gt;child(1));
1106                 break;
1107             }
1108 
1109             // Turn this: BitOr(BitXor(x1, allOnes), BitXor(x2, allOnes)
1110             // Into this: BitXor(BitAnd(x1, x2), allOnes)
1111             // By applying De Morgan laws
1112             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1113                 &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
1114                 &amp;&amp; ((m_value-&gt;type() == Int64
1115                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max())
1116                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))
1117                     || (m_value-&gt;type() == Int32
1118                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())
1119                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {
1120                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
1121                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(1)-&gt;child(1));
1122                 break;
1123             }
1124 
1125             // Turn this: BitOr(BitXor(x, allOnes), c)
1126             // Into this: BitXor(BitAnd(x, ~c), allOnes)
1127             // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
1128             // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
1129             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1130                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
1131                 &amp;&amp; ((m_value-&gt;type() == Int64
1132                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))
1133                     || (m_value-&gt;type() == Int32
1134                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {
1135                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1)));
1136                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(0)-&gt;child(1));
1137                 break;
1138             }
1139 
1140             if (handleBitAndDistributivity())
1141                 break;
1142 
1143             break;
1144 
1145         case BitXor:
1146             handleCommutativity();
1147 
1148             // Turn this: BitXor(constant1, constant2)
1149             // Into this: constant1 ^ constant2
1150             if (Value* constantBitXor = m_value-&gt;child(0)-&gt;bitXorConstant(m_proc, m_value-&gt;child(1))) {
1151                 replaceWithNewValue(constantBitXor);
1152                 break;
1153             }
1154 
1155             // Turn this: BitXor(BitXor(value, constant1), constant2)
1156             // Into this: BitXor(value, constant1 ^ constant2).
1157             if (m_value-&gt;child(0)-&gt;opcode() == BitXor) {
1158                 Value* newConstant = m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));
1159                 if (newConstant) {
1160                     m_insertionSet.insertValue(m_index, newConstant);
1161                     m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1162                     m_value-&gt;child(1) = newConstant;
1163                     m_changed = true;
1164                 }
1165             }
1166 
1167             // Turn this: BitXor(compare, 1)
1168             // Into this: invertedCompare
1169             if (m_value-&gt;child(1)-&gt;isInt32(1)) {
1170                 if (Value* invertedCompare = m_value-&gt;child(0)-&gt;invertedCompare(m_proc)) {
1171                     replaceWithNewValue(invertedCompare);
1172                     break;
1173                 }
1174             }
1175 
1176             // Turn this: BitXor(valueX, valueX)
1177             // Into this: zero-constant.
1178             if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
1179                 replaceWithNewValue(m_proc.addIntConstant(m_value, 0));
1180                 break;
1181             }
1182 
1183             // Turn this: BitXor(value, zero-constant)
1184             // Into this: value.
1185             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1186                 replaceWithIdentity(m_value-&gt;child(0));
1187                 break;
1188             }
1189 
1190             if (handleBitAndDistributivity())
1191                 break;
1192 
1193             break;
1194 
1195         case Shl:
1196             // Turn this: Shl(constant1, constant2)
1197             // Into this: constant1 &lt;&lt; constant2
1198             if (Value* constant = m_value-&gt;child(0)-&gt;shlConstant(m_proc, m_value-&gt;child(1))) {
1199                 replaceWithNewValue(constant);
1200                 break;
1201             }
1202 
1203             handleShiftAmount();
1204             break;
1205 
1206         case SShr:
1207             // Turn this: SShr(constant1, constant2)
1208             // Into this: constant1 &gt;&gt; constant2
1209             if (Value* constant = m_value-&gt;child(0)-&gt;sShrConstant(m_proc, m_value-&gt;child(1))) {
1210                 replaceWithNewValue(constant);
1211                 break;
1212             }
1213 
1214             if (m_value-&gt;child(1)-&gt;hasInt32()
1215                 &amp;&amp; m_value-&gt;child(0)-&gt;opcode() == Shl
1216                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt32()
1217                 &amp;&amp; m_value-&gt;child(1)-&gt;asInt32() == m_value-&gt;child(0)-&gt;child(1)-&gt;asInt32()) {
1218                 switch (m_value-&gt;child(1)-&gt;asInt32()) {
1219                 case 16:
1220                     if (m_value-&gt;type() == Int32) {
1221                         // Turn this: SShr(Shl(value, 16), 16)
1222                         // Into this: SExt16(value)
1223                         replaceWithNewValue(
1224                             m_proc.add&lt;Value&gt;(
1225                                 SExt16, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0)));
1226                     }
1227                     break;
1228 
1229                 case 24:
1230                     if (m_value-&gt;type() == Int32) {
1231                         // Turn this: SShr(Shl(value, 24), 24)
1232                         // Into this: SExt8(value)
1233                         replaceWithNewValue(
1234                             m_proc.add&lt;Value&gt;(
1235                                 SExt8, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0)));
1236                     }
1237                     break;
1238 
1239                 case 32:
1240                     if (m_value-&gt;type() == Int64) {
1241                         // Turn this: SShr(Shl(value, 32), 32)
1242                         // Into this: SExt32(Trunc(value))
1243                         replaceWithNewValue(
1244                             m_proc.add&lt;Value&gt;(
1245                                 SExt32, m_value-&gt;origin(),
1246                                 m_insertionSet.insert&lt;Value&gt;(
1247                                     m_index, Trunc, m_value-&gt;origin(),
1248                                     m_value-&gt;child(0)-&gt;child(0))));
1249                     }
1250                     break;
1251 
1252                 // FIXME: Add cases for 48 and 56, but that would translate to SExt32(SExt8) or
1253                 // SExt32(SExt16), which we don&#39;t currently lower efficiently.
1254 
1255                 default:
1256                     break;
1257                 }
1258 
1259                 if (m_value-&gt;opcode() != SShr)
1260                     break;
1261             }
1262 
1263             handleShiftAmount();
1264             break;
1265 
1266         case ZShr:
1267             // Turn this: ZShr(constant1, constant2)
1268             // Into this: (unsigned)constant1 &gt;&gt; constant2
1269             if (Value* constant = m_value-&gt;child(0)-&gt;zShrConstant(m_proc, m_value-&gt;child(1))) {
1270                 replaceWithNewValue(constant);
1271                 break;
1272             }
1273 
1274             handleShiftAmount();
1275             break;
1276 
1277         case RotR:
1278             // Turn this: RotR(constant1, constant2)
1279             // Into this: (constant1 &gt;&gt; constant2) | (constant1 &lt;&lt; sizeof(constant1) * 8 - constant2)
1280             if (Value* constant = m_value-&gt;child(0)-&gt;rotRConstant(m_proc, m_value-&gt;child(1))) {
1281                 replaceWithNewValue(constant);
1282                 break;
1283             }
1284 
1285             handleShiftAmount();
1286             break;
1287 
1288         case RotL:
1289             // Turn this: RotL(constant1, constant2)
1290             // Into this: (constant1 &lt;&lt; constant2) | (constant1 &gt;&gt; sizeof(constant1) * 8 - constant2)
1291             if (Value* constant = m_value-&gt;child(0)-&gt;rotLConstant(m_proc, m_value-&gt;child(1))) {
1292                 replaceWithNewValue(constant);
1293                 break;
1294             }
1295 
1296             handleShiftAmount();
1297             break;
1298 
1299         case Abs:
1300             // Turn this: Abs(constant)
1301             // Into this: fabs&lt;value-&gt;type()&gt;(constant)
1302             if (Value* constant = m_value-&gt;child(0)-&gt;absConstant(m_proc)) {
1303                 replaceWithNewValue(constant);
1304                 break;
1305             }
1306 
1307             // Turn this: Abs(Abs(value))
1308             // Into this: Abs(value)
1309             if (m_value-&gt;child(0)-&gt;opcode() == Abs) {
1310                 replaceWithIdentity(m_value-&gt;child(0));
1311                 break;
1312             }
1313 
1314             // Turn this: Abs(Neg(value))
1315             // Into this: Abs(value)
1316             if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
1317                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1318                 m_changed = true;
1319                 break;
1320             }
1321 
1322             // Turn this: Abs(BitwiseCast(value))
1323             // Into this: BitwiseCast(And(value, mask-top-bit))
1324             if (m_value-&gt;child(0)-&gt;opcode() == BitwiseCast) {
1325                 Value* mask;
1326                 if (m_value-&gt;type() == Double)
1327                     mask = m_insertionSet.insert&lt;Const64Value&gt;(m_index, m_value-&gt;origin(), ~(1ll &lt;&lt; 63));
1328                 else
1329                     mask = m_insertionSet.insert&lt;Const32Value&gt;(m_index, m_value-&gt;origin(), ~(1l &lt;&lt; 31));
1330 
1331                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(),
1332                     m_value-&gt;child(0)-&gt;child(0),
1333                     mask);
1334                 Value* cast = m_insertionSet.insert&lt;Value&gt;(m_index, BitwiseCast, m_value-&gt;origin(), bitAnd);
1335                 replaceWithIdentity(cast);
1336                 break;
1337             }
1338             break;
1339 
1340         case Ceil:
1341             // Turn this: Ceil(constant)
1342             // Into this: ceil&lt;value-&gt;type()&gt;(constant)
1343             if (Value* constant = m_value-&gt;child(0)-&gt;ceilConstant(m_proc)) {
1344                 replaceWithNewValue(constant);
1345                 break;
1346             }
1347 
1348             // Turn this: Ceil(roundedValue)
1349             // Into this: roundedValue
1350             if (m_value-&gt;child(0)-&gt;isRounded()) {
1351                 replaceWithIdentity(m_value-&gt;child(0));
1352                 break;
1353             }
1354             break;
1355 
1356         case Floor:
1357             // Turn this: Floor(constant)
1358             // Into this: floor&lt;value-&gt;type()&gt;(constant)
1359             if (Value* constant = m_value-&gt;child(0)-&gt;floorConstant(m_proc)) {
1360                 replaceWithNewValue(constant);
1361                 break;
1362             }
1363 
1364             // Turn this: Floor(roundedValue)
1365             // Into this: roundedValue
1366             if (m_value-&gt;child(0)-&gt;isRounded()) {
1367                 replaceWithIdentity(m_value-&gt;child(0));
1368                 break;
1369             }
1370             break;
1371 
1372         case Sqrt:
1373             // Turn this: Sqrt(constant)
1374             // Into this: sqrt&lt;value-&gt;type()&gt;(constant)
1375             if (Value* constant = m_value-&gt;child(0)-&gt;sqrtConstant(m_proc)) {
1376                 replaceWithNewValue(constant);
1377                 break;
1378             }
1379             break;
1380 
1381         case BitwiseCast:
1382             // Turn this: BitwiseCast(constant)
1383             // Into this: bitwise_cast&lt;value-&gt;type()&gt;(constant)
1384             if (Value* constant = m_value-&gt;child(0)-&gt;bitwiseCastConstant(m_proc)) {
1385                 replaceWithNewValue(constant);
1386                 break;
1387             }
1388 
1389             // Turn this: BitwiseCast(BitwiseCast(value))
1390             // Into this: value
1391             if (m_value-&gt;child(0)-&gt;opcode() == BitwiseCast) {
1392                 replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
1393                 break;
1394             }
1395             break;
1396 
1397         case SExt8:
1398             // Turn this: SExt8(constant)
1399             // Into this: static_cast&lt;int8_t&gt;(constant)
1400             if (m_value-&gt;child(0)-&gt;hasInt32()) {
1401                 int32_t result = static_cast&lt;int8_t&gt;(m_value-&gt;child(0)-&gt;asInt32());
1402                 replaceWithNewValue(m_proc.addIntConstant(m_value, result));
1403                 break;
1404             }
1405 
1406             // Turn this: SExt8(SExt8(value))
1407             //   or this: SExt8(SExt16(value))
1408             // Into this: SExt8(value)
1409             if (m_value-&gt;child(0)-&gt;opcode() == SExt8 || m_value-&gt;child(0)-&gt;opcode() == SExt16) {
1410                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1411                 m_changed = true;
1412             }
1413 
1414             if (m_value-&gt;child(0)-&gt;opcode() == BitAnd &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt32()) {
1415                 Value* input = m_value-&gt;child(0)-&gt;child(0);
1416                 int32_t mask = m_value-&gt;child(0)-&gt;child(1)-&gt;asInt32();
1417 
1418                 // Turn this: SExt8(BitAnd(input, mask)) where (mask &amp; 0xff) == 0xff
1419                 // Into this: SExt8(input)
1420                 if ((mask &amp; 0xff) == 0xff) {
1421                     m_value-&gt;child(0) = input;
1422                     m_changed = true;
1423                     break;
1424                 }
1425 
1426                 // Turn this: SExt8(BitAnd(input, mask)) where (mask &amp; 0x80) == 0
1427                 // Into this: BitAnd(input, const &amp; 0x7f)
1428                 if (!(mask &amp; 0x80)) {
1429                     replaceWithNewValue(
1430                         m_proc.add&lt;Value&gt;(
1431                             BitAnd, m_value-&gt;origin(), input,
1432                             m_insertionSet.insert&lt;Const32Value&gt;(
1433                                 m_index, m_value-&gt;origin(), mask &amp; 0x7f)));
1434                     break;
1435                 }
1436             }
1437 
1438             if (!m_proc.hasQuirks()) {
1439                 // Turn this: SExt8(AtomicXchg___)
1440                 // Into this: AtomicXchg___
1441                 if (isAtomicXchg(m_value-&gt;child(0)-&gt;opcode())
1442                     &amp;&amp; m_value-&gt;child(0)-&gt;as&lt;AtomicValue&gt;()-&gt;accessWidth() == Width8) {
1443                     replaceWithIdentity(m_value-&gt;child(0));
1444                     break;
1445                 }
1446             }
1447             break;
1448 
1449         case SExt16:
1450             // Turn this: SExt16(constant)
1451             // Into this: static_cast&lt;int16_t&gt;(constant)
1452             if (m_value-&gt;child(0)-&gt;hasInt32()) {
1453                 int32_t result = static_cast&lt;int16_t&gt;(m_value-&gt;child(0)-&gt;asInt32());
1454                 replaceWithNewValue(m_proc.addIntConstant(m_value, result));
1455                 break;
1456             }
1457 
1458             // Turn this: SExt16(SExt16(value))
1459             // Into this: SExt16(value)
1460             if (m_value-&gt;child(0)-&gt;opcode() == SExt16) {
1461                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1462                 m_changed = true;
1463             }
1464 
1465             // Turn this: SExt16(SExt8(value))
1466             // Into this: SExt8(value)
1467             if (m_value-&gt;child(0)-&gt;opcode() == SExt8) {
1468                 replaceWithIdentity(m_value-&gt;child(0));
1469                 break;
1470             }
1471 
1472             if (m_value-&gt;child(0)-&gt;opcode() == BitAnd &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt32()) {
1473                 Value* input = m_value-&gt;child(0)-&gt;child(0);
1474                 int32_t mask = m_value-&gt;child(0)-&gt;child(1)-&gt;asInt32();
1475 
1476                 // Turn this: SExt16(BitAnd(input, mask)) where (mask &amp; 0xffff) == 0xffff
1477                 // Into this: SExt16(input)
1478                 if ((mask &amp; 0xffff) == 0xffff) {
1479                     m_value-&gt;child(0) = input;
1480                     m_changed = true;
1481                     break;
1482                 }
1483 
1484                 // Turn this: SExt16(BitAnd(input, mask)) where (mask &amp; 0x8000) == 0
1485                 // Into this: BitAnd(input, const &amp; 0x7fff)
1486                 if (!(mask &amp; 0x8000)) {
1487                     replaceWithNewValue(
1488                         m_proc.add&lt;Value&gt;(
1489                             BitAnd, m_value-&gt;origin(), input,
1490                             m_insertionSet.insert&lt;Const32Value&gt;(
1491                                 m_index, m_value-&gt;origin(), mask &amp; 0x7fff)));
1492                     break;
1493                 }
1494             }
1495 
1496             if (!m_proc.hasQuirks()) {
1497                 // Turn this: SExt16(AtomicXchg___)
1498                 // Into this: AtomicXchg___
1499                 if (isAtomicXchg(m_value-&gt;child(0)-&gt;opcode())
1500                     &amp;&amp; m_value-&gt;child(0)-&gt;as&lt;AtomicValue&gt;()-&gt;accessWidth() == Width16) {
1501                     replaceWithIdentity(m_value-&gt;child(0));
1502                     break;
1503                 }
1504             }
1505             break;
1506 
1507         case SExt32:
1508             // Turn this: SExt32(constant)
1509             // Into this: static_cast&lt;int64_t&gt;(constant)
1510             if (m_value-&gt;child(0)-&gt;hasInt32()) {
1511                 replaceWithNewValue(m_proc.addIntConstant(m_value, m_value-&gt;child(0)-&gt;asInt32()));
1512                 break;
1513             }
1514 
1515             // Turn this: SExt32(BitAnd(input, mask)) where (mask &amp; 0x80000000) == 0
1516             // Into this: ZExt32(BitAnd(input, mask))
1517             if (m_value-&gt;child(0)-&gt;opcode() == BitAnd &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt32()
1518                 &amp;&amp; !(m_value-&gt;child(0)-&gt;child(1)-&gt;asInt32() &amp; 0x80000000)) {
1519                 replaceWithNewValue(
1520                     m_proc.add&lt;Value&gt;(
1521                         ZExt32, m_value-&gt;origin(), m_value-&gt;child(0)));
1522                 break;
1523             }
1524             break;
1525 
1526         case ZExt32:
1527             // Turn this: ZExt32(constant)
1528             // Into this: static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(constant))
1529             if (m_value-&gt;child(0)-&gt;hasInt32()) {
1530                 replaceWithNewValue(
1531                     m_proc.addIntConstant(
1532                         m_value,
1533                         static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(m_value-&gt;child(0)-&gt;asInt32()))));
1534                 break;
1535             }
1536             break;
1537 
1538         case Trunc:
1539             // Turn this: Trunc(constant)
1540             // Into this: static_cast&lt;int32_t&gt;(constant)
1541             if (m_value-&gt;child(0)-&gt;hasInt64() || m_value-&gt;child(0)-&gt;hasDouble()) {
1542                 replaceWithNewValue(
1543                     m_proc.addIntConstant(m_value, static_cast&lt;int32_t&gt;(m_value-&gt;child(0)-&gt;asInt64())));
1544                 break;
1545             }
1546 
1547             // Turn this: Trunc(SExt32(value)) or Trunc(ZExt32(value))
1548             // Into this: value
1549             if (m_value-&gt;child(0)-&gt;opcode() == SExt32 || m_value-&gt;child(0)-&gt;opcode() == ZExt32) {
1550                 replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
1551                 break;
1552             }
1553 
1554             // Turn this: Trunc(Op(value, constant))
1555             //     where !(constant &amp; 0xffffffff)
1556             //       and Op is Add, Sub, BitOr, or BitXor
1557             // into this: Trunc(value)
1558             switch (m_value-&gt;child(0)-&gt;opcode()) {
1559             case Add:
1560             case Sub:
1561             case BitOr:
1562             case BitXor:
1563                 if (m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt64()
1564                     &amp;&amp; !(m_value-&gt;child(0)-&gt;child(1)-&gt;asInt64() &amp; 0xffffffffll)) {
1565                     m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1566                     m_changed = true;
1567                     break;
1568                 }
1569                 break;
1570             default:
1571                 break;
1572             }
1573             break;
1574 
1575         case IToD:
1576             // Turn this: IToD(constant)
1577             // Into this: ConstDouble(constant)
1578             if (Value* constant = m_value-&gt;child(0)-&gt;iToDConstant(m_proc)) {
1579                 replaceWithNewValue(constant);
1580                 break;
1581             }
1582             break;
1583 
1584         case IToF:
1585             // Turn this: IToF(constant)
1586             // Into this: ConstFloat(constant)
1587             if (Value* constant = m_value-&gt;child(0)-&gt;iToFConstant(m_proc)) {
1588                 replaceWithNewValue(constant);
1589                 break;
1590             }
1591             break;
1592 
1593         case FloatToDouble:
1594             // Turn this: FloatToDouble(constant)
1595             // Into this: ConstDouble(constant)
1596             if (Value* constant = m_value-&gt;child(0)-&gt;floatToDoubleConstant(m_proc)) {
1597                 replaceWithNewValue(constant);
1598                 break;
1599             }
1600             break;
1601 
1602         case DoubleToFloat:
1603             // Turn this: DoubleToFloat(FloatToDouble(value))
1604             // Into this: value
1605             if (m_value-&gt;child(0)-&gt;opcode() == FloatToDouble) {
1606                 replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
1607                 break;
1608             }
1609 
1610             // Turn this: DoubleToFloat(constant)
1611             // Into this: ConstFloat(constant)
1612             if (Value* constant = m_value-&gt;child(0)-&gt;doubleToFloatConstant(m_proc)) {
1613                 replaceWithNewValue(constant);
1614                 break;
1615             }
1616             break;
1617 
1618         case Select:
1619             // Turn this: Select(constant, a, b)
1620             // Into this: constant ? a : b
1621             if (m_value-&gt;child(0)-&gt;hasInt32()) {
1622                 replaceWithIdentity(
1623                     m_value-&gt;child(0)-&gt;asInt32() ? m_value-&gt;child(1) : m_value-&gt;child(2));
1624                 break;
1625             }
1626 
1627             // Turn this: Select(Equal(x, 0), a, b)
1628             // Into this: Select(x, b, a)
1629             if (m_value-&gt;child(0)-&gt;opcode() == Equal &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(0)) {
1630                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1631                 std::swap(m_value-&gt;child(1), m_value-&gt;child(2));
1632                 m_changed = true;
1633                 break;
1634             }
1635 
1636             // Turn this: Select(BitXor(bool, 1), a, b)
1637             // Into this: Select(bool, b, a)
1638             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1639                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(1)
1640                 &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;returnsBool()) {
1641                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1642                 std::swap(m_value-&gt;child(1), m_value-&gt;child(2));
1643                 m_changed = true;
1644                 break;
1645             }
1646 
1647             // Turn this: Select(BitAnd(bool, xyz1), a, b)
1648             // Into this: Select(bool, a, b)
1649             if (m_value-&gt;child(0)-&gt;opcode() == BitAnd
1650                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()
1651                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() &amp; 1
1652                 &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;returnsBool()) {
1653                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1654                 m_changed = true;
1655                 break;
1656             }
1657 
1658             // Turn this: Select(stuff, x, x)
1659             // Into this: x
1660             if (m_value-&gt;child(1) == m_value-&gt;child(2)) {
1661                 replaceWithIdentity(m_value-&gt;child(1));
1662                 break;
1663             }
1664             break;
1665 
1666         case Load8Z:
1667         case Load8S:
1668         case Load16Z:
1669         case Load16S:
1670         case Load:
1671         case Store8:
1672         case Store16:
1673         case Store: {
1674             Value* address = m_value-&gt;lastChild();
1675             MemoryValue* memory = m_value-&gt;as&lt;MemoryValue&gt;();
1676 
1677             // Turn this: Load(Add(address, offset1), offset = offset2)
1678             // Into this: Load(address, offset = offset1 + offset2)
1679             //
1680             // Also turns this: Store(value, Add(address, offset1), offset = offset2)
1681             // Into this: Store(value, address, offset = offset1 + offset2)
1682             if (address-&gt;opcode() == Add &amp;&amp; address-&gt;child(1)-&gt;hasIntPtr()) {
1683                 intptr_t offset = address-&gt;child(1)-&gt;asIntPtr();
1684                 if (!sumOverflows&lt;intptr_t&gt;(offset, memory-&gt;offset())) {
1685                     offset += memory-&gt;offset();
1686                     Value::OffsetType smallOffset = static_cast&lt;Value::OffsetType&gt;(offset);
1687                     if (smallOffset == offset) {
1688                         address = address-&gt;child(0);
1689                         memory-&gt;lastChild() = address;
1690                         memory-&gt;setOffset(smallOffset);
1691                         m_changed = true;
1692                     }
1693                 }
1694             }
1695 
1696             // Turn this: Load(constant1, offset = constant2)
1697             // Into this: Load(constant1 + constant2)
1698             //
1699             // This is a fun canonicalization. It purely regresses naively generated code. We rely
1700             // on constant materialization to be smart enough to materialize this constant the smart
1701             // way. We want this canonicalization because we want to know if two memory accesses see
1702             // the same address.
1703             if (memory-&gt;offset()) {
1704                 if (Value* newAddress = address-&gt;addConstant(m_proc, memory-&gt;offset())) {
1705                     m_insertionSet.insertValue(m_index, newAddress);
1706                     address = newAddress;
1707                     memory-&gt;lastChild() = newAddress;
1708                     memory-&gt;setOffset(0);
1709                     m_changed = true;
1710                 }
1711             }
1712 
1713             break;
1714         }
1715 
1716         case CCall: {
1717             // Turn this: Call(fmod, constant1, constant2)
1718             // Into this: fcall-constant(constant1, constant2)
1719             auto* fmodDouble = tagCFunctionPtr&lt;double (*)(double, double)&gt;(fmod, B3CCallPtrTag);
1720             if (m_value-&gt;type() == Double
1721                 &amp;&amp; m_value-&gt;numChildren() == 3
1722                 &amp;&amp; m_value-&gt;child(0)-&gt;isIntPtr(reinterpret_cast&lt;intptr_t&gt;(fmodDouble))
1723                 &amp;&amp; m_value-&gt;child(1)-&gt;type() == Double
1724                 &amp;&amp; m_value-&gt;child(2)-&gt;type() == Double) {
1725                 replaceWithNewValue(m_value-&gt;child(1)-&gt;modConstant(m_proc, m_value-&gt;child(2)));
1726             }
1727             break;
1728         }
1729         case Equal:
1730             handleCommutativity();
1731 
1732             // Turn this: Equal(bool, 0)
1733             // Into this: BitXor(bool, 1)
1734             if (m_value-&gt;child(0)-&gt;returnsBool() &amp;&amp; m_value-&gt;child(1)-&gt;isInt32(0)) {
1735                 replaceWithNew&lt;Value&gt;(
1736                     BitXor, m_value-&gt;origin(), m_value-&gt;child(0),
1737                     m_insertionSet.insert&lt;Const32Value&gt;(m_index, m_value-&gt;origin(), 1));
1738                 break;
1739             }
1740 
1741             // Turn this Equal(bool, 1)
1742             // Into this: bool
1743             if (m_value-&gt;child(0)-&gt;returnsBool() &amp;&amp; m_value-&gt;child(1)-&gt;isInt32(1)) {
1744                 replaceWithIdentity(m_value-&gt;child(0));
1745                 break;
1746             }
1747 
1748             // Turn this: Equal(const1, const2)
1749             // Into this: const1 == const2
1750             replaceWithNewValue(
1751                 m_proc.addBoolConstant(
1752                     m_value-&gt;origin(),
1753                     m_value-&gt;child(0)-&gt;equalConstant(m_value-&gt;child(1))));
1754             break;
1755 
1756         case NotEqual:
1757             handleCommutativity();
1758 
1759             if (m_value-&gt;child(0)-&gt;returnsBool()) {
1760                 // Turn this: NotEqual(bool, 0)
1761                 // Into this: bool
1762                 if (m_value-&gt;child(1)-&gt;isInt32(0)) {
1763                     replaceWithIdentity(m_value-&gt;child(0));
1764                     break;
1765                 }
1766 
1767                 // Turn this: NotEqual(bool, 1)
1768                 // Into this: Equal(bool, 0)
1769                 if (m_value-&gt;child(1)-&gt;isInt32(1)) {
1770                     replaceWithNew&lt;Value&gt;(
1771                         Equal, m_value-&gt;origin(), m_value-&gt;child(0),
1772                         m_insertionSet.insertIntConstant(m_index, m_value-&gt;origin(), Int32, 0));
1773                     break;
1774                 }
1775             }
1776 
1777             // Turn this: NotEqual(const1, const2)
1778             // Into this: const1 != const2
1779             replaceWithNewValue(
1780                 m_proc.addBoolConstant(
1781                     m_value-&gt;origin(),
1782                     m_value-&gt;child(0)-&gt;notEqualConstant(m_value-&gt;child(1))));
1783             break;
1784 
1785         case LessThan:
1786         case GreaterThan:
1787         case LessEqual:
1788         case GreaterEqual:
1789         case Above:
1790         case Below:
1791         case AboveEqual:
1792         case BelowEqual: {
1793             CanonicalizedComparison comparison = canonicalizeComparison(m_value);
1794             TriState result = MixedTriState;
1795             switch (comparison.opcode) {
1796             case LessThan:
1797                 result = comparison.operands[1]-&gt;greaterThanConstant(comparison.operands[0]);
1798                 break;
1799             case GreaterThan:
1800                 result = comparison.operands[1]-&gt;lessThanConstant(comparison.operands[0]);
1801                 break;
1802             case LessEqual:
1803                 result = comparison.operands[1]-&gt;greaterEqualConstant(comparison.operands[0]);
1804                 break;
1805             case GreaterEqual:
1806                 result = comparison.operands[1]-&gt;lessEqualConstant(comparison.operands[0]);
1807                 break;
1808             case Above:
1809                 result = comparison.operands[1]-&gt;belowConstant(comparison.operands[0]);
1810                 break;
1811             case Below:
1812                 result = comparison.operands[1]-&gt;aboveConstant(comparison.operands[0]);
1813                 break;
1814             case AboveEqual:
1815                 result = comparison.operands[1]-&gt;belowEqualConstant(comparison.operands[0]);
1816                 break;
1817             case BelowEqual:
1818                 result = comparison.operands[1]-&gt;aboveEqualConstant(comparison.operands[0]);
1819                 break;
1820             default:
1821                 RELEASE_ASSERT_NOT_REACHED();
1822                 break;
1823             }
1824 
1825             if (auto* constant = m_proc.addBoolConstant(m_value-&gt;origin(), result)) {
1826                 replaceWithNewValue(constant);
1827                 break;
1828             }
1829             if (comparison.opcode != m_value-&gt;opcode()) {
1830                 replaceWithNew&lt;Value&gt;(comparison.opcode, m_value-&gt;origin(), comparison.operands[0], comparison.operands[1]);
1831                 break;
1832             }
1833             break;
1834         }
1835 
1836         case EqualOrUnordered:
1837             handleCommutativity();
1838 
1839             // Turn this: Equal(const1, const2)
1840             // Into this: isunordered(const1, const2) || const1 == const2.
1841             // Turn this: Equal(value, const_NaN)
1842             // Into this: 1.
1843             replaceWithNewValue(
1844                 m_proc.addBoolConstant(
1845                     m_value-&gt;origin(),
1846                     m_value-&gt;child(1)-&gt;equalOrUnorderedConstant(m_value-&gt;child(0))));
1847             break;
1848 
1849         case CheckAdd: {
1850             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;checkAddConstant(m_proc, m_value-&gt;child(1))))
1851                 break;
1852 
1853             handleCommutativity();
1854 
1855             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1856                 replaceWithIdentity(m_value-&gt;child(0));
1857                 break;
1858             }
1859 
1860             IntRange leftRange = rangeFor(m_value-&gt;child(0));
1861             IntRange rightRange = rangeFor(m_value-&gt;child(1));
1862             if (!leftRange.couldOverflowAdd(rightRange, m_value-&gt;type())) {
1863                 replaceWithNewValue(
1864                     m_proc.add&lt;Value&gt;(Add, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)));
1865                 break;
1866             }
1867             break;
1868         }
1869 
1870         case CheckSub: {
1871             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;checkSubConstant(m_proc, m_value-&gt;child(1))))
1872                 break;
1873 
1874             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1875                 replaceWithIdentity(m_value-&gt;child(0));
1876                 break;
1877             }
1878 
1879             if (Value* negatedConstant = m_value-&gt;child(1)-&gt;checkNegConstant(m_proc)) {
1880                 m_insertionSet.insertValue(m_index, negatedConstant);
1881                 m_value-&gt;as&lt;CheckValue&gt;()-&gt;convertToAdd();
1882                 m_value-&gt;child(1) = negatedConstant;
1883                 m_changed = true;
1884                 break;
1885             }
1886 
1887             IntRange leftRange = rangeFor(m_value-&gt;child(0));
1888             IntRange rightRange = rangeFor(m_value-&gt;child(1));
1889             if (!leftRange.couldOverflowSub(rightRange, m_value-&gt;type())) {
1890                 replaceWithNewValue(
1891                     m_proc.add&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)));
1892                 break;
1893             }
1894             break;
1895         }
1896 
1897         case CheckMul: {
1898             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;checkMulConstant(m_proc, m_value-&gt;child(1))))
1899                 break;
1900 
1901             handleCommutativity();
1902 
1903             if (m_value-&gt;child(1)-&gt;hasInt()) {
1904                 bool modified = true;
1905                 switch (m_value-&gt;child(1)-&gt;asInt()) {
1906                 case 0:
1907                     replaceWithNewValue(m_proc.addIntConstant(m_value, 0));
1908                     break;
1909                 case 1:
1910                     replaceWithIdentity(m_value-&gt;child(0));
1911                     break;
1912                 case 2:
1913                     m_value-&gt;as&lt;CheckValue&gt;()-&gt;convertToAdd();
1914                     m_value-&gt;child(1) = m_value-&gt;child(0);
1915                     m_changed = true;
1916                     break;
1917                 default:
1918                     modified = false;
1919                     break;
1920                 }
1921                 if (modified)
1922                     break;
1923             }
1924 
1925             IntRange leftRange = rangeFor(m_value-&gt;child(0));
1926             IntRange rightRange = rangeFor(m_value-&gt;child(1));
1927             if (!leftRange.couldOverflowMul(rightRange, m_value-&gt;type())) {
1928                 replaceWithNewValue(
1929                     m_proc.add&lt;Value&gt;(Mul, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)));
1930                 break;
1931             }
1932             break;
1933         }
1934 
1935         case Check: {
1936             CheckValue* checkValue = m_value-&gt;as&lt;CheckValue&gt;();
1937 
1938             if (checkValue-&gt;child(0)-&gt;isLikeZero()) {
1939                 checkValue-&gt;replaceWithNop();
1940                 m_changed = true;
1941                 break;
1942             }
1943 
1944             if (checkValue-&gt;child(0)-&gt;isLikeNonZero()) {
1945                 PatchpointValue* patchpoint =
1946                     m_insertionSet.insert&lt;PatchpointValue&gt;(m_index, Void, checkValue-&gt;origin());
1947 
1948                 patchpoint-&gt;effects = Effects();
1949                 patchpoint-&gt;effects.reads = HeapRange::top();
1950                 patchpoint-&gt;effects.exitsSideways = true;
1951 
1952                 for (unsigned i = 1; i &lt; checkValue-&gt;numChildren(); ++i)
1953                     patchpoint-&gt;append(checkValue-&gt;constrainedChild(i));
1954 
1955                 patchpoint-&gt;setGenerator(checkValue-&gt;generator());
1956 
1957                 // Replace the rest of the block with an Oops.
1958                 for (unsigned i = m_index + 1; i &lt; m_block-&gt;size() - 1; ++i)
1959                     m_block-&gt;at(i)-&gt;replaceWithBottom(m_insertionSet, m_index);
1960                 m_block-&gt;last()-&gt;replaceWithOops(m_block);
1961                 m_block-&gt;last()-&gt;setOrigin(checkValue-&gt;origin());
1962 
1963                 // Replace ourselves last.
1964                 checkValue-&gt;replaceWithNop();
1965                 m_changedCFG = true;
1966                 break;
1967             }
1968 
1969             if (checkValue-&gt;child(0)-&gt;opcode() == NotEqual
1970                 &amp;&amp; checkValue-&gt;child(0)-&gt;child(1)-&gt;isInt(0)) {
1971                 checkValue-&gt;child(0) = checkValue-&gt;child(0)-&gt;child(0);
1972                 m_changed = true;
1973             }
1974 
1975             if (m_proc.optLevel() &lt; 2)
1976                 break;
1977 
1978             // If we are checking some bounded-size SSA expression that leads to a Select that
1979             // has a constant as one of its results, then turn the Select into a Branch and split
1980             // the code between the Check and the Branch. For example, this:
1981             //
1982             //     @a = Select(@p, @x, 42)
1983             //     @b = Add(@a, 35)
1984             //     Check(@b)
1985             //
1986             // becomes this:
1987             //
1988             //     Branch(@p, #truecase, #falsecase)
1989             //
1990             //   BB#truecase:
1991             //     @b_truecase = Add(@x, 35)
1992             //     Check(@b_truecase)
1993             //     Upsilon(@x, ^a)
1994             //     Upsilon(@b_truecase, ^b)
1995             //     Jump(#continuation)
1996             //
1997             //   BB#falsecase:
1998             //     @b_falsecase = Add(42, 35)
1999             //     Check(@b_falsecase)
2000             //     Upsilon(42, ^a)
2001             //     Upsilon(@b_falsecase, ^b)
2002             //     Jump(#continuation)
2003             //
2004             //   BB#continuation:
2005             //     @a = Phi()
2006             //     @b = Phi()
2007             //
2008             // The goal of this optimization is to kill a lot of code in one of those basic
2009             // blocks. This is pretty much guaranteed since one of those blocks will replace all
2010             // uses of the Select with a constant, and that constant will be transitively used
2011             // from the check.
2012             static const unsigned selectSpecializationBound = 3;
2013             Value* select = findRecentNodeMatching(
2014                 m_value-&gt;child(0), selectSpecializationBound,
2015                 [&amp;] (Value* value) -&gt; bool {
2016                     return value-&gt;opcode() == Select
2017                         &amp;&amp; (value-&gt;child(1)-&gt;isConstant() &amp;&amp; value-&gt;child(2)-&gt;isConstant());
2018                 });
2019 
2020             if (select) {
2021                 specializeSelect(select);
2022                 break;
2023             }
2024             break;
2025         }
2026 
2027         case Branch: {
2028             // Turn this: Branch(NotEqual(x, 0))
2029             // Into this: Branch(x)
2030             if (m_value-&gt;child(0)-&gt;opcode() == NotEqual &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(0)) {
2031                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
2032                 m_changed = true;
2033             }
2034 
2035             // Turn this: Branch(Equal(x, 0), then, else)
2036             // Into this: Branch(x, else, then)
2037             if (m_value-&gt;child(0)-&gt;opcode() == Equal &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(0)) {
2038                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
2039                 std::swap(m_block-&gt;taken(), m_block-&gt;notTaken());
2040                 m_changed = true;
2041             }
2042 
2043             // Turn this: Branch(BitXor(bool, 1), then, else)
2044             // Into this: Branch(bool, else, then)
2045             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
2046                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(1)
2047                 &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;returnsBool()) {
2048                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
2049                 std::swap(m_block-&gt;taken(), m_block-&gt;notTaken());
2050                 m_changed = true;
2051             }
2052 
2053             // Turn this: Branch(BitAnd(bool, xyb1), then, else)
2054             // Into this: Branch(bool, then, else)
2055             if (m_value-&gt;child(0)-&gt;opcode() == BitAnd
2056                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()
2057                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() &amp; 1
2058                 &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;returnsBool()) {
2059                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
2060                 m_changed = true;
2061             }
2062 
2063             TriState triState = m_value-&gt;child(0)-&gt;asTriState();
2064 
2065             // Turn this: Branch(0, then, else)
2066             // Into this: Jump(else)
2067             if (triState == FalseTriState) {
2068                 m_block-&gt;taken().block()-&gt;removePredecessor(m_block);
2069                 m_value-&gt;replaceWithJump(m_block, m_block-&gt;notTaken());
2070                 m_changedCFG = true;
2071                 break;
2072             }
2073 
2074             // Turn this: Branch(not 0, then, else)
2075             // Into this: Jump(then)
2076             if (triState == TrueTriState) {
2077                 m_block-&gt;notTaken().block()-&gt;removePredecessor(m_block);
2078                 m_value-&gt;replaceWithJump(m_block, m_block-&gt;taken());
2079                 m_changedCFG = true;
2080                 break;
2081             }
2082 
2083             if (m_proc.optLevel() &gt;= 2) {
2084                 // If a check for the same property dominates us, we can kill the branch. This sort
2085                 // of makes sense here because it&#39;s cheap, but hacks like this show that we&#39;re going
2086                 // to need SCCP.
2087                 Value* check = m_pureCSE.findMatch(
2088                     ValueKey(Check, Void, m_value-&gt;child(0)), m_block, *m_dominators);
2089                 if (check) {
2090                     // The Check would have side-exited if child(0) was non-zero. So, it must be
2091                     // zero here.
2092                     m_block-&gt;taken().block()-&gt;removePredecessor(m_block);
2093                     m_value-&gt;replaceWithJump(m_block, m_block-&gt;notTaken());
2094                     m_changedCFG = true;
2095                 }
2096             }
2097             break;
2098         }
2099 
2100         default:
2101             break;
2102         }
2103     }
2104 
2105     // Find a node that:
2106     //     - functor(node) returns true.
2107     //     - it&#39;s reachable from the given node via children.
2108     //     - it&#39;s in the last &quot;bound&quot; slots in the current basic block.
2109     // This algorithm is optimized under the assumption that the bound is small.
2110     template&lt;typename Functor&gt;
2111     Value* findRecentNodeMatching(Value* start, unsigned bound, const Functor&amp; functor)
2112     {
2113         unsigned startIndex = bound &lt; m_index ? m_index - bound : 0;
2114         Value* result = nullptr;
2115         start-&gt;walk(
2116             [&amp;] (Value* value) -&gt; Value::WalkStatus {
2117                 bool found = false;
2118                 for (unsigned i = startIndex; i &lt;= m_index; ++i) {
2119                     if (m_block-&gt;at(i) == value)
2120                         found = true;
2121                 }
2122                 if (!found)
2123                     return Value::IgnoreChildren;
2124 
2125                 if (functor(value)) {
2126                     result = value;
2127                     return Value::Stop;
2128                 }
2129 
2130                 return Value::Continue;
2131             });
2132         return result;
2133     }
2134 
2135     // This specializes a sequence of code up to a Select. This doesn&#39;t work when we&#39;re at a
2136     // terminal. It would be cool to fix that eventually. The main problem is that instead of
2137     // splitting the block, we should just insert the then/else blocks. We&#39;ll have to create
2138     // double the Phis and double the Upsilons. It&#39;ll probably be the sort of optimization that
2139     // we want to do only after we&#39;ve done loop optimizations, since this will *definitely*
2140     // obscure things. In fact, even this simpler form of select specialization will possibly
2141     // obscure other optimizations. It would be great to have two modes of strength reduction,
2142     // one that does obscuring optimizations and runs late, and another that does not do
2143     // obscuring optimizations and runs early.
2144     // FIXME: Make select specialization handle branches.
2145     // FIXME: Have a form of strength reduction that does no obscuring optimizations and runs
2146     // early.
2147     void specializeSelect(Value* source)
2148     {
2149         if (B3ReduceStrengthInternal::verbose)
2150             dataLog(&quot;Specializing select: &quot;, deepDump(m_proc, source), &quot;\n&quot;);
2151 
2152         // This mutates startIndex to account for the fact that m_block got the front of it
2153         // chopped off.
2154         BasicBlock* predecessor =
2155             m_blockInsertionSet.splitForward(m_block, m_index, &amp;m_insertionSet);
2156 
2157         // Splitting will commit the insertion set, which changes the exact position of the
2158         // source. That&#39;s why we do the search after splitting.
2159         unsigned startIndex = UINT_MAX;
2160         for (unsigned i = predecessor-&gt;size(); i--;) {
2161             if (predecessor-&gt;at(i) == source) {
2162                 startIndex = i;
2163                 break;
2164             }
2165         }
2166 
2167         RELEASE_ASSERT(startIndex != UINT_MAX);
2168 
2169         // By BasicBlock convention, caseIndex == 0 =&gt; then, caseIndex == 1 =&gt; else.
2170         static const unsigned numCases = 2;
2171         BasicBlock* cases[numCases];
2172         for (unsigned i = 0; i &lt; numCases; ++i)
2173             cases[i] = m_blockInsertionSet.insertBefore(m_block);
2174 
2175         HashMap&lt;Value*, Value*&gt; mappings[2];
2176 
2177         // Save things we want to know about the source.
2178         Value* predicate = source-&gt;child(0);
2179 
2180         for (unsigned i = 0; i &lt; numCases; ++i)
2181             mappings[i].add(source, source-&gt;child(1 + i));
2182 
2183         auto cloneValue = [&amp;] (Value* value) {
2184             ASSERT(value != source);
2185 
2186             for (unsigned i = 0; i &lt; numCases; ++i) {
2187                 Value* clone = m_proc.clone(value);
2188                 for (Value*&amp; child : clone-&gt;children()) {
2189                     if (Value* newChild = mappings[i].get(child))
2190                         child = newChild;
2191                 }
2192                 if (value-&gt;type() != Void)
2193                     mappings[i].add(value, clone);
2194 
2195                 cases[i]-&gt;append(clone);
2196                 if (value-&gt;type() != Void)
2197                     cases[i]-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, value-&gt;origin(), clone, value);
2198             }
2199 
2200             value-&gt;replaceWithPhi();
2201         };
2202 
2203         // The jump that the splitter inserted is of no use to us.
2204         predecessor-&gt;removeLast(m_proc);
2205 
2206         // Hance the source, it&#39;s special.
2207         for (unsigned i = 0; i &lt; numCases; ++i) {
2208             cases[i]-&gt;appendNew&lt;UpsilonValue&gt;(
2209                 m_proc, source-&gt;origin(), source-&gt;child(1 + i), source);
2210         }
2211         source-&gt;replaceWithPhi();
2212         m_insertionSet.insertValue(m_index, source);
2213 
2214         // Now handle all values between the source and the check.
2215         for (unsigned i = startIndex + 1; i &lt; predecessor-&gt;size(); ++i) {
2216             Value* value = predecessor-&gt;at(i);
2217             value-&gt;owner = nullptr;
2218 
2219             cloneValue(value);
2220 
2221             if (value-&gt;type() != Void)
2222                 m_insertionSet.insertValue(m_index, value);
2223             else
2224                 m_proc.deleteValue(value);
2225         }
2226 
2227         // Finally, deal with the check.
2228         cloneValue(m_value);
2229 
2230         // Remove the values from the predecessor.
2231         predecessor-&gt;values().resize(startIndex);
2232 
2233         predecessor-&gt;appendNew&lt;Value&gt;(m_proc, Branch, source-&gt;origin(), predicate);
2234         predecessor-&gt;setSuccessors(FrequentedBlock(cases[0]), FrequentedBlock(cases[1]));
2235 
2236         for (unsigned i = 0; i &lt; numCases; ++i) {
2237             cases[i]-&gt;appendNew&lt;Value&gt;(m_proc, Jump, m_value-&gt;origin());
2238             cases[i]-&gt;setSuccessors(FrequentedBlock(m_block));
2239         }
2240 
2241         m_changed = true;
2242 
2243         predecessor-&gt;updatePredecessorsAfter();
2244     }
2245 
2246     static bool shouldSwapBinaryOperands(Value* value)
2247     {
2248         // Note that we have commutative operations that take more than two children. Those operations may
2249         // commute their first two children while leaving the rest unaffected.
2250         ASSERT(value-&gt;numChildren() &gt;= 2);
2251 
2252         // Leave it alone if the right child is a constant.
2253         if (value-&gt;child(1)-&gt;isConstant()
2254             || value-&gt;child(0)-&gt;opcode() == AtomicStrongCAS)
2255             return false;
2256 
2257         if (value-&gt;child(0)-&gt;isConstant())
2258             return true;
2259 
2260         if (value-&gt;child(1)-&gt;opcode() == AtomicStrongCAS)
2261             return true;
2262 
2263         // Sort the operands. This is an important canonicalization. We use the index instead of
2264         // the address to make this at least slightly deterministic.
2265         if (value-&gt;child(0)-&gt;index() &gt; value-&gt;child(1)-&gt;index())
2266             return true;
2267 
2268         return false;
2269     }
2270 
2271     // Turn this: Add(constant, value)
2272     // Into this: Add(value, constant)
2273     //
2274     // Also:
2275     // Turn this: Add(value1, value2)
2276     // Into this: Add(value2, value1)
2277     // If we decide that value2 coming first is the canonical ordering.
2278     void handleCommutativity()
2279     {
2280         if (shouldSwapBinaryOperands(m_value)) {
2281             std::swap(m_value-&gt;child(0), m_value-&gt;child(1));
2282             m_changed = true;
2283         }
2284     }
2285 
2286     // For Op==BitOr or BitXor, turn any of these:
2287     //      Op(BitAnd(x1, x2), BitAnd(x1, x3))
2288     //      Op(BitAnd(x2, x1), BitAnd(x1, x3))
2289     //      Op(BitAnd(x1, x2), BitAnd(x3, x1))
2290     //      Op(BitAnd(x2, x1), BitAnd(x3, x1))
2291     // Into this: BitAnd(Op(x2, x3), x1)
2292     // And any of these:
2293     //      Op(BitAnd(x1, x2), x1)
2294     //      Op(BitAnd(x2, x1), x1)
2295     //      Op(x1, BitAnd(x1, x2))
2296     //      Op(x1, BitAnd(x2, x1))
2297     // Into this: BitAnd(Op(x2, x1), x1)
2298     // This second set is equivalent to doing x1 =&gt; BitAnd(x1, x1), and then applying the first set.
2299     // It does not reduce the number of operations executed, but provides some useful normalization: we prefer to have BitAnd at the outermost, then BitXor, and finally BitOr at the innermost
2300     bool handleBitAndDistributivity()
2301     {
2302         ASSERT(m_value-&gt;opcode() == BitOr || m_value-&gt;opcode() == BitXor);
2303         Value* x1 = nullptr;
2304         Value* x2 = nullptr;
2305         Value* x3 = nullptr;
2306         if (m_value-&gt;child(0)-&gt;opcode() == BitAnd &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitAnd) {
2307             if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)-&gt;child(0)) {
2308                 x1 = m_value-&gt;child(0)-&gt;child(0);
2309                 x2 = m_value-&gt;child(0)-&gt;child(1);
2310                 x3 = m_value-&gt;child(1)-&gt;child(1);
2311             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)-&gt;child(0)) {
2312                 x1 = m_value-&gt;child(0)-&gt;child(1);
2313                 x2 = m_value-&gt;child(0)-&gt;child(0);
2314                 x3 = m_value-&gt;child(1)-&gt;child(1);
2315             } else if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)-&gt;child(1)) {
2316                 x1 = m_value-&gt;child(0)-&gt;child(0);
2317                 x2 = m_value-&gt;child(0)-&gt;child(1);
2318                 x3 = m_value-&gt;child(1)-&gt;child(0);
2319             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)-&gt;child(1)) {
2320                 x1 = m_value-&gt;child(0)-&gt;child(1);
2321                 x2 = m_value-&gt;child(0)-&gt;child(0);
2322                 x3 = m_value-&gt;child(1)-&gt;child(0);
2323             }
2324         } else if (m_value-&gt;child(0)-&gt;opcode() == BitAnd) {
2325             if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)) {
2326                 x1 = x3 = m_value-&gt;child(1);
2327                 x2 = m_value-&gt;child(0)-&gt;child(1);
2328             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)) {
2329                 x1 = x3 = m_value-&gt;child(1);
2330                 x2 = m_value-&gt;child(0)-&gt;child(0);
2331             }
2332         } else if (m_value-&gt;child(1)-&gt;opcode() == BitAnd) {
2333             if (m_value-&gt;child(1)-&gt;child(0) == m_value-&gt;child(0)) {
2334                 x1 = x3 = m_value-&gt;child(0);
2335                 x2 = m_value-&gt;child(1)-&gt;child(1);
2336             } else if (m_value-&gt;child(1)-&gt;child(1) == m_value-&gt;child(0)) {
2337                 x1 = x3 = m_value-&gt;child(0);
2338                 x2 = m_value-&gt;child(1)-&gt;child(0);
2339             }
2340         }
2341         if (x1 != nullptr) {
2342             ASSERT(x2 != nullptr &amp;&amp; x3 != nullptr);
2343             Value* bitOp = m_insertionSet.insert&lt;Value&gt;(m_index, m_value-&gt;opcode(), m_value-&gt;origin(), x2, x3);
2344             replaceWithNew&lt;Value&gt;(BitAnd, m_value-&gt;origin(), bitOp, x1);
2345             return true;
2346         }
2347         return false;
2348     }
2349 
2350     struct CanonicalizedComparison {
2351         Opcode opcode;
2352         Value* operands[2];
2353     };
2354     static CanonicalizedComparison canonicalizeComparison(Value* value)
2355     {
2356         auto flip = [] (Opcode opcode) {
2357             switch (opcode) {
2358             case LessThan:
2359                 return GreaterThan;
2360             case GreaterThan:
2361                 return LessThan;
2362             case LessEqual:
2363                 return GreaterEqual;
2364             case GreaterEqual:
2365                 return LessEqual;
2366             case Above:
2367                 return Below;
2368             case Below:
2369                 return Above;
2370             case AboveEqual:
2371                 return BelowEqual;
2372             case BelowEqual:
2373                 return AboveEqual;
2374             default:
2375                 return opcode;
2376             }
2377         };
2378         if (shouldSwapBinaryOperands(value))
2379             return { flip(value-&gt;opcode()), { value-&gt;child(1), value-&gt;child(0) } };
2380         return { value-&gt;opcode(), { value-&gt;child(0), value-&gt;child(1) } };
2381     }
2382 
2383     // FIXME: This should really be a forward analysis. Instead, we uses a bounded-search backwards
2384     // analysis.
2385     IntRange rangeFor(Value* value, unsigned timeToLive = 5)
2386     {
2387         if (!timeToLive)
2388             return IntRange::top(value-&gt;type());
2389 
2390         switch (value-&gt;opcode()) {
2391         case Const32:
2392         case Const64: {
2393             int64_t intValue = value-&gt;asInt();
2394             return IntRange(intValue, intValue);
2395         }
2396 
2397         case BitAnd:
2398             if (value-&gt;child(1)-&gt;hasInt())
2399                 return IntRange::rangeForMask(value-&gt;child(1)-&gt;asInt(), value-&gt;type());
2400             break;
2401 
2402         case SShr:
2403             if (value-&gt;child(1)-&gt;hasInt32()) {
2404                 return rangeFor(value-&gt;child(0), timeToLive - 1).sShr(
2405                     value-&gt;child(1)-&gt;asInt32(), value-&gt;type());
2406             }
2407             break;
2408 
2409         case ZShr:
2410             if (value-&gt;child(1)-&gt;hasInt32()) {
2411                 return rangeFor(value-&gt;child(0), timeToLive - 1).zShr(
2412                     value-&gt;child(1)-&gt;asInt32(), value-&gt;type());
2413             }
2414             break;
2415 
2416         case Shl:
2417             if (value-&gt;child(1)-&gt;hasInt32()) {
2418                 return rangeFor(value-&gt;child(0), timeToLive - 1).shl(
2419                     value-&gt;child(1)-&gt;asInt32(), value-&gt;type());
2420             }
2421             break;
2422 
2423         case Add:
2424             return rangeFor(value-&gt;child(0), timeToLive - 1).add(
2425                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2426 
2427         case Sub:
2428             return rangeFor(value-&gt;child(0), timeToLive - 1).sub(
2429                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2430 
2431         case Mul:
2432             return rangeFor(value-&gt;child(0), timeToLive - 1).mul(
2433                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2434 
2435         default:
2436             break;
2437         }
2438 
2439         return IntRange::top(value-&gt;type());
2440     }
2441 
2442     template&lt;typename ValueType, typename... Arguments&gt;
2443     void replaceWithNew(Arguments... arguments)
2444     {
2445         replaceWithNewValue(m_proc.add&lt;ValueType&gt;(arguments...));
2446     }
2447 
2448     bool replaceWithNewValue(Value* newValue)
2449     {
2450         if (!newValue)
2451             return false;
2452         m_insertionSet.insertValue(m_index, newValue);
2453         m_value-&gt;replaceWithIdentity(newValue);
2454         m_changed = true;
2455         return true;
2456     }
2457 
2458     void replaceWithIdentity(Value* newValue)
2459     {
2460         m_value-&gt;replaceWithIdentity(newValue);
2461         m_changed = true;
2462     }
2463 
2464     void handleShiftAmount()
2465     {
2466         // Shift anything by zero is identity.
2467         if (m_value-&gt;child(1)-&gt;isInt32(0)) {
2468             replaceWithIdentity(m_value-&gt;child(0));
2469             return;
2470         }
2471 
2472         // The shift already masks its shift amount. If the shift amount is being masked by a
2473         // redundant amount, then remove the mask. For example,
2474         // Turn this: Shl(@x, BitAnd(@y, 63))
2475         // Into this: Shl(@x, @y)
2476         unsigned mask = sizeofType(m_value-&gt;type()) * 8 - 1;
2477         if (m_value-&gt;child(1)-&gt;opcode() == BitAnd
2478             &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;hasInt32()
2479             &amp;&amp; (m_value-&gt;child(1)-&gt;child(1)-&gt;asInt32() &amp; mask) == mask) {
2480             m_value-&gt;child(1) = m_value-&gt;child(1)-&gt;child(0);
2481             m_changed = true;
2482         }
2483     }
2484 
2485     void replaceIfRedundant()
2486     {
2487         m_changed |= m_pureCSE.process(m_value, *m_dominators);
2488     }
2489 
2490     void simplifyCFG()
2491     {
2492         if (B3ReduceStrengthInternal::verbose) {
2493             dataLog(&quot;Before simplifyCFG:\n&quot;);
2494             dataLog(m_proc);
2495         }
2496 
2497         // We have three easy simplification rules:
2498         //
2499         // 1) If a successor is a block that just jumps to another block, then jump directly to
2500         //    that block.
2501         //
2502         // 2) If all successors are the same and the operation has no effects, then use a jump
2503         //    instead.
2504         //
2505         // 3) If you jump to a block that is not you and has one predecessor, then merge.
2506         //
2507         // Note that because of the first rule, this phase may introduce critical edges. That&#39;s fine.
2508         // If you need broken critical edges, then you have to break them yourself.
2509 
2510         // Note that this relies on predecessors being at least conservatively correct. It&#39;s fine for
2511         // predecessors to mention a block that isn&#39;t actually a predecessor. It&#39;s *not* fine for a
2512         // predecessor to be omitted. We assert as much in the loop. In practice, we precisely preserve
2513         // predecessors during strength reduction since that minimizes the total number of fixpoint
2514         // iterations needed to kill a lot of code.
2515 
2516         for (BasicBlock* block : m_proc.blocksInPostOrder()) {
2517             if (B3ReduceStrengthInternal::verbose)
2518                 dataLog(&quot;Considering block &quot;, *block, &quot;:\n&quot;);
2519 
2520             checkPredecessorValidity();
2521 
2522             // We don&#39;t care about blocks that don&#39;t have successors.
2523             if (!block-&gt;numSuccessors())
2524                 continue;
2525 
2526             // First check if any of the successors of this block can be forwarded over.
2527             for (BasicBlock*&amp; successor : block-&gt;successorBlocks()) {
2528                 if (successor != block
2529                     &amp;&amp; successor-&gt;size() == 1
2530                     &amp;&amp; successor-&gt;last()-&gt;opcode() == Jump) {
2531                     BasicBlock* newSuccessor = successor-&gt;successorBlock(0);
2532                     if (newSuccessor != successor) {
2533                         if (B3ReduceStrengthInternal::verbose) {
2534                             dataLog(
2535                                 &quot;Replacing &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successor),
2536                                 &quot; with &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(newSuccessor),
2537                                 &quot;\n&quot;);
2538                         }
2539                         // Note that we do not do replacePredecessor() because the block we&#39;re
2540                         // skipping will still have newSuccessor as its successor.
2541                         newSuccessor-&gt;addPredecessor(block);
2542                         successor = newSuccessor;
2543                         m_changedCFG = true;
2544                     }
2545                 }
2546             }
2547 
2548             // Now check if the block&#39;s terminal can be replaced with a jump.
2549             if (block-&gt;numSuccessors() &gt; 1) {
2550                 // The terminal must not have weird effects.
2551                 Effects effects = block-&gt;last()-&gt;effects();
2552                 effects.terminal = false;
2553                 if (!effects.mustExecute()) {
2554                     // All of the successors must be the same.
2555                     bool allSame = true;
2556                     BasicBlock* firstSuccessor = block-&gt;successorBlock(0);
2557                     for (unsigned i = 1; i &lt; block-&gt;numSuccessors(); ++i) {
2558                         if (block-&gt;successorBlock(i) != firstSuccessor) {
2559                             allSame = false;
2560                             break;
2561                         }
2562                     }
2563                     if (allSame) {
2564                         if (B3ReduceStrengthInternal::verbose) {
2565                             dataLog(
2566                                 &quot;Changing &quot;, pointerDump(block), &quot;&#39;s terminal to a Jump.\n&quot;);
2567                         }
2568                         block-&gt;last()-&gt;replaceWithJump(block, FrequentedBlock(firstSuccessor));
2569                         m_changedCFG = true;
2570                     }
2571                 }
2572             }
2573 
2574             // Finally handle jumps to a block with one predecessor.
2575             if (block-&gt;numSuccessors() == 1) {
2576                 BasicBlock* successor = block-&gt;successorBlock(0);
2577                 if (successor != block &amp;&amp; successor-&gt;numPredecessors() == 1) {
2578                     RELEASE_ASSERT(successor-&gt;predecessor(0) == block);
2579 
2580                     // We can merge the two blocks, because the predecessor only jumps to the successor
2581                     // and the successor is only reachable from the predecessor.
2582 
2583                     // Remove the terminal.
2584                     Value* value = block-&gt;values().takeLast();
2585                     Origin jumpOrigin = value-&gt;origin();
2586                     RELEASE_ASSERT(value-&gt;effects().terminal);
2587                     m_proc.deleteValue(value);
2588 
2589                     // Append the full contents of the successor to the predecessor.
2590                     block-&gt;values().appendVector(successor-&gt;values());
2591                     block-&gt;successors() = successor-&gt;successors();
2592 
2593                     // Make sure that the successor has nothing left in it. Make sure that the block
2594                     // has a terminal so that nobody chokes when they look at it.
2595                     successor-&gt;values().shrink(0);
2596                     successor-&gt;appendNew&lt;Value&gt;(m_proc, Oops, jumpOrigin);
2597                     successor-&gt;clearSuccessors();
2598 
2599                     // Ensure that predecessors of block&#39;s new successors know what&#39;s up.
2600                     for (BasicBlock* newSuccessor : block-&gt;successorBlocks())
2601                         newSuccessor-&gt;replacePredecessor(successor, block);
2602 
2603                     if (B3ReduceStrengthInternal::verbose) {
2604                         dataLog(
2605                             &quot;Merged &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successor), &quot;\n&quot;);
2606                     }
2607 
2608                     m_changedCFG = true;
2609                 }
2610             }
2611         }
2612 
2613         if (m_changedCFG &amp;&amp; B3ReduceStrengthInternal::verbose) {
2614             dataLog(&quot;B3 after simplifyCFG:\n&quot;);
2615             dataLog(m_proc);
2616         }
2617     }
2618 
2619     void handleChangedCFGIfNecessary()
2620     {
2621         if (m_changedCFG) {
2622             m_proc.resetReachability();
2623             m_proc.invalidateCFG();
2624             m_dominators = nullptr; // Dominators are not valid anymore, and we don&#39;t need them yet.
2625             m_changed = true;
2626         }
2627     }
2628 
2629     void checkPredecessorValidity()
2630     {
2631         if (!shouldValidateIRAtEachPhase())
2632             return;
2633 
2634         for (BasicBlock* block : m_proc) {
2635             for (BasicBlock* successor : block-&gt;successorBlocks())
2636                 RELEASE_ASSERT(successor-&gt;containsPredecessor(block));
2637         }
2638     }
2639 
2640     void killDeadCode()
2641     {
2642         GraphNodeWorklist&lt;Value*, IndexSet&lt;Value*&gt;&gt; worklist;
2643         Vector&lt;UpsilonValue*, 64&gt; upsilons;
2644         for (BasicBlock* block : m_proc) {
2645             for (Value* value : *block) {
2646                 Effects effects;
2647                 // We don&#39;t care about effects of SSA operations, since we model them more
2648                 // accurately than the effects() method does.
2649                 if (value-&gt;opcode() != Phi &amp;&amp; value-&gt;opcode() != Upsilon)
2650                     effects = value-&gt;effects();
2651 
2652                 if (effects.mustExecute())
2653                     worklist.push(value);
2654 
2655                 if (UpsilonValue* upsilon = value-&gt;as&lt;UpsilonValue&gt;())
2656                     upsilons.append(upsilon);
2657             }
2658         }
2659         for (;;) {
2660             while (Value* value = worklist.pop()) {
2661                 for (Value* child : value-&gt;children())
2662                     worklist.push(child);
2663             }
2664 
2665             bool didPush = false;
2666             for (size_t upsilonIndex = 0; upsilonIndex &lt; upsilons.size(); ++upsilonIndex) {
2667                 UpsilonValue* upsilon = upsilons[upsilonIndex];
2668                 if (worklist.saw(upsilon-&gt;phi())) {
2669                     worklist.push(upsilon);
2670                     upsilons[upsilonIndex--] = upsilons.last();
2671                     upsilons.takeLast();
2672                     didPush = true;
2673                 }
2674             }
2675             if (!didPush)
2676                 break;
2677         }
2678 
2679         IndexSet&lt;Variable*&gt; liveVariables;
2680 
2681         for (BasicBlock* block : m_proc) {
2682             size_t sourceIndex = 0;
2683             size_t targetIndex = 0;
2684             while (sourceIndex &lt; block-&gt;size()) {
2685                 Value* value = block-&gt;at(sourceIndex++);
2686                 if (worklist.saw(value)) {
2687                     if (VariableValue* variableValue = value-&gt;as&lt;VariableValue&gt;())
2688                         liveVariables.add(variableValue-&gt;variable());
2689                     block-&gt;at(targetIndex++) = value;
2690                 } else {
2691                     m_proc.deleteValue(value);
2692                     m_changed = true;
2693                 }
2694             }
2695             block-&gt;values().resize(targetIndex);
2696         }
2697 
2698         for (Variable* variable : m_proc.variables()) {
2699             if (!liveVariables.contains(variable))
2700                 m_proc.deleteVariable(variable);
2701         }
2702     }
2703 
2704     void simplifySSA()
2705     {
2706         // This runs Aycock and Horspool&#39;s algorithm on our Phi functions [1]. For most CFG patterns,
2707         // this can take a suboptimal arrangement of Phi functions and make it optimal, as if you had
2708         // run Cytron, Ferrante, Rosen, Wegman, and Zadeck. It&#39;s only suboptimal for irreducible
2709         // CFGs. In practice, that doesn&#39;t matter, since we expect clients of B3 to run their own SSA
2710         // conversion before lowering to B3, and in the case of the DFG, that conversion uses Cytron
2711         // et al. In that context, this algorithm is intended to simplify Phi functions that were
2712         // made redundant by prior CFG simplification. But according to Aycock and Horspool&#39;s paper,
2713         // this algorithm is good enough that a B3 client could just give us maximal Phi&#39;s (i.e. Phi
2714         // for each variable at each basic block) and we will make them optimal.
2715         // [1] http://pages.cpsc.ucalgary.ca/~aycock/papers/ssa.ps
2716 
2717         // Aycock and Horspool prescribe two rules that are to be run to fixpoint:
2718         //
2719         // 1) If all of the Phi&#39;s children are the same (i.e. it&#39;s one child referenced from one or
2720         //    more Upsilons), then replace all uses of the Phi with the one child.
2721         //
2722         // 2) If all of the Phi&#39;s children are either the Phi itself or exactly one other child, then
2723         //    replace all uses of the Phi with the one other child.
2724         //
2725         // Rule (2) subsumes rule (1), so we can just run (2). We only run one fixpoint iteration
2726         // here. This premise is that in common cases, this will only find optimization opportunities
2727         // as a result of CFG simplification and usually CFG simplification will only do one round
2728         // of block merging per ReduceStrength fixpoint iteration, so it&#39;s OK for this to only do one
2729         // round of Phi merging - since Phis are the value analogue of blocks.
2730 
2731         PhiChildren phiChildren(m_proc);
2732 
2733         for (Value* phi : phiChildren.phis()) {
2734             Value* otherChild = nullptr;
2735             bool ok = true;
2736             for (Value* child : phiChildren[phi].values()) {
2737                 if (child == phi)
2738                     continue;
2739                 if (child == otherChild)
2740                     continue;
2741                 if (!otherChild) {
2742                     otherChild = child;
2743                     continue;
2744                 }
2745                 ok = false;
2746                 break;
2747             }
2748             if (!ok)
2749                 continue;
2750             if (!otherChild) {
2751                 // Wow, this would be super weird. It probably won&#39;t happen, except that things could
2752                 // get weird as a consequence of stepwise simplifications in the strength reduction
2753                 // fixpoint.
2754                 continue;
2755             }
2756 
2757             // Turn the Phi into an Identity and turn the Upsilons into Nops.
2758             m_changed = true;
2759             for (Value* upsilon : phiChildren[phi])
2760                 upsilon-&gt;replaceWithNop();
2761             phi-&gt;replaceWithIdentity(otherChild);
2762         }
2763     }
2764 
2765     Procedure&amp; m_proc;
2766     InsertionSet m_insertionSet;
2767     BlockInsertionSet m_blockInsertionSet;
2768     BasicBlock* m_block { nullptr };
2769     unsigned m_index { 0 };
2770     Value* m_value { nullptr };
2771     Dominators* m_dominators { nullptr };
2772     PureCSE m_pureCSE;
2773     bool m_changed { false };
2774     bool m_changedCFG { false };
2775 };
2776 
2777 } // anonymous namespace
2778 
2779 bool reduceStrength(Procedure&amp; proc)
2780 {
2781     PhaseScope phaseScope(proc, &quot;reduceStrength&quot;);
2782     ReduceStrength reduceStrength(proc);
2783     return reduceStrength.run();
2784 }
2785 
2786 } } // namespace JSC::B3
2787 
2788 #endif // ENABLE(B3_JIT)
2789 
    </pre>
  </body>
</html>