<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlockFlow.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 101 // FIXME: We should store these based on physical direction.
 102 typedef WTF::HashMap&lt;const RenderBox*, Optional&lt;LayoutUnit&gt;&gt; OverrideOptionalSizeMap;
 103 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalHeightMap = nullptr;
 104 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalWidthMap = nullptr;
 105 
 106 // Size of border belt for autoscroll. When mouse pointer in border belt,
 107 // autoscroll is started.
 108 static const int autoscrollBeltSize = 20;
 109 static const unsigned backgroundObscurationTestMaxDepth = 4;
 110 
 111 using ControlStatesRendererMap = HashMap&lt;const RenderObject*, std::unique_ptr&lt;ControlStates&gt;&gt;;
 112 static ControlStatesRendererMap&amp; controlStatesRendererMap()
 113 {
 114     static NeverDestroyed&lt;ControlStatesRendererMap&gt; map;
 115     return map;
 116 }
 117 
 118 static ControlStates* controlStatesForRenderer(const RenderBox&amp; renderer)
 119 {
 120     return controlStatesRendererMap().ensure(&amp;renderer, [] {
<span class="line-modified"> 121         return std::make_unique&lt;ControlStates&gt;();</span>
 122     }).iterator-&gt;value.get();
 123 }
 124 
 125 static void removeControlStatesForRenderer(const RenderBox&amp; renderer)
 126 {
 127     controlStatesRendererMap().remove(&amp;renderer);
 128 }
 129 
 130 bool RenderBox::s_hadOverflowClip = false;
 131 
 132 RenderBox::RenderBox(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 133     : RenderBoxModelObject(element, WTFMove(style), baseTypeFlags)
 134 {
 135     setIsBox();
 136 }
 137 
 138 RenderBox::RenderBox(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 139     : RenderBoxModelObject(document, WTFMove(style), baseTypeFlags)
 140 {
 141     setIsBox();
</pre>
<hr />
<pre>
 558 }
 559 
 560 int RenderBox::scrollLeft() const
 561 {
 562     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().x() : 0;
 563 }
 564 
 565 int RenderBox::scrollTop() const
 566 {
 567     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
 568 }
 569 
 570 static void setupWheelEventTestTrigger(RenderLayer&amp; layer)
 571 {
 572     Page&amp; page = layer.renderer().page();
 573     if (!page.expectsWheelEventTriggers())
 574         return;
 575     layer.scrollAnimator().setWheelEventTestTrigger(page.testTrigger());
 576 }
 577 
<span class="line-modified"> 578 void RenderBox::setScrollLeft(int newLeft, ScrollClamping clamping)</span>
 579 {
 580     if (!hasOverflowClip() || !layer())
 581         return;
 582     setupWheelEventTestTrigger(*layer());
<span class="line-modified"> 583     layer()-&gt;scrollToXPosition(newLeft, clamping);</span>
 584 }
 585 
<span class="line-modified"> 586 void RenderBox::setScrollTop(int newTop, ScrollClamping clamping)</span>
 587 {
 588     if (!hasOverflowClip() || !layer())
 589         return;
 590     setupWheelEventTestTrigger(*layer());
<span class="line-modified"> 591     layer()-&gt;scrollToYPosition(newTop, clamping);</span>
 592 }
 593 
 594 void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 595 {
 596     rects.append(snappedIntRect(accumulatedOffset, size()));
 597 }
 598 
 599 void RenderBox::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 600 {
 601     FloatRect localRect(0, 0, width(), height());
 602 
 603     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 604     if (fragmentedFlow &amp;&amp; fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
 605         return;
 606 
 607     quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
 608 }
 609 
 610 void RenderBox::updateLayerTransform()
 611 {
</pre>
<hr />
<pre>
 641         if (Optional&lt;LayoutUnit&gt; maxH = computeContentLogicalHeight(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 642             logicalHeight = std::min(logicalHeight, maxH.value());
 643     }
 644     if (Optional&lt;LayoutUnit&gt; computedContentLogicalHeight = computeContentLogicalHeight(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 645         return std::max(logicalHeight, computedContentLogicalHeight.value());
 646     return logicalHeight;
 647 }
 648 
 649 RoundedRect::Radii RenderBox::borderRadii() const
 650 {
 651     auto&amp; style = this-&gt;style();
 652     LayoutRect bounds = frameRect();
 653 
 654     unsigned borderLeft = style.borderLeftWidth();
 655     unsigned borderTop = style.borderTopWidth();
 656     bounds.moveBy(LayoutPoint(borderLeft, borderTop));
 657     bounds.contract(borderLeft + style.borderRightWidth(), borderTop + style.borderBottomWidth());
 658     return style.getRoundedBorderFor(bounds).radii();
 659 }
 660 










 661 LayoutRect RenderBox::contentBoxRect() const
 662 {
 663     return { contentBoxLocation(), contentSize() };
 664 }
 665 
 666 LayoutPoint RenderBox::contentBoxLocation() const
 667 {
 668     LayoutUnit scrollbarSpace = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth() : 0;
 669     return { borderLeft() + paddingLeft() + scrollbarSpace, borderTop() + paddingTop() };
 670 }
 671 
 672 IntRect RenderBox::absoluteContentBox() const
 673 {
 674     // This is wrong with transforms and flipped writing modes.
 675     IntRect rect = snappedIntRect(contentBoxRect());
 676     FloatPoint absPos = localToAbsolute();
 677     rect.move(absPos.x(), absPos.y());
 678     return rect;
 679 }
 680 
</pre>
<hr />
<pre>
 966 
 967     ASSERT(hasLayer());
 968     return layer()-&gt;scrollPosition();
 969 }
 970 
 971 LayoutSize RenderBox::cachedSizeForOverflowClip() const
 972 {
 973     ASSERT(hasOverflowClip());
 974     ASSERT(hasLayer());
 975     return layer()-&gt;size();
 976 }
 977 
 978 bool RenderBox::applyCachedClipAndScrollPosition(LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 979 {
 980     flipForWritingMode(rect);
 981 
 982     if (context.m_options.contains(VisibleRectContextOption::ApplyCompositedContainerScrolls) || this != container || !usesCompositedScrolling())
 983         rect.moveBy(-scrollPosition()); // For overflow:auto/scroll/hidden.
 984 
 985     // Do not clip scroll layer contents to reduce the number of repaints while scrolling.
<span class="line-modified"> 986     if (!context.m_options.contains(VisibleRectContextOption::ApplyCompositedClips) &amp;&amp; usesCompositedScrolling()) {</span>

 987         flipForWritingMode(rect);
 988         return true;
 989     }
 990 
 991     // height() is inaccurate if we&#39;re in the middle of a layout of this RenderBox, so use the
 992     // layer&#39;s size instead. Even if the layer&#39;s size is wrong, the layer itself will repaint
 993     // anyway if its size does change.
 994     LayoutRect clipRect(LayoutPoint(), cachedSizeForOverflowClip());
 995     bool intersects;
 996     if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
 997         intersects = rect.edgeInclusiveIntersect(clipRect);
 998     else {
 999         rect.intersect(clipRect);
1000         intersects = !rect.isEmpty();
1001     }
1002     flipForWritingMode(rect);
1003     return intersects;
1004 }
1005 
1006 void RenderBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
</pre>
<hr />
<pre>
1229         if (result.addNodeToListBasedTestResult(element(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
1230             return true;
1231     }
1232 
1233     return false;
1234 }
1235 
1236 // --------------------- painting stuff -------------------------------
1237 
1238 void RenderBox::paintRootBoxFillLayers(const PaintInfo&amp; paintInfo)
1239 {
1240     ASSERT(isDocumentElementRenderer());
1241     if (paintInfo.skipRootBackground())
1242         return;
1243 
1244     auto* rootBackgroundRenderer = view().rendererForRootBackground();
1245     if (!rootBackgroundRenderer)
1246         return;
1247 
1248     auto&amp; style = rootBackgroundRenderer-&gt;style();
<span class="line-removed">1249 </span>
1250     auto color = style.visitedDependentColor(CSSPropertyBackgroundColor);
<span class="line-modified">1251 </span>
<span class="line-removed">1252     CompositeOperator compositeOp = CompositeSourceOver;</span>
<span class="line-removed">1253     if (document().settings().punchOutWhiteBackgroundsInDarkMode() &amp;&amp; Color::isWhiteColor(color) &amp;&amp; useDarkAppearance())</span>
<span class="line-removed">1254         compositeOp = CompositeDestinationOut;</span>
1255 
1256     paintFillLayers(paintInfo, style.colorByApplyingColorFilter(color), style.backgroundLayers(), view().backgroundRect(), BackgroundBleedNone, compositeOp, rootBackgroundRenderer);
1257 }
1258 
1259 BackgroundBleedAvoidance RenderBox::determineBackgroundBleedAvoidance(GraphicsContext&amp; context) const
1260 {
1261     if (context.paintingDisabled())
1262         return BackgroundBleedNone;
1263 
1264     const RenderStyle&amp; style = this-&gt;style();
1265 
1266     if (!style.hasBackground() || !style.hasBorder() || !style.hasBorderRadius() || borderImageIsLoadedAndCanBeRendered())
1267         return BackgroundBleedNone;
1268 
1269     AffineTransform ctm = context.getCTM();
1270     FloatSize contextScaling(static_cast&lt;float&gt;(ctm.xScale()), static_cast&lt;float&gt;(ctm.yScale()));
1271 
1272     // Because RoundedRect uses IntRect internally the inset applied by the
1273     // BackgroundBleedShrinkBackground strategy cannot be less than one integer
1274     // layout coordinate, even with subpixel layout enabled. To take that into
</pre>
<hr />
<pre>
1285 
1286     if (borderObscuresBackgroundEdge(contextScaling))
1287         return BackgroundBleedShrinkBackground;
1288     if (!style.hasAppearance() &amp;&amp; borderObscuresBackground() &amp;&amp; backgroundHasOpaqueTopLayer())
1289         return BackgroundBleedBackgroundOverBorder;
1290 
1291     return BackgroundBleedUseTransparencyLayer;
1292 }
1293 
1294 void RenderBox::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1295 {
1296     if (!paintInfo.shouldPaintWithinRoot(*this))
1297         return;
1298 
1299     LayoutRect paintRect = borderBoxRectInFragment(nullptr);
1300     paintRect.moveBy(paintOffset);
1301     adjustBorderBoxRectForPainting(paintRect);
1302 
1303 #if PLATFORM(IOS_FAMILY)
1304     // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.

1305     if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1306         int width = std::min(paintRect.width(), paintRect.height());
1307         int height = width;
<span class="line-modified">1308         paintRect = IntRect(paintRect.x(), paintRect.y() + (this-&gt;height() - height) / 2, width, height); // Vertically center the checkbox, like on desktop</span>
1309     }
1310 #endif
1311     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
1312 
1313     // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
1314     // custom shadows of their own.
1315     if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1316         paintBoxShadow(paintInfo, paintRect, style(), Normal);
1317 
1318     GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
1319     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
1320         // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
1321         // into a transparency layer, and then clip that in one go (which requires setting up the clip before
1322         // beginning the layer).
1323         stateSaver.save();
1324         paintInfo.context().clipRoundedRect(style().getRoundedBorderFor(paintRect).pixelSnappedRoundedRectForPainting(document().deviceScaleFactor()));
1325         paintInfo.context().beginTransparencyLayer(1);
1326     }
1327 
1328     // If we have a native theme appearance, paint that before painting our background.
</pre>
<hr />
<pre>
1364             || documentElementRenderer-&gt;hasBackground()
1365             || (documentElementRenderer != parent());
1366     }
1367 
1368     return true;
1369 }
1370 
1371 void RenderBox::paintBackground(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect, BackgroundBleedAvoidance bleedAvoidance)
1372 {
1373     if (isDocumentElementRenderer()) {
1374         paintRootBoxFillLayers(paintInfo);
1375         return;
1376     }
1377 
1378     if (!paintsOwnBackground())
1379         return;
1380 
1381     if (backgroundIsKnownToBeObscured(paintRect.location()) &amp;&amp; !boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1382         return;
1383 
<span class="line-modified">1384     Color backgroundColor = style().visitedDependentColor(CSSPropertyBackgroundColor);</span>
<span class="line-modified">1385 </span>
<span class="line-removed">1386     CompositeOperator compositeOp = CompositeSourceOver;</span>
<span class="line-removed">1387     if (document().settings().punchOutWhiteBackgroundsInDarkMode() &amp;&amp; Color::isWhiteColor(backgroundColor) &amp;&amp; useDarkAppearance())</span>
<span class="line-removed">1388         compositeOp = CompositeDestinationOut;</span>
1389 
1390     paintFillLayers(paintInfo, style().colorByApplyingColorFilter(backgroundColor), style().backgroundLayers(), paintRect, bleedAvoidance, compositeOp);
1391 }
1392 
1393 bool RenderBox::getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp; paintedExtent) const
1394 {
1395     ASSERT(hasBackground());
1396     LayoutRect backgroundRect = snappedIntRect(borderBoxRect());
1397 
1398     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1399     if (backgroundColor.isVisible()) {
1400         paintedExtent = backgroundRect;
1401         return true;
1402     }
1403 
1404     auto&amp; layers = style().backgroundLayers();
1405     if (!layers.image() || layers.next()) {
1406         paintedExtent =  backgroundRect;
1407         return true;
1408     }
</pre>
<hr />
<pre>
1680     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1681         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data())
1682             return true;
1683     }
1684     return false;
1685 }
1686 
1687 void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)
1688 {
1689     if (!parent())
1690         return;
1691 
1692     if ((style().borderImage().image() &amp;&amp; style().borderImage().image()-&gt;data() == image) ||
1693         (style().maskBoxImage().image() &amp;&amp; style().maskBoxImage().image()-&gt;data() == image)) {
1694         repaint();
1695         return;
1696     }
1697 
1698     ShapeValue* shapeOutsideValue = style().shapeOutside();
1699     if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<span class="line-modified">1700         ShapeOutsideInfo&amp; info = ShapeOutsideInfo::ensureInfo(*this);</span>
<span class="line-modified">1701         if (!info.isComputingShape()) {</span>
<span class="line-modified">1702             info.markShapeAsDirty();</span>
<span class="line-removed">1703             markShapeOutsideDependentsForLayout();</span>
<span class="line-removed">1704         }</span>
<span class="line-removed">1705      }</span>
1706 
1707     bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
1708     if (!didFullRepaint)
1709         repaintLayerRectsForImage(image, style().maskLayers(), false);
1710 
1711     if (!isComposited())
1712         return;
1713 
1714     if (layer()-&gt;hasCompositedMask() &amp;&amp; layersUseImage(image, style().maskLayers()))
1715         layer()-&gt;contentChanged(MaskImageChanged);
1716     if (layersUseImage(image, style().backgroundLayers()))
1717         layer()-&gt;contentChanged(BackgroundImageChanged);
1718 }
1719 
1720 bool RenderBox::repaintLayerRectsForImage(WrappedImagePtr image, const FillLayer&amp; layers, bool drawingBackground)
1721 {
1722     LayoutRect rendererRect;
1723     RenderBox* layerRenderer = nullptr;
1724 
1725     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
</pre>
<hr />
<pre>
1785 
1786     bool isControlClip = hasControlClip();
1787     bool isOverflowClip = hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer();
1788 
1789     if (!isControlClip &amp;&amp; !isOverflowClip)
1790         return false;
1791 
1792     if (paintInfo.phase == PaintPhase::Outline)
1793         paintInfo.phase = PaintPhase::ChildOutlines;
1794     else if (paintInfo.phase == PaintPhase::ChildBlockBackground) {
1795         paintInfo.phase = PaintPhase::BlockBackground;
1796         paintObject(paintInfo, accumulatedOffset);
1797         paintInfo.phase = PaintPhase::ChildBlockBackgrounds;
1798     }
1799     float deviceScaleFactor = document().deviceScaleFactor();
1800     FloatRect clipRect = snapRectToDevicePixels((isControlClip ? controlClipRect(accumulatedOffset) : overflowClipRect(accumulatedOffset, nullptr, IgnoreOverlayScrollbarSize, paintInfo.phase)), deviceScaleFactor);
1801     paintInfo.context().save();
1802     if (style().hasBorderRadius())
1803         paintInfo.context().clipRoundedRect(style().getRoundedInnerBorderFor(LayoutRect(accumulatedOffset, size())).pixelSnappedRoundedRectForPainting(deviceScaleFactor));
1804     paintInfo.context().clip(clipRect);




1805     return true;
1806 }
1807 
1808 void RenderBox::popContentsClip(PaintInfo&amp; paintInfo, PaintPhase originalPhase, const LayoutPoint&amp; accumulatedOffset)
1809 {
1810     ASSERT(hasControlClip() || (hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer()));
1811 



1812     paintInfo.context().restore();
1813     if (originalPhase == PaintPhase::Outline) {
1814         paintInfo.phase = PaintPhase::SelfOutline;
1815         paintObject(paintInfo, accumulatedOffset);
1816         paintInfo.phase = originalPhase;
1817     } else if (originalPhase == PaintPhase::ChildBlockBackground)
1818         paintInfo.phase = originalPhase;
1819 }
1820 
1821 LayoutRect RenderBox::overflowClipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment, OverlayScrollbarSizeRelevancy relevancy, PaintPhase)
1822 {
1823     // FIXME: When overflow-clip (CSS3) is implemented, we&#39;ll obtain the property
1824     // here.
1825     LayoutRect clipRect = borderBoxRectInFragment(fragment);
1826     clipRect.setLocation(location + clipRect.location() + LayoutSize(borderLeft(), borderTop()));
1827     clipRect.setSize(clipRect.size() - LayoutSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
1828 
1829     // Subtract out scrollbars if we have them.
1830     if (layer()) {
1831         if (shouldPlaceBlockDirectionScrollbarOnLeft())
</pre>
<hr />
<pre>
2096     if (isInFlowPositioned())
2097         offset += offsetForInFlowPosition();
2098 
2099     if (!isInline() || isReplaced())
2100         offset += topLeftLocationOffset();
2101 
2102     if (is&lt;RenderBox&gt;(container))
2103         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
2104 
2105     if (isAbsolutelyPositioned() &amp;&amp; container.isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(container))
2106         offset += downcast&lt;RenderInline&gt;(container).offsetForInFlowPositionedInline(this);
2107 
2108     if (offsetDependsOnPoint)
2109         *offsetDependsOnPoint |= is&lt;RenderFragmentedFlow&gt;(container);
2110 
2111     return offset;
2112 }
2113 
2114 std::unique_ptr&lt;InlineElementBox&gt; RenderBox::createInlineBox()
2115 {
<span class="line-modified">2116     return std::make_unique&lt;InlineElementBox&gt;(*this);</span>
2117 }
2118 
2119 void RenderBox::dirtyLineBoxes(bool fullLayout)
2120 {
2121     if (!m_inlineBoxWrapper)
2122         return;
2123 
2124     if (fullLayout) {
2125         delete m_inlineBoxWrapper;
2126         m_inlineBoxWrapper = nullptr;
2127     } else
2128         m_inlineBoxWrapper-&gt;dirtyLineBoxes();
2129 }
2130 
2131 void RenderBox::positionLineBox(InlineElementBox&amp; box)
2132 {
2133     if (isOutOfFlowPositioned()) {
2134         // Cache the x position only if we were an DisplayType::Inline type originally.
2135         bool wasInline = style().isOriginalDisplayInlineType();
2136         if (wasInline) {
2137             // The value is cached in the xPos of the box.  We only need this value if
2138             // our object was inline originally, since otherwise it would have ended up underneath
2139             // the inlines.
2140             RootInlineBox&amp; rootBox = box.root();
2141             rootBox.blockFlow().setStaticInlinePositionForChild(*this, rootBox.lineTopWithLeading(), LayoutUnit::fromFloatRound(box.logicalLeft()));
2142             if (style().hasStaticInlinePosition(box.isHorizontal()))
2143                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2144         } else {
2145             // Our object was a block originally, so we make our normal flow position be
2146             // just below the line box (as though all the inlines that came before us got
2147             // wrapped in an anonymous block, which is what would have happened had we been
2148             // in flow).  This value was cached in the y() of the box.
<span class="line-modified">2149             layer()-&gt;setStaticBlockPosition(box.logicalTop());</span>
2150             if (style().hasStaticBlockPosition(box.isHorizontal()))
2151                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2152         }
2153         return;
2154     }
2155 
2156     if (isReplaced()) {
2157         setLocation(LayoutPoint(box.topLeft()));
2158         setInlineBoxWrapper(&amp;box);
2159     }
2160 }
2161 
2162 void RenderBox::deleteLineBoxWrapper()
2163 {
2164     if (!m_inlineBoxWrapper)
2165         return;
2166 
2167     if (!renderTreeBeingDestroyed())
2168         m_inlineBoxWrapper-&gt;removeFromParent();
2169     delete m_inlineBoxWrapper;
</pre>
<hr />
<pre>
2380     // https://bugs.webkit.org/show_bug.cgi?id=46418
2381     bool inVerticalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Vertical);
2382     bool stretching = (parent()-&gt;style().boxAlign() == BoxAlignment::Stretch);
2383     // FIXME: Stretching is the only reason why we don&#39;t want the box to be treated as a replaced element, so we could perhaps
2384     // refactor all this logic, not only for flex and grid since alignment is intended to be applied to any block.
2385     bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inVerticalBox || !stretching);
2386     treatAsReplaced = treatAsReplaced &amp;&amp; (!isGridItem() || !hasStretchedLogicalWidth());
2387 
2388     const RenderStyle&amp; styleToUse = style();
2389     Length logicalWidthLength = treatAsReplaced ? Length(computeReplacedLogicalWidth(), Fixed) : styleToUse.logicalWidth();
2390 
2391     RenderBlock&amp; cb = *containingBlock();
2392     LayoutUnit containerLogicalWidth = std::max&lt;LayoutUnit&gt;(0, containingBlockLogicalWidthForContentInFragment(fragment));
2393     bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2394 
2395     if (isInline() &amp;&amp; !isInlineBlockOrInlineTable()) {
2396         // just calculate margins
2397         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2398         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2399         if (treatAsReplaced)
<span class="line-modified">2400             computedValues.m_extent = std::max&lt;LayoutUnit&gt;(floatValueForLength(logicalWidthLength, 0) + borderAndPaddingLogicalWidth(), minPreferredLogicalWidth());</span>
2401         return;
2402     }
2403 
2404     LayoutUnit containerWidthInInlineDirection = containerLogicalWidth;
2405     if (hasPerpendicularContainingBlock)
2406         containerWidthInInlineDirection = perpendicularContainingBlockLogicalHeight();
2407 
2408     // Width calculations
2409     if (treatAsReplaced) {
2410         computedValues.m_extent = logicalWidthLength.value() + borderAndPaddingLogicalWidth();
2411     } else {
2412         LayoutUnit preferredWidth = computeLogicalWidthInFragmentUsing(MainOrPreferredSize, styleToUse.logicalWidth(), containerWidthInInlineDirection, cb, fragment);
2413         computedValues.m_extent = constrainLogicalWidthInFragmentByMinMax(preferredWidth, containerWidthInInlineDirection, cb, fragment);
2414     }
2415 
2416     // Margin calculations.
2417     if (hasPerpendicularContainingBlock || isFloating() || isInline()) {
2418         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2419         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2420     } else {
</pre>
<hr />
<pre>
4495     if (closestRenderer)
4496         return closestRenderer-&gt;positionForPoint(adjustedPoint - closestRenderer-&gt;locationOffset(), fragment);
4497 
4498     return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4499 }
4500 
4501 bool RenderBox::shrinkToAvoidFloats() const
4502 {
4503     // Floating objects don&#39;t shrink.  Objects that don&#39;t avoid floats don&#39;t shrink.  Marquees don&#39;t shrink.
4504     if ((isInline() &amp;&amp; !isHTMLMarquee()) || !avoidsFloats() || isFloating())
4505         return false;
4506 
4507     // Only auto width objects can possibly shrink to avoid floats.
4508     return style().width().isAuto();
4509 }
4510 
4511 bool RenderBox::createsNewFormattingContext() const
4512 {
4513     return isInlineBlockOrInlineTable() || isFloatingOrOutOfFlowPositioned() || hasOverflowClip() || isFlexItemIncludingDeprecated()
4514         || isTableCell() || isTableCaption() || isFieldset() || isWritingModeRoot() || isDocumentElementRenderer() || isRenderFragmentedFlow() || isRenderFragmentContainer()
<span class="line-modified">4515         || isGridItem() || style().specifiesColumns() || style().columnSpan() == ColumnSpan::All;</span>
4516 }
4517 
4518 bool RenderBox::avoidsFloats() const
4519 {
4520     return isReplaced() || isHR() || isLegend() || isFieldset() || createsNewFormattingContext();
4521 }
4522 
4523 void RenderBox::addVisualEffectOverflow()
4524 {
4525     if (!style().boxShadow() &amp;&amp; !style().hasBorderImageOutsets() &amp;&amp; !outlineStyleForRepaint().hasOutlineInVisualOverflow())
4526         return;
4527 
4528     addVisualOverflow(applyVisualEffectOverflow(borderBoxRect()));
4529 
4530     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4531     if (fragmentedFlow)
4532         fragmentedFlow-&gt;addFragmentsVisualEffectOverflow(this);
4533 }
4534 
4535 LayoutRect RenderBox::applyVisualEffectOverflow(const LayoutRect&amp; borderBox) const
</pre>
<hr />
<pre>
4553         // In flipped blocks writing modes such as vertical-rl, the physical right shadow value is actually at the lower x-coordinate.
4554         overflowMinX = borderBox.x() + ((!isFlipped || isHorizontal) ? shadowLeft : -shadowRight);
4555         overflowMaxX = borderBox.maxX() + ((!isFlipped || isHorizontal) ? shadowRight : -shadowLeft);
4556         overflowMinY = borderBox.y() + ((!isFlipped || !isHorizontal) ? shadowTop : -shadowBottom);
4557         overflowMaxY = borderBox.maxY() + ((!isFlipped || !isHorizontal) ? shadowBottom : -shadowTop);
4558     }
4559 
4560     // Now compute border-image-outset overflow.
4561     if (style().hasBorderImageOutsets()) {
4562         LayoutBoxExtent borderOutsets = style().borderImageOutsets();
4563 
4564         // In flipped blocks writing modes, the physical sides are inverted. For example in vertical-rl, the right
4565         // border is at the lower x coordinate value.
4566         overflowMinX = std::min(overflowMinX, borderBox.x() - ((!isFlipped || isHorizontal) ? borderOutsets.left() : borderOutsets.right()));
4567         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + ((!isFlipped || isHorizontal) ? borderOutsets.right() : borderOutsets.left()));
4568         overflowMinY = std::min(overflowMinY, borderBox.y() - ((!isFlipped || !isHorizontal) ? borderOutsets.top() : borderOutsets.bottom()));
4569         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + ((!isFlipped || !isHorizontal) ? borderOutsets.bottom() : borderOutsets.top()));
4570     }
4571 
4572     if (outlineStyleForRepaint().hasOutlineInVisualOverflow()) {
<span class="line-modified">4573         LayoutUnit outlineSize = outlineStyleForRepaint().outlineSize();</span>
4574         overflowMinX = std::min(overflowMinX, borderBox.x() - outlineSize);
4575         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + outlineSize);
4576         overflowMinY = std::min(overflowMinY, borderBox.y() - outlineSize);
4577         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + outlineSize);
4578     }
4579     // Add in the final overflow with shadows and outsets combined.
4580     return LayoutRect(overflowMinX, overflowMinY, overflowMaxX - overflowMinX, overflowMaxY - overflowMinY);
4581 }
4582 
4583 void RenderBox::addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta)
4584 {
4585     // Never allow flow threads to propagate overflow up to a parent.
4586     if (child-&gt;isRenderFragmentedFlow())
4587         return;
4588 
4589     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4590     if (fragmentedFlow)
4591         fragmentedFlow-&gt;addFragmentsOverflowFromChild(this, child, delta);
4592 
4593     // Only propagate layout overflow from the child if the child isn&#39;t clipping its overflow.  If it is, then
</pre>
</td>
<td>
<hr />
<pre>
 101 // FIXME: We should store these based on physical direction.
 102 typedef WTF::HashMap&lt;const RenderBox*, Optional&lt;LayoutUnit&gt;&gt; OverrideOptionalSizeMap;
 103 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalHeightMap = nullptr;
 104 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalWidthMap = nullptr;
 105 
 106 // Size of border belt for autoscroll. When mouse pointer in border belt,
 107 // autoscroll is started.
 108 static const int autoscrollBeltSize = 20;
 109 static const unsigned backgroundObscurationTestMaxDepth = 4;
 110 
 111 using ControlStatesRendererMap = HashMap&lt;const RenderObject*, std::unique_ptr&lt;ControlStates&gt;&gt;;
 112 static ControlStatesRendererMap&amp; controlStatesRendererMap()
 113 {
 114     static NeverDestroyed&lt;ControlStatesRendererMap&gt; map;
 115     return map;
 116 }
 117 
 118 static ControlStates* controlStatesForRenderer(const RenderBox&amp; renderer)
 119 {
 120     return controlStatesRendererMap().ensure(&amp;renderer, [] {
<span class="line-modified"> 121         return makeUnique&lt;ControlStates&gt;();</span>
 122     }).iterator-&gt;value.get();
 123 }
 124 
 125 static void removeControlStatesForRenderer(const RenderBox&amp; renderer)
 126 {
 127     controlStatesRendererMap().remove(&amp;renderer);
 128 }
 129 
 130 bool RenderBox::s_hadOverflowClip = false;
 131 
 132 RenderBox::RenderBox(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 133     : RenderBoxModelObject(element, WTFMove(style), baseTypeFlags)
 134 {
 135     setIsBox();
 136 }
 137 
 138 RenderBox::RenderBox(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 139     : RenderBoxModelObject(document, WTFMove(style), baseTypeFlags)
 140 {
 141     setIsBox();
</pre>
<hr />
<pre>
 558 }
 559 
 560 int RenderBox::scrollLeft() const
 561 {
 562     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().x() : 0;
 563 }
 564 
 565 int RenderBox::scrollTop() const
 566 {
 567     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
 568 }
 569 
 570 static void setupWheelEventTestTrigger(RenderLayer&amp; layer)
 571 {
 572     Page&amp; page = layer.renderer().page();
 573     if (!page.expectsWheelEventTriggers())
 574         return;
 575     layer.scrollAnimator().setWheelEventTestTrigger(page.testTrigger());
 576 }
 577 
<span class="line-modified"> 578 void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)</span>
 579 {
 580     if (!hasOverflowClip() || !layer())
 581         return;
 582     setupWheelEventTestTrigger(*layer());
<span class="line-modified"> 583     layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);</span>
 584 }
 585 
<span class="line-modified"> 586 void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)</span>
 587 {
 588     if (!hasOverflowClip() || !layer())
 589         return;
 590     setupWheelEventTestTrigger(*layer());
<span class="line-modified"> 591     layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);</span>
 592 }
 593 
 594 void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 595 {
 596     rects.append(snappedIntRect(accumulatedOffset, size()));
 597 }
 598 
 599 void RenderBox::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 600 {
 601     FloatRect localRect(0, 0, width(), height());
 602 
 603     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 604     if (fragmentedFlow &amp;&amp; fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
 605         return;
 606 
 607     quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
 608 }
 609 
 610 void RenderBox::updateLayerTransform()
 611 {
</pre>
<hr />
<pre>
 641         if (Optional&lt;LayoutUnit&gt; maxH = computeContentLogicalHeight(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 642             logicalHeight = std::min(logicalHeight, maxH.value());
 643     }
 644     if (Optional&lt;LayoutUnit&gt; computedContentLogicalHeight = computeContentLogicalHeight(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 645         return std::max(logicalHeight, computedContentLogicalHeight.value());
 646     return logicalHeight;
 647 }
 648 
 649 RoundedRect::Radii RenderBox::borderRadii() const
 650 {
 651     auto&amp; style = this-&gt;style();
 652     LayoutRect bounds = frameRect();
 653 
 654     unsigned borderLeft = style.borderLeftWidth();
 655     unsigned borderTop = style.borderTopWidth();
 656     bounds.moveBy(LayoutPoint(borderLeft, borderTop));
 657     bounds.contract(borderLeft + style.borderRightWidth(), borderTop + style.borderBottomWidth());
 658     return style.getRoundedBorderFor(bounds).radii();
 659 }
 660 
<span class="line-added"> 661 LayoutRect RenderBox::paddingBoxRect() const</span>
<span class="line-added"> 662 {</span>
<span class="line-added"> 663     auto verticalScrollbarWidth = this-&gt;verticalScrollbarWidth();</span>
<span class="line-added"> 664     LayoutUnit offsetForScrollbar = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth : 0;</span>
<span class="line-added"> 665 </span>
<span class="line-added"> 666     return LayoutRect(borderLeft() + offsetForScrollbar, borderTop(),</span>
<span class="line-added"> 667         width() - borderLeft() - borderRight() - verticalScrollbarWidth,</span>
<span class="line-added"> 668         height() - borderTop() - borderBottom() - horizontalScrollbarHeight());</span>
<span class="line-added"> 669 }</span>
<span class="line-added"> 670 </span>
 671 LayoutRect RenderBox::contentBoxRect() const
 672 {
 673     return { contentBoxLocation(), contentSize() };
 674 }
 675 
 676 LayoutPoint RenderBox::contentBoxLocation() const
 677 {
 678     LayoutUnit scrollbarSpace = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth() : 0;
 679     return { borderLeft() + paddingLeft() + scrollbarSpace, borderTop() + paddingTop() };
 680 }
 681 
 682 IntRect RenderBox::absoluteContentBox() const
 683 {
 684     // This is wrong with transforms and flipped writing modes.
 685     IntRect rect = snappedIntRect(contentBoxRect());
 686     FloatPoint absPos = localToAbsolute();
 687     rect.move(absPos.x(), absPos.y());
 688     return rect;
 689 }
 690 
</pre>
<hr />
<pre>
 976 
 977     ASSERT(hasLayer());
 978     return layer()-&gt;scrollPosition();
 979 }
 980 
 981 LayoutSize RenderBox::cachedSizeForOverflowClip() const
 982 {
 983     ASSERT(hasOverflowClip());
 984     ASSERT(hasLayer());
 985     return layer()-&gt;size();
 986 }
 987 
 988 bool RenderBox::applyCachedClipAndScrollPosition(LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 989 {
 990     flipForWritingMode(rect);
 991 
 992     if (context.m_options.contains(VisibleRectContextOption::ApplyCompositedContainerScrolls) || this != container || !usesCompositedScrolling())
 993         rect.moveBy(-scrollPosition()); // For overflow:auto/scroll/hidden.
 994 
 995     // Do not clip scroll layer contents to reduce the number of repaints while scrolling.
<span class="line-modified"> 996     if ((!context.m_options.contains(VisibleRectContextOption::ApplyCompositedClips) &amp;&amp; usesCompositedScrolling())</span>
<span class="line-added"> 997         || (!context.m_options.contains(VisibleRectContextOption::ApplyContainerClip) &amp;&amp; this == container)) {</span>
 998         flipForWritingMode(rect);
 999         return true;
1000     }
1001 
1002     // height() is inaccurate if we&#39;re in the middle of a layout of this RenderBox, so use the
1003     // layer&#39;s size instead. Even if the layer&#39;s size is wrong, the layer itself will repaint
1004     // anyway if its size does change.
1005     LayoutRect clipRect(LayoutPoint(), cachedSizeForOverflowClip());
1006     bool intersects;
1007     if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
1008         intersects = rect.edgeInclusiveIntersect(clipRect);
1009     else {
1010         rect.intersect(clipRect);
1011         intersects = !rect.isEmpty();
1012     }
1013     flipForWritingMode(rect);
1014     return intersects;
1015 }
1016 
1017 void RenderBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
</pre>
<hr />
<pre>
1240         if (result.addNodeToListBasedTestResult(element(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
1241             return true;
1242     }
1243 
1244     return false;
1245 }
1246 
1247 // --------------------- painting stuff -------------------------------
1248 
1249 void RenderBox::paintRootBoxFillLayers(const PaintInfo&amp; paintInfo)
1250 {
1251     ASSERT(isDocumentElementRenderer());
1252     if (paintInfo.skipRootBackground())
1253         return;
1254 
1255     auto* rootBackgroundRenderer = view().rendererForRootBackground();
1256     if (!rootBackgroundRenderer)
1257         return;
1258 
1259     auto&amp; style = rootBackgroundRenderer-&gt;style();

1260     auto color = style.visitedDependentColor(CSSPropertyBackgroundColor);
<span class="line-modified">1261     auto compositeOp = document().compositeOperatorForBackgroundColor(color, *this);</span>



1262 
1263     paintFillLayers(paintInfo, style.colorByApplyingColorFilter(color), style.backgroundLayers(), view().backgroundRect(), BackgroundBleedNone, compositeOp, rootBackgroundRenderer);
1264 }
1265 
1266 BackgroundBleedAvoidance RenderBox::determineBackgroundBleedAvoidance(GraphicsContext&amp; context) const
1267 {
1268     if (context.paintingDisabled())
1269         return BackgroundBleedNone;
1270 
1271     const RenderStyle&amp; style = this-&gt;style();
1272 
1273     if (!style.hasBackground() || !style.hasBorder() || !style.hasBorderRadius() || borderImageIsLoadedAndCanBeRendered())
1274         return BackgroundBleedNone;
1275 
1276     AffineTransform ctm = context.getCTM();
1277     FloatSize contextScaling(static_cast&lt;float&gt;(ctm.xScale()), static_cast&lt;float&gt;(ctm.yScale()));
1278 
1279     // Because RoundedRect uses IntRect internally the inset applied by the
1280     // BackgroundBleedShrinkBackground strategy cannot be less than one integer
1281     // layout coordinate, even with subpixel layout enabled. To take that into
</pre>
<hr />
<pre>
1292 
1293     if (borderObscuresBackgroundEdge(contextScaling))
1294         return BackgroundBleedShrinkBackground;
1295     if (!style.hasAppearance() &amp;&amp; borderObscuresBackground() &amp;&amp; backgroundHasOpaqueTopLayer())
1296         return BackgroundBleedBackgroundOverBorder;
1297 
1298     return BackgroundBleedUseTransparencyLayer;
1299 }
1300 
1301 void RenderBox::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1302 {
1303     if (!paintInfo.shouldPaintWithinRoot(*this))
1304         return;
1305 
1306     LayoutRect paintRect = borderBoxRectInFragment(nullptr);
1307     paintRect.moveBy(paintOffset);
1308     adjustBorderBoxRectForPainting(paintRect);
1309 
1310 #if PLATFORM(IOS_FAMILY)
1311     // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
<span class="line-added">1312     // FIXME: Consolidate this code with the same code in RenderElement::paintOutline(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.</span>
1313     if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1314         int width = std::min(paintRect.width(), paintRect.height());
1315         int height = width;
<span class="line-modified">1316         paintRect = IntRect { paintRect.x(), paintRect.y() + (this-&gt;height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop</span>
1317     }
1318 #endif
1319     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
1320 
1321     // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
1322     // custom shadows of their own.
1323     if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1324         paintBoxShadow(paintInfo, paintRect, style(), Normal);
1325 
1326     GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
1327     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
1328         // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
1329         // into a transparency layer, and then clip that in one go (which requires setting up the clip before
1330         // beginning the layer).
1331         stateSaver.save();
1332         paintInfo.context().clipRoundedRect(style().getRoundedBorderFor(paintRect).pixelSnappedRoundedRectForPainting(document().deviceScaleFactor()));
1333         paintInfo.context().beginTransparencyLayer(1);
1334     }
1335 
1336     // If we have a native theme appearance, paint that before painting our background.
</pre>
<hr />
<pre>
1372             || documentElementRenderer-&gt;hasBackground()
1373             || (documentElementRenderer != parent());
1374     }
1375 
1376     return true;
1377 }
1378 
1379 void RenderBox::paintBackground(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect, BackgroundBleedAvoidance bleedAvoidance)
1380 {
1381     if (isDocumentElementRenderer()) {
1382         paintRootBoxFillLayers(paintInfo);
1383         return;
1384     }
1385 
1386     if (!paintsOwnBackground())
1387         return;
1388 
1389     if (backgroundIsKnownToBeObscured(paintRect.location()) &amp;&amp; !boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1390         return;
1391 
<span class="line-modified">1392     auto backgroundColor = style().visitedDependentColor(CSSPropertyBackgroundColor);</span>
<span class="line-modified">1393     auto compositeOp = document().compositeOperatorForBackgroundColor(backgroundColor, *this);</span>



1394 
1395     paintFillLayers(paintInfo, style().colorByApplyingColorFilter(backgroundColor), style().backgroundLayers(), paintRect, bleedAvoidance, compositeOp);
1396 }
1397 
1398 bool RenderBox::getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp; paintedExtent) const
1399 {
1400     ASSERT(hasBackground());
1401     LayoutRect backgroundRect = snappedIntRect(borderBoxRect());
1402 
1403     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1404     if (backgroundColor.isVisible()) {
1405         paintedExtent = backgroundRect;
1406         return true;
1407     }
1408 
1409     auto&amp; layers = style().backgroundLayers();
1410     if (!layers.image() || layers.next()) {
1411         paintedExtent =  backgroundRect;
1412         return true;
1413     }
</pre>
<hr />
<pre>
1685     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1686         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data())
1687             return true;
1688     }
1689     return false;
1690 }
1691 
1692 void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)
1693 {
1694     if (!parent())
1695         return;
1696 
1697     if ((style().borderImage().image() &amp;&amp; style().borderImage().image()-&gt;data() == image) ||
1698         (style().maskBoxImage().image() &amp;&amp; style().maskBoxImage().image()-&gt;data() == image)) {
1699         repaint();
1700         return;
1701     }
1702 
1703     ShapeValue* shapeOutsideValue = style().shapeOutside();
1704     if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<span class="line-modified">1705         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();</span>
<span class="line-modified">1706         markShapeOutsideDependentsForLayout();</span>
<span class="line-modified">1707     }</span>



1708 
1709     bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
1710     if (!didFullRepaint)
1711         repaintLayerRectsForImage(image, style().maskLayers(), false);
1712 
1713     if (!isComposited())
1714         return;
1715 
1716     if (layer()-&gt;hasCompositedMask() &amp;&amp; layersUseImage(image, style().maskLayers()))
1717         layer()-&gt;contentChanged(MaskImageChanged);
1718     if (layersUseImage(image, style().backgroundLayers()))
1719         layer()-&gt;contentChanged(BackgroundImageChanged);
1720 }
1721 
1722 bool RenderBox::repaintLayerRectsForImage(WrappedImagePtr image, const FillLayer&amp; layers, bool drawingBackground)
1723 {
1724     LayoutRect rendererRect;
1725     RenderBox* layerRenderer = nullptr;
1726 
1727     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
</pre>
<hr />
<pre>
1787 
1788     bool isControlClip = hasControlClip();
1789     bool isOverflowClip = hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer();
1790 
1791     if (!isControlClip &amp;&amp; !isOverflowClip)
1792         return false;
1793 
1794     if (paintInfo.phase == PaintPhase::Outline)
1795         paintInfo.phase = PaintPhase::ChildOutlines;
1796     else if (paintInfo.phase == PaintPhase::ChildBlockBackground) {
1797         paintInfo.phase = PaintPhase::BlockBackground;
1798         paintObject(paintInfo, accumulatedOffset);
1799         paintInfo.phase = PaintPhase::ChildBlockBackgrounds;
1800     }
1801     float deviceScaleFactor = document().deviceScaleFactor();
1802     FloatRect clipRect = snapRectToDevicePixels((isControlClip ? controlClipRect(accumulatedOffset) : overflowClipRect(accumulatedOffset, nullptr, IgnoreOverlayScrollbarSize, paintInfo.phase)), deviceScaleFactor);
1803     paintInfo.context().save();
1804     if (style().hasBorderRadius())
1805         paintInfo.context().clipRoundedRect(style().getRoundedInnerBorderFor(LayoutRect(accumulatedOffset, size())).pixelSnappedRoundedRectForPainting(deviceScaleFactor));
1806     paintInfo.context().clip(clipRect);
<span class="line-added">1807 </span>
<span class="line-added">1808     if (paintInfo.phase == PaintPhase::EventRegion)</span>
<span class="line-added">1809         paintInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(clipRect));</span>
<span class="line-added">1810 </span>
1811     return true;
1812 }
1813 
1814 void RenderBox::popContentsClip(PaintInfo&amp; paintInfo, PaintPhase originalPhase, const LayoutPoint&amp; accumulatedOffset)
1815 {
1816     ASSERT(hasControlClip() || (hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer()));
1817 
<span class="line-added">1818     if (paintInfo.phase == PaintPhase::EventRegion)</span>
<span class="line-added">1819         paintInfo.eventRegionContext-&gt;popClip();</span>
<span class="line-added">1820 </span>
1821     paintInfo.context().restore();
1822     if (originalPhase == PaintPhase::Outline) {
1823         paintInfo.phase = PaintPhase::SelfOutline;
1824         paintObject(paintInfo, accumulatedOffset);
1825         paintInfo.phase = originalPhase;
1826     } else if (originalPhase == PaintPhase::ChildBlockBackground)
1827         paintInfo.phase = originalPhase;
1828 }
1829 
1830 LayoutRect RenderBox::overflowClipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment, OverlayScrollbarSizeRelevancy relevancy, PaintPhase)
1831 {
1832     // FIXME: When overflow-clip (CSS3) is implemented, we&#39;ll obtain the property
1833     // here.
1834     LayoutRect clipRect = borderBoxRectInFragment(fragment);
1835     clipRect.setLocation(location + clipRect.location() + LayoutSize(borderLeft(), borderTop()));
1836     clipRect.setSize(clipRect.size() - LayoutSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
1837 
1838     // Subtract out scrollbars if we have them.
1839     if (layer()) {
1840         if (shouldPlaceBlockDirectionScrollbarOnLeft())
</pre>
<hr />
<pre>
2105     if (isInFlowPositioned())
2106         offset += offsetForInFlowPosition();
2107 
2108     if (!isInline() || isReplaced())
2109         offset += topLeftLocationOffset();
2110 
2111     if (is&lt;RenderBox&gt;(container))
2112         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
2113 
2114     if (isAbsolutelyPositioned() &amp;&amp; container.isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(container))
2115         offset += downcast&lt;RenderInline&gt;(container).offsetForInFlowPositionedInline(this);
2116 
2117     if (offsetDependsOnPoint)
2118         *offsetDependsOnPoint |= is&lt;RenderFragmentedFlow&gt;(container);
2119 
2120     return offset;
2121 }
2122 
2123 std::unique_ptr&lt;InlineElementBox&gt; RenderBox::createInlineBox()
2124 {
<span class="line-modified">2125     return makeUnique&lt;InlineElementBox&gt;(*this);</span>
2126 }
2127 
2128 void RenderBox::dirtyLineBoxes(bool fullLayout)
2129 {
2130     if (!m_inlineBoxWrapper)
2131         return;
2132 
2133     if (fullLayout) {
2134         delete m_inlineBoxWrapper;
2135         m_inlineBoxWrapper = nullptr;
2136     } else
2137         m_inlineBoxWrapper-&gt;dirtyLineBoxes();
2138 }
2139 
2140 void RenderBox::positionLineBox(InlineElementBox&amp; box)
2141 {
2142     if (isOutOfFlowPositioned()) {
2143         // Cache the x position only if we were an DisplayType::Inline type originally.
2144         bool wasInline = style().isOriginalDisplayInlineType();
2145         if (wasInline) {
2146             // The value is cached in the xPos of the box.  We only need this value if
2147             // our object was inline originally, since otherwise it would have ended up underneath
2148             // the inlines.
2149             RootInlineBox&amp; rootBox = box.root();
2150             rootBox.blockFlow().setStaticInlinePositionForChild(*this, rootBox.lineTopWithLeading(), LayoutUnit::fromFloatRound(box.logicalLeft()));
2151             if (style().hasStaticInlinePosition(box.isHorizontal()))
2152                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2153         } else {
2154             // Our object was a block originally, so we make our normal flow position be
2155             // just below the line box (as though all the inlines that came before us got
2156             // wrapped in an anonymous block, which is what would have happened had we been
2157             // in flow).  This value was cached in the y() of the box.
<span class="line-modified">2158             layer()-&gt;setStaticBlockPosition(LayoutUnit(box.logicalTop()));</span>
2159             if (style().hasStaticBlockPosition(box.isHorizontal()))
2160                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2161         }
2162         return;
2163     }
2164 
2165     if (isReplaced()) {
2166         setLocation(LayoutPoint(box.topLeft()));
2167         setInlineBoxWrapper(&amp;box);
2168     }
2169 }
2170 
2171 void RenderBox::deleteLineBoxWrapper()
2172 {
2173     if (!m_inlineBoxWrapper)
2174         return;
2175 
2176     if (!renderTreeBeingDestroyed())
2177         m_inlineBoxWrapper-&gt;removeFromParent();
2178     delete m_inlineBoxWrapper;
</pre>
<hr />
<pre>
2389     // https://bugs.webkit.org/show_bug.cgi?id=46418
2390     bool inVerticalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Vertical);
2391     bool stretching = (parent()-&gt;style().boxAlign() == BoxAlignment::Stretch);
2392     // FIXME: Stretching is the only reason why we don&#39;t want the box to be treated as a replaced element, so we could perhaps
2393     // refactor all this logic, not only for flex and grid since alignment is intended to be applied to any block.
2394     bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inVerticalBox || !stretching);
2395     treatAsReplaced = treatAsReplaced &amp;&amp; (!isGridItem() || !hasStretchedLogicalWidth());
2396 
2397     const RenderStyle&amp; styleToUse = style();
2398     Length logicalWidthLength = treatAsReplaced ? Length(computeReplacedLogicalWidth(), Fixed) : styleToUse.logicalWidth();
2399 
2400     RenderBlock&amp; cb = *containingBlock();
2401     LayoutUnit containerLogicalWidth = std::max&lt;LayoutUnit&gt;(0, containingBlockLogicalWidthForContentInFragment(fragment));
2402     bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2403 
2404     if (isInline() &amp;&amp; !isInlineBlockOrInlineTable()) {
2405         // just calculate margins
2406         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2407         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2408         if (treatAsReplaced)
<span class="line-modified">2409             computedValues.m_extent = std::max(LayoutUnit(floatValueForLength(logicalWidthLength, 0) + borderAndPaddingLogicalWidth()), minPreferredLogicalWidth());</span>
2410         return;
2411     }
2412 
2413     LayoutUnit containerWidthInInlineDirection = containerLogicalWidth;
2414     if (hasPerpendicularContainingBlock)
2415         containerWidthInInlineDirection = perpendicularContainingBlockLogicalHeight();
2416 
2417     // Width calculations
2418     if (treatAsReplaced) {
2419         computedValues.m_extent = logicalWidthLength.value() + borderAndPaddingLogicalWidth();
2420     } else {
2421         LayoutUnit preferredWidth = computeLogicalWidthInFragmentUsing(MainOrPreferredSize, styleToUse.logicalWidth(), containerWidthInInlineDirection, cb, fragment);
2422         computedValues.m_extent = constrainLogicalWidthInFragmentByMinMax(preferredWidth, containerWidthInInlineDirection, cb, fragment);
2423     }
2424 
2425     // Margin calculations.
2426     if (hasPerpendicularContainingBlock || isFloating() || isInline()) {
2427         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2428         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2429     } else {
</pre>
<hr />
<pre>
4504     if (closestRenderer)
4505         return closestRenderer-&gt;positionForPoint(adjustedPoint - closestRenderer-&gt;locationOffset(), fragment);
4506 
4507     return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4508 }
4509 
4510 bool RenderBox::shrinkToAvoidFloats() const
4511 {
4512     // Floating objects don&#39;t shrink.  Objects that don&#39;t avoid floats don&#39;t shrink.  Marquees don&#39;t shrink.
4513     if ((isInline() &amp;&amp; !isHTMLMarquee()) || !avoidsFloats() || isFloating())
4514         return false;
4515 
4516     // Only auto width objects can possibly shrink to avoid floats.
4517     return style().width().isAuto();
4518 }
4519 
4520 bool RenderBox::createsNewFormattingContext() const
4521 {
4522     return isInlineBlockOrInlineTable() || isFloatingOrOutOfFlowPositioned() || hasOverflowClip() || isFlexItemIncludingDeprecated()
4523         || isTableCell() || isTableCaption() || isFieldset() || isWritingModeRoot() || isDocumentElementRenderer() || isRenderFragmentedFlow() || isRenderFragmentContainer()
<span class="line-modified">4524         || isGridItem() || style().specifiesColumns() || style().columnSpan() == ColumnSpan::All || style().display() == DisplayType::FlowRoot;</span>
4525 }
4526 
4527 bool RenderBox::avoidsFloats() const
4528 {
4529     return isReplaced() || isHR() || isLegend() || isFieldset() || createsNewFormattingContext();
4530 }
4531 
4532 void RenderBox::addVisualEffectOverflow()
4533 {
4534     if (!style().boxShadow() &amp;&amp; !style().hasBorderImageOutsets() &amp;&amp; !outlineStyleForRepaint().hasOutlineInVisualOverflow())
4535         return;
4536 
4537     addVisualOverflow(applyVisualEffectOverflow(borderBoxRect()));
4538 
4539     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4540     if (fragmentedFlow)
4541         fragmentedFlow-&gt;addFragmentsVisualEffectOverflow(this);
4542 }
4543 
4544 LayoutRect RenderBox::applyVisualEffectOverflow(const LayoutRect&amp; borderBox) const
</pre>
<hr />
<pre>
4562         // In flipped blocks writing modes such as vertical-rl, the physical right shadow value is actually at the lower x-coordinate.
4563         overflowMinX = borderBox.x() + ((!isFlipped || isHorizontal) ? shadowLeft : -shadowRight);
4564         overflowMaxX = borderBox.maxX() + ((!isFlipped || isHorizontal) ? shadowRight : -shadowLeft);
4565         overflowMinY = borderBox.y() + ((!isFlipped || !isHorizontal) ? shadowTop : -shadowBottom);
4566         overflowMaxY = borderBox.maxY() + ((!isFlipped || !isHorizontal) ? shadowBottom : -shadowTop);
4567     }
4568 
4569     // Now compute border-image-outset overflow.
4570     if (style().hasBorderImageOutsets()) {
4571         LayoutBoxExtent borderOutsets = style().borderImageOutsets();
4572 
4573         // In flipped blocks writing modes, the physical sides are inverted. For example in vertical-rl, the right
4574         // border is at the lower x coordinate value.
4575         overflowMinX = std::min(overflowMinX, borderBox.x() - ((!isFlipped || isHorizontal) ? borderOutsets.left() : borderOutsets.right()));
4576         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + ((!isFlipped || isHorizontal) ? borderOutsets.right() : borderOutsets.left()));
4577         overflowMinY = std::min(overflowMinY, borderBox.y() - ((!isFlipped || !isHorizontal) ? borderOutsets.top() : borderOutsets.bottom()));
4578         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + ((!isFlipped || !isHorizontal) ? borderOutsets.bottom() : borderOutsets.top()));
4579     }
4580 
4581     if (outlineStyleForRepaint().hasOutlineInVisualOverflow()) {
<span class="line-modified">4582         LayoutUnit outlineSize { outlineStyleForRepaint().outlineSize() };</span>
4583         overflowMinX = std::min(overflowMinX, borderBox.x() - outlineSize);
4584         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + outlineSize);
4585         overflowMinY = std::min(overflowMinY, borderBox.y() - outlineSize);
4586         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + outlineSize);
4587     }
4588     // Add in the final overflow with shadows and outsets combined.
4589     return LayoutRect(overflowMinX, overflowMinY, overflowMaxX - overflowMinX, overflowMaxY - overflowMinY);
4590 }
4591 
4592 void RenderBox::addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta)
4593 {
4594     // Never allow flow threads to propagate overflow up to a parent.
4595     if (child-&gt;isRenderFragmentedFlow())
4596         return;
4597 
4598     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4599     if (fragmentedFlow)
4600         fragmentedFlow-&gt;addFragmentsOverflowFromChild(this, child, delta);
4601 
4602     // Only propagate layout overflow from the child if the child isn&#39;t clipping its overflow.  If it is, then
</pre>
</td>
</tr>
</table>
<center><a href="RenderBlockFlow.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>