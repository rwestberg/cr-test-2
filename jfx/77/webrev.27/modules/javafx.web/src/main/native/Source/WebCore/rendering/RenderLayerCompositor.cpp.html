<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009, 2010 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerCompositor.h&quot;
  29 
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;ChromeClient.h&quot;
  35 #include &quot;DocumentTimeline.h&quot;
  36 #include &quot;Frame.h&quot;
  37 #include &quot;FrameView.h&quot;
  38 #include &quot;FullscreenManager.h&quot;
  39 #include &quot;GraphicsLayer.h&quot;
  40 #include &quot;HTMLCanvasElement.h&quot;
  41 #include &quot;HTMLIFrameElement.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;HitTestResult.h&quot;
  44 #include &quot;InspectorInstrumentation.h&quot;
  45 #include &quot;LayerAncestorClippingStack.h&quot;
  46 #include &quot;LayerOverlapMap.h&quot;
  47 #include &quot;Logging.h&quot;
  48 #include &quot;NodeList.h&quot;
  49 #include &quot;Page.h&quot;
  50 #include &quot;PageOverlayController.h&quot;
  51 #include &quot;RenderEmbeddedObject.h&quot;
  52 #include &quot;RenderFragmentedFlow.h&quot;
  53 #include &quot;RenderFullScreen.h&quot;
  54 #include &quot;RenderGeometryMap.h&quot;
  55 #include &quot;RenderIFrame.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderLayerBacking.h&quot;
  58 #include &quot;RenderReplica.h&quot;
  59 #include &quot;RenderVideo.h&quot;
  60 #include &quot;RenderView.h&quot;
  61 #include &quot;RuntimeEnabledFeatures.h&quot;
  62 #include &quot;ScrollingConstraints.h&quot;
  63 #include &quot;ScrollingCoordinator.h&quot;
  64 #include &quot;Settings.h&quot;
  65 #include &quot;TiledBacking.h&quot;
  66 #include &quot;TransformState.h&quot;
  67 #include &lt;wtf/HexNumber.h&gt;
  68 #include &lt;wtf/MemoryPressureHandler.h&gt;
  69 #include &lt;wtf/SetForScope.h&gt;
  70 #include &lt;wtf/text/CString.h&gt;
  71 #include &lt;wtf/text/StringBuilder.h&gt;
  72 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  73 #include &lt;wtf/text/TextStream.h&gt;
  74 
  75 #if PLATFORM(IOS_FAMILY)
  76 #include &quot;LegacyTileCache.h&quot;
  77 #include &quot;RenderScrollbar.h&quot;
  78 #endif
  79 
  80 #if PLATFORM(MAC)
  81 #include &quot;LocalDefaultSystemAppearance.h&quot;
  82 #endif
  83 
  84 #if ENABLE(TREE_DEBUGGING)
  85 #include &quot;RenderTreeAsText.h&quot;
  86 #endif
  87 
  88 #if ENABLE(3D_TRANSFORMS)
  89 // This symbol is used to determine from a script whether 3D rendering is enabled (via &#39;nm&#39;).
  90 WEBCORE_EXPORT bool WebCoreHas3DRendering = true;
  91 #endif
  92 
  93 #if !PLATFORM(MAC) &amp;&amp; !PLATFORM(IOS_FAMILY)
  94 #define USE_COMPOSITING_FOR_SMALL_CANVASES 1
  95 #endif
  96 
  97 namespace WebCore {
  98 
  99 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
 100 static const int canvasAreaThresholdRequiringCompositing = 50 * 100;
 101 #endif
 102 // During page loading delay layer flushes up to this many seconds to allow them coalesce, reducing workload.
 103 #if PLATFORM(IOS_FAMILY)
 104 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 105 static const Seconds throttledLayerFlushDelay { 1.5_s };
 106 #else
 107 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 108 static const Seconds throttledLayerFlushDelay { 500_ms };
 109 #endif
 110 
 111 using namespace HTMLNames;
 112 
 113 struct ScrollingTreeState {
 114     Optional&lt;ScrollingNodeID&gt; parentNodeID;
 115     size_t nextChildIndex { 0 };
 116 };
 117 
 118 struct RenderLayerCompositor::OverlapExtent {
 119     LayoutRect bounds;
 120     bool extentComputed { false };
 121     bool hasTransformAnimation { false };
 122     bool animationCausesExtentUncertainty { false };
 123 
 124     bool knownToBeHaveExtentUncertainty() const { return extentComputed &amp;&amp; animationCausesExtentUncertainty; }
 125 };
 126 
 127 struct RenderLayerCompositor::CompositingState {
 128     CompositingState(RenderLayer* compAncestor, bool testOverlap = true)
 129         : compositingAncestor(compAncestor)
 130         , testingOverlap(testOverlap)
 131     {
 132     }
 133 
 134     CompositingState stateForPaintOrderChildren(RenderLayer&amp; layer) const
 135     {
 136         UNUSED_PARAM(layer);
 137         CompositingState childState(compositingAncestor);
 138         if (layer.isStackingContext())
 139             childState.stackingContextAncestor = &amp;layer;
 140         else
 141             childState.stackingContextAncestor = stackingContextAncestor;
 142 
 143         childState.backingSharingAncestor = backingSharingAncestor;
 144         childState.subtreeIsCompositing = false;
 145         childState.testingOverlap = testingOverlap;
 146         childState.fullPaintOrderTraversalRequired = fullPaintOrderTraversalRequired;
 147         childState.descendantsRequireCompositingUpdate = descendantsRequireCompositingUpdate;
 148         childState.ancestorHasTransformAnimation = ancestorHasTransformAnimation;
 149 #if ENABLE(CSS_COMPOSITING)
 150         childState.hasNotIsolatedCompositedBlendingDescendants = false; // FIXME: should this only be reset for stacking contexts?
 151 #endif
 152 #if !LOG_DISABLED
 153         childState.depth = depth + 1;
 154 #endif
 155         return childState;
 156     }
 157 
 158     void updateWithDescendantStateAndLayer(const CompositingState&amp; childState, const RenderLayer&amp; layer, const OverlapExtent&amp; layerExtent, bool isUnchangedSubtree = false)
 159     {
 160         // Subsequent layers in the parent stacking context also need to composite.
 161         subtreeIsCompositing |= childState.subtreeIsCompositing | layer.isComposited();
 162         if (!isUnchangedSubtree)
 163             fullPaintOrderTraversalRequired |= childState.fullPaintOrderTraversalRequired;
 164 
 165         // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.
 166         // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because
 167         // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.
 168         auto canReenableOverlapTesting = [&amp;layer]() {
 169             return layer.isComposited() &amp;&amp; RenderLayerCompositor::clipsCompositingDescendants(layer);
 170         };
 171         if ((!childState.testingOverlap &amp;&amp; !canReenableOverlapTesting()) || layerExtent.knownToBeHaveExtentUncertainty())
 172             testingOverlap = false;
 173 
 174 #if ENABLE(CSS_COMPOSITING)
 175         if ((layer.isComposited() &amp;&amp; layer.hasBlendMode()) || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))
 176             hasNotIsolatedCompositedBlendingDescendants = true;
 177 #endif
 178     }
 179 
 180     bool hasNonRootCompositedAncestor() const
 181     {
 182         return compositingAncestor &amp;&amp; !compositingAncestor-&gt;isRenderViewLayer();
 183     }
 184 
 185     RenderLayer* compositingAncestor;
 186     RenderLayer* backingSharingAncestor { nullptr };
 187     RenderLayer* stackingContextAncestor { nullptr };
 188     bool subtreeIsCompositing { false };
 189     bool testingOverlap { true };
 190     bool fullPaintOrderTraversalRequired { false };
 191     bool descendantsRequireCompositingUpdate { false };
 192     bool ancestorHasTransformAnimation { false };
 193 #if ENABLE(CSS_COMPOSITING)
 194     bool hasNotIsolatedCompositedBlendingDescendants { false };
 195 #endif
 196 #if !LOG_DISABLED
 197     unsigned depth { 0 };
 198 #endif
 199 };
 200 
 201 class RenderLayerCompositor::BackingSharingState {
 202     WTF_MAKE_NONCOPYABLE(BackingSharingState);
 203 public:
 204     BackingSharingState() = default;
 205 
 206     RenderLayer* backingProviderCandidate() const { return m_backingProviderCandidate; };
 207 
 208     void appendSharingLayer(RenderLayer&amp; layer)
 209     {
 210         ASSERT(m_backingProviderCandidate);
 211         m_backingSharingLayers.append(makeWeakPtr(layer));
 212     }
 213 
 214     void updateBeforeDescendantTraversal(RenderLayer&amp;, bool willBeComposited);
 215     void updateAfterDescendantTraversal(RenderLayer&amp;, RenderLayer* stackingContextAncestor);
 216 
 217 private:
 218     void layerWillBeComposited(RenderLayer&amp;);
 219 
 220     void startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext);
 221     void endBackingSharingSequence();
 222 
 223     RenderLayer* m_backingProviderCandidate { nullptr };
 224     RenderLayer* m_backingProviderStackingContext { nullptr };
 225     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;
 226 };
 227 
 228 void RenderLayerCompositor::BackingSharingState::startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext)
 229 {
 230     ASSERT(!m_backingProviderCandidate);
 231     ASSERT(m_backingSharingLayers.isEmpty());
 232 
 233     m_backingProviderCandidate = &amp;candidateLayer;
 234     m_backingProviderStackingContext = candidateStackingContext;
 235 }
 236 
 237 void RenderLayerCompositor::BackingSharingState::endBackingSharingSequence()
 238 {
 239     if (m_backingProviderCandidate) {
 240         m_backingProviderCandidate-&gt;backing()-&gt;setBackingSharingLayers(WTFMove(m_backingSharingLayers));
 241         m_backingSharingLayers.clear();
 242     }
 243 
 244     m_backingProviderCandidate = nullptr;
 245 }
 246 
 247 void RenderLayerCompositor::BackingSharingState::updateBeforeDescendantTraversal(RenderLayer&amp; layer, bool willBeComposited)
 248 {
 249     layer.setBackingProviderLayer(nullptr);
 250 
 251     // A layer that composites resets backing-sharing, since subsequent layers need to composite to overlap it.
 252     if (willBeComposited) {
 253         m_backingSharingLayers.removeAll(&amp;layer);
 254         endBackingSharingSequence();
 255     }
 256 }
 257 
 258 void RenderLayerCompositor::BackingSharingState::updateAfterDescendantTraversal(RenderLayer&amp; layer, RenderLayer* stackingContextAncestor)
 259 {
 260     if (layer.isComposited()) {
 261         // If this layer is being composited, clean up sharing-related state.
 262         layer.disconnectFromBackingProviderLayer();
 263         m_backingSharingLayers.removeAll(&amp;layer);
 264     }
 265 
 266     if (m_backingProviderCandidate &amp;&amp; &amp;layer == m_backingProviderStackingContext) {
 267         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;End of stacking context for backing provider &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot;, ending sharing sequence with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);
 268         endBackingSharingSequence();
 269     } else if (!m_backingProviderCandidate &amp;&amp; layer.isComposited()) {
 270         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Post-descendant compositing of &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;, ending sharing sequence for &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot; with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);
 271         endBackingSharingSequence();
 272         startBackingSharingSequence(layer, stackingContextAncestor);
 273     }
 274 
 275     if (&amp;layer != m_backingProviderCandidate &amp;&amp; layer.isComposited())
 276         layer.backing()-&gt;clearBackingSharingLayers();
 277 }
 278 
 279 #if !LOG_DISABLED || ENABLE(TREE_DEBUGGING)
 280 static inline bool compositingLogEnabled()
 281 {
 282     return LogCompositing.state == WTFLogChannelState::On;
 283 }
 284 
 285 static inline bool layersLogEnabled()
 286 {
 287     return LogLayers.state == WTFLogChannelState::On;
 288 }
 289 #endif
 290 
 291 RenderLayerCompositor::RenderLayerCompositor(RenderView&amp; renderView)
 292     : m_renderView(renderView)
 293     , m_updateCompositingLayersTimer(*this, &amp;RenderLayerCompositor::updateCompositingLayersTimerFired)
 294     , m_layerFlushTimer(*this, &amp;RenderLayerCompositor::layerFlushTimerFired)
 295 {
 296 #if PLATFORM(IOS_FAMILY)
 297     if (m_renderView.frameView().platformWidget())
 298         m_legacyScrollingLayerCoordinator = makeUnique&lt;LegacyWebKitScrollingLayerCoordinator&gt;(page().chrome().client(), isMainFrameCompositor());
 299 #endif
 300 }
 301 
 302 RenderLayerCompositor::~RenderLayerCompositor()
 303 {
 304     // Take care that the owned GraphicsLayers are deleted first as their destructors may call back here.
 305     GraphicsLayer::unparentAndClear(m_rootContentsLayer);
 306 
 307     GraphicsLayer::unparentAndClear(m_clipLayer);
 308     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
 309     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
 310 
 311     GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
 312 
 313     GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
 314     GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
 315     GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
 316 
 317 #if ENABLE(RUBBER_BANDING)
 318     GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
 319     GraphicsLayer::unparentAndClear(m_contentShadowLayer);
 320     GraphicsLayer::unparentAndClear(m_layerForTopOverhangArea);
 321     GraphicsLayer::unparentAndClear(m_layerForBottomOverhangArea);
 322     GraphicsLayer::unparentAndClear(m_layerForHeader);
 323     GraphicsLayer::unparentAndClear(m_layerForFooter);
 324 #endif
 325 
 326     ASSERT(m_rootLayerAttachment == RootLayerUnattached);
 327 }
 328 
 329 void RenderLayerCompositor::enableCompositingMode(bool enable /* = true */)
 330 {
 331     if (enable != m_compositing) {
 332         m_compositing = enable;
 333 
 334         if (m_compositing) {
 335             ensureRootLayer();
 336             notifyIFramesOfCompositingChange();
 337         } else
 338             destroyRootLayer();
 339 
 340 
 341         m_renderView.layer()-&gt;setNeedsPostLayoutCompositingUpdate();
 342     }
 343 }
 344 
 345 void RenderLayerCompositor::cacheAcceleratedCompositingFlags()
 346 {
 347     auto&amp; settings = m_renderView.settings();
 348     bool hasAcceleratedCompositing = settings.acceleratedCompositingEnabled();
 349 
 350     // We allow the chrome to override the settings, in case the page is rendered
 351     // on a chrome that doesn&#39;t allow accelerated compositing.
 352     if (hasAcceleratedCompositing) {
 353         m_compositingTriggers = page().chrome().client().allowedCompositingTriggers();
 354         hasAcceleratedCompositing = m_compositingTriggers;
 355     }
 356 
 357     bool showDebugBorders = settings.showDebugBorders();
 358     bool showRepaintCounter = settings.showRepaintCounter();
 359     bool acceleratedDrawingEnabled = settings.acceleratedDrawingEnabled();
 360     bool displayListDrawingEnabled = settings.displayListDrawingEnabled();
 361 
 362     // forceCompositingMode for subframes can only be computed after layout.
 363     bool forceCompositingMode = m_forceCompositingMode;
 364     if (isMainFrameCompositor())
 365         forceCompositingMode = m_renderView.settings().forceCompositingMode() &amp;&amp; hasAcceleratedCompositing;
 366 
 367     if (hasAcceleratedCompositing != m_hasAcceleratedCompositing || showDebugBorders != m_showDebugBorders || showRepaintCounter != m_showRepaintCounter || forceCompositingMode != m_forceCompositingMode) {
 368         if (auto* rootLayer = m_renderView.layer()) {
 369             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
 370             rootLayer-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
 371         }
 372     }
 373 
 374     bool debugBordersChanged = m_showDebugBorders != showDebugBorders;
 375     m_hasAcceleratedCompositing = hasAcceleratedCompositing;
 376     m_forceCompositingMode = forceCompositingMode;
 377     m_showDebugBorders = showDebugBorders;
 378     m_showRepaintCounter = showRepaintCounter;
 379     m_acceleratedDrawingEnabled = acceleratedDrawingEnabled;
 380     m_displayListDrawingEnabled = displayListDrawingEnabled;
 381 
 382     if (debugBordersChanged) {
 383         if (m_layerForHorizontalScrollbar)
 384             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
 385 
 386         if (m_layerForVerticalScrollbar)
 387             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
 388 
 389         if (m_layerForScrollCorner)
 390             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
 391     }
 392 
 393     if (updateCompositingPolicy())
 394         rootRenderLayer().setDescendantsNeedCompositingRequirementsTraversal();
 395 }
 396 
 397 void RenderLayerCompositor::cacheAcceleratedCompositingFlagsAfterLayout()
 398 {
 399     cacheAcceleratedCompositingFlags();
 400 
 401     if (isMainFrameCompositor())
 402         return;
 403 
 404     RequiresCompositingData queryData;
 405     bool forceCompositingMode = m_hasAcceleratedCompositing &amp;&amp; m_renderView.settings().forceCompositingMode() &amp;&amp; requiresCompositingForScrollableFrame(queryData);
 406     if (forceCompositingMode != m_forceCompositingMode) {
 407         m_forceCompositingMode = forceCompositingMode;
 408         rootRenderLayer().setDescendantsNeedCompositingRequirementsTraversal();
 409     }
 410 }
 411 
 412 bool RenderLayerCompositor::updateCompositingPolicy()
 413 {
 414     if (!usesCompositing())
 415         return false;
 416 
 417     auto currentPolicy = m_compositingPolicy;
 418     if (page().compositingPolicyOverride()) {
 419         m_compositingPolicy = page().compositingPolicyOverride().value();
 420         return m_compositingPolicy != currentPolicy;
 421     }
 422 
 423     auto memoryPolicy = MemoryPressureHandler::currentMemoryUsagePolicy();
 424     m_compositingPolicy = memoryPolicy == WTF::MemoryUsagePolicy::Unrestricted ? CompositingPolicy::Normal : CompositingPolicy::Conservative;
 425     return m_compositingPolicy != currentPolicy;
 426 }
 427 
 428 bool RenderLayerCompositor::canRender3DTransforms() const
 429 {
 430     return hasAcceleratedCompositing() &amp;&amp; (m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger);
 431 }
 432 
 433 void RenderLayerCompositor::willRecalcStyle()
 434 {
 435     cacheAcceleratedCompositingFlags();
 436 }
 437 
 438 bool RenderLayerCompositor::didRecalcStyleWithNoPendingLayout()
 439 {
 440     return updateCompositingLayers(CompositingUpdateType::AfterStyleChange);
 441 }
 442 
 443 void RenderLayerCompositor::customPositionForVisibleRectComputation(const GraphicsLayer* graphicsLayer, FloatPoint&amp; position) const
 444 {
 445     if (graphicsLayer != m_scrolledContentsLayer.get())
 446         return;
 447 
 448     FloatPoint scrollPosition = -position;
 449 
 450     if (m_renderView.frameView().scrollBehaviorForFixedElements() == StickToDocumentBounds)
 451         scrollPosition = m_renderView.frameView().constrainScrollPositionForOverhang(roundedIntPoint(scrollPosition));
 452 
 453     position = -scrollPosition;
 454 }
 455 
 456 void RenderLayerCompositor::notifyFlushRequired(const GraphicsLayer* layer)
 457 {
 458     scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
 459 }
 460 
 461 void RenderLayerCompositor::scheduleLayerFlush(bool canThrottle)
 462 {
 463     ASSERT(!m_flushingLayers);
 464 
 465     if (canThrottle)
 466         startInitialLayerFlushTimerIfNeeded();
 467 
 468     if (canThrottle &amp;&amp; isThrottlingLayerFlushes())
 469         m_hasPendingLayerFlush = true;
 470     else {
 471         m_hasPendingLayerFlush = false;
 472         page().renderingUpdateScheduler().scheduleRenderingUpdate();
 473     }
 474 }
 475 
 476 FloatRect RenderLayerCompositor::visibleRectForLayerFlushing() const
 477 {
 478     const FrameView&amp; frameView = m_renderView.frameView();
 479 #if PLATFORM(IOS_FAMILY)
 480     return frameView.exposedContentRect();
 481 #else
 482     // Having a m_scrolledContentsLayer indicates that we&#39;re doing scrolling via GraphicsLayers.
 483     FloatRect visibleRect = m_scrolledContentsLayer ? FloatRect({ }, frameView.sizeForVisibleContent()) : frameView.visibleContentRect();
 484 
 485     if (frameView.viewExposedRect())
 486         visibleRect.intersect(frameView.viewExposedRect().value());
 487 
 488     return visibleRect;
 489 #endif
 490 }
 491 
 492 void RenderLayerCompositor::flushPendingLayerChanges(bool isFlushRoot)
 493 {
 494     // FrameView::flushCompositingStateIncludingSubframes() flushes each subframe,
 495     // but GraphicsLayer::flushCompositingState() will cross frame boundaries
 496     // if the GraphicsLayers are connected (the RootLayerAttachedViaEnclosingFrame case).
 497     // As long as we&#39;re not the root of the flush, we can bail.
 498     if (!isFlushRoot &amp;&amp; rootLayerAttachment() == RootLayerAttachedViaEnclosingFrame)
 499         return;
 500 
 501     if (rootLayerAttachment() == RootLayerUnattached) {
 502 #if PLATFORM(IOS_FAMILY)
 503         startLayerFlushTimerIfNeeded();
 504 #endif
 505         m_shouldFlushOnReattach = true;
 506         return;
 507     }
 508 
 509     auto&amp; frameView = m_renderView.frameView();
 510     AnimationUpdateBlock animationUpdateBlock(&amp;frameView.frame().animation());
 511 
 512     ASSERT(!m_flushingLayers);
 513     {
 514         SetForScope&lt;bool&gt; flushingLayersScope(m_flushingLayers, true);
 515 
 516         if (auto* rootLayer = rootGraphicsLayer()) {
 517             FloatRect visibleRect = visibleRectForLayerFlushing();
 518             LOG_WITH_STREAM(Compositing,  stream &lt;&lt; &quot;\nRenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; flushPendingLayerChanges (is root &quot; &lt;&lt; isFlushRoot &lt;&lt; &quot;) visible rect &quot; &lt;&lt; visibleRect);
 519             rootLayer-&gt;flushCompositingState(visibleRect);
 520         }
 521 
 522         ASSERT(m_flushingLayers);
 523 
 524 #if ENABLE(TREE_DEBUGGING)
 525         if (layersLogEnabled()) {
 526             LOG(Layers, &quot;RenderLayerCompositor::flushPendingLayerChanges&quot;);
 527             showGraphicsLayerTree(rootGraphicsLayer());
 528         }
 529 #endif
 530     }
 531 
 532 #if PLATFORM(IOS_FAMILY)
 533     updateScrollCoordinatedLayersAfterFlushIncludingSubframes();
 534 
 535     if (isFlushRoot)
 536         page().chrome().client().didFlushCompositingLayers();
 537 #endif
 538 
 539     ++m_layerFlushCount;
 540     startLayerFlushTimerIfNeeded();
 541 }
 542 
 543 #if PLATFORM(IOS_FAMILY)
 544 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlushIncludingSubframes()
 545 {
 546     updateScrollCoordinatedLayersAfterFlush();
 547 
 548     auto&amp; frame = m_renderView.frameView().frame();
 549     for (Frame* subframe = frame.tree().firstChild(); subframe; subframe = subframe-&gt;tree().traverseNext(&amp;frame)) {
 550         auto* view = subframe-&gt;contentRenderer();
 551         if (!view)
 552             continue;
 553 
 554         view-&gt;compositor().updateScrollCoordinatedLayersAfterFlush();
 555     }
 556 }
 557 
 558 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlush()
 559 {
 560     if (m_legacyScrollingLayerCoordinator) {
 561         m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
 562         m_legacyScrollingLayerCoordinator-&gt;registerAllScrollingLayers();
 563     }
 564 }
 565 #endif
 566 
 567 void RenderLayerCompositor::didChangePlatformLayerForLayer(RenderLayer&amp; layer, const GraphicsLayer*)
 568 {
 569     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
 570     if (!scrollingCoordinator)
 571         return;
 572 
 573     auto* backing = layer.backing();
 574     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
 575         updateScrollingNodeLayers(nodeID, layer, *scrollingCoordinator);
 576 
 577     if (auto* clippingStack = layer.backing()-&gt;ancestorClippingStack())
 578         clippingStack-&gt;updateScrollingNodeLayers(*scrollingCoordinator);
 579 
 580     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
 581         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 582 
 583     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 584         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 585 
 586     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Positioning))
 587         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 588 }
 589 
 590 void RenderLayerCompositor::didPaintBacking(RenderLayerBacking*)
 591 {
 592     auto&amp; frameView = m_renderView.frameView();
 593     frameView.setLastPaintTime(MonotonicTime::now());
 594     if (frameView.milestonesPendingPaint())
 595         frameView.firePaintRelatedMilestonesIfNeeded();
 596 }
 597 
 598 void RenderLayerCompositor::didChangeVisibleRect()
 599 {
 600     auto* rootLayer = rootGraphicsLayer();
 601     if (!rootLayer)
 602         return;
 603 
 604     FloatRect visibleRect = visibleRectForLayerFlushing();
 605     bool requiresFlush = rootLayer-&gt;visibleRectChangeRequiresFlush(visibleRect);
 606     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor::didChangeVisibleRect &quot; &lt;&lt; visibleRect &lt;&lt; &quot; requiresFlush &quot; &lt;&lt; requiresFlush);
 607     if (requiresFlush)
 608         scheduleLayerFlush();
 609 }
 610 
 611 void RenderLayerCompositor::notifyFlushBeforeDisplayRefresh(const GraphicsLayer*)
 612 {
 613     if (!m_layerUpdater) {
 614         PlatformDisplayID displayID = page().chrome().displayID();
 615         m_layerUpdater = makeUnique&lt;GraphicsLayerUpdater&gt;(*this, displayID);
 616     }
 617 
 618     m_layerUpdater-&gt;scheduleUpdate();
 619 }
 620 
 621 void RenderLayerCompositor::flushLayersSoon(GraphicsLayerUpdater&amp;)
 622 {
 623     scheduleLayerFlush(true);
 624 }
 625 
 626 void RenderLayerCompositor::layerTiledBackingUsageChanged(const GraphicsLayer* graphicsLayer, bool usingTiledBacking)
 627 {
 628     if (usingTiledBacking) {
 629         ++m_layersWithTiledBackingCount;
 630         graphicsLayer-&gt;tiledBacking()-&gt;setIsInWindow(page().isInWindow());
 631     } else {
 632         ASSERT(m_layersWithTiledBackingCount &gt; 0);
 633         --m_layersWithTiledBackingCount;
 634     }
 635 }
 636 
 637 void RenderLayerCompositor::scheduleCompositingLayerUpdate()
 638 {
 639     if (!m_updateCompositingLayersTimer.isActive())
 640         m_updateCompositingLayersTimer.startOneShot(0_s);
 641 }
 642 
 643 void RenderLayerCompositor::updateCompositingLayersTimerFired()
 644 {
 645     updateCompositingLayers(CompositingUpdateType::AfterLayout);
 646 }
 647 
 648 void RenderLayerCompositor::cancelCompositingLayerUpdate()
 649 {
 650     m_updateCompositingLayersTimer.stop();
 651 }
 652 
 653 static Optional&lt;ScrollingNodeID&gt; frameHostingNodeForFrame(Frame&amp; frame)
 654 {
 655     if (!frame.document() || !frame.view())
 656         return { };
 657 
 658     // Find the frame&#39;s enclosing layer in our render tree.
 659     auto* ownerElement = frame.document()-&gt;ownerElement();
 660     if (!ownerElement)
 661         return { };
 662 
 663     auto* frameRenderer = ownerElement-&gt;renderer();
 664     if (!frameRenderer || !is&lt;RenderWidget&gt;(frameRenderer))
 665         return { };
 666 
 667     auto&amp; widgetRenderer = downcast&lt;RenderWidget&gt;(*frameRenderer);
 668     if (!widgetRenderer.hasLayer() || !widgetRenderer.layer()-&gt;isComposited()) {
 669         LOG(Scrolling, &quot;frameHostingNodeForFrame: frame renderer has no layer or is not composited.&quot;);
 670         return { };
 671     }
 672 
 673     if (auto frameHostingNodeID = widgetRenderer.layer()-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 674         return frameHostingNodeID;
 675 
 676     return { };
 677 }
 678 
 679 // Returns true on a successful update.
 680 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 681 {
 682     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
 683 
 684 #if ENABLE(TREE_DEBUGGING)
 685     if (compositingLogEnabled())
 686         showPaintOrderTree(m_renderView.layer());
 687 #endif
 688 
 689     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
 690         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 691 
 692     m_updateCompositingLayersTimer.stop();
 693 
 694     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache
 695         || m_renderView.document().pageCacheState() == Document::AboutToEnterPageCache);
 696 
 697     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
 698     if (!m_renderView.document().visualUpdatesAllowed())
 699         return false;
 700 
 701     // Avoid updating the layers with old values. Compositing layers will be updated after the layout is finished.
 702     // This happens when m_updateCompositingLayersTimer fires before layout is updated.
 703     if (m_renderView.needsLayout()) {
 704         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; - m_renderView.needsLayout, bailing &quot;);
 705         return false;
 706     }
 707 
 708     if (!m_compositing &amp;&amp; (m_forceCompositingMode || (isMainFrameCompositor() &amp;&amp; page().pageOverlayController().overlayCount())))
 709         enableCompositingMode(true);
 710 
 711     bool isPageScroll = !updateRoot || updateRoot == &amp;rootRenderLayer();
 712     updateRoot = &amp;rootRenderLayer();
 713 
 714     if (updateType == CompositingUpdateType::OnScroll || updateType == CompositingUpdateType::OnCompositedScroll) {
 715         // We only get here if we didn&#39;t scroll on the scrolling thread, so this update needs to re-position viewport-constrained layers.
 716         if (m_renderView.settings().acceleratedCompositingForFixedPositionEnabled() &amp;&amp; isPageScroll) {
 717             if (auto* viewportConstrainedObjects = m_renderView.frameView().viewportConstrainedObjects()) {
 718                 for (auto* renderer : *viewportConstrainedObjects) {
 719                     if (auto* layer = renderer-&gt;layer())
 720                         layer-&gt;setNeedsCompositingGeometryUpdate();
 721                 }
 722             }
 723         }
 724 
 725         // Scrolling can affect overlap. FIXME: avoid for page scrolling.
 726         updateRoot-&gt;setDescendantsNeedCompositingRequirementsTraversal();
 727     }
 728 
 729     if (updateType == CompositingUpdateType::AfterLayout) {
 730         // Ensure that post-layout updates push new scroll position and viewport rects onto the root node.
 731         rootRenderLayer().setNeedsScrollingTreeUpdate();
 732     }
 733 
 734     if (!updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !m_compositing) {
 735         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; no compositing work to do&quot;);
 736         return true;
 737     }
 738 
 739     if (!updateRoot-&gt;needsAnyCompositingTraversal()) {
 740         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; updateRoot has no dirty child and doesn&#39;t need update&quot;);
 741         return true;
 742     }
 743 
 744     ++m_compositingUpdateCount;
 745 
 746     AnimationUpdateBlock animationUpdateBlock(&amp;m_renderView.frameView().frame().animation());
 747 
 748     SetForScope&lt;bool&gt; postLayoutChange(m_inPostLayoutUpdate, true);
 749 
 750 #if !LOG_DISABLED
 751     MonotonicTime startTime;
 752     if (compositingLogEnabled()) {
 753         ++m_rootLayerUpdateCount;
 754         startTime = MonotonicTime::now();
 755     }
 756 
 757     if (compositingLogEnabled()) {
 758         m_obligateCompositedLayerCount = 0;
 759         m_secondaryCompositedLayerCount = 0;
 760         m_obligatoryBackingStoreBytes = 0;
 761         m_secondaryBackingStoreBytes = 0;
 762 
 763         auto&amp; frame = m_renderView.frameView().frame();
 764         bool isMainFrame = isMainFrameCompositor();
 765         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;\nUpdate &quot; &lt;&lt; m_rootLayerUpdateCount &lt;&lt; &quot; of &quot; &lt;&lt; (isMainFrame ? &quot;main frame&quot; : frame.tree().uniqueName().string().utf8().data()) &lt;&lt; &quot; - compositing policy is &quot; &lt;&lt; m_compositingPolicy);
 766     }
 767 #endif
 768 
 769     // FIXME: optimize root-only update.
 770     if (updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() || updateRoot-&gt;needsCompositingRequirementsTraversal()) {
 771         auto&amp; rootLayer = rootRenderLayer();
 772         CompositingState compositingState(updateRoot);
 773         BackingSharingState backingSharingState;
 774         LayerOverlapMap overlapMap(rootLayer);
 775 
 776         bool descendantHas3DTransform = false;
 777         computeCompositingRequirements(nullptr, rootLayer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 778     }
 779 
 780     LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
 781 #if ENABLE(TREE_DEBUGGING)
 782     if (compositingLogEnabled())
 783         showPaintOrderTree(m_renderView.layer());
 784 #endif
 785 
 786     if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
 787         ScrollingTreeState scrollingTreeState = { 0, 0 };
 788         if (!m_renderView.frame().isMainFrame())
 789             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 790 
 791         Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
 792         updateBackingAndHierarchy(*updateRoot, childList, scrollingTreeState);
 793 
 794         // Host the document layer in the RenderView&#39;s root layer.
 795         appendDocumentOverlayLayers(childList);
 796         // Even when childList is empty, don&#39;t drop out of compositing mode if there are
 797         // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
 798         if (childList.isEmpty() &amp;&amp; !needsCompositingForContentOrOverlays())
 799             destroyRootLayer();
 800         else if (m_rootContentsLayer)
 801             m_rootContentsLayer-&gt;setChildren(WTFMove(childList));
 802     }
 803 
 804 #if !LOG_DISABLED
 805     if (compositingLogEnabled()) {
 806         MonotonicTime endTime = MonotonicTime::now();
 807         LOG(Compositing, &quot;Total layers   primary   secondary   obligatory backing (KB)   secondary backing(KB)   total backing (KB)  update time (ms)\n&quot;);
 808 
 809         LOG(Compositing, &quot;%8d %11d %9d %20.2f %22.2f %22.2f %18.2f\n&quot;,
 810             m_obligateCompositedLayerCount + m_secondaryCompositedLayerCount, m_obligateCompositedLayerCount,
 811             m_secondaryCompositedLayerCount, m_obligatoryBackingStoreBytes / 1024, m_secondaryBackingStoreBytes / 1024, (m_obligatoryBackingStoreBytes + m_secondaryBackingStoreBytes) / 1024, (endTime - startTime).milliseconds());
 812     }
 813 #endif
 814 
 815     // FIXME: Only do if dirty.
 816     updateRootLayerPosition();
 817 
 818 #if ENABLE(TREE_DEBUGGING)
 819     if (compositingLogEnabled()) {
 820         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - post&quot;);
 821         showPaintOrderTree(m_renderView.layer());
 822     }
 823 #endif
 824 
 825     InspectorInstrumentation::layerTreeDidChange(&amp;page());
 826 
 827     return true;
 828 }
 829 
 830 static bool backingProviderLayerCanIncludeLayer(const RenderLayer&amp; sharedLayer, const RenderLayer&amp; layer)
 831 {
 832     // Disable sharing when painting shared layers doesn&#39;t work correctly.
 833     if (layer.hasReflection())
 834         return false;
 835 
 836     return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);
 837 }
 838 
 839 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
 840 {
 841     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()
 842         &amp;&amp; !layer.needsCompositingRequirementsTraversal()
 843         &amp;&amp; !compositingState.fullPaintOrderTraversalRequired
 844         &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {
 845         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 846         return;
 847     }
 848 
 849     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; computeCompositingRequirements (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
 850 
 851     // FIXME: maybe we can avoid updating all remaining layers in paint order.
 852     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
 853     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 854 
 855     layer.updateDescendantDependentFlags();
 856     layer.updateLayerListsIfNeeded();
 857 
 858     layer.setHasCompositingDescendant(false);
 859 
 860     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
 861     RequiresCompositingData queryData;
 862     bool willBeComposited = layer.isComposited();
 863     bool becameCompositedAfterDescendantTraversal = false;
 864     IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None;
 865 
 866     if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
 867         layer.setIndirectCompositingReason(IndirectCompositingReason::None);
 868         willBeComposited = needsToBeComposited(layer, queryData);
 869     }
 870 
 871     bool layerPaintsIntoProvidedBacking = false;
 872     if (!willBeComposited &amp;&amp; compositingState.subtreeIsCompositing &amp;&amp; backingSharingState.backingProviderCandidate() &amp;&amp; canBeComposited(layer) &amp;&amp; backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer)) {
 873         backingSharingState.appendSharingLayer(layer);
 874         LOG(Compositing, &quot; layer %p can share with %p&quot;, &amp;layer, backingSharingState.backingProviderCandidate());
 875         compositingReason = IndirectCompositingReason::None;
 876         layerPaintsIntoProvidedBacking = true;
 877     }
 878 
 879     compositingState.fullPaintOrderTraversalRequired |= layer.subsequentLayersNeedCompositingRequirementsTraversal();
 880 
 881     OverlapExtent layerExtent;
 882     // Use the fact that we&#39;re composited as a hint to check for an animating transform.
 883     // FIXME: Maybe needsToBeComposited() should return a bitmask of reasons, to avoid the need to recompute things.
 884     if (willBeComposited &amp;&amp; !layer.isRenderViewLayer())
 885         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
 886 
 887     bool respectTransforms = !layerExtent.hasTransformAnimation;
 888     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
 889 
 890     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
 891     if (!willBeComposited &amp;&amp; !layerPaintsIntoProvidedBacking &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap) {
 892         // If we&#39;re testing for overlap, we only need to composite if we overlap something that is already composited.
 893         if (layerOverlaps(overlapMap, layer, layerExtent))
 894             compositingReason = IndirectCompositingReason::Overlap;
 895         else
 896             compositingReason = IndirectCompositingReason::None;
 897     }
 898 
 899 #if ENABLE(VIDEO)
 900     // Video is special. It&#39;s the only RenderLayer type that can both have
 901     // RenderLayer children and whose children can&#39;t use its backing to render
 902     // into. These children (the controls) always need to be promoted into their
 903     // own layers to draw on top of the accelerated video.
 904     if (compositingState.compositingAncestor &amp;&amp; compositingState.compositingAncestor-&gt;renderer().isVideo())
 905         compositingReason = IndirectCompositingReason::Overlap;
 906 #endif
 907 
 908     if (compositingReason != IndirectCompositingReason::None)
 909         layer.setIndirectCompositingReason(compositingReason);
 910 
 911     // Check if the computed indirect reason will force the layer to become composited.
 912     if (!willBeComposited &amp;&amp; layer.mustCompositeForIndirectReasons() &amp;&amp; canBeComposited(layer)) {
 913         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; compositing for indirect reason &quot; &lt;&lt; layer.indirectCompositingReason() &lt;&lt; &quot; (was sharing: &quot; &lt;&lt; layerPaintsIntoProvidedBacking &lt;&lt; &quot;)&quot;);
 914         willBeComposited = true;
 915         layerPaintsIntoProvidedBacking = false;
 916     }
 917 
 918     // The children of this layer don&#39;t need to composite, unless there is
 919     // a compositing layer among them, so start by inheriting the compositing
 920     // ancestor with subtreeIsCompositing set to false.
 921     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);
 922     bool didPushOverlapContainer = false;
 923 
 924     auto layerWillComposite = [&amp;] {
 925         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
 926         // animation running behind this layer, meaning they can rely on the overlap map testing again.
 927         currentState.testingOverlap = true;
 928         // This layer now acts as the ancestor for kids.
 929         currentState.compositingAncestor = &amp;layer;
 930         // Compositing turns off backing sharing.
 931         currentState.backingSharingAncestor = nullptr;
 932 
 933         if (layerPaintsIntoProvidedBacking) {
 934             layerPaintsIntoProvidedBacking = false;
 935             // layerPaintsIntoProvidedBacking was only true for layers that would otherwise composite because of overlap. If we can
 936             // no longer share, put this this indirect reason back on the layer so that requiresOwnBackingStore() sees it.
 937             layer.setIndirectCompositingReason(IndirectCompositingReason::Overlap);
 938             LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; was sharing now will composite&quot;);
 939         } else {
 940             overlapMap.pushCompositingContainer();
 941             didPushOverlapContainer = true;
 942             LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);
 943         }
 944 
 945         willBeComposited = true;
 946     };
 947 
 948     auto layerWillCompositePostDescendants = [&amp;] {
 949         layerWillComposite();
 950         currentState.subtreeIsCompositing = true;
 951         becameCompositedAfterDescendantTraversal = true;
 952     };
 953 
 954     if (willBeComposited) {
 955         layerWillComposite();
 956 
 957         computeExtent(overlapMap, layer, layerExtent);
 958         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
 959         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
 960         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
 961     } else if (layerPaintsIntoProvidedBacking) {
 962         currentState.backingSharingAncestor = &amp;layer;
 963         overlapMap.pushCompositingContainer();
 964         didPushOverlapContainer = true;
 965         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
 966     }
 967 
 968     backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);
 969 
 970 #if !ASSERT_DISABLED
 971     LayerListMutationDetector mutationChecker(layer);
 972 #endif
 973 
 974     bool anyDescendantHas3DTransform = false;
 975     bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();
 976 
 977     for (auto* childLayer : layer.negativeZOrderLayers()) {
 978         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
 979 
 980         // If we have to make a layer for this child, make one now so we can have a contents layer
 981         // (since we need to ensure that the -ve z-order child renders underneath our contents).
 982         if (!willBeComposited &amp;&amp; currentState.subtreeIsCompositing) {
 983             layer.setIndirectCompositingReason(IndirectCompositingReason::BackgroundLayer);
 984             layerWillComposite();
 985         }
 986     }
 987 
 988     for (auto* childLayer : layer.normalFlowLayers())
 989         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
 990 
 991     for (auto* childLayer : layer.positiveZOrderLayers())
 992         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
 993 
 994     // Set the flag to say that this layer has compositing children.
 995     layer.setHasCompositingDescendant(currentState.subtreeIsCompositing);
 996 
 997     // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
 998     if (layer.isRenderViewLayer()) {
 999         if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
1000             willBeComposited = true;
1001     }
1002 
1003 #if ENABLE(CSS_COMPOSITING)
1004     bool isolatedCompositedBlending = layer.isolatesCompositedBlending();
1005     layer.setHasNotIsolatedCompositedBlendingDescendants(currentState.hasNotIsolatedCompositedBlendingDescendants);
1006     if (layer.isolatesCompositedBlending() != isolatedCompositedBlending) {
1007         // isolatedCompositedBlending affects the result of clippedByAncestor().
1008         layer.setChildrenNeedCompositingGeometryUpdate();
1009     }
1010 
1011     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
1012 #endif
1013     // Now check for reasons to become composited that depend on the state of descendant layers.
1014     IndirectCompositingReason indirectCompositingReason;
1015     if (!willBeComposited &amp;&amp; canBeComposited(layer)
1016         &amp;&amp; requiresCompositingForIndirectReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking, indirectCompositingReason)) {
1017         layer.setIndirectCompositingReason(indirectCompositingReason);
1018         layerWillCompositePostDescendants();
1019     }
1020 
1021     if (layer.reflectionLayer()) {
1022         // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
1023         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);
1024     }
1025 
1026     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that now.
1027     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);
1028     if (isCompositedClippingLayer &amp; !willBeComposited)
1029         layerWillCompositePostDescendants();
1030 
1031     // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
1032     // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
1033     // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
1034     RequiresCompositingData rootLayerQueryData;
1035     if (layer.isRenderViewLayer() &amp;&amp; !currentState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {
1036         // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
1037 #if !PLATFORM(IOS_FAMILY)
1038         enableCompositingMode(false);
1039         willBeComposited = false;
1040 #endif
1041     }
1042 
1043     ASSERT(willBeComposited == needsToBeComposited(layer, queryData));
1044 
1045     // Create or destroy backing here. However, we can&#39;t update geometry because layers above us may become composited
1046     // during post-order traversal (e.g. for clipping).
1047     if (updateBacking(layer, queryData, CompositingChangeRepaintNow, willBeComposited ? BackingRequired::Yes : BackingRequired::No)) {
1048         layer.setNeedsCompositingLayerConnection();
1049         // Child layers need to get a geometry update to recompute their position.
1050         layer.setChildrenNeedCompositingGeometryUpdate();
1051         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
1052         layer.setNeedsCompositingGeometryUpdateOnAncestors();
1053     }
1054 
1055     // Update layer state bits.
1056     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))
1057         layer.setNeedsCompositingLayerConnection();
1058 
1059     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
1060     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
1061         layer.setChildrenNeedCompositingGeometryUpdate();
1062         layer.setNeedsCompositingLayerConnection();
1063     }
1064 
1065     layer.clearCompositingRequirementsTraversalState();
1066 
1067     // Compute state passed to the caller.
1068     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1069     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent);
1070     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1071 
1072     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1073     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap, becameCompositedAfterDescendantTraversal &amp;&amp; !descendantsAddedToOverlap);
1074 
1075     if (layer.isComposited())
1076         layer.backing()-&gt;updateAllowsBackingStoreDetaching(layerExtent.bounds);
1077 
1078     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1079 
1080     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; &quot; computeCompositingRequirements - willBeComposited &quot; &lt;&lt; willBeComposited &lt;&lt; &quot; (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
1081 }
1082 
1083 // We have to traverse unchanged layers to fill in the overlap map.
1084 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
1085 {
1086     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
1087     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
1088     ASSERT(!layer.needsCompositingRequirementsTraversal());
1089 
1090     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; traverseUnchangedSubtree&quot;);
1091 
1092     layer.updateDescendantDependentFlags();
1093     layer.updateLayerListsIfNeeded();
1094 
1095     bool layerIsComposited = layer.isComposited();
1096     bool layerPaintsIntoProvidedBacking = false;
1097     bool didPushOverlapContainer = false;
1098 
1099     OverlapExtent layerExtent;
1100     if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
1101         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
1102 
1103     bool respectTransforms = !layerExtent.hasTransformAnimation;
1104     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
1105 
1106     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
1107     if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
1108         computeExtent(overlapMap, layer, layerExtent);
1109 
1110     if (layer.paintsIntoProvidedBacking()) {
1111         ASSERT(backingSharingState.backingProviderCandidate());
1112         ASSERT(backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer));
1113         backingSharingState.appendSharingLayer(layer);
1114         layerPaintsIntoProvidedBacking = true;
1115     }
1116 
1117     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);
1118 
1119     if (layerIsComposited) {
1120         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
1121         // animation running behind this layer, meaning they can rely on the overlap map testing again.
1122         currentState.testingOverlap = true;
1123         // This layer now acts as the ancestor for kids.
1124         currentState.compositingAncestor = &amp;layer;
1125         currentState.backingSharingAncestor = nullptr;
1126         overlapMap.pushCompositingContainer();
1127         didPushOverlapContainer = true;
1128         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);
1129 
1130         computeExtent(overlapMap, layer, layerExtent);
1131         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
1132         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
1133         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
1134     } else if (layerPaintsIntoProvidedBacking) {
1135         overlapMap.pushCompositingContainer();
1136         currentState.backingSharingAncestor = &amp;layer;
1137         didPushOverlapContainer = true;
1138         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
1139     }
1140 
1141     backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);
1142 
1143 #if !ASSERT_DISABLED
1144     LayerListMutationDetector mutationChecker(layer);
1145 #endif
1146 
1147     bool anyDescendantHas3DTransform = false;
1148 
1149     for (auto* childLayer : layer.negativeZOrderLayers()) {
1150         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1151         if (currentState.subtreeIsCompositing)
1152             ASSERT(layerIsComposited);
1153     }
1154 
1155     for (auto* childLayer : layer.normalFlowLayers())
1156         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1157 
1158     for (auto* childLayer : layer.positiveZOrderLayers())
1159         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1160 
1161     // Set the flag to say that this layer has compositing children.
1162     ASSERT(layer.hasCompositingDescendant() == currentState.subtreeIsCompositing);
1163     ASSERT_IMPLIES(canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer), layerIsComposited);
1164 
1165     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1166 
1167     ASSERT(!currentState.fullPaintOrderTraversalRequired);
1168     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent, true);
1169     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1170 
1171     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1172     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap);
1173 
1174     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1175 
1176     ASSERT(!layer.needsCompositingRequirementsTraversal());
1177 }
1178 
1179 void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)
1180 {
1181     layer.updateDescendantDependentFlags();
1182     layer.updateLayerListsIfNeeded();
1183 
1184     bool layerNeedsUpdate = !updateLevel.isEmpty();
1185     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
1186         updateLevel.add(UpdateLevel::AllDescendants);
1187 
1188     ScrollingTreeState stateForDescendants = scrollingTreeState;
1189 
1190     auto* layerBacking = layer.backing();
1191     if (layerBacking) {
1192         updateLevel.remove(UpdateLevel::CompositedChildren);
1193 
1194         // We updated the composited bounds in RenderLayerBacking::updateAfterLayout(), but it may have changed
1195         // based on which descendants are now composited.
1196         if (layerBacking-&gt;updateCompositedBounds()) {
1197             layer.setNeedsCompositingGeometryUpdate();
1198             // Our geometry can affect descendants.
1199             updateLevel.add(UpdateLevel::CompositedChildren);
1200         }
1201 
1202         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
1203             if (layerBacking-&gt;updateConfiguration()) {
1204                 layerNeedsUpdate = true; // We also need to update geometry.
1205                 layer.setNeedsCompositingLayerConnection();
1206             }
1207 
1208             layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1209         }
1210 
1211         OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
1212         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {
1213             layerBacking-&gt;updateGeometry();
1214             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1215         } else if (layer.needsScrollingTreeUpdate())
1216             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1217 
1218         // This needs to happen after any geometry update.
1219         // FIXME: Use separate bit for event region invalidation.
1220         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate())
1221             layerBacking-&gt;updateEventRegion();
1222 
1223         if (auto* reflection = layer.reflectionLayer()) {
1224             if (auto* reflectionBacking = reflection-&gt;backing()) {
1225                 reflectionBacking-&gt;updateCompositedBounds();
1226                 reflectionBacking-&gt;updateGeometry();
1227                 reflectionBacking-&gt;updateAfterDescendants();
1228             }
1229         }
1230 
1231         if (!layer.parent())
1232             updateRootLayerPosition();
1233 
1234         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
1235         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
1236         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, scrollingNodeChanges);
1237         stateForDescendants.nextChildIndex = 0;
1238 
1239 #if !LOG_DISABLED
1240         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);
1241 #else
1242         UNUSED_PARAM(depth);
1243 #endif
1244     }
1245 
1246     if (layer.childrenNeedCompositingGeometryUpdate())
1247         updateLevel.add(UpdateLevel::CompositedChildren);
1248 
1249     // If this layer has backing, then we are collecting its children, otherwise appending
1250     // to the compositing child list of an enclosing layer.
1251     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; layerChildren;
1252     auto&amp; childList = layerBacking ? layerChildren : childLayersOfEnclosingLayer;
1253 
1254     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
1255         || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
1256 
1257     bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
1258 
1259 #if !ASSERT_DISABLED
1260     LayerListMutationDetector mutationChecker(layer);
1261 #endif
1262 
1263     auto appendForegroundLayerIfNecessary = [&amp;] {
1264         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
1265         if (layer.negativeZOrderLayers().size()) {
1266             if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
1267                 childList.append(*layerBacking-&gt;foregroundLayer());
1268         }
1269     };
1270 
1271     if (requireDescendantTraversal) {
1272         for (auto* renderLayer : layer.negativeZOrderLayers())
1273             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1274 
1275         appendForegroundLayerIfNecessary();
1276 
1277         for (auto* renderLayer : layer.normalFlowLayers())
1278             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1279 
1280         for (auto* renderLayer : layer.positiveZOrderLayers())
1281             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1282     } else if (requiresChildRebuild)
1283         appendForegroundLayerIfNecessary();
1284 
1285     if (layerBacking) {
1286         if (requireDescendantTraversal || requiresChildRebuild) {
1287             bool parented = false;
1288             if (is&lt;RenderWidget&gt;(layer.renderer()))
1289                 parented = parentFrameContentLayers(downcast&lt;RenderWidget&gt;(layer.renderer()));
1290 
1291             if (!parented)
1292                 layerBacking-&gt;parentForSublayers()-&gt;setChildren(WTFMove(layerChildren));
1293 
1294             // If the layer has a clipping layer the overflow controls layers will be siblings of the clipping layer.
1295             // Otherwise, the overflow control layers are normal children.
1296             if (!layerBacking-&gt;hasClippingLayer() &amp;&amp; !layerBacking-&gt;hasScrollingLayer()) {
1297                 if (auto* overflowControlLayer = layerBacking-&gt;layerForHorizontalScrollbar())
1298                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1299 
1300                 if (auto* overflowControlLayer = layerBacking-&gt;layerForVerticalScrollbar())
1301                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1302 
1303                 if (auto* overflowControlLayer = layerBacking-&gt;layerForScrollCorner())
1304                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1305             }
1306         }
1307 
1308         childLayersOfEnclosingLayer.append(*layerBacking-&gt;childForSuperlayers());
1309 
1310         layerBacking-&gt;updateAfterDescendants();
1311     }
1312 
1313     layer.clearUpdateBackingOrHierarchyTraversalState();
1314 }
1315 
1316 void RenderLayerCompositor::appendDocumentOverlayLayers(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childList)
1317 {
1318     if (!isMainFrameCompositor() || !m_compositing)
1319         return;
1320 
1321     if (!page().pageOverlayController().hasDocumentOverlays())
1322         return;
1323 
1324     Ref&lt;GraphicsLayer&gt; overlayHost = page().pageOverlayController().layerWithDocumentOverlays();
1325     childList.append(WTFMove(overlayHost));
1326 }
1327 
1328 bool RenderLayerCompositor::needsCompositingForContentOrOverlays() const
1329 {
1330     return m_contentLayersCount + page().pageOverlayController().overlayCount();
1331 }
1332 
1333 void RenderLayerCompositor::layerBecameComposited(const RenderLayer&amp; layer)
1334 {
1335     if (&amp;layer != m_renderView.layer())
1336         ++m_contentLayersCount;
1337 }
1338 
1339 void RenderLayerCompositor::layerBecameNonComposited(const RenderLayer&amp; layer)
1340 {
1341     // Inform the inspector that the given RenderLayer was destroyed.
1342     // FIXME: &quot;destroyed&quot; is a misnomer.
1343     InspectorInstrumentation::renderLayerDestroyed(&amp;page(), layer);
1344 
1345     if (&amp;layer != m_renderView.layer()) {
1346         ASSERT(m_contentLayersCount &gt; 0);
1347         --m_contentLayersCount;
1348     }
1349 }
1350 
1351 #if !LOG_DISABLED
1352 void RenderLayerCompositor::logLayerInfo(const RenderLayer&amp; layer, const char* phase, int depth)
1353 {
1354     if (!compositingLogEnabled())
1355         return;
1356 
1357     auto* backing = layer.backing();
1358     RequiresCompositingData queryData;
1359     if (requiresCompositingLayer(layer, queryData) || layer.isRenderViewLayer()) {
1360         ++m_obligateCompositedLayerCount;
1361         m_obligatoryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1362     } else {
1363         ++m_secondaryCompositedLayerCount;
1364         m_secondaryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1365     }
1366 
1367     LayoutRect absoluteBounds = backing-&gt;compositedBounds();
1368     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
1369 
1370     StringBuilder logString;
1371     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);
1372 
1373     if (!layer.renderer().style().hasAutoZIndex())
1374         logString.append(&quot; z-index: &quot;, layer.renderer().style().zIndex());
1375 
1376     logString.append(&quot; (&quot;, logReasonsForCompositing(layer), &quot;) &quot;);
1377 
1378     if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1379         logString.append(&#39;[&#39;);
1380         bool prependSpace = false;
1381         if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
1382             logString.appendLiteral(&quot;opaque&quot;);
1383             prependSpace = true;
1384         }
1385 
1386         if (backing-&gt;paintsIntoCompositedAncestor()) {
1387             if (prependSpace)
1388                 logString.appendLiteral(&quot;, &quot;);
1389             logString.appendLiteral(&quot;paints into ancestor&quot;);
1390             prependSpace = true;
1391         }
1392 
1393         if (backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1394             if (prependSpace)
1395                 logString.appendLiteral(&quot;, &quot;);
1396             if (backing-&gt;foregroundLayer() &amp;&amp; backing-&gt;backgroundLayer()) {
1397                 logString.appendLiteral(&quot;+foreground+background&quot;);
1398                 prependSpace = true;
1399             } else if (backing-&gt;foregroundLayer()) {
1400                 logString.appendLiteral(&quot;+foreground&quot;);
1401                 prependSpace = true;
1402             } else {
1403                 logString.appendLiteral(&quot;+background&quot;);
1404                 prependSpace = true;
1405             }
1406         }
1407 
1408         if (backing-&gt;paintsSubpixelAntialiasedText()) {
1409             if (prependSpace)
1410                 logString.appendLiteral(&quot;, &quot;);
1411             logString.appendLiteral(&quot;texty&quot;);
1412         }
1413 
1414         logString.appendLiteral(&quot;] &quot;);
1415     }
1416 
1417     logString.append(layer.name());
1418 
1419     logString.appendLiteral(&quot; - &quot;);
1420     logString.append(phase);
1421 
1422     LOG(Compositing, &quot;%s&quot;, logString.toString().utf8().data());
1423 }
1424 #endif
1425 
1426 static bool clippingChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
1427 {
1428     return oldStyle.overflowX() != newStyle.overflowX() || oldStyle.overflowY() != newStyle.overflowY()
1429         || oldStyle.hasClip() != newStyle.hasClip() || oldStyle.clip() != newStyle.clip();
1430 }
1431 
1432 static bool styleAffectsLayerGeometry(const RenderStyle&amp; style)
1433 {
1434     return style.hasClip() || style.clipPath() || style.hasBorderRadius();
1435 }
1436 
1437 static bool recompositeChangeRequiresGeometryUpdate(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
1438 {
1439     return oldStyle.transform() != newStyle.transform()
1440         || oldStyle.transformOriginX() != newStyle.transformOriginX()
1441         || oldStyle.transformOriginY() != newStyle.transformOriginY()
1442         || oldStyle.transformOriginZ() != newStyle.transformOriginZ()
1443         || oldStyle.transformStyle3D() != newStyle.transformStyle3D()
1444         || oldStyle.perspective() != newStyle.perspective()
1445         || oldStyle.perspectiveOriginX() != newStyle.perspectiveOriginX()
1446         || oldStyle.perspectiveOriginY() != newStyle.perspectiveOriginY()
1447         || oldStyle.backfaceVisibility() != newStyle.backfaceVisibility()
1448         || !arePointingToEqualData(oldStyle.clipPath(), newStyle.clipPath());
1449 }
1450 
1451 void RenderLayerCompositor::layerStyleChanged(StyleDifference diff, RenderLayer&amp; layer, const RenderStyle* oldStyle)
1452 {
1453     if (diff == StyleDifference::Equal)
1454         return;
1455 
1456     // Create or destroy backing here so that code that runs during layout can reliably use isComposited() (though this
1457     // is only true for layers composited for direct reasons).
1458     // Also, it allows us to avoid a tree walk in updateCompositingLayers() when no layer changed its compositing state.
1459     RequiresCompositingData queryData;
1460     queryData.layoutUpToDate = LayoutUpToDate::No;
1461 
1462     bool layerChanged = updateBacking(layer, queryData, CompositingChangeRepaintNow);
1463     if (layerChanged) {
1464         layer.setChildrenNeedCompositingGeometryUpdate();
1465         layer.setNeedsCompositingLayerConnection();
1466         layer.setSubsequentLayersNeedCompositingRequirementsTraversal();
1467         // Ancestor layers that composited for indirect reasons (things listed in styleChangeMayAffectIndirectCompositingReasons()) need to get updated.
1468         // This could be optimized by only setting this flag on layers with the relevant styles.
1469         layer.setNeedsPostLayoutCompositingUpdateOnAncestors();
1470     }
1471 
1472     if (queryData.reevaluateAfterLayout)
1473         layer.setNeedsPostLayoutCompositingUpdate();
1474 
1475     const auto&amp; newStyle = layer.renderer().style();
1476 
1477     if (hasContentCompositingLayers()) {
1478         if (diff &gt;= StyleDifference::LayoutPositionedMovementOnly) {
1479             layer.setNeedsPostLayoutCompositingUpdate();
1480             layer.setNeedsCompositingGeometryUpdate();
1481         }
1482 
1483         if (diff &gt;= StyleDifference::Layout) {
1484             // FIXME: only set flags here if we know we have a composited descendant, but we might not know at this point.
1485             if (oldStyle &amp;&amp; clippingChanged(*oldStyle, newStyle)) {
1486                 if (layer.isStackingContext()) {
1487                     layer.setNeedsPostLayoutCompositingUpdate(); // Layer needs to become composited if it has composited descendants.
1488                     layer.setNeedsCompositingConfigurationUpdate(); // If already composited, layer needs to create/destroy clipping layer.
1489                 } else {
1490                     // Descendant (in containing block order) compositing layers need to re-evaluate their clipping,
1491                     // but they might be siblings in z-order so go up to our stacking context.
1492                     if (auto* stackingContext = layer.stackingContext())
1493                         stackingContext-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
1494                 }
1495             }
1496 
1497             // These properties trigger compositing if some descendant is composited.
1498             if (oldStyle &amp;&amp; styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
1499                 layer.setNeedsPostLayoutCompositingUpdate();
1500 
1501             layer.setNeedsCompositingGeometryUpdate();
1502         }
1503     }
1504 
1505     auto* backing = layer.backing();
1506     if (!backing)
1507         return;
1508 
1509     backing-&gt;updateConfigurationAfterStyleChange();
1510 
1511     if (diff &gt;= StyleDifference::Repaint) {
1512         // Visibility change may affect geometry of the enclosing composited layer.
1513         if (oldStyle &amp;&amp; oldStyle-&gt;visibility() != newStyle.visibility())
1514             layer.setNeedsCompositingGeometryUpdate();
1515 
1516         // We&#39;ll get a diff of Repaint when things like clip-path change; these might affect layer or inner-layer geometry.
1517         if (layer.isComposited() &amp;&amp; oldStyle) {
1518             if (styleAffectsLayerGeometry(*oldStyle) || styleAffectsLayerGeometry(newStyle))
1519                 layer.setNeedsCompositingGeometryUpdate();
1520         }
1521     }
1522 
1523     // This is necessary to get iframe layers hooked up in response to scheduleInvalidateStyleAndLayerComposition().
1524     if (diff == StyleDifference::RecompositeLayer &amp;&amp; layer.isComposited() &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer()))
1525         layer.setNeedsCompositingConfigurationUpdate();
1526 
1527     if (diff &gt;= StyleDifference::RecompositeLayer &amp;&amp; oldStyle &amp;&amp; recompositeChangeRequiresGeometryUpdate(*oldStyle, newStyle)) {
1528         // FIXME: transform changes really need to trigger layout. See RenderElement::adjustStyleDifference().
1529         layer.setNeedsPostLayoutCompositingUpdate();
1530         layer.setNeedsCompositingGeometryUpdate();
1531     }
1532 }
1533 
1534 bool RenderLayerCompositor::needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp; layer, const RenderStyle* oldStyle) const
1535 {
1536     // Needed for scroll bars.
1537     if (layer.isRenderViewLayer())
1538         return true;
1539 
1540     if (!oldStyle)
1541         return false;
1542 
1543     const RenderStyle&amp; newStyle = layer.renderer().style();
1544     // Visibility change may affect geometry of the enclosing composited layer.
1545     if (oldStyle-&gt;visibility() != newStyle.visibility())
1546         return true;
1547 
1548     // We don&#39;t have any direct reasons for this style change to affect layer composition. Test if it might affect things indirectly.
1549     if (styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
1550         return true;
1551 
1552     return false;
1553 }
1554 
1555 bool RenderLayerCompositor::canCompositeClipPath(const RenderLayer&amp; layer)
1556 {
1557     ASSERT(layer.isComposited());
1558     ASSERT(layer.renderer().style().clipPath());
1559 
1560     if (layer.renderer().hasMask())
1561         return false;
1562 
1563     auto&amp; clipPath = *layer.renderer().style().clipPath();
1564     return (clipPath.type() != ClipPathOperation::Shape || clipPath.type() == ClipPathOperation::Shape) &amp;&amp; GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape);
1565 }
1566 
1567 // FIXME: remove and never ask questions about reflection layers.
1568 static RenderLayerModelObject&amp; rendererForCompositingTests(const RenderLayer&amp; layer)
1569 {
1570     auto* renderer = &amp;layer.renderer();
1571 
1572     // The compositing state of a reflection should match that of its reflected layer.
1573     if (layer.isReflection())
1574         renderer = downcast&lt;RenderLayerModelObject&gt;(renderer-&gt;parent()); // The RenderReplica&#39;s parent is the object being reflected.
1575 
1576     return *renderer;
1577 }
1578 
1579 void RenderLayerCompositor::updateRootContentLayerClipping()
1580 {
1581     m_rootContentsLayer-&gt;setMasksToBounds(!m_renderView.settings().backgroundShouldExtendBeyondPage());
1582 }
1583 
1584 bool RenderLayerCompositor::updateBacking(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint, BackingRequired backingRequired)
1585 {
1586     bool layerChanged = false;
1587     if (backingRequired == BackingRequired::Unknown)
1588         backingRequired = needsToBeComposited(layer, queryData) ? BackingRequired::Yes : BackingRequired::No;
1589     else {
1590         // Need to fetch viewportConstrainedNotCompositedReason, but without doing all the work that needsToBeComposited does.
1591         requiresCompositingForPosition(rendererForCompositingTests(layer), layer, queryData);
1592     }
1593 
1594     if (backingRequired == BackingRequired::Yes) {
1595         layer.disconnectFromBackingProviderLayer();
1596 
1597         enableCompositingMode();
1598 
1599         if (!layer.backing()) {
1600             // If we need to repaint, do so before making backing
1601             if (shouldRepaint == CompositingChangeRepaintNow)
1602                 repaintOnCompositingChange(layer); // wrong backing
1603 
1604             layer.ensureBacking();
1605 
1606             if (layer.isRenderViewLayer() &amp;&amp; useCoordinatedScrollingForLayer(layer)) {
1607                 auto&amp; frameView = m_renderView.frameView();
1608                 if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1609                     scrollingCoordinator-&gt;frameViewRootLayerDidChange(frameView);
1610 #if ENABLE(RUBBER_BANDING)
1611                 updateLayerForHeader(frameView.headerHeight());
1612                 updateLayerForFooter(frameView.footerHeight());
1613 #endif
1614                 updateRootContentLayerClipping();
1615 
1616                 if (auto* tiledBacking = layer.backing()-&gt;tiledBacking())
1617                     tiledBacking-&gt;setTopContentInset(frameView.topContentInset());
1618             }
1619 
1620             // This layer and all of its descendants have cached repaints rects that are relative to
1621             // the repaint container, so change when compositing changes; we need to update them here.
1622             if (layer.parent())
1623                 layer.computeRepaintRectsIncludingDescendants();
1624 
1625             layer.setNeedsCompositingGeometryUpdate();
1626             layer.setNeedsCompositingConfigurationUpdate();
1627             layer.setNeedsCompositingPaintOrderChildrenUpdate();
1628 
1629             layerChanged = true;
1630         }
1631     } else {
1632         if (layer.backing()) {
1633             // If we&#39;re removing backing on a reflection, clear the source GraphicsLayer&#39;s pointer to
1634             // its replica GraphicsLayer. In practice this should never happen because reflectee and reflection
1635             // are both either composited, or not composited.
1636             if (layer.isReflection()) {
1637                 auto* sourceLayer = downcast&lt;RenderLayerModelObject&gt;(*layer.renderer().parent()).layer();
1638                 if (auto* backing = sourceLayer-&gt;backing()) {
1639                     ASSERT(backing-&gt;graphicsLayer()-&gt;replicaLayer() == layer.backing()-&gt;graphicsLayer());
1640                     backing-&gt;graphicsLayer()-&gt;setReplicatedByLayer(nullptr);
1641                 }
1642             }
1643 
1644             layer.clearBacking();
1645             layerChanged = true;
1646 
1647             // This layer and all of its descendants have cached repaints rects that are relative to
1648             // the repaint container, so change when compositing changes; we need to update them here.
1649             layer.computeRepaintRectsIncludingDescendants();
1650 
1651             // If we need to repaint, do so now that we&#39;ve removed the backing
1652             if (shouldRepaint == CompositingChangeRepaintNow)
1653                 repaintOnCompositingChange(layer);
1654         }
1655     }
1656 
1657 #if ENABLE(VIDEO)
1658     if (layerChanged &amp;&amp; is&lt;RenderVideo&gt;(layer.renderer())) {
1659         // If it&#39;s a video, give the media player a chance to hook up to the layer.
1660         downcast&lt;RenderVideo&gt;(layer.renderer()).acceleratedRenderingStateChanged();
1661     }
1662 #endif
1663 
1664     if (layerChanged &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer())) {
1665         auto* innerCompositor = frameContentsCompositor(downcast&lt;RenderWidget&gt;(layer.renderer()));
1666         if (innerCompositor &amp;&amp; innerCompositor-&gt;usesCompositing())
1667             innerCompositor-&gt;updateRootLayerAttachment();
1668     }
1669 
1670     if (layerChanged)
1671         layer.clearClipRectsIncludingDescendants(PaintingClipRects);
1672 
1673     // If a fixed position layer gained/lost a backing or the reason not compositing it changed,
1674     // the scrolling coordinator needs to recalculate whether it can do fast scrolling.
1675     if (layer.renderer().isFixedPositioned()) {
1676         if (layer.viewportConstrainedNotCompositedReason() != queryData.nonCompositedForPositionReason) {
1677             layer.setViewportConstrainedNotCompositedReason(queryData.nonCompositedForPositionReason);
1678             layerChanged = true;
1679         }
1680         if (layerChanged) {
1681             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1682                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(m_renderView.frameView());
1683         }
1684     } else
1685         layer.setViewportConstrainedNotCompositedReason(RenderLayer::NoNotCompositedReason);
1686 
1687     if (layer.backing())
1688         layer.backing()-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1689 
1690     return layerChanged;
1691 }
1692 
1693 bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint)
1694 {
1695     bool layerChanged = updateBacking(layer, queryData, shouldRepaint);
1696 
1697     // See if we need content or clipping layers. Methods called here should assume
1698     // that the compositing state of descendant layers has not been updated yet.
1699     if (layer.backing() &amp;&amp; layer.backing()-&gt;updateConfiguration())
1700         layerChanged = true;
1701 
1702     return layerChanged;
1703 }
1704 
1705 void RenderLayerCompositor::repaintOnCompositingChange(RenderLayer&amp; layer)
1706 {
1707     // If the renderer is not attached yet, no need to repaint.
1708     if (&amp;layer.renderer() != &amp;m_renderView &amp;&amp; !layer.renderer().parent())
1709         return;
1710 
1711     auto* repaintContainer = layer.renderer().containerForRepaint();
1712     if (!repaintContainer)
1713         repaintContainer = &amp;m_renderView;
1714 
1715     layer.repaintIncludingNonCompositingDescendants(repaintContainer);
1716     if (repaintContainer == &amp;m_renderView) {
1717         // The contents of this layer may be moving between the window
1718         // and a GraphicsLayer, so we need to make sure the window system
1719         // synchronizes those changes on the screen.
1720         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1721     }
1722 }
1723 
1724 // This method assumes that layout is up-to-date, unlike repaintOnCompositingChange().
1725 void RenderLayerCompositor::repaintInCompositedAncestor(RenderLayer&amp; layer, const LayoutRect&amp; rect)
1726 {
1727     auto* compositedAncestor = layer.enclosingCompositingLayerForRepaint(ExcludeSelf);
1728     if (!compositedAncestor)
1729         return;
1730 
1731     ASSERT(compositedAncestor-&gt;backing());
1732     LayoutRect repaintRect = rect;
1733     repaintRect.move(layer.offsetFromAncestor(compositedAncestor));
1734     compositedAncestor-&gt;setBackingNeedsRepaintInRect(repaintRect);
1735 
1736     // The contents of this layer may be moving from a GraphicsLayer to the window,
1737     // so we need to make sure the window system synchronizes those changes on the screen.
1738     if (compositedAncestor-&gt;isRenderViewLayer())
1739         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1740 }
1741 
1742 // FIXME: remove.
1743 void RenderLayerCompositor::layerWasAdded(RenderLayer&amp;, RenderLayer&amp;)
1744 {
1745 }
1746 
1747 void RenderLayerCompositor::layerWillBeRemoved(RenderLayer&amp; parent, RenderLayer&amp; child)
1748 {
1749     if (parent.renderer().renderTreeBeingDestroyed())
1750         return;
1751 
1752     if (child.isComposited())
1753         repaintInCompositedAncestor(child, child.backing()-&gt;compositedBounds()); // FIXME: do via dirty bits?
1754     else if (child.paintsIntoProvidedBacking()) {
1755         auto* backingProviderLayer = child.backingProviderLayer();
1756         // FIXME: Optimize this repaint.
1757         backingProviderLayer-&gt;setBackingNeedsRepaint();
1758         backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(child);
1759     } else
1760         return;
1761 
1762     child.setNeedsCompositingLayerConnection();
1763 }
1764 
1765 RenderLayer* RenderLayerCompositor::enclosingNonStackingClippingLayer(const RenderLayer&amp; layer) const
1766 {
1767     for (auto* parent = layer.parent(); parent; parent = parent-&gt;parent()) {
1768         if (parent-&gt;isStackingContext())
1769             return nullptr;
1770         if (parent-&gt;renderer().hasClipOrOverflowClip())
1771             return parent;
1772     }
1773     return nullptr;
1774 }
1775 
1776 void RenderLayerCompositor::computeExtent(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const
1777 {
1778     if (extent.extentComputed)
1779         return;
1780 
1781     LayoutRect layerBounds;
1782     if (extent.hasTransformAnimation)
1783         extent.animationCausesExtentUncertainty = !layer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(layerBounds);
1784     else
1785         layerBounds = layer.overlapBounds();
1786 
1787     // In the animating transform case, we avoid double-accounting for the transform because
1788     // we told pushMappingsToAncestor() to ignore transforms earlier.
1789     extent.bounds = enclosingLayoutRect(overlapMap.geometryMap().absoluteRect(layerBounds));
1790 
1791     // Empty rects never intersect, but we need them to for the purposes of overlap testing.
1792     if (extent.bounds.isEmpty())
1793         extent.bounds.setSize(LayoutSize(1, 1));
1794 
1795     RenderLayerModelObject&amp; renderer = layer.renderer();
1796     if (renderer.isFixedPositioned() &amp;&amp; renderer.container() == &amp;m_renderView) {
1797         // Because fixed elements get moved around without re-computing overlap, we have to compute an overlap
1798         // rect that covers all the locations that the fixed element could move to.
1799         // FIXME: need to handle sticky too.
1800         extent.bounds = m_renderView.frameView().fixedScrollableAreaBoundsInflatedForScrolling(extent.bounds);
1801     }
1802 
1803     extent.extentComputed = true;
1804 }
1805 
1806 enum class AncestorTraversal { Continue, Stop };
1807 
1808 // This is a simplified version of containing block walking that only handles absolute position.
1809 template &lt;typename Function&gt;
1810 static AncestorTraversal traverseAncestorLayers(const RenderLayer&amp; layer, Function&amp;&amp; function)
1811 {
1812     bool containingBlockCanSkipLayers = layer.renderer().isAbsolutelyPositioned();
1813     RenderLayer* nextPaintOrderParent = layer.paintOrderParent();
1814 
1815     for (const auto* ancestorLayer = layer.parent(); ancestorLayer; ancestorLayer = ancestorLayer-&gt;parent()) {
1816         bool inContainingBlockChain = true;
1817 
1818         if (containingBlockCanSkipLayers)
1819             inContainingBlockChain = ancestorLayer-&gt;renderer().canContainAbsolutelyPositionedObjects();
1820 
1821         if (function(*ancestorLayer, inContainingBlockChain, ancestorLayer == nextPaintOrderParent) == AncestorTraversal::Stop)
1822             return AncestorTraversal::Stop;
1823 
1824         if (inContainingBlockChain)
1825             containingBlockCanSkipLayers = ancestorLayer-&gt;renderer().isAbsolutelyPositioned();
1826 
1827         if (ancestorLayer == nextPaintOrderParent)
1828             nextPaintOrderParent = ancestorLayer-&gt;paintOrderParent();
1829     }
1830 
1831     return AncestorTraversal::Continue;
1832 }
1833 
1834 static bool createsClippingScope(const RenderLayer&amp; layer)
1835 {
1836     return layer.hasCompositedScrollableOverflow();
1837 }
1838 
1839 static Vector&lt;LayerOverlapMap::LayerAndBounds&gt; enclosingClippingScopes(const RenderLayer&amp; layer, const RenderLayer&amp; rootLayer)
1840 {
1841     Vector&lt;LayerOverlapMap::LayerAndBounds&gt; clippingScopes;
1842     clippingScopes.append({ const_cast&lt;RenderLayer&amp;&gt;(rootLayer), { } });
1843 
1844     if (!layer.hasCompositedScrollingAncestor())
1845         return clippingScopes;
1846 
1847     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {
1848         if (inContainingBlockChain &amp;&amp; createsClippingScope(ancestorLayer)) {
1849             LayoutRect clipRect;
1850             if (is&lt;RenderBox&gt;(ancestorLayer.renderer())) {
1851                 // FIXME: This is expensive. Broken with transforms.
1852                 LayoutPoint offsetFromRoot = ancestorLayer.convertToLayerCoords(&amp;rootLayer, { });
1853                 clipRect = downcast&lt;RenderBox&gt;(ancestorLayer.renderer()).overflowClipRect(offsetFromRoot);
1854             }
1855 
1856             LayerOverlapMap::LayerAndBounds layerAndBounds { const_cast&lt;RenderLayer&amp;&gt;(ancestorLayer), clipRect };
1857             clippingScopes.insert(1, layerAndBounds); // Order is roots to leaves.
1858         }
1859         return AncestorTraversal::Continue;
1860     });
1861 
1862     return clippingScopes;
1863 }
1864 
1865 void RenderLayerCompositor::addToOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const
1866 {
1867     if (layer.isRenderViewLayer())
1868         return;
1869 
1870     computeExtent(overlapMap, layer, extent);
1871 
1872     // FIXME: constrain the scopes (by composited stacking context ancestor I think).
1873     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());
1874 
1875     LayoutRect clipRect;
1876     if (layer.hasCompositedScrollingAncestor()) {
1877         // Compute a clip up to the composited scrolling ancestor, then convert it to absolute coordinates.
1878         auto&amp; scrollingScope = clippingScopes.last();
1879         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;scrollingScope.layer, TemporaryClipRects, IgnoreOverlayScrollbarSize, IgnoreOverflowClip)).rect();
1880         if (!clipRect.isInfinite())
1881             clipRect.setLocation(layer.convertToLayerCoords(&amp;rootRenderLayer(), clipRect.location()));
1882     } else
1883         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.
1884 
1885     auto clippedBounds = extent.bounds;
1886     if (!clipRect.isInfinite()) {
1887         // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.
1888         if (!m_renderView.settings().delegatesPageScaling())
1889             clipRect.scale(pageScaleFactor());
1890 
1891         clippedBounds.intersect(clipRect);
1892     }
1893 
1894     overlapMap.add(layer, clippedBounds, clippingScopes);
1895 }
1896 
1897 void RenderLayerCompositor::addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const
1898 {
1899     if (!canBeComposited(layer))
1900         return;
1901 
1902     // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
1903     if (ancestorLayer) {
1904         overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
1905 
1906         OverlapExtent layerExtent;
1907         addToOverlapMap(overlapMap, layer, layerExtent);
1908     }
1909 
1910 #if !ASSERT_DISABLED
1911     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
1912 #endif
1913 
1914     for (auto* renderLayer : layer.negativeZOrderLayers())
1915         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1916 
1917     for (auto* renderLayer : layer.normalFlowLayers())
1918         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1919 
1920     for (auto* renderLayer : layer.positiveZOrderLayers())
1921         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1922 
1923     if (ancestorLayer)
1924         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1925 }
1926 
1927 void RenderLayerCompositor::updateOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap) const
1928 {
1929     if (addLayerToOverlap) {
1930         addToOverlapMap(overlapMap, layer, layerExtent);
1931         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; contributes to overlap, added to map &quot; &lt;&lt; overlapMap);
1932     }
1933 
1934     if (addDescendantsToOverlap) {
1935         // If this is the first non-root layer to composite, we need to add all the descendants we already traversed to the overlap map.
1936         addDescendantsToOverlapMapRecursive(overlapMap, layer);
1937         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; composited post descendant traversal, added recursive &quot; &lt;&lt; overlapMap);
1938     }
1939 
1940     if (didPushContainer) {
1941         overlapMap.popCompositingContainer();
1942         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is composited or shared, popped container &quot; &lt;&lt; overlapMap);
1943     }
1944 }
1945 
1946 bool RenderLayerCompositor::layerOverlaps(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent) const
1947 {
1948     computeExtent(overlapMap, layer, layerExtent);
1949 
1950     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());
1951     return overlapMap.overlapsLayers(layer, layerExtent.bounds, clippingScopes);
1952 }
1953 
1954 #if ENABLE(VIDEO)
1955 bool RenderLayerCompositor::canAccelerateVideoRendering(RenderVideo&amp; video) const
1956 {
1957     if (!m_hasAcceleratedCompositing)
1958         return false;
1959 
1960     return video.supportsAcceleratedRendering();
1961 }
1962 #endif
1963 
1964 void RenderLayerCompositor::frameViewDidChangeLocation(const IntPoint&amp; contentsOffset)
1965 {
1966     if (m_overflowControlsHostLayer)
1967         m_overflowControlsHostLayer-&gt;setPosition(contentsOffset);
1968 }
1969 
1970 void RenderLayerCompositor::frameViewDidChangeSize()
1971 {
1972     if (auto* layer = m_renderView.layer())
1973         layer-&gt;setNeedsCompositingGeometryUpdate();
1974 
1975     if (m_scrolledContentsLayer) {
1976         updateScrollLayerClipping();
1977         frameViewDidScroll();
1978         updateOverflowControlsLayers();
1979 
1980 #if ENABLE(RUBBER_BANDING)
1981         if (m_layerForOverhangAreas) {
1982             auto&amp; frameView = m_renderView.frameView();
1983             m_layerForOverhangAreas-&gt;setSize(frameView.frameRect().size());
1984             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, frameView.topContentInset()));
1985         }
1986 #endif
1987     }
1988 }
1989 
1990 void RenderLayerCompositor::widgetDidChangeSize(RenderWidget&amp; widget)
1991 {
1992     if (!widget.hasLayer())
1993         return;
1994 
1995     auto&amp; layer = *widget.layer();
1996 
1997     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; widgetDidChangeSize (layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;)&quot;);
1998 
1999     // Widget size affects answer to requiresCompositingForFrame() so we need to trigger
2000     // a compositing update.
2001     layer.setNeedsPostLayoutCompositingUpdate();
2002     scheduleCompositingLayerUpdate();
2003 
2004     if (layer.isComposited())
2005         layer.backing()-&gt;updateAfterWidgetResize();
2006 }
2007 
2008 bool RenderLayerCompositor::hasCoordinatedScrolling() const
2009 {
2010     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
2011     return scrollingCoordinator &amp;&amp; scrollingCoordinator-&gt;coordinatesScrollingForFrameView(m_renderView.frameView());
2012 }
2013 
2014 void RenderLayerCompositor::updateScrollLayerPosition()
2015 {
2016     ASSERT(!hasCoordinatedScrolling());
2017     ASSERT(m_scrolledContentsLayer);
2018 
2019     auto&amp; frameView = m_renderView.frameView();
2020     IntPoint scrollPosition = frameView.scrollPosition();
2021 
2022     // We use scroll position here because the root content layer is offset to account for scrollOrigin (see FrameView::positionForRootContentLayer).
2023     m_scrolledContentsLayer-&gt;setPosition(FloatPoint(-scrollPosition.x(), -scrollPosition.y()));
2024 
2025     if (auto* fixedBackgroundLayer = fixedRootBackgroundLayer())
2026         fixedBackgroundLayer-&gt;setPosition(frameView.scrollPositionForFixedPosition());
2027 }
2028 
2029 void RenderLayerCompositor::updateScrollLayerClipping()
2030 {
2031     auto* layerForClipping = this-&gt;layerForClipping();
2032     if (!layerForClipping)
2033         return;
2034 
2035     layerForClipping-&gt;setSize(m_renderView.frameView().sizeForVisibleContent());
2036     layerForClipping-&gt;setPosition(positionForClipLayer());
2037 }
2038 
2039 FloatPoint RenderLayerCompositor::positionForClipLayer() const
2040 {
2041     auto&amp; frameView = m_renderView.frameView();
2042 
2043     return FloatPoint(
2044         frameView.shouldPlaceBlockDirectionScrollbarOnLeft() ? frameView.horizontalScrollbarIntrusion() : 0,
2045         FrameView::yPositionForInsetClipLayer(frameView.scrollPosition(), frameView.topContentInset()));
2046 }
2047 
2048 void RenderLayerCompositor::frameViewDidScroll()
2049 {
2050     if (!m_scrolledContentsLayer)
2051         return;
2052 
2053     // If there&#39;s a scrolling coordinator that manages scrolling for this frame view,
2054     // it will also manage updating the scroll layer position.
2055     if (hasCoordinatedScrolling()) {
2056         // We have to schedule a flush in order for the main TiledBacking to update its tile coverage.
2057         scheduleLayerFlush();
2058         return;
2059     }
2060 
2061     updateScrollLayerPosition();
2062 }
2063 
2064 void RenderLayerCompositor::frameViewDidAddOrRemoveScrollbars()
2065 {
2066     updateOverflowControlsLayers();
2067 }
2068 
2069 void RenderLayerCompositor::frameViewDidLayout()
2070 {
2071     if (auto* renderViewBacking = m_renderView.layer()-&gt;backing())
2072         renderViewBacking-&gt;adjustTiledBackingCoverage();
2073 }
2074 
2075 void RenderLayerCompositor::rootLayerConfigurationChanged()
2076 {
2077     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
2078     if (renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking()) {
2079         m_renderView.layer()-&gt;setNeedsCompositingConfigurationUpdate();
2080         scheduleCompositingLayerUpdate();
2081     }
2082 }
2083 
2084 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
2085 {
2086     updateCompositingLayers(CompositingUpdateType::AfterLayout);
2087 
2088     if (!m_rootContentsLayer)
2089         return String();
2090 
2091     flushPendingLayerChanges(true);
2092     page().renderingUpdateScheduler().scheduleImmediateRenderingUpdate();
2093 
2094     LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
2095     if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
2096         layerTreeBehavior |= LayerTreeAsTextDebug;
2097     if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
2098         layerTreeBehavior |= LayerTreeAsTextIncludeVisibleRects;
2099     if (flags &amp; LayerTreeFlagsIncludeTileCaches)
2100         layerTreeBehavior |= LayerTreeAsTextIncludeTileCaches;
2101     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2102         layerTreeBehavior |= LayerTreeAsTextIncludeRepaintRects;
2103     if (flags &amp; LayerTreeFlagsIncludePaintingPhases)
2104         layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
2105     if (flags &amp; LayerTreeFlagsIncludeContentLayers)
2106         layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
2107     if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
2108         layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;
2109     if (flags &amp; LayerTreeFlagsIncludeClipping)
2110         layerTreeBehavior |= LayerTreeAsTextIncludeClipping;
2111     if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
2112         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
2113     if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
2114         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
2115     if (flags &amp; LayerTreeFlagsIncludeEventRegion)
2116         layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;
2117 
2118     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
2119     // similar between platforms.
2120     String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
2121 
2122     // Dump an empty layer tree only if the only composited layer is the main frame&#39;s tiled backing,
2123     // so that tests expecting us to drop out of accelerated compositing when there are no layers succeed.
2124     if (!hasContentCompositingLayers() &amp;&amp; documentUsesTiledBacking() &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeTileCaches) &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeRootLayerProperties))
2125         layerTreeText = emptyString();
2126 
2127     // The true root layer is not included in the dump, so if we want to report
2128     // its repaint rects, they must be included here.
2129     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2130         return m_renderView.frameView().trackedRepaintRectsAsText() + layerTreeText;
2131 
2132     return layerTreeText;
2133 }
2134 
2135 static RenderView* frameContentsRenderView(RenderWidget&amp; renderer)
2136 {
2137     if (auto* contentDocument = renderer.frameOwnerElement().contentDocument())
2138         return contentDocument-&gt;renderView();
2139 
2140     return nullptr;
2141 }
2142 
2143 RenderLayerCompositor* RenderLayerCompositor::frameContentsCompositor(RenderWidget&amp; renderer)
2144 {
2145     if (auto* view = frameContentsRenderView(renderer))
2146         return &amp;view-&gt;compositor();
2147 
2148     return nullptr;
2149 }
2150 
2151 bool RenderLayerCompositor::parentFrameContentLayers(RenderWidget&amp; renderer)
2152 {
2153     auto* innerCompositor = frameContentsCompositor(renderer);
2154     if (!innerCompositor || !innerCompositor-&gt;usesCompositing() || innerCompositor-&gt;rootLayerAttachment() != RootLayerAttachedViaEnclosingFrame)
2155         return false;
2156 
2157     auto* layer = renderer.layer();
2158     if (!layer-&gt;isComposited())
2159         return false;
2160 
2161     auto* backing = layer-&gt;backing();
2162     auto* hostingLayer = backing-&gt;parentForSublayers();
2163     auto* rootLayer = innerCompositor-&gt;rootGraphicsLayer();
2164     if (hostingLayer-&gt;children().size() != 1 || hostingLayer-&gt;children()[0].ptr() != rootLayer) {
2165         hostingLayer-&gt;removeAllChildren();
2166         hostingLayer-&gt;addChild(*rootLayer);
2167     }
2168 
2169     if (auto frameHostingNodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting)) {
2170         auto* contentsRenderView = frameContentsRenderView(renderer);
2171         if (auto frameRootScrollingNodeID = contentsRenderView-&gt;frameView().scrollingNodeID()) {
2172             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
2173                 scrollingCoordinator-&gt;insertNode(ScrollingNodeType::Subframe, frameRootScrollingNodeID, frameHostingNodeID, 0);
2174         }
2175     }
2176 
2177     // FIXME: Why always return true and not just when the layers changed?
2178     return true;
2179 }
2180 
2181 void RenderLayerCompositor::repaintCompositedLayers()
2182 {
2183     recursiveRepaintLayer(rootRenderLayer());
2184 }
2185 
2186 void RenderLayerCompositor::recursiveRepaintLayer(RenderLayer&amp; layer)
2187 {
2188     layer.updateLayerListsIfNeeded();
2189 
2190     // FIXME: This method does not work correctly with transforms.
2191     if (layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor())
2192         layer.setBackingNeedsRepaint();
2193 
2194 #if !ASSERT_DISABLED
2195     LayerListMutationDetector mutationChecker(layer);
2196 #endif
2197 
2198     if (layer.hasCompositingDescendant()) {
2199         for (auto* renderLayer : layer.negativeZOrderLayers())
2200             recursiveRepaintLayer(*renderLayer);
2201 
2202         for (auto* renderLayer : layer.positiveZOrderLayers())
2203             recursiveRepaintLayer(*renderLayer);
2204     }
2205 
2206     for (auto* renderLayer : layer.normalFlowLayers())
2207         recursiveRepaintLayer(*renderLayer);
2208 }
2209 
2210 RenderLayer&amp; RenderLayerCompositor::rootRenderLayer() const
2211 {
2212     return *m_renderView.layer();
2213 }
2214 
2215 GraphicsLayer* RenderLayerCompositor::rootGraphicsLayer() const
2216 {
2217     if (m_overflowControlsHostLayer)
2218         return m_overflowControlsHostLayer.get();
2219     return m_rootContentsLayer.get();
2220 }
2221 
2222 void RenderLayerCompositor::setIsInWindow(bool isInWindow)
2223 {
2224     LOG(Compositing, &quot;RenderLayerCompositor %p setIsInWindow %d&quot;, this, isInWindow);
2225 
2226     if (!usesCompositing())
2227         return;
2228 
2229     if (auto* rootLayer = rootGraphicsLayer()) {
2230         GraphicsLayer::traverse(*rootLayer, [isInWindow](GraphicsLayer&amp; layer) {
2231             layer.setIsInWindow(isInWindow);
2232         });
2233     }
2234 
2235     if (isInWindow) {
2236         if (m_rootLayerAttachment != RootLayerUnattached)
2237             return;
2238 
2239         RootLayerAttachment attachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
2240         attachRootLayer(attachment);
2241 #if PLATFORM(IOS_FAMILY)
2242         if (m_legacyScrollingLayerCoordinator) {
2243             m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
2244             m_legacyScrollingLayerCoordinator-&gt;registerAllScrollingLayers();
2245         }
2246 #endif
2247     } else {
2248         if (m_rootLayerAttachment == RootLayerUnattached)
2249             return;
2250 
2251         detachRootLayer();
2252 #if PLATFORM(IOS_FAMILY)
2253         if (m_legacyScrollingLayerCoordinator) {
2254             m_legacyScrollingLayerCoordinator-&gt;unregisterAllViewportConstrainedLayers();
2255             m_legacyScrollingLayerCoordinator-&gt;unregisterAllScrollingLayers();
2256         }
2257 #endif
2258     }
2259 }
2260 
2261 void RenderLayerCompositor::clearBackingForLayerIncludingDescendants(RenderLayer&amp; layer)
2262 {
2263     if (layer.isComposited())
2264         layer.clearBacking();
2265 
2266     for (auto* childLayer = layer.firstChild(); childLayer; childLayer = childLayer-&gt;nextSibling())
2267         clearBackingForLayerIncludingDescendants(*childLayer);
2268 }
2269 
2270 void RenderLayerCompositor::clearBackingForAllLayers()
2271 {
2272     clearBackingForLayerIncludingDescendants(*m_renderView.layer());
2273 }
2274 
2275 void RenderLayerCompositor::updateRootLayerPosition()
2276 {
2277     if (m_rootContentsLayer) {
2278         m_rootContentsLayer-&gt;setSize(m_renderView.frameView().contentsSize());
2279         m_rootContentsLayer-&gt;setPosition(m_renderView.frameView().positionForRootContentLayer());
2280         m_rootContentsLayer-&gt;setAnchorPoint(FloatPoint3D());
2281     }
2282 
2283     updateScrollLayerClipping();
2284 
2285 #if ENABLE(RUBBER_BANDING)
2286     if (m_contentShadowLayer &amp;&amp; m_rootContentsLayer) {
2287         m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
2288         m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
2289     }
2290 
2291     updateLayerForTopOverhangArea(m_layerForTopOverhangArea != nullptr);
2292     updateLayerForBottomOverhangArea(m_layerForBottomOverhangArea != nullptr);
2293     updateLayerForHeader(m_layerForHeader != nullptr);
2294     updateLayerForFooter(m_layerForFooter != nullptr);
2295 #endif
2296 }
2297 
2298 bool RenderLayerCompositor::has3DContent() const
2299 {
2300     return layerHas3DContent(rootRenderLayer());
2301 }
2302 
2303 bool RenderLayerCompositor::needsToBeComposited(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2304 {
2305     if (!canBeComposited(layer))
2306         return false;
2307 
2308     return requiresCompositingLayer(layer, queryData) || layer.mustCompositeForIndirectReasons() || (usesCompositing() &amp;&amp; layer.isRenderViewLayer());
2309 }
2310 
2311 // Note: this specifies whether the RL needs a compositing layer for intrinsic reasons.
2312 // Use needsToBeComposited() to determine if a RL actually needs a compositing layer.
2313 // FIXME: is clipsCompositingDescendants() an intrinsic reason?
2314 bool RenderLayerCompositor::requiresCompositingLayer(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2315 {
2316     auto&amp; renderer = rendererForCompositingTests(layer);
2317 
2318     // The root layer always has a compositing layer, but it may not have backing.
2319     return requiresCompositingForTransform(renderer)
2320         || requiresCompositingForAnimation(renderer)
2321         || clipsCompositingDescendants(*renderer.layer())
2322         || requiresCompositingForPosition(renderer, *renderer.layer(), queryData)
2323         || requiresCompositingForCanvas(renderer)
2324         || requiresCompositingForFilters(renderer)
2325         || requiresCompositingForWillChange(renderer)
2326         || requiresCompositingForBackfaceVisibility(renderer)
2327         || requiresCompositingForVideo(renderer)
2328         || requiresCompositingForFrame(renderer, queryData)
2329         || requiresCompositingForPlugin(renderer, queryData)
2330         || requiresCompositingForEditableImage(renderer)
2331         || requiresCompositingForOverflowScrolling(*renderer.layer(), queryData);
2332 }
2333 
2334 bool RenderLayerCompositor::canBeComposited(const RenderLayer&amp; layer) const
2335 {
2336     if (m_hasAcceleratedCompositing &amp;&amp; layer.isSelfPaintingLayer()) {
2337         if (!layer.isInsideFragmentedFlow())
2338             return true;
2339 
2340         // CSS Regions flow threads do not need to be composited as we use composited RenderFragmentContainers
2341         // to render the background of the RenderFragmentedFlow.
2342         if (layer.isRenderFragmentedFlow())
2343             return false;
2344 
2345         return true;
2346     }
2347     return false;
2348 }
2349 
2350 #if ENABLE(FULLSCREEN_API)
2351 enum class FullScreenDescendant { Yes, No, NotApplicable };
2352 static FullScreenDescendant isDescendantOfFullScreenLayer(const RenderLayer&amp; layer)
2353 {
2354     auto&amp; document = layer.renderer().document();
2355 
2356     if (!document.fullscreenManager().isFullscreen() || !document.fullscreenManager().fullscreenRenderer())
2357         return FullScreenDescendant::NotApplicable;
2358 
2359     auto* fullScreenLayer = document.fullscreenManager().fullscreenRenderer()-&gt;layer();
2360     if (!fullScreenLayer) {
2361         ASSERT_NOT_REACHED();
2362         return FullScreenDescendant::NotApplicable;
2363     }
2364 
2365     return layer.isDescendantOf(*fullScreenLayer) ? FullScreenDescendant::Yes : FullScreenDescendant::No;
2366 }
2367 #endif
2368 
2369 bool RenderLayerCompositor::requiresOwnBackingStore(const RenderLayer&amp; layer, const RenderLayer* compositingAncestorLayer, const LayoutRect&amp; layerCompositedBoundsInAncestor, const LayoutRect&amp; ancestorCompositedBounds) const
2370 {
2371     auto&amp; renderer = layer.renderer();
2372 
2373     if (compositingAncestorLayer
2374         &amp;&amp; !(compositingAncestorLayer-&gt;backing()-&gt;graphicsLayer()-&gt;drawsContent()
2375             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoWindow()
2376             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoCompositedAncestor()))
2377         return true;
2378 
2379     RequiresCompositingData queryData;
2380     if (layer.isRenderViewLayer()
2381         || layer.transform() // note: excludes perspective and transformStyle3D.
2382         || requiresCompositingForAnimation(renderer)
2383         || requiresCompositingForPosition(renderer, layer, queryData)
2384         || requiresCompositingForCanvas(renderer)
2385         || requiresCompositingForFilters(renderer)
2386         || requiresCompositingForWillChange(renderer)
2387         || requiresCompositingForBackfaceVisibility(renderer)
2388         || requiresCompositingForVideo(renderer)
2389         || requiresCompositingForFrame(renderer, queryData)
2390         || requiresCompositingForPlugin(renderer, queryData)
2391         || requiresCompositingForEditableImage(renderer)
2392         || requiresCompositingForOverflowScrolling(layer, queryData)
2393         || needsContentsCompositingLayer(layer)
2394         || renderer.isTransparent()
2395         || renderer.hasMask()
2396         || renderer.hasReflection()
2397         || renderer.hasFilter()
2398         || renderer.hasBackdropFilter())
2399         return true;
2400 
2401     if (layer.mustCompositeForIndirectReasons()) {
2402         IndirectCompositingReason reason = layer.indirectCompositingReason();
2403         return reason == IndirectCompositingReason::Overlap
2404             || reason == IndirectCompositingReason::OverflowScrollPositioning
2405             || reason == IndirectCompositingReason::Stacking
2406             || reason == IndirectCompositingReason::BackgroundLayer
2407             || reason == IndirectCompositingReason::GraphicalEffect
2408             || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
2409     }
2410 
2411     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
2412         return true;
2413 
2414     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())
2415         return true;
2416 
2417     return false;
2418 }
2419 
2420 OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
2421 {
2422     OptionSet&lt;CompositingReason&gt; reasons;
2423 
2424     if (!layer.isComposited())
2425         return reasons;
2426 
2427     RequiresCompositingData queryData;
2428 
2429     auto&amp; renderer = rendererForCompositingTests(layer);
2430 
2431     if (requiresCompositingForTransform(renderer))
2432         reasons.add(CompositingReason::Transform3D);
2433 
2434     if (requiresCompositingForVideo(renderer))
2435         reasons.add(CompositingReason::Video);
2436     else if (requiresCompositingForCanvas(renderer))
2437         reasons.add(CompositingReason::Canvas);
2438     else if (requiresCompositingForPlugin(renderer, queryData))
2439         reasons.add(CompositingReason::Plugin);
2440     else if (requiresCompositingForFrame(renderer, queryData))
2441         reasons.add(CompositingReason::IFrame);
2442     else if (requiresCompositingForEditableImage(renderer))
2443         reasons.add(CompositingReason::EmbeddedView);
2444 
2445     if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
2446         reasons.add(CompositingReason::BackfaceVisibilityHidden);
2447 
2448     if (clipsCompositingDescendants(*renderer.layer()))
2449         reasons.add(CompositingReason::ClipsCompositingDescendants);
2450 
2451     if (requiresCompositingForAnimation(renderer))
2452         reasons.add(CompositingReason::Animation);
2453 
2454     if (requiresCompositingForFilters(renderer))
2455         reasons.add(CompositingReason::Filters);
2456 
2457     if (requiresCompositingForWillChange(renderer))
2458         reasons.add(CompositingReason::WillChange);
2459 
2460     if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
2461         reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
2462 
2463     if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
2464         reasons.add(CompositingReason::OverflowScrolling);
2465 
2466     switch (renderer.layer()-&gt;indirectCompositingReason()) {
2467     case IndirectCompositingReason::None:
2468         break;
2469     case IndirectCompositingReason::Stacking:
2470         reasons.add(CompositingReason::Stacking);
2471         break;
2472     case IndirectCompositingReason::OverflowScrollPositioning:
2473         reasons.add(CompositingReason::OverflowScrollPositioning);
2474         break;
2475     case IndirectCompositingReason::Overlap:
2476         reasons.add(CompositingReason::Overlap);
2477         break;
2478     case IndirectCompositingReason::BackgroundLayer:
2479         reasons.add(CompositingReason::NegativeZIndexChildren);
2480         break;
2481     case IndirectCompositingReason::GraphicalEffect:
2482         if (renderer.hasTransform())
2483             reasons.add(CompositingReason::TransformWithCompositedDescendants);
2484 
2485         if (renderer.isTransparent())
2486             reasons.add(CompositingReason::OpacityWithCompositedDescendants);
2487 
2488         if (renderer.hasMask())
2489             reasons.add(CompositingReason::MaskWithCompositedDescendants);
2490 
2491         if (renderer.hasReflection())
2492             reasons.add(CompositingReason::ReflectionWithCompositedDescendants);
2493 
2494         if (renderer.hasFilter() || renderer.hasBackdropFilter())
2495             reasons.add(CompositingReason::FilterWithCompositedDescendants);
2496 
2497 #if ENABLE(CSS_COMPOSITING)
2498         if (layer.isolatesCompositedBlending())
2499             reasons.add(CompositingReason::IsolatesCompositedBlendingDescendants);
2500 
2501         if (layer.hasBlendMode())
2502             reasons.add(CompositingReason::BlendingWithCompositedDescendants);
2503 #endif
2504         break;
2505     case IndirectCompositingReason::Perspective:
2506         reasons.add(CompositingReason::Perspective);
2507         break;
2508     case IndirectCompositingReason::Preserve3D:
2509         reasons.add(CompositingReason::Preserve3D);
2510         break;
2511     }
2512 
2513     if (usesCompositing() &amp;&amp; renderer.layer()-&gt;isRenderViewLayer())
2514         reasons.add(CompositingReason::Root);
2515 
2516     return reasons;
2517 }
2518 
2519 #if !LOG_DISABLED
2520 const char* RenderLayerCompositor::logReasonsForCompositing(const RenderLayer&amp; layer)
2521 {
2522     OptionSet&lt;CompositingReason&gt; reasons = reasonsForCompositing(layer);
2523 
2524     if (reasons &amp; CompositingReason::Transform3D)
2525         return &quot;3D transform&quot;;
2526 
2527     if (reasons &amp; CompositingReason::Video)
2528         return &quot;video&quot;;
2529 
2530     if (reasons &amp; CompositingReason::Canvas)
2531         return &quot;canvas&quot;;
2532 
2533     if (reasons &amp; CompositingReason::Plugin)
2534         return &quot;plugin&quot;;
2535 
2536     if (reasons &amp; CompositingReason::IFrame)
2537         return &quot;iframe&quot;;
2538 
2539     if (reasons &amp; CompositingReason::BackfaceVisibilityHidden)
2540         return &quot;backface-visibility: hidden&quot;;
2541 
2542     if (reasons &amp; CompositingReason::ClipsCompositingDescendants)
2543         return &quot;clips compositing descendants&quot;;
2544 
2545     if (reasons &amp; CompositingReason::Animation)
2546         return &quot;animation&quot;;
2547 
2548     if (reasons &amp; CompositingReason::Filters)
2549         return &quot;filters&quot;;
2550 
2551     if (reasons &amp; CompositingReason::PositionFixed)
2552         return &quot;position: fixed&quot;;
2553 
2554     if (reasons &amp; CompositingReason::PositionSticky)
2555         return &quot;position: sticky&quot;;
2556 
2557     if (reasons &amp; CompositingReason::OverflowScrolling)
2558         return &quot;async overflow scrolling&quot;;
2559 
2560     if (reasons &amp; CompositingReason::Stacking)
2561         return &quot;stacking&quot;;
2562 
2563     if (reasons &amp; CompositingReason::Overlap)
2564         return &quot;overlap&quot;;
2565 
2566     if (reasons &amp; CompositingReason::NegativeZIndexChildren)
2567         return &quot;negative z-index children&quot;;
2568 
2569     if (reasons &amp; CompositingReason::TransformWithCompositedDescendants)
2570         return &quot;transform with composited descendants&quot;;
2571 
2572     if (reasons &amp; CompositingReason::OpacityWithCompositedDescendants)
2573         return &quot;opacity with composited descendants&quot;;
2574 
2575     if (reasons &amp; CompositingReason::MaskWithCompositedDescendants)
2576         return &quot;mask with composited descendants&quot;;
2577 
2578     if (reasons &amp; CompositingReason::ReflectionWithCompositedDescendants)
2579         return &quot;reflection with composited descendants&quot;;
2580 
2581     if (reasons &amp; CompositingReason::FilterWithCompositedDescendants)
2582         return &quot;filter with composited descendants&quot;;
2583 
2584 #if ENABLE(CSS_COMPOSITING)
2585     if (reasons &amp; CompositingReason::BlendingWithCompositedDescendants)
2586         return &quot;blending with composited descendants&quot;;
2587 
2588     if (reasons &amp; CompositingReason::IsolatesCompositedBlendingDescendants)
2589         return &quot;isolates composited blending descendants&quot;;
2590 #endif
2591 
2592     if (reasons &amp; CompositingReason::Perspective)
2593         return &quot;perspective&quot;;
2594 
2595     if (reasons &amp; CompositingReason::Preserve3D)
2596         return &quot;preserve-3d&quot;;
2597 
2598     if (reasons &amp; CompositingReason::Root)
2599         return &quot;root&quot;;
2600 
2601     return &quot;&quot;;
2602 }
2603 #endif
2604 
2605 // Return true if the given layer has some ancestor in the RenderLayer hierarchy that clips,
2606 // up to the enclosing compositing ancestor. This is required because compositing layers are parented
2607 // according to the z-order hierarchy, yet clipping goes down the renderer hierarchy.
2608 // Thus, a RenderLayer can be clipped by a RenderLayer that is an ancestor in the renderer hierarchy,
2609 // but a sibling in the z-order hierarchy.
2610 // FIXME: can we do this without a tree walk?
2611 bool RenderLayerCompositor::clippedByAncestor(RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const
2612 {
2613     ASSERT(layer.isComposited());
2614     if (!compositingAncestor)
2615         return false;
2616 
2617     // If the compositingAncestor clips, that will be taken care of by clipsCompositingDescendants(),
2618     // so we only care about clipping between its first child that is our ancestor (the computeClipRoot),
2619     // and layer. The exception is when the compositingAncestor isolates composited blending children,
2620     // in this case it is not allowed to clipsCompositingDescendants() and each of its children
2621     // will be clippedByAncestor()s, including the compositingAncestor.
2622     auto* computeClipRoot = compositingAncestor;
2623     if (!compositingAncestor-&gt;isolatesCompositedBlending()) {
2624         computeClipRoot = nullptr;
2625         auto* parent = &amp;layer;
2626         while (parent) {
2627             auto* next = parent-&gt;parent();
2628             if (next == compositingAncestor) {
2629                 computeClipRoot = parent;
2630                 break;
2631             }
2632             parent = next;
2633         }
2634 
2635         if (!computeClipRoot || computeClipRoot == &amp;layer)
2636             return false;
2637     }
2638 
2639     return !layer.backgroundClipRect(RenderLayer::ClipRectsContext(computeClipRoot, TemporaryClipRects)).isInfinite(); // FIXME: Incorrect for CSS regions.
2640 }
2641 
2642 bool RenderLayerCompositor::updateAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const
2643 {
2644     ASSERT(layer.isComposited());
2645 
2646     auto clippingStack = computeAncestorClippingStack(layer, compositingAncestor);
2647     return layer.backing()-&gt;updateAncestorClippingStack(WTFMove(clippingStack));
2648 }
2649 
2650 Vector&lt;CompositedClipData&gt; RenderLayerCompositor::computeAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const
2651 {
2652     // On first pass in WK1, the root may not have become composited yet.
2653     if (!compositingAncestor)
2654         return { };
2655 
2656     // We&#39;ll start by building a child-to-ancestors stack.
2657     Vector&lt;CompositedClipData&gt; newStack;
2658 
2659     // Walk up the containing block chain to composited ancestor, prepending an entry to the clip stack for:
2660     // * each composited scrolling layer
2661     // * each set of RenderLayers which contribute a clip.
2662     bool haveNonScrollableClippingIntermediateLayer = false;
2663     const RenderLayer* currentClippedLayer = &amp;layer;
2664 
2665     auto pushNonScrollableClip = [&amp;](const RenderLayer&amp; clippedLayer, const RenderLayer&amp; clippingRoot, ShouldRespectOverflowClip respectClip = IgnoreOverflowClip) {
2666         // Pass IgnoreOverflowClip to ignore overflow contributed by clippingRoot (which may be a scroller).
2667         auto clipRect = clippedLayer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;clippingRoot, TemporaryClipRects, IgnoreOverlayScrollbarSize, respectClip)).rect();
2668         auto offset = layer.convertToLayerCoords(&amp;clippingRoot, { }, RenderLayer::AdjustForColumns);
2669         clipRect.moveBy(-offset);
2670 
2671         CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;clippedLayer), clipRect, false };
2672         newStack.insert(0, WTFMove(clipData));
2673     };
2674 
2675     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {
2676         if (&amp;ancestorLayer == compositingAncestor) {
2677 
2678             if (haveNonScrollableClippingIntermediateLayer)
2679                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, ancestorLayer.isolatesCompositedBlending() ? RespectOverflowClip : IgnoreOverflowClip);
2680             else if (ancestorLayer.isolatesCompositedBlending() &amp;&amp; newStack.isEmpty())
2681                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, RespectOverflowClip);
2682 
2683             return AncestorTraversal::Stop;
2684         }
2685 
2686         if (isContainingBlockChain &amp;&amp; ancestorLayer.renderer().hasClipOrOverflowClip()) {
2687             if (ancestorLayer.hasCompositedScrollableOverflow()) {
2688                 if (haveNonScrollableClippingIntermediateLayer) {
2689                     pushNonScrollableClip(*currentClippedLayer, ancestorLayer);
2690                     haveNonScrollableClippingIntermediateLayer = false;
2691                 }
2692 
2693                 auto clipRect = parentRelativeScrollableRect(ancestorLayer, &amp;ancestorLayer);
2694                 auto offset = layer.convertToLayerCoords(&amp;ancestorLayer, { }, RenderLayer::AdjustForColumns);
2695                 clipRect.moveBy(-offset);
2696 
2697                 CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;ancestorLayer), clipRect, true };
2698                 newStack.insert(0, WTFMove(clipData));
2699                 currentClippedLayer = &amp;ancestorLayer;
2700             } else
2701                 haveNonScrollableClippingIntermediateLayer = true;
2702         }
2703 
2704         return AncestorTraversal::Continue;
2705     });
2706 
2707     return newStack;
2708 }
2709 
2710 // Note that this returns the ScrollingNodeID of the scroller this layer is embedded in, not the layer&#39;s own ScrollingNodeID if it has one.
2711 ScrollingNodeID RenderLayerCompositor::asyncScrollableContainerNodeID(const RenderObject&amp; renderer)
2712 {
2713     auto* enclosingLayer = renderer.enclosingLayer();
2714     if (!enclosingLayer)
2715         return 0;
2716 
2717     auto layerScrollingNodeID = [](const RenderLayer&amp; layer) -&gt; ScrollingNodeID {
2718         if (layer.isComposited())
2719             return layer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
2720         return 0;
2721     };
2722 
2723     // If the renderer is inside the layer, we care about the layer&#39;s scrollability. Otherwise, we let traverseAncestorLayers look at ancestors.
2724     if (!renderer.hasLayer()) {
2725         if (auto scrollingNodeID = layerScrollingNodeID(*enclosingLayer))
2726             return scrollingNodeID;
2727     }
2728 
2729     ScrollingNodeID containerScrollingNodeID = 0;
2730     traverseAncestorLayers(*enclosingLayer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {
2731         if (isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow()) {
2732             containerScrollingNodeID = layerScrollingNodeID(ancestorLayer);
2733             return AncestorTraversal::Stop;
2734         }
2735         return AncestorTraversal::Continue;
2736     });
2737 
2738     return containerScrollingNodeID;
2739 }
2740 
2741 // Return true if the given layer is a stacking context and has compositing child
2742 // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
2743 // into the hierarchy between this layer and its children in the z-order hierarchy.
2744 bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer)
2745 {
2746     return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
2747 }
2748 
2749 bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
2750 {
2751     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2752         return false;
2753 
2754     if (auto* element = renderer.element()) {
2755         if (auto* timeline = element-&gt;document().existingTimeline()) {
2756             if (timeline-&gt;runningAnimationsForElementAreAllAccelerated(*element))
2757                 return true;
2758         }
2759     }
2760 
2761     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
2762         return false;
2763 
2764     auto&amp; animController = renderer.animation();
2765     return (animController.isRunningAnimationOnRenderer(renderer, CSSPropertyOpacity)
2766         &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))
2767         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyFilter)
2768 #if ENABLE(FILTERS_LEVEL_2)
2769         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyWebkitBackdropFilter)
2770 #endif
2771         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2772 }
2773 
2774 bool RenderLayerCompositor::requiresCompositingForTransform(RenderLayerModelObject&amp; renderer) const
2775 {
2776     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2777         return false;
2778 
2779     // Note that we ask the renderer if it has a transform, because the style may have transforms,
2780     // but the renderer may be an inline that doesn&#39;t suppport them.
2781     if (!renderer.hasTransform())
2782         return false;
2783 
2784     switch (m_compositingPolicy) {
2785     case CompositingPolicy::Normal:
2786         return renderer.style().transform().has3DOperation();
2787     case CompositingPolicy::Conservative:
2788         // Continue to allow pages to avoid the very slow software filter path.
2789         if (renderer.style().transform().has3DOperation() &amp;&amp; renderer.hasFilter())
2790             return true;
2791         return renderer.style().transform().isRepresentableIn2D() ? false : true;
2792     }
2793     return false;
2794 }
2795 
2796 bool RenderLayerCompositor::requiresCompositingForBackfaceVisibility(RenderLayerModelObject&amp; renderer) const
2797 {
2798     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2799         return false;
2800 
2801     if (renderer.style().backfaceVisibility() != BackfaceVisibility::Hidden)
2802         return false;
2803 
2804     if (renderer.layer()-&gt;has3DTransformedAncestor())
2805         return true;
2806 
2807     // FIXME: workaround for webkit.org/b/132801
2808     auto* stackingContext = renderer.layer()-&gt;stackingContext();
2809     if (stackingContext &amp;&amp; stackingContext-&gt;renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D)
2810         return true;
2811 
2812     return false;
2813 }
2814 
2815 bool RenderLayerCompositor::requiresCompositingForVideo(RenderLayerModelObject&amp; renderer) const
2816 {
2817     if (!(m_compositingTriggers &amp; ChromeClient::VideoTrigger))
2818         return false;
2819 
2820 #if ENABLE(VIDEO)
2821     if (!is&lt;RenderVideo&gt;(renderer))
2822         return false;
2823 
2824     auto&amp; video = downcast&lt;RenderVideo&gt;(renderer);
2825     if ((video.requiresImmediateCompositing() || video.shouldDisplayVideo()) &amp;&amp; canAccelerateVideoRendering(video))
2826         return true;
2827 #else
2828     UNUSED_PARAM(renderer);
2829 #endif
2830     return false;
2831 }
2832 
2833 bool RenderLayerCompositor::requiresCompositingForCanvas(RenderLayerModelObject&amp; renderer) const
2834 {
2835     if (!(m_compositingTriggers &amp; ChromeClient::CanvasTrigger))
2836         return false;
2837 
2838     if (!renderer.isCanvas())
2839         return false;
2840 
2841     bool isCanvasLargeEnoughToForceCompositing = true;
2842 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
2843     auto* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer.element());
2844     auto canvasArea = canvas-&gt;size().area&lt;RecordOverflow&gt;();
2845     isCanvasLargeEnoughToForceCompositing = !canvasArea.hasOverflowed() &amp;&amp; canvasArea.unsafeGet() &gt;= canvasAreaThresholdRequiringCompositing;
2846 #endif
2847 
2848     CanvasCompositingStrategy compositingStrategy = canvasCompositingStrategy(renderer);
2849     if (compositingStrategy == CanvasAsLayerContents)
2850         return true;
2851 
2852     if (m_compositingPolicy == CompositingPolicy::Normal)
2853         return compositingStrategy == CanvasPaintedToLayer &amp;&amp; isCanvasLargeEnoughToForceCompositing;
2854 
2855     return false;
2856 }
2857 
2858 bool RenderLayerCompositor::requiresCompositingForFilters(RenderLayerModelObject&amp; renderer) const
2859 {
2860 #if ENABLE(FILTERS_LEVEL_2)
2861     if (renderer.hasBackdropFilter())
2862         return true;
2863 #endif
2864 
2865     if (!(m_compositingTriggers &amp; ChromeClient::FilterTrigger))
2866         return false;
2867 
2868     return renderer.hasFilter();
2869 }
2870 
2871 bool RenderLayerCompositor::requiresCompositingForWillChange(RenderLayerModelObject&amp; renderer) const
2872 {
2873     if (!renderer.style().willChange() || !renderer.style().willChange()-&gt;canTriggerCompositing())
2874         return false;
2875 
2876 #if ENABLE(FULLSCREEN_API)
2877     // FIXME: does this require layout?
2878     if (renderer.layer() &amp;&amp; isDescendantOfFullScreenLayer(*renderer.layer()) == FullScreenDescendant::No)
2879         return false;
2880 #endif
2881 
2882     if (m_compositingPolicy == CompositingPolicy::Conservative)
2883         return false;
2884 
2885     if (is&lt;RenderBox&gt;(renderer))
2886         return true;
2887 
2888     return renderer.style().willChange()-&gt;canTriggerCompositingOnInline();
2889 }
2890 
2891 bool RenderLayerCompositor::requiresCompositingForPlugin(RenderLayerModelObject&amp; renderer, RequiresCompositingData&amp; queryData) const
2892 {
2893     if (!(m_compositingTriggers &amp; ChromeClient::PluginTrigger))
2894         return false;
2895 
2896     bool isCompositedPlugin = is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing();
2897     if (!isCompositedPlugin)
2898         return false;
2899 
2900     auto&amp; pluginRenderer = downcast&lt;RenderWidget&gt;(renderer);
2901     if (pluginRenderer.style().visibility() != Visibility::Visible)
2902         return false;
2903 
2904     // If we can&#39;t reliably know the size of the plugin yet, don&#39;t change compositing state.
2905     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2906         queryData.reevaluateAfterLayout = true;
2907         return pluginRenderer.isComposited();
2908     }
2909 
2910     // Don&#39;t go into compositing mode if height or width are zero, or size is 1x1.
2911     IntRect contentBox = snappedIntRect(pluginRenderer.contentBoxRect());
2912     return (contentBox.height() * contentBox.width() &gt; 1);
2913 }
2914 
2915 bool RenderLayerCompositor::requiresCompositingForEditableImage(RenderLayerModelObject&amp; renderer) const
2916 {
2917     if (!renderer.isRenderImage())
2918         return false;
2919 
2920     auto&amp; image = downcast&lt;RenderImage&gt;(renderer);
2921     if (!image.isEditableImage())
2922         return false;
2923 
2924     return true;
2925 }
2926 
2927 bool RenderLayerCompositor::requiresCompositingForFrame(RenderLayerModelObject&amp; renderer, RequiresCompositingData&amp; queryData) const
2928 {
2929     if (!is&lt;RenderWidget&gt;(renderer))
2930         return false;
2931 
2932     auto&amp; frameRenderer = downcast&lt;RenderWidget&gt;(renderer);
2933     if (frameRenderer.style().visibility() != Visibility::Visible)
2934         return false;
2935 
2936     if (!frameRenderer.requiresAcceleratedCompositing())
2937         return false;
2938 
2939     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2940         queryData.reevaluateAfterLayout = true;
2941         return frameRenderer.isComposited();
2942     }
2943 
2944     // Don&#39;t go into compositing mode if height or width are zero.
2945     return !snappedIntRect(frameRenderer.contentBoxRect()).isEmpty();
2946 }
2947 
2948 bool RenderLayerCompositor::requiresCompositingForScrollableFrame(RequiresCompositingData&amp; queryData) const
2949 {
2950     if (isMainFrameCompositor())
2951         return false;
2952 
2953 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
2954     if (!m_renderView.settings().asyncFrameScrollingEnabled())
2955         return false;
2956 #endif
2957 
2958     if (!(m_compositingTriggers &amp; ChromeClient::ScrollableNonMainFrameTrigger))
2959         return false;
2960 
2961     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2962         queryData.reevaluateAfterLayout = true;
2963         return m_renderView.isComposited();
2964     }
2965 
2966     return m_renderView.frameView().isScrollable();
2967 }
2968 
2969 bool RenderLayerCompositor::requiresCompositingForPosition(RenderLayerModelObject&amp; renderer, const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2970 {
2971     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
2972     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
2973     // z-index and clipping will be broken.
2974     if (!renderer.isPositioned())
2975         return false;
2976 
2977 #if ENABLE(FULLSCREEN_API)
2978     if (isDescendantOfFullScreenLayer(layer) == FullScreenDescendant::No)
2979         return false;
2980 #endif
2981 
2982     auto position = renderer.style().position();
2983     bool isFixed = renderer.isFixedPositioned();
2984     if (isFixed &amp;&amp; !layer.isStackingContext())
2985         return false;
2986 
2987     bool isSticky = renderer.isInFlowPositioned() &amp;&amp; position == PositionType::Sticky;
2988     if (!isFixed &amp;&amp; !isSticky)
2989         return false;
2990 
2991     // FIXME: acceleratedCompositingForFixedPositionEnabled should probably be renamed acceleratedCompositingForViewportConstrainedPositionEnabled().
2992     if (!m_renderView.settings().acceleratedCompositingForFixedPositionEnabled())
2993         return false;
2994 
2995     if (isSticky)
2996         return isAsyncScrollableStickyLayer(layer);
2997 
2998     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2999         queryData.reevaluateAfterLayout = true;
3000         return layer.isComposited();
3001     }
3002 
3003     auto container = renderer.container();
3004     ASSERT(container);
3005 
3006     // Don&#39;t promote fixed position elements that are descendants of a non-view container, e.g. transformed elements.
3007     // They will stay fixed wrt the container rather than the enclosing frame.
3008     if (container != &amp;m_renderView) {
3009         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNonViewContainer;
3010         return false;
3011     }
3012 
3013     bool paintsContent = layer.isVisuallyNonEmpty() || layer.hasVisibleDescendant();
3014     if (!paintsContent) {
3015         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNoVisibleContent;
3016         return false;
3017     }
3018 
3019     bool intersectsViewport = fixedLayerIntersectsViewport(layer);
3020     if (!intersectsViewport) {
3021         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForBoundsOutOfView;
3022         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is outside the viewport&quot;);
3023         return false;
3024     }
3025 
3026     return true;
3027 }
3028 
3029 bool RenderLayerCompositor::requiresCompositingForOverflowScrolling(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
3030 {
3031     if (!layer.canUseCompositedScrolling())
3032         return false;
3033 
3034     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
3035         queryData.reevaluateAfterLayout = true;
3036         return layer.isComposited();
3037     }
3038 
3039     return layer.hasCompositedScrollableOverflow();
3040 }
3041 
3042 // FIXME: why doesn&#39;t this handle the clipping cases?
3043 bool RenderLayerCompositor::requiresCompositingForIndirectReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason&amp; reason) const
3044 {
3045     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
3046     // via compositing so that they also apply to those composited descendants.
3047     auto&amp; renderer = layer.renderer();
3048     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {
3049         reason = IndirectCompositingReason::GraphicalEffect;
3050         return true;
3051     }
3052 
3053     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
3054     // will be affected by the preserve-3d or perspective.
3055     if (has3DTransformedDescendants) {
3056         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {
3057             reason = IndirectCompositingReason::Preserve3D;
3058             return true;
3059         }
3060 
3061         if (renderer.style().hasPerspective()) {
3062             reason = IndirectCompositingReason::Perspective;
3063             return true;
3064         }
3065     }
3066 
3067     // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.
3068     if (!paintsIntoProvidedBacking &amp;&amp; layer.hasCompositedScrollingAncestor()) {
3069         auto* paintDestination = layer.paintOrderParent();
3070         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None) {
3071             reason = IndirectCompositingReason::OverflowScrollPositioning;
3072             return true;
3073         }
3074     }
3075 
3076     reason = IndirectCompositingReason::None;
3077     return false;
3078 }
3079 
3080 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
3081 {
3082     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
3083         return true;
3084     if (newStyle.isolation() != oldStyle.isolation())
3085         return true;
3086     if (newStyle.hasTransform() != oldStyle.hasTransform())
3087         return true;
3088     if (newStyle.boxReflect() != oldStyle.boxReflect())
3089         return true;
3090     if (newStyle.transformStyle3D() != oldStyle.transformStyle3D())
3091         return true;
3092     if (newStyle.hasPerspective() != oldStyle.hasPerspective())
3093         return true;
3094 
3095     return false;
3096 }
3097 
3098 bool RenderLayerCompositor::isAsyncScrollableStickyLayer(const RenderLayer&amp; layer, const RenderLayer** enclosingAcceleratedOverflowLayer) const
3099 {
3100     ASSERT(layer.renderer().isStickilyPositioned());
3101 
3102     auto* enclosingOverflowLayer = layer.enclosingOverflowClipLayer(ExcludeSelf);
3103 
3104     if (enclosingOverflowLayer &amp;&amp; enclosingOverflowLayer-&gt;hasCompositedScrollableOverflow()) {
3105         if (enclosingAcceleratedOverflowLayer)
3106             *enclosingAcceleratedOverflowLayer = enclosingOverflowLayer;
3107         return true;
3108     }
3109 
3110     // If the layer is inside normal overflow, it&#39;s not async-scrollable.
3111     if (enclosingOverflowLayer)
3112         return false;
3113 
3114     // No overflow ancestor, so see if the frame supports async scrolling.
3115     if (hasCoordinatedScrolling())
3116         return true;
3117 
3118 #if PLATFORM(IOS_FAMILY)
3119     // iOS WK1 has fixed/sticky support in the main frame via WebFixedPositionContent.
3120     return isMainFrameCompositor();
3121 #else
3122     return false;
3123 #endif
3124 }
3125 
3126 bool RenderLayerCompositor::isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp; layer) const
3127 {
3128     if (layer.renderer().isStickilyPositioned())
3129         return isAsyncScrollableStickyLayer(layer);
3130 
3131     if (!layer.renderer().isFixedPositioned())
3132         return false;
3133 
3134     // FIXME: Handle fixed inside of a transform, which should not behave as fixed.
3135     for (auto* ancestor = layer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {
3136         if (ancestor-&gt;hasCompositedScrollableOverflow())
3137             return true;
3138         if (ancestor-&gt;isStackingContext() &amp;&amp; ancestor-&gt;isComposited() &amp;&amp; ancestor-&gt;renderer().isFixedPositioned())
3139             return false;
3140     }
3141 
3142     return true;
3143 }
3144 
3145 bool RenderLayerCompositor::fixedLayerIntersectsViewport(const RenderLayer&amp; layer) const
3146 {
3147     ASSERT(layer.renderer().isFixedPositioned());
3148 
3149     // Fixed position elements that are invisible in the current view don&#39;t get their own layer.
3150     // FIXME: We shouldn&#39;t have to check useFixedLayout() here; one of the viewport rects needs to give the correct answer.
3151     LayoutRect viewBounds;
3152     if (m_renderView.frameView().useFixedLayout())
3153         viewBounds = m_renderView.unscaledDocumentRect();
3154     else
3155         viewBounds = m_renderView.frameView().rectForFixedPositionLayout();
3156 
3157     LayoutRect layerBounds = layer.calculateLayerBounds(&amp;layer, LayoutSize(), { RenderLayer::UseLocalClipRectIfPossible, RenderLayer::IncludeFilterOutsets, RenderLayer::UseFragmentBoxesExcludingCompositing,
3158         RenderLayer::ExcludeHiddenDescendants, RenderLayer::DontConstrainForMask, RenderLayer::IncludeCompositedDescendants });
3159     // Map to m_renderView to ignore page scale.
3160     FloatRect absoluteBounds = layer.renderer().localToContainerQuad(FloatRect(layerBounds), &amp;m_renderView).boundingBox();
3161     return viewBounds.intersects(enclosingIntRect(absoluteBounds));
3162 }
3163 
3164 bool RenderLayerCompositor::useCoordinatedScrollingForLayer(const RenderLayer&amp; layer) const
3165 {
3166     if (layer.isRenderViewLayer() &amp;&amp; hasCoordinatedScrolling())
3167         return true;
3168 
3169     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3170         return scrollingCoordinator-&gt;coordinatesScrollingForOverflowLayer(layer);
3171 
3172     return false;
3173 }
3174 
3175 static bool isScrolledByOverflowScrollLayer(const RenderLayer&amp; layer, const RenderLayer&amp; overflowScrollLayer)
3176 {
3177     bool scrolledByOverflowScroll = false;
3178     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {
3179         if (&amp;ancestorLayer == &amp;overflowScrollLayer) {
3180             scrolledByOverflowScroll = inContainingBlockChain;
3181             return AncestorTraversal::Stop;
3182         }
3183         return AncestorTraversal::Continue;
3184     });
3185     return scrolledByOverflowScroll;
3186 }
3187 
3188 static RenderLayer* enclosingCompositedScrollingLayer(const RenderLayer&amp; layer, const RenderLayer&amp; intermediateLayer, bool&amp; sawIntermediateLayer)
3189 {
3190     const auto* ancestorLayer = layer.parent();
3191     while (ancestorLayer) {
3192         if (ancestorLayer == &amp;intermediateLayer)
3193             sawIntermediateLayer = true;
3194 
3195         if (ancestorLayer-&gt;hasCompositedScrollableOverflow())
3196             return const_cast&lt;RenderLayer*&gt;(ancestorLayer);
3197 
3198         ancestorLayer = ancestorLayer-&gt;parent();
3199     }
3200 
3201     return nullptr;
3202 }
3203 
3204 ScrollPositioningBehavior RenderLayerCompositor::layerScrollBehahaviorRelativeToCompositedAncestor(const RenderLayer&amp; layer, const RenderLayer&amp; compositedAncestor)
3205 {
3206     if (!layer.hasCompositedScrollingAncestor())
3207         return ScrollPositioningBehavior::None;
3208 
3209     bool compositedAncestorIsInsideScroller = false;
3210     auto* scrollingAncestor = enclosingCompositedScrollingLayer(layer, compositedAncestor, compositedAncestorIsInsideScroller);
3211     if (!scrollingAncestor) {
3212         ASSERT_NOT_REACHED(); // layer.hasCompositedScrollingAncestor() should guarantee we have one.
3213         return ScrollPositioningBehavior::None;
3214     }
3215 
3216     bool ancestorMovedByScroller = &amp;compositedAncestor == scrollingAncestor || (compositedAncestorIsInsideScroller &amp;&amp; isScrolledByOverflowScrollLayer(compositedAncestor, *scrollingAncestor));
3217     bool layerMovedByScroller = isScrolledByOverflowScrollLayer(layer, *scrollingAncestor);
3218 
3219     if (ancestorMovedByScroller == layerMovedByScroller)
3220         return ScrollPositioningBehavior::None;
3221 
3222     return layerMovedByScroller ? ScrollPositioningBehavior::Moves : ScrollPositioningBehavior::Stationary;
3223 }
3224 
3225 static void collectStationaryLayerRelatedOverflowNodes(const RenderLayer&amp; layer, const RenderLayer&amp;, Vector&lt;ScrollingNodeID&gt;&amp; scrollingNodes)
3226 {
3227     ASSERT(layer.isComposited());
3228 
3229     auto appendOverflowLayerNodeID = [&amp;scrollingNodes] (const RenderLayer&amp; overflowLayer) {
3230         ASSERT(overflowLayer.isComposited());
3231         auto scrollingNodeID = overflowLayer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
3232         if (scrollingNodeID)
3233             scrollingNodes.append(scrollingNodeID);
3234         else
3235             LOG(Scrolling, &quot;Layer %p doesn&#39;t have scrolling node ID yet&quot;, &amp;overflowLayer);
3236     };
3237 
3238     // Collect all the composited scrollers which affect the position of this layer relative to its compositing ancestor (which might be inside the scroller or the scroller itself).
3239     bool seenPaintOrderAncestor = false;
3240     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool isPaintOrderAncestor) {
3241         seenPaintOrderAncestor |= isPaintOrderAncestor;
3242         if (isContainingBlockChain &amp;&amp; isPaintOrderAncestor)
3243             return AncestorTraversal::Stop;
3244 
3245         if (seenPaintOrderAncestor &amp;&amp; !isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow())
3246             appendOverflowLayerNodeID(ancestorLayer);
3247 
3248         return AncestorTraversal::Continue;
3249     });
3250 }
3251 
3252 ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer) const
3253 {
3254     if (layer.isRenderViewLayer())
3255         return ScrollPositioningBehavior::None;
3256 
3257     if (layer.renderer().isFixedPositioned())
3258         return ScrollPositioningBehavior::None;
3259 
3260     if (!layer.hasCompositedScrollingAncestor())
3261         return ScrollPositioningBehavior::None;
3262 
3263     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3264     if (!scrollingCoordinator)
3265         return ScrollPositioningBehavior::None;
3266 
3267     auto* compositedAncestor = layer.ancestorCompositingLayer();
3268     if (!compositedAncestor) {
3269         ASSERT_NOT_REACHED();
3270         return ScrollPositioningBehavior::None;
3271     }
3272 
3273     return layerScrollBehahaviorRelativeToCompositedAncestor(layer, *compositedAncestor);
3274 }
3275 
3276 static Vector&lt;ScrollingNodeID&gt; collectRelatedCoordinatedScrollingNodes(const RenderLayer&amp; layer, ScrollPositioningBehavior positioningBehavior)
3277 {
3278     Vector&lt;ScrollingNodeID&gt; overflowNodeIDs;
3279 
3280     switch (positioningBehavior) {
3281     case ScrollPositioningBehavior::Stationary: {
3282         auto* compositedAncestor = layer.ancestorCompositingLayer();
3283         if (!compositedAncestor)
3284             return overflowNodeIDs;
3285         collectStationaryLayerRelatedOverflowNodes(layer, *compositedAncestor, overflowNodeIDs);
3286         break;
3287     }
3288     case ScrollPositioningBehavior::Moves:
3289     case ScrollPositioningBehavior::None:
3290         ASSERT_NOT_REACHED();
3291         break;
3292     }
3293 
3294     return overflowNodeIDs;
3295 }
3296 
3297 bool RenderLayerCompositor::isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp; layer) const
3298 {
3299     if (!is&lt;RenderWidget&gt;(layer.renderer()))
3300         return false;
3301 
3302     auto* contentDocument = downcast&lt;RenderWidget&gt;(layer.renderer()).frameOwnerElement().contentDocument();
3303     if (!contentDocument)
3304         return false;
3305 
3306     auto* view = contentDocument-&gt;renderView();
3307     if (!view)
3308         return false;
3309 
3310     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3311         return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(view-&gt;frameView());
3312 
3313     return false;
3314 }
3315 
3316 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
3317 {
3318     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
3319         return false;
3320 
3321     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
3322         if (auto* element = renderer.element()) {
3323             if (auto* timeline = element-&gt;document().existingTimeline())
3324                 return timeline-&gt;isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
3325         }
3326         return false;
3327     }
3328     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
3329 }
3330 
3331 // If an element has composited negative z-index children, those children render in front of the
3332 // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
3333 bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
3334 {
3335     for (auto* layer : layer.negativeZOrderLayers()) {
3336         if (layer-&gt;isComposited() || layer-&gt;hasCompositingDescendant())
3337             return true;
3338     }
3339 
3340     return false;
3341 }
3342 
3343 bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
3344 {
3345     auto&amp; frameView = m_renderView.frameView();
3346 
3347     // This applies when the application UI handles scrolling, in which case RenderLayerCompositor doesn&#39;t need to manage it.
3348     if (frameView.delegatesScrolling() &amp;&amp; isMainFrameCompositor())
3349         return false;
3350 
3351     // We need to handle our own scrolling if we&#39;re:
3352     return !m_renderView.frameView().platformWidget() // viewless (i.e. non-Mac, or Mac in WebKit2)
3353         || attachment == RootLayerAttachedViaEnclosingFrame; // a composited frame on Mac
3354 }
3355 
3356 void paintScrollbar(Scrollbar* scrollbar, GraphicsContext&amp; context, const IntRect&amp; clip)
3357 {
3358     if (!scrollbar)
3359         return;
3360 
3361     context.save();
3362     const IntRect&amp; scrollbarRect = scrollbar-&gt;frameRect();
3363     context.translate(-scrollbarRect.location());
3364     IntRect transformedClip = clip;
3365     transformedClip.moveBy(scrollbarRect.location());
3366     scrollbar-&gt;paint(context, transformedClip);
3367     context.restore();
3368 }
3369 
3370 void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)
3371 {
3372 #if PLATFORM(MAC)
3373     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
3374 #endif
3375 
3376     IntRect pixelSnappedRectForIntegralPositionedItems = snappedIntRect(LayoutRect(clip));
3377     if (graphicsLayer == layerForHorizontalScrollbar())
3378         paintScrollbar(m_renderView.frameView().horizontalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3379     else if (graphicsLayer == layerForVerticalScrollbar())
3380         paintScrollbar(m_renderView.frameView().verticalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3381     else if (graphicsLayer == layerForScrollCorner()) {
3382         const IntRect&amp; scrollCorner = m_renderView.frameView().scrollCornerRect();
3383         context.save();
3384         context.translate(-scrollCorner.location());
3385         IntRect transformedClip = pixelSnappedRectForIntegralPositionedItems;
3386         transformedClip.moveBy(scrollCorner.location());
3387         m_renderView.frameView().paintScrollCorner(context, transformedClip);
3388         context.restore();
3389     }
3390 }
3391 
3392 bool RenderLayerCompositor::supportsFixedRootBackgroundCompositing() const
3393 {
3394     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
3395     return renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking();
3396 }
3397 
3398 bool RenderLayerCompositor::needsFixedRootBackgroundLayer(const RenderLayer&amp; layer) const
3399 {
3400     if (!layer.isRenderViewLayer())
3401         return false;
3402 
3403     if (m_renderView.settings().fixedBackgroundsPaintRelativeToDocument())
3404         return false;
3405 
3406     return supportsFixedRootBackgroundCompositing() &amp;&amp; m_renderView.rootBackgroundIsEntirelyFixed();
3407 }
3408 
3409 GraphicsLayer* RenderLayerCompositor::fixedRootBackgroundLayer() const
3410 {
3411     // Get the fixed root background from the RenderView layer&#39;s backing.
3412     auto* viewLayer = m_renderView.layer();
3413     if (!viewLayer)
3414         return nullptr;
3415 
3416     if (viewLayer-&gt;isComposited() &amp;&amp; viewLayer-&gt;backing()-&gt;backgroundLayerPaintsFixedRootBackground())
3417         return viewLayer-&gt;backing()-&gt;backgroundLayer();
3418 
3419     return nullptr;
3420 }
3421 
3422 void RenderLayerCompositor::resetTrackedRepaintRects()
3423 {
3424     if (auto* rootLayer = rootGraphicsLayer()) {
3425         GraphicsLayer::traverse(*rootLayer, [](GraphicsLayer&amp; layer) {
3426             layer.resetTrackedRepaints();
3427         });
3428     }
3429 }
3430 
3431 float RenderLayerCompositor::deviceScaleFactor() const
3432 {
3433 #if PLATFORM(JAVA)
3434     // Java port does device scale factor in the lower level.
3435     return GraphicsLayerClient::deviceScaleFactor();
3436 #else
3437     return m_renderView.document().deviceScaleFactor();
3438 #endif
3439 }
3440 
3441 float RenderLayerCompositor::pageScaleFactor() const
3442 {
3443     return page().pageScaleFactor();
3444 }
3445 
3446 float RenderLayerCompositor::zoomedOutPageScaleFactor() const
3447 {
3448     return page().zoomedOutPageScaleFactor();
3449 }
3450 
3451 float RenderLayerCompositor::contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const
3452 {
3453 #if PLATFORM(IOS_FAMILY)
3454     LegacyTileCache* tileCache = nullptr;
3455     if (auto* frameView = page().mainFrame().view())
3456         tileCache = frameView-&gt;legacyTileCache();
3457 
3458     if (!tileCache)
3459         return 1;
3460 
3461     return tileCache-&gt;tileControllerShouldUseLowScaleTiles() ? 0.125 : 1;
3462 #else
3463     return 1;
3464 #endif
3465 }
3466 
3467 bool RenderLayerCompositor::documentUsesTiledBacking() const
3468 {
3469     auto* layer = m_renderView.layer();
3470     if (!layer)
3471         return false;
3472 
3473     auto* backing = layer-&gt;backing();
3474     if (!backing)
3475         return false;
3476 
3477     return backing-&gt;isFrameLayerWithTiledBacking();
3478 }
3479 
3480 bool RenderLayerCompositor::isMainFrameCompositor() const
3481 {
3482     return m_renderView.frameView().frame().isMainFrame();
3483 }
3484 
3485 bool RenderLayerCompositor::shouldCompositeOverflowControls() const
3486 {
3487     auto&amp; frameView = m_renderView.frameView();
3488 
3489     if (!frameView.managesScrollbars())
3490         return false;
3491 
3492     if (documentUsesTiledBacking())
3493         return true;
3494 
3495     if (m_overflowControlsHostLayer &amp;&amp; isMainFrameCompositor())
3496         return true;
3497 
3498 #if !USE(COORDINATED_GRAPHICS)
3499     if (!frameView.hasOverlayScrollbars())
3500         return false;
3501 #endif
3502 
3503     return true;
3504 }
3505 
3506 bool RenderLayerCompositor::requiresHorizontalScrollbarLayer() const
3507 {
3508     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().horizontalScrollbar();
3509 }
3510 
3511 bool RenderLayerCompositor::requiresVerticalScrollbarLayer() const
3512 {
3513     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().verticalScrollbar();
3514 }
3515 
3516 bool RenderLayerCompositor::requiresScrollCornerLayer() const
3517 {
3518     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().isScrollCornerVisible();
3519 }
3520 
3521 #if ENABLE(RUBBER_BANDING)
3522 bool RenderLayerCompositor::requiresOverhangAreasLayer() const
3523 {
3524     if (!isMainFrameCompositor())
3525         return false;
3526 
3527     // We do want a layer if we&#39;re using tiled drawing and can scroll.
3528     if (documentUsesTiledBacking() &amp;&amp; m_renderView.frameView().hasOpaqueBackground() &amp;&amp; !m_renderView.frameView().prohibitsScrolling())
3529         return true;
3530 
3531     return false;
3532 }
3533 
3534 bool RenderLayerCompositor::requiresContentShadowLayer() const
3535 {
3536     if (!isMainFrameCompositor())
3537         return false;
3538 
3539 #if PLATFORM(COCOA)
3540     if (viewHasTransparentBackground())
3541         return false;
3542 
3543     // If the background is going to extend, then it doesn&#39;t make sense to have a shadow layer.
3544     if (m_renderView.settings().backgroundShouldExtendBeyondPage())
3545         return false;
3546 
3547     // On Mac, we want a content shadow layer if we&#39;re using tiled drawing and can scroll.
3548     if (documentUsesTiledBacking() &amp;&amp; !m_renderView.frameView().prohibitsScrolling())
3549         return true;
3550 #endif
3551 
3552     return false;
3553 }
3554 
3555 GraphicsLayer* RenderLayerCompositor::updateLayerForTopOverhangArea(bool wantsLayer)
3556 {
3557     if (!isMainFrameCompositor())
3558         return nullptr;
3559 
3560     if (!wantsLayer) {
3561         GraphicsLayer::unparentAndClear(m_layerForTopOverhangArea);
3562         return nullptr;
3563     }
3564 
3565     if (!m_layerForTopOverhangArea) {
3566         m_layerForTopOverhangArea = GraphicsLayer::create(graphicsLayerFactory(), *this);
3567         m_layerForTopOverhangArea-&gt;setName(&quot;top overhang&quot;);
3568         m_scrolledContentsLayer-&gt;addChildBelow(*m_layerForTopOverhangArea, m_rootContentsLayer.get());
3569     }
3570 
3571     return m_layerForTopOverhangArea.get();
3572 }
3573 
3574 GraphicsLayer* RenderLayerCompositor::updateLayerForBottomOverhangArea(bool wantsLayer)
3575 {
3576     if (!isMainFrameCompositor())
3577         return nullptr;
3578 
3579     if (!wantsLayer) {
3580         GraphicsLayer::unparentAndClear(m_layerForBottomOverhangArea);
3581         return nullptr;
3582     }
3583 
3584     if (!m_layerForBottomOverhangArea) {
3585         m_layerForBottomOverhangArea = GraphicsLayer::create(graphicsLayerFactory(), *this);
3586         m_layerForBottomOverhangArea-&gt;setName(&quot;bottom overhang&quot;);
3587         m_scrolledContentsLayer-&gt;addChildBelow(*m_layerForBottomOverhangArea, m_rootContentsLayer.get());
3588     }
3589 
3590     m_layerForBottomOverhangArea-&gt;setPosition(FloatPoint(0, m_rootContentsLayer-&gt;size().height() + m_renderView.frameView().headerHeight()
3591         + m_renderView.frameView().footerHeight() + m_renderView.frameView().topContentInset()));
3592     return m_layerForBottomOverhangArea.get();
3593 }
3594 
3595 GraphicsLayer* RenderLayerCompositor::updateLayerForHeader(bool wantsLayer)
3596 {
3597     if (!isMainFrameCompositor())
3598         return nullptr;
3599 
3600     if (!wantsLayer) {
3601         if (m_layerForHeader) {
3602             GraphicsLayer::unparentAndClear(m_layerForHeader);
3603 
3604             // The ScrollingTree knows about the header layer, and the position of the root layer is affected
3605             // by the header layer, so if we remove the header, we need to tell the scrolling tree.
3606             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3607                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3608         }
3609         return nullptr;
3610     }
3611 
3612     if (!m_layerForHeader) {
3613         m_layerForHeader = GraphicsLayer::create(graphicsLayerFactory(), *this);
3614         m_layerForHeader-&gt;setName(&quot;header&quot;);
3615         m_scrolledContentsLayer-&gt;addChildAbove(*m_layerForHeader, m_rootContentsLayer.get());
3616         m_renderView.frameView().addPaintPendingMilestones(DidFirstFlushForHeaderLayer);
3617     }
3618 
3619     m_layerForHeader-&gt;setPosition(FloatPoint(0,
3620         FrameView::yPositionForHeaderLayer(m_renderView.frameView().scrollPosition(), m_renderView.frameView().topContentInset())));
3621     m_layerForHeader-&gt;setAnchorPoint(FloatPoint3D());
3622     m_layerForHeader-&gt;setSize(FloatSize(m_renderView.frameView().visibleWidth(), m_renderView.frameView().headerHeight()));
3623 
3624     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3625         scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3626 
3627     page().chrome().client().didAddHeaderLayer(*m_layerForHeader);
3628 
3629     return m_layerForHeader.get();
3630 }
3631 
3632 GraphicsLayer* RenderLayerCompositor::updateLayerForFooter(bool wantsLayer)
3633 {
3634     if (!isMainFrameCompositor())
3635         return nullptr;
3636 
3637     if (!wantsLayer) {
3638         if (m_layerForFooter) {
3639             GraphicsLayer::unparentAndClear(m_layerForFooter);
3640 
3641             // The ScrollingTree knows about the footer layer, and the total scrollable size is affected
3642             // by the footer layer, so if we remove the footer, we need to tell the scrolling tree.
3643             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3644                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3645         }
3646         return nullptr;
3647     }
3648 
3649     if (!m_layerForFooter) {
3650         m_layerForFooter = GraphicsLayer::create(graphicsLayerFactory(), *this);
3651         m_layerForFooter-&gt;setName(&quot;footer&quot;);
3652         m_scrolledContentsLayer-&gt;addChildAbove(*m_layerForFooter, m_rootContentsLayer.get());
3653     }
3654 
3655     float totalContentHeight = m_rootContentsLayer-&gt;size().height() + m_renderView.frameView().headerHeight() + m_renderView.frameView().footerHeight();
3656     m_layerForFooter-&gt;setPosition(FloatPoint(0, FrameView::yPositionForFooterLayer(m_renderView.frameView().scrollPosition(),
3657         m_renderView.frameView().topContentInset(), totalContentHeight, m_renderView.frameView().footerHeight())));
3658     m_layerForFooter-&gt;setAnchorPoint(FloatPoint3D());
3659     m_layerForFooter-&gt;setSize(FloatSize(m_renderView.frameView().visibleWidth(), m_renderView.frameView().footerHeight()));
3660 
3661     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3662         scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3663 
3664     page().chrome().client().didAddFooterLayer(*m_layerForFooter);
3665 
3666     return m_layerForFooter.get();
3667 }
3668 
3669 #endif
3670 
3671 bool RenderLayerCompositor::viewHasTransparentBackground(Color* backgroundColor) const
3672 {
3673     if (m_renderView.frameView().isTransparent()) {
3674         if (backgroundColor)
3675             *backgroundColor = Color(); // Return an invalid color.
3676         return true;
3677     }
3678 
3679     Color documentBackgroundColor = m_renderView.frameView().documentBackgroundColor();
3680     if (!documentBackgroundColor.isValid())
3681         documentBackgroundColor = m_renderView.frameView().baseBackgroundColor();
3682 
3683     ASSERT(documentBackgroundColor.isValid());
3684 
3685     if (backgroundColor)
3686         *backgroundColor = documentBackgroundColor;
3687 
3688     return !documentBackgroundColor.isOpaque();
3689 }
3690 
3691 // We can&#39;t rely on getting layerStyleChanged() for a style change that affects the root background, because the style change may
3692 // be on the body which has no RenderLayer.
3693 void RenderLayerCompositor::rootOrBodyStyleChanged(RenderElement&amp; renderer, const RenderStyle* oldStyle)
3694 {
3695     if (!usesCompositing())
3696         return;
3697 
3698     Color oldBackgroundColor;
3699     if (oldStyle)
3700         oldBackgroundColor = oldStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3701 
3702     if (oldBackgroundColor != renderer.style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor))
3703         rootBackgroundColorOrTransparencyChanged();
3704 
3705     bool hadFixedBackground = oldStyle &amp;&amp; oldStyle-&gt;hasEntirelyFixedBackground();
3706     if (hadFixedBackground != renderer.style().hasEntirelyFixedBackground())
3707         rootLayerConfigurationChanged();
3708 }
3709 
3710 void RenderLayerCompositor::rootBackgroundColorOrTransparencyChanged()
3711 {
3712     if (!usesCompositing())
3713         return;
3714 
3715     Color backgroundColor;
3716     bool isTransparent = viewHasTransparentBackground(&amp;backgroundColor);
3717 
3718     Color extendedBackgroundColor = m_renderView.settings().backgroundShouldExtendBeyondPage() ? backgroundColor : Color();
3719 
3720     bool transparencyChanged = m_viewBackgroundIsTransparent != isTransparent;
3721     bool backgroundColorChanged = m_viewBackgroundColor != backgroundColor;
3722     bool extendedBackgroundColorChanged = m_rootExtendedBackgroundColor != extendedBackgroundColor;
3723 
3724     if (!transparencyChanged &amp;&amp; !backgroundColorChanged &amp;&amp; !extendedBackgroundColorChanged)
3725         return;
3726 
3727     LOG(Compositing, &quot;RenderLayerCompositor %p rootBackgroundColorOrTransparencyChanged. isTransparent=%d&quot;, this, isTransparent);
3728 
3729     m_viewBackgroundIsTransparent = isTransparent;
3730     m_viewBackgroundColor = backgroundColor;
3731     m_rootExtendedBackgroundColor = extendedBackgroundColor;
3732 
3733     if (extendedBackgroundColorChanged) {
3734         page().chrome().client().pageExtendedBackgroundColorDidChange(m_rootExtendedBackgroundColor);
3735 
3736 #if ENABLE(RUBBER_BANDING)
3737         if (m_layerForOverhangAreas) {
3738             m_layerForOverhangAreas-&gt;setBackgroundColor(m_rootExtendedBackgroundColor);
3739 
3740             if (!m_rootExtendedBackgroundColor.isValid())
3741                 m_layerForOverhangAreas-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingOverhang);
3742         }
3743 #endif
3744     }
3745 
3746     rootLayerConfigurationChanged();
3747 }
3748 
3749 void RenderLayerCompositor::updateOverflowControlsLayers()
3750 {
3751 #if ENABLE(RUBBER_BANDING)
3752     if (requiresOverhangAreasLayer()) {
3753         if (!m_layerForOverhangAreas) {
3754             m_layerForOverhangAreas = GraphicsLayer::create(graphicsLayerFactory(), *this);
3755             m_layerForOverhangAreas-&gt;setName(&quot;overhang areas&quot;);
3756             m_layerForOverhangAreas-&gt;setDrawsContent(false);
3757 
3758             float topContentInset = m_renderView.frameView().topContentInset();
3759             IntSize overhangAreaSize = m_renderView.frameView().frameRect().size();
3760             overhangAreaSize.setHeight(overhangAreaSize.height() - topContentInset);
3761             m_layerForOverhangAreas-&gt;setSize(overhangAreaSize);
3762             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, topContentInset));
3763             m_layerForOverhangAreas-&gt;setAnchorPoint(FloatPoint3D());
3764 
3765             if (m_renderView.settings().backgroundShouldExtendBeyondPage())
3766                 m_layerForOverhangAreas-&gt;setBackgroundColor(m_renderView.frameView().documentBackgroundColor());
3767             else
3768                 m_layerForOverhangAreas-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingOverhang);
3769 
3770             // We want the overhang areas layer to be positioned below the frame contents,
3771             // so insert it below the clip layer.
3772             m_overflowControlsHostLayer-&gt;addChildBelow(*m_layerForOverhangAreas, layerForClipping());
3773         }
3774     } else
3775         GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3776 
3777     if (requiresContentShadowLayer()) {
3778         if (!m_contentShadowLayer) {
3779             m_contentShadowLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3780             m_contentShadowLayer-&gt;setName(&quot;content shadow&quot;);
3781             m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
3782             m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
3783             m_contentShadowLayer-&gt;setAnchorPoint(FloatPoint3D());
3784             m_contentShadowLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingShadow);
3785 
3786             m_scrolledContentsLayer-&gt;addChildBelow(*m_contentShadowLayer, m_rootContentsLayer.get());
3787         }
3788     } else
3789         GraphicsLayer::unparentAndClear(m_contentShadowLayer);
3790 #endif
3791 
3792     if (requiresHorizontalScrollbarLayer()) {
3793         if (!m_layerForHorizontalScrollbar) {
3794             m_layerForHorizontalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
3795             m_layerForHorizontalScrollbar-&gt;setAllowsBackingStoreDetaching(false);
3796             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3797             m_layerForHorizontalScrollbar-&gt;setName(&quot;horizontal scrollbar container&quot;);
3798 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3799             m_layerForHorizontalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3800 #endif
3801             m_overflowControlsHostLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
3802 
3803             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3804                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3805         }
3806     } else if (m_layerForHorizontalScrollbar) {
3807         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3808 
3809         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3810             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3811     }
3812 
3813     if (requiresVerticalScrollbarLayer()) {
3814         if (!m_layerForVerticalScrollbar) {
3815             m_layerForVerticalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
3816             m_layerForVerticalScrollbar-&gt;setAllowsBackingStoreDetaching(false);
3817             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3818             m_layerForVerticalScrollbar-&gt;setName(&quot;vertical scrollbar container&quot;);
3819 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3820             m_layerForVerticalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3821 #endif
3822             m_overflowControlsHostLayer-&gt;addChild(*m_layerForVerticalScrollbar);
3823 
3824             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3825                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3826         }
3827     } else if (m_layerForVerticalScrollbar) {
3828         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3829 
3830         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3831             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3832     }
3833 
3834     if (requiresScrollCornerLayer()) {
3835         if (!m_layerForScrollCorner) {
3836             m_layerForScrollCorner = GraphicsLayer::create(graphicsLayerFactory(), *this);
3837             m_layerForScrollCorner-&gt;setAllowsBackingStoreDetaching(false);
3838             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
3839             m_layerForScrollCorner-&gt;setName(&quot;scroll corner&quot;);
3840 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3841             m_layerForScrollCorner-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3842 #endif
3843             m_overflowControlsHostLayer-&gt;addChild(*m_layerForScrollCorner);
3844         }
3845     } else
3846         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3847 
3848     m_renderView.frameView().positionScrollbarLayers();
3849 }
3850 
3851 void RenderLayerCompositor::ensureRootLayer()
3852 {
3853     RootLayerAttachment expectedAttachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
3854     if (expectedAttachment == m_rootLayerAttachment)
3855          return;
3856 
3857     if (!m_rootContentsLayer) {
3858         m_rootContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3859         m_rootContentsLayer-&gt;setName(&quot;content root&quot;);
3860         IntRect overflowRect = snappedIntRect(m_renderView.layoutOverflowRect());
3861         m_rootContentsLayer-&gt;setSize(FloatSize(overflowRect.maxX(), overflowRect.maxY()));
3862         m_rootContentsLayer-&gt;setPosition(FloatPoint());
3863 
3864 #if PLATFORM(IOS_FAMILY)
3865         // Page scale is applied above this on iOS, so we&#39;ll just say that our root layer applies it.
3866         auto&amp; frame = m_renderView.frameView().frame();
3867         if (frame.isMainFrame())
3868             m_rootContentsLayer-&gt;setAppliesPageScale();
3869 #endif
3870 
3871         // Need to clip to prevent transformed content showing outside this frame
3872         updateRootContentLayerClipping();
3873     }
3874 
3875     if (requiresScrollLayer(expectedAttachment)) {
3876         if (!m_overflowControlsHostLayer) {
3877             ASSERT(!m_scrolledContentsLayer);
3878             ASSERT(!m_clipLayer);
3879 
3880             // Create a layer to host the clipping layer and the overflow controls layers.
3881             m_overflowControlsHostLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3882             m_overflowControlsHostLayer-&gt;setName(&quot;overflow controls host&quot;);
3883 
3884             m_scrolledContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrolledContents);
3885             m_scrolledContentsLayer-&gt;setName(&quot;scrolled contents&quot;);
3886             m_scrolledContentsLayer-&gt;setAnchorPoint({ });
3887 
3888 #if PLATFORM(IOS_FAMILY)
3889             if (m_renderView.settings().asyncFrameScrollingEnabled()) {
3890                 m_scrollContainerLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrollContainer);
3891 
3892                 m_scrollContainerLayer-&gt;setName(&quot;scroll container&quot;);
3893                 m_scrollContainerLayer-&gt;setMasksToBounds(true);
3894                 m_scrollContainerLayer-&gt;setAnchorPoint({ });
3895 
3896                 m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
3897                 m_overflowControlsHostLayer-&gt;addChild(*m_scrollContainerLayer);
3898             }
3899 #endif
3900             // FIXME: m_scrollContainerLayer and m_clipLayer have similar roles here, but m_clipLayer has some special positioning to
3901             // account for clipping and top content inset (see FrameView::yPositionForInsetClipLayer()).
3902             if (!m_scrollContainerLayer) {
3903                 m_clipLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3904                 m_clipLayer-&gt;setName(&quot;frame clipping&quot;);
3905                 m_clipLayer-&gt;setMasksToBounds(true);
3906                 m_clipLayer-&gt;setAnchorPoint({ });
3907 
3908                 m_clipLayer-&gt;addChild(*m_scrolledContentsLayer);
3909                 m_overflowControlsHostLayer-&gt;addChild(*m_clipLayer);
3910             }
3911 
3912             m_scrolledContentsLayer-&gt;addChild(*m_rootContentsLayer);
3913 
3914             updateScrollLayerClipping();
3915             updateOverflowControlsLayers();
3916 
3917             if (hasCoordinatedScrolling())
3918                 scheduleLayerFlush(true);
3919             else
3920                 updateScrollLayerPosition();
3921         }
3922     } else {
3923         if (m_overflowControlsHostLayer) {
3924             GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
3925             GraphicsLayer::unparentAndClear(m_clipLayer);
3926             GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
3927             GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
3928         }
3929     }
3930 
3931     // Check to see if we have to change the attachment
3932     if (m_rootLayerAttachment != RootLayerUnattached)
3933         detachRootLayer();
3934 
3935     attachRootLayer(expectedAttachment);
3936 }
3937 
3938 void RenderLayerCompositor::destroyRootLayer()
3939 {
3940     if (!m_rootContentsLayer)
3941         return;
3942 
3943     detachRootLayer();
3944 
3945 #if ENABLE(RUBBER_BANDING)
3946     GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3947 #endif
3948 
3949     if (m_layerForHorizontalScrollbar) {
3950         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3951         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3952             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3953         if (auto* horizontalScrollbar = m_renderView.frameView().verticalScrollbar())
3954             m_renderView.frameView().invalidateScrollbar(*horizontalScrollbar, IntRect(IntPoint(0, 0), horizontalScrollbar-&gt;frameRect().size()));
3955     }
3956 
3957     if (m_layerForVerticalScrollbar) {
3958         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3959         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3960             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3961         if (auto* verticalScrollbar = m_renderView.frameView().verticalScrollbar())
3962             m_renderView.frameView().invalidateScrollbar(*verticalScrollbar, IntRect(IntPoint(0, 0), verticalScrollbar-&gt;frameRect().size()));
3963     }
3964 
3965     if (m_layerForScrollCorner) {
3966         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3967         m_renderView.frameView().invalidateScrollCorner(m_renderView.frameView().scrollCornerRect());
3968     }
3969 
3970     if (m_overflowControlsHostLayer) {
3971         GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
3972         GraphicsLayer::unparentAndClear(m_clipLayer);
3973         GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
3974         GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
3975     }
3976     ASSERT(!m_scrolledContentsLayer);
3977     GraphicsLayer::unparentAndClear(m_rootContentsLayer);
3978 
3979     m_layerUpdater = nullptr;
3980 }
3981 
3982 void RenderLayerCompositor::attachRootLayer(RootLayerAttachment attachment)
3983 {
3984     if (!m_rootContentsLayer)
3985         return;
3986 
3987     LOG(Compositing, &quot;RenderLayerCompositor %p attachRootLayer %d&quot;, this, attachment);
3988 
3989     switch (attachment) {
3990         case RootLayerUnattached:
3991             ASSERT_NOT_REACHED();
3992             break;
3993         case RootLayerAttachedViaChromeClient: {
3994             auto&amp; frame = m_renderView.frameView().frame();
3995             page().chrome().client().attachRootGraphicsLayer(frame, rootGraphicsLayer());
3996             break;
3997         }
3998         case RootLayerAttachedViaEnclosingFrame: {
3999             // The layer will get hooked up via RenderLayerBacking::updateConfiguration()
4000             // for the frame&#39;s renderer in the parent document.
4001             if (auto* ownerElement = m_renderView.document().ownerElement())
4002                 ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4003             break;
4004         }
4005     }
4006 
4007     m_rootLayerAttachment = attachment;
4008     rootLayerAttachmentChanged();
4009 
4010     if (m_shouldFlushOnReattach) {
4011         scheduleLayerFlush();
4012         m_shouldFlushOnReattach = false;
4013     }
4014 }
4015 
4016 void RenderLayerCompositor::detachRootLayer()
4017 {
4018     if (!m_rootContentsLayer || m_rootLayerAttachment == RootLayerUnattached)
4019         return;
4020 
4021     switch (m_rootLayerAttachment) {
4022     case RootLayerAttachedViaEnclosingFrame: {
4023         // The layer will get unhooked up via RenderLayerBacking::updateConfiguration()
4024         // for the frame&#39;s renderer in the parent document.
4025         if (m_overflowControlsHostLayer)
4026             m_overflowControlsHostLayer-&gt;removeFromParent();
4027         else
4028             m_rootContentsLayer-&gt;removeFromParent();
4029 
4030         if (auto* ownerElement = m_renderView.document().ownerElement())
4031             ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4032 
4033         if (auto frameRootScrollingNodeID = m_renderView.frameView().scrollingNodeID()) {
4034             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
4035                 scrollingCoordinator-&gt;unparentNode(frameRootScrollingNodeID);
4036         }
4037         break;
4038     }
4039     case RootLayerAttachedViaChromeClient: {
4040         auto&amp; frame = m_renderView.frameView().frame();
4041         page().chrome().client().attachRootGraphicsLayer(frame, nullptr);
4042     }
4043     break;
4044     case RootLayerUnattached:
4045         break;
4046     }
4047 
4048     m_rootLayerAttachment = RootLayerUnattached;
4049     rootLayerAttachmentChanged();
4050 }
4051 
4052 void RenderLayerCompositor::updateRootLayerAttachment()
4053 {
4054     ensureRootLayer();
4055 }
4056 
4057 void RenderLayerCompositor::rootLayerAttachmentChanged()
4058 {
4059     // The document-relative page overlay layer (which is pinned to the main frame&#39;s layer tree)
4060     // is moved between different RenderLayerCompositors&#39; layer trees, and needs to be
4061     // reattached whenever we swap in a new RenderLayerCompositor.
4062     if (m_rootLayerAttachment == RootLayerUnattached)
4063         return;
4064 
4065     auto&amp; frame = m_renderView.frameView().frame();
4066 
4067     // The attachment can affect whether the RenderView layer&#39;s paintsIntoWindow() behavior,
4068     // so call updateDrawsContent() to update that.
4069     auto* layer = m_renderView.layer();
4070     if (auto* backing = layer ? layer-&gt;backing() : nullptr)
4071         backing-&gt;updateDrawsContent();
4072 
4073     if (!frame.isMainFrame())
4074         return;
4075 
4076     Ref&lt;GraphicsLayer&gt; overlayHost = page().pageOverlayController().layerWithDocumentOverlays();
4077     m_rootContentsLayer-&gt;addChild(WTFMove(overlayHost));
4078 }
4079 
4080 void RenderLayerCompositor::notifyIFramesOfCompositingChange()
4081 {
4082     // Compositing affects the answer to RenderIFrame::requiresAcceleratedCompositing(), so
4083     // we need to schedule a style recalc in our parent document.
4084     if (auto* ownerElement = m_renderView.document().ownerElement())
4085         ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4086 }
4087 
4088 bool RenderLayerCompositor::layerHas3DContent(const RenderLayer&amp; layer) const
4089 {
4090     const RenderStyle&amp; style = layer.renderer().style();
4091 
4092     if (style.transformStyle3D() == TransformStyle3D::Preserve3D || style.hasPerspective() || style.transform().has3DOperation())
4093         return true;
4094 
4095     const_cast&lt;RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
4096 
4097 #if !ASSERT_DISABLED
4098     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
4099 #endif
4100 
4101     for (auto* renderLayer : layer.negativeZOrderLayers()) {
4102         if (layerHas3DContent(*renderLayer))
4103             return true;
4104     }
4105 
4106     for (auto* renderLayer : layer.positiveZOrderLayers()) {
4107         if (layerHas3DContent(*renderLayer))
4108             return true;
4109     }
4110 
4111     for (auto* renderLayer : layer.normalFlowLayers()) {
4112         if (layerHas3DContent(*renderLayer))
4113             return true;
4114     }
4115 
4116     return false;
4117 }
4118 
4119 void RenderLayerCompositor::deviceOrPageScaleFactorChanged()
4120 {
4121     // Page scale will only be applied at to the RenderView and sublayers, but the device scale factor
4122     // needs to be applied at the level of rootGraphicsLayer().
4123     if (auto* rootLayer = rootGraphicsLayer())
4124         rootLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
4125 }
4126 
4127 void RenderLayerCompositor::removeFromScrollCoordinatedLayers(RenderLayer&amp; layer)
4128 {
4129 #if PLATFORM(IOS_FAMILY)
4130     if (m_legacyScrollingLayerCoordinator)
4131         m_legacyScrollingLayerCoordinator-&gt;removeLayer(layer);
4132 #endif
4133 
4134     detachScrollCoordinatedLayer(layer, allScrollCoordinationRoles());
4135 }
4136 
4137 FixedPositionViewportConstraints RenderLayerCompositor::computeFixedViewportConstraints(RenderLayer&amp; layer) const
4138 {
4139     ASSERT(layer.isComposited());
4140 
4141     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4142 
4143     FixedPositionViewportConstraints constraints;
4144     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4145     constraints.setViewportRectAtLastLayout(m_renderView.frameView().rectForFixedPositionLayout());
4146     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4147 
4148     const RenderStyle&amp; style = layer.renderer().style();
4149     if (!style.left().isAuto())
4150         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
4151 
4152     if (!style.right().isAuto())
4153         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
4154 
4155     if (!style.top().isAuto())
4156         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
4157 
4158     if (!style.bottom().isAuto())
4159         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
4160 
4161     // If left and right are auto, use left.
4162     if (style.left().isAuto() &amp;&amp; style.right().isAuto())
4163         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
4164 
4165     // If top and bottom are auto, use top.
4166     if (style.top().isAuto() &amp;&amp; style.bottom().isAuto())
4167         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
4168 
4169     return constraints;
4170 }
4171 
4172 StickyPositionViewportConstraints RenderLayerCompositor::computeStickyViewportConstraints(RenderLayer&amp; layer) const
4173 {
4174     ASSERT(layer.isComposited());
4175 
4176     auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(layer.renderer());
4177 
4178     StickyPositionViewportConstraints constraints;
4179     renderer.computeStickyPositionConstraints(constraints, renderer.constrainingRectForStickyPosition());
4180 
4181     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4182     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4183     constraints.setStickyOffsetAtLastLayout(renderer.stickyPositionOffset());
4184     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4185 
4186     return constraints;
4187 }
4188 
4189 static inline ScrollCoordinationRole scrollCoordinationRoleForNodeType(ScrollingNodeType nodeType)
4190 {
4191     switch (nodeType) {
4192     case ScrollingNodeType::MainFrame:
4193     case ScrollingNodeType::Subframe:
4194     case ScrollingNodeType::Overflow:
4195         return ScrollCoordinationRole::Scrolling;
4196     case ScrollingNodeType::OverflowProxy:
4197         return ScrollCoordinationRole::ScrollingProxy;
4198     case ScrollingNodeType::FrameHosting:
4199         return ScrollCoordinationRole::FrameHosting;
4200     case ScrollingNodeType::Fixed:
4201     case ScrollingNodeType::Sticky:
4202         return ScrollCoordinationRole::ViewportConstrained;
4203     case ScrollingNodeType::Positioned:
4204         return ScrollCoordinationRole::Positioning;
4205     }
4206     ASSERT_NOT_REACHED();
4207     return ScrollCoordinationRole::Scrolling;
4208 }
4209 
4210 ScrollingNodeID RenderLayerCompositor::attachScrollingNode(RenderLayer&amp; layer, ScrollingNodeType nodeType, ScrollingTreeState&amp; treeState)
4211 {
4212     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4213     auto* backing = layer.backing();
4214     // Crash logs suggest that backing can be null here, but we don&#39;t know how: rdar://problem/18545452.
4215     ASSERT(backing);
4216     if (!backing)
4217         return 0;
4218 
4219     ASSERT(treeState.parentNodeID || nodeType == ScrollingNodeType::Subframe);
4220     ASSERT_IMPLIES(nodeType == ScrollingNodeType::MainFrame, !treeState.parentNodeID.value());
4221 
4222     ScrollCoordinationRole role = scrollCoordinationRoleForNodeType(nodeType);
4223     ScrollingNodeID nodeID = backing-&gt;scrollingNodeIDForRole(role);
4224 
4225     nodeID = registerScrollingNodeID(*scrollingCoordinator, nodeID, nodeType, treeState);
4226 
4227     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; attachScrollingNode &quot; &lt;&lt; nodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; backing-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) type &quot; &lt;&lt; nodeType &lt;&lt; &quot; parent &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
4228 
4229     if (!nodeID)
4230         return 0;
4231 
4232     backing-&gt;setScrollingNodeIDForRole(nodeID, role);
4233     m_scrollingNodeToLayerMap.add(nodeID, &amp;layer);
4234 
4235     return nodeID;
4236 }
4237 
4238 ScrollingNodeID RenderLayerCompositor::registerScrollingNodeID(ScrollingCoordinator&amp; scrollingCoordinator, ScrollingNodeID nodeID, ScrollingNodeType nodeType, struct ScrollingTreeState&amp; treeState)
4239 {
4240     if (!nodeID)
4241         nodeID = scrollingCoordinator.uniqueScrollingNodeID();
4242 
4243     if (nodeType == ScrollingNodeType::Subframe &amp;&amp; !treeState.parentNodeID)
4244         nodeID = scrollingCoordinator.createNode(nodeType, nodeID);
4245     else {
4246         auto newNodeID = scrollingCoordinator.insertNode(nodeType, nodeID, treeState.parentNodeID.valueOr(0), treeState.nextChildIndex);
4247         if (newNodeID != nodeID) {
4248             // We&#39;ll get a new nodeID if the type changed (and not if the node is new).
4249             scrollingCoordinator.unparentChildrenAndDestroyNode(nodeID);
4250             m_scrollingNodeToLayerMap.remove(nodeID);
4251         }
4252         nodeID = newNodeID;
4253     }
4254 
4255     ASSERT(nodeID);
4256     if (!nodeID)
4257         return 0;
4258 
4259     ++treeState.nextChildIndex;
4260     return nodeID;
4261 }
4262 
4263 void RenderLayerCompositor::detachScrollCoordinatedLayerWithRole(RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator, ScrollCoordinationRole role)
4264 {
4265     auto unregisterNode = [&amp;](ScrollingNodeID nodeID) {
4266         auto childNodes = scrollingCoordinator.childrenOfNode(nodeID);
4267         for (auto childNodeID : childNodes) {
4268             if (auto* layer = m_scrollingNodeToLayerMap.get(childNodeID))
4269                 layer-&gt;setNeedsScrollingTreeUpdate();
4270         }
4271 
4272         m_scrollingNodeToLayerMap.remove(nodeID);
4273     };
4274 
4275     if (role == ScrollCoordinationRole::ScrollingProxy) {
4276         ASSERT(layer.isComposited());
4277         auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();
4278         if (!clippingStack)
4279             return;
4280 
4281         auto&amp; stack = clippingStack-&gt;stack();
4282         for (auto&amp; entry : stack) {
4283             if (entry.overflowScrollProxyNodeID)
4284                 unregisterNode(entry.overflowScrollProxyNodeID);
4285         }
4286         return;
4287     }
4288 
4289     auto nodeID = layer.backing()-&gt;scrollingNodeIDForRole(role);
4290     if (!nodeID)
4291         return;
4292 
4293     unregisterNode(nodeID);
4294 }
4295 
4296 void RenderLayerCompositor::detachScrollCoordinatedLayer(RenderLayer&amp; layer, OptionSet&lt;ScrollCoordinationRole&gt; roles)
4297 {
4298     auto* backing = layer.backing();
4299     if (!backing)
4300         return;
4301 
4302     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4303 
4304     if (roles.contains(ScrollCoordinationRole::Scrolling))
4305         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
4306 
4307     if (roles.contains(ScrollCoordinationRole::ScrollingProxy))
4308         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ScrollingProxy);
4309 
4310     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4311         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
4312 
4313     if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4314         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
4315 
4316     if (roles.contains(ScrollCoordinationRole::Positioning))
4317         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);
4318 
4319     backing-&gt;detachFromScrollingCoordinator(roles);
4320 }
4321 
4322 OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer) const
4323 {
4324     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;
4325     if (isViewportConstrainedFixedOrStickyLayer(layer))
4326         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);
4327 
4328     if (useCoordinatedScrollingForLayer(layer))
4329         coordinationRoles.add(ScrollCoordinationRole::Scrolling);
4330 
4331     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer);
4332     switch (coordinatedPositioning) {
4333     case ScrollPositioningBehavior::Moves:
4334         coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);
4335         break;
4336     case ScrollPositioningBehavior::Stationary:
4337         coordinationRoles.add(ScrollCoordinationRole::Positioning);
4338         break;
4339     case ScrollPositioningBehavior::None:
4340         break;
4341     }
4342 
4343     if (isLayerForIFrameWithScrollCoordinatedContents(layer))
4344         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);
4345 
4346     return coordinationRoles;
4347 }
4348 
4349 ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4350 {
4351     auto roles = coordinatedScrollingRolesForLayer(layer);
4352 
4353 #if PLATFORM(IOS_FAMILY)
4354     if (m_legacyScrollingLayerCoordinator) {
4355         if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4356             m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
4357         else
4358             m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
4359     }
4360 #endif
4361 
4362     if (!hasCoordinatedScrolling()) {
4363         // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
4364         return 0;
4365     }
4366 
4367     auto newNodeID = treeState.parentNodeID.valueOr(0);
4368 
4369     ScrollingTreeState childTreeState;
4370     ScrollingTreeState* currentTreeState = &amp;treeState;
4371 
4372     // If there&#39;s a positioning node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4373     if (roles.contains(ScrollCoordinationRole::Positioning)) {
4374         newNodeID = updateScrollingNodeForPositioningRole(layer, *currentTreeState, changes);
4375         childTreeState.parentNodeID = newNodeID;
4376         currentTreeState = &amp;childTreeState;
4377     } else
4378         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);
4379 
4380     // If there&#39;s a scrolling proxy node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4381     if (roles.contains(ScrollCoordinationRole::ScrollingProxy)) {
4382         newNodeID = updateScrollingNodeForScrollingProxyRole(layer, *currentTreeState, changes);
4383         childTreeState.parentNodeID = newNodeID;
4384         currentTreeState = &amp;childTreeState;
4385     } else
4386         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ScrollingProxy);
4387 
4388     // If is fixed or sticky, it&#39;s the parent scrolling node for scrolling/frame hosting.
4389     if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
4390         newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
4391         // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
4392         childTreeState.parentNodeID = newNodeID;
4393         currentTreeState = &amp;childTreeState;
4394     } else
4395         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ViewportConstrained);
4396 
4397     if (roles.contains(ScrollCoordinationRole::Scrolling))
4398         newNodeID = updateScrollingNodeForScrollingRole(layer, *currentTreeState, changes);
4399     else
4400         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Scrolling);
4401 
4402     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4403         newNodeID = updateScrollingNodeForFrameHostingRole(layer, *currentTreeState, changes);
4404     else
4405         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::FrameHosting);
4406 
4407     return newNodeID;
4408 }
4409 
4410 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4411 {
4412     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4413 
4414     auto nodeType = ScrollingNodeType::Fixed;
4415     if (layer.renderer().style().position() == PositionType::Sticky)
4416         nodeType = ScrollingNodeType::Sticky;
4417     else
4418         ASSERT(layer.renderer().isFixedPositioned());
4419 
4420     auto newNodeID = attachScrollingNode(layer, nodeType, treeState);
4421     if (!newNodeID) {
4422         ASSERT_NOT_REACHED();
4423         return treeState.parentNodeID.valueOr(0);
4424     }
4425 
4426     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Registering ViewportConstrained &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) as child of &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
4427 
4428     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4429         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4430 
4431     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4432         switch (nodeType) {
4433         case ScrollingNodeType::Fixed:
4434             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeFixedViewportConstraints(layer));
4435             break;
4436         case ScrollingNodeType::Sticky:
4437             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeStickyViewportConstraints(layer));
4438             break;
4439         default:
4440             break;
4441         }
4442     }
4443 
4444     return newNodeID;
4445 }
4446 
4447 LayoutRect RenderLayerCompositor::rootParentRelativeScrollableRect() const
4448 {
4449     auto&amp; frameView = m_renderView.frameView();
4450 
4451     if (m_renderView.frame().isMainFrame())
4452         return frameView.frameRect();
4453 
4454     return LayoutRect({ }, LayoutSize(frameView.size()));
4455 }
4456 
4457 LayoutRect RenderLayerCompositor::parentRelativeScrollableRect(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const
4458 {
4459     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
4460     if (!ancestorLayer)
4461         return LayoutRect({ }, LayoutSize(layer.visibleSize()));
4462 
4463     LayoutRect scrollableRect;
4464     if (is&lt;RenderBox&gt;(layer.renderer()))
4465         scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();
4466 
4467     auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.
4468     scrollableRect.setLocation(offset);
4469     return scrollableRect;
4470 }
4471 
4472 void RenderLayerCompositor::updateScrollingNodeLayers(ScrollingNodeID nodeID, RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator)
4473 {
4474     if (layer.isRenderViewLayer()) {
4475         FrameView&amp; frameView = m_renderView.frameView();
4476         scrollingCoordinator.setNodeLayers(nodeID, { nullptr,
4477             scrollContainerLayer(), scrolledContentsLayer(),
4478             fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer(),
4479             frameView.layerForHorizontalScrollbar(), frameView.layerForVerticalScrollbar() });
4480     } else {
4481         auto&amp; backing = *layer.backing();
4482         scrollingCoordinator.setNodeLayers(nodeID, { backing.graphicsLayer(),
4483             backing.scrollContainerLayer(), backing.scrolledContentsLayer(),
4484             nullptr, nullptr, nullptr,
4485             layer.layerForHorizontalScrollbar(), layer.layerForVerticalScrollbar() });
4486     }
4487 }
4488 
4489 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4490 {
4491     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4492 
4493     ScrollingNodeID newNodeID = 0;
4494 
4495     if (layer.isRenderViewLayer()) {
4496         FrameView&amp; frameView = m_renderView.frameView();
4497         ASSERT_UNUSED(frameView, scrollingCoordinator-&gt;coordinatesScrollingForFrameView(frameView));
4498 
4499         newNodeID = attachScrollingNode(*m_renderView.layer(), m_renderView.frame().isMainFrame() ? ScrollingNodeType::MainFrame : ScrollingNodeType::Subframe, treeState);
4500 
4501         if (!newNodeID) {
4502             ASSERT_NOT_REACHED();
4503             return treeState.parentNodeID.valueOr(0);
4504         }
4505 
4506         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4507             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);
4508 
4509         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4510             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, rootParentRelativeScrollableRect());
4511             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, frameView);
4512             scrollingCoordinator-&gt;setFrameScrollingNodeState(newNodeID, frameView);
4513         }
4514     } else {
4515         newNodeID = attachScrollingNode(layer, ScrollingNodeType::Overflow, treeState);
4516         if (!newNodeID) {
4517             ASSERT_NOT_REACHED();
4518             return treeState.parentNodeID.valueOr(0);
4519         }
4520 
4521         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4522             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);
4523 
4524         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4525             RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4526             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));
4527             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, layer);
4528         }
4529     }
4530 
4531     return newNodeID;
4532 }
4533 
4534 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingProxyRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4535 {
4536     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4537     auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();
4538     if (!clippingStack) {
4539         ASSERT_NOT_REACHED();
4540         return treeState.parentNodeID.valueOr(0);
4541     }
4542 
4543     ScrollingNodeID nodeID = 0;
4544     for (auto&amp; entry : clippingStack-&gt;stack()) {
4545         if (!entry.clipData.isOverflowScroll)
4546             continue;
4547 
4548         nodeID = registerScrollingNodeID(*scrollingCoordinator, entry.overflowScrollProxyNodeID, ScrollingNodeType::OverflowProxy, treeState);
4549         if (!nodeID) {
4550             ASSERT_NOT_REACHED();
4551             return treeState.parentNodeID.valueOr(0);
4552         }
4553         entry.overflowScrollProxyNodeID = nodeID;
4554 
4555         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4556             scrollingCoordinator-&gt;setNodeLayers(entry.overflowScrollProxyNodeID, { entry.clippingLayer.get() });
4557 
4558         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4559             ASSERT(entry.clipData.clippingLayer);
4560             ASSERT(entry.clipData.clippingLayer-&gt;isComposited());
4561 
4562             ScrollingNodeID overflowScrollNodeID = 0;
4563             if (auto* backing = entry.clipData.clippingLayer-&gt;backing())
4564                 overflowScrollNodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
4565 
4566             Vector&lt;ScrollingNodeID&gt; scrollingNodeIDs;
4567             if (overflowScrollNodeID)
4568                 scrollingNodeIDs.append(overflowScrollNodeID);
4569             scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(entry.overflowScrollProxyNodeID, WTFMove(scrollingNodeIDs));
4570         }
4571     }
4572 
4573     if (!nodeID)
4574         return treeState.parentNodeID.valueOr(0);
4575 
4576     return nodeID;
4577 }
4578 
4579 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForFrameHostingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4580 {
4581     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4582 
4583     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
4584     if (!newNodeID) {
4585         ASSERT_NOT_REACHED();
4586         return treeState.parentNodeID.valueOr(0);
4587     }
4588 
4589     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4590         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4591 
4592     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4593         RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4594         scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));
4595     }
4596 
4597     return newNodeID;
4598 }
4599 
4600 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4601 {
4602     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4603 
4604     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);
4605     if (!newNodeID) {
4606         ASSERT_NOT_REACHED();
4607         return treeState.parentNodeID.valueOr(0);
4608     }
4609 
4610     if (changes &amp; ScrollingNodeChangeFlags::Layer) {
4611         auto&amp; backing = *layer.backing();
4612         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { backing.graphicsLayer() });
4613     }
4614 
4615     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4616         // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.
4617         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer);
4618         auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);
4619         scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));
4620 
4621         auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4622         AbsolutePositionConstraints constraints;
4623         constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4624         constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4625         scrollingCoordinator-&gt;setPositionedNodeConstraints(newNodeID, constraints);
4626     }
4627 
4628     return newNodeID;
4629 }
4630 
4631 ScrollableArea* RenderLayerCompositor::scrollableAreaForScrollLayerID(ScrollingNodeID nodeID) const
4632 {
4633     if (!nodeID)
4634         return nullptr;
4635 
4636     return m_scrollingNodeToLayerMap.get(nodeID);
4637 }
4638 
4639 void RenderLayerCompositor::willRemoveScrollingLayerWithBacking(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4640 {
4641     if (scrollingCoordinator())
4642         return;
4643 
4644 #if PLATFORM(IOS_FAMILY)
4645     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
4646     if (m_legacyScrollingLayerCoordinator)
4647         m_legacyScrollingLayerCoordinator-&gt;removeScrollingLayer(layer, backing);
4648 #else
4649     UNUSED_PARAM(layer);
4650     UNUSED_PARAM(backing);
4651 #endif
4652 }
4653 
4654 // FIXME: This should really be called from the updateBackingAndHierarchy.
4655 void RenderLayerCompositor::didAddScrollingLayer(RenderLayer&amp; layer)
4656 {
4657     if (scrollingCoordinator())
4658         return;
4659 
4660 #if PLATFORM(IOS_FAMILY)
4661     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
4662     if (m_legacyScrollingLayerCoordinator)
4663         m_legacyScrollingLayerCoordinator-&gt;addScrollingLayer(layer);
4664 #else
4665     UNUSED_PARAM(layer);
4666 #endif
4667 }
4668 
4669 void RenderLayerCompositor::windowScreenDidChange(PlatformDisplayID displayID)
4670 {
4671     if (m_layerUpdater)
4672         m_layerUpdater-&gt;screenDidChange(displayID);
4673 }
4674 
4675 ScrollingCoordinator* RenderLayerCompositor::scrollingCoordinator() const
4676 {
4677     return page().scrollingCoordinator();
4678 }
4679 
4680 GraphicsLayerFactory* RenderLayerCompositor::graphicsLayerFactory() const
4681 {
4682     return page().chrome().client().graphicsLayerFactory();
4683 }
4684 
4685 void RenderLayerCompositor::setLayerFlushThrottlingEnabled(bool enabled)
4686 {
4687     m_layerFlushThrottlingEnabled = enabled;
4688     if (m_layerFlushThrottlingEnabled)
4689         return;
4690     m_layerFlushTimer.stop();
4691     if (!m_hasPendingLayerFlush)
4692         return;
4693     scheduleLayerFlush();
4694 }
4695 
4696 void RenderLayerCompositor::disableLayerFlushThrottlingTemporarilyForInteraction()
4697 {
4698     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4699         return;
4700     m_layerFlushThrottlingTemporarilyDisabledForInteraction = true;
4701 }
4702 
4703 bool RenderLayerCompositor::isThrottlingLayerFlushes() const
4704 {
4705     if (!m_layerFlushThrottlingEnabled)
4706         return false;
4707     if (!m_layerFlushTimer.isActive())
4708         return false;
4709     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4710         return false;
4711     return true;
4712 }
4713 
4714 void RenderLayerCompositor::startLayerFlushTimerIfNeeded()
4715 {
4716     m_layerFlushThrottlingTemporarilyDisabledForInteraction = false;
4717     m_layerFlushTimer.stop();
4718     if (!m_layerFlushThrottlingEnabled)
4719         return;
4720     m_layerFlushTimer.startOneShot(throttledLayerFlushDelay);
4721 }
4722 
4723 void RenderLayerCompositor::startInitialLayerFlushTimerIfNeeded()
4724 {
4725     if (!m_layerFlushThrottlingEnabled)
4726         return;
4727     if (m_layerFlushTimer.isActive())
4728         return;
4729     m_layerFlushTimer.startOneShot(throttledLayerFlushInitialDelay);
4730 }
4731 
4732 void RenderLayerCompositor::layerFlushTimerFired()
4733 {
4734     if (!m_hasPendingLayerFlush)
4735         return;
4736     scheduleLayerFlush();
4737 }
4738 
4739 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
4740 RefPtr&lt;DisplayRefreshMonitor&gt; RenderLayerCompositor::createDisplayRefreshMonitor(PlatformDisplayID displayID) const
4741 {
4742     if (auto monitor = page().chrome().client().createDisplayRefreshMonitor(displayID))
4743         return monitor;
4744 
4745     return DisplayRefreshMonitor::createDefaultDisplayRefreshMonitor(displayID);
4746 }
4747 #endif
4748 
4749 #if ENABLE(CSS_SCROLL_SNAP)
4750 void RenderLayerCompositor::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView) const
4751 {
4752     if (auto* coordinator = scrollingCoordinator())
4753         coordinator-&gt;updateScrollSnapPropertiesWithFrameView(frameView);
4754 }
4755 #endif
4756 
4757 Page&amp; RenderLayerCompositor::page() const
4758 {
4759     return m_renderView.page();
4760 }
4761 
4762 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CompositingUpdateType updateType)
4763 {
4764     switch (updateType) {
4765     case CompositingUpdateType::AfterStyleChange: ts &lt;&lt; &quot;after style change&quot;; break;
4766     case CompositingUpdateType::AfterLayout: ts &lt;&lt; &quot;after layout&quot;; break;
4767     case CompositingUpdateType::OnScroll: ts &lt;&lt; &quot;on scroll&quot;; break;
4768     case CompositingUpdateType::OnCompositedScroll: ts &lt;&lt; &quot;on composited scroll&quot;; break;
4769     }
4770     return ts;
4771 }
4772 
4773 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CompositingPolicy compositingPolicy)
4774 {
4775     switch (compositingPolicy) {
4776     case CompositingPolicy::Normal: ts &lt;&lt; &quot;normal&quot;; break;
4777     case CompositingPolicy::Conservative: ts &lt;&lt; &quot;conservative&quot;; break;
4778     }
4779     return ts;
4780 }
4781 
4782 #if PLATFORM(IOS_FAMILY)
4783 typedef HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt; LayerMap;
4784 typedef HashMap&lt;PlatformLayer*, PlatformLayer*&gt; StickyContainerMap;
4785 
4786 void LegacyWebKitScrollingLayerCoordinator::registerAllViewportConstrainedLayers(RenderLayerCompositor&amp; compositor)
4787 {
4788     if (!m_coordinateViewportConstrainedLayers)
4789         return;
4790 
4791     LayerMap layerMap;
4792     StickyContainerMap stickyContainerMap;
4793 
4794     for (auto* layer : m_viewportConstrainedLayers) {
4795         ASSERT(layer-&gt;isComposited());
4796 
4797         std::unique_ptr&lt;ViewportConstraints&gt; constraints;
4798         if (layer-&gt;renderer().isStickilyPositioned()) {
4799             constraints = makeUnique&lt;StickyPositionViewportConstraints&gt;(compositor.computeStickyViewportConstraints(*layer));
4800             const RenderLayer* enclosingTouchScrollableLayer = nullptr;
4801             if (compositor.isAsyncScrollableStickyLayer(*layer, &amp;enclosingTouchScrollableLayer) &amp;&amp; enclosingTouchScrollableLayer) {
4802                 ASSERT(enclosingTouchScrollableLayer-&gt;isComposited());
4803                 // what
4804                 stickyContainerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), enclosingTouchScrollableLayer-&gt;backing()-&gt;scrollContainerLayer()-&gt;platformLayer());
4805             }
4806         } else if (layer-&gt;renderer().isFixedPositioned())
4807             constraints = makeUnique&lt;FixedPositionViewportConstraints&gt;(compositor.computeFixedViewportConstraints(*layer));
4808         else
4809             continue;
4810 
4811         layerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), WTFMove(constraints));
4812     }
4813 
4814     m_chromeClient.updateViewportConstrainedLayers(layerMap, stickyContainerMap);
4815 }
4816 
4817 void LegacyWebKitScrollingLayerCoordinator::unregisterAllViewportConstrainedLayers()
4818 {
4819     if (!m_coordinateViewportConstrainedLayers)
4820         return;
4821 
4822     LayerMap layerMap;
4823     m_chromeClient.updateViewportConstrainedLayers(layerMap, { });
4824 }
4825 
4826 void LegacyWebKitScrollingLayerCoordinator::updateScrollingLayer(RenderLayer&amp; layer)
4827 {
4828     auto* backing = layer.backing();
4829     ASSERT(backing);
4830 
4831     bool allowHorizontalScrollbar = !layer.horizontalScrollbarHiddenByStyle();
4832     bool allowVerticalScrollbar = !layer.verticalScrollbarHiddenByStyle();
4833 
4834     m_chromeClient.addOrUpdateScrollingLayer(layer.renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer(),
4835         layer.reachableTotalContentsSize(), allowHorizontalScrollbar, allowVerticalScrollbar);
4836 }
4837 
4838 void LegacyWebKitScrollingLayerCoordinator::registerAllScrollingLayers()
4839 {
4840     for (auto* layer : m_scrollingLayers)
4841         updateScrollingLayer(*layer);
4842 }
4843 
4844 void LegacyWebKitScrollingLayerCoordinator::unregisterAllScrollingLayers()
4845 {
4846     for (auto* layer : m_scrollingLayers) {
4847         auto* backing = layer-&gt;backing();
4848         ASSERT(backing);
4849         m_chromeClient.removeScrollingLayer(layer-&gt;renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer());
4850     }
4851 }
4852 
4853 void LegacyWebKitScrollingLayerCoordinator::addScrollingLayer(RenderLayer&amp; layer)
4854 {
4855     m_scrollingLayers.add(&amp;layer);
4856 }
4857 
4858 void LegacyWebKitScrollingLayerCoordinator::removeScrollingLayer(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4859 {
4860     if (m_scrollingLayers.remove(&amp;layer)) {
4861         auto* scrollContainerLayer = backing.scrollContainerLayer()-&gt;platformLayer();
4862         auto* scrolledContentsLayer = backing.scrolledContentsLayer()-&gt;platformLayer();
4863         m_chromeClient.removeScrollingLayer(layer.renderer().element(), scrollContainerLayer, scrolledContentsLayer);
4864     }
4865 }
4866 
4867 void LegacyWebKitScrollingLayerCoordinator::removeLayer(RenderLayer&amp; layer)
4868 {
4869     removeScrollingLayer(layer, *layer.backing());
4870 
4871     // We&#39;ll put the new set of layers to the client via registerAllViewportConstrainedLayers() at flush time.
4872     m_viewportConstrainedLayers.remove(&amp;layer);
4873 }
4874 
4875 void LegacyWebKitScrollingLayerCoordinator::addViewportConstrainedLayer(RenderLayer&amp; layer)
4876 {
4877     m_viewportConstrainedLayers.add(&amp;layer);
4878 }
4879 
4880 void LegacyWebKitScrollingLayerCoordinator::removeViewportConstrainedLayer(RenderLayer&amp; layer)
4881 {
4882     m_viewportConstrainedLayers.remove(&amp;layer);
4883 }
4884 
4885 #endif
4886 
4887 } // namespace WebCore
4888 
4889 #if ENABLE(TREE_DEBUGGING)
4890 void showGraphicsLayerTreeForCompositor(WebCore::RenderLayerCompositor&amp; compositor)
4891 {
4892     showGraphicsLayerTree(compositor.rootGraphicsLayer());
4893 }
4894 #endif
    </pre>
  </body>
</html>