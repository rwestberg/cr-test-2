<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2004 Allan Sandfeld Jensen (kde@carewolf.com)
   6  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2011, 2013 Apple Inc. All rights reserved.
   7  * Copyright (C) 2009 Google Inc. All rights reserved.
   8  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  *
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;RenderObject.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;CSSAnimationController.h&quot;
  32 #include &quot;Editing.h&quot;
  33 #include &quot;FloatQuad.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;FrameSelection.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;GeometryUtilities.h&quot;
  38 #include &quot;GraphicsContext.h&quot;
  39 #include &quot;HTMLElement.h&quot;
  40 #include &quot;HTMLNames.h&quot;
  41 #include &quot;HTMLTableCellElement.h&quot;
  42 #include &quot;HTMLTableElement.h&quot;
  43 #include &quot;HitTestResult.h&quot;
  44 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  45 #include &quot;Page.h&quot;
  46 #include &quot;PseudoElement.h&quot;
  47 #include &quot;RenderChildIterator.h&quot;
  48 #include &quot;RenderCounter.h&quot;
  49 #include &quot;RenderFragmentedFlow.h&quot;
  50 #include &quot;RenderGeometryMap.h&quot;
  51 #include &quot;RenderInline.h&quot;
  52 #include &quot;RenderIterator.h&quot;
  53 #include &quot;RenderLayer.h&quot;
  54 #include &quot;RenderLayerBacking.h&quot;
  55 #include &quot;RenderLayerCompositor.h&quot;
  56 #include &quot;RenderMultiColumnFlow.h&quot;
  57 #include &quot;RenderRuby.h&quot;
  58 #include &quot;RenderSVGBlock.h&quot;
  59 #include &quot;RenderSVGInline.h&quot;
  60 #include &quot;RenderSVGModelObject.h&quot;
  61 #include &quot;RenderSVGResourceContainer.h&quot;
  62 #include &quot;RenderSVGRoot.h&quot;
  63 #include &quot;RenderScrollbarPart.h&quot;
  64 #include &quot;RenderTableRow.h&quot;
  65 #include &quot;RenderTheme.h&quot;
  66 #include &quot;RenderTreeBuilder.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;RenderWidget.h&quot;
  69 #include &quot;SVGRenderSupport.h&quot;
  70 #include &quot;StyleResolver.h&quot;
  71 #include &quot;TransformState.h&quot;
  72 #include &lt;algorithm&gt;
  73 #include &lt;stdio.h&gt;
  74 #include &lt;wtf/IsoMallocInlines.h&gt;
  75 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  76 #include &lt;wtf/text/TextStream.h&gt;
  77 
  78 #if PLATFORM(IOS_FAMILY)
  79 #include &quot;SelectionRect.h&quot;
  80 #endif
  81 
  82 namespace WebCore {
  83 
  84 using namespace HTMLNames;
  85 
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderObject);
  87 
  88 #ifndef NDEBUG
  89 
  90 RenderObject::SetLayoutNeededForbiddenScope::SetLayoutNeededForbiddenScope(RenderObject* renderObject, bool isForbidden)
  91     : m_renderObject(renderObject)
  92     , m_preexistingForbidden(m_renderObject-&gt;isSetNeedsLayoutForbidden())
  93 {
  94     m_renderObject-&gt;setNeedsLayoutIsForbidden(isForbidden);
  95 }
  96 
  97 RenderObject::SetLayoutNeededForbiddenScope::~SetLayoutNeededForbiddenScope()
  98 {
  99     m_renderObject-&gt;setNeedsLayoutIsForbidden(m_preexistingForbidden);
 100 }
 101 #endif
 102 
 103 struct SameSizeAsRenderObject {
 104     virtual ~SameSizeAsRenderObject() = default; // Allocate vtable pointer.
 105     void* pointers[5];
 106 #ifndef NDEBUG
 107     unsigned m_debugBitfields : 2;
 108 #endif
 109     unsigned m_bitfields;
 110 };
 111 
 112 COMPILE_ASSERT(sizeof(RenderObject) == sizeof(SameSizeAsRenderObject), RenderObject_should_stay_small);
 113 
 114 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, renderObjectCounter, (&quot;RenderObject&quot;));
 115 
 116 void RenderObjectDeleter::operator() (RenderObject* renderer) const
 117 {
 118     renderer-&gt;destroy();
 119 }
 120 
 121 RenderObject::RenderObject(Node&amp; node)
 122     : CachedImageClient()
 123     , m_node(node)
 124     , m_parent(nullptr)
 125     , m_previous(nullptr)
 126     , m_next(nullptr)
 127 #ifndef NDEBUG
 128     , m_hasAXObject(false)
 129     , m_setNeedsLayoutForbidden(false)
 130 #endif
 131     , m_bitfields(node)
 132 {
 133     if (RenderView* renderView = node.document().renderView())
 134         renderView-&gt;didCreateRenderer();
 135 #ifndef NDEBUG
 136     renderObjectCounter.increment();
 137 #endif
 138 }
 139 
 140 RenderObject::~RenderObject()
 141 {
 142     view().didDestroyRenderer();
 143 #ifndef NDEBUG
 144     ASSERT(!m_hasAXObject);
 145     renderObjectCounter.decrement();
 146 #endif
 147     ASSERT(!hasRareData());
 148 }
 149 
 150 RenderTheme&amp; RenderObject::theme() const
 151 {
 152     return RenderTheme::singleton();
 153 }
 154 
 155 bool RenderObject::isDescendantOf(const RenderObject* ancestor) const
 156 {
 157     for (const RenderObject* renderer = this; renderer; renderer = renderer-&gt;m_parent) {
 158         if (renderer == ancestor)
 159             return true;
 160     }
 161     return false;
 162 }
 163 
 164 bool RenderObject::isLegend() const
 165 {
 166     return node() &amp;&amp; node()-&gt;hasTagName(legendTag);
 167 }
 168 
 169 
 170 bool RenderObject::isFieldset() const
 171 {
 172     return node() &amp;&amp; node()-&gt;hasTagName(fieldsetTag);
 173 }
 174 
 175 bool RenderObject::isHTMLMarquee() const
 176 {
 177     return node() &amp;&amp; node()-&gt;renderer() == this &amp;&amp; node()-&gt;hasTagName(marqueeTag);
 178 }
 179 
 180 void RenderObject::setFragmentedFlowStateIncludingDescendants(FragmentedFlowState state)
 181 {
 182     setFragmentedFlowState(state);
 183 
 184     if (!is&lt;RenderElement&gt;(*this))
 185         return;
 186 
 187     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(*this))) {
 188         // If the child is a fragmentation context it already updated the descendants flag accordingly.
 189         if (child.isRenderFragmentedFlow())
 190             continue;
 191         ASSERT(state != child.fragmentedFlowState());
 192         child.setFragmentedFlowStateIncludingDescendants(state);
 193     }
 194 }
 195 
 196 RenderObject::FragmentedFlowState RenderObject::computedFragmentedFlowState(const RenderObject&amp; renderer)
 197 {
 198     if (!renderer.parent())
 199         return renderer.fragmentedFlowState();
 200 
 201     if (is&lt;RenderMultiColumnFlow&gt;(renderer)) {
 202         // Multicolumn flows do not inherit the flow state.
 203         return InsideInFragmentedFlow;
 204     }
 205 
 206     auto inheritedFlowState = RenderObject::NotInsideFragmentedFlow;
 207     if (is&lt;RenderText&gt;(renderer))
 208         inheritedFlowState = renderer.parent()-&gt;fragmentedFlowState();
 209     else if (is&lt;RenderSVGBlock&gt;(renderer) || is&lt;RenderSVGInline&gt;(renderer) || is&lt;RenderSVGModelObject&gt;(renderer)) {
 210         // containingBlock() skips svg boundary (SVG root is a RenderReplaced).
 211         if (auto* svgRoot = SVGRenderSupport::findTreeRootObject(downcast&lt;RenderElement&gt;(renderer)))
 212             inheritedFlowState = svgRoot-&gt;fragmentedFlowState();
 213     } else if (auto* container = renderer.container())
 214         inheritedFlowState = container-&gt;fragmentedFlowState();
 215     else {
 216         // Splitting lines or doing continuation, so just keep the current state.
 217         inheritedFlowState = renderer.fragmentedFlowState();
 218     }
 219     return inheritedFlowState;
 220 }
 221 
 222 void RenderObject::initializeFragmentedFlowStateOnInsertion()
 223 {
 224     ASSERT(parent());
 225 
 226     // A RenderFragmentedFlow is always considered to be inside itself, so it never has to change its state in response to parent changes.
 227     if (isRenderFragmentedFlow())
 228         return;
 229 
 230     auto computedState = computedFragmentedFlowState(*this);
 231     if (fragmentedFlowState() == computedState)
 232         return;
 233 
 234     setFragmentedFlowStateIncludingDescendants(computedState);
 235 }
 236 
 237 void RenderObject::resetFragmentedFlowStateOnRemoval()
 238 {
 239     if (fragmentedFlowState() == NotInsideFragmentedFlow)
 240         return;
 241 
 242     if (!renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderElement&gt;(*this)) {
 243         downcast&lt;RenderElement&gt;(*this).removeFromRenderFragmentedFlow();
 244         return;
 245     }
 246 
 247     // A RenderFragmentedFlow is always considered to be inside itself, so it never has to change its state in response to parent changes.
 248     if (isRenderFragmentedFlow())
 249         return;
 250 
 251     setFragmentedFlowStateIncludingDescendants(NotInsideFragmentedFlow);
 252 }
 253 
 254 void RenderObject::setParent(RenderElement* parent)
 255 {
 256     m_parent = parent;
 257 }
 258 
 259 RenderObject* RenderObject::nextInPreOrder() const
 260 {
 261     if (RenderObject* o = firstChildSlow())
 262         return o;
 263 
 264     return nextInPreOrderAfterChildren();
 265 }
 266 
 267 RenderObject* RenderObject::nextInPreOrderAfterChildren() const
 268 {
 269     RenderObject* o;
 270     if (!(o = nextSibling())) {
 271         o = parent();
 272         while (o &amp;&amp; !o-&gt;nextSibling())
 273             o = o-&gt;parent();
 274         if (o)
 275             o = o-&gt;nextSibling();
 276     }
 277 
 278     return o;
 279 }
 280 
 281 RenderObject* RenderObject::nextInPreOrder(const RenderObject* stayWithin) const
 282 {
 283     if (RenderObject* o = firstChildSlow())
 284         return o;
 285 
 286     return nextInPreOrderAfterChildren(stayWithin);
 287 }
 288 
 289 RenderObject* RenderObject::nextInPreOrderAfterChildren(const RenderObject* stayWithin) const
 290 {
 291     if (this == stayWithin)
 292         return nullptr;
 293 
 294     const RenderObject* current = this;
 295     RenderObject* next;
 296     while (!(next = current-&gt;nextSibling())) {
 297         current = current-&gt;parent();
 298         if (!current || current == stayWithin)
 299             return nullptr;
 300     }
 301     return next;
 302 }
 303 
 304 RenderObject* RenderObject::previousInPreOrder() const
 305 {
 306     if (RenderObject* o = previousSibling()) {
 307         while (RenderObject* last = o-&gt;lastChildSlow())
 308             o = last;
 309         return o;
 310     }
 311 
 312     return parent();
 313 }
 314 
 315 RenderObject* RenderObject::previousInPreOrder(const RenderObject* stayWithin) const
 316 {
 317     if (this == stayWithin)
 318         return nullptr;
 319 
 320     return previousInPreOrder();
 321 }
 322 
 323 RenderObject* RenderObject::childAt(unsigned index) const
 324 {
 325     RenderObject* child = firstChildSlow();
 326     for (unsigned i = 0; child &amp;&amp; i &lt; index; i++)
 327         child = child-&gt;nextSibling();
 328     return child;
 329 }
 330 
 331 RenderObject* RenderObject::firstLeafChild() const
 332 {
 333     RenderObject* r = firstChildSlow();
 334     while (r) {
 335         RenderObject* n = nullptr;
 336         n = r-&gt;firstChildSlow();
 337         if (!n)
 338             break;
 339         r = n;
 340     }
 341     return r;
 342 }
 343 
 344 RenderObject* RenderObject::lastLeafChild() const
 345 {
 346     RenderObject* r = lastChildSlow();
 347     while (r) {
 348         RenderObject* n = nullptr;
 349         n = r-&gt;lastChildSlow();
 350         if (!n)
 351             break;
 352         r = n;
 353     }
 354     return r;
 355 }
 356 
 357 #if ENABLE(TEXT_AUTOSIZING)
 358 
 359 // Non-recursive version of the DFS search.
 360 RenderObject* RenderObject::traverseNext(const RenderObject* stayWithin, HeightTypeTraverseNextInclusionFunction inclusionFunction, int&amp; currentDepth, int&amp; newFixedDepth) const
 361 {
 362     BlockContentHeightType overflowType;
 363 
 364     // Check for suitable children.
 365     for (RenderObject* child = firstChildSlow(); child; child = child-&gt;nextSibling()) {
 366         overflowType = inclusionFunction(*child);
 367         if (overflowType != FixedHeight) {
 368             currentDepth++;
 369             if (overflowType == OverflowHeight)
 370                 newFixedDepth = currentDepth;
 371             ASSERT(!stayWithin || child-&gt;isDescendantOf(stayWithin));
 372             return child;
 373         }
 374     }
 375 
 376     if (this == stayWithin)
 377         return nullptr;
 378 
 379     // Now we traverse other nodes if they exist, otherwise
 380     // we go to the parent node and try doing the same.
 381     const RenderObject* n = this;
 382     while (n) {
 383         while (n &amp;&amp; !n-&gt;nextSibling() &amp;&amp; (!stayWithin || n-&gt;parent() != stayWithin)) {
 384             n = n-&gt;parent();
 385             currentDepth--;
 386         }
 387         if (!n)
 388             return nullptr;
 389         for (RenderObject* sibling = n-&gt;nextSibling(); sibling; sibling = sibling-&gt;nextSibling()) {
 390             overflowType = inclusionFunction(*sibling);
 391             if (overflowType != FixedHeight) {
 392                 if (overflowType == OverflowHeight)
 393                     newFixedDepth = currentDepth;
 394                 ASSERT(!stayWithin || !n-&gt;nextSibling() || n-&gt;nextSibling()-&gt;isDescendantOf(stayWithin));
 395                 return sibling;
 396             }
 397         }
 398         if (!stayWithin || n-&gt;parent() != stayWithin) {
 399             n = n-&gt;parent();
 400             currentDepth--;
 401         } else
 402             return nullptr;
 403     }
 404     return nullptr;
 405 }
 406 
 407 #endif // ENABLE(TEXT_AUTOSIZING)
 408 
 409 RenderLayer* RenderObject::enclosingLayer() const
 410 {
 411     for (auto&amp; renderer : lineageOfType&lt;RenderLayerModelObject&gt;(*this)) {
 412         if (renderer.hasLayer())
 413             return renderer.layer();
 414     }
 415     return nullptr;
 416 }
 417 
 418 bool RenderObject::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
 419 {
 420     if (options.revealMode == SelectionRevealMode::DoNotReveal)
 421         return false;
 422 
 423     RenderLayer* enclosingLayer = this-&gt;enclosingLayer();
 424     if (!enclosingLayer)
 425         return false;
 426 
 427     enclosingLayer-&gt;scrollRectToVisible(absoluteRect, insideFixed, options);
 428     return true;
 429 }
 430 
 431 RenderBox&amp; RenderObject::enclosingBox() const
 432 {
 433     return *lineageOfType&lt;RenderBox&gt;(const_cast&lt;RenderObject&amp;&gt;(*this)).first();
 434 }
 435 
 436 RenderBoxModelObject&amp; RenderObject::enclosingBoxModelObject() const
 437 {
 438     return *lineageOfType&lt;RenderBoxModelObject&gt;(const_cast&lt;RenderObject&amp;&gt;(*this)).first();
 439 }
 440 
 441 const RenderBox* RenderObject::enclosingScrollableContainerForSnapping() const
 442 {
 443     auto&amp; renderBox = enclosingBox();
 444     if (auto* scrollableContainer = renderBox.findEnclosingScrollableContainer()) {
 445         // The scrollable container for snapping cannot be the node itself.
 446         if (scrollableContainer != this)
 447             return scrollableContainer;
 448         if (renderBox.parentBox())
 449             return renderBox.parentBox()-&gt;findEnclosingScrollableContainer();
 450     }
 451     return nullptr;
 452 }
 453 
 454 RenderBlock* RenderObject::firstLineBlock() const
 455 {
 456     return nullptr;
 457 }
 458 
 459 static inline bool objectIsRelayoutBoundary(const RenderElement* object)
 460 {
 461     // FIXME: In future it may be possible to broaden these conditions in order to improve performance.
 462     if (object-&gt;isRenderView())
 463         return true;
 464 
 465     if (object-&gt;isTextControl())
 466         return true;
 467 
 468     if (object-&gt;isSVGRoot())
 469         return true;
 470 
 471     if (!object-&gt;hasOverflowClip())
 472         return false;
 473 
 474     if (object-&gt;style().width().isIntrinsicOrAuto() || object-&gt;style().height().isIntrinsicOrAuto() || object-&gt;style().height().isPercentOrCalculated())
 475         return false;
 476 
 477     // Table parts can&#39;t be relayout roots since the table is responsible for layouting all the parts.
 478     if (object-&gt;isTablePart())
 479         return false;
 480 
 481     return true;
 482 }
 483 
 484 void RenderObject::clearNeedsLayout()
 485 {
 486     m_bitfields.setNeedsLayout(false);
 487     setEverHadLayout(true);
 488     setPosChildNeedsLayoutBit(false);
 489     setNeedsSimplifiedNormalFlowLayoutBit(false);
 490     setNormalChildNeedsLayoutBit(false);
 491     setNeedsPositionedMovementLayoutBit(false);
 492     if (is&lt;RenderElement&gt;(*this))
 493         downcast&lt;RenderElement&gt;(*this).setAncestorLineBoxDirty(false);
 494 #ifndef NDEBUG
 495     checkBlockPositionedObjectsNeedLayout();
 496 #endif
 497 }
 498 
 499 static void scheduleRelayoutForSubtree(RenderElement&amp; renderer)
 500 {
 501     if (is&lt;RenderView&gt;(renderer)) {
 502         downcast&lt;RenderView&gt;(renderer).frameView().layoutContext().scheduleLayout();
 503         return;
 504     }
 505 
 506     if (renderer.isRooted())
 507         renderer.view().frameView().layoutContext().scheduleSubtreeLayout(renderer);
 508 }
 509 
 510 void RenderObject::markContainingBlocksForLayout(ScheduleRelayout scheduleRelayout, RenderElement* newRoot)
 511 {
 512     ASSERT(scheduleRelayout == ScheduleRelayout::No || !newRoot);
 513     ASSERT(!isSetNeedsLayoutForbidden());
 514 
 515     auto ancestor = container();
 516 
 517     bool simplifiedNormalFlowLayout = needsSimplifiedNormalFlowLayout() &amp;&amp; !selfNeedsLayout() &amp;&amp; !normalChildNeedsLayout();
 518     bool hasOutOfFlowPosition = !isText() &amp;&amp; style().hasOutOfFlowPosition();
 519 
 520     while (ancestor) {
 521 #ifndef NDEBUG
 522         // FIXME: Remove this once we remove the special cases for counters, quotes and mathml
 523         // calling setNeedsLayout during preferred width computation.
 524         SetLayoutNeededForbiddenScope layoutForbiddenScope(ancestor, isSetNeedsLayoutForbidden());
 525 #endif
 526         // Don&#39;t mark the outermost object of an unrooted subtree. That object will be
 527         // marked when the subtree is added to the document.
 528         auto container = ancestor-&gt;container();
 529         if (!container &amp;&amp; !ancestor-&gt;isRenderView())
 530             return;
 531         if (hasOutOfFlowPosition) {
 532             bool willSkipRelativelyPositionedInlines = !ancestor-&gt;isRenderBlock() || ancestor-&gt;isAnonymousBlock();
 533             // Skip relatively positioned inlines and anonymous blocks to get to the enclosing RenderBlock.
 534             while (ancestor &amp;&amp; (!ancestor-&gt;isRenderBlock() || ancestor-&gt;isAnonymousBlock()))
 535                 ancestor = ancestor-&gt;container();
 536             if (!ancestor || ancestor-&gt;posChildNeedsLayout())
 537                 return;
 538             if (willSkipRelativelyPositionedInlines)
 539                 container = ancestor-&gt;container();
 540             ancestor-&gt;setPosChildNeedsLayoutBit(true);
 541             simplifiedNormalFlowLayout = true;
 542         } else if (simplifiedNormalFlowLayout) {
 543             if (ancestor-&gt;needsSimplifiedNormalFlowLayout())
 544                 return;
 545             ancestor-&gt;setNeedsSimplifiedNormalFlowLayoutBit(true);
 546         } else {
 547             if (ancestor-&gt;normalChildNeedsLayout())
 548                 return;
 549             ancestor-&gt;setNormalChildNeedsLayoutBit(true);
 550         }
 551         ASSERT(!ancestor-&gt;isSetNeedsLayoutForbidden());
 552 
 553         if (ancestor == newRoot)
 554             return;
 555 
 556         if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; objectIsRelayoutBoundary(ancestor))
 557             break;
 558 
 559         hasOutOfFlowPosition = ancestor-&gt;style().hasOutOfFlowPosition();
 560         ancestor = container;
 561     }
 562 
 563     if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; ancestor)
 564         scheduleRelayoutForSubtree(*ancestor);
 565 }
 566 
 567 #ifndef NDEBUG
 568 void RenderObject::checkBlockPositionedObjectsNeedLayout()
 569 {
 570     ASSERT(!needsLayout());
 571 
 572     if (is&lt;RenderBlock&gt;(*this))
 573         downcast&lt;RenderBlock&gt;(*this).checkPositionedObjectsNeedLayout();
 574 }
 575 #endif
 576 
 577 void RenderObject::setPreferredLogicalWidthsDirty(bool shouldBeDirty, MarkingBehavior markParents)
 578 {
 579     bool alreadyDirty = preferredLogicalWidthsDirty();
 580     m_bitfields.setPreferredLogicalWidthsDirty(shouldBeDirty);
 581     if (shouldBeDirty &amp;&amp; !alreadyDirty &amp;&amp; markParents == MarkContainingBlockChain &amp;&amp; (isText() || !style().hasOutOfFlowPosition()))
 582         invalidateContainerPreferredLogicalWidths();
 583 }
 584 
 585 void RenderObject::invalidateContainerPreferredLogicalWidths()
 586 {
 587     // In order to avoid pathological behavior when inlines are deeply nested, we do include them
 588     // in the chain that we mark dirty (even though they&#39;re kind of irrelevant).
 589     auto o = isTableCell() ? containingBlock() : container();
 590     while (o &amp;&amp; !o-&gt;preferredLogicalWidthsDirty()) {
 591         // Don&#39;t invalidate the outermost object of an unrooted subtree. That object will be
 592         // invalidated when the subtree is added to the document.
 593         auto container = o-&gt;isTableCell() ? o-&gt;containingBlock() : o-&gt;container();
 594         if (!container &amp;&amp; !o-&gt;isRenderView())
 595             break;
 596 
 597         o-&gt;m_bitfields.setPreferredLogicalWidthsDirty(true);
 598         if (o-&gt;style().hasOutOfFlowPosition())
 599             // A positioned object has no effect on the min/max width of its containing block ever.
 600             // We can optimize this case and not go up any further.
 601             break;
 602         o = container;
 603     }
 604 }
 605 
 606 void RenderObject::setLayerNeedsFullRepaint()
 607 {
 608     ASSERT(hasLayer());
 609     downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;setRepaintStatus(NeedsFullRepaint);
 610 }
 611 
 612 void RenderObject::setLayerNeedsFullRepaintForPositionedMovementLayout()
 613 {
 614     ASSERT(hasLayer());
 615     downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;setRepaintStatus(NeedsFullRepaintForPositionedMovementLayout);
 616 }
 617 
 618 RenderBlock* RenderObject::containingBlock() const
 619 {
 620     auto containingBlockForRenderer = [](const RenderElement&amp; renderer)
 621     {
 622         if (renderer.isAbsolutelyPositioned())
 623             return renderer.containingBlockForAbsolutePosition();
 624         if (renderer.isFixedPositioned())
 625             return renderer.containingBlockForFixedPosition();
 626         return renderer.containingBlockForObjectInFlow();
 627     };
 628 
 629     if (is&lt;RenderText&gt;(*this))
 630         return containingBlockForObjectInFlow();
 631 
 632     if (!parent() &amp;&amp; is&lt;RenderScrollbarPart&gt;(*this)) {
 633         if (auto* scrollbarPart = downcast&lt;RenderScrollbarPart&gt;(*this).rendererOwningScrollbar())
 634             return containingBlockForRenderer(*scrollbarPart);
 635         return nullptr;
 636     }
 637     return containingBlockForRenderer(downcast&lt;RenderElement&gt;(*this));
 638 }
 639 
 640 RenderBlock* RenderObject::containingBlockForObjectInFlow() const
 641 {
 642     auto* renderer = parent();
 643     while (renderer &amp;&amp; ((renderer-&gt;isInline() &amp;&amp; !renderer-&gt;isReplaced()) || !renderer-&gt;isRenderBlock()))
 644         renderer = renderer-&gt;parent();
 645     return downcast&lt;RenderBlock&gt;(renderer);
 646 }
 647 
 648 void RenderObject::addPDFURLRect(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 649 {
 650     Vector&lt;LayoutRect&gt; focusRingRects;
 651     addFocusRingRects(focusRingRects, paintOffset, paintInfo.paintContainer);
 652     LayoutRect urlRect = unionRect(focusRingRects);
 653 
 654     if (urlRect.isEmpty())
 655         return;
 656     Node* node = this-&gt;node();
 657     if (!is&lt;Element&gt;(node) || !node-&gt;isLink())
 658         return;
 659     Element&amp; element = downcast&lt;Element&gt;(*node);
 660     const AtomicString&amp; href = element.getAttribute(hrefAttr);
 661     if (href.isNull())
 662         return;
 663 
 664     if (paintInfo.context().supportsInternalLinks()) {
 665         String outAnchorName;
 666         Element* linkTarget = element.findAnchorElementForLink(outAnchorName);
 667         if (linkTarget) {
 668             paintInfo.context().setDestinationForRect(outAnchorName, urlRect);
 669             return;
 670         }
 671     }
 672 
 673     paintInfo.context().setURLForRect(node-&gt;document().completeURL(href), urlRect);
 674 
 675 }
 676 
 677 #if PLATFORM(IOS_FAMILY)
 678 // This function is similar in spirit to RenderText::absoluteRectsForRange, but returns rectangles
 679 // which are annotated with additional state which helps iOS draw selections in its unique way.
 680 // No annotations are added in this class.
 681 // FIXME: Move to RenderText with absoluteRectsForRange()?
 682 void RenderObject::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned start, unsigned end)
 683 {
 684     Vector&lt;FloatQuad&gt; quads;
 685 
 686     if (!firstChildSlow()) {
 687         // FIXME: WebKit&#39;s position for an empty span after a BR is incorrect, so we can&#39;t trust
 688         // quads for them. We don&#39;t need selection rects for those anyway though, since they
 689         // are just empty containers. See &lt;https://bugs.webkit.org/show_bug.cgi?id=49358&gt;.
 690         RenderObject* previous = previousSibling();
 691         Node* node = this-&gt;node();
 692         if (!previous || !previous-&gt;isBR() || !node || !node-&gt;isContainerNode() || !isInline()) {
 693             // For inline elements we don&#39;t use absoluteQuads, since it takes into account continuations and leads to wrong results.
 694             absoluteQuadsForSelection(quads);
 695         }
 696     } else {
 697         unsigned offset = start;
 698         for (RenderObject* child = childAt(start); child &amp;&amp; offset &lt; end; child = child-&gt;nextSibling(), ++offset)
 699             child-&gt;absoluteQuads(quads);
 700     }
 701 
 702     unsigned numberOfQuads = quads.size();
 703     for (unsigned i = 0; i &lt; numberOfQuads; ++i)
 704         rects.append(SelectionRect(quads[i].enclosingBoundingBox(), isHorizontalWritingMode(), view().pageNumberForBlockProgressionOffset(quads[i].enclosingBoundingBox().x())));
 705 }
 706 #endif
 707 
 708 IntRect RenderObject::absoluteBoundingBoxRect(bool useTransforms, bool* wasFixed) const
 709 {
 710     if (useTransforms) {
 711         Vector&lt;FloatQuad&gt; quads;
 712         absoluteQuads(quads, wasFixed);
 713 
 714         size_t n = quads.size();
 715         if (!n)
 716             return IntRect();
 717 
 718         IntRect result = quads[0].enclosingBoundingBox();
 719         for (size_t i = 1; i &lt; n; ++i)
 720             result.unite(quads[i].enclosingBoundingBox());
 721         return result;
 722     }
 723 
 724     FloatPoint absPos = localToAbsolute(FloatPoint(), 0 /* ignore transforms */, wasFixed);
 725     Vector&lt;IntRect&gt; rects;
 726     absoluteRects(rects, flooredLayoutPoint(absPos));
 727 
 728     size_t n = rects.size();
 729     if (!n)
 730         return IntRect();
 731 
 732     LayoutRect result = rects[0];
 733     for (size_t i = 1; i &lt; n; ++i)
 734         result.unite(rects[i]);
 735     return snappedIntRect(result);
 736 }
 737 
 738 void RenderObject::absoluteFocusRingQuads(Vector&lt;FloatQuad&gt;&amp; quads)
 739 {
 740     Vector&lt;LayoutRect&gt; rects;
 741     // FIXME: addFocusRingRects() needs to be passed this transform-unaware
 742     // localToAbsolute() offset here because RenderInline::addFocusRingRects()
 743     // implicitly assumes that. This doesn&#39;t work correctly with transformed
 744     // descendants.
 745     FloatPoint absolutePoint = localToAbsolute();
 746     addFocusRingRects(rects, flooredLayoutPoint(absolutePoint));
 747     float deviceScaleFactor = document().deviceScaleFactor();
 748     for (auto rect : rects) {
 749         rect.moveBy(LayoutPoint(-absolutePoint));
 750         quads.append(localToAbsoluteQuad(FloatQuad(snapRectToDevicePixels(rect, deviceScaleFactor))));
 751     }
 752 }
 753 
 754 FloatRect RenderObject::absoluteBoundingBoxRectForRange(const Range* range)
 755 {
 756     if (!range)
 757         return FloatRect();
 758 
 759     range-&gt;ownerDocument().updateLayout();
 760 
 761     Vector&lt;FloatQuad&gt; quads;
 762     range-&gt;absoluteTextQuads(quads);
 763 
 764     if (quads.isEmpty())
 765         return FloatRect();
 766 
 767     FloatRect result = quads[0].boundingBox();
 768     for (size_t i = 1; i &lt; quads.size(); ++i)
 769         result.uniteEvenIfEmpty(quads[i].boundingBox());
 770 
 771     return result;
 772 }
 773 
 774 void RenderObject::addAbsoluteRectForLayer(LayoutRect&amp; result)
 775 {
 776     if (hasLayer())
 777         result.unite(absoluteBoundingBoxRectIgnoringTransforms());
 778 
 779     if (!is&lt;RenderElement&gt;(*this))
 780         return;
 781 
 782     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(*this)))
 783         child.addAbsoluteRectForLayer(result);
 784 }
 785 
 786 // FIXME: change this to use the subtreePaint terminology
 787 LayoutRect RenderObject::paintingRootRect(LayoutRect&amp; topLevelRect)
 788 {
 789     LayoutRect result = absoluteBoundingBoxRectIgnoringTransforms();
 790     topLevelRect = result;
 791     if (is&lt;RenderElement&gt;(*this)) {
 792         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(*this)))
 793             child.addAbsoluteRectForLayer(result);
 794     }
 795     return result;
 796 }
 797 
 798 RenderLayerModelObject* RenderObject::containerForRepaint() const
 799 {
 800     RenderLayerModelObject* repaintContainer = nullptr;
 801 
 802     if (view().usesCompositing()) {
 803         if (RenderLayer* parentLayer = enclosingLayer()) {
 804             RenderLayer* compLayer = parentLayer-&gt;enclosingCompositingLayerForRepaint();
 805             if (compLayer)
 806                 repaintContainer = &amp;compLayer-&gt;renderer();
 807         }
 808     }
 809     if (view().hasSoftwareFilters()) {
 810         if (RenderLayer* parentLayer = enclosingLayer()) {
 811             RenderLayer* enclosingFilterLayer = parentLayer-&gt;enclosingFilterLayer();
 812             if (enclosingFilterLayer)
 813                 return &amp;enclosingFilterLayer-&gt;renderer();
 814         }
 815     }
 816 
 817     // If we have a flow thread, then we need to do individual repaints within the RenderFragmentContainers instead.
 818     // Return the flow thread as a repaint container in order to create a chokepoint that allows us to change
 819     // repainting to do individual region repaints.
 820     RenderFragmentedFlow* parentRenderFragmentedFlow = enclosingFragmentedFlow();
 821     if (parentRenderFragmentedFlow) {
 822         // If we have already found a repaint container then we will repaint into that container only if it is part of the same
 823         // flow thread. Otherwise we will need to catch the repaint call and send it to the flow thread.
 824         RenderFragmentedFlow* repaintContainerFragmentedFlow = repaintContainer ? repaintContainer-&gt;enclosingFragmentedFlow() : nullptr;
 825         if (!repaintContainerFragmentedFlow || repaintContainerFragmentedFlow != parentRenderFragmentedFlow)
 826             repaintContainer = parentRenderFragmentedFlow;
 827     }
 828     return repaintContainer;
 829 }
 830 
 831 void RenderObject::propagateRepaintToParentWithOutlineAutoIfNeeded(const RenderLayerModelObject&amp; repaintContainer, const LayoutRect&amp; repaintRect) const
 832 {
 833     if (!hasOutlineAutoAncestor())
 834         return;
 835 
 836     // FIXME: We should really propagate only when the child renderer sticks out.
 837     bool repaintRectNeedsConverting = false;
 838     // Issue repaint on the renderer with outline: auto.
 839     for (const auto* renderer = this; renderer; renderer = renderer-&gt;parent()) {
 840         bool rendererHasOutlineAutoAncestor = renderer-&gt;hasOutlineAutoAncestor();
 841         ASSERT(rendererHasOutlineAutoAncestor
 842             || renderer-&gt;outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On
 843             || (is&lt;RenderBoxModelObject&gt;(*renderer) &amp;&amp; downcast&lt;RenderBoxModelObject&gt;(*renderer).isContinuation()));
 844         if (renderer == &amp;repaintContainer &amp;&amp; rendererHasOutlineAutoAncestor)
 845             repaintRectNeedsConverting = true;
 846         if (rendererHasOutlineAutoAncestor)
 847             continue;
 848         // Issue repaint on the correct repaint container.
 849         LayoutRect adjustedRepaintRect = repaintRect;
 850         adjustedRepaintRect.inflate(renderer-&gt;outlineStyleForRepaint().outlineSize());
 851         if (!repaintRectNeedsConverting)
 852             repaintContainer.repaintRectangle(adjustedRepaintRect);
 853         else if (is&lt;RenderLayerModelObject&gt;(renderer)) {
 854             const auto&amp; rendererWithOutline = downcast&lt;RenderLayerModelObject&gt;(*renderer);
 855             adjustedRepaintRect = LayoutRect(repaintContainer.localToContainerQuad(FloatRect(adjustedRepaintRect), &amp;rendererWithOutline).boundingBox());
 856             rendererWithOutline.repaintRectangle(adjustedRepaintRect);
 857         }
 858         return;
 859     }
 860     ASSERT_NOT_REACHED();
 861 }
 862 
 863 void RenderObject::repaintUsingContainer(const RenderLayerModelObject* repaintContainer, const LayoutRect&amp; r, bool shouldClipToLayer) const
 864 {
 865     if (r.isEmpty())
 866         return;
 867 
 868     if (!repaintContainer)
 869         repaintContainer = &amp;view();
 870 
 871     if (is&lt;RenderFragmentedFlow&gt;(*repaintContainer)) {
 872         downcast&lt;RenderFragmentedFlow&gt;(*repaintContainer).repaintRectangleInFragments(r);
 873         return;
 874     }
 875 
 876     propagateRepaintToParentWithOutlineAutoIfNeeded(*repaintContainer, r);
 877 
 878     if (repaintContainer-&gt;hasFilter() &amp;&amp; repaintContainer-&gt;layer() &amp;&amp; repaintContainer-&gt;layer()-&gt;requiresFullLayerImageForFilters()) {
 879         repaintContainer-&gt;layer()-&gt;setFilterBackendNeedsRepaintingInRect(r);
 880         return;
 881     }
 882 
 883     if (repaintContainer-&gt;isRenderView()) {
 884         RenderView&amp; view = this-&gt;view();
 885         ASSERT(repaintContainer == &amp;view);
 886         bool viewHasCompositedLayer = view.isComposited();
 887         if (!viewHasCompositedLayer || view.layer()-&gt;backing()-&gt;paintsIntoWindow()) {
 888             LayoutRect rect = r;
 889             if (viewHasCompositedLayer &amp;&amp; view.layer()-&gt;transform())
 890                 rect = LayoutRect(view.layer()-&gt;transform()-&gt;mapRect(snapRectToDevicePixels(rect, document().deviceScaleFactor())));
 891             view.repaintViewRectangle(rect);
 892             return;
 893         }
 894     }
 895 
 896     if (view().usesCompositing()) {
 897         ASSERT(repaintContainer-&gt;isComposited());
 898         repaintContainer-&gt;layer()-&gt;setBackingNeedsRepaintInRect(r, shouldClipToLayer ? GraphicsLayer::ClipToLayer : GraphicsLayer::DoNotClipToLayer);
 899     }
 900 }
 901 
 902 void RenderObject::repaint() const
 903 {
 904     // Don&#39;t repaint if we&#39;re unrooted (note that view() still returns the view when unrooted)
 905     if (!isRooted())
 906         return;
 907 
 908     const RenderView&amp; view = this-&gt;view();
 909     if (view.printing())
 910         return;
 911 
 912     RenderLayerModelObject* repaintContainer = containerForRepaint();
 913     repaintUsingContainer(repaintContainer, clippedOverflowRectForRepaint(repaintContainer));
 914 }
 915 
 916 void RenderObject::repaintRectangle(const LayoutRect&amp; r, bool shouldClipToLayer) const
 917 {
 918     // Don&#39;t repaint if we&#39;re unrooted (note that view() still returns the view when unrooted)
 919     if (!isRooted())
 920         return;
 921 
 922     const RenderView&amp; view = this-&gt;view();
 923     if (view.printing())
 924         return;
 925 
 926     LayoutRect dirtyRect(r);
 927     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 928     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 929     dirtyRect.move(view.frameView().layoutContext().layoutDelta());
 930 
 931     RenderLayerModelObject* repaintContainer = containerForRepaint();
 932     repaintUsingContainer(repaintContainer, computeRectForRepaint(dirtyRect, repaintContainer), shouldClipToLayer);
 933 }
 934 
 935 void RenderObject::repaintSlowRepaintObject() const
 936 {
 937     // Don&#39;t repaint if we&#39;re unrooted (note that view() still returns the view when unrooted)
 938     if (!isRooted())
 939         return;
 940 
 941     const RenderView&amp; view = this-&gt;view();
 942     if (view.printing())
 943         return;
 944 
 945     const RenderLayerModelObject* repaintContainer = containerForRepaint();
 946 
 947     bool shouldClipToLayer = true;
 948     IntRect repaintRect;
 949     // If this is the root background, we need to check if there is an extended background rect. If
 950     // there is, then we should not allow painting to clip to the layer size.
 951     if (isDocumentElementRenderer() || isBody()) {
 952         shouldClipToLayer = !view.frameView().hasExtendedBackgroundRectForPainting();
 953         repaintRect = snappedIntRect(view.backgroundRect());
 954     } else
 955         repaintRect = snappedIntRect(clippedOverflowRectForRepaint(repaintContainer));
 956 
 957     repaintUsingContainer(repaintContainer, repaintRect, shouldClipToLayer);
 958 }
 959 
 960 IntRect RenderObject::pixelSnappedAbsoluteClippedOverflowRect() const
 961 {
 962     return snappedIntRect(absoluteClippedOverflowRect());
 963 }
 964 
 965 LayoutRect RenderObject::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
 966 {
 967     LayoutRect r(clippedOverflowRectForRepaint(repaintContainer));
 968     r.inflate(outlineWidth);
 969     return r;
 970 }
 971 
 972 LayoutRect RenderObject::clippedOverflowRectForRepaint(const RenderLayerModelObject*) const
 973 {
 974     ASSERT_NOT_REACHED();
 975     return LayoutRect();
 976 }
 977 
 978 bool RenderObject::shouldApplyCompositedContainerScrollsForRepaint()
 979 {
 980 #if PLATFORM(IOS_FAMILY)
 981     return false;
 982 #else
 983     return true;
 984 #endif
 985 }
 986 
 987 RenderObject::VisibleRectContext RenderObject::visibleRectContextForRepaint()
 988 {
 989     VisibleRectContext context;
 990     if (shouldApplyCompositedContainerScrollsForRepaint())
 991         context.m_options.add(VisibleRectContextOption::ApplyCompositedContainerScrolls);
 992     return context;
 993 }
 994 
 995 LayoutRect RenderObject::computeRectForRepaint(const LayoutRect&amp; rect, const RenderLayerModelObject* repaintContainer) const
 996 {
 997     return *computeVisibleRectInContainer(rect, repaintContainer, visibleRectContextForRepaint());
 998 }
 999 
1000 FloatRect RenderObject::computeFloatRectForRepaint(const FloatRect&amp; rect, const RenderLayerModelObject* repaintContainer) const
1001 {
1002     return *computeFloatVisibleRectInContainer(rect, repaintContainer, visibleRectContextForRepaint());
1003 }
1004 
1005 Optional&lt;LayoutRect&gt; RenderObject::computeVisibleRectInContainer(const LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
1006 {
1007     if (container == this)
1008         return rect;
1009 
1010     auto* parent = this-&gt;parent();
1011     if (!parent)
1012         return rect;
1013 
1014     LayoutRect adjustedRect = rect;
1015     if (parent-&gt;hasOverflowClip()) {
1016         bool isEmpty = !downcast&lt;RenderBox&gt;(*parent).applyCachedClipAndScrollPosition(adjustedRect, container, context);
1017         if (isEmpty) {
1018             if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
1019                 return WTF::nullopt;
1020             return adjustedRect;
1021         }
1022     }
1023     return parent-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
1024 }
1025 
1026 Optional&lt;FloatRect&gt; RenderObject::computeFloatVisibleRectInContainer(const FloatRect&amp;, const RenderLayerModelObject*, VisibleRectContext) const
1027 {
1028     ASSERT_NOT_REACHED();
1029     return FloatRect();
1030 }
1031 
1032 #if ENABLE(TREE_DEBUGGING)
1033 
1034 static void outputRenderTreeLegend(TextStream&amp; stream)
1035 {
1036     stream.nextLine();
1037     stream &lt;&lt; &quot;(B)lock/(I)nline/I(N)line-block, (A)bsolute/Fi(X)ed/(R)elative/Stic(K)y, (F)loating, (O)verflow clip, Anon(Y)mous, (G)enerated, has(L)ayer, (C)omposited, (+)Dirty style, (+)Dirty layout&quot;;
1038     stream.nextLine();
1039 }
1040 
1041 void RenderObject::showNodeTreeForThis() const
1042 {
1043     if (!node())
1044         return;
1045     node()-&gt;showTreeForThis();
1046 }
1047 
1048 void RenderObject::showRenderTreeForThis() const
1049 {
1050     const WebCore::RenderObject* root = this;
1051     while (root-&gt;parent())
1052         root = root-&gt;parent();
1053     TextStream stream(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
1054     outputRenderTreeLegend(stream);
1055     root-&gt;outputRenderSubTreeAndMark(stream, this, 1);
1056     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
1057 }
1058 
1059 void RenderObject::showLineTreeForThis() const
1060 {
1061     if (!is&lt;RenderBlockFlow&gt;(*this))
1062         return;
1063     TextStream stream(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
1064     outputRenderTreeLegend(stream);
1065     outputRenderObject(stream, false, 1);
1066     downcast&lt;RenderBlockFlow&gt;(*this).outputLineTreeAndMark(stream, nullptr, 2);
1067     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
1068 }
1069 
1070 static const RenderFragmentedFlow* enclosingFragmentedFlowFromRenderer(const RenderObject* renderer)
1071 {
1072     if (!renderer)
1073         return nullptr;
1074 
1075     if (renderer-&gt;fragmentedFlowState() == RenderObject::NotInsideFragmentedFlow)
1076         return nullptr;
1077 
1078     if (is&lt;RenderFragmentedFlow&gt;(*renderer))
1079         return downcast&lt;RenderFragmentedFlow&gt;(renderer);
1080 
1081     if (is&lt;RenderBlock&gt;(*renderer))
1082         return downcast&lt;RenderBlock&gt;(*renderer).cachedEnclosingFragmentedFlow();
1083 
1084     return nullptr;
1085 }
1086 
1087 void RenderObject::outputRegionsInformation(TextStream&amp; stream) const
1088 {
1089     const RenderFragmentedFlow* ftcb = enclosingFragmentedFlowFromRenderer(this);
1090 
1091     if (!ftcb) {
1092         // Only the boxes have region range information.
1093         // Try to get the flow thread containing block information
1094         // from the containing block of this box.
1095         if (is&lt;RenderBox&gt;(*this))
1096             ftcb = enclosingFragmentedFlowFromRenderer(containingBlock());
1097     }
1098 
1099     if (!ftcb)
1100         return;
1101 
1102     RenderFragmentContainer* startRegion = nullptr;
1103     RenderFragmentContainer* endRegion = nullptr;
1104     ftcb-&gt;getFragmentRangeForBox(downcast&lt;RenderBox&gt;(this), startRegion, endRegion);
1105     stream &lt;&lt; &quot; [Rs:&quot; &lt;&lt; startRegion &lt;&lt; &quot; Re:&quot; &lt;&lt; endRegion &lt;&lt; &quot;]&quot;;
1106 }
1107 
1108 void RenderObject::outputRenderObject(TextStream&amp; stream, bool mark, int depth) const
1109 {
1110     if (isInlineBlockOrInlineTable())
1111         stream &lt;&lt; &quot;N&quot;;
1112     else if (isInline())
1113         stream &lt;&lt; &quot;I&quot;;
1114     else
1115         stream &lt;&lt; &quot;B&quot;;
1116 
1117     if (isPositioned()) {
1118         if (isRelativelyPositioned())
1119             stream &lt;&lt; &quot;R&quot;;
1120         else if (isStickilyPositioned())
1121             stream &lt;&lt; &quot;K&quot;;
1122         else if (isOutOfFlowPositioned()) {
1123             if (isAbsolutelyPositioned())
1124                 stream &lt;&lt; &quot;A&quot;;
1125             else
1126                 stream &lt;&lt; &quot;X&quot;;
1127         }
1128     } else
1129         stream &lt;&lt; &quot;-&quot;;
1130 
1131     if (isFloating())
1132         stream &lt;&lt; &quot;F&quot;;
1133     else
1134         stream &lt;&lt; &quot;-&quot;;
1135 
1136     if (hasOverflowClip())
1137         stream &lt;&lt; &quot;O&quot;;
1138     else
1139         stream &lt;&lt; &quot;-&quot;;
1140 
1141     if (isAnonymous())
1142         stream &lt;&lt; &quot;Y&quot;;
1143     else
1144         stream &lt;&lt; &quot;-&quot;;
1145 
1146     if (isPseudoElement() || isAnonymous())
1147         stream &lt;&lt; &quot;G&quot;;
1148     else
1149         stream &lt;&lt; &quot;-&quot;;
1150 
1151     if (hasLayer())
1152         stream &lt;&lt; &quot;L&quot;;
1153     else
1154         stream &lt;&lt; &quot;-&quot;;
1155 
1156     if (isComposited())
1157         stream &lt;&lt; &quot;C&quot;;
1158     else
1159         stream &lt;&lt; &quot;-&quot;;
1160 
1161     stream &lt;&lt; &quot; &quot;;
1162 
1163     if (node() &amp;&amp; node()-&gt;needsStyleRecalc())
1164         stream &lt;&lt; &quot;+&quot;;
1165     else
1166         stream &lt;&lt; &quot;-&quot;;
1167 
1168     if (needsLayout())
1169         stream &lt;&lt; &quot;+&quot;;
1170     else
1171         stream &lt;&lt; &quot;-&quot;;
1172 
1173     int printedCharacters = 0;
1174     if (mark) {
1175         stream &lt;&lt; &quot;*&quot;;
1176         ++printedCharacters;
1177     }
1178 
1179     while (++printedCharacters &lt;= depth * 2)
1180         stream &lt;&lt; &quot; &quot;;
1181 
1182     if (node())
1183         stream &lt;&lt; node()-&gt;nodeName().utf8().data() &lt;&lt; &quot; &quot;;
1184 
1185     String name = renderName();
1186     // FIXME: Renderer&#39;s name should not include property value listing.
1187     int pos = name.find(&#39;(&#39;);
1188     if (pos &gt; 0)
1189         stream &lt;&lt; name.left(pos - 1).utf8().data();
1190     else
1191         stream &lt;&lt; name.utf8().data();
1192 
1193     if (is&lt;RenderBox&gt;(*this)) {
1194         auto&amp; renderBox = downcast&lt;RenderBox&gt;(*this);
1195         FloatRect boxRect = renderBox.frameRect();
1196         if (renderBox.isInFlowPositioned())
1197             boxRect.move(renderBox.offsetForInFlowPosition());
1198         stream &lt;&lt; &quot; &quot; &lt;&lt; boxRect;
1199     } else if (is&lt;RenderInline&gt;(*this) &amp;&amp; isInFlowPositioned()) {
1200         FloatSize inlineOffset = downcast&lt;RenderInline&gt;(*this).offsetForInFlowPosition();
1201         stream &lt;&lt; &quot;  (&quot; &lt;&lt; inlineOffset.width() &lt;&lt; &quot;, &quot; &lt;&lt; inlineOffset.height() &lt;&lt; &quot;)&quot;;
1202     }
1203 
1204     stream &lt;&lt; &quot; renderer-&gt;(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot;;
1205     if (node()) {
1206         stream &lt;&lt; &quot; node-&gt;(&quot; &lt;&lt; node() &lt;&lt; &quot;)&quot;;
1207         if (node()-&gt;isTextNode()) {
1208             String value = node()-&gt;nodeValue();
1209             stream &lt;&lt; &quot; length-&gt;(&quot; &lt;&lt; value.length() &lt;&lt; &quot;)&quot;;
1210 
1211             value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1212             value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1213 
1214             const int maxPrintedLength = 80;
1215             if (value.length() &gt; maxPrintedLength) {
1216                 String substring = value.substring(0, maxPrintedLength);
1217                 stream &lt;&lt; &quot; \&quot;&quot; &lt;&lt; substring.utf8().data() &lt;&lt; &quot;\&quot;...&quot;;
1218             } else
1219                 stream &lt;&lt; &quot; \&quot;&quot; &lt;&lt; value.utf8().data() &lt;&lt; &quot;\&quot;&quot;;
1220         }
1221     }
1222     if (is&lt;RenderBoxModelObject&gt;(*this)) {
1223         auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(*this);
1224         if (renderer.continuation())
1225             stream &lt;&lt; &quot; continuation-&gt;(&quot; &lt;&lt; renderer.continuation() &lt;&lt; &quot;)&quot;;
1226     }
1227     outputRegionsInformation(stream);
1228     if (needsLayout()) {
1229         stream &lt;&lt; &quot; layout-&gt;&quot;;
1230         if (selfNeedsLayout())
1231             stream &lt;&lt; &quot;[self]&quot;;
1232         if (normalChildNeedsLayout())
1233             stream &lt;&lt; &quot;[normal child]&quot;;
1234         if (posChildNeedsLayout())
1235             stream &lt;&lt; &quot;[positioned child]&quot;;
1236         if (needsSimplifiedNormalFlowLayout())
1237             stream &lt;&lt; &quot;[simplified]&quot;;
1238         if (needsPositionedMovementLayout())
1239             stream &lt;&lt; &quot;[positioned movement]&quot;;
1240     }
1241     stream.nextLine();
1242 }
1243 
1244 void RenderObject::outputRenderSubTreeAndMark(TextStream&amp; stream, const RenderObject* markedObject, int depth) const
1245 {
1246     outputRenderObject(stream, markedObject == this, depth);
1247     if (is&lt;RenderBlockFlow&gt;(*this))
1248         downcast&lt;RenderBlockFlow&gt;(*this).outputLineTreeAndMark(stream, nullptr, depth + 1);
1249 
1250     for (auto* child = firstChildSlow(); child; child = child-&gt;nextSibling())
1251         child-&gt;outputRenderSubTreeAndMark(stream, markedObject, depth + 1);
1252 }
1253 
1254 #endif // NDEBUG
1255 
1256 FloatPoint RenderObject::localToAbsolute(const FloatPoint&amp; localPoint, MapCoordinatesFlags mode, bool* wasFixed) const
1257 {
1258     TransformState transformState(TransformState::ApplyTransformDirection, localPoint);
1259     mapLocalToContainer(nullptr, transformState, mode | ApplyContainerFlip, wasFixed);
1260     transformState.flatten();
1261 
1262     return transformState.lastPlanarPoint();
1263 }
1264 
1265 FloatPoint RenderObject::absoluteToLocal(const FloatPoint&amp; containerPoint, MapCoordinatesFlags mode) const
1266 {
1267     TransformState transformState(TransformState::UnapplyInverseTransformDirection, containerPoint);
1268     mapAbsoluteToLocalPoint(mode, transformState);
1269     transformState.flatten();
1270 
1271     return transformState.lastPlanarPoint();
1272 }
1273 
1274 FloatQuad RenderObject::absoluteToLocalQuad(const FloatQuad&amp; quad, MapCoordinatesFlags mode) const
1275 {
1276     TransformState transformState(TransformState::UnapplyInverseTransformDirection, quad.boundingBox().center(), quad);
1277     mapAbsoluteToLocalPoint(mode, transformState);
1278     transformState.flatten();
1279     return transformState.lastPlanarQuad();
1280 }
1281 
1282 void RenderObject::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
1283 {
1284     if (repaintContainer == this)
1285         return;
1286 
1287     auto* parent = this-&gt;parent();
1288     if (!parent)
1289         return;
1290 
1291     // FIXME: this should call offsetFromContainer to share code, but I&#39;m not sure it&#39;s ever called.
1292     LayoutPoint centerPoint(transformState.mappedPoint());
1293     if (mode &amp; ApplyContainerFlip &amp;&amp; is&lt;RenderBox&gt;(*parent)) {
1294         if (parent-&gt;style().isFlippedBlocksWritingMode())
1295             transformState.move(downcast&lt;RenderBox&gt;(parent)-&gt;flipForWritingMode(LayoutPoint(transformState.mappedPoint())) - centerPoint);
1296         mode &amp;= ~ApplyContainerFlip;
1297     }
1298 
1299     if (is&lt;RenderBox&gt;(*parent))
1300         transformState.move(-toLayoutSize(downcast&lt;RenderBox&gt;(*parent).scrollPosition()));
1301 
1302     parent-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
1303 }
1304 
1305 const RenderObject* RenderObject::pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp; geometryMap) const
1306 {
1307     ASSERT_UNUSED(ancestorToStopAt, ancestorToStopAt != this);
1308 
1309     auto* container = parent();
1310     if (!container)
1311         return nullptr;
1312 
1313     // FIXME: this should call offsetFromContainer to share code, but I&#39;m not sure it&#39;s ever called.
1314     LayoutSize offset;
1315     if (is&lt;RenderBox&gt;(*container))
1316         offset = -toLayoutSize(downcast&lt;RenderBox&gt;(*container).scrollPosition());
1317 
1318     geometryMap.push(this, offset, false);
1319 
1320     return container;
1321 }
1322 
1323 void RenderObject::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
1324 {
1325     if (auto* parent = this-&gt;parent()) {
1326         parent-&gt;mapAbsoluteToLocalPoint(mode, transformState);
1327         if (is&lt;RenderBox&gt;(*parent))
1328             transformState.move(toLayoutSize(downcast&lt;RenderBox&gt;(*parent).scrollPosition()));
1329     }
1330 }
1331 
1332 bool RenderObject::shouldUseTransformFromContainer(const RenderObject* containerObject) const
1333 {
1334 #if ENABLE(3D_TRANSFORMS)
1335     return hasTransform() || (containerObject &amp;&amp; containerObject-&gt;style().hasPerspective());
1336 #else
1337     UNUSED_PARAM(containerObject);
1338     return hasTransform();
1339 #endif
1340 }
1341 
1342 void RenderObject::getTransformFromContainer(const RenderObject* containerObject, const LayoutSize&amp; offsetInContainer, TransformationMatrix&amp; transform) const
1343 {
1344     transform.makeIdentity();
1345     transform.translate(offsetInContainer.width(), offsetInContainer.height());
1346     RenderLayer* layer;
1347     if (hasLayer() &amp;&amp; (layer = downcast&lt;RenderLayerModelObject&gt;(*this).layer()) &amp;&amp; layer-&gt;transform())
1348         transform.multiply(layer-&gt;currentTransform());
1349 
1350 #if ENABLE(3D_TRANSFORMS)
1351     if (containerObject &amp;&amp; containerObject-&gt;hasLayer() &amp;&amp; containerObject-&gt;style().hasPerspective()) {
1352         // Perpsective on the container affects us, so we have to factor it in here.
1353         ASSERT(containerObject-&gt;hasLayer());
1354         FloatPoint perspectiveOrigin = downcast&lt;RenderLayerModelObject&gt;(*containerObject).layer()-&gt;perspectiveOrigin();
1355 
1356         TransformationMatrix perspectiveMatrix;
1357         perspectiveMatrix.applyPerspective(containerObject-&gt;style().perspective());
1358 
1359         transform.translateRight3d(-perspectiveOrigin.x(), -perspectiveOrigin.y(), 0);
1360         transform = perspectiveMatrix * transform;
1361         transform.translateRight3d(perspectiveOrigin.x(), perspectiveOrigin.y(), 0);
1362     }
1363 #else
1364     UNUSED_PARAM(containerObject);
1365 #endif
1366 }
1367 
1368 FloatQuad RenderObject::localToContainerQuad(const FloatQuad&amp; localQuad, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags mode, bool* wasFixed) const
1369 {
1370     // Track the point at the center of the quad&#39;s bounding box. As mapLocalToContainer() calls offsetFromContainer(),
1371     // it will use that point as the reference point to decide which column&#39;s transform to apply in multiple-column blocks.
1372     TransformState transformState(TransformState::ApplyTransformDirection, localQuad.boundingBox().center(), localQuad);
1373     mapLocalToContainer(repaintContainer, transformState, mode | ApplyContainerFlip, wasFixed);
1374     transformState.flatten();
1375 
1376     return transformState.lastPlanarQuad();
1377 }
1378 
1379 FloatPoint RenderObject::localToContainerPoint(const FloatPoint&amp; localPoint, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags mode, bool* wasFixed) const
1380 {
1381     TransformState transformState(TransformState::ApplyTransformDirection, localPoint);
1382     mapLocalToContainer(repaintContainer, transformState, mode | ApplyContainerFlip, wasFixed);
1383     transformState.flatten();
1384 
1385     return transformState.lastPlanarPoint();
1386 }
1387 
1388 LayoutSize RenderObject::offsetFromContainer(RenderElement&amp; container, const LayoutPoint&amp;, bool* offsetDependsOnPoint) const
1389 {
1390     ASSERT(&amp;container == this-&gt;container());
1391 
1392     LayoutSize offset;
1393     if (is&lt;RenderBox&gt;(container))
1394         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
1395 
1396     if (offsetDependsOnPoint)
1397         *offsetDependsOnPoint = is&lt;RenderFragmentedFlow&gt;(container);
1398 
1399     return offset;
1400 }
1401 
1402 LayoutSize RenderObject::offsetFromAncestorContainer(RenderElement&amp; container) const
1403 {
1404     LayoutSize offset;
1405     LayoutPoint referencePoint;
1406     const RenderObject* currContainer = this;
1407     do {
1408         RenderElement* nextContainer = currContainer-&gt;container();
1409         ASSERT(nextContainer);  // This means we reached the top without finding container.
1410         if (!nextContainer)
1411             break;
1412         ASSERT(!currContainer-&gt;hasTransform());
1413         LayoutSize currentOffset = currContainer-&gt;offsetFromContainer(*nextContainer, referencePoint);
1414         offset += currentOffset;
1415         referencePoint.move(currentOffset);
1416         currContainer = nextContainer;
1417     } while (currContainer != &amp;container);
1418 
1419     return offset;
1420 }
1421 
1422 LayoutRect RenderObject::localCaretRect(InlineBox*, unsigned, LayoutUnit* extraWidthToEndOfLine)
1423 {
1424     if (extraWidthToEndOfLine)
1425         *extraWidthToEndOfLine = 0;
1426 
1427     return LayoutRect();
1428 }
1429 
1430 bool RenderObject::isRooted() const
1431 {
1432     return isDescendantOf(&amp;view());
1433 }
1434 
1435 static inline RenderElement* containerForElement(const RenderObject&amp; renderer, const RenderLayerModelObject* repaintContainer, bool* repaintContainerSkipped)
1436 {
1437     // This method is extremely similar to containingBlock(), but with a few notable
1438     // exceptions.
1439     // (1) For normal flow elements, it just returns the parent.
1440     // (2) For absolute positioned elements, it will return a relative positioned inline, while
1441     // containingBlock() skips to the non-anonymous containing block.
1442     // This does mean that computePositionedLogicalWidth and computePositionedLogicalHeight have to use container().
1443     auto pos = renderer.style().position();
1444     auto* parent = renderer.parent();
1445     if (is&lt;RenderText&gt;(renderer) || (pos != PositionType::Fixed &amp;&amp; pos != PositionType::Absolute))
1446         return parent;
1447     for (; parent &amp;&amp; (pos == PositionType::Absolute ? !parent-&gt;canContainAbsolutelyPositionedObjects() : !parent-&gt;canContainFixedPositionObjects()); parent = parent-&gt;parent()) {
1448         if (repaintContainerSkipped &amp;&amp; repaintContainer == parent)
1449             *repaintContainerSkipped = true;
1450     }
1451     return parent;
1452 }
1453 
1454 RenderElement* RenderObject::container() const
1455 {
1456     return containerForElement(*this, nullptr, nullptr);
1457 }
1458 
1459 RenderElement* RenderObject::container(const RenderLayerModelObject* repaintContainer, bool&amp; repaintContainerSkipped) const
1460 {
1461     repaintContainerSkipped = false;
1462     return containerForElement(*this, repaintContainer, &amp;repaintContainerSkipped);
1463 }
1464 
1465 bool RenderObject::isSelectionBorder() const
1466 {
1467     SelectionState st = selectionState();
1468     return st == SelectionStart
1469         || st == SelectionEnd
1470         || st == SelectionBoth
1471         || view().selection().start() == this
1472         || view().selection().end() == this;
1473 }
1474 
1475 void RenderObject::willBeDestroyed()
1476 {
1477     ASSERT(!m_parent);
1478     ASSERT(renderTreeBeingDestroyed() || !is&lt;RenderElement&gt;(*this) || !view().frameView().hasSlowRepaintObject(downcast&lt;RenderElement&gt;(*this)));
1479 
1480     if (AXObjectCache* cache = document().existingAXObjectCache())
1481         cache-&gt;remove(this);
1482 
1483     if (auto* node = this-&gt;node()) {
1484         // FIXME: Continuations should be anonymous.
1485         ASSERT(!node-&gt;renderer() || node-&gt;renderer() == this || (is&lt;RenderElement&gt;(*this) &amp;&amp; downcast&lt;RenderElement&gt;(*this).isContinuation()));
1486         if (node-&gt;renderer() == this)
1487             node-&gt;setRenderer(nullptr);
1488     }
1489 
1490     removeRareData();
1491 }
1492 
1493 void RenderObject::insertedIntoTree()
1494 {
1495     // FIXME: We should ASSERT(isRooted()) here but generated content makes some out-of-order insertion.
1496     if (!isFloating() &amp;&amp; parent()-&gt;childrenInline())
1497         parent()-&gt;dirtyLinesFromChangedChild(*this);
1498 }
1499 
1500 void RenderObject::willBeRemovedFromTree()
1501 {
1502     // FIXME: We should ASSERT(isRooted()) but we have some out-of-order removals which would need to be fixed first.
1503     // Update cached boundaries in SVG renderers, if a child is removed.
1504     parent()-&gt;setNeedsBoundariesUpdate();
1505 }
1506 
1507 void RenderObject::destroy()
1508 {
1509     RELEASE_ASSERT(!m_parent);
1510     RELEASE_ASSERT(!m_next);
1511     RELEASE_ASSERT(!m_previous);
1512     RELEASE_ASSERT(!m_bitfields.beingDestroyed());
1513 
1514     m_bitfields.setBeingDestroyed(true);
1515 
1516 #if PLATFORM(IOS_FAMILY)
1517     if (hasLayer())
1518         downcast&lt;RenderBoxModelObject&gt;(*this).layer()-&gt;willBeDestroyed();
1519 #endif
1520 
1521     willBeDestroyed();
1522 
1523     if (is&lt;RenderWidget&gt;(*this)) {
1524         downcast&lt;RenderWidget&gt;(*this).deref();
1525         return;
1526     }
1527     delete this;
1528 }
1529 
1530 bool RenderObject::isTransparentOrFullyClippedRespectingParentFrames() const
1531 {
1532     static const double minimumVisibleOpacity = 0.01;
1533 
1534     float currentOpacity = 1;
1535     auto* layer = enclosingLayer();
1536     while (layer) {
1537         auto&amp; layerRenderer = layer-&gt;renderer();
1538         auto&amp; style = layerRenderer.style();
1539         if (auto* box = layer-&gt;renderBox()) {
1540             bool isOverflowHidden = style.overflowX() == Overflow::Hidden || style.overflowY() == Overflow::Hidden;
1541             if (isOverflowHidden &amp;&amp; !box-&gt;isDocumentElementRenderer() &amp;&amp; box-&gt;contentSize().isEmpty())
1542                 return true;
1543         }
1544         currentOpacity *= style.opacity();
1545         if (currentOpacity &lt; minimumVisibleOpacity)
1546             return true;
1547 
1548         auto* parentLayer = layer-&gt;parent();
1549         if (!parentLayer) {
1550             if (!is&lt;RenderView&gt;(layerRenderer))
1551                 return false;
1552 
1553             auto&amp; enclosingFrame = downcast&lt;RenderView&gt;(layerRenderer).view().frame();
1554             if (enclosingFrame.isMainFrame())
1555                 return false;
1556 
1557             if (auto *frameOwnerRenderer = enclosingFrame.ownerElement()-&gt;renderer())
1558                 parentLayer = frameOwnerRenderer-&gt;enclosingLayer();
1559         }
1560         layer = parentLayer;
1561     }
1562     return false;
1563 }
1564 
1565 Position RenderObject::positionForPoint(const LayoutPoint&amp; point)
1566 {
1567     // FIXME: This should just create a Position object instead (webkit.org/b/168566).
1568     return positionForPoint(point, nullptr).deepEquivalent();
1569 }
1570 
1571 VisiblePosition RenderObject::positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*)
1572 {
1573     return createVisiblePosition(caretMinOffset(), DOWNSTREAM);
1574 }
1575 
1576 void RenderObject::updateDragState(bool dragOn)
1577 {
1578     bool valueChanged = (dragOn != isDragging());
1579     setIsDragging(dragOn);
1580 
1581     if (!is&lt;RenderElement&gt;(*this))
1582         return;
1583     auto&amp; renderElement = downcast&lt;RenderElement&gt;(*this);
1584 
1585     if (valueChanged &amp;&amp; renderElement.element() &amp;&amp; (style().affectedByDrag() || renderElement.element()-&gt;childrenAffectedByDrag()))
1586         renderElement.element()-&gt;invalidateStyleForSubtree();
1587 
1588     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderElement))
1589         child.updateDragState(dragOn);
1590 }
1591 
1592 bool RenderObject::isComposited() const
1593 {
1594     return hasLayer() &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited();
1595 }
1596 
1597 bool RenderObject::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestFilter hitTestFilter)
1598 {
1599     bool inside = false;
1600     if (hitTestFilter != HitTestSelf) {
1601         // First test the foreground layer (lines and inlines).
1602         inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestForeground);
1603 
1604         // Test floats next.
1605         if (!inside)
1606             inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestFloat);
1607 
1608         // Finally test to see if the mouse is in the background (within a child block&#39;s background).
1609         if (!inside)
1610             inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestChildBlockBackgrounds);
1611     }
1612 
1613     // See if the mouse is inside us but not any of our descendants
1614     if (hitTestFilter != HitTestDescendants &amp;&amp; !inside)
1615         inside = nodeAtPoint(request, result, locationInContainer, accumulatedOffset, HitTestBlockBackground);
1616 
1617     return inside;
1618 }
1619 
1620 void RenderObject::updateHitTestResult(HitTestResult&amp; result, const LayoutPoint&amp; point)
1621 {
1622     if (result.innerNode())
1623         return;
1624 
1625     Node* node = this-&gt;node();
1626 
1627     // If we hit the anonymous renderers inside generated content we should
1628     // actually hit the generated content so walk up to the PseudoElement.
1629     if (!node &amp;&amp; parent() &amp;&amp; parent()-&gt;isBeforeOrAfterContent()) {
1630         for (auto* renderer = parent(); renderer &amp;&amp; !node; renderer = renderer-&gt;parent())
1631             node = renderer-&gt;element();
1632     }
1633 
1634     if (node) {
1635         result.setInnerNode(node);
1636         if (!result.innerNonSharedNode())
1637             result.setInnerNonSharedNode(node);
1638         result.setLocalPoint(point);
1639     }
1640 }
1641 
1642 bool RenderObject::nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; /*locationInContainer*/, const LayoutPoint&amp; /*accumulatedOffset*/, HitTestAction)
1643 {
1644     return false;
1645 }
1646 
1647 int RenderObject::innerLineHeight() const
1648 {
1649     return style().computedLineHeight();
1650 }
1651 
1652 #if ENABLE(DASHBOARD_SUPPORT)
1653 void RenderObject::addAnnotatedRegions(Vector&lt;AnnotatedRegionValue&gt;&amp; regions)
1654 {
1655     // Convert the style regions to absolute coordinates.
1656     if (style().visibility() != Visibility::Visible || !is&lt;RenderBox&gt;(*this))
1657         return;
1658 
1659     auto&amp; box = downcast&lt;RenderBox&gt;(*this);
1660     FloatPoint absPos = localToAbsolute();
1661 
1662     const Vector&lt;StyleDashboardRegion&gt;&amp; styleRegions = style().dashboardRegions();
1663     for (const auto&amp; styleRegion : styleRegions) {
1664         LayoutUnit w = box.width();
1665         LayoutUnit h = box.height();
1666 
1667         AnnotatedRegionValue region;
1668         region.label = styleRegion.label;
1669         region.bounds = LayoutRect(styleRegion.offset.left().value(),
1670                                    styleRegion.offset.top().value(),
1671                                    w - styleRegion.offset.left().value() - styleRegion.offset.right().value(),
1672                                    h - styleRegion.offset.top().value() - styleRegion.offset.bottom().value());
1673         region.type = styleRegion.type;
1674 
1675         region.clip = computeAbsoluteRepaintRect(region.bounds);
1676         if (region.clip.height() &lt; 0) {
1677             region.clip.setHeight(0);
1678             region.clip.setWidth(0);
1679         }
1680 
1681         region.bounds.setX(absPos.x() + styleRegion.offset.left().value());
1682         region.bounds.setY(absPos.y() + styleRegion.offset.top().value());
1683 
1684         regions.append(region);
1685     }
1686 }
1687 
1688 void RenderObject::collectAnnotatedRegions(Vector&lt;AnnotatedRegionValue&gt;&amp; regions)
1689 {
1690     // RenderTexts don&#39;t have their own style, they just use their parent&#39;s style,
1691     // so we don&#39;t want to include them.
1692     if (is&lt;RenderText&gt;(*this))
1693         return;
1694 
1695     addAnnotatedRegions(regions);
1696     for (RenderObject* current = downcast&lt;RenderElement&gt;(*this).firstChild(); current; current = current-&gt;nextSibling())
1697         current-&gt;collectAnnotatedRegions(regions);
1698 }
1699 #endif
1700 
1701 int RenderObject::caretMinOffset() const
1702 {
1703     return 0;
1704 }
1705 
1706 int RenderObject::caretMaxOffset() const
1707 {
1708     if (isReplaced())
1709         return node() ? std::max(1U, node()-&gt;countChildNodes()) : 1;
1710     if (isHR())
1711         return 1;
1712     return 0;
1713 }
1714 
1715 int RenderObject::previousOffset(int current) const
1716 {
1717     return current - 1;
1718 }
1719 
1720 int RenderObject::previousOffsetForBackwardDeletion(int current) const
1721 {
1722     return current - 1;
1723 }
1724 
1725 int RenderObject::nextOffset(int current) const
1726 {
1727     return current + 1;
1728 }
1729 
1730 void RenderObject::adjustRectForOutlineAndShadow(LayoutRect&amp; rect) const
1731 {
1732     LayoutUnit outlineSize = outlineStyleForRepaint().outlineSize();
1733     if (const ShadowData* boxShadow = style().boxShadow()) {
1734         boxShadow-&gt;adjustRectForShadow(rect, outlineSize);
1735         return;
1736     }
1737     rect.inflate(outlineSize);
1738 }
1739 
1740 void RenderObject::imageChanged(CachedImage* image, const IntRect* rect)
1741 {
1742     imageChanged(static_cast&lt;WrappedImagePtr&gt;(image), rect);
1743 }
1744 
1745 RenderBoxModelObject* RenderObject::offsetParent() const
1746 {
1747     // If any of the following holds true return null and stop this algorithm:
1748     // A is the root element.
1749     // A is the HTML body element.
1750     // The computed value of the position property for element A is fixed.
1751     if (isDocumentElementRenderer() || isBody() || isFixedPositioned())
1752         return nullptr;
1753 
1754     // If A is an area HTML element which has a map HTML element somewhere in the ancestor
1755     // chain return the nearest ancestor map HTML element and stop this algorithm.
1756     // FIXME: Implement!
1757 
1758     // Return the nearest ancestor element of A for which at least one of the following is
1759     // true and stop this algorithm if such an ancestor is found:
1760     //     * The computed value of the position property is not static.
1761     //     * It is the HTML body element.
1762     //     * The computed value of the position property of A is static and the ancestor
1763     //       is one of the following HTML elements: td, th, or table.
1764     //     * Our own extension: if there is a difference in the effective zoom
1765 
1766     bool skipTables = isPositioned();
1767     float currZoom = style().effectiveZoom();
1768     auto current = parent();
1769     while (current &amp;&amp; (!current-&gt;element() || (!current-&gt;isPositioned() &amp;&amp; !current-&gt;isBody()))) {
1770         Element* element = current-&gt;element();
1771         if (!skipTables &amp;&amp; element &amp;&amp; (is&lt;HTMLTableElement&gt;(*element) || is&lt;HTMLTableCellElement&gt;(*element)))
1772             break;
1773 
1774         float newZoom = current-&gt;style().effectiveZoom();
1775         if (currZoom != newZoom)
1776             break;
1777         currZoom = newZoom;
1778         current = current-&gt;parent();
1779     }
1780 
1781     return is&lt;RenderBoxModelObject&gt;(current) ? downcast&lt;RenderBoxModelObject&gt;(current) : nullptr;
1782 }
1783 
1784 VisiblePosition RenderObject::createVisiblePosition(int offset, EAffinity affinity) const
1785 {
1786     // If this is a non-anonymous renderer in an editable area, then it&#39;s simple.
1787     if (Node* node = nonPseudoNode()) {
1788         if (!node-&gt;hasEditableStyle()) {
1789             // If it can be found, we prefer a visually equivalent position that is editable.
1790             Position position = createLegacyEditingPosition(node, offset);
1791             Position candidate = position.downstream(CanCrossEditingBoundary);
1792             if (candidate.deprecatedNode()-&gt;hasEditableStyle())
1793                 return VisiblePosition(candidate, affinity);
1794             candidate = position.upstream(CanCrossEditingBoundary);
1795             if (candidate.deprecatedNode()-&gt;hasEditableStyle())
1796                 return VisiblePosition(candidate, affinity);
1797         }
1798         // FIXME: Eliminate legacy editing positions
1799         return VisiblePosition(createLegacyEditingPosition(node, offset), affinity);
1800     }
1801 
1802     // We don&#39;t want to cross the boundary between editable and non-editable
1803     // regions of the document, but that is either impossible or at least
1804     // extremely unlikely in any normal case because we stop as soon as we
1805     // find a single non-anonymous renderer.
1806 
1807     // Find a nearby non-anonymous renderer.
1808     const RenderObject* child = this;
1809     while (const auto parent = child-&gt;parent()) {
1810         // Find non-anonymous content after.
1811         const RenderObject* renderer = child;
1812         while ((renderer = renderer-&gt;nextInPreOrder(parent))) {
1813             if (Node* node = renderer-&gt;nonPseudoNode())
1814                 return VisiblePosition(firstPositionInOrBeforeNode(node), DOWNSTREAM);
1815         }
1816 
1817         // Find non-anonymous content before.
1818         renderer = child;
1819         while ((renderer = renderer-&gt;previousInPreOrder())) {
1820             if (renderer == parent)
1821                 break;
1822             if (Node* node = renderer-&gt;nonPseudoNode())
1823                 return VisiblePosition(lastPositionInOrAfterNode(node), DOWNSTREAM);
1824         }
1825 
1826         // Use the parent itself unless it too is anonymous.
1827         if (Element* element = parent-&gt;nonPseudoElement())
1828             return VisiblePosition(firstPositionInOrBeforeNode(element), DOWNSTREAM);
1829 
1830         // Repeat at the next level up.
1831         child = parent;
1832     }
1833 
1834     // Everything was anonymous. Give up.
1835     return VisiblePosition();
1836 }
1837 
1838 VisiblePosition RenderObject::createVisiblePosition(const Position&amp; position) const
1839 {
1840     if (position.isNotNull())
1841         return VisiblePosition(position);
1842 
1843     ASSERT(!node());
1844     return createVisiblePosition(0, DOWNSTREAM);
1845 }
1846 
1847 CursorDirective RenderObject::getCursor(const LayoutPoint&amp;, Cursor&amp;) const
1848 {
1849     return SetCursorBasedOnStyle;
1850 }
1851 
1852 bool RenderObject::useDarkAppearance() const
1853 {
1854     return document().useDarkAppearance(&amp;style());
1855 }
1856 
1857 OptionSet&lt;StyleColor::Options&gt; RenderObject::styleColorOptions() const
1858 {
1859     return document().styleColorOptions(&amp;style());
1860 }
1861 
1862 bool RenderObject::canUpdateSelectionOnRootLineBoxes()
1863 {
1864     if (needsLayout())
1865         return false;
1866 
1867     RenderBlock* containingBlock = this-&gt;containingBlock();
1868     return containingBlock ? !containingBlock-&gt;needsLayout() : true;
1869 }
1870 
1871 // We only create &quot;generated&quot; child renderers like one for first-letter if:
1872 // - the firstLetterBlock can have children in the DOM and
1873 // - the block doesn&#39;t have any special assumption on its text children.
1874 // This correctly prevents form controls from having such renderers.
1875 bool RenderObject::canHaveGeneratedChildren() const
1876 {
1877     return canHaveChildren();
1878 }
1879 
1880 Node* RenderObject::generatingPseudoHostElement() const
1881 {
1882     return downcast&lt;PseudoElement&gt;(*node()).hostElement();
1883 }
1884 
1885 void RenderObject::setNeedsBoundariesUpdate()
1886 {
1887     if (auto renderer = parent())
1888         renderer-&gt;setNeedsBoundariesUpdate();
1889 }
1890 
1891 FloatRect RenderObject::objectBoundingBox() const
1892 {
1893     ASSERT_NOT_REACHED();
1894     return FloatRect();
1895 }
1896 
1897 FloatRect RenderObject::strokeBoundingBox() const
1898 {
1899     ASSERT_NOT_REACHED();
1900     return FloatRect();
1901 }
1902 
1903 // Returns the smallest rectangle enclosing all of the painted content
1904 // respecting clipping, masking, filters, opacity, stroke-width and markers
1905 FloatRect RenderObject::repaintRectInLocalCoordinates() const
1906 {
1907     ASSERT_NOT_REACHED();
1908     return FloatRect();
1909 }
1910 
1911 AffineTransform RenderObject::localTransform() const
1912 {
1913     static const AffineTransform identity;
1914     return identity;
1915 }
1916 
1917 const AffineTransform&amp; RenderObject::localToParentTransform() const
1918 {
1919     static const AffineTransform identity;
1920     return identity;
1921 }
1922 
1923 bool RenderObject::nodeAtFloatPoint(const HitTestRequest&amp;, HitTestResult&amp;, const FloatPoint&amp;, HitTestAction)
1924 {
1925     ASSERT_NOT_REACHED();
1926     return false;
1927 }
1928 
1929 RenderFragmentedFlow* RenderObject::locateEnclosingFragmentedFlow() const
1930 {
1931     RenderBlock* containingBlock = this-&gt;containingBlock();
1932     return containingBlock ? containingBlock-&gt;enclosingFragmentedFlow() : nullptr;
1933 }
1934 
1935 void RenderObject::calculateBorderStyleColor(const BorderStyle&amp; style, const BoxSide&amp; side, Color&amp; color)
1936 {
1937     ASSERT(style == BorderStyle::Inset || style == BorderStyle::Outset);
1938     // This values were derived empirically.
1939     const RGBA32 baseDarkColor = 0xFF202020;
1940     const RGBA32 baseLightColor = 0xFFEBEBEB;
1941     enum Operation { Darken, Lighten };
1942 
1943     Operation operation = (side == BSTop || side == BSLeft) == (style == BorderStyle::Inset) ? Darken : Lighten;
1944 
1945     // Here we will darken the border decoration color when needed. This will yield a similar behavior as in FF.
1946     if (operation == Darken) {
1947         if (differenceSquared(color, Color::black) &gt; differenceSquared(baseDarkColor, Color::black))
1948             color = color.dark();
1949     } else {
1950         if (differenceSquared(color, Color::white) &gt; differenceSquared(baseLightColor, Color::white))
1951             color = color.light();
1952     }
1953 }
1954 
1955 void RenderObject::setIsDragging(bool isDragging)
1956 {
1957     if (isDragging || hasRareData())
1958         ensureRareData().setIsDragging(isDragging);
1959 }
1960 
1961 void RenderObject::setHasReflection(bool hasReflection)
1962 {
1963     if (hasReflection || hasRareData())
1964         ensureRareData().setHasReflection(hasReflection);
1965 }
1966 
1967 void RenderObject::setIsRenderFragmentedFlow(bool isFragmentedFlow)
1968 {
1969     if (isFragmentedFlow || hasRareData())
1970         ensureRareData().setIsRenderFragmentedFlow(isFragmentedFlow);
1971 }
1972 
1973 void RenderObject::setHasOutlineAutoAncestor(bool hasOutlineAutoAncestor)
1974 {
1975     if (hasOutlineAutoAncestor || hasRareData())
1976         ensureRareData().setHasOutlineAutoAncestor(hasOutlineAutoAncestor);
1977 }
1978 
1979 RenderObject::RareDataMap&amp; RenderObject::rareDataMap()
1980 {
1981     static NeverDestroyed&lt;RareDataMap&gt; map;
1982     return map;
1983 }
1984 
1985 const RenderObject::RenderObjectRareData&amp; RenderObject::rareData() const
1986 {
1987     ASSERT(hasRareData());
1988     return *rareDataMap().get(this);
1989 }
1990 
1991 RenderObject::RenderObjectRareData&amp; RenderObject::ensureRareData()
1992 {
1993     setHasRareData(true);
1994     return *rareDataMap().ensure(this, [] { return std::make_unique&lt;RenderObjectRareData&gt;(); }).iterator-&gt;value;
1995 }
1996 
1997 void RenderObject::removeRareData()
1998 {
1999     rareDataMap().remove(this);
2000     setHasRareData(false);
2001 }
2002 
2003 #if ENABLE(TREE_DEBUGGING)
2004 
2005 void printRenderTreeForLiveDocuments()
2006 {
2007     for (const auto* document : Document::allDocuments()) {
2008         if (!document-&gt;renderView())
2009             continue;
2010         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
2011             fprintf(stderr, &quot;----------------------main frame--------------------------\n&quot;);
2012         fprintf(stderr, &quot;%s&quot;, document-&gt;url().string().utf8().data());
2013         showRenderTree(document-&gt;renderView());
2014     }
2015 }
2016 
2017 void printLayerTreeForLiveDocuments()
2018 {
2019     for (const auto* document : Document::allDocuments()) {
2020         if (!document-&gt;renderView())
2021             continue;
2022         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
2023             fprintf(stderr, &quot;----------------------main frame--------------------------\n&quot;);
2024         fprintf(stderr, &quot;%s&quot;, document-&gt;url().string().utf8().data());
2025         showLayerTree(document-&gt;renderView());
2026     }
2027 }
2028 
2029 void printGraphicsLayerTreeForLiveDocuments()
2030 {
2031     for (const auto* document : Document::allDocuments()) {
2032         if (!document-&gt;renderView())
2033             continue;
2034         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame()) {
2035             WTFLogAlways(&quot;Graphics layer tree for root document %p %s&quot;, document, document-&gt;url().string().utf8().data());
2036             showGraphicsLayerTreeForCompositor(document-&gt;renderView()-&gt;compositor());
2037         }
2038     }
2039 }
2040 
2041 #endif // ENABLE(TREE_DEBUGGING)
2042 
2043 } // namespace WebCore
2044 
2045 #if ENABLE(TREE_DEBUGGING)
2046 
2047 void showNodeTree(const WebCore::RenderObject* object)
2048 {
2049     if (!object)
2050         return;
2051     object-&gt;showNodeTreeForThis();
2052 }
2053 
2054 void showLineTree(const WebCore::RenderObject* object)
2055 {
2056     if (!object)
2057         return;
2058     object-&gt;showLineTreeForThis();
2059 }
2060 
2061 void showRenderTree(const WebCore::RenderObject* object)
2062 {
2063     if (!object)
2064         return;
2065     object-&gt;showRenderTreeForThis();
2066 }
2067 
2068 #endif
    </pre>
  </body>
</html>