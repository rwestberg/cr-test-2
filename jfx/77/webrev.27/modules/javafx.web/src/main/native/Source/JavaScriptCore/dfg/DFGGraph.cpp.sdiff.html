<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGGraph.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGGenerationInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGGraph.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  57 #include &quot;StackAlignment.h&quot;
  58 #include &lt;wtf/CommaPrinter.h&gt;
  59 #include &lt;wtf/ListDump.h&gt;
  60 
  61 namespace JSC { namespace DFG {
  62 
  63 static constexpr bool dumpOSRAvailabilityData = false;
  64 
  65 // Creates an array of stringized names.
  66 static const char* dfgOpNames[] = {
  67 #define STRINGIZE_DFG_OP_ENUM(opcode, flags) #opcode ,
  68     FOR_EACH_DFG_OP(STRINGIZE_DFG_OP_ENUM)
  69 #undef STRINGIZE_DFG_OP_ENUM
  70 };
  71 
  72 Graph::Graph(VM&amp; vm, Plan&amp; plan)
  73     : m_vm(vm)
  74     , m_plan(plan)
  75     , m_codeBlock(m_plan.codeBlock())
  76     , m_profiledBlock(m_codeBlock-&gt;alternative())
<span class="line-modified">  77     , m_ssaCFG(std::make_unique&lt;SSACFG&gt;(*this))</span>
  78     , m_nextMachineLocal(0)
  79     , m_fixpointState(BeforeFixpoint)
  80     , m_structureRegistrationState(HaveNotStartedRegistering)
  81     , m_form(LoadStore)
  82     , m_unificationState(LocallyUnified)
  83     , m_refCountState(EverythingIsLive)
  84 {
  85     ASSERT(m_profiledBlock);
  86 
  87     m_hasDebuggerEnabled = m_profiledBlock-&gt;wasCompiledWithDebuggingOpcodes() || Options::forceDebuggerBytecodeGeneration();
  88 
<span class="line-modified">  89     m_indexingCache = std::make_unique&lt;FlowIndexing&gt;(*this);</span>
<span class="line-modified">  90     m_abstractValuesCache = std::make_unique&lt;FlowMap&lt;AbstractValue&gt;&gt;(*this);</span>
  91 
  92     registerStructure(vm.structureStructure.get());
  93     this-&gt;stringStructure = registerStructure(vm.stringStructure.get());
  94     this-&gt;symbolStructure = registerStructure(vm.symbolStructure.get());
  95 }
  96 
  97 Graph::~Graph()
  98 {
  99 }
 100 
 101 const char *Graph::opName(NodeType op)
 102 {
 103     return dfgOpNames[op];
 104 }
 105 
 106 static void printWhiteSpace(PrintStream&amp; out, unsigned amount)
 107 {
 108     while (amount-- &gt; 0)
 109         out.print(&quot; &quot;);
 110 }
 111 
<span class="line-modified"> 112 bool Graph::dumpCodeOrigin(PrintStream&amp; out, const char* prefix, Node*&amp; previousNodeRef, Node* currentNode, DumpContext* context)</span>
 113 {



 114     if (!currentNode-&gt;origin.semantic)
 115         return false;
 116 
 117     Node* previousNode = previousNodeRef;
 118     previousNodeRef = currentNode;
 119 
 120     if (!previousNode)
 121         return false;
 122 
<span class="line-modified"> 123     if (previousNode-&gt;origin.semantic.inlineCallFrame == currentNode-&gt;origin.semantic.inlineCallFrame)</span>
 124         return false;
 125 
 126     Vector&lt;CodeOrigin&gt; previousInlineStack = previousNode-&gt;origin.semantic.inlineStack();
 127     Vector&lt;CodeOrigin&gt; currentInlineStack = currentNode-&gt;origin.semantic.inlineStack();
 128     unsigned commonSize = std::min(previousInlineStack.size(), currentInlineStack.size());
 129     unsigned indexOfDivergence = commonSize;
 130     for (unsigned i = 0; i &lt; commonSize; ++i) {
<span class="line-modified"> 131         if (previousInlineStack[i].inlineCallFrame != currentInlineStack[i].inlineCallFrame) {</span>
 132             indexOfDivergence = i;
 133             break;
 134         }
 135     }
 136 
 137     bool hasPrinted = false;
 138 
 139     // Print the pops.
 140     for (unsigned i = previousInlineStack.size(); i-- &gt; indexOfDivergence;) {
 141         out.print(prefix);
 142         printWhiteSpace(out, i * 2);
<span class="line-modified"> 143         out.print(&quot;&lt;-- &quot;, inContext(*previousInlineStack[i].inlineCallFrame, context), &quot;\n&quot;);</span>
 144         hasPrinted = true;
 145     }
 146 
 147     // Print the pushes.
 148     for (unsigned i = indexOfDivergence; i &lt; currentInlineStack.size(); ++i) {
 149         out.print(prefix);
 150         printWhiteSpace(out, i * 2);
<span class="line-modified"> 151         out.print(&quot;--&gt; &quot;, inContext(*currentInlineStack[i].inlineCallFrame, context), &quot;\n&quot;);</span>
 152         hasPrinted = true;
 153     }
 154 
 155     return hasPrinted;
 156 }
 157 
 158 int Graph::amountOfNodeWhiteSpace(Node* node)
 159 {
 160     return (node-&gt;origin.semantic.inlineDepth() - 1) * 2;
 161 }
 162 
 163 void Graph::printNodeWhiteSpace(PrintStream&amp; out, Node* node)
 164 {
 165     printWhiteSpace(out, amountOfNodeWhiteSpace(node));
 166 }
 167 
<span class="line-modified"> 168 void Graph::dump(PrintStream&amp; out, const char* prefix, Node* node, DumpContext* context)</span>
 169 {



 170     NodeType op = node-&gt;op();
 171 
 172     unsigned refCount = node-&gt;refCount();
 173     bool mustGenerate = node-&gt;mustGenerate();
 174     if (mustGenerate)
 175         --refCount;
 176 
 177     out.print(prefix);
 178     printNodeWhiteSpace(out, node);
 179 
 180     // Example/explanation of dataflow dump output
 181     //
 182     //   14:   &lt;!2:7&gt;  GetByVal(@3, @13)
 183     //   ^1     ^2 ^3     ^4       ^5
 184     //
 185     // (1) The nodeIndex of this operation.
 186     // (2) The reference count. The number printed is the &#39;real&#39; count,
 187     //     not including the &#39;mustGenerate&#39; ref. If the node is
 188     //     &#39;mustGenerate&#39; then the count it prefixed with &#39;!&#39;.
 189     // (3) The virtual register slot assigned to this node.
</pre>
<hr />
<pre>
 377         out.print(comma, &quot;default:&quot;, data-&gt;fallThrough);
 378     }
 379     if (node-&gt;isEntrySwitch()) {
 380         EntrySwitchData* data = node-&gt;entrySwitchData();
 381         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 382             out.print(comma, BranchTarget(data-&gt;cases[i]));
 383     }
 384     ClobberSet reads;
 385     ClobberSet writes;
 386     addReadsAndWrites(*this, node, reads, writes);
 387     if (!reads.isEmpty())
 388         out.print(comma, &quot;R:&quot;, sortedListDump(reads.direct(), &quot;,&quot;));
 389     if (!writes.isEmpty())
 390         out.print(comma, &quot;W:&quot;, sortedListDump(writes.direct(), &quot;,&quot;));
 391     ExitMode exitMode = mayExit(*this, node);
 392     if (exitMode != DoesNotExit)
 393         out.print(comma, exitMode);
 394     if (clobbersExitState(*this, node))
 395         out.print(comma, &quot;ClobbersExit&quot;);
 396     if (node-&gt;origin.isSet()) {
<span class="line-modified"> 397         out.print(comma, &quot;bc#&quot;, node-&gt;origin.semantic.bytecodeIndex);</span>
 398         if (node-&gt;origin.semantic != node-&gt;origin.forExit &amp;&amp; node-&gt;origin.forExit.isSet())
 399             out.print(comma, &quot;exit: &quot;, node-&gt;origin.forExit);
 400     }
 401     out.print(comma, node-&gt;origin.exitOK ? &quot;ExitValid&quot; : &quot;ExitInvalid&quot;);
 402     if (node-&gt;origin.wasHoisted)
 403         out.print(comma, &quot;WasHoisted&quot;);
 404     out.print(&quot;)&quot;);
 405 
 406     if (node-&gt;accessesStack(*this) &amp;&amp; node-&gt;tryGetVariableAccessData())
 407         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;tryGetVariableAccessData()-&gt;prediction()));
 408     else if (node-&gt;hasHeapPrediction())
 409         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;getHeapPrediction()));
 410 
 411     out.print(&quot;\n&quot;);
 412 }
 413 
 414 bool Graph::terminalsAreValid()
 415 {
 416     for (BasicBlock* block : blocksInNaturalOrder()) {
 417         if (!block-&gt;terminal())
 418             return false;
 419     }
 420     return true;
 421 }
 422 
 423 static BasicBlock* unboxLoopNode(const CPSCFG::Node&amp; node) { return node.node(); }
 424 static BasicBlock* unboxLoopNode(BasicBlock* block) { return block; }
 425 
<span class="line-modified"> 426 void Graph::dumpBlockHeader(PrintStream&amp; out, const char* prefix, BasicBlock* block, PhiNodeDumpMode phiNodeDumpMode, DumpContext* context)</span>
 427 {



 428     out.print(prefix, &quot;Block &quot;, *block, &quot; (&quot;, inContext(block-&gt;at(0)-&gt;origin.semantic, context), &quot;):&quot;,
 429         block-&gt;isReachable ? &quot;&quot; : &quot; (skipped)&quot;, block-&gt;isOSRTarget ? &quot; (OSR target)&quot; : &quot;&quot;, block-&gt;isCatchEntrypoint ? &quot; (Catch Entrypoint)&quot; : &quot;&quot;, &quot;\n&quot;);
 430     if (block-&gt;executionCount == block-&gt;executionCount)
 431         out.print(prefix, &quot;  Execution count: &quot;, block-&gt;executionCount, &quot;\n&quot;);
 432     out.print(prefix, &quot;  Predecessors:&quot;);
 433     for (size_t i = 0; i &lt; block-&gt;predecessors.size(); ++i)
 434         out.print(&quot; &quot;, *block-&gt;predecessors[i]);
 435     out.print(&quot;\n&quot;);
 436     out.print(prefix, &quot;  Successors:&quot;);
 437     if (block-&gt;terminal()) {
 438         for (BasicBlock* successor : block-&gt;successors()) {
 439             out.print(&quot; &quot;, *successor);
 440         }
 441     } else
 442         out.print(&quot; &lt;invalid&gt;&quot;);
 443     out.print(&quot;\n&quot;);
 444 
 445     auto printDominators = [&amp;] (auto&amp; dominators) {
 446         out.print(prefix, &quot;  Dominated by: &quot;, dominators.dominatorsOf(block), &quot;\n&quot;);
 447         out.print(prefix, &quot;  Dominates: &quot;, dominators.blocksDominatedBy(block), &quot;\n&quot;);
</pre>
<hr />
<pre>
 502             Node* phiNode = block-&gt;phis[i];
 503             if (!phiNode-&gt;shouldGenerate() &amp;&amp; phiNodeDumpMode == DumpLivePhisOnly)
 504                 continue;
 505             out.print(&quot; @&quot;, phiNode-&gt;index(), &quot;&lt;&quot;, phiNode-&gt;local(), &quot;,&quot;, phiNode-&gt;refCount(), &quot;&gt;-&gt;(&quot;);
 506             if (phiNode-&gt;child1()) {
 507                 out.print(&quot;@&quot;, phiNode-&gt;child1()-&gt;index());
 508                 if (phiNode-&gt;child2()) {
 509                     out.print(&quot;, @&quot;, phiNode-&gt;child2()-&gt;index());
 510                     if (phiNode-&gt;child3())
 511                         out.print(&quot;, @&quot;, phiNode-&gt;child3()-&gt;index());
 512                 }
 513             }
 514             out.print(&quot;)&quot;, i + 1 &lt; block-&gt;phis.size() ? &quot;,&quot; : &quot;&quot;);
 515         }
 516         out.print(&quot;\n&quot;);
 517     }
 518 }
 519 
 520 void Graph::dump(PrintStream&amp; out, DumpContext* context)
 521 {

 522     DumpContext myContext;
 523     myContext.graph = this;
 524     if (!context)
 525         context = &amp;myContext;
 526 
 527     out.print(&quot;\n&quot;);
<span class="line-modified"> 528     out.print(&quot;DFG for &quot;, CodeBlockWithJITType(m_codeBlock, JITCode::DFGJIT), &quot;:\n&quot;);</span>
<span class="line-modified"> 529     out.print(&quot;  Fixpoint state: &quot;, m_fixpointState, &quot;; Form: &quot;, m_form, &quot;; Unification state: &quot;, m_unificationState, &quot;; Ref count state: &quot;, m_refCountState, &quot;\n&quot;);</span>
 530     if (m_form == SSA) {
 531         for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_argumentFormats.size(); ++entrypointIndex)
<span class="line-modified"> 532             out.print(&quot;  Argument formats for entrypoint index: &quot;, entrypointIndex, &quot; : &quot;, listDump(m_argumentFormats[entrypointIndex]), &quot;\n&quot;);</span>
 533     }
 534     else {
 535         for (auto pair : m_rootToArguments)
<span class="line-modified"> 536             out.print(&quot;  Arguments for block#&quot;, pair.key-&gt;index, &quot;: &quot;, listDump(pair.value), &quot;\n&quot;);</span>
 537     }
 538     out.print(&quot;\n&quot;);
 539 
 540     Node* lastNode = nullptr;
 541     for (size_t b = 0; b &lt; m_blocks.size(); ++b) {
 542         BasicBlock* block = m_blocks[b].get();
 543         if (!block)
 544             continue;
<span class="line-modified"> 545         dumpBlockHeader(out, &quot;&quot;, block, DumpAllPhis, context);</span>
<span class="line-modified"> 546         out.print(&quot;  States: &quot;, block-&gt;cfaStructureClobberStateAtHead);</span>

 547         if (!block-&gt;cfaHasVisited)
 548             out.print(&quot;, CurrentlyCFAUnreachable&quot;);
 549         if (!block-&gt;intersectionOfCFAHasVisited)
 550             out.print(&quot;, CFAUnreachable&quot;);
 551         out.print(&quot;\n&quot;);
 552         switch (m_form) {
 553         case LoadStore:
 554         case ThreadedCPS: {
<span class="line-modified"> 555             out.print(&quot;  Vars Before: &quot;);</span>
 556             if (block-&gt;cfaHasVisited)
 557                 out.print(inContext(block-&gt;valuesAtHead, context));
 558             else
 559                 out.print(&quot;&lt;empty&gt;&quot;);
 560             out.print(&quot;\n&quot;);
<span class="line-modified"> 561             out.print(&quot;  Intersected Vars Before: &quot;);</span>
 562             if (block-&gt;intersectionOfCFAHasVisited)
 563                 out.print(inContext(block-&gt;intersectionOfPastValuesAtHead, context));
 564             else
 565                 out.print(&quot;&lt;empty&gt;&quot;);
 566             out.print(&quot;\n&quot;);
<span class="line-modified"> 567             out.print(&quot;  Var Links: &quot;, block-&gt;variablesAtHead, &quot;\n&quot;);</span>
 568             break;
 569         }
 570 
 571         case SSA: {
 572             RELEASE_ASSERT(block-&gt;ssa);
 573             if (dumpOSRAvailabilityData)
<span class="line-modified"> 574                 out.print(&quot;  Availability: &quot;, block-&gt;ssa-&gt;availabilityAtHead, &quot;\n&quot;);</span>
<span class="line-modified"> 575             out.print(&quot;  Live: &quot;, nodeListDump(block-&gt;ssa-&gt;liveAtHead), &quot;\n&quot;);</span>
<span class="line-modified"> 576             out.print(&quot;  Values: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtHead, context), &quot;\n&quot;);</span>
 577             break;
 578         } }
 579         for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
<span class="line-modified"> 580             dumpCodeOrigin(out, &quot;&quot;, lastNode, block-&gt;at(i), context);</span>
<span class="line-modified"> 581             dump(out, &quot;&quot;, block-&gt;at(i), context);</span>


 582         }
<span class="line-modified"> 583         out.print(&quot;  States: &quot;, block-&gt;cfaBranchDirection, &quot;, &quot;, block-&gt;cfaStructureClobberStateAtTail);</span>

 584         if (!block-&gt;cfaDidFinish)
 585             out.print(&quot;, CFAInvalidated&quot;);
 586         out.print(&quot;\n&quot;);
 587         switch (m_form) {
 588         case LoadStore:
 589         case ThreadedCPS: {
<span class="line-modified"> 590             out.print(&quot;  Vars After: &quot;);</span>
 591             if (block-&gt;cfaHasVisited)
 592                 out.print(inContext(block-&gt;valuesAtTail, context));
 593             else
 594                 out.print(&quot;&lt;empty&gt;&quot;);
 595             out.print(&quot;\n&quot;);
<span class="line-modified"> 596             out.print(&quot;  Var Links: &quot;, block-&gt;variablesAtTail, &quot;\n&quot;);</span>
 597             break;
 598         }
 599 
 600         case SSA: {
 601             RELEASE_ASSERT(block-&gt;ssa);
 602             if (dumpOSRAvailabilityData)
<span class="line-modified"> 603                 out.print(&quot;  Availability: &quot;, block-&gt;ssa-&gt;availabilityAtTail, &quot;\n&quot;);</span>
<span class="line-modified"> 604             out.print(&quot;  Live: &quot;, nodeListDump(block-&gt;ssa-&gt;liveAtTail), &quot;\n&quot;);</span>
<span class="line-modified"> 605             out.print(&quot;  Values: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtTail, context), &quot;\n&quot;);</span>
 606             break;
 607         } }
 608         out.print(&quot;\n&quot;);
 609     }

 610 
<span class="line-modified"> 611     out.print(&quot;GC Values:\n&quot;);</span>
 612     for (FrozenValue* value : m_frozenValues) {
 613         if (value-&gt;pointsToHeap())
<span class="line-modified"> 614             out.print(&quot;    &quot;, inContext(*value, &amp;myContext), &quot;\n&quot;);</span>
 615     }
 616 
 617     out.print(inContext(watchpoints(), &amp;myContext));
 618 
 619     if (!myContext.isEmpty()) {
<span class="line-modified"> 620         myContext.dump(out);</span>


 621         out.print(&quot;\n&quot;);
 622     }
 623 }
 624 
 625 void Graph::deleteNode(Node* node)
 626 {
 627     if (validationEnabled() &amp;&amp; m_form == SSA) {
 628         for (BasicBlock* block : blocksInNaturalOrder()) {
 629             DFG_ASSERT(*this, node, !block-&gt;ssa-&gt;liveAtHead.contains(node));
 630             DFG_ASSERT(*this, node, !block-&gt;ssa-&gt;liveAtTail.contains(node));
 631         }
 632     }
 633 
 634     m_nodes.remove(node);
 635 }
 636 
 637 void Graph::packNodeIndices()
 638 {
 639     m_nodes.packIndices();
 640 }
</pre>
<hr />
<pre>
 871                 continue;
 872             substitute(block, indexInBlock, node, newGetLocal);
 873             Node* oldTailNode = block.variablesAtTail.operand(variableAccessData-&gt;local());
 874             if (oldTailNode == node)
 875                 block.variablesAtTail.operand(variableAccessData-&gt;local()) = newGetLocal;
 876             shouldContinue = false;
 877             break;
 878         }
 879 
 880         default:
 881             break;
 882         }
 883         if (!shouldContinue)
 884             break;
 885     }
 886 }
 887 
 888 BlockList Graph::blocksInPreOrder()
 889 {
 890     BlockList result;

 891     BlockWorklist worklist;
 892     for (BasicBlock* entrypoint : m_roots)
 893         worklist.push(entrypoint);
 894     while (BasicBlock* block = worklist.pop()) {
 895         result.append(block);
 896         for (unsigned i = block-&gt;numSuccessors(); i--;)
 897             worklist.push(block-&gt;successor(i));
 898     }
 899 
 900     if (validationEnabled()) {
 901         // When iterating over pre order, we should see dominators
 902         // before things they dominate.
 903         auto validateResults = [&amp;] (auto&amp; dominators) {
 904             for (unsigned i = 0; i &lt; result.size(); ++i) {
 905                 BasicBlock* a = result[i];
 906                 if (!a)
 907                     continue;
 908                 for (unsigned j = 0; j &lt; result.size(); ++j) {
 909                     BasicBlock* b = result[j];
 910                     if (!b || a == b)
 911                         continue;
 912                     if (dominators.dominates(a, b))
 913                         RELEASE_ASSERT(i &lt; j);
 914                 }
 915             }
 916         };
 917 
 918         if (m_form == SSA || m_isInSSAConversion)
 919             validateResults(ensureSSADominators());
 920         else
 921             validateResults(ensureCPSDominators());
 922     }
 923     return result;
 924 }
 925 
 926 BlockList Graph::blocksInPostOrder(bool isSafeToValidate)
 927 {
 928     BlockList result;

 929     PostOrderBlockWorklist worklist;
 930     for (BasicBlock* entrypoint : m_roots)
 931         worklist.push(entrypoint);
 932     while (BlockWithOrder item = worklist.pop()) {
 933         switch (item.order) {
 934         case VisitOrder::Pre:
 935             worklist.pushPost(item.node);
 936             for (unsigned i = item.node-&gt;numSuccessors(); i--;)
 937                 worklist.push(item.node-&gt;successor(i));
 938             break;
 939         case VisitOrder::Post:
 940             result.append(item.node);
 941             break;
 942         }
 943     }
 944 
 945     if (isSafeToValidate &amp;&amp; validationEnabled()) { // There are users of this where we haven&#39;t yet built of the CFG enough to be able to run dominators.
 946         auto validateResults = [&amp;] (auto&amp; dominators) {
 947             // When iterating over reverse post order, we should see dominators
 948             // before things they dominate.
</pre>
<hr />
<pre>
1061 bool Graph::watchGlobalProperty(JSGlobalObject* globalObject, unsigned identifierNumber)
1062 {
1063     UniquedStringImpl* uid = identifiers()[identifierNumber];
1064     // If we already have a WatchpointSet, and it is already invalidated, it means that this scope operation must be changed from GlobalProperty to GlobalLexicalVar,
1065     // but we still have stale metadata here since we have not yet executed this bytecode operation since the invalidation. Just emitting ForceOSRExit to update the
1066     // metadata when it reaches to this code.
1067     if (auto* watchpoint = globalObject-&gt;getReferencedPropertyWatchpointSet(uid)) {
1068         if (!watchpoint-&gt;isStillValid())
1069             return false;
1070     }
1071     globalProperties().addLazily(DesiredGlobalProperty(globalObject, identifierNumber));
1072     return true;
1073 }
1074 
1075 FullBytecodeLiveness&amp; Graph::livenessFor(CodeBlock* codeBlock)
1076 {
1077     HashMap&lt;CodeBlock*, std::unique_ptr&lt;FullBytecodeLiveness&gt;&gt;::iterator iter = m_bytecodeLiveness.find(codeBlock);
1078     if (iter != m_bytecodeLiveness.end())
1079         return *iter-&gt;value;
1080 
<span class="line-modified">1081     std::unique_ptr&lt;FullBytecodeLiveness&gt; liveness = std::make_unique&lt;FullBytecodeLiveness&gt;();</span>
1082     codeBlock-&gt;livenessAnalysis().computeFullLiveness(codeBlock, *liveness);
1083     FullBytecodeLiveness&amp; result = *liveness;
1084     m_bytecodeLiveness.add(codeBlock, WTFMove(liveness));
1085     return result;
1086 }
1087 
1088 FullBytecodeLiveness&amp; Graph::livenessFor(InlineCallFrame* inlineCallFrame)
1089 {
1090     return livenessFor(baselineCodeBlockFor(inlineCallFrame));
1091 }
1092 
1093 BytecodeKills&amp; Graph::killsFor(CodeBlock* codeBlock)
1094 {
1095     HashMap&lt;CodeBlock*, std::unique_ptr&lt;BytecodeKills&gt;&gt;::iterator iter = m_bytecodeKills.find(codeBlock);
1096     if (iter != m_bytecodeKills.end())
1097         return *iter-&gt;value;
1098 
<span class="line-modified">1099     std::unique_ptr&lt;BytecodeKills&gt; kills = std::make_unique&lt;BytecodeKills&gt;();</span>
1100     codeBlock-&gt;livenessAnalysis().computeKills(codeBlock, *kills);
1101     BytecodeKills&amp; result = *kills;
1102     m_bytecodeKills.add(codeBlock, WTFMove(kills));
1103     return result;
1104 }
1105 
1106 BytecodeKills&amp; Graph::killsFor(InlineCallFrame* inlineCallFrame)
1107 {
1108     return killsFor(baselineCodeBlockFor(inlineCallFrame));
1109 }
1110 
1111 bool Graph::isLiveInBytecode(VirtualRegister operand, CodeOrigin codeOrigin)
1112 {
1113     static const bool verbose = false;
1114 
1115     if (verbose)
1116         dataLog(&quot;Checking of operand is live: &quot;, operand, &quot;\n&quot;);
1117     CodeOrigin* codeOriginPtr = &amp;codeOrigin;
1118     for (;;) {
1119         VirtualRegister reg = VirtualRegister(
1120             operand.offset() - codeOriginPtr-&gt;stackOffset());
1121 
1122         if (verbose)
1123             dataLog(&quot;reg = &quot;, reg, &quot;\n&quot;);
1124 

1125         if (operand.offset() &lt; codeOriginPtr-&gt;stackOffset() + CallFrame::headerSizeInRegisters) {
1126             if (reg.isArgument()) {
1127                 RELEASE_ASSERT(reg.offset() &lt; CallFrame::headerSizeInRegisters);
1128 
<span class="line-modified">1129                 if (codeOriginPtr-&gt;inlineCallFrame-&gt;isClosureCall</span>

1130                     &amp;&amp; reg.offset() == CallFrameSlot::callee) {
1131                     if (verbose)
1132                         dataLog(&quot;Looks like a callee.\n&quot;);
1133                     return true;
1134                 }
1135 
<span class="line-modified">1136                 if (codeOriginPtr-&gt;inlineCallFrame-&gt;isVarargs()</span>
1137                     &amp;&amp; reg.offset() == CallFrameSlot::argumentCount) {
1138                     if (verbose)
1139                         dataLog(&quot;Looks like the argument count.\n&quot;);
1140                     return true;
1141                 }
1142 
1143                 return false;
1144             }
1145 
1146             if (verbose)
1147                 dataLog(&quot;Asking the bytecode liveness.\n&quot;);
<span class="line-modified">1148             return livenessFor(codeOriginPtr-&gt;inlineCallFrame).operandIsLive(</span>
<span class="line-removed">1149                 reg.offset(), codeOriginPtr-&gt;bytecodeIndex);</span>
1150         }
1151 
<span class="line-removed">1152         InlineCallFrame* inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame;</span>
1153         if (!inlineCallFrame) {
1154             if (verbose)
1155                 dataLog(&quot;Ran out of stack, returning true.\n&quot;);
1156             return true;
1157         }
1158 
1159         // Arguments are always live. This would be redundant if it wasn&#39;t for our
1160         // op_call_varargs inlining.
1161         if (reg.isArgument()
1162             &amp;&amp; static_cast&lt;size_t&gt;(reg.toArgument()) &lt; inlineCallFrame-&gt;argumentsWithFixup.size()) {
1163             if (verbose)
1164                 dataLog(&quot;Argument is live.\n&quot;);
1165             return true;
1166         }
1167 
<span class="line-modified">1168         codeOriginPtr = inlineCallFrame-&gt;getCallerSkippingTailCalls();</span>
<span class="line-modified">1169 </span>
<span class="line-modified">1170         // The first inline call frame could be an inline tail call</span>
<span class="line-removed">1171         if (!codeOriginPtr) {</span>
<span class="line-removed">1172             if (verbose)</span>
<span class="line-removed">1173                 dataLog(&quot;Dead because of tail inlining.\n&quot;);</span>
<span class="line-removed">1174             return false;</span>
<span class="line-removed">1175         }</span>
1176     }
1177 
1178     RELEASE_ASSERT_NOT_REACHED();
1179 }
1180 
1181 BitVector Graph::localsLiveInBytecode(CodeOrigin codeOrigin)
1182 {
1183     BitVector result;
1184     result.ensureSize(block(0)-&gt;variablesAtHead.numberOfLocals());
1185     forAllLocalsLiveInBytecode(
1186         codeOrigin,
1187         [&amp;] (VirtualRegister reg) {
1188             ASSERT(reg.isLocal());
1189             result.quickSet(reg.toLocal());
1190         });
1191     return result;
1192 }
1193 
1194 unsigned Graph::parameterSlotsForArgCount(unsigned argCount)
1195 {
</pre>
<hr />
<pre>
1522 {
1523     logDFGAssertionFailure(*this, &quot;&quot;, file, line, function, assertion);
1524 }
1525 
1526 void Graph::logAssertionFailure(
1527     Node* node, const char* file, int line, const char* function, const char* assertion)
1528 {
1529     logDFGAssertionFailure(*this, toCString(&quot;While handling node &quot;, node, &quot;\n\n&quot;), file, line, function, assertion);
1530 }
1531 
1532 void Graph::logAssertionFailure(
1533     BasicBlock* block, const char* file, int line, const char* function, const char* assertion)
1534 {
1535     logDFGAssertionFailure(*this, toCString(&quot;While handling block &quot;, pointerDump(block), &quot;\n\n&quot;), file, line, function, assertion);
1536 }
1537 
1538 CPSCFG&amp; Graph::ensureCPSCFG()
1539 {
1540     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1541     if (!m_cpsCFG)
<span class="line-modified">1542         m_cpsCFG = std::make_unique&lt;CPSCFG&gt;(*this);</span>
1543     return *m_cpsCFG;
1544 }
1545 
1546 CPSDominators&amp; Graph::ensureCPSDominators()
1547 {
1548     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1549     if (!m_cpsDominators)
<span class="line-modified">1550         m_cpsDominators = std::make_unique&lt;CPSDominators&gt;(*this);</span>
1551     return *m_cpsDominators;
1552 }
1553 
1554 SSADominators&amp; Graph::ensureSSADominators()
1555 {
1556     RELEASE_ASSERT(m_form == SSA || m_isInSSAConversion);
1557     if (!m_ssaDominators)
<span class="line-modified">1558         m_ssaDominators = std::make_unique&lt;SSADominators&gt;(*this);</span>
1559     return *m_ssaDominators;
1560 }
1561 
1562 CPSNaturalLoops&amp; Graph::ensureCPSNaturalLoops()
1563 {
1564     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1565     ensureCPSDominators();
1566     if (!m_cpsNaturalLoops)
<span class="line-modified">1567         m_cpsNaturalLoops = std::make_unique&lt;CPSNaturalLoops&gt;(*this);</span>
1568     return *m_cpsNaturalLoops;
1569 }
1570 
1571 SSANaturalLoops&amp; Graph::ensureSSANaturalLoops()
1572 {
1573     RELEASE_ASSERT(m_form == SSA);
1574     ensureSSADominators();
1575     if (!m_ssaNaturalLoops)
<span class="line-modified">1576         m_ssaNaturalLoops = std::make_unique&lt;SSANaturalLoops&gt;(*this);</span>
1577     return *m_ssaNaturalLoops;
1578 }
1579 
1580 BackwardsCFG&amp; Graph::ensureBackwardsCFG()
1581 {
1582     // We could easily relax this in the future to work over CPS, but today, it&#39;s only used in SSA.
1583     RELEASE_ASSERT(m_form == SSA);
1584     if (!m_backwardsCFG)
<span class="line-modified">1585         m_backwardsCFG = std::make_unique&lt;BackwardsCFG&gt;(*this);</span>
1586     return *m_backwardsCFG;
1587 }
1588 
1589 BackwardsDominators&amp; Graph::ensureBackwardsDominators()
1590 {
1591     RELEASE_ASSERT(m_form == SSA);
1592     if (!m_backwardsDominators)
<span class="line-modified">1593         m_backwardsDominators = std::make_unique&lt;BackwardsDominators&gt;(*this);</span>
1594     return *m_backwardsDominators;
1595 }
1596 
1597 ControlEquivalenceAnalysis&amp; Graph::ensureControlEquivalenceAnalysis()
1598 {
1599     RELEASE_ASSERT(m_form == SSA);
1600     if (!m_controlEquivalenceAnalysis)
<span class="line-modified">1601         m_controlEquivalenceAnalysis = std::make_unique&lt;ControlEquivalenceAnalysis&gt;(*this);</span>
1602     return *m_controlEquivalenceAnalysis;
1603 }
1604 
1605 MethodOfGettingAValueProfile Graph::methodOfGettingAValueProfileFor(Node* currentNode, Node* operandNode)
1606 {
1607     // This represents IR like `CurrentNode(@operandNode)`. For example: `GetByVal(..., Int32:@GetLocal)`.
1608 
1609     for (Node* node = operandNode; node;) {
1610         // currentNode is null when we&#39;re doing speculation checks for checkArgumentTypes().
1611         if (!currentNode || node-&gt;origin.semantic != currentNode-&gt;origin.semantic || !currentNode-&gt;hasResult()) {
1612             CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);
1613 
1614             if (node-&gt;accessesStack(*this)) {
1615                 if (m_form != SSA &amp;&amp; node-&gt;local().isArgument()) {
1616                     int argument = node-&gt;local().toArgument();
1617                     Node* argumentNode = m_rootToArguments.find(block(0))-&gt;value[argument];
<span class="line-modified">1618                     // FIXME: We should match SetArgument nodes at other entrypoints as well:</span>
1619                     // https://bugs.webkit.org/show_bug.cgi?id=175841
1620                     if (argumentNode &amp;&amp; node-&gt;variableAccessData() == argumentNode-&gt;variableAccessData())
1621                         return &amp;profiledBlock-&gt;valueProfileForArgument(argument);
1622                 }
1623 
1624                 if (node-&gt;op() == GetLocal) {
1625                     return MethodOfGettingAValueProfile::fromLazyOperand(
1626                         profiledBlock,
1627                         LazyOperandValueProfileKey(
<span class="line-modified">1628                             node-&gt;origin.semantic.bytecodeIndex, node-&gt;local()));</span>
1629                 }
1630             }
1631 
1632             if (node-&gt;hasHeapPrediction())
<span class="line-modified">1633                 return &amp;profiledBlock-&gt;valueProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
1634 
1635             if (profiledBlock-&gt;hasBaselineJITProfiling()) {
<span class="line-modified">1636                 if (ArithProfile* result = profiledBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex))</span>
1637                     return result;
1638             }
1639         }
1640 
1641         switch (node-&gt;op()) {
1642         case BooleanToNumber:
1643         case Identity:
1644         case ValueRep:
1645         case DoubleRep:
1646         case Int52Rep:
1647             node = node-&gt;child1().node();
1648             break;
1649         default:
1650             node = nullptr;
1651         }
1652     }
1653 
1654     return MethodOfGettingAValueProfile();
1655 }
1656 
</pre>
<hr />
<pre>
1694     JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, equivalenceCondition.condition().requiredValue());
1695     if (!function)
1696         return false;
1697 
1698     if (function-&gt;executable()-&gt;intrinsicFor(CodeForCall) != StringPrototypeValueOfIntrinsic)
1699         return false;
1700 
1701     return watchConditions(conditions);
1702 }
1703 
1704 
1705 bool Graph::canOptimizeStringObjectAccess(const CodeOrigin&amp; codeOrigin)
1706 {
1707     if (hasExitSite(codeOrigin, BadCache) || hasExitSite(codeOrigin, BadConstantCache))
1708         return false;
1709 
1710     JSGlobalObject* globalObject = globalObjectFor(codeOrigin);
1711     Structure* stringObjectStructure = globalObjectFor(codeOrigin)-&gt;stringObjectStructure();
1712     registerStructure(stringObjectStructure);
1713     ASSERT(stringObjectStructure-&gt;storedPrototype().isObject());
<span class="line-modified">1714     ASSERT(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;classInfo(*stringObjectStructure-&gt;storedPrototype().asCell()-&gt;vm()) == StringPrototype::info());</span>
1715 
1716     if (!watchConditions(generateConditionsForPropertyMissConcurrently(m_vm, globalObject, stringObjectStructure, m_vm.propertyNames-&gt;toPrimitiveSymbol.impl())))
1717         return false;
1718 
1719     // We&#39;re being conservative here. We want DFG&#39;s ToString on StringObject to be
1720     // used in both numeric contexts (that would call valueOf()) and string contexts
1721     // (that would call toString()). We don&#39;t want the DFG to have to distinguish
1722     // between the two, just because that seems like it would get confusing. So we
1723     // just require both methods to be sane.
1724     if (!isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;valueOf.impl()))
1725         return false;
1726     return isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;toString.impl());
1727 }
1728 
1729 bool Graph::willCatchExceptionInMachineFrame(CodeOrigin codeOrigin, CodeOrigin&amp; opCatchOriginOut, HandlerInfo*&amp; catchHandlerOut)
1730 {
1731     if (!m_hasExceptionHandlers)
1732         return false;
1733 
<span class="line-modified">1734     unsigned bytecodeIndexToCheck = codeOrigin.bytecodeIndex;</span>
1735     while (1) {
<span class="line-modified">1736         InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame;</span>
1737         CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);
1738         if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeOffset(bytecodeIndexToCheck)) {
1739             opCatchOriginOut = CodeOrigin(handler-&gt;target, inlineCallFrame);
1740             catchHandlerOut = handler;
1741             return true;
1742         }
1743 
1744         if (!inlineCallFrame)
1745             return false;
1746 
<span class="line-modified">1747         bytecodeIndexToCheck = inlineCallFrame-&gt;directCaller.bytecodeIndex;</span>
<span class="line-modified">1748         codeOrigin = codeOrigin.inlineCallFrame-&gt;directCaller;</span>
1749     }
1750 
1751     RELEASE_ASSERT_NOT_REACHED();
1752 }
1753 
1754 bool Graph::canDoFastSpread(Node* node, const AbstractValue&amp; value)
1755 {
1756     // The parameter &#39;value&#39; is the AbstractValue for child1 (the thing being spread).
1757     ASSERT(node-&gt;op() == Spread);
1758 
1759     if (node-&gt;child1().useKind() != ArrayUse) {
1760         // Note: we only speculate on ArrayUse when we&#39;ve set up the necessary watchpoints
1761         // to prove that the iteration protocol is non-observable starting from ArrayPrototype.
1762         return false;
1763     }
1764 
1765     // FIXME: We should add profiling of the incoming operand to Spread
1766     // so we can speculate in such a way that we guarantee that this
1767     // function would return true:
1768     // https://bugs.webkit.org/show_bug.cgi?id=171198
</pre>
<hr />
<pre>
1773     ArrayPrototype* arrayPrototype = globalObjectFor(node-&gt;child1()-&gt;origin.semantic)-&gt;arrayPrototype();
1774     bool allGood = true;
1775     value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
1776         allGood &amp;= structure-&gt;hasMonoProto()
1777             &amp;&amp; structure-&gt;storedPrototype() == arrayPrototype
1778             &amp;&amp; !structure-&gt;isDictionary()
1779             &amp;&amp; structure-&gt;getConcurrently(m_vm.propertyNames-&gt;iteratorSymbol.impl()) == invalidOffset
1780             &amp;&amp; !structure-&gt;mayInterceptIndexedAccesses();
1781     });
1782 
1783     return allGood;
1784 }
1785 
1786 void Graph::clearCPSCFGData()
1787 {
1788     m_cpsNaturalLoops = nullptr;
1789     m_cpsDominators = nullptr;
1790     m_cpsCFG = nullptr;
1791 }
1792 

























1793 } } // namespace JSC::DFG
1794 
1795 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  57 #include &quot;StackAlignment.h&quot;
  58 #include &lt;wtf/CommaPrinter.h&gt;
  59 #include &lt;wtf/ListDump.h&gt;
  60 
  61 namespace JSC { namespace DFG {
  62 
  63 static constexpr bool dumpOSRAvailabilityData = false;
  64 
  65 // Creates an array of stringized names.
  66 static const char* dfgOpNames[] = {
  67 #define STRINGIZE_DFG_OP_ENUM(opcode, flags) #opcode ,
  68     FOR_EACH_DFG_OP(STRINGIZE_DFG_OP_ENUM)
  69 #undef STRINGIZE_DFG_OP_ENUM
  70 };
  71 
  72 Graph::Graph(VM&amp; vm, Plan&amp; plan)
  73     : m_vm(vm)
  74     , m_plan(plan)
  75     , m_codeBlock(m_plan.codeBlock())
  76     , m_profiledBlock(m_codeBlock-&gt;alternative())
<span class="line-modified">  77     , m_ssaCFG(makeUnique&lt;SSACFG&gt;(*this))</span>
  78     , m_nextMachineLocal(0)
  79     , m_fixpointState(BeforeFixpoint)
  80     , m_structureRegistrationState(HaveNotStartedRegistering)
  81     , m_form(LoadStore)
  82     , m_unificationState(LocallyUnified)
  83     , m_refCountState(EverythingIsLive)
  84 {
  85     ASSERT(m_profiledBlock);
  86 
  87     m_hasDebuggerEnabled = m_profiledBlock-&gt;wasCompiledWithDebuggingOpcodes() || Options::forceDebuggerBytecodeGeneration();
  88 
<span class="line-modified">  89     m_indexingCache = makeUnique&lt;FlowIndexing&gt;(*this);</span>
<span class="line-modified">  90     m_abstractValuesCache = makeUnique&lt;FlowMap&lt;AbstractValue&gt;&gt;(*this);</span>
  91 
  92     registerStructure(vm.structureStructure.get());
  93     this-&gt;stringStructure = registerStructure(vm.stringStructure.get());
  94     this-&gt;symbolStructure = registerStructure(vm.symbolStructure.get());
  95 }
  96 
  97 Graph::~Graph()
  98 {
  99 }
 100 
 101 const char *Graph::opName(NodeType op)
 102 {
 103     return dfgOpNames[op];
 104 }
 105 
 106 static void printWhiteSpace(PrintStream&amp; out, unsigned amount)
 107 {
 108     while (amount-- &gt; 0)
 109         out.print(&quot; &quot;);
 110 }
 111 
<span class="line-modified"> 112 bool Graph::dumpCodeOrigin(PrintStream&amp; out, const char* prefixStr, Node*&amp; previousNodeRef, Node* currentNode, DumpContext* context)</span>
 113 {
<span class="line-added"> 114     Prefix myPrefix(prefixStr);</span>
<span class="line-added"> 115     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;</span>
<span class="line-added"> 116 </span>
 117     if (!currentNode-&gt;origin.semantic)
 118         return false;
 119 
 120     Node* previousNode = previousNodeRef;
 121     previousNodeRef = currentNode;
 122 
 123     if (!previousNode)
 124         return false;
 125 
<span class="line-modified"> 126     if (previousNode-&gt;origin.semantic.inlineCallFrame() == currentNode-&gt;origin.semantic.inlineCallFrame())</span>
 127         return false;
 128 
 129     Vector&lt;CodeOrigin&gt; previousInlineStack = previousNode-&gt;origin.semantic.inlineStack();
 130     Vector&lt;CodeOrigin&gt; currentInlineStack = currentNode-&gt;origin.semantic.inlineStack();
 131     unsigned commonSize = std::min(previousInlineStack.size(), currentInlineStack.size());
 132     unsigned indexOfDivergence = commonSize;
 133     for (unsigned i = 0; i &lt; commonSize; ++i) {
<span class="line-modified"> 134         if (previousInlineStack[i].inlineCallFrame() != currentInlineStack[i].inlineCallFrame()) {</span>
 135             indexOfDivergence = i;
 136             break;
 137         }
 138     }
 139 
 140     bool hasPrinted = false;
 141 
 142     // Print the pops.
 143     for (unsigned i = previousInlineStack.size(); i-- &gt; indexOfDivergence;) {
 144         out.print(prefix);
 145         printWhiteSpace(out, i * 2);
<span class="line-modified"> 146         out.print(&quot;&lt;-- &quot;, inContext(*previousInlineStack[i].inlineCallFrame(), context), &quot;\n&quot;);</span>
 147         hasPrinted = true;
 148     }
 149 
 150     // Print the pushes.
 151     for (unsigned i = indexOfDivergence; i &lt; currentInlineStack.size(); ++i) {
 152         out.print(prefix);
 153         printWhiteSpace(out, i * 2);
<span class="line-modified"> 154         out.print(&quot;--&gt; &quot;, inContext(*currentInlineStack[i].inlineCallFrame(), context), &quot;\n&quot;);</span>
 155         hasPrinted = true;
 156     }
 157 
 158     return hasPrinted;
 159 }
 160 
 161 int Graph::amountOfNodeWhiteSpace(Node* node)
 162 {
 163     return (node-&gt;origin.semantic.inlineDepth() - 1) * 2;
 164 }
 165 
 166 void Graph::printNodeWhiteSpace(PrintStream&amp; out, Node* node)
 167 {
 168     printWhiteSpace(out, amountOfNodeWhiteSpace(node));
 169 }
 170 
<span class="line-modified"> 171 void Graph::dump(PrintStream&amp; out, const char* prefixStr, Node* node, DumpContext* context)</span>
 172 {
<span class="line-added"> 173     Prefix myPrefix(prefixStr);</span>
<span class="line-added"> 174     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;</span>
<span class="line-added"> 175 </span>
 176     NodeType op = node-&gt;op();
 177 
 178     unsigned refCount = node-&gt;refCount();
 179     bool mustGenerate = node-&gt;mustGenerate();
 180     if (mustGenerate)
 181         --refCount;
 182 
 183     out.print(prefix);
 184     printNodeWhiteSpace(out, node);
 185 
 186     // Example/explanation of dataflow dump output
 187     //
 188     //   14:   &lt;!2:7&gt;  GetByVal(@3, @13)
 189     //   ^1     ^2 ^3     ^4       ^5
 190     //
 191     // (1) The nodeIndex of this operation.
 192     // (2) The reference count. The number printed is the &#39;real&#39; count,
 193     //     not including the &#39;mustGenerate&#39; ref. If the node is
 194     //     &#39;mustGenerate&#39; then the count it prefixed with &#39;!&#39;.
 195     // (3) The virtual register slot assigned to this node.
</pre>
<hr />
<pre>
 383         out.print(comma, &quot;default:&quot;, data-&gt;fallThrough);
 384     }
 385     if (node-&gt;isEntrySwitch()) {
 386         EntrySwitchData* data = node-&gt;entrySwitchData();
 387         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 388             out.print(comma, BranchTarget(data-&gt;cases[i]));
 389     }
 390     ClobberSet reads;
 391     ClobberSet writes;
 392     addReadsAndWrites(*this, node, reads, writes);
 393     if (!reads.isEmpty())
 394         out.print(comma, &quot;R:&quot;, sortedListDump(reads.direct(), &quot;,&quot;));
 395     if (!writes.isEmpty())
 396         out.print(comma, &quot;W:&quot;, sortedListDump(writes.direct(), &quot;,&quot;));
 397     ExitMode exitMode = mayExit(*this, node);
 398     if (exitMode != DoesNotExit)
 399         out.print(comma, exitMode);
 400     if (clobbersExitState(*this, node))
 401         out.print(comma, &quot;ClobbersExit&quot;);
 402     if (node-&gt;origin.isSet()) {
<span class="line-modified"> 403         out.print(comma, &quot;bc#&quot;, node-&gt;origin.semantic.bytecodeIndex());</span>
 404         if (node-&gt;origin.semantic != node-&gt;origin.forExit &amp;&amp; node-&gt;origin.forExit.isSet())
 405             out.print(comma, &quot;exit: &quot;, node-&gt;origin.forExit);
 406     }
 407     out.print(comma, node-&gt;origin.exitOK ? &quot;ExitValid&quot; : &quot;ExitInvalid&quot;);
 408     if (node-&gt;origin.wasHoisted)
 409         out.print(comma, &quot;WasHoisted&quot;);
 410     out.print(&quot;)&quot;);
 411 
 412     if (node-&gt;accessesStack(*this) &amp;&amp; node-&gt;tryGetVariableAccessData())
 413         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;tryGetVariableAccessData()-&gt;prediction()));
 414     else if (node-&gt;hasHeapPrediction())
 415         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;getHeapPrediction()));
 416 
 417     out.print(&quot;\n&quot;);
 418 }
 419 
 420 bool Graph::terminalsAreValid()
 421 {
 422     for (BasicBlock* block : blocksInNaturalOrder()) {
 423         if (!block-&gt;terminal())
 424             return false;
 425     }
 426     return true;
 427 }
 428 
 429 static BasicBlock* unboxLoopNode(const CPSCFG::Node&amp; node) { return node.node(); }
 430 static BasicBlock* unboxLoopNode(BasicBlock* block) { return block; }
 431 
<span class="line-modified"> 432 void Graph::dumpBlockHeader(PrintStream&amp; out, const char* prefixStr, BasicBlock* block, PhiNodeDumpMode phiNodeDumpMode, DumpContext* context)</span>
 433 {
<span class="line-added"> 434     Prefix myPrefix(prefixStr);</span>
<span class="line-added"> 435     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;</span>
<span class="line-added"> 436 </span>
 437     out.print(prefix, &quot;Block &quot;, *block, &quot; (&quot;, inContext(block-&gt;at(0)-&gt;origin.semantic, context), &quot;):&quot;,
 438         block-&gt;isReachable ? &quot;&quot; : &quot; (skipped)&quot;, block-&gt;isOSRTarget ? &quot; (OSR target)&quot; : &quot;&quot;, block-&gt;isCatchEntrypoint ? &quot; (Catch Entrypoint)&quot; : &quot;&quot;, &quot;\n&quot;);
 439     if (block-&gt;executionCount == block-&gt;executionCount)
 440         out.print(prefix, &quot;  Execution count: &quot;, block-&gt;executionCount, &quot;\n&quot;);
 441     out.print(prefix, &quot;  Predecessors:&quot;);
 442     for (size_t i = 0; i &lt; block-&gt;predecessors.size(); ++i)
 443         out.print(&quot; &quot;, *block-&gt;predecessors[i]);
 444     out.print(&quot;\n&quot;);
 445     out.print(prefix, &quot;  Successors:&quot;);
 446     if (block-&gt;terminal()) {
 447         for (BasicBlock* successor : block-&gt;successors()) {
 448             out.print(&quot; &quot;, *successor);
 449         }
 450     } else
 451         out.print(&quot; &lt;invalid&gt;&quot;);
 452     out.print(&quot;\n&quot;);
 453 
 454     auto printDominators = [&amp;] (auto&amp; dominators) {
 455         out.print(prefix, &quot;  Dominated by: &quot;, dominators.dominatorsOf(block), &quot;\n&quot;);
 456         out.print(prefix, &quot;  Dominates: &quot;, dominators.blocksDominatedBy(block), &quot;\n&quot;);
</pre>
<hr />
<pre>
 511             Node* phiNode = block-&gt;phis[i];
 512             if (!phiNode-&gt;shouldGenerate() &amp;&amp; phiNodeDumpMode == DumpLivePhisOnly)
 513                 continue;
 514             out.print(&quot; @&quot;, phiNode-&gt;index(), &quot;&lt;&quot;, phiNode-&gt;local(), &quot;,&quot;, phiNode-&gt;refCount(), &quot;&gt;-&gt;(&quot;);
 515             if (phiNode-&gt;child1()) {
 516                 out.print(&quot;@&quot;, phiNode-&gt;child1()-&gt;index());
 517                 if (phiNode-&gt;child2()) {
 518                     out.print(&quot;, @&quot;, phiNode-&gt;child2()-&gt;index());
 519                     if (phiNode-&gt;child3())
 520                         out.print(&quot;, @&quot;, phiNode-&gt;child3()-&gt;index());
 521                 }
 522             }
 523             out.print(&quot;)&quot;, i + 1 &lt; block-&gt;phis.size() ? &quot;,&quot; : &quot;&quot;);
 524         }
 525         out.print(&quot;\n&quot;);
 526     }
 527 }
 528 
 529 void Graph::dump(PrintStream&amp; out, DumpContext* context)
 530 {
<span class="line-added"> 531     Prefix&amp; prefix = m_prefix;</span>
 532     DumpContext myContext;
 533     myContext.graph = this;
 534     if (!context)
 535         context = &amp;myContext;
 536 
 537     out.print(&quot;\n&quot;);
<span class="line-modified"> 538     out.print(prefix, &quot;DFG for &quot;, CodeBlockWithJITType(m_codeBlock, JITType::DFGJIT), &quot;:\n&quot;);</span>
<span class="line-modified"> 539     out.print(prefix, &quot;  Fixpoint state: &quot;, m_fixpointState, &quot;; Form: &quot;, m_form, &quot;; Unification state: &quot;, m_unificationState, &quot;; Ref count state: &quot;, m_refCountState, &quot;\n&quot;);</span>
 540     if (m_form == SSA) {
 541         for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_argumentFormats.size(); ++entrypointIndex)
<span class="line-modified"> 542             out.print(prefix, &quot;  Argument formats for entrypoint index: &quot;, entrypointIndex, &quot; : &quot;, listDump(m_argumentFormats[entrypointIndex]), &quot;\n&quot;);</span>
 543     }
 544     else {
 545         for (auto pair : m_rootToArguments)
<span class="line-modified"> 546             out.print(prefix, &quot;  Arguments for block#&quot;, pair.key-&gt;index, &quot;: &quot;, listDump(pair.value), &quot;\n&quot;);</span>
 547     }
 548     out.print(&quot;\n&quot;);
 549 
 550     Node* lastNode = nullptr;
 551     for (size_t b = 0; b &lt; m_blocks.size(); ++b) {
 552         BasicBlock* block = m_blocks[b].get();
 553         if (!block)
 554             continue;
<span class="line-modified"> 555         prefix.blockIndex = block-&gt;index;</span>
<span class="line-modified"> 556         dumpBlockHeader(out, Prefix::noString, block, DumpAllPhis, context);</span>
<span class="line-added"> 557         out.print(prefix, &quot;  States: &quot;, block-&gt;cfaStructureClobberStateAtHead);</span>
 558         if (!block-&gt;cfaHasVisited)
 559             out.print(&quot;, CurrentlyCFAUnreachable&quot;);
 560         if (!block-&gt;intersectionOfCFAHasVisited)
 561             out.print(&quot;, CFAUnreachable&quot;);
 562         out.print(&quot;\n&quot;);
 563         switch (m_form) {
 564         case LoadStore:
 565         case ThreadedCPS: {
<span class="line-modified"> 566             out.print(prefix, &quot;  Vars Before: &quot;);</span>
 567             if (block-&gt;cfaHasVisited)
 568                 out.print(inContext(block-&gt;valuesAtHead, context));
 569             else
 570                 out.print(&quot;&lt;empty&gt;&quot;);
 571             out.print(&quot;\n&quot;);
<span class="line-modified"> 572             out.print(prefix, &quot;  Intersected Vars Before: &quot;);</span>
 573             if (block-&gt;intersectionOfCFAHasVisited)
 574                 out.print(inContext(block-&gt;intersectionOfPastValuesAtHead, context));
 575             else
 576                 out.print(&quot;&lt;empty&gt;&quot;);
 577             out.print(&quot;\n&quot;);
<span class="line-modified"> 578             out.print(prefix, &quot;  Var Links: &quot;, block-&gt;variablesAtHead, &quot;\n&quot;);</span>
 579             break;
 580         }
 581 
 582         case SSA: {
 583             RELEASE_ASSERT(block-&gt;ssa);
 584             if (dumpOSRAvailabilityData)
<span class="line-modified"> 585                 out.print(prefix, &quot;  Availability: &quot;, block-&gt;ssa-&gt;availabilityAtHead, &quot;\n&quot;);</span>
<span class="line-modified"> 586             out.print(prefix, &quot;  Live: &quot;, nodeListDump(block-&gt;ssa-&gt;liveAtHead), &quot;\n&quot;);</span>
<span class="line-modified"> 587             out.print(prefix, &quot;  Values: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtHead, context), &quot;\n&quot;);</span>
 588             break;
 589         } }
 590         for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
<span class="line-modified"> 591             prefix.clearNodeIndex();</span>
<span class="line-modified"> 592             dumpCodeOrigin(out, Prefix::noString, lastNode, block-&gt;at(i), context);</span>
<span class="line-added"> 593             prefix.nodeIndex = i;</span>
<span class="line-added"> 594             dump(out, Prefix::noString, block-&gt;at(i), context);</span>
 595         }
<span class="line-modified"> 596         prefix.clearNodeIndex();</span>
<span class="line-added"> 597         out.print(prefix, &quot;  States: &quot;, block-&gt;cfaBranchDirection, &quot;, &quot;, block-&gt;cfaStructureClobberStateAtTail);</span>
 598         if (!block-&gt;cfaDidFinish)
 599             out.print(&quot;, CFAInvalidated&quot;);
 600         out.print(&quot;\n&quot;);
 601         switch (m_form) {
 602         case LoadStore:
 603         case ThreadedCPS: {
<span class="line-modified"> 604             out.print(prefix, &quot;  Vars After: &quot;);</span>
 605             if (block-&gt;cfaHasVisited)
 606                 out.print(inContext(block-&gt;valuesAtTail, context));
 607             else
 608                 out.print(&quot;&lt;empty&gt;&quot;);
 609             out.print(&quot;\n&quot;);
<span class="line-modified"> 610             out.print(prefix, &quot;  Var Links: &quot;, block-&gt;variablesAtTail, &quot;\n&quot;);</span>
 611             break;
 612         }
 613 
 614         case SSA: {
 615             RELEASE_ASSERT(block-&gt;ssa);
 616             if (dumpOSRAvailabilityData)
<span class="line-modified"> 617                 out.print(prefix, &quot;  Availability: &quot;, block-&gt;ssa-&gt;availabilityAtTail, &quot;\n&quot;);</span>
<span class="line-modified"> 618             out.print(prefix, &quot;  Live: &quot;, nodeListDump(block-&gt;ssa-&gt;liveAtTail), &quot;\n&quot;);</span>
<span class="line-modified"> 619             out.print(prefix, &quot;  Values: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtTail, context), &quot;\n&quot;);</span>
 620             break;
 621         } }
 622         out.print(&quot;\n&quot;);
 623     }
<span class="line-added"> 624     prefix.clearBlockIndex();</span>
 625 
<span class="line-modified"> 626     out.print(prefix, &quot;GC Values:\n&quot;);</span>
 627     for (FrozenValue* value : m_frozenValues) {
 628         if (value-&gt;pointsToHeap())
<span class="line-modified"> 629             out.print(prefix, &quot;    &quot;, inContext(*value, &amp;myContext), &quot;\n&quot;);</span>
 630     }
 631 
 632     out.print(inContext(watchpoints(), &amp;myContext));
 633 
 634     if (!myContext.isEmpty()) {
<span class="line-modified"> 635         StringPrintStream prefixStr;</span>
<span class="line-added"> 636         prefixStr.print(prefix);</span>
<span class="line-added"> 637         myContext.dump(out, prefixStr.toCString().data());</span>
 638         out.print(&quot;\n&quot;);
 639     }
 640 }
 641 
 642 void Graph::deleteNode(Node* node)
 643 {
 644     if (validationEnabled() &amp;&amp; m_form == SSA) {
 645         for (BasicBlock* block : blocksInNaturalOrder()) {
 646             DFG_ASSERT(*this, node, !block-&gt;ssa-&gt;liveAtHead.contains(node));
 647             DFG_ASSERT(*this, node, !block-&gt;ssa-&gt;liveAtTail.contains(node));
 648         }
 649     }
 650 
 651     m_nodes.remove(node);
 652 }
 653 
 654 void Graph::packNodeIndices()
 655 {
 656     m_nodes.packIndices();
 657 }
</pre>
<hr />
<pre>
 888                 continue;
 889             substitute(block, indexInBlock, node, newGetLocal);
 890             Node* oldTailNode = block.variablesAtTail.operand(variableAccessData-&gt;local());
 891             if (oldTailNode == node)
 892                 block.variablesAtTail.operand(variableAccessData-&gt;local()) = newGetLocal;
 893             shouldContinue = false;
 894             break;
 895         }
 896 
 897         default:
 898             break;
 899         }
 900         if (!shouldContinue)
 901             break;
 902     }
 903 }
 904 
 905 BlockList Graph::blocksInPreOrder()
 906 {
 907     BlockList result;
<span class="line-added"> 908     result.reserveInitialCapacity(m_blocks.size());</span>
 909     BlockWorklist worklist;
 910     for (BasicBlock* entrypoint : m_roots)
 911         worklist.push(entrypoint);
 912     while (BasicBlock* block = worklist.pop()) {
 913         result.append(block);
 914         for (unsigned i = block-&gt;numSuccessors(); i--;)
 915             worklist.push(block-&gt;successor(i));
 916     }
 917 
 918     if (validationEnabled()) {
 919         // When iterating over pre order, we should see dominators
 920         // before things they dominate.
 921         auto validateResults = [&amp;] (auto&amp; dominators) {
 922             for (unsigned i = 0; i &lt; result.size(); ++i) {
 923                 BasicBlock* a = result[i];
 924                 if (!a)
 925                     continue;
 926                 for (unsigned j = 0; j &lt; result.size(); ++j) {
 927                     BasicBlock* b = result[j];
 928                     if (!b || a == b)
 929                         continue;
 930                     if (dominators.dominates(a, b))
 931                         RELEASE_ASSERT(i &lt; j);
 932                 }
 933             }
 934         };
 935 
 936         if (m_form == SSA || m_isInSSAConversion)
 937             validateResults(ensureSSADominators());
 938         else
 939             validateResults(ensureCPSDominators());
 940     }
 941     return result;
 942 }
 943 
 944 BlockList Graph::blocksInPostOrder(bool isSafeToValidate)
 945 {
 946     BlockList result;
<span class="line-added"> 947     result.reserveInitialCapacity(m_blocks.size());</span>
 948     PostOrderBlockWorklist worklist;
 949     for (BasicBlock* entrypoint : m_roots)
 950         worklist.push(entrypoint);
 951     while (BlockWithOrder item = worklist.pop()) {
 952         switch (item.order) {
 953         case VisitOrder::Pre:
 954             worklist.pushPost(item.node);
 955             for (unsigned i = item.node-&gt;numSuccessors(); i--;)
 956                 worklist.push(item.node-&gt;successor(i));
 957             break;
 958         case VisitOrder::Post:
 959             result.append(item.node);
 960             break;
 961         }
 962     }
 963 
 964     if (isSafeToValidate &amp;&amp; validationEnabled()) { // There are users of this where we haven&#39;t yet built of the CFG enough to be able to run dominators.
 965         auto validateResults = [&amp;] (auto&amp; dominators) {
 966             // When iterating over reverse post order, we should see dominators
 967             // before things they dominate.
</pre>
<hr />
<pre>
1080 bool Graph::watchGlobalProperty(JSGlobalObject* globalObject, unsigned identifierNumber)
1081 {
1082     UniquedStringImpl* uid = identifiers()[identifierNumber];
1083     // If we already have a WatchpointSet, and it is already invalidated, it means that this scope operation must be changed from GlobalProperty to GlobalLexicalVar,
1084     // but we still have stale metadata here since we have not yet executed this bytecode operation since the invalidation. Just emitting ForceOSRExit to update the
1085     // metadata when it reaches to this code.
1086     if (auto* watchpoint = globalObject-&gt;getReferencedPropertyWatchpointSet(uid)) {
1087         if (!watchpoint-&gt;isStillValid())
1088             return false;
1089     }
1090     globalProperties().addLazily(DesiredGlobalProperty(globalObject, identifierNumber));
1091     return true;
1092 }
1093 
1094 FullBytecodeLiveness&amp; Graph::livenessFor(CodeBlock* codeBlock)
1095 {
1096     HashMap&lt;CodeBlock*, std::unique_ptr&lt;FullBytecodeLiveness&gt;&gt;::iterator iter = m_bytecodeLiveness.find(codeBlock);
1097     if (iter != m_bytecodeLiveness.end())
1098         return *iter-&gt;value;
1099 
<span class="line-modified">1100     std::unique_ptr&lt;FullBytecodeLiveness&gt; liveness = makeUnique&lt;FullBytecodeLiveness&gt;();</span>
1101     codeBlock-&gt;livenessAnalysis().computeFullLiveness(codeBlock, *liveness);
1102     FullBytecodeLiveness&amp; result = *liveness;
1103     m_bytecodeLiveness.add(codeBlock, WTFMove(liveness));
1104     return result;
1105 }
1106 
1107 FullBytecodeLiveness&amp; Graph::livenessFor(InlineCallFrame* inlineCallFrame)
1108 {
1109     return livenessFor(baselineCodeBlockFor(inlineCallFrame));
1110 }
1111 
1112 BytecodeKills&amp; Graph::killsFor(CodeBlock* codeBlock)
1113 {
1114     HashMap&lt;CodeBlock*, std::unique_ptr&lt;BytecodeKills&gt;&gt;::iterator iter = m_bytecodeKills.find(codeBlock);
1115     if (iter != m_bytecodeKills.end())
1116         return *iter-&gt;value;
1117 
<span class="line-modified">1118     std::unique_ptr&lt;BytecodeKills&gt; kills = makeUnique&lt;BytecodeKills&gt;();</span>
1119     codeBlock-&gt;livenessAnalysis().computeKills(codeBlock, *kills);
1120     BytecodeKills&amp; result = *kills;
1121     m_bytecodeKills.add(codeBlock, WTFMove(kills));
1122     return result;
1123 }
1124 
1125 BytecodeKills&amp; Graph::killsFor(InlineCallFrame* inlineCallFrame)
1126 {
1127     return killsFor(baselineCodeBlockFor(inlineCallFrame));
1128 }
1129 
1130 bool Graph::isLiveInBytecode(VirtualRegister operand, CodeOrigin codeOrigin)
1131 {
1132     static const bool verbose = false;
1133 
1134     if (verbose)
1135         dataLog(&quot;Checking of operand is live: &quot;, operand, &quot;\n&quot;);
1136     CodeOrigin* codeOriginPtr = &amp;codeOrigin;
1137     for (;;) {
1138         VirtualRegister reg = VirtualRegister(
1139             operand.offset() - codeOriginPtr-&gt;stackOffset());
1140 
1141         if (verbose)
1142             dataLog(&quot;reg = &quot;, reg, &quot;\n&quot;);
1143 
<span class="line-added">1144         auto* inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
1145         if (operand.offset() &lt; codeOriginPtr-&gt;stackOffset() + CallFrame::headerSizeInRegisters) {
1146             if (reg.isArgument()) {
1147                 RELEASE_ASSERT(reg.offset() &lt; CallFrame::headerSizeInRegisters);
1148 
<span class="line-modified">1149 </span>
<span class="line-added">1150                 if (inlineCallFrame-&gt;isClosureCall</span>
1151                     &amp;&amp; reg.offset() == CallFrameSlot::callee) {
1152                     if (verbose)
1153                         dataLog(&quot;Looks like a callee.\n&quot;);
1154                     return true;
1155                 }
1156 
<span class="line-modified">1157                 if (inlineCallFrame-&gt;isVarargs()</span>
1158                     &amp;&amp; reg.offset() == CallFrameSlot::argumentCount) {
1159                     if (verbose)
1160                         dataLog(&quot;Looks like the argument count.\n&quot;);
1161                     return true;
1162                 }
1163 
1164                 return false;
1165             }
1166 
1167             if (verbose)
1168                 dataLog(&quot;Asking the bytecode liveness.\n&quot;);
<span class="line-modified">1169             return livenessFor(inlineCallFrame).operandIsLive(reg.offset(), codeOriginPtr-&gt;bytecodeIndex());</span>

1170         }
1171 

1172         if (!inlineCallFrame) {
1173             if (verbose)
1174                 dataLog(&quot;Ran out of stack, returning true.\n&quot;);
1175             return true;
1176         }
1177 
1178         // Arguments are always live. This would be redundant if it wasn&#39;t for our
1179         // op_call_varargs inlining.
1180         if (reg.isArgument()
1181             &amp;&amp; static_cast&lt;size_t&gt;(reg.toArgument()) &lt; inlineCallFrame-&gt;argumentsWithFixup.size()) {
1182             if (verbose)
1183                 dataLog(&quot;Argument is live.\n&quot;);
1184             return true;
1185         }
1186 
<span class="line-modified">1187         // We need to handle tail callers because we may decide to exit to the</span>
<span class="line-modified">1188         // the return bytecode following the tail call.</span>
<span class="line-modified">1189         codeOriginPtr = &amp;inlineCallFrame-&gt;directCaller;</span>





1190     }
1191 
1192     RELEASE_ASSERT_NOT_REACHED();
1193 }
1194 
1195 BitVector Graph::localsLiveInBytecode(CodeOrigin codeOrigin)
1196 {
1197     BitVector result;
1198     result.ensureSize(block(0)-&gt;variablesAtHead.numberOfLocals());
1199     forAllLocalsLiveInBytecode(
1200         codeOrigin,
1201         [&amp;] (VirtualRegister reg) {
1202             ASSERT(reg.isLocal());
1203             result.quickSet(reg.toLocal());
1204         });
1205     return result;
1206 }
1207 
1208 unsigned Graph::parameterSlotsForArgCount(unsigned argCount)
1209 {
</pre>
<hr />
<pre>
1536 {
1537     logDFGAssertionFailure(*this, &quot;&quot;, file, line, function, assertion);
1538 }
1539 
1540 void Graph::logAssertionFailure(
1541     Node* node, const char* file, int line, const char* function, const char* assertion)
1542 {
1543     logDFGAssertionFailure(*this, toCString(&quot;While handling node &quot;, node, &quot;\n\n&quot;), file, line, function, assertion);
1544 }
1545 
1546 void Graph::logAssertionFailure(
1547     BasicBlock* block, const char* file, int line, const char* function, const char* assertion)
1548 {
1549     logDFGAssertionFailure(*this, toCString(&quot;While handling block &quot;, pointerDump(block), &quot;\n\n&quot;), file, line, function, assertion);
1550 }
1551 
1552 CPSCFG&amp; Graph::ensureCPSCFG()
1553 {
1554     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1555     if (!m_cpsCFG)
<span class="line-modified">1556         m_cpsCFG = makeUnique&lt;CPSCFG&gt;(*this);</span>
1557     return *m_cpsCFG;
1558 }
1559 
1560 CPSDominators&amp; Graph::ensureCPSDominators()
1561 {
1562     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1563     if (!m_cpsDominators)
<span class="line-modified">1564         m_cpsDominators = makeUnique&lt;CPSDominators&gt;(*this);</span>
1565     return *m_cpsDominators;
1566 }
1567 
1568 SSADominators&amp; Graph::ensureSSADominators()
1569 {
1570     RELEASE_ASSERT(m_form == SSA || m_isInSSAConversion);
1571     if (!m_ssaDominators)
<span class="line-modified">1572         m_ssaDominators = makeUnique&lt;SSADominators&gt;(*this);</span>
1573     return *m_ssaDominators;
1574 }
1575 
1576 CPSNaturalLoops&amp; Graph::ensureCPSNaturalLoops()
1577 {
1578     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1579     ensureCPSDominators();
1580     if (!m_cpsNaturalLoops)
<span class="line-modified">1581         m_cpsNaturalLoops = makeUnique&lt;CPSNaturalLoops&gt;(*this);</span>
1582     return *m_cpsNaturalLoops;
1583 }
1584 
1585 SSANaturalLoops&amp; Graph::ensureSSANaturalLoops()
1586 {
1587     RELEASE_ASSERT(m_form == SSA);
1588     ensureSSADominators();
1589     if (!m_ssaNaturalLoops)
<span class="line-modified">1590         m_ssaNaturalLoops = makeUnique&lt;SSANaturalLoops&gt;(*this);</span>
1591     return *m_ssaNaturalLoops;
1592 }
1593 
1594 BackwardsCFG&amp; Graph::ensureBackwardsCFG()
1595 {
1596     // We could easily relax this in the future to work over CPS, but today, it&#39;s only used in SSA.
1597     RELEASE_ASSERT(m_form == SSA);
1598     if (!m_backwardsCFG)
<span class="line-modified">1599         m_backwardsCFG = makeUnique&lt;BackwardsCFG&gt;(*this);</span>
1600     return *m_backwardsCFG;
1601 }
1602 
1603 BackwardsDominators&amp; Graph::ensureBackwardsDominators()
1604 {
1605     RELEASE_ASSERT(m_form == SSA);
1606     if (!m_backwardsDominators)
<span class="line-modified">1607         m_backwardsDominators = makeUnique&lt;BackwardsDominators&gt;(*this);</span>
1608     return *m_backwardsDominators;
1609 }
1610 
1611 ControlEquivalenceAnalysis&amp; Graph::ensureControlEquivalenceAnalysis()
1612 {
1613     RELEASE_ASSERT(m_form == SSA);
1614     if (!m_controlEquivalenceAnalysis)
<span class="line-modified">1615         m_controlEquivalenceAnalysis = makeUnique&lt;ControlEquivalenceAnalysis&gt;(*this);</span>
1616     return *m_controlEquivalenceAnalysis;
1617 }
1618 
1619 MethodOfGettingAValueProfile Graph::methodOfGettingAValueProfileFor(Node* currentNode, Node* operandNode)
1620 {
1621     // This represents IR like `CurrentNode(@operandNode)`. For example: `GetByVal(..., Int32:@GetLocal)`.
1622 
1623     for (Node* node = operandNode; node;) {
1624         // currentNode is null when we&#39;re doing speculation checks for checkArgumentTypes().
1625         if (!currentNode || node-&gt;origin.semantic != currentNode-&gt;origin.semantic || !currentNode-&gt;hasResult()) {
1626             CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);
1627 
1628             if (node-&gt;accessesStack(*this)) {
1629                 if (m_form != SSA &amp;&amp; node-&gt;local().isArgument()) {
1630                     int argument = node-&gt;local().toArgument();
1631                     Node* argumentNode = m_rootToArguments.find(block(0))-&gt;value[argument];
<span class="line-modified">1632                     // FIXME: We should match SetArgumentDefinitely nodes at other entrypoints as well:</span>
1633                     // https://bugs.webkit.org/show_bug.cgi?id=175841
1634                     if (argumentNode &amp;&amp; node-&gt;variableAccessData() == argumentNode-&gt;variableAccessData())
1635                         return &amp;profiledBlock-&gt;valueProfileForArgument(argument);
1636                 }
1637 
1638                 if (node-&gt;op() == GetLocal) {
1639                     return MethodOfGettingAValueProfile::fromLazyOperand(
1640                         profiledBlock,
1641                         LazyOperandValueProfileKey(
<span class="line-modified">1642                             node-&gt;origin.semantic.bytecodeIndex(), node-&gt;local()));</span>
1643                 }
1644             }
1645 
1646             if (node-&gt;hasHeapPrediction())
<span class="line-modified">1647                 return &amp;profiledBlock-&gt;valueProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex());</span>
1648 
1649             if (profiledBlock-&gt;hasBaselineJITProfiling()) {
<span class="line-modified">1650                 if (ArithProfile* result = profiledBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex()))</span>
1651                     return result;
1652             }
1653         }
1654 
1655         switch (node-&gt;op()) {
1656         case BooleanToNumber:
1657         case Identity:
1658         case ValueRep:
1659         case DoubleRep:
1660         case Int52Rep:
1661             node = node-&gt;child1().node();
1662             break;
1663         default:
1664             node = nullptr;
1665         }
1666     }
1667 
1668     return MethodOfGettingAValueProfile();
1669 }
1670 
</pre>
<hr />
<pre>
1708     JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, equivalenceCondition.condition().requiredValue());
1709     if (!function)
1710         return false;
1711 
1712     if (function-&gt;executable()-&gt;intrinsicFor(CodeForCall) != StringPrototypeValueOfIntrinsic)
1713         return false;
1714 
1715     return watchConditions(conditions);
1716 }
1717 
1718 
1719 bool Graph::canOptimizeStringObjectAccess(const CodeOrigin&amp; codeOrigin)
1720 {
1721     if (hasExitSite(codeOrigin, BadCache) || hasExitSite(codeOrigin, BadConstantCache))
1722         return false;
1723 
1724     JSGlobalObject* globalObject = globalObjectFor(codeOrigin);
1725     Structure* stringObjectStructure = globalObjectFor(codeOrigin)-&gt;stringObjectStructure();
1726     registerStructure(stringObjectStructure);
1727     ASSERT(stringObjectStructure-&gt;storedPrototype().isObject());
<span class="line-modified">1728     ASSERT(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;classInfo(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;vm()) == StringPrototype::info());</span>
1729 
1730     if (!watchConditions(generateConditionsForPropertyMissConcurrently(m_vm, globalObject, stringObjectStructure, m_vm.propertyNames-&gt;toPrimitiveSymbol.impl())))
1731         return false;
1732 
1733     // We&#39;re being conservative here. We want DFG&#39;s ToString on StringObject to be
1734     // used in both numeric contexts (that would call valueOf()) and string contexts
1735     // (that would call toString()). We don&#39;t want the DFG to have to distinguish
1736     // between the two, just because that seems like it would get confusing. So we
1737     // just require both methods to be sane.
1738     if (!isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;valueOf.impl()))
1739         return false;
1740     return isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;toString.impl());
1741 }
1742 
1743 bool Graph::willCatchExceptionInMachineFrame(CodeOrigin codeOrigin, CodeOrigin&amp; opCatchOriginOut, HandlerInfo*&amp; catchHandlerOut)
1744 {
1745     if (!m_hasExceptionHandlers)
1746         return false;
1747 
<span class="line-modified">1748     unsigned bytecodeIndexToCheck = codeOrigin.bytecodeIndex();</span>
1749     while (1) {
<span class="line-modified">1750         InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame();</span>
1751         CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);
1752         if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeOffset(bytecodeIndexToCheck)) {
1753             opCatchOriginOut = CodeOrigin(handler-&gt;target, inlineCallFrame);
1754             catchHandlerOut = handler;
1755             return true;
1756         }
1757 
1758         if (!inlineCallFrame)
1759             return false;
1760 
<span class="line-modified">1761         bytecodeIndexToCheck = inlineCallFrame-&gt;directCaller.bytecodeIndex();</span>
<span class="line-modified">1762         codeOrigin = inlineCallFrame-&gt;directCaller;</span>
1763     }
1764 
1765     RELEASE_ASSERT_NOT_REACHED();
1766 }
1767 
1768 bool Graph::canDoFastSpread(Node* node, const AbstractValue&amp; value)
1769 {
1770     // The parameter &#39;value&#39; is the AbstractValue for child1 (the thing being spread).
1771     ASSERT(node-&gt;op() == Spread);
1772 
1773     if (node-&gt;child1().useKind() != ArrayUse) {
1774         // Note: we only speculate on ArrayUse when we&#39;ve set up the necessary watchpoints
1775         // to prove that the iteration protocol is non-observable starting from ArrayPrototype.
1776         return false;
1777     }
1778 
1779     // FIXME: We should add profiling of the incoming operand to Spread
1780     // so we can speculate in such a way that we guarantee that this
1781     // function would return true:
1782     // https://bugs.webkit.org/show_bug.cgi?id=171198
</pre>
<hr />
<pre>
1787     ArrayPrototype* arrayPrototype = globalObjectFor(node-&gt;child1()-&gt;origin.semantic)-&gt;arrayPrototype();
1788     bool allGood = true;
1789     value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
1790         allGood &amp;= structure-&gt;hasMonoProto()
1791             &amp;&amp; structure-&gt;storedPrototype() == arrayPrototype
1792             &amp;&amp; !structure-&gt;isDictionary()
1793             &amp;&amp; structure-&gt;getConcurrently(m_vm.propertyNames-&gt;iteratorSymbol.impl()) == invalidOffset
1794             &amp;&amp; !structure-&gt;mayInterceptIndexedAccesses();
1795     });
1796 
1797     return allGood;
1798 }
1799 
1800 void Graph::clearCPSCFGData()
1801 {
1802     m_cpsNaturalLoops = nullptr;
1803     m_cpsDominators = nullptr;
1804     m_cpsCFG = nullptr;
1805 }
1806 
<span class="line-added">1807 void Prefix::dump(PrintStream&amp; out) const</span>
<span class="line-added">1808 {</span>
<span class="line-added">1809     if (!m_enabled)</span>
<span class="line-added">1810         return;</span>
<span class="line-added">1811 </span>
<span class="line-added">1812     if (!noHeader) {</span>
<span class="line-added">1813         if (nodeIndex &gt;= 0)</span>
<span class="line-added">1814             out.printf(&quot;%3d &quot;, nodeIndex);</span>
<span class="line-added">1815         else</span>
<span class="line-added">1816             out.printf(&quot;    &quot;);</span>
<span class="line-added">1817 </span>
<span class="line-added">1818         if (blockIndex &gt;= 0)</span>
<span class="line-added">1819             out.printf(&quot;%2d &quot;, blockIndex);</span>
<span class="line-added">1820         else</span>
<span class="line-added">1821             out.printf(&quot;   &quot;);</span>
<span class="line-added">1822 </span>
<span class="line-added">1823         if (phaseNumber &gt;= 0)</span>
<span class="line-added">1824             out.printf(&quot;%2d: &quot;, phaseNumber);</span>
<span class="line-added">1825         else</span>
<span class="line-added">1826             out.printf(&quot;  : &quot;);</span>
<span class="line-added">1827     }</span>
<span class="line-added">1828     if (prefixStr)</span>
<span class="line-added">1829         out.printf(&quot;%s&quot;, prefixStr);</span>
<span class="line-added">1830 }</span>
<span class="line-added">1831 </span>
1832 } } // namespace JSC::DFG
1833 
1834 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGGenerationInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>