<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/Database.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMWindowWebDatabase.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Database.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/Database.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
176     // Map empty string to null string (see comment above).
177     guidToVersionMap().set(guid, newVersion.isEmpty() ? String() : newVersion.isolatedCopy());
178 }
179 
180 static HashMap&lt;DatabaseGUID, HashSet&lt;Database*&gt;&gt;&amp; guidToDatabaseMap()
181 {
182     static NeverDestroyed&lt;HashMap&lt;DatabaseGUID, HashSet&lt;Database*&gt;&gt;&gt; map;
183     return map;
184 }
185 
186 static inline DatabaseGUID guidForOriginAndName(const String&amp; origin, const String&amp; name)
187 {
188     static NeverDestroyed&lt;HashMap&lt;String, DatabaseGUID&gt;&gt; map;
189     return map.get().ensure(makeString(origin, &#39;/&#39;, name), [] {
190         static DatabaseGUID lastUsedGUID;
191         return ++lastUsedGUID;
192     }).iterator-&gt;value;
193 }
194 
195 Database::Database(DatabaseContext&amp; context, const String&amp; name, const String&amp; expectedVersion, const String&amp; displayName, unsigned long long estimatedSize)
<span class="line-modified">196     : m_scriptExecutionContext(*context.scriptExecutionContext())</span>
<span class="line-modified">197     , m_contextThreadSecurityOrigin(m_scriptExecutionContext-&gt;securityOrigin()-&gt;isolatedCopy())</span>
<span class="line-modified">198     , m_databaseThreadSecurityOrigin(m_scriptExecutionContext-&gt;securityOrigin()-&gt;isolatedCopy())</span>
199     , m_databaseContext(context)
200     , m_name((name.isNull() ? emptyString() : name).isolatedCopy())
201     , m_expectedVersion(expectedVersion.isolatedCopy())
202     , m_displayName(displayName.isolatedCopy())
203     , m_estimatedSize(estimatedSize)
<span class="line-modified">204     , m_filename(DatabaseManager::singleton().fullPathForDatabase(*m_scriptExecutionContext-&gt;securityOrigin(), m_name))</span>
205     , m_databaseAuthorizer(DatabaseAuthorizer::create(unqualifiedInfoTableName))
206 {
207     {
208         std::lock_guard&lt;Lock&gt; locker(guidMutex);
209 
210         m_guid = guidForOriginAndName(securityOrigin().securityOrigin()-&gt;toString(), name);
211         guidToDatabaseMap().ensure(m_guid, [] {
212             return HashSet&lt;Database*&gt;();
213         }).iterator-&gt;value.add(this);
214     }
215 
216     m_databaseContext-&gt;databaseThread();
217 
218     ASSERT(m_databaseContext-&gt;existingDatabaseThread());
219 }
220 
221 DatabaseThread&amp; Database::databaseThread()
222 {
223     ASSERT(m_databaseContext-&gt;existingDatabaseThread());
224     return *m_databaseContext-&gt;existingDatabaseThread();
225 }
226 
227 Database::~Database()
228 {
<span class="line-modified">229     // The reference to the ScriptExecutionContext needs to be cleared on the JavaScript thread.  If we&#39;re on that thread already, we can just let the RefPtr&#39;s destruction do the dereffing.</span>
<span class="line-modified">230     if (!m_scriptExecutionContext-&gt;isContextThread()) {</span>
<span class="line-modified">231         auto passedContext = WTFMove(m_scriptExecutionContext);</span>
<span class="line-removed">232         auto&amp; contextRef = passedContext.get();</span>
<span class="line-removed">233         contextRef.postTask({ScriptExecutionContext::Task::CleanupTask, [passedContext = WTFMove(passedContext), databaseContext = WTFMove(m_databaseContext)] (ScriptExecutionContext&amp; context) {</span>
<span class="line-removed">234             ASSERT_UNUSED(context, &amp;context == passedContext.ptr());</span>
<span class="line-removed">235         }});</span>
<span class="line-removed">236     }</span>
237 
238     // SQLite is &quot;multi-thread safe&quot;, but each database handle can only be used
239     // on a single thread at a time.
240     //
241     // For DatabaseBackend, we open the SQLite database on the DatabaseThread,
242     // and hence we should also close it on that same thread. This means that the
243     // SQLite database need to be closed by another mechanism (see
244     // DatabaseContext::stopDatabases()). By the time we get here, the SQLite
245     // database should have already been closed.
246 
247     ASSERT(!m_opened);
248 }
249 
250 ExceptionOr&lt;void&gt; Database::openAndVerifyVersion(bool setVersionInNewDatabase)
251 {
252     DatabaseTaskSynchronizer synchronizer;
253     auto&amp; thread = databaseThread();
254     if (thread.terminationRequested(&amp;synchronizer))
255         return Exception { InvalidStateError };
256 
257     ExceptionOr&lt;void&gt; result;
<span class="line-modified">258     auto task = std::make_unique&lt;DatabaseOpenTask&gt;(*this, setVersionInNewDatabase, synchronizer, result);</span>
259     thread.scheduleImmediateTask(WTFMove(task));
260     synchronizer.waitForTaskCompletion();
261 
262     return result;
263 }
264 
265 void Database::interrupt()
266 {
267     // It is safe to call this from any thread for an opened or closed database.
268     m_sqliteDatabase.interrupt();
269 }
270 
271 void Database::close()
272 {
273     auto&amp; thread = databaseThread();
274 
275     DatabaseTaskSynchronizer synchronizer;
276     if (thread.terminationRequested(&amp;synchronizer)) {
277         LOG(StorageAPI, &quot;Database handle %p is on a terminated DatabaseThread, cannot be marked for normal closure\n&quot;, this);
278         return;
279     }
280 
<span class="line-modified">281     thread.scheduleImmediateTask(std::make_unique&lt;DatabaseCloseTask&gt;(*this, synchronizer));</span>
282 
283     // FIXME: iOS depends on this function blocking until the database is closed as part
284     // of closing all open databases from a process assertion expiration handler.
285     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=157184&gt;.
286     synchronizer.waitForTaskCompletion();
287 }
288 
289 void Database::performClose()
290 {
291     ASSERT(databaseThread().getThread() == &amp;Thread::current());
292 
293     {
294         LockHolder locker(m_transactionInProgressMutex);
295 
296         // Clean up transactions that have not been scheduled yet:
297         // Transaction phase 1 cleanup. See comment on &quot;What happens if a
298         // transaction is interrupted?&quot; at the top of SQLTransactionBackend.cpp.
299         while (!m_transactionQueue.isEmpty())
300             m_transactionQueue.takeFirst()-&gt;notifyDatabaseThreadIsShuttingDown();
301 
</pre>
<hr />
<pre>
331 
332 private:
333     Database&amp; m_database;
334 };
335 
336 ExceptionOr&lt;void&gt; Database::performOpenAndVerify(bool shouldSetVersionInNewDatabase)
337 {
338     DoneCreatingDatabaseOnExitCaller onExitCaller(*this);
339 
340     const int maxSqliteBusyWaitTime = 30000;
341 
342 #if PLATFORM(IOS_FAMILY)
343     {
344         // Make sure we wait till the background removal of the empty database files finished before trying to open any database.
345         auto locker = holdLock(DatabaseTracker::openDatabaseMutex());
346     }
347 #endif
348 
349     SQLiteTransactionInProgressAutoCounter transactionCounter;
350 
<span class="line-modified">351     if (!m_sqliteDatabase.open(m_filename, true))</span>
352         return Exception { InvalidStateError, formatErrorMessage(&quot;unable to open database&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg()) };
353     if (!m_sqliteDatabase.turnOnIncrementalAutoVacuum())
354         LOG_ERROR(&quot;Unable to turn on incremental auto-vacuum (%d %s)&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg());
355 
356     m_sqliteDatabase.setBusyTimeout(maxSqliteBusyWaitTime);
357 
358     String currentVersion;
359     {
360         std::lock_guard&lt;Lock&gt; locker(guidMutex);
361 
362         auto entry = guidToVersionMap().find(m_guid);
363         if (entry != guidToVersionMap().end()) {
364             // Map null string to empty string (see updateGUIDVersionMap()).
365             currentVersion = entry-&gt;value.isNull() ? emptyString() : entry-&gt;value.isolatedCopy();
366             LOG(StorageAPI, &quot;Current cached version for guid %i is %s&quot;, m_guid, currentVersion.ascii().data());
367         } else {
368             LOG(StorageAPI, &quot;No cached version for guid %i&quot;, m_guid);
369 
370             SQLiteTransaction transaction(m_sqliteDatabase);
371             transaction.begin();
</pre>
<hr />
<pre>
520 {
521     ASSERT(m_sqliteDatabase.transactionInProgress());
522 
523     // Note: In multi-process browsers the cached value may be inaccurate.
524     // So we retrieve the value from the database and update the cached value here.
525     return getVersionFromDatabase(actualVersion, true);
526 }
527 
528 void Database::scheduleTransaction()
529 {
530     ASSERT(!m_transactionInProgressMutex.tryLock()); // Locked by caller.
531 
532     if (!m_isTransactionQueueEnabled || m_transactionQueue.isEmpty()) {
533         m_transactionInProgress = false;
534         return;
535     }
536 
537     m_transactionInProgress = true;
538 
539     auto transaction = m_transactionQueue.takeFirst();
<span class="line-modified">540     auto task = std::make_unique&lt;DatabaseTransactionTask&gt;(WTFMove(transaction));</span>
541     LOG(StorageAPI, &quot;Scheduling DatabaseTransactionTask %p for transaction %p\n&quot;, task.get(), task-&gt;transaction());
542     databaseThread().scheduleTask(WTFMove(task));
543 }
544 
545 void Database::scheduleTransactionStep(SQLTransaction&amp; transaction)
546 {
547     auto&amp; thread = databaseThread();
548 
<span class="line-modified">549     auto task = std::make_unique&lt;DatabaseTransactionTask&gt;(&amp;transaction);</span>
550     LOG(StorageAPI, &quot;Scheduling DatabaseTransactionTask %p for the transaction step\n&quot;, task.get());
551     thread.scheduleTask(WTFMove(task));
552 }
553 
554 void Database::inProgressTransactionCompleted()
555 {
556     LockHolder locker(m_transactionInProgressMutex);
557     m_transactionInProgress = false;
558     scheduleTransaction();
559 }
560 
561 bool Database::hasPendingTransaction()
562 {
563     LockHolder locker(m_transactionInProgressMutex);
564     return m_transactionInProgress || !m_transactionQueue.isEmpty();
565 }
566 
567 SQLTransactionCoordinator* Database::transactionCoordinator()
568 {
569     return databaseThread().transactionCoordinator();
570 }
571 
572 String Database::version() const
573 {
574     if (m_deleted)
575         return String();
576 
577     // Note: In multi-process browsers the cached value may be accurate, but we cannot read the
578     // actual version from the database without potentially inducing a deadlock.
579     // FIXME: Add an async version getter to the DatabaseAPI.
580     return getCachedVersion();
581 }
582 
583 void Database::markAsDeletedAndClose()
584 {
585     if (m_deleted)
586         return;
587 
<span class="line-modified">588     LOG(StorageAPI, &quot;Marking %s (%p) as deleted&quot;, stringIdentifier().ascii().data(), this);</span>
589     m_deleted = true;
590 
591     close();
592 }
593 
594 void Database::changeVersion(const String&amp; oldVersion, const String&amp; newVersion, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
595 {
596     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), ChangeVersionWrapper::create(oldVersion, newVersion), false);
597 }
598 
599 void Database::transaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
600 {
601     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), nullptr, false);
602 }
603 
604 void Database::readTransaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
605 {
606     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), nullptr, true);
607 }
608 
<span class="line-modified">609 String Database::stringIdentifier() const</span>
610 {
611     // Return a deep copy for ref counting thread safety
612     return m_name.isolatedCopy();
613 }
614 
<span class="line-modified">615 String Database::displayName() const</span>
616 {
617     // Return a deep copy for ref counting thread safety
618     return m_displayName.isolatedCopy();
619 }
620 






621 unsigned long long Database::estimatedSize() const
622 {
623     return m_estimatedSize;
624 }
625 
626 void Database::setEstimatedSize(unsigned long long estimatedSize)
627 {
628     m_estimatedSize = estimatedSize;
629     DatabaseTracker::singleton().setDatabaseDetails(securityOrigin(), m_name, m_displayName, m_estimatedSize);
630 }
631 
<span class="line-modified">632 String Database::fileName() const</span>
633 {
634     // Return a deep copy for ref counting thread safety
635     return m_filename.isolatedCopy();
636 }
637 
638 DatabaseDetails Database::details() const
639 {
640     // This code path is only used for database quota delegate calls, so file dates are irrelevant and left uninitialized.
<span class="line-modified">641     return DatabaseDetails(stringIdentifier(), displayName(), estimatedSize(), 0, WTF::nullopt, WTF::nullopt);</span>
642 }
643 
644 void Database::disableAuthorizer()
645 {
646     m_databaseAuthorizer-&gt;disable();
647 }
648 
649 void Database::enableAuthorizer()
650 {
651     m_databaseAuthorizer-&gt;enable();
652 }
653 
654 void Database::setAuthorizerPermissions(int permissions)
655 {
656     m_databaseAuthorizer-&gt;setPermissions(permissions);
657 }
658 
659 bool Database::lastActionChangedDatabase()
660 {
661     return m_databaseAuthorizer-&gt;lastActionChangedDatabase();
</pre>
<hr />
<pre>
669 void Database::resetDeletes()
670 {
671     m_databaseAuthorizer-&gt;resetDeletes();
672 }
673 
674 bool Database::hadDeletes()
675 {
676     return m_databaseAuthorizer-&gt;hadDeletes();
677 }
678 
679 void Database::resetAuthorizer()
680 {
681     m_databaseAuthorizer-&gt;reset();
682 }
683 
684 void Database::runTransaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
685 {
686     LockHolder locker(m_transactionInProgressMutex);
687     if (!m_isTransactionQueueEnabled) {
688         if (errorCallback) {
<span class="line-modified">689             RefPtr&lt;SQLTransactionErrorCallback&gt; errorCallbackProtector = WTFMove(errorCallback);</span>
<span class="line-modified">690             m_scriptExecutionContext-&gt;postTask([errorCallbackProtector](ScriptExecutionContext&amp;) {</span>
<span class="line-removed">691                 errorCallbackProtector-&gt;handleEvent(SQLError::create(SQLError::UNKNOWN_ERR, &quot;database has been closed&quot;));</span>
692             });
693         }
694         return;
695     }
696 
697     m_transactionQueue.append(SQLTransaction::create(*this, WTFMove(callback), WTFMove(successCallback), errorCallback.copyRef(), WTFMove(wrapper), readOnly));
698     if (!m_transactionInProgress)
699         scheduleTransaction();
700 }
701 
702 void Database::scheduleTransactionCallback(SQLTransaction* transaction)
703 {
<span class="line-modified">704     RefPtr&lt;SQLTransaction&gt; transactionProtector(transaction);</span>
<span class="line-modified">705     m_scriptExecutionContext-&gt;postTask([transactionProtector] (ScriptExecutionContext&amp;) {</span>
<span class="line-removed">706         transactionProtector-&gt;performPendingCallback();</span>
707     });
708 }
709 
710 Vector&lt;String&gt; Database::performGetTableNames()
711 {
712     disableAuthorizer();
713 
714     SQLiteStatement statement(sqliteDatabase(), &quot;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;;&quot;);
715     if (statement.prepare() != SQLITE_OK) {
716         LOG_ERROR(&quot;Unable to retrieve list of tables for database %s&quot;, databaseDebugName().ascii().data());
717         enableAuthorizer();
718         return Vector&lt;String&gt;();
719     }
720 
721     Vector&lt;String&gt; tableNames;
722     int result;
723     while ((result = statement.step()) == SQLITE_ROW) {
724         String name = statement.getColumnText(0);
725         if (name != unqualifiedInfoTableName)
726             tableNames.append(name);
</pre>
<hr />
<pre>
734     }
735 
736     return tableNames;
737 }
738 
739 void Database::incrementalVacuumIfNeeded()
740 {
741     SQLiteTransactionInProgressAutoCounter transactionCounter;
742 
743     int64_t freeSpaceSize = m_sqliteDatabase.freeSpaceSize();
744     int64_t totalSize = m_sqliteDatabase.totalSize();
745     if (totalSize &lt;= 10 * freeSpaceSize) {
746         int result = m_sqliteDatabase.runIncrementalVacuumCommand();
747         if (result != SQLITE_OK)
748             logErrorMessage(formatErrorMessage(&quot;error vacuuming database&quot;, result, m_sqliteDatabase.lastErrorMsg()));
749     }
750 }
751 
752 void Database::logErrorMessage(const String&amp; message)
753 {
<span class="line-modified">754     m_scriptExecutionContext-&gt;addConsoleMessage(MessageSource::Storage, MessageLevel::Error, message);</span>
755 }
756 
757 Vector&lt;String&gt; Database::tableNames()
758 {
759     // FIXME: Not using isolatedCopy on these strings looks ok since threads take strict turns
760     // in dealing with them. However, if the code changes, this may not be true anymore.
761     Vector&lt;String&gt; result;
762     DatabaseTaskSynchronizer synchronizer;
763     auto&amp; thread = databaseThread();
764     if (thread.terminationRequested(&amp;synchronizer))
765         return result;
766 
<span class="line-modified">767     auto task = std::make_unique&lt;DatabaseTableNamesTask&gt;(*this, synchronizer, result);</span>
768     thread.scheduleImmediateTask(WTFMove(task));
769     synchronizer.waitForTaskCompletion();
770 
771     return result;
772 }
773 
774 SecurityOriginData Database::securityOrigin()
775 {
<span class="line-modified">776     if (m_scriptExecutionContext-&gt;isContextThread())</span>
777         return m_contextThreadSecurityOrigin-&gt;data();
778     if (databaseThread().getThread() == &amp;Thread::current())
779         return m_databaseThreadSecurityOrigin-&gt;data();
780     RELEASE_ASSERT_NOT_REACHED();
781 }
782 
783 unsigned long long Database::maximumSize()
784 {
785     return DatabaseTracker::singleton().maximumSize(*this);
786 }
787 
788 void Database::didCommitWriteTransaction()
789 {
<span class="line-modified">790     DatabaseTracker::singleton().scheduleNotifyDatabaseChanged(securityOrigin(), stringIdentifier());</span>
791 }
792 
793 bool Database::didExceedQuota()
794 {
<span class="line-modified">795     ASSERT(databaseContext().scriptExecutionContext()-&gt;isContextThread());</span>
796     auto&amp; tracker = DatabaseTracker::singleton();
797     auto oldQuota = tracker.quota(securityOrigin());
798     if (estimatedSize() &lt;= oldQuota) {
799         // The expected usage provided by the page is now smaller than the actual database size so we bump the expected usage to
800         // oldQuota + 5MB so that the client actually increases the quota.
801         setEstimatedSize(oldQuota + quotaIncreaseSize);
802     }
<span class="line-modified">803     databaseContext().databaseExceededQuota(stringIdentifier(), details());</span>
804     return tracker.quota(securityOrigin()) &gt; oldQuota;
805 }
806 
807 #if !LOG_DISABLED || !ERROR_DISABLED
808 
809 String Database::databaseDebugName() const
810 {
811     return m_contextThreadSecurityOrigin-&gt;toString() + &quot;::&quot; + m_name;
812 }
813 
814 #endif
815 
816 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
176     // Map empty string to null string (see comment above).
177     guidToVersionMap().set(guid, newVersion.isEmpty() ? String() : newVersion.isolatedCopy());
178 }
179 
180 static HashMap&lt;DatabaseGUID, HashSet&lt;Database*&gt;&gt;&amp; guidToDatabaseMap()
181 {
182     static NeverDestroyed&lt;HashMap&lt;DatabaseGUID, HashSet&lt;Database*&gt;&gt;&gt; map;
183     return map;
184 }
185 
186 static inline DatabaseGUID guidForOriginAndName(const String&amp; origin, const String&amp; name)
187 {
188     static NeverDestroyed&lt;HashMap&lt;String, DatabaseGUID&gt;&gt; map;
189     return map.get().ensure(makeString(origin, &#39;/&#39;, name), [] {
190         static DatabaseGUID lastUsedGUID;
191         return ++lastUsedGUID;
192     }).iterator-&gt;value;
193 }
194 
195 Database::Database(DatabaseContext&amp; context, const String&amp; name, const String&amp; expectedVersion, const String&amp; displayName, unsigned long long estimatedSize)
<span class="line-modified">196     : m_document(*context.document())</span>
<span class="line-modified">197     , m_contextThreadSecurityOrigin(m_document-&gt;securityOrigin().isolatedCopy())</span>
<span class="line-modified">198     , m_databaseThreadSecurityOrigin(m_document-&gt;securityOrigin().isolatedCopy())</span>
199     , m_databaseContext(context)
200     , m_name((name.isNull() ? emptyString() : name).isolatedCopy())
201     , m_expectedVersion(expectedVersion.isolatedCopy())
202     , m_displayName(displayName.isolatedCopy())
203     , m_estimatedSize(estimatedSize)
<span class="line-modified">204     , m_filename(DatabaseManager::singleton().fullPathForDatabase(m_document-&gt;securityOrigin(), m_name))</span>
205     , m_databaseAuthorizer(DatabaseAuthorizer::create(unqualifiedInfoTableName))
206 {
207     {
208         std::lock_guard&lt;Lock&gt; locker(guidMutex);
209 
210         m_guid = guidForOriginAndName(securityOrigin().securityOrigin()-&gt;toString(), name);
211         guidToDatabaseMap().ensure(m_guid, [] {
212             return HashSet&lt;Database*&gt;();
213         }).iterator-&gt;value.add(this);
214     }
215 
216     m_databaseContext-&gt;databaseThread();
217 
218     ASSERT(m_databaseContext-&gt;existingDatabaseThread());
219 }
220 
221 DatabaseThread&amp; Database::databaseThread()
222 {
223     ASSERT(m_databaseContext-&gt;existingDatabaseThread());
224     return *m_databaseContext-&gt;existingDatabaseThread();
225 }
226 
227 Database::~Database()
228 {
<span class="line-modified">229     // The reference to the Document needs to be cleared on the JavaScript thread. If we&#39;re on that thread already, we can just let the RefPtr&#39;s destruction do the dereffing.</span>
<span class="line-modified">230     if (!isMainThread())</span>
<span class="line-modified">231         callOnMainThread([document = WTFMove(m_document), databaseContext = WTFMove(m_databaseContext)] { });</span>





232 
233     // SQLite is &quot;multi-thread safe&quot;, but each database handle can only be used
234     // on a single thread at a time.
235     //
236     // For DatabaseBackend, we open the SQLite database on the DatabaseThread,
237     // and hence we should also close it on that same thread. This means that the
238     // SQLite database need to be closed by another mechanism (see
239     // DatabaseContext::stopDatabases()). By the time we get here, the SQLite
240     // database should have already been closed.
241 
242     ASSERT(!m_opened);
243 }
244 
245 ExceptionOr&lt;void&gt; Database::openAndVerifyVersion(bool setVersionInNewDatabase)
246 {
247     DatabaseTaskSynchronizer synchronizer;
248     auto&amp; thread = databaseThread();
249     if (thread.terminationRequested(&amp;synchronizer))
250         return Exception { InvalidStateError };
251 
252     ExceptionOr&lt;void&gt; result;
<span class="line-modified">253     auto task = makeUnique&lt;DatabaseOpenTask&gt;(*this, setVersionInNewDatabase, synchronizer, result);</span>
254     thread.scheduleImmediateTask(WTFMove(task));
255     synchronizer.waitForTaskCompletion();
256 
257     return result;
258 }
259 
260 void Database::interrupt()
261 {
262     // It is safe to call this from any thread for an opened or closed database.
263     m_sqliteDatabase.interrupt();
264 }
265 
266 void Database::close()
267 {
268     auto&amp; thread = databaseThread();
269 
270     DatabaseTaskSynchronizer synchronizer;
271     if (thread.terminationRequested(&amp;synchronizer)) {
272         LOG(StorageAPI, &quot;Database handle %p is on a terminated DatabaseThread, cannot be marked for normal closure\n&quot;, this);
273         return;
274     }
275 
<span class="line-modified">276     thread.scheduleImmediateTask(makeUnique&lt;DatabaseCloseTask&gt;(*this, synchronizer));</span>
277 
278     // FIXME: iOS depends on this function blocking until the database is closed as part
279     // of closing all open databases from a process assertion expiration handler.
280     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=157184&gt;.
281     synchronizer.waitForTaskCompletion();
282 }
283 
284 void Database::performClose()
285 {
286     ASSERT(databaseThread().getThread() == &amp;Thread::current());
287 
288     {
289         LockHolder locker(m_transactionInProgressMutex);
290 
291         // Clean up transactions that have not been scheduled yet:
292         // Transaction phase 1 cleanup. See comment on &quot;What happens if a
293         // transaction is interrupted?&quot; at the top of SQLTransactionBackend.cpp.
294         while (!m_transactionQueue.isEmpty())
295             m_transactionQueue.takeFirst()-&gt;notifyDatabaseThreadIsShuttingDown();
296 
</pre>
<hr />
<pre>
326 
327 private:
328     Database&amp; m_database;
329 };
330 
331 ExceptionOr&lt;void&gt; Database::performOpenAndVerify(bool shouldSetVersionInNewDatabase)
332 {
333     DoneCreatingDatabaseOnExitCaller onExitCaller(*this);
334 
335     const int maxSqliteBusyWaitTime = 30000;
336 
337 #if PLATFORM(IOS_FAMILY)
338     {
339         // Make sure we wait till the background removal of the empty database files finished before trying to open any database.
340         auto locker = holdLock(DatabaseTracker::openDatabaseMutex());
341     }
342 #endif
343 
344     SQLiteTransactionInProgressAutoCounter transactionCounter;
345 
<span class="line-modified">346     if (!m_sqliteDatabase.open(m_filename))</span>
347         return Exception { InvalidStateError, formatErrorMessage(&quot;unable to open database&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg()) };
348     if (!m_sqliteDatabase.turnOnIncrementalAutoVacuum())
349         LOG_ERROR(&quot;Unable to turn on incremental auto-vacuum (%d %s)&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg());
350 
351     m_sqliteDatabase.setBusyTimeout(maxSqliteBusyWaitTime);
352 
353     String currentVersion;
354     {
355         std::lock_guard&lt;Lock&gt; locker(guidMutex);
356 
357         auto entry = guidToVersionMap().find(m_guid);
358         if (entry != guidToVersionMap().end()) {
359             // Map null string to empty string (see updateGUIDVersionMap()).
360             currentVersion = entry-&gt;value.isNull() ? emptyString() : entry-&gt;value.isolatedCopy();
361             LOG(StorageAPI, &quot;Current cached version for guid %i is %s&quot;, m_guid, currentVersion.ascii().data());
362         } else {
363             LOG(StorageAPI, &quot;No cached version for guid %i&quot;, m_guid);
364 
365             SQLiteTransaction transaction(m_sqliteDatabase);
366             transaction.begin();
</pre>
<hr />
<pre>
515 {
516     ASSERT(m_sqliteDatabase.transactionInProgress());
517 
518     // Note: In multi-process browsers the cached value may be inaccurate.
519     // So we retrieve the value from the database and update the cached value here.
520     return getVersionFromDatabase(actualVersion, true);
521 }
522 
523 void Database::scheduleTransaction()
524 {
525     ASSERT(!m_transactionInProgressMutex.tryLock()); // Locked by caller.
526 
527     if (!m_isTransactionQueueEnabled || m_transactionQueue.isEmpty()) {
528         m_transactionInProgress = false;
529         return;
530     }
531 
532     m_transactionInProgress = true;
533 
534     auto transaction = m_transactionQueue.takeFirst();
<span class="line-modified">535     auto task = makeUnique&lt;DatabaseTransactionTask&gt;(WTFMove(transaction));</span>
536     LOG(StorageAPI, &quot;Scheduling DatabaseTransactionTask %p for transaction %p\n&quot;, task.get(), task-&gt;transaction());
537     databaseThread().scheduleTask(WTFMove(task));
538 }
539 
540 void Database::scheduleTransactionStep(SQLTransaction&amp; transaction)
541 {
542     auto&amp; thread = databaseThread();
543 
<span class="line-modified">544     auto task = makeUnique&lt;DatabaseTransactionTask&gt;(&amp;transaction);</span>
545     LOG(StorageAPI, &quot;Scheduling DatabaseTransactionTask %p for the transaction step\n&quot;, task.get());
546     thread.scheduleTask(WTFMove(task));
547 }
548 
549 void Database::inProgressTransactionCompleted()
550 {
551     LockHolder locker(m_transactionInProgressMutex);
552     m_transactionInProgress = false;
553     scheduleTransaction();
554 }
555 
556 bool Database::hasPendingTransaction()
557 {
558     LockHolder locker(m_transactionInProgressMutex);
559     return m_transactionInProgress || !m_transactionQueue.isEmpty();
560 }
561 
562 SQLTransactionCoordinator* Database::transactionCoordinator()
563 {
564     return databaseThread().transactionCoordinator();
565 }
566 
567 String Database::version() const
568 {
569     if (m_deleted)
570         return String();
571 
572     // Note: In multi-process browsers the cached value may be accurate, but we cannot read the
573     // actual version from the database without potentially inducing a deadlock.
574     // FIXME: Add an async version getter to the DatabaseAPI.
575     return getCachedVersion();
576 }
577 
578 void Database::markAsDeletedAndClose()
579 {
580     if (m_deleted)
581         return;
582 
<span class="line-modified">583     LOG(StorageAPI, &quot;Marking %s (%p) as deleted&quot;, stringIdentifierIsolatedCopy().ascii().data(), this);</span>
584     m_deleted = true;
585 
586     close();
587 }
588 
589 void Database::changeVersion(const String&amp; oldVersion, const String&amp; newVersion, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
590 {
591     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), ChangeVersionWrapper::create(oldVersion, newVersion), false);
592 }
593 
594 void Database::transaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
595 {
596     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), nullptr, false);
597 }
598 
599 void Database::readTransaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
600 {
601     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), nullptr, true);
602 }
603 
<span class="line-modified">604 String Database::stringIdentifierIsolatedCopy() const</span>
605 {
606     // Return a deep copy for ref counting thread safety
607     return m_name.isolatedCopy();
608 }
609 
<span class="line-modified">610 String Database::displayNameIsolatedCopy() const</span>
611 {
612     // Return a deep copy for ref counting thread safety
613     return m_displayName.isolatedCopy();
614 }
615 
<span class="line-added">616 String Database::expectedVersionIsolatedCopy() const</span>
<span class="line-added">617 {</span>
<span class="line-added">618     // Return a deep copy for ref counting thread safety</span>
<span class="line-added">619     return m_expectedVersion.isolatedCopy();</span>
<span class="line-added">620 }</span>
<span class="line-added">621 </span>
622 unsigned long long Database::estimatedSize() const
623 {
624     return m_estimatedSize;
625 }
626 
627 void Database::setEstimatedSize(unsigned long long estimatedSize)
628 {
629     m_estimatedSize = estimatedSize;
630     DatabaseTracker::singleton().setDatabaseDetails(securityOrigin(), m_name, m_displayName, m_estimatedSize);
631 }
632 
<span class="line-modified">633 String Database::fileNameIsolatedCopy() const</span>
634 {
635     // Return a deep copy for ref counting thread safety
636     return m_filename.isolatedCopy();
637 }
638 
639 DatabaseDetails Database::details() const
640 {
641     // This code path is only used for database quota delegate calls, so file dates are irrelevant and left uninitialized.
<span class="line-modified">642     return DatabaseDetails(stringIdentifierIsolatedCopy(), displayNameIsolatedCopy(), estimatedSize(), 0, WTF::nullopt, WTF::nullopt);</span>
643 }
644 
645 void Database::disableAuthorizer()
646 {
647     m_databaseAuthorizer-&gt;disable();
648 }
649 
650 void Database::enableAuthorizer()
651 {
652     m_databaseAuthorizer-&gt;enable();
653 }
654 
655 void Database::setAuthorizerPermissions(int permissions)
656 {
657     m_databaseAuthorizer-&gt;setPermissions(permissions);
658 }
659 
660 bool Database::lastActionChangedDatabase()
661 {
662     return m_databaseAuthorizer-&gt;lastActionChangedDatabase();
</pre>
<hr />
<pre>
670 void Database::resetDeletes()
671 {
672     m_databaseAuthorizer-&gt;resetDeletes();
673 }
674 
675 bool Database::hadDeletes()
676 {
677     return m_databaseAuthorizer-&gt;hadDeletes();
678 }
679 
680 void Database::resetAuthorizer()
681 {
682     m_databaseAuthorizer-&gt;reset();
683 }
684 
685 void Database::runTransaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
686 {
687     LockHolder locker(m_transactionInProgressMutex);
688     if (!m_isTransactionQueueEnabled) {
689         if (errorCallback) {
<span class="line-modified">690             callOnMainThread([errorCallback = makeRef(*errorCallback)]() {</span>
<span class="line-modified">691                 errorCallback-&gt;handleEvent(SQLError::create(SQLError::UNKNOWN_ERR, &quot;database has been closed&quot;));</span>

692             });
693         }
694         return;
695     }
696 
697     m_transactionQueue.append(SQLTransaction::create(*this, WTFMove(callback), WTFMove(successCallback), errorCallback.copyRef(), WTFMove(wrapper), readOnly));
698     if (!m_transactionInProgress)
699         scheduleTransaction();
700 }
701 
702 void Database::scheduleTransactionCallback(SQLTransaction* transaction)
703 {
<span class="line-modified">704     callOnMainThread([transaction = makeRefPtr(transaction)] {</span>
<span class="line-modified">705         transaction-&gt;performPendingCallback();</span>

706     });
707 }
708 
709 Vector&lt;String&gt; Database::performGetTableNames()
710 {
711     disableAuthorizer();
712 
713     SQLiteStatement statement(sqliteDatabase(), &quot;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;;&quot;);
714     if (statement.prepare() != SQLITE_OK) {
715         LOG_ERROR(&quot;Unable to retrieve list of tables for database %s&quot;, databaseDebugName().ascii().data());
716         enableAuthorizer();
717         return Vector&lt;String&gt;();
718     }
719 
720     Vector&lt;String&gt; tableNames;
721     int result;
722     while ((result = statement.step()) == SQLITE_ROW) {
723         String name = statement.getColumnText(0);
724         if (name != unqualifiedInfoTableName)
725             tableNames.append(name);
</pre>
<hr />
<pre>
733     }
734 
735     return tableNames;
736 }
737 
738 void Database::incrementalVacuumIfNeeded()
739 {
740     SQLiteTransactionInProgressAutoCounter transactionCounter;
741 
742     int64_t freeSpaceSize = m_sqliteDatabase.freeSpaceSize();
743     int64_t totalSize = m_sqliteDatabase.totalSize();
744     if (totalSize &lt;= 10 * freeSpaceSize) {
745         int result = m_sqliteDatabase.runIncrementalVacuumCommand();
746         if (result != SQLITE_OK)
747             logErrorMessage(formatErrorMessage(&quot;error vacuuming database&quot;, result, m_sqliteDatabase.lastErrorMsg()));
748     }
749 }
750 
751 void Database::logErrorMessage(const String&amp; message)
752 {
<span class="line-modified">753     m_document-&gt;addConsoleMessage(MessageSource::Storage, MessageLevel::Error, message);</span>
754 }
755 
756 Vector&lt;String&gt; Database::tableNames()
757 {
758     // FIXME: Not using isolatedCopy on these strings looks ok since threads take strict turns
759     // in dealing with them. However, if the code changes, this may not be true anymore.
760     Vector&lt;String&gt; result;
761     DatabaseTaskSynchronizer synchronizer;
762     auto&amp; thread = databaseThread();
763     if (thread.terminationRequested(&amp;synchronizer))
764         return result;
765 
<span class="line-modified">766     auto task = makeUnique&lt;DatabaseTableNamesTask&gt;(*this, synchronizer, result);</span>
767     thread.scheduleImmediateTask(WTFMove(task));
768     synchronizer.waitForTaskCompletion();
769 
770     return result;
771 }
772 
773 SecurityOriginData Database::securityOrigin()
774 {
<span class="line-modified">775     if (isMainThread())</span>
776         return m_contextThreadSecurityOrigin-&gt;data();
777     if (databaseThread().getThread() == &amp;Thread::current())
778         return m_databaseThreadSecurityOrigin-&gt;data();
779     RELEASE_ASSERT_NOT_REACHED();
780 }
781 
782 unsigned long long Database::maximumSize()
783 {
784     return DatabaseTracker::singleton().maximumSize(*this);
785 }
786 
787 void Database::didCommitWriteTransaction()
788 {
<span class="line-modified">789     DatabaseTracker::singleton().scheduleNotifyDatabaseChanged(securityOrigin(), stringIdentifierIsolatedCopy());</span>
790 }
791 
792 bool Database::didExceedQuota()
793 {
<span class="line-modified">794     ASSERT(isMainThread());</span>
795     auto&amp; tracker = DatabaseTracker::singleton();
796     auto oldQuota = tracker.quota(securityOrigin());
797     if (estimatedSize() &lt;= oldQuota) {
798         // The expected usage provided by the page is now smaller than the actual database size so we bump the expected usage to
799         // oldQuota + 5MB so that the client actually increases the quota.
800         setEstimatedSize(oldQuota + quotaIncreaseSize);
801     }
<span class="line-modified">802     databaseContext().databaseExceededQuota(stringIdentifierIsolatedCopy(), details());</span>
803     return tracker.quota(securityOrigin()) &gt; oldQuota;
804 }
805 
806 #if !LOG_DISABLED || !ERROR_DISABLED
807 
808 String Database::databaseDebugName() const
809 {
810     return m_contextThreadSecurityOrigin-&gt;toString() + &quot;::&quot; + m_name;
811 }
812 
813 #endif
814 
815 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DOMWindowWebDatabase.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Database.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>