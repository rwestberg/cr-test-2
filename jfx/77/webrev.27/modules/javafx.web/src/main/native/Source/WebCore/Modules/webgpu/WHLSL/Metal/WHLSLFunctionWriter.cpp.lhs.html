<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;WHLSLArrayReferenceType.h&quot;</span>
<span class="line-modified"> 32 #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-removed"> 33 #include &quot;WHLSLAssignmentExpression.h&quot;</span>
<span class="line-removed"> 34 #include &quot;WHLSLBooleanLiteral.h&quot;</span>
<span class="line-removed"> 35 #include &quot;WHLSLBuiltInSemantic.h&quot;</span>
<span class="line-removed"> 36 #include &quot;WHLSLCallExpression.h&quot;</span>
<span class="line-removed"> 37 #include &quot;WHLSLCommaExpression.h&quot;</span>
<span class="line-removed"> 38 #include &quot;WHLSLDereferenceExpression.h&quot;</span>
<span class="line-removed"> 39 #include &quot;WHLSLDoWhileLoop.h&quot;</span>
<span class="line-removed"> 40 #include &quot;WHLSLEffectfulExpressionStatement.h&quot;</span>
 41 #include &quot;WHLSLEntryPointScaffolding.h&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 42 #include &quot;WHLSLEntryPointType.h&quot;</span>
<span class="line-removed"> 43 #include &quot;WHLSLFloatLiteral.h&quot;</span>
<span class="line-removed"> 44 #include &quot;WHLSLForLoop.h&quot;</span>
<span class="line-removed"> 45 #include &quot;WHLSLFunctionDeclaration.h&quot;</span>
<span class="line-removed"> 46 #include &quot;WHLSLFunctionDefinition.h&quot;</span>
<span class="line-removed"> 47 #include &quot;WHLSLIfStatement.h&quot;</span>
<span class="line-removed"> 48 #include &quot;WHLSLIntegerLiteral.h&quot;</span>
<span class="line-removed"> 49 #include &quot;WHLSLLogicalExpression.h&quot;</span>
<span class="line-removed"> 50 #include &quot;WHLSLLogicalNotExpression.h&quot;</span>
<span class="line-removed"> 51 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;</span>
<span class="line-removed"> 52 #include &quot;WHLSLMakePointerExpression.h&quot;</span>
<span class="line-removed"> 53 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;</span>
 54 #include &quot;WHLSLNativeFunctionWriter.h&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 55 #include &quot;WHLSLNativeTypeDeclaration.h&quot;</span>
<span class="line-removed"> 56 #include &quot;WHLSLPointerType.h&quot;</span>
 57 #include &quot;WHLSLProgram.h&quot;
<a name="4" id="anc4"></a><span class="line-removed"> 58 #include &quot;WHLSLReturn.h&quot;</span>
<span class="line-removed"> 59 #include &quot;WHLSLSwitchCase.h&quot;</span>
<span class="line-removed"> 60 #include &quot;WHLSLSwitchStatement.h&quot;</span>
<span class="line-removed"> 61 #include &quot;WHLSLTernaryExpression.h&quot;</span>
 62 #include &quot;WHLSLTypeNamer.h&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 63 #include &quot;WHLSLUnsignedIntegerLiteral.h&quot;</span>
<span class="line-removed"> 64 #include &quot;WHLSLVariableDeclaration.h&quot;</span>
<span class="line-removed"> 65 #include &quot;WHLSLVariableDeclarationsStatement.h&quot;</span>
<span class="line-removed"> 66 #include &quot;WHLSLVariableReference.h&quot;</span>
 67 #include &quot;WHLSLVisitor.h&quot;
<a name="6" id="anc6"></a><span class="line-removed"> 68 #include &quot;WHLSLWhileLoop.h&quot;</span>
 69 #include &lt;wtf/HashMap.h&gt;
<a name="7" id="anc7"></a>

 70 #include &lt;wtf/text/StringBuilder.h&gt;
 71 
 72 namespace WebCore {
 73 
 74 namespace WHLSL {
 75 
 76 namespace Metal {
 77 
<a name="8" id="anc8"></a><span class="line-modified"> 78 class FunctionDeclarationWriter : public Visitor {</span>
















 79 public:
<a name="9" id="anc9"></a><span class="line-modified"> 80     FunctionDeclarationWriter(TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; functionMapping)</span>
<span class="line-modified"> 81         : m_typeNamer(typeNamer)</span>


 82         , m_functionMapping(functionMapping)
<a name="10" id="anc10"></a>
 83     {
 84     }
 85 
<a name="11" id="anc11"></a><span class="line-modified"> 86     virtual ~FunctionDeclarationWriter() = default;</span>
 87 
<a name="12" id="anc12"></a><span class="line-modified"> 88     String toString() { return m_stringBuilder.toString(); }</span>
<span class="line-modified"> 89     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override</span>
<span class="line-modified"> 90     {</span>
<span class="line-modified"> 91         if (functionDeclaration.entryPointType())</span>
<span class="line-modified"> 92             return;</span>







































 93 
<a name="13" id="anc13"></a><span class="line-modified"> 94         auto iterator = m_functionMapping.find(&amp;functionDeclaration);</span>
<span class="line-modified"> 95         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified"> 96         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;));</span>
<span class="line-modified"> 97         for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {</span>
<span class="line-modified"> 98             if (i)</span>
<span class="line-removed"> 99                 m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-removed">100             m_stringBuilder.append(m_typeNamer.mangledNameForType(*functionDeclaration.parameters()[i].type()));</span>
<span class="line-removed">101         }</span>
<span class="line-removed">102         m_stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-removed">103     }</span>
104 
<a name="14" id="anc14"></a><span class="line-modified">105 private:</span>
<span class="line-removed">106     TypeNamer&amp; m_typeNamer;</span>
<span class="line-removed">107     HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; m_functionMapping;</span>
<span class="line-removed">108     StringBuilder m_stringBuilder;</span>
<span class="line-removed">109 };</span>
110 
<a name="15" id="anc15"></a><span class="line-modified">111 class FunctionDefinitionWriter : public Visitor {</span>
<span class="line-modified">112 public:</span>
<span class="line-modified">113     FunctionDefinitionWriter(Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; functionMapping)</span>
<span class="line-modified">114         : m_intrinsics(intrinsics)</span>
<span class="line-modified">115         , m_typeNamer(typeNamer)</span>
<span class="line-modified">116         , m_functionMapping(functionMapping)</span>




















117     {
<a name="16" id="anc16"></a>
118     }
119 
<a name="17" id="anc17"></a><span class="line-modified">120     virtual ~FunctionDefinitionWriter() = default;</span>
<span class="line-modified">121 </span>
<span class="line-modified">122     String toString() { return m_stringBuilder.toString(); }</span>

123 
<a name="18" id="anc18"></a><span class="line-modified">124     void visit(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration) override</span>
125     {
<a name="19" id="anc19"></a><span class="line-modified">126         auto iterator = m_functionMapping.find(&amp;nativeFunctionDeclaration);</span>
<span class="line-modified">127         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified">128         m_stringBuilder.append(writeNativeFunction(nativeFunctionDeclaration, iterator-&gt;value, m_typeNamer));</span>
129     }
130 
<a name="20" id="anc20"></a><span class="line-modified">131     void visit(AST::FunctionDefinition&amp; functionDefinition) override</span>
132     {
<a name="21" id="anc21"></a><span class="line-modified">133         auto iterator = m_functionMapping.find(&amp;functionDefinition);</span>
<span class="line-modified">134         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified">135         if (functionDefinition.entryPointType()) {</span>
<span class="line-modified">136             m_entryPointScaffolding = EntryPointScaffolding(functionDefinition, m_intrinsics);</span>
<span class="line-modified">137             m_stringBuilder.append(m_entryPointScaffolding-&gt;helperTypes());</span>
<span class="line-modified">138             m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">139             m_stringBuilder.append(makeString(m_entryPointScaffolding-&gt;signature(), &quot; {&quot;));</span>
<span class="line-modified">140             m_stringBuilder.append(m_entryPointScaffolding-&gt;unpack());</span>
<span class="line-modified">141             checkErrorAndVisit(functionDefinition.block());</span>
<span class="line-modified">142             ASSERT(m_stack.isEmpty());</span>
<span class="line-modified">143             m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">144         } else {</span>
<span class="line-modified">145             m_entryPointScaffolding = WTF::nullopt;</span>
<span class="line-modified">146             m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;));</span>















































147             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<a name="22" id="anc22"></a><span class="line-modified">148                 auto&amp; parameter = functionDefinition.parameters()[i];</span>
<span class="line-removed">149                 if (i)</span>
<span class="line-removed">150                     m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-removed">151                 auto parameterName = generateNextVariableName();</span>
<span class="line-removed">152                 auto addResult = m_variableMapping.add(&amp;parameter, parameterName);</span>
153                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
<a name="23" id="anc23"></a><span class="line-removed">154                 m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*parameter.type()), &#39; &#39;, parameterName));</span>
155             }
<a name="24" id="anc24"></a><span class="line-removed">156             m_stringBuilder.append(&quot;) {\n&quot;);</span>
157             checkErrorAndVisit(functionDefinition.block());
158             ASSERT(m_stack.isEmpty());
<a name="25" id="anc25"></a><span class="line-removed">159             m_stringBuilder.append(&quot;}\n&quot;);</span>
160         }
<a name="26" id="anc26"></a>


















161     }
<a name="27" id="anc27"></a>
162 
<a name="28" id="anc28"></a><span class="line-modified">163 private:</span>
<span class="line-modified">164     void visit(AST::FunctionDeclaration&amp;) override</span>
<span class="line-modified">165     {</span>
<span class="line-modified">166         ASSERT_NOT_REACHED();</span>
<span class="line-removed">167     }</span>
168 
<a name="29" id="anc29"></a><span class="line-modified">169     void visit(AST::Statement&amp; statement) override</span>
<span class="line-modified">170     {</span>
<span class="line-modified">171         Visitor::visit(statement);</span>
<span class="line-modified">172     }</span>
173 
<a name="30" id="anc30"></a><span class="line-modified">174     void visit(AST::Block&amp; block) override</span>


175     {
<a name="31" id="anc31"></a><span class="line-modified">176         m_stringBuilder.append(&quot;{\n&quot;);</span>
177         for (auto&amp; statement : block.statements())
178             checkErrorAndVisit(statement);
<a name="32" id="anc32"></a><span class="line-removed">179         m_stringBuilder.append(&quot;}\n&quot;);</span>
180     }
<a name="33" id="anc33"></a>

181 
<a name="34" id="anc34"></a><span class="line-modified">182     void visit(AST::Break&amp;) override</span>
<span class="line-modified">183     {</span>
<span class="line-modified">184         m_stringBuilder.append(&quot;break;\n&quot;);</span>











185     }
<a name="35" id="anc35"></a>
186 
<a name="36" id="anc36"></a><span class="line-modified">187     void visit(AST::Continue&amp;) override</span>
<span class="line-modified">188     {</span>
<span class="line-modified">189         // FIXME: Figure out which loop we&#39;re in, and run the increment code</span>
<span class="line-modified">190         CRASH();</span>
<span class="line-modified">191     }</span>
192 
<a name="37" id="anc37"></a><span class="line-modified">193     void visit(AST::DoWhileLoop&amp; doWhileLoop) override</span>
<span class="line-modified">194     {</span>
<span class="line-modified">195         m_stringBuilder.append(&quot;do {\n&quot;);</span>
<span class="line-modified">196         checkErrorAndVisit(doWhileLoop.body());</span>
<span class="line-modified">197         checkErrorAndVisit(doWhileLoop.conditional());</span>
<span class="line-removed">198         m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
<span class="line-removed">199         m_stringBuilder.append(makeString(&quot;} while(true);\n&quot;));</span>
<span class="line-removed">200     }</span>
201 
<a name="38" id="anc38"></a><span class="line-modified">202     void visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement) override</span>
<span class="line-modified">203     {</span>
<span class="line-modified">204         checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());</span>
<span class="line-modified">205         m_stack.takeLast(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
<span class="line-removed">206     }</span>
207 
<a name="39" id="anc39"></a><span class="line-modified">208     void visit(AST::Fallthrough&amp;) override</span>
<span class="line-modified">209     {</span>
<span class="line-modified">210         m_stringBuilder.append(&quot;[[clang::fallthrough]];\n&quot;); // FIXME: Make sure this is okay. Alternatively, we could do nothing and just return here instead.</span>
<span class="line-removed">211     }</span>
212 
<a name="40" id="anc40"></a><span class="line-modified">213     void visit(AST::ForLoop&amp; forLoop) override</span>



214     {
<a name="41" id="anc41"></a><span class="line-modified">215         WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {</span>
<span class="line-modified">216             checkErrorAndVisit(variableDeclarationsStatement);</span>
<span class="line-modified">217         }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {</span>
<span class="line-modified">218             checkErrorAndVisit(expression);</span>
<span class="line-modified">219             m_stack.takeLast(); // We don&#39;t need to do anything with the result.</span>
<span class="line-modified">220         }), forLoop.initialization());</span>
<span class="line-modified">221 </span>
<span class="line-removed">222         m_stringBuilder.append(&quot;for ( ; ; ) {\n&quot;);</span>
<span class="line-removed">223         if (forLoop.condition()) {</span>
<span class="line-removed">224             checkErrorAndVisit(*forLoop.condition());</span>
<span class="line-removed">225             m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
226         }
<a name="42" id="anc42"></a><span class="line-modified">227         checkErrorAndVisit(forLoop.body());</span>
<span class="line-modified">228         if (forLoop.increment()) {</span>
<span class="line-modified">229             checkErrorAndVisit(*forLoop.increment());</span>
<span class="line-modified">230             m_stack.takeLast();</span>















231         }
<a name="43" id="anc43"></a><span class="line-modified">232         m_stringBuilder.append(&quot;}\n&quot;);</span>




























233     }
<a name="44" id="anc44"></a>

234 
<a name="45" id="anc45"></a><span class="line-modified">235     void visit(AST::IfStatement&amp; ifStatement) override</span>



236     {
<a name="46" id="anc46"></a><span class="line-modified">237         checkErrorAndVisit(ifStatement.conditional());</span>
<span class="line-removed">238         m_stringBuilder.append(makeString(&quot;if (&quot;, m_stack.takeLast(), &quot;) {\n&quot;));</span>
239         checkErrorAndVisit(ifStatement.body());
<a name="47" id="anc47"></a><span class="line-modified">240         if (ifStatement.elseBody()) {</span>
<span class="line-modified">241             m_stringBuilder.append(&quot;} else {\n&quot;);</span>



242             checkErrorAndVisit(*ifStatement.elseBody());
243         }
<a name="48" id="anc48"></a><span class="line-removed">244         m_stringBuilder.append(&quot;}\n&quot;);</span>
245     }
<a name="49" id="anc49"></a>

246 
<a name="50" id="anc50"></a><span class="line-modified">247     void visit(AST::Return&amp; returnStatement) override</span>
<span class="line-modified">248     {</span>
<span class="line-modified">249         if (returnStatement.value()) {</span>
<span class="line-modified">250             checkErrorAndVisit(*returnStatement.value());</span>
<span class="line-modified">251             if (m_entryPointScaffolding) {</span>
<span class="line-modified">252                 auto variableName = generateNextVariableName();</span>
<span class="line-modified">253                 m_stringBuilder.append(m_entryPointScaffolding-&gt;pack(m_stack.takeLast(), variableName));</span>
<span class="line-modified">254                 m_stringBuilder.append(makeString(&quot;return &quot;, variableName, &quot;;\n&quot;));</span>
<span class="line-modified">255             } else</span>
<span class="line-removed">256                 m_stringBuilder.append(makeString(&quot;return &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
257         } else
<a name="51" id="anc51"></a><span class="line-modified">258             m_stringBuilder.append(&quot;return;\n&quot;);</span>
<span class="line-modified">259     }</span>


260 
<a name="52" id="anc52"></a><span class="line-modified">261     void visit(AST::SwitchStatement&amp; switchStatement) override</span>
<span class="line-modified">262     {</span>
<span class="line-modified">263         checkErrorAndVisit(switchStatement.value());</span>
264 
<a name="53" id="anc53"></a><span class="line-modified">265         m_stringBuilder.append(makeString(&quot;switch (&quot;, m_stack.takeLast(), &quot;) {&quot;));</span>


266         for (auto&amp; switchCase : switchStatement.switchCases())
267             checkErrorAndVisit(switchCase);
<a name="54" id="anc54"></a><span class="line-removed">268         m_stringBuilder.append(&quot;}\n&quot;);</span>
269     }
<a name="55" id="anc55"></a>

270 
<a name="56" id="anc56"></a><span class="line-modified">271     void visit(AST::SwitchCase&amp; switchCase) override</span>
<span class="line-modified">272     {</span>
<span class="line-modified">273         if (switchCase.value())</span>
<span class="line-modified">274             m_stringBuilder.append(makeString(&quot;case &quot;, constantExpressionString(*switchCase.value()), &quot;:\n&quot;));</span>
<span class="line-modified">275         else</span>
<span class="line-modified">276             m_stringBuilder.append(&quot;default:\n&quot;);</span>
<span class="line-modified">277         checkErrorAndVisit(switchCase.block());</span>
<span class="line-modified">278         // FIXME: Figure out whether we need to break or fallthrough.</span>
<span class="line-modified">279         CRASH();</span>
<span class="line-modified">280     }</span>


281 
<a name="57" id="anc57"></a><span class="line-modified">282     void visit(AST::Trap&amp;) override</span>
<span class="line-modified">283     {</span>
<span class="line-modified">284         // FIXME: Implement this</span>
<span class="line-modified">285         CRASH();</span>
<span class="line-removed">286     }</span>
287 
<a name="58" id="anc58"></a><span class="line-modified">288     void visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) override</span>
<span class="line-modified">289     {</span>
<span class="line-modified">290         Visitor::visit(variableDeclarationsStatement);</span>
<span class="line-modified">291     }</span>



292 
<a name="59" id="anc59"></a><span class="line-modified">293     void visit(AST::WhileLoop&amp; whileLoop) override</span>
<span class="line-modified">294     {</span>
<span class="line-modified">295         m_stringBuilder.append(makeString(&quot;while (true) {\n&quot;));</span>
<span class="line-modified">296         checkErrorAndVisit(whileLoop.conditional());</span>
<span class="line-modified">297         m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
<span class="line-modified">298         checkErrorAndVisit(whileLoop.body());</span>
<span class="line-modified">299         m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">300     }</span>
301 
<a name="60" id="anc60"></a><span class="line-modified">302     void visit(AST::IntegerLiteral&amp; integerLiteral) override</span>
<span class="line-modified">303     {</span>
<span class="line-modified">304         ASSERT(integerLiteral.resolvedType());</span>
<span class="line-modified">305         auto variableName = generateNextVariableName();</span>
<span class="line-modified">306         auto mangledTypeName = m_typeNamer.mangledNameForType(*integerLiteral.resolvedType());</span>
<span class="line-modified">307         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">308         m_stack.append(variableName);</span>
<span class="line-removed">309     }</span>
310 
<a name="61" id="anc61"></a><span class="line-modified">311     void visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) override</span>
<span class="line-modified">312     {</span>
<span class="line-modified">313         ASSERT(unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">314         auto variableName = generateNextVariableName();</span>
<span class="line-modified">315         auto mangledTypeName = m_typeNamer.mangledNameForType(*unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">316         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">317         m_stack.append(variableName);</span>
<span class="line-modified">318     }</span>






319 
<a name="62" id="anc62"></a><span class="line-modified">320     void visit(AST::FloatLiteral&amp; floatLiteral) override</span>
<span class="line-modified">321     {</span>
<span class="line-modified">322         ASSERT(floatLiteral.resolvedType());</span>
<span class="line-modified">323         auto variableName = generateNextVariableName();</span>
<span class="line-modified">324         auto mangledTypeName = m_typeNamer.mangledNameForType(*floatLiteral.resolvedType());</span>
<span class="line-modified">325         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">326         m_stack.append(variableName);</span>
<span class="line-removed">327     }</span>
328 
<a name="63" id="anc63"></a><span class="line-modified">329     void visit(AST::NullLiteral&amp; nullLiteral) override</span>
<span class="line-modified">330     {</span>
<span class="line-modified">331         ASSERT(nullLiteral.resolvedType());</span>
<span class="line-modified">332         auto&amp; unifyNode = nullLiteral.resolvedType()-&gt;unifyNode();</span>
<span class="line-modified">333         ASSERT(is&lt;AST::UnnamedType&gt;(unifyNode));</span>
<span class="line-modified">334         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">335         bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-modified">336 </span>
<span class="line-modified">337         auto variableName = generateNextVariableName();</span>
<span class="line-removed">338         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;));</span>
<span class="line-removed">339         if (isArrayReferenceType)</span>
<span class="line-removed">340             m_stringBuilder.append(&quot;{ nullptr, 0 }&quot;);</span>
<span class="line-removed">341         else</span>
<span class="line-removed">342             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-removed">343         m_stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-removed">344         m_stack.append(variableName);</span>
<span class="line-removed">345     }</span>
346 
<a name="64" id="anc64"></a><span class="line-modified">347     void visit(AST::BooleanLiteral&amp; booleanLiteral) override</span>
<span class="line-modified">348     {</span>
<span class="line-modified">349         ASSERT(booleanLiteral.resolvedType());</span>
<span class="line-modified">350         auto variableName = generateNextVariableName();</span>
<span class="line-removed">351         auto mangledTypeName = m_typeNamer.mangledNameForType(*booleanLiteral.resolvedType());</span>
<span class="line-removed">352         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;));</span>
<span class="line-removed">353         m_stack.append(variableName);</span>
<span class="line-removed">354     }</span>
355 
<a name="65" id="anc65"></a><span class="line-modified">356     void visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) override</span>
<span class="line-modified">357     {</span>
<span class="line-modified">358         ASSERT(enumerationMemberLiteral.resolvedType());</span>
<span class="line-modified">359         ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">360         ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">361         auto variableName = generateNextVariableName();</span>
<span class="line-modified">362         auto mangledTypeName = m_typeNamer.mangledNameForType(*enumerationMemberLiteral.resolvedType());</span>
<span class="line-removed">363         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &#39;.&#39;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;));</span>
<span class="line-removed">364         m_stack.append(variableName);</span>
<span class="line-removed">365     }</span>
366 
<a name="66" id="anc66"></a><span class="line-modified">367     void visit(AST::Expression&amp; expression) override</span>
<span class="line-modified">368     {</span>
<span class="line-modified">369         Visitor::visit(expression);</span>
<span class="line-modified">370     }</span>
371 
<a name="67" id="anc67"></a><span class="line-modified">372     void visit(AST::DotExpression&amp;) override</span>
<span class="line-modified">373     {</span>
<span class="line-removed">374         // This should be lowered already.</span>
<span class="line-removed">375         ASSERT_NOT_REACHED();</span>
<span class="line-removed">376     }</span>
377 
<a name="68" id="anc68"></a><span class="line-modified">378     void visit(AST::IndexExpression&amp;) override</span>
<span class="line-removed">379     {</span>
<span class="line-removed">380         // This should be lowered already.</span>
<span class="line-removed">381         ASSERT_NOT_REACHED();</span>
<span class="line-removed">382     }</span>
383 
<a name="69" id="anc69"></a><span class="line-modified">384     void visit(AST::PropertyAccessExpression&amp;) override</span>
<span class="line-modified">385     {</span>
<span class="line-removed">386         ASSERT_NOT_REACHED();</span>
<span class="line-removed">387     }</span>
388 
<a name="70" id="anc70"></a><span class="line-modified">389     void visit(AST::VariableDeclaration&amp; variableDeclaration) override</span>
<span class="line-modified">390     {</span>
<span class="line-modified">391         ASSERT(variableDeclaration.type());</span>
<span class="line-modified">392         if (variableDeclaration.initializer())</span>
<span class="line-modified">393             checkErrorAndVisit(*variableDeclaration.initializer());</span>
<span class="line-modified">394         else {</span>
<span class="line-modified">395             // FIXME: Zero-fill the variable.</span>
<span class="line-modified">396             CRASH();</span>
<span class="line-modified">397         }</span>
<span class="line-modified">398         // FIXME: Implement qualifiers.</span>
<span class="line-modified">399         auto variableName = generateNextVariableName();</span>
<span class="line-modified">400         auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);</span>
<span class="line-modified">401         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-modified">402         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">403         m_stack.append(variableName);</span>














































404     }
405 
<a name="71" id="anc71"></a><span class="line-modified">406     void visit(AST::AssignmentExpression&amp; assignmentExpression) override</span>
<span class="line-modified">407     {</span>
<span class="line-modified">408         checkErrorAndVisit(assignmentExpression.left());</span>
<span class="line-modified">409         auto leftName = m_stack.takeLast();</span>
<span class="line-modified">410         checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-removed">411         auto rightName = m_stack.takeLast();</span>
<span class="line-removed">412         m_stringBuilder.append(makeString(leftName, &quot; = &quot;, rightName, &quot;;\n&quot;));</span>
413     }
414 
<a name="72" id="anc72"></a><span class="line-modified">415     void visit(AST::CallExpression&amp; callExpression) override</span>
<span class="line-modified">416     {</span>
<span class="line-modified">417         Vector&lt;String&gt; argumentNames;</span>
<span class="line-modified">418         for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-modified">419             checkErrorAndVisit(argument);</span>
<span class="line-modified">420             argumentNames.append(m_stack.takeLast());</span>
<span class="line-modified">421         }</span>
<span class="line-modified">422         ASSERT(callExpression.resolvedType());</span>
<span class="line-modified">423         ASSERT(callExpression.function());</span>
<span class="line-modified">424         auto iterator = m_functionMapping.find(callExpression.function());</span>


425         ASSERT(iterator != m_functionMapping.end());
<a name="73" id="anc73"></a><span class="line-modified">426         auto variableName = generateNextVariableName();</span>
<span class="line-modified">427         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*callExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, iterator-&gt;value, &#39;(&#39;));</span>

428         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {
429             if (i)
430                 m_stringBuilder.append(&quot;, &quot;);
431             m_stringBuilder.append(argumentNames[i]);
432         }
433         m_stringBuilder.append(&quot;);\n&quot;);
<a name="74" id="anc74"></a><span class="line-removed">434         m_stack.append(variableName);</span>
435     }
436 
<a name="75" id="anc75"></a><span class="line-modified">437     void visit(AST::CommaExpression&amp; commaExpression) override</span>
<span class="line-modified">438     {</span>
<span class="line-removed">439         String result;</span>
<span class="line-removed">440         for (auto&amp; expression : commaExpression.list()) {</span>
<span class="line-removed">441             checkErrorAndVisit(expression);</span>
<span class="line-removed">442             result = m_stack.takeLast();</span>
<span class="line-removed">443         }</span>
<span class="line-removed">444         m_stack.append(result);</span>
<span class="line-removed">445     }</span>
446 
<a name="76" id="anc76"></a><span class="line-modified">447     void visit(AST::DereferenceExpression&amp; dereferenceExpression) override</span>
<span class="line-modified">448     {</span>
<span class="line-modified">449         checkErrorAndVisit(dereferenceExpression.pointer());</span>
<span class="line-modified">450         auto right = m_stack.takeLast();</span>
<span class="line-modified">451         ASSERT(dereferenceExpression.resolvedType());</span>
<span class="line-modified">452         auto variableName = generateNextVariableName();</span>
<span class="line-removed">453         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*dereferenceExpression.resolvedType()), &#39; &#39;, variableName, &quot; = *&quot;, right, &quot;;\n&quot;));</span>
<span class="line-removed">454         m_stack.append(variableName);</span>
455     }
<a name="77" id="anc77"></a>


456 
<a name="78" id="anc78"></a><span class="line-modified">457     void visit(AST::LogicalExpression&amp; logicalExpression) override</span>
<span class="line-modified">458     {</span>
<span class="line-modified">459         checkErrorAndVisit(logicalExpression.left());</span>
<span class="line-modified">460         auto left = m_stack.takeLast();</span>
<span class="line-modified">461         checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-modified">462         auto right = m_stack.takeLast();</span>
<span class="line-modified">463         ASSERT(logicalExpression.resolvedType());</span>
<span class="line-modified">464         auto variableName = generateNextVariableName();</span>
<span class="line-modified">465         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left));</span>
<span class="line-modified">466         switch (logicalExpression.type()) {</span>
<span class="line-modified">467         case AST::LogicalExpression::Type::And:</span>
<span class="line-modified">468             m_stringBuilder.append(&quot; &amp;&amp; &quot;);</span>
<span class="line-modified">469             break;</span>
<span class="line-modified">470         default:</span>
<span class="line-modified">471             ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
<span class="line-modified">472             m_stringBuilder.append(&quot; || &quot;);</span>
<span class="line-modified">473             break;</span>






























































































































474         }
<a name="79" id="anc79"></a><span class="line-modified">475         m_stringBuilder.append(makeString(right, &quot;;\n&quot;));</span>
<span class="line-modified">476         m_stack.append(variableName);</span>
<span class="line-removed">477     }</span>
478 
<a name="80" id="anc80"></a><span class="line-modified">479     void visit(AST::LogicalNotExpression&amp; logicalNotExpression) override</span>




480     {
<a name="81" id="anc81"></a><span class="line-removed">481         checkErrorAndVisit(logicalNotExpression.operand());</span>
<span class="line-removed">482         auto operand = m_stack.takeLast();</span>
<span class="line-removed">483         ASSERT(logicalNotExpression.resolvedType());</span>
<span class="line-removed">484         auto variableName = generateNextVariableName();</span>
<span class="line-removed">485         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;));</span>
<span class="line-removed">486         m_stack.append(variableName);</span>
487     }
488 
<a name="82" id="anc82"></a><span class="line-modified">489     void visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression) override</span>
<span class="line-modified">490     {</span>
<span class="line-removed">491         checkErrorAndVisit(makeArrayReferenceExpression.lValue());</span>
<span class="line-removed">492         auto lValue = m_stack.takeLast();</span>
<span class="line-removed">493         ASSERT(makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">494         auto variableName = generateNextVariableName();</span>
<span class="line-removed">495         auto mangledTypeName = m_typeNamer.mangledNameForType(*makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">496         if (is&lt;AST::PointerType&gt;(*makeArrayReferenceExpression.resolvedType()))</span>
<span class="line-removed">497             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;));</span>
<span class="line-removed">498         else if (is&lt;AST::ArrayType&gt;(*makeArrayReferenceExpression.resolvedType())) {</span>
<span class="line-removed">499             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(*makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">500             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &amp;(&quot;, lValue, &quot;[0]), &quot;, arrayType.numElements(), &quot; };\n&quot;));</span>
<span class="line-removed">501         } else</span>
<span class="line-removed">502             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &amp;&quot;, lValue, &quot;, 1 };\n&quot;));</span>
<span class="line-removed">503         m_stack.append(variableName);</span>
<span class="line-removed">504     }</span>
505 
<a name="83" id="anc83"></a><span class="line-modified">506     void visit(AST::MakePointerExpression&amp; makePointerExpression) override</span>
<span class="line-modified">507     {</span>
<span class="line-modified">508         checkErrorAndVisit(makePointerExpression.lValue());</span>
<span class="line-modified">509         auto lValue = m_stack.takeLast();</span>
<span class="line-modified">510         ASSERT(makePointerExpression.resolvedType());</span>
<span class="line-modified">511         auto variableName = generateNextVariableName();</span>
<span class="line-modified">512         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &amp;&quot;, lValue, &quot;;\n&quot;));</span>
<span class="line-modified">513         m_stack.append(variableName);</span>
<span class="line-modified">514     }</span>





515 
<a name="84" id="anc84"></a><span class="line-modified">516     void visit(AST::ReadModifyWriteExpression&amp;) override</span>




517     {
<a name="85" id="anc85"></a><span class="line-removed">518         // This should be lowered already.</span>
<span class="line-removed">519         ASSERT_NOT_REACHED();</span>
520     }
521 
<a name="86" id="anc86"></a><span class="line-modified">522     void visit(AST::TernaryExpression&amp; ternaryExpression) override</span>
<span class="line-modified">523     {</span>
<span class="line-modified">524         checkErrorAndVisit(ternaryExpression.predicate());</span>
<span class="line-modified">525         auto check = m_stack.takeLast();</span>
<span class="line-modified">526 </span>
<span class="line-modified">527         ASSERT(ternaryExpression.resolvedType());</span>
<span class="line-modified">528         auto variableName = generateNextVariableName();</span>
<span class="line-modified">529         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot;;\n&quot;));</span>
<span class="line-modified">530 </span>
<span class="line-modified">531         m_stringBuilder.append(makeString(&quot;if (&quot;, check, &quot;) {\n&quot;));</span>
<span class="line-modified">532         checkErrorAndVisit(ternaryExpression.bodyExpression());</span>
<span class="line-modified">533         m_stringBuilder.append(makeString(variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">534         m_stringBuilder.append(&quot;} else {\n&quot;);</span>
<span class="line-modified">535         checkErrorAndVisit(ternaryExpression.elseExpression());</span>
<span class="line-modified">536         m_stringBuilder.append(makeString(variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">537         m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">538         m_stack.append(variableName);</span>






539     }
540 
<a name="87" id="anc87"></a><span class="line-modified">541     void visit(AST::VariableReference&amp; variableReference) override</span>
<span class="line-modified">542     {</span>
<span class="line-modified">543         ASSERT(variableReference.variable());</span>
<span class="line-modified">544         auto iterator = m_variableMapping.find(variableReference.variable());</span>
<span class="line-modified">545         ASSERT(iterator != m_variableMapping.end());</span>
<span class="line-modified">546         m_stack.append(iterator-&gt;value);</span>


547     }
548 
<a name="88" id="anc88"></a><span class="line-modified">549     String constantExpressionString(AST::ConstantExpression&amp; constantExpression)</span>





550     {
<a name="89" id="anc89"></a><span class="line-modified">551         String result;</span>
<span class="line-modified">552         constantExpression.visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">553             result = makeString(&quot;&quot;, integerLiteral.value());</span>
<span class="line-removed">554         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed">555             result = makeString(&quot;&quot;, unsignedIntegerLiteral.value());</span>
<span class="line-removed">556         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-removed">557             result = makeString(&quot;&quot;, floatLiteral.value());</span>
<span class="line-removed">558         }, [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-removed">559             result = &quot;nullptr&quot;_str;</span>
<span class="line-removed">560         }, [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {</span>
<span class="line-removed">561             result = booleanLiteral.value() ? &quot;true&quot;_str : &quot;false&quot;_str;</span>
<span class="line-removed">562         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
<span class="line-removed">563             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-removed">564             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-removed">565             result = makeString(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &#39;.&#39;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>
<span class="line-removed">566         }));</span>
<span class="line-removed">567         return result;</span>
568     }
569 
<a name="90" id="anc90"></a><span class="line-modified">570     String generateNextVariableName()</span>
571     {
<a name="91" id="anc91"></a><span class="line-modified">572         return makeString(&quot;variable&quot;, m_variableCount++);</span>




573     }
574 
<a name="92" id="anc92"></a>

575 private:
<a name="93" id="anc93"></a><span class="line-modified">576     Intrinsics&amp; m_intrinsics;</span>
<span class="line-removed">577     TypeNamer&amp; m_typeNamer;</span>
<span class="line-removed">578     HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; m_functionMapping;</span>
<span class="line-removed">579     HashMap&lt;AST::VariableDeclaration*, String&gt; m_variableMapping;</span>
<span class="line-removed">580     StringBuilder m_stringBuilder;</span>
<span class="line-removed">581     Vector&lt;String&gt; m_stack;</span>
<span class="line-removed">582     Optional&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;</span>
<span class="line-removed">583     unsigned m_variableCount { 0 };</span>
584 };
585 
<a name="94" id="anc94"></a><span class="line-modified">586 String metalFunctions(Program&amp; program, TypeNamer&amp; typeNamer)</span>
587 {
<a name="95" id="anc95"></a><span class="line-modified">588     StringBuilder stringBuilder;</span>

589 
<a name="96" id="anc96"></a><span class="line-modified">590     unsigned numFunctions = 0;</span>
<span class="line-modified">591     HashMap&lt;AST::FunctionDeclaration*, String&gt; functionMapping;</span>
<span class="line-modified">592     for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations()) {</span>
<span class="line-modified">593         auto addResult = functionMapping.add(&amp;nativeFunctionDeclaration, makeString(&quot;function&quot;, numFunctions++));</span>
<span class="line-modified">594         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-modified">595     }</span>





596     for (auto&amp; functionDefinition : program.functionDefinitions()) {
<a name="97" id="anc97"></a><span class="line-modified">597         auto addResult = functionMapping.add(&amp;functionDefinition, makeString(&quot;function&quot;, numFunctions++));</span>
<span class="line-modified">598         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
599     }
600 
<a name="98" id="anc98"></a><span class="line-modified">601     {</span>
<span class="line-modified">602         FunctionDeclarationWriter functionDeclarationWriter(typeNamer, functionMapping);</span>
<span class="line-removed">603         for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations())</span>
<span class="line-removed">604             functionDeclarationWriter.visit(nativeFunctionDeclaration);</span>
<span class="line-removed">605         for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-removed">606             if (!functionDefinition-&gt;entryPointType())</span>
<span class="line-removed">607                 functionDeclarationWriter.visit(functionDefinition);</span>
<span class="line-removed">608         }</span>
<span class="line-removed">609         stringBuilder.append(functionDeclarationWriter.toString());</span>
<span class="line-removed">610     }</span>
611 
<a name="99" id="anc99"></a><span class="line-modified">612     stringBuilder.append(&#39;\n&#39;);</span>


613 
<a name="100" id="anc100"></a><span class="line-modified">614     {</span>
<span class="line-modified">615         FunctionDefinitionWriter functionDefinitionWriter(program.intrinsics(), typeNamer, functionMapping);</span>
<span class="line-modified">616         for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations())</span>
<span class="line-modified">617             functionDefinitionWriter.visit(nativeFunctionDeclaration);</span>
<span class="line-modified">618         for (auto&amp; functionDefinition : program.functionDefinitions())</span>





619             functionDefinitionWriter.visit(functionDefinition);
<a name="101" id="anc101"></a><span class="line-removed">620         stringBuilder.append(functionDefinitionWriter.toString());</span>
621     }
622 
<a name="102" id="anc102"></a><span class="line-modified">623     return stringBuilder.toString();</span>
624 }
625 
626 } // namespace Metal
627 
628 } // namespace WHLSL
629 
630 } // namespace WebCore
631 
632 #endif
<a name="103" id="anc103"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="103" type="hidden" />
</body>
</html>