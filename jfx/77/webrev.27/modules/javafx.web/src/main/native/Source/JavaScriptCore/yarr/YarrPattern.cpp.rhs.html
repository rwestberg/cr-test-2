<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrPattern.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009, 2013-2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010 Peter Varga (pvarga@inf.u-szeged.hu), University of Szeged
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;YarrPattern.h&quot;
  29 
  30 #include &quot;Options.h&quot;
  31 #include &quot;Yarr.h&quot;
  32 #include &quot;YarrCanonicalize.h&quot;
  33 #include &quot;YarrParser.h&quot;
  34 #include &lt;wtf/DataLog.h&gt;
  35 #include &lt;wtf/Optional.h&gt;
  36 #include &lt;wtf/StackPointer.h&gt;
  37 #include &lt;wtf/Threading.h&gt;
  38 #include &lt;wtf/Vector.h&gt;
<a name="1" id="anc1"></a>
  39 
  40 namespace JSC { namespace Yarr {
  41 
  42 #include &quot;RegExpJitTables.h&quot;
  43 
  44 class CharacterClassConstructor {
  45 public:
  46     CharacterClassConstructor(bool isCaseInsensitive, CanonicalMode canonicalMode)
  47         : m_isCaseInsensitive(isCaseInsensitive)
<a name="2" id="anc2"></a>
  48         , m_anyCharacter(false)
<a name="3" id="anc3"></a><span class="line-added">  49         , m_characterWidths(CharacterClassWidths::Unknown)</span>
  50         , m_canonicalMode(canonicalMode)
  51     {
  52     }
  53 
  54     void reset()
  55     {
  56         m_matches.clear();
  57         m_ranges.clear();
  58         m_matchesUnicode.clear();
  59         m_rangesUnicode.clear();
<a name="4" id="anc4"></a>
  60         m_anyCharacter = false;
<a name="5" id="anc5"></a><span class="line-added">  61         m_characterWidths = CharacterClassWidths::Unknown;</span>
  62     }
  63 
  64     void append(const CharacterClass* other)
  65     {
  66         for (size_t i = 0; i &lt; other-&gt;m_matches.size(); ++i)
  67             addSorted(m_matches, other-&gt;m_matches[i]);
  68         for (size_t i = 0; i &lt; other-&gt;m_ranges.size(); ++i)
  69             addSortedRange(m_ranges, other-&gt;m_ranges[i].begin, other-&gt;m_ranges[i].end);
  70         for (size_t i = 0; i &lt; other-&gt;m_matchesUnicode.size(); ++i)
  71             addSorted(m_matchesUnicode, other-&gt;m_matchesUnicode[i]);
  72         for (size_t i = 0; i &lt; other-&gt;m_rangesUnicode.size(); ++i)
  73             addSortedRange(m_rangesUnicode, other-&gt;m_rangesUnicode[i].begin, other-&gt;m_rangesUnicode[i].end);
  74     }
  75 
  76     void appendInverted(const CharacterClass* other)
  77     {
  78         auto addSortedInverted = [&amp;](UChar32 min, UChar32 max,
  79             const Vector&lt;UChar32&gt;&amp; srcMatches, const Vector&lt;CharacterRange&gt;&amp; srcRanges,
  80             Vector&lt;UChar32&gt;&amp; destMatches, Vector&lt;CharacterRange&gt;&amp; destRanges) {
  81 
  82             auto addSortedMatchOrRange = [&amp;](UChar32 lo, UChar32 hiPlusOne) {
  83                 if (lo &lt; hiPlusOne) {
  84                     if (lo + 1 == hiPlusOne)
  85                         addSorted(destMatches, lo);
  86                     else
  87                         addSortedRange(destRanges, lo, hiPlusOne - 1);
  88                 }
  89             };
  90 
  91             UChar32 lo = min;
  92             size_t matchesIndex = 0;
  93             size_t rangesIndex = 0;
  94             bool matchesRemaining = matchesIndex &lt; srcMatches.size();
  95             bool rangesRemaining = rangesIndex &lt; srcRanges.size();
  96 
  97             if (!matchesRemaining &amp;&amp; !rangesRemaining) {
  98                 addSortedMatchOrRange(min, max + 1);
  99                 return;
 100             }
 101 
 102             while (matchesRemaining || rangesRemaining) {
 103                 UChar32 hiPlusOne;
 104                 UChar32 nextLo;
 105 
 106                 if (matchesRemaining
 107                     &amp;&amp; (!rangesRemaining || srcMatches[matchesIndex] &lt; srcRanges[rangesIndex].begin)) {
 108                     hiPlusOne = srcMatches[matchesIndex];
 109                     nextLo = hiPlusOne + 1;
 110                     ++matchesIndex;
 111                     matchesRemaining = matchesIndex &lt; srcMatches.size();
 112                 } else {
 113                     hiPlusOne = srcRanges[rangesIndex].begin;
 114                     nextLo = srcRanges[rangesIndex].end + 1;
 115                     ++rangesIndex;
 116                     rangesRemaining = rangesIndex &lt; srcRanges.size();
 117                 }
 118 
 119                 addSortedMatchOrRange(lo, hiPlusOne);
 120 
 121                 lo = nextLo;
 122             }
 123 
 124             addSortedMatchOrRange(lo, max + 1);
 125         };
 126 
 127         addSortedInverted(0, 0x7f, other-&gt;m_matches, other-&gt;m_ranges, m_matches, m_ranges);
 128         addSortedInverted(0x80, 0x10ffff, other-&gt;m_matchesUnicode, other-&gt;m_rangesUnicode, m_matchesUnicode, m_rangesUnicode);
 129     }
 130 
 131     void putChar(UChar32 ch)
 132     {
 133         if (!m_isCaseInsensitive) {
 134             addSorted(ch);
 135             return;
 136         }
 137 
 138         if (m_canonicalMode == CanonicalMode::UCS2 &amp;&amp; isASCII(ch)) {
 139             // Handle ASCII cases.
 140             if (isASCIIAlpha(ch)) {
 141                 addSorted(m_matches, toASCIIUpper(ch));
 142                 addSorted(m_matches, toASCIILower(ch));
 143             } else
 144                 addSorted(m_matches, ch);
 145             return;
 146         }
 147 
 148         // Add multiple matches, if necessary.
 149         const CanonicalizationRange* info = canonicalRangeInfoFor(ch, m_canonicalMode);
 150         if (info-&gt;type == CanonicalizeUnique)
 151             addSorted(ch);
 152         else
 153             putUnicodeIgnoreCase(ch, info);
 154     }
 155 
 156     void putUnicodeIgnoreCase(UChar32 ch, const CanonicalizationRange* info)
 157     {
 158         ASSERT(m_isCaseInsensitive);
 159         ASSERT(ch &gt;= info-&gt;begin &amp;&amp; ch &lt;= info-&gt;end);
 160         ASSERT(info-&gt;type != CanonicalizeUnique);
 161         if (info-&gt;type == CanonicalizeSet) {
 162             for (const UChar32* set = canonicalCharacterSetInfo(info-&gt;value, m_canonicalMode); (ch = *set); ++set)
 163                 addSorted(ch);
 164         } else {
 165             addSorted(ch);
 166             addSorted(getCanonicalPair(info, ch));
 167         }
 168     }
 169 
 170     void putRange(UChar32 lo, UChar32 hi)
 171     {
 172         if (isASCII(lo)) {
 173             char asciiLo = lo;
 174             char asciiHi = std::min(hi, (UChar32)0x7f);
 175             addSortedRange(m_ranges, lo, asciiHi);
 176 
 177             if (m_isCaseInsensitive) {
 178                 if ((asciiLo &lt;= &#39;Z&#39;) &amp;&amp; (asciiHi &gt;= &#39;A&#39;))
 179                     addSortedRange(m_ranges, std::max(asciiLo, &#39;A&#39;)+(&#39;a&#39;-&#39;A&#39;), std::min(asciiHi, &#39;Z&#39;)+(&#39;a&#39;-&#39;A&#39;));
 180                 if ((asciiLo &lt;= &#39;z&#39;) &amp;&amp; (asciiHi &gt;= &#39;a&#39;))
 181                     addSortedRange(m_ranges, std::max(asciiLo, &#39;a&#39;)+(&#39;A&#39;-&#39;a&#39;), std::min(asciiHi, &#39;z&#39;)+(&#39;A&#39;-&#39;a&#39;));
 182             }
 183         }
 184         if (isASCII(hi))
 185             return;
 186 
 187         lo = std::max(lo, (UChar32)0x80);
 188         addSortedRange(m_rangesUnicode, lo, hi);
 189 
 190         if (!m_isCaseInsensitive)
 191             return;
 192 
 193         const CanonicalizationRange* info = canonicalRangeInfoFor(lo, m_canonicalMode);
 194         while (true) {
 195             // Handle the range [lo .. end]
 196             UChar32 end = std::min&lt;UChar32&gt;(info-&gt;end, hi);
 197 
 198             switch (info-&gt;type) {
 199             case CanonicalizeUnique:
 200                 // Nothing to do - no canonical equivalents.
 201                 break;
 202             case CanonicalizeSet: {
 203                 UChar ch;
 204                 for (const UChar32* set = canonicalCharacterSetInfo(info-&gt;value, m_canonicalMode); (ch = *set); ++set)
 205                     addSorted(m_matchesUnicode, ch);
 206                 break;
 207             }
 208             case CanonicalizeRangeLo:
 209                 addSortedRange(m_rangesUnicode, lo + info-&gt;value, end + info-&gt;value);
 210                 break;
 211             case CanonicalizeRangeHi:
 212                 addSortedRange(m_rangesUnicode, lo - info-&gt;value, end - info-&gt;value);
 213                 break;
 214             case CanonicalizeAlternatingAligned:
 215                 // Use addSortedRange since there is likely an abutting range to combine with.
 216                 if (lo &amp; 1)
 217                     addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
 218                 if (!(end &amp; 1))
 219                     addSortedRange(m_rangesUnicode, end + 1, end + 1);
 220                 break;
 221             case CanonicalizeAlternatingUnaligned:
 222                 // Use addSortedRange since there is likely an abutting range to combine with.
 223                 if (!(lo &amp; 1))
 224                     addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
 225                 if (end &amp; 1)
 226                     addSortedRange(m_rangesUnicode, end + 1, end + 1);
 227                 break;
 228             }
 229 
 230             if (hi == end)
 231                 return;
 232 
 233             ++info;
 234             lo = info-&gt;begin;
 235         };
 236 
 237     }
 238 
 239     std::unique_ptr&lt;CharacterClass&gt; charClass()
 240     {
 241         coalesceTables();
 242 
<a name="6" id="anc6"></a><span class="line-modified"> 243         auto characterClass = makeUnique&lt;CharacterClass&gt;();</span>
 244 
 245         characterClass-&gt;m_matches.swap(m_matches);
 246         characterClass-&gt;m_ranges.swap(m_ranges);
 247         characterClass-&gt;m_matchesUnicode.swap(m_matchesUnicode);
 248         characterClass-&gt;m_rangesUnicode.swap(m_rangesUnicode);
<a name="7" id="anc7"></a>
 249         characterClass-&gt;m_anyCharacter = anyCharacter();
<a name="8" id="anc8"></a><span class="line-added"> 250         characterClass-&gt;m_characterWidths = characterWidths();</span>
 251 
<a name="9" id="anc9"></a>
 252         m_anyCharacter = false;
<a name="10" id="anc10"></a><span class="line-added"> 253         m_characterWidths = CharacterClassWidths::Unknown;</span>
 254 
 255         return characterClass;
 256     }
 257 
 258 private:
 259     void addSorted(UChar32 ch)
 260     {
 261         addSorted(isASCII(ch) ? m_matches : m_matchesUnicode, ch);
 262     }
 263 
 264     void addSorted(Vector&lt;UChar32&gt;&amp; matches, UChar32 ch)
 265     {
 266         unsigned pos = 0;
 267         unsigned range = matches.size();
 268 
<a name="11" id="anc11"></a><span class="line-modified"> 269         m_characterWidths |= (U_IS_BMP(ch) ? CharacterClassWidths::HasBMPChars : CharacterClassWidths::HasNonBMPChars);</span>

 270 
 271         // binary chop, find position to insert char.
 272         while (range) {
 273             unsigned index = range &gt;&gt; 1;
 274 
 275             int val = matches[pos+index] - ch;
 276             if (!val)
 277                 return;
 278             else if (val &gt; 0) {
 279                 if (val == 1) {
 280                     UChar32 lo = ch;
 281                     UChar32 hi = ch + 1;
 282                     matches.remove(pos + index);
 283                     if (pos + index &gt; 0 &amp;&amp; matches[pos + index - 1] == ch - 1) {
 284                         lo = ch - 1;
 285                         matches.remove(pos + index - 1);
 286                     }
 287                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 288                     return;
 289                 }
 290                 range = index;
 291             } else {
 292                 if (val == -1) {
 293                     UChar32 lo = ch - 1;
 294                     UChar32 hi = ch;
 295                     matches.remove(pos + index);
 296                     if (pos + index + 1 &lt; matches.size() &amp;&amp; matches[pos + index + 1] == ch + 1) {
 297                         hi = ch + 1;
 298                         matches.remove(pos + index + 1);
 299                     }
 300                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 301                     return;
 302                 }
 303                 pos += (index+1);
 304                 range -= (index+1);
 305             }
 306         }
 307 
 308         if (pos == matches.size())
 309             matches.append(ch);
 310         else
 311             matches.insert(pos, ch);
 312     }
 313 
 314     void addSortedRange(Vector&lt;CharacterRange&gt;&amp; ranges, UChar32 lo, UChar32 hi)
 315     {
 316         size_t end = ranges.size();
 317 
<a name="12" id="anc12"></a><span class="line-added"> 318         if (U_IS_BMP(lo))</span>
<span class="line-added"> 319             m_characterWidths |= CharacterClassWidths::HasBMPChars;</span>
 320         if (!U_IS_BMP(hi))
<a name="13" id="anc13"></a><span class="line-modified"> 321             m_characterWidths |= CharacterClassWidths::HasNonBMPChars;</span>
 322 
 323         // Simple linear scan - I doubt there are that many ranges anyway...
 324         // feel free to fix this with something faster (eg binary chop).
 325         for (size_t i = 0; i &lt; end; ++i) {
 326             // does the new range fall before the current position in the array
 327             if (hi &lt; ranges[i].begin) {
 328                 // Concatenate appending ranges.
 329                 if (hi == (ranges[i].begin - 1)) {
 330                     ranges[i].begin = lo;
 331                     return;
 332                 }
 333                 ranges.insert(i, CharacterRange(lo, hi));
 334                 return;
 335             }
 336             // Okay, since we didn&#39;t hit the last case, the end of the new range is definitely at or after the begining
 337             // If the new range start at or before the end of the last range, then the overlap (if it starts one after the
 338             // end of the last range they concatenate, which is just as good.
 339             if (lo &lt;= (ranges[i].end + 1)) {
 340                 // found an intersect! we&#39;ll replace this entry in the array.
 341                 ranges[i].begin = std::min(ranges[i].begin, lo);
 342                 ranges[i].end = std::max(ranges[i].end, hi);
 343 
 344                 mergeRangesFrom(ranges, i);
 345                 return;
 346             }
 347         }
 348 
 349         // CharacterRange comes after all existing ranges.
 350         ranges.append(CharacterRange(lo, hi));
 351     }
 352 
 353     void mergeRangesFrom(Vector&lt;CharacterRange&gt;&amp; ranges, size_t index)
 354     {
 355         unsigned next = index + 1;
 356 
 357         // each iteration of the loop we will either remove something from the list, or break out of the loop.
 358         while (next &lt; ranges.size()) {
 359             if (ranges[next].begin &lt;= (ranges[index].end + 1)) {
 360                 // the next entry now overlaps / concatenates with this one.
 361                 ranges[index].end = std::max(ranges[index].end, ranges[next].end);
 362                 ranges.remove(next);
 363             } else
 364                 break;
 365         }
 366 
 367     }
 368 
 369     void coalesceTables()
 370     {
 371         auto coalesceMatchesAndRanges = [&amp;](Vector&lt;UChar32&gt;&amp; matches, Vector&lt;CharacterRange&gt;&amp; ranges) {
 372 
 373             size_t matchesIndex = 0;
 374             size_t rangesIndex = 0;
 375 
 376             while (matchesIndex &lt; matches.size() &amp;&amp; rangesIndex &lt; ranges.size()) {
 377                 while (matchesIndex &lt; matches.size() &amp;&amp; matches[matchesIndex] &lt; ranges[rangesIndex].begin - 1)
 378                     matchesIndex++;
 379 
 380                 if (matchesIndex &lt; matches.size() &amp;&amp; matches[matchesIndex] == ranges[rangesIndex].begin - 1) {
 381                     ranges[rangesIndex].begin = matches[matchesIndex];
 382                     matches.remove(matchesIndex);
 383                 }
 384 
 385                 while (matchesIndex &lt; matches.size() &amp;&amp; matches[matchesIndex] &lt; ranges[rangesIndex].end + 1)
 386                     matchesIndex++;
 387 
 388                 if (matchesIndex &lt; matches.size()) {
 389                     if (matches[matchesIndex] == ranges[rangesIndex].end + 1) {
 390                         ranges[rangesIndex].end = matches[matchesIndex];
 391                         matches.remove(matchesIndex);
 392 
 393                         mergeRangesFrom(ranges, rangesIndex);
 394                     } else
 395                         matchesIndex++;
 396                 }
 397             }
 398         };
 399 
 400         coalesceMatchesAndRanges(m_matches, m_ranges);
 401         coalesceMatchesAndRanges(m_matchesUnicode, m_rangesUnicode);
 402 
 403         if (!m_matches.size() &amp;&amp; !m_matchesUnicode.size()
 404             &amp;&amp; m_ranges.size() == 1 &amp;&amp; m_rangesUnicode.size() == 1
 405             &amp;&amp; m_ranges[0].begin == 0 &amp;&amp; m_ranges[0].end == 0x7f
 406             &amp;&amp; m_rangesUnicode[0].begin == 0x80 &amp;&amp; m_rangesUnicode[0].end == 0x10ffff)
 407             m_anyCharacter = true;
 408     }
 409 
 410     bool hasNonBMPCharacters()
 411     {
<a name="14" id="anc14"></a><span class="line-modified"> 412         return m_characterWidths &amp; CharacterClassWidths::HasNonBMPChars;</span>
<span class="line-added"> 413     }</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415     CharacterClassWidths characterWidths()</span>
<span class="line-added"> 416     {</span>
<span class="line-added"> 417         return m_characterWidths;</span>
 418     }
 419 
 420     bool anyCharacter()
 421     {
 422         return m_anyCharacter;
 423     }
 424 
 425     bool m_isCaseInsensitive : 1;
<a name="15" id="anc15"></a>
 426     bool m_anyCharacter : 1;
<a name="16" id="anc16"></a><span class="line-added"> 427     CharacterClassWidths m_characterWidths;</span>
<span class="line-added"> 428 </span>
 429     CanonicalMode m_canonicalMode;
 430 
 431     Vector&lt;UChar32&gt; m_matches;
 432     Vector&lt;CharacterRange&gt; m_ranges;
 433     Vector&lt;UChar32&gt; m_matchesUnicode;
 434     Vector&lt;CharacterRange&gt; m_rangesUnicode;
 435 };
 436 
 437 class YarrPatternConstructor {
 438 public:
 439     YarrPatternConstructor(YarrPattern&amp; pattern, void* stackLimit)
 440         : m_pattern(pattern)
 441         , m_characterClassConstructor(pattern.ignoreCase(), pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
 442         , m_stackLimit(stackLimit)
 443     {
<a name="17" id="anc17"></a><span class="line-modified"> 444         auto body = makeUnique&lt;PatternDisjunction&gt;();</span>
 445         m_pattern.m_body = body.get();
 446         m_alternative = body-&gt;addNewAlternative();
 447         m_pattern.m_disjunctions.append(WTFMove(body));
 448     }
 449 
 450     ~YarrPatternConstructor()
 451     {
 452     }
 453 
 454     void resetForReparsing()
 455     {
 456         m_pattern.resetForReparsing();
 457         m_characterClassConstructor.reset();
 458 
<a name="18" id="anc18"></a><span class="line-modified"> 459         auto body = makeUnique&lt;PatternDisjunction&gt;();</span>
 460         m_pattern.m_body = body.get();
 461         m_alternative = body-&gt;addNewAlternative();
 462         m_pattern.m_disjunctions.append(WTFMove(body));
 463     }
 464 
 465     void saveUnmatchedNamedForwardReferences()
 466     {
 467         m_unmatchedNamedForwardReferences.shrink(0);
 468 
 469         for (auto&amp; entry : m_pattern.m_namedForwardReferences) {
 470             if (!m_pattern.m_captureGroupNames.contains(entry))
 471                 m_unmatchedNamedForwardReferences.append(entry);
 472         }
 473     }
 474 
 475     void assertionBOL()
 476     {
 477         if (!m_alternative-&gt;m_terms.size() &amp;&amp; !m_invertParentheticalAssertion) {
 478             m_alternative-&gt;m_startsWithBOL = true;
 479             m_alternative-&gt;m_containsBOL = true;
 480             m_pattern.m_containsBOL = true;
 481         }
 482         m_alternative-&gt;m_terms.append(PatternTerm::BOL());
 483     }
 484     void assertionEOL()
 485     {
 486         m_alternative-&gt;m_terms.append(PatternTerm::EOL());
 487     }
 488     void assertionWordBoundary(bool invert)
 489     {
 490         m_alternative-&gt;m_terms.append(PatternTerm::WordBoundary(invert));
 491     }
 492 
 493     void atomPatternCharacter(UChar32 ch)
 494     {
 495         // We handle case-insensitive checking of unicode characters which do have both
 496         // cases by handling them as if they were defined using a CharacterClass.
 497         if (!m_pattern.ignoreCase() || (isASCII(ch) &amp;&amp; !m_pattern.unicode())) {
 498             m_alternative-&gt;m_terms.append(PatternTerm(ch));
 499             return;
 500         }
 501 
 502         const CanonicalizationRange* info = canonicalRangeInfoFor(ch, m_pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2);
 503         if (info-&gt;type == CanonicalizeUnique) {
 504             m_alternative-&gt;m_terms.append(PatternTerm(ch));
 505             return;
 506         }
 507 
 508         m_characterClassConstructor.putUnicodeIgnoreCase(ch, info);
 509         auto newCharacterClass = m_characterClassConstructor.charClass();
 510         m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass.get(), false));
 511         m_pattern.m_userCharacterClasses.append(WTFMove(newCharacterClass));
 512     }
 513 
 514     void atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert)
 515     {
 516         switch (classID) {
 517         case BuiltInCharacterClassID::DigitClassID:
 518             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.digitsCharacterClass(), invert));
 519             break;
 520         case BuiltInCharacterClassID::SpaceClassID:
 521             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.spacesCharacterClass(), invert));
 522             break;
 523         case BuiltInCharacterClassID::WordClassID:
 524             if (m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())
 525                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.wordUnicodeIgnoreCaseCharCharacterClass(), invert));
 526             else
 527                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.wordcharCharacterClass(), invert));
 528             break;
 529         case BuiltInCharacterClassID::DotClassID:
 530             ASSERT(!invert);
 531             if (m_pattern.dotAll())
 532                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.anyCharacterClass(), false));
 533             else
 534                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.newlineCharacterClass(), true));
 535             break;
 536         default:
 537             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.unicodeCharacterClassFor(classID), invert));
 538             break;
 539         }
 540     }
 541 
 542     void atomCharacterClassBegin(bool invert = false)
 543     {
 544         m_invertCharacterClass = invert;
 545     }
 546 
 547     void atomCharacterClassAtom(UChar32 ch)
 548     {
 549         m_characterClassConstructor.putChar(ch);
 550     }
 551 
 552     void atomCharacterClassRange(UChar32 begin, UChar32 end)
 553     {
 554         m_characterClassConstructor.putRange(begin, end);
 555     }
 556 
 557     void atomCharacterClassBuiltIn(BuiltInCharacterClassID classID, bool invert)
 558     {
 559         ASSERT(classID != BuiltInCharacterClassID::DotClassID);
 560 
 561         switch (classID) {
 562         case BuiltInCharacterClassID::DigitClassID:
 563             m_characterClassConstructor.append(invert ? m_pattern.nondigitsCharacterClass() : m_pattern.digitsCharacterClass());
 564             break;
 565 
 566         case BuiltInCharacterClassID::SpaceClassID:
 567             m_characterClassConstructor.append(invert ? m_pattern.nonspacesCharacterClass() : m_pattern.spacesCharacterClass());
 568             break;
 569 
 570         case BuiltInCharacterClassID::WordClassID:
 571             if (m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())
 572                 m_characterClassConstructor.append(invert ? m_pattern.nonwordUnicodeIgnoreCaseCharCharacterClass() : m_pattern.wordUnicodeIgnoreCaseCharCharacterClass());
 573             else
 574                 m_characterClassConstructor.append(invert ? m_pattern.nonwordcharCharacterClass() : m_pattern.wordcharCharacterClass());
 575             break;
 576 
 577         default:
 578             if (!invert)
 579                 m_characterClassConstructor.append(m_pattern.unicodeCharacterClassFor(classID));
 580             else
 581                 m_characterClassConstructor.appendInverted(m_pattern.unicodeCharacterClassFor(classID));
 582         }
 583     }
 584 
 585     void atomCharacterClassEnd()
 586     {
 587         auto newCharacterClass = m_characterClassConstructor.charClass();
 588 
 589         if (!m_invertCharacterClass &amp;&amp; newCharacterClass.get()-&gt;m_anyCharacter) {
 590             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.anyCharacterClass(), false));
 591             return;
 592         }
 593         m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass.get(), m_invertCharacterClass));
 594         m_pattern.m_userCharacterClasses.append(WTFMove(newCharacterClass));
 595     }
 596 
 597     void atomParenthesesSubpatternBegin(bool capture = true, Optional&lt;String&gt; optGroupName = WTF::nullopt)
 598     {
 599         unsigned subpatternId = m_pattern.m_numSubpatterns + 1;
 600         if (capture) {
 601             m_pattern.m_numSubpatterns++;
 602             if (optGroupName) {
 603                 while (m_pattern.m_captureGroupNames.size() &lt; subpatternId)
 604                     m_pattern.m_captureGroupNames.append(String());
 605                 m_pattern.m_captureGroupNames.append(optGroupName.value());
 606                 m_pattern.m_namedGroupToParenIndex.add(optGroupName.value(), subpatternId);
 607             }
 608         } else
 609             ASSERT(!optGroupName);
 610 
<a name="19" id="anc19"></a><span class="line-modified"> 611         auto parenthesesDisjunction = makeUnique&lt;PatternDisjunction&gt;(m_alternative);</span>
 612         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParenthesesSubpattern, subpatternId, parenthesesDisjunction.get(), capture, false));
 613         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 614         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 615     }
 616 
 617     void atomParentheticalAssertionBegin(bool invert = false)
 618     {
<a name="20" id="anc20"></a><span class="line-modified"> 619         auto parenthesesDisjunction = makeUnique&lt;PatternDisjunction&gt;(m_alternative);</span>
 620         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParentheticalAssertion, m_pattern.m_numSubpatterns + 1, parenthesesDisjunction.get(), false, invert));
 621         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 622         m_invertParentheticalAssertion = invert;
 623         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 624     }
 625 
 626     void atomParenthesesEnd()
 627     {
 628         ASSERT(m_alternative-&gt;m_parent);
 629         ASSERT(m_alternative-&gt;m_parent-&gt;m_parent);
 630 
 631         PatternDisjunction* parenthesesDisjunction = m_alternative-&gt;m_parent;
 632         m_alternative = m_alternative-&gt;m_parent-&gt;m_parent;
 633 
 634         PatternTerm&amp; lastTerm = m_alternative-&gt;lastTerm();
 635 
 636         unsigned numParenAlternatives = parenthesesDisjunction-&gt;m_alternatives.size();
 637         unsigned numBOLAnchoredAlts = 0;
 638 
 639         for (unsigned i = 0; i &lt; numParenAlternatives; i++) {
 640             // Bubble up BOL flags
 641             if (parenthesesDisjunction-&gt;m_alternatives[i]-&gt;m_startsWithBOL)
 642                 numBOLAnchoredAlts++;
 643         }
 644 
 645         if (numBOLAnchoredAlts) {
 646             m_alternative-&gt;m_containsBOL = true;
 647             // If all the alternatives in parens start with BOL, then so does this one
 648             if (numBOLAnchoredAlts == numParenAlternatives)
 649                 m_alternative-&gt;m_startsWithBOL = true;
 650         }
 651 
 652         lastTerm.parentheses.lastSubpatternId = m_pattern.m_numSubpatterns;
 653         m_invertParentheticalAssertion = false;
 654     }
 655 
 656     void atomBackReference(unsigned subpatternId)
 657     {
 658         ASSERT(subpatternId);
 659         m_pattern.m_containsBackreferences = true;
 660         m_pattern.m_maxBackReference = std::max(m_pattern.m_maxBackReference, subpatternId);
 661 
 662         if (subpatternId &gt; m_pattern.m_numSubpatterns) {
 663             m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 664             return;
 665         }
 666 
 667         PatternAlternative* currentAlternative = m_alternative;
 668         ASSERT(currentAlternative);
 669 
 670         // Note to self: if we waited until the AST was baked, we could also remove forwards refs
 671         while ((currentAlternative = currentAlternative-&gt;m_parent-&gt;m_parent)) {
 672             PatternTerm&amp; term = currentAlternative-&gt;lastTerm();
 673             ASSERT((term.type == PatternTerm::TypeParenthesesSubpattern) || (term.type == PatternTerm::TypeParentheticalAssertion));
 674 
 675             if ((term.type == PatternTerm::TypeParenthesesSubpattern) &amp;&amp; term.capture() &amp;&amp; (subpatternId == term.parentheses.subpatternId)) {
 676                 m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 677                 return;
 678             }
 679         }
 680 
 681         m_alternative-&gt;m_terms.append(PatternTerm(subpatternId));
 682     }
 683 
 684     void atomNamedBackReference(const String&amp; subpatternName)
 685     {
 686         ASSERT(m_pattern.m_namedGroupToParenIndex.find(subpatternName) != m_pattern.m_namedGroupToParenIndex.end());
 687         atomBackReference(m_pattern.m_namedGroupToParenIndex.get(subpatternName));
 688     }
 689 
 690     bool isValidNamedForwardReference(const String&amp; subpatternName)
 691     {
 692         return !m_unmatchedNamedForwardReferences.contains(subpatternName);
 693     }
 694 
 695     void atomNamedForwardReference(const String&amp; subpatternName)
 696     {
 697         m_pattern.m_namedForwardReferences.appendIfNotContains(subpatternName);
 698         m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 699     }
 700 
 701     // deep copy the argument disjunction.  If filterStartsWithBOL is true,
 702     // skip alternatives with m_startsWithBOL set true.
 703     PatternDisjunction* copyDisjunction(PatternDisjunction* disjunction, bool filterStartsWithBOL = false)
 704     {
<a name="21" id="anc21"></a><span class="line-added"> 705         if (UNLIKELY(!isSafeToRecurse())) {</span>
<span class="line-added"> 706             m_error = ErrorCode::PatternTooLarge;</span>
<span class="line-added"> 707             return 0;</span>
<span class="line-added"> 708         }</span>
<span class="line-added"> 709 </span>
 710         std::unique_ptr&lt;PatternDisjunction&gt; newDisjunction;
 711         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
 712             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
 713             if (!filterStartsWithBOL || !alternative-&gt;m_startsWithBOL) {
 714                 if (!newDisjunction) {
<a name="22" id="anc22"></a><span class="line-modified"> 715                     newDisjunction = makeUnique&lt;PatternDisjunction&gt;();</span>
 716                     newDisjunction-&gt;m_parent = disjunction-&gt;m_parent;
 717                 }
 718                 PatternAlternative* newAlternative = newDisjunction-&gt;addNewAlternative();
 719                 newAlternative-&gt;m_terms.reserveInitialCapacity(alternative-&gt;m_terms.size());
 720                 for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size(); ++i)
 721                     newAlternative-&gt;m_terms.append(copyTerm(alternative-&gt;m_terms[i], filterStartsWithBOL));
 722             }
 723         }
 724 
<a name="23" id="anc23"></a><span class="line-added"> 725         if (hasError(error())) {</span>
<span class="line-added"> 726             newDisjunction = 0;</span>
<span class="line-added"> 727             return 0;</span>
<span class="line-added"> 728         }</span>
<span class="line-added"> 729 </span>
 730         if (!newDisjunction)
 731             return 0;
 732 
 733         PatternDisjunction* copiedDisjunction = newDisjunction.get();
 734         m_pattern.m_disjunctions.append(WTFMove(newDisjunction));
 735         return copiedDisjunction;
 736     }
 737 
 738     PatternTerm copyTerm(PatternTerm&amp; term, bool filterStartsWithBOL = false)
 739     {
<a name="24" id="anc24"></a><span class="line-added"> 740         if (UNLIKELY(!isSafeToRecurse())) {</span>
<span class="line-added"> 741             m_error = ErrorCode::PatternTooLarge;</span>
<span class="line-added"> 742             return PatternTerm(term);</span>
<span class="line-added"> 743         }</span>
<span class="line-added"> 744 </span>
 745         if ((term.type != PatternTerm::TypeParenthesesSubpattern) &amp;&amp; (term.type != PatternTerm::TypeParentheticalAssertion))
 746             return PatternTerm(term);
 747 
 748         PatternTerm termCopy = term;
 749         termCopy.parentheses.disjunction = copyDisjunction(termCopy.parentheses.disjunction, filterStartsWithBOL);
 750         m_pattern.m_hasCopiedParenSubexpressions = true;
 751         return termCopy;
 752     }
 753 
 754     void quantifyAtom(unsigned min, unsigned max, bool greedy)
 755     {
 756         ASSERT(min &lt;= max);
 757         ASSERT(m_alternative-&gt;m_terms.size());
 758 
 759         if (!max) {
 760             m_alternative-&gt;removeLastTerm();
 761             return;
 762         }
 763 
 764         PatternTerm&amp; term = m_alternative-&gt;lastTerm();
 765         ASSERT(term.type &gt; PatternTerm::TypeAssertionWordBoundary);
 766         ASSERT(term.quantityMinCount == 1 &amp;&amp; term.quantityMaxCount == 1 &amp;&amp; term.quantityType == QuantifierFixedCount);
 767 
 768         if (term.type == PatternTerm::TypeParentheticalAssertion) {
 769             // If an assertion is quantified with a minimum count of zero, it can simply be removed.
 770             // This arises from the RepeatMatcher behaviour in the spec. Matching an assertion never
 771             // results in any input being consumed, however the continuation passed to the assertion
 772             // (called in steps, 8c and 9 of the RepeatMatcher definition, ES5.1 15.10.2.5) will
 773             // reject all zero length matches (see step 2.1). A match from the continuation of the
 774             // expression will still be accepted regardless (via steps 8a and 11) - the upshot of all
 775             // this is that matches from the assertion are not required, and won&#39;t be accepted anyway,
 776             // so no need to ever run it.
 777             if (!min)
 778                 m_alternative-&gt;removeLastTerm();
 779             // We never need to run an assertion more than once. Subsequent interations will be run
 780             // with the same start index (since assertions are non-capturing) and the same captures
 781             // (per step 4 of RepeatMatcher in ES5.1 15.10.2.5), and as such will always produce the
 782             // same result and captures. If the first match succeeds then the subsequent (min - 1)
 783             // matches will too. Any additional optional matches will fail (on the same basis as the
 784             // minimum zero quantified assertions, above), but this will still result in a match.
 785             return;
 786         }
 787 
 788         if (min == max)
 789             term.quantify(min, max, QuantifierFixedCount);
 790         else if (!min || (term.type == PatternTerm::TypeParenthesesSubpattern &amp;&amp; m_pattern.m_hasCopiedParenSubexpressions))
 791             term.quantify(min, max, greedy ? QuantifierGreedy : QuantifierNonGreedy);
 792         else {
 793             term.quantify(min, min, QuantifierFixedCount);
 794             m_alternative-&gt;m_terms.append(copyTerm(term));
 795             // NOTE: this term is interesting from an analysis perspective, in that it can be ignored.....
 796             m_alternative-&gt;lastTerm().quantify((max == quantifyInfinite) ? max : max - min, greedy ? QuantifierGreedy : QuantifierNonGreedy);
 797             if (m_alternative-&gt;lastTerm().type == PatternTerm::TypeParenthesesSubpattern)
 798                 m_alternative-&gt;lastTerm().parentheses.isCopy = true;
 799         }
 800     }
 801 
 802     void disjunction()
 803     {
 804         m_alternative = m_alternative-&gt;m_parent-&gt;addNewAlternative();
 805     }
 806 
 807     ErrorCode setupAlternativeOffsets(PatternAlternative* alternative, unsigned currentCallFrameSize, unsigned initialInputPosition, unsigned&amp; newCallFrameSize) WARN_UNUSED_RETURN
 808     {
 809         if (UNLIKELY(!isSafeToRecurse()))
 810             return ErrorCode::TooManyDisjunctions;
 811 
 812         ErrorCode error = ErrorCode::NoError;
 813         alternative-&gt;m_hasFixedSize = true;
 814         Checked&lt;unsigned, RecordOverflow&gt; currentInputPosition = initialInputPosition;
 815 
 816         for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size(); ++i) {
 817             PatternTerm&amp; term = alternative-&gt;m_terms[i];
 818 
 819             switch (term.type) {
 820             case PatternTerm::TypeAssertionBOL:
 821             case PatternTerm::TypeAssertionEOL:
 822             case PatternTerm::TypeAssertionWordBoundary:
 823                 term.inputPosition = currentInputPosition.unsafeGet();
 824                 break;
 825 
 826             case PatternTerm::TypeBackReference:
 827                 term.inputPosition = currentInputPosition.unsafeGet();
 828                 term.frameLocation = currentCallFrameSize;
 829                 currentCallFrameSize += YarrStackSpaceForBackTrackInfoBackReference;
 830                 alternative-&gt;m_hasFixedSize = false;
 831                 break;
 832 
 833             case PatternTerm::TypeForwardReference:
 834                 break;
 835 
 836             case PatternTerm::TypePatternCharacter:
 837                 term.inputPosition = currentInputPosition.unsafeGet();
 838                 if (term.quantityType != QuantifierFixedCount) {
 839                     term.frameLocation = currentCallFrameSize;
 840                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoPatternCharacter;
 841                     alternative-&gt;m_hasFixedSize = false;
 842                 } else if (m_pattern.unicode()) {
 843                     Checked&lt;unsigned, RecordOverflow&gt; tempCount = term.quantityMaxCount;
 844                     tempCount *= U16_LENGTH(term.patternCharacter);
 845                     if (tempCount.hasOverflowed())
 846                         return ErrorCode::OffsetTooLarge;
 847                     currentInputPosition += tempCount;
 848                 } else
 849                     currentInputPosition += term.quantityMaxCount;
 850                 break;
 851 
 852             case PatternTerm::TypeCharacterClass:
 853                 term.inputPosition = currentInputPosition.unsafeGet();
 854                 if (term.quantityType != QuantifierFixedCount) {
 855                     term.frameLocation = currentCallFrameSize;
 856                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
 857                     alternative-&gt;m_hasFixedSize = false;
 858                 } else if (m_pattern.unicode()) {
 859                     term.frameLocation = currentCallFrameSize;
 860                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
<a name="25" id="anc25"></a><span class="line-modified"> 861                     if (term.characterClass-&gt;hasOneCharacterSize() &amp;&amp; !term.invert()) {</span>
<span class="line-modified"> 862                         Checked&lt;unsigned, RecordOverflow&gt; tempCount = term.quantityMaxCount;</span>
<span class="line-added"> 863                         tempCount *= term.characterClass-&gt;hasNonBMPCharacters() ? 2 : 1;</span>
<span class="line-added"> 864                         if (tempCount.hasOverflowed())</span>
<span class="line-added"> 865                             return ErrorCode::OffsetTooLarge;</span>
<span class="line-added"> 866                         currentInputPosition += tempCount;</span>
<span class="line-added"> 867                     } else {</span>
<span class="line-added"> 868                         currentInputPosition += term.quantityMaxCount;</span>
<span class="line-added"> 869                         alternative-&gt;m_hasFixedSize = false;</span>
<span class="line-added"> 870                     }</span>
 871                 } else
 872                     currentInputPosition += term.quantityMaxCount;
 873                 break;
 874 
 875             case PatternTerm::TypeParenthesesSubpattern:
 876                 // Note: for fixed once parentheses we will ensure at least the minimum is available; others are on their own.
 877                 term.frameLocation = currentCallFrameSize;
 878                 if (term.quantityMaxCount == 1 &amp;&amp; !term.parentheses.isCopy) {
 879                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesOnce;
 880                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 881                     if (hasError(error))
 882                         return error;
 883                     // If quantity is fixed, then pre-check its minimum size.
 884                     if (term.quantityType == QuantifierFixedCount)
 885                         currentInputPosition += term.parentheses.disjunction-&gt;m_minimumSize;
 886                     term.inputPosition = currentInputPosition.unsafeGet();
 887                 } else if (term.parentheses.isTerminal) {
 888                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesTerminal;
 889                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 890                     if (hasError(error))
 891                         return error;
 892                     term.inputPosition = currentInputPosition.unsafeGet();
 893                 } else {
 894                     term.inputPosition = currentInputPosition.unsafeGet();
 895                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParentheses;
 896                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 897                     if (hasError(error))
 898                         return error;
 899                 }
 900                 // Fixed count of 1 could be accepted, if they have a fixed size *AND* if all alternatives are of the same length.
 901                 alternative-&gt;m_hasFixedSize = false;
 902                 break;
 903 
 904             case PatternTerm::TypeParentheticalAssertion:
 905                 term.inputPosition = currentInputPosition.unsafeGet();
 906                 term.frameLocation = currentCallFrameSize;
 907                 error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize + YarrStackSpaceForBackTrackInfoParentheticalAssertion, currentInputPosition.unsafeGet(), currentCallFrameSize);
 908                 if (hasError(error))
 909                     return error;
 910                 break;
 911 
 912             case PatternTerm::TypeDotStarEnclosure:
 913                 ASSERT(!m_pattern.m_saveInitialStartValue);
 914                 alternative-&gt;m_hasFixedSize = false;
 915                 term.inputPosition = initialInputPosition;
 916                 m_pattern.m_initialStartValueFrameLocation = currentCallFrameSize;
 917                 currentCallFrameSize += YarrStackSpaceForDotStarEnclosure;
 918                 m_pattern.m_saveInitialStartValue = true;
 919                 break;
 920             }
 921             if (currentInputPosition.hasOverflowed())
 922                 return ErrorCode::OffsetTooLarge;
 923         }
 924 
 925         alternative-&gt;m_minimumSize = (currentInputPosition - initialInputPosition).unsafeGet();
 926         newCallFrameSize = currentCallFrameSize;
 927         return error;
 928     }
 929 
 930     ErrorCode setupDisjunctionOffsets(PatternDisjunction* disjunction, unsigned initialCallFrameSize, unsigned initialInputPosition, unsigned&amp; callFrameSize)
 931     {
 932         if (UNLIKELY(!isSafeToRecurse()))
 933             return ErrorCode::TooManyDisjunctions;
 934 
 935         if ((disjunction != m_pattern.m_body) &amp;&amp; (disjunction-&gt;m_alternatives.size() &gt; 1))
 936             initialCallFrameSize += YarrStackSpaceForBackTrackInfoAlternative;
 937 
 938         unsigned minimumInputSize = UINT_MAX;
 939         unsigned maximumCallFrameSize = 0;
 940         bool hasFixedSize = true;
 941         ErrorCode error = ErrorCode::NoError;
 942 
 943         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
 944             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
 945             unsigned currentAlternativeCallFrameSize;
 946             error = setupAlternativeOffsets(alternative, initialCallFrameSize, initialInputPosition, currentAlternativeCallFrameSize);
 947             if (hasError(error))
 948                 return error;
 949             minimumInputSize = std::min(minimumInputSize, alternative-&gt;m_minimumSize);
 950             maximumCallFrameSize = std::max(maximumCallFrameSize, currentAlternativeCallFrameSize);
 951             hasFixedSize &amp;= alternative-&gt;m_hasFixedSize;
 952             if (alternative-&gt;m_minimumSize &gt; INT_MAX)
 953                 m_pattern.m_containsUnsignedLengthPattern = true;
 954         }
 955 
 956         ASSERT(minimumInputSize != UINT_MAX);
 957         ASSERT(maximumCallFrameSize &gt;= initialCallFrameSize);
 958 
 959         disjunction-&gt;m_hasFixedSize = hasFixedSize;
 960         disjunction-&gt;m_minimumSize = minimumInputSize;
 961         disjunction-&gt;m_callFrameSize = maximumCallFrameSize;
 962         callFrameSize = maximumCallFrameSize;
 963         return error;
 964     }
 965 
 966     ErrorCode setupOffsets()
 967     {
 968         // FIXME: Yarr should not use the stack to handle subpatterns (rdar://problem/26436314).
 969         unsigned ignoredCallFrameSize;
 970         return setupDisjunctionOffsets(m_pattern.m_body, 0, 0, ignoredCallFrameSize);
 971     }
 972 
 973     // This optimization identifies sets of parentheses that we will never need to backtrack.
 974     // In these cases we do not need to store state from prior iterations.
 975     // We can presently avoid backtracking for:
 976     //   * where the parens are at the end of the regular expression (last term in any of the
 977     //     alternatives of the main body disjunction).
 978     //   * where the parens are non-capturing, and quantified unbounded greedy (*).
 979     //   * where the parens do not contain any capturing subpatterns.
 980     void checkForTerminalParentheses()
 981     {
 982         // This check is much too crude; should be just checking whether the candidate
 983         // node contains nested capturing subpatterns, not the whole expression!
 984         if (m_pattern.m_numSubpatterns)
 985             return;
 986 
 987         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = m_pattern.m_body-&gt;m_alternatives;
 988         for (size_t i = 0; i &lt; alternatives.size(); ++i) {
 989             Vector&lt;PatternTerm&gt;&amp; terms = alternatives[i]-&gt;m_terms;
 990             if (terms.size()) {
 991                 PatternTerm&amp; term = terms.last();
 992                 if (term.type == PatternTerm::TypeParenthesesSubpattern
 993                     &amp;&amp; term.quantityType == QuantifierGreedy
 994                     &amp;&amp; term.quantityMinCount == 0
 995                     &amp;&amp; term.quantityMaxCount == quantifyInfinite
 996                     &amp;&amp; !term.capture())
 997                     term.parentheses.isTerminal = true;
 998             }
 999         }
1000     }
1001 
1002     void optimizeBOL()
1003     {
1004         // Look for expressions containing beginning of line (^) anchoring and unroll them.
1005         // e.g. /^a|^b|c/ becomes /^a|^b|c/ which is executed once followed by /c/ which loops
1006         // This code relies on the parsing code tagging alternatives with m_containsBOL and
1007         // m_startsWithBOL and rolling those up to containing alternatives.
1008         // At this point, this is only valid for non-multiline expressions.
1009         PatternDisjunction* disjunction = m_pattern.m_body;
1010 
1011         if (!m_pattern.m_containsBOL || m_pattern.multiline())
1012             return;
1013 
1014         PatternDisjunction* loopDisjunction = copyDisjunction(disjunction, true);
1015 
1016         // Set alternatives in disjunction to &quot;onceThrough&quot;
1017         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt)
1018             disjunction-&gt;m_alternatives[alt]-&gt;setOnceThrough();
1019 
1020         if (loopDisjunction) {
1021             // Move alternatives from loopDisjunction to disjunction
1022             for (unsigned alt = 0; alt &lt; loopDisjunction-&gt;m_alternatives.size(); ++alt)
1023                 disjunction-&gt;m_alternatives.append(loopDisjunction-&gt;m_alternatives[alt].release());
1024 
1025             loopDisjunction-&gt;m_alternatives.clear();
1026         }
1027     }
1028 
1029     bool containsCapturingTerms(PatternAlternative* alternative, size_t firstTermIndex, size_t endIndex)
1030     {
1031         Vector&lt;PatternTerm&gt;&amp; terms = alternative-&gt;m_terms;
1032 
1033         ASSERT(endIndex &lt;= terms.size());
1034         for (size_t termIndex = firstTermIndex; termIndex &lt; endIndex; ++termIndex) {
1035             PatternTerm&amp; term = terms[termIndex];
1036 
1037             if (term.m_capture)
1038                 return true;
1039 
1040             if (term.type == PatternTerm::TypeParenthesesSubpattern) {
1041                 PatternDisjunction* nestedDisjunction = term.parentheses.disjunction;
1042                 for (unsigned alt = 0; alt &lt; nestedDisjunction-&gt;m_alternatives.size(); ++alt) {
1043                     if (containsCapturingTerms(nestedDisjunction-&gt;m_alternatives[alt].get(), 0, nestedDisjunction-&gt;m_alternatives[alt]-&gt;m_terms.size()))
1044                         return true;
1045                 }
1046             }
1047         }
1048 
1049         return false;
1050     }
1051 
1052     // This optimization identifies alternatives in the form of
1053     // [^].*[?]&lt;expression&gt;.*[$] for expressions that don&#39;t have any
1054     // capturing terms. The alternative is changed to &lt;expression&gt;
1055     // followed by processing of the dot stars to find and adjust the
1056     // beginning and the end of the match.
1057     void optimizeDotStarWrappedExpressions()
1058     {
1059         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = m_pattern.m_body-&gt;m_alternatives;
1060         if (alternatives.size() != 1)
1061             return;
1062 
1063         CharacterClass* dotCharacterClass = m_pattern.dotAll() ? m_pattern.anyCharacterClass() : m_pattern.newlineCharacterClass();
1064         PatternAlternative* alternative = alternatives[0].get();
1065         Vector&lt;PatternTerm&gt;&amp; terms = alternative-&gt;m_terms;
1066         if (terms.size() &gt;= 3) {
1067             bool startsWithBOL = false;
1068             bool endsWithEOL = false;
1069             size_t termIndex, firstExpressionTerm;
1070 
1071             termIndex = 0;
1072             if (terms[termIndex].type == PatternTerm::TypeAssertionBOL) {
1073                 startsWithBOL = true;
1074                 ++termIndex;
1075             }
1076 
1077             PatternTerm&amp; firstNonAnchorTerm = terms[termIndex];
1078             if (firstNonAnchorTerm.type != PatternTerm::TypeCharacterClass
1079                 || firstNonAnchorTerm.characterClass != dotCharacterClass
1080                 || firstNonAnchorTerm.quantityMinCount
1081                 || firstNonAnchorTerm.quantityMaxCount != quantifyInfinite)
1082                 return;
1083 
1084             firstExpressionTerm = termIndex + 1;
1085 
1086             termIndex = terms.size() - 1;
1087             if (terms[termIndex].type == PatternTerm::TypeAssertionEOL) {
1088                 endsWithEOL = true;
1089                 --termIndex;
1090             }
1091 
1092             PatternTerm&amp; lastNonAnchorTerm = terms[termIndex];
1093             if (lastNonAnchorTerm.type != PatternTerm::TypeCharacterClass
1094                 || lastNonAnchorTerm.characterClass != dotCharacterClass
1095                 || lastNonAnchorTerm.quantityType != QuantifierGreedy
1096                 || lastNonAnchorTerm.quantityMinCount
1097                 || lastNonAnchorTerm.quantityMaxCount != quantifyInfinite)
1098                 return;
1099 
1100             size_t endIndex = termIndex;
1101             if (firstExpressionTerm &gt;= endIndex)
1102                 return;
1103 
1104             if (!containsCapturingTerms(alternative, firstExpressionTerm, endIndex)) {
1105                 for (termIndex = terms.size() - 1; termIndex &gt;= endIndex; --termIndex)
1106                     terms.remove(termIndex);
1107 
1108                 for (termIndex = firstExpressionTerm; termIndex &gt; 0; --termIndex)
1109                     terms.remove(termIndex - 1);
1110 
1111                 terms.append(PatternTerm(startsWithBOL, endsWithEOL));
1112 
1113                 m_pattern.m_containsBOL = false;
1114             }
1115         }
1116     }
1117 
<a name="26" id="anc26"></a><span class="line-added">1118     ErrorCode error() { return m_error; }</span>
<span class="line-added">1119 </span>
1120 private:
1121     bool isSafeToRecurse() const
1122     {
1123         if (!m_stackLimit)
1124             return true;
1125         ASSERT(Thread::current().stack().isGrowingDownward());
1126         int8_t* curr = reinterpret_cast&lt;int8_t*&gt;(currentStackPointer());
1127         int8_t* limit = reinterpret_cast&lt;int8_t*&gt;(m_stackLimit);
1128         return curr &gt;= limit;
1129     }
1130 
1131     YarrPattern&amp; m_pattern;
1132     PatternAlternative* m_alternative;
1133     CharacterClassConstructor m_characterClassConstructor;
1134     Vector&lt;String&gt; m_unmatchedNamedForwardReferences;
1135     void* m_stackLimit;
<a name="27" id="anc27"></a><span class="line-added">1136     ErrorCode m_error { ErrorCode::NoError };</span>
1137     bool m_invertCharacterClass;
1138     bool m_invertParentheticalAssertion { false };
1139 };
1140 
1141 ErrorCode YarrPattern::compile(const String&amp; patternString, void* stackLimit)
1142 {
1143     YarrPatternConstructor constructor(*this, stackLimit);
1144 
<a name="28" id="anc28"></a>


1145     {
1146         ErrorCode error = parse(constructor, patternString, unicode());
1147         if (hasError(error))
1148             return error;
1149     }
1150 
1151     // If the pattern contains illegal backreferences reset &amp; reparse.
1152     // Quoting Netscape&#39;s &quot;What&#39;s new in JavaScript 1.2&quot;,
1153     //      &quot;Note: if the number of left parentheses is less than the number specified
1154     //       in \#, the \# is taken as an octal escape as described in the next row.&quot;
1155     if (containsIllegalBackReference() || containsIllegalNamedForwardReferences()) {
1156         if (unicode())
1157             return ErrorCode::InvalidBackreference;
1158 
1159         unsigned numSubpatterns = m_numSubpatterns;
1160 
1161         constructor.saveUnmatchedNamedForwardReferences();
1162         constructor.resetForReparsing();
1163         ErrorCode error = parse(constructor, patternString, unicode(), numSubpatterns);
1164         ASSERT_UNUSED(error, !hasError(error));
1165         ASSERT(numSubpatterns == m_numSubpatterns);
1166     }
1167 
1168     constructor.checkForTerminalParentheses();
1169     constructor.optimizeDotStarWrappedExpressions();
1170     constructor.optimizeBOL();
1171 
<a name="29" id="anc29"></a><span class="line-added">1172     if (hasError(constructor.error()))</span>
<span class="line-added">1173         return constructor.error();</span>
<span class="line-added">1174 </span>
1175     {
1176         ErrorCode error = constructor.setupOffsets();
1177         if (hasError(error))
1178             return error;
1179     }
1180 
1181     if (Options::dumpCompiledRegExpPatterns())
1182         dumpPattern(patternString);
1183 
1184     return ErrorCode::NoError;
1185 }
1186 
<a name="30" id="anc30"></a><span class="line-modified">1187 YarrPattern::YarrPattern(const String&amp; pattern, OptionSet&lt;Flags&gt; flags, ErrorCode&amp; error, void* stackLimit)</span>
1188     : m_containsBackreferences(false)
1189     , m_containsBOL(false)
1190     , m_containsUnsignedLengthPattern(false)
1191     , m_hasCopiedParenSubexpressions(false)
1192     , m_saveInitialStartValue(false)
1193     , m_flags(flags)
1194 {
<a name="31" id="anc31"></a><span class="line-added">1195     ASSERT(m_flags != Flags::DeletedValue);</span>
1196     error = compile(pattern, stackLimit);
1197 }
1198 
1199 void indentForNestingLevel(PrintStream&amp; out, unsigned nestingDepth)
1200 {
1201     out.print(&quot;    &quot;);
1202     for (; nestingDepth; --nestingDepth)
1203         out.print(&quot;  &quot;);
1204 }
1205 
1206 void dumpUChar32(PrintStream&amp; out, UChar32 c)
1207 {
1208     if (c &gt;= &#39; &#39;&amp;&amp; c &lt;= 0xff)
1209         out.printf(&quot;&#39;%c&#39;&quot;, static_cast&lt;char&gt;(c));
1210     else
1211         out.printf(&quot;0x%04x&quot;, c);
1212 }
1213 
1214 void dumpCharacterClass(PrintStream&amp; out, YarrPattern* pattern, CharacterClass* characterClass)
1215 {
1216     if (characterClass == pattern-&gt;anyCharacterClass())
1217         out.print(&quot;&lt;any character&gt;&quot;);
1218     else if (characterClass == pattern-&gt;newlineCharacterClass())
1219         out.print(&quot;&lt;newline&gt;&quot;);
1220     else if (characterClass == pattern-&gt;digitsCharacterClass())
1221         out.print(&quot;&lt;digits&gt;&quot;);
1222     else if (characterClass == pattern-&gt;spacesCharacterClass())
1223         out.print(&quot;&lt;whitespace&gt;&quot;);
1224     else if (characterClass == pattern-&gt;wordcharCharacterClass())
1225         out.print(&quot;&lt;word&gt;&quot;);
1226     else if (characterClass == pattern-&gt;wordUnicodeIgnoreCaseCharCharacterClass())
1227         out.print(&quot;&lt;unicode word ignore case&gt;&quot;);
1228     else if (characterClass == pattern-&gt;nondigitsCharacterClass())
1229         out.print(&quot;&lt;non-digits&gt;&quot;);
1230     else if (characterClass == pattern-&gt;nonspacesCharacterClass())
1231         out.print(&quot;&lt;non-whitespace&gt;&quot;);
1232     else if (characterClass == pattern-&gt;nonwordcharCharacterClass())
1233         out.print(&quot;&lt;non-word&gt;&quot;);
1234     else if (characterClass == pattern-&gt;nonwordUnicodeIgnoreCaseCharCharacterClass())
1235         out.print(&quot;&lt;unicode non-word ignore case&gt;&quot;);
1236     else {
1237         bool needMatchesRangesSeperator = false;
1238 
1239         auto dumpMatches = [&amp;] (const char* prefix, Vector&lt;UChar32&gt; matches) {
1240             size_t matchesSize = matches.size();
1241             if (matchesSize) {
1242                 if (needMatchesRangesSeperator)
1243                     out.print(&quot;,&quot;);
1244                 needMatchesRangesSeperator = true;
1245 
1246                 out.print(prefix, &quot;:(&quot;);
1247                 for (size_t i = 0; i &lt; matchesSize; ++i) {
1248                     if (i)
1249                         out.print(&quot;,&quot;);
1250                     dumpUChar32(out, matches[i]);
1251                 }
1252                 out.print(&quot;)&quot;);
1253             }
1254         };
1255 
1256         auto dumpRanges = [&amp;] (const char* prefix, Vector&lt;CharacterRange&gt; ranges) {
1257             size_t rangeSize = ranges.size();
1258             if (rangeSize) {
1259                 if (needMatchesRangesSeperator)
1260                     out.print(&quot;,&quot;);
1261                 needMatchesRangesSeperator = true;
1262 
1263                 out.print(prefix, &quot; ranges:(&quot;);
1264                 for (size_t i = 0; i &lt; rangeSize; ++i) {
1265                     if (i)
1266                         out.print(&quot;,&quot;);
1267                     CharacterRange range = ranges[i];
1268                     out.print(&quot;(&quot;);
1269                     dumpUChar32(out, range.begin);
1270                     out.print(&quot;..&quot;);
1271                     dumpUChar32(out, range.end);
1272                     out.print(&quot;)&quot;);
1273                 }
1274                 out.print(&quot;)&quot;);
1275             }
1276         };
1277 
1278         out.print(&quot;[&quot;);
1279         dumpMatches(&quot;ASCII&quot;, characterClass-&gt;m_matches);
1280         dumpRanges(&quot;ASCII&quot;, characterClass-&gt;m_ranges);
1281         dumpMatches(&quot;Unicode&quot;, characterClass-&gt;m_matchesUnicode);
1282         dumpRanges(&quot;Unicode&quot;, characterClass-&gt;m_rangesUnicode);
1283         out.print(&quot;]&quot;);
1284     }
1285 }
1286 
1287 void PatternAlternative::dump(PrintStream&amp; out, YarrPattern* thisPattern, unsigned nestingDepth)
1288 {
1289     out.print(&quot;minimum size: &quot;, m_minimumSize);
1290     if (m_hasFixedSize)
1291         out.print(&quot;,fixed size&quot;);
1292     if (m_onceThrough)
1293         out.print(&quot;,once through&quot;);
1294     if (m_startsWithBOL)
1295         out.print(&quot;,starts with ^&quot;);
1296     if (m_containsBOL)
1297         out.print(&quot;,contains ^&quot;);
1298     out.print(&quot;\n&quot;);
1299 
1300     for (size_t i = 0; i &lt; m_terms.size(); ++i)
1301         m_terms[i].dump(out, thisPattern, nestingDepth);
1302 }
1303 
1304 void PatternTerm::dumpQuantifier(PrintStream&amp; out)
1305 {
1306     if (quantityType == QuantifierFixedCount &amp;&amp; quantityMinCount == 1 &amp;&amp; quantityMaxCount == 1)
1307         return;
1308     out.print(&quot; {&quot;, quantityMinCount.unsafeGet());
1309     if (quantityMinCount != quantityMaxCount) {
1310         if (quantityMaxCount == UINT_MAX)
1311             out.print(&quot;,...&quot;);
1312         else
1313             out.print(&quot;,&quot;, quantityMaxCount.unsafeGet());
1314     }
1315     out.print(&quot;}&quot;);
1316     if (quantityType == QuantifierGreedy)
1317         out.print(&quot; greedy&quot;);
1318     else if (quantityType == QuantifierNonGreedy)
1319         out.print(&quot; non-greedy&quot;);
1320 }
1321 
1322 void PatternTerm::dump(PrintStream&amp; out, YarrPattern* thisPattern, unsigned nestingDepth)
1323 {
1324     indentForNestingLevel(out, nestingDepth);
1325 
1326     if (type != TypeParenthesesSubpattern &amp;&amp; type != TypeParentheticalAssertion) {
1327         if (invert())
1328             out.print(&quot;not &quot;);
1329     }
1330 
1331     switch (type) {
1332     case TypeAssertionBOL:
1333         out.println(&quot;BOL&quot;);
1334         break;
1335     case TypeAssertionEOL:
1336         out.println(&quot;EOL&quot;);
1337         break;
1338     case TypeAssertionWordBoundary:
1339         out.println(&quot;word boundary&quot;);
1340         break;
1341     case TypePatternCharacter:
1342         out.printf(&quot;character &quot;);
1343         out.printf(&quot;inputPosition %u &quot;, inputPosition);
1344         if (thisPattern-&gt;ignoreCase() &amp;&amp; isASCIIAlpha(patternCharacter)) {
1345             dumpUChar32(out, toASCIIUpper(patternCharacter));
1346             out.print(&quot;/&quot;);
1347             dumpUChar32(out, toASCIILower(patternCharacter));
1348         } else
1349             dumpUChar32(out, patternCharacter);
1350         dumpQuantifier(out);
1351         if (quantityType != QuantifierFixedCount)
1352             out.print(&quot;,frame location &quot;, frameLocation);
1353         out.println();
1354         break;
1355     case TypeCharacterClass:
1356         out.print(&quot;character class &quot;);
<a name="32" id="anc32"></a><span class="line-added">1357         out.printf(&quot;inputPosition %u &quot;, inputPosition);</span>
1358         dumpCharacterClass(out, thisPattern, characterClass);
1359         dumpQuantifier(out);
1360         if (quantityType != QuantifierFixedCount || thisPattern-&gt;unicode())
1361             out.print(&quot;,frame location &quot;, frameLocation);
1362         out.println();
1363         break;
1364     case TypeBackReference:
1365         out.print(&quot;back reference to subpattern #&quot;, backReferenceSubpatternId);
1366         out.println(&quot;,frame location &quot;, frameLocation);
1367         break;
1368     case TypeForwardReference:
1369         out.println(&quot;forward reference&quot;);
1370         break;
1371     case TypeParenthesesSubpattern:
1372         if (m_capture)
1373             out.print(&quot;captured &quot;);
1374         else
1375             out.print(&quot;non-captured &quot;);
1376 
1377         FALLTHROUGH;
1378     case TypeParentheticalAssertion:
1379         if (m_invert)
1380             out.print(&quot;inverted &quot;);
1381 
1382         if (type == TypeParenthesesSubpattern)
1383             out.print(&quot;subpattern&quot;);
1384         else if (type == TypeParentheticalAssertion)
1385             out.print(&quot;assertion&quot;);
1386 
1387         if (m_capture)
1388             out.print(&quot; #&quot;, parentheses.subpatternId);
1389 
1390         dumpQuantifier(out);
1391 
1392         if (parentheses.isCopy)
1393             out.print(&quot;,copy&quot;);
1394 
1395         if (parentheses.isTerminal)
1396             out.print(&quot;,terminal&quot;);
1397 
1398         out.println(&quot;,frame location &quot;, frameLocation);
1399 
1400         if (parentheses.disjunction-&gt;m_alternatives.size() &gt; 1) {
1401             indentForNestingLevel(out, nestingDepth + 1);
1402             unsigned alternativeFrameLocation = frameLocation;
1403             if (quantityMaxCount == 1 &amp;&amp; !parentheses.isCopy)
1404                 alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce;
1405             else if (parentheses.isTerminal)
1406                 alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesTerminal;
1407             else
1408                 alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParentheses;
1409             out.println(&quot;alternative list,frame location &quot;, alternativeFrameLocation);
1410         }
1411 
1412         parentheses.disjunction-&gt;dump(out, thisPattern, nestingDepth + 1);
1413         break;
1414     case TypeDotStarEnclosure:
1415         out.println(&quot;.* enclosure,frame location &quot;, thisPattern-&gt;m_initialStartValueFrameLocation);
1416         break;
1417     }
1418 }
1419 
1420 void PatternDisjunction::dump(PrintStream&amp; out, YarrPattern* thisPattern, unsigned nestingDepth = 0)
1421 {
1422     unsigned alternativeCount = m_alternatives.size();
1423     for (unsigned i = 0; i &lt; alternativeCount; ++i) {
1424         indentForNestingLevel(out, nestingDepth);
1425         if (alternativeCount &gt; 1)
1426             out.print(&quot;alternative #&quot;, i, &quot;: &quot;);
1427         m_alternatives[i].get()-&gt;dump(out, thisPattern, nestingDepth + (alternativeCount &gt; 1));
1428     }
1429 }
1430 
1431 void YarrPattern::dumpPatternString(PrintStream&amp; out, const String&amp; patternString)
1432 {
1433     out.print(&quot;/&quot;, patternString, &quot;/&quot;);
1434 
1435     if (global())
1436         out.print(&quot;g&quot;);
1437     if (ignoreCase())
1438         out.print(&quot;i&quot;);
1439     if (multiline())
1440         out.print(&quot;m&quot;);
1441     if (unicode())
1442         out.print(&quot;u&quot;);
1443     if (sticky())
1444         out.print(&quot;y&quot;);
1445 }
1446 
1447 void YarrPattern::dumpPattern(const String&amp; patternString)
1448 {
1449     dumpPattern(WTF::dataFile(), patternString);
1450 }
1451 
1452 void YarrPattern::dumpPattern(PrintStream&amp; out, const String&amp; patternString)
1453 {
1454     out.print(&quot;RegExp pattern for &quot;);
1455     dumpPatternString(out, patternString);
1456 
<a name="33" id="anc33"></a><span class="line-modified">1457     if (m_flags) {</span>
<span class="line-modified">1458         bool printSeparator = false;</span>
1459         out.print(&quot; (&quot;);
1460         if (global()) {
1461             out.print(&quot;global&quot;);
<a name="34" id="anc34"></a><span class="line-modified">1462             printSeparator = true;</span>
1463         }
1464         if (ignoreCase()) {
<a name="35" id="anc35"></a><span class="line-modified">1465             if (printSeparator)</span>
1466                 out.print(&quot;|&quot;);
1467             out.print(&quot;ignore case&quot;);
<a name="36" id="anc36"></a><span class="line-modified">1468             printSeparator = true;</span>
1469         }
1470         if (multiline()) {
<a name="37" id="anc37"></a><span class="line-modified">1471             if (printSeparator)</span>
1472                 out.print(&quot;|&quot;);
1473             out.print(&quot;multiline&quot;);
<a name="38" id="anc38"></a><span class="line-modified">1474             printSeparator = true;</span>
1475         }
1476         if (unicode()) {
<a name="39" id="anc39"></a><span class="line-modified">1477             if (printSeparator)</span>
1478                 out.print(&quot;|&quot;);
1479             out.print(&quot;unicode&quot;);
<a name="40" id="anc40"></a><span class="line-modified">1480             printSeparator = true;</span>
1481         }
1482         if (sticky()) {
<a name="41" id="anc41"></a><span class="line-modified">1483             if (printSeparator)</span>
1484                 out.print(&quot;|&quot;);
1485             out.print(&quot;sticky&quot;);
<a name="42" id="anc42"></a>
1486         }
1487         out.print(&quot;)&quot;);
1488     }
1489     out.print(&quot;:\n&quot;);
1490     if (m_body-&gt;m_callFrameSize)
1491         out.print(&quot;    callframe size: &quot;, m_body-&gt;m_callFrameSize, &quot;\n&quot;);
1492     m_body-&gt;dump(out, this);
1493 }
1494 
1495 std::unique_ptr&lt;CharacterClass&gt; anycharCreate()
1496 {
<a name="43" id="anc43"></a><span class="line-modified">1497     auto characterClass = makeUnique&lt;CharacterClass&gt;();</span>
1498     characterClass-&gt;m_ranges.append(CharacterRange(0x00, 0x7f));
1499     characterClass-&gt;m_rangesUnicode.append(CharacterRange(0x0080, 0x10ffff));
<a name="44" id="anc44"></a><span class="line-modified">1500     characterClass-&gt;m_characterWidths = CharacterClassWidths::HasBothBMPAndNonBMP;</span>
1501     characterClass-&gt;m_anyCharacter = true;
1502     return characterClass;
1503 }
1504 
1505 } } // namespace JSC::Yarr
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>