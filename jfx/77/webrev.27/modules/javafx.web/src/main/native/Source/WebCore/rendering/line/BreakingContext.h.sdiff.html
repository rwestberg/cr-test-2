<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/line/BreakingContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TextPainter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LineBreaker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/line/BreakingContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  97         : m_lineBreaker(lineBreaker)
  98         , m_resolver(resolver)
  99         , m_current(resolver.position())
 100         , m_lineBreak(resolver.position())
 101         , m_block(block)
 102         , m_lastObject(m_current.renderer())
 103         , m_nextObject(nullptr)
 104         , m_currentStyle(nullptr)
 105         , m_blockStyle(block.style())
 106         , m_lineInfo(inLineInfo)
 107         , m_renderTextInfo(inRenderTextInfo)
 108         , m_lastFloatFromPreviousLine(inLastFloatFromPreviousLine)
 109         , m_width(lineWidth)
 110         , m_currWS(WhiteSpace::Normal)
 111         , m_lastWS(WhiteSpace::Normal)
 112         , m_preservesNewline(false)
 113         , m_atStart(true)
 114         , m_ignoringSpaces(false)
 115         , m_currentCharacterIsSpace(false)
 116         , m_currentCharacterIsWS(false)

 117         , m_appliedStartWidth(appliedStartWidth)
 118         , m_includeEndWidth(true)
 119         , m_autoWrap(false)
 120         , m_autoWrapWasEverTrueOnLine(false)
 121         , m_floatsFitOnLine(true)
 122         , m_collapseWhiteSpace(false)
 123         , m_startingNewParagraph(m_lineInfo.previousLineBrokeCleanly())
 124         , m_allowImagesToBreak(!block.document().inQuirksMode() || !block.isTableCell() || !m_blockStyle.logicalWidth().isIntrinsicOrAuto())
 125         , m_atEnd(false)
 126         , m_hadUncommittedWidthBeforeCurrent(false)
 127         , m_lineWhitespaceCollapsingState(resolver.whitespaceCollapsingState())
 128     {
 129         m_lineInfo.setPreviousLineBrokeCleanly(false);
 130     }
 131 
 132     RenderObject* currentObject() { return m_current.renderer(); }
 133     InlineIterator lineBreak() { return m_lineBreak; }
 134     LineWidth&amp; lineWidth() { return m_width; }
 135     bool atEnd() { return m_atEnd; }
 136 
 137     bool fitsOnLineOrHangsAtEnd() const { return m_width.fitsOnLine() || m_hangsAtEnd; }
 138 
 139     void initializeForCurrentObject();
 140 
 141     void increment();
 142 
 143     void handleBR(Clear&amp;);
 144     void handleOutOfFlowPositioned(Vector&lt;RenderBox*&gt;&amp; positionedObjects);
 145     void handleFloat();
 146     void handleEmptyInline();
 147     void handleReplaced();
 148     bool handleText(WordMeasurements&amp;, bool&amp; hyphenated, unsigned&amp; consecutiveHyphenatedLines);

 149     bool canBreakAtThisPosition();
 150     void commitAndUpdateLineBreakIfNeeded();
 151     InlineIterator handleEndOfLine();
 152 
 153     float computeAdditionalBetweenWordsWidth(RenderText&amp;, TextLayout*, UChar, WordTrailingSpace&amp;, HashSet&lt;const Font*&gt;&amp; fallbackFonts, WordMeasurements&amp;, const FontCascade&amp;, bool isFixedPitch, unsigned lastSpace, float lastSpaceWordSpacing, float wordSpacingForWordMeasurement, unsigned offset);
 154 
 155     void clearLineBreakIfFitsOnLine(bool ignoringTrailingSpace = false)
 156     {
 157         if (m_width.fitsOnLine(ignoringTrailingSpace) || m_lastWS == WhiteSpace::NoWrap || m_hangsAtEnd)
 158             m_lineBreak.clear();
 159         m_hangsAtEnd = false;
 160     }
 161 
 162     void commitLineBreakClear()
 163     {
 164         m_width.commit();
 165         m_lineBreak.clear();
 166         m_hangsAtEnd = false;
 167     }
 168 
</pre>
<hr />
<pre>
 198 
 199     FloatingObject* m_lastFloatFromPreviousLine;
 200 
 201     LineWidth m_width;
 202 
 203     WhiteSpace m_currWS;
 204     WhiteSpace m_lastWS;
 205 
 206     bool m_preservesNewline;
 207     bool m_atStart;
 208 
 209     // This variable is used only if whitespace isn&#39;t set to WhiteSpace::Pre, and it tells us whether
 210     // or not we are currently ignoring whitespace.
 211     bool m_ignoringSpaces;
 212 
 213     // This variable tracks whether the very last character we saw was a space. We use
 214     // this to detect when we encounter a second space so we know we have to terminate
 215     // a run.
 216     bool m_currentCharacterIsSpace;
 217     bool m_currentCharacterIsWS;

 218     bool m_appliedStartWidth;
 219     bool m_includeEndWidth;
 220     bool m_autoWrap;
 221     bool m_autoWrapWasEverTrueOnLine;
 222     bool m_floatsFitOnLine;
 223     bool m_collapseWhiteSpace;
 224     bool m_startingNewParagraph;
 225     bool m_allowImagesToBreak;
 226     bool m_atEnd;
 227     bool m_hadUncommittedWidthBeforeCurrent;
 228 
 229     bool m_hangsAtEnd { false };
 230 
 231     LineWhitespaceCollapsingState&amp; m_lineWhitespaceCollapsingState;
 232 
 233     TrailingObjects m_trailingObjects;
 234 };
 235 
 236 inline void BreakingContext::initializeForCurrentObject()
 237 {
</pre>
<hr />
<pre>
 556         return text.width(from, len, font, xPos, &amp;fallbackFonts, &amp;glyphOverflow);
 557 
 558     if (layout)
 559         return FontCascade::width(*layout, from, len, &amp;fallbackFonts);
 560 
 561     TextRun run = RenderBlock::constructTextRun(text, from, len, style);
 562     run.setCharacterScanForCodePath(!text.canUseSimpleFontCodePath());
 563     run.setTabSize(!collapseWhiteSpace, style.tabSize());
 564     run.setXPos(xPos);
 565     return font.width(run, &amp;fallbackFonts, &amp;glyphOverflow);
 566 }
 567 
 568 // Adding a pair of whitespace collapsing transitions before a character will split it out into a new line box.
 569 inline void ensureCharacterGetsLineBox(LineWhitespaceCollapsingState&amp; lineWhitespaceCollapsingState, InlineIterator&amp; textParagraphSeparator)
 570 {
 571     InlineIterator transition(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset());
 572     lineWhitespaceCollapsingState.startIgnoringSpaces(InlineIterator(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset() - 1));
 573     lineWhitespaceCollapsingState.stopIgnoringSpaces(InlineIterator(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset()));
 574 }
 575 
<span class="line-modified"> 576 inline void tryHyphenating(RenderText&amp; text, const FontCascade&amp; font, const AtomicString&amp; localeIdentifier, unsigned consecutiveHyphenatedLines, int consecutiveHyphenatedLinesLimit, int minimumPrefixLimit, int minimumSuffixLimit, unsigned lastSpace, unsigned pos, float xPos, float availableWidth, bool isFixedPitch, bool collapseWhiteSpace, int lastSpaceWordSpacing, InlineIterator&amp; lineBreak, Optional&lt;unsigned&gt; nextBreakable, bool&amp; hyphenated)</span>
 577 {
 578     // Map &#39;hyphenate-limit-{before,after}: auto;&#39; to 2.
 579     unsigned minimumPrefixLength;
 580     unsigned minimumSuffixLength;
 581 
 582     if (minimumPrefixLimit &lt; 0)
 583         minimumPrefixLength = 2;
 584     else
 585         minimumPrefixLength = static_cast&lt;unsigned&gt;(minimumPrefixLimit);
 586 
 587     if (minimumSuffixLimit &lt; 0)
 588         minimumSuffixLength = 2;
 589     else
 590         minimumSuffixLength = static_cast&lt;unsigned&gt;(minimumSuffixLimit);
 591 
 592     if (pos - lastSpace &lt;= minimumSuffixLength)
 593         return;
 594 
 595     if (consecutiveHyphenatedLinesLimit &gt;= 0 &amp;&amp; consecutiveHyphenatedLines &gt;= static_cast&lt;unsigned&gt;(consecutiveHyphenatedLinesLimit))
 596         return;
</pre>
<hr />
<pre>
 693     const FontCascade&amp; font = style.fontCascade();
 694     bool isFixedPitch = font.isFixedPitch();
 695     bool canHyphenate = style.hyphens() == Hyphens::Auto &amp;&amp; WebCore::canHyphenate(style.locale());
 696     bool canHangPunctuationAtStart = style.hangingPunctuation().contains(HangingPunctuation::First);
 697     bool canHangPunctuationAtEnd = style.hangingPunctuation().contains(HangingPunctuation::Last);
 698     bool canHangStopOrCommaAtLineEnd = style.hangingPunctuation().contains(HangingPunctuation::AllowEnd);
 699     int endPunctuationIndex = canHangPunctuationAtEnd &amp;&amp; m_collapseWhiteSpace ? renderText.lastCharacterIndexStrippingSpaces() : renderText.text().length() - 1;
 700     unsigned lastSpace = m_current.offset();
 701     float wordSpacing = m_currentStyle-&gt;fontCascade().wordSpacing();
 702     float lastSpaceWordSpacing = 0;
 703     float wordSpacingForWordMeasurement = 0;
 704 
 705     float wrapWidthOffset = m_width.uncommittedWidth() + inlineLogicalWidth(m_current.renderer(), !m_appliedStartWidth, true);
 706     float wrapW = wrapWidthOffset;
 707     float charWidth = 0;
 708     bool breakNBSP = m_autoWrap &amp;&amp; m_currentStyle-&gt;nbspMode() == NBSPMode::Space;
 709     // Auto-wrapping text should wrap in the middle of a word only if it could not wrap before the word,
 710     // which is only possible if the word is the first thing on the line.
 711     bool breakWords = m_currentStyle-&gt;breakWords() &amp;&amp; ((m_autoWrap &amp;&amp; (!m_width.committedWidth() &amp;&amp; !m_width.hasCommittedReplaced())) || m_currWS == WhiteSpace::Pre);
 712     bool midWordBreak = false;
<span class="line-modified"> 713     bool breakAll = m_currentStyle-&gt;wordBreak() == WordBreak::BreakAll &amp;&amp; m_autoWrap;</span>

 714     bool keepAllWords = m_currentStyle-&gt;wordBreak() == WordBreak::KeepAll;
 715     float hyphenWidth = 0;
 716     auto iteratorMode = mapLineBreakToIteratorMode(m_blockStyle.lineBreak());
 717     bool canUseLineBreakShortcut = iteratorMode == LineBreakIteratorMode::Default;
 718     bool isLineEmpty = m_lineInfo.isEmpty();
 719 
 720     if (isSVGText) {
 721         breakWords = false;
 722         breakAll = false;
 723     }
 724 
 725     if (m_renderTextInfo.text != &amp;renderText) {
 726         updateCounterIfNeeded(renderText);
 727         m_renderTextInfo.text = &amp;renderText;
 728         m_renderTextInfo.font = &amp;font;
 729         m_renderTextInfo.layout = font.createLayout(renderText, m_width.currentWidth(), m_collapseWhiteSpace);
 730         m_renderTextInfo.lineBreakIterator.resetStringAndReleaseIterator(renderText.text(), style.locale(), iteratorMode);
 731     } else if (m_renderTextInfo.layout &amp;&amp; m_renderTextInfo.font != &amp;font) {
 732         m_renderTextInfo.font = &amp;font;
 733         m_renderTextInfo.layout = font.createLayout(renderText, m_width.currentWidth(), m_collapseWhiteSpace);
 734     }
 735 
 736     HashSet&lt;const Font*&gt; fallbackFonts;


 737     UChar lastCharacterFromPreviousRenderText = m_renderTextInfo.lineBreakIterator.lastCharacter();
 738     UChar lastCharacter = m_renderTextInfo.lineBreakIterator.lastCharacter();
 739     UChar secondToLastCharacter = m_renderTextInfo.lineBreakIterator.secondToLastCharacter();
 740     // Non-zero only when kerning is enabled and TextLayout isn&#39;t used, in which case we measure
 741     // words with their trailing space, then subtract its width.
 742     TextLayout* textLayout = m_renderTextInfo.layout.get();
 743     WordTrailingSpace wordTrailingSpace(style, !textLayout);
 744     for (; m_current.offset() &lt; renderText.text().length(); m_current.fastIncrementInTextNode()) {
 745         bool previousCharacterIsSpace = m_currentCharacterIsSpace;
 746         bool previousCharacterIsWS = m_currentCharacterIsWS;
 747         UChar c = m_current.current();
 748         m_currentCharacterIsSpace = c == &#39; &#39; || c == &#39;\t&#39; || (!m_preservesNewline &amp;&amp; (c == &#39;\n&#39;));
 749 








 750         if (canHangPunctuationAtStart &amp;&amp; m_width.isFirstLine() &amp;&amp; !m_width.committedWidth() &amp;&amp; !wrapW &amp;&amp; !inlineLogicalWidth(m_current.renderer(), true, false)) {
 751             m_width.addUncommittedWidth(-renderText.hangablePunctuationStartWidth(m_current.offset()));
 752             canHangPunctuationAtStart = false;
 753         }
 754 
 755         if (canHangPunctuationAtEnd &amp;&amp; !m_nextObject &amp;&amp; (int)m_current.offset() == endPunctuationIndex &amp;&amp; !inlineLogicalWidth(m_current.renderer(), false, true)) {
 756             m_width.addUncommittedWidth(-renderText.hangablePunctuationEndWidth(endPunctuationIndex));
 757             canHangPunctuationAtEnd = false;
 758         }
 759 
 760         if (!m_collapseWhiteSpace || !m_currentCharacterIsSpace)
 761             m_lineInfo.setEmpty(false, &amp;m_block, &amp;m_width);
 762 
 763         if (c == softHyphen &amp;&amp; m_autoWrap &amp;&amp; !hyphenWidth &amp;&amp; style.hyphens() != Hyphens::None) {
 764             hyphenWidth = measureHyphenWidth(renderText, font, &amp;fallbackFonts);
 765             m_width.addUncommittedWidth(hyphenWidth);
 766         }
 767 
 768         bool applyWordSpacing = false;
 769 
 770         m_currentCharacterIsWS = m_currentCharacterIsSpace || (breakNBSP &amp;&amp; c == noBreakSpace);
 771 
<span class="line-modified"> 772         if ((breakAll || breakWords) &amp;&amp; !midWordBreak &amp;&amp; (!m_currentCharacterIsSpace || style.whiteSpace() != WhiteSpace::PreWrap)) {</span>
 773             wrapW += charWidth;
 774             bool midWordBreakIsBeforeSurrogatePair = U16_IS_LEAD(c) &amp;&amp; U16_IS_TRAIL(renderText.characterAt(m_current.offset() + 1));
 775             charWidth = textWidth(renderText, m_current.offset(), midWordBreakIsBeforeSurrogatePair ? 2 : 1, font, m_width.committedWidth() + wrapW, isFixedPitch, m_collapseWhiteSpace, fallbackFonts, textLayout);
 776             midWordBreak = m_width.committedWidth() + wrapW + charWidth &gt; m_width.availableWidth();
 777         }
 778 
 779         Optional&lt;unsigned&gt; nextBreakablePosition = m_current.nextBreakablePosition();
<span class="line-modified"> 780         bool betweenWords = c == &#39;\n&#39; || (m_currWS != WhiteSpace::Pre &amp;&amp; !m_atStart &amp;&amp; isBreakable(m_renderTextInfo.lineBreakIterator, m_current.offset(), nextBreakablePosition, breakNBSP, canUseLineBreakShortcut, keepAllWords)</span>
 781             &amp;&amp; (style.hyphens() != Hyphens::None || (m_current.previousInSameNode() != softHyphen)));
 782         m_current.setNextBreakablePosition(nextBreakablePosition);
 783 
 784         if (canHangStopOrCommaAtLineEnd &amp;&amp; renderText.isHangableStopOrComma(c) &amp;&amp; m_width.fitsOnLine()) {
 785             // We need to see if a measurement that excludes the stop would fit. If so, then we should hang
 786             // the stop/comma at the end. First measure including the comma.
 787             m_hangsAtEnd = false;
 788             float inlineStartWidth = !m_appliedStartWidth ? inlineLogicalWidth(m_current.renderer(), true, false) : 0_lu;
 789             float widthIncludingComma = computeAdditionalBetweenWordsWidth(renderText, textLayout, c, wordTrailingSpace, fallbackFonts, wordMeasurements, font, isFixedPitch, lastSpace, lastSpaceWordSpacing, wordSpacingForWordMeasurement, m_current.offset() + 1) + inlineStartWidth;
 790             m_width.addUncommittedWidth(widthIncludingComma);
 791             if (!m_width.fitsOnLine()) {
 792                 // See if we fit without the comma involved. If we do, then this is a potential hang point.
 793                 float widthWithoutStopOrComma = computeAdditionalBetweenWordsWidth(renderText, textLayout, lastCharacter, wordTrailingSpace, fallbackFonts, wordMeasurements, font, isFixedPitch, lastSpace, lastSpaceWordSpacing, wordSpacingForWordMeasurement, m_current.offset()) + inlineStartWidth;
 794                 m_width.addUncommittedWidth(widthWithoutStopOrComma - widthIncludingComma);
 795                 if (m_width.fitsOnLine())
 796                     m_hangsAtEnd = true;
 797             } else
 798                 m_width.addUncommittedWidth(-widthIncludingComma);
 799         }
 800 
</pre>
<hr />
<pre>
 824             if (m_collapseWhiteSpace &amp;&amp; previousCharacterIsSpace &amp;&amp; m_currentCharacterIsSpace &amp;&amp; additionalTempWidth)
 825                 m_width.setTrailingWhitespaceWidth(additionalTempWidth);
 826 
 827             if (!m_appliedStartWidth) {
 828                 float inlineStartWidth = inlineLogicalWidth(m_current.renderer(), true, false);
 829                 m_width.addUncommittedWidth(inlineStartWidth);
 830                 m_appliedStartWidth = true;
 831                 if (m_hangsAtEnd &amp;&amp; inlineStartWidth)
 832                     m_hangsAtEnd = false;
 833             }
 834 
 835             applyWordSpacing = wordSpacing &amp;&amp; m_currentCharacterIsSpace;
 836 
 837             if (!m_width.hasCommitted() &amp;&amp; m_autoWrap &amp;&amp; !fitsOnLineOrHangsAtEnd())
 838                 m_width.fitBelowFloats(m_lineInfo.isFirstLine());
 839 
 840             if (m_autoWrap || breakWords) {
 841                 // If we break only after white-space, consider the current character
 842                 // as candidate width for this line.
 843                 bool lineWasTooWide = false;
<span class="line-modified"> 844                 if (fitsOnLineOrHangsAtEnd() &amp;&amp; m_currentCharacterIsWS &amp;&amp; m_currentStyle-&gt;breakOnlyAfterWhiteSpace() &amp;&amp; !midWordBreak) {</span>
 845                     float charWidth = textWidth(renderText, m_current.offset(), 1, font, m_width.currentWidth(), isFixedPitch, m_collapseWhiteSpace, wordMeasurement.fallbackFonts, textLayout) + (applyWordSpacing ? wordSpacing : 0);
 846                     // Check if line is too big even without the extra space
 847                     // at the end of the line. If it is not, do nothing.
 848                     // If the line needs the extra whitespace to be too long,
 849                     // then move the line break to the space and skip all
 850                     // additional whitespace.
 851                     if (!m_width.fitsOnLineIncludingExtraWidth(charWidth)) {
 852                         lineWasTooWide = true;
<span class="line-modified"> 853                         m_lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());</span>
<span class="line-modified"> 854                         m_lineBreaker.skipTrailingWhitespace(m_lineBreak, m_lineInfo);</span>




 855                     }
 856                 }
 857                 if ((lineWasTooWide || !m_width.fitsOnLine()) &amp;&amp; !m_hangsAtEnd) {
 858                     // Don&#39;t try to hyphenate at the final break of a block, since this means there is
 859                     // no more content, and a hyphenated single word would end up on a line by itself. This looks
 860                     // bad so just don&#39;t allow it.
 861                     if (canHyphenate &amp;&amp; !m_width.fitsOnLine() &amp;&amp; (m_nextObject || !renderText.containsOnlyHTMLWhitespace(m_current.offset(), renderText.text().length() - m_current.offset()) || isLineEmpty)) {
 862                         tryHyphenating(renderText, font, style.locale(), consecutiveHyphenatedLines, m_blockStyle.hyphenationLimitLines(), style.hyphenationLimitBefore(), style.hyphenationLimitAfter(), lastSpace, m_current.offset(), m_width.currentWidth() - additionalTempWidth, m_width.availableWidth(), isFixedPitch, m_collapseWhiteSpace, lastSpaceWordSpacing, m_lineBreak, m_current.nextBreakablePosition(), m_lineBreaker.m_hyphenated);
 863                         if (m_lineBreaker.m_hyphenated) {
 864                             m_atEnd = true;
 865                             return false;
 866                         }
 867                     }
 868                     if (m_lineBreak.atTextParagraphSeparator()) {
 869                         if (!stoppedIgnoringSpaces &amp;&amp; m_current.offset() &gt; 0)
 870                             ensureCharacterGetsLineBox(m_lineWhitespaceCollapsingState, m_current);
 871                         m_lineBreak.increment();
 872                         m_lineInfo.setPreviousLineBrokeCleanly(true);
 873                         wordMeasurement.endOffset = m_lineBreak.offset();
 874                     }
</pre>
<hr />
<pre>
 919                         hyphenWidth = 0;
 920                     }
 921                 }
 922             }
 923 
 924             if (c == &#39;\n&#39; &amp;&amp; m_preservesNewline) {
 925                 if (!stoppedIgnoringSpaces &amp;&amp; m_current.offset())
 926                     ensureCharacterGetsLineBox(m_lineWhitespaceCollapsingState, m_current);
 927                 commitLineBreakAtCurrentWidth(renderObject, m_current.offset(), m_current.nextBreakablePosition());
 928                 m_lineBreak.increment();
 929                 m_lineInfo.setPreviousLineBrokeCleanly(true);
 930                 return true;
 931             }
 932 
 933             if (m_autoWrap &amp;&amp; betweenWords) {
 934                 commitLineBreakAtCurrentWidth(renderObject, m_current.offset(), m_current.nextBreakablePosition());
 935                 wrapWidthOffset = 0;
 936                 wrapW = wrapWidthOffset;
 937                 // Auto-wrapping text should not wrap in the middle of a word once it has had an
 938                 // opportunity to break after a word.

 939                 breakWords = false;

 940             }
 941 
 942             if (midWordBreak &amp;&amp; !U16_IS_TRAIL(c) &amp;&amp; !(U_GET_GC_MASK(c) &amp; U_GC_M_MASK)) {
 943                 // Remember this as a breakable position in case
 944                 // adding the end width forces a break.
 945                 m_lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());
<span class="line-modified"> 946                 midWordBreak &amp;= (breakWords || breakAll);</span>
 947             }
 948 
 949             if (betweenWords) {
 950                 lastSpaceWordSpacing = applyWordSpacing ? wordSpacing : 0;
 951                 wordSpacingForWordMeasurement = (applyWordSpacing &amp;&amp; wordMeasurement.width) ? wordSpacing : 0;
 952                 lastSpace = m_current.offset();
 953             }
 954 
 955             if (!m_ignoringSpaces &amp;&amp; m_currentStyle-&gt;collapseWhiteSpace()) {
 956                 // If we encounter a newline, or if we encounter a second space,
 957                 // we need to break up this run and enter a mode where we start collapsing spaces.
 958                 if (m_currentCharacterIsSpace &amp;&amp; previousCharacterIsSpace) {
 959                     m_ignoringSpaces = true;
 960 
 961                     // We just entered a mode where we are ignoring
 962                     // spaces. Create a transition to terminate the run
 963                     // before the second space.
 964                     m_lineWhitespaceCollapsingState.startIgnoringSpaces(m_startOfIgnoredSpaces);
 965                     m_trailingObjects.updateWhitespaceCollapsingTransitionsForTrailingBoxes(m_lineWhitespaceCollapsingState, InlineIterator(), TrailingObjects::DoNotCollapseFirstSpace);
 966                 }
</pre>
<hr />
<pre>
1050         // Don&#39;t try to hyphenate at the final break of a block, since this means there is
1051         // no more content, and a hyphenated single word would end up on a line by itself. This looks
1052         // bad so just don&#39;t allow it.
1053         if (canHyphenate &amp;&amp; (m_nextObject || isLineEmpty))
1054             tryHyphenating(renderText, font, style.locale(), consecutiveHyphenatedLines, m_blockStyle.hyphenationLimitLines(), style.hyphenationLimitBefore(), style.hyphenationLimitAfter(), lastSpace, m_current.offset(), m_width.currentWidth() - additionalTempWidth, m_width.availableWidth(), isFixedPitch, m_collapseWhiteSpace, lastSpaceWordSpacing, m_lineBreak, m_current.nextBreakablePosition(), m_lineBreaker.m_hyphenated);
1055 
1056         if (!hyphenated &amp;&amp; m_lineBreak.previousInSameNode() == softHyphen &amp;&amp; style.hyphens() != Hyphens::None) {
1057             hyphenated = true;
1058             m_atEnd = true;
1059         }
1060     }
1061     return false;
1062 }
1063 
1064 inline bool textBeginsWithBreakablePosition(RenderText&amp; nextText)
1065 {
1066     UChar c = nextText.characterAt(0);
1067     return c == &#39; &#39; || c == &#39;\t&#39; || (c == &#39;\n&#39; &amp;&amp; !nextText.preservesNewline());
1068 }
1069 
















1070 inline bool BreakingContext::canBreakAtThisPosition()
1071 {
1072     // If we are no-wrap and have found a line-breaking opportunity already then we should take it.
1073     if (m_width.committedWidth() &amp;&amp; !m_width.fitsOnLine(m_currentCharacterIsSpace) &amp;&amp; m_currWS == WhiteSpace::NoWrap)
1074         return true;
1075 
1076     // Avoid breaking on empty inlines.
1077     if (is&lt;RenderInline&gt;(*m_current.renderer()) &amp;&amp; isEmptyInline(downcast&lt;RenderInline&gt;(*m_current.renderer())))
1078         return false;
1079 
1080     // Avoid breaking before empty inlines (as long as the current object isn&#39;t replaced).
1081     if (!m_current.renderer()-&gt;isReplaced() &amp;&amp; is&lt;RenderInline&gt;(m_nextObject) &amp;&amp; isEmptyInline(downcast&lt;RenderInline&gt;(*m_nextObject)))
1082         return false;
1083 
1084     // Return early if we autowrap and the current character is a space as we will always want to break at such a position.
1085     if (m_autoWrap &amp;&amp; m_currentCharacterIsSpace)
1086         return true;
1087 
1088     if (m_nextObject &amp;&amp; m_nextObject-&gt;isLineBreakOpportunity())
1089         return m_autoWrap;
</pre>
</td>
<td>
<hr />
<pre>
  97         : m_lineBreaker(lineBreaker)
  98         , m_resolver(resolver)
  99         , m_current(resolver.position())
 100         , m_lineBreak(resolver.position())
 101         , m_block(block)
 102         , m_lastObject(m_current.renderer())
 103         , m_nextObject(nullptr)
 104         , m_currentStyle(nullptr)
 105         , m_blockStyle(block.style())
 106         , m_lineInfo(inLineInfo)
 107         , m_renderTextInfo(inRenderTextInfo)
 108         , m_lastFloatFromPreviousLine(inLastFloatFromPreviousLine)
 109         , m_width(lineWidth)
 110         , m_currWS(WhiteSpace::Normal)
 111         , m_lastWS(WhiteSpace::Normal)
 112         , m_preservesNewline(false)
 113         , m_atStart(true)
 114         , m_ignoringSpaces(false)
 115         , m_currentCharacterIsSpace(false)
 116         , m_currentCharacterIsWS(false)
<span class="line-added"> 117         , m_hasFormerOpportunity(false)</span>
 118         , m_appliedStartWidth(appliedStartWidth)
 119         , m_includeEndWidth(true)
 120         , m_autoWrap(false)
 121         , m_autoWrapWasEverTrueOnLine(false)
 122         , m_floatsFitOnLine(true)
 123         , m_collapseWhiteSpace(false)
 124         , m_startingNewParagraph(m_lineInfo.previousLineBrokeCleanly())
 125         , m_allowImagesToBreak(!block.document().inQuirksMode() || !block.isTableCell() || !m_blockStyle.logicalWidth().isIntrinsicOrAuto())
 126         , m_atEnd(false)
 127         , m_hadUncommittedWidthBeforeCurrent(false)
 128         , m_lineWhitespaceCollapsingState(resolver.whitespaceCollapsingState())
 129     {
 130         m_lineInfo.setPreviousLineBrokeCleanly(false);
 131     }
 132 
 133     RenderObject* currentObject() { return m_current.renderer(); }
 134     InlineIterator lineBreak() { return m_lineBreak; }
 135     LineWidth&amp; lineWidth() { return m_width; }
 136     bool atEnd() { return m_atEnd; }
 137 
 138     bool fitsOnLineOrHangsAtEnd() const { return m_width.fitsOnLine() || m_hangsAtEnd; }
 139 
 140     void initializeForCurrentObject();
 141 
 142     void increment();
 143 
 144     void handleBR(Clear&amp;);
 145     void handleOutOfFlowPositioned(Vector&lt;RenderBox*&gt;&amp; positionedObjects);
 146     void handleFloat();
 147     void handleEmptyInline();
 148     void handleReplaced();
 149     bool handleText(WordMeasurements&amp;, bool&amp; hyphenated, unsigned&amp; consecutiveHyphenatedLines);
<span class="line-added"> 150     void trailingSpacesHang(InlineIterator&amp;, RenderObject&amp;, bool canBreakMidWord, bool previousCharacterIsSpace);</span>
 151     bool canBreakAtThisPosition();
 152     void commitAndUpdateLineBreakIfNeeded();
 153     InlineIterator handleEndOfLine();
 154 
 155     float computeAdditionalBetweenWordsWidth(RenderText&amp;, TextLayout*, UChar, WordTrailingSpace&amp;, HashSet&lt;const Font*&gt;&amp; fallbackFonts, WordMeasurements&amp;, const FontCascade&amp;, bool isFixedPitch, unsigned lastSpace, float lastSpaceWordSpacing, float wordSpacingForWordMeasurement, unsigned offset);
 156 
 157     void clearLineBreakIfFitsOnLine(bool ignoringTrailingSpace = false)
 158     {
 159         if (m_width.fitsOnLine(ignoringTrailingSpace) || m_lastWS == WhiteSpace::NoWrap || m_hangsAtEnd)
 160             m_lineBreak.clear();
 161         m_hangsAtEnd = false;
 162     }
 163 
 164     void commitLineBreakClear()
 165     {
 166         m_width.commit();
 167         m_lineBreak.clear();
 168         m_hangsAtEnd = false;
 169     }
 170 
</pre>
<hr />
<pre>
 200 
 201     FloatingObject* m_lastFloatFromPreviousLine;
 202 
 203     LineWidth m_width;
 204 
 205     WhiteSpace m_currWS;
 206     WhiteSpace m_lastWS;
 207 
 208     bool m_preservesNewline;
 209     bool m_atStart;
 210 
 211     // This variable is used only if whitespace isn&#39;t set to WhiteSpace::Pre, and it tells us whether
 212     // or not we are currently ignoring whitespace.
 213     bool m_ignoringSpaces;
 214 
 215     // This variable tracks whether the very last character we saw was a space. We use
 216     // this to detect when we encounter a second space so we know we have to terminate
 217     // a run.
 218     bool m_currentCharacterIsSpace;
 219     bool m_currentCharacterIsWS;
<span class="line-added"> 220     bool m_hasFormerOpportunity;</span>
 221     bool m_appliedStartWidth;
 222     bool m_includeEndWidth;
 223     bool m_autoWrap;
 224     bool m_autoWrapWasEverTrueOnLine;
 225     bool m_floatsFitOnLine;
 226     bool m_collapseWhiteSpace;
 227     bool m_startingNewParagraph;
 228     bool m_allowImagesToBreak;
 229     bool m_atEnd;
 230     bool m_hadUncommittedWidthBeforeCurrent;
 231 
 232     bool m_hangsAtEnd { false };
 233 
 234     LineWhitespaceCollapsingState&amp; m_lineWhitespaceCollapsingState;
 235 
 236     TrailingObjects m_trailingObjects;
 237 };
 238 
 239 inline void BreakingContext::initializeForCurrentObject()
 240 {
</pre>
<hr />
<pre>
 559         return text.width(from, len, font, xPos, &amp;fallbackFonts, &amp;glyphOverflow);
 560 
 561     if (layout)
 562         return FontCascade::width(*layout, from, len, &amp;fallbackFonts);
 563 
 564     TextRun run = RenderBlock::constructTextRun(text, from, len, style);
 565     run.setCharacterScanForCodePath(!text.canUseSimpleFontCodePath());
 566     run.setTabSize(!collapseWhiteSpace, style.tabSize());
 567     run.setXPos(xPos);
 568     return font.width(run, &amp;fallbackFonts, &amp;glyphOverflow);
 569 }
 570 
 571 // Adding a pair of whitespace collapsing transitions before a character will split it out into a new line box.
 572 inline void ensureCharacterGetsLineBox(LineWhitespaceCollapsingState&amp; lineWhitespaceCollapsingState, InlineIterator&amp; textParagraphSeparator)
 573 {
 574     InlineIterator transition(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset());
 575     lineWhitespaceCollapsingState.startIgnoringSpaces(InlineIterator(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset() - 1));
 576     lineWhitespaceCollapsingState.stopIgnoringSpaces(InlineIterator(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset()));
 577 }
 578 
<span class="line-modified"> 579 inline void tryHyphenating(RenderText&amp; text, const FontCascade&amp; font, const AtomString&amp; localeIdentifier, unsigned consecutiveHyphenatedLines, int consecutiveHyphenatedLinesLimit, int minimumPrefixLimit, int minimumSuffixLimit, unsigned lastSpace, unsigned pos, float xPos, float availableWidth, bool isFixedPitch, bool collapseWhiteSpace, int lastSpaceWordSpacing, InlineIterator&amp; lineBreak, Optional&lt;unsigned&gt; nextBreakable, bool&amp; hyphenated)</span>
 580 {
 581     // Map &#39;hyphenate-limit-{before,after}: auto;&#39; to 2.
 582     unsigned minimumPrefixLength;
 583     unsigned minimumSuffixLength;
 584 
 585     if (minimumPrefixLimit &lt; 0)
 586         minimumPrefixLength = 2;
 587     else
 588         minimumPrefixLength = static_cast&lt;unsigned&gt;(minimumPrefixLimit);
 589 
 590     if (minimumSuffixLimit &lt; 0)
 591         minimumSuffixLength = 2;
 592     else
 593         minimumSuffixLength = static_cast&lt;unsigned&gt;(minimumSuffixLimit);
 594 
 595     if (pos - lastSpace &lt;= minimumSuffixLength)
 596         return;
 597 
 598     if (consecutiveHyphenatedLinesLimit &gt;= 0 &amp;&amp; consecutiveHyphenatedLines &gt;= static_cast&lt;unsigned&gt;(consecutiveHyphenatedLinesLimit))
 599         return;
</pre>
<hr />
<pre>
 696     const FontCascade&amp; font = style.fontCascade();
 697     bool isFixedPitch = font.isFixedPitch();
 698     bool canHyphenate = style.hyphens() == Hyphens::Auto &amp;&amp; WebCore::canHyphenate(style.locale());
 699     bool canHangPunctuationAtStart = style.hangingPunctuation().contains(HangingPunctuation::First);
 700     bool canHangPunctuationAtEnd = style.hangingPunctuation().contains(HangingPunctuation::Last);
 701     bool canHangStopOrCommaAtLineEnd = style.hangingPunctuation().contains(HangingPunctuation::AllowEnd);
 702     int endPunctuationIndex = canHangPunctuationAtEnd &amp;&amp; m_collapseWhiteSpace ? renderText.lastCharacterIndexStrippingSpaces() : renderText.text().length() - 1;
 703     unsigned lastSpace = m_current.offset();
 704     float wordSpacing = m_currentStyle-&gt;fontCascade().wordSpacing();
 705     float lastSpaceWordSpacing = 0;
 706     float wordSpacingForWordMeasurement = 0;
 707 
 708     float wrapWidthOffset = m_width.uncommittedWidth() + inlineLogicalWidth(m_current.renderer(), !m_appliedStartWidth, true);
 709     float wrapW = wrapWidthOffset;
 710     float charWidth = 0;
 711     bool breakNBSP = m_autoWrap &amp;&amp; m_currentStyle-&gt;nbspMode() == NBSPMode::Space;
 712     // Auto-wrapping text should wrap in the middle of a word only if it could not wrap before the word,
 713     // which is only possible if the word is the first thing on the line.
 714     bool breakWords = m_currentStyle-&gt;breakWords() &amp;&amp; ((m_autoWrap &amp;&amp; (!m_width.committedWidth() &amp;&amp; !m_width.hasCommittedReplaced())) || m_currWS == WhiteSpace::Pre);
 715     bool midWordBreak = false;
<span class="line-modified"> 716     bool breakAnywhere = m_currentStyle-&gt;lineBreak() == LineBreak::Anywhere &amp;&amp; m_autoWrap;</span>
<span class="line-added"> 717     bool breakAll = (m_currentStyle-&gt;wordBreak() == WordBreak::BreakAll || breakAnywhere) &amp;&amp; m_autoWrap;</span>
 718     bool keepAllWords = m_currentStyle-&gt;wordBreak() == WordBreak::KeepAll;
 719     float hyphenWidth = 0;
 720     auto iteratorMode = mapLineBreakToIteratorMode(m_blockStyle.lineBreak());
 721     bool canUseLineBreakShortcut = iteratorMode == LineBreakIteratorMode::Default;
 722     bool isLineEmpty = m_lineInfo.isEmpty();
 723 
 724     if (isSVGText) {
 725         breakWords = false;
 726         breakAll = false;
 727     }
 728 
 729     if (m_renderTextInfo.text != &amp;renderText) {
 730         updateCounterIfNeeded(renderText);
 731         m_renderTextInfo.text = &amp;renderText;
 732         m_renderTextInfo.font = &amp;font;
 733         m_renderTextInfo.layout = font.createLayout(renderText, m_width.currentWidth(), m_collapseWhiteSpace);
 734         m_renderTextInfo.lineBreakIterator.resetStringAndReleaseIterator(renderText.text(), style.locale(), iteratorMode);
 735     } else if (m_renderTextInfo.layout &amp;&amp; m_renderTextInfo.font != &amp;font) {
 736         m_renderTextInfo.font = &amp;font;
 737         m_renderTextInfo.layout = font.createLayout(renderText, m_width.currentWidth(), m_collapseWhiteSpace);
 738     }
 739 
 740     HashSet&lt;const Font*&gt; fallbackFonts;
<span class="line-added"> 741     m_hasFormerOpportunity = false;</span>
<span class="line-added"> 742     bool canBreakMidWord = breakWords || breakAll;</span>
 743     UChar lastCharacterFromPreviousRenderText = m_renderTextInfo.lineBreakIterator.lastCharacter();
 744     UChar lastCharacter = m_renderTextInfo.lineBreakIterator.lastCharacter();
 745     UChar secondToLastCharacter = m_renderTextInfo.lineBreakIterator.secondToLastCharacter();
 746     // Non-zero only when kerning is enabled and TextLayout isn&#39;t used, in which case we measure
 747     // words with their trailing space, then subtract its width.
 748     TextLayout* textLayout = m_renderTextInfo.layout.get();
 749     WordTrailingSpace wordTrailingSpace(style, !textLayout);
 750     for (; m_current.offset() &lt; renderText.text().length(); m_current.fastIncrementInTextNode()) {
 751         bool previousCharacterIsSpace = m_currentCharacterIsSpace;
 752         bool previousCharacterIsWS = m_currentCharacterIsWS;
 753         UChar c = m_current.current();
 754         m_currentCharacterIsSpace = c == &#39; &#39; || c == &#39;\t&#39; || (!m_preservesNewline &amp;&amp; (c == &#39;\n&#39;));
 755 
<span class="line-added"> 756         // A single preserved leading white-space doesn&#39;t fulfill the &#39;betweenWords&#39; condition, however it&#39;s indeed a</span>
<span class="line-added"> 757         // soft-breaking opportunty so we may want to avoid breaking in the middle of the word.</span>
<span class="line-added"> 758         if (m_atStart &amp;&amp; m_currentCharacterIsSpace &amp;&amp; !previousCharacterIsSpace) {</span>
<span class="line-added"> 759             m_hasFormerOpportunity = !breakAnywhere;</span>
<span class="line-added"> 760             breakWords = false;</span>
<span class="line-added"> 761             canBreakMidWord = breakAll;</span>
<span class="line-added"> 762         }</span>
<span class="line-added"> 763 </span>
 764         if (canHangPunctuationAtStart &amp;&amp; m_width.isFirstLine() &amp;&amp; !m_width.committedWidth() &amp;&amp; !wrapW &amp;&amp; !inlineLogicalWidth(m_current.renderer(), true, false)) {
 765             m_width.addUncommittedWidth(-renderText.hangablePunctuationStartWidth(m_current.offset()));
 766             canHangPunctuationAtStart = false;
 767         }
 768 
 769         if (canHangPunctuationAtEnd &amp;&amp; !m_nextObject &amp;&amp; (int)m_current.offset() == endPunctuationIndex &amp;&amp; !inlineLogicalWidth(m_current.renderer(), false, true)) {
 770             m_width.addUncommittedWidth(-renderText.hangablePunctuationEndWidth(endPunctuationIndex));
 771             canHangPunctuationAtEnd = false;
 772         }
 773 
 774         if (!m_collapseWhiteSpace || !m_currentCharacterIsSpace)
 775             m_lineInfo.setEmpty(false, &amp;m_block, &amp;m_width);
 776 
 777         if (c == softHyphen &amp;&amp; m_autoWrap &amp;&amp; !hyphenWidth &amp;&amp; style.hyphens() != Hyphens::None) {
 778             hyphenWidth = measureHyphenWidth(renderText, font, &amp;fallbackFonts);
 779             m_width.addUncommittedWidth(hyphenWidth);
 780         }
 781 
 782         bool applyWordSpacing = false;
 783 
 784         m_currentCharacterIsWS = m_currentCharacterIsSpace || (breakNBSP &amp;&amp; c == noBreakSpace);
 785 
<span class="line-modified"> 786         if (canBreakMidWord &amp;&amp; !midWordBreak &amp;&amp; (!m_currentCharacterIsSpace || m_atStart || style.whiteSpace() != WhiteSpace::PreWrap)) {</span>
 787             wrapW += charWidth;
 788             bool midWordBreakIsBeforeSurrogatePair = U16_IS_LEAD(c) &amp;&amp; U16_IS_TRAIL(renderText.characterAt(m_current.offset() + 1));
 789             charWidth = textWidth(renderText, m_current.offset(), midWordBreakIsBeforeSurrogatePair ? 2 : 1, font, m_width.committedWidth() + wrapW, isFixedPitch, m_collapseWhiteSpace, fallbackFonts, textLayout);
 790             midWordBreak = m_width.committedWidth() + wrapW + charWidth &gt; m_width.availableWidth();
 791         }
 792 
 793         Optional&lt;unsigned&gt; nextBreakablePosition = m_current.nextBreakablePosition();
<span class="line-modified"> 794         bool betweenWords = c == &#39;\n&#39; || (m_currWS != WhiteSpace::Pre &amp;&amp; !m_atStart &amp;&amp; isBreakable(m_renderTextInfo.lineBreakIterator, m_current.offset(), nextBreakablePosition, breakNBSP, canUseLineBreakShortcut, keepAllWords, breakAnywhere)</span>
 795             &amp;&amp; (style.hyphens() != Hyphens::None || (m_current.previousInSameNode() != softHyphen)));
 796         m_current.setNextBreakablePosition(nextBreakablePosition);
 797 
 798         if (canHangStopOrCommaAtLineEnd &amp;&amp; renderText.isHangableStopOrComma(c) &amp;&amp; m_width.fitsOnLine()) {
 799             // We need to see if a measurement that excludes the stop would fit. If so, then we should hang
 800             // the stop/comma at the end. First measure including the comma.
 801             m_hangsAtEnd = false;
 802             float inlineStartWidth = !m_appliedStartWidth ? inlineLogicalWidth(m_current.renderer(), true, false) : 0_lu;
 803             float widthIncludingComma = computeAdditionalBetweenWordsWidth(renderText, textLayout, c, wordTrailingSpace, fallbackFonts, wordMeasurements, font, isFixedPitch, lastSpace, lastSpaceWordSpacing, wordSpacingForWordMeasurement, m_current.offset() + 1) + inlineStartWidth;
 804             m_width.addUncommittedWidth(widthIncludingComma);
 805             if (!m_width.fitsOnLine()) {
 806                 // See if we fit without the comma involved. If we do, then this is a potential hang point.
 807                 float widthWithoutStopOrComma = computeAdditionalBetweenWordsWidth(renderText, textLayout, lastCharacter, wordTrailingSpace, fallbackFonts, wordMeasurements, font, isFixedPitch, lastSpace, lastSpaceWordSpacing, wordSpacingForWordMeasurement, m_current.offset()) + inlineStartWidth;
 808                 m_width.addUncommittedWidth(widthWithoutStopOrComma - widthIncludingComma);
 809                 if (m_width.fitsOnLine())
 810                     m_hangsAtEnd = true;
 811             } else
 812                 m_width.addUncommittedWidth(-widthIncludingComma);
 813         }
 814 
</pre>
<hr />
<pre>
 838             if (m_collapseWhiteSpace &amp;&amp; previousCharacterIsSpace &amp;&amp; m_currentCharacterIsSpace &amp;&amp; additionalTempWidth)
 839                 m_width.setTrailingWhitespaceWidth(additionalTempWidth);
 840 
 841             if (!m_appliedStartWidth) {
 842                 float inlineStartWidth = inlineLogicalWidth(m_current.renderer(), true, false);
 843                 m_width.addUncommittedWidth(inlineStartWidth);
 844                 m_appliedStartWidth = true;
 845                 if (m_hangsAtEnd &amp;&amp; inlineStartWidth)
 846                     m_hangsAtEnd = false;
 847             }
 848 
 849             applyWordSpacing = wordSpacing &amp;&amp; m_currentCharacterIsSpace;
 850 
 851             if (!m_width.hasCommitted() &amp;&amp; m_autoWrap &amp;&amp; !fitsOnLineOrHangsAtEnd())
 852                 m_width.fitBelowFloats(m_lineInfo.isFirstLine());
 853 
 854             if (m_autoWrap || breakWords) {
 855                 // If we break only after white-space, consider the current character
 856                 // as candidate width for this line.
 857                 bool lineWasTooWide = false;
<span class="line-modified"> 858                 if (fitsOnLineOrHangsAtEnd() &amp;&amp; m_currentCharacterIsWS &amp;&amp; m_currentStyle-&gt;breakOnlyAfterWhiteSpace() &amp;&amp; (!midWordBreak || m_currWS == WhiteSpace::BreakSpaces)) {</span>
 859                     float charWidth = textWidth(renderText, m_current.offset(), 1, font, m_width.currentWidth(), isFixedPitch, m_collapseWhiteSpace, wordMeasurement.fallbackFonts, textLayout) + (applyWordSpacing ? wordSpacing : 0);
 860                     // Check if line is too big even without the extra space
 861                     // at the end of the line. If it is not, do nothing.
 862                     // If the line needs the extra whitespace to be too long,
 863                     // then move the line break to the space and skip all
 864                     // additional whitespace.
 865                     if (!m_width.fitsOnLineIncludingExtraWidth(charWidth)) {
 866                         lineWasTooWide = true;
<span class="line-modified"> 867                         if (m_currWS == WhiteSpace::BreakSpaces)</span>
<span class="line-modified"> 868                             trailingSpacesHang(m_lineBreak, renderObject, canBreakMidWord, previousCharacterIsSpace);</span>
<span class="line-added"> 869                         else {</span>
<span class="line-added"> 870                             m_lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());</span>
<span class="line-added"> 871                             m_lineBreaker.skipTrailingWhitespace(m_lineBreak, m_lineInfo);</span>
<span class="line-added"> 872                         }</span>
 873                     }
 874                 }
 875                 if ((lineWasTooWide || !m_width.fitsOnLine()) &amp;&amp; !m_hangsAtEnd) {
 876                     // Don&#39;t try to hyphenate at the final break of a block, since this means there is
 877                     // no more content, and a hyphenated single word would end up on a line by itself. This looks
 878                     // bad so just don&#39;t allow it.
 879                     if (canHyphenate &amp;&amp; !m_width.fitsOnLine() &amp;&amp; (m_nextObject || !renderText.containsOnlyHTMLWhitespace(m_current.offset(), renderText.text().length() - m_current.offset()) || isLineEmpty)) {
 880                         tryHyphenating(renderText, font, style.locale(), consecutiveHyphenatedLines, m_blockStyle.hyphenationLimitLines(), style.hyphenationLimitBefore(), style.hyphenationLimitAfter(), lastSpace, m_current.offset(), m_width.currentWidth() - additionalTempWidth, m_width.availableWidth(), isFixedPitch, m_collapseWhiteSpace, lastSpaceWordSpacing, m_lineBreak, m_current.nextBreakablePosition(), m_lineBreaker.m_hyphenated);
 881                         if (m_lineBreaker.m_hyphenated) {
 882                             m_atEnd = true;
 883                             return false;
 884                         }
 885                     }
 886                     if (m_lineBreak.atTextParagraphSeparator()) {
 887                         if (!stoppedIgnoringSpaces &amp;&amp; m_current.offset() &gt; 0)
 888                             ensureCharacterGetsLineBox(m_lineWhitespaceCollapsingState, m_current);
 889                         m_lineBreak.increment();
 890                         m_lineInfo.setPreviousLineBrokeCleanly(true);
 891                         wordMeasurement.endOffset = m_lineBreak.offset();
 892                     }
</pre>
<hr />
<pre>
 937                         hyphenWidth = 0;
 938                     }
 939                 }
 940             }
 941 
 942             if (c == &#39;\n&#39; &amp;&amp; m_preservesNewline) {
 943                 if (!stoppedIgnoringSpaces &amp;&amp; m_current.offset())
 944                     ensureCharacterGetsLineBox(m_lineWhitespaceCollapsingState, m_current);
 945                 commitLineBreakAtCurrentWidth(renderObject, m_current.offset(), m_current.nextBreakablePosition());
 946                 m_lineBreak.increment();
 947                 m_lineInfo.setPreviousLineBrokeCleanly(true);
 948                 return true;
 949             }
 950 
 951             if (m_autoWrap &amp;&amp; betweenWords) {
 952                 commitLineBreakAtCurrentWidth(renderObject, m_current.offset(), m_current.nextBreakablePosition());
 953                 wrapWidthOffset = 0;
 954                 wrapW = wrapWidthOffset;
 955                 // Auto-wrapping text should not wrap in the middle of a word once it has had an
 956                 // opportunity to break after a word.
<span class="line-added"> 957                 m_hasFormerOpportunity = !breakAnywhere;</span>
 958                 breakWords = false;
<span class="line-added"> 959                 canBreakMidWord = breakAll;</span>
 960             }
 961 
 962             if (midWordBreak &amp;&amp; !U16_IS_TRAIL(c) &amp;&amp; !(U_GET_GC_MASK(c) &amp; U_GC_M_MASK)) {
 963                 // Remember this as a breakable position in case
 964                 // adding the end width forces a break.
 965                 m_lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());
<span class="line-modified"> 966                 midWordBreak &amp;= canBreakMidWord;</span>
 967             }
 968 
 969             if (betweenWords) {
 970                 lastSpaceWordSpacing = applyWordSpacing ? wordSpacing : 0;
 971                 wordSpacingForWordMeasurement = (applyWordSpacing &amp;&amp; wordMeasurement.width) ? wordSpacing : 0;
 972                 lastSpace = m_current.offset();
 973             }
 974 
 975             if (!m_ignoringSpaces &amp;&amp; m_currentStyle-&gt;collapseWhiteSpace()) {
 976                 // If we encounter a newline, or if we encounter a second space,
 977                 // we need to break up this run and enter a mode where we start collapsing spaces.
 978                 if (m_currentCharacterIsSpace &amp;&amp; previousCharacterIsSpace) {
 979                     m_ignoringSpaces = true;
 980 
 981                     // We just entered a mode where we are ignoring
 982                     // spaces. Create a transition to terminate the run
 983                     // before the second space.
 984                     m_lineWhitespaceCollapsingState.startIgnoringSpaces(m_startOfIgnoredSpaces);
 985                     m_trailingObjects.updateWhitespaceCollapsingTransitionsForTrailingBoxes(m_lineWhitespaceCollapsingState, InlineIterator(), TrailingObjects::DoNotCollapseFirstSpace);
 986                 }
</pre>
<hr />
<pre>
1070         // Don&#39;t try to hyphenate at the final break of a block, since this means there is
1071         // no more content, and a hyphenated single word would end up on a line by itself. This looks
1072         // bad so just don&#39;t allow it.
1073         if (canHyphenate &amp;&amp; (m_nextObject || isLineEmpty))
1074             tryHyphenating(renderText, font, style.locale(), consecutiveHyphenatedLines, m_blockStyle.hyphenationLimitLines(), style.hyphenationLimitBefore(), style.hyphenationLimitAfter(), lastSpace, m_current.offset(), m_width.currentWidth() - additionalTempWidth, m_width.availableWidth(), isFixedPitch, m_collapseWhiteSpace, lastSpaceWordSpacing, m_lineBreak, m_current.nextBreakablePosition(), m_lineBreaker.m_hyphenated);
1075 
1076         if (!hyphenated &amp;&amp; m_lineBreak.previousInSameNode() == softHyphen &amp;&amp; style.hyphens() != Hyphens::None) {
1077             hyphenated = true;
1078             m_atEnd = true;
1079         }
1080     }
1081     return false;
1082 }
1083 
1084 inline bool textBeginsWithBreakablePosition(RenderText&amp; nextText)
1085 {
1086     UChar c = nextText.characterAt(0);
1087     return c == &#39; &#39; || c == &#39;\t&#39; || (c == &#39;\n&#39; &amp;&amp; !nextText.preservesNewline());
1088 }
1089 
<span class="line-added">1090 inline void BreakingContext::trailingSpacesHang(InlineIterator&amp; lineBreak, RenderObject&amp; renderObject, bool canBreakMidWord, bool previousCharacterIsSpace)</span>
<span class="line-added">1091 {</span>
<span class="line-added">1092     ASSERT(m_currWS == WhiteSpace::BreakSpaces);</span>
<span class="line-added">1093     // Avoid breaking before the first white-space after a word if there is a</span>
<span class="line-added">1094     // breaking opportunity before.</span>
<span class="line-added">1095     if (m_hasFormerOpportunity &amp;&amp; !previousCharacterIsSpace)</span>
<span class="line-added">1096         return;</span>
<span class="line-added">1097 </span>
<span class="line-added">1098     lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());</span>
<span class="line-added">1099 </span>
<span class="line-added">1100     // Avoid breaking before the first white-space after a word, unless</span>
<span class="line-added">1101     // overflow-wrap or word-break allow to.</span>
<span class="line-added">1102     if (!previousCharacterIsSpace &amp;&amp; !canBreakMidWord)</span>
<span class="line-added">1103         lineBreak.increment();</span>
<span class="line-added">1104 }</span>
<span class="line-added">1105 </span>
1106 inline bool BreakingContext::canBreakAtThisPosition()
1107 {
1108     // If we are no-wrap and have found a line-breaking opportunity already then we should take it.
1109     if (m_width.committedWidth() &amp;&amp; !m_width.fitsOnLine(m_currentCharacterIsSpace) &amp;&amp; m_currWS == WhiteSpace::NoWrap)
1110         return true;
1111 
1112     // Avoid breaking on empty inlines.
1113     if (is&lt;RenderInline&gt;(*m_current.renderer()) &amp;&amp; isEmptyInline(downcast&lt;RenderInline&gt;(*m_current.renderer())))
1114         return false;
1115 
1116     // Avoid breaking before empty inlines (as long as the current object isn&#39;t replaced).
1117     if (!m_current.renderer()-&gt;isReplaced() &amp;&amp; is&lt;RenderInline&gt;(m_nextObject) &amp;&amp; isEmptyInline(downcast&lt;RenderInline&gt;(*m_nextObject)))
1118         return false;
1119 
1120     // Return early if we autowrap and the current character is a space as we will always want to break at such a position.
1121     if (m_autoWrap &amp;&amp; m_currentCharacterIsSpace)
1122         return true;
1123 
1124     if (m_nextObject &amp;&amp; m_nextObject-&gt;isLineBreakOpportunity())
1125         return m_autoWrap;
</pre>
</td>
</tr>
</table>
<center><a href="../TextPainter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LineBreaker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>