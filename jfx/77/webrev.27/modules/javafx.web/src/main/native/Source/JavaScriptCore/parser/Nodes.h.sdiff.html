<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Nodes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 187         virtual bool isBracketAccessorNode() const { return false; }
 188         virtual bool isDotAccessorNode() const { return false; }
 189         virtual bool isDestructuringNode() const { return false; }
 190         virtual bool isBaseFuncExprNode() const { return false; }
 191         virtual bool isFuncExprNode() const { return false; }
 192         virtual bool isArrowFuncExprNode() const { return false; }
 193         virtual bool isClassExprNode() const { return false; }
 194         virtual bool isCommaNode() const { return false; }
 195         virtual bool isSimpleArray() const { return false; }
 196         virtual bool isAdd() const { return false; }
 197         virtual bool isSubtract() const { return false; }
 198         virtual bool isBoolean() const { return false; }
 199         virtual bool isSpreadExpression() const { return false; }
 200         virtual bool isSuperNode() const { return false; }
 201         virtual bool isImportNode() const { return false; }
 202         virtual bool isMetaProperty() const { return false; }
 203         virtual bool isNewTarget() const { return false; }
 204         virtual bool isImportMeta() const { return false; }
 205         virtual bool isBytecodeIntrinsicNode() const { return false; }
 206         virtual bool isBinaryOpNode() const { return false; }



 207 
 208         virtual void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp;, Label&amp;, FallThroughMode);
 209 
 210         virtual ExpressionNode* stripUnaryPlus() { return this; }
 211 
 212         ResultType resultDescriptor() const { return m_resultType; }
 213 



 214     private:
 215         ResultType m_resultType;

 216     };
 217 
 218     class StatementNode : public Node {
 219     protected:
 220         StatementNode(const JSTokenLocation&amp;);
 221 
 222     public:
 223         virtual void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = 0) = 0;
 224 
 225         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset);
 226         unsigned lastLine() const { return m_lastLine; }
 227 
 228         StatementNode* next() const { return m_next; }
 229         void setNext(StatementNode* next) { m_next = next; }
 230 
 231         virtual bool hasCompletionValue() const { return true; }
 232         virtual bool hasEarlyBreakOrContinue() const { return false; }
 233 
 234         virtual bool isEmptyStatement() const { return false; }
 235         virtual bool isDebuggerStatement() const { return false; }
</pre>
<hr />
<pre>
 852 
 853     class NewExprNode final : public ExpressionNode, public ThrowableExpressionData {
 854     public:
 855         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*);
 856         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*);
 857 
 858     private:
 859         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 860 
 861         ExpressionNode* m_expr;
 862         ArgumentsNode* m_args;
 863     };
 864 
 865     class EvalFunctionCallNode final : public ExpressionNode, public ThrowableExpressionData {
 866     public:
 867         EvalFunctionCallNode(const JSTokenLocation&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 868 
 869     private:
 870         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 871 


 872         ArgumentsNode* m_args;
 873     };
 874 
 875     class FunctionCallValueNode final : public ExpressionNode, public ThrowableExpressionData {
 876     public:
 877         FunctionCallValueNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 878 
 879     private:
 880         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 881 


 882         ExpressionNode* m_expr;
 883         ArgumentsNode* m_args;
 884     };
 885 
 886     class FunctionCallResolveNode final : public ExpressionNode, public ThrowableExpressionData {
 887     public:
 888         FunctionCallResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 889 
 890     private:
 891         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 892 


 893         const Identifier&amp; m_ident;
 894         ArgumentsNode* m_args;
 895     };
 896 
 897     class FunctionCallBracketNode final : public ExpressionNode, public ThrowableSubExpressionData {
 898     public:
 899         FunctionCallBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 900 
 901     private:
 902         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 903 


 904         ExpressionNode* m_base;
 905         ExpressionNode* m_subscript;
 906         ArgumentsNode* m_args;
 907         bool m_subscriptHasAssignments;
 908     };
 909 
 910     class FunctionCallDotNode : public ExpressionNode, public ThrowableSubExpressionData {
 911     public:
 912         FunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 913 
 914     private:
 915         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 916 
 917     protected:


 918         ExpressionNode* m_base;
 919         const Identifier&amp; m_ident;
 920         ArgumentsNode* m_args;
 921     };
 922 
 923     class BytecodeIntrinsicNode final : public ExpressionNode, public ThrowableExpressionData {
 924     public:
 925         enum class Type : uint8_t {
 926             Constant,
 927             Function
 928         };
 929 
 930         typedef RegisterID* (BytecodeIntrinsicNode::* EmitterType)(BytecodeGenerator&amp;, RegisterID*);
 931 
 932         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, EmitterType, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 933 
 934         bool isBytecodeIntrinsicNode() const override { return true; }
 935 
 936         Type type() const { return m_type; }
 937         EmitterType emitter() const { return m_emitter; }
 938         const Identifier&amp; identifier() const { return m_ident; }
 939 
 940 #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
 941         JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 942         JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 943 #undef JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS
 944 
 945     private:
 946         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 947 


 948         EmitterType m_emitter;
 949         const Identifier&amp; m_ident;
 950         ArgumentsNode* m_args;
 951         Type m_type;
 952     };
 953 
 954     class CallFunctionCallDotNode final : public FunctionCallDotNode {
 955     public:
 956         CallFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 957 
 958     private:
 959         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 960         size_t m_distanceToInnermostCallOrApply;
 961     };
 962 
 963     class ApplyFunctionCallDotNode final : public FunctionCallDotNode {
 964     public:
 965         ApplyFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 966 
 967     private:
 968         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 969         size_t m_distanceToInnermostCallOrApply;
 970     };
 971 
 972     class DeleteResolveNode final : public ExpressionNode, public ThrowableExpressionData {
 973     public:
 974         DeleteResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 975 
 976     private:
 977         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 978 


 979         const Identifier&amp; m_ident;
 980     };
 981 
 982     class DeleteBracketNode final : public ExpressionNode, public ThrowableExpressionData {
 983     public:
 984         DeleteBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 985 
 986     private:
 987         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 988 


 989         ExpressionNode* m_base;
 990         ExpressionNode* m_subscript;
 991     };
 992 
 993     class DeleteDotNode final : public ExpressionNode, public ThrowableExpressionData {
 994     public:
 995         DeleteDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 996 
 997     private:
 998         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 999 


1000         ExpressionNode* m_base;
1001         const Identifier&amp; m_ident;
1002     };
1003 
1004     class DeleteValueNode final : public ExpressionNode {
1005     public:
1006         DeleteValueNode(const JSTokenLocation&amp;, ExpressionNode*);
1007 
1008     private:
1009         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1010 


1011         ExpressionNode* m_expr;
1012     };
1013 
1014     class VoidNode final : public ExpressionNode {
1015     public:
1016         VoidNode(const JSTokenLocation&amp;, ExpressionNode*);
1017 
1018     private:
1019         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1020 
1021         ExpressionNode* m_expr;
1022     };
1023 
1024     class TypeOfResolveNode final : public ExpressionNode {
1025     public:
1026         TypeOfResolveNode(const JSTokenLocation&amp;, const Identifier&amp;);
1027 
1028         const Identifier&amp; identifier() const { return m_ident; }
1029 
1030     private:
</pre>
<hr />
<pre>
1275 
1276     class BitXOrNode final : public BinaryOpNode {
1277     public:
1278         BitXOrNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1279     };
1280 
1281     // m_expr1 &amp;&amp; m_expr2, m_expr1 || m_expr2
1282     class LogicalOpNode final : public ExpressionNode {
1283     public:
1284         LogicalOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, LogicalOperator);
1285 
1286     private:
1287         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1288         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1289 
1290         LogicalOperator m_operator;
1291         ExpressionNode* m_expr1;
1292         ExpressionNode* m_expr2;
1293     };
1294 




























1295     // The ternary operator, &quot;m_logical ? m_expr1 : m_expr2&quot;
1296     class ConditionalNode final : public ExpressionNode {
1297     public:
1298         ConditionalNode(const JSTokenLocation&amp;, ExpressionNode* logical, ExpressionNode* expr1, ExpressionNode* expr2);
1299 
1300     private:
1301         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1302 
1303         ExpressionNode* m_logical;
1304         ExpressionNode* m_expr1;
1305         ExpressionNode* m_expr2;
1306     };
1307 
1308     class ReadModifyResolveNode final : public ExpressionNode, public ThrowableExpressionData {
1309     public:
1310         ReadModifyResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, Operator, ExpressionNode*  right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1311 
1312     private:
1313         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1314 
</pre>
<hr />
<pre>
1727         bool doAnyInnerArrowFunctionsUseSuperProperty() { return m_innerArrowFunctionCodeFeatures &amp; SuperPropertyInnerArrowFunctionFeature; }
1728         bool doAnyInnerArrowFunctionsUseEval() { return m_innerArrowFunctionCodeFeatures &amp; EvalInnerArrowFunctionFeature; }
1729         bool doAnyInnerArrowFunctionsUseThis() { return m_innerArrowFunctionCodeFeatures &amp; ThisInnerArrowFunctionFeature; }
1730         bool doAnyInnerArrowFunctionsUseNewTarget() { return m_innerArrowFunctionCodeFeatures &amp; NewTargetInnerArrowFunctionFeature; }
1731 
1732         bool usesEval() const { return m_features &amp; EvalFeature; }
1733         bool usesArguments() const { return (m_features &amp; ArgumentsFeature) &amp;&amp; !(m_features &amp; ShadowsArgumentsFeature); }
1734         bool usesArrowFunction() const { return m_features &amp; ArrowFunctionFeature; }
1735         bool isStrictMode() const { return m_features &amp; StrictModeFeature; }
1736         void setUsesArguments() { m_features |= ArgumentsFeature; }
1737         bool usesThis() const { return m_features &amp; ThisFeature; }
1738         bool usesSuperCall() const { return m_features &amp; SuperCallFeature; }
1739         bool usesSuperProperty() const { return m_features &amp; SuperPropertyFeature; }
1740         bool usesNewTarget() const { return m_features &amp; NewTargetFeature; }
1741         bool needsActivation() const { return (hasCapturedVariables()) || (m_features &amp; (EvalFeature | WithFeature)); }
1742         bool hasCapturedVariables() const { return m_varDeclarations.hasCapturedVariables(); }
1743         bool captures(UniquedStringImpl* uid) { return m_varDeclarations.captures(uid); }
1744         bool captures(const Identifier&amp; ident) { return captures(ident.impl()); }
1745         bool hasSloppyModeHoistedFunction(UniquedStringImpl* uid) const { return m_sloppyModeHoistedFunctions.contains(uid); }
1746 





1747         VariableEnvironment&amp; varDeclarations() { return m_varDeclarations; }
1748 
1749         int neededConstants()
1750         {
1751             // We may need 2 more constants than the count given by the parser,
1752             // because of the various uses of jsUndefined() and jsNull().
1753             return m_numConstants + 2;
1754         }
1755 
1756         StatementNode* singleStatement() const;
1757 
1758         bool hasCompletionValue() const override;
1759         bool hasEarlyBreakOrContinue() const override;
1760 
1761         void emitStatementsBytecode(BytecodeGenerator&amp;, RegisterID* destination);
1762 
1763         void analyzeModule(ModuleAnalyzer&amp;);
1764 
1765     protected:
1766         int m_startLineNumber;
</pre>
<hr />
<pre>
1977             ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
1978             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
1979             int functionNameStart, int parametersStart, bool isInStrictContext,
1980             ConstructorKind, SuperBinding, unsigned parameterCount,
1981             SourceParseMode, bool isArrowFunctionBodyExpression);
1982         FunctionMetadataNode(
1983             const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
1984             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
1985             int functionNameStart, int parametersStart, bool isInStrictContext,
1986             ConstructorKind, SuperBinding, unsigned parameterCount,
1987             SourceParseMode, bool isArrowFunctionBodyExpression);
1988 
1989         void dump(PrintStream&amp;) const;
1990 
1991         void finishParsing(const SourceCode&amp;, const Identifier&amp;, FunctionMode);
1992 
1993         void overrideName(const Identifier&amp; ident) { m_ident = ident; }
1994         const Identifier&amp; ident() { return m_ident; }
1995         void setEcmaName(const Identifier&amp; ecmaName) { m_ecmaName = ecmaName; }
1996         const Identifier&amp; ecmaName() { return m_ident.isEmpty() ? m_ecmaName : m_ident; }
<span class="line-removed">1997         void setInferredName(const Identifier&amp; inferredName) { ASSERT(!inferredName.isNull()); m_inferredName = inferredName; }</span>
<span class="line-removed">1998         const Identifier&amp; inferredName() { return m_inferredName.isEmpty() ? m_ident : m_inferredName; }</span>
1999 
2000         FunctionMode functionMode() { return m_functionMode; }
2001 
2002         int functionNameStart() const { return m_functionNameStart; }
2003         int functionKeywordStart() const { return m_functionKeywordStart; }
2004         int parametersStart() const { return m_parametersStart; }
2005         unsigned startColumn() const { return m_startColumn; }
2006         unsigned endColumn() const { return m_endColumn; }
2007         unsigned parameterCount() const { return m_parameterCount; }
2008         SourceParseMode parseMode() const { return m_parseMode; }
2009 
2010         void setEndPosition(JSTextPosition);
2011 
2012         const SourceCode&amp; source() const { return m_source; }
2013         const SourceCode&amp; classSource() const { return m_classSource; }
2014         void setClassSource(const SourceCode&amp; source) { m_classSource = source; }
2015 
2016         int startStartOffset() const { return m_startStartOffset; }
2017         bool isInStrictContext() const { return m_isInStrictContext; }
2018         SuperBinding superBinding() { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
</pre>
<hr />
<pre>
2022         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
2023         {
2024             m_lastLine = lastLine;
2025             m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
2026             ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
2027         }
2028         unsigned lastLine() const { return m_lastLine; }
2029 
2030         bool operator==(const FunctionMetadataNode&amp;) const;
2031         bool operator!=(const FunctionMetadataNode&amp; other) const
2032         {
2033             return !(*this == other);
2034         }
2035 
2036     public:
2037         unsigned m_isInStrictContext : 1;
2038         unsigned m_superBinding : 1;
2039         unsigned m_constructorKind : 2;
2040         unsigned m_isArrowFunctionBodyExpression : 1;
2041         SourceParseMode m_parseMode;

2042         Identifier m_ident;
2043         Identifier m_ecmaName;
<span class="line-removed">2044         Identifier m_inferredName;</span>
<span class="line-removed">2045         FunctionMode m_functionMode;</span>
2046         unsigned m_startColumn;
2047         unsigned m_endColumn;
2048         int m_functionKeywordStart;
2049         int m_functionNameStart;
2050         int m_parametersStart;
2051         SourceCode m_source;
2052         SourceCode m_classSource;
2053         int m_startStartOffset;
2054         unsigned m_parameterCount;
2055         int m_lastLine;
2056     };
2057 
2058     class FunctionNode final : public ScopeNode {
2059     public:
2060         FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
2061 
2062         FunctionParameters* parameters() const { return m_parameters; }
2063 
2064         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2065 
</pre>
</td>
<td>
<hr />
<pre>
 187         virtual bool isBracketAccessorNode() const { return false; }
 188         virtual bool isDotAccessorNode() const { return false; }
 189         virtual bool isDestructuringNode() const { return false; }
 190         virtual bool isBaseFuncExprNode() const { return false; }
 191         virtual bool isFuncExprNode() const { return false; }
 192         virtual bool isArrowFuncExprNode() const { return false; }
 193         virtual bool isClassExprNode() const { return false; }
 194         virtual bool isCommaNode() const { return false; }
 195         virtual bool isSimpleArray() const { return false; }
 196         virtual bool isAdd() const { return false; }
 197         virtual bool isSubtract() const { return false; }
 198         virtual bool isBoolean() const { return false; }
 199         virtual bool isSpreadExpression() const { return false; }
 200         virtual bool isSuperNode() const { return false; }
 201         virtual bool isImportNode() const { return false; }
 202         virtual bool isMetaProperty() const { return false; }
 203         virtual bool isNewTarget() const { return false; }
 204         virtual bool isImportMeta() const { return false; }
 205         virtual bool isBytecodeIntrinsicNode() const { return false; }
 206         virtual bool isBinaryOpNode() const { return false; }
<span class="line-added"> 207         virtual bool isFunctionCall() const { return false; }</span>
<span class="line-added"> 208         virtual bool isDeleteNode() const { return false; }</span>
<span class="line-added"> 209         virtual bool isOptionalChain() const { return false; }</span>
 210 
 211         virtual void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp;, Label&amp;, FallThroughMode);
 212 
 213         virtual ExpressionNode* stripUnaryPlus() { return this; }
 214 
 215         ResultType resultDescriptor() const { return m_resultType; }
 216 
<span class="line-added"> 217         bool isOptionalChainBase() const { return m_isOptionalChainBase; }</span>
<span class="line-added"> 218         void setIsOptionalChainBase() { m_isOptionalChainBase = true; }</span>
<span class="line-added"> 219 </span>
 220     private:
 221         ResultType m_resultType;
<span class="line-added"> 222         bool m_isOptionalChainBase { false };</span>
 223     };
 224 
 225     class StatementNode : public Node {
 226     protected:
 227         StatementNode(const JSTokenLocation&amp;);
 228 
 229     public:
 230         virtual void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = 0) = 0;
 231 
 232         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset);
 233         unsigned lastLine() const { return m_lastLine; }
 234 
 235         StatementNode* next() const { return m_next; }
 236         void setNext(StatementNode* next) { m_next = next; }
 237 
 238         virtual bool hasCompletionValue() const { return true; }
 239         virtual bool hasEarlyBreakOrContinue() const { return false; }
 240 
 241         virtual bool isEmptyStatement() const { return false; }
 242         virtual bool isDebuggerStatement() const { return false; }
</pre>
<hr />
<pre>
 859 
 860     class NewExprNode final : public ExpressionNode, public ThrowableExpressionData {
 861     public:
 862         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*);
 863         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*);
 864 
 865     private:
 866         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 867 
 868         ExpressionNode* m_expr;
 869         ArgumentsNode* m_args;
 870     };
 871 
 872     class EvalFunctionCallNode final : public ExpressionNode, public ThrowableExpressionData {
 873     public:
 874         EvalFunctionCallNode(const JSTokenLocation&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 875 
 876     private:
 877         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 878 
<span class="line-added"> 879         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 880 </span>
 881         ArgumentsNode* m_args;
 882     };
 883 
 884     class FunctionCallValueNode final : public ExpressionNode, public ThrowableExpressionData {
 885     public:
 886         FunctionCallValueNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 887 
 888     private:
 889         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 890 
<span class="line-added"> 891         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 892 </span>
 893         ExpressionNode* m_expr;
 894         ArgumentsNode* m_args;
 895     };
 896 
 897     class FunctionCallResolveNode final : public ExpressionNode, public ThrowableExpressionData {
 898     public:
 899         FunctionCallResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 900 
 901     private:
 902         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 903 
<span class="line-added"> 904         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 905 </span>
 906         const Identifier&amp; m_ident;
 907         ArgumentsNode* m_args;
 908     };
 909 
 910     class FunctionCallBracketNode final : public ExpressionNode, public ThrowableSubExpressionData {
 911     public:
 912         FunctionCallBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 913 
 914     private:
 915         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 916 
<span class="line-added"> 917         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 918 </span>
 919         ExpressionNode* m_base;
 920         ExpressionNode* m_subscript;
 921         ArgumentsNode* m_args;
 922         bool m_subscriptHasAssignments;
 923     };
 924 
 925     class FunctionCallDotNode : public ExpressionNode, public ThrowableSubExpressionData {
 926     public:
 927         FunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 928 
 929     private:
 930         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 931 
 932     protected:
<span class="line-added"> 933         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 934 </span>
 935         ExpressionNode* m_base;
 936         const Identifier&amp; m_ident;
 937         ArgumentsNode* m_args;
 938     };
 939 
 940     class BytecodeIntrinsicNode final : public ExpressionNode, public ThrowableExpressionData {
 941     public:
 942         enum class Type : uint8_t {
 943             Constant,
 944             Function
 945         };
 946 
 947         typedef RegisterID* (BytecodeIntrinsicNode::* EmitterType)(BytecodeGenerator&amp;, RegisterID*);
 948 
 949         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, EmitterType, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 950 
 951         bool isBytecodeIntrinsicNode() const override { return true; }
 952 
 953         Type type() const { return m_type; }
 954         EmitterType emitter() const { return m_emitter; }
 955         const Identifier&amp; identifier() const { return m_ident; }
 956 
 957 #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
 958         JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 959         JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 960 #undef JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS
 961 
 962     private:
 963         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 964 
<span class="line-added"> 965         bool isFunctionCall() const override { return m_type == Type::Function; }</span>
<span class="line-added"> 966 </span>
 967         EmitterType m_emitter;
 968         const Identifier&amp; m_ident;
 969         ArgumentsNode* m_args;
 970         Type m_type;
 971     };
 972 
 973     class CallFunctionCallDotNode final : public FunctionCallDotNode {
 974     public:
 975         CallFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 976 
 977     private:
 978         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 979         size_t m_distanceToInnermostCallOrApply;
 980     };
 981 
 982     class ApplyFunctionCallDotNode final : public FunctionCallDotNode {
 983     public:
 984         ApplyFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 985 
 986     private:
 987         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 988         size_t m_distanceToInnermostCallOrApply;
 989     };
 990 
 991     class DeleteResolveNode final : public ExpressionNode, public ThrowableExpressionData {
 992     public:
 993         DeleteResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 994 
 995     private:
 996         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 997 
<span class="line-added"> 998         bool isDeleteNode() const final { return true; }</span>
<span class="line-added"> 999 </span>
1000         const Identifier&amp; m_ident;
1001     };
1002 
1003     class DeleteBracketNode final : public ExpressionNode, public ThrowableExpressionData {
1004     public:
1005         DeleteBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1006 
1007     private:
1008         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1009 
<span class="line-added">1010         bool isDeleteNode() const final { return true; }</span>
<span class="line-added">1011 </span>
1012         ExpressionNode* m_base;
1013         ExpressionNode* m_subscript;
1014     };
1015 
1016     class DeleteDotNode final : public ExpressionNode, public ThrowableExpressionData {
1017     public:
1018         DeleteDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1019 
1020     private:
1021         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1022 
<span class="line-added">1023         bool isDeleteNode() const final { return true; }</span>
<span class="line-added">1024 </span>
1025         ExpressionNode* m_base;
1026         const Identifier&amp; m_ident;
1027     };
1028 
1029     class DeleteValueNode final : public ExpressionNode {
1030     public:
1031         DeleteValueNode(const JSTokenLocation&amp;, ExpressionNode*);
1032 
1033     private:
1034         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1035 
<span class="line-added">1036         bool isDeleteNode() const final { return true; }</span>
<span class="line-added">1037 </span>
1038         ExpressionNode* m_expr;
1039     };
1040 
1041     class VoidNode final : public ExpressionNode {
1042     public:
1043         VoidNode(const JSTokenLocation&amp;, ExpressionNode*);
1044 
1045     private:
1046         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1047 
1048         ExpressionNode* m_expr;
1049     };
1050 
1051     class TypeOfResolveNode final : public ExpressionNode {
1052     public:
1053         TypeOfResolveNode(const JSTokenLocation&amp;, const Identifier&amp;);
1054 
1055         const Identifier&amp; identifier() const { return m_ident; }
1056 
1057     private:
</pre>
<hr />
<pre>
1302 
1303     class BitXOrNode final : public BinaryOpNode {
1304     public:
1305         BitXOrNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1306     };
1307 
1308     // m_expr1 &amp;&amp; m_expr2, m_expr1 || m_expr2
1309     class LogicalOpNode final : public ExpressionNode {
1310     public:
1311         LogicalOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, LogicalOperator);
1312 
1313     private:
1314         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1315         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1316 
1317         LogicalOperator m_operator;
1318         ExpressionNode* m_expr1;
1319         ExpressionNode* m_expr2;
1320     };
1321 
<span class="line-added">1322     class CoalesceNode final : public ExpressionNode {</span>
<span class="line-added">1323     public:</span>
<span class="line-added">1324         CoalesceNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool);</span>
<span class="line-added">1325 </span>
<span class="line-added">1326     private:</span>
<span class="line-added">1327         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = nullptr) final;</span>
<span class="line-added">1328 </span>
<span class="line-added">1329         ExpressionNode* m_expr1;</span>
<span class="line-added">1330         ExpressionNode* m_expr2;</span>
<span class="line-added">1331         bool m_hasAbsorbedOptionalChain;</span>
<span class="line-added">1332     };</span>
<span class="line-added">1333 </span>
<span class="line-added">1334     class OptionalChainNode final : public ExpressionNode {</span>
<span class="line-added">1335     public:</span>
<span class="line-added">1336         OptionalChainNode(const JSTokenLocation&amp;, ExpressionNode*, bool);</span>
<span class="line-added">1337 </span>
<span class="line-added">1338         void setExpr(ExpressionNode* expr) { m_expr = expr; }</span>
<span class="line-added">1339         ExpressionNode* expr() const { return m_expr; }</span>
<span class="line-added">1340 </span>
<span class="line-added">1341     private:</span>
<span class="line-added">1342         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = nullptr) final;</span>
<span class="line-added">1343 </span>
<span class="line-added">1344         bool isOptionalChain() const final { return true; }</span>
<span class="line-added">1345 </span>
<span class="line-added">1346         ExpressionNode* m_expr;</span>
<span class="line-added">1347         bool m_isOutermost;</span>
<span class="line-added">1348     };</span>
<span class="line-added">1349 </span>
1350     // The ternary operator, &quot;m_logical ? m_expr1 : m_expr2&quot;
1351     class ConditionalNode final : public ExpressionNode {
1352     public:
1353         ConditionalNode(const JSTokenLocation&amp;, ExpressionNode* logical, ExpressionNode* expr1, ExpressionNode* expr2);
1354 
1355     private:
1356         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1357 
1358         ExpressionNode* m_logical;
1359         ExpressionNode* m_expr1;
1360         ExpressionNode* m_expr2;
1361     };
1362 
1363     class ReadModifyResolveNode final : public ExpressionNode, public ThrowableExpressionData {
1364     public:
1365         ReadModifyResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, Operator, ExpressionNode*  right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1366 
1367     private:
1368         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1369 
</pre>
<hr />
<pre>
1782         bool doAnyInnerArrowFunctionsUseSuperProperty() { return m_innerArrowFunctionCodeFeatures &amp; SuperPropertyInnerArrowFunctionFeature; }
1783         bool doAnyInnerArrowFunctionsUseEval() { return m_innerArrowFunctionCodeFeatures &amp; EvalInnerArrowFunctionFeature; }
1784         bool doAnyInnerArrowFunctionsUseThis() { return m_innerArrowFunctionCodeFeatures &amp; ThisInnerArrowFunctionFeature; }
1785         bool doAnyInnerArrowFunctionsUseNewTarget() { return m_innerArrowFunctionCodeFeatures &amp; NewTargetInnerArrowFunctionFeature; }
1786 
1787         bool usesEval() const { return m_features &amp; EvalFeature; }
1788         bool usesArguments() const { return (m_features &amp; ArgumentsFeature) &amp;&amp; !(m_features &amp; ShadowsArgumentsFeature); }
1789         bool usesArrowFunction() const { return m_features &amp; ArrowFunctionFeature; }
1790         bool isStrictMode() const { return m_features &amp; StrictModeFeature; }
1791         void setUsesArguments() { m_features |= ArgumentsFeature; }
1792         bool usesThis() const { return m_features &amp; ThisFeature; }
1793         bool usesSuperCall() const { return m_features &amp; SuperCallFeature; }
1794         bool usesSuperProperty() const { return m_features &amp; SuperPropertyFeature; }
1795         bool usesNewTarget() const { return m_features &amp; NewTargetFeature; }
1796         bool needsActivation() const { return (hasCapturedVariables()) || (m_features &amp; (EvalFeature | WithFeature)); }
1797         bool hasCapturedVariables() const { return m_varDeclarations.hasCapturedVariables(); }
1798         bool captures(UniquedStringImpl* uid) { return m_varDeclarations.captures(uid); }
1799         bool captures(const Identifier&amp; ident) { return captures(ident.impl()); }
1800         bool hasSloppyModeHoistedFunction(UniquedStringImpl* uid) const { return m_sloppyModeHoistedFunctions.contains(uid); }
1801 
<span class="line-added">1802         bool needsNewTargetRegisterForThisScope() const</span>
<span class="line-added">1803         {</span>
<span class="line-added">1804             return usesSuperCall() || usesNewTarget();</span>
<span class="line-added">1805         }</span>
<span class="line-added">1806 </span>
1807         VariableEnvironment&amp; varDeclarations() { return m_varDeclarations; }
1808 
1809         int neededConstants()
1810         {
1811             // We may need 2 more constants than the count given by the parser,
1812             // because of the various uses of jsUndefined() and jsNull().
1813             return m_numConstants + 2;
1814         }
1815 
1816         StatementNode* singleStatement() const;
1817 
1818         bool hasCompletionValue() const override;
1819         bool hasEarlyBreakOrContinue() const override;
1820 
1821         void emitStatementsBytecode(BytecodeGenerator&amp;, RegisterID* destination);
1822 
1823         void analyzeModule(ModuleAnalyzer&amp;);
1824 
1825     protected:
1826         int m_startLineNumber;
</pre>
<hr />
<pre>
2037             ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
2038             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
2039             int functionNameStart, int parametersStart, bool isInStrictContext,
2040             ConstructorKind, SuperBinding, unsigned parameterCount,
2041             SourceParseMode, bool isArrowFunctionBodyExpression);
2042         FunctionMetadataNode(
2043             const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
2044             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
2045             int functionNameStart, int parametersStart, bool isInStrictContext,
2046             ConstructorKind, SuperBinding, unsigned parameterCount,
2047             SourceParseMode, bool isArrowFunctionBodyExpression);
2048 
2049         void dump(PrintStream&amp;) const;
2050 
2051         void finishParsing(const SourceCode&amp;, const Identifier&amp;, FunctionMode);
2052 
2053         void overrideName(const Identifier&amp; ident) { m_ident = ident; }
2054         const Identifier&amp; ident() { return m_ident; }
2055         void setEcmaName(const Identifier&amp; ecmaName) { m_ecmaName = ecmaName; }
2056         const Identifier&amp; ecmaName() { return m_ident.isEmpty() ? m_ecmaName : m_ident; }


2057 
2058         FunctionMode functionMode() { return m_functionMode; }
2059 
2060         int functionNameStart() const { return m_functionNameStart; }
2061         int functionKeywordStart() const { return m_functionKeywordStart; }
2062         int parametersStart() const { return m_parametersStart; }
2063         unsigned startColumn() const { return m_startColumn; }
2064         unsigned endColumn() const { return m_endColumn; }
2065         unsigned parameterCount() const { return m_parameterCount; }
2066         SourceParseMode parseMode() const { return m_parseMode; }
2067 
2068         void setEndPosition(JSTextPosition);
2069 
2070         const SourceCode&amp; source() const { return m_source; }
2071         const SourceCode&amp; classSource() const { return m_classSource; }
2072         void setClassSource(const SourceCode&amp; source) { m_classSource = source; }
2073 
2074         int startStartOffset() const { return m_startStartOffset; }
2075         bool isInStrictContext() const { return m_isInStrictContext; }
2076         SuperBinding superBinding() { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
</pre>
<hr />
<pre>
2080         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
2081         {
2082             m_lastLine = lastLine;
2083             m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
2084             ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
2085         }
2086         unsigned lastLine() const { return m_lastLine; }
2087 
2088         bool operator==(const FunctionMetadataNode&amp;) const;
2089         bool operator!=(const FunctionMetadataNode&amp; other) const
2090         {
2091             return !(*this == other);
2092         }
2093 
2094     public:
2095         unsigned m_isInStrictContext : 1;
2096         unsigned m_superBinding : 1;
2097         unsigned m_constructorKind : 2;
2098         unsigned m_isArrowFunctionBodyExpression : 1;
2099         SourceParseMode m_parseMode;
<span class="line-added">2100         FunctionMode m_functionMode;</span>
2101         Identifier m_ident;
2102         Identifier m_ecmaName;


2103         unsigned m_startColumn;
2104         unsigned m_endColumn;
2105         int m_functionKeywordStart;
2106         int m_functionNameStart;
2107         int m_parametersStart;
2108         SourceCode m_source;
2109         SourceCode m_classSource;
2110         int m_startStartOffset;
2111         unsigned m_parameterCount;
2112         int m_lastLine;
2113     };
2114 
2115     class FunctionNode final : public ScopeNode {
2116     public:
2117         FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
2118 
2119         FunctionParameters* parameters() const { return m_parameters; }
2120 
2121         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2122 
</pre>
</td>
</tr>
</table>
<center><a href="Nodes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>