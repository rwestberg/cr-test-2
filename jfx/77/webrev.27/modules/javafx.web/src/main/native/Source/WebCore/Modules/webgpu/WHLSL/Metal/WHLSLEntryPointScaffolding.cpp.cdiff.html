<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../AST/WHLSLWhileLoop.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,48 ***</span>
  #include &quot;config.h&quot;
  #include &quot;WHLSLEntryPointScaffolding.h&quot;
  
  #if ENABLE(WEBGPU)
  
  #include &quot;WHLSLGatherEntryPointItems.h&quot;
  
  namespace WebCore {
  
  namespace WHLSL {
  
  namespace Metal {
  
<span class="line-modified">! EntryPointScaffolding::EntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics)</span>
<span class="line-removed">-     : m_functionDefinition(&amp;functionDefinition)</span>
<span class="line-removed">-     , m_intrinsics(&amp;intrinsics)</span>
  {
<span class="line-modified">!     // FIXME: Implement this.</span>
<span class="line-modified">!     gatherEntryPointItems(*m_intrinsics, *m_functionDefinition);</span>
  }
  
<span class="line-modified">! String EntryPointScaffolding::helperTypes()</span>
  {
<span class="line-modified">!     // FIXME: Implement this.</span>
<span class="line-modified">!     return String();</span>
  }
  
<span class="line-modified">! String EntryPointScaffolding::signature()</span>
  {
<span class="line-modified">!     // FIXME: Implement this.</span>
<span class="line-modified">!     return String();</span>
  }
  
<span class="line-modified">! String EntryPointScaffolding::unpack()</span>
  {
<span class="line-modified">!     // FIXME: Implement this.</span>
<span class="line-removed">-     return String();</span>
  }
  
<span class="line-modified">! String EntryPointScaffolding::pack(const String&amp;, const String&amp;)</span>
  {
<span class="line-modified">!     // FIXME: Implement this.</span>
<span class="line-removed">-     return String();</span>
  }
  
  }
  
  }
<span class="line-new-header">--- 26,581 ---</span>
  #include &quot;config.h&quot;
  #include &quot;WHLSLEntryPointScaffolding.h&quot;
  
  #if ENABLE(WEBGPU)
  
<span class="line-added">+ #include &quot;WHLSLBuiltInSemantic.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLFunctionDefinition.h&quot;</span>
  #include &quot;WHLSLGatherEntryPointItems.h&quot;
<span class="line-added">+ #include &quot;WHLSLPipelineDescriptor.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLReferenceType.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLResourceSemantic.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLStageInOutSemantic.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLStructureDefinition.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLTypeNamer.h&quot;</span>
<span class="line-added">+ #include &lt;algorithm&gt;</span>
<span class="line-added">+ #include &lt;wtf/Optional.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/text/StringBuilder.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/text/StringConcatenateNumbers.h&gt;</span>
  
  namespace WebCore {
  
  namespace WHLSL {
  
  namespace Metal {
  
<span class="line-modified">! static String attributeForSemantic(AST::BuiltInSemantic&amp; builtInSemantic)</span>
  {
<span class="line-modified">!     switch (builtInSemantic.variable()) {</span>
<span class="line-modified">!     case AST::BuiltInSemantic::Variable::SVInstanceID:</span>
<span class="line-added">+         return &quot;[[instance_id]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVVertexID:</span>
<span class="line-added">+         return &quot;[[vertex_id]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::PSize:</span>
<span class="line-added">+         return &quot;[[point_size]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVPosition:</span>
<span class="line-added">+         return &quot;[[position]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVIsFrontFace:</span>
<span class="line-added">+         return &quot;[[front_facing]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVSampleIndex:</span>
<span class="line-added">+         return &quot;[[sample_id]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVInnerCoverage:</span>
<span class="line-added">+         return &quot;[[sample_mask]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVTarget:</span>
<span class="line-added">+         return makeString(&quot;[[color(&quot;, *builtInSemantic.targetIndex(), &quot;)]]&quot;);</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVDepth:</span>
<span class="line-added">+         return &quot;[[depth(any)]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVCoverage:</span>
<span class="line-added">+         return &quot;[[sample_mask]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVDispatchThreadID:</span>
<span class="line-added">+         return &quot;[[thread_position_in_grid]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVGroupID:</span>
<span class="line-added">+         return &quot;[[threadgroup_position_in_grid]]&quot;_str;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVGroupIndex:</span>
<span class="line-added">+         return &quot;[[thread_index_in_threadgroup]]&quot;_str;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         ASSERT(builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
<span class="line-added">+         return &quot;[[thread_position_in_threadgroup]]&quot;_str;</span>
<span class="line-added">+     }</span>
  }
  
<span class="line-modified">! static String attributeForSemantic(AST::Semantic&amp; semantic)</span>
  {
<span class="line-modified">!     if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(semantic))</span>
<span class="line-modified">!         return attributeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(semantic));</span>
<span class="line-added">+     auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);</span>
<span class="line-added">+     return makeString(&quot;[[user(user&quot;, stageInOutSemantic.index(), &quot;)]]&quot;);</span>
  }
  
<span class="line-modified">! EntryPointScaffolding::EntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)</span>
<span class="line-added">+     : m_functionDefinition(functionDefinition)</span>
<span class="line-added">+     , m_intrinsics(intrinsics)</span>
<span class="line-added">+     , m_typeNamer(typeNamer)</span>
<span class="line-added">+     , m_entryPointItems(entryPointItems)</span>
<span class="line-added">+     , m_resourceMap(resourceMap)</span>
<span class="line-added">+     , m_layout(layout)</span>
<span class="line-added">+     , m_generateNextVariableName(generateNextVariableName)</span>
  {
<span class="line-modified">!     m_namedBindGroups.reserveInitialCapacity(m_layout.size());</span>
<span class="line-modified">!     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">+         NamedBindGroup namedBindGroup;</span>
<span class="line-added">+         namedBindGroup.structName = m_typeNamer.generateNextTypeName();</span>
<span class="line-added">+         namedBindGroup.variableName = m_generateNextVariableName();</span>
<span class="line-added">+         namedBindGroup.argumentBufferIndex = m_layout[i].name; // convertLayout() in GPURenderPipelineMetal.mm makes sure these don&#39;t collide.</span>
<span class="line-added">+         namedBindGroup.namedBindings.reserveInitialCapacity(m_layout[i].bindings.size());</span>
<span class="line-added">+         for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {</span>
<span class="line-added">+             NamedBinding namedBinding;</span>
<span class="line-added">+             namedBinding.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">+             namedBinding.index = m_layout[i].bindings[j].internalName;</span>
<span class="line-added">+             WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding&amp; uniformBufferBinding) {</span>
<span class="line-added">+                 LengthInformation lengthInformation { m_typeNamer.generateNextStructureElementName(), m_generateNextVariableName(), uniformBufferBinding.lengthName };</span>
<span class="line-added">+                 namedBinding.lengthInformation = lengthInformation;</span>
<span class="line-added">+             }, [&amp;](SamplerBinding&amp;) {</span>
<span class="line-added">+             }, [&amp;](TextureBinding&amp;) {</span>
<span class="line-added">+             }, [&amp;](StorageBufferBinding&amp; storageBufferBinding) {</span>
<span class="line-added">+                 LengthInformation lengthInformation { m_typeNamer.generateNextStructureElementName(), m_generateNextVariableName(), storageBufferBinding.lengthName };</span>
<span class="line-added">+                 namedBinding.lengthInformation = lengthInformation;</span>
<span class="line-added">+             }), m_layout[i].bindings[j].binding);</span>
<span class="line-added">+             namedBindGroup.namedBindings.uncheckedAppend(WTFMove(namedBinding));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         m_namedBindGroups.uncheckedAppend(WTFMove(namedBindGroup));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {</span>
<span class="line-added">+         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*m_entryPointItems.inputs[i].semantic))</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         NamedBuiltIn namedBuiltIn;</span>
<span class="line-added">+         namedBuiltIn.indexInEntryPointItems = i;</span>
<span class="line-added">+         namedBuiltIn.variableName = m_generateNextVariableName();</span>
<span class="line-added">+         m_namedBuiltIns.append(WTFMove(namedBuiltIn));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_parameterVariables.reserveInitialCapacity(m_functionDefinition.parameters().size());</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)</span>
<span class="line-added">+         m_parameterVariables.uncheckedAppend(m_generateNextVariableName());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void EntryPointScaffolding::emitResourceHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">+         stringBuilder.append(indent, &quot;struct &quot;, m_namedBindGroups[i].structName, &quot; {\n&quot;);</span>
<span class="line-added">+         {</span>
<span class="line-added">+             IndentationScope scope(indent);</span>
<span class="line-added">+             Vector&lt;std::pair&lt;unsigned, String&gt;&gt; structItems;</span>
<span class="line-added">+             for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {</span>
<span class="line-added">+                 auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="line-added">+                 if (iterator == m_resourceMap.end())</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 auto&amp; type = m_entryPointItems.inputs[iterator-&gt;value].unnamedType-&gt;unifyNode();</span>
<span class="line-added">+                 if (is&lt;AST::UnnamedType&gt;(type) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type))) {</span>
<span class="line-added">+                     auto&amp; referenceType = downcast&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type));</span>
<span class="line-added">+                     auto mangledTypeName = m_typeNamer.mangledNameForType(referenceType.elementType());</span>
<span class="line-added">+                     auto addressSpace = toString(referenceType.addressSpace());</span>
<span class="line-added">+                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">+                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-added">+                     structItems.append(std::make_pair(index, makeString(addressSpace, &quot; &quot;, mangledTypeName, &quot;* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">+                     if (auto lengthInformation = m_namedBindGroups[i].namedBindings[j].lengthInformation)</span>
<span class="line-added">+                         structItems.append(std::make_pair(lengthInformation-&gt;index, makeString(&quot;uint2 &quot;, lengthInformation-&gt;elementName, &quot; [[id(&quot;, lengthInformation-&gt;index, &quot;)]];&quot;)));</span>
<span class="line-added">+                 } else if (is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type))) {</span>
<span class="line-added">+                     auto&amp; namedType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="line-added">+                     auto mangledTypeName = m_typeNamer.mangledNameForType(namedType);</span>
<span class="line-added">+                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">+                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-added">+                     structItems.append(std::make_pair(index, makeString(mangledTypeName, &#39; &#39;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             std::sort(structItems.begin(), structItems.end(), [](const std::pair&lt;unsigned, String&gt;&amp; left, const std::pair&lt;unsigned, String&gt;&amp; right) {</span>
<span class="line-added">+                 return left.first &lt; right.first;</span>
<span class="line-added">+             });</span>
<span class="line-added">+             for (const auto&amp; structItem : structItems)</span>
<span class="line-added">+                 stringBuilder.append(indent, structItem.second, &#39;\n&#39;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         stringBuilder.append(indent, &quot;};\n\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool EntryPointScaffolding::emitResourceSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_layout.size())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (includePrecedingComma == IncludePrecedingComma::Yes)</span>
<span class="line-added">+         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">+         if (i)</span>
<span class="line-added">+             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">+         auto&amp; namedBindGroup = m_namedBindGroups[i];</span>
<span class="line-added">+         stringBuilder.append(&quot;device &quot;, namedBindGroup.structName, &quot;&amp; &quot;, namedBindGroup.variableName, &quot; [[buffer(&quot;, namedBindGroup.argumentBufferIndex, &quot;)]]&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static StringView internalTypeForSemantic(const AST::BuiltInSemantic&amp; builtInSemantic)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (builtInSemantic.variable()) {</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVInstanceID:</span>
<span class="line-added">+         return &quot;uint&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVVertexID:</span>
<span class="line-added">+         return &quot;uint&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::PSize:</span>
<span class="line-added">+         return &quot;float&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVPosition:</span>
<span class="line-added">+         return &quot;float4&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVIsFrontFace:</span>
<span class="line-added">+         return &quot;bool&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVSampleIndex:</span>
<span class="line-added">+         return &quot;uint&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVInnerCoverage:</span>
<span class="line-added">+         return &quot;uint&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVTarget:</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVDepth:</span>
<span class="line-added">+         return &quot;float&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVCoverage:</span>
<span class="line-added">+         return &quot;uint&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVDispatchThreadID:</span>
<span class="line-added">+         return &quot;uint3&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVGroupID:</span>
<span class="line-added">+         return &quot;uint3&quot;;</span>
<span class="line-added">+     case AST::BuiltInSemantic::Variable::SVGroupIndex:</span>
<span class="line-added">+         return &quot;uint&quot;;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         ASSERT(builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
<span class="line-added">+         return &quot;uint3&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool EntryPointScaffolding::emitBuiltInsSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_namedBuiltIns.size())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (includePrecedingComma == IncludePrecedingComma::Yes)</span>
<span class="line-added">+         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_namedBuiltIns.size(); ++i) {</span>
<span class="line-added">+         if (i)</span>
<span class="line-added">+             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">+         auto&amp; namedBuiltIn = m_namedBuiltIns[i];</span>
<span class="line-added">+         auto&amp; item = m_entryPointItems.inputs[namedBuiltIn.indexInEntryPointItems];</span>
<span class="line-added">+         auto&amp; builtInSemantic = WTF::get&lt;AST::BuiltInSemantic&gt;(*item.semantic);</span>
<span class="line-added">+         auto internalType = internalTypeForSemantic(builtInSemantic);</span>
<span class="line-added">+         if (!internalType.isNull())</span>
<span class="line-added">+             stringBuilder.append(internalType);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             stringBuilder.append(m_typeNamer.mangledNameForType(*item.unnamedType));</span>
<span class="line-added">+         stringBuilder.append(&#39; &#39;, namedBuiltIn.variableName, &#39; &#39;, attributeForSemantic(builtInSemantic));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void EntryPointScaffolding::emitMangledInputPath(StringBuilder&amp; stringBuilder, Vector&lt;String&gt;&amp; path)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!path.isEmpty());</span>
<span class="line-added">+     bool found = false;</span>
<span class="line-added">+     AST::StructureDefinition* structureDefinition = nullptr;</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i) {</span>
<span class="line-added">+         if (m_functionDefinition.parameters()[i]-&gt;name() == path[0]) {</span>
<span class="line-added">+             stringBuilder.append(m_parameterVariables[i]);</span>
<span class="line-added">+             auto&amp; unifyNode = m_functionDefinition.parameters()[i]-&gt;type()-&gt;unifyNode();</span>
<span class="line-added">+             if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-added">+                 auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">+                 if (is&lt;AST::StructureDefinition&gt;(namedType))</span>
<span class="line-added">+                     structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             found = true;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ASSERT(found);</span>
<span class="line-added">+     for (size_t i = 1; i &lt; path.size(); ++i) {</span>
<span class="line-added">+         ASSERT(structureDefinition);</span>
<span class="line-added">+         auto* next = structureDefinition-&gt;find(path[i]);</span>
<span class="line-added">+         ASSERT(next);</span>
<span class="line-added">+         stringBuilder.append(&#39;.&#39;, m_typeNamer.mangledNameForStructureElement(*next));</span>
<span class="line-added">+         structureDefinition = nullptr;</span>
<span class="line-added">+         auto&amp; unifyNode = next-&gt;type().unifyNode();</span>
<span class="line-added">+         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-added">+             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">+             if (is&lt;AST::StructureDefinition&gt;(namedType))</span>
<span class="line-added">+                 structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void EntryPointScaffolding::emitMangledOutputPath(StringBuilder&amp; stringBuilder, Vector&lt;String&gt;&amp; path)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     AST::StructureDefinition* structureDefinition = nullptr;</span>
<span class="line-added">+     auto&amp; unifyNode = m_functionDefinition.type().unifyNode();</span>
<span class="line-added">+     structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifyNode));</span>
<span class="line-added">+     for (auto&amp; component : path) {</span>
<span class="line-added">+         ASSERT(structureDefinition);</span>
<span class="line-added">+         auto* next = structureDefinition-&gt;find(component);</span>
<span class="line-added">+         ASSERT(next);</span>
<span class="line-added">+         stringBuilder.append(&#39;.&#39;, m_typeNamer.mangledNameForStructureElement(*next));</span>
<span class="line-added">+         structureDefinition = nullptr;</span>
<span class="line-added">+         auto&amp; unifyNode = next-&gt;type().unifyNode();</span>
<span class="line-added">+         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-added">+             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">+             if (is&lt;AST::StructureDefinition&gt;(namedType))</span>
<span class="line-added">+                 structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void EntryPointScaffolding::emitUnpackResourcesAndNamedBuiltIns(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)</span>
<span class="line-added">+         stringBuilder.append(indent, m_typeNamer.mangledNameForType(*m_functionDefinition.parameters()[i]-&gt;type()), &#39; &#39;, m_parameterVariables[i], &quot;;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">+         auto variableName = m_namedBindGroups[i].variableName;</span>
<span class="line-added">+         for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {</span>
<span class="line-added">+             auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="line-added">+             if (iterator == m_resourceMap.end())</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             if (m_namedBindGroups[i].namedBindings[j].lengthInformation) {</span>
<span class="line-added">+                 auto&amp; path = m_entryPointItems.inputs[iterator-&gt;value].path;</span>
<span class="line-added">+                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">+                 auto lengthElementName = m_namedBindGroups[i].namedBindings[j].lengthInformation-&gt;elementName;</span>
<span class="line-added">+                 auto lengthTemporaryName = m_namedBindGroups[i].namedBindings[j].lengthInformation-&gt;temporaryName;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto&amp; unnamedType = *m_entryPointItems.inputs[iterator-&gt;value].unnamedType;</span>
<span class="line-added">+                 auto mangledTypeName = m_typeNamer.mangledNameForType(downcast&lt;AST::ReferenceType&gt;(unnamedType).elementType());</span>
<span class="line-added">+ </span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, &quot;size_t &quot;, lengthTemporaryName, &quot; = &quot;, variableName, &#39;.&#39;, lengthElementName, &quot;.y;\n&quot;,</span>
<span class="line-added">+                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; &lt;&lt; 32;\n&quot;,</span>
<span class="line-added">+                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; | &quot;, variableName, &#39;.&#39;, lengthElementName, &quot;.x;\n&quot;,</span>
<span class="line-added">+                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; / sizeof(&quot;, mangledTypeName, &quot;);\n&quot;,</span>
<span class="line-added">+                     indent, &quot;if (&quot;, lengthTemporaryName, &quot; &gt; 0xFFFFFFFF)\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    &quot;, lengthTemporaryName, &quot; = 0xFFFFFFFF;\n&quot;</span>
<span class="line-added">+                 );</span>
<span class="line-added">+ </span>
<span class="line-added">+                 stringBuilder.append(indent);</span>
<span class="line-added">+                 emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     &quot; = { &quot;, variableName, &#39;.&#39;, elementName, &quot;, static_cast&lt;uint32_t&gt;(&quot;, lengthTemporaryName, &quot;) };\n&quot;</span>
<span class="line-added">+                 );</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 auto&amp; path = m_entryPointItems.inputs[iterator-&gt;value].path;</span>
<span class="line-added">+                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 stringBuilder.append(indent);</span>
<span class="line-added">+                 emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">+                 stringBuilder.append(&quot; = &quot;, variableName, &#39;.&#39;, elementName, &quot;;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; namedBuiltIn : m_namedBuiltIns) {</span>
<span class="line-added">+         auto&amp; item = m_entryPointItems.inputs[namedBuiltIn.indexInEntryPointItems];</span>
<span class="line-added">+         auto&amp; path = item.path;</span>
<span class="line-added">+         auto&amp; variableName = namedBuiltIn.variableName;</span>
<span class="line-added">+         auto mangledTypeName = m_typeNamer.mangledNameForType(*item.unnamedType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(indent);</span>
<span class="line-added">+         emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">+         stringBuilder.append(&quot; = &quot;, mangledTypeName, &#39;(&#39;, variableName, &quot;);\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ VertexEntryPointScaffolding::VertexEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, HashMap&lt;VertexAttribute*, size_t&gt;&amp; matchedVertexAttributes)</span>
<span class="line-added">+     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))</span>
<span class="line-added">+     , m_matchedVertexAttributes(matchedVertexAttributes)</span>
<span class="line-added">+     , m_stageInStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">+     , m_returnStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">+     , m_stageInParameterName(m_generateNextVariableName())</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_namedStageIns.reserveInitialCapacity(m_matchedVertexAttributes.size());</span>
<span class="line-added">+     for (auto&amp; keyValuePair : m_matchedVertexAttributes) {</span>
<span class="line-added">+         NamedStageIn namedStageIn;</span>
<span class="line-added">+         namedStageIn.indexInEntryPointItems = keyValuePair.value;</span>
<span class="line-added">+         namedStageIn.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">+         namedStageIn.attributeIndex = keyValuePair.key-&gt;metalLocation;</span>
<span class="line-added">+         m_namedStageIns.uncheckedAppend(WTFMove(namedStageIn));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_namedOutputs.reserveInitialCapacity(m_entryPointItems.outputs.size());</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">+         auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">+         NamedOutput namedOutput;</span>
<span class="line-added">+         namedOutput.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">+         StringView internalType;</span>
<span class="line-added">+         if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic))</span>
<span class="line-added">+             internalType = internalTypeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic));</span>
<span class="line-added">+         if (!internalType.isNull())</span>
<span class="line-added">+             namedOutput.internalTypeName = internalType.toString();</span>
<span class="line-added">+         else</span>
<span class="line-added">+             namedOutput.internalTypeName = m_typeNamer.mangledNameForType(*outputItem.unnamedType);</span>
<span class="line-added">+         m_namedOutputs.uncheckedAppend(WTFMove(namedOutput));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void VertexEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stringBuilder.append(indent, &quot;struct &quot;, m_stageInStructName, &quot; {\n&quot;);</span>
<span class="line-added">+     {</span>
<span class="line-added">+         IndentationScope scope(indent);</span>
<span class="line-added">+         for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">+             auto mangledTypeName = m_typeNamer.mangledNameForType(*m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].unnamedType);</span>
<span class="line-added">+             auto elementName = namedStageIn.elementName;</span>
<span class="line-added">+             auto attributeIndex = namedStageIn.attributeIndex;</span>
<span class="line-added">+             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[attribute(&quot;, attributeIndex, &quot;)]];\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     stringBuilder.append(</span>
<span class="line-added">+         indent, &quot;};\n\n&quot;,</span>
<span class="line-added">+         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;</span>
<span class="line-added">+     );</span>
<span class="line-added">+     {</span>
<span class="line-added">+         IndentationScope scope(indent);</span>
<span class="line-added">+         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">+             auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">+             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">+             auto elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">+             auto attribute = attributeForSemantic(*outputItem.semantic);</span>
<span class="line-added">+             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     stringBuilder.append(indent, &quot;};\n\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void VertexEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stringBuilder.append(indent, &quot;vertex &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);</span>
<span class="line-added">+     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">+     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">+     stringBuilder.append(&quot;)\n&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void VertexEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">+         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;</span>
<span class="line-added">+         auto&amp; elementName = namedStageIn.elementName;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(indent);</span>
<span class="line-added">+         emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">+         stringBuilder.append(&quot; = &quot;, m_stageInParameterName, &#39;.&#39;, elementName, &quot;;\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void VertexEntryPointScaffolding::emitPack(StringBuilder&amp; stringBuilder, MangledVariableName inputVariableName, MangledVariableName outputVariableName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stringBuilder.append(indent, m_returnStructName, &#39; &#39;, outputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">+     if (m_entryPointItems.outputs.size() == 1 &amp;&amp; !m_entryPointItems.outputs[0].path.size()) {</span>
<span class="line-added">+         auto&amp; elementName = m_namedOutputs[0].elementName;</span>
<span class="line-added">+         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">+         auto&amp; elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">+         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">+         auto&amp; path = m_entryPointItems.outputs[i].path;</span>
<span class="line-added">+         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);</span>
<span class="line-added">+         emitMangledOutputPath(stringBuilder, path);</span>
<span class="line-added">+         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FragmentEntryPointScaffolding::FragmentEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, HashMap&lt;AttachmentDescriptor*, size_t&gt;&amp;)</span>
<span class="line-added">+     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))</span>
<span class="line-added">+     , m_stageInStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">+     , m_returnStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">+     , m_stageInParameterName(m_generateNextVariableName())</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {</span>
<span class="line-added">+         auto&amp; inputItem = m_entryPointItems.inputs[i];</span>
<span class="line-added">+         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*inputItem.semantic))</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*inputItem.semantic);</span>
<span class="line-added">+         NamedStageIn namedStageIn;</span>
<span class="line-added">+         namedStageIn.indexInEntryPointItems = i;</span>
<span class="line-added">+         namedStageIn.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">+         namedStageIn.attributeIndex = stageInOutSemantic.index();</span>
<span class="line-added">+         m_namedStageIns.append(WTFMove(namedStageIn));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_namedOutputs.reserveInitialCapacity(m_entryPointItems.outputs.size());</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">+         auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">+         NamedOutput namedOutput;</span>
<span class="line-added">+         namedOutput.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">+         StringView internalType;</span>
<span class="line-added">+         if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic))</span>
<span class="line-added">+             internalType = internalTypeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic));</span>
<span class="line-added">+         if (!internalType.isNull())</span>
<span class="line-added">+             namedOutput.internalTypeName = internalType.toString();</span>
<span class="line-added">+         else</span>
<span class="line-added">+             namedOutput.internalTypeName = m_typeNamer.mangledNameForType(*outputItem.unnamedType);</span>
<span class="line-added">+         m_namedOutputs.uncheckedAppend(WTFMove(namedOutput));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FragmentEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stringBuilder.append(indent, &quot;struct &quot;, m_stageInStructName, &quot; {\n&quot;);</span>
<span class="line-added">+     {</span>
<span class="line-added">+         IndentationScope scope(indent);</span>
<span class="line-added">+         for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">+             auto mangledTypeName = m_typeNamer.mangledNameForType(*m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].unnamedType);</span>
<span class="line-added">+             auto elementName = namedStageIn.elementName;</span>
<span class="line-added">+             auto attributeIndex = namedStageIn.attributeIndex;</span>
<span class="line-added">+             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[user(user&quot;, attributeIndex, &quot;)]];\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     stringBuilder.append(</span>
<span class="line-added">+         indent, &quot;};\n\n&quot;,</span>
<span class="line-added">+         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;</span>
<span class="line-added">+     );</span>
<span class="line-added">+     {</span>
<span class="line-added">+         IndentationScope scope(indent);</span>
<span class="line-added">+         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">+             auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">+             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">+             auto elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">+             auto attribute = attributeForSemantic(*outputItem.semantic);</span>
<span class="line-added">+             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     stringBuilder.append(indent, &quot;};\n\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FragmentEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stringBuilder.append(indent, &quot;fragment &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);</span>
<span class="line-added">+     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">+     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">+     stringBuilder.append(&quot;)\n&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FragmentEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">+         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;</span>
<span class="line-added">+         auto&amp; elementName = namedStageIn.elementName;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(indent);</span>
<span class="line-added">+         emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">+         stringBuilder.append(&quot; = &quot;, m_stageInParameterName, &#39;.&#39;, elementName, &quot;;\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FragmentEntryPointScaffolding::emitPack(StringBuilder&amp; stringBuilder, MangledVariableName inputVariableName, MangledVariableName outputVariableName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stringBuilder.append(indent, m_returnStructName, &#39; &#39;, outputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">+     if (m_entryPointItems.outputs.size() == 1 &amp;&amp; !m_entryPointItems.outputs[0].path.size()) {</span>
<span class="line-added">+         auto&amp; elementName = m_namedOutputs[0].elementName;</span>
<span class="line-added">+         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">+         auto&amp; elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">+         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">+         auto&amp; path = m_entryPointItems.outputs[i].path;</span>
<span class="line-added">+         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);</span>
<span class="line-added">+         emitMangledOutputPath(stringBuilder, path);</span>
<span class="line-added">+         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ComputeEntryPointScaffolding::ComputeEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)</span>
<span class="line-added">+     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ComputeEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ComputeEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stringBuilder.append(indent, &quot;kernel void &quot;, functionName, &#39;(&#39;);</span>
<span class="line-added">+     bool addedToSignature = emitResourceSignature(stringBuilder, IncludePrecedingComma::No);</span>
<span class="line-added">+     emitBuiltInsSignature(stringBuilder, addedToSignature ? IncludePrecedingComma::Yes : IncludePrecedingComma::No);</span>
<span class="line-added">+     stringBuilder.append(&quot;)\n&quot;);</span>
  }
  
<span class="line-modified">! void ComputeEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
  {
<span class="line-modified">!     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);</span>
  }
  
<span class="line-modified">! void ComputeEntryPointScaffolding::emitPack(StringBuilder&amp;, MangledVariableName, MangledVariableName, Indentation&lt;4&gt;)</span>
  {
<span class="line-modified">!     ASSERT_NOT_REACHED();</span>
  }
  
  }
  
  }
</pre>
<center><a href="../AST/WHLSLWhileLoop.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>