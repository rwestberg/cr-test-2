<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MIPSAssembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2009 University of Szeged
   4  * All rights reserved.
   5  * Copyright (C) 2010 MIPS Technologies, Inc. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
  32 
  33 #include &quot;AssemblerBuffer.h&quot;
  34 #include &quot;JITCompilationEffort.h&quot;
  35 #include &quot;MIPSRegisters.h&quot;
  36 #include &lt;limits.h&gt;
  37 #include &lt;wtf/Assertions.h&gt;
  38 #include &lt;wtf/SegmentedVector.h&gt;
  39 
  40 namespace JSC {
  41 
  42 typedef uint32_t MIPSWord;
  43 
  44 namespace RegisterNames {
  45 typedef enum : int8_t {
  46 #define REGISTER_ID(id, name, r, cs) id,
  47     FOR_EACH_GP_REGISTER(REGISTER_ID)
  48 #undef REGISTER_ID
  49 #define REGISTER_ALIAS(id, alias) id = alias,
  50     FOR_EACH_REGISTER_ALIAS(REGISTER_ALIAS)
  51 #undef REGISTER_ALIAS
  52     InvalidGPRReg = -1,
  53 } RegisterID;
  54 
  55 typedef enum : int8_t {
  56 #define REGISTER_ID(id, name, idx) id = idx,
  57     FOR_EACH_SP_REGISTER(REGISTER_ID)
  58 #undef REGISTER_ID
  59 } SPRegisterID;
  60 
  61 typedef enum : int8_t {
  62 #define REGISTER_ID(id, name, r, cs) id,
  63     FOR_EACH_FP_REGISTER(REGISTER_ID)
  64 #undef REGISTER_ID
  65     InvalidFPRReg = -1,
  66 } FPRegisterID;
  67 
  68 } // namespace MIPSRegisters
  69 
  70 class MIPSAssembler {
  71 public:
  72     typedef MIPSRegisters::RegisterID RegisterID;
  73     typedef MIPSRegisters::SPRegisterID SPRegisterID;
  74     typedef MIPSRegisters::FPRegisterID FPRegisterID;
  75     typedef SegmentedVector&lt;AssemblerLabel, 64&gt; Jumps;
  76 
  77     static constexpr RegisterID firstRegister() { return MIPSRegisters::r0; }
  78     static constexpr RegisterID lastRegister() { return MIPSRegisters::r31; }
  79     static constexpr unsigned numberOfRegisters() { return lastRegister() - firstRegister() + 1; }
  80 
  81     static constexpr SPRegisterID firstSPRegister() { return MIPSRegisters::fir; }
  82     static constexpr SPRegisterID lastSPRegister() { return MIPSRegisters::pc; }
  83     static constexpr unsigned numberOfSPRegisters() { return lastSPRegister() - firstSPRegister() + 1; }
  84 
  85     static constexpr FPRegisterID firstFPRegister() { return MIPSRegisters::f0; }
  86     static constexpr FPRegisterID lastFPRegister() { return MIPSRegisters::f31; }
  87     static constexpr unsigned numberOfFPRegisters() { return lastFPRegister() - firstFPRegister() + 1; }
  88 
  89     static const char* gprName(RegisterID id)
  90     {
  91         ASSERT(id &gt;= firstRegister() &amp;&amp; id &lt;= lastRegister());
  92         static const char* const nameForRegister[numberOfRegisters()] = {
  93 #define REGISTER_NAME(id, name, r, c) name,
  94         FOR_EACH_GP_REGISTER(REGISTER_NAME)
  95 #undef REGISTER_NAME
  96         };
  97         return nameForRegister[id];
  98     }
  99 
 100     static const char* sprName(SPRegisterID id)
 101     {
 102         ASSERT(id &gt;= firstSPRegister() &amp;&amp; id &lt;= lastSPRegister());
 103         static const char* const nameForRegister[numberOfSPRegisters()] = {
 104 #define REGISTER_NAME(id, name, idx) name,
 105         FOR_EACH_SP_REGISTER(REGISTER_NAME)
 106 #undef REGISTER_NAME
 107         };
 108         return nameForRegister[id];
 109     }
 110 
 111     static const char* fprName(FPRegisterID id)
 112     {
 113         ASSERT(id &gt;= firstFPRegister() &amp;&amp; id &lt;= lastFPRegister());
 114         static const char* const nameForRegister[numberOfFPRegisters()] = {
 115 #define REGISTER_NAME(id, name, r, cs) name,
 116         FOR_EACH_FP_REGISTER(REGISTER_NAME)
 117 #undef REGISTER_NAME
 118         };
 119         return nameForRegister[id];
 120     }
 121 
 122     MIPSAssembler()
 123         : m_indexOfLastWatchpoint(INT_MIN)
 124         , m_indexOfTailOfLastWatchpoint(INT_MIN)
 125     {
 126     }
 127 
 128     AssemblerBuffer&amp; buffer() { return m_buffer; }
 129 
 130     // MIPS instruction opcode field position
 131     enum {
 132         OP_SH_RD = 11,
 133         OP_SH_RT = 16,
 134         OP_SH_RS = 21,
 135         OP_SH_SHAMT = 6,
 136         OP_SH_CODE = 16,
 137         OP_SH_FD = 6,
 138         OP_SH_FS = 11,
 139         OP_SH_FT = 16,
 140         OP_SH_MSB = 11,
 141         OP_SH_LSB = 6
 142     };
 143 
 144     // FCSR Bits
 145     enum {
 146         FP_CAUSE_INVALID_OPERATION = 1 &lt;&lt; 16
 147     };
 148 
 149     void emitInst(MIPSWord op)
 150     {
 151         void* oldBase = m_buffer.data();
 152 
 153         m_buffer.putInt(op);
 154 
 155         void* newBase = m_buffer.data();
 156         if (oldBase != newBase)
 157             relocateJumps(oldBase, newBase);
 158     }
 159 
 160     void nop()
 161     {
 162         emitInst(0x00000000);
 163     }
 164 
 165     template &lt;typename CopyFunction&gt;
 166     static void fillNops(void* base, size_t size, CopyFunction copy)
 167     {
 168         UNUSED_PARAM(copy);
 169         RELEASE_ASSERT(!(size % sizeof(int32_t)));
 170 
 171         int32_t* ptr = static_cast&lt;int32_t*&gt;(base);
 172         const size_t num32s = size / sizeof(int32_t);
 173         const int32_t insn = 0x00000000;
 174         for (size_t i = 0; i &lt; num32s; i++)
 175             *ptr++ = insn;
 176     }
 177 
 178     void sync()
 179     {
 180         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=169984
 181         // We might get a performance improvements by using SYNC_MB in some or
 182         // all cases.
 183         emitInst(0x0000000f);
 184     }
 185 
 186     /* Need to insert one load data delay nop for mips1.  */
 187     void loadDelayNop()
 188     {
 189 #if WTF_MIPS_ISA(1)
 190         nop();
 191 #endif
 192     }
 193 
 194     /* Need to insert one coprocessor access delay nop for mips1.  */
 195     void copDelayNop()
 196     {
 197 #if WTF_MIPS_ISA(1)
 198         nop();
 199 #endif
 200     }
 201 
 202     void move(RegisterID rd, RegisterID rs)
 203     {
 204         /* addu */
 205         emitInst(0x00000021 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS));
 206     }
 207 
 208     /* Set an immediate value to a register.  This may generate 1 or 2
 209        instructions.  */
 210     void li(RegisterID dest, int imm)
 211     {
 212         if (imm &gt;= -32768 &amp;&amp; imm &lt;= 32767)
 213             addiu(dest, MIPSRegisters::zero, imm);
 214         else if (imm &gt;= 0 &amp;&amp; imm &lt; 65536)
 215             ori(dest, MIPSRegisters::zero, imm);
 216         else {
 217             lui(dest, imm &gt;&gt; 16);
 218             if (imm &amp; 0xffff)
 219                 ori(dest, dest, imm);
 220         }
 221     }
 222 
 223     void ext(RegisterID rt, RegisterID rs, int pos, int size)
 224     {
 225         int msb = size - 1;
 226         emitInst(0x7c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (pos &lt;&lt; OP_SH_LSB) | (msb &lt;&lt; OP_SH_MSB));
 227     }
 228 
 229     void mfhc1(RegisterID rt, FPRegisterID fs)
 230     {
 231         emitInst(0x4460000 | (rt &lt;&lt; OP_SH_RT) | (fs &lt;&lt; OP_SH_FS));
 232     }
 233 
 234     void lui(RegisterID rt, int imm)
 235     {
 236         emitInst(0x3c000000 | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 237     }
 238 
 239     void clz(RegisterID rd, RegisterID rs)
 240     {
 241         emitInst(0x70000020 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rd &lt;&lt; OP_SH_RT));
 242     }
 243 
 244     void addiu(RegisterID rt, RegisterID rs, int imm)
 245     {
 246         emitInst(0x24000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 247     }
 248 
 249     void addu(RegisterID rd, RegisterID rs, RegisterID rt)
 250     {
 251         emitInst(0x00000021 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 252     }
 253 
 254     void subu(RegisterID rd, RegisterID rs, RegisterID rt)
 255     {
 256         emitInst(0x00000023 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 257     }
 258 
 259     void mult(RegisterID rs, RegisterID rt)
 260     {
 261         emitInst(0x00000018 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 262     }
 263 
 264     void div(RegisterID rs, RegisterID rt)
 265     {
 266         emitInst(0x0000001a | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 267     }
 268 
 269     void mfhi(RegisterID rd)
 270     {
 271         emitInst(0x00000010 | (rd &lt;&lt; OP_SH_RD));
 272     }
 273 
 274     void mflo(RegisterID rd)
 275     {
 276         emitInst(0x00000012 | (rd &lt;&lt; OP_SH_RD));
 277     }
 278 
 279     void mul(RegisterID rd, RegisterID rs, RegisterID rt)
 280     {
 281 #if WTF_MIPS_ISA_AT_LEAST(32)
 282         emitInst(0x70000002 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 283 #else
 284         mult(rs, rt);
 285         mflo(rd);
 286 #endif
 287     }
 288 
 289     void andInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 290     {
 291         emitInst(0x00000024 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 292     }
 293 
 294     void andi(RegisterID rt, RegisterID rs, int imm)
 295     {
 296         emitInst(0x30000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 297     }
 298 
 299     void nor(RegisterID rd, RegisterID rs, RegisterID rt)
 300     {
 301         emitInst(0x00000027 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 302     }
 303 
 304     void orInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 305     {
 306         emitInst(0x00000025 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 307     }
 308 
 309     void ori(RegisterID rt, RegisterID rs, int imm)
 310     {
 311         emitInst(0x34000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 312     }
 313 
 314     void xorInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 315     {
 316         emitInst(0x00000026 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 317     }
 318 
 319     void xori(RegisterID rt, RegisterID rs, int imm)
 320     {
 321         emitInst(0x38000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 322     }
 323 
 324     void slt(RegisterID rd, RegisterID rs, RegisterID rt)
 325     {
 326         emitInst(0x0000002a | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 327     }
 328 
 329     void sltu(RegisterID rd, RegisterID rs, RegisterID rt)
 330     {
 331         emitInst(0x0000002b | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 332     }
 333 
 334     void slti(RegisterID rt, RegisterID rs, int imm)
 335     {
 336         emitInst(0x28000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 337     }
 338 
 339     void sltiu(RegisterID rt, RegisterID rs, int imm)
 340     {
 341         emitInst(0x2c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 342     }
 343 
 344     void sll(RegisterID rd, RegisterID rt, int shamt)
 345     {
 346         emitInst(0x00000000 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 347     }
 348 
 349     void sllv(RegisterID rd, RegisterID rt, RegisterID rs)
 350     {
 351         emitInst(0x00000004 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 352     }
 353 
 354     void sra(RegisterID rd, RegisterID rt, int shamt)
 355     {
 356         emitInst(0x00000003 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 357     }
 358 
 359     void srav(RegisterID rd, RegisterID rt, RegisterID rs)
 360     {
 361         emitInst(0x00000007 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 362     }
 363 
 364     void srl(RegisterID rd, RegisterID rt, int shamt)
 365     {
 366         emitInst(0x00000002 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 367     }
 368 
 369     void srlv(RegisterID rd, RegisterID rt, RegisterID rs)
 370     {
 371         emitInst(0x00000006 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 372     }
 373 
 374     void lb(RegisterID rt, RegisterID rs, int offset)
 375     {
 376         emitInst(0x80000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 377         loadDelayNop();
 378     }
 379 
 380     void lbu(RegisterID rt, RegisterID rs, int offset)
 381     {
 382         emitInst(0x90000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 383         loadDelayNop();
 384     }
 385 
 386     void lw(RegisterID rt, RegisterID rs, int offset)
 387     {
 388         emitInst(0x8c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 389         loadDelayNop();
 390     }
 391 
 392     void lwl(RegisterID rt, RegisterID rs, int offset)
 393     {
 394         emitInst(0x88000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 395         loadDelayNop();
 396     }
 397 
 398     void lwr(RegisterID rt, RegisterID rs, int offset)
 399     {
 400         emitInst(0x98000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 401         loadDelayNop();
 402     }
 403 
 404     void lh(RegisterID rt, RegisterID rs, int offset)
 405     {
 406         emitInst(0x84000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 407         loadDelayNop();
 408     }
 409 
 410     void lhu(RegisterID rt, RegisterID rs, int offset)
 411     {
 412         emitInst(0x94000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 413         loadDelayNop();
 414     }
 415 
 416     void sb(RegisterID rt, RegisterID rs, int offset)
 417     {
 418         emitInst(0xa0000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 419     }
 420 
 421     void sh(RegisterID rt, RegisterID rs, int offset)
 422     {
 423         emitInst(0xa4000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 424     }
 425 
 426     void sw(RegisterID rt, RegisterID rs, int offset)
 427     {
 428         emitInst(0xac000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 429     }
 430 
 431     void jr(RegisterID rs)
 432     {
 433         emitInst(0x00000008 | (rs &lt;&lt; OP_SH_RS));
 434     }
 435 
 436     void jalr(RegisterID rs)
 437     {
 438         emitInst(0x0000f809 | (rs &lt;&lt; OP_SH_RS));
 439     }
 440 
 441     void jal()
 442     {
 443         emitInst(0x0c000000);
 444     }
 445 
 446     void bkpt()
 447     {
 448         int value = 512; /* BRK_BUG */
 449         emitInst(0x0000000d | ((value &amp; 0x3ff) &lt;&lt; OP_SH_CODE));
 450     }
 451 
 452     static bool isBkpt(void* address)
 453     {
 454         int value = 512; /* BRK_BUG */
 455         MIPSWord expected = (0x0000000d | ((value &amp; 0x3ff) &lt;&lt; OP_SH_CODE));
 456         MIPSWord candidateInstruction = *reinterpret_cast&lt;MIPSWord*&gt;(address);
 457         return candidateInstruction == expected;
 458     }
 459 
 460     void bgez(RegisterID rs, int imm)
 461     {
 462         emitInst(0x04010000 | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 463     }
 464 
 465     void bltz(RegisterID rs, int imm)
 466     {
 467         emitInst(0x04000000 | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 468     }
 469 
 470     void beq(RegisterID rs, RegisterID rt, int imm)
 471     {
 472         emitInst(0x10000000 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 473     }
 474 
 475     void bne(RegisterID rs, RegisterID rt, int imm)
 476     {
 477         emitInst(0x14000000 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 478     }
 479 
 480     void bc1t()
 481     {
 482         emitInst(0x45010000);
 483     }
 484 
 485     void bc1f()
 486     {
 487         emitInst(0x45000000);
 488     }
 489 
 490     void appendJump()
 491     {
 492         m_jumps.append(m_buffer.label());
 493     }
 494 
 495     void addd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 496     {
 497         emitInst(0x46200000 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 498     }
 499 
 500     void subd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 501     {
 502         emitInst(0x46200001 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 503     }
 504 
 505     void muld(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 506     {
 507         emitInst(0x46200002 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 508     }
 509 
 510     void divd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 511     {
 512         emitInst(0x46200003 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 513     }
 514 
 515     void lwc1(FPRegisterID ft, RegisterID rs, int offset)
 516     {
 517         emitInst(0xc4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 518         copDelayNop();
 519     }
 520 
 521     void ldc1(FPRegisterID ft, RegisterID rs, int offset)
 522     {
 523         emitInst(0xd4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 524     }
 525 
 526     void swc1(FPRegisterID ft, RegisterID rs, int offset)
 527     {
 528         emitInst(0xe4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 529     }
 530 
 531     void sdc1(FPRegisterID ft, RegisterID rs, int offset)
 532     {
 533         emitInst(0xf4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 534     }
 535 
 536     void mtc1(RegisterID rt, FPRegisterID fs)
 537     {
 538         emitInst(0x44800000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 539         copDelayNop();
 540     }
 541 
 542     void mthc1(RegisterID rt, FPRegisterID fs)
 543     {
 544         emitInst(0x44e00000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 545         copDelayNop();
 546     }
 547 
 548     void mfc1(RegisterID rt, FPRegisterID fs)
 549     {
 550         emitInst(0x44000000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 551         copDelayNop();
 552     }
 553 
 554     void sqrtd(FPRegisterID fd, FPRegisterID fs)
 555     {
 556         emitInst(0x46200004 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 557     }
 558 
 559     void absd(FPRegisterID fd, FPRegisterID fs)
 560     {
 561         emitInst(0x46200005 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 562     }
 563 
 564     void movd(FPRegisterID fd, FPRegisterID fs)
 565     {
 566         emitInst(0x46200006 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 567     }
 568 
 569     void negd(FPRegisterID fd, FPRegisterID fs)
 570     {
 571         emitInst(0x46200007 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 572     }
 573 
 574     void truncwd(FPRegisterID fd, FPRegisterID fs)
 575     {
 576         emitInst(0x4620000d | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 577     }
 578 
 579     void cvtdw(FPRegisterID fd, FPRegisterID fs)
 580     {
 581         emitInst(0x46800021 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 582     }
 583 
 584     void cvtds(FPRegisterID fd, FPRegisterID fs)
 585     {
 586         emitInst(0x46000021 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 587     }
 588 
 589     void cvtwd(FPRegisterID fd, FPRegisterID fs)
 590     {
 591         emitInst(0x46200024 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 592     }
 593 
 594     void cvtsd(FPRegisterID fd, FPRegisterID fs)
 595     {
 596         emitInst(0x46200020 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 597     }
 598 
 599     void ceqd(FPRegisterID fs, FPRegisterID ft)
 600     {
 601         emitInst(0x46200032 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 602         copDelayNop();
 603     }
 604 
 605     void cngtd(FPRegisterID fs, FPRegisterID ft)
 606     {
 607         emitInst(0x4620003f | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 608         copDelayNop();
 609     }
 610 
 611     void cnged(FPRegisterID fs, FPRegisterID ft)
 612     {
 613         emitInst(0x4620003d | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 614         copDelayNop();
 615     }
 616 
 617     void cltd(FPRegisterID fs, FPRegisterID ft)
 618     {
 619         emitInst(0x4620003c | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 620         copDelayNop();
 621     }
 622 
 623     void cled(FPRegisterID fs, FPRegisterID ft)
 624     {
 625         emitInst(0x4620003e | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 626         copDelayNop();
 627     }
 628 
 629     void cueqd(FPRegisterID fs, FPRegisterID ft)
 630     {
 631         emitInst(0x46200033 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 632         copDelayNop();
 633     }
 634 
 635     void coled(FPRegisterID fs, FPRegisterID ft)
 636     {
 637         emitInst(0x46200036 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 638         copDelayNop();
 639     }
 640 
 641     void coltd(FPRegisterID fs, FPRegisterID ft)
 642     {
 643         emitInst(0x46200034 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 644         copDelayNop();
 645     }
 646 
 647     void culed(FPRegisterID fs, FPRegisterID ft)
 648     {
 649         emitInst(0x46200037 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 650         copDelayNop();
 651     }
 652 
 653     void cultd(FPRegisterID fs, FPRegisterID ft)
 654     {
 655         emitInst(0x46200035 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 656         copDelayNop();
 657     }
 658 
 659     void cfc1(RegisterID rt, SPRegisterID fs)
 660     {
 661         emitInst(0x44400000 | (rt &lt;&lt; OP_SH_RT) | (fs &lt;&lt; OP_SH_FS));
 662         copDelayNop();
 663     }
 664 
 665     // General helpers
 666 
 667     AssemblerLabel labelIgnoringWatchpoints()
 668     {
 669         return m_buffer.label();
 670     }
 671 
 672     AssemblerLabel labelForWatchpoint()
 673     {
 674         AssemblerLabel result = m_buffer.label();
 675         if (static_cast&lt;int&gt;(result.m_offset) != m_indexOfLastWatchpoint)
 676             result = label();
 677         m_indexOfLastWatchpoint = result.m_offset;
 678         m_indexOfTailOfLastWatchpoint = result.m_offset + maxJumpReplacementSize();
 679         return result;
 680     }
 681 
 682     AssemblerLabel label()
 683     {
 684         AssemblerLabel result = m_buffer.label();
 685         while (UNLIKELY(static_cast&lt;int&gt;(result.m_offset) &lt; m_indexOfTailOfLastWatchpoint)) {
 686             nop();
 687             result = m_buffer.label();
 688         }
 689         return result;
 690     }
 691 
 692     AssemblerLabel align(int alignment)
 693     {
 694         while (!m_buffer.isAligned(alignment))
 695             bkpt();
 696 
 697         return label();
 698     }
 699 
 700     static void* getRelocatedAddress(void* code, AssemblerLabel label)
 701     {
 702         return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;char*&gt;(code) + label.m_offset);
 703     }
 704 
 705     static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
 706     {
 707         return b.m_offset - a.m_offset;
 708     }
 709 
 710     // Assembler admin methods:
 711 
 712     size_t codeSize() const
 713     {
 714         return m_buffer.codeSize();
 715     }
 716 
 717     unsigned debugOffset() { return m_buffer.debugOffset(); }
 718 
 719     // Assembly helpers for moving data between fp and registers.
 720     void vmov(RegisterID rd1, RegisterID rd2, FPRegisterID rn)
 721     {
 722 #if WTF_MIPS_ISA_REV(2) &amp;&amp; WTF_MIPS_FP64
 723         mfc1(rd1, rn);
 724         mfhc1(rd2, rn);
 725 #else
 726         mfc1(rd1, rn);
 727         mfc1(rd2, FPRegisterID(rn + 1));
 728 #endif
 729     }
 730 
 731     void vmov(FPRegisterID rd, RegisterID rn1, RegisterID rn2)
 732     {
 733 #if WTF_MIPS_ISA_REV(2) &amp;&amp; WTF_MIPS_FP64
 734         mtc1(rn1, rd);
 735         mthc1(rn2, rd);
 736 #else
 737         mtc1(rn1, rd);
 738         mtc1(rn2, FPRegisterID(rd + 1));
 739 #endif
 740     }
 741 
 742     static unsigned getCallReturnOffset(AssemblerLabel call)
 743     {
 744         // The return address is after a call and a delay slot instruction
 745         return call.m_offset;
 746     }
 747 
 748     // Linking &amp; patching:
 749     //
 750     // &#39;link&#39; and &#39;patch&#39; methods are for use on unprotected code - such as the code
 751     // within the AssemblerBuffer, and code being patched by the patch buffer. Once
 752     // code has been finalized it is (platform support permitting) within a non-
 753     // writable region of memory; to modify the code in an execute-only execuable
 754     // pool the &#39;repatch&#39; and &#39;relink&#39; methods should be used.
 755 
 756     static size_t linkDirectJump(void* code, void* to)
 757     {
 758         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code));
 759         size_t ops = 0;
 760         int32_t slotAddr = reinterpret_cast&lt;int&gt;(insn) + 4;
 761         int32_t toAddr = reinterpret_cast&lt;int&gt;(to);
 762 
 763         if ((slotAddr &amp; 0xf0000000) != (toAddr &amp; 0xf0000000)) {
 764             // lui
 765             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((toAddr &gt;&gt; 16) &amp; 0xffff);
 766             ++insn;
 767             // ori
 768             *insn = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (toAddr &amp; 0xffff);
 769             ++insn;
 770             // jr
 771             *insn = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
 772             ++insn;
 773             ops = 4 * sizeof(MIPSWord);
 774         } else {
 775             // j
 776             *insn = 0x08000000 | ((toAddr &amp; 0x0fffffff) &gt;&gt; 2);
 777             ++insn;
 778             ops = 2 * sizeof(MIPSWord);
 779         }
 780         // nop
 781         *insn = 0x00000000;
 782         return ops;
 783     }
 784 
 785     void linkJump(AssemblerLabel from, AssemblerLabel to)
 786     {
 787         ASSERT(to.isSet());
 788         ASSERT(from.isSet());
 789         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(m_buffer.data()) + from.m_offset);
 790         MIPSWord* toPos = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(m_buffer.data()) + to.m_offset);
 791 
 792         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 2)) &amp;&amp; !(*(insn - 3)) &amp;&amp; !(*(insn - 5)));
 793         insn = insn - 6;
 794         linkWithOffset(insn, toPos);
 795     }
 796 
 797     static void linkJump(void* code, AssemblerLabel from, void* to)
 798     {
 799         ASSERT(from.isSet());
 800         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 801 
 802         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 2)) &amp;&amp; !(*(insn - 3)) &amp;&amp; !(*(insn - 5)));
 803         insn = insn - 6;
 804         linkWithOffset(insn, to);
 805     }
 806 
 807     static void linkCall(void* code, AssemblerLabel from, void* to)
 808     {
 809         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 810         linkCallInternal(insn, to);
 811     }
 812 
 813     static void linkPointer(void* code, AssemblerLabel from, void* to)
 814     {
 815         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 816         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 817         *insn = (*insn &amp; 0xffff0000) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
 818         insn++;
 819         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 820         *insn = (*insn &amp; 0xffff0000) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
 821     }
 822 
 823     static void relinkJump(void* from, void* to)
 824     {
 825         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 826 
 827         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 5)));
 828         insn = insn - 6;
 829         int flushSize = linkWithOffset(insn, to);
 830 
 831         cacheFlush(insn, flushSize);
 832     }
 833 
 834     static void relinkJumpToNop(void* from)
 835     {
 836         relinkJump(from, from);
 837     }
 838 
 839     static void relinkCall(void* from, void* to)
 840     {
 841         void* start;
 842         int size = linkCallInternal(from, to);
 843         if (size == sizeof(MIPSWord))
 844             start = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;(from) - 2 * sizeof(MIPSWord));
 845         else
 846             start = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;(from) - 4 * sizeof(MIPSWord));
 847 
 848         cacheFlush(start, size);
 849     }
 850 
 851     static void repatchInt32(void* from, int32_t to)
 852     {
 853         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 854         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 855         *insn = (*insn &amp; 0xffff0000) | ((to &gt;&gt; 16) &amp; 0xffff);
 856         insn++;
 857         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 858         *insn = (*insn &amp; 0xffff0000) | (to &amp; 0xffff);
 859         cacheFlush(from, 2 * sizeof(MIPSWord));
 860     }
 861 
 862     static int32_t readInt32(void* from)
 863     {
 864         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 865         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 866         int32_t result = (*insn &amp; 0x0000ffff) &lt;&lt; 16;
 867         insn++;
 868         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 869         result |= *insn &amp; 0x0000ffff;
 870         return result;
 871     }
 872 
 873     static void repatchCompact(void* where, int32_t value)
 874     {
 875         repatchInt32(where, value);
 876     }
 877 
 878     static void repatchPointer(void* from, void* to)
 879     {
 880         repatchInt32(from, reinterpret_cast&lt;int32_t&gt;(to));
 881     }
 882 
 883     static void* readPointer(void* from)
 884     {
 885         return reinterpret_cast&lt;void*&gt;(readInt32(from));
 886     }
 887 
 888     static void* readCallTarget(void* from)
 889     {
 890         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 891         insn -= 4;
 892         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 893         int32_t result = (*insn &amp; 0x0000ffff) &lt;&lt; 16;
 894         insn++;
 895         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 896         result |= *insn &amp; 0x0000ffff;
 897         return reinterpret_cast&lt;void*&gt;(result);
 898     }
 899 
 900     static void cacheFlush(void* code, size_t size)
 901     {
 902         intptr_t end = reinterpret_cast&lt;intptr_t&gt;(code) + size;
 903         __builtin___clear_cache(reinterpret_cast&lt;char*&gt;(code), reinterpret_cast&lt;char*&gt;(end));
 904     }
 905 
 906     static ptrdiff_t maxJumpReplacementSize()
 907     {
 908         return sizeof(MIPSWord) * 4;
 909     }
 910 
 911     static constexpr ptrdiff_t patchableJumpSize()
 912     {
 913         return sizeof(MIPSWord) * 8;
 914     }
 915 
 916     static void revertJumpToMove(void* instructionStart, RegisterID rt, int imm)
 917     {
 918         MIPSWord* insn = static_cast&lt;MIPSWord*&gt;(instructionStart);
 919         size_t codeSize = 2 * sizeof(MIPSWord);
 920 
 921         // lui
 922         *insn = 0x3c000000 | (rt &lt;&lt; OP_SH_RT) | ((imm &gt;&gt; 16) &amp; 0xffff);
 923         ++insn;
 924         // ori
 925         *insn = 0x34000000 | (rt &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff);
 926         ++insn;
 927         // if jr $t9
 928         if (*insn == 0x03200008) {
 929             *insn = 0x00000000;
 930             codeSize += sizeof(MIPSWord);
 931         }
 932         cacheFlush(instructionStart, codeSize);
 933     }
 934 
 935     static void replaceWithJump(void* instructionStart, void* to)
 936     {
 937         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(instructionStart) &amp; 3));
 938         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(to) &amp; 3));
 939         size_t ops = linkDirectJump(instructionStart, to);
 940         cacheFlush(instructionStart, ops);
 941     }
 942 
 943     static void replaceWithLoad(void* instructionStart)
 944     {
 945         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(instructionStart);
 946         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 947         insn++;
 948         ASSERT((*insn &amp; 0xfc0007ff) == 0x00000021); // addu
 949         insn++;
 950         *insn = 0x8c000000 | ((*insn) &amp; 0x3ffffff); // lw
 951         cacheFlush(insn, 4);
 952     }
 953 
 954     static void replaceWithAddressComputation(void* instructionStart)
 955     {
 956         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(instructionStart);
 957         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 958         insn++;
 959         ASSERT((*insn &amp; 0xfc0007ff) == 0x00000021); // addu
 960         insn++;
 961         *insn = 0x24000000 | ((*insn) &amp; 0x3ffffff); // addiu
 962         cacheFlush(insn, 4);
 963     }
 964 
 965     /* Update each jump in the buffer of newBase.  */
 966     void relocateJumps(void* oldBase, void* newBase)
 967     {
 968         // Check each jump
 969         for (Jumps::Iterator iter = m_jumps.begin(); iter != m_jumps.end(); ++iter) {
 970             int pos = iter-&gt;m_offset;
 971             MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(newBase) + pos);
 972             insn = insn + 2;
 973             // Need to make sure we have 5 valid instructions after pos
 974             if ((unsigned)pos &gt;= m_buffer.codeSize() - 5 * sizeof(MIPSWord))
 975                 continue;
 976 
 977             if ((*insn &amp; 0xfc000000) == 0x08000000) { // j
 978                 int offset = *insn &amp; 0x03ffffff;
 979                 int oldInsnAddress = (int)insn - (int)newBase + (int)oldBase;
 980                 int topFourBits = (oldInsnAddress + 4) &gt;&gt; 28;
 981                 int oldTargetAddress = (topFourBits &lt;&lt; 28) | (offset &lt;&lt; 2);
 982                 int newTargetAddress = oldTargetAddress - (int)oldBase + (int)newBase;
 983                 int newInsnAddress = (int)insn;
 984                 if (((newInsnAddress + 4) &gt;&gt; 28) == (newTargetAddress &gt;&gt; 28))
 985                     *insn = 0x08000000 | ((newTargetAddress &gt;&gt; 2) &amp; 0x3ffffff);
 986                 else {
 987                     /* lui */
 988                     *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
 989                     /* ori */
 990                     *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
 991                     /* jr */
 992                     *(insn + 2) = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
 993                 }
 994             } else if ((*insn &amp; 0xffe00000) == 0x3c000000) { // lui
 995                 int high = (*insn &amp; 0xffff) &lt;&lt; 16;
 996                 int low = *(insn + 1) &amp; 0xffff;
 997                 int oldTargetAddress = high | low;
 998                 int newTargetAddress = oldTargetAddress - (int)oldBase + (int)newBase;
 999                 /* lui */
1000                 *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
1001                 /* ori */
1002                 *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
1003             }
1004         }
1005     }
1006 
1007 private:
1008     static int linkWithOffset(MIPSWord* insn, void* to)
1009     {
1010         ASSERT((*insn &amp; 0xfc000000) == 0x10000000 // beq
1011             || (*insn &amp; 0xfc000000) == 0x14000000 // bne
1012             || (*insn &amp; 0xffff0000) == 0x45010000 // bc1t
1013             || (*insn &amp; 0xffff0000) == 0x45000000); // bc1f
1014         intptr_t diff = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(insn) - 4) &gt;&gt; 2;
1015 
1016         if (diff &lt; -32768 || diff &gt; 32767 || *(insn + 2) != 0x10000003) {
1017             /*
1018                 Convert the sequence:
1019                   beq $2, $3, target
1020                   nop
1021                   b 1f
1022                   nop
1023                   nop
1024                   nop
1025                 1:
1026 
1027                 to the new sequence if possible:
1028                   bne $2, $3, 1f
1029                   nop
1030                   j    target
1031                   nop
1032                   nop
1033                   nop
1034                 1:
1035 
1036                 OR to the new sequence:
1037                   bne $2, $3, 1f
1038                   nop
1039                   lui $25, target &gt;&gt; 16
1040                   ori $25, $25, target &amp; 0xffff
1041                   jr $25
1042                   nop
1043                 1:
1044 
1045                 Note: beq/bne/bc1t/bc1f are converted to bne/beq/bc1f/bc1t.
1046             */
1047 
1048             if (*(insn + 2) == 0x10000003) {
1049                 if ((*insn &amp; 0xfc000000) == 0x10000000) // beq
1050                     *insn = (*insn &amp; 0x03ff0000) | 0x14000005; // bne
1051                 else if ((*insn &amp; 0xfc000000) == 0x14000000) // bne
1052                     *insn = (*insn &amp; 0x03ff0000) | 0x10000005; // beq
1053                 else if ((*insn &amp; 0xffff0000) == 0x45010000) // bc1t
1054                     *insn = 0x45000005; // bc1f
1055                 else if ((*insn &amp; 0xffff0000) == 0x45000000) // bc1f
1056                     *insn = 0x45010005; // bc1t
1057                 else
1058                     ASSERT(0);
1059             }
1060 
1061             insn = insn + 2;
1062             if ((reinterpret_cast&lt;intptr_t&gt;(insn) + 4) &gt;&gt; 28
1063                 == reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 28) {
1064                 *insn = 0x08000000 | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 2) &amp; 0x3ffffff);
1065                 *(insn + 1) = 0;
1066                 return 4 * sizeof(MIPSWord);
1067             }
1068 
1069             intptr_t newTargetAddress = reinterpret_cast&lt;intptr_t&gt;(to);
1070             /* lui */
1071             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
1072             /* ori */
1073             *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
1074             /* jr */
1075             *(insn + 2) = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
1076             return 5 * sizeof(MIPSWord);
1077         }
1078 
1079         *insn = (*insn &amp; 0xffff0000) | (diff &amp; 0xffff);
1080         return sizeof(MIPSWord);
1081     }
1082 
1083     static int linkCallInternal(void* from, void* to)
1084     {
1085         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
1086         insn = insn - 4;
1087 
1088         if ((*(insn + 2) &amp; 0xfc000000) == 0x0c000000) { // jal
1089             if ((reinterpret_cast&lt;intptr_t&gt;(from) - 4) &gt;&gt; 28
1090                 == reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 28) {
1091                 *(insn + 2) = 0x0c000000 | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 2) &amp; 0x3ffffff);
1092                 return sizeof(MIPSWord);
1093             }
1094 
1095             /* lui $25, (to &gt;&gt; 16) &amp; 0xffff */
1096             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
1097             /* ori $25, $25, to &amp; 0xffff */
1098             *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
1099             /* jalr $25 */
1100             *(insn + 2) = 0x0000f809 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
1101             return 3 * sizeof(MIPSWord);
1102         }
1103 
1104         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
1105         ASSERT((*(insn + 1) &amp; 0xfc000000) == 0x34000000); // ori
1106 
1107         /* lui */
1108         *insn = (*insn &amp; 0xffff0000) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
1109         /* ori */
1110         *(insn + 1) = (*(insn + 1) &amp; 0xffff0000) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
1111         return 2 * sizeof(MIPSWord);
1112     }
1113 
1114     AssemblerBuffer m_buffer;
1115     Jumps m_jumps;
1116     int m_indexOfLastWatchpoint;
1117     int m_indexOfTailOfLastWatchpoint;
1118 };
1119 
1120 } // namespace JSC
1121 
1122 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
    </pre>
  </body>
</html>