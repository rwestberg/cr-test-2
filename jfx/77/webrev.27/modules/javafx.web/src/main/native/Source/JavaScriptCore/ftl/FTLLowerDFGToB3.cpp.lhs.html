<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
    3  *
    4  * Redistribution and use in source and binary forms, with or without
    5  * modification, are permitted provided that the following conditions
    6  * are met:
    7  * 1. Redistributions of source code must retain the above copyright
    8  *    notice, this list of conditions and the following disclaimer.
    9  * 2. Redistributions in binary form must reproduce the above copyright
   10  *    notice, this list of conditions and the following disclaimer in the
   11  *    documentation and/or other materials provided with the distribution.
   12  *
   13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
   14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;FTLLowerDFGToB3.h&quot;
   28 
   29 #if ENABLE(FTL_JIT)
   30 
   31 #include &quot;AirCode.h&quot;
   32 #include &quot;AirGenerationContext.h&quot;
   33 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
   34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
   35 #include &quot;AtomicsObject.h&quot;
   36 #include &quot;B3CheckValue.h&quot;
   37 #include &quot;B3FenceValue.h&quot;
   38 #include &quot;B3PatchpointValue.h&quot;
   39 #include &quot;B3SlotBaseValue.h&quot;
   40 #include &quot;B3StackmapGenerationParams.h&quot;
   41 #include &quot;B3ValueInlines.h&quot;
   42 #include &quot;CallFrameShuffler.h&quot;
   43 #include &quot;CodeBlockWithJITType.h&quot;
   44 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   45 #include &quot;DFGCapabilities.h&quot;
   46 #include &quot;DFGDoesGC.h&quot;
   47 #include &quot;DFGDominators.h&quot;
   48 #include &quot;DFGInPlaceAbstractState.h&quot;
<a name="1" id="anc1"></a>
   49 #include &quot;DFGMayExit.h&quot;
   50 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
   51 #include &quot;DFGOSRExitFuzz.h&quot;
   52 #include &quot;DirectArguments.h&quot;
   53 #include &quot;FTLAbstractHeapRepository.h&quot;
   54 #include &quot;FTLAvailableRecovery.h&quot;
   55 #include &quot;FTLExceptionTarget.h&quot;
   56 #include &quot;FTLForOSREntryJITCode.h&quot;
   57 #include &quot;FTLFormattedValue.h&quot;
   58 #include &quot;FTLLazySlowPathCall.h&quot;
   59 #include &quot;FTLLoweredNodeValue.h&quot;
   60 #include &quot;FTLOperations.h&quot;
   61 #include &quot;FTLOutput.h&quot;
   62 #include &quot;FTLPatchpointExceptionHandle.h&quot;
   63 #include &quot;FTLSnippetParams.h&quot;
   64 #include &quot;FTLThunks.h&quot;
   65 #include &quot;FTLWeightedTarget.h&quot;
   66 #include &quot;JITAddGenerator.h&quot;
   67 #include &quot;JITBitAndGenerator.h&quot;
   68 #include &quot;JITBitOrGenerator.h&quot;
   69 #include &quot;JITBitXorGenerator.h&quot;
   70 #include &quot;JITDivGenerator.h&quot;
   71 #include &quot;JITInlineCacheGenerator.h&quot;
   72 #include &quot;JITLeftShiftGenerator.h&quot;
   73 #include &quot;JITMathIC.h&quot;
   74 #include &quot;JITMulGenerator.h&quot;
   75 #include &quot;JITRightShiftGenerator.h&quot;
   76 #include &quot;JITSubGenerator.h&quot;
   77 #include &quot;JSAsyncFunction.h&quot;
   78 #include &quot;JSAsyncGeneratorFunction.h&quot;
   79 #include &quot;JSCInlines.h&quot;
   80 #include &quot;JSGeneratorFunction.h&quot;
   81 #include &quot;JSImmutableButterfly.h&quot;
   82 #include &quot;JSLexicalEnvironment.h&quot;
   83 #include &quot;JSMap.h&quot;
   84 #include &quot;OperandsInlines.h&quot;
<a name="2" id="anc2"></a>
   85 #include &quot;RegExpObject.h&quot;
   86 #include &quot;ScopedArguments.h&quot;
   87 #include &quot;ScopedArgumentsTable.h&quot;
   88 #include &quot;ScratchRegisterAllocator.h&quot;
   89 #include &quot;SetupVarargsFrame.h&quot;
   90 #include &quot;ShadowChicken.h&quot;
   91 #include &quot;StructureStubInfo.h&quot;
   92 #include &quot;SuperSampler.h&quot;
   93 #include &quot;ThunkGenerators.h&quot;
   94 #include &quot;VirtualRegister.h&quot;
   95 #include &quot;Watchdog.h&quot;
   96 #include &lt;atomic&gt;
   97 #include &lt;wtf/Box.h&gt;
   98 #include &lt;wtf/Gigacage.h&gt;
   99 #include &lt;wtf/RecursableLambda.h&gt;
  100 #include &lt;wtf/StdUnorderedSet.h&gt;
  101 
  102 #undef RELEASE_ASSERT
  103 #define RELEASE_ASSERT(assertion) do { \
  104     if (!(assertion)) { \
  105         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
  106         CRASH(); \
  107     } \
  108 } while (0)
  109 
  110 namespace JSC { namespace FTL {
  111 
  112 using namespace B3;
  113 using namespace DFG;
  114 
  115 namespace {
  116 
  117 std::atomic&lt;int&gt; compileCounter;
  118 
  119 #if !ASSERT_DISABLED
  120 NO_RETURN_DUE_TO_CRASH static void ftlUnreachable(
  121     CodeBlock* codeBlock, BlockIndex blockIndex, unsigned nodeIndex)
  122 {
  123     dataLog(&quot;Crashing in thought-to-be-unreachable FTL-generated code for &quot;, pointerDump(codeBlock), &quot; at basic block #&quot;, blockIndex);
  124     if (nodeIndex != UINT_MAX)
  125         dataLog(&quot;, node @&quot;, nodeIndex);
  126     dataLog(&quot;.\n&quot;);
  127     CRASH();
  128 }
  129 #endif
  130 
  131 // Using this instead of typeCheck() helps to reduce the load on B3, by creating
  132 // significantly less dead code.
  133 #define FTL_TYPE_CHECK_WITH_EXIT_KIND(exitKind, lowValue, highValue, typesPassedThrough, failCondition) do { \
  134         FormattedValue _ftc_lowValue = (lowValue);                      \
  135         Edge _ftc_highValue = (highValue);                              \
  136         SpeculatedType _ftc_typesPassedThrough = (typesPassedThrough);  \
  137         if (!m_interpreter.needsTypeCheck(_ftc_highValue, _ftc_typesPassedThrough)) \
  138             break;                                                      \
  139         typeCheck(_ftc_lowValue, _ftc_highValue, _ftc_typesPassedThrough, (failCondition), exitKind); \
  140     } while (false)
  141 
  142 #define FTL_TYPE_CHECK(lowValue, highValue, typesPassedThrough, failCondition) \
  143     FTL_TYPE_CHECK_WITH_EXIT_KIND(BadType, lowValue, highValue, typesPassedThrough, failCondition)
  144 
  145 class LowerDFGToB3 {
  146     WTF_MAKE_NONCOPYABLE(LowerDFGToB3);
  147 public:
  148     LowerDFGToB3(State&amp; state)
  149         : m_graph(state.graph)
  150         , m_ftlState(state)
  151         , m_out(state)
  152         , m_proc(*state.proc)
  153         , m_availabilityCalculator(m_graph)
  154         , m_state(state.graph)
  155         , m_interpreter(state.graph, m_state)
  156         , m_indexMaskingMode(Options::enableSpectreMitigations() ?  IndexMaskingEnabled : IndexMaskingDisabled)
  157     {
<a name="3" id="anc3"></a>






















  158     }
  159 
  160     void lower()
  161     {
  162         State* state = &amp;m_ftlState;
  163 
  164         CString name;
  165         if (verboseCompilationEnabled()) {
  166             name = toCString(
  167                 &quot;jsBody_&quot;, ++compileCounter, &quot;_&quot;, codeBlock()-&gt;inferredName(),
  168                 &quot;_&quot;, codeBlock()-&gt;hash());
  169         } else
  170             name = &quot;jsBody&quot;;
  171 
  172         {
  173             m_proc.setNumEntrypoints(m_graph.m_numberOfEntrypoints);
  174             CodeBlock* codeBlock = m_graph.m_codeBlock;
  175 
  176             Ref&lt;B3::Air::PrologueGenerator&gt; catchPrologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;(
  177                 [codeBlock] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
  178                     AllowMacroScratchRegisterUsage allowScratch(jit);
  179                     jit.addPtr(CCallHelpers::TrustedImm32(-code.frameSize()), GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
  180                     if (Options::zeroStackFrame())
  181                         jit.clearStackFrame(GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister, GPRInfo::regT0, code.frameSize());
  182 
  183                     jit.emitSave(code.calleeSaveRegisterAtOffsetList());
  184                     jit.emitPutToCallFrameHeader(codeBlock, CallFrameSlot::codeBlock);
  185                 });
  186 
  187             for (unsigned catchEntrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys()) {
  188                 RELEASE_ASSERT(catchEntrypointIndex != 0);
  189                 m_proc.code().setPrologueForEntrypoint(catchEntrypointIndex, catchPrologueGenerator.copyRef());
  190             }
  191 
  192             if (m_graph.m_maxLocalsForCatchOSREntry) {
  193                 uint32_t numberOfLiveLocals = std::max(*m_graph.m_maxLocalsForCatchOSREntry, 1u); // Make sure we always allocate a non-null catchOSREntryBuffer.
  194                 m_ftlState.jitCode-&gt;common.catchOSREntryBuffer = m_graph.m_vm.scratchBufferForSize(sizeof(JSValue) * numberOfLiveLocals);
  195             }
  196         }
  197 
  198         m_graph.ensureSSADominators();
  199 
  200         if (verboseCompilationEnabled())
  201             dataLog(&quot;Function ready, beginning lowering.\n&quot;);
  202 
  203         m_out.initialize(m_heaps);
  204 
  205         // We use prologue frequency for all of the initialization code.
  206         m_out.setFrequency(1);
  207 
  208         bool hasMultipleEntrypoints = m_graph.m_numberOfEntrypoints &gt; 1;
  209 
  210         LBasicBlock prologue = m_out.newBlock();
  211         LBasicBlock callEntrypointArgumentSpeculations = hasMultipleEntrypoints ? m_out.newBlock() : nullptr;
  212         m_handleExceptions = m_out.newBlock();
  213 
  214         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
  215             m_highBlock = m_graph.block(blockIndex);
  216             if (!m_highBlock)
  217                 continue;
  218             m_out.setFrequency(m_highBlock-&gt;executionCount);
  219             m_blocks.add(m_highBlock, m_out.newBlock());
  220         }
  221 
  222         // Back to prologue frequency for any bocks that get sneakily created in the initialization code.
  223         m_out.setFrequency(1);
  224 
  225         m_out.appendTo(prologue, hasMultipleEntrypoints ? callEntrypointArgumentSpeculations : m_handleExceptions);
  226         m_out.initializeConstants(m_proc, prologue);
  227         createPhiVariables();
  228 
  229         size_t sizeOfCaptured = sizeof(JSValue) * m_graph.m_nextMachineLocal;
  230         B3::SlotBaseValue* capturedBase = m_out.lockedStackSlot(sizeOfCaptured);
  231         m_captured = m_out.add(capturedBase, m_out.constIntPtr(sizeOfCaptured));
  232         state-&gt;capturedValue = capturedBase-&gt;slot();
  233 
  234         auto preOrder = m_graph.blocksInPreOrder();
  235 
  236         m_callFrame = m_out.framePointer();
  237         m_tagTypeNumber = m_out.constInt64(TagTypeNumber);
  238         m_tagMask = m_out.constInt64(TagMask);
  239 
  240         // Make sure that B3 knows that we really care about the mask registers. This forces the
  241         // constants to be materialized in registers.
  242         m_proc.addFastConstant(m_tagTypeNumber-&gt;key());
  243         m_proc.addFastConstant(m_tagMask-&gt;key());
  244 
  245         // We don&#39;t want the CodeBlock to have a weak pointer to itself because
  246         // that would cause it to always get collected.
  247         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), addressFor(CallFrameSlot::codeBlock));
  248 
  249         VM* vm = &amp;this-&gt;vm();
  250 
  251         // Stack Overflow Check.
  252         unsigned exitFrameSize = m_graph.requiredRegisterCountForExit() * sizeof(Register);
  253         MacroAssembler::AbsoluteAddress addressOfStackLimit(vm-&gt;addressOfSoftStackLimit());
  254         PatchpointValue* stackOverflowHandler = m_out.patchpoint(Void);
  255         CallSiteIndex callSiteIndex = callSiteIndexForCodeOrigin(m_ftlState, CodeOrigin(0));
  256         stackOverflowHandler-&gt;appendSomeRegister(m_callFrame);
  257         stackOverflowHandler-&gt;clobber(RegisterSet::macroScratchRegisters());
  258         stackOverflowHandler-&gt;numGPScratchRegisters = 1;
  259         stackOverflowHandler-&gt;setGenerator(
  260             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
  261                 AllowMacroScratchRegisterUsage allowScratch(jit);
  262                 GPRReg fp = params[0].gpr();
  263                 GPRReg scratch = params.gpScratch(0);
  264 
  265                 unsigned ftlFrameSize = params.proc().frameSize();
  266                 unsigned maxFrameSize = std::max(exitFrameSize, ftlFrameSize);
  267 
  268                 jit.addPtr(MacroAssembler::TrustedImm32(-maxFrameSize), fp, scratch);
  269                 MacroAssembler::JumpList stackOverflow;
  270                 if (UNLIKELY(maxFrameSize &gt; Options::reservedZoneSize()))
  271                     stackOverflow.append(jit.branchPtr(MacroAssembler::Above, scratch, fp));
  272                 stackOverflow.append(jit.branchPtr(MacroAssembler::Above, addressOfStackLimit, scratch));
  273 
  274                 params.addLatePath([=] (CCallHelpers&amp; jit) {
  275                     AllowMacroScratchRegisterUsage allowScratch(jit);
  276 
  277                     stackOverflow.link(&amp;jit);
  278 
  279                     // FIXME: We would not have to do this if the stack check was part of the Air
  280                     // prologue. Then, we would know that there is no way for the callee-saves to
  281                     // get clobbered.
  282                     // https://bugs.webkit.org/show_bug.cgi?id=172456
  283                     jit.emitRestore(params.proc().calleeSaveRegisterAtOffsetList());
  284 
  285                     jit.store32(
  286                         MacroAssembler::TrustedImm32(callSiteIndex.bits()),
  287                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
  288                     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
  289 
  290                     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
  291                     jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()), GPRInfo::argumentGPR1);
  292                     CCallHelpers::Call throwCall = jit.call(OperationPtrTag);
  293 
  294                     jit.move(CCallHelpers::TrustedImmPtr(vm), GPRInfo::argumentGPR0);
  295                     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);
  296                     CCallHelpers::Call lookupExceptionHandlerCall = jit.call(OperationPtrTag);
  297                     jit.jumpToExceptionHandler(*vm);
  298 
  299                     jit.addLinkTask(
  300                         [=] (LinkBuffer&amp; linkBuffer) {
  301                             linkBuffer.link(throwCall, FunctionPtr&lt;OperationPtrTag&gt;(operationThrowStackOverflowError));
  302                             linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandlerFromCallerFrame));
  303                     });
  304                 });
  305             });
  306 
  307         LBasicBlock firstDFGBasicBlock = lowBlock(m_graph.block(0));
  308 
  309         {
  310             if (hasMultipleEntrypoints) {
  311                 Vector&lt;LBasicBlock&gt; successors(m_graph.m_numberOfEntrypoints);
  312                 successors[0] = callEntrypointArgumentSpeculations;
  313                 for (unsigned i = 1; i &lt; m_graph.m_numberOfEntrypoints; ++i) {
  314                     // Currently, the only other entrypoint is an op_catch entrypoint.
  315                     // We do OSR entry at op_catch, and we prove argument formats before
  316                     // jumping to FTL code, so we don&#39;t need to check argument types here
  317                     // for these entrypoints.
  318                     successors[i] = firstDFGBasicBlock;
  319                 }
  320 
  321                 m_out.entrySwitch(successors);
  322                 m_out.appendTo(callEntrypointArgumentSpeculations, m_handleExceptions);
  323             }
  324 
  325             m_node = nullptr;
  326             m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);
  327 
  328             // Check Arguments.
  329             availabilityMap().clear();
  330             availabilityMap().m_locals = Operands&lt;Availability&gt;(codeBlock()-&gt;numParameters(), 0);
  331             for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
  332                 availabilityMap().m_locals.argument(i) =
  333                     Availability(FlushedAt(FlushedJSValue, virtualRegisterForArgument(i)));
  334             }
  335 
  336             for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
  337                 MethodOfGettingAValueProfile profile(&amp;m_graph.m_profiledBlock-&gt;valueProfileForArgument(i));
  338                 VirtualRegister operand = virtualRegisterForArgument(i);
  339                 LValue jsValue = m_out.load64(addressFor(operand));
  340 
  341                 switch (m_graph.m_argumentFormats[0][i]) {
  342                 case FlushedInt32:
  343                     speculate(BadType, jsValueValue(jsValue), profile, isNotInt32(jsValue));
  344                     break;
  345                 case FlushedBoolean:
  346                     speculate(BadType, jsValueValue(jsValue), profile, isNotBoolean(jsValue));
  347                     break;
  348                 case FlushedCell:
  349                     speculate(BadType, jsValueValue(jsValue), profile, isNotCell(jsValue));
  350                     break;
  351                 case FlushedJSValue:
  352                     break;
  353                 default:
  354                     DFG_CRASH(m_graph, nullptr, &quot;Bad flush format for argument&quot;);
  355                     break;
  356                 }
  357             }
  358             m_out.jump(firstDFGBasicBlock);
  359         }
  360 
  361 
  362         m_out.appendTo(m_handleExceptions, firstDFGBasicBlock);
  363         Box&lt;CCallHelpers::Label&gt; exceptionHandler = state-&gt;exceptionHandler;
  364         m_out.patchpoint(Void)-&gt;setGenerator(
  365             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
  366                 CCallHelpers::Jump jump = jit.jump();
  367                 jit.addLinkTask(
  368                     [=] (LinkBuffer&amp; linkBuffer) {
  369                         linkBuffer.link(jump, linkBuffer.locationOf&lt;ExceptionHandlerPtrTag&gt;(*exceptionHandler));
  370                     });
  371             });
  372         m_out.unreachable();
  373 
  374         for (DFG::BasicBlock* block : preOrder)
  375             compileBlock(block);
  376 
  377         // Make sure everything is decorated. This does a bunch of deferred decorating. This has
  378         // to happen last because our abstract heaps are generated lazily. They have to be
  379         // generated lazily because we have an infinite number of numbered, indexed, and
  380         // absolute heaps. We only become aware of the ones we actually mention while lowering.
  381         m_heaps.computeRangesAndDecorateInstructions();
  382 
  383         // We create all Phi&#39;s up front, but we may then decide not to compile the basic block
  384         // that would have contained one of them. So this creates orphans, which triggers B3
  385         // validation failures. Calling this fixes the issue.
  386         //
  387         // Note that you should avoid the temptation to make this call conditional upon
  388         // validation being enabled. B3 makes no guarantees of any kind of correctness when
  389         // dealing with IR that would have failed validation. For example, it would be valid to
  390         // write a B3 phase that so aggressively assumes the lack of orphans that it would crash
  391         // if any orphans were around. We might even have such phases already.
  392         m_proc.deleteOrphans();
  393 
  394         // We put the blocks into the B3 procedure in a super weird order. Now we reorder them.
  395         m_out.applyBlockOrder();
  396     }
  397 
  398 private:
  399 
  400     void createPhiVariables()
  401     {
  402         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  403             DFG::BasicBlock* block = m_graph.block(blockIndex);
  404             if (!block)
  405                 continue;
  406             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
  407                 Node* node = block-&gt;at(nodeIndex);
  408                 if (node-&gt;op() != DFG::Phi)
  409                     continue;
  410                 LType type;
  411                 switch (node-&gt;flags() &amp; NodeResultMask) {
  412                 case NodeResultDouble:
  413                     type = Double;
  414                     break;
  415                 case NodeResultInt32:
  416                     type = Int32;
  417                     break;
  418                 case NodeResultInt52:
  419                     type = Int64;
  420                     break;
  421                 case NodeResultBoolean:
  422                     type = Int32;
  423                     break;
  424                 case NodeResultJS:
  425                     type = Int64;
  426                     break;
  427                 default:
  428                     DFG_CRASH(m_graph, node, &quot;Bad Phi node result type&quot;);
  429                     break;
  430                 }
  431                 m_phis.add(node, m_proc.add&lt;Value&gt;(B3::Phi, type, Origin(node)));
  432             }
  433         }
  434     }
  435 
  436     void compileBlock(DFG::BasicBlock* block)
  437     {
  438         if (!block)
  439             return;
  440 
  441         if (verboseCompilationEnabled())
  442             dataLog(&quot;Compiling block &quot;, *block, &quot;\n&quot;);
  443 
  444         m_highBlock = block;
  445 
  446         // Make sure that any blocks created while lowering code in the high block have the frequency of
  447         // the high block. This is appropriate because B3 doesn&#39;t need precise frequencies. It just needs
  448         // something roughly approximate for things like register allocation.
  449         m_out.setFrequency(m_highBlock-&gt;executionCount);
  450 
  451         LBasicBlock lowBlock = m_blocks.get(m_highBlock);
  452 
  453         m_nextHighBlock = 0;
  454         for (BlockIndex nextBlockIndex = m_highBlock-&gt;index + 1; nextBlockIndex &lt; m_graph.numBlocks(); ++nextBlockIndex) {
  455             m_nextHighBlock = m_graph.block(nextBlockIndex);
  456             if (m_nextHighBlock)
  457                 break;
  458         }
  459         m_nextLowBlock = m_nextHighBlock ? m_blocks.get(m_nextHighBlock) : 0;
  460 
  461         // All of this effort to find the next block gives us the ability to keep the
  462         // generated IR in roughly program order. This ought not affect the performance
  463         // of the generated code (since we expect B3 to reorder things) but it will
  464         // make IR dumps easier to read.
  465         m_out.appendTo(lowBlock, m_nextLowBlock);
  466 
  467         if (Options::ftlCrashes())
  468             m_out.trap();
  469 
  470         if (!m_highBlock-&gt;cfaHasVisited) {
  471             if (verboseCompilationEnabled())
  472                 dataLog(&quot;Bailing because CFA didn&#39;t reach.\n&quot;);
  473             crash(m_highBlock, nullptr);
  474             return;
  475         }
  476 
<a name="4" id="anc4"></a>

  477         m_availabilityCalculator.beginBlock(m_highBlock);
  478 
  479         m_state.reset();
  480         m_state.beginBasicBlock(m_highBlock);
  481 
  482         for (m_nodeIndex = 0; m_nodeIndex &lt; m_highBlock-&gt;size(); ++m_nodeIndex) {
  483             if (!compileNode(m_nodeIndex))
  484                 break;
  485         }
  486     }
  487 
  488     void safelyInvalidateAfterTermination()
  489     {
  490         if (verboseCompilationEnabled())
  491             dataLog(&quot;Bailing.\n&quot;);
  492         crash();
  493 
  494         // Invalidate dominated blocks. Under normal circumstances we would expect
  495         // them to be invalidated already. But you can have the CFA become more
  496         // precise over time because the structures of objects change on the main
  497         // thread. Failing to do this would result in weird crashes due to a value
  498         // being used but not defined. Race conditions FTW!
  499         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  500             DFG::BasicBlock* target = m_graph.block(blockIndex);
  501             if (!target)
  502                 continue;
  503             if (m_graph.m_ssaDominators-&gt;dominates(m_highBlock, target)) {
  504                 if (verboseCompilationEnabled())
  505                     dataLog(&quot;Block &quot;, *target, &quot; will bail also.\n&quot;);
  506                 target-&gt;cfaHasVisited = false;
  507             }
  508         }
  509     }
  510 
<a name="5" id="anc5"></a>






























































































































  511     bool compileNode(unsigned nodeIndex)
  512     {
  513         if (!m_state.isValid()) {
  514             safelyInvalidateAfterTermination();
  515             return false;
  516         }
  517 
  518         m_node = m_highBlock-&gt;at(nodeIndex);
  519         m_origin = m_node-&gt;origin;
  520         m_out.setOrigin(m_node);
  521 
  522         if (verboseCompilationEnabled())
  523             dataLog(&quot;Lowering &quot;, m_node, &quot;\n&quot;);
  524 
<a name="6" id="anc6"></a><span class="line-removed">  525         m_availableRecoveries.shrink(0);</span>
<span class="line-removed">  526 </span>
  527         m_interpreter.startExecuting();
  528         m_interpreter.executeKnownEdgeTypes(m_node);
  529 
<a name="7" id="anc7"></a>


  530         if (validateDFGDoesGC) {
  531             bool expectDoesGC = doesGC(m_graph, m_node);
  532             m_out.store(m_out.constBool(expectDoesGC), m_out.absolute(vm().heap.addressOfExpectDoesGC()));
  533         }
  534 
  535         switch (m_node-&gt;op()) {
  536         case DFG::Upsilon:
  537             compileUpsilon();
  538             break;
  539         case DFG::Phi:
  540             compilePhi();
  541             break;
  542         case JSConstant:
  543             break;
  544         case DoubleConstant:
  545             compileDoubleConstant();
  546             break;
  547         case Int52Constant:
  548             compileInt52Constant();
  549             break;
  550         case LazyJSConstant:
  551             compileLazyJSConstant();
  552             break;
  553         case DoubleRep:
  554             compileDoubleRep();
  555             break;
  556         case DoubleAsInt32:
  557             compileDoubleAsInt32();
  558             break;
  559         case DFG::ValueRep:
  560             compileValueRep();
  561             break;
  562         case Int52Rep:
  563             compileInt52Rep();
  564             break;
  565         case ValueToInt32:
  566             compileValueToInt32();
  567             break;
  568         case BooleanToNumber:
  569             compileBooleanToNumber();
  570             break;
  571         case ExtractOSREntryLocal:
  572             compileExtractOSREntryLocal();
  573             break;
  574         case ExtractCatchLocal:
  575             compileExtractCatchLocal();
  576             break;
  577         case ClearCatchLocals:
  578             compileClearCatchLocals();
  579             break;
  580         case GetStack:
  581             compileGetStack();
  582             break;
  583         case PutStack:
  584             compilePutStack();
  585             break;
  586         case DFG::Check:
  587         case CheckVarargs:
  588             compileNoOp();
  589             break;
  590         case ToObject:
  591         case CallObjectConstructor:
  592             compileToObjectOrCallObjectConstructor();
  593             break;
  594         case ToThis:
  595             compileToThis();
  596             break;
  597         case ValueNegate:
  598             compileValueNegate();
  599             break;
  600         case ValueAdd:
  601             compileValueAdd();
  602             break;
  603         case ValueSub:
  604             compileValueSub();
  605             break;
  606         case ValueMul:
  607             compileValueMul();
  608             break;
  609         case StrCat:
  610             compileStrCat();
  611             break;
  612         case ArithAdd:
  613         case ArithSub:
  614             compileArithAddOrSub();
  615             break;
  616         case ArithClz32:
  617             compileArithClz32();
  618             break;
  619         case ArithMul:
  620             compileArithMul();
  621             break;
  622         case ValueDiv:
  623             compileValueDiv();
  624             break;
  625         case ArithDiv:
  626             compileArithDiv();
  627             break;
<a name="8" id="anc8"></a>


  628         case ArithMod:
  629             compileArithMod();
  630             break;
  631         case ArithMin:
  632         case ArithMax:
  633             compileArithMinOrMax();
  634             break;
  635         case ArithAbs:
  636             compileArithAbs();
  637             break;
<a name="9" id="anc9"></a>


  638         case ArithPow:
  639             compileArithPow();
  640             break;
  641         case ArithRandom:
  642             compileArithRandom();
  643             break;
  644         case ArithRound:
  645             compileArithRound();
  646             break;
  647         case ArithFloor:
  648             compileArithFloor();
  649             break;
  650         case ArithCeil:
  651             compileArithCeil();
  652             break;
  653         case ArithTrunc:
  654             compileArithTrunc();
  655             break;
  656         case ArithSqrt:
  657             compileArithSqrt();
  658             break;
  659         case ArithFRound:
  660             compileArithFRound();
  661             break;
  662         case ArithNegate:
  663             compileArithNegate();
  664             break;
  665         case ArithUnary:
  666             compileArithUnary();
  667             break;
<a name="10" id="anc10"></a>


  668         case ArithBitNot:
  669             compileArithBitNot();
  670             break;
  671         case ValueBitAnd:
  672             compileValueBitAnd();
  673             break;
  674         case ArithBitAnd:
  675             compileArithBitAnd();
  676             break;
  677         case ValueBitOr:
  678             compileValueBitOr();
  679             break;
  680         case ArithBitOr:
  681             compileArithBitOr();
  682             break;
  683         case ArithBitXor:
  684             compileArithBitXor();
  685             break;
  686         case ValueBitXor:
  687             compileValueBitXor();
  688             break;
  689         case BitRShift:
  690             compileBitRShift();
  691             break;
<a name="11" id="anc11"></a><span class="line-modified">  692         case BitLShift:</span>
<span class="line-modified">  693             compileBitLShift();</span>



  694             break;
  695         case BitURShift:
  696             compileBitURShift();
  697             break;
  698         case UInt32ToNumber:
  699             compileUInt32ToNumber();
  700             break;
  701         case CheckStructure:
  702             compileCheckStructure();
  703             break;
  704         case CheckStructureOrEmpty:
  705             compileCheckStructureOrEmpty();
  706             break;
  707         case CheckCell:
  708             compileCheckCell();
  709             break;
  710         case CheckNotEmpty:
  711             compileCheckNotEmpty();
  712             break;
  713         case AssertNotEmpty:
  714             compileAssertNotEmpty();
  715             break;
  716         case CheckBadCell:
  717             compileCheckBadCell();
  718             break;
  719         case CheckStringIdent:
  720             compileCheckStringIdent();
  721             break;
  722         case GetExecutable:
  723             compileGetExecutable();
  724             break;
  725         case Arrayify:
  726         case ArrayifyToStructure:
  727             compileArrayify();
  728             break;
  729         case PutStructure:
  730             compilePutStructure();
  731             break;
  732         case TryGetById:
  733             compileGetById(AccessType::TryGet);
  734             break;
  735         case GetById:
  736         case GetByIdFlush:
  737             compileGetById(AccessType::Get);
  738             break;
  739         case GetByIdWithThis:
  740             compileGetByIdWithThis();
  741             break;
  742         case GetByIdDirect:
  743         case GetByIdDirectFlush:
  744             compileGetById(AccessType::GetDirect);
  745             break;
  746         case InById:
  747             compileInById();
  748             break;
  749         case InByVal:
  750             compileInByVal();
  751             break;
  752         case HasOwnProperty:
  753             compileHasOwnProperty();
  754             break;
  755         case PutById:
  756         case PutByIdDirect:
  757         case PutByIdFlush:
  758             compilePutById();
  759             break;
  760         case PutByIdWithThis:
  761             compilePutByIdWithThis();
  762             break;
  763         case PutGetterById:
  764         case PutSetterById:
  765             compilePutAccessorById();
  766             break;
  767         case PutGetterSetterById:
  768             compilePutGetterSetterById();
  769             break;
  770         case PutGetterByVal:
  771         case PutSetterByVal:
  772             compilePutAccessorByVal();
  773             break;
  774         case DeleteById:
  775             compileDeleteById();
  776             break;
  777         case DeleteByVal:
  778             compileDeleteByVal();
  779             break;
  780         case GetButterfly:
  781             compileGetButterfly();
  782             break;
  783         case ConstantStoragePointer:
  784             compileConstantStoragePointer();
  785             break;
  786         case GetIndexedPropertyStorage:
  787             compileGetIndexedPropertyStorage();
  788             break;
  789         case CheckArray:
  790             compileCheckArray();
  791             break;
  792         case GetArrayLength:
  793             compileGetArrayLength();
  794             break;
  795         case GetVectorLength:
  796             compileGetVectorLength();
  797             break;
  798         case CheckInBounds:
  799             compileCheckInBounds();
  800             break;
  801         case GetByVal:
  802             compileGetByVal();
  803             break;
  804         case GetMyArgumentByVal:
  805         case GetMyArgumentByValOutOfBounds:
  806             compileGetMyArgumentByVal();
  807             break;
  808         case GetByValWithThis:
  809             compileGetByValWithThis();
  810             break;
  811         case PutByVal:
  812         case PutByValAlias:
  813         case PutByValDirect:
  814             compilePutByVal();
  815             break;
  816         case PutByValWithThis:
  817             compilePutByValWithThis();
  818             break;
  819         case AtomicsAdd:
  820         case AtomicsAnd:
  821         case AtomicsCompareExchange:
  822         case AtomicsExchange:
  823         case AtomicsLoad:
  824         case AtomicsOr:
  825         case AtomicsStore:
  826         case AtomicsSub:
  827         case AtomicsXor:
  828             compileAtomicsReadModifyWrite();
  829             break;
  830         case AtomicsIsLockFree:
  831             compileAtomicsIsLockFree();
  832             break;
  833         case DefineDataProperty:
  834             compileDefineDataProperty();
  835             break;
  836         case DefineAccessorProperty:
  837             compileDefineAccessorProperty();
  838             break;
  839         case ArrayPush:
  840             compileArrayPush();
  841             break;
  842         case ArrayPop:
  843             compileArrayPop();
  844             break;
  845         case ArraySlice:
  846             compileArraySlice();
  847             break;
  848         case ArrayIndexOf:
  849             compileArrayIndexOf();
  850             break;
  851         case CreateActivation:
  852             compileCreateActivation();
  853             break;
  854         case PushWithScope:
  855             compilePushWithScope();
  856             break;
  857         case NewFunction:
  858         case NewGeneratorFunction:
  859         case NewAsyncGeneratorFunction:
  860         case NewAsyncFunction:
  861             compileNewFunction();
  862             break;
  863         case CreateDirectArguments:
  864             compileCreateDirectArguments();
  865             break;
  866         case CreateScopedArguments:
  867             compileCreateScopedArguments();
  868             break;
  869         case CreateClonedArguments:
  870             compileCreateClonedArguments();
  871             break;
  872         case ObjectCreate:
  873             compileObjectCreate();
  874             break;
  875         case ObjectKeys:
  876             compileObjectKeys();
  877             break;
  878         case NewObject:
  879             compileNewObject();
  880             break;
  881         case NewStringObject:
  882             compileNewStringObject();
  883             break;
  884         case NewSymbol:
  885             compileNewSymbol();
  886             break;
  887         case NewArray:
  888             compileNewArray();
  889             break;
  890         case NewArrayWithSpread:
  891             compileNewArrayWithSpread();
  892             break;
  893         case CreateThis:
  894             compileCreateThis();
  895             break;
  896         case Spread:
  897             compileSpread();
  898             break;
  899         case NewArrayBuffer:
  900             compileNewArrayBuffer();
  901             break;
  902         case NewArrayWithSize:
  903             compileNewArrayWithSize();
  904             break;
  905         case NewTypedArray:
  906             compileNewTypedArray();
  907             break;
  908         case GetTypedArrayByteOffset:
  909             compileGetTypedArrayByteOffset();
  910             break;
  911         case GetPrototypeOf:
  912             compileGetPrototypeOf();
  913             break;
  914         case AllocatePropertyStorage:
  915             compileAllocatePropertyStorage();
  916             break;
  917         case ReallocatePropertyStorage:
  918             compileReallocatePropertyStorage();
  919             break;
  920         case NukeStructureAndSetButterfly:
  921             compileNukeStructureAndSetButterfly();
  922             break;
  923         case ToNumber:
  924             compileToNumber();
  925             break;
  926         case ToString:
  927         case CallStringConstructor:
  928         case StringValueOf:
  929             compileToStringOrCallStringConstructorOrStringValueOf();
  930             break;
  931         case ToPrimitive:
  932             compileToPrimitive();
  933             break;
  934         case MakeRope:
  935             compileMakeRope();
  936             break;
  937         case StringCharAt:
  938             compileStringCharAt();
  939             break;
  940         case StringCharCodeAt:
  941             compileStringCharCodeAt();
  942             break;
  943         case StringFromCharCode:
  944             compileStringFromCharCode();
  945             break;
  946         case GetByOffset:
  947         case GetGetterSetterByOffset:
  948             compileGetByOffset();
  949             break;
  950         case GetGetter:
  951             compileGetGetter();
  952             break;
  953         case GetSetter:
  954             compileGetSetter();
  955             break;
  956         case MultiGetByOffset:
  957             compileMultiGetByOffset();
  958             break;
  959         case PutByOffset:
  960             compilePutByOffset();
  961             break;
  962         case MultiPutByOffset:
  963             compileMultiPutByOffset();
  964             break;
  965         case MatchStructure:
  966             compileMatchStructure();
  967             break;
  968         case GetGlobalVar:
  969         case GetGlobalLexicalVariable:
  970             compileGetGlobalVariable();
  971             break;
  972         case PutGlobalVariable:
  973             compilePutGlobalVariable();
  974             break;
  975         case NotifyWrite:
  976             compileNotifyWrite();
  977             break;
  978         case GetCallee:
  979             compileGetCallee();
  980             break;
  981         case SetCallee:
  982             compileSetCallee();
  983             break;
  984         case GetArgumentCountIncludingThis:
  985             compileGetArgumentCountIncludingThis();
  986             break;
  987         case SetArgumentCountIncludingThis:
  988             compileSetArgumentCountIncludingThis();
  989             break;
  990         case GetScope:
  991             compileGetScope();
  992             break;
  993         case SkipScope:
  994             compileSkipScope();
  995             break;
  996         case GetGlobalObject:
  997             compileGetGlobalObject();
  998             break;
  999         case GetGlobalThis:
 1000             compileGetGlobalThis();
 1001             break;
 1002         case GetClosureVar:
 1003             compileGetClosureVar();
 1004             break;
 1005         case PutClosureVar:
 1006             compilePutClosureVar();
 1007             break;
 1008         case GetFromArguments:
 1009             compileGetFromArguments();
 1010             break;
 1011         case PutToArguments:
 1012             compilePutToArguments();
 1013             break;
 1014         case GetArgument:
 1015             compileGetArgument();
 1016             break;
 1017         case CompareEq:
 1018             compileCompareEq();
 1019             break;
 1020         case CompareStrictEq:
 1021             compileCompareStrictEq();
 1022             break;
 1023         case CompareLess:
 1024             compileCompareLess();
 1025             break;
 1026         case CompareLessEq:
 1027             compileCompareLessEq();
 1028             break;
 1029         case CompareGreater:
 1030             compileCompareGreater();
 1031             break;
 1032         case CompareGreaterEq:
 1033             compileCompareGreaterEq();
 1034             break;
 1035         case CompareBelow:
 1036             compileCompareBelow();
 1037             break;
 1038         case CompareBelowEq:
 1039             compileCompareBelowEq();
 1040             break;
 1041         case CompareEqPtr:
 1042             compileCompareEqPtr();
 1043             break;
 1044         case SameValue:
 1045             compileSameValue();
 1046             break;
 1047         case LogicalNot:
 1048             compileLogicalNot();
 1049             break;
 1050         case Call:
 1051         case TailCallInlinedCaller:
 1052         case Construct:
 1053             compileCallOrConstruct();
 1054             break;
 1055         case DirectCall:
 1056         case DirectTailCallInlinedCaller:
 1057         case DirectConstruct:
 1058         case DirectTailCall:
 1059             compileDirectCallOrConstruct();
 1060             break;
 1061         case TailCall:
 1062             compileTailCall();
 1063             break;
 1064         case CallVarargs:
 1065         case CallForwardVarargs:
 1066         case TailCallVarargs:
 1067         case TailCallVarargsInlinedCaller:
 1068         case TailCallForwardVarargs:
 1069         case TailCallForwardVarargsInlinedCaller:
 1070         case ConstructVarargs:
 1071         case ConstructForwardVarargs:
 1072             compileCallOrConstructVarargs();
 1073             break;
 1074         case CallEval:
 1075             compileCallEval();
 1076             break;
 1077         case LoadVarargs:
 1078             compileLoadVarargs();
 1079             break;
 1080         case ForwardVarargs:
 1081             compileForwardVarargs();
 1082             break;
 1083         case DFG::Jump:
 1084             compileJump();
 1085             break;
 1086         case DFG::Branch:
 1087             compileBranch();
 1088             break;
 1089         case DFG::Switch:
 1090             compileSwitch();
 1091             break;
 1092         case DFG::EntrySwitch:
 1093             compileEntrySwitch();
 1094             break;
 1095         case DFG::Return:
 1096             compileReturn();
 1097             break;
 1098         case ForceOSRExit:
 1099             compileForceOSRExit();
 1100             break;
 1101         case CPUIntrinsic:
 1102 #if CPU(X86_64)
 1103             compileCPUIntrinsic();
 1104 #else
 1105             RELEASE_ASSERT_NOT_REACHED();
 1106 #endif
 1107             break;
 1108         case Throw:
 1109             compileThrow();
 1110             break;
 1111         case ThrowStaticError:
 1112             compileThrowStaticError();
 1113             break;
 1114         case InvalidationPoint:
 1115             compileInvalidationPoint();
 1116             break;
 1117         case IsEmpty:
 1118             compileIsEmpty();
 1119             break;
 1120         case IsUndefined:
 1121             compileIsUndefined();
 1122             break;
 1123         case IsUndefinedOrNull:
 1124             compileIsUndefinedOrNull();
 1125             break;
 1126         case IsBoolean:
 1127             compileIsBoolean();
 1128             break;
 1129         case IsNumber:
 1130             compileIsNumber();
 1131             break;
 1132         case NumberIsInteger:
 1133             compileNumberIsInteger();
 1134             break;
 1135         case IsCellWithType:
 1136             compileIsCellWithType();
 1137             break;
 1138         case MapHash:
 1139             compileMapHash();
 1140             break;
 1141         case NormalizeMapKey:
 1142             compileNormalizeMapKey();
 1143             break;
 1144         case GetMapBucket:
 1145             compileGetMapBucket();
 1146             break;
 1147         case GetMapBucketHead:
 1148             compileGetMapBucketHead();
 1149             break;
 1150         case GetMapBucketNext:
 1151             compileGetMapBucketNext();
 1152             break;
 1153         case LoadKeyFromMapBucket:
 1154             compileLoadKeyFromMapBucket();
 1155             break;
 1156         case LoadValueFromMapBucket:
 1157             compileLoadValueFromMapBucket();
 1158             break;
 1159         case ExtractValueFromWeakMapGet:
 1160             compileExtractValueFromWeakMapGet();
 1161             break;
 1162         case SetAdd:
 1163             compileSetAdd();
 1164             break;
 1165         case MapSet:
 1166             compileMapSet();
 1167             break;
 1168         case WeakMapGet:
 1169             compileWeakMapGet();
 1170             break;
 1171         case WeakSetAdd:
 1172             compileWeakSetAdd();
 1173             break;
 1174         case WeakMapSet:
 1175             compileWeakMapSet();
 1176             break;
 1177         case IsObject:
 1178             compileIsObject();
 1179             break;
 1180         case IsObjectOrNull:
 1181             compileIsObjectOrNull();
 1182             break;
 1183         case IsFunction:
 1184             compileIsFunction();
 1185             break;
 1186         case IsTypedArrayView:
 1187             compileIsTypedArrayView();
 1188             break;
 1189         case ParseInt:
 1190             compileParseInt();
 1191             break;
 1192         case TypeOf:
 1193             compileTypeOf();
 1194             break;
 1195         case CheckTypeInfoFlags:
 1196             compileCheckTypeInfoFlags();
 1197             break;
 1198         case OverridesHasInstance:
 1199             compileOverridesHasInstance();
 1200             break;
 1201         case InstanceOf:
 1202             compileInstanceOf();
 1203             break;
 1204         case InstanceOfCustom:
 1205             compileInstanceOfCustom();
 1206             break;
 1207         case CountExecution:
 1208             compileCountExecution();
 1209             break;
 1210         case SuperSamplerBegin:
 1211             compileSuperSamplerBegin();
 1212             break;
 1213         case SuperSamplerEnd:
 1214             compileSuperSamplerEnd();
 1215             break;
 1216         case StoreBarrier:
 1217         case FencedStoreBarrier:
 1218             compileStoreBarrier();
 1219             break;
 1220         case HasIndexedProperty:
 1221             compileHasIndexedProperty();
 1222             break;
 1223         case HasGenericProperty:
 1224             compileHasGenericProperty();
 1225             break;
 1226         case HasStructureProperty:
 1227             compileHasStructureProperty();
 1228             break;
 1229         case GetDirectPname:
 1230             compileGetDirectPname();
 1231             break;
 1232         case GetEnumerableLength:
 1233             compileGetEnumerableLength();
 1234             break;
 1235         case GetPropertyEnumerator:
 1236             compileGetPropertyEnumerator();
 1237             break;
 1238         case GetEnumeratorStructurePname:
 1239             compileGetEnumeratorStructurePname();
 1240             break;
 1241         case GetEnumeratorGenericPname:
 1242             compileGetEnumeratorGenericPname();
 1243             break;
 1244         case ToIndexString:
 1245             compileToIndexString();
 1246             break;
 1247         case CheckStructureImmediate:
 1248             compileCheckStructureImmediate();
 1249             break;
 1250         case MaterializeNewObject:
 1251             compileMaterializeNewObject();
 1252             break;
 1253         case MaterializeCreateActivation:
 1254             compileMaterializeCreateActivation();
 1255             break;
 1256         case CheckTraps:
 1257             compileCheckTraps();
 1258             break;
 1259         case CreateRest:
 1260             compileCreateRest();
 1261             break;
 1262         case GetRestLength:
 1263             compileGetRestLength();
 1264             break;
 1265         case RegExpExec:
 1266             compileRegExpExec();
 1267             break;
 1268         case RegExpExecNonGlobalOrSticky:
 1269             compileRegExpExecNonGlobalOrSticky();
 1270             break;
 1271         case RegExpTest:
 1272             compileRegExpTest();
 1273             break;
 1274         case RegExpMatchFast:
 1275             compileRegExpMatchFast();
 1276             break;
 1277         case RegExpMatchFastGlobal:
 1278             compileRegExpMatchFastGlobal();
 1279             break;
 1280         case NewRegexp:
 1281             compileNewRegexp();
 1282             break;
 1283         case SetFunctionName:
 1284             compileSetFunctionName();
 1285             break;
 1286         case StringReplace:
 1287         case StringReplaceRegExp:
 1288             compileStringReplace();
 1289             break;
 1290         case GetRegExpObjectLastIndex:
 1291             compileGetRegExpObjectLastIndex();
 1292             break;
 1293         case SetRegExpObjectLastIndex:
 1294             compileSetRegExpObjectLastIndex();
 1295             break;
 1296         case LogShadowChickenPrologue:
 1297             compileLogShadowChickenPrologue();
 1298             break;
 1299         case LogShadowChickenTail:
 1300             compileLogShadowChickenTail();
 1301             break;
 1302         case RecordRegExpCachedResult:
 1303             compileRecordRegExpCachedResult();
 1304             break;
 1305         case ResolveScopeForHoistingFuncDeclInEval:
 1306             compileResolveScopeForHoistingFuncDeclInEval();
 1307             break;
 1308         case ResolveScope:
 1309             compileResolveScope();
 1310             break;
 1311         case GetDynamicVar:
 1312             compileGetDynamicVar();
 1313             break;
 1314         case PutDynamicVar:
 1315             compilePutDynamicVar();
 1316             break;
 1317         case Unreachable:
 1318             compileUnreachable();
 1319             break;
 1320         case StringSlice:
 1321             compileStringSlice();
 1322             break;
 1323         case ToLowerCase:
 1324             compileToLowerCase();
 1325             break;
 1326         case NumberToStringWithRadix:
 1327             compileNumberToStringWithRadix();
 1328             break;
 1329         case NumberToStringWithValidRadixConstant:
 1330             compileNumberToStringWithValidRadixConstant();
 1331             break;
 1332         case CheckSubClass:
 1333             compileCheckSubClass();
 1334             break;
 1335         case CallDOM:
 1336             compileCallDOM();
 1337             break;
 1338         case CallDOMGetter:
 1339             compileCallDOMGetter();
 1340             break;
 1341         case FilterCallLinkStatus:
 1342         case FilterGetByIdStatus:
 1343         case FilterPutByIdStatus:
 1344         case FilterInByIdStatus:
 1345             compileFilterICStatus();
 1346             break;
 1347         case DataViewGetInt:
 1348         case DataViewGetFloat:
 1349             compileDataViewGet();
 1350             break;
 1351         case DataViewSet:
 1352             compileDataViewSet();
 1353             break;
 1354 
 1355         case PhantomLocal:
 1356         case LoopHint:
 1357         case MovHint:
 1358         case ZombieHint:
 1359         case ExitOK:
 1360         case PhantomNewObject:
 1361         case PhantomNewFunction:
 1362         case PhantomNewGeneratorFunction:
 1363         case PhantomNewAsyncGeneratorFunction:
 1364         case PhantomNewAsyncFunction:
 1365         case PhantomCreateActivation:
 1366         case PhantomDirectArguments:
 1367         case PhantomCreateRest:
 1368         case PhantomSpread:
 1369         case PhantomNewArrayWithSpread:
 1370         case PhantomNewArrayBuffer:
 1371         case PhantomClonedArguments:
 1372         case PhantomNewRegexp:
 1373         case PutHint:
 1374         case BottomValue:
 1375         case KillStack:
 1376         case InitializeEntrypointArguments:
 1377             break;
 1378         default:
 1379             DFG_CRASH(m_graph, m_node, &quot;Unrecognized node in FTL backend&quot;);
 1380             break;
 1381         }
 1382 
 1383         if (m_node-&gt;isTerminal())
 1384             return false;
 1385 
 1386         if (!m_state.isValid()) {
 1387             safelyInvalidateAfterTermination();
 1388             return false;
 1389         }
 1390 
 1391         m_availabilityCalculator.executeNode(m_node);
 1392         m_interpreter.executeEffects(nodeIndex);
 1393 
 1394         return true;
 1395     }
 1396 
 1397     void compileUpsilon()
 1398     {
 1399         LValue upsilonValue = nullptr;
 1400         switch (m_node-&gt;child1().useKind()) {
 1401         case DoubleRepUse:
 1402             upsilonValue = lowDouble(m_node-&gt;child1());
 1403             break;
 1404         case Int32Use:
 1405         case KnownInt32Use:
 1406             upsilonValue = lowInt32(m_node-&gt;child1());
 1407             break;
 1408         case Int52RepUse:
 1409             upsilonValue = lowInt52(m_node-&gt;child1());
 1410             break;
 1411         case BooleanUse:
 1412         case KnownBooleanUse:
 1413             upsilonValue = lowBoolean(m_node-&gt;child1());
 1414             break;
 1415         case CellUse:
 1416         case KnownCellUse:
 1417             upsilonValue = lowCell(m_node-&gt;child1());
 1418             break;
 1419         case UntypedUse:
 1420             upsilonValue = lowJSValue(m_node-&gt;child1());
 1421             break;
 1422         default:
 1423             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1424             break;
 1425         }
 1426         ValueFromBlock upsilon = m_out.anchor(upsilonValue);
 1427         LValue phiNode = m_phis.get(m_node-&gt;phi());
 1428         m_out.addIncomingToPhi(phiNode, upsilon);
 1429     }
 1430 
 1431     void compilePhi()
 1432     {
 1433         LValue phi = m_phis.get(m_node);
 1434         m_out.m_block-&gt;append(phi);
 1435 
 1436         switch (m_node-&gt;flags() &amp; NodeResultMask) {
 1437         case NodeResultDouble:
 1438             setDouble(phi);
 1439             break;
 1440         case NodeResultInt32:
 1441             setInt32(phi);
 1442             break;
 1443         case NodeResultInt52:
 1444             setInt52(phi);
 1445             break;
 1446         case NodeResultBoolean:
 1447             setBoolean(phi);
 1448             break;
 1449         case NodeResultJS:
 1450             setJSValue(phi);
 1451             break;
 1452         default:
 1453             DFG_CRASH(m_graph, m_node, &quot;Bad result type&quot;);
 1454             break;
 1455         }
 1456     }
 1457 
 1458     void compileDoubleConstant()
 1459     {
 1460         setDouble(m_out.constDouble(m_node-&gt;asNumber()));
 1461     }
 1462 
 1463     void compileInt52Constant()
 1464     {
 1465         int64_t value = m_node-&gt;asAnyInt();
 1466 
 1467         setInt52(m_out.constInt64(value &lt;&lt; JSValue::int52ShiftAmount));
 1468         setStrictInt52(m_out.constInt64(value));
 1469     }
 1470 
 1471     void compileLazyJSConstant()
 1472     {
 1473         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 1474         LazyJSValue value = m_node-&gt;lazyJSValue();
 1475         patchpoint-&gt;setGenerator(
 1476             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 1477                 value.emit(jit, JSValueRegs(params[0].gpr()));
 1478             });
 1479         patchpoint-&gt;effects = Effects::none();
 1480         setJSValue(patchpoint);
 1481     }
 1482 
 1483     void compileDoubleRep()
 1484     {
 1485         switch (m_node-&gt;child1().useKind()) {
 1486         case RealNumberUse: {
 1487             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 1488 
 1489             LValue doubleValue = unboxDouble(value);
 1490 
 1491             LBasicBlock intCase = m_out.newBlock();
 1492             LBasicBlock continuation = m_out.newBlock();
 1493 
 1494             ValueFromBlock fastResult = m_out.anchor(doubleValue);
 1495             m_out.branch(
 1496                 m_out.doubleEqual(doubleValue, doubleValue),
 1497                 usually(continuation), rarely(intCase));
 1498 
 1499             LBasicBlock lastNext = m_out.appendTo(intCase, continuation);
 1500 
 1501             FTL_TYPE_CHECK(
 1502                 jsValueValue(value), m_node-&gt;child1(), SpecBytecodeRealNumber,
 1503                 isNotInt32(value, provenType(m_node-&gt;child1()) &amp; ~SpecDoubleReal));
 1504             ValueFromBlock slowResult = m_out.anchor(m_out.intToDouble(unboxInt32(value)));
 1505             m_out.jump(continuation);
 1506 
 1507             m_out.appendTo(continuation, lastNext);
 1508 
 1509             setDouble(m_out.phi(Double, fastResult, slowResult));
 1510             return;
 1511         }
 1512 
 1513         case NotCellUse:
 1514         case NumberUse: {
 1515             bool shouldConvertNonNumber = m_node-&gt;child1().useKind() == NotCellUse;
 1516 
 1517             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 1518 
 1519             LBasicBlock intCase = m_out.newBlock();
 1520             LBasicBlock doubleTesting = m_out.newBlock();
 1521             LBasicBlock doubleCase = m_out.newBlock();
 1522             LBasicBlock nonDoubleCase = m_out.newBlock();
 1523             LBasicBlock continuation = m_out.newBlock();
 1524 
 1525             m_out.branch(
 1526                 isNotInt32(value, provenType(m_node-&gt;child1())),
 1527                 unsure(doubleTesting), unsure(intCase));
 1528 
 1529             LBasicBlock lastNext = m_out.appendTo(intCase, doubleTesting);
 1530 
 1531             ValueFromBlock intToDouble = m_out.anchor(
 1532                 m_out.intToDouble(unboxInt32(value)));
 1533             m_out.jump(continuation);
 1534 
 1535             m_out.appendTo(doubleTesting, doubleCase);
 1536             LValue valueIsNumber = isNumber(value, provenType(m_node-&gt;child1()));
 1537             m_out.branch(valueIsNumber, usually(doubleCase), rarely(nonDoubleCase));
 1538 
 1539             m_out.appendTo(doubleCase, nonDoubleCase);
 1540             ValueFromBlock unboxedDouble = m_out.anchor(unboxDouble(value));
 1541             m_out.jump(continuation);
 1542 
 1543             if (shouldConvertNonNumber) {
 1544                 LBasicBlock undefinedCase = m_out.newBlock();
 1545                 LBasicBlock testNullCase = m_out.newBlock();
 1546                 LBasicBlock nullCase = m_out.newBlock();
 1547                 LBasicBlock testBooleanTrueCase = m_out.newBlock();
 1548                 LBasicBlock convertBooleanTrueCase = m_out.newBlock();
 1549                 LBasicBlock convertBooleanFalseCase = m_out.newBlock();
 1550 
 1551                 m_out.appendTo(nonDoubleCase, undefinedCase);
 1552                 LValue valueIsUndefined = m_out.equal(value, m_out.constInt64(ValueUndefined));
 1553                 m_out.branch(valueIsUndefined, unsure(undefinedCase), unsure(testNullCase));
 1554 
 1555                 m_out.appendTo(undefinedCase, testNullCase);
 1556                 ValueFromBlock convertedUndefined = m_out.anchor(m_out.constDouble(PNaN));
 1557                 m_out.jump(continuation);
 1558 
 1559                 m_out.appendTo(testNullCase, nullCase);
 1560                 LValue valueIsNull = m_out.equal(value, m_out.constInt64(ValueNull));
 1561                 m_out.branch(valueIsNull, unsure(nullCase), unsure(testBooleanTrueCase));
 1562 
 1563                 m_out.appendTo(nullCase, testBooleanTrueCase);
 1564                 ValueFromBlock convertedNull = m_out.anchor(m_out.constDouble(0));
 1565                 m_out.jump(continuation);
 1566 
 1567                 m_out.appendTo(testBooleanTrueCase, convertBooleanTrueCase);
 1568                 LValue valueIsBooleanTrue = m_out.equal(value, m_out.constInt64(ValueTrue));
 1569                 m_out.branch(valueIsBooleanTrue, unsure(convertBooleanTrueCase), unsure(convertBooleanFalseCase));
 1570 
 1571                 m_out.appendTo(convertBooleanTrueCase, convertBooleanFalseCase);
 1572                 ValueFromBlock convertedTrue = m_out.anchor(m_out.constDouble(1));
 1573                 m_out.jump(continuation);
 1574 
 1575                 m_out.appendTo(convertBooleanFalseCase, continuation);
 1576 
 1577                 LValue valueIsNotBooleanFalse = m_out.notEqual(value, m_out.constInt64(ValueFalse));
 1578                 FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), ~SpecCellCheck, valueIsNotBooleanFalse);
 1579                 ValueFromBlock convertedFalse = m_out.anchor(m_out.constDouble(0));
 1580                 m_out.jump(continuation);
 1581 
 1582                 m_out.appendTo(continuation, lastNext);
 1583                 setDouble(m_out.phi(Double, intToDouble, unboxedDouble, convertedUndefined, convertedNull, convertedTrue, convertedFalse));
 1584                 return;
 1585             }
 1586             m_out.appendTo(nonDoubleCase, continuation);
 1587             FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), SpecBytecodeNumber, m_out.booleanTrue);
 1588             m_out.unreachable();
 1589 
 1590             m_out.appendTo(continuation, lastNext);
 1591 
 1592             setDouble(m_out.phi(Double, intToDouble, unboxedDouble));
 1593             return;
 1594         }
 1595 
 1596         case Int52RepUse: {
 1597             setDouble(strictInt52ToDouble(lowStrictInt52(m_node-&gt;child1())));
 1598             return;
 1599         }
 1600 
 1601         default:
 1602             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1603         }
 1604     }
 1605 
 1606     void compileDoubleAsInt32()
 1607     {
 1608         LValue integerValue = convertDoubleToInt32(lowDouble(m_node-&gt;child1()), shouldCheckNegativeZero(m_node-&gt;arithMode()));
 1609         setInt32(integerValue);
 1610     }
 1611 
 1612     void compileValueRep()
 1613     {
 1614         switch (m_node-&gt;child1().useKind()) {
 1615         case DoubleRepUse: {
 1616             LValue value = lowDouble(m_node-&gt;child1());
 1617 
 1618             if (m_interpreter.needsTypeCheck(m_node-&gt;child1(), ~SpecDoubleImpureNaN)) {
 1619                 value = m_out.select(
 1620                     m_out.doubleEqual(value, value), value, m_out.constDouble(PNaN));
 1621             }
 1622 
 1623             setJSValue(boxDouble(value));
 1624             return;
 1625         }
 1626 
 1627         case Int52RepUse: {
 1628             setJSValue(strictInt52ToJSValue(lowStrictInt52(m_node-&gt;child1())));
 1629             return;
 1630         }
 1631 
 1632         default:
 1633             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1634         }
 1635     }
 1636 
 1637     void compileInt52Rep()
 1638     {
 1639         switch (m_node-&gt;child1().useKind()) {
 1640         case Int32Use:
 1641             setStrictInt52(m_out.signExt32To64(lowInt32(m_node-&gt;child1())));
 1642             return;
 1643 
 1644         case AnyIntUse:
 1645             setStrictInt52(
 1646                 jsValueToStrictInt52(
 1647                     m_node-&gt;child1(), lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation)));
 1648             return;
 1649 
 1650         case DoubleRepAnyIntUse:
 1651             setStrictInt52(
 1652                 doubleToStrictInt52(
 1653                     m_node-&gt;child1(), lowDouble(m_node-&gt;child1())));
 1654             return;
 1655 
 1656         default:
 1657             RELEASE_ASSERT_NOT_REACHED();
 1658         }
 1659     }
 1660 
 1661     void compileValueToInt32()
 1662     {
 1663         switch (m_node-&gt;child1().useKind()) {
 1664         case Int52RepUse:
 1665             setInt32(m_out.castToInt32(lowStrictInt52(m_node-&gt;child1())));
 1666             break;
 1667 
 1668         case DoubleRepUse:
 1669             setInt32(doubleToInt32(lowDouble(m_node-&gt;child1())));
 1670             break;
 1671 
 1672         case NumberUse:
 1673         case NotCellUse: {
 1674             LoweredNodeValue value = m_int32Values.get(m_node-&gt;child1().node());
 1675             if (isValid(value)) {
 1676                 setInt32(value.value());
 1677                 break;
 1678             }
 1679 
 1680             value = m_jsValueValues.get(m_node-&gt;child1().node());
 1681             if (isValid(value)) {
 1682                 setInt32(numberOrNotCellToInt32(m_node-&gt;child1(), value.value()));
 1683                 break;
 1684             }
 1685 
 1686             // We&#39;ll basically just get here for constants. But it&#39;s good to have this
 1687             // catch-all since we often add new representations into the mix.
 1688             setInt32(
 1689                 numberOrNotCellToInt32(
 1690                     m_node-&gt;child1(),
 1691                     lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation)));
 1692             break;
 1693         }
 1694 
 1695         default:
 1696             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1697             break;
 1698         }
 1699     }
 1700 
 1701     void compileBooleanToNumber()
 1702     {
 1703         switch (m_node-&gt;child1().useKind()) {
 1704         case BooleanUse: {
 1705             setInt32(m_out.zeroExt(lowBoolean(m_node-&gt;child1()), Int32));
 1706             return;
 1707         }
 1708 
 1709         case UntypedUse: {
 1710             LValue value = lowJSValue(m_node-&gt;child1());
 1711 
 1712             if (!m_interpreter.needsTypeCheck(m_node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
 1713                 setInt32(m_out.bitAnd(m_out.castToInt32(value), m_out.int32One));
 1714                 return;
 1715             }
 1716 
 1717             LBasicBlock booleanCase = m_out.newBlock();
 1718             LBasicBlock continuation = m_out.newBlock();
 1719 
 1720             ValueFromBlock notBooleanResult = m_out.anchor(value);
 1721             m_out.branch(
 1722                 isBoolean(value, provenType(m_node-&gt;child1())),
 1723                 unsure(booleanCase), unsure(continuation));
 1724 
 1725             LBasicBlock lastNext = m_out.appendTo(booleanCase, continuation);
 1726             ValueFromBlock booleanResult = m_out.anchor(m_out.bitOr(
 1727                 m_out.zeroExt(unboxBoolean(value), Int64), m_tagTypeNumber));
 1728             m_out.jump(continuation);
 1729 
 1730             m_out.appendTo(continuation, lastNext);
 1731             setJSValue(m_out.phi(Int64, booleanResult, notBooleanResult));
 1732             return;
 1733         }
 1734 
 1735         default:
 1736             RELEASE_ASSERT_NOT_REACHED();
 1737             return;
 1738         }
 1739     }
 1740 
 1741     void compileExtractOSREntryLocal()
 1742     {
 1743         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(
 1744             m_ftlState.jitCode-&gt;ftlForOSREntry()-&gt;entryBuffer()-&gt;dataBuffer());
 1745         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;unlinkedLocal().toLocal())));
 1746     }
 1747 
 1748     void compileExtractCatchLocal()
 1749     {
 1750         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(m_ftlState.jitCode-&gt;common.catchOSREntryBuffer-&gt;dataBuffer());
 1751         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;catchOSREntryIndex())));
 1752     }
 1753 
 1754     void compileClearCatchLocals()
 1755     {
 1756         ScratchBuffer* scratchBuffer = m_ftlState.jitCode-&gt;common.catchOSREntryBuffer;
 1757         ASSERT(scratchBuffer);
 1758         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 1759     }
 1760 
 1761     void compileGetStack()
 1762     {
 1763         StackAccessData* data = m_node-&gt;stackAccessData();
 1764         AbstractValue&amp; value = m_state.operand(data-&gt;local);
 1765 
 1766         DFG_ASSERT(m_graph, m_node, isConcrete(data-&gt;format), data-&gt;format);
 1767 
 1768         switch (data-&gt;format) {
 1769         case FlushedDouble:
 1770             setDouble(m_out.loadDouble(addressFor(data-&gt;machineLocal)));
 1771             break;
 1772         case FlushedInt52:
 1773             setInt52(m_out.load64(addressFor(data-&gt;machineLocal)));
 1774             break;
 1775         default:
 1776             if (isInt32Speculation(value.m_type))
<a name="12" id="anc12"></a><span class="line-modified"> 1777             setInt32(m_out.load32(payloadFor(data-&gt;machineLocal)));</span>
<span class="line-modified"> 1778         else</span>
<span class="line-modified"> 1779             setJSValue(m_out.load64(addressFor(data-&gt;machineLocal)));</span>
 1780             break;
 1781         }
 1782     }
 1783 
 1784     void compilePutStack()
 1785     {
 1786         StackAccessData* data = m_node-&gt;stackAccessData();
 1787         switch (data-&gt;format) {
 1788         case FlushedJSValue: {
 1789             LValue value = lowJSValue(m_node-&gt;child1());
 1790             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1791             break;
 1792         }
 1793 
 1794         case FlushedDouble: {
 1795             LValue value = lowDouble(m_node-&gt;child1());
 1796             m_out.storeDouble(value, addressFor(data-&gt;machineLocal));
 1797             break;
 1798         }
 1799 
 1800         case FlushedInt32: {
 1801             LValue value = lowInt32(m_node-&gt;child1());
 1802             m_out.store32(value, payloadFor(data-&gt;machineLocal));
 1803             break;
 1804         }
 1805 
 1806         case FlushedInt52: {
 1807             LValue value = lowInt52(m_node-&gt;child1());
 1808             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1809             break;
 1810         }
 1811 
 1812         case FlushedCell: {
 1813             LValue value = lowCell(m_node-&gt;child1());
 1814             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1815             break;
 1816         }
 1817 
 1818         case FlushedBoolean: {
 1819             speculateBoolean(m_node-&gt;child1());
 1820             m_out.store64(
 1821                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 1822                 addressFor(data-&gt;machineLocal));
 1823             break;
 1824         }
 1825 
 1826         default:
 1827             DFG_CRASH(m_graph, m_node, &quot;Bad flush format&quot;);
 1828             break;
 1829         }
 1830     }
 1831 
 1832     void compileNoOp()
 1833     {
 1834         DFG_NODE_DO_TO_CHILDREN(m_graph, m_node, speculate);
 1835     }
 1836 
 1837     void compileToObjectOrCallObjectConstructor()
 1838     {
 1839         LValue value = lowJSValue(m_node-&gt;child1());
 1840 
 1841         LBasicBlock isCellCase = m_out.newBlock();
 1842         LBasicBlock slowCase = m_out.newBlock();
 1843         LBasicBlock continuation = m_out.newBlock();
 1844 
 1845         m_out.branch(isCell(value, provenType(m_node-&gt;child1())), usually(isCellCase), rarely(slowCase));
 1846 
 1847         LBasicBlock lastNext = m_out.appendTo(isCellCase, slowCase);
 1848         ValueFromBlock fastResult = m_out.anchor(value);
 1849         m_out.branch(isObject(value), usually(continuation), rarely(slowCase));
 1850 
 1851         m_out.appendTo(slowCase, continuation);
 1852 
 1853         ValueFromBlock slowResult;
 1854         if (m_node-&gt;op() == ToObject) {
 1855             auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 1856             slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationToObject), m_callFrame, weakPointer(globalObject), value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 1857         } else
 1858             slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationCallObjectConstructor), m_callFrame, frozenPointer(m_node-&gt;cellOperand()), value));
 1859         m_out.jump(continuation);
 1860 
 1861         m_out.appendTo(continuation, lastNext);
 1862         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 1863     }
 1864 
 1865     void compileToThis()
 1866     {
 1867         LValue value = lowJSValue(m_node-&gt;child1());
 1868 
 1869         LBasicBlock isCellCase = m_out.newBlock();
 1870         LBasicBlock slowCase = m_out.newBlock();
 1871         LBasicBlock continuation = m_out.newBlock();
 1872 
 1873         m_out.branch(
 1874             isCell(value, provenType(m_node-&gt;child1())), usually(isCellCase), rarely(slowCase));
 1875 
 1876         LBasicBlock lastNext = m_out.appendTo(isCellCase, slowCase);
 1877         ValueFromBlock fastResult = m_out.anchor(value);
 1878         m_out.branch(
 1879             m_out.testIsZero32(
 1880                 m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
 1881                 m_out.constInt32(OverridesToThis)),
 1882             usually(continuation), rarely(slowCase));
 1883 
 1884         m_out.appendTo(slowCase, continuation);
 1885         J_JITOperation_EJ function;
 1886         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 1887             function = operationToThisStrict;
 1888         else
 1889             function = operationToThis;
 1890         ValueFromBlock slowResult = m_out.anchor(
 1891             vmCall(Int64, m_out.operation(function), m_callFrame, value));
 1892         m_out.jump(continuation);
 1893 
 1894         m_out.appendTo(continuation, lastNext);
 1895         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 1896     }
 1897 
 1898     void compileValueAdd()
 1899     {
 1900         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 1901             LValue left = lowBigInt(m_node-&gt;child1());
 1902             LValue right = lowBigInt(m_node-&gt;child2());
 1903 
 1904             LValue result = vmCall(pointerType(), m_out.operation(operationAddBigInt), m_callFrame, left, right);
 1905             setJSValue(result);
 1906             return;
 1907         }
 1908 
 1909         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="13" id="anc13"></a><span class="line-modified"> 1910         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 1911         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 1912         auto repatchingFunction = operationValueAddOptimize;
 1913         auto nonRepatchingFunction = operationValueAdd;
<a name="14" id="anc14"></a><span class="line-modified"> 1914         compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 1915     }
 1916 
 1917     void compileValueSub()
 1918     {
 1919         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 1920             LValue left = lowBigInt(m_node-&gt;child1());
 1921             LValue right = lowBigInt(m_node-&gt;child2());
 1922 
 1923             LValue result = vmCall(pointerType(), m_out.operation(operationSubBigInt), m_callFrame, left, right);
 1924             setJSValue(result);
 1925             return;
 1926         }
 1927 
 1928         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="15" id="anc15"></a><span class="line-modified"> 1929         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 1930         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 1931         auto repatchingFunction = operationValueSubOptimize;
 1932         auto nonRepatchingFunction = operationValueSub;
<a name="16" id="anc16"></a><span class="line-modified"> 1933         compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 1934     }
 1935 
 1936     void compileValueMul()
 1937     {
 1938         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 1939             LValue left = lowBigInt(m_node-&gt;child1());
 1940             LValue right = lowBigInt(m_node-&gt;child2());
 1941 
 1942             LValue result = vmCall(Int64, m_out.operation(operationMulBigInt), m_callFrame, left, right);
 1943             setJSValue(result);
 1944             return;
 1945         }
 1946 
 1947         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="17" id="anc17"></a><span class="line-modified"> 1948         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 1949         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 1950         auto repatchingFunction = operationValueMulOptimize;
 1951         auto nonRepatchingFunction = operationValueMul;
<a name="18" id="anc18"></a><span class="line-modified"> 1952         compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 1953     }
 1954 
 1955     template &lt;typename Generator, typename Func1, typename Func2,
 1956         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<a name="19" id="anc19"></a><span class="line-modified"> 1957     void compileUnaryMathIC(ArithProfile* arithProfile, const Instruction* instruction, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 1958     {
 1959         Node* node = m_node;
 1960 
 1961         LValue operand = lowJSValue(node-&gt;child1());
 1962 
 1963         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 1964         patchpoint-&gt;appendSomeRegister(operand);
 1965         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 1966         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 1967         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 1968         patchpoint-&gt;numGPScratchRegisters = 1;
 1969         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 1970         State* state = &amp;m_ftlState;
 1971         patchpoint-&gt;setGenerator(
 1972             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 1973                 AllowMacroScratchRegisterUsage allowScratch(jit);
 1974 
 1975                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 1976                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 1977 
 1978 #if ENABLE(MATH_IC_STATS)
 1979                 auto inlineStart = jit.label();
 1980 #endif
 1981 
 1982                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<a name="20" id="anc20"></a><span class="line-modified"> 1983                 JITUnaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile, instruction);</span>
 1984                 mathIC-&gt;m_generator = Generator(JSValueRegs(params[0].gpr()), JSValueRegs(params[1].gpr()), params.gpScratch(0));
 1985 
 1986                 bool shouldEmitProfiling = false;
 1987                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 1988 
 1989                 if (generatedInline) {
 1990                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 1991                     auto done = jit.label();
 1992                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 1993                         AllowMacroScratchRegisterUsage allowScratch(jit);
 1994                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 1995                         mathICGenerationState-&gt;slowPathStart = jit.label();
 1996 #if ENABLE(MATH_IC_STATS)
 1997                         auto slowPathStart = jit.label();
 1998 #endif
 1999 
 2000                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2001                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2002                                 repatchingFunction, params[0].gpr(), params[1].gpr(), CCallHelpers::TrustedImmPtr(mathIC));
 2003                             mathICGenerationState-&gt;slowPathCall = call.call();
 2004                         } else {
 2005                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
 2006                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), params[1].gpr());
 2007                             mathICGenerationState-&gt;slowPathCall = call.call();
 2008                         }
 2009                         jit.jump().linkTo(done, &amp;jit);
 2010 
 2011                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2012                             mathIC-&gt;finalizeInlineCode(*mathICGenerationState, linkBuffer);
 2013                         });
 2014 
 2015 #if ENABLE(MATH_IC_STATS)
 2016                         auto slowPathEnd = jit.label();
 2017                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2018                             size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
 2019                             mathIC-&gt;m_generatedCodeSize += size;
 2020                         });
 2021 #endif
 2022                     });
 2023                 } else {
 2024                     callOperation(
 2025                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2026                         nonRepatchingFunction, params[0].gpr(), params[1].gpr());
 2027                 }
 2028 
 2029 #if ENABLE(MATH_IC_STATS)
 2030                 auto inlineEnd = jit.label();
 2031                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2032                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2033                     mathIC-&gt;m_generatedCodeSize += size;
 2034                 });
 2035 #endif
 2036             });
 2037 
 2038         setJSValue(patchpoint);
 2039     }
 2040 
 2041     template &lt;typename Generator, typename Func1, typename Func2,
 2042         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<a name="21" id="anc21"></a><span class="line-modified"> 2043     void compileBinaryMathIC(ArithProfile* arithProfile, const Instruction* instruction, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 2044     {
 2045         Node* node = m_node;
 2046 
 2047         LValue left = lowJSValue(node-&gt;child1());
 2048         LValue right = lowJSValue(node-&gt;child2());
 2049 
 2050         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
 2051         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
 2052 
 2053         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2054         patchpoint-&gt;appendSomeRegister(left);
 2055         patchpoint-&gt;appendSomeRegister(right);
 2056         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 2057         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 2058         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 2059             preparePatchpointForExceptions(patchpoint);
 2060         patchpoint-&gt;numGPScratchRegisters = 1;
 2061         patchpoint-&gt;numFPScratchRegisters = 2;
 2062         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2063         State* state = &amp;m_ftlState;
 2064         patchpoint-&gt;setGenerator(
 2065             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2066                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2067 
 2068 
 2069                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2070                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2071 
 2072 #if ENABLE(MATH_IC_STATS)
 2073                 auto inlineStart = jit.label();
 2074 #endif
 2075 
 2076                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<a name="22" id="anc22"></a><span class="line-modified"> 2077                 JITBinaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile, instruction);</span>
 2078                 mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
 2079                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.fpScratch(0),
 2080                     params.fpScratch(1), params.gpScratch(0), InvalidFPRReg);
 2081 
 2082                 bool shouldEmitProfiling = false;
 2083                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2084 
 2085                 if (generatedInline) {
 2086                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2087                     auto done = jit.label();
 2088                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2089                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2090                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2091                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2092 #if ENABLE(MATH_IC_STATS)
 2093                         auto slowPathStart = jit.label();
 2094 #endif
 2095 
 2096                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2097                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2098                                 repatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr(), CCallHelpers::TrustedImmPtr(mathIC));
 2099                             mathICGenerationState-&gt;slowPathCall = call.call();
 2100                         } else {
 2101                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
 2102                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr());
 2103                             mathICGenerationState-&gt;slowPathCall = call.call();
 2104                         }
 2105                         jit.jump().linkTo(done, &amp;jit);
 2106 
 2107                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2108                             mathIC-&gt;finalizeInlineCode(*mathICGenerationState, linkBuffer);
 2109                         });
 2110 
 2111 #if ENABLE(MATH_IC_STATS)
 2112                         auto slowPathEnd = jit.label();
 2113                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2114                             size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
 2115                             mathIC-&gt;m_generatedCodeSize += size;
 2116                         });
 2117 #endif
 2118                     });
 2119                 } else {
 2120                     callOperation(
 2121                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2122                         nonRepatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr());
 2123                 }
 2124 
 2125 #if ENABLE(MATH_IC_STATS)
 2126                 auto inlineEnd = jit.label();
 2127                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2128                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2129                     mathIC-&gt;m_generatedCodeSize += size;
 2130                 });
 2131 #endif
 2132             });
 2133 
 2134         setJSValue(patchpoint);
 2135     }
 2136 
 2137     void compileStrCat()
 2138     {
 2139         LValue result;
 2140         if (m_node-&gt;child3()) {
 2141             result = vmCall(
 2142                 Int64, m_out.operation(operationStrCat3), m_callFrame,
 2143                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 2144                 lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation),
 2145                 lowJSValue(m_node-&gt;child3(), ManualOperandSpeculation));
 2146         } else {
 2147             result = vmCall(
 2148                 Int64, m_out.operation(operationStrCat2), m_callFrame,
 2149                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 2150                 lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation));
 2151         }
 2152         setJSValue(result);
 2153     }
 2154 
 2155     void compileArithAddOrSub()
 2156     {
 2157         bool isSub =  m_node-&gt;op() == ArithSub;
 2158         switch (m_node-&gt;binaryUseKind()) {
 2159         case Int32Use: {
 2160             LValue left = lowInt32(m_node-&gt;child1());
 2161             LValue right = lowInt32(m_node-&gt;child2());
 2162 
 2163             if (!shouldCheckOverflow(m_node-&gt;arithMode())) {
 2164                 setInt32(isSub ? m_out.sub(left, right) : m_out.add(left, right));
 2165                 break;
 2166             }
 2167 
 2168             CheckValue* result =
 2169                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2170             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2171             setInt32(result);
 2172             break;
 2173         }
 2174 
 2175         case Int52RepUse: {
<a name="23" id="anc23"></a><span class="line-modified"> 2176             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecInt52Only)</span>
<span class="line-modified"> 2177                 &amp;&amp; !abstractValue(m_node-&gt;child2()).couldBeType(SpecInt52Only)) {</span>
 2178                 Int52Kind kind;
 2179                 LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2180                 LValue right = lowInt52(m_node-&gt;child2(), kind);
 2181                 setInt52(isSub ? m_out.sub(left, right) : m_out.add(left, right), kind);
 2182                 break;
 2183             }
 2184 
 2185             LValue left = lowInt52(m_node-&gt;child1());
 2186             LValue right = lowInt52(m_node-&gt;child2());
 2187             CheckValue* result =
 2188                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2189             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2190             setInt52(result);
 2191             break;
 2192         }
 2193 
 2194         case DoubleRepUse: {
 2195             LValue C1 = lowDouble(m_node-&gt;child1());
 2196             LValue C2 = lowDouble(m_node-&gt;child2());
 2197 
 2198             setDouble(isSub ? m_out.doubleSub(C1, C2) : m_out.doubleAdd(C1, C2));
 2199             break;
 2200         }
 2201 
 2202         case UntypedUse: {
 2203             if (!isSub) {
 2204                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2205                 break;
 2206             }
 2207 
 2208             CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="24" id="anc24"></a><span class="line-modified"> 2209             ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 2210             const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 2211             auto repatchingFunction = operationValueSubOptimize;
 2212             auto nonRepatchingFunction = operationValueSub;
<a name="25" id="anc25"></a><span class="line-modified"> 2213             compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 2214             break;
 2215         }
 2216 
 2217         default:
 2218             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2219             break;
 2220         }
 2221     }
 2222 
 2223     void compileArithClz32()
 2224     {
 2225         if (m_node-&gt;child1().useKind() == Int32Use || m_node-&gt;child1().useKind() == KnownInt32Use) {
 2226             LValue operand = lowInt32(m_node-&gt;child1());
 2227             setInt32(m_out.ctlz32(operand));
 2228             return;
 2229         }
 2230         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2231         LValue argument = lowJSValue(m_node-&gt;child1());
 2232         LValue result = vmCall(Int32, m_out.operation(operationArithClz32), m_callFrame, argument);
 2233         setInt32(result);
 2234     }
 2235 
 2236     void compileArithMul()
 2237     {
 2238         switch (m_node-&gt;binaryUseKind()) {
 2239         case Int32Use: {
 2240             LValue left = lowInt32(m_node-&gt;child1());
 2241             LValue right = lowInt32(m_node-&gt;child2());
 2242 
 2243             LValue result;
 2244 
 2245             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 2246                 result = m_out.mul(left, right);
 2247             else {
 2248                 CheckValue* speculation = m_out.speculateMul(left, right);
 2249                 blessSpeculation(speculation, Overflow, noValue(), nullptr, m_origin);
 2250                 result = speculation;
 2251             }
 2252 
 2253             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2254                 LBasicBlock slowCase = m_out.newBlock();
 2255                 LBasicBlock continuation = m_out.newBlock();
 2256 
 2257                 m_out.branch(
 2258                     m_out.notZero32(result), usually(continuation), rarely(slowCase));
 2259 
 2260                 LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
 2261                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(left, m_out.int32Zero));
 2262                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(right, m_out.int32Zero));
 2263                 m_out.jump(continuation);
 2264                 m_out.appendTo(continuation, lastNext);
 2265             }
 2266 
 2267             setInt32(result);
 2268             break;
 2269         }
 2270 
 2271         case Int52RepUse: {
 2272             Int52Kind kind;
 2273             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2274             LValue right = lowInt52(m_node-&gt;child2(), opposite(kind));
 2275 
 2276             CheckValue* result = m_out.speculateMul(left, right);
 2277             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2278 
 2279             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2280                 LBasicBlock slowCase = m_out.newBlock();
 2281                 LBasicBlock continuation = m_out.newBlock();
 2282 
 2283                 m_out.branch(
 2284                     m_out.notZero64(result), usually(continuation), rarely(slowCase));
 2285 
 2286                 LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
 2287                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(left, m_out.int64Zero));
 2288                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(right, m_out.int64Zero));
 2289                 m_out.jump(continuation);
 2290                 m_out.appendTo(continuation, lastNext);
 2291             }
 2292 
 2293             setInt52(result);
 2294             break;
 2295         }
 2296 
 2297         case DoubleRepUse: {
 2298             setDouble(
 2299                 m_out.doubleMul(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2300             break;
 2301         }
 2302 
 2303         default:
 2304             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2305             break;
 2306         }
 2307     }
 2308 
 2309     void compileValueDiv()
 2310     {
 2311         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2312             LValue left = lowBigInt(m_node-&gt;child1());
 2313             LValue right = lowBigInt(m_node-&gt;child2());
 2314 
 2315             LValue result = vmCall(pointerType(), m_out.operation(operationDivBigInt), m_callFrame, left, right);
 2316             setJSValue(result);
 2317             return;
 2318         }
 2319 
 2320         emitBinarySnippet&lt;JITDivGenerator, NeedScratchFPR&gt;(operationValueDiv);
 2321     }
 2322 
 2323     void compileArithDiv()
 2324     {
 2325         switch (m_node-&gt;binaryUseKind()) {
 2326         case Int32Use: {
 2327             LValue numerator = lowInt32(m_node-&gt;child1());
 2328             LValue denominator = lowInt32(m_node-&gt;child2());
 2329 
 2330             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2331                 LBasicBlock zeroNumerator = m_out.newBlock();
 2332                 LBasicBlock numeratorContinuation = m_out.newBlock();
 2333 
 2334                 m_out.branch(
 2335                     m_out.isZero32(numerator),
 2336                     rarely(zeroNumerator), usually(numeratorContinuation));
 2337 
 2338                 LBasicBlock innerLastNext = m_out.appendTo(zeroNumerator, numeratorContinuation);
 2339 
 2340                 speculate(
 2341                     NegativeZero, noValue(), 0, m_out.lessThan(denominator, m_out.int32Zero));
 2342 
 2343                 m_out.jump(numeratorContinuation);
 2344 
 2345                 m_out.appendTo(numeratorContinuation, innerLastNext);
 2346             }
 2347 
 2348             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2349                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2350                 LBasicBlock continuation = m_out.newBlock();
 2351 
 2352                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2353                 m_out.branch(
 2354                     m_out.above(adjustedDenominator, m_out.int32One),
 2355                     usually(continuation), rarely(unsafeDenominator));
 2356 
 2357                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2358                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2359                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
 2360                 speculate(Overflow, noValue(), nullptr, m_out.equal(numerator, neg2ToThe31));
 2361                 m_out.jump(continuation);
 2362 
 2363                 m_out.appendTo(continuation, lastNext);
 2364                 LValue result = m_out.div(numerator, denominator);
 2365                 speculate(
 2366                     Overflow, noValue(), 0,
 2367                     m_out.notEqual(m_out.mul(result, denominator), numerator));
 2368                 setInt32(result);
 2369             } else
 2370                 setInt32(m_out.chillDiv(numerator, denominator));
 2371 
 2372             break;
 2373         }
 2374 
 2375         case DoubleRepUse: {
 2376             setDouble(m_out.doubleDiv(
 2377                 lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2378             break;
 2379         }
 2380 
 2381         default:
 2382             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2383             break;
 2384         }
 2385     }
 2386 
<a name="26" id="anc26"></a>

















 2387     void compileArithMod()
 2388     {
 2389         switch (m_node-&gt;binaryUseKind()) {
 2390         case Int32Use: {
 2391             LValue numerator = lowInt32(m_node-&gt;child1());
 2392             LValue denominator = lowInt32(m_node-&gt;child2());
 2393 
 2394             LValue remainder;
 2395             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2396                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2397                 LBasicBlock continuation = m_out.newBlock();
 2398 
 2399                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2400                 m_out.branch(
 2401                     m_out.above(adjustedDenominator, m_out.int32One),
 2402                     usually(continuation), rarely(unsafeDenominator));
 2403 
 2404                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2405                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2406                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
 2407                 speculate(Overflow, noValue(), nullptr, m_out.equal(numerator, neg2ToThe31));
 2408                 m_out.jump(continuation);
 2409 
 2410                 m_out.appendTo(continuation, lastNext);
 2411                 LValue result = m_out.mod(numerator, denominator);
 2412                 remainder = result;
 2413             } else
 2414                 remainder = m_out.chillMod(numerator, denominator);
 2415 
 2416             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2417                 LBasicBlock negativeNumerator = m_out.newBlock();
 2418                 LBasicBlock numeratorContinuation = m_out.newBlock();
 2419 
 2420                 m_out.branch(
 2421                     m_out.lessThan(numerator, m_out.int32Zero),
 2422                     unsure(negativeNumerator), unsure(numeratorContinuation));
 2423 
 2424                 LBasicBlock innerLastNext = m_out.appendTo(negativeNumerator, numeratorContinuation);
 2425 
 2426                 speculate(NegativeZero, noValue(), 0, m_out.isZero32(remainder));
 2427 
 2428                 m_out.jump(numeratorContinuation);
 2429 
 2430                 m_out.appendTo(numeratorContinuation, innerLastNext);
 2431             }
 2432 
 2433             setInt32(remainder);
 2434             break;
 2435         }
 2436 
 2437         case DoubleRepUse: {
 2438             setDouble(
 2439                 m_out.doubleMod(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2440             break;
 2441         }
 2442 
 2443         default:
 2444             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2445             break;
 2446         }
 2447     }
 2448 
 2449     void compileArithMinOrMax()
 2450     {
 2451         switch (m_node-&gt;binaryUseKind()) {
 2452         case Int32Use: {
 2453             LValue left = lowInt32(m_node-&gt;child1());
 2454             LValue right = lowInt32(m_node-&gt;child2());
 2455 
 2456             setInt32(
 2457                 m_out.select(
 2458                     m_node-&gt;op() == ArithMin
 2459                         ? m_out.lessThan(left, right)
 2460                         : m_out.lessThan(right, left),
 2461                     left, right));
 2462             break;
 2463         }
 2464 
 2465         case DoubleRepUse: {
 2466             LValue left = lowDouble(m_node-&gt;child1());
 2467             LValue right = lowDouble(m_node-&gt;child2());
 2468 
 2469             LBasicBlock notLessThan = m_out.newBlock();
 2470             LBasicBlock continuation = m_out.newBlock();
 2471 
 2472             Vector&lt;ValueFromBlock, 2&gt; results;
 2473 
 2474             results.append(m_out.anchor(left));
 2475             m_out.branch(
 2476                 m_node-&gt;op() == ArithMin
 2477                     ? m_out.doubleLessThan(left, right)
 2478                     : m_out.doubleGreaterThan(left, right),
 2479                 unsure(continuation), unsure(notLessThan));
 2480 
 2481             LBasicBlock lastNext = m_out.appendTo(notLessThan, continuation);
 2482             results.append(m_out.anchor(m_out.select(
 2483                 m_node-&gt;op() == ArithMin
 2484                     ? m_out.doubleGreaterThanOrEqual(left, right)
 2485                     : m_out.doubleLessThanOrEqual(left, right),
 2486                 right, m_out.constDouble(PNaN))));
 2487             m_out.jump(continuation);
 2488 
 2489             m_out.appendTo(continuation, lastNext);
 2490             setDouble(m_out.phi(Double, results));
 2491             break;
 2492         }
 2493 
 2494         default:
 2495             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2496             break;
 2497         }
 2498     }
 2499 
 2500     void compileArithAbs()
 2501     {
 2502         switch (m_node-&gt;child1().useKind()) {
 2503         case Int32Use: {
 2504             LValue value = lowInt32(m_node-&gt;child1());
 2505 
 2506             LValue mask = m_out.aShr(value, m_out.constInt32(31));
 2507             LValue result = m_out.bitXor(mask, m_out.add(mask, value));
 2508 
 2509             if (shouldCheckOverflow(m_node-&gt;arithMode()))
 2510                 speculate(Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
 2511 
 2512             setInt32(result);
 2513             break;
 2514         }
 2515 
 2516         case DoubleRepUse: {
 2517             setDouble(m_out.doubleAbs(lowDouble(m_node-&gt;child1())));
 2518             break;
 2519         }
 2520 
 2521         default: {
 2522             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2523             LValue argument = lowJSValue(m_node-&gt;child1());
 2524             LValue result = vmCall(Double, m_out.operation(operationArithAbs), m_callFrame, argument);
 2525             setDouble(result);
 2526             break;
 2527         }
 2528         }
 2529     }
 2530 
 2531     void compileArithUnary()
 2532     {
 2533         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2534             setDouble(m_out.doubleUnary(m_node-&gt;arithUnaryType(), lowDouble(m_node-&gt;child1())));
 2535             return;
 2536         }
 2537         LValue argument = lowJSValue(m_node-&gt;child1());
 2538         LValue result = vmCall(Double, m_out.operation(DFG::arithUnaryOperation(m_node-&gt;arithUnaryType())), m_callFrame, argument);
 2539         setDouble(result);
 2540     }
 2541 
<a name="27" id="anc27"></a>
















 2542     void compileArithPow()
 2543     {
 2544         if (m_node-&gt;child2().useKind() == Int32Use)
 2545             setDouble(m_out.doublePowi(lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2546         else {
 2547             LValue base = lowDouble(m_node-&gt;child1());
 2548             LValue exponent = lowDouble(m_node-&gt;child2());
 2549 
 2550             LBasicBlock integerExponentIsSmallBlock = m_out.newBlock();
 2551             LBasicBlock integerExponentPowBlock = m_out.newBlock();
 2552             LBasicBlock doubleExponentPowBlockEntry = m_out.newBlock();
 2553             LBasicBlock nanExceptionBaseIsOne = m_out.newBlock();
 2554             LBasicBlock nanExceptionExponentIsInfinity = m_out.newBlock();
 2555             LBasicBlock testExponentIsOneHalf = m_out.newBlock();
 2556             LBasicBlock handleBaseZeroExponentIsOneHalf = m_out.newBlock();
 2557             LBasicBlock handleInfinityForExponentIsOneHalf = m_out.newBlock();
 2558             LBasicBlock exponentIsOneHalfNormal = m_out.newBlock();
 2559             LBasicBlock exponentIsOneHalfInfinity = m_out.newBlock();
 2560             LBasicBlock testExponentIsNegativeOneHalf = m_out.newBlock();
 2561             LBasicBlock testBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
 2562             LBasicBlock handleBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
 2563             LBasicBlock handleInfinityForExponentIsNegativeOneHalf = m_out.newBlock();
 2564             LBasicBlock exponentIsNegativeOneHalfNormal = m_out.newBlock();
 2565             LBasicBlock exponentIsNegativeOneHalfInfinity = m_out.newBlock();
 2566             LBasicBlock powBlock = m_out.newBlock();
 2567             LBasicBlock nanExceptionResultIsNaN = m_out.newBlock();
 2568             LBasicBlock continuation = m_out.newBlock();
 2569 
 2570             LValue integerExponent = m_out.doubleToInt(exponent);
 2571             LValue integerExponentConvertedToDouble = m_out.intToDouble(integerExponent);
 2572             LValue exponentIsInteger = m_out.doubleEqual(exponent, integerExponentConvertedToDouble);
 2573             m_out.branch(exponentIsInteger, unsure(integerExponentIsSmallBlock), unsure(doubleExponentPowBlockEntry));
 2574 
 2575             LBasicBlock lastNext = m_out.appendTo(integerExponentIsSmallBlock, integerExponentPowBlock);
 2576             LValue integerExponentBelowMax = m_out.belowOrEqual(integerExponent, m_out.constInt32(maxExponentForIntegerMathPow));
 2577             m_out.branch(integerExponentBelowMax, usually(integerExponentPowBlock), rarely(doubleExponentPowBlockEntry));
 2578 
 2579             m_out.appendTo(integerExponentPowBlock, doubleExponentPowBlockEntry);
 2580             ValueFromBlock powDoubleIntResult = m_out.anchor(m_out.doublePowi(base, integerExponent));
 2581             m_out.jump(continuation);
 2582 
 2583             // If y is NaN, the result is NaN.
 2584             m_out.appendTo(doubleExponentPowBlockEntry, nanExceptionBaseIsOne);
 2585             LValue exponentIsNaN;
 2586             if (provenType(m_node-&gt;child2()) &amp; SpecDoubleNaN)
 2587                 exponentIsNaN = m_out.doubleNotEqualOrUnordered(exponent, exponent);
 2588             else
 2589                 exponentIsNaN = m_out.booleanFalse;
 2590             m_out.branch(exponentIsNaN, rarely(nanExceptionResultIsNaN), usually(nanExceptionBaseIsOne));
 2591 
 2592             // If abs(x) is 1 and y is +infinity, the result is NaN.
 2593             // If abs(x) is 1 and y is -infinity, the result is NaN.
 2594 
 2595             //     Test if base == 1.
 2596             m_out.appendTo(nanExceptionBaseIsOne, nanExceptionExponentIsInfinity);
 2597             LValue absoluteBase = m_out.doubleAbs(base);
 2598             LValue absoluteBaseIsOne = m_out.doubleEqual(absoluteBase, m_out.constDouble(1));
 2599             m_out.branch(absoluteBaseIsOne, rarely(nanExceptionExponentIsInfinity), usually(testExponentIsOneHalf));
 2600 
 2601             //     Test if abs(y) == Infinity.
 2602             m_out.appendTo(nanExceptionExponentIsInfinity, testExponentIsOneHalf);
 2603             LValue absoluteExponent = m_out.doubleAbs(exponent);
 2604             LValue absoluteExponentIsInfinity = m_out.doubleEqual(absoluteExponent, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2605             m_out.branch(absoluteExponentIsInfinity, rarely(nanExceptionResultIsNaN), usually(testExponentIsOneHalf));
 2606 
 2607             // If y == 0.5 or y == -0.5, handle it through SQRT.
 2608             // We have be carefuly with -0 and -Infinity.
 2609 
 2610             //     Test if y == 0.5
 2611             m_out.appendTo(testExponentIsOneHalf, handleBaseZeroExponentIsOneHalf);
 2612             LValue exponentIsOneHalf = m_out.doubleEqual(exponent, m_out.constDouble(0.5));
 2613             m_out.branch(exponentIsOneHalf, rarely(handleBaseZeroExponentIsOneHalf), usually(testExponentIsNegativeOneHalf));
 2614 
 2615             //     Handle x == -0.
 2616             m_out.appendTo(handleBaseZeroExponentIsOneHalf, handleInfinityForExponentIsOneHalf);
 2617             LValue baseIsZeroExponentIsOneHalf = m_out.doubleEqual(base, m_out.doubleZero);
 2618             ValueFromBlock zeroResultExponentIsOneHalf = m_out.anchor(m_out.doubleZero);
 2619             m_out.branch(baseIsZeroExponentIsOneHalf, rarely(continuation), usually(handleInfinityForExponentIsOneHalf));
 2620 
 2621             //     Test if abs(x) == Infinity.
 2622             m_out.appendTo(handleInfinityForExponentIsOneHalf, exponentIsOneHalfNormal);
 2623             LValue absoluteBaseIsInfinityOneHalf = m_out.doubleEqual(absoluteBase, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2624             m_out.branch(absoluteBaseIsInfinityOneHalf, rarely(exponentIsOneHalfInfinity), usually(exponentIsOneHalfNormal));
 2625 
 2626             //     The exponent is 0.5, the base is finite or NaN, we can use SQRT.
 2627             m_out.appendTo(exponentIsOneHalfNormal, exponentIsOneHalfInfinity);
 2628             ValueFromBlock sqrtResult = m_out.anchor(m_out.doubleSqrt(base));
 2629             m_out.jump(continuation);
 2630 
 2631             //     The exponent is 0.5, the base is infinite, the result is always infinite.
 2632             m_out.appendTo(exponentIsOneHalfInfinity, testExponentIsNegativeOneHalf);
 2633             ValueFromBlock sqrtInfinityResult = m_out.anchor(m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2634             m_out.jump(continuation);
 2635 
 2636             //     Test if y == -0.5
 2637             m_out.appendTo(testExponentIsNegativeOneHalf, testBaseZeroExponentIsNegativeOneHalf);
 2638             LValue exponentIsNegativeOneHalf = m_out.doubleEqual(exponent, m_out.constDouble(-0.5));
 2639             m_out.branch(exponentIsNegativeOneHalf, rarely(testBaseZeroExponentIsNegativeOneHalf), usually(powBlock));
 2640 
 2641             //     Handle x == -0.
 2642             m_out.appendTo(testBaseZeroExponentIsNegativeOneHalf, handleBaseZeroExponentIsNegativeOneHalf);
 2643             LValue baseIsZeroExponentIsNegativeOneHalf = m_out.doubleEqual(base, m_out.doubleZero);
 2644             m_out.branch(baseIsZeroExponentIsNegativeOneHalf, rarely(handleBaseZeroExponentIsNegativeOneHalf), usually(handleInfinityForExponentIsNegativeOneHalf));
 2645 
 2646             m_out.appendTo(handleBaseZeroExponentIsNegativeOneHalf, handleInfinityForExponentIsNegativeOneHalf);
 2647             ValueFromBlock oneOverSqrtZeroResult = m_out.anchor(m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2648             m_out.jump(continuation);
 2649 
 2650             //     Test if abs(x) == Infinity.
 2651             m_out.appendTo(handleInfinityForExponentIsNegativeOneHalf, exponentIsNegativeOneHalfNormal);
 2652             LValue absoluteBaseIsInfinityNegativeOneHalf = m_out.doubleEqual(absoluteBase, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2653             m_out.branch(absoluteBaseIsInfinityNegativeOneHalf, rarely(exponentIsNegativeOneHalfInfinity), usually(exponentIsNegativeOneHalfNormal));
 2654 
 2655             //     The exponent is -0.5, the base is finite or NaN, we can use 1/SQRT.
 2656             m_out.appendTo(exponentIsNegativeOneHalfNormal, exponentIsNegativeOneHalfInfinity);
 2657             LValue sqrtBase = m_out.doubleSqrt(base);
 2658             ValueFromBlock oneOverSqrtResult = m_out.anchor(m_out.div(m_out.constDouble(1.), sqrtBase));
 2659             m_out.jump(continuation);
 2660 
 2661             //     The exponent is -0.5, the base is infinite, the result is always zero.
 2662             m_out.appendTo(exponentIsNegativeOneHalfInfinity, powBlock);
 2663             ValueFromBlock oneOverSqrtInfinityResult = m_out.anchor(m_out.doubleZero);
 2664             m_out.jump(continuation);
 2665 
 2666             m_out.appendTo(powBlock, nanExceptionResultIsNaN);
 2667             ValueFromBlock powResult = m_out.anchor(m_out.doublePow(base, exponent));
 2668             m_out.jump(continuation);
 2669 
 2670             m_out.appendTo(nanExceptionResultIsNaN, continuation);
 2671             ValueFromBlock pureNan = m_out.anchor(m_out.constDouble(PNaN));
 2672             m_out.jump(continuation);
 2673 
 2674             m_out.appendTo(continuation, lastNext);
 2675             setDouble(m_out.phi(Double, powDoubleIntResult, zeroResultExponentIsOneHalf, sqrtResult, sqrtInfinityResult, oneOverSqrtZeroResult, oneOverSqrtResult, oneOverSqrtInfinityResult, powResult, pureNan));
 2676         }
 2677     }
 2678 
 2679     void compileArithRandom()
 2680     {
 2681         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 2682 
 2683         // Inlined WeakRandom::advance().
 2684         // uint64_t x = m_low;
 2685         void* lowAddress = reinterpret_cast&lt;uint8_t*&gt;(globalObject) + JSGlobalObject::weakRandomOffset() + WeakRandom::lowOffset();
 2686         LValue low = m_out.load64(m_out.absolute(lowAddress));
 2687         // uint64_t y = m_high;
 2688         void* highAddress = reinterpret_cast&lt;uint8_t*&gt;(globalObject) + JSGlobalObject::weakRandomOffset() + WeakRandom::highOffset();
 2689         LValue high = m_out.load64(m_out.absolute(highAddress));
 2690         // m_low = y;
 2691         m_out.store64(high, m_out.absolute(lowAddress));
 2692 
 2693         // x ^= x &lt;&lt; 23;
 2694         LValue phase1 = m_out.bitXor(m_out.shl(low, m_out.constInt64(23)), low);
 2695 
 2696         // x ^= x &gt;&gt; 17;
 2697         LValue phase2 = m_out.bitXor(m_out.lShr(phase1, m_out.constInt64(17)), phase1);
 2698 
 2699         // x ^= y ^ (y &gt;&gt; 26);
 2700         LValue phase3 = m_out.bitXor(m_out.bitXor(high, m_out.lShr(high, m_out.constInt64(26))), phase2);
 2701 
 2702         // m_high = x;
 2703         m_out.store64(phase3, m_out.absolute(highAddress));
 2704 
 2705         // return x + y;
 2706         LValue random64 = m_out.add(phase3, high);
 2707 
 2708         // Extract random 53bit. [0, 53] bit is safe integer number ranges in double representation.
 2709         LValue random53 = m_out.bitAnd(random64, m_out.constInt64((1ULL &lt;&lt; 53) - 1));
 2710 
 2711         LValue double53Integer = m_out.intToDouble(random53);
 2712 
 2713         // Convert `(53bit double integer value) / (1 &lt;&lt; 53)` to `(53bit double integer value) * (1.0 / (1 &lt;&lt; 53))`.
 2714         // In latter case, `1.0 / (1 &lt;&lt; 53)` will become a double value represented as (mantissa = 0 &amp; exp = 970, it means 1e-(2**54)).
 2715         static const double scale = 1.0 / (1ULL &lt;&lt; 53);
 2716 
 2717         // Multiplying 1e-(2**54) with the double integer does not change anything of the mantissa part of the double integer.
 2718         // It just reduces the exp part of the given 53bit double integer.
 2719         // (Except for 0.0. This is specially handled and in this case, exp just becomes 0.)
 2720         // Now we get 53bit precision random double value in [0, 1).
 2721         LValue result = m_out.doubleMul(double53Integer, m_out.constDouble(scale));
 2722 
 2723         setDouble(result);
 2724     }
 2725 
 2726     void compileArithRound()
 2727     {
 2728         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2729             LValue result = nullptr;
 2730             if (producesInteger(m_node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())) {
 2731                 LValue value = lowDouble(m_node-&gt;child1());
 2732                 result = m_out.doubleFloor(m_out.doubleAdd(value, m_out.constDouble(0.5)));
 2733             } else {
 2734                 LBasicBlock realPartIsMoreThanHalf = m_out.newBlock();
 2735                 LBasicBlock continuation = m_out.newBlock();
 2736 
 2737                 LValue value = lowDouble(m_node-&gt;child1());
 2738                 LValue integerValue = m_out.doubleCeil(value);
 2739                 ValueFromBlock integerValueResult = m_out.anchor(integerValue);
 2740 
 2741                 LValue realPart = m_out.doubleSub(integerValue, value);
 2742 
 2743                 m_out.branch(m_out.doubleGreaterThanOrUnordered(realPart, m_out.constDouble(0.5)), unsure(realPartIsMoreThanHalf), unsure(continuation));
 2744 
 2745                 LBasicBlock lastNext = m_out.appendTo(realPartIsMoreThanHalf, continuation);
 2746                 LValue integerValueRoundedDown = m_out.doubleSub(integerValue, m_out.constDouble(1));
 2747                 ValueFromBlock integerValueRoundedDownResult = m_out.anchor(integerValueRoundedDown);
 2748                 m_out.jump(continuation);
 2749                 m_out.appendTo(continuation, lastNext);
 2750 
 2751                 result = m_out.phi(Double, integerValueResult, integerValueRoundedDownResult);
 2752             }
 2753 
 2754             if (producesInteger(m_node-&gt;arithRoundingMode())) {
 2755                 LValue integerValue = convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode()));
 2756                 setInt32(integerValue);
 2757             } else
 2758                 setDouble(result);
 2759             return;
 2760         }
 2761 
 2762         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2763         LValue argument = lowJSValue(m_node-&gt;child1());
 2764         setJSValue(vmCall(Int64, m_out.operation(operationArithRound), m_callFrame, argument));
 2765     }
 2766 
 2767     void compileArithFloor()
 2768     {
 2769         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2770             LValue value = lowDouble(m_node-&gt;child1());
 2771             LValue integerValue = m_out.doubleFloor(value);
 2772             if (producesInteger(m_node-&gt;arithRoundingMode()))
 2773                 setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 2774             else
 2775                 setDouble(integerValue);
 2776             return;
 2777         }
 2778         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2779         LValue argument = lowJSValue(m_node-&gt;child1());
 2780         setJSValue(vmCall(Int64, m_out.operation(operationArithFloor), m_callFrame, argument));
 2781     }
 2782 
 2783     void compileArithCeil()
 2784     {
 2785         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2786             LValue value = lowDouble(m_node-&gt;child1());
 2787             LValue integerValue = m_out.doubleCeil(value);
 2788             if (producesInteger(m_node-&gt;arithRoundingMode()))
 2789                 setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 2790             else
 2791                 setDouble(integerValue);
 2792             return;
 2793         }
 2794         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2795         LValue argument = lowJSValue(m_node-&gt;child1());
 2796         setJSValue(vmCall(Int64, m_out.operation(operationArithCeil), m_callFrame, argument));
 2797     }
 2798 
 2799     void compileArithTrunc()
 2800     {
 2801         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2802             LValue value = lowDouble(m_node-&gt;child1());
 2803             LValue result = m_out.doubleTrunc(value);
 2804             if (producesInteger(m_node-&gt;arithRoundingMode()))
 2805                 setInt32(convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 2806             else
 2807                 setDouble(result);
 2808             return;
 2809         }
 2810         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2811         LValue argument = lowJSValue(m_node-&gt;child1());
 2812         setJSValue(vmCall(Int64, m_out.operation(operationArithTrunc), m_callFrame, argument));
 2813     }
 2814 
 2815     void compileArithSqrt()
 2816     {
 2817         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2818             setDouble(m_out.doubleSqrt(lowDouble(m_node-&gt;child1())));
 2819             return;
 2820         }
 2821         LValue argument = lowJSValue(m_node-&gt;child1());
 2822         LValue result = vmCall(Double, m_out.operation(operationArithSqrt), m_callFrame, argument);
 2823         setDouble(result);
 2824     }
 2825 
 2826     void compileArithFRound()
 2827     {
 2828         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2829             setDouble(m_out.fround(lowDouble(m_node-&gt;child1())));
 2830             return;
 2831         }
 2832         LValue argument = lowJSValue(m_node-&gt;child1());
 2833         LValue result = vmCall(Double, m_out.operation(operationArithFRound), m_callFrame, argument);
 2834         setDouble(result);
 2835     }
 2836 
 2837     void compileValueNegate()
 2838     {
 2839         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
 2840         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="28" id="anc28"></a><span class="line-modified"> 2841         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 2842         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
 2843         auto repatchingFunction = operationArithNegateOptimize;
 2844         auto nonRepatchingFunction = operationArithNegate;
<a name="29" id="anc29"></a><span class="line-modified"> 2845         compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
 2846     }
 2847 
 2848     void compileArithNegate()
 2849     {
 2850         switch (m_node-&gt;child1().useKind()) {
 2851         case Int32Use: {
 2852             LValue value = lowInt32(m_node-&gt;child1());
 2853 
 2854             LValue result;
 2855             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 2856                 result = m_out.neg(value);
 2857             else if (!shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2858                 CheckValue* check = m_out.speculateSub(m_out.int32Zero, value);
 2859                 blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 2860                 result = check;
 2861             } else {
 2862                 speculate(Overflow, noValue(), 0, m_out.testIsZero32(value, m_out.constInt32(0x7fffffff)));
 2863                 result = m_out.neg(value);
 2864             }
 2865 
 2866             setInt32(result);
 2867             break;
 2868         }
 2869 
 2870         case Int52RepUse: {
<a name="30" id="anc30"></a><span class="line-modified"> 2871             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecInt52Only)) {</span>
 2872                 Int52Kind kind;
 2873                 LValue value = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2874                 LValue result = m_out.neg(value);
 2875                 if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 2876                     speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 2877                 setInt52(result, kind);
 2878                 break;
 2879             }
 2880 
 2881             LValue value = lowInt52(m_node-&gt;child1());
 2882             CheckValue* result = m_out.speculateSub(m_out.int64Zero, value);
 2883             blessSpeculation(result, Int52Overflow, noValue(), nullptr, m_origin);
 2884             if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 2885                 speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 2886             setInt52(result);
 2887             break;
 2888         }
 2889 
 2890         case DoubleRepUse: {
 2891             setDouble(m_out.doubleNeg(lowDouble(m_node-&gt;child1())));
 2892             break;
 2893         }
 2894 
 2895         default:
 2896             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2897             break;
 2898         }
 2899     }
 2900 
<a name="31" id="anc31"></a><span class="line-modified"> 2901     void compileArithBitNot()</span>
 2902     {
<a name="32" id="anc32"></a><span class="line-modified"> 2903         if (m_node-&gt;child1().useKind() == UntypedUse) {</span>
<span class="line-modified"> 2904             LValue operand = lowJSValue(m_node-&gt;child1());</span>
<span class="line-modified"> 2905             LValue result = vmCall(Int64, m_out.operation(operationValueBitNot), m_callFrame, operand);</span>
 2906             setJSValue(result);
 2907             return;
 2908         }
 2909 
<a name="33" id="anc33"></a>






 2910         setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
 2911     }
 2912 
 2913     void compileValueBitAnd()
 2914     {
 2915         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2916             LValue left = lowBigInt(m_node-&gt;child1());
 2917             LValue right = lowBigInt(m_node-&gt;child2());
 2918 
 2919             LValue result = vmCall(pointerType(), m_out.operation(operationBitAndBigInt), m_callFrame, left, right);
 2920             setJSValue(result);
 2921             return;
 2922         }
 2923 
 2924         emitBinaryBitOpSnippet&lt;JITBitAndGenerator&gt;(operationValueBitAnd);
 2925     }
 2926 
 2927     void compileArithBitAnd()
 2928     {
 2929         setInt32(m_out.bitAnd(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2930     }
 2931 
 2932     void compileValueBitOr()
 2933     {
 2934         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2935             LValue left = lowBigInt(m_node-&gt;child1());
 2936             LValue right = lowBigInt(m_node-&gt;child2());
 2937 
 2938             LValue result = vmCall(pointerType(), m_out.operation(operationBitOrBigInt), m_callFrame, left, right);
 2939             setJSValue(result);
 2940             return;
 2941         }
 2942 
 2943         emitBinaryBitOpSnippet&lt;JITBitOrGenerator&gt;(operationValueBitOr);
 2944     }
 2945 
 2946     void compileArithBitOr()
 2947     {
 2948         setInt32(m_out.bitOr(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2949     }
 2950 
 2951     void compileValueBitXor()
 2952     {
 2953         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2954             LValue left = lowBigInt(m_node-&gt;child1());
 2955             LValue right = lowBigInt(m_node-&gt;child2());
 2956 
 2957             LValue result = vmCall(pointerType(), m_out.operation(operationBitXorBigInt), m_callFrame, left, right);
 2958             setJSValue(result);
 2959             return;
 2960         }
 2961 
 2962         emitBinaryBitOpSnippet&lt;JITBitXorGenerator&gt;(operationValueBitXor);
 2963     }
 2964 
 2965     void compileArithBitXor()
 2966     {
 2967         setInt32(m_out.bitXor(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2968     }
 2969 
 2970     void compileBitRShift()
 2971     {
 2972         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 2973             emitRightShiftSnippet(JITRightShiftGenerator::SignedShift);
 2974             return;
 2975         }
 2976         setInt32(m_out.aShr(
 2977             lowInt32(m_node-&gt;child1()),
 2978             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 2979     }
 2980 
<a name="34" id="anc34"></a><span class="line-modified"> 2981     void compileBitLShift()</span>
 2982     {
<a name="35" id="anc35"></a><span class="line-removed"> 2983         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {</span>
<span class="line-removed"> 2984             emitBinaryBitOpSnippet&lt;JITLeftShiftGenerator&gt;(operationValueBitLShift);</span>
<span class="line-removed"> 2985             return;</span>
<span class="line-removed"> 2986         }</span>
 2987         setInt32(m_out.shl(
 2988             lowInt32(m_node-&gt;child1()),
 2989             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 2990     }
 2991 
<a name="36" id="anc36"></a>














 2992     void compileBitURShift()
 2993     {
 2994         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 2995             emitRightShiftSnippet(JITRightShiftGenerator::UnsignedShift);
 2996             return;
 2997         }
 2998         setInt32(m_out.lShr(
 2999             lowInt32(m_node-&gt;child1()),
 3000             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3001     }
 3002 
 3003     void compileUInt32ToNumber()
 3004     {
 3005         LValue value = lowInt32(m_node-&gt;child1());
 3006 
 3007         if (doesOverflow(m_node-&gt;arithMode())) {
 3008             setStrictInt52(m_out.zeroExtPtr(value));
 3009             return;
 3010         }
 3011 
 3012         speculate(Overflow, noValue(), 0, m_out.lessThan(value, m_out.int32Zero));
 3013         setInt32(value);
 3014     }
 3015 
 3016     void compileCheckStructure()
 3017     {
 3018         ExitKind exitKind;
 3019         if (m_node-&gt;child1()-&gt;hasConstant())
 3020             exitKind = BadConstantCache;
 3021         else
 3022             exitKind = BadCache;
 3023 
 3024         switch (m_node-&gt;child1().useKind()) {
 3025         case CellUse:
 3026         case KnownCellUse: {
 3027             LValue cell = lowCell(m_node-&gt;child1());
 3028 
 3029             checkStructure(
 3030                 m_out.load32(cell, m_heaps.JSCell_structureID), jsValueValue(cell),
 3031                 exitKind, m_node-&gt;structureSet(),
 3032                 [&amp;] (RegisteredStructure structure) {
 3033                     return weakStructureID(structure);
 3034                 });
 3035             return;
 3036         }
 3037 
 3038         case CellOrOtherUse: {
 3039             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 3040 
 3041             LBasicBlock cellCase = m_out.newBlock();
 3042             LBasicBlock notCellCase = m_out.newBlock();
 3043             LBasicBlock continuation = m_out.newBlock();
 3044 
 3045             m_out.branch(
 3046                 isCell(value, provenType(m_node-&gt;child1())), unsure(cellCase), unsure(notCellCase));
 3047 
 3048             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
 3049             checkStructure(
 3050                 m_out.load32(value, m_heaps.JSCell_structureID), jsValueValue(value),
 3051                 exitKind, m_node-&gt;structureSet(),
 3052                 [&amp;] (RegisteredStructure structure) {
 3053                     return weakStructureID(structure);
 3054                 });
 3055             m_out.jump(continuation);
 3056 
 3057             m_out.appendTo(notCellCase, continuation);
 3058             FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), SpecCell | SpecOther, isNotOther(value));
 3059             m_out.jump(continuation);
 3060 
 3061             m_out.appendTo(continuation, lastNext);
 3062             return;
 3063         }
 3064 
 3065         default:
 3066             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3067             return;
 3068         }
 3069     }
 3070 
 3071     void compileCheckStructureOrEmpty()
 3072     {
 3073         ExitKind exitKind;
 3074         if (m_node-&gt;child1()-&gt;hasConstant())
 3075             exitKind = BadConstantCache;
 3076         else
 3077             exitKind = BadCache;
 3078 
 3079         LValue cell = lowCell(m_node-&gt;child1());
 3080         bool maySeeEmptyValue = m_interpreter.forNode(m_node-&gt;child1()).m_type &amp; SpecEmpty;
 3081         LBasicBlock notEmpty;
 3082         LBasicBlock continuation;
 3083         LBasicBlock lastNext;
 3084         if (maySeeEmptyValue) {
 3085             notEmpty = m_out.newBlock();
 3086             continuation = m_out.newBlock();
 3087             m_out.branch(m_out.isZero64(cell), unsure(continuation), unsure(notEmpty));
 3088             lastNext = m_out.appendTo(notEmpty, continuation);
 3089         }
 3090 
 3091         checkStructure(
 3092             m_out.load32(cell, m_heaps.JSCell_structureID), jsValueValue(cell),
 3093             exitKind, m_node-&gt;structureSet(),
 3094             [&amp;] (RegisteredStructure structure) {
 3095                 return weakStructureID(structure);
 3096             });
 3097 
 3098         if (maySeeEmptyValue) {
 3099             m_out.jump(continuation);
 3100             m_out.appendTo(continuation, lastNext);
 3101         }
 3102     }
 3103 
 3104     void compileCheckCell()
 3105     {
 3106         LValue cell = lowCell(m_node-&gt;child1());
 3107 
 3108         speculate(
 3109             BadCell, jsValueValue(cell), m_node-&gt;child1().node(),
 3110             m_out.notEqual(cell, weakPointer(m_node-&gt;cellOperand()-&gt;cell())));
 3111     }
 3112 
 3113     void compileCheckBadCell()
 3114     {
 3115         terminate(BadCell);
 3116     }
 3117 
 3118     void compileCheckNotEmpty()
 3119     {
 3120         speculate(TDZFailure, noValue(), nullptr, m_out.isZero64(lowJSValue(m_node-&gt;child1())));
 3121     }
 3122 
 3123     void compileAssertNotEmpty()
 3124     {
 3125         if (!validationEnabled())
 3126             return;
 3127 
 3128         LValue val = lowJSValue(m_node-&gt;child1());
 3129         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 3130         patchpoint-&gt;appendSomeRegister(val);
 3131         patchpoint-&gt;setGenerator(
 3132             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 3133                 AllowMacroScratchRegisterUsage allowScratch(jit);
 3134                 GPRReg input =  params[0].gpr();
 3135                 CCallHelpers::Jump done = jit.branchIfNotEmpty(input);
 3136                 jit.breakpoint();
 3137                 done.link(&amp;jit);
 3138             });
 3139     }
 3140 
 3141     void compileCheckStringIdent()
 3142     {
 3143         UniquedStringImpl* uid = m_node-&gt;uidOperand();
 3144         LValue stringImpl = lowStringIdent(m_node-&gt;child1());
 3145         speculate(BadIdent, noValue(), nullptr, m_out.notEqual(stringImpl, m_out.constIntPtr(uid)));
 3146     }
 3147 
 3148     void compileGetExecutable()
 3149     {
 3150         LValue cell = lowCell(m_node-&gt;child1());
 3151         speculateFunction(m_node-&gt;child1(), cell);
 3152         setJSValue(m_out.loadPtr(cell, m_heaps.JSFunction_executable));
 3153     }
 3154 
 3155     void compileArrayify()
 3156     {
 3157         LValue cell = lowCell(m_node-&gt;child1());
 3158         LValue property = !!m_node-&gt;child2() ? lowInt32(m_node-&gt;child2()) : 0;
 3159 
 3160         LBasicBlock unexpectedStructure = m_out.newBlock();
 3161         LBasicBlock continuation = m_out.newBlock();
 3162 
 3163         auto isUnexpectedArray = [&amp;] (LValue cell) {
 3164             if (m_node-&gt;op() == Arrayify)
 3165                 return m_out.logicalNot(isArrayTypeForArrayify(cell, m_node-&gt;arrayMode()));
 3166 
 3167             ASSERT(m_node-&gt;op() == ArrayifyToStructure);
 3168             return m_out.notEqual(m_out.load32(cell, m_heaps.JSCell_structureID), weakStructureID(m_node-&gt;structure()));
 3169         };
 3170 
 3171         m_out.branch(isUnexpectedArray(cell), rarely(unexpectedStructure), usually(continuation));
 3172 
 3173         LBasicBlock lastNext = m_out.appendTo(unexpectedStructure, continuation);
 3174 
 3175         if (property) {
 3176             switch (m_node-&gt;arrayMode().type()) {
 3177             case Array::Int32:
 3178             case Array::Double:
 3179             case Array::Contiguous:
 3180                 speculate(
 3181                     Uncountable, noValue(), 0,
 3182                     m_out.aboveOrEqual(property, m_out.constInt32(MIN_SPARSE_ARRAY_INDEX)));
 3183                 break;
 3184             default:
 3185                 break;
 3186             }
 3187         }
 3188 
 3189         switch (m_node-&gt;arrayMode().type()) {
 3190         case Array::Int32:
 3191             vmCall(Void, m_out.operation(operationEnsureInt32), m_callFrame, cell);
 3192             break;
 3193         case Array::Double:
 3194             vmCall(Void, m_out.operation(operationEnsureDouble), m_callFrame, cell);
 3195             break;
 3196         case Array::Contiguous:
 3197             vmCall(Void, m_out.operation(operationEnsureContiguous), m_callFrame, cell);
 3198             break;
 3199         case Array::ArrayStorage:
 3200         case Array::SlowPutArrayStorage:
 3201             vmCall(Void, m_out.operation(operationEnsureArrayStorage), m_callFrame, cell);
 3202             break;
 3203         default:
 3204             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 3205             break;
 3206         }
 3207 
 3208         speculate(BadIndexingType, jsValueValue(cell), 0, isUnexpectedArray(cell));
 3209         m_out.jump(continuation);
 3210 
 3211         m_out.appendTo(continuation, lastNext);
 3212     }
 3213 
 3214     void compilePutStructure()
 3215     {
 3216         m_ftlState.jitCode-&gt;common.notifyCompilingStructureTransition(m_graph.m_plan, codeBlock(), m_node);
 3217 
 3218         RegisteredStructure oldStructure = m_node-&gt;transition()-&gt;previous;
 3219         RegisteredStructure newStructure = m_node-&gt;transition()-&gt;next;
 3220         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
 3221         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
 3222         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
 3223 
 3224         LValue cell = lowCell(m_node-&gt;child1());
 3225         m_out.store32(
 3226             weakStructureID(newStructure),
 3227             cell, m_heaps.JSCell_structureID);
 3228     }
 3229 
 3230     void compileGetById(AccessType type)
 3231     {
 3232         ASSERT(type == AccessType::Get || type == AccessType::TryGet || type == AccessType::GetDirect);
 3233         switch (m_node-&gt;child1().useKind()) {
 3234         case CellUse: {
 3235             setJSValue(getById(lowCell(m_node-&gt;child1()), type));
 3236             return;
 3237         }
 3238 
 3239         case UntypedUse: {
 3240             // This is pretty weird, since we duplicate the slow path both here and in the
 3241             // code generated by the IC. We should investigate making this less bad.
 3242             // https://bugs.webkit.org/show_bug.cgi?id=127830
 3243             LValue value = lowJSValue(m_node-&gt;child1());
 3244 
 3245             LBasicBlock cellCase = m_out.newBlock();
 3246             LBasicBlock notCellCase = m_out.newBlock();
 3247             LBasicBlock continuation = m_out.newBlock();
 3248 
 3249             m_out.branch(
 3250                 isCell(value, provenType(m_node-&gt;child1())), unsure(cellCase), unsure(notCellCase));
 3251 
 3252             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
 3253             ValueFromBlock cellResult = m_out.anchor(getById(value, type));
 3254             m_out.jump(continuation);
 3255 
 3256             J_JITOperation_EJI getByIdFunction = appropriateGenericGetByIdFunction(type);
 3257 
 3258             m_out.appendTo(notCellCase, continuation);
 3259             ValueFromBlock notCellResult = m_out.anchor(vmCall(
 3260                 Int64, m_out.operation(getByIdFunction),
 3261                 m_callFrame, value,
 3262                 m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 3263             m_out.jump(continuation);
 3264 
 3265             m_out.appendTo(continuation, lastNext);
 3266             setJSValue(m_out.phi(Int64, cellResult, notCellResult));
 3267             return;
 3268         }
 3269 
 3270         default:
 3271             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3272             return;
 3273         }
 3274     }
 3275 
 3276     void compileGetByIdWithThis()
 3277     {
 3278         if (m_node-&gt;child1().useKind() == CellUse &amp;&amp; m_node-&gt;child2().useKind() == CellUse)
 3279             setJSValue(getByIdWithThis(lowCell(m_node-&gt;child1()), lowCell(m_node-&gt;child2())));
 3280         else {
 3281             LValue base = lowJSValue(m_node-&gt;child1());
 3282             LValue thisValue = lowJSValue(m_node-&gt;child2());
 3283 
 3284             LBasicBlock baseCellCase = m_out.newBlock();
 3285             LBasicBlock notCellCase = m_out.newBlock();
 3286             LBasicBlock thisValueCellCase = m_out.newBlock();
 3287             LBasicBlock continuation = m_out.newBlock();
 3288 
 3289             m_out.branch(
 3290                 isCell(base, provenType(m_node-&gt;child1())), unsure(baseCellCase), unsure(notCellCase));
 3291 
 3292             LBasicBlock lastNext = m_out.appendTo(baseCellCase, thisValueCellCase);
 3293 
 3294             m_out.branch(
 3295                 isCell(thisValue, provenType(m_node-&gt;child2())), unsure(thisValueCellCase), unsure(notCellCase));
 3296 
 3297             m_out.appendTo(thisValueCellCase, notCellCase);
 3298             ValueFromBlock cellResult = m_out.anchor(getByIdWithThis(base, thisValue));
 3299             m_out.jump(continuation);
 3300 
 3301             m_out.appendTo(notCellCase, continuation);
 3302             ValueFromBlock notCellResult = m_out.anchor(vmCall(
 3303                 Int64, m_out.operation(operationGetByIdWithThisGeneric),
 3304                 m_callFrame, base, thisValue,
 3305                 m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 3306             m_out.jump(continuation);
 3307 
 3308             m_out.appendTo(continuation, lastNext);
 3309             setJSValue(m_out.phi(Int64, cellResult, notCellResult));
 3310         }
 3311 
 3312     }
 3313 
 3314     void compileGetByValWithThis()
 3315     {
 3316         LValue base = lowJSValue(m_node-&gt;child1());
 3317         LValue thisValue = lowJSValue(m_node-&gt;child2());
 3318         LValue subscript = lowJSValue(m_node-&gt;child3());
 3319 
 3320         LValue result = vmCall(Int64, m_out.operation(operationGetByValWithThis), m_callFrame, base, thisValue, subscript);
 3321         setJSValue(result);
 3322     }
 3323 
 3324     void compilePutByIdWithThis()
 3325     {
 3326         LValue base = lowJSValue(m_node-&gt;child1());
 3327         LValue thisValue = lowJSValue(m_node-&gt;child2());
 3328         LValue value = lowJSValue(m_node-&gt;child3());
 3329 
 3330         vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis),
 3331             m_callFrame, base, thisValue, value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()]));
 3332     }
 3333 
 3334     void compilePutByValWithThis()
 3335     {
 3336         LValue base = lowJSValue(m_graph.varArgChild(m_node, 0));
 3337         LValue thisValue = lowJSValue(m_graph.varArgChild(m_node, 1));
 3338         LValue property = lowJSValue(m_graph.varArgChild(m_node, 2));
 3339         LValue value = lowJSValue(m_graph.varArgChild(m_node, 3));
 3340 
 3341         vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis),
 3342             m_callFrame, base, thisValue, property, value);
 3343     }
 3344 
 3345     void compileAtomicsReadModifyWrite()
 3346     {
 3347         TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
 3348         unsigned numExtraArgs = numExtraAtomicsArgs(m_node-&gt;op());
 3349         Edge baseEdge = m_graph.child(m_node, 0);
 3350         Edge indexEdge = m_graph.child(m_node, 1);
 3351         Edge argEdges[maxNumExtraAtomicsArgs];
 3352         for (unsigned i = numExtraArgs; i--;)
 3353             argEdges[i] = m_graph.child(m_node, 2 + i);
 3354         Edge storageEdge = m_graph.child(m_node, 2 + numExtraArgs);
 3355 
 3356         auto operation = [&amp;] () -&gt; LValue {
 3357             switch (m_node-&gt;op()) {
 3358             case AtomicsAdd:
 3359                 return m_out.operation(operationAtomicsAdd);
 3360             case AtomicsAnd:
 3361                 return m_out.operation(operationAtomicsAnd);
 3362             case AtomicsCompareExchange:
 3363                 return m_out.operation(operationAtomicsCompareExchange);
 3364             case AtomicsExchange:
 3365                 return m_out.operation(operationAtomicsExchange);
 3366             case AtomicsLoad:
 3367                 return m_out.operation(operationAtomicsLoad);
 3368             case AtomicsOr:
 3369                 return m_out.operation(operationAtomicsOr);
 3370             case AtomicsStore:
 3371                 return m_out.operation(operationAtomicsStore);
 3372             case AtomicsSub:
 3373                 return m_out.operation(operationAtomicsSub);
 3374             case AtomicsXor:
 3375                 return m_out.operation(operationAtomicsXor);
 3376             default:
 3377                 RELEASE_ASSERT_NOT_REACHED();
 3378                 break;
 3379             }
 3380         };
 3381 
 3382         if (!storageEdge) {
 3383             Vector&lt;LValue&gt; args;
 3384             args.append(m_callFrame);
 3385             args.append(lowJSValue(baseEdge));
 3386             args.append(lowJSValue(indexEdge));
 3387             for (unsigned i = 0; i &lt; numExtraArgs; ++i)
 3388                 args.append(lowJSValue(argEdges[i]));
 3389             LValue result = vmCall(Int64, operation(), args);
 3390             setJSValue(result);
 3391             return;
 3392         }
 3393 
 3394         LValue index = lowInt32(indexEdge);
 3395         LValue args[2];
 3396         for (unsigned i = numExtraArgs; i--;)
 3397             args[i] = getIntTypedArrayStoreOperand(argEdges[i]);
 3398         LValue storage = lowStorage(storageEdge);
 3399 
 3400         TypedPointer pointer = pointerIntoTypedArray(storage, index, type);
 3401         Width width = widthForBytes(elementSize(type));
 3402 
 3403         LValue atomicValue;
 3404         LValue result;
 3405 
 3406         auto sanitizeResult = [&amp;] (LValue value) -&gt; LValue {
 3407             if (isSigned(type)) {
 3408                 switch (elementSize(type)) {
 3409                 case 1:
 3410                     value = m_out.bitAnd(value, m_out.constInt32(0xff));
 3411                     break;
 3412                 case 2:
 3413                     value = m_out.bitAnd(value, m_out.constInt32(0xffff));
 3414                     break;
 3415                 case 4:
 3416                     break;
 3417                 default:
 3418                     RELEASE_ASSERT_NOT_REACHED();
 3419                     break;
 3420                 }
 3421             }
 3422             return value;
 3423         };
 3424 
 3425         switch (m_node-&gt;op()) {
 3426         case AtomicsAdd:
 3427             atomicValue = m_out.atomicXchgAdd(args[0], pointer, width);
 3428             result = sanitizeResult(atomicValue);
 3429             break;
 3430         case AtomicsAnd:
 3431             atomicValue = m_out.atomicXchgAnd(args[0], pointer, width);
 3432             result = sanitizeResult(atomicValue);
 3433             break;
 3434         case AtomicsCompareExchange:
 3435             atomicValue = m_out.atomicStrongCAS(args[0], args[1], pointer, width);
 3436             result = sanitizeResult(atomicValue);
 3437             break;
 3438         case AtomicsExchange:
 3439             atomicValue = m_out.atomicXchg(args[0], pointer, width);
 3440             result = sanitizeResult(atomicValue);
 3441             break;
 3442         case AtomicsLoad:
 3443             atomicValue = m_out.atomicXchgAdd(m_out.int32Zero, pointer, width);
 3444             result = sanitizeResult(atomicValue);
 3445             break;
 3446         case AtomicsOr:
 3447             atomicValue = m_out.atomicXchgOr(args[0], pointer, width);
 3448             result = sanitizeResult(atomicValue);
 3449             break;
 3450         case AtomicsStore:
 3451             atomicValue = m_out.atomicXchg(args[0], pointer, width);
 3452             result = args[0];
 3453             break;
 3454         case AtomicsSub:
 3455             atomicValue = m_out.atomicXchgSub(args[0], pointer, width);
 3456             result = sanitizeResult(atomicValue);
 3457             break;
 3458         case AtomicsXor:
 3459             atomicValue = m_out.atomicXchgXor(args[0], pointer, width);
 3460             result = sanitizeResult(atomicValue);
 3461             break;
 3462         default:
 3463             RELEASE_ASSERT_NOT_REACHED();
 3464             break;
 3465         }
 3466         // Signify that the state against which the atomic operations are serialized is confined to just
 3467         // the typed array storage, since that&#39;s as precise of an abstraction as we can have of shared
 3468         // array buffer storage.
 3469         m_heaps.decorateFencedAccess(&amp;m_heaps.typedArrayProperties, atomicValue);
 3470 
 3471         setIntTypedArrayLoadResult(result, type);
 3472     }
 3473 
 3474     void compileAtomicsIsLockFree()
 3475     {
 3476         if (m_node-&gt;child1().useKind() != Int32Use) {
 3477             setJSValue(vmCall(Int64, m_out.operation(operationAtomicsIsLockFree), m_callFrame, lowJSValue(m_node-&gt;child1())));
 3478             return;
 3479         }
 3480 
 3481         LValue bytes = lowInt32(m_node-&gt;child1());
 3482 
 3483         LBasicBlock trueCase = m_out.newBlock();
 3484         LBasicBlock falseCase = m_out.newBlock();
 3485         LBasicBlock continuation = m_out.newBlock();
 3486 
 3487         LBasicBlock lastNext = m_out.insertNewBlocksBefore(trueCase);
 3488 
 3489         Vector&lt;SwitchCase&gt; cases;
 3490         cases.append(SwitchCase(m_out.constInt32(1), trueCase, Weight()));
 3491         cases.append(SwitchCase(m_out.constInt32(2), trueCase, Weight()));
 3492         cases.append(SwitchCase(m_out.constInt32(4), trueCase, Weight()));
 3493         m_out.switchInstruction(bytes, cases, falseCase, Weight());
 3494 
 3495         m_out.appendTo(trueCase, falseCase);
 3496         ValueFromBlock trueValue = m_out.anchor(m_out.booleanTrue);
 3497         m_out.jump(continuation);
 3498         m_out.appendTo(falseCase, continuation);
 3499         ValueFromBlock falseValue = m_out.anchor(m_out.booleanFalse);
 3500         m_out.jump(continuation);
 3501 
 3502         m_out.appendTo(continuation, lastNext);
 3503         setBoolean(m_out.phi(Int32, trueValue, falseValue));
 3504     }
 3505 
 3506     void compileDefineDataProperty()
 3507     {
 3508         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3509         LValue value  = lowJSValue(m_graph.varArgChild(m_node, 2));
 3510         LValue attributes = lowInt32(m_graph.varArgChild(m_node, 3));
 3511         Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
 3512         switch (propertyEdge.useKind()) {
 3513         case StringUse: {
 3514             LValue property = lowString(propertyEdge);
 3515             vmCall(Void, m_out.operation(operationDefineDataPropertyString), m_callFrame, base, property, value, attributes);
 3516             break;
 3517         }
 3518         case StringIdentUse: {
 3519             LValue property = lowStringIdent(propertyEdge);
 3520             vmCall(Void, m_out.operation(operationDefineDataPropertyStringIdent), m_callFrame, base, property, value, attributes);
 3521             break;
 3522         }
 3523         case SymbolUse: {
 3524             LValue property = lowSymbol(propertyEdge);
 3525             vmCall(Void, m_out.operation(operationDefineDataPropertySymbol), m_callFrame, base, property, value, attributes);
 3526             break;
 3527         }
 3528         case UntypedUse: {
 3529             LValue property = lowJSValue(propertyEdge);
 3530             vmCall(Void, m_out.operation(operationDefineDataProperty), m_callFrame, base, property, value, attributes);
 3531             break;
 3532         }
 3533         default:
 3534             RELEASE_ASSERT_NOT_REACHED();
 3535         }
 3536     }
 3537 
 3538     void compileDefineAccessorProperty()
 3539     {
 3540         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3541         LValue getter = lowCell(m_graph.varArgChild(m_node, 2));
 3542         LValue setter = lowCell(m_graph.varArgChild(m_node, 3));
 3543         LValue attributes = lowInt32(m_graph.varArgChild(m_node, 4));
 3544         Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
 3545         switch (propertyEdge.useKind()) {
 3546         case StringUse: {
 3547             LValue property = lowString(propertyEdge);
 3548             vmCall(Void, m_out.operation(operationDefineAccessorPropertyString), m_callFrame, base, property, getter, setter, attributes);
 3549             break;
 3550         }
 3551         case StringIdentUse: {
 3552             LValue property = lowStringIdent(propertyEdge);
 3553             vmCall(Void, m_out.operation(operationDefineAccessorPropertyStringIdent), m_callFrame, base, property, getter, setter, attributes);
 3554             break;
 3555         }
 3556         case SymbolUse: {
 3557             LValue property = lowSymbol(propertyEdge);
 3558             vmCall(Void, m_out.operation(operationDefineAccessorPropertySymbol), m_callFrame, base, property, getter, setter, attributes);
 3559             break;
 3560         }
 3561         case UntypedUse: {
 3562             LValue property = lowJSValue(propertyEdge);
 3563             vmCall(Void, m_out.operation(operationDefineAccessorProperty), m_callFrame, base, property, getter, setter, attributes);
 3564             break;
 3565         }
 3566         default:
 3567             RELEASE_ASSERT_NOT_REACHED();
 3568         }
 3569     }
 3570 
 3571     void compilePutById()
 3572     {
 3573         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == CellUse, m_node-&gt;child1().useKind());
 3574 
 3575         Node* node = m_node;
 3576         LValue base = lowCell(node-&gt;child1());
 3577         LValue value = lowJSValue(node-&gt;child2());
 3578         auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
 3579 
 3580         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 3581         patchpoint-&gt;appendSomeRegister(base);
 3582         patchpoint-&gt;appendSomeRegister(value);
 3583         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 3584         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 3585         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 3586 
 3587         // FIXME: If this is a PutByIdFlush, we might want to late-clobber volatile registers.
 3588         // https://bugs.webkit.org/show_bug.cgi?id=152848
 3589 
 3590         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 3591             preparePatchpointForExceptions(patchpoint);
 3592 
 3593         State* state = &amp;m_ftlState;
 3594         ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;ecmaMode();
 3595 
 3596         patchpoint-&gt;setGenerator(
 3597             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 3598                 AllowMacroScratchRegisterUsage allowScratch(jit);
 3599 
 3600                 CallSiteIndex callSiteIndex =
 3601                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
 3602 
 3603                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 3604                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 3605 
 3606                 // JS setter call ICs generated by the PutById IC will need this.
 3607                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 3608 
 3609                 auto generator = Box&lt;JITPutByIdGenerator&gt;::create(
 3610                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
 3611                     params.unavailableRegisters(), JSValueRegs(params[0].gpr()),
 3612                     JSValueRegs(params[1].gpr()), GPRInfo::patchpointScratchRegister, ecmaMode,
 3613                     node-&gt;op() == PutByIdDirect ? Direct : NotDirect);
 3614 
 3615                 generator-&gt;generateFastPath(jit);
 3616                 CCallHelpers::Label done = jit.label();
 3617 
 3618                 params.addLatePath(
 3619                     [=] (CCallHelpers&amp; jit) {
 3620                         AllowMacroScratchRegisterUsage allowScratch(jit);
 3621 
 3622                         generator-&gt;slowPathJump().link(&amp;jit);
 3623                         CCallHelpers::Label slowPathBegin = jit.label();
 3624                         CCallHelpers::Call slowPathCall = callOperation(
 3625                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
 3626                             exceptions.get(), generator-&gt;slowPathFunction(), InvalidGPRReg,
 3627                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
 3628                             params[0].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
 3629                         jit.jump().linkTo(done, &amp;jit);
 3630 
 3631                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
 3632 
 3633                         jit.addLinkTask(
 3634                             [=] (LinkBuffer&amp; linkBuffer) {
 3635                                 generator-&gt;finalize(linkBuffer, linkBuffer);
 3636                             });
 3637                     });
 3638             });
 3639     }
 3640 
 3641     void compileGetButterfly()
 3642     {
 3643         LValue butterfly = m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSObject_butterfly);
 3644         setStorage(butterfly);
 3645     }
 3646 
 3647     void compileConstantStoragePointer()
 3648     {
 3649         setStorage(m_out.constIntPtr(m_node-&gt;storagePointer()));
 3650     }
 3651 
 3652     void compileGetIndexedPropertyStorage()
 3653     {
 3654         LValue cell = lowCell(m_node-&gt;child1());
 3655 
 3656         if (m_node-&gt;arrayMode().type() == Array::String) {
 3657             LBasicBlock slowPath = m_out.newBlock();
 3658             LBasicBlock continuation = m_out.newBlock();
 3659 
 3660             LValue fastResultValue = m_out.loadPtr(cell, m_heaps.JSString_value);
 3661             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 3662 
 3663             m_out.branch(isRopeString(cell, m_node-&gt;child1()), rarely(slowPath), usually(continuation));
 3664 
 3665             LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
 3666 
 3667             ValueFromBlock slowResult = m_out.anchor(
 3668                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, cell));
 3669 
 3670             m_out.jump(continuation);
 3671 
 3672             m_out.appendTo(continuation, lastNext);
 3673 
 3674             setStorage(m_out.loadPtr(m_out.phi(pointerType(), fastResult, slowResult), m_heaps.StringImpl_data));
 3675             return;
 3676         }
 3677 
 3678         DFG_ASSERT(m_graph, m_node, isTypedView(m_node-&gt;arrayMode().typedArrayType()), m_node-&gt;arrayMode().typedArrayType());
 3679         LValue vector = m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector);
<a name="37" id="anc37"></a><span class="line-modified"> 3680         setStorage(caged(Gigacage::Primitive, vector));</span>
 3681     }
 3682 
 3683     void compileCheckArray()
 3684     {
 3685         Edge edge = m_node-&gt;child1();
 3686         LValue cell = lowCell(edge);
 3687 
 3688         if (m_node-&gt;arrayMode().alreadyChecked(m_graph, m_node, abstractValue(edge)))
 3689             return;
 3690 
 3691         speculate(
 3692             BadIndexingType, jsValueValue(cell), 0,
 3693             m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));
 3694     }
 3695 
 3696     void compileGetTypedArrayByteOffset()
 3697     {
 3698         LValue basePtr = lowCell(m_node-&gt;child1());
 3699 
 3700         LBasicBlock simpleCase = m_out.newBlock();
 3701         LBasicBlock wastefulCase = m_out.newBlock();
 3702         LBasicBlock notNull = m_out.newBlock();
 3703         LBasicBlock continuation = m_out.newBlock();
 3704 
 3705         LValue mode = m_out.load32(basePtr, m_heaps.JSArrayBufferView_mode);
 3706         m_out.branch(
 3707             m_out.notEqual(mode, m_out.constInt32(WastefulTypedArray)),
 3708             unsure(simpleCase), unsure(wastefulCase));
 3709 
 3710         LBasicBlock lastNext = m_out.appendTo(simpleCase, wastefulCase);
 3711 
 3712         ValueFromBlock simpleOut = m_out.anchor(m_out.constIntPtr(0));
 3713 
 3714         m_out.jump(continuation);
 3715 
 3716         m_out.appendTo(wastefulCase, notNull);
 3717 
 3718         LValue vector = m_out.loadPtr(basePtr, m_heaps.JSArrayBufferView_vector);
 3719         ValueFromBlock nullVectorOut = m_out.anchor(vector);
 3720         m_out.branch(vector, unsure(notNull), unsure(continuation));
 3721 
 3722         m_out.appendTo(notNull, continuation);
 3723 
<a name="38" id="anc38"></a><span class="line-modified"> 3724         LValue butterflyPtr = caged(Gigacage::JSValue, m_out.loadPtr(basePtr, m_heaps.JSObject_butterfly));</span>
 3725         LValue arrayBufferPtr = m_out.loadPtr(butterflyPtr, m_heaps.Butterfly_arrayBuffer);
 3726 
<a name="39" id="anc39"></a><span class="line-modified"> 3727         LValue vectorPtr = caged(Gigacage::Primitive, vector);</span>
 3728 
 3729         // FIXME: This needs caging.
 3730         // https://bugs.webkit.org/show_bug.cgi?id=175515
 3731         LValue dataPtr = m_out.loadPtr(arrayBufferPtr, m_heaps.ArrayBuffer_data);
<a name="40" id="anc40"></a>
 3732 
 3733         ValueFromBlock wastefulOut = m_out.anchor(m_out.sub(vectorPtr, dataPtr));
 3734 
 3735         m_out.jump(continuation);
 3736         m_out.appendTo(continuation, lastNext);
 3737 
 3738         setInt32(m_out.castToInt32(m_out.phi(pointerType(), simpleOut, nullVectorOut, wastefulOut)));
 3739     }
 3740 
 3741     void compileGetPrototypeOf()
 3742     {
 3743         switch (m_node-&gt;child1().useKind()) {
 3744         case ArrayUse:
 3745         case FunctionUse:
 3746         case FinalObjectUse: {
 3747             LValue object = lowCell(m_node-&gt;child1());
 3748             switch (m_node-&gt;child1().useKind()) {
 3749             case ArrayUse:
 3750                 speculateArray(m_node-&gt;child1(), object);
 3751                 break;
 3752             case FunctionUse:
 3753                 speculateFunction(m_node-&gt;child1(), object);
 3754                 break;
 3755             case FinalObjectUse:
 3756                 speculateFinalObject(m_node-&gt;child1(), object);
 3757                 break;
 3758             default:
 3759                 RELEASE_ASSERT_NOT_REACHED();
 3760                 break;
 3761             }
 3762 
 3763             LValue structure = loadStructure(object);
 3764 
 3765             AbstractValue&amp; value = m_state.forNode(m_node-&gt;child1());
 3766             if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
 3767                 bool hasPolyProto = false;
 3768                 bool hasMonoProto = false;
 3769                 value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
 3770                     if (structure-&gt;hasPolyProto())
 3771                         hasPolyProto = true;
 3772                     else
 3773                         hasMonoProto = true;
 3774                 });
 3775 
 3776                 if (hasMonoProto &amp;&amp; !hasPolyProto) {
 3777                     setJSValue(m_out.load64(structure, m_heaps.Structure_prototype));
 3778                     return;
 3779                 }
 3780 
 3781                 if (hasPolyProto &amp;&amp; !hasMonoProto) {
 3782                     setJSValue(m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), object, m_out.constInt64(knownPolyProtoOffset), ScaleEight, JSObject::offsetOfInlineStorage())));
 3783                     return;
 3784                 }
 3785             }
 3786 
 3787             LBasicBlock continuation = m_out.newBlock();
 3788             LBasicBlock loadPolyProto = m_out.newBlock();
 3789 
 3790             LValue prototypeBits = m_out.load64(structure, m_heaps.Structure_prototype);
 3791             ValueFromBlock directPrototype = m_out.anchor(prototypeBits);
 3792             m_out.branch(m_out.isZero64(prototypeBits), unsure(loadPolyProto), unsure(continuation));
 3793 
 3794             LBasicBlock lastNext = m_out.appendTo(loadPolyProto, continuation);
 3795             ValueFromBlock polyProto = m_out.anchor(
 3796                 m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), object, m_out.constInt64(knownPolyProtoOffset), ScaleEight, JSObject::offsetOfInlineStorage())));
 3797             m_out.jump(continuation);
 3798 
 3799             m_out.appendTo(continuation, lastNext);
 3800             setJSValue(m_out.phi(Int64, directPrototype, polyProto));
 3801             return;
 3802         }
 3803         case ObjectUse: {
 3804             setJSValue(vmCall(Int64, m_out.operation(operationGetPrototypeOfObject), m_callFrame, lowObject(m_node-&gt;child1())));
 3805             return;
 3806         }
 3807         default: {
 3808             setJSValue(vmCall(Int64, m_out.operation(operationGetPrototypeOf), m_callFrame, lowJSValue(m_node-&gt;child1())));
 3809             return;
 3810         }
 3811         }
 3812     }
 3813 
 3814     void compileGetArrayLength()
 3815     {
 3816         switch (m_node-&gt;arrayMode().type()) {
 3817         case Array::Undecided:
 3818         case Array::Int32:
 3819         case Array::Double:
 3820         case Array::Contiguous: {
 3821             setInt32(m_out.load32NonNegative(lowStorage(m_node-&gt;child2()), m_heaps.Butterfly_publicLength));
 3822             return;
 3823         }
 3824 
 3825         case Array::ArrayStorage:
 3826         case Array::SlowPutArrayStorage: {
 3827             LValue length = m_out.load32(lowStorage(m_node-&gt;child2()), m_heaps.ArrayStorage_publicLength);
 3828             speculate(Uncountable, noValue(), nullptr, m_out.lessThan(length, m_out.int32Zero));
 3829             setInt32(length);
 3830             return;
 3831         }
 3832 
 3833         case Array::String: {
 3834             LValue string = lowCell(m_node-&gt;child1());
 3835 
 3836             LBasicBlock ropePath = m_out.newBlock();
 3837             LBasicBlock nonRopePath = m_out.newBlock();
 3838             LBasicBlock continuation = m_out.newBlock();
 3839 
 3840             m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropePath), usually(nonRopePath));
 3841 
 3842             LBasicBlock lastNext = m_out.appendTo(ropePath, nonRopePath);
 3843             ValueFromBlock ropeLength = m_out.anchor(m_out.load32NonNegative(string, m_heaps.JSRopeString_length));
 3844             m_out.jump(continuation);
 3845 
 3846             m_out.appendTo(nonRopePath, continuation);
 3847             ValueFromBlock nonRopeLength = m_out.anchor(m_out.load32NonNegative(m_out.loadPtr(string, m_heaps.JSString_value), m_heaps.StringImpl_length));
 3848             m_out.jump(continuation);
 3849 
 3850             m_out.appendTo(continuation, lastNext);
 3851             setInt32(m_out.phi(Int32, ropeLength, nonRopeLength));
 3852             return;
 3853         }
 3854 
 3855         case Array::DirectArguments: {
 3856             LValue arguments = lowCell(m_node-&gt;child1());
 3857             speculate(
 3858                 ExoticObjectMode, noValue(), nullptr,
 3859                 m_out.notNull(m_out.loadPtr(arguments, m_heaps.DirectArguments_mappedArguments)));
 3860             setInt32(m_out.load32NonNegative(arguments, m_heaps.DirectArguments_length));
 3861             return;
 3862         }
 3863 
 3864         case Array::ScopedArguments: {
 3865             LValue arguments = lowCell(m_node-&gt;child1());
 3866             LValue storage = m_out.loadPtr(arguments, m_heaps.ScopedArguments_storage);
 3867             speculate(
 3868                 ExoticObjectMode, noValue(), nullptr,
 3869                 m_out.notZero32(m_out.load8ZeroExt32(storage, m_heaps.ScopedArguments_Storage_overrodeThings)));
 3870             setInt32(m_out.load32NonNegative(storage, m_heaps.ScopedArguments_Storage_totalLength));
 3871             return;
 3872         }
 3873 
 3874         default:
 3875             if (m_node-&gt;arrayMode().isSomeTypedArrayView()) {
 3876                 setInt32(
 3877                     m_out.load32NonNegative(lowCell(m_node-&gt;child1()), m_heaps.JSArrayBufferView_length));
 3878                 return;
 3879             }
 3880 
 3881             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 3882             return;
 3883         }
 3884     }
 3885 
 3886     void compileGetVectorLength()
 3887     {
 3888         switch (m_node-&gt;arrayMode().type()) {
 3889         case Array::ArrayStorage:
 3890         case Array::SlowPutArrayStorage:
 3891             setInt32(m_out.load32NonNegative(lowStorage(m_node-&gt;child2()), m_heaps.ArrayStorage_vectorLength));
 3892             return;
 3893         default:
 3894             return;
 3895         }
 3896     }
 3897 
 3898     void compileCheckInBounds()
 3899     {
 3900         speculate(
 3901             OutOfBounds, noValue(), 0,
 3902             m_out.aboveOrEqual(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3903 
 3904         // Even though we claim to have JSValue result, no user of us should
 3905         // depend on our value. Users of this node just need to maintain that
 3906         // we dominate them.
 3907     }
 3908 
 3909     void compileGetByVal()
 3910     {
 3911         switch (m_node-&gt;arrayMode().type()) {
 3912         case Array::Int32:
 3913         case Array::Contiguous: {
 3914             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 3915             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 3916 
 3917             IndexedAbstractHeap&amp; heap = m_node-&gt;arrayMode().type() == Array::Int32 ?
 3918                 m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties;
 3919 
 3920             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3921 
 3922             if (m_node-&gt;arrayMode().isInBounds()) {
 3923                 LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 3924                 LValue isHole = m_out.isZero64(result);
 3925                 if (m_node-&gt;arrayMode().isSaneChain()) {
 3926                     DFG_ASSERT(
 3927                         m_graph, m_node, m_node-&gt;arrayMode().type() == Array::Contiguous, m_node-&gt;arrayMode().type());
 3928                     result = m_out.select(
 3929                         isHole, m_out.constInt64(JSValue::encode(jsUndefined())), result);
 3930                 } else
 3931                     speculate(LoadFromHole, noValue(), 0, isHole);
 3932                 setJSValue(result);
 3933                 return;
 3934             }
 3935 
 3936             LBasicBlock fastCase = m_out.newBlock();
 3937             LBasicBlock slowCase = m_out.newBlock();
 3938             LBasicBlock continuation = m_out.newBlock();
 3939 
 3940             m_out.branch(
 3941                 m_out.aboveOrEqual(
 3942                     index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
 3943                 rarely(slowCase), usually(fastCase));
 3944 
 3945             LBasicBlock lastNext = m_out.appendTo(fastCase, slowCase);
 3946 
 3947             LValue fastResultValue = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 3948             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 3949             m_out.branch(
 3950                 m_out.isZero64(fastResultValue), rarely(slowCase), usually(continuation));
 3951 
 3952             m_out.appendTo(slowCase, continuation);
 3953             ValueFromBlock slowResult = m_out.anchor(
 3954                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 3955             m_out.jump(continuation);
 3956 
 3957             m_out.appendTo(continuation, lastNext);
 3958             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 3959             return;
 3960         }
 3961 
 3962         case Array::Double: {
 3963             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3964             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 3965             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 3966 
 3967             IndexedAbstractHeap&amp; heap = m_heaps.indexedDoubleProperties;
 3968 
 3969             if (m_node-&gt;arrayMode().isInBounds()) {
 3970                 LValue result = m_out.loadDouble(
 3971                     baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 3972 
 3973                 if (!m_node-&gt;arrayMode().isSaneChain()) {
 3974                     speculate(
 3975                         LoadFromHole, noValue(), 0,
 3976                         m_out.doubleNotEqualOrUnordered(result, result));
 3977                 }
 3978                 setDouble(result);
 3979                 break;
 3980             }
 3981 
 3982             LBasicBlock inBounds = m_out.newBlock();
 3983             LBasicBlock boxPath = m_out.newBlock();
 3984             LBasicBlock slowCase = m_out.newBlock();
 3985             LBasicBlock continuation = m_out.newBlock();
 3986 
 3987             m_out.branch(
 3988                 m_out.aboveOrEqual(
 3989                     index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
 3990                 rarely(slowCase), usually(inBounds));
 3991 
 3992             LBasicBlock lastNext = m_out.appendTo(inBounds, boxPath);
 3993             LValue doubleValue = m_out.loadDouble(
 3994                 baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 3995             m_out.branch(
 3996                 m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue),
 3997                 rarely(slowCase), usually(boxPath));
 3998 
 3999             m_out.appendTo(boxPath, slowCase);
 4000             ValueFromBlock fastResult = m_out.anchor(boxDouble(doubleValue));
 4001             m_out.jump(continuation);
 4002 
 4003             m_out.appendTo(slowCase, continuation);
 4004             ValueFromBlock slowResult = m_out.anchor(
 4005                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 4006             m_out.jump(continuation);
 4007 
 4008             m_out.appendTo(continuation, lastNext);
 4009             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4010             return;
 4011         }
 4012 
 4013         case Array::Undecided: {
 4014             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4015 
 4016             speculate(OutOfBounds, noValue(), m_node, m_out.lessThan(index, m_out.int32Zero));
 4017             setJSValue(m_out.constInt64(ValueUndefined));
 4018             return;
 4019         }
 4020 
 4021         case Array::DirectArguments: {
 4022             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4023             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4024 
 4025             speculate(
 4026                 ExoticObjectMode, noValue(), nullptr,
 4027                 m_out.notNull(m_out.loadPtr(base, m_heaps.DirectArguments_mappedArguments)));
 4028 
 4029             LValue length = m_out.load32NonNegative(base, m_heaps.DirectArguments_length);
 4030             auto isOutOfBounds = m_out.aboveOrEqual(index, length);
 4031             if (m_node-&gt;arrayMode().isInBounds()) {
 4032                 speculate(OutOfBounds, noValue(), nullptr, isOutOfBounds);
 4033                 TypedPointer address = m_out.baseIndex(
 4034                     m_heaps.DirectArguments_storage, base, m_out.zeroExtPtr(index));
 4035                 setJSValue(m_out.load64(address));
 4036                 return;
 4037             }
 4038 
 4039             LBasicBlock inBounds = m_out.newBlock();
 4040             LBasicBlock slowCase = m_out.newBlock();
 4041             LBasicBlock continuation = m_out.newBlock();
 4042 
 4043             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBounds));
 4044 
 4045             LBasicBlock lastNext = m_out.appendTo(inBounds, slowCase);
 4046             TypedPointer address = m_out.baseIndex(
 4047                 m_heaps.DirectArguments_storage,
 4048                 base,
 4049                 m_out.zeroExt(index, pointerType()));
 4050             ValueFromBlock fastResult = m_out.anchor(m_out.load64(address));
 4051             m_out.jump(continuation);
 4052 
 4053             m_out.appendTo(slowCase, continuation);
 4054             ValueFromBlock slowResult = m_out.anchor(
 4055                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 4056             m_out.jump(continuation);
 4057 
 4058             m_out.appendTo(continuation, lastNext);
 4059             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4060             return;
 4061         }
 4062 
 4063         case Array::ScopedArguments: {
 4064             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4065             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4066 
 4067             LValue storage = m_out.loadPtr(base, m_heaps.ScopedArguments_storage);
 4068             LValue totalLength = m_out.load32NonNegative(
 4069                 storage, m_heaps.ScopedArguments_Storage_totalLength);
 4070             speculate(
 4071                 ExoticObjectMode, noValue(), nullptr,
 4072                 m_out.aboveOrEqual(index, totalLength));
 4073 
 4074             LValue table = m_out.loadPtr(base, m_heaps.ScopedArguments_table);
 4075             LValue namedLength = m_out.load32(table, m_heaps.ScopedArgumentsTable_length);
 4076 
 4077             LBasicBlock namedCase = m_out.newBlock();
 4078             LBasicBlock overflowCase = m_out.newBlock();
 4079             LBasicBlock continuation = m_out.newBlock();
 4080 
 4081             m_out.branch(
 4082                 m_out.aboveOrEqual(index, namedLength), unsure(overflowCase), unsure(namedCase));
 4083 
 4084             LBasicBlock lastNext = m_out.appendTo(namedCase, overflowCase);
 4085 
 4086             LValue scope = m_out.loadPtr(base, m_heaps.ScopedArguments_scope);
 4087             LValue arguments = m_out.loadPtr(table, m_heaps.ScopedArgumentsTable_arguments);
 4088 
 4089             TypedPointer address = m_out.baseIndex(
 4090                 m_heaps.scopedArgumentsTableArguments, arguments, m_out.zeroExtPtr(index));
 4091             LValue scopeOffset = m_out.load32(address);
 4092 
 4093             speculate(
 4094                 ExoticObjectMode, noValue(), nullptr,
 4095                 m_out.equal(scopeOffset, m_out.constInt32(ScopeOffset::invalidOffset)));
 4096 
 4097             address = m_out.baseIndex(
 4098                 m_heaps.JSLexicalEnvironment_variables, scope, m_out.zeroExtPtr(scopeOffset));
 4099             ValueFromBlock namedResult = m_out.anchor(m_out.load64(address));
 4100             m_out.jump(continuation);
 4101 
 4102             m_out.appendTo(overflowCase, continuation);
 4103 
 4104             address = m_out.baseIndex(
 4105                 m_heaps.ScopedArguments_Storage_storage, storage,
 4106                 m_out.zeroExtPtr(m_out.sub(index, namedLength)));
 4107             LValue overflowValue = m_out.load64(address);
 4108             speculate(ExoticObjectMode, noValue(), nullptr, m_out.isZero64(overflowValue));
 4109             ValueFromBlock overflowResult = m_out.anchor(overflowValue);
 4110             m_out.jump(continuation);
 4111 
 4112             m_out.appendTo(continuation, lastNext);
 4113 
 4114             LValue result = m_out.phi(Int64, namedResult, overflowResult);
 4115             result = preciseIndexMask32(result, index, totalLength);
 4116 
 4117             setJSValue(result);
 4118             return;
 4119         }
 4120 
 4121         case Array::Generic: {
 4122             if (m_graph.varArgChild(m_node, 0).useKind() == ObjectUse) {
 4123                 if (m_graph.varArgChild(m_node, 1).useKind() == StringUse) {
 4124                     setJSValue(vmCall(
 4125                         Int64, m_out.operation(operationGetByValObjectString), m_callFrame,
 4126                         lowObject(m_graph.varArgChild(m_node, 0)), lowString(m_graph.varArgChild(m_node, 1))));
 4127                     return;
 4128                 }
 4129 
 4130                 if (m_graph.varArgChild(m_node, 1).useKind() == SymbolUse) {
 4131                     setJSValue(vmCall(
 4132                         Int64, m_out.operation(operationGetByValObjectSymbol), m_callFrame,
 4133                         lowObject(m_graph.varArgChild(m_node, 0)), lowSymbol(m_graph.varArgChild(m_node, 1))));
 4134                     return;
 4135                 }
 4136             }
 4137             setJSValue(vmCall(
 4138                 Int64, m_out.operation(operationGetByVal), m_callFrame,
 4139                 lowJSValue(m_graph.varArgChild(m_node, 0)), lowJSValue(m_graph.varArgChild(m_node, 1))));
 4140             return;
 4141         }
 4142 
 4143         case Array::ArrayStorage:
 4144         case Array::SlowPutArrayStorage: {
 4145             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4146             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4147             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4148 
 4149             IndexedAbstractHeap&amp; heap = m_heaps.ArrayStorage_vector;
 4150 
 4151             if (m_node-&gt;arrayMode().isInBounds()) {
 4152                 LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4153                 speculate(LoadFromHole, noValue(), 0, m_out.isZero64(result));
 4154                 setJSValue(result);
 4155                 break;
 4156             }
 4157 
 4158             LBasicBlock inBounds = m_out.newBlock();
 4159             LBasicBlock slowCase = m_out.newBlock();
 4160             LBasicBlock continuation = m_out.newBlock();
 4161 
 4162             m_out.branch(
 4163                 m_out.aboveOrEqual(index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength)),
 4164                 rarely(slowCase), usually(inBounds));
 4165 
 4166             LBasicBlock lastNext = m_out.appendTo(inBounds, slowCase);
 4167             LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4168             ValueFromBlock fastResult = m_out.anchor(result);
 4169             m_out.branch(
 4170                 m_out.isZero64(result),
 4171                 rarely(slowCase), usually(continuation));
 4172 
 4173             m_out.appendTo(slowCase, continuation);
 4174             ValueFromBlock slowResult = m_out.anchor(
 4175                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 4176             m_out.jump(continuation);
 4177 
 4178             m_out.appendTo(continuation, lastNext);
 4179             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4180             return;
 4181         }
 4182 
 4183         case Array::String: {
 4184             compileStringCharAt();
 4185             return;
 4186         }
 4187 
 4188         case Array::Int8Array:
 4189         case Array::Int16Array:
 4190         case Array::Int32Array:
 4191         case Array::Uint8Array:
 4192         case Array::Uint8ClampedArray:
 4193         case Array::Uint16Array:
 4194         case Array::Uint32Array:
 4195         case Array::Float32Array:
 4196         case Array::Float64Array: {
 4197             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4198             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4199 
 4200             TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
 4201             ASSERT(isTypedView(type));
 4202             {
 4203                 TypedPointer pointer = pointerIntoTypedArray(storage, index, type);
 4204 
 4205                 if (isInt(type)) {
 4206                     LValue result = loadFromIntTypedArray(pointer, type);
 4207                     bool canSpeculate = true;
 4208                     setIntTypedArrayLoadResult(result, type, canSpeculate);
 4209                     return;
 4210                 }
 4211 
 4212                 ASSERT(isFloat(type));
 4213 
 4214                 LValue result;
 4215                 switch (type) {
 4216                 case TypeFloat32:
 4217                     result = m_out.floatToDouble(m_out.loadFloat(pointer));
 4218                     break;
 4219                 case TypeFloat64:
 4220                     result = m_out.loadDouble(pointer);
 4221                     break;
 4222                 default:
 4223                     DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 4224                 }
 4225 
 4226                 setDouble(result);
 4227                 return;
 4228             }
 4229         }
 4230 
 4231         case Array::AnyTypedArray:
 4232         case Array::ForceExit:
 4233         case Array::SelectUsingArguments:
 4234         case Array::SelectUsingPredictions:
 4235         case Array::Unprofiled:
 4236             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4237             return;
 4238         }
 4239     }
 4240 
 4241     void compileGetMyArgumentByVal()
 4242     {
<a name="41" id="anc41"></a><span class="line-modified"> 4243         InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 4244 
 4245         LValue originalIndex = lowInt32(m_node-&gt;child2());
 4246 
 4247         LValue numberOfArgsIncludingThis;
 4248         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
 4249             numberOfArgsIncludingThis = m_out.constInt32(inlineCallFrame-&gt;argumentCountIncludingThis);
 4250         else {
 4251             VirtualRegister argumentCountRegister = AssemblyHelpers::argumentCount(inlineCallFrame);
 4252             numberOfArgsIncludingThis = m_out.load32(payloadFor(argumentCountRegister));
 4253         }
 4254 
 4255         LValue numberOfArgs = m_out.sub(numberOfArgsIncludingThis, m_out.int32One);
 4256         LValue indexToCheck = originalIndex;
 4257         LValue numberOfArgumentsToSkip = m_out.int32Zero;
 4258         if (m_node-&gt;numberOfArgumentsToSkip()) {
 4259             numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 4260             CheckValue* check = m_out.speculateAdd(indexToCheck, numberOfArgumentsToSkip);
 4261             blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 4262             indexToCheck = check;
 4263         }
 4264 
 4265         LValue isOutOfBounds = m_out.bitOr(m_out.aboveOrEqual(indexToCheck, numberOfArgs), m_out.below(indexToCheck, numberOfArgumentsToSkip));
 4266         LBasicBlock continuation = nullptr;
 4267         LBasicBlock lastNext = nullptr;
 4268         ValueFromBlock slowResult;
 4269         if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
 4270             LBasicBlock normalCase = m_out.newBlock();
 4271             continuation = m_out.newBlock();
 4272 
 4273             slowResult = m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined())));
 4274             m_out.branch(isOutOfBounds, unsure(continuation), unsure(normalCase));
 4275 
 4276             lastNext = m_out.appendTo(normalCase, continuation);
 4277         } else
 4278             speculate(OutOfBounds, noValue(), nullptr, isOutOfBounds);
 4279 
 4280         LValue index = m_out.add(indexToCheck, m_out.int32One);
 4281 
 4282         TypedPointer base;
 4283         if (inlineCallFrame) {
 4284             if (inlineCallFrame-&gt;argumentCountIncludingThis &gt; 1)
 4285                 base = addressFor(inlineCallFrame-&gt;argumentsWithFixup[0].virtualRegister());
 4286         } else
 4287             base = addressFor(virtualRegisterForArgument(0));
 4288 
 4289         LValue result;
 4290         if (base) {
 4291             LValue pointer = m_out.baseIndex(
 4292                 base.value(), m_out.zeroExt(index, pointerType()), ScaleEight);
 4293             result = m_out.load64(TypedPointer(m_heaps.variables.atAnyIndex(), pointer));
 4294             result = preciseIndexMask32(result, indexToCheck, numberOfArgs);
 4295         } else
 4296             result = m_out.constInt64(JSValue::encode(jsUndefined()));
 4297 
 4298         if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
 4299             ValueFromBlock normalResult = m_out.anchor(result);
 4300             m_out.jump(continuation);
 4301 
 4302             m_out.appendTo(continuation, lastNext);
 4303             result = m_out.phi(Int64, slowResult, normalResult);
 4304         }
 4305 
 4306         setJSValue(result);
 4307     }
 4308 
 4309     void compilePutByVal()
 4310     {
 4311         Edge child1 = m_graph.varArgChild(m_node, 0);
 4312         Edge child2 = m_graph.varArgChild(m_node, 1);
 4313         Edge child3 = m_graph.varArgChild(m_node, 2);
 4314         Edge child4 = m_graph.varArgChild(m_node, 3);
 4315         Edge child5 = m_graph.varArgChild(m_node, 4);
 4316 
 4317         ArrayMode arrayMode = m_node-&gt;arrayMode().modeForPut();
 4318         switch (arrayMode.type()) {
 4319         case Array::Generic: {
 4320             if (child1.useKind() == CellUse) {
 4321                 V_JITOperation_ECCJ operation = nullptr;
 4322                 if (child2.useKind() == StringUse) {
 4323                     if (m_node-&gt;op() == PutByValDirect) {
 4324                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4325                             operation = operationPutByValDirectCellStringStrict;
 4326                         else
 4327                             operation = operationPutByValDirectCellStringNonStrict;
 4328                     } else {
 4329                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4330                             operation = operationPutByValCellStringStrict;
 4331                         else
 4332                             operation = operationPutByValCellStringNonStrict;
 4333                     }
 4334                     vmCall(Void, m_out.operation(operation), m_callFrame, lowCell(child1), lowString(child2), lowJSValue(child3));
 4335                     return;
 4336                 }
 4337 
 4338                 if (child2.useKind() == SymbolUse) {
 4339                     if (m_node-&gt;op() == PutByValDirect) {
 4340                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4341                             operation = operationPutByValDirectCellSymbolStrict;
 4342                         else
 4343                             operation = operationPutByValDirectCellSymbolNonStrict;
 4344                     } else {
 4345                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4346                             operation = operationPutByValCellSymbolStrict;
 4347                         else
 4348                             operation = operationPutByValCellSymbolNonStrict;
 4349                     }
 4350                     vmCall(Void, m_out.operation(operation), m_callFrame, lowCell(child1), lowSymbol(child2), lowJSValue(child3));
 4351                     return;
 4352                 }
 4353             }
 4354 
 4355             V_JITOperation_EJJJ operation;
 4356             if (m_node-&gt;op() == PutByValDirect) {
 4357                 if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4358                     operation = operationPutByValDirectStrict;
 4359                 else
 4360                     operation = operationPutByValDirectNonStrict;
 4361             } else {
 4362                 if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4363                     operation = operationPutByValStrict;
 4364                 else
 4365                     operation = operationPutByValNonStrict;
 4366             }
 4367 
 4368             vmCall(
 4369                 Void, m_out.operation(operation), m_callFrame,
 4370                 lowJSValue(child1), lowJSValue(child2), lowJSValue(child3));
 4371             return;
 4372         }
 4373 
 4374         default:
 4375             break;
 4376         }
 4377 
 4378         LValue base = lowCell(child1);
 4379         LValue index = lowInt32(child2);
 4380         LValue storage = lowStorage(child4);
 4381 
 4382         switch (arrayMode.type()) {
 4383         case Array::Int32:
 4384         case Array::Double:
 4385         case Array::Contiguous: {
 4386             LBasicBlock continuation = m_out.newBlock();
 4387             LBasicBlock outerLastNext = m_out.appendTo(m_out.m_block, continuation);
 4388 
 4389             switch (arrayMode.type()) {
 4390             case Array::Int32:
 4391             case Array::Contiguous: {
 4392                 LValue value = lowJSValue(child3, ManualOperandSpeculation);
 4393 
 4394                 if (arrayMode.type() == Array::Int32)
 4395                     FTL_TYPE_CHECK(jsValueValue(value), child3, SpecInt32Only, isNotInt32(value));
 4396 
 4397                 TypedPointer elementPointer = m_out.baseIndex(
 4398                     arrayMode.type() == Array::Int32 ?
 4399                     m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties,
 4400                     storage, m_out.zeroExtPtr(index), provenValue(child2));
 4401 
 4402                 if (m_node-&gt;op() == PutByValAlias) {
 4403                     m_out.store64(value, elementPointer);
 4404                     break;
 4405                 }
 4406 
 4407                 contiguousPutByValOutOfBounds(
<a name="42" id="anc42"></a><span class="line-modified"> 4408                     codeBlock()-&gt;isStrictMode()</span>
 4409                         ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4410                         : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
 4411                     base, storage, index, value, continuation);
 4412 
 4413                 m_out.store64(value, elementPointer);
 4414                 break;
 4415             }
 4416 
 4417             case Array::Double: {
 4418                 LValue value = lowDouble(child3);
 4419 
 4420                 FTL_TYPE_CHECK(
 4421                     doubleValue(value), child3, SpecDoubleReal,
 4422                     m_out.doubleNotEqualOrUnordered(value, value));
 4423 
 4424                 TypedPointer elementPointer = m_out.baseIndex(
 4425                     m_heaps.indexedDoubleProperties, storage, m_out.zeroExtPtr(index),
 4426                     provenValue(child2));
 4427 
 4428                 if (m_node-&gt;op() == PutByValAlias) {
 4429                     m_out.storeDouble(value, elementPointer);
 4430                     break;
 4431                 }
 4432 
 4433                 contiguousPutByValOutOfBounds(
<a name="43" id="anc43"></a><span class="line-modified"> 4434                     codeBlock()-&gt;isStrictMode()</span>
 4435                         ? (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 4436                         : (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 4437                     base, storage, index, value, continuation);
 4438 
 4439                 m_out.storeDouble(value, elementPointer);
 4440                 break;
 4441             }
 4442 
 4443             default:
 4444                 DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4445             }
 4446 
 4447             m_out.jump(continuation);
 4448             m_out.appendTo(continuation, outerLastNext);
 4449             return;
 4450         }
 4451 
 4452         case Array::ArrayStorage:
 4453         case Array::SlowPutArrayStorage: {
 4454             LValue value = lowJSValue(child3);
 4455 
 4456             TypedPointer elementPointer = m_out.baseIndex(
 4457                 m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(index),
 4458                 provenValue(child2));
 4459 
 4460             if (m_node-&gt;op() == PutByValAlias) {
 4461                 m_out.store64(value, elementPointer);
 4462                 return;
 4463             }
 4464 
 4465             if (arrayMode.isInBounds()) {
 4466                 speculate(StoreToHole, noValue(), 0, m_out.isZero64(m_out.load64(elementPointer)));
 4467                 m_out.store64(value, elementPointer);
 4468                 return;
 4469             }
 4470 
 4471             LValue isOutOfBounds = m_out.aboveOrEqual(
 4472                 index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength));
 4473 
<a name="44" id="anc44"></a><span class="line-modified"> 4474             auto slowPathFunction = codeBlock()-&gt;isStrictMode()</span>
 4475                 ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4476                 : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict);
 4477             if (!arrayMode.isOutOfBounds()) {
 4478                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
 4479                 isOutOfBounds = m_out.booleanFalse;
 4480             }
 4481 
 4482             LBasicBlock inBoundCase = m_out.newBlock();
 4483             LBasicBlock slowCase = m_out.newBlock();
 4484             LBasicBlock holeCase = m_out.newBlock();
 4485             LBasicBlock doStoreCase = m_out.newBlock();
 4486             LBasicBlock lengthUpdateCase = m_out.newBlock();
 4487             LBasicBlock continuation = m_out.newBlock();
 4488 
 4489             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBoundCase));
 4490 
 4491             LBasicBlock lastNext = m_out.appendTo(slowCase, inBoundCase);
 4492             vmCall(
 4493                 Void, m_out.operation(slowPathFunction),
 4494                 m_callFrame, base, index, value);
 4495             m_out.jump(continuation);
 4496 
 4497 
 4498             if (arrayMode.isSlowPut()) {
 4499                 m_out.appendTo(inBoundCase, doStoreCase);
 4500                 m_out.branch(m_out.isZero64(m_out.load64(elementPointer)), rarely(slowCase), usually(doStoreCase));
 4501             } else {
 4502                 m_out.appendTo(inBoundCase, holeCase);
 4503                 m_out.branch(m_out.isZero64(m_out.load64(elementPointer)), rarely(holeCase), usually(doStoreCase));
 4504 
 4505                 m_out.appendTo(holeCase, lengthUpdateCase);
 4506                 m_out.store32(
 4507                     m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 4508                     storage, m_heaps.ArrayStorage_numValuesInVector);
 4509                 m_out.branch(
 4510                     m_out.below(
 4511                         index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_publicLength)),
 4512                     unsure(doStoreCase), unsure(lengthUpdateCase));
 4513 
 4514                 m_out.appendTo(lengthUpdateCase, doStoreCase);
 4515                 m_out.store32(
 4516                     m_out.add(index, m_out.int32One),
 4517                     storage, m_heaps.ArrayStorage_publicLength);
 4518                 m_out.jump(doStoreCase);
 4519             }
 4520 
 4521             m_out.appendTo(doStoreCase, continuation);
 4522             m_out.store64(value, elementPointer);
 4523             m_out.jump(continuation);
 4524 
 4525             m_out.appendTo(continuation, lastNext);
 4526             return;
 4527         }
 4528 
 4529         case Array::Int8Array:
 4530         case Array::Int16Array:
 4531         case Array::Int32Array:
 4532         case Array::Uint8Array:
 4533         case Array::Uint8ClampedArray:
 4534         case Array::Uint16Array:
 4535         case Array::Uint32Array:
 4536         case Array::Float32Array:
 4537         case Array::Float64Array: {
 4538             TypedArrayType type = arrayMode.typedArrayType();
 4539 
 4540             ASSERT(isTypedView(type));
 4541             {
 4542                 TypedPointer pointer = TypedPointer(
 4543                     m_heaps.typedArrayProperties,
 4544                     m_out.add(
 4545                         storage,
 4546                         m_out.shl(
 4547                             m_out.zeroExt(index, pointerType()),
 4548                             m_out.constIntPtr(logElementSize(type)))));
 4549 
 4550                 LValue valueToStore;
 4551 
 4552                 if (isInt(type)) {
 4553                     LValue intValue = getIntTypedArrayStoreOperand(child3, isClamped(type));
 4554 
 4555                     valueToStore = intValue;
 4556                 } else /* !isInt(type) */ {
 4557                     LValue value = lowDouble(child3);
 4558                     switch (type) {
 4559                     case TypeFloat32:
 4560                         valueToStore = m_out.doubleToFloat(value);
 4561                         break;
 4562                     case TypeFloat64:
 4563                         valueToStore = value;
 4564                         break;
 4565                     default:
 4566                         DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 4567                     }
 4568                 }
 4569 
 4570                 if (arrayMode.isInBounds() || m_node-&gt;op() == PutByValAlias)
 4571                     m_out.store(valueToStore, pointer, storeType(type));
 4572                 else {
 4573                     LBasicBlock isInBounds = m_out.newBlock();
 4574                     LBasicBlock isOutOfBounds = m_out.newBlock();
 4575                     LBasicBlock continuation = m_out.newBlock();
 4576 
 4577                     m_out.branch(
 4578                         m_out.aboveOrEqual(index, lowInt32(child5)),
 4579                         unsure(isOutOfBounds), unsure(isInBounds));
 4580 
 4581                     LBasicBlock lastNext = m_out.appendTo(isInBounds, isOutOfBounds);
 4582                     m_out.store(valueToStore, pointer, storeType(type));
 4583                     m_out.jump(continuation);
 4584 
 4585                     m_out.appendTo(isOutOfBounds, continuation);
 4586                     speculateTypedArrayIsNotNeutered(base);
 4587                     m_out.jump(continuation);
 4588 
 4589                     m_out.appendTo(continuation, lastNext);
 4590                 }
 4591 
 4592                 return;
 4593             }
 4594         }
 4595 
 4596         case Array::AnyTypedArray:
 4597         case Array::String:
 4598         case Array::DirectArguments:
 4599         case Array::ForceExit:
 4600         case Array::Generic:
 4601         case Array::ScopedArguments:
 4602         case Array::SelectUsingArguments:
 4603         case Array::SelectUsingPredictions:
 4604         case Array::Undecided:
 4605         case Array::Unprofiled:
 4606             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4607             break;
 4608         }
 4609     }
 4610 
 4611     void compilePutAccessorById()
 4612     {
 4613         LValue base = lowCell(m_node-&gt;child1());
 4614         LValue accessor = lowCell(m_node-&gt;child2());
 4615         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 4616         vmCall(
 4617             Void,
 4618             m_out.operation(m_node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById),
 4619             m_callFrame, base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);
 4620     }
 4621 
 4622     void compilePutGetterSetterById()
 4623     {
 4624         LValue base = lowCell(m_node-&gt;child1());
 4625         LValue getter = lowJSValue(m_node-&gt;child2());
 4626         LValue setter = lowJSValue(m_node-&gt;child3());
 4627         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 4628         vmCall(
 4629             Void, m_out.operation(operationPutGetterSetter),
 4630             m_callFrame, base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), getter, setter);
 4631 
 4632     }
 4633 
 4634     void compilePutAccessorByVal()
 4635     {
 4636         LValue base = lowCell(m_node-&gt;child1());
 4637         LValue subscript = lowJSValue(m_node-&gt;child2());
 4638         LValue accessor = lowCell(m_node-&gt;child3());
 4639         vmCall(
 4640             Void,
 4641             m_out.operation(m_node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal),
 4642             m_callFrame, base, subscript, m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);
 4643     }
 4644 
 4645     void compileDeleteById()
 4646     {
 4647         LValue base = lowJSValue(m_node-&gt;child1());
 4648         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 4649         setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationDeleteById), m_callFrame, base, m_out.constIntPtr(uid))));
 4650     }
 4651 
 4652     void compileDeleteByVal()
 4653     {
 4654         LValue base = lowJSValue(m_node-&gt;child1());
 4655         LValue subscript = lowJSValue(m_node-&gt;child2());
 4656         setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationDeleteByVal), m_callFrame, base, subscript)));
 4657     }
 4658 
 4659     void compileArrayPush()
 4660     {
 4661         LValue base = lowCell(m_graph.varArgChild(m_node, 1));
 4662         LValue storage = lowStorage(m_graph.varArgChild(m_node, 0));
 4663         unsigned elementOffset = 2;
 4664         unsigned elementCount = m_node-&gt;numChildren() - elementOffset;
 4665 
 4666         switch (m_node-&gt;arrayMode().type()) {
 4667         case Array::Int32:
 4668         case Array::Contiguous:
 4669         case Array::Double: {
 4670             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 4671 
 4672             if (elementCount == 1) {
 4673                 LValue value;
 4674                 Output::StoreType storeType;
 4675 
 4676                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
<a name="45" id="anc45"></a>
 4677                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4678                     value = lowJSValue(element, ManualOperandSpeculation);
<a name="46" id="anc46"></a><span class="line-removed"> 4679                     if (m_node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed"> 4680                         DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecInt32Only));</span>
 4681                     storeType = Output::Store64;
 4682                 } else {
 4683                     value = lowDouble(element);
<a name="47" id="anc47"></a><span class="line-removed"> 4684                     DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecDoubleReal));</span>
 4685                     storeType = Output::StoreDouble;
 4686                 }
 4687 
 4688                 LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4689 
 4690                 LBasicBlock fastPath = m_out.newBlock();
 4691                 LBasicBlock slowPath = m_out.newBlock();
 4692                 LBasicBlock continuation = m_out.newBlock();
 4693 
 4694                 m_out.branch(
 4695                     m_out.aboveOrEqual(
 4696                         prevLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength)),
 4697                     unsure(slowPath), unsure(fastPath));
 4698 
 4699                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4700                 m_out.store(
 4701                     value, m_out.baseIndex(heap, storage, m_out.zeroExtPtr(prevLength)), storeType);
 4702                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 4703                 m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4704 
 4705                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4706                 m_out.jump(continuation);
 4707 
 4708                 m_out.appendTo(slowPath, continuation);
 4709                 LValue operation;
 4710                 if (m_node-&gt;arrayMode().type() != Array::Double)
 4711                     operation = m_out.operation(operationArrayPush);
 4712                 else
 4713                     operation = m_out.operation(operationArrayPushDouble);
 4714                 ValueFromBlock slowResult = m_out.anchor(
 4715                     vmCall(Int64, operation, m_callFrame, value, base));
 4716                 m_out.jump(continuation);
 4717 
 4718                 m_out.appendTo(continuation, lastNext);
 4719                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4720                 return;
 4721             }
 4722 
<a name="48" id="anc48"></a>




 4723             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4724             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 4725 
 4726             LBasicBlock fastPath = m_out.newBlock();
 4727             LBasicBlock slowPath = m_out.newBlock();
 4728             LBasicBlock setup = m_out.newBlock();
 4729             LBasicBlock slowCallPath = m_out.newBlock();
 4730             LBasicBlock continuation = m_out.newBlock();
 4731 
 4732             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength));
 4733 
 4734             m_out.branch(beyondVectorLength, unsure(slowPath), unsure(fastPath));
 4735 
 4736             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4737             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4738             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight));
 4739             m_out.jump(setup);
 4740 
 4741             m_out.appendTo(slowPath, setup);
 4742             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 4743             static_assert(sizeof(EncodedJSValue) == sizeof(double), &quot;&quot;);
 4744             ASSERT(scratchSize);
 4745             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 4746             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4747             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 4748             m_out.jump(setup);
 4749 
 4750             m_out.appendTo(setup, slowCallPath);
 4751             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 4752             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 4753                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 4754 
 4755                 LValue value;
 4756                 Output::StoreType storeType;
 4757                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4758                     value = lowJSValue(element, ManualOperandSpeculation);
<a name="49" id="anc49"></a><span class="line-removed"> 4759                     if (m_node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed"> 4760                         DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecInt32Only));</span>
 4761                     storeType = Output::Store64;
 4762                 } else {
 4763                     value = lowDouble(element);
<a name="50" id="anc50"></a><span class="line-removed"> 4764                     DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecDoubleReal));</span>
 4765                     storeType = Output::StoreDouble;
 4766                 }
 4767 
 4768                 m_out.store(value, m_out.baseIndex(heap, buffer, m_out.constInt32(elementIndex), jsNumber(elementIndex)), storeType);
 4769             }
 4770             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4771 
 4772             m_out.branch(beyondVectorLength, unsure(slowCallPath), unsure(continuation));
 4773 
 4774             m_out.appendTo(slowCallPath, continuation);
 4775             LValue operation;
 4776             if (m_node-&gt;arrayMode().type() != Array::Double)
 4777                 operation = m_out.operation(operationArrayPushMultiple);
 4778             else
 4779                 operation = m_out.operation(operationArrayPushDoubleMultiple);
 4780             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, base, buffer, m_out.constInt32(elementCount)));
 4781             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4782             m_out.jump(continuation);
 4783 
 4784             m_out.appendTo(continuation, lastNext);
 4785             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4786             return;
 4787         }
 4788 
 4789         case Array::ArrayStorage: {
 4790             // This ensures that the result of ArrayPush is Int32 in AI.
 4791             int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 4792 
 4793             LValue prevLength = m_out.load32(storage, m_heaps.ArrayStorage_publicLength);
 4794             // Refuse to handle bizarre lengths.
 4795             speculate(Uncountable, noValue(), nullptr, m_out.above(prevLength, m_out.constInt32(largestPositiveInt32Length)));
 4796 
 4797             if (elementCount == 1) {
 4798                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
 4799 
 4800                 LValue value = lowJSValue(element);
 4801 
 4802                 LBasicBlock fastPath = m_out.newBlock();
 4803                 LBasicBlock slowPath = m_out.newBlock();
 4804                 LBasicBlock continuation = m_out.newBlock();
 4805 
 4806                 m_out.branch(
 4807                     m_out.aboveOrEqual(
 4808                         prevLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength)),
 4809                     rarely(slowPath), usually(fastPath));
 4810 
 4811                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4812                 m_out.store64(
 4813                     value, m_out.baseIndex(m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(prevLength)));
 4814                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 4815                 m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 4816                 m_out.store32(
 4817                     m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 4818                     storage, m_heaps.ArrayStorage_numValuesInVector);
 4819 
 4820                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4821                 m_out.jump(continuation);
 4822 
 4823                 m_out.appendTo(slowPath, continuation);
 4824                 ValueFromBlock slowResult = m_out.anchor(
 4825                     vmCall(Int64, m_out.operation(operationArrayPush), m_callFrame, value, base));
 4826                 m_out.jump(continuation);
 4827 
 4828                 m_out.appendTo(continuation, lastNext);
 4829                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4830                 return;
 4831             }
 4832 
 4833             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 4834 
 4835             LBasicBlock fastPath = m_out.newBlock();
 4836             LBasicBlock slowPath = m_out.newBlock();
 4837             LBasicBlock setup = m_out.newBlock();
 4838             LBasicBlock slowCallPath = m_out.newBlock();
 4839             LBasicBlock continuation = m_out.newBlock();
 4840 
 4841             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength));
 4842 
 4843             m_out.branch(beyondVectorLength, rarely(slowPath), usually(fastPath));
 4844 
 4845             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4846             m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 4847             m_out.store32(
 4848                 m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.constInt32(elementCount)),
 4849                 storage, m_heaps.ArrayStorage_numValuesInVector);
 4850             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight, ArrayStorage::vectorOffset()));
 4851             m_out.jump(setup);
 4852 
 4853             m_out.appendTo(slowPath, setup);
 4854             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 4855             ASSERT(scratchSize);
 4856             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 4857             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4858             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 4859             m_out.jump(setup);
 4860 
 4861             m_out.appendTo(setup, slowCallPath);
 4862             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 4863             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 4864                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 4865 
 4866                 LValue value = lowJSValue(element);
 4867                 m_out.store64(value, m_out.baseIndex(m_heaps.ArrayStorage_vector.atAnyIndex(), buffer, m_out.constIntPtr(elementIndex), ScaleEight));
 4868             }
 4869             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4870 
 4871             m_out.branch(beyondVectorLength, rarely(slowCallPath), usually(continuation));
 4872 
 4873             m_out.appendTo(slowCallPath, continuation);
 4874             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationArrayPushMultiple), m_callFrame, base, buffer, m_out.constInt32(elementCount)));
 4875             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4876             m_out.jump(continuation);
 4877 
 4878             m_out.appendTo(continuation, lastNext);
 4879             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4880             return;
 4881         }
 4882 
 4883         default:
 4884             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4885             return;
 4886         }
 4887     }
 4888 
 4889     std::pair&lt;LValue, LValue&gt; populateSliceRange(LValue start, LValue end, LValue length)
 4890     {
 4891         // end can be nullptr.
 4892         ASSERT(start);
 4893         ASSERT(length);
 4894 
 4895         auto pickIndex = [&amp;] (LValue index) {
 4896             return m_out.select(m_out.greaterThanOrEqual(index, m_out.int32Zero),
 4897                 m_out.select(m_out.above(index, length), length, index),
 4898                 m_out.select(m_out.lessThan(m_out.add(length, index), m_out.int32Zero), m_out.int32Zero, m_out.add(length, index)));
 4899         };
 4900 
 4901         LValue endBoundary = length;
 4902         if (end)
 4903             endBoundary = pickIndex(end);
 4904         LValue startIndex = pickIndex(start);
 4905         return std::make_pair(startIndex, endBoundary);
 4906     }
 4907 
 4908     void compileArraySlice()
 4909     {
 4910         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 4911 
 4912         LValue sourceArray = lowCell(m_graph.varArgChild(m_node, 0));
 4913         LValue sourceStorage = lowStorage(m_graph.varArgChild(m_node, m_node-&gt;numChildren() - 1));
 4914         LValue inputLength = m_out.load32(sourceStorage, m_heaps.Butterfly_publicLength);
 4915 
 4916         LValue startIndex = nullptr;
 4917         LValue resultLength = nullptr;
 4918         if (m_node-&gt;numChildren() == 2) {
 4919             startIndex = m_out.constInt32(0);
 4920             resultLength = inputLength;
 4921         } else {
 4922             LValue start = lowInt32(m_graph.varArgChild(m_node, 1));
 4923             LValue end = nullptr;
 4924             if (m_node-&gt;numChildren() != 3)
 4925                 end = lowInt32(m_graph.varArgChild(m_node, 2));
 4926 
 4927             auto range = populateSliceRange(start, end, inputLength);
 4928             startIndex = range.first;
 4929             LValue endBoundary = range.second;
 4930 
 4931             resultLength = m_out.select(m_out.belowOrEqual(startIndex, endBoundary),
 4932                 m_out.sub(endBoundary, startIndex),
 4933                 m_out.constInt32(0));
 4934         }
 4935 
 4936         ArrayValues arrayResult;
 4937         {
 4938             LValue indexingType = m_out.load8ZeroExt32(sourceArray, m_heaps.JSCell_indexingTypeAndMisc);
 4939             // We can ignore the writability of the cell since we won&#39;t write to the source.
 4940             indexingType = m_out.bitAnd(indexingType, m_out.constInt32(AllWritableArrayTypesAndHistory));
 4941             // When we emit an ArraySlice, we dominate the use of the array by a CheckStructure
 4942             // to ensure the incoming array is one to be one of the original array structures
 4943             // with one of the following indexing shapes: Int32, Contiguous, Double.
 4944             LValue structure = m_out.select(
 4945                 m_out.equal(indexingType, m_out.constInt32(ArrayWithInt32)),
 4946                 weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))),
 4947                 m_out.select(m_out.equal(indexingType, m_out.constInt32(ArrayWithContiguous)),
 4948                     weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous))),
 4949                     weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithDouble)))));
 4950             arrayResult = allocateJSArray(resultLength, resultLength, structure, indexingType, false, false);
 4951         }
 4952 
 4953         // Keep the sourceArray alive at least until after anything that can GC.
 4954         keepAlive(sourceArray);
 4955 
 4956         LBasicBlock loop = m_out.newBlock();
 4957         LBasicBlock continuation = m_out.newBlock();
 4958 
 4959         resultLength = m_out.zeroExtPtr(resultLength);
 4960         ValueFromBlock startLoadIndex = m_out.anchor(m_out.zeroExtPtr(startIndex));
 4961         ValueFromBlock startStoreIndex = m_out.anchor(m_out.constIntPtr(0));
 4962 
 4963         m_out.branch(
 4964             m_out.below(m_out.constIntPtr(0), resultLength), unsure(loop), unsure(continuation));
 4965 
 4966         LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 4967         LValue storeIndex = m_out.phi(pointerType(), startStoreIndex);
 4968         LValue loadIndex = m_out.phi(pointerType(), startLoadIndex);
 4969         LValue value = m_out.load64(m_out.baseIndex(m_heaps.root, sourceStorage, loadIndex, ScaleEight));
 4970         m_out.store64(value, m_out.baseIndex(m_heaps.root, arrayResult.butterfly, storeIndex, ScaleEight));
 4971         LValue nextStoreIndex = m_out.add(storeIndex, m_out.constIntPtr(1));
 4972         m_out.addIncomingToPhi(storeIndex, m_out.anchor(nextStoreIndex));
 4973         m_out.addIncomingToPhi(loadIndex, m_out.anchor(m_out.add(loadIndex, m_out.constIntPtr(1))));
 4974         m_out.branch(
 4975             m_out.below(nextStoreIndex, resultLength), unsure(loop), unsure(continuation));
 4976 
 4977         m_out.appendTo(continuation, lastNext);
 4978 
 4979         mutatorFence();
 4980         setJSValue(arrayResult.array);
 4981     }
 4982 
 4983     void compileArrayIndexOf()
 4984     {
 4985         LValue storage = lowStorage(m_node-&gt;numChildren() == 3 ? m_graph.varArgChild(m_node, 2) : m_graph.varArgChild(m_node, 3));
 4986         LValue length = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4987 
 4988         LValue startIndex;
 4989         if (m_node-&gt;numChildren() == 4) {
 4990             startIndex = lowInt32(m_graph.varArgChild(m_node, 2));
 4991             startIndex = m_out.select(m_out.greaterThanOrEqual(startIndex, m_out.int32Zero),
 4992                 m_out.select(m_out.above(startIndex, length), length, startIndex),
 4993                 m_out.select(m_out.lessThan(m_out.add(length, startIndex), m_out.int32Zero), m_out.int32Zero, m_out.add(length, startIndex)));
 4994         } else
 4995             startIndex = m_out.int32Zero;
 4996 
 4997         Edge&amp; searchElementEdge = m_graph.varArgChild(m_node, 1);
 4998         switch (searchElementEdge.useKind()) {
 4999         case Int32Use:
 5000         case ObjectUse:
 5001         case SymbolUse:
 5002         case OtherUse:
 5003         case DoubleRepUse: {
 5004             LBasicBlock loopHeader = m_out.newBlock();
 5005             LBasicBlock loopBody = m_out.newBlock();
 5006             LBasicBlock loopNext = m_out.newBlock();
 5007             LBasicBlock notFound = m_out.newBlock();
 5008             LBasicBlock continuation = m_out.newBlock();
 5009 
 5010             LValue searchElement;
 5011             switch (searchElementEdge.useKind()) {
 5012             case Int32Use:
 5013                 ASSERT(m_node-&gt;arrayMode().type() == Array::Int32);
 5014                 speculate(searchElementEdge);
 5015                 searchElement = lowJSValue(searchElementEdge, ManualOperandSpeculation);
 5016                 break;
 5017             case ObjectUse:
 5018                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5019                 searchElement = lowObject(searchElementEdge);
 5020                 break;
 5021             case SymbolUse:
 5022                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5023                 searchElement = lowSymbol(searchElementEdge);
 5024                 break;
 5025             case OtherUse:
 5026                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5027                 speculate(searchElementEdge);
 5028                 searchElement = lowJSValue(searchElementEdge, ManualOperandSpeculation);
 5029                 break;
 5030             case DoubleRepUse:
 5031                 ASSERT(m_node-&gt;arrayMode().type() == Array::Double);
 5032                 searchElement = lowDouble(searchElementEdge);
 5033                 break;
 5034             default:
 5035                 RELEASE_ASSERT_NOT_REACHED();
 5036                 break;
 5037             }
 5038 
 5039             startIndex = m_out.zeroExtPtr(startIndex);
 5040             length = m_out.zeroExtPtr(length);
 5041 
 5042             ValueFromBlock initialStartIndex = m_out.anchor(startIndex);
 5043             m_out.jump(loopHeader);
 5044 
 5045             LBasicBlock lastNext = m_out.appendTo(loopHeader, loopBody);
 5046             LValue index = m_out.phi(pointerType(), initialStartIndex);
 5047             m_out.branch(m_out.notEqual(index, length), unsure(loopBody), unsure(notFound));
 5048 
 5049             m_out.appendTo(loopBody, loopNext);
 5050             ValueFromBlock foundResult = m_out.anchor(index);
 5051             switch (searchElementEdge.useKind()) {
 5052             case Int32Use: {
 5053                 // Empty value is ignored because of TagTypeNumber.
 5054                 LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedInt32Properties, storage, index));
 5055                 m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
 5056                 break;
 5057             }
 5058             case ObjectUse:
 5059             case SymbolUse:
 5060             case OtherUse: {
 5061                 // Empty value never matches against non-empty JS values.
 5062                 LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, index));
 5063                 m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
 5064                 break;
 5065             }
 5066             case DoubleRepUse: {
 5067                 // Empty value is ignored because of NaN.
 5068                 LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, storage, index));
 5069                 m_out.branch(m_out.doubleEqual(value, searchElement), unsure(continuation), unsure(loopNext));
 5070                 break;
 5071             }
 5072             default:
 5073                 RELEASE_ASSERT_NOT_REACHED();
 5074                 break;
 5075             }
 5076 
 5077             m_out.appendTo(loopNext, notFound);
 5078             LValue nextIndex = m_out.add(index, m_out.intPtrOne);
 5079             m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 5080             m_out.jump(loopHeader);
 5081 
 5082             m_out.appendTo(notFound, continuation);
 5083             ValueFromBlock notFoundResult = m_out.anchor(m_out.constIntPtr(-1));
 5084             m_out.jump(continuation);
 5085 
 5086             m_out.appendTo(continuation, lastNext);
 5087             setInt32(m_out.castToInt32(m_out.phi(pointerType(), notFoundResult, foundResult)));
 5088             break;
 5089         }
 5090 
 5091         case StringUse:
 5092             ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5093             setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfString), m_callFrame, storage, lowString(searchElementEdge), startIndex));
 5094             break;
 5095 
 5096         case UntypedUse:
 5097             switch (m_node-&gt;arrayMode().type()) {
 5098             case Array::Double:
 5099                 setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfValueDouble), m_callFrame, storage, lowJSValue(searchElementEdge), startIndex));
 5100                 break;
 5101             case Array::Int32:
 5102             case Array::Contiguous:
 5103                 setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfValueInt32OrContiguous), m_callFrame, storage, lowJSValue(searchElementEdge), startIndex));
 5104                 break;
 5105             default:
 5106                 RELEASE_ASSERT_NOT_REACHED();
 5107                 break;
 5108             }
 5109             break;
 5110 
 5111         default:
 5112             RELEASE_ASSERT_NOT_REACHED();
 5113             break;
 5114         }
 5115     }
 5116 
 5117 
 5118     void compileArrayPop()
 5119     {
 5120         LValue base = lowCell(m_node-&gt;child1());
 5121         LValue storage = lowStorage(m_node-&gt;child2());
 5122 
 5123         switch (m_node-&gt;arrayMode().type()) {
 5124         case Array::Int32:
 5125         case Array::Double:
 5126         case Array::Contiguous: {
 5127             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 5128 
 5129             LBasicBlock fastCase = m_out.newBlock();
 5130             LBasicBlock slowCase = m_out.newBlock();
 5131             LBasicBlock continuation = m_out.newBlock();
 5132 
 5133             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 5134 
 5135             Vector&lt;ValueFromBlock, 3&gt; results;
 5136             results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 5137             m_out.branch(
 5138                 m_out.isZero32(prevLength), rarely(continuation), usually(fastCase));
 5139 
 5140             LBasicBlock lastNext = m_out.appendTo(fastCase, slowCase);
 5141             LValue newLength = m_out.sub(prevLength, m_out.int32One);
 5142             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 5143             TypedPointer pointer = m_out.baseIndex(heap, storage, m_out.zeroExtPtr(newLength));
 5144             if (m_node-&gt;arrayMode().type() != Array::Double) {
 5145                 LValue result = m_out.load64(pointer);
 5146                 m_out.store64(m_out.int64Zero, pointer);
 5147                 results.append(m_out.anchor(result));
 5148                 m_out.branch(
 5149                     m_out.notZero64(result), usually(continuation), rarely(slowCase));
 5150             } else {
 5151                 LValue result = m_out.loadDouble(pointer);
 5152                 m_out.store64(m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN)), pointer);
 5153                 results.append(m_out.anchor(boxDouble(result)));
 5154                 m_out.branch(
 5155                     m_out.doubleEqual(result, result),
 5156                     usually(continuation), rarely(slowCase));
 5157             }
 5158 
 5159             m_out.appendTo(slowCase, continuation);
 5160             results.append(m_out.anchor(vmCall(
 5161                 Int64, m_out.operation(operationArrayPopAndRecoverLength), m_callFrame, base)));
 5162             m_out.jump(continuation);
 5163 
 5164             m_out.appendTo(continuation, lastNext);
 5165             setJSValue(m_out.phi(Int64, results));
 5166             return;
 5167         }
 5168 
 5169         case Array::ArrayStorage: {
 5170             LBasicBlock vectorLengthCheckCase = m_out.newBlock();
 5171             LBasicBlock popCheckCase = m_out.newBlock();
 5172             LBasicBlock fastCase = m_out.newBlock();
 5173             LBasicBlock slowCase = m_out.newBlock();
 5174             LBasicBlock continuation = m_out.newBlock();
 5175 
 5176             LValue prevLength = m_out.load32(storage, m_heaps.ArrayStorage_publicLength);
 5177 
 5178             Vector&lt;ValueFromBlock, 3&gt; results;
 5179             results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 5180             m_out.branch(
 5181                 m_out.isZero32(prevLength), rarely(continuation), usually(vectorLengthCheckCase));
 5182 
 5183             LBasicBlock lastNext = m_out.appendTo(vectorLengthCheckCase, popCheckCase);
 5184             LValue newLength = m_out.sub(prevLength, m_out.int32One);
 5185             m_out.branch(
 5186                 m_out.aboveOrEqual(newLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength)), rarely(slowCase), usually(popCheckCase));
 5187 
 5188             m_out.appendTo(popCheckCase, fastCase);
 5189             TypedPointer pointer = m_out.baseIndex(m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(newLength));
 5190             LValue result = m_out.load64(pointer);
 5191             m_out.branch(m_out.notZero64(result), usually(fastCase), rarely(slowCase));
 5192 
 5193             m_out.appendTo(fastCase, slowCase);
 5194             m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 5195             m_out.store64(m_out.int64Zero, pointer);
 5196             m_out.store32(
 5197                 m_out.sub(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 5198                 storage, m_heaps.ArrayStorage_numValuesInVector);
 5199             results.append(m_out.anchor(result));
 5200             m_out.jump(continuation);
 5201 
 5202             m_out.appendTo(slowCase, continuation);
 5203             results.append(m_out.anchor(vmCall(
 5204                 Int64, m_out.operation(operationArrayPop), m_callFrame, base)));
 5205             m_out.jump(continuation);
 5206 
 5207             m_out.appendTo(continuation, lastNext);
 5208             setJSValue(m_out.phi(Int64, results));
 5209             return;
 5210         }
 5211 
 5212         default:
 5213             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 5214             return;
 5215         }
 5216     }
 5217 
 5218     void compilePushWithScope()
 5219     {
 5220         LValue parentScope = lowCell(m_node-&gt;child1());
 5221         auto objectEdge = m_node-&gt;child2();
 5222         if (objectEdge.useKind() == ObjectUse) {
 5223             LValue object = lowNonNullObject(objectEdge);
 5224             LValue result = vmCall(Int64, m_out.operation(operationPushWithScopeObject), m_callFrame, parentScope, object);
 5225             setJSValue(result);
 5226         } else {
 5227             ASSERT(objectEdge.useKind() == UntypedUse);
 5228             LValue object = lowJSValue(m_node-&gt;child2());
 5229             LValue result = vmCall(Int64, m_out.operation(operationPushWithScope), m_callFrame, parentScope, object);
 5230             setJSValue(result);
 5231         }
 5232     }
 5233 
 5234     void compileCreateActivation()
 5235     {
 5236         LValue scope = lowCell(m_node-&gt;child1());
 5237         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
 5238         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
 5239         JSValue initializationValue = m_node-&gt;initializationValueForActivation();
 5240         ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
<a name="51" id="anc51"></a><span class="line-modified"> 5241         if (table-&gt;singletonScope()-&gt;isStillValid()) {</span>
 5242             LValue callResult = vmCall(
 5243                 Int64,
 5244                 m_out.operation(operationCreateActivationDirect), m_callFrame, weakStructure(structure),
 5245                 scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
 5246             setJSValue(callResult);
 5247             return;
 5248         }
 5249 
 5250         LBasicBlock slowPath = m_out.newBlock();
 5251         LBasicBlock continuation = m_out.newBlock();
 5252 
 5253         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5254 
 5255         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
 5256             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
 5257 
 5258         // We don&#39;t need memory barriers since we just fast-created the activation, so the
 5259         // activation must be young.
 5260         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
 5261         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
 5262 
 5263         for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 5264             m_out.store64(
 5265                 m_out.constInt64(JSValue::encode(initializationValue)),
 5266                 fastObject, m_heaps.JSLexicalEnvironment_variables[i]);
 5267         }
 5268 
 5269         mutatorFence();
 5270 
 5271         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5272         m_out.jump(continuation);
 5273 
 5274         m_out.appendTo(slowPath, continuation);
 5275         VM&amp; vm = this-&gt;vm();
 5276         LValue callResult = lazySlowPath(
 5277             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5278                 return createLazyCallGenerator(vm,
 5279                     operationCreateActivationDirect, locations[0].directGPR(),
 5280                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 5281                     CCallHelpers::TrustedImmPtr(table),
 5282                     CCallHelpers::TrustedImm64(JSValue::encode(initializationValue)));
 5283             },
 5284             scope);
 5285         ValueFromBlock slowResult = m_out.anchor(callResult);
 5286         m_out.jump(continuation);
 5287 
 5288         m_out.appendTo(continuation, lastNext);
 5289         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5290     }
 5291 
 5292     void compileNewFunction()
 5293     {
 5294         ASSERT(m_node-&gt;op() == NewFunction || m_node-&gt;op() == NewGeneratorFunction || m_node-&gt;op() == NewAsyncGeneratorFunction || m_node-&gt;op() == NewAsyncFunction);
 5295         bool isGeneratorFunction = m_node-&gt;op() == NewGeneratorFunction;
 5296         bool isAsyncFunction = m_node-&gt;op() == NewAsyncFunction;
 5297         bool isAsyncGeneratorFunction =  m_node-&gt;op() == NewAsyncGeneratorFunction;
 5298 
 5299         LValue scope = lowCell(m_node-&gt;child1());
 5300 
 5301         FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
<a name="52" id="anc52"></a><span class="line-modified"> 5302         if (executable-&gt;singletonFunction()-&gt;isStillValid()) {</span>
 5303             LValue callResult =
 5304                 isGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5305                 isAsyncFunction ? vmCall(Int64, m_out.operation(operationNewAsyncFunction), m_callFrame, scope, weakPointer(executable)) :
 5306                 isAsyncGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewAsyncGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5307                 vmCall(Int64, m_out.operation(operationNewFunction), m_callFrame, scope, weakPointer(executable));
 5308             setJSValue(callResult);
 5309             return;
 5310         }
 5311 
 5312         RegisteredStructure structure = m_graph.registerStructure(
 5313             [&amp;] () {
 5314                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5315                 switch (m_node-&gt;op()) {
 5316                 case NewGeneratorFunction:
 5317                     return globalObject-&gt;generatorFunctionStructure();
 5318                 case NewAsyncFunction:
 5319                     return globalObject-&gt;asyncFunctionStructure();
 5320                 case NewAsyncGeneratorFunction:
 5321                     return globalObject-&gt;asyncGeneratorFunctionStructure();
 5322                 case NewFunction:
 5323                     return JSFunction::selectStructureForNewFuncExp(globalObject, m_node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 5324                 default:
 5325                     RELEASE_ASSERT_NOT_REACHED();
 5326                 }
 5327             }());
 5328 
 5329         LBasicBlock slowPath = m_out.newBlock();
 5330         LBasicBlock continuation = m_out.newBlock();
 5331 
 5332         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5333 
 5334         LValue fastObject =
 5335             isGeneratorFunction ? allocateObject&lt;JSGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5336             isAsyncFunction ? allocateObject&lt;JSAsyncFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5337             isAsyncGeneratorFunction ? allocateObject&lt;JSAsyncGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5338             allocateObject&lt;JSFunction&gt;(structure, m_out.intPtrZero, slowPath);
 5339 
 5340 
 5341         // We don&#39;t need memory barriers since we just fast-created the function, so it
 5342         // must be young.
 5343         m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
 5344         m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executable);
 5345         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.JSFunction_rareData);
 5346 
<a name="53" id="anc53"></a><span class="line-modified"> 5347         mutatorFence();</span>

















 5348 
 5349         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5350         m_out.jump(continuation);
 5351 
 5352         m_out.appendTo(slowPath, continuation);
 5353 
 5354         Vector&lt;LValue&gt; slowPathArguments;
 5355         slowPathArguments.append(scope);
<a name="54" id="anc54"></a><span class="line-removed"> 5356         VM&amp; vm = this-&gt;vm();</span>
 5357         LValue callResult = lazySlowPath(
 5358             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5359                 auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
 5360                 if (isGeneratorFunction)
 5361                     operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5362                 else if (isAsyncFunction)
 5363                     operation = operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint;
 5364                 else if (isAsyncGeneratorFunction)
 5365                     operation = operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5366 
 5367                 return createLazyCallGenerator(vm, operation,
 5368                     locations[0].directGPR(), locations[1].directGPR(),
 5369                     CCallHelpers::TrustedImmPtr(executable));
 5370             },
 5371             slowPathArguments);
 5372         ValueFromBlock slowResult = m_out.anchor(callResult);
 5373         m_out.jump(continuation);
 5374 
 5375         m_out.appendTo(continuation, lastNext);
 5376         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5377     }
 5378 
 5379     void compileCreateDirectArguments()
 5380     {
 5381         // FIXME: A more effective way of dealing with the argument count and callee is to have
 5382         // them be explicit arguments to this node.
 5383         // https://bugs.webkit.org/show_bug.cgi?id=142207
 5384 
 5385         RegisteredStructure structure =
 5386             m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 5387 
 5388         unsigned minCapacity = m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic)-&gt;numParameters() - 1;
 5389 
 5390         LBasicBlock slowPath = m_out.newBlock();
 5391         LBasicBlock continuation = m_out.newBlock();
 5392 
 5393         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5394 
 5395         ArgumentsLength length = getArgumentsLength();
 5396 
 5397         LValue fastObject;
 5398         if (length.isKnown) {
 5399             fastObject = allocateObject&lt;DirectArguments&gt;(
 5400                 DirectArguments::allocationSize(std::max(length.known, minCapacity)), structure,
 5401                 m_out.intPtrZero, slowPath);
 5402         } else {
 5403             LValue size = m_out.add(
 5404                 m_out.shl(length.value, m_out.constInt32(3)),
 5405                 m_out.constInt32(DirectArguments::storageOffset()));
 5406 
 5407             size = m_out.select(
 5408                 m_out.aboveOrEqual(length.value, m_out.constInt32(minCapacity)),
 5409                 size, m_out.constInt32(DirectArguments::allocationSize(minCapacity)));
 5410 
 5411             fastObject = allocateVariableSizedObject&lt;DirectArguments&gt;(
 5412                 m_out.zeroExtPtr(size), structure, m_out.intPtrZero, slowPath);
 5413         }
 5414 
 5415         m_out.store32(length.value, fastObject, m_heaps.DirectArguments_length);
 5416         m_out.store32(m_out.constInt32(minCapacity), fastObject, m_heaps.DirectArguments_minCapacity);
 5417         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.DirectArguments_mappedArguments);
 5418         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.DirectArguments_modifiedArgumentsDescriptor);
 5419 
 5420         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5421         m_out.jump(continuation);
 5422 
 5423         m_out.appendTo(slowPath, continuation);
 5424         VM&amp; vm = this-&gt;vm();
 5425         LValue callResult = lazySlowPath(
 5426             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5427                 return createLazyCallGenerator(vm,
 5428                     operationCreateDirectArguments, locations[0].directGPR(),
 5429                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 5430                     CCallHelpers::TrustedImm32(minCapacity));
 5431             }, length.value);
 5432         ValueFromBlock slowResult = m_out.anchor(callResult);
 5433         m_out.jump(continuation);
 5434 
 5435         m_out.appendTo(continuation, lastNext);
 5436         LValue result = m_out.phi(pointerType(), fastResult, slowResult);
 5437 
 5438         m_out.storePtr(getCurrentCallee(), result, m_heaps.DirectArguments_callee);
 5439 
 5440         if (length.isKnown) {
 5441             VirtualRegister start = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic);
 5442             for (unsigned i = 0; i &lt; std::max(length.known, minCapacity); ++i) {
 5443                 m_out.store64(
 5444                     m_out.load64(addressFor(start + i)),
 5445                     result, m_heaps.DirectArguments_storage[i]);
 5446             }
 5447         } else {
 5448             LValue stackBase = getArgumentsStart();
 5449 
 5450             LBasicBlock loop = m_out.newBlock();
 5451             LBasicBlock end = m_out.newBlock();
 5452 
 5453             ValueFromBlock originalLength;
 5454             if (minCapacity) {
 5455                 LValue capacity = m_out.select(
 5456                     m_out.aboveOrEqual(length.value, m_out.constInt32(minCapacity)),
 5457                     length.value,
 5458                     m_out.constInt32(minCapacity));
 5459                 LValue originalLengthValue = m_out.zeroExtPtr(capacity);
 5460                 originalLength = m_out.anchor(originalLengthValue);
 5461                 m_out.jump(loop);
 5462             } else {
 5463                 LValue originalLengthValue = m_out.zeroExtPtr(length.value);
 5464                 originalLength = m_out.anchor(originalLengthValue);
 5465                 m_out.branch(m_out.isNull(originalLengthValue), unsure(end), unsure(loop));
 5466             }
 5467 
 5468             lastNext = m_out.appendTo(loop, end);
 5469             LValue previousIndex = m_out.phi(pointerType(), originalLength);
 5470             LValue index = m_out.sub(previousIndex, m_out.intPtrOne);
 5471             m_out.store64(
 5472                 m_out.load64(m_out.baseIndex(m_heaps.variables, stackBase, index)),
 5473                 m_out.baseIndex(m_heaps.DirectArguments_storage, result, index));
 5474             ValueFromBlock nextIndex = m_out.anchor(index);
 5475             m_out.addIncomingToPhi(previousIndex, nextIndex);
 5476             m_out.branch(m_out.isNull(index), unsure(end), unsure(loop));
 5477 
 5478             m_out.appendTo(end, lastNext);
 5479         }
 5480 
 5481         mutatorFence();
 5482 
 5483         setJSValue(result);
 5484     }
 5485 
 5486     void compileCreateScopedArguments()
 5487     {
 5488         LValue scope = lowCell(m_node-&gt;child1());
 5489 
 5490         LValue result = vmCall(
 5491             Int64, m_out.operation(operationCreateScopedArguments), m_callFrame,
 5492             weakPointer(
 5493                 m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),
 5494             getArgumentsStart(), getArgumentsLength().value, getCurrentCallee(), scope);
 5495 
 5496         setJSValue(result);
 5497     }
 5498 
 5499     void compileCreateClonedArguments()
 5500     {
 5501         LValue result = vmCall(
 5502             Int64, m_out.operation(operationCreateClonedArguments), m_callFrame,
 5503             weakPointer(
 5504                 m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),
 5505             getArgumentsStart(), getArgumentsLength().value, getCurrentCallee());
 5506 
 5507         setJSValue(result);
 5508     }
 5509 
 5510     void compileCreateRest()
 5511     {
 5512         if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 5513             LBasicBlock continuation = m_out.newBlock();
 5514             LValue arrayLength = lowInt32(m_node-&gt;child1());
 5515             LBasicBlock loopStart = m_out.newBlock();
 5516             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5517             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;originalRestParameterStructure());
 5518             ArrayValues arrayValues = allocateUninitializedContiguousJSArray(arrayLength, structure);
 5519             LValue array = arrayValues.array;
 5520             LValue butterfly = arrayValues.butterfly;
 5521             ValueFromBlock startLength = m_out.anchor(arrayLength);
 5522             LValue argumentRegion = m_out.add(getArgumentsStart(), m_out.constInt64(sizeof(Register) * m_node-&gt;numberOfArgumentsToSkip()));
 5523             m_out.branch(m_out.equal(arrayLength, m_out.constInt32(0)),
 5524                 unsure(continuation), unsure(loopStart));
 5525 
 5526             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 5527             LValue phiOffset = m_out.phi(Int32, startLength);
 5528             LValue currentOffset = m_out.sub(phiOffset, m_out.int32One);
 5529             m_out.addIncomingToPhi(phiOffset, m_out.anchor(currentOffset));
 5530             LValue loadedValue = m_out.load64(m_out.baseIndex(m_heaps.variables, argumentRegion, m_out.zeroExtPtr(currentOffset)));
 5531             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 5532             m_out.store64(loadedValue, m_out.baseIndex(heap, butterfly, m_out.zeroExtPtr(currentOffset)));
 5533             m_out.branch(m_out.equal(currentOffset, m_out.constInt32(0)), unsure(continuation), unsure(loopStart));
 5534 
 5535             m_out.appendTo(continuation, lastNext);
 5536             mutatorFence();
 5537             setJSValue(array);
 5538             return;
 5539         }
 5540 
 5541         LValue arrayLength = lowInt32(m_node-&gt;child1());
 5542         LValue argumentStart = getArgumentsStart();
 5543         LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 5544         setJSValue(vmCall(
 5545             Int64, m_out.operation(operationCreateRest), m_callFrame, argumentStart, numberOfArgumentsToSkip, arrayLength));
 5546     }
 5547 
 5548     void compileGetRestLength()
 5549     {
 5550         LBasicBlock nonZeroLength = m_out.newBlock();
 5551         LBasicBlock continuation = m_out.newBlock();
 5552 
 5553         ValueFromBlock zeroLengthResult = m_out.anchor(m_out.constInt32(0));
 5554 
 5555         LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 5556         LValue argumentsLength = getArgumentsLength().value;
 5557         m_out.branch(m_out.above(argumentsLength, numberOfArgumentsToSkip),
 5558             unsure(nonZeroLength), unsure(continuation));
 5559 
 5560         LBasicBlock lastNext = m_out.appendTo(nonZeroLength, continuation);
 5561         ValueFromBlock nonZeroLengthResult = m_out.anchor(m_out.sub(argumentsLength, numberOfArgumentsToSkip));
 5562         m_out.jump(continuation);
 5563 
 5564         m_out.appendTo(continuation, lastNext);
 5565         setInt32(m_out.phi(Int32, zeroLengthResult, nonZeroLengthResult));
 5566     }
 5567 
 5568     void compileObjectKeys()
 5569     {
 5570         switch (m_node-&gt;child1().useKind()) {
 5571         case ObjectUse: {
 5572             if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 5573                 LBasicBlock notNullCase = m_out.newBlock();
 5574                 LBasicBlock rareDataCase = m_out.newBlock();
 5575                 LBasicBlock useCacheCase = m_out.newBlock();
 5576                 LBasicBlock slowButArrayBufferCase = m_out.newBlock();
 5577                 LBasicBlock slowCase = m_out.newBlock();
 5578                 LBasicBlock continuation = m_out.newBlock();
 5579 
 5580                 LValue object = lowObject(m_node-&gt;child1());
 5581                 LValue structure = loadStructure(object);
 5582                 LValue previousOrRareData = m_out.loadPtr(structure, m_heaps.Structure_previousOrRareData);
 5583                 m_out.branch(m_out.notNull(previousOrRareData), unsure(notNullCase), unsure(slowCase));
 5584 
 5585                 LBasicBlock lastNext = m_out.appendTo(notNullCase, rareDataCase);
 5586                 m_out.branch(
 5587                     m_out.notEqual(m_out.load32(previousOrRareData, m_heaps.JSCell_structureID), m_out.constInt32(m_graph.m_vm.structureStructure-&gt;structureID())),
 5588                     unsure(rareDataCase), unsure(slowCase));
 5589 
 5590                 m_out.appendTo(rareDataCase, useCacheCase);
 5591                 ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
 5592                 LValue cachedOwnKeys = m_out.loadPtr(previousOrRareData, m_heaps.StructureRareData_cachedOwnKeys);
 5593                 m_out.branch(m_out.belowOrEqual(cachedOwnKeys, m_out.constIntPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))), unsure(slowCase), unsure(useCacheCase));
 5594 
 5595                 m_out.appendTo(useCacheCase, slowButArrayBufferCase);
 5596                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5597                 RegisteredStructure arrayStructure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
 5598                 LValue fastArray = allocateObject&lt;JSArray&gt;(arrayStructure, m_out.addPtr(cachedOwnKeys, JSImmutableButterfly::offsetOfData()), slowButArrayBufferCase);
 5599                 ValueFromBlock fastResult = m_out.anchor(fastArray);
 5600                 m_out.jump(continuation);
 5601 
 5602                 m_out.appendTo(slowButArrayBufferCase, slowCase);
 5603                 LValue slowArray = vmCall(Int64, m_out.operation(operationNewArrayBuffer), m_callFrame, weakStructure(arrayStructure), cachedOwnKeys);
 5604                 ValueFromBlock slowButArrayBufferResult = m_out.anchor(slowArray);
 5605                 m_out.jump(continuation);
 5606 
 5607                 m_out.appendTo(slowCase, continuation);
 5608                 VM&amp; vm = this-&gt;vm();
 5609                 LValue slowResultValue = lazySlowPath(
 5610                     [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5611                         return createLazyCallGenerator(vm,
 5612                             operationObjectKeysObject, locations[0].directGPR(), locations[1].directGPR());
 5613                     },
 5614                     object);
 5615                 ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 5616                 m_out.jump(continuation);
 5617 
 5618                 m_out.appendTo(continuation, lastNext);
 5619                 setJSValue(m_out.phi(pointerType(), fastResult, slowButArrayBufferResult, slowResult));
 5620                 break;
 5621             }
 5622             setJSValue(vmCall(Int64, m_out.operation(operationObjectKeysObject), m_callFrame, lowObject(m_node-&gt;child1())));
 5623             break;
 5624         }
 5625         case UntypedUse:
 5626             setJSValue(vmCall(Int64, m_out.operation(operationObjectKeys), m_callFrame, lowJSValue(m_node-&gt;child1())));
 5627             break;
 5628         default:
 5629             RELEASE_ASSERT_NOT_REACHED();
 5630             break;
 5631         }
 5632     }
 5633 
 5634     void compileObjectCreate()
 5635     {
 5636         switch (m_node-&gt;child1().useKind()) {
 5637         case ObjectUse:
 5638             setJSValue(vmCall(Int64, m_out.operation(operationObjectCreateObject), m_callFrame, lowObject(m_node-&gt;child1())));
 5639             break;
 5640         case UntypedUse:
 5641             setJSValue(vmCall(Int64, m_out.operation(operationObjectCreate), m_callFrame, lowJSValue(m_node-&gt;child1())));
 5642             break;
 5643         default:
 5644             RELEASE_ASSERT_NOT_REACHED();
 5645             break;
 5646         }
 5647     }
 5648 
 5649     void compileNewObject()
 5650     {
 5651         setJSValue(allocateObject(m_node-&gt;structure()));
 5652         mutatorFence();
 5653     }
 5654 
 5655     void compileNewStringObject()
 5656     {
 5657         RegisteredStructure structure = m_node-&gt;structure();
 5658         LValue string = lowString(m_node-&gt;child1());
 5659 
 5660         LBasicBlock slowCase = m_out.newBlock();
 5661         LBasicBlock continuation = m_out.newBlock();
 5662 
 5663         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
 5664 
 5665         LValue fastResultValue = allocateObject&lt;StringObject&gt;(structure, m_out.intPtrZero, slowCase);
 5666         m_out.storePtr(m_out.constIntPtr(StringObject::info()), fastResultValue, m_heaps.JSDestructibleObject_classInfo);
 5667         m_out.store64(string, fastResultValue, m_heaps.JSWrapperObject_internalValue);
 5668         mutatorFence();
 5669         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 5670         m_out.jump(continuation);
 5671 
 5672         m_out.appendTo(slowCase, continuation);
 5673         VM&amp; vm = this-&gt;vm();
 5674         LValue slowResultValue = lazySlowPath(
 5675             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5676                 return createLazyCallGenerator(vm,
 5677                     operationNewStringObject, locations[0].directGPR(), locations[1].directGPR(),
 5678                     CCallHelpers::TrustedImmPtr(structure.get()));
 5679             },
 5680             string);
 5681         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 5682         m_out.jump(continuation);
 5683 
 5684         m_out.appendTo(continuation, lastNext);
 5685         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5686     }
 5687 
 5688     void compileNewSymbol()
 5689     {
 5690         if (!m_node-&gt;child1()) {
 5691             setJSValue(vmCall(pointerType(), m_out.operation(operationNewSymbol), m_callFrame));
 5692             return;
 5693         }
 5694         ASSERT(m_node-&gt;child1().useKind() == KnownStringUse);
 5695         setJSValue(vmCall(pointerType(), m_out.operation(operationNewSymbolWithDescription), m_callFrame, lowString(m_node-&gt;child1())));
 5696     }
 5697 
 5698     void compileNewArray()
 5699     {
 5700         // First speculate appropriately on all of the children. Do this unconditionally up here
 5701         // because some of the slow paths may otherwise forget to do it. It&#39;s sort of arguable
 5702         // that doing the speculations up here might be unprofitable for RA - so we can consider
 5703         // sinking this to below the allocation fast path if we find that this has a lot of
 5704         // register pressure.
 5705         for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex)
 5706             speculate(m_graph.varArgChild(m_node, operandIndex));
 5707 
 5708         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5709         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 5710             m_node-&gt;indexingType()));
 5711 
 5712         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingType())) {
 5713             unsigned numElements = m_node-&gt;numChildren();
 5714             unsigned vectorLengthHint = m_node-&gt;vectorLengthHint();
 5715             ASSERT(vectorLengthHint &gt;= numElements);
 5716 
 5717             ArrayValues arrayValues =
 5718                 allocateUninitializedContiguousJSArray(numElements, vectorLengthHint, structure);
 5719 
 5720             for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex) {
 5721                 Edge edge = m_graph.varArgChild(m_node, operandIndex);
 5722 
 5723                 switch (m_node-&gt;indexingType()) {
 5724                 case ALL_BLANK_INDEXING_TYPES:
 5725                 case ALL_UNDECIDED_INDEXING_TYPES:
 5726                     DFG_CRASH(m_graph, m_node, &quot;Bad indexing type&quot;);
 5727                     break;
 5728 
 5729                 case ALL_DOUBLE_INDEXING_TYPES:
 5730                     m_out.storeDouble(
 5731                         lowDouble(edge),
 5732                         arrayValues.butterfly, m_heaps.indexedDoubleProperties[operandIndex]);
 5733                     break;
 5734 
 5735                 case ALL_INT32_INDEXING_TYPES:
 5736                 case ALL_CONTIGUOUS_INDEXING_TYPES:
 5737                     m_out.store64(
 5738                         lowJSValue(edge, ManualOperandSpeculation),
 5739                         arrayValues.butterfly,
 5740                         m_heaps.forIndexingType(m_node-&gt;indexingType())-&gt;at(operandIndex));
 5741                     break;
 5742 
 5743                 default:
 5744                     DFG_CRASH(m_graph, m_node, &quot;Corrupt indexing type&quot;);
 5745                     break;
 5746                 }
 5747             }
 5748 
 5749             setJSValue(arrayValues.array);
 5750             mutatorFence();
 5751             return;
 5752         }
 5753 
 5754         if (!m_node-&gt;numChildren()) {
 5755             setJSValue(vmCall(
 5756                 Int64, m_out.operation(operationNewEmptyArray), m_callFrame,
 5757                 weakStructure(structure)));
 5758             return;
 5759         }
 5760 
 5761         size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
 5762         ASSERT(scratchSize);
 5763         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 5764         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 5765 
 5766         for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex) {
 5767             Edge edge = m_graph.varArgChild(m_node, operandIndex);
 5768             LValue valueToStore;
 5769             switch (m_node-&gt;indexingType()) {
 5770             case ALL_DOUBLE_INDEXING_TYPES:
 5771                 valueToStore = boxDouble(lowDouble(edge));
 5772                 break;
 5773             default:
 5774                 valueToStore = lowJSValue(edge, ManualOperandSpeculation);
 5775                 break;
 5776             }
 5777             m_out.store64(valueToStore, m_out.absolute(buffer + operandIndex));
 5778         }
 5779 
 5780         m_out.storePtr(
 5781             m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5782 
 5783         LValue result = vmCall(
 5784             Int64, m_out.operation(operationNewArray), m_callFrame,
 5785             weakStructure(structure), m_out.constIntPtr(buffer),
 5786             m_out.constIntPtr(m_node-&gt;numChildren()));
 5787 
 5788         m_out.storePtr(m_out.intPtrZero, m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5789 
 5790         setJSValue(result);
 5791     }
 5792 
 5793     void compileNewArrayWithSpread()
 5794     {
 5795         if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 5796             CheckedInt32 startLength = 0;
 5797             BitVector* bitVector = m_node-&gt;bitVector();
 5798             HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 5799 
 5800             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 5801                 if (!bitVector-&gt;get(i))
 5802                     ++startLength;
 5803                 else {
 5804                     Edge&amp; child = m_graph.varArgChild(m_node, i);
 5805                     if (child-&gt;op() == PhantomSpread &amp;&amp; child-&gt;child1()-&gt;op() == PhantomNewArrayBuffer)
 5806                         startLength += child-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 5807                 }
 5808             }
 5809 
 5810             if (startLength.hasOverflowed()) {
 5811                 terminate(Overflow);
 5812                 return;
 5813             }
 5814 
 5815             LValue length = m_out.constInt32(startLength.unsafeGet());
 5816 
 5817             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 5818                 if (bitVector-&gt;get(i)) {
 5819                     Edge use = m_graph.varArgChild(m_node, i);
 5820                     CheckValue* lengthCheck = nullptr;
 5821                     if (use-&gt;op() == PhantomSpread) {
 5822                         if (use-&gt;child1()-&gt;op() == PhantomCreateRest) {
<a name="55" id="anc55"></a><span class="line-modified"> 5823                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 5824                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 5825                             LValue spreadLength = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 5826                                 return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 5827                             }).iterator-&gt;value;
 5828                             lengthCheck = m_out.speculateAdd(length, spreadLength);
 5829                         }
 5830                     } else {
 5831                         LValue fixedArray = lowCell(use);
 5832                         lengthCheck = m_out.speculateAdd(length, m_out.load32(fixedArray, m_heaps.JSFixedArray_size));
 5833                     }
 5834 
 5835                     if (lengthCheck) {
 5836                         blessSpeculation(lengthCheck, Overflow, noValue(), nullptr, m_origin);
 5837                         length = lengthCheck;
 5838                     }
 5839                 }
 5840             }
 5841 
 5842             LValue exceedsMaxAllowedLength = m_out.aboveOrEqual(length, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
 5843             blessSpeculation(m_out.speculate(exceedsMaxAllowedLength), Overflow, noValue(), nullptr, m_origin);
 5844 
 5845             RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));
 5846             ArrayValues arrayValues = allocateUninitializedContiguousJSArray(length, structure);
 5847             LValue result = arrayValues.array;
 5848             LValue storage = arrayValues.butterfly;
 5849             LValue index = m_out.constIntPtr(0);
 5850 
 5851             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 5852                 Edge use = m_graph.varArgChild(m_node, i);
 5853                 if (bitVector-&gt;get(i)) {
 5854                     if (use-&gt;op() == PhantomSpread) {
 5855                         if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
 5856                             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 5857                             auto* array = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 5858                             for (unsigned i = 0; i &lt; array-&gt;length(); ++i) {
 5859                                 // Because resulted array from NewArrayWithSpread is always contiguous, we should not generate value
 5860                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 5861                                 int64_t value = JSValue::encode(array-&gt;get(i));
 5862                                 m_out.store64(m_out.constInt64(value), m_out.baseIndex(heap, storage, index, JSValue(), (Checked&lt;int32_t&gt;(sizeof(JSValue)) * i).unsafeGet()));
 5863                             }
 5864                             index = m_out.add(index, m_out.constIntPtr(array-&gt;length()));
 5865                         } else {
 5866                             RELEASE_ASSERT(use-&gt;child1()-&gt;op() == PhantomCreateRest);
<a name="56" id="anc56"></a><span class="line-modified"> 5867                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 5868                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 5869 
 5870                             LValue length = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 5871                             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 5872 
 5873                             LBasicBlock loopStart = m_out.newBlock();
 5874                             LBasicBlock continuation = m_out.newBlock();
 5875 
 5876                             ValueFromBlock loadIndexStart = m_out.anchor(m_out.constIntPtr(0));
 5877                             ValueFromBlock arrayIndexStart = m_out.anchor(index);
 5878                             ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 5879 
 5880                             m_out.branch(
 5881                                 m_out.isZero64(length),
 5882                                 unsure(continuation), unsure(loopStart));
 5883 
 5884                             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 5885 
 5886                             LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
 5887                             LValue loadIndex = m_out.phi(pointerType(), loadIndexStart);
 5888 
 5889                             LValue item = m_out.load64(m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 5890                             m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
 5891 
 5892                             LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
 5893                             LValue nextLoadIndex = m_out.add(loadIndex, m_out.constIntPtr(1));
 5894                             ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
 5895 
 5896                             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
 5897                             m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
 5898 
 5899                             m_out.branch(
 5900                                 m_out.below(nextLoadIndex, length),
 5901                                 unsure(loopStart), unsure(continuation));
 5902 
 5903                             m_out.appendTo(continuation, lastNext);
 5904                             index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
 5905                         }
 5906                     } else {
 5907                         LBasicBlock loopStart = m_out.newBlock();
 5908                         LBasicBlock continuation = m_out.newBlock();
 5909 
 5910                         LValue fixedArray = lowCell(use);
 5911 
 5912                         ValueFromBlock fixedIndexStart = m_out.anchor(m_out.constIntPtr(0));
 5913                         ValueFromBlock arrayIndexStart = m_out.anchor(index);
 5914                         ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 5915 
 5916                         LValue fixedArraySize = m_out.zeroExtPtr(m_out.load32(fixedArray, m_heaps.JSFixedArray_size));
 5917 
 5918                         m_out.branch(
 5919                             m_out.isZero64(fixedArraySize),
 5920                             unsure(continuation), unsure(loopStart));
 5921 
 5922                         LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 5923 
 5924                         LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
 5925                         LValue fixedArrayIndex = m_out.phi(pointerType(), fixedIndexStart);
 5926 
 5927                         LValue item = m_out.load64(m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, fixedArrayIndex));
 5928                         m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
 5929 
 5930                         LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
 5931                         LValue nextFixedArrayIndex = m_out.add(fixedArrayIndex, m_out.constIntPtr(1));
 5932                         ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
 5933 
 5934                         m_out.addIncomingToPhi(fixedArrayIndex, m_out.anchor(nextFixedArrayIndex));
 5935                         m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
 5936 
 5937                         m_out.branch(
 5938                             m_out.below(nextFixedArrayIndex, fixedArraySize),
 5939                             unsure(loopStart), unsure(continuation));
 5940 
 5941                         m_out.appendTo(continuation, lastNext);
 5942                         index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
 5943                     }
 5944                 } else {
 5945                     IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 5946                     LValue item = lowJSValue(use);
 5947                     m_out.store64(item, m_out.baseIndex(heap, storage, index));
 5948                     index = m_out.add(index, m_out.constIntPtr(1));
 5949                 }
 5950             }
 5951 
 5952             mutatorFence();
 5953             setJSValue(result);
 5954             return;
 5955         }
 5956 
 5957         ASSERT(m_node-&gt;numChildren());
 5958         size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
 5959         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 5960         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 5961         BitVector* bitVector = m_node-&gt;bitVector();
 5962         for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 5963             Edge use = m_graph.m_varArgChildren[m_node-&gt;firstChild() + i];
 5964             LValue value;
 5965             if (bitVector-&gt;get(i))
 5966                 value = lowCell(use);
 5967             else
 5968                 value = lowJSValue(use);
 5969             m_out.store64(value, m_out.absolute(&amp;buffer[i]));
 5970         }
 5971 
 5972         m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5973         LValue result = vmCall(Int64, m_out.operation(operationNewArrayWithSpreadSlow), m_callFrame, m_out.constIntPtr(buffer), m_out.constInt32(m_node-&gt;numChildren()));
 5974         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5975 
 5976         setJSValue(result);
 5977     }
 5978 
 5979     void compileCreateThis()
 5980     {
 5981         LValue callee = lowCell(m_node-&gt;child1());
 5982 
 5983         LBasicBlock isFunctionBlock = m_out.newBlock();
 5984         LBasicBlock hasRareData = m_out.newBlock();
 5985         LBasicBlock slowPath = m_out.newBlock();
 5986         LBasicBlock continuation = m_out.newBlock();
 5987 
 5988         m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowPath));
 5989 
 5990         LBasicBlock lastNext = m_out.appendTo(isFunctionBlock, hasRareData);
 5991         LValue rareData = m_out.loadPtr(callee, m_heaps.JSFunction_rareData);
 5992         m_out.branch(m_out.isZero64(rareData), rarely(slowPath), usually(hasRareData));
 5993 
 5994         m_out.appendTo(hasRareData, slowPath);
 5995         LValue allocator = m_out.loadPtr(rareData, m_heaps.FunctionRareData_allocator);
 5996         LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_structure);
 5997         LValue butterfly = m_out.constIntPtr(0);
 5998         ValueFromBlock fastResult = m_out.anchor(allocateObject(allocator, structure, butterfly, slowPath));
 5999         m_out.jump(continuation);
 6000 
 6001         m_out.appendTo(slowPath, continuation);
 6002         ValueFromBlock slowResult = m_out.anchor(vmCall(
 6003             Int64, m_out.operation(operationCreateThis), m_callFrame, callee, m_out.constInt32(m_node-&gt;inlineCapacity())));
 6004         m_out.jump(continuation);
 6005 
 6006         m_out.appendTo(continuation, lastNext);
 6007         LValue result = m_out.phi(Int64, fastResult, slowResult);
 6008 
 6009         mutatorFence();
 6010         setJSValue(result);
 6011     }
 6012 
 6013     void compileSpread()
 6014     {
 6015         if (m_node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
 6016             LBasicBlock slowAllocation = m_out.newBlock();
 6017             LBasicBlock continuation = m_out.newBlock();
 6018 
 6019             auto* immutableButterfly = m_node-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6020 
 6021             LValue fastFixedArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(
 6022                 m_out.constIntPtr(JSFixedArray::allocationSize(immutableButterfly-&gt;length()).unsafeGet()),
 6023                 m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);
 6024             m_out.store32(m_out.constInt32(immutableButterfly-&gt;length()), fastFixedArrayValue, m_heaps.JSFixedArray_size);
 6025             ValueFromBlock fastFixedArray = m_out.anchor(fastFixedArrayValue);
 6026             m_out.jump(continuation);
 6027 
 6028             LBasicBlock lastNext = m_out.appendTo(slowAllocation, continuation);
 6029             ValueFromBlock slowFixedArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, m_out.constInt32(immutableButterfly-&gt;length())));
 6030             m_out.jump(continuation);
 6031 
 6032             m_out.appendTo(continuation, lastNext);
 6033             LValue fixedArray = m_out.phi(pointerType(), fastFixedArray, slowFixedArray);
 6034             for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); i++) {
 6035                 // Because forwarded values are drained as JSValue, we should not generate value
 6036                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 6037                 int64_t value = JSValue::encode(immutableButterfly-&gt;get(i));
 6038                 m_out.store64(
 6039                     m_out.constInt64(value),
 6040                     m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, m_out.constIntPtr(i), jsNumber(i)));
 6041             }
 6042             mutatorFence();
 6043             setJSValue(fixedArray);
 6044             return;
 6045         }
 6046 
 6047         if (m_node-&gt;child1()-&gt;op() == PhantomCreateRest) {
 6048             // This IR is rare to generate since it requires escaping the Spread
 6049             // but not the CreateRest. In bytecode, we have only few operations that
 6050             // accept Spread&#39;s result as input. This usually leads to the Spread node not
 6051             // escaping. However, this can happen if for example we generate a PutStack on
 6052             // the Spread but nothing escapes the CreateRest.
 6053             LBasicBlock loopHeader = m_out.newBlock();
 6054             LBasicBlock loopBody = m_out.newBlock();
 6055             LBasicBlock slowAllocation = m_out.newBlock();
 6056             LBasicBlock continuation = m_out.newBlock();
 6057             LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopHeader);
 6058 
<a name="57" id="anc57"></a><span class="line-modified"> 6059             InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 6060             unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6061             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6062             LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6063             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6064             LValue size = m_out.add(
 6065                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
 6066                 m_out.constIntPtr(JSFixedArray::offsetOfData()));
 6067 
 6068             LValue fastArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);
 6069             m_out.store32(length, fastArrayValue, m_heaps.JSFixedArray_size);
 6070             ValueFromBlock fastArray = m_out.anchor(fastArrayValue);
 6071             m_out.jump(loopHeader);
 6072 
 6073             m_out.appendTo(slowAllocation, loopHeader);
 6074             ValueFromBlock slowArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, length));
 6075             m_out.jump(loopHeader);
 6076 
 6077             m_out.appendTo(loopHeader, loopBody);
 6078             LValue fixedArray = m_out.phi(pointerType(), fastArray, slowArray);
 6079             ValueFromBlock startIndex = m_out.anchor(m_out.constIntPtr(0));
 6080             m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopBody));
 6081 
 6082             m_out.appendTo(loopBody, continuation);
 6083             LValue index = m_out.phi(pointerType(), startIndex);
 6084             LValue value = m_out.load64(
 6085                 m_out.baseIndex(m_heaps.variables, sourceStart, index));
 6086             m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, index));
 6087             LValue nextIndex = m_out.add(m_out.constIntPtr(1), index);
 6088             m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6089             m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)), unsure(loopBody), unsure(continuation));
 6090 
 6091             m_out.appendTo(continuation, lastNext);
 6092             mutatorFence();
 6093             setJSValue(fixedArray);
 6094             return;
 6095         }
 6096 
 6097         LValue argument = lowCell(m_node-&gt;child1());
 6098 
 6099         LValue result;
 6100 
 6101         if (m_node-&gt;child1().useKind() == ArrayUse)
 6102             speculateArray(m_node-&gt;child1());
 6103 
 6104         if (m_graph.canDoFastSpread(m_node, m_state.forNode(m_node-&gt;child1()))) {
 6105             LBasicBlock preLoop = m_out.newBlock();
 6106             LBasicBlock loopSelection = m_out.newBlock();
 6107             LBasicBlock contiguousLoopStart = m_out.newBlock();
 6108             LBasicBlock doubleLoopStart = m_out.newBlock();
 6109             LBasicBlock slowPath = m_out.newBlock();
 6110             LBasicBlock continuation = m_out.newBlock();
 6111 
 6112             LValue indexingShape = m_out.load8ZeroExt32(argument, m_heaps.JSCell_indexingTypeAndMisc);
 6113             indexingShape = m_out.bitAnd(indexingShape, m_out.constInt32(IndexingShapeMask));
 6114             LValue isOKIndexingType = m_out.belowOrEqual(
 6115                 m_out.sub(indexingShape, m_out.constInt32(Int32Shape)),
 6116                 m_out.constInt32(ContiguousShape - Int32Shape));
 6117 
 6118             m_out.branch(isOKIndexingType, unsure(preLoop), unsure(slowPath));
 6119             LBasicBlock lastNext = m_out.appendTo(preLoop, loopSelection);
 6120 
 6121             LValue butterfly = m_out.loadPtr(argument, m_heaps.JSObject_butterfly);
 6122             LValue length = m_out.load32NonNegative(butterfly, m_heaps.Butterfly_publicLength);
 6123             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6124             LValue size = m_out.add(
 6125                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
 6126                 m_out.constIntPtr(JSFixedArray::offsetOfData()));
 6127 
 6128             LValue fastAllocation = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowPath);
 6129             ValueFromBlock fastResult = m_out.anchor(fastAllocation);
 6130             m_out.store32(length, fastAllocation, m_heaps.JSFixedArray_size);
 6131 
 6132             ValueFromBlock startIndexForContiguous = m_out.anchor(m_out.constIntPtr(0));
 6133             ValueFromBlock startIndexForDouble = m_out.anchor(m_out.constIntPtr(0));
 6134 
 6135             m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopSelection));
 6136 
 6137             m_out.appendTo(loopSelection, contiguousLoopStart);
 6138             m_out.branch(m_out.equal(indexingShape, m_out.constInt32(DoubleShape)),
 6139                 unsure(doubleLoopStart), unsure(contiguousLoopStart));
 6140 
 6141             {
 6142                 m_out.appendTo(contiguousLoopStart, doubleLoopStart);
 6143                 LValue index = m_out.phi(pointerType(), startIndexForContiguous);
 6144 
 6145                 TypedPointer loadSite = m_out.baseIndex(m_heaps.root, butterfly, index, ScaleEight); // We read TOP here since we can be reading either int32 or contiguous properties.
 6146                 LValue value = m_out.load64(loadSite);
 6147                 value = m_out.select(m_out.isZero64(value), m_out.constInt64(JSValue::encode(jsUndefined())), value);
 6148                 m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fastAllocation, index));
 6149 
 6150                 LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
 6151                 m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6152 
 6153                 m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
 6154                     unsure(contiguousLoopStart), unsure(continuation));
 6155             }
 6156 
 6157             {
 6158                 m_out.appendTo(doubleLoopStart, slowPath);
 6159                 LValue index = m_out.phi(pointerType(), startIndexForDouble);
 6160 
 6161                 LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, butterfly, index));
 6162                 LValue isNaN = m_out.doubleNotEqualOrUnordered(value, value);
 6163                 LValue holeResult = m_out.constInt64(JSValue::encode(jsUndefined()));
 6164                 LValue normalResult = boxDouble(value);
 6165                 value = m_out.select(isNaN, holeResult, normalResult);
 6166                 m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fastAllocation, index));
 6167 
 6168                 LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
 6169                 m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6170 
 6171                 m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
 6172                     unsure(doubleLoopStart), unsure(continuation));
 6173             }
 6174 
 6175             m_out.appendTo(slowPath, continuation);
 6176             ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_out.operation(operationSpreadFastArray), m_callFrame, argument));
 6177             m_out.jump(continuation);
 6178 
 6179             m_out.appendTo(continuation, lastNext);
 6180             result = m_out.phi(pointerType(), fastResult, slowResult);
 6181             mutatorFence();
 6182         } else
 6183             result = vmCall(pointerType(), m_out.operation(operationSpreadGeneric), m_callFrame, argument);
 6184 
 6185         setJSValue(result);
 6186     }
 6187 
 6188     void compileNewArrayBuffer()
 6189     {
 6190         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6191         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 6192             m_node-&gt;indexingMode()));
 6193         auto* immutableButterfly = m_node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6194 
 6195         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingMode())) {
 6196             LBasicBlock slowPath = m_out.newBlock();
 6197             LBasicBlock continuation = m_out.newBlock();
 6198 
 6199             LValue fastArray = allocateObject&lt;JSArray&gt;(structure, m_out.constIntPtr(immutableButterfly-&gt;toButterfly()), slowPath);
 6200             ValueFromBlock fastResult = m_out.anchor(fastArray);
 6201             m_out.jump(continuation);
 6202 
 6203             m_out.appendTo(slowPath, continuation);
 6204             LValue slowArray = vmCall(Int64, m_out.operation(operationNewArrayBuffer), m_callFrame, weakStructure(structure), m_out.weakPointer(m_node-&gt;cellOperand()));
 6205             ValueFromBlock slowResult = m_out.anchor(slowArray);
 6206             m_out.jump(continuation);
 6207 
 6208             m_out.appendTo(continuation);
 6209 
 6210             mutatorFence();
 6211             setJSValue(m_out.phi(pointerType(), slowResult, fastResult));
 6212             return;
 6213         }
 6214 
 6215         setJSValue(vmCall(
 6216             Int64, m_out.operation(operationNewArrayBuffer), m_callFrame,
 6217             weakStructure(structure), m_out.weakPointer(m_node-&gt;cellOperand())));
 6218     }
 6219 
 6220     void compileNewArrayWithSize()
 6221     {
 6222         LValue publicLength = lowInt32(m_node-&gt;child1());
 6223 
 6224         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6225         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 6226             m_node-&gt;indexingType()));
 6227 
 6228         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingType())) {
 6229             IndexingType indexingType = m_node-&gt;indexingType();
 6230             setJSValue(
 6231                 allocateJSArray(
 6232                     publicLength, publicLength, weakPointer(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType)), m_out.constInt32(indexingType)).array);
 6233             mutatorFence();
 6234             return;
 6235         }
 6236 
 6237         LValue structureValue = m_out.select(
 6238             m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)),
 6239             weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))),
 6240             weakStructure(structure));
 6241         setJSValue(vmCall(Int64, m_out.operation(operationNewArrayWithSize), m_callFrame, structureValue, publicLength, m_out.intPtrZero));
 6242     }
 6243 
 6244     void compileNewTypedArray()
 6245     {
 6246         TypedArrayType typedArrayType = m_node-&gt;typedArrayType();
 6247         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6248 
 6249         switch (m_node-&gt;child1().useKind()) {
 6250         case Int32Use: {
 6251             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 6252 
 6253             LValue size = lowInt32(m_node-&gt;child1());
 6254 
 6255             LBasicBlock smallEnoughCase = m_out.newBlock();
 6256             LBasicBlock slowCase = m_out.newBlock();
 6257             LBasicBlock continuation = m_out.newBlock();
 6258 
 6259             ValueFromBlock noStorage = m_out.anchor(m_out.intPtrZero);
 6260 
 6261             m_out.branch(
 6262                 m_out.above(size, m_out.constInt32(JSArrayBufferView::fastSizeLimit)),
 6263                 rarely(slowCase), usually(smallEnoughCase));
 6264 
 6265             LBasicBlock lastNext = m_out.appendTo(smallEnoughCase, slowCase);
 6266 
 6267             LValue byteSize =
 6268                 m_out.shl(m_out.zeroExtPtr(size), m_out.constInt32(logElementSize(typedArrayType)));
 6269             if (elementSize(typedArrayType) &lt; 8) {
 6270                 byteSize = m_out.bitAnd(
 6271                     m_out.add(byteSize, m_out.constIntPtr(7)),
 6272                     m_out.constIntPtr(~static_cast&lt;intptr_t&gt;(7)));
 6273             }
 6274 
 6275             LValue allocator = allocatorForSize(vm().primitiveGigacageAuxiliarySpace, byteSize, slowCase);
 6276             LValue storage = allocateHeapCell(allocator, slowCase);
 6277 
 6278             splatWords(
 6279                 storage,
 6280                 m_out.int32Zero,
 6281                 m_out.castToInt32(m_out.lShr(byteSize, m_out.constIntPtr(3))),
 6282                 m_out.int64Zero,
 6283                 m_heaps.typedArrayProperties);
 6284 
<a name="58" id="anc58"></a>













 6285             ValueFromBlock haveStorage = m_out.anchor(storage);
 6286 
 6287             LValue fastResultValue =
 6288                 allocateObject&lt;JSArrayBufferView&gt;(structure, m_out.intPtrZero, slowCase);
 6289 
 6290             m_out.storePtr(storage, fastResultValue, m_heaps.JSArrayBufferView_vector);
 6291             m_out.store32(size, fastResultValue, m_heaps.JSArrayBufferView_length);
 6292             m_out.store32(m_out.constInt32(FastTypedArray), fastResultValue, m_heaps.JSArrayBufferView_mode);
 6293 
 6294             mutatorFence();
 6295             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 6296             m_out.jump(continuation);
 6297 
 6298             m_out.appendTo(slowCase, continuation);
 6299             LValue storageValue = m_out.phi(pointerType(), noStorage, haveStorage);
 6300 
 6301             VM&amp; vm = this-&gt;vm();
 6302             LValue slowResultValue = lazySlowPath(
 6303                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6304                     return createLazyCallGenerator(vm,
 6305                         operationNewTypedArrayWithSizeForType(typedArrayType), locations[0].directGPR(),
 6306                         CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 6307                         locations[2].directGPR());
 6308                 },
 6309                 size, storageValue);
 6310             ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6311             m_out.jump(continuation);
 6312 
 6313             m_out.appendTo(continuation, lastNext);
 6314             setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 6315             return;
 6316         }
 6317 
 6318         case UntypedUse: {
 6319             LValue argument = lowJSValue(m_node-&gt;child1());
 6320 
 6321             LValue result = vmCall(
 6322                 pointerType(), m_out.operation(operationNewTypedArrayWithOneArgumentForType(typedArrayType)),
 6323                 m_callFrame, weakPointer(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType)), argument);
 6324 
 6325             setJSValue(result);
 6326             return;
 6327         }
 6328 
 6329         default:
 6330             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 6331             return;
 6332         }
 6333     }
 6334 
 6335     void compileAllocatePropertyStorage()
 6336     {
 6337         LValue object = lowCell(m_node-&gt;child1());
 6338         setStorage(allocatePropertyStorage(object, m_node-&gt;transition()-&gt;previous.get()));
 6339     }
 6340 
 6341     void compileReallocatePropertyStorage()
 6342     {
 6343         Transition* transition = m_node-&gt;transition();
 6344         LValue object = lowCell(m_node-&gt;child1());
 6345         LValue oldStorage = lowStorage(m_node-&gt;child2());
 6346 
 6347         setStorage(
 6348             reallocatePropertyStorage(
 6349                 object, oldStorage, transition-&gt;previous.get(), transition-&gt;next.get()));
 6350     }
 6351 
 6352     void compileNukeStructureAndSetButterfly()
 6353     {
 6354         nukeStructureAndSetButterfly(lowStorage(m_node-&gt;child2()), lowCell(m_node-&gt;child1()));
 6355     }
 6356 
 6357     void compileToNumber()
 6358     {
 6359         LValue value = lowJSValue(m_node-&gt;child1());
 6360 
 6361         if (!(abstractValue(m_node-&gt;child1()).m_type &amp; SpecBytecodeNumber))
 6362             setJSValue(vmCall(Int64, m_out.operation(operationToNumber), m_callFrame, value));
 6363         else {
 6364             LBasicBlock notNumber = m_out.newBlock();
 6365             LBasicBlock continuation = m_out.newBlock();
 6366 
 6367             ValueFromBlock fastResult = m_out.anchor(value);
 6368             m_out.branch(isNumber(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notNumber));
 6369 
 6370             // notNumber case.
 6371             LBasicBlock lastNext = m_out.appendTo(notNumber, continuation);
 6372             // We have several attempts to remove ToNumber. But ToNumber still exists.
 6373             // It means that converting non-numbers to numbers by this ToNumber is not rare.
 6374             // Instead of the lazy slow path generator, we call the operation here.
 6375             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationToNumber), m_callFrame, value));
 6376             m_out.jump(continuation);
 6377 
 6378             // continuation case.
 6379             m_out.appendTo(continuation, lastNext);
 6380             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 6381         }
 6382     }
 6383 
 6384     void compileToStringOrCallStringConstructorOrStringValueOf()
 6385     {
 6386         ASSERT(m_node-&gt;op() != StringValueOf || m_node-&gt;child1().useKind() == UntypedUse);
 6387         switch (m_node-&gt;child1().useKind()) {
 6388         case StringObjectUse: {
 6389             LValue cell = lowCell(m_node-&gt;child1());
 6390             speculateStringObjectForCell(m_node-&gt;child1(), cell);
 6391             setJSValue(m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
 6392             return;
 6393         }
 6394 
 6395         case StringOrStringObjectUse: {
 6396             LValue cell = lowCell(m_node-&gt;child1());
 6397             LValue type = m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType);
 6398 
 6399             LBasicBlock notString = m_out.newBlock();
 6400             LBasicBlock continuation = m_out.newBlock();
 6401 
 6402             ValueFromBlock simpleResult = m_out.anchor(cell);
 6403             m_out.branch(
 6404                 m_out.equal(type, m_out.constInt32(StringType)),
 6405                 unsure(continuation), unsure(notString));
 6406 
 6407             LBasicBlock lastNext = m_out.appendTo(notString, continuation);
 6408             speculate(
 6409                 BadType, jsValueValue(cell), m_node-&gt;child1().node(),
 6410                 m_out.notEqual(type, m_out.constInt32(StringObjectType)));
 6411             ValueFromBlock unboxedResult = m_out.anchor(
 6412                 m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
 6413             m_out.jump(continuation);
 6414 
 6415             m_out.appendTo(continuation, lastNext);
 6416             setJSValue(m_out.phi(Int64, simpleResult, unboxedResult));
 6417 
 6418             m_interpreter.filter(m_node-&gt;child1(), SpecString | SpecStringObject);
 6419             return;
 6420         }
 6421 
 6422         case CellUse:
 6423         case NotCellUse:
 6424         case UntypedUse: {
 6425             LValue value;
 6426             if (m_node-&gt;child1().useKind() == CellUse)
 6427                 value = lowCell(m_node-&gt;child1());
 6428             else if (m_node-&gt;child1().useKind() == NotCellUse)
 6429                 value = lowNotCell(m_node-&gt;child1());
 6430             else
 6431                 value = lowJSValue(m_node-&gt;child1());
 6432 
 6433             LBasicBlock isCell = m_out.newBlock();
 6434             LBasicBlock notString = m_out.newBlock();
 6435             LBasicBlock continuation = m_out.newBlock();
 6436 
 6437             LValue isCellPredicate;
 6438             if (m_node-&gt;child1().useKind() == CellUse)
 6439                 isCellPredicate = m_out.booleanTrue;
 6440             else if (m_node-&gt;child1().useKind() == NotCellUse)
 6441                 isCellPredicate = m_out.booleanFalse;
 6442             else
 6443                 isCellPredicate = this-&gt;isCell(value, provenType(m_node-&gt;child1()));
 6444             m_out.branch(isCellPredicate, unsure(isCell), unsure(notString));
 6445 
 6446             LBasicBlock lastNext = m_out.appendTo(isCell, notString);
 6447             ValueFromBlock simpleResult = m_out.anchor(value);
 6448             LValue isStringPredicate;
 6449             if (m_node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 6450                 isStringPredicate = isString(value, provenType(m_node-&gt;child1()));
 6451             } else
 6452                 isStringPredicate = m_out.booleanFalse;
 6453             m_out.branch(isStringPredicate, unsure(continuation), unsure(notString));
 6454 
 6455             m_out.appendTo(notString, continuation);
 6456             LValue operation;
 6457             if (m_node-&gt;child1().useKind() == CellUse) {
 6458                 ASSERT(m_node-&gt;op() != StringValueOf);
 6459                 operation = m_out.operation(m_node-&gt;op() == ToString ? operationToStringOnCell : operationCallStringConstructorOnCell);
 6460             } else {
 6461                 operation = m_out.operation(m_node-&gt;op() == ToString
 6462                     ? operationToString : m_node-&gt;op() == StringValueOf
 6463                     ? operationStringValueOf : operationCallStringConstructor);
 6464             }
 6465             ValueFromBlock convertedResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, value));
 6466             m_out.jump(continuation);
 6467 
 6468             m_out.appendTo(continuation, lastNext);
 6469             setJSValue(m_out.phi(Int64, simpleResult, convertedResult));
 6470             return;
 6471         }
 6472 
 6473         case Int32Use:
 6474             setJSValue(vmCall(Int64, m_out.operation(operationInt32ToStringWithValidRadix), m_callFrame, lowInt32(m_node-&gt;child1()), m_out.constInt32(10)));
 6475             return;
 6476 
 6477         case Int52RepUse:
 6478             setJSValue(vmCall(Int64, m_out.operation(operationInt52ToStringWithValidRadix), m_callFrame, lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(10)));
 6479             return;
 6480 
 6481         case DoubleRepUse:
 6482             setJSValue(vmCall(Int64, m_out.operation(operationDoubleToStringWithValidRadix), m_callFrame, lowDouble(m_node-&gt;child1()), m_out.constInt32(10)));
 6483             return;
 6484 
 6485         default:
 6486             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 6487             break;
 6488         }
 6489     }
 6490 
 6491     void compileToPrimitive()
 6492     {
 6493         LValue value = lowJSValue(m_node-&gt;child1());
 6494 
 6495         LBasicBlock isCellCase = m_out.newBlock();
 6496         LBasicBlock isObjectCase = m_out.newBlock();
 6497         LBasicBlock continuation = m_out.newBlock();
 6498 
 6499         Vector&lt;ValueFromBlock, 3&gt; results;
 6500 
 6501         results.append(m_out.anchor(value));
 6502         m_out.branch(
 6503             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
 6504 
 6505         LBasicBlock lastNext = m_out.appendTo(isCellCase, isObjectCase);
 6506         results.append(m_out.anchor(value));
 6507         m_out.branch(
 6508             isObject(value, provenType(m_node-&gt;child1())),
 6509             unsure(isObjectCase), unsure(continuation));
 6510 
 6511         m_out.appendTo(isObjectCase, continuation);
 6512         results.append(m_out.anchor(vmCall(
 6513             Int64, m_out.operation(operationToPrimitive), m_callFrame, value)));
 6514         m_out.jump(continuation);
 6515 
 6516         m_out.appendTo(continuation, lastNext);
 6517         setJSValue(m_out.phi(Int64, results));
 6518     }
 6519 
 6520     void compileMakeRope()
 6521     {
 6522         struct FlagsAndLength {
 6523             LValue flags;
 6524             LValue length;
 6525         };
 6526 
 6527         Edge edges[3] = {
 6528             m_node-&gt;child1(),
 6529             m_node-&gt;child2(),
 6530             m_node-&gt;child3(),
 6531         };
 6532         LValue kids[3];
 6533         unsigned numKids;
 6534         kids[0] = lowCell(edges[0]);
 6535         kids[1] = lowCell(edges[1]);
 6536         if (edges[2]) {
 6537             kids[2] = lowCell(edges[2]);
 6538             numKids = 3;
 6539         } else {
 6540             kids[2] = 0;
 6541             numKids = 2;
 6542         }
 6543 
<a name="59" id="anc59"></a>
 6544         LBasicBlock slowPath = m_out.newBlock();
 6545         LBasicBlock continuation = m_out.newBlock();
 6546 
 6547         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
 6548 
 6549         LValue result = allocateCell(
 6550             m_out.constIntPtr(allocator.localAllocator()), vm().stringStructure.get(), slowPath);
 6551 
<a name="60" id="anc60"></a><span class="line-modified"> 6552         m_out.storePtr(m_out.bitOr(kids[0], m_out.constIntPtr(JSString::isRopeInPointer)), result, m_heaps.JSRopeString_fiber0);</span>
<span class="line-modified"> 6553 </span>
<span class="line-removed"> 6554         m_out.store32(m_out.castToInt32(kids[1]), result, m_heaps.JSRopeString_fiber1Lower);</span>
<span class="line-removed"> 6555         m_out.store32As16(m_out.castToInt32(m_out.lShr(kids[1], m_out.constInt32(32))), result, m_heaps.JSRopeString_fiber1Upper);</span>
<span class="line-removed"> 6556 </span>
<span class="line-removed"> 6557         if (numKids == 3) {</span>
<span class="line-removed"> 6558             m_out.store32(m_out.castToInt32(kids[2]), result, m_heaps.JSRopeString_fiber2Lower);</span>
<span class="line-removed"> 6559             m_out.store32As16(m_out.castToInt32(m_out.lShr(kids[2], m_out.constInt32(32))), result, m_heaps.JSRopeString_fiber2Upper);</span>
<span class="line-removed"> 6560         } else {</span>
<span class="line-removed"> 6561             m_out.store32(m_out.int32Zero, result, m_heaps.JSRopeString_fiber2Lower);</span>
<span class="line-removed"> 6562             m_out.store32As16(m_out.int32Zero, result, m_heaps.JSRopeString_fiber2Upper);</span>
<span class="line-removed"> 6563         }</span>
 6564 
 6565         auto getFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child) {
 6566             if (JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
 6567                 return FlagsAndLength {
 6568                     m_out.constInt32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0),
 6569                     m_out.constInt32(string-&gt;length())
 6570                 };
 6571             }
 6572 
 6573             LBasicBlock continuation = m_out.newBlock();
 6574             LBasicBlock ropeCase = m_out.newBlock();
 6575             LBasicBlock notRopeCase = m_out.newBlock();
 6576 
 6577             m_out.branch(isRopeString(child, edge), unsure(ropeCase), unsure(notRopeCase));
 6578 
 6579             LBasicBlock lastNext = m_out.appendTo(ropeCase, notRopeCase);
<a name="61" id="anc61"></a><span class="line-modified"> 6580             ValueFromBlock flagsForRope = m_out.anchor(m_out.load16ZeroExt32(child, m_heaps.JSRopeString_flags));</span>
 6581             ValueFromBlock lengthForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_length));
 6582             m_out.jump(continuation);
 6583 
 6584             m_out.appendTo(notRopeCase, continuation);
 6585             LValue stringImpl = m_out.loadPtr(child, m_heaps.JSString_value);
 6586             ValueFromBlock flagsForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_hashAndFlags));
 6587             ValueFromBlock lengthForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length));
 6588             m_out.jump(continuation);
 6589 
 6590             m_out.appendTo(continuation, lastNext);
 6591             return FlagsAndLength {
 6592                 m_out.phi(Int32, flagsForRope, flagsForNonRope),
 6593                 m_out.phi(Int32, lengthForRope, lengthForNonRope)
 6594             };
 6595         };
 6596 
 6597         FlagsAndLength flagsAndLength = getFlagsAndLength(edges[0], kids[0]);
 6598         for (unsigned i = 1; i &lt; numKids; ++i) {
 6599             auto mergeFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child, FlagsAndLength previousFlagsAndLength) {
 6600                 FlagsAndLength flagsAndLength = getFlagsAndLength(edge, child);
 6601                 LValue flags = m_out.bitAnd(previousFlagsAndLength.flags, flagsAndLength.flags);
 6602                 CheckValue* lengthCheck = m_out.speculateAdd(previousFlagsAndLength.length, flagsAndLength.length);
<a name="62" id="anc62"></a><span class="line-modified"> 6603             blessSpeculation(lengthCheck, Uncountable, noValue(), nullptr, m_origin);</span>
 6604                 return FlagsAndLength {
 6605                     flags,
 6606                     lengthCheck
 6607                 };
 6608             };
 6609             flagsAndLength = mergeFlagsAndLength(edges[i], kids[i], flagsAndLength);
 6610         }
<a name="63" id="anc63"></a><span class="line-modified"> 6611         m_out.store32As16(flagsAndLength.flags, result, m_heaps.JSRopeString_flags);</span>
<span class="line-modified"> 6612         m_out.store32(flagsAndLength.length, result, m_heaps.JSRopeString_length);</span>











 6613 
 6614         mutatorFence();
<a name="64" id="anc64"></a><span class="line-modified"> 6615         ValueFromBlock fastResult = m_out.anchor(m_out.select(m_out.isZero32(flagsAndLength.length), weakPointer(jsEmptyString(&amp;m_graph.m_vm)), result));</span>




 6616         m_out.jump(continuation);
 6617 
<a name="65" id="anc65"></a><span class="line-modified"> 6618         LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);</span>
 6619         LValue slowResultValue;
 6620         VM&amp; vm = this-&gt;vm();
 6621         switch (numKids) {
 6622         case 2:
 6623             slowResultValue = lazySlowPath(
 6624                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6625                     return createLazyCallGenerator(vm,
 6626                         operationMakeRope2, locations[0].directGPR(), locations[1].directGPR(),
 6627                         locations[2].directGPR());
 6628                 }, kids[0], kids[1]);
 6629             break;
 6630         case 3:
 6631             slowResultValue = lazySlowPath(
 6632                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6633                     return createLazyCallGenerator(vm,
 6634                         operationMakeRope3, locations[0].directGPR(), locations[1].directGPR(),
 6635                         locations[2].directGPR(), locations[3].directGPR());
 6636                 }, kids[0], kids[1], kids[2]);
 6637             break;
 6638         default:
 6639             DFG_CRASH(m_graph, m_node, &quot;Bad number of children&quot;);
 6640             break;
 6641         }
 6642         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6643         m_out.jump(continuation);
 6644 
 6645         m_out.appendTo(continuation, lastNext);
<a name="66" id="anc66"></a><span class="line-modified"> 6646         setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
 6647     }
 6648 
 6649     void compileStringCharAt()
 6650     {
 6651         LValue base = lowString(m_graph.child(m_node, 0));
 6652         LValue index = lowInt32(m_graph.child(m_node, 1));
 6653         LValue storage = lowStorage(m_graph.child(m_node, 2));
 6654 
 6655         LBasicBlock fastPath = m_out.newBlock();
 6656         LBasicBlock slowPath = m_out.newBlock();
 6657         LBasicBlock continuation = m_out.newBlock();
 6658 
 6659         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 6660         m_out.branch(
 6661             m_out.aboveOrEqual(
 6662                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)),
 6663             rarely(slowPath), usually(fastPath));
 6664 
 6665         LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 6666 
 6667         LBasicBlock is8Bit = m_out.newBlock();
 6668         LBasicBlock is16Bit = m_out.newBlock();
 6669         LBasicBlock bitsContinuation = m_out.newBlock();
 6670         LBasicBlock bigCharacter = m_out.newBlock();
 6671 
 6672         m_out.branch(
 6673             m_out.testIsZero32(
 6674                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
 6675                 m_out.constInt32(StringImpl::flagIs8Bit())),
 6676             unsure(is16Bit), unsure(is8Bit));
 6677 
 6678         m_out.appendTo(is8Bit, is16Bit);
 6679 
 6680         // FIXME: Need to cage strings!
 6681         // https://bugs.webkit.org/show_bug.cgi?id=174924
 6682         ValueFromBlock char8Bit = m_out.anchor(
 6683             m_out.load8ZeroExt32(m_out.baseIndex(
 6684                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),
 6685                 provenValue(m_graph.child(m_node, 1)))));
 6686         m_out.jump(bitsContinuation);
 6687 
 6688         m_out.appendTo(is16Bit, bigCharacter);
 6689 
 6690         LValue char16BitValue = m_out.load16ZeroExt32(
 6691             m_out.baseIndex(
 6692                 m_heaps.characters16, storage, m_out.zeroExtPtr(index),
 6693                 provenValue(m_graph.child(m_node, 1))));
 6694         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
 6695         m_out.branch(
 6696             m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
 6697             rarely(bigCharacter), usually(bitsContinuation));
 6698 
 6699         m_out.appendTo(bigCharacter, bitsContinuation);
 6700 
 6701         Vector&lt;ValueFromBlock, 4&gt; results;
 6702         results.append(m_out.anchor(vmCall(
 6703             Int64, m_out.operation(operationSingleCharacterString),
 6704             m_callFrame, char16BitValue)));
 6705         m_out.jump(continuation);
 6706 
 6707         m_out.appendTo(bitsContinuation, slowPath);
 6708 
 6709         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
 6710 
 6711         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 6712 
 6713         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
 6714             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
 6715         m_out.jump(continuation);
 6716 
 6717         m_out.appendTo(slowPath, continuation);
 6718 
 6719         if (m_node-&gt;arrayMode().isInBounds()) {
 6720             speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
 6721             results.append(m_out.anchor(m_out.intPtrZero));
 6722         } else {
 6723             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<a name="67" id="anc67"></a>


 6724 
<a name="68" id="anc68"></a><span class="line-removed"> 6725             bool prototypeChainIsSane = false;</span>
 6726             if (globalObject-&gt;stringPrototypeChainIsSane()) {
 6727                 // FIXME: This could be captured using a Speculation mode that means
 6728                 // &quot;out-of-bounds loads return a trivial value&quot;, something like
 6729                 // SaneChainOutOfBounds.
 6730                 // https://bugs.webkit.org/show_bug.cgi?id=144668
 6731 
<a name="69" id="anc69"></a><span class="line-modified"> 6732                 m_graph.registerAndWatchStructureTransition(globalObject-&gt;stringPrototype()-&gt;structure(vm()));</span>
<span class="line-modified"> 6733                 m_graph.registerAndWatchStructureTransition(globalObject-&gt;objectPrototype()-&gt;structure(vm()));</span>
 6734 
<a name="70" id="anc70"></a><span class="line-removed"> 6735                 prototypeChainIsSane = globalObject-&gt;stringPrototypeChainIsSane();</span>
<span class="line-removed"> 6736             }</span>
<span class="line-removed"> 6737             if (prototypeChainIsSane) {</span>
 6738                 LBasicBlock negativeIndex = m_out.newBlock();
 6739 
 6740                 results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 6741                 m_out.branch(
 6742                     m_out.lessThan(index, m_out.int32Zero),
 6743                     rarely(negativeIndex), usually(continuation));
 6744 
 6745                 m_out.appendTo(negativeIndex, continuation);
 6746             }
 6747 
 6748             results.append(m_out.anchor(vmCall(
 6749                 Int64, m_out.operation(operationGetByValStringInt), m_callFrame, base, index)));
 6750         }
 6751 
 6752         m_out.jump(continuation);
 6753 
 6754         m_out.appendTo(continuation, lastNext);
 6755         setJSValue(m_out.phi(Int64, results));
 6756     }
 6757 
 6758     void compileStringCharCodeAt()
 6759     {
 6760         LBasicBlock is8Bit = m_out.newBlock();
 6761         LBasicBlock is16Bit = m_out.newBlock();
 6762         LBasicBlock continuation = m_out.newBlock();
 6763 
 6764         LValue base = lowString(m_node-&gt;child1());
 6765         LValue index = lowInt32(m_node-&gt;child2());
 6766         LValue storage = lowStorage(m_node-&gt;child3());
 6767 
 6768         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 6769 
 6770         speculate(
 6771             Uncountable, noValue(), 0,
 6772             m_out.aboveOrEqual(
 6773                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)));
 6774 
 6775         m_out.branch(
 6776             m_out.testIsZero32(
 6777                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
 6778                 m_out.constInt32(StringImpl::flagIs8Bit())),
 6779             unsure(is16Bit), unsure(is8Bit));
 6780 
 6781         LBasicBlock lastNext = m_out.appendTo(is8Bit, is16Bit);
 6782 
 6783         // FIXME: need to cage strings!
 6784         // https://bugs.webkit.org/show_bug.cgi?id=174924
 6785         ValueFromBlock char8Bit = m_out.anchor(
 6786             m_out.load8ZeroExt32(m_out.baseIndex(
 6787                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),
 6788                 provenValue(m_node-&gt;child2()))));
 6789         m_out.jump(continuation);
 6790 
 6791         m_out.appendTo(is16Bit, continuation);
 6792 
 6793         ValueFromBlock char16Bit = m_out.anchor(
 6794             m_out.load16ZeroExt32(m_out.baseIndex(
 6795                 m_heaps.characters16, storage, m_out.zeroExtPtr(index),
 6796                 provenValue(m_node-&gt;child2()))));
 6797         m_out.jump(continuation);
 6798 
 6799         m_out.appendTo(continuation, lastNext);
 6800 
 6801         setInt32(m_out.phi(Int32, char8Bit, char16Bit));
 6802     }
 6803 
 6804     void compileStringFromCharCode()
 6805     {
 6806         Edge childEdge = m_node-&gt;child1();
 6807 
 6808         if (childEdge.useKind() == UntypedUse) {
 6809             LValue result = vmCall(
 6810                 Int64, m_out.operation(operationStringFromCharCodeUntyped), m_callFrame,
 6811                 lowJSValue(childEdge));
 6812             setJSValue(result);
 6813             return;
 6814         }
 6815 
 6816         DFG_ASSERT(m_graph, m_node, childEdge.useKind() == Int32Use, childEdge.useKind());
 6817 
 6818         LValue value = lowInt32(childEdge);
 6819 
 6820         LBasicBlock smallIntCase = m_out.newBlock();
 6821         LBasicBlock slowCase = m_out.newBlock();
 6822         LBasicBlock continuation = m_out.newBlock();
 6823 
 6824         m_out.branch(
<a name="71" id="anc71"></a><span class="line-modified"> 6825             m_out.aboveOrEqual(value, m_out.constInt32(maxSingleCharacterString)),</span>
 6826             rarely(slowCase), usually(smallIntCase));
 6827 
 6828         LBasicBlock lastNext = m_out.appendTo(smallIntCase, slowCase);
 6829 
 6830         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 6831         LValue fastResultValue = m_out.loadPtr(
 6832             m_out.baseIndex(m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(value)));
 6833         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 6834         m_out.jump(continuation);
 6835 
 6836         m_out.appendTo(slowCase, continuation);
 6837 
 6838         LValue slowResultValue = vmCall(
 6839             pointerType(), m_out.operation(operationStringFromCharCode), m_callFrame, value);
 6840         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6841         m_out.jump(continuation);
 6842 
 6843         m_out.appendTo(continuation, lastNext);
 6844 
 6845         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 6846     }
 6847 
 6848     void compileGetByOffset()
 6849     {
 6850         StorageAccessData&amp; data = m_node-&gt;storageAccessData();
 6851 
 6852         setJSValue(loadProperty(
 6853             lowStorage(m_node-&gt;child1()), data.identifierNumber, data.offset));
 6854     }
 6855 
 6856     void compileGetGetter()
 6857     {
 6858         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.GetterSetter_getter));
 6859     }
 6860 
 6861     void compileGetSetter()
 6862     {
 6863         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.GetterSetter_setter));
 6864     }
 6865 
 6866     void compileMultiGetByOffset()
 6867     {
 6868         LValue base = lowCell(m_node-&gt;child1());
 6869 
 6870         MultiGetByOffsetData&amp; data = m_node-&gt;multiGetByOffsetData();
 6871 
 6872         Vector&lt;LBasicBlock, 2&gt; blocks(data.cases.size());
 6873         for (unsigned i = data.cases.size(); i--;)
 6874             blocks[i] = m_out.newBlock();
 6875         LBasicBlock exit = m_out.newBlock();
 6876         LBasicBlock continuation = m_out.newBlock();
 6877 
 6878         Vector&lt;SwitchCase, 2&gt; cases;
 6879         RegisteredStructureSet baseSet;
 6880         for (unsigned i = data.cases.size(); i--;) {
 6881             MultiGetByOffsetCase getCase = data.cases[i];
 6882             for (unsigned j = getCase.set().size(); j--;) {
 6883                 RegisteredStructure structure = getCase.set()[j];
 6884                 baseSet.add(structure);
 6885                 cases.append(SwitchCase(weakStructureID(structure), blocks[i], Weight(1)));
 6886             }
 6887         }
 6888         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 6889         emitSwitchForMultiByOffset(base, structuresChecked, cases, exit);
 6890 
 6891         LBasicBlock lastNext = m_out.m_nextBlock;
 6892 
 6893         Vector&lt;ValueFromBlock, 2&gt; results;
 6894         for (unsigned i = data.cases.size(); i--;) {
 6895             MultiGetByOffsetCase getCase = data.cases[i];
 6896             GetByOffsetMethod method = getCase.method();
 6897 
 6898             m_out.appendTo(blocks[i], i + 1 &lt; data.cases.size() ? blocks[i + 1] : exit);
 6899 
 6900             LValue result;
 6901 
 6902             switch (method.kind()) {
 6903             case GetByOffsetMethod::Invalid:
 6904                 RELEASE_ASSERT_NOT_REACHED();
 6905                 break;
 6906 
 6907             case GetByOffsetMethod::Constant:
 6908                 result = m_out.constInt64(JSValue::encode(method.constant()-&gt;value()));
 6909                 break;
 6910 
 6911             case GetByOffsetMethod::Load:
 6912             case GetByOffsetMethod::LoadFromPrototype: {
 6913                 LValue propertyBase;
 6914                 if (method.kind() == GetByOffsetMethod::Load)
 6915                     propertyBase = base;
 6916                 else
 6917                     propertyBase = weakPointer(method.prototype()-&gt;value().asCell());
 6918                 if (!isInlineOffset(method.offset()))
 6919                     propertyBase = m_out.loadPtr(propertyBase, m_heaps.JSObject_butterfly);
 6920                 result = loadProperty(
 6921                     propertyBase, data.identifierNumber, method.offset());
 6922                 break;
 6923             } }
 6924 
 6925             results.append(m_out.anchor(result));
 6926             m_out.jump(continuation);
 6927         }
 6928 
 6929         m_out.appendTo(exit, continuation);
 6930         if (!structuresChecked)
 6931             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 6932         m_out.unreachable();
 6933 
 6934         m_out.appendTo(continuation, lastNext);
 6935         setJSValue(m_out.phi(Int64, results));
 6936     }
 6937 
 6938     void compilePutByOffset()
 6939     {
 6940         StorageAccessData&amp; data = m_node-&gt;storageAccessData();
 6941 
 6942         storeProperty(
 6943             lowJSValue(m_node-&gt;child3()),
 6944             lowStorage(m_node-&gt;child1()), data.identifierNumber, data.offset);
 6945     }
 6946 
 6947     void compileMultiPutByOffset()
 6948     {
 6949         LValue base = lowCell(m_node-&gt;child1());
 6950         LValue value = lowJSValue(m_node-&gt;child2());
 6951 
 6952         MultiPutByOffsetData&amp; data = m_node-&gt;multiPutByOffsetData();
 6953 
 6954         Vector&lt;LBasicBlock, 2&gt; blocks(data.variants.size());
 6955         for (unsigned i = data.variants.size(); i--;)
 6956             blocks[i] = m_out.newBlock();
 6957         LBasicBlock exit = m_out.newBlock();
 6958         LBasicBlock continuation = m_out.newBlock();
 6959 
 6960         Vector&lt;SwitchCase, 2&gt; cases;
 6961         RegisteredStructureSet baseSet;
 6962         for (unsigned i = data.variants.size(); i--;) {
 6963             PutByIdVariant variant = data.variants[i];
 6964             for (unsigned j = variant.oldStructure().size(); j--;) {
 6965                 RegisteredStructure structure = m_graph.registerStructure(variant.oldStructure()[j]);
 6966                 baseSet.add(structure);
 6967                 cases.append(SwitchCase(weakStructureID(structure), blocks[i], Weight(1)));
 6968             }
 6969         }
 6970         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 6971         emitSwitchForMultiByOffset(base, structuresChecked, cases, exit);
 6972 
 6973         LBasicBlock lastNext = m_out.m_nextBlock;
 6974 
 6975         for (unsigned i = data.variants.size(); i--;) {
 6976             m_out.appendTo(blocks[i], i + 1 &lt; data.variants.size() ? blocks[i + 1] : exit);
 6977 
 6978             PutByIdVariant variant = data.variants[i];
 6979 
 6980             LValue storage;
 6981             if (variant.kind() == PutByIdVariant::Replace) {
 6982                 if (isInlineOffset(variant.offset()))
 6983                     storage = base;
 6984                 else
 6985                     storage = m_out.loadPtr(base, m_heaps.JSObject_butterfly);
 6986             } else {
 6987                 DFG_ASSERT(m_graph, m_node, variant.kind() == PutByIdVariant::Transition, variant.kind());
 6988                 m_graph.m_plan.transitions().addLazily(
 6989                     codeBlock(), m_node-&gt;origin.semantic.codeOriginOwner(),
 6990                     variant.oldStructureForTransition(), variant.newStructure());
 6991 
 6992                 storage = storageForTransition(
 6993                     base, variant.offset(),
 6994                     variant.oldStructureForTransition(), variant.newStructure());
 6995             }
 6996 
 6997             storeProperty(value, storage, data.identifierNumber, variant.offset());
 6998 
 6999             if (variant.kind() == PutByIdVariant::Transition) {
 7000                 ASSERT(variant.oldStructureForTransition()-&gt;indexingType() == variant.newStructure()-&gt;indexingType());
 7001                 ASSERT(variant.oldStructureForTransition()-&gt;typeInfo().inlineTypeFlags() == variant.newStructure()-&gt;typeInfo().inlineTypeFlags());
 7002                 ASSERT(variant.oldStructureForTransition()-&gt;typeInfo().type() == variant.newStructure()-&gt;typeInfo().type());
 7003                 m_out.store32(
 7004                     weakStructureID(m_graph.registerStructure(variant.newStructure())), base, m_heaps.JSCell_structureID);
 7005             }
 7006 
 7007             m_out.jump(continuation);
 7008         }
 7009 
 7010         m_out.appendTo(exit, continuation);
 7011         if (!structuresChecked)
 7012             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 7013         m_out.unreachable();
 7014 
 7015         m_out.appendTo(continuation, lastNext);
 7016     }
 7017 
 7018     void compileMatchStructure()
 7019     {
 7020         LValue base = lowCell(m_node-&gt;child1());
 7021 
 7022         MatchStructureData&amp; data = m_node-&gt;matchStructureData();
 7023 
 7024         LBasicBlock trueBlock = m_out.newBlock();
 7025         LBasicBlock falseBlock = m_out.newBlock();
 7026         LBasicBlock exitBlock = m_out.newBlock();
 7027         LBasicBlock continuation = m_out.newBlock();
 7028 
 7029         LBasicBlock lastNext = m_out.insertNewBlocksBefore(trueBlock);
 7030 
 7031         Vector&lt;SwitchCase, 2&gt; cases;
 7032         RegisteredStructureSet baseSet;
 7033         for (MatchStructureVariant&amp; variant : data.variants) {
 7034             baseSet.add(variant.structure);
 7035             cases.append(SwitchCase(
 7036                 weakStructureID(variant.structure),
 7037                 variant.result ? trueBlock : falseBlock, Weight(1)));
 7038         }
 7039         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 7040         emitSwitchForMultiByOffset(base, structuresChecked, cases, exitBlock);
 7041 
 7042         m_out.appendTo(trueBlock, falseBlock);
 7043         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
 7044         m_out.jump(continuation);
 7045 
 7046         m_out.appendTo(falseBlock, exitBlock);
 7047         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
 7048         m_out.jump(continuation);
 7049 
 7050         m_out.appendTo(exitBlock, continuation);
 7051         if (!structuresChecked)
 7052             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 7053         m_out.unreachable();
 7054 
 7055         m_out.appendTo(continuation, lastNext);
 7056         setBoolean(m_out.phi(Int32, trueResult, falseResult));
 7057     }
 7058 
 7059     void compileGetGlobalVariable()
 7060     {
 7061         setJSValue(m_out.load64(m_out.absolute(m_node-&gt;variablePointer())));
 7062     }
 7063 
 7064     void compilePutGlobalVariable()
 7065     {
 7066         m_out.store64(
 7067             lowJSValue(m_node-&gt;child2()), m_out.absolute(m_node-&gt;variablePointer()));
 7068     }
 7069 
 7070     void compileNotifyWrite()
 7071     {
 7072         WatchpointSet* set = m_node-&gt;watchpointSet();
 7073 
 7074         LBasicBlock isNotInvalidated = m_out.newBlock();
 7075         LBasicBlock continuation = m_out.newBlock();
 7076 
 7077         LValue state = m_out.load8ZeroExt32(m_out.absolute(set-&gt;addressOfState()));
 7078         m_out.branch(
 7079             m_out.equal(state, m_out.constInt32(IsInvalidated)),
 7080             usually(continuation), rarely(isNotInvalidated));
 7081 
 7082         LBasicBlock lastNext = m_out.appendTo(isNotInvalidated, continuation);
 7083 
 7084         VM&amp; vm = this-&gt;vm();
 7085         lazySlowPath(
 7086             [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 7087                 return createLazyCallGenerator(vm,
 7088                     operationNotifyWrite, InvalidGPRReg, CCallHelpers::TrustedImmPtr(set));
 7089             });
 7090         m_out.jump(continuation);
 7091 
 7092         m_out.appendTo(continuation, lastNext);
 7093     }
 7094 
 7095     void compileGetCallee()
 7096     {
 7097         setJSValue(m_out.loadPtr(addressFor(CallFrameSlot::callee)));
 7098     }
 7099 
 7100     void compileSetCallee()
 7101     {
 7102         auto callee = lowCell(m_node-&gt;child1());
 7103         m_out.storePtr(callee, payloadFor(CallFrameSlot::callee));
 7104     }
 7105 
 7106     void compileGetArgumentCountIncludingThis()
 7107     {
 7108         VirtualRegister argumentCountRegister;
 7109         if (InlineCallFrame* inlineCallFrame = m_node-&gt;argumentsInlineCallFrame())
 7110             argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
 7111         else
 7112             argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
 7113         setInt32(m_out.load32(payloadFor(argumentCountRegister)));
 7114     }
 7115 
 7116     void compileSetArgumentCountIncludingThis()
 7117     {
 7118         m_out.store32(m_out.constInt32(m_node-&gt;argumentCountIncludingThis()), payloadFor(CallFrameSlot::argumentCount));
 7119     }
 7120 
 7121     void compileGetScope()
 7122     {
 7123         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSFunction_scope));
 7124     }
 7125 
 7126     void compileSkipScope()
 7127     {
 7128         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSScope_next));
 7129     }
 7130 
 7131     void compileGetGlobalObject()
 7132     {
 7133         LValue structure = loadStructure(lowCell(m_node-&gt;child1()));
 7134         setJSValue(m_out.loadPtr(structure, m_heaps.Structure_globalObject));
 7135     }
 7136 
 7137     void compileGetGlobalThis()
 7138     {
 7139         auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 7140         setJSValue(m_out.loadPtr(m_out.absolute(globalObject-&gt;addressOfGlobalThis())));
 7141     }
 7142 
 7143     void compileGetClosureVar()
 7144     {
 7145         setJSValue(
 7146             m_out.load64(
 7147                 lowCell(m_node-&gt;child1()),
 7148                 m_heaps.JSLexicalEnvironment_variables[m_node-&gt;scopeOffset().offset()]));
 7149     }
 7150 
 7151     void compilePutClosureVar()
 7152     {
 7153         m_out.store64(
 7154             lowJSValue(m_node-&gt;child2()),
 7155             lowCell(m_node-&gt;child1()),
 7156             m_heaps.JSLexicalEnvironment_variables[m_node-&gt;scopeOffset().offset()]);
 7157     }
 7158 
 7159     void compileGetFromArguments()
 7160     {
 7161         setJSValue(
 7162             m_out.load64(
 7163                 lowCell(m_node-&gt;child1()),
 7164                 m_heaps.DirectArguments_storage[m_node-&gt;capturedArgumentsOffset().offset()]));
 7165     }
 7166 
 7167     void compilePutToArguments()
 7168     {
 7169         m_out.store64(
 7170             lowJSValue(m_node-&gt;child2()),
 7171             lowCell(m_node-&gt;child1()),
 7172             m_heaps.DirectArguments_storage[m_node-&gt;capturedArgumentsOffset().offset()]);
 7173     }
 7174 
 7175     void compileGetArgument()
 7176     {
 7177         LValue argumentCount = m_out.load32(payloadFor(AssemblyHelpers::argumentCount(m_node-&gt;origin.semantic)));
 7178 
 7179         LBasicBlock inBounds = m_out.newBlock();
 7180         LBasicBlock outOfBounds = m_out.newBlock();
 7181         LBasicBlock continuation = m_out.newBlock();
 7182 
 7183         m_out.branch(m_out.lessThanOrEqual(argumentCount, m_out.constInt32(m_node-&gt;argumentIndex())), unsure(outOfBounds), unsure(inBounds));
 7184 
 7185         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
 7186         VirtualRegister arg = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic) + m_node-&gt;argumentIndex() - 1;
 7187         ValueFromBlock inBoundsResult = m_out.anchor(m_out.load64(addressFor(arg)));
 7188         m_out.jump(continuation);
 7189 
 7190         m_out.appendTo(outOfBounds, continuation);
 7191         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueUndefined));
 7192         m_out.jump(continuation);
 7193 
 7194         m_out.appendTo(continuation, lastNext);
 7195         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
 7196     }
 7197 
 7198     void compileCompareEq()
 7199     {
 7200         if (m_node-&gt;isBinaryUseKind(Int32Use)
 7201             || m_node-&gt;isBinaryUseKind(Int52RepUse)
 7202             || m_node-&gt;isBinaryUseKind(DoubleRepUse)
 7203             || m_node-&gt;isBinaryUseKind(ObjectUse)
 7204             || m_node-&gt;isBinaryUseKind(BooleanUse)
 7205             || m_node-&gt;isBinaryUseKind(SymbolUse)
 7206             || m_node-&gt;isBinaryUseKind(StringIdentUse)
 7207             || m_node-&gt;isBinaryUseKind(StringUse)) {
 7208             compileCompareStrictEq();
 7209             return;
 7210         }
 7211 
 7212         if (m_node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse)) {
 7213             compareEqObjectOrOtherToObject(m_node-&gt;child2(), m_node-&gt;child1());
 7214             return;
 7215         }
 7216 
 7217         if (m_node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
 7218             compareEqObjectOrOtherToObject(m_node-&gt;child1(), m_node-&gt;child2());
 7219             return;
 7220         }
 7221 
 7222         if (m_node-&gt;child1().useKind() == KnownOtherUse) {
 7223             ASSERT(!m_interpreter.needsTypeCheck(m_node-&gt;child1(), SpecOther));
 7224             setBoolean(equalNullOrUndefined(m_node-&gt;child2(), AllCellsAreFalse, EqualNullOrUndefined, ManualOperandSpeculation));
 7225             return;
 7226         }
 7227 
 7228         if (m_node-&gt;child2().useKind() == KnownOtherUse) {
 7229             ASSERT(!m_interpreter.needsTypeCheck(m_node-&gt;child2(), SpecOther));
 7230             setBoolean(equalNullOrUndefined(m_node-&gt;child1(), AllCellsAreFalse, EqualNullOrUndefined, ManualOperandSpeculation));
 7231             return;
 7232         }
 7233 
 7234         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
 7235         nonSpeculativeCompare(
 7236             [&amp;] (LValue left, LValue right) {
 7237                 return m_out.equal(left, right);
 7238             },
 7239             operationCompareEq);
 7240     }
 7241 
 7242     void compileCompareStrictEq()
 7243     {
 7244         if (m_node-&gt;isBinaryUseKind(Int32Use)) {
 7245             setBoolean(
 7246                 m_out.equal(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 7247             return;
 7248         }
 7249 
 7250         if (m_node-&gt;isBinaryUseKind(Int52RepUse)) {
 7251             Int52Kind kind;
 7252             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 7253             LValue right = lowInt52(m_node-&gt;child2(), kind);
 7254             setBoolean(m_out.equal(left, right));
 7255             return;
 7256         }
 7257 
 7258         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
 7259             setBoolean(
 7260                 m_out.doubleEqual(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 7261             return;
 7262         }
 7263 
 7264         if (m_node-&gt;isBinaryUseKind(StringIdentUse)) {
 7265             setBoolean(
 7266                 m_out.equal(lowStringIdent(m_node-&gt;child1()), lowStringIdent(m_node-&gt;child2())));
 7267             return;
 7268         }
 7269 
 7270         if (m_node-&gt;isBinaryUseKind(StringUse)) {
 7271             LValue left = lowCell(m_node-&gt;child1());
 7272             LValue right = lowCell(m_node-&gt;child2());
 7273 
 7274             LBasicBlock notTriviallyEqualCase = m_out.newBlock();
 7275             LBasicBlock continuation = m_out.newBlock();
 7276 
 7277             speculateString(m_node-&gt;child1(), left);
 7278 
 7279             ValueFromBlock fastResult = m_out.anchor(m_out.booleanTrue);
 7280             m_out.branch(
 7281                 m_out.equal(left, right), unsure(continuation), unsure(notTriviallyEqualCase));
 7282 
 7283             LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
 7284 
 7285             speculateString(m_node-&gt;child2(), right);
 7286 
 7287             ValueFromBlock slowResult = m_out.anchor(stringsEqual(left, right, m_node-&gt;child1(), m_node-&gt;child2()));
 7288             m_out.jump(continuation);
 7289 
 7290             m_out.appendTo(continuation, lastNext);
 7291             setBoolean(m_out.phi(Int32, fastResult, slowResult));
 7292             return;
 7293         }
 7294 
 7295         if (m_node-&gt;isBinaryUseKind(ObjectUse, UntypedUse)) {
 7296             setBoolean(
 7297                 m_out.equal(
 7298                     lowNonNullObject(m_node-&gt;child1()),
 7299                     lowJSValue(m_node-&gt;child2())));
 7300             return;
 7301         }
 7302 
 7303         if (m_node-&gt;isBinaryUseKind(UntypedUse, ObjectUse)) {
 7304             setBoolean(
 7305                 m_out.equal(
 7306                     lowNonNullObject(m_node-&gt;child2()),
 7307                     lowJSValue(m_node-&gt;child1())));
 7308             return;
 7309         }
 7310 
 7311         if (m_node-&gt;isBinaryUseKind(ObjectUse)) {
 7312             setBoolean(
 7313                 m_out.equal(
 7314                     lowNonNullObject(m_node-&gt;child1()),
 7315                     lowNonNullObject(m_node-&gt;child2())));
 7316             return;
 7317         }
 7318 
 7319         if (m_node-&gt;isBinaryUseKind(BooleanUse)) {
 7320             setBoolean(
 7321                 m_out.equal(lowBoolean(m_node-&gt;child1()), lowBoolean(m_node-&gt;child2())));
 7322             return;
 7323         }
 7324 
 7325         if (m_node-&gt;isBinaryUseKind(SymbolUse)) {
 7326             LValue leftSymbol = lowSymbol(m_node-&gt;child1());
 7327             LValue rightSymbol = lowSymbol(m_node-&gt;child2());
 7328             setBoolean(m_out.equal(leftSymbol, rightSymbol));
 7329             return;
 7330         }
 7331 
 7332         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 7333             // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
 7334             // https://bugs.webkit.org/show_bug.cgi?id=182895
 7335             LValue left = lowBigInt(m_node-&gt;child1());
 7336             LValue right = lowBigInt(m_node-&gt;child2());
 7337 
 7338             LBasicBlock notTriviallyEqualCase = m_out.newBlock();
 7339             LBasicBlock continuation = m_out.newBlock();
 7340 
 7341             ValueFromBlock fastResult = m_out.anchor(m_out.booleanTrue);
 7342             m_out.branch(m_out.equal(left, right), rarely(continuation), usually(notTriviallyEqualCase));
 7343 
 7344             LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
 7345 
 7346             ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
 7347                 pointerType(), m_out.operation(operationCompareStrictEq), m_callFrame, left, right)));
 7348             m_out.jump(continuation);
 7349 
 7350             m_out.appendTo(continuation, lastNext);
 7351             setBoolean(m_out.phi(Int32, fastResult, slowResult));
 7352             return;
 7353         }
 7354 
 7355         if (m_node-&gt;isBinaryUseKind(SymbolUse, UntypedUse)
 7356             || m_node-&gt;isBinaryUseKind(UntypedUse, SymbolUse)) {
 7357             Edge symbolEdge = m_node-&gt;child1();
 7358             Edge untypedEdge = m_node-&gt;child2();
 7359             if (symbolEdge.useKind() != SymbolUse)
 7360                 std::swap(symbolEdge, untypedEdge);
 7361 
 7362             LValue leftSymbol = lowSymbol(symbolEdge);
 7363             LValue untypedValue = lowJSValue(untypedEdge);
 7364 
 7365             setBoolean(m_out.equal(leftSymbol, untypedValue));
 7366             return;
 7367         }
 7368 
 7369         if (m_node-&gt;isBinaryUseKind(MiscUse, UntypedUse)
 7370             || m_node-&gt;isBinaryUseKind(UntypedUse, MiscUse)) {
 7371             speculate(m_node-&gt;child1());
 7372             speculate(m_node-&gt;child2());
 7373             LValue left = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 7374             LValue right = lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation);
 7375             setBoolean(m_out.equal(left, right));
 7376             return;
 7377         }
 7378 
 7379         if (m_node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse)
 7380             || m_node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse)) {
 7381             Edge leftEdge = m_node-&gt;childFor(StringIdentUse);
 7382             Edge rightEdge = m_node-&gt;childFor(NotStringVarUse);
 7383 
 7384             LValue left = lowStringIdent(leftEdge);
 7385             LValue rightValue = lowJSValue(rightEdge, ManualOperandSpeculation);
 7386 
 7387             LBasicBlock isCellCase = m_out.newBlock();
 7388             LBasicBlock isStringCase = m_out.newBlock();
 7389             LBasicBlock continuation = m_out.newBlock();
 7390 
 7391             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
 7392             m_out.branch(
 7393                 isCell(rightValue, provenType(rightEdge)),
 7394                 unsure(isCellCase), unsure(continuation));
 7395 
 7396             LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
 7397             ValueFromBlock notStringResult = m_out.anchor(m_out.booleanFalse);
 7398             m_out.branch(
 7399                 isString(rightValue, provenType(rightEdge)),
 7400                 unsure(isStringCase), unsure(continuation));
 7401 
 7402             m_out.appendTo(isStringCase, continuation);
 7403             LValue right = m_out.loadPtr(rightValue, m_heaps.JSString_value);
 7404             speculateStringIdent(rightEdge, rightValue, right);
 7405             ValueFromBlock isStringResult = m_out.anchor(m_out.equal(left, right));
 7406             m_out.jump(continuation);
 7407 
 7408             m_out.appendTo(continuation, lastNext);
 7409             setBoolean(m_out.phi(Int32, notCellResult, notStringResult, isStringResult));
 7410             return;
 7411         }
 7412 
 7413         if (m_node-&gt;isBinaryUseKind(StringUse, UntypedUse)) {
 7414             compileStringToUntypedStrictEquality(m_node-&gt;child1(), m_node-&gt;child2());
 7415             return;
 7416         }
 7417         if (m_node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
 7418             compileStringToUntypedStrictEquality(m_node-&gt;child2(), m_node-&gt;child1());
 7419             return;
 7420         }
 7421 
 7422         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
 7423         nonSpeculativeCompare(
 7424             [&amp;] (LValue left, LValue right) {
 7425                 return m_out.equal(left, right);
 7426             },
 7427             operationCompareStrictEq);
 7428     }
 7429 
 7430     void compileStringToUntypedStrictEquality(Edge stringEdge, Edge untypedEdge)
 7431     {
 7432         ASSERT(stringEdge.useKind() == StringUse);
 7433         ASSERT(untypedEdge.useKind() == UntypedUse);
 7434 
 7435         LValue leftString = lowCell(stringEdge);
 7436         LValue rightValue = lowJSValue(untypedEdge);
 7437         SpeculatedType rightValueType = provenType(untypedEdge);
 7438 
 7439         // Verify left is string.
 7440         speculateString(stringEdge, leftString);
 7441 
 7442         LBasicBlock testUntypedEdgeIsCell = m_out.newBlock();
 7443         LBasicBlock testUntypedEdgeIsString = m_out.newBlock();
 7444         LBasicBlock testStringEquality = m_out.newBlock();
 7445         LBasicBlock continuation = m_out.newBlock();
 7446 
 7447         // Given left is string. If the value are strictly equal, rightValue has to be the same string.
 7448         ValueFromBlock fastTrue = m_out.anchor(m_out.booleanTrue);
 7449         m_out.branch(m_out.equal(leftString, rightValue), unsure(continuation), unsure(testUntypedEdgeIsCell));
 7450 
 7451         LBasicBlock lastNext = m_out.appendTo(testUntypedEdgeIsCell, testUntypedEdgeIsString);
 7452         ValueFromBlock fastFalse = m_out.anchor(m_out.booleanFalse);
 7453         m_out.branch(isNotCell(rightValue, rightValueType), unsure(continuation), unsure(testUntypedEdgeIsString));
 7454 
 7455         // Check if the untyped edge is a string.
 7456         m_out.appendTo(testUntypedEdgeIsString, testStringEquality);
 7457         m_out.branch(isNotString(rightValue, rightValueType), unsure(continuation), unsure(testStringEquality));
 7458 
 7459         // Full String compare.
 7460         m_out.appendTo(testStringEquality, continuation);
 7461         ValueFromBlock slowResult = m_out.anchor(stringsEqual(leftString, rightValue, stringEdge, untypedEdge));
 7462         m_out.jump(continuation);
 7463 
 7464         // Continuation.
 7465         m_out.appendTo(continuation, lastNext);
 7466         setBoolean(m_out.phi(Int32, fastTrue, fastFalse, slowResult));
 7467     }
 7468 
 7469     void compileCompareEqPtr()
 7470     {
 7471         setBoolean(
 7472             m_out.equal(
 7473                 lowJSValue(m_node-&gt;child1()),
 7474                 weakPointer(m_node-&gt;cellOperand()-&gt;cell())));
 7475     }
 7476 
 7477     void compileCompareLess()
 7478     {
 7479         compare(
 7480             [&amp;] (LValue left, LValue right) {
 7481                 return m_out.lessThan(left, right);
 7482             },
 7483             [&amp;] (LValue left, LValue right) {
 7484                 return m_out.doubleLessThan(left, right);
 7485             },
 7486             operationCompareStringImplLess,
 7487             operationCompareStringLess,
 7488             operationCompareLess);
 7489     }
 7490 
 7491     void compileCompareLessEq()
 7492     {
 7493         compare(
 7494             [&amp;] (LValue left, LValue right) {
 7495                 return m_out.lessThanOrEqual(left, right);
 7496             },
 7497             [&amp;] (LValue left, LValue right) {
 7498                 return m_out.doubleLessThanOrEqual(left, right);
 7499             },
 7500             operationCompareStringImplLessEq,
 7501             operationCompareStringLessEq,
 7502             operationCompareLessEq);
 7503     }
 7504 
 7505     void compileCompareGreater()
 7506     {
 7507         compare(
 7508             [&amp;] (LValue left, LValue right) {
 7509                 return m_out.greaterThan(left, right);
 7510             },
 7511             [&amp;] (LValue left, LValue right) {
 7512                 return m_out.doubleGreaterThan(left, right);
 7513             },
 7514             operationCompareStringImplGreater,
 7515             operationCompareStringGreater,
 7516             operationCompareGreater);
 7517     }
 7518 
 7519     void compileCompareGreaterEq()
 7520     {
 7521         compare(
 7522             [&amp;] (LValue left, LValue right) {
 7523                 return m_out.greaterThanOrEqual(left, right);
 7524             },
 7525             [&amp;] (LValue left, LValue right) {
 7526                 return m_out.doubleGreaterThanOrEqual(left, right);
 7527             },
 7528             operationCompareStringImplGreaterEq,
 7529             operationCompareStringGreaterEq,
 7530             operationCompareGreaterEq);
 7531     }
 7532 
 7533     void compileCompareBelow()
 7534     {
 7535         setBoolean(m_out.below(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 7536     }
 7537 
 7538     void compileCompareBelowEq()
 7539     {
 7540         setBoolean(m_out.belowOrEqual(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 7541     }
 7542 
 7543     void compileSameValue()
 7544     {
 7545         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
 7546             LValue arg1 = lowDouble(m_node-&gt;child1());
 7547             LValue arg2 = lowDouble(m_node-&gt;child2());
 7548 
 7549             LBasicBlock numberCase = m_out.newBlock();
 7550             LBasicBlock continuation = m_out.newBlock();
 7551 
 7552             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 7553             patchpoint-&gt;append(arg1, ValueRep::SomeRegister);
 7554             patchpoint-&gt;append(arg2, ValueRep::SomeRegister);
 7555             patchpoint-&gt;numGPScratchRegisters = 1;
 7556             patchpoint-&gt;setGenerator(
 7557                 [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7558                     GPRReg scratchGPR = params.gpScratch(0);
 7559                     jit.moveDoubleTo64(params[1].fpr(), scratchGPR);
 7560                     jit.moveDoubleTo64(params[2].fpr(), params[0].gpr());
 7561                     jit.compare64(CCallHelpers::Equal, scratchGPR, params[0].gpr(), params[0].gpr());
 7562                 });
 7563             patchpoint-&gt;effects = Effects::none();
 7564             ValueFromBlock compareResult = m_out.anchor(patchpoint);
 7565             m_out.branch(patchpoint, unsure(continuation), unsure(numberCase));
 7566 
 7567             LBasicBlock lastNext = m_out.appendTo(numberCase, continuation);
 7568             LValue isArg1NaN = m_out.doubleNotEqualOrUnordered(arg1, arg1);
 7569             LValue isArg2NaN = m_out.doubleNotEqualOrUnordered(arg2, arg2);
 7570             ValueFromBlock nanResult = m_out.anchor(m_out.bitAnd(isArg1NaN, isArg2NaN));
 7571             m_out.jump(continuation);
 7572 
 7573             m_out.appendTo(continuation, lastNext);
 7574             setBoolean(m_out.phi(Int32, compareResult, nanResult));
 7575             return;
 7576         }
 7577 
 7578         ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
 7579         setBoolean(vmCall(Int32, m_out.operation(operationSameValue), m_callFrame, lowJSValue(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));
 7580     }
 7581 
 7582     void compileLogicalNot()
 7583     {
 7584         setBoolean(m_out.logicalNot(boolify(m_node-&gt;child1())));
 7585     }
 7586 
 7587     void compileCallOrConstruct()
 7588     {
 7589         Node* node = m_node;
 7590         unsigned numArgs = node-&gt;numChildren() - 1;
 7591 
 7592         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 7593 
 7594         unsigned frameSize = (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue);
 7595         unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 7596 
 7597         // JS-&gt;JS calling convention requires that the caller allows this much space on top of stack to
 7598         // get trashed by the callee, even if not all of that space is used to pass arguments. We tell
 7599         // B3 this explicitly for two reasons:
 7600         //
 7601         // - We will only pass frameSize worth of stuff.
 7602         // - The trashed stack guarantee is logically separate from the act of passing arguments, so we
 7603         //   shouldn&#39;t rely on Air to infer the trashed stack property based on the arguments it ends
 7604         //   up seeing.
 7605         m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 7606 
 7607         // Collect the arguments, since this can generate code and we want to generate it before we emit
 7608         // the call.
 7609         Vector&lt;ConstrainedValue&gt; arguments;
 7610 
 7611         // Make sure that the callee goes into GPR0 because that&#39;s where the slow path thunks expect the
 7612         // callee to be.
 7613         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 7614 
 7615         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 7616             intptr_t offsetFromSP =
 7617                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 7618             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 7619         };
 7620 
 7621         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 7622         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 7623         for (unsigned i = 0; i &lt; numArgs; ++i)
 7624             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 7625 
 7626         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 7627         patchpoint-&gt;appendVector(arguments);
 7628 
 7629         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 7630             preparePatchpointForExceptions(patchpoint);
 7631 
 7632         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 7633         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 7634         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 7635         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<a name="72" id="anc72"></a><span class="line-modified"> 7636         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 7637 
 7638         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 7639         State* state = &amp;m_ftlState;
 7640         VM* vm = &amp;this-&gt;vm();
 7641         patchpoint-&gt;setGenerator(
 7642             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7643                 AllowMacroScratchRegisterUsage allowScratch(jit);
 7644                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 7645 
 7646                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 7647 
 7648                 jit.store32(
 7649                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 7650                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 7651 
 7652                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 7653 
 7654                 CCallHelpers::DataLabelPtr targetToCheck;
 7655                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 7656                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 7657                     CCallHelpers::TrustedImmPtr(nullptr));
 7658 
 7659                 CCallHelpers::Call fastCall = jit.nearCall();
 7660                 CCallHelpers::Jump done = jit.jump();
 7661 
 7662                 slowPath.link(&amp;jit);
 7663 
 7664                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 7665                 CCallHelpers::Call slowCall = jit.nearCall();
 7666                 done.link(&amp;jit);
 7667 
 7668                 callLinkInfo-&gt;setUpCall(
 7669                     node-&gt;op() == Construct ? CallLinkInfo::Construct : CallLinkInfo::Call,
 7670                     node-&gt;origin.semantic, GPRInfo::regT0);
 7671 
 7672                 jit.addPtr(
 7673                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 7674                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 7675 
 7676                 jit.addLinkTask(
 7677                     [=] (LinkBuffer&amp; linkBuffer) {
 7678                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 7679                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 7680 
 7681                         callLinkInfo-&gt;setCallLocations(
 7682                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 7683                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 7684                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 7685                     });
 7686             });
 7687 
 7688         setJSValue(patchpoint);
 7689     }
 7690 
 7691     void compileDirectCallOrConstruct()
 7692     {
 7693         Node* node = m_node;
 7694         bool isTail = node-&gt;op() == DirectTailCall;
 7695         bool isConstruct = node-&gt;op() == DirectConstruct;
 7696 
 7697         ExecutableBase* executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 7698         FunctionExecutable* functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 7699 
 7700         unsigned numPassedArgs = node-&gt;numChildren() - 1;
 7701         unsigned numAllocatedArgs = numPassedArgs;
 7702 
 7703         if (functionExecutable) {
 7704             numAllocatedArgs = std::max(
 7705                 numAllocatedArgs,
 7706                 std::min(
 7707                     static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1,
 7708                     Options::maximumDirectCallStackSize()));
 7709         }
 7710 
 7711         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 7712 
 7713         if (!isTail) {
 7714             unsigned frameSize = (CallFrame::headerSizeInRegisters + numAllocatedArgs) * sizeof(EncodedJSValue);
 7715             unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 7716 
 7717             m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 7718         }
 7719 
 7720         Vector&lt;ConstrainedValue&gt; arguments;
 7721 
 7722         arguments.append(ConstrainedValue(jsCallee, ValueRep::SomeRegister));
 7723         if (!isTail) {
 7724             auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 7725                 intptr_t offsetFromSP =
 7726                     (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 7727                 arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 7728             };
 7729 
 7730             addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 7731             addArgument(m_out.constInt32(numPassedArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 7732             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
 7733                 addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 7734             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 7735                 addArgument(m_out.constInt64(JSValue::encode(jsUndefined())), virtualRegisterForArgument(i), 0);
 7736         } else {
 7737             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
 7738                 arguments.append(ConstrainedValue(lowJSValue(m_graph.varArgChild(node, 1 + i)), ValueRep::WarmAny));
 7739         }
 7740 
 7741         PatchpointValue* patchpoint = m_out.patchpoint(isTail ? Void : Int64);
 7742         patchpoint-&gt;appendVector(arguments);
 7743 
 7744         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 7745 
 7746         if (isTail) {
 7747             // The shuffler needs tags.
 7748             patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 7749             patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 7750         }
 7751 
 7752         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 7753         if (!isTail) {
 7754             patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<a name="73" id="anc73"></a><span class="line-modified"> 7755             patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 7756         }
 7757 
 7758         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 7759         State* state = &amp;m_ftlState;
 7760         patchpoint-&gt;setGenerator(
 7761             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7762                 AllowMacroScratchRegisterUsage allowScratch(jit);
 7763                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 7764 
 7765                 GPRReg calleeGPR = params[!isTail].gpr();
 7766 
 7767                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 7768 
 7769                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 7770                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 7771 
 7772                 if (isTail) {
 7773                     CallFrameShuffleData shuffleData;
 7774                     shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 7775 
 7776                     RegisterSet toSave = params.unavailableRegisters();
 7777                     shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatCell);
 7778                     toSave.set(calleeGPR);
 7779                     for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 7780                         ValueRecovery recovery = params[1 + i].recoveryForJSValue();
 7781                         shuffleData.args.append(recovery);
 7782                         recovery.forEachReg(
 7783                             [&amp;] (Reg reg) {
 7784                                 toSave.set(reg);
 7785                             });
 7786                     }
 7787                     for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 7788                         shuffleData.args.append(ValueRecovery::constant(jsUndefined()));
 7789                     shuffleData.numPassedArgs = numPassedArgs;
 7790                     shuffleData.setupCalleeSaveRegisters(jit.codeBlock());
 7791 
 7792                     CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 7793 
 7794                     CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
 7795                     CCallHelpers::Label mainPath = jit.label();
 7796 
 7797                     jit.store32(
 7798                         CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 7799                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 7800 
 7801                     callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 7802                     CallFrameShuffler(jit, shuffleData).prepareForTailCall();
 7803 
 7804                     CCallHelpers::Call call = jit.nearTailCall();
 7805 
 7806                     jit.abortWithReason(JITDidReturnFromTailCall);
 7807 
 7808                     CCallHelpers::Label slowPath = jit.label();
 7809                     patchableJump.m_jump.linkTo(slowPath, &amp;jit);
 7810                     callOperation(
 7811                         *state, toSave, jit,
 7812                         node-&gt;origin.semantic, exceptions.get(), operationLinkDirectCall,
 7813                         InvalidGPRReg, CCallHelpers::TrustedImmPtr(callLinkInfo), calleeGPR).call();
 7814                     jit.jump().linkTo(mainPath, &amp;jit);
 7815 
 7816                     callLinkInfo-&gt;setUpCall(
 7817                         CallLinkInfo::DirectTailCall, node-&gt;origin.semantic, InvalidGPRReg);
 7818                     callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 7819                     if (numAllocatedArgs &gt; numPassedArgs)
 7820                         callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);
 7821 
 7822                     jit.addLinkTask(
 7823                         [=] (LinkBuffer&amp; linkBuffer) {
 7824                             CodeLocationLabel&lt;JSInternalPtrTag&gt; patchableJumpLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump);
 7825                             CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
 7826                             CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(slowPath);
 7827 
 7828                             callLinkInfo-&gt;setCallLocations(
 7829                                 patchableJumpLocation,
 7830                                 slowPathLocation,
 7831                                 callLocation);
 7832                         });
 7833                     return;
 7834                 }
 7835 
 7836                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 7837 
 7838                 CCallHelpers::Label mainPath = jit.label();
 7839 
 7840                 jit.store32(
 7841                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 7842                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 7843 
 7844                 CCallHelpers::Call call = jit.nearCall();
 7845                 jit.addPtr(
 7846                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 7847                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 7848 
 7849                 callLinkInfo-&gt;setUpCall(
 7850                     isConstruct ? CallLinkInfo::DirectConstruct : CallLinkInfo::DirectCall,
 7851                     node-&gt;origin.semantic, InvalidGPRReg);
 7852                 callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 7853                 if (numAllocatedArgs &gt; numPassedArgs)
 7854                     callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);
 7855 
 7856                 params.addLatePath(
 7857                     [=] (CCallHelpers&amp; jit) {
 7858                         AllowMacroScratchRegisterUsage allowScratch(jit);
 7859 
 7860                         CCallHelpers::Label slowPath = jit.label();
 7861                         if (isX86())
 7862                             jit.pop(CCallHelpers::selectScratchGPR(calleeGPR));
 7863 
 7864                         callOperation(
 7865                             *state, params.unavailableRegisters(), jit,
 7866                             node-&gt;origin.semantic, exceptions.get(), operationLinkDirectCall,
 7867                             InvalidGPRReg, CCallHelpers::TrustedImmPtr(callLinkInfo),
 7868                             calleeGPR).call();
 7869                         jit.jump().linkTo(mainPath, &amp;jit);
 7870 
 7871                         jit.addLinkTask(
 7872                             [=] (LinkBuffer&amp; linkBuffer) {
 7873                                 CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
 7874                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(slowPath);
 7875 
 7876                                 linkBuffer.link(call, slowPathLocation);
 7877 
 7878                                 callLinkInfo-&gt;setCallLocations(
 7879                                     CodeLocationLabel&lt;JSInternalPtrTag&gt;(),
 7880                                     slowPathLocation,
 7881                                     callLocation);
 7882                             });
 7883                     });
 7884             });
 7885 
 7886         if (isTail)
 7887             patchpoint-&gt;effects.terminal = true;
 7888         else
 7889             setJSValue(patchpoint);
 7890     }
 7891 
 7892     void compileTailCall()
 7893     {
 7894         Node* node = m_node;
 7895         unsigned numArgs = node-&gt;numChildren() - 1;
 7896 
 7897         // It seems counterintuitive that this is needed given that tail calls don&#39;t create a new frame
 7898         // on the stack. However, the tail call slow path builds the frame at SP instead of FP before
 7899         // calling into the slow path C code. This slow path may decide to throw an exception because
 7900         // the callee we&#39;re trying to call is not callable. Throwing an exception will cause us to walk
 7901         // the stack, which may read, for the sake of the correctness of this code, arbitrary slots on the
 7902         // stack to recover state. This call arg area ensures the call frame shuffler does not overwrite
 7903         // any of the slots the stack walking code requires when on the slow path.
 7904         m_proc.requestCallArgAreaSizeInBytes(
 7905             WTF::roundUpToMultipleOf(stackAlignmentBytes(), (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue)));
 7906 
 7907         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 7908 
 7909         // We want B3 to give us all of the arguments using whatever mechanism it thinks is
 7910         // convenient. The generator then shuffles those arguments into our own call frame,
 7911         // destroying our frame in the process.
 7912 
 7913         // Note that we don&#39;t have to do anything special for exceptions. A tail call is only a
 7914         // tail call if it is not inside a try block.
 7915 
 7916         Vector&lt;ConstrainedValue&gt; arguments;
 7917 
 7918         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 7919 
 7920         for (unsigned i = 0; i &lt; numArgs; ++i) {
 7921             // Note: we could let the shuffler do boxing for us, but it&#39;s not super clear that this
 7922             // would be better. Also, if we wanted to do that, then we&#39;d have to teach the shuffler
 7923             // that 32-bit values could land at 4-byte alignment but not 8-byte alignment.
 7924 
 7925             ConstrainedValue constrainedValue(
 7926                 lowJSValue(m_graph.varArgChild(node, 1 + i)),
 7927                 ValueRep::WarmAny);
 7928             arguments.append(constrainedValue);
 7929         }
 7930 
 7931         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 7932         patchpoint-&gt;appendVector(arguments);
 7933 
 7934         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 7935         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 7936 
 7937         // Prevent any of the arguments from using the scratch register.
 7938         patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());
 7939 
 7940         patchpoint-&gt;effects.terminal = true;
 7941 
 7942         // We don&#39;t have to tell the patchpoint that we will clobber registers, since we won&#39;t return
 7943         // anyway.
 7944 
 7945         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 7946         State* state = &amp;m_ftlState;
 7947         VM* vm = &amp;this-&gt;vm();
 7948         patchpoint-&gt;setGenerator(
 7949             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7950                 AllowMacroScratchRegisterUsage allowScratch(jit);
 7951                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 7952 
 7953                 // Yes, this is really necessary. You could throw an exception in a host call on the
 7954                 // slow path. That&#39;ll route us to lookupExceptionHandler(), which unwinds starting
 7955                 // with the call site index of our frame. Bad things happen if it&#39;s not set.
 7956                 jit.store32(
 7957                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 7958                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 7959 
 7960                 CallFrameShuffleData shuffleData;
 7961                 shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 7962                 shuffleData.callee = ValueRecovery::inGPR(GPRInfo::regT0, DataFormatJS);
 7963 
 7964                 for (unsigned i = 0; i &lt; numArgs; ++i)
 7965                     shuffleData.args.append(params[1 + i].recoveryForJSValue());
 7966 
 7967                 shuffleData.numPassedArgs = numArgs;
 7968 
 7969                 shuffleData.setupCalleeSaveRegisters(jit.codeBlock());
 7970 
 7971                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 7972 
 7973                 CCallHelpers::DataLabelPtr targetToCheck;
 7974                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 7975                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 7976                     CCallHelpers::TrustedImmPtr(nullptr));
 7977 
 7978                 callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 7979                 CallFrameShuffler(jit, shuffleData).prepareForTailCall();
 7980 
 7981                 CCallHelpers::Call fastCall = jit.nearTailCall();
 7982 
 7983                 slowPath.link(&amp;jit);
 7984 
 7985                 CallFrameShuffler slowPathShuffler(jit, shuffleData);
 7986                 slowPathShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 7987                 slowPathShuffler.prepareForSlowPath();
 7988 
 7989                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 7990                 CCallHelpers::Call slowCall = jit.nearCall();
 7991 
 7992                 jit.abortWithReason(JITDidReturnFromTailCall);
 7993 
 7994                 callLinkInfo-&gt;setUpCall(CallLinkInfo::TailCall, codeOrigin, GPRInfo::regT0);
 7995 
 7996                 jit.addLinkTask(
 7997                     [=] (LinkBuffer&amp; linkBuffer) {
 7998                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 7999                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8000 
 8001                         callLinkInfo-&gt;setCallLocations(
 8002                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8003                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8004                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8005                     });
 8006             });
 8007     }
 8008 
 8009     void compileCallOrConstructVarargsSpread()
 8010     {
 8011         Node* node = m_node;
 8012         Node* arguments = node-&gt;child3().node();
 8013 
 8014         LValue jsCallee = lowJSValue(m_node-&gt;child1());
 8015         LValue thisArg = lowJSValue(m_node-&gt;child2());
 8016 
 8017         RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomSpread || arguments-&gt;op() == PhantomNewArrayBuffer);
 8018 
 8019         unsigned staticArgumentCount = 0;
 8020         Vector&lt;LValue, 2&gt; spreadLengths;
 8021         Vector&lt;LValue, 8&gt; patchpointArguments;
 8022         HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 8023         auto pushAndCountArgumentsFromRightToLeft = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 8024             if (target-&gt;op() == PhantomSpread) {
 8025                 self(target-&gt;child1().node());
 8026                 return;
 8027             }
 8028 
 8029             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8030                 BitVector* bitVector = target-&gt;bitVector();
 8031                 for (unsigned i = target-&gt;numChildren(); i--; ) {
 8032                     if (bitVector-&gt;get(i))
 8033                         self(m_graph.varArgChild(target, i).node());
 8034                     else {
 8035                         ++staticArgumentCount;
 8036                         LValue argument = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 8037                         patchpointArguments.append(argument);
 8038                     }
 8039                 }
 8040                 return;
 8041             }
 8042 
 8043             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8044                 staticArgumentCount += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 8045                 return;
 8046             }
 8047 
 8048             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<a name="74" id="anc74"></a><span class="line-modified"> 8049             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8050             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8051             LValue length = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 8052                 return m_out.zeroExtPtr(this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));
 8053             }).iterator-&gt;value;
 8054             patchpointArguments.append(length);
 8055             spreadLengths.append(length);
 8056         });
 8057 
 8058         pushAndCountArgumentsFromRightToLeft(arguments);
 8059         LValue argumentCountIncludingThis = m_out.constIntPtr(staticArgumentCount + 1);
 8060         for (LValue length : spreadLengths)
 8061             argumentCountIncludingThis = m_out.add(length, argumentCountIncludingThis);
 8062 
 8063         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8064 
 8065         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 8066         patchpoint-&gt;append(thisArg, ValueRep::WarmAny);
 8067         patchpoint-&gt;append(argumentCountIncludingThis, ValueRep::WarmAny);
 8068         patchpoint-&gt;appendVectorWithRep(patchpointArguments, ValueRep::WarmAny);
 8069         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8070         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8071 
 8072         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8073 
 8074         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8075         patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
<a name="75" id="anc75"></a><span class="line-modified"> 8076         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 8077 
 8078         patchpoint-&gt;numGPScratchRegisters = 0;
 8079 
 8080         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8081         unsigned minimumJSCallAreaSize =
 8082             sizeof(CallerFrameAndPC) +
 8083             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8084 
 8085         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8086 
 8087         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8088         State* state = &amp;m_ftlState;
 8089         VM* vm = &amp;this-&gt;vm();
 8090         patchpoint-&gt;setGenerator(
 8091             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8092                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8093                 CallSiteIndex callSiteIndex =
 8094                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8095 
 8096                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8097                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8098 
 8099                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8100 
 8101                 jit.store32(
 8102                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8103                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8104 
 8105                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8106 
 8107                 RegisterSet usedRegisters = RegisterSet::allRegisters();
 8108                 usedRegisters.exclude(RegisterSet::volatileRegistersForJSCall());
 8109                 GPRReg calleeGPR = params[1].gpr();
 8110                 usedRegisters.set(calleeGPR);
 8111 
 8112                 ScratchRegisterAllocator allocator(usedRegisters);
 8113                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 8114                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 8115                 GPRReg scratchGPR3 = allocator.allocateScratchGPR();
 8116                 GPRReg scratchGPR4 = allocator.allocateScratchGPR();
 8117                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 8118 
 8119                 auto getValueFromRep = [&amp;] (B3::ValueRep rep, GPRReg result) {
 8120                     ASSERT(!usedRegisters.get(result));
 8121 
 8122                     if (rep.isConstant()) {
 8123                         jit.move(CCallHelpers::Imm64(rep.value()), result);
 8124                         return;
 8125                     }
 8126 
 8127                     // Note: in this function, we only request 64 bit values.
 8128                     if (rep.isStack()) {
 8129                         jit.load64(
 8130                             CCallHelpers::Address(GPRInfo::callFrameRegister, rep.offsetFromFP()),
 8131                             result);
 8132                         return;
 8133                     }
 8134 
 8135                     RELEASE_ASSERT(rep.isGPR());
 8136                     ASSERT(usedRegisters.get(rep.gpr()));
 8137                     jit.move(rep.gpr(), result);
 8138                 };
 8139 
 8140                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 8141                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 8142                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8143                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8144                 };
 8145 
 8146                 CCallHelpers::JumpList slowCase;
 8147                 unsigned originalStackHeight = params.proc().frameSize();
 8148 
 8149                 {
 8150                     unsigned numUsedSlots = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), originalStackHeight / sizeof(EncodedJSValue));
 8151                     B3::ValueRep argumentCountIncludingThisRep = params[3];
 8152                     getValueFromRep(argumentCountIncludingThisRep, scratchGPR2);
 8153                     slowCase.append(jit.branch32(CCallHelpers::Above, scratchGPR2, CCallHelpers::TrustedImm32(JSC::maxArguments + 1)));
 8154 
 8155                     jit.move(scratchGPR2, scratchGPR1);
 8156                     jit.addPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(numUsedSlots + CallFrame::headerSizeInRegisters)), scratchGPR1);
 8157                     // scratchGPR1 now has the required frame size in Register units
 8158                     // Round scratchGPR1 to next multiple of stackAlignmentRegisters()
 8159                     jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentRegisters() - 1), scratchGPR1);
 8160                     jit.andPtr(CCallHelpers::TrustedImm32(~(stackAlignmentRegisters() - 1)), scratchGPR1);
 8161                     jit.negPtr(scratchGPR1);
 8162                     jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR1, CCallHelpers::TimesEight), scratchGPR1);
 8163 
 8164                     // Before touching stack values, we should update the stack pointer to protect them from signal stack.
 8165                     jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), scratchGPR1, CCallHelpers::stackPointerRegister);
 8166 
 8167                     jit.store32(scratchGPR2, CCallHelpers::Address(scratchGPR1, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));
 8168 
 8169                     int storeOffset = CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register));
 8170 
 8171                     unsigned paramsOffset = 4;
 8172                     unsigned index = 0;
 8173                     auto emitArgumentsFromRightToLeft = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 8174                         if (target-&gt;op() == PhantomSpread) {
 8175                             self(target-&gt;child1().node());
 8176                             return;
 8177                         }
 8178 
 8179                         if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8180                             BitVector* bitVector = target-&gt;bitVector();
 8181                             for (unsigned i = target-&gt;numChildren(); i--; ) {
 8182                                 if (bitVector-&gt;get(i))
 8183                                     self(state-&gt;graph.varArgChild(target, i).node());
 8184                                 else {
 8185                                     jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 8186                                     getValueFromRep(params[paramsOffset + (index++)], scratchGPR3);
 8187                                     jit.store64(scratchGPR3,
 8188                                         CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 8189                                 }
 8190                             }
 8191                             return;
 8192                         }
 8193 
 8194                         if (target-&gt;op() == PhantomNewArrayBuffer) {
 8195                             auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 8196                             Checked&lt;int32_t&gt; offsetCount { 1 };
 8197                             for (unsigned i = array-&gt;length(); i--; ++offsetCount) {
 8198                                 // Because varargs values are drained as JSValue, we should not generate value
 8199                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 8200                                 int64_t value = JSValue::encode(array-&gt;get(i));
 8201                                 jit.move(CCallHelpers::TrustedImm64(value), scratchGPR3);
 8202                                 Checked&lt;int32_t&gt; currentStoreOffset { storeOffset };
 8203                                 currentStoreOffset -= (offsetCount * static_cast&lt;int32_t&gt;(sizeof(Register)));
 8204                                 jit.store64(scratchGPR3,
 8205                                     CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, currentStoreOffset.unsafeGet()));
 8206                             }
 8207                             jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(array-&gt;length())), scratchGPR2);
 8208                             return;
 8209                         }
 8210 
 8211                         RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<a name="76" id="anc76"></a><span class="line-modified"> 8212                         InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8213 
 8214                         unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8215 
 8216                         B3::ValueRep numArgumentsToCopy = params[paramsOffset + (index++)];
 8217                         getValueFromRep(numArgumentsToCopy, scratchGPR3);
 8218                         int loadOffset = (AssemblyHelpers::argumentsStart(inlineCallFrame).offset() + numberOfArgumentsToSkip) * static_cast&lt;int&gt;(sizeof(Register));
 8219 
 8220                         auto done = jit.branchTestPtr(MacroAssembler::Zero, scratchGPR3);
 8221                         auto loopStart = jit.label();
 8222                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR3);
 8223                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 8224                         jit.load64(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR3, CCallHelpers::TimesEight, loadOffset), scratchGPR4);
 8225                         jit.store64(scratchGPR4,
 8226                             CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 8227                         jit.branchTestPtr(CCallHelpers::NonZero, scratchGPR3).linkTo(loopStart, &amp;jit);
 8228                         done.link(&amp;jit);
 8229                     });
 8230                     emitArgumentsFromRightToLeft(arguments);
 8231                 }
 8232 
 8233                 {
 8234                     CCallHelpers::Jump dontThrow = jit.jump();
 8235                     slowCase.link(&amp;jit);
 8236                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();
 8237                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 8238                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 8239 
 8240                     dontThrow.link(&amp;jit);
 8241                 }
 8242 
 8243                 ASSERT(calleeGPR == GPRInfo::regT0);
 8244                 jit.store64(calleeGPR, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));
 8245                 getValueFromRep(params[2], scratchGPR3);
 8246                 jit.store64(scratchGPR3, CCallHelpers::calleeArgumentSlot(0));
 8247 
 8248                 CallLinkInfo::CallType callType;
 8249                 if (node-&gt;op() == ConstructVarargs || node-&gt;op() == ConstructForwardVarargs)
 8250                     callType = CallLinkInfo::ConstructVarargs;
 8251                 else if (node-&gt;op() == TailCallVarargs || node-&gt;op() == TailCallForwardVarargs)
 8252                     callType = CallLinkInfo::TailCallVarargs;
 8253                 else
 8254                     callType = CallLinkInfo::CallVarargs;
 8255 
 8256                 bool isTailCall = CallLinkInfo::callModeFor(callType) == CallMode::Tail;
 8257 
 8258                 CCallHelpers::DataLabelPtr targetToCheck;
 8259                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 8260                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 8261                     CCallHelpers::TrustedImmPtr(nullptr));
 8262 
 8263                 CCallHelpers::Call fastCall;
 8264                 CCallHelpers::Jump done;
 8265 
 8266                 if (isTailCall) {
 8267                     jit.emitRestoreCalleeSaves();
 8268                     jit.prepareForTailCallSlow();
 8269                     fastCall = jit.nearTailCall();
 8270                 } else {
 8271                     fastCall = jit.nearCall();
 8272                     done = jit.jump();
 8273                 }
 8274 
 8275                 slowPath.link(&amp;jit);
 8276 
 8277                 if (isTailCall)
 8278                     jit.emitRestoreCalleeSaves();
 8279                 ASSERT(!usedRegisters.get(GPRInfo::regT2));
 8280                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 8281                 CCallHelpers::Call slowCall = jit.nearCall();
 8282 
 8283                 if (isTailCall)
 8284                     jit.abortWithReason(JITDidReturnFromTailCall);
 8285                 else
 8286                     done.link(&amp;jit);
 8287 
 8288                 callLinkInfo-&gt;setUpCall(callType, node-&gt;origin.semantic, GPRInfo::regT0);
 8289 
 8290                 jit.addPtr(
 8291                     CCallHelpers::TrustedImm32(-originalStackHeight),
 8292                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8293 
 8294                 jit.addLinkTask(
 8295                     [=] (LinkBuffer&amp; linkBuffer) {
 8296                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 8297                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8298 
 8299                         callLinkInfo-&gt;setCallLocations(
 8300                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8301                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8302                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8303                     });
 8304             });
 8305 
 8306         switch (node-&gt;op()) {
 8307         case TailCallForwardVarargs:
 8308             m_out.unreachable();
 8309             break;
 8310 
 8311         default:
 8312             setJSValue(patchpoint);
 8313             break;
 8314         }
 8315     }
 8316 
 8317     void compileCallOrConstructVarargs()
 8318     {
 8319         Node* node = m_node;
 8320         LValue jsCallee = lowJSValue(m_node-&gt;child1());
 8321         LValue thisArg = lowJSValue(m_node-&gt;child2());
 8322 
 8323         LValue jsArguments = nullptr;
 8324         bool forwarding = false;
 8325 
 8326         switch (node-&gt;op()) {
 8327         case CallVarargs:
 8328         case TailCallVarargs:
 8329         case TailCallVarargsInlinedCaller:
 8330         case ConstructVarargs:
 8331             jsArguments = lowJSValue(node-&gt;child3());
 8332             break;
 8333         case CallForwardVarargs:
 8334         case TailCallForwardVarargs:
 8335         case TailCallForwardVarargsInlinedCaller:
 8336         case ConstructForwardVarargs:
 8337             forwarding = true;
 8338             break;
 8339         default:
 8340             DFG_CRASH(m_graph, node, &quot;bad node type&quot;);
 8341             break;
 8342         }
 8343 
 8344         if (forwarding &amp;&amp; m_node-&gt;child3()) {
 8345             Node* arguments = m_node-&gt;child3().node();
 8346             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 8347                 compileCallOrConstructVarargsSpread();
 8348                 return;
 8349             }
 8350         }
 8351 
 8352 
 8353         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8354 
 8355         // Append the forms of the arguments that we will use before any clobbering happens.
 8356         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 8357         if (jsArguments)
 8358             patchpoint-&gt;appendSomeRegister(jsArguments);
 8359         patchpoint-&gt;appendSomeRegister(thisArg);
 8360 
 8361         if (!forwarding) {
 8362             // Now append them again for after clobbering. Note that the compiler may ask us to use a
 8363             // different register for the late for the post-clobbering version of the value. This gives
 8364             // the compiler a chance to spill these values without having to burn any callee-saves.
 8365             patchpoint-&gt;append(jsCallee, ValueRep::LateColdAny);
 8366             patchpoint-&gt;append(jsArguments, ValueRep::LateColdAny);
 8367             patchpoint-&gt;append(thisArg, ValueRep::LateColdAny);
 8368         }
 8369 
 8370         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 8371             preparePatchpointForExceptions(patchpoint);
 8372 
 8373         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8374         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8375 
 8376         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8377         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<a name="77" id="anc77"></a><span class="line-modified"> 8378         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 8379 
 8380         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8381         unsigned minimumJSCallAreaSize =
 8382             sizeof(CallerFrameAndPC) +
 8383             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8384 
 8385         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8386 
 8387         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8388         State* state = &amp;m_ftlState;
 8389         VM* vm = &amp;this-&gt;vm();
 8390         patchpoint-&gt;setGenerator(
 8391             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8392                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8393                 CallSiteIndex callSiteIndex =
 8394                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8395 
 8396                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8397                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8398 
 8399                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8400 
 8401                 jit.store32(
 8402                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8403                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8404 
 8405                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8406                 CallVarargsData* data = node-&gt;callVarargsData();
 8407 
 8408                 unsigned argIndex = 1;
 8409                 GPRReg calleeGPR = params[argIndex++].gpr();
 8410                 ASSERT(calleeGPR == GPRInfo::regT0);
 8411                 GPRReg argumentsGPR = jsArguments ? params[argIndex++].gpr() : InvalidGPRReg;
 8412                 GPRReg thisGPR = params[argIndex++].gpr();
 8413 
 8414                 B3::ValueRep calleeLateRep;
 8415                 B3::ValueRep argumentsLateRep;
 8416                 B3::ValueRep thisLateRep;
 8417                 if (!forwarding) {
 8418                     // If we&#39;re not forwarding then we&#39;ll need callee, arguments, and this after we
 8419                     // have potentially clobbered calleeGPR, argumentsGPR, and thisGPR. Our technique
 8420                     // for this is to supply all of those operands as late uses in addition to
 8421                     // specifying them as early uses. It&#39;s possible that the late use uses a spill
 8422                     // while the early use uses a register, and it&#39;s possible for the late and early
 8423                     // uses to use different registers. We do know that the late uses interfere with
 8424                     // all volatile registers and so won&#39;t use those, but the early uses may use
 8425                     // volatile registers and in the case of calleeGPR, it&#39;s pinned to regT0 so it
 8426                     // definitely will.
 8427                     //
 8428                     // Note that we have to be super careful with these. It&#39;s possible that these
 8429                     // use a shuffling of the registers used for calleeGPR, argumentsGPR, and
 8430                     // thisGPR. If that happens and we do for example:
 8431                     //
 8432                     //     calleeLateRep.emitRestore(jit, calleeGPR);
 8433                     //     argumentsLateRep.emitRestore(jit, calleeGPR);
 8434                     //
 8435                     // Then we might end up with garbage if calleeLateRep.gpr() == argumentsGPR and
 8436                     // argumentsLateRep.gpr() == calleeGPR.
 8437                     //
 8438                     // We do a variety of things to prevent this from happening. For example, we use
 8439                     // argumentsLateRep before needing the other two and after we&#39;ve already stopped
 8440                     // using the *GPRs. Also, we pin calleeGPR to regT0, and rely on the fact that
 8441                     // the *LateReps cannot use volatile registers (so they cannot be regT0, so
 8442                     // calleeGPR != argumentsLateRep.gpr() and calleeGPR != thisLateRep.gpr()).
 8443                     //
 8444                     // An alternative would have been to just use early uses and early-clobber all
 8445                     // volatile registers. But that would force callee, arguments, and this into
 8446                     // callee-save registers even if we have to spill them. We don&#39;t want spilling to
 8447                     // use up three callee-saves.
 8448                     //
 8449                     // TL;DR: The way we use LateReps here is dangerous and barely works but achieves
 8450                     // some desirable performance properties, so don&#39;t mistake the cleverness for
 8451                     // elegance.
 8452                     calleeLateRep = params[argIndex++];
 8453                     argumentsLateRep = params[argIndex++];
 8454                     thisLateRep = params[argIndex++];
 8455                 }
 8456 
 8457                 // Get some scratch registers.
 8458                 RegisterSet usedRegisters;
 8459                 usedRegisters.merge(RegisterSet::stackRegisters());
 8460                 usedRegisters.merge(RegisterSet::reservedHardwareRegisters());
 8461                 usedRegisters.merge(RegisterSet::calleeSaveRegisters());
 8462                 usedRegisters.set(calleeGPR);
 8463                 if (argumentsGPR != InvalidGPRReg)
 8464                     usedRegisters.set(argumentsGPR);
 8465                 usedRegisters.set(thisGPR);
 8466                 if (calleeLateRep.isReg())
 8467                     usedRegisters.set(calleeLateRep.reg());
 8468                 if (argumentsLateRep.isReg())
 8469                     usedRegisters.set(argumentsLateRep.reg());
 8470                 if (thisLateRep.isReg())
 8471                     usedRegisters.set(thisLateRep.reg());
 8472                 ScratchRegisterAllocator allocator(usedRegisters);
 8473                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 8474                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 8475                 GPRReg scratchGPR3 = forwarding ? allocator.allocateScratchGPR() : InvalidGPRReg;
 8476                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 8477 
 8478                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 8479                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 8480                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8481                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8482                 };
 8483 
 8484                 unsigned originalStackHeight = params.proc().frameSize();
 8485 
 8486                 if (forwarding) {
 8487                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8488 
 8489                     CCallHelpers::JumpList slowCase;
 8490                     InlineCallFrame* inlineCallFrame;
 8491                     if (node-&gt;child3())
<a name="78" id="anc78"></a><span class="line-modified"> 8492                         inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame;</span>
 8493                     else
<a name="79" id="anc79"></a><span class="line-modified"> 8494                         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;</span>
 8495 
 8496                     // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 8497                     emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 8498 
 8499                     CCallHelpers::Jump done = jit.jump();
 8500                     slowCase.link(&amp;jit);
 8501                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();
 8502                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 8503                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 8504 
 8505                     done.link(&amp;jit);
 8506                 } else {
 8507                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR1);
 8508                     jit.setupArguments&lt;decltype(operationSizeFrameForVarargs)&gt;(argumentsGPR, scratchGPR1, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset));
 8509                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSizeFrameForVarargs));
 8510 
 8511                     jit.move(GPRInfo::returnValueGPR, scratchGPR1);
 8512                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8513                     argumentsLateRep.emitRestore(jit, argumentsGPR);
 8514                     emitSetVarargsFrame(jit, scratchGPR1, false, scratchGPR2, scratchGPR2);
 8515                     jit.addPtr(CCallHelpers::TrustedImm32(-minimumJSCallAreaSize), scratchGPR2, CCallHelpers::stackPointerRegister);
 8516                     jit.setupArguments&lt;decltype(operationSetupVarargsFrame)&gt;(scratchGPR2, argumentsGPR, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset), scratchGPR1);
 8517                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSetupVarargsFrame));
 8518 
 8519                     jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, CCallHelpers::stackPointerRegister);
 8520 
 8521                     calleeLateRep.emitRestore(jit, GPRInfo::regT0);
 8522 
 8523                     // This may not emit code if thisGPR got a callee-save. Also, we&#39;re guaranteed
 8524                     // that thisGPR != GPRInfo::regT0 because regT0 interferes with it.
 8525                     thisLateRep.emitRestore(jit, thisGPR);
 8526                 }
 8527 
 8528                 jit.store64(GPRInfo::regT0, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));
 8529                 jit.store64(thisGPR, CCallHelpers::calleeArgumentSlot(0));
 8530 
 8531                 CallLinkInfo::CallType callType;
 8532                 if (node-&gt;op() == ConstructVarargs || node-&gt;op() == ConstructForwardVarargs)
 8533                     callType = CallLinkInfo::ConstructVarargs;
 8534                 else if (node-&gt;op() == TailCallVarargs || node-&gt;op() == TailCallForwardVarargs)
 8535                     callType = CallLinkInfo::TailCallVarargs;
 8536                 else
 8537                     callType = CallLinkInfo::CallVarargs;
 8538 
 8539                 bool isTailCall = CallLinkInfo::callModeFor(callType) == CallMode::Tail;
 8540 
 8541                 CCallHelpers::DataLabelPtr targetToCheck;
 8542                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 8543                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 8544                     CCallHelpers::TrustedImmPtr(nullptr));
 8545 
 8546                 CCallHelpers::Call fastCall;
 8547                 CCallHelpers::Jump done;
 8548 
 8549                 if (isTailCall) {
 8550                     jit.emitRestoreCalleeSaves();
 8551                     jit.prepareForTailCallSlow();
 8552                     fastCall = jit.nearTailCall();
 8553                 } else {
 8554                     fastCall = jit.nearCall();
 8555                     done = jit.jump();
 8556                 }
 8557 
 8558                 slowPath.link(&amp;jit);
 8559 
 8560                 if (isTailCall)
 8561                     jit.emitRestoreCalleeSaves();
 8562                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 8563                 CCallHelpers::Call slowCall = jit.nearCall();
 8564 
 8565                 if (isTailCall)
 8566                     jit.abortWithReason(JITDidReturnFromTailCall);
 8567                 else
 8568                     done.link(&amp;jit);
 8569 
 8570                 callLinkInfo-&gt;setUpCall(callType, node-&gt;origin.semantic, GPRInfo::regT0);
 8571 
 8572                 jit.addPtr(
 8573                     CCallHelpers::TrustedImm32(-originalStackHeight),
 8574                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8575 
 8576                 jit.addLinkTask(
 8577                     [=] (LinkBuffer&amp; linkBuffer) {
 8578                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 8579                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8580 
 8581                         callLinkInfo-&gt;setCallLocations(
 8582                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8583                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8584                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8585                     });
 8586             });
 8587 
 8588         switch (node-&gt;op()) {
 8589         case TailCallVarargs:
 8590         case TailCallForwardVarargs:
 8591             m_out.unreachable();
 8592             break;
 8593 
 8594         default:
 8595             setJSValue(patchpoint);
 8596             break;
 8597         }
 8598     }
 8599 
 8600     void compileCallEval()
 8601     {
 8602         Node* node = m_node;
 8603         unsigned numArgs = node-&gt;numChildren() - 1;
 8604 
 8605         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 8606 
 8607         unsigned frameSize = (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue);
 8608         unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 8609 
 8610         m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 8611 
 8612         Vector&lt;ConstrainedValue&gt; arguments;
 8613         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 8614 
 8615         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 8616             intptr_t offsetFromSP =
 8617                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 8618             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 8619         };
 8620 
 8621         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 8622         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 8623         for (unsigned i = 0; i &lt; numArgs; ++i)
 8624             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 8625 
 8626         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8627         patchpoint-&gt;appendVector(arguments);
 8628 
 8629         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8630 
 8631         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8632         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8633         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8634         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<a name="80" id="anc80"></a><span class="line-modified"> 8635         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
 8636 
 8637         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8638         State* state = &amp;m_ftlState;
 8639         VM&amp; vm = this-&gt;vm();
 8640         patchpoint-&gt;setGenerator(
 8641             [=, &amp;vm] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8642                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8643                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8644 
 8645                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8646 
 8647                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8648 
 8649                 jit.store32(
 8650                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8651                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8652 
 8653                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8654                 callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, node-&gt;origin.semantic, GPRInfo::regT0);
 8655 
 8656                 jit.addPtr(CCallHelpers::TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), CCallHelpers::stackPointerRegister, GPRInfo::regT1);
 8657                 jit.storePtr(GPRInfo::callFrameRegister, CCallHelpers::Address(GPRInfo::regT1, CallFrame::callerFrameOffset()));
 8658 
 8659                 // Now we need to make room for:
 8660                 // - The caller frame and PC for a call to operationCallEval.
 8661                 // - Potentially two arguments on the stack.
 8662                 unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;
 8663                 requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 8664                 jit.subPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
 8665                 jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT1);
 8666                 jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationCallEval)), GPRInfo::nonPreservedNonArgumentGPR0);
 8667                 jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8668                 exceptions-&gt;append(jit.emitExceptionCheck(state-&gt;vm(), AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8669 
 8670                 CCallHelpers::Jump done = jit.branchTest64(CCallHelpers::NonZero, GPRInfo::returnValueGPR);
 8671 
 8672                 jit.addPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
 8673                 jit.load64(CCallHelpers::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
 8674                 jit.emitDumbVirtualCall(vm, callLinkInfo);
 8675 
 8676                 done.link(&amp;jit);
 8677                 jit.addPtr(
 8678                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 8679                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8680             });
 8681 
 8682         setJSValue(patchpoint);
 8683     }
 8684 
 8685     void compileLoadVarargs()
 8686     {
 8687         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8688         LValue jsArguments = lowJSValue(m_node-&gt;child1());
 8689 
 8690         LValue length = vmCall(
 8691             Int32, m_out.operation(operationSizeOfVarargs), m_callFrame, jsArguments,
 8692             m_out.constInt32(data-&gt;offset));
 8693 
 8694         // FIXME: There is a chance that we will call an effectful length property twice. This is safe
 8695         // from the standpoint of the VM&#39;s integrity, but it&#39;s subtly wrong from a spec compliance
 8696         // standpoint. The best solution would be one where we can exit *into* the op_call_varargs right
 8697         // past the sizing.
 8698         // https://bugs.webkit.org/show_bug.cgi?id=141448
 8699 
 8700         LValue lengthIncludingThis = m_out.add(length, m_out.int32One);
 8701 
 8702         speculate(
 8703             VarargsOverflow, noValue(), nullptr,
 8704             m_out.above(length, lengthIncludingThis));
 8705 
 8706         speculate(
 8707             VarargsOverflow, noValue(), nullptr,
 8708             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 8709 
 8710         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 8711 
 8712         // FIXME: This computation is rather silly. If operationLaodVarargs just took a pointer instead
 8713         // of a VirtualRegister, we wouldn&#39;t have to do this.
 8714         // https://bugs.webkit.org/show_bug.cgi?id=141660
 8715         LValue machineStart = m_out.lShr(
 8716             m_out.sub(addressFor(data-&gt;machineStart.offset()).value(), m_callFrame),
 8717             m_out.constIntPtr(3));
 8718 
 8719         vmCall(
 8720             Void, m_out.operation(operationLoadVarargs), m_callFrame,
 8721             m_out.castToInt32(machineStart), jsArguments, m_out.constInt32(data-&gt;offset),
 8722             length, m_out.constInt32(data-&gt;mandatoryMinimum));
 8723     }
 8724 
 8725     void compileForwardVarargs()
 8726     {
 8727         if (m_node-&gt;child1()) {
 8728             Node* arguments = m_node-&gt;child1().node();
 8729             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 8730                 compileForwardVarargsWithSpread();
 8731                 return;
 8732             }
 8733         }
 8734 
 8735         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8736         InlineCallFrame* inlineCallFrame;
 8737         if (m_node-&gt;child1())
<a name="81" id="anc81"></a><span class="line-modified"> 8738             inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 8739         else
<a name="82" id="anc82"></a><span class="line-modified"> 8740             inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame;</span>
 8741 
 8742         LValue length = nullptr;
 8743         LValue lengthIncludingThis = nullptr;
 8744         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
 8745         if (argumentsLength.isKnown) {
 8746             unsigned knownLength = argumentsLength.known;
 8747             if (knownLength &gt;= data-&gt;offset)
 8748                 knownLength = knownLength - data-&gt;offset;
 8749             else
 8750                 knownLength = 0;
 8751             length = m_out.constInt32(knownLength);
 8752             lengthIncludingThis = m_out.constInt32(knownLength + 1);
 8753         } else {
 8754             // We need to perform the same logical operation as the code above, but through dynamic operations.
 8755             if (!data-&gt;offset)
 8756                 length = argumentsLength.value;
 8757             else {
 8758                 LBasicBlock isLarger = m_out.newBlock();
 8759                 LBasicBlock continuation = m_out.newBlock();
 8760 
 8761                 ValueFromBlock smallerOrEqualLengthResult = m_out.anchor(m_out.constInt32(0));
 8762                 m_out.branch(
 8763                     m_out.above(argumentsLength.value, m_out.constInt32(data-&gt;offset)), unsure(isLarger), unsure(continuation));
 8764                 LBasicBlock lastNext = m_out.appendTo(isLarger, continuation);
 8765                 ValueFromBlock largerLengthResult = m_out.anchor(m_out.sub(argumentsLength.value, m_out.constInt32(data-&gt;offset)));
 8766                 m_out.jump(continuation);
 8767 
 8768                 m_out.appendTo(continuation, lastNext);
 8769                 length = m_out.phi(Int32, smallerOrEqualLengthResult, largerLengthResult);
 8770             }
 8771             lengthIncludingThis = m_out.add(length, m_out.constInt32(1));
 8772         }
 8773 
 8774         speculate(
 8775             VarargsOverflow, noValue(), nullptr,
 8776             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 8777 
 8778         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 8779 
 8780         unsigned numberOfArgumentsToSkip = data-&gt;offset;
 8781         LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 8782         LValue targetStart = addressFor(data-&gt;machineStart).value();
 8783 
 8784         LBasicBlock undefinedLoop = m_out.newBlock();
 8785         LBasicBlock mainLoopEntry = m_out.newBlock();
 8786         LBasicBlock mainLoop = m_out.newBlock();
 8787         LBasicBlock continuation = m_out.newBlock();
 8788 
 8789         LValue lengthAsPtr = m_out.zeroExtPtr(length);
 8790         LValue loopBoundValue = m_out.constIntPtr(data-&gt;mandatoryMinimum);
 8791         ValueFromBlock loopBound = m_out.anchor(loopBoundValue);
 8792         m_out.branch(
 8793             m_out.above(loopBoundValue, lengthAsPtr), unsure(undefinedLoop), unsure(mainLoopEntry));
 8794 
 8795         LBasicBlock lastNext = m_out.appendTo(undefinedLoop, mainLoopEntry);
 8796         LValue previousIndex = m_out.phi(pointerType(), loopBound);
 8797         LValue currentIndex = m_out.sub(previousIndex, m_out.intPtrOne);
 8798         m_out.store64(
 8799             m_out.constInt64(JSValue::encode(jsUndefined())),
 8800             m_out.baseIndex(m_heaps.variables, targetStart, currentIndex));
 8801         ValueFromBlock nextIndex = m_out.anchor(currentIndex);
 8802         m_out.addIncomingToPhi(previousIndex, nextIndex);
 8803         m_out.branch(
 8804             m_out.above(currentIndex, lengthAsPtr), unsure(undefinedLoop), unsure(mainLoopEntry));
 8805 
 8806         m_out.appendTo(mainLoopEntry, mainLoop);
 8807         loopBound = m_out.anchor(lengthAsPtr);
 8808         m_out.branch(m_out.notNull(lengthAsPtr), unsure(mainLoop), unsure(continuation));
 8809 
 8810         m_out.appendTo(mainLoop, continuation);
 8811         previousIndex = m_out.phi(pointerType(), loopBound);
 8812         currentIndex = m_out.sub(previousIndex, m_out.intPtrOne);
 8813         LValue value = m_out.load64(
 8814             m_out.baseIndex(m_heaps.variables, sourceStart, currentIndex));
 8815         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, currentIndex));
 8816         nextIndex = m_out.anchor(currentIndex);
 8817         m_out.addIncomingToPhi(previousIndex, nextIndex);
 8818         m_out.branch(m_out.isNull(currentIndex), unsure(continuation), unsure(mainLoop));
 8819 
 8820         m_out.appendTo(continuation, lastNext);
 8821     }
 8822 
 8823     LValue getSpreadLengthFromInlineCallFrame(InlineCallFrame* inlineCallFrame, unsigned numberOfArgumentsToSkip)
 8824     {
 8825         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
 8826         if (argumentsLength.isKnown) {
 8827             unsigned knownLength = argumentsLength.known;
 8828             if (knownLength &gt;= numberOfArgumentsToSkip)
 8829                 knownLength = knownLength - numberOfArgumentsToSkip;
 8830             else
 8831                 knownLength = 0;
 8832             return m_out.constInt32(knownLength);
 8833         }
 8834 
 8835 
 8836         // We need to perform the same logical operation as the code above, but through dynamic operations.
 8837         if (!numberOfArgumentsToSkip)
 8838             return argumentsLength.value;
 8839 
 8840         LBasicBlock isLarger = m_out.newBlock();
 8841         LBasicBlock continuation = m_out.newBlock();
 8842 
 8843         ValueFromBlock smallerOrEqualLengthResult = m_out.anchor(m_out.constInt32(0));
 8844         m_out.branch(
 8845             m_out.above(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip)), unsure(isLarger), unsure(continuation));
 8846         LBasicBlock lastNext = m_out.appendTo(isLarger, continuation);
 8847         ValueFromBlock largerLengthResult = m_out.anchor(m_out.sub(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip)));
 8848         m_out.jump(continuation);
 8849 
 8850         m_out.appendTo(continuation, lastNext);
 8851         return m_out.phi(Int32, smallerOrEqualLengthResult, largerLengthResult);
 8852     }
 8853 
 8854     void compileForwardVarargsWithSpread()
 8855     {
 8856         HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 8857 
 8858         Node* arguments = m_node-&gt;child1().node();
 8859         RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread);
 8860 
 8861         unsigned numberOfStaticArguments = 0;
 8862         Vector&lt;LValue, 2&gt; spreadLengths;
 8863 
 8864         auto collectArgumentCount = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 8865             if (target-&gt;op() == PhantomSpread) {
 8866                 self(target-&gt;child1().node());
 8867                 return;
 8868             }
 8869 
 8870             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8871                 BitVector* bitVector = target-&gt;bitVector();
 8872                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {
 8873                     if (bitVector-&gt;get(i))
 8874                         self(m_graph.varArgChild(target, i).node());
 8875                     else
 8876                         ++numberOfStaticArguments;
 8877                 }
 8878                 return;
 8879             }
 8880 
 8881             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8882                 numberOfStaticArguments += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 8883                 return;
 8884             }
 8885 
 8886             ASSERT(target-&gt;op() == PhantomCreateRest);
<a name="83" id="anc83"></a><span class="line-modified"> 8887             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8888             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8889             spreadLengths.append(cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 8890                 return this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 8891             }).iterator-&gt;value);
 8892         });
 8893 
 8894         collectArgumentCount(arguments);
 8895         LValue lengthIncludingThis = m_out.constInt32(1 + numberOfStaticArguments);
 8896         for (LValue length : spreadLengths)
 8897             lengthIncludingThis = m_out.add(lengthIncludingThis, length);
 8898 
 8899         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8900         speculate(
 8901             VarargsOverflow, noValue(), nullptr,
 8902             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 8903 
 8904         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 8905 
 8906         LValue targetStart = addressFor(data-&gt;machineStart).value();
 8907 
 8908         auto forwardSpread = recursableLambda([this, &amp;cachedSpreadLengths, &amp;targetStart](auto self, Node* target, LValue storeIndex) -&gt; LValue {
 8909             if (target-&gt;op() == PhantomSpread)
 8910                 return self(target-&gt;child1().node(), storeIndex);
 8911 
 8912             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8913                 BitVector* bitVector = target-&gt;bitVector();
 8914                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {
 8915                     if (bitVector-&gt;get(i))
 8916                         storeIndex = self(m_graph.varArgChild(target, i).node(), storeIndex);
 8917                     else {
 8918                         LValue value = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 8919                         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, storeIndex));
 8920                         storeIndex = m_out.add(m_out.constIntPtr(1), storeIndex);
 8921                     }
 8922                 }
 8923                 return storeIndex;
 8924             }
 8925 
 8926             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8927                 auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 8928                 for (unsigned i = 0; i &lt; array-&gt;length(); i++) {
 8929                     // Because forwarded values are drained as JSValue, we should not generate value
 8930                     // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 8931                     int64_t value = JSValue::encode(array-&gt;get(i));
 8932                     m_out.store64(m_out.constInt64(value), m_out.baseIndex(m_heaps.variables, targetStart, storeIndex, JSValue(), (Checked&lt;int32_t&gt;(sizeof(Register)) * i).unsafeGet()));
 8933                 }
 8934                 return m_out.add(m_out.constIntPtr(array-&gt;length()), storeIndex);
 8935             }
 8936 
 8937             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<a name="84" id="anc84"></a><span class="line-modified"> 8938             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
 8939 
 8940             LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, target-&gt;numberOfArgumentsToSkip());
 8941             LValue spreadLength = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 8942 
 8943             LBasicBlock loop = m_out.newBlock();
 8944             LBasicBlock continuation = m_out.newBlock();
 8945             ValueFromBlock startLoadIndex = m_out.anchor(m_out.constIntPtr(0));
 8946             ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 8947             ValueFromBlock startStoreIndexForEnd = m_out.anchor(storeIndex);
 8948 
 8949             m_out.branch(m_out.isZero64(spreadLength), unsure(continuation), unsure(loop));
 8950 
 8951             LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 8952             LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 8953             LValue loadIndex = m_out.phi(Int64, startLoadIndex);
 8954             LValue value = m_out.load64(
 8955                 m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 8956             m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 8957             LValue nextLoadIndex = m_out.add(m_out.constIntPtr(1), loadIndex);
 8958             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
 8959             LValue nextStoreIndex = m_out.add(m_out.constIntPtr(1), loopStoreIndex);
 8960             m_out.addIncomingToPhi(loopStoreIndex, m_out.anchor(nextStoreIndex));
 8961             ValueFromBlock loopStoreIndexForEnd = m_out.anchor(nextStoreIndex);
 8962             m_out.branch(m_out.below(nextLoadIndex, spreadLength), unsure(loop), unsure(continuation));
 8963 
 8964             m_out.appendTo(continuation, lastNext);
 8965             return m_out.phi(Int64, startStoreIndexForEnd, loopStoreIndexForEnd);
 8966         });
 8967 
 8968         LValue storeIndex = forwardSpread(arguments, m_out.constIntPtr(0));
 8969 
 8970         LBasicBlock undefinedLoop = m_out.newBlock();
 8971         LBasicBlock continuation = m_out.newBlock();
 8972 
 8973         ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 8974         LValue loopBoundValue = m_out.constIntPtr(data-&gt;mandatoryMinimum);
 8975         m_out.branch(m_out.below(storeIndex, loopBoundValue),
 8976             unsure(undefinedLoop), unsure(continuation));
 8977 
 8978         LBasicBlock lastNext = m_out.appendTo(undefinedLoop, continuation);
 8979         LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 8980         m_out.store64(
 8981             m_out.constInt64(JSValue::encode(jsUndefined())),
 8982             m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 8983         LValue nextIndex = m_out.add(loopStoreIndex, m_out.constIntPtr(1));
 8984         m_out.addIncomingToPhi(loopStoreIndex, m_out.anchor(nextIndex));
 8985         m_out.branch(
 8986             m_out.below(nextIndex, loopBoundValue), unsure(undefinedLoop), unsure(continuation));
 8987 
 8988         m_out.appendTo(continuation, lastNext);
 8989     }
 8990 
 8991     void compileJump()
 8992     {
 8993         m_out.jump(lowBlock(m_node-&gt;targetBlock()));
 8994     }
 8995 
 8996     void compileBranch()
 8997     {
 8998         m_out.branch(
 8999             boolify(m_node-&gt;child1()),
 9000             WeightedTarget(
 9001                 lowBlock(m_node-&gt;branchData()-&gt;taken.block),
 9002                 m_node-&gt;branchData()-&gt;taken.count),
 9003             WeightedTarget(
 9004                 lowBlock(m_node-&gt;branchData()-&gt;notTaken.block),
 9005                 m_node-&gt;branchData()-&gt;notTaken.count));
 9006     }
 9007 
 9008     void compileSwitch()
 9009     {
 9010         SwitchData* data = m_node-&gt;switchData();
 9011         switch (data-&gt;kind) {
 9012         case SwitchImm: {
 9013             Vector&lt;ValueFromBlock, 2&gt; intValues;
 9014             LBasicBlock switchOnInts = m_out.newBlock();
 9015 
 9016             LBasicBlock lastNext = m_out.appendTo(m_out.m_block, switchOnInts);
 9017 
 9018             switch (m_node-&gt;child1().useKind()) {
 9019             case Int32Use: {
 9020                 intValues.append(m_out.anchor(lowInt32(m_node-&gt;child1())));
 9021                 m_out.jump(switchOnInts);
 9022                 break;
 9023             }
 9024 
 9025             case UntypedUse: {
 9026                 LBasicBlock isInt = m_out.newBlock();
 9027                 LBasicBlock isNotInt = m_out.newBlock();
 9028                 LBasicBlock isDouble = m_out.newBlock();
 9029 
 9030                 LValue boxedValue = lowJSValue(m_node-&gt;child1());
 9031                 m_out.branch(isNotInt32(boxedValue), unsure(isNotInt), unsure(isInt));
 9032 
 9033                 LBasicBlock innerLastNext = m_out.appendTo(isInt, isNotInt);
 9034 
 9035                 intValues.append(m_out.anchor(unboxInt32(boxedValue)));
 9036                 m_out.jump(switchOnInts);
 9037 
 9038                 m_out.appendTo(isNotInt, isDouble);
 9039                 m_out.branch(
 9040                     isCellOrMisc(boxedValue, provenType(m_node-&gt;child1())),
 9041                     usually(lowBlock(data-&gt;fallThrough.block)), rarely(isDouble));
 9042 
 9043                 m_out.appendTo(isDouble, innerLastNext);
 9044                 LValue doubleValue = unboxDouble(boxedValue);
 9045                 LValue intInDouble = m_out.doubleToInt(doubleValue);
 9046                 intValues.append(m_out.anchor(intInDouble));
 9047                 m_out.branch(
 9048                     m_out.doubleEqual(m_out.intToDouble(intInDouble), doubleValue),
 9049                     unsure(switchOnInts), unsure(lowBlock(data-&gt;fallThrough.block)));
 9050                 break;
 9051             }
 9052 
 9053             default:
 9054                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9055                 break;
 9056             }
 9057 
 9058             m_out.appendTo(switchOnInts, lastNext);
 9059             buildSwitch(data, Int32, m_out.phi(Int32, intValues));
 9060             return;
 9061         }
 9062 
 9063         case SwitchChar: {
 9064             LValue stringValue;
 9065 
 9066             // FIXME: We should use something other than unsure() for the branch weight
 9067             // of the fallThrough block. The main challenge is just that we have multiple
 9068             // branches to fallThrough but a single count, so we would need to divvy it up
 9069             // among the different lowered branches.
 9070             // https://bugs.webkit.org/show_bug.cgi?id=129082
 9071 
 9072             switch (m_node-&gt;child1().useKind()) {
 9073             case StringUse: {
 9074                 stringValue = lowString(m_node-&gt;child1());
 9075                 break;
 9076             }
 9077 
 9078             case UntypedUse: {
 9079                 LValue unboxedValue = lowJSValue(m_node-&gt;child1());
 9080 
 9081                 LBasicBlock isCellCase = m_out.newBlock();
 9082                 LBasicBlock isStringCase = m_out.newBlock();
 9083 
 9084                 m_out.branch(
 9085                     isNotCell(unboxedValue, provenType(m_node-&gt;child1())),
 9086                     unsure(lowBlock(data-&gt;fallThrough.block)), unsure(isCellCase));
 9087 
 9088                 LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
 9089                 LValue cellValue = unboxedValue;
 9090                 m_out.branch(
 9091                     isNotString(cellValue, provenType(m_node-&gt;child1())),
 9092                     unsure(lowBlock(data-&gt;fallThrough.block)), unsure(isStringCase));
 9093 
 9094                 m_out.appendTo(isStringCase, lastNext);
 9095                 stringValue = cellValue;
 9096                 break;
 9097             }
 9098 
 9099             default:
 9100                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9101                 break;
 9102             }
 9103 
 9104             LBasicBlock lengthIs1 = m_out.newBlock();
 9105             LBasicBlock needResolution = m_out.newBlock();
 9106             LBasicBlock resolved = m_out.newBlock();
 9107             LBasicBlock is8Bit = m_out.newBlock();
 9108             LBasicBlock is16Bit = m_out.newBlock();
 9109             LBasicBlock continuation = m_out.newBlock();
 9110 
 9111             ValueFromBlock fastValue = m_out.anchor(m_out.loadPtr(stringValue, m_heaps.JSString_value));
 9112             m_out.branch(
 9113                 isRopeString(stringValue, m_node-&gt;child1()),
 9114                 rarely(needResolution), usually(resolved));
 9115 
 9116             LBasicBlock lastNext = m_out.appendTo(needResolution, resolved);
 9117             ValueFromBlock slowValue = m_out.anchor(
 9118                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, stringValue));
 9119             m_out.jump(resolved);
 9120 
 9121             m_out.appendTo(resolved, lengthIs1);
 9122             LValue value = m_out.phi(pointerType(), fastValue, slowValue);
 9123             m_out.branch(
 9124                 m_out.notEqual(
 9125                     m_out.load32NonNegative(value, m_heaps.StringImpl_length),
 9126                     m_out.int32One),
 9127                 unsure(lowBlock(data-&gt;fallThrough.block)), unsure(lengthIs1));
 9128 
 9129             m_out.appendTo(lengthIs1, is8Bit);
 9130             LValue characterData = m_out.loadPtr(value, m_heaps.StringImpl_data);
 9131             m_out.branch(
 9132                 m_out.testNonZero32(
 9133                     m_out.load32(value, m_heaps.StringImpl_hashAndFlags),
 9134                     m_out.constInt32(StringImpl::flagIs8Bit())),
 9135                 unsure(is8Bit), unsure(is16Bit));
 9136 
 9137             Vector&lt;ValueFromBlock, 2&gt; characters;
 9138             m_out.appendTo(is8Bit, is16Bit);
 9139             characters.append(m_out.anchor(m_out.load8ZeroExt32(characterData, m_heaps.characters8[0])));
 9140             m_out.jump(continuation);
 9141 
 9142             m_out.appendTo(is16Bit, continuation);
 9143             characters.append(m_out.anchor(m_out.load16ZeroExt32(characterData, m_heaps.characters16[0])));
 9144             m_out.jump(continuation);
 9145 
 9146             m_out.appendTo(continuation, lastNext);
 9147             buildSwitch(data, Int32, m_out.phi(Int32, characters));
 9148             return;
 9149         }
 9150 
 9151         case SwitchString: {
 9152             switch (m_node-&gt;child1().useKind()) {
 9153             case StringIdentUse: {
 9154                 LValue stringImpl = lowStringIdent(m_node-&gt;child1());
 9155 
 9156                 Vector&lt;SwitchCase&gt; cases;
 9157                 for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
 9158                     LValue value = m_out.constIntPtr(data-&gt;cases[i].value.stringImpl());
 9159                     LBasicBlock block = lowBlock(data-&gt;cases[i].target.block);
 9160                     Weight weight = Weight(data-&gt;cases[i].target.count);
 9161                     cases.append(SwitchCase(value, block, weight));
 9162                 }
 9163 
 9164                 m_out.switchInstruction(
 9165                     stringImpl, cases, lowBlock(data-&gt;fallThrough.block),
 9166                     Weight(data-&gt;fallThrough.count));
 9167                 return;
 9168             }
 9169 
 9170             case StringUse: {
 9171                 switchString(data, lowString(m_node-&gt;child1()), m_node-&gt;child1());
 9172                 return;
 9173             }
 9174 
 9175             case UntypedUse: {
 9176                 LValue value = lowJSValue(m_node-&gt;child1());
 9177 
 9178                 LBasicBlock isCellBlock = m_out.newBlock();
 9179                 LBasicBlock isStringBlock = m_out.newBlock();
 9180 
 9181                 m_out.branch(
 9182                     isCell(value, provenType(m_node-&gt;child1())),
 9183                     unsure(isCellBlock), unsure(lowBlock(data-&gt;fallThrough.block)));
 9184 
 9185                 LBasicBlock lastNext = m_out.appendTo(isCellBlock, isStringBlock);
 9186 
 9187                 m_out.branch(
 9188                     isString(value, provenType(m_node-&gt;child1())),
 9189                     unsure(isStringBlock), unsure(lowBlock(data-&gt;fallThrough.block)));
 9190 
 9191                 m_out.appendTo(isStringBlock, lastNext);
 9192 
 9193                 switchString(data, value, m_node-&gt;child1());
 9194                 return;
 9195             }
 9196 
 9197             default:
 9198                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9199                 return;
 9200             }
 9201             return;
 9202         }
 9203 
 9204         case SwitchCell: {
 9205             LValue cell;
 9206             switch (m_node-&gt;child1().useKind()) {
 9207             case CellUse: {
 9208                 cell = lowCell(m_node-&gt;child1());
 9209                 break;
 9210             }
 9211 
 9212             case UntypedUse: {
 9213                 LValue value = lowJSValue(m_node-&gt;child1());
 9214                 LBasicBlock cellCase = m_out.newBlock();
 9215                 m_out.branch(
 9216                     isCell(value, provenType(m_node-&gt;child1())),
 9217                     unsure(cellCase), unsure(lowBlock(data-&gt;fallThrough.block)));
 9218                 m_out.appendTo(cellCase);
 9219                 cell = value;
 9220                 break;
 9221             }
 9222 
 9223             default:
 9224                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9225                 return;
 9226             }
 9227 
 9228             buildSwitch(m_node-&gt;switchData(), pointerType(), cell);
 9229             return;
 9230         } }
 9231 
 9232         DFG_CRASH(m_graph, m_node, &quot;Bad switch kind&quot;);
 9233     }
 9234 
 9235     void compileEntrySwitch()
 9236     {
 9237         Vector&lt;LBasicBlock&gt; successors;
 9238         for (DFG::BasicBlock* successor : m_node-&gt;entrySwitchData()-&gt;cases)
 9239             successors.append(lowBlock(successor));
 9240         m_out.entrySwitch(successors);
 9241     }
 9242 
 9243     void compileReturn()
 9244     {
 9245         m_out.ret(lowJSValue(m_node-&gt;child1()));
 9246     }
 9247 
 9248     void compileForceOSRExit()
 9249     {
 9250         terminate(InadequateCoverage);
 9251     }
 9252 
 9253     void compileCPUIntrinsic()
 9254     {
 9255 #if CPU(X86_64)
 9256         Intrinsic intrinsic = m_node-&gt;intrinsic();
 9257         switch (intrinsic) {
 9258         case CPUMfenceIntrinsic:
 9259         case CPUCpuidIntrinsic:
 9260         case CPUPauseIntrinsic: {
 9261             PatchpointValue* patchpoint = m_out.patchpoint(Void);
 9262             patchpoint-&gt;effects = Effects::forCall();
 9263             if (intrinsic == CPUCpuidIntrinsic)
 9264                 patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::ebx, X86Registers::ecx, X86Registers::edx });
 9265 
 9266             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 9267                 switch (intrinsic) {
 9268                 case CPUMfenceIntrinsic:
 9269                     jit.mfence();
 9270                     break;
 9271                 case CPUCpuidIntrinsic:
 9272                     jit.cpuid();
 9273                     break;
 9274                 case CPUPauseIntrinsic:
 9275                     jit.pause();
 9276                     break;
 9277                 default:
 9278                     RELEASE_ASSERT_NOT_REACHED();
 9279                 }
 9280             });
 9281             setJSValue(m_out.constInt64(JSValue::encode(jsUndefined())));
 9282             break;
 9283         }
 9284         case CPURdtscIntrinsic: {
 9285             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 9286             patchpoint-&gt;effects = Effects::forCall();
 9287             patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::edx });
 9288             // The low 32-bits of rdtsc go into rax.
<a name="85" id="anc85"></a><span class="line-modified"> 9289             patchpoint-&gt;resultConstraint = ValueRep::reg(X86Registers::eax);</span>
 9290             patchpoint-&gt;setGenerator( [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 9291                 jit.rdtsc();
 9292             });
 9293             setJSValue(boxInt32(patchpoint));
 9294             break;
 9295         }
 9296         default:
 9297             RELEASE_ASSERT_NOT_REACHED();
 9298 
 9299         }
 9300 #endif
 9301     }
 9302 
 9303     void compileThrow()
 9304     {
 9305         LValue error = lowJSValue(m_node-&gt;child1());
 9306         vmCall(Void, m_out.operation(operationThrowDFG), m_callFrame, error);
 9307         // vmCall() does an exception check so we should never reach this.
 9308         m_out.unreachable();
 9309     }
 9310 
 9311     void compileThrowStaticError()
 9312     {
 9313         LValue errorMessage = lowString(m_node-&gt;child1());
 9314         LValue errorType = m_out.constInt32(m_node-&gt;errorType());
 9315         vmCall(Void, m_out.operation(operationThrowStaticError), m_callFrame, errorMessage, errorType);
 9316         // vmCall() does an exception check so we should never reach this.
 9317         m_out.unreachable();
 9318     }
 9319 
 9320     void compileInvalidationPoint()
 9321     {
 9322         if (verboseCompilationEnabled())
 9323             dataLog(&quot;    Invalidation point with availability: &quot;, availabilityMap(), &quot;\n&quot;);
 9324 
 9325         DFG_ASSERT(m_graph, m_node, m_origin.exitOK);
 9326 
 9327         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 9328         OSRExitDescriptor* descriptor = appendOSRExitDescriptor(noValue(), nullptr);
 9329         NodeOrigin origin = m_origin;
 9330         patchpoint-&gt;appendColdAnys(buildExitArguments(descriptor, origin.forExit, noValue()));
 9331 
 9332         State* state = &amp;m_ftlState;
 9333 
 9334         patchpoint-&gt;setGenerator(
 9335             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
 9336                 // The MacroAssembler knows more about this than B3 does. The watchpointLabel() method
 9337                 // will ensure that this is followed by a nop shadow but only when this is actually
 9338                 // necessary.
 9339                 CCallHelpers::Label label = jit.watchpointLabel();
 9340 
 9341                 RefPtr&lt;OSRExitHandle&gt; handle = descriptor-&gt;emitOSRExitLater(
 9342                     *state, UncountableInvalidation, origin, params);
 9343 
 9344                 RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode.get();
 9345 
 9346                 jit.addLinkTask(
 9347                     [=] (LinkBuffer&amp; linkBuffer) {
 9348                         JumpReplacement jumpReplacement(
 9349                             linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(label),
 9350                             linkBuffer.locationOf&lt;OSRExitPtrTag&gt;(handle-&gt;label));
 9351                         jitCode-&gt;common.jumpReplacements.append(jumpReplacement);
 9352                     });
 9353             });
 9354 
 9355         // Set some obvious things.
 9356         patchpoint-&gt;effects.terminal = false;
 9357         patchpoint-&gt;effects.writesLocalState = false;
 9358         patchpoint-&gt;effects.readsLocalState = false;
 9359 
 9360         // This is how we tell B3 about the possibility of jump replacement.
 9361         patchpoint-&gt;effects.exitsSideways = true;
 9362 
 9363         // It&#39;s not possible for some prior branch to determine the safety of this operation. It&#39;s always
 9364         // fine to execute this on some path that wouldn&#39;t have originally executed it before
 9365         // optimization.
 9366         patchpoint-&gt;effects.controlDependent = false;
 9367 
 9368         // If this falls through then it won&#39;t write anything.
 9369         patchpoint-&gt;effects.writes = HeapRange();
 9370 
 9371         // When this abruptly terminates, it could read any heap location.
 9372         patchpoint-&gt;effects.reads = HeapRange::top();
 9373     }
 9374 
 9375     void compileIsEmpty()
 9376     {
 9377         setBoolean(m_out.isZero64(lowJSValue(m_node-&gt;child1())));
 9378     }
 9379 
 9380     void compileIsUndefined()
 9381     {
 9382         setBoolean(equalNullOrUndefined(m_node-&gt;child1(), AllCellsAreFalse, EqualUndefined));
 9383     }
 9384 
 9385     void compileIsUndefinedOrNull()
 9386     {
 9387         setBoolean(isOther(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
 9388     }
 9389 
 9390     void compileIsBoolean()
 9391     {
 9392         setBoolean(isBoolean(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
 9393     }
 9394 
 9395     void compileIsNumber()
 9396     {
 9397         setBoolean(isNumber(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
 9398     }
 9399 
 9400     void compileNumberIsInteger()
 9401     {
 9402         LBasicBlock notInt32 = m_out.newBlock();
 9403         LBasicBlock doubleCase = m_out.newBlock();
 9404         LBasicBlock doubleNotNanOrInf = m_out.newBlock();
 9405         LBasicBlock continuation = m_out.newBlock();
 9406 
 9407         LValue input = lowJSValue(m_node-&gt;child1());
 9408 
 9409         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
 9410         m_out.branch(
 9411             isInt32(input, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notInt32));
 9412 
 9413         LBasicBlock lastNext = m_out.appendTo(notInt32, doubleCase);
 9414         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
 9415         m_out.branch(
 9416             isNotNumber(input, provenType(m_node-&gt;child1())), unsure(continuation), unsure(doubleCase));
 9417 
 9418         m_out.appendTo(doubleCase, doubleNotNanOrInf);
 9419         LValue doubleAsInt;
 9420         LValue asDouble = unboxDouble(input, &amp;doubleAsInt);
 9421         LValue expBits = m_out.bitAnd(m_out.lShr(doubleAsInt, m_out.constInt32(52)), m_out.constInt64(0x7ff));
 9422         m_out.branch(
 9423             m_out.equal(expBits, m_out.constInt64(0x7ff)),
 9424             unsure(continuation), unsure(doubleNotNanOrInf));
 9425 
 9426         m_out.appendTo(doubleNotNanOrInf, continuation);
 9427         PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 9428         patchpoint-&gt;appendSomeRegister(asDouble);
 9429         patchpoint-&gt;numFPScratchRegisters = 1;
 9430         patchpoint-&gt;effects = Effects::none();
 9431         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9432             GPRReg result = params[0].gpr();
 9433             FPRReg input = params[1].fpr();
 9434             FPRReg temp = params.fpScratch(0);
 9435             jit.roundTowardZeroDouble(input, temp);
 9436             jit.compareDouble(MacroAssembler::DoubleEqual, input, temp, result);
 9437         });
 9438         ValueFromBlock patchpointResult = m_out.anchor(patchpoint);
 9439         m_out.jump(continuation);
 9440 
 9441         m_out.appendTo(continuation, lastNext);
 9442         setBoolean(m_out.phi(Int32, trueResult, falseResult, patchpointResult));
 9443     }
 9444 
 9445     void compileIsCellWithType()
 9446     {
 9447         if (m_node-&gt;child1().useKind() == UntypedUse) {
 9448             LValue value = lowJSValue(m_node-&gt;child1());
 9449 
 9450             LBasicBlock isCellCase = m_out.newBlock();
 9451             LBasicBlock continuation = m_out.newBlock();
 9452 
 9453             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
 9454             m_out.branch(
 9455                 isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
 9456 
 9457             LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
 9458             ValueFromBlock cellResult = m_out.anchor(isCellWithType(value, m_node-&gt;queriedType(), m_node-&gt;speculatedTypeForQuery(), provenType(m_node-&gt;child1())));
 9459             m_out.jump(continuation);
 9460 
 9461             m_out.appendTo(continuation, lastNext);
 9462             setBoolean(m_out.phi(Int32, notCellResult, cellResult));
 9463         } else {
 9464             ASSERT(m_node-&gt;child1().useKind() == CellUse);
 9465             setBoolean(isCellWithType(lowCell(m_node-&gt;child1()), m_node-&gt;queriedType(), m_node-&gt;speculatedTypeForQuery(), provenType(m_node-&gt;child1())));
 9466         }
 9467     }
 9468 
 9469     void compileIsObject()
 9470     {
 9471         LValue value = lowJSValue(m_node-&gt;child1());
 9472 
 9473         LBasicBlock isCellCase = m_out.newBlock();
 9474         LBasicBlock continuation = m_out.newBlock();
 9475 
 9476         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
 9477         m_out.branch(
 9478             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
 9479 
 9480         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
 9481         ValueFromBlock cellResult = m_out.anchor(isObject(value, provenType(m_node-&gt;child1())));
 9482         m_out.jump(continuation);
 9483 
 9484         m_out.appendTo(continuation, lastNext);
 9485         setBoolean(m_out.phi(Int32, notCellResult, cellResult));
 9486     }
 9487 
 9488     LValue wangsInt64Hash(LValue input)
 9489     {
 9490         // key += ~(key &lt;&lt; 32);
 9491         LValue key = input;
 9492         LValue temp = key;
 9493         temp = m_out.shl(temp, m_out.constInt32(32));
 9494         temp = m_out.bitNot(temp);
 9495         key = m_out.add(key, temp);
 9496         // key ^= (key &gt;&gt; 22);
 9497         temp = key;
 9498         temp = m_out.lShr(temp, m_out.constInt32(22));
 9499         key = m_out.bitXor(key, temp);
 9500         // key += ~(key &lt;&lt; 13);
 9501         temp = key;
 9502         temp = m_out.shl(temp, m_out.constInt32(13));
 9503         temp = m_out.bitNot(temp);
 9504         key = m_out.add(key, temp);
 9505         // key ^= (key &gt;&gt; 8);
 9506         temp = key;
 9507         temp = m_out.lShr(temp, m_out.constInt32(8));
 9508         key = m_out.bitXor(key, temp);
 9509         // key += (key &lt;&lt; 3);
 9510         temp = key;
 9511         temp = m_out.shl(temp, m_out.constInt32(3));
 9512         key = m_out.add(key, temp);
 9513         // key ^= (key &gt;&gt; 15);
 9514         temp = key;
 9515         temp = m_out.lShr(temp, m_out.constInt32(15));
 9516         key = m_out.bitXor(key, temp);
 9517         // key += ~(key &lt;&lt; 27);
 9518         temp = key;
 9519         temp = m_out.shl(temp, m_out.constInt32(27));
 9520         temp = m_out.bitNot(temp);
 9521         key = m_out.add(key, temp);
 9522         // key ^= (key &gt;&gt; 31);
 9523         temp = key;
 9524         temp = m_out.lShr(temp, m_out.constInt32(31));
 9525         key = m_out.bitXor(key, temp);
 9526         key = m_out.castToInt32(key);
 9527 
 9528         return key;
 9529     }
 9530 
 9531     LValue mapHashString(LValue string, Edge&amp; edge)
 9532     {
 9533         LBasicBlock nonEmptyStringCase = m_out.newBlock();
 9534         LBasicBlock slowCase = m_out.newBlock();
 9535         LBasicBlock continuation = m_out.newBlock();
 9536 
 9537         m_out.branch(isRopeString(string, edge), rarely(slowCase), usually(nonEmptyStringCase));
 9538 
 9539         LBasicBlock lastNext = m_out.appendTo(nonEmptyStringCase, slowCase);
 9540         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
 9541         LValue hash = m_out.lShr(m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
 9542         ValueFromBlock nonEmptyStringHashResult = m_out.anchor(hash);
 9543         m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
 9544             unsure(slowCase), unsure(continuation));
 9545 
 9546         m_out.appendTo(slowCase, continuation);
 9547         ValueFromBlock slowResult = m_out.anchor(
 9548             vmCall(Int32, m_out.operation(operationMapHash), m_callFrame, string));
 9549         m_out.jump(continuation);
 9550 
 9551         m_out.appendTo(continuation, lastNext);
 9552         return m_out.phi(Int32, slowResult, nonEmptyStringHashResult);
 9553     }
 9554 
 9555     void compileMapHash()
 9556     {
 9557         switch (m_node-&gt;child1().useKind()) {
 9558         case BooleanUse:
 9559         case Int32Use:
 9560         case SymbolUse:
 9561         case ObjectUse: {
 9562             LValue key = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 9563             speculate(m_node-&gt;child1());
 9564             setInt32(wangsInt64Hash(key));
 9565             return;
 9566         }
 9567 
 9568         case CellUse: {
 9569             LBasicBlock isString = m_out.newBlock();
 9570             LBasicBlock notString = m_out.newBlock();
 9571             LBasicBlock continuation = m_out.newBlock();
 9572 
 9573             LValue value = lowCell(m_node-&gt;child1());
 9574             LValue isStringValue = m_out.equal(m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoType), m_out.constInt32(StringType));
 9575             m_out.branch(
 9576                 isStringValue, unsure(isString), unsure(notString));
 9577 
 9578             LBasicBlock lastNext = m_out.appendTo(isString, notString);
 9579             ValueFromBlock stringResult = m_out.anchor(mapHashString(value, m_node-&gt;child1()));
 9580             m_out.jump(continuation);
 9581 
 9582             m_out.appendTo(notString, continuation);
 9583             ValueFromBlock notStringResult = m_out.anchor(wangsInt64Hash(value));
 9584             m_out.jump(continuation);
 9585 
 9586             m_out.appendTo(continuation, lastNext);
 9587             setInt32(m_out.phi(Int32, stringResult, notStringResult));
 9588             return;
 9589         }
 9590 
 9591         case StringUse: {
 9592             LValue string = lowString(m_node-&gt;child1());
 9593             setInt32(mapHashString(string, m_node-&gt;child1()));
 9594             return;
 9595         }
 9596 
 9597         default:
 9598             RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
 9599             break;
 9600         }
 9601 
 9602         LValue value = lowJSValue(m_node-&gt;child1());
 9603 
 9604         LBasicBlock isCellCase = m_out.newBlock();
 9605         LBasicBlock slowCase = m_out.newBlock();
 9606         LBasicBlock straightHash = m_out.newBlock();
 9607         LBasicBlock isStringCase = m_out.newBlock();
 9608         LBasicBlock nonEmptyStringCase = m_out.newBlock();
 9609         LBasicBlock continuation = m_out.newBlock();
 9610 
 9611         m_out.branch(
 9612             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(straightHash));
 9613 
 9614         LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
 9615         LValue isString = m_out.equal(m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoType), m_out.constInt32(StringType));
 9616         m_out.branch(
 9617             isString, unsure(isStringCase), unsure(straightHash));
 9618 
 9619         m_out.appendTo(isStringCase, nonEmptyStringCase);
 9620         m_out.branch(isRopeString(value, m_node-&gt;child1()), rarely(slowCase), usually(nonEmptyStringCase));
 9621 
 9622         m_out.appendTo(nonEmptyStringCase, straightHash);
 9623         LValue stringImpl = m_out.loadPtr(value, m_heaps.JSString_value);
 9624         LValue hash = m_out.lShr(m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
 9625         ValueFromBlock nonEmptyStringHashResult = m_out.anchor(hash);
 9626         m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
 9627             unsure(slowCase), unsure(continuation));
 9628 
 9629         m_out.appendTo(straightHash, slowCase);
 9630         ValueFromBlock fastResult = m_out.anchor(wangsInt64Hash(value));
 9631         m_out.jump(continuation);
 9632 
 9633         m_out.appendTo(slowCase, continuation);
 9634         ValueFromBlock slowResult = m_out.anchor(
 9635             vmCall(Int32, m_out.operation(operationMapHash), m_callFrame, value));
 9636         m_out.jump(continuation);
 9637 
 9638         m_out.appendTo(continuation, lastNext);
 9639         setInt32(m_out.phi(Int32, fastResult, slowResult, nonEmptyStringHashResult));
 9640     }
 9641 
 9642     void compileNormalizeMapKey()
 9643     {
 9644         ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
 9645 
 9646         LBasicBlock isNumberCase = m_out.newBlock();
 9647         LBasicBlock notInt32NumberCase = m_out.newBlock();
 9648         LBasicBlock notNaNCase = m_out.newBlock();
 9649         LBasicBlock convertibleCase = m_out.newBlock();
 9650         LBasicBlock continuation = m_out.newBlock();
 9651 
 9652         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isNumberCase);
 9653 
 9654         LValue key = lowJSValue(m_node-&gt;child1());
 9655         ValueFromBlock fastResult = m_out.anchor(key);
 9656         m_out.branch(isNotNumber(key), unsure(continuation), unsure(isNumberCase));
 9657 
 9658         m_out.appendTo(isNumberCase, notInt32NumberCase);
 9659         m_out.branch(isInt32(key), unsure(continuation), unsure(notInt32NumberCase));
 9660 
 9661         m_out.appendTo(notInt32NumberCase, notNaNCase);
 9662         LValue doubleValue = unboxDouble(key);
<a name="86" id="anc86"></a>
 9663         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue), unsure(continuation), unsure(notNaNCase));
 9664 
 9665         m_out.appendTo(notNaNCase, convertibleCase);
 9666         LValue integerValue = m_out.doubleToInt(doubleValue);
 9667         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
<a name="87" id="anc87"></a>
 9668         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, integerValueConvertedToDouble), unsure(continuation), unsure(convertibleCase));
 9669 
 9670         m_out.appendTo(convertibleCase, continuation);
<a name="88" id="anc88"></a><span class="line-modified"> 9671         ValueFromBlock slowResult = m_out.anchor(boxInt32(integerValue));</span>
 9672         m_out.jump(continuation);
 9673 
 9674         m_out.appendTo(continuation, lastNext);
<a name="89" id="anc89"></a><span class="line-modified"> 9675         setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
 9676     }
 9677 
 9678     void compileGetMapBucket()
 9679     {
 9680         LBasicBlock loopStart = m_out.newBlock();
 9681         LBasicBlock loopAround = m_out.newBlock();
 9682         LBasicBlock slowPath = m_out.newBlock();
 9683         LBasicBlock notPresentInTable = m_out.newBlock();
 9684         LBasicBlock notEmptyValue = m_out.newBlock();
 9685         LBasicBlock notDeletedValue = m_out.newBlock();
 9686         LBasicBlock continuation = m_out.newBlock();
 9687 
 9688         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
 9689 
 9690         LValue map;
 9691         if (m_node-&gt;child1().useKind() == MapObjectUse)
 9692             map = lowMapObject(m_node-&gt;child1());
 9693         else if (m_node-&gt;child1().useKind() == SetObjectUse)
 9694             map = lowSetObject(m_node-&gt;child1());
 9695         else
 9696             RELEASE_ASSERT_NOT_REACHED();
 9697 
 9698         LValue key = lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation);
 9699         if (m_node-&gt;child2().useKind() != UntypedUse)
 9700             speculate(m_node-&gt;child2());
 9701 
 9702         LValue hash = lowInt32(m_node-&gt;child3());
 9703 
 9704         LValue buffer = m_out.loadPtr(map, m_heaps.HashMapImpl_buffer);
 9705         LValue mask = m_out.sub(m_out.load32(map, m_heaps.HashMapImpl_capacity), m_out.int32One);
 9706 
 9707         ValueFromBlock indexStart = m_out.anchor(hash);
 9708         m_out.jump(loopStart);
 9709 
 9710         m_out.appendTo(loopStart, notEmptyValue);
 9711         LValue unmaskedIndex = m_out.phi(Int32, indexStart);
 9712         LValue index = m_out.bitAnd(mask, unmaskedIndex);
 9713         // FIXME: I think these buffers are caged?
 9714         // https://bugs.webkit.org/show_bug.cgi?id=174925
 9715         LValue hashMapBucket = m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), buffer, m_out.zeroExt(index, Int64), ScaleEight));
 9716         ValueFromBlock bucketResult = m_out.anchor(hashMapBucket);
 9717         m_out.branch(m_out.equal(hashMapBucket, m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::emptyValue()))),
 9718             unsure(notPresentInTable), unsure(notEmptyValue));
 9719 
 9720         m_out.appendTo(notEmptyValue, notDeletedValue);
 9721         m_out.branch(m_out.equal(hashMapBucket, m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::deletedValue()))),
 9722             unsure(loopAround), unsure(notDeletedValue));
 9723 
 9724         m_out.appendTo(notDeletedValue, loopAround);
 9725         LValue bucketKey = m_out.load64(hashMapBucket, m_heaps.HashMapBucket_key);
 9726 
 9727         // Perform Object.is()
 9728         switch (m_node-&gt;child2().useKind()) {
 9729         case BooleanUse:
 9730         case Int32Use:
 9731         case SymbolUse:
 9732         case ObjectUse: {
 9733             m_out.branch(m_out.equal(key, bucketKey),
 9734                 unsure(continuation), unsure(loopAround));
 9735             break;
 9736         }
 9737         case StringUse: {
 9738             LBasicBlock notBitEqual = m_out.newBlock();
 9739             LBasicBlock bucketKeyIsCell = m_out.newBlock();
 9740 
 9741             m_out.branch(m_out.equal(key, bucketKey),
 9742                 unsure(continuation), unsure(notBitEqual));
 9743 
 9744             m_out.appendTo(notBitEqual, bucketKeyIsCell);
 9745             m_out.branch(isCell(bucketKey),
 9746                 unsure(bucketKeyIsCell), unsure(loopAround));
 9747 
 9748             m_out.appendTo(bucketKeyIsCell, loopAround);
 9749             m_out.branch(isString(bucketKey),
 9750                 unsure(slowPath), unsure(loopAround));
 9751             break;
 9752         }
 9753         case CellUse: {
 9754             LBasicBlock notBitEqual = m_out.newBlock();
 9755             LBasicBlock bucketKeyIsCell = m_out.newBlock();
 9756             LBasicBlock bucketKeyIsString = m_out.newBlock();
 9757 
 9758             m_out.branch(m_out.equal(key, bucketKey),
 9759                 unsure(continuation), unsure(notBitEqual));
 9760 
 9761             m_out.appendTo(notBitEqual, bucketKeyIsCell);
 9762             m_out.branch(isCell(bucketKey),
 9763                 unsure(bucketKeyIsCell), unsure(loopAround));
 9764 
 9765             m_out.appendTo(bucketKeyIsCell, bucketKeyIsString);
 9766             m_out.branch(isString(bucketKey),
 9767                 unsure(bucketKeyIsString), unsure(loopAround));
 9768 
 9769             m_out.appendTo(bucketKeyIsString, loopAround);
 9770             m_out.branch(isString(key),
 9771                 unsure(slowPath), unsure(loopAround));
 9772             break;
 9773         }
 9774         case UntypedUse: {
 9775             LBasicBlock notBitEqual = m_out.newBlock();
 9776             LBasicBlock bucketKeyIsCell = m_out.newBlock();
 9777             LBasicBlock bothAreCells = m_out.newBlock();
 9778             LBasicBlock bucketKeyIsString = m_out.newBlock();
 9779 
 9780             m_out.branch(m_out.equal(key, bucketKey),
 9781                 unsure(continuation), unsure(notBitEqual));
 9782 
 9783             m_out.appendTo(notBitEqual, bucketKeyIsCell);
 9784             m_out.branch(isCell(bucketKey),
 9785                 unsure(bucketKeyIsCell), unsure(loopAround));
 9786 
 9787             m_out.appendTo(bucketKeyIsCell, bothAreCells);
 9788             m_out.branch(isCell(key),
 9789                 unsure(bothAreCells), unsure(loopAround));
 9790 
 9791             m_out.appendTo(bothAreCells, bucketKeyIsString);
 9792             m_out.branch(isString(bucketKey),
 9793                 unsure(bucketKeyIsString), unsure(loopAround));
 9794 
 9795             m_out.appendTo(bucketKeyIsString, loopAround);
 9796             m_out.branch(isString(key),
 9797                 unsure(slowPath), unsure(loopAround));
 9798             break;
 9799         }
 9800         default:
 9801             RELEASE_ASSERT_NOT_REACHED();
 9802         }
 9803 
 9804         m_out.appendTo(loopAround, slowPath);
 9805         m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
 9806         m_out.jump(loopStart);
 9807 
 9808         m_out.appendTo(slowPath, notPresentInTable);
 9809         ValueFromBlock slowPathResult = m_out.anchor(vmCall(pointerType(),
 9810             m_out.operation(m_node-&gt;child1().useKind() == MapObjectUse ? operationJSMapFindBucket : operationJSSetFindBucket), m_callFrame, map, key, hash));
 9811         m_out.jump(continuation);
 9812 
 9813         m_out.appendTo(notPresentInTable, continuation);
 9814         ValueFromBlock notPresentResult;
 9815         if (m_node-&gt;child1().useKind() == MapObjectUse)
 9816             notPresentResult = m_out.anchor(weakPointer(vm().sentinelMapBucket()));
 9817         else if (m_node-&gt;child1().useKind() == SetObjectUse)
 9818             notPresentResult = m_out.anchor(weakPointer(vm().sentinelSetBucket()));
 9819         else
 9820             RELEASE_ASSERT_NOT_REACHED();
 9821         m_out.jump(continuation);
 9822 
 9823         m_out.appendTo(continuation, lastNext);
 9824         setJSValue(m_out.phi(pointerType(), bucketResult, slowPathResult, notPresentResult));
 9825     }
 9826 
 9827     void compileGetMapBucketHead()
 9828     {
 9829         LValue map;
 9830         if (m_node-&gt;child1().useKind() == MapObjectUse)
 9831             map = lowMapObject(m_node-&gt;child1());
 9832         else if (m_node-&gt;child1().useKind() == SetObjectUse)
 9833             map = lowSetObject(m_node-&gt;child1());
 9834         else
 9835             RELEASE_ASSERT_NOT_REACHED();
 9836 
 9837         ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
 9838         setJSValue(m_out.loadPtr(map, m_heaps.HashMapImpl_head));
 9839     }
 9840 
 9841     void compileGetMapBucketNext()
 9842     {
 9843         LBasicBlock loopStart = m_out.newBlock();
 9844         LBasicBlock continuation = m_out.newBlock();
 9845         LBasicBlock noBucket = m_out.newBlock();
 9846         LBasicBlock hasBucket = m_out.newBlock();
 9847         LBasicBlock nextBucket = m_out.newBlock();
 9848 
 9849         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
 9850 
 9851         ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
 9852         ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
 9853         LValue mapBucketPrev = lowCell(m_node-&gt;child1());
 9854         ValueFromBlock mapBucketStart = m_out.anchor(m_out.loadPtr(mapBucketPrev, m_heaps.HashMapBucket_next));
 9855         m_out.jump(loopStart);
 9856 
 9857         m_out.appendTo(loopStart, noBucket);
 9858         LValue mapBucket = m_out.phi(pointerType(), mapBucketStart);
 9859         m_out.branch(m_out.isNull(mapBucket), unsure(noBucket), unsure(hasBucket));
 9860 
 9861         m_out.appendTo(noBucket, hasBucket);
 9862         ValueFromBlock noBucketResult;
 9863         if (m_node-&gt;bucketOwnerType() == BucketOwnerType::Map)
 9864             noBucketResult = m_out.anchor(weakPointer(vm().sentinelMapBucket()));
 9865         else {
 9866             ASSERT(m_node-&gt;bucketOwnerType() == BucketOwnerType::Set);
 9867             noBucketResult = m_out.anchor(weakPointer(vm().sentinelSetBucket()));
 9868         }
 9869         m_out.jump(continuation);
 9870 
 9871         m_out.appendTo(hasBucket, nextBucket);
 9872         ValueFromBlock bucketResult = m_out.anchor(mapBucket);
 9873         m_out.branch(m_out.isZero64(m_out.load64(mapBucket, m_heaps.HashMapBucket_key)), unsure(nextBucket), unsure(continuation));
 9874 
 9875         m_out.appendTo(nextBucket, continuation);
 9876         m_out.addIncomingToPhi(mapBucket, m_out.anchor(m_out.loadPtr(mapBucket, m_heaps.HashMapBucket_next)));
 9877         m_out.jump(loopStart);
 9878 
 9879         m_out.appendTo(continuation, lastNext);
 9880         setJSValue(m_out.phi(pointerType(), noBucketResult, bucketResult));
 9881     }
 9882 
 9883     void compileLoadValueFromMapBucket()
 9884     {
 9885         LValue mapBucket = lowCell(m_node-&gt;child1());
 9886         setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_value));
 9887     }
 9888 
 9889     void compileExtractValueFromWeakMapGet()
 9890     {
 9891         LValue value = lowJSValue(m_node-&gt;child1());
 9892         setJSValue(m_out.select(m_out.isZero64(value),
 9893             m_out.constInt64(JSValue::encode(jsUndefined())),
 9894             value));
 9895     }
 9896 
 9897     void compileLoadKeyFromMapBucket()
 9898     {
 9899         LValue mapBucket = lowCell(m_node-&gt;child1());
 9900         setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_key));
 9901     }
 9902 
 9903     void compileSetAdd()
 9904     {
 9905         LValue set = lowSetObject(m_node-&gt;child1());
 9906         LValue key = lowJSValue(m_node-&gt;child2());
 9907         LValue hash = lowInt32(m_node-&gt;child3());
 9908 
 9909         setJSValue(vmCall(pointerType(), m_out.operation(operationSetAdd), m_callFrame, set, key, hash));
 9910     }
 9911 
 9912     void compileMapSet()
 9913     {
 9914         LValue map = lowMapObject(m_graph.varArgChild(m_node, 0));
 9915         LValue key = lowJSValue(m_graph.varArgChild(m_node, 1));
 9916         LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
 9917         LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
 9918 
 9919         setJSValue(vmCall(pointerType(), m_out.operation(operationMapSet), m_callFrame, map, key, value, hash));
 9920     }
 9921 
 9922     void compileWeakMapGet()
 9923     {
 9924         LBasicBlock loopStart = m_out.newBlock();
 9925         LBasicBlock loopAround = m_out.newBlock();
 9926         LBasicBlock notEqualValue = m_out.newBlock();
 9927         LBasicBlock continuation = m_out.newBlock();
 9928 
 9929         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
 9930 
 9931         LValue weakMap;
 9932         if (m_node-&gt;child1().useKind() == WeakMapObjectUse)
 9933             weakMap = lowWeakMapObject(m_node-&gt;child1());
 9934         else if (m_node-&gt;child1().useKind() == WeakSetObjectUse)
 9935             weakMap = lowWeakSetObject(m_node-&gt;child1());
 9936         else
 9937             RELEASE_ASSERT_NOT_REACHED();
 9938         LValue key = lowObject(m_node-&gt;child2());
 9939         LValue hash = lowInt32(m_node-&gt;child3());
 9940 
 9941         LValue buffer = m_out.loadPtr(weakMap, m_heaps.WeakMapImpl_buffer);
 9942         LValue mask = m_out.sub(m_out.load32(weakMap, m_heaps.WeakMapImpl_capacity), m_out.int32One);
 9943 
 9944         ValueFromBlock indexStart = m_out.anchor(hash);
 9945         m_out.jump(loopStart);
 9946 
 9947         m_out.appendTo(loopStart, notEqualValue);
 9948         LValue unmaskedIndex = m_out.phi(Int32, indexStart);
 9949         LValue index = m_out.bitAnd(mask, unmaskedIndex);
 9950 
 9951         LValue bucket;
 9952 
 9953         if (m_node-&gt;child1().useKind() == WeakMapObjectUse) {
 9954             static_assert(hasOneBitSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;)), &quot;Should be a power of 2&quot;);
 9955             bucket = m_out.add(buffer, m_out.shl(m_out.zeroExt(index, Int64), m_out.constInt32(getLSBSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;)))));
 9956         } else {
 9957             static_assert(hasOneBitSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;)), &quot;Should be a power of 2&quot;);
 9958             bucket = m_out.add(buffer, m_out.shl(m_out.zeroExt(index, Int64), m_out.constInt32(getLSBSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;)))));
 9959         }
 9960 
 9961         LValue bucketKey = m_out.load64(bucket, m_heaps.WeakMapBucket_key);
 9962         m_out.branch(m_out.equal(key, bucketKey), unsure(continuation), unsure(notEqualValue));
 9963 
 9964         m_out.appendTo(notEqualValue, loopAround);
 9965         m_out.branch(m_out.isNull(bucketKey), unsure(continuation), unsure(loopAround));
 9966 
 9967         m_out.appendTo(loopAround, continuation);
 9968         m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
 9969         m_out.jump(loopStart);
 9970 
 9971         m_out.appendTo(continuation, lastNext);
 9972         LValue result;
 9973         if (m_node-&gt;child1().useKind() == WeakMapObjectUse)
 9974             result = m_out.load64(bucket, m_heaps.WeakMapBucket_value);
 9975         else
 9976             result = bucketKey;
 9977         setJSValue(result);
 9978     }
 9979 
 9980     void compileWeakSetAdd()
 9981     {
 9982         LValue set = lowWeakSetObject(m_node-&gt;child1());
 9983         LValue key = lowObject(m_node-&gt;child2());
 9984         LValue hash = lowInt32(m_node-&gt;child3());
 9985 
 9986         vmCall(Void, m_out.operation(operationWeakSetAdd), m_callFrame, set, key, hash);
 9987     }
 9988 
 9989     void compileWeakMapSet()
 9990     {
 9991         LValue map = lowWeakMapObject(m_graph.varArgChild(m_node, 0));
 9992         LValue key = lowObject(m_graph.varArgChild(m_node, 1));
 9993         LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
 9994         LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
 9995 
 9996         vmCall(Void, m_out.operation(operationWeakMapSet), m_callFrame, map, key, value, hash);
 9997     }
 9998 
 9999     void compileIsObjectOrNull()
10000     {
10001         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
10002 
10003         Edge child = m_node-&gt;child1();
10004         LValue value = lowJSValue(child);
10005 
10006         LBasicBlock cellCase = m_out.newBlock();
10007         LBasicBlock notFunctionCase = m_out.newBlock();
10008         LBasicBlock objectCase = m_out.newBlock();
10009         LBasicBlock slowPath = m_out.newBlock();
10010         LBasicBlock notCellCase = m_out.newBlock();
10011         LBasicBlock continuation = m_out.newBlock();
10012 
10013         m_out.branch(isCell(value, provenType(child)), unsure(cellCase), unsure(notCellCase));
10014 
10015         LBasicBlock lastNext = m_out.appendTo(cellCase, notFunctionCase);
10016         ValueFromBlock isFunctionResult = m_out.anchor(m_out.booleanFalse);
10017         m_out.branch(
10018             isFunction(value, provenType(child)),
10019             unsure(continuation), unsure(notFunctionCase));
10020 
10021         m_out.appendTo(notFunctionCase, objectCase);
10022         ValueFromBlock notObjectResult = m_out.anchor(m_out.booleanFalse);
10023         m_out.branch(
10024             isObject(value, provenType(child)),
10025             unsure(objectCase), unsure(continuation));
10026 
10027         m_out.appendTo(objectCase, slowPath);
10028         ValueFromBlock objectResult = m_out.anchor(m_out.booleanTrue);
10029         m_out.branch(
10030             isExoticForTypeof(value, provenType(child)),
10031             rarely(slowPath), usually(continuation));
10032 
10033         m_out.appendTo(slowPath, notCellCase);
10034         VM&amp; vm = this-&gt;vm();
10035         LValue slowResultValue = lazySlowPath(
10036             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
10037                 return createLazyCallGenerator(vm,
10038                     operationObjectIsObject, locations[0].directGPR(),
10039                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
10040             }, value);
10041         ValueFromBlock slowResult = m_out.anchor(m_out.notZero64(slowResultValue));
10042         m_out.jump(continuation);
10043 
10044         m_out.appendTo(notCellCase, continuation);
10045         LValue notCellResultValue = m_out.equal(value, m_out.constInt64(JSValue::encode(jsNull())));
10046         ValueFromBlock notCellResult = m_out.anchor(notCellResultValue);
10047         m_out.jump(continuation);
10048 
10049         m_out.appendTo(continuation, lastNext);
10050         LValue result = m_out.phi(
10051             Int32,
10052             isFunctionResult, notObjectResult, objectResult, slowResult, notCellResult);
10053         setBoolean(result);
10054     }
10055 
10056     void compileIsFunction()
10057     {
10058         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
10059 
10060         Edge child = m_node-&gt;child1();
10061         LValue value = lowJSValue(child);
10062 
10063         LBasicBlock cellCase = m_out.newBlock();
10064         LBasicBlock notFunctionCase = m_out.newBlock();
10065         LBasicBlock slowPath = m_out.newBlock();
10066         LBasicBlock continuation = m_out.newBlock();
10067 
10068         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
10069         m_out.branch(
10070             isCell(value, provenType(child)), unsure(cellCase), unsure(continuation));
10071 
10072         LBasicBlock lastNext = m_out.appendTo(cellCase, notFunctionCase);
10073         ValueFromBlock functionResult = m_out.anchor(m_out.booleanTrue);
10074         m_out.branch(
10075             isFunction(value, provenType(child)),
10076             unsure(continuation), unsure(notFunctionCase));
10077 
10078         m_out.appendTo(notFunctionCase, slowPath);
10079         ValueFromBlock objectResult = m_out.anchor(m_out.booleanFalse);
10080         m_out.branch(
10081             isExoticForTypeof(value, provenType(child)),
10082             rarely(slowPath), usually(continuation));
10083 
10084         m_out.appendTo(slowPath, continuation);
10085         VM&amp; vm = this-&gt;vm();
10086         LValue slowResultValue = lazySlowPath(
10087             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
10088                 return createLazyCallGenerator(vm,
10089                     operationObjectIsFunction, locations[0].directGPR(),
10090                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
10091             }, value);
10092         ValueFromBlock slowResult = m_out.anchor(m_out.notNull(slowResultValue));
10093         m_out.jump(continuation);
10094 
10095         m_out.appendTo(continuation, lastNext);
10096         LValue result = m_out.phi(
10097             Int32, notCellResult, functionResult, objectResult, slowResult);
10098         setBoolean(result);
10099     }
10100 
10101     void compileIsTypedArrayView()
10102     {
10103         LValue value = lowJSValue(m_node-&gt;child1());
10104 
10105         LBasicBlock isCellCase = m_out.newBlock();
10106         LBasicBlock continuation = m_out.newBlock();
10107 
10108         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
10109         m_out.branch(isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
10110 
10111         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
10112         ValueFromBlock cellResult = m_out.anchor(isTypedArrayView(value, provenType(m_node-&gt;child1())));
10113         m_out.jump(continuation);
10114 
10115         m_out.appendTo(continuation, lastNext);
10116         setBoolean(m_out.phi(Int32, notCellResult, cellResult));
10117     }
10118 
10119     void compileTypeOf()
10120     {
10121         Edge child = m_node-&gt;child1();
10122         LValue value = lowJSValue(child);
10123 
10124         LBasicBlock continuation = m_out.newBlock();
10125         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
10126 
10127         Vector&lt;ValueFromBlock&gt; results;
10128 
10129         buildTypeOf(
10130             child, value,
10131             [&amp;] (TypeofType type) {
10132                 results.append(m_out.anchor(weakPointer(vm().smallStrings.typeString(type))));
10133                 m_out.jump(continuation);
10134             });
10135 
10136         m_out.appendTo(continuation, lastNext);
10137         setJSValue(m_out.phi(Int64, results));
10138     }
10139 
10140     void compileInByVal()
10141     {
10142         setJSValue(vmCall(Int64, m_out.operation(operationInByVal), m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));
10143     }
10144 
10145     void compileInById()
10146     {
10147         Node* node = m_node;
10148         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
10149         LValue base = lowCell(m_node-&gt;child1());
10150 
10151         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
10152         patchpoint-&gt;appendSomeRegister(base);
10153         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
10154         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
10155 
10156         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
10157 
10158         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
10159             preparePatchpointForExceptions(patchpoint);
10160 
10161         State* state = &amp;m_ftlState;
10162         patchpoint-&gt;setGenerator(
10163             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10164                 AllowMacroScratchRegisterUsage allowScratch(jit);
10165 
10166                 CallSiteIndex callSiteIndex =
10167                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
10168 
10169                 // This is the direct exit target for operation calls.
10170                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
10171                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
10172 
10173                 auto generator = Box&lt;JITInByIdGenerator&gt;::create(
10174                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
10175                     params.unavailableRegisters(), uid, JSValueRegs(params[1].gpr()),
10176                     JSValueRegs(params[0].gpr()));
10177 
10178                 generator-&gt;generateFastPath(jit);
10179                 CCallHelpers::Label done = jit.label();
10180 
10181                 params.addLatePath(
10182                     [=] (CCallHelpers&amp; jit) {
10183                         AllowMacroScratchRegisterUsage allowScratch(jit);
10184 
10185                         generator-&gt;slowPathJump().link(&amp;jit);
10186                         CCallHelpers::Label slowPathBegin = jit.label();
10187                         CCallHelpers::Call slowPathCall = callOperation(
10188                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
10189                             exceptions.get(), operationInByIdOptimize, params[0].gpr(),
10190                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
10191                             CCallHelpers::TrustedImmPtr(uid)).call();
10192                         jit.jump().linkTo(done, &amp;jit);
10193 
10194                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
10195 
10196                         jit.addLinkTask(
10197                             [=] (LinkBuffer&amp; linkBuffer) {
10198                                 generator-&gt;finalize(linkBuffer, linkBuffer);
10199                             });
10200                     });
10201             });
10202 
10203         setJSValue(patchpoint);
10204     }
10205 
10206     void compileHasOwnProperty()
10207     {
10208         LBasicBlock slowCase = m_out.newBlock();
10209         LBasicBlock continuation = m_out.newBlock();
10210         LBasicBlock lastNext = nullptr;
10211 
10212         LValue object = lowObject(m_node-&gt;child1());
10213         LValue uniquedStringImpl;
10214         LValue keyAsValue = nullptr;
10215         switch (m_node-&gt;child2().useKind()) {
10216         case StringUse: {
10217             LBasicBlock isNonEmptyString = m_out.newBlock();
<a name="90" id="anc90"></a><span class="line-modified">10218             LBasicBlock isAtomicString = m_out.newBlock();</span>
10219 
10220             keyAsValue = lowString(m_node-&gt;child2());
10221             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10222 
<a name="91" id="anc91"></a><span class="line-modified">10223             lastNext = m_out.appendTo(isNonEmptyString, isAtomicString);</span>
10224             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
<a name="92" id="anc92"></a><span class="line-modified">10225             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtomic()));</span>
<span class="line-modified">10226             m_out.branch(isNotAtomic, rarely(slowCase), usually(isAtomicString));</span>
10227 
<a name="93" id="anc93"></a><span class="line-modified">10228             m_out.appendTo(isAtomicString, slowCase);</span>
10229             break;
10230         }
10231         case SymbolUse: {
10232             keyAsValue = lowSymbol(m_node-&gt;child2());
10233             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl);
10234             lastNext = m_out.insertNewBlocksBefore(slowCase);
10235             break;
10236         }
10237         case UntypedUse: {
10238             LBasicBlock isCellCase = m_out.newBlock();
10239             LBasicBlock isStringCase = m_out.newBlock();
10240             LBasicBlock notStringCase = m_out.newBlock();
10241             LBasicBlock isNonEmptyString = m_out.newBlock();
10242             LBasicBlock isSymbolCase = m_out.newBlock();
10243             LBasicBlock hasUniquedStringImpl = m_out.newBlock();
10244 
10245             keyAsValue = lowJSValue(m_node-&gt;child2());
10246             m_out.branch(isCell(keyAsValue), usually(isCellCase), rarely(slowCase));
10247 
10248             lastNext = m_out.appendTo(isCellCase, isStringCase);
10249             m_out.branch(isString(keyAsValue), unsure(isStringCase), unsure(notStringCase));
10250 
10251             m_out.appendTo(isStringCase, isNonEmptyString);
10252             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10253 
10254             m_out.appendTo(isNonEmptyString, notStringCase);
10255             LValue implFromString = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
10256             ValueFromBlock stringResult = m_out.anchor(implFromString);
<a name="94" id="anc94"></a><span class="line-modified">10257             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(implFromString, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtomic()));</span>
10258             m_out.branch(isNotAtomic, rarely(slowCase), usually(hasUniquedStringImpl));
10259 
10260             m_out.appendTo(notStringCase, isSymbolCase);
10261             m_out.branch(isSymbol(keyAsValue), unsure(isSymbolCase), unsure(slowCase));
10262 
10263             m_out.appendTo(isSymbolCase, hasUniquedStringImpl);
10264             ValueFromBlock symbolResult = m_out.anchor(m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl));
10265             m_out.jump(hasUniquedStringImpl);
10266 
10267             m_out.appendTo(hasUniquedStringImpl, slowCase);
10268             uniquedStringImpl = m_out.phi(pointerType(), stringResult, symbolResult);
10269             break;
10270         }
10271         default:
10272             RELEASE_ASSERT_NOT_REACHED();
10273         }
10274 
10275         ASSERT(keyAsValue);
10276 
<a name="95" id="anc95"></a><span class="line-modified">10277         // Note that we don&#39;t test if the hash is zero here. AtomicStringImpl&#39;s can&#39;t have a zero</span>
10278         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
10279         // ever load the result from the cache if the cache entry matches what we are querying for.
10280         // So we either get super lucky and use zero for the hash and somehow collide with the entity
10281         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
10282         // slow path anyways.
10283         LValue hash = m_out.lShr(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
10284 
10285         LValue structureID = m_out.load32(object, m_heaps.JSCell_structureID);
10286         LValue index = m_out.add(hash, structureID);
10287         index = m_out.zeroExtPtr(m_out.bitAnd(index, m_out.constInt32(HasOwnPropertyCache::mask)));
10288         ASSERT(vm().hasOwnPropertyCache());
10289         LValue cache = m_out.constIntPtr(vm().hasOwnPropertyCache());
10290 
10291         IndexedAbstractHeap&amp; heap = m_heaps.HasOwnPropertyCache;
10292         LValue sameStructureID = m_out.equal(structureID, m_out.load32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfStructureID())));
10293         LValue sameImpl = m_out.equal(uniquedStringImpl, m_out.loadPtr(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfImpl())));
10294         ValueFromBlock fastResult = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfResult())));
10295         LValue cacheHit = m_out.bitAnd(sameStructureID, sameImpl);
10296 
10297         m_out.branch(m_out.notZero32(cacheHit), usually(continuation), rarely(slowCase));
10298 
10299         m_out.appendTo(slowCase, continuation);
10300         ValueFromBlock slowResult;
10301         slowResult = m_out.anchor(vmCall(Int32, m_out.operation(operationHasOwnProperty), m_callFrame, object, keyAsValue));
10302         m_out.jump(continuation);
10303 
10304         m_out.appendTo(continuation, lastNext);
10305         setBoolean(m_out.phi(Int32, fastResult, slowResult));
10306     }
10307 
10308     void compileParseInt()
10309     {
10310         RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse || m_node-&gt;child1().useKind() == StringUse);
10311         LValue result;
10312         if (m_node-&gt;child2()) {
10313             LValue radix = lowInt32(m_node-&gt;child2());
10314             if (m_node-&gt;child1().useKind() == UntypedUse)
10315                 result = vmCall(Int64, m_out.operation(operationParseIntGeneric), m_callFrame, lowJSValue(m_node-&gt;child1()), radix);
10316             else
10317                 result = vmCall(Int64, m_out.operation(operationParseIntString), m_callFrame, lowString(m_node-&gt;child1()), radix);
10318         } else {
10319             if (m_node-&gt;child1().useKind() == UntypedUse)
10320                 result = vmCall(Int64, m_out.operation(operationParseIntNoRadixGeneric), m_callFrame, lowJSValue(m_node-&gt;child1()));
10321             else
10322                 result = vmCall(Int64, m_out.operation(operationParseIntStringNoRadix), m_callFrame, lowString(m_node-&gt;child1()));
10323         }
10324         setJSValue(result);
10325     }
10326 
10327     void compileOverridesHasInstance()
10328     {
10329         FrozenValue* defaultHasInstanceFunction = m_node-&gt;cellOperand();
10330         ASSERT(defaultHasInstanceFunction-&gt;cell()-&gt;inherits&lt;JSFunction&gt;(vm()));
10331 
10332         LValue constructor = lowCell(m_node-&gt;child1());
10333         LValue hasInstance = lowJSValue(m_node-&gt;child2());
10334 
10335         LBasicBlock defaultHasInstance = m_out.newBlock();
10336         LBasicBlock continuation = m_out.newBlock();
10337 
10338         // Unlike in the DFG, we don&#39;t worry about cleaning this code up for the case where we have proven the hasInstanceValue is a constant as B3 should fix it for us.
10339 
10340         ValueFromBlock notDefaultHasInstanceResult = m_out.anchor(m_out.booleanTrue);
10341         m_out.branch(m_out.notEqual(hasInstance, frozenPointer(defaultHasInstanceFunction)), unsure(continuation), unsure(defaultHasInstance));
10342 
10343         LBasicBlock lastNext = m_out.appendTo(defaultHasInstance, continuation);
10344         ValueFromBlock implementsDefaultHasInstanceResult = m_out.anchor(m_out.testIsZero32(
10345             m_out.load8ZeroExt32(constructor, m_heaps.JSCell_typeInfoFlags),
10346             m_out.constInt32(ImplementsDefaultHasInstance)));
10347         m_out.jump(continuation);
10348 
10349         m_out.appendTo(continuation, lastNext);
10350         setBoolean(m_out.phi(Int32, implementsDefaultHasInstanceResult, notDefaultHasInstanceResult));
10351     }
10352 
10353     void compileCheckTypeInfoFlags()
10354     {
10355         speculate(
10356             BadTypeInfoFlags, noValue(), 0,
10357             m_out.testIsZero32(
10358                 m_out.load8ZeroExt32(lowCell(m_node-&gt;child1()), m_heaps.JSCell_typeInfoFlags),
10359                 m_out.constInt32(m_node-&gt;typeInfoOperand())));
10360     }
10361 
10362     void compileInstanceOf()
10363     {
10364         Node* node = m_node;
10365         State* state = &amp;m_ftlState;
10366 
10367         LValue value;
10368         LValue prototype;
10369         bool valueIsCell;
10370         bool prototypeIsCell;
10371         if (m_node-&gt;child1().useKind() == CellUse
10372             &amp;&amp; m_node-&gt;child2().useKind() == CellUse) {
10373             value = lowCell(m_node-&gt;child1());
10374             prototype = lowCell(m_node-&gt;child2());
10375 
10376             valueIsCell = true;
10377             prototypeIsCell = true;
10378         } else {
10379             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
10380             DFG_ASSERT(m_graph, m_node, m_node-&gt;child2().useKind() == UntypedUse);
10381 
10382             value = lowJSValue(m_node-&gt;child1());
10383             prototype = lowJSValue(m_node-&gt;child2());
10384 
10385             valueIsCell = abstractValue(m_node-&gt;child1()).isType(SpecCell);
10386             prototypeIsCell = abstractValue(m_node-&gt;child2()).isType(SpecCell);
10387         }
10388 
10389         bool prototypeIsObject = abstractValue(m_node-&gt;child2()).isType(SpecObject | ~SpecCell);
10390 
10391         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
10392         patchpoint-&gt;appendSomeRegister(value);
10393         patchpoint-&gt;appendSomeRegister(prototype);
10394         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
10395         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
10396         patchpoint-&gt;numGPScratchRegisters = 2;
<a name="96" id="anc96"></a><span class="line-modified">10397         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
10398         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
10399 
10400         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
10401             preparePatchpointForExceptions(patchpoint);
10402 
10403         patchpoint-&gt;setGenerator(
10404             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10405                 AllowMacroScratchRegisterUsage allowScratch(jit);
10406 
10407                 GPRReg resultGPR = params[0].gpr();
10408                 GPRReg valueGPR = params[1].gpr();
10409                 GPRReg prototypeGPR = params[2].gpr();
10410                 GPRReg scratchGPR = params.gpScratch(0);
10411                 GPRReg scratch2GPR = params.gpScratch(1);
10412 
10413                 CCallHelpers::Jump doneJump;
10414                 if (!valueIsCell) {
10415                     CCallHelpers::Jump isCell = jit.branchIfCell(valueGPR);
10416                     jit.boxBooleanPayload(false, resultGPR);
10417                     doneJump = jit.jump();
10418                     isCell.link(&amp;jit);
10419                 }
10420 
10421                 CCallHelpers::JumpList slowCases;
10422                 if (!prototypeIsCell)
10423                     slowCases.append(jit.branchIfNotCell(prototypeGPR));
10424 
10425                 CallSiteIndex callSiteIndex =
10426                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
10427 
10428                 // This is the direct exit target for operation calls.
10429                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
10430                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
10431 
10432                 auto generator = Box&lt;JITInstanceOfGenerator&gt;::create(
10433                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
10434                     params.unavailableRegisters(), resultGPR, valueGPR, prototypeGPR, scratchGPR,
10435                     scratch2GPR, prototypeIsObject);
10436                 generator-&gt;generateFastPath(jit);
10437                 CCallHelpers::Label done = jit.label();
10438 
10439                 params.addLatePath(
10440                     [=] (CCallHelpers&amp; jit) {
10441                         AllowMacroScratchRegisterUsage allowScratch(jit);
10442 
10443                         J_JITOperation_ESsiJJ optimizationFunction = operationInstanceOfOptimize;
10444 
10445                         slowCases.link(&amp;jit);
10446                         CCallHelpers::Label slowPathBegin = jit.label();
10447                         CCallHelpers::Call slowPathCall = callOperation(
10448                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
10449                             exceptions.get(), optimizationFunction, resultGPR,
10450                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), valueGPR,
10451                             prototypeGPR).call();
10452                         jit.jump().linkTo(done, &amp;jit);
10453 
10454                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
10455 
10456                         jit.addLinkTask(
10457                             [=] (LinkBuffer&amp; linkBuffer) {
10458                                 generator-&gt;finalize(linkBuffer, linkBuffer);
10459                             });
10460                     });
10461 
10462                 if (doneJump.isSet())
10463                     doneJump.link(&amp;jit);
10464             });
10465 
10466         // This returns a boxed boolean.
10467         setJSValue(patchpoint);
10468     }
10469 
10470     void compileInstanceOfCustom()
10471     {
10472         LValue value = lowJSValue(m_node-&gt;child1());
10473         LValue constructor = lowCell(m_node-&gt;child2());
10474         LValue hasInstance = lowJSValue(m_node-&gt;child3());
10475 
10476         setBoolean(m_out.logicalNot(m_out.equal(m_out.constInt32(0), vmCall(Int32, m_out.operation(operationInstanceOfCustom), m_callFrame, value, constructor, hasInstance))));
10477     }
10478 
10479     void compileCountExecution()
10480     {
10481         TypedPointer counter = m_out.absolute(m_node-&gt;executionCounter()-&gt;address());
10482         m_out.store64(m_out.add(m_out.load64(counter), m_out.constInt64(1)), counter);
10483     }
10484 
10485     void compileSuperSamplerBegin()
10486     {
10487         TypedPointer counter = m_out.absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
10488         m_out.store32(m_out.add(m_out.load32(counter), m_out.constInt32(1)), counter);
10489     }
10490 
10491     void compileSuperSamplerEnd()
10492     {
10493         TypedPointer counter = m_out.absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
10494         m_out.store32(m_out.sub(m_out.load32(counter), m_out.constInt32(1)), counter);
10495     }
10496 
10497     void compileStoreBarrier()
10498     {
10499         emitStoreBarrier(lowCell(m_node-&gt;child1()), m_node-&gt;op() == FencedStoreBarrier);
10500     }
10501 
10502     void compileHasIndexedProperty()
10503     {
10504         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
10505         LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
10506 
10507         switch (m_node-&gt;arrayMode().type()) {
10508         case Array::Int32:
10509         case Array::Contiguous: {
10510             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
10511             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10512 
10513             IndexedAbstractHeap&amp; heap = m_node-&gt;arrayMode().type() == Array::Int32 ?
10514                 m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties;
10515 
10516             LBasicBlock slowCase = m_out.newBlock();
10517             LBasicBlock continuation = m_out.newBlock();
10518             LBasicBlock lastNext = nullptr;
10519 
10520             if (!m_node-&gt;arrayMode().isInBounds()) {
10521                 LBasicBlock checkHole = m_out.newBlock();
10522                 m_out.branch(
10523                     m_out.aboveOrEqual(
10524                         index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
10525                     rarely(slowCase), usually(checkHole));
10526                 lastNext = m_out.appendTo(checkHole, slowCase);
10527             } else
10528                 lastNext = m_out.insertNewBlocksBefore(slowCase);
10529 
10530             LValue checkHoleResultValue =
10531                 m_out.notZero64(m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1))));
10532             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
10533             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
10534 
10535             m_out.appendTo(slowCase, continuation);
10536             ValueFromBlock slowResult = m_out.anchor(
10537                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10538             m_out.jump(continuation);
10539 
10540             m_out.appendTo(continuation, lastNext);
10541             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
10542             return;
10543         }
10544         case Array::Double: {
10545             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
10546             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10547 
10548             IndexedAbstractHeap&amp; heap = m_heaps.indexedDoubleProperties;
10549 
10550             LBasicBlock slowCase = m_out.newBlock();
10551             LBasicBlock continuation = m_out.newBlock();
10552             LBasicBlock lastNext = nullptr;
10553 
10554             if (!m_node-&gt;arrayMode().isInBounds()) {
10555                 LBasicBlock checkHole = m_out.newBlock();
10556                 m_out.branch(
10557                     m_out.aboveOrEqual(
10558                         index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
10559                     rarely(slowCase), usually(checkHole));
10560                 lastNext = m_out.appendTo(checkHole, slowCase);
10561             } else
10562                 lastNext = m_out.insertNewBlocksBefore(slowCase);
10563 
10564             LValue doubleValue = m_out.loadDouble(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
10565             LValue checkHoleResultValue = m_out.doubleEqual(doubleValue, doubleValue);
10566             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
10567             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
10568 
10569             m_out.appendTo(slowCase, continuation);
10570             ValueFromBlock slowResult = m_out.anchor(
10571                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10572             m_out.jump(continuation);
10573 
10574             m_out.appendTo(continuation, lastNext);
10575             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
10576             return;
10577         }
10578 
10579         case Array::ArrayStorage: {
10580             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
10581             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10582 
10583             LBasicBlock slowCase = m_out.newBlock();
10584             LBasicBlock continuation = m_out.newBlock();
10585             LBasicBlock lastNext = nullptr;
10586 
10587             if (!m_node-&gt;arrayMode().isInBounds()) {
10588                 LBasicBlock checkHole = m_out.newBlock();
10589                 m_out.branch(
10590                     m_out.aboveOrEqual(
10591                         index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength)),
10592                     rarely(slowCase), usually(checkHole));
10593                 lastNext = m_out.appendTo(checkHole, slowCase);
10594             } else
10595                 lastNext = m_out.insertNewBlocksBefore(slowCase);
10596 
10597             LValue checkHoleResultValue =
10598                 m_out.notZero64(m_out.load64(baseIndex(m_heaps.ArrayStorage_vector, storage, index, m_graph.varArgChild(m_node, 1))));
10599             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
10600             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
10601 
10602             m_out.appendTo(slowCase, continuation);
10603             ValueFromBlock slowResult = m_out.anchor(
10604                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10605             m_out.jump(continuation);
10606 
10607             m_out.appendTo(continuation, lastNext);
10608             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
10609             break;
10610         }
10611 
10612         default: {
10613             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10614             setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10615             break;
10616         }
10617         }
10618     }
10619 
10620     void compileHasGenericProperty()
10621     {
10622         LValue base = lowJSValue(m_node-&gt;child1());
10623         LValue property = lowCell(m_node-&gt;child2());
10624         setJSValue(vmCall(Int64, m_out.operation(operationHasGenericProperty), m_callFrame, base, property));
10625     }
10626 
10627     void compileHasStructureProperty()
10628     {
10629         LValue base = lowJSValue(m_node-&gt;child1());
10630         LValue property = lowString(m_node-&gt;child2());
10631         LValue enumerator = lowCell(m_node-&gt;child3());
10632 
10633         LBasicBlock correctStructure = m_out.newBlock();
10634         LBasicBlock wrongStructure = m_out.newBlock();
10635         LBasicBlock continuation = m_out.newBlock();
10636 
10637         m_out.branch(m_out.notEqual(
10638             m_out.load32(base, m_heaps.JSCell_structureID),
10639             m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedStructureID)),
10640             rarely(wrongStructure), usually(correctStructure));
10641 
10642         LBasicBlock lastNext = m_out.appendTo(correctStructure, wrongStructure);
10643         ValueFromBlock correctStructureResult = m_out.anchor(m_out.booleanTrue);
10644         m_out.jump(continuation);
10645 
10646         m_out.appendTo(wrongStructure, continuation);
10647         ValueFromBlock wrongStructureResult = m_out.anchor(
10648             m_out.equal(
10649                 m_out.constInt64(JSValue::encode(jsBoolean(true))),
10650                 vmCall(Int64, m_out.operation(operationHasGenericProperty), m_callFrame, base, property)));
10651         m_out.jump(continuation);
10652 
10653         m_out.appendTo(continuation, lastNext);
10654         setBoolean(m_out.phi(Int32, correctStructureResult, wrongStructureResult));
10655     }
10656 
10657     void compileGetDirectPname()
10658     {
10659         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
10660         LValue property = lowCell(m_graph.varArgChild(m_node, 1));
10661         LValue index = lowInt32(m_graph.varArgChild(m_node, 2));
10662         LValue enumerator = lowCell(m_graph.varArgChild(m_node, 3));
10663 
10664         LBasicBlock checkOffset = m_out.newBlock();
10665         LBasicBlock inlineLoad = m_out.newBlock();
10666         LBasicBlock outOfLineLoad = m_out.newBlock();
10667         LBasicBlock slowCase = m_out.newBlock();
10668         LBasicBlock continuation = m_out.newBlock();
10669 
10670         m_out.branch(m_out.notEqual(
10671             m_out.load32(base, m_heaps.JSCell_structureID),
10672             m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedStructureID)),
10673             rarely(slowCase), usually(checkOffset));
10674 
10675         LBasicBlock lastNext = m_out.appendTo(checkOffset, inlineLoad);
10676         m_out.branch(m_out.aboveOrEqual(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedInlineCapacity)),
10677             unsure(outOfLineLoad), unsure(inlineLoad));
10678 
10679         m_out.appendTo(inlineLoad, outOfLineLoad);
10680         ValueFromBlock inlineResult = m_out.anchor(
10681             m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(),
10682                 base, m_out.zeroExt(index, Int64), ScaleEight, JSObject::offsetOfInlineStorage())));
10683         m_out.jump(continuation);
10684 
10685         m_out.appendTo(outOfLineLoad, slowCase);
10686         LValue storage = m_out.loadPtr(base, m_heaps.JSObject_butterfly);
10687         LValue realIndex = m_out.signExt32To64(
10688             m_out.neg(m_out.sub(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedInlineCapacity))));
10689         int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
10690         ValueFromBlock outOfLineResult = m_out.anchor(
10691             m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), storage, realIndex, ScaleEight, offsetOfFirstProperty)));
10692         m_out.jump(continuation);
10693 
10694         m_out.appendTo(slowCase, continuation);
10695         ValueFromBlock slowCaseResult = m_out.anchor(
10696             vmCall(Int64, m_out.operation(operationGetByVal), m_callFrame, base, property));
10697         m_out.jump(continuation);
10698 
10699         m_out.appendTo(continuation, lastNext);
10700         setJSValue(m_out.phi(Int64, inlineResult, outOfLineResult, slowCaseResult));
10701     }
10702 
10703     void compileGetEnumerableLength()
10704     {
10705         LValue enumerator = lowCell(m_node-&gt;child1());
10706         setInt32(m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_indexLength));
10707     }
10708 
10709     void compileGetPropertyEnumerator()
10710     {
10711         if (m_node-&gt;child1().useKind() == CellUse)
10712             setJSValue(vmCall(Int64, m_out.operation(operationGetPropertyEnumeratorCell), m_callFrame, lowCell(m_node-&gt;child1())));
10713         else
10714             setJSValue(vmCall(Int64, m_out.operation(operationGetPropertyEnumerator), m_callFrame, lowJSValue(m_node-&gt;child1())));
10715     }
10716 
10717     void compileGetEnumeratorStructurePname()
10718     {
10719         LValue enumerator = lowCell(m_node-&gt;child1());
10720         LValue index = lowInt32(m_node-&gt;child2());
10721 
10722         LBasicBlock inBounds = m_out.newBlock();
10723         LBasicBlock outOfBounds = m_out.newBlock();
10724         LBasicBlock continuation = m_out.newBlock();
10725 
10726         m_out.branch(m_out.below(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_endStructurePropertyIndex)),
10727             usually(inBounds), rarely(outOfBounds));
10728 
10729         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
10730         LValue storage = m_out.loadPtr(enumerator, m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVector);
10731         ValueFromBlock inBoundsResult = m_out.anchor(
10732             m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
10733         m_out.jump(continuation);
10734 
10735         m_out.appendTo(outOfBounds, continuation);
10736         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueNull));
10737         m_out.jump(continuation);
10738 
10739         m_out.appendTo(continuation, lastNext);
10740         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
10741     }
10742 
10743     void compileGetEnumeratorGenericPname()
10744     {
10745         LValue enumerator = lowCell(m_node-&gt;child1());
10746         LValue index = lowInt32(m_node-&gt;child2());
10747 
10748         LBasicBlock inBounds = m_out.newBlock();
10749         LBasicBlock outOfBounds = m_out.newBlock();
10750         LBasicBlock continuation = m_out.newBlock();
10751 
10752         m_out.branch(m_out.below(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_endGenericPropertyIndex)),
10753             usually(inBounds), rarely(outOfBounds));
10754 
10755         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
10756         LValue storage = m_out.loadPtr(enumerator, m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVector);
10757         ValueFromBlock inBoundsResult = m_out.anchor(
10758             m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
10759         m_out.jump(continuation);
10760 
10761         m_out.appendTo(outOfBounds, continuation);
10762         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueNull));
10763         m_out.jump(continuation);
10764 
10765         m_out.appendTo(continuation, lastNext);
10766         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
10767     }
10768 
10769     void compileToIndexString()
10770     {
10771         LValue index = lowInt32(m_node-&gt;child1());
10772         setJSValue(vmCall(Int64, m_out.operation(operationToIndexString), m_callFrame, index));
10773     }
10774 
10775     void compileCheckStructureImmediate()
10776     {
10777         LValue structure = lowCell(m_node-&gt;child1());
10778         checkStructure(
10779             structure, noValue(), BadCache, m_node-&gt;structureSet(),
10780             [this] (RegisteredStructure structure) {
10781                 return weakStructure(structure);
10782             });
10783     }
10784 
10785     void compileMaterializeNewObject()
10786     {
10787         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
10788 
10789         // Lower the values first, to avoid creating values inside a control flow diamond.
10790 
10791         Vector&lt;LValue, 8&gt; values;
10792         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
10793             Edge edge = m_graph.varArgChild(m_node, 1 + i);
10794             switch (data.m_properties[i].kind()) {
10795             case PublicLengthPLoc:
10796             case VectorLengthPLoc:
10797                 values.append(lowInt32(edge));
10798                 break;
10799             default:
10800                 values.append(lowJSValue(edge));
10801                 break;
10802             }
10803         }
10804 
10805         RegisteredStructureSet set = m_node-&gt;structureSet();
10806 
10807         Vector&lt;LBasicBlock, 1&gt; blocks(set.size());
10808         for (unsigned i = set.size(); i--;)
10809             blocks[i] = m_out.newBlock();
10810         LBasicBlock dummyDefault = m_out.newBlock();
10811         LBasicBlock outerContinuation = m_out.newBlock();
10812 
10813         Vector&lt;SwitchCase, 1&gt; cases(set.size());
10814         for (unsigned i = set.size(); i--;)
10815             cases[i] = SwitchCase(weakStructure(set.at(i)), blocks[i], Weight(1));
10816         m_out.switchInstruction(
10817             lowCell(m_graph.varArgChild(m_node, 0)), cases, dummyDefault, Weight(0));
10818 
10819         LBasicBlock outerLastNext = m_out.m_nextBlock;
10820 
10821         Vector&lt;ValueFromBlock, 1&gt; results;
10822 
10823         for (unsigned i = set.size(); i--;) {
10824             m_out.appendTo(blocks[i], i + 1 &lt; set.size() ? blocks[i + 1] : dummyDefault);
10825 
10826             RegisteredStructure structure = set.at(i);
10827 
10828             LValue object;
10829             LValue butterfly;
10830 
10831             if (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType())) {
10832                 size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
10833                 Allocator cellAllocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
10834 
10835                 bool hasIndexingHeader = hasIndexedProperties(structure-&gt;indexingType());
10836                 unsigned indexingHeaderSize = 0;
10837                 LValue indexingPayloadSizeInBytes = m_out.intPtrZero;
10838                 LValue vectorLength = m_out.int32Zero;
10839                 LValue publicLength = m_out.int32Zero;
10840                 if (hasIndexingHeader) {
10841                     indexingHeaderSize = sizeof(IndexingHeader);
10842                     for (unsigned i = data.m_properties.size(); i--;) {
10843                         PromotedLocationDescriptor descriptor = data.m_properties[i];
10844                         switch (descriptor.kind()) {
10845                         case PublicLengthPLoc:
10846                             publicLength = values[i];
10847                             break;
10848                         case VectorLengthPLoc:
10849                             vectorLength = values[i];
10850                             break;
10851                         default:
10852                             break;
10853                         }
10854                     }
10855                     indexingPayloadSizeInBytes =
10856                         m_out.mul(m_out.zeroExtPtr(vectorLength), m_out.intPtrEight);
10857                 }
10858 
10859                 LValue butterflySize = m_out.add(
10860                     m_out.constIntPtr(
10861                         structure-&gt;outOfLineCapacity() * sizeof(JSValue) + indexingHeaderSize),
10862                     indexingPayloadSizeInBytes);
10863 
10864                 LBasicBlock slowPath = m_out.newBlock();
10865                 LBasicBlock continuation = m_out.newBlock();
10866 
10867                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
10868 
10869                 ValueFromBlock noButterfly = m_out.anchor(m_out.intPtrZero);
10870 
10871                 LValue startOfStorage = allocateHeapCell(
10872                     allocatorForSize(vm().jsValueGigacageAuxiliarySpace, butterflySize, slowPath),
10873                     slowPath);
10874 
10875                 LValue fastButterflyValue = m_out.add(
10876                     startOfStorage,
10877                     m_out.constIntPtr(
10878                         structure-&gt;outOfLineCapacity() * sizeof(JSValue) + sizeof(IndexingHeader)));
10879 
10880                 ValueFromBlock haveButterfly = m_out.anchor(fastButterflyValue);
10881 
10882                 splatWords(
10883                     fastButterflyValue,
10884                     m_out.constInt32(-structure-&gt;outOfLineCapacity() - 1),
10885                     m_out.constInt32(-1),
10886                     m_out.int64Zero, m_heaps.properties.atAnyNumber());
10887 
10888                 m_out.store32(vectorLength, fastButterflyValue, m_heaps.Butterfly_vectorLength);
10889 
10890                 LValue fastObjectValue = allocateObject(
10891                     m_out.constIntPtr(cellAllocator.localAllocator()), structure, fastButterflyValue,
10892                     slowPath);
10893 
10894                 ValueFromBlock fastObject = m_out.anchor(fastObjectValue);
10895                 ValueFromBlock fastButterfly = m_out.anchor(fastButterflyValue);
10896                 m_out.jump(continuation);
10897 
10898                 m_out.appendTo(slowPath, continuation);
10899 
10900                 LValue butterflyValue = m_out.phi(pointerType(), noButterfly, haveButterfly);
10901 
10902                 VM&amp; vm = this-&gt;vm();
10903                 LValue slowObjectValue;
10904                 if (hasIndexingHeader) {
10905                     slowObjectValue = lazySlowPath(
10906                         [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
10907                             return createLazyCallGenerator(vm,
10908                                 operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength,
10909                                 locations[0].directGPR(), CCallHelpers::TrustedImmPtr(structure.get()),
10910                                 locations[1].directGPR(), locations[2].directGPR());
10911                         },
10912                         vectorLength, butterflyValue);
10913                 } else {
10914                     slowObjectValue = lazySlowPath(
10915                         [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
10916                             return createLazyCallGenerator(vm,
10917                                 operationNewObjectWithButterfly, locations[0].directGPR(),
10918                                 CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR());
10919                         },
10920                         butterflyValue);
10921                 }
10922                 ValueFromBlock slowObject = m_out.anchor(slowObjectValue);
10923                 ValueFromBlock slowButterfly = m_out.anchor(
10924                     m_out.loadPtr(slowObjectValue, m_heaps.JSObject_butterfly));
10925 
10926                 m_out.jump(continuation);
10927 
10928                 m_out.appendTo(continuation, lastNext);
10929 
10930                 object = m_out.phi(pointerType(), fastObject, slowObject);
10931                 butterfly = m_out.phi(pointerType(), fastButterfly, slowButterfly);
10932 
10933                 m_out.store32(publicLength, butterfly, m_heaps.Butterfly_publicLength);
10934 
10935                 initializeArrayElements(m_out.constInt32(structure-&gt;indexingType()), m_out.int32Zero, vectorLength, butterfly);
10936 
10937                 HashMap&lt;int32_t, LValue, DefaultHash&lt;int32_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int32_t&gt;&gt; indexMap;
10938                 Vector&lt;int32_t&gt; indices;
10939                 for (unsigned i = data.m_properties.size(); i--;) {
10940                     PromotedLocationDescriptor descriptor = data.m_properties[i];
10941                     if (descriptor.kind() != IndexedPropertyPLoc)
10942                         continue;
10943                     int32_t index = static_cast&lt;int32_t&gt;(descriptor.info());
10944 
10945                     auto result = indexMap.add(index, values[i]);
10946                     DFG_ASSERT(m_graph, m_node, result); // Duplicates are illegal.
10947 
10948                     indices.append(index);
10949                 }
10950 
10951                 if (!indices.isEmpty()) {
10952                     std::sort(indices.begin(), indices.end());
10953 
10954                     Vector&lt;LBasicBlock&gt; blocksWithStores(indices.size());
10955                     Vector&lt;LBasicBlock&gt; blocksWithChecks(indices.size());
10956 
10957                     for (unsigned i = indices.size(); i--;) {
10958                         blocksWithStores[i] = m_out.newBlock();
10959                         blocksWithChecks[i] = m_out.newBlock(); // blocksWithChecks[0] is the continuation.
10960                     }
10961 
10962                     LBasicBlock indexLastNext = m_out.m_nextBlock;
10963 
10964                     for (unsigned i = indices.size(); i--;) {
10965                         int32_t index = indices[i];
10966                         LValue value = indexMap.get(index);
10967 
10968                         m_out.branch(
10969                             m_out.below(m_out.constInt32(index), publicLength),
10970                             unsure(blocksWithStores[i]), unsure(blocksWithChecks[i]));
10971 
10972                         m_out.appendTo(blocksWithStores[i], blocksWithChecks[i]);
10973 
10974                         // This has to type-check and convert its inputs, but it cannot do so in a
10975                         // way that updates AI. That&#39;s a bit annoying, but if you think about how
10976                         // sinking works, it&#39;s actually not a bad thing. We are virtually guaranteed
10977                         // that these type checks will not fail, since the type checks that guarded
10978                         // the original stores to the array are still somewhere above this point.
10979                         Output::StoreType storeType;
10980                         IndexedAbstractHeap* heap;
10981                         switch (structure-&gt;indexingType()) {
10982                         case ALL_INT32_INDEXING_TYPES:
10983                             // FIXME: This could use the proven type if we had the Edge for the
10984                             // value. https://bugs.webkit.org/show_bug.cgi?id=155311
10985                             speculate(BadType, noValue(), nullptr, isNotInt32(value));
10986                             storeType = Output::Store64;
10987                             heap = &amp;m_heaps.indexedInt32Properties;
10988                             break;
10989 
10990                         case ALL_DOUBLE_INDEXING_TYPES: {
10991                             // FIXME: If the source is ValueRep, we should avoid emitting any
10992                             // checks. We could also avoid emitting checks if we had the Edge of
10993                             // this value. https://bugs.webkit.org/show_bug.cgi?id=155311
10994 
10995                             LBasicBlock intCase = m_out.newBlock();
10996                             LBasicBlock doubleCase = m_out.newBlock();
10997                             LBasicBlock continuation = m_out.newBlock();
10998 
10999                             m_out.branch(isInt32(value), unsure(intCase), unsure(doubleCase));
11000 
11001                             LBasicBlock lastNext = m_out.appendTo(intCase, doubleCase);
11002 
11003                             ValueFromBlock intResult =
11004                                 m_out.anchor(m_out.intToDouble(unboxInt32(value)));
11005                             m_out.jump(continuation);
11006 
11007                             m_out.appendTo(doubleCase, continuation);
11008 
11009                             speculate(BadType, noValue(), nullptr, isNumber(value));
11010                             ValueFromBlock doubleResult = m_out.anchor(unboxDouble(value));
11011                             m_out.jump(continuation);
11012 
11013                             m_out.appendTo(continuation, lastNext);
11014                             value = m_out.phi(Double, intResult, doubleResult);
11015                             storeType = Output::StoreDouble;
11016                             heap = &amp;m_heaps.indexedDoubleProperties;
11017                             break;
11018                         }
11019 
11020                         case ALL_CONTIGUOUS_INDEXING_TYPES:
11021                             storeType = Output::Store64;
11022                             heap = &amp;m_heaps.indexedContiguousProperties;
11023                             break;
11024 
11025                         default:
11026                             DFG_CRASH(m_graph, m_node, &quot;Invalid indexing type&quot;);
11027                             break;
11028                         }
11029 
11030                         m_out.store(value, m_out.address(butterfly, heap-&gt;at(index)), storeType);
11031 
11032                         m_out.jump(blocksWithChecks[i]);
11033                         m_out.appendTo(
11034                             blocksWithChecks[i], i ? blocksWithStores[i - 1] : indexLastNext);
11035                     }
11036                 }
11037             } else {
11038                 // In the easy case where we can do a one-shot allocation, we simply allocate the
11039                 // object to directly have the desired structure.
11040                 object = allocateObject(structure);
11041                 butterfly = nullptr; // Don&#39;t have one, don&#39;t need one.
11042             }
11043 
11044             BitVector setInlineOffsets;
11045             for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
11046                 for (unsigned i = data.m_properties.size(); i--;) {
11047                     PromotedLocationDescriptor descriptor = data.m_properties[i];
11048                     if (descriptor.kind() != NamedPropertyPLoc)
11049                         continue;
11050                     if (m_graph.identifiers()[descriptor.info()] != entry.key)
11051                         continue;
11052 
11053                     LValue base;
11054                     if (isInlineOffset(entry.offset)) {
11055                         setInlineOffsets.set(entry.offset);
11056                         base = object;
11057                     } else
11058                         base = butterfly;
11059                     storeProperty(values[i], base, descriptor.info(), entry.offset);
11060                     break;
11061                 }
11062             }
11063             for (unsigned i = structure-&gt;inlineCapacity(); i--;) {
11064                 if (!setInlineOffsets.get(i))
11065                     m_out.store64(m_out.int64Zero, m_out.address(m_heaps.properties.atAnyNumber(), object, offsetRelativeToBase(i)));
11066             }
11067 
11068             results.append(m_out.anchor(object));
11069             m_out.jump(outerContinuation);
11070         }
11071 
11072         m_out.appendTo(dummyDefault, outerContinuation);
11073         m_out.unreachable();
11074 
11075         m_out.appendTo(outerContinuation, outerLastNext);
11076         setJSValue(m_out.phi(pointerType(), results));
11077         mutatorFence();
11078     }
11079 
11080     void compileMaterializeCreateActivation()
11081     {
11082         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
11083 
11084         Vector&lt;LValue, 8&gt; values;
11085         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)
11086             values.append(lowJSValue(m_graph.varArgChild(m_node, 2 + i)));
11087 
11088         LValue scope = lowCell(m_graph.varArgChild(m_node, 1));
11089         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
<a name="97" id="anc97"></a><span class="line-removed">11090         ASSERT(table == m_graph.varArgChild(m_node, 0)-&gt;castConstant&lt;SymbolTable*&gt;(vm()));</span>
11091         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
11092 
11093         LBasicBlock slowPath = m_out.newBlock();
11094         LBasicBlock continuation = m_out.newBlock();
11095 
11096         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
11097 
11098         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
11099             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
11100 
11101         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
11102         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
11103 
11104 
11105         ValueFromBlock fastResult = m_out.anchor(fastObject);
11106         m_out.jump(continuation);
11107 
11108         m_out.appendTo(slowPath, continuation);
11109         // We ensure allocation sinking explictly sets bottom values for all field members.
11110         // Therefore, it doesn&#39;t matter what JSValue we pass in as the initialization value
11111         // because all fields will be overwritten.
11112         // FIXME: It may be worth creating an operation that calls a constructor on JSLexicalEnvironment that
11113         // doesn&#39;t initialize every slot because we are guaranteed to do that here.
11114         VM&amp; vm = this-&gt;vm();
11115         LValue callResult = lazySlowPath(
11116             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11117                 return createLazyCallGenerator(vm,
11118                     operationCreateActivationDirect, locations[0].directGPR(),
11119                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
11120                     CCallHelpers::TrustedImmPtr(table),
11121                     CCallHelpers::TrustedImm64(JSValue::encode(jsUndefined())));
11122             }, scope);
11123         ValueFromBlock slowResult =  m_out.anchor(callResult);
11124         m_out.jump(continuation);
11125 
11126         m_out.appendTo(continuation, lastNext);
11127         LValue activation = m_out.phi(pointerType(), fastResult, slowResult);
11128         RELEASE_ASSERT(data.m_properties.size() == table-&gt;scopeSize());
11129         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
11130             PromotedLocationDescriptor descriptor = data.m_properties[i];
11131             ASSERT(descriptor.kind() == ClosureVarPLoc);
11132             m_out.store64(
11133                 values[i], activation,
11134                 m_heaps.JSLexicalEnvironment_variables[descriptor.info()]);
11135         }
11136 
11137         if (validationEnabled()) {
11138             // Validate to make sure every slot in the scope has one value.
11139             ConcurrentJSLocker locker(table-&gt;m_lock);
11140             for (auto iter = table-&gt;begin(locker), end = table-&gt;end(locker); iter != end; ++iter) {
11141                 bool found = false;
11142                 for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
11143                     PromotedLocationDescriptor descriptor = data.m_properties[i];
11144                     ASSERT(descriptor.kind() == ClosureVarPLoc);
11145                     if (iter-&gt;value.scopeOffset().offset() == descriptor.info()) {
11146                         found = true;
11147                         break;
11148                     }
11149                 }
11150                 ASSERT_UNUSED(found, found);
11151             }
11152         }
11153 
11154         mutatorFence();
11155         setJSValue(activation);
11156     }
11157 
11158     void compileCheckTraps()
11159     {
11160         ASSERT(Options::usePollingTraps());
11161         LBasicBlock needTrapHandling = m_out.newBlock();
11162         LBasicBlock continuation = m_out.newBlock();
11163 
11164         LValue state = m_out.load8ZeroExt32(m_out.absolute(vm().needTrapHandlingAddress()));
11165         m_out.branch(m_out.isZero32(state),
11166             usually(continuation), rarely(needTrapHandling));
11167 
11168         LBasicBlock lastNext = m_out.appendTo(needTrapHandling, continuation);
11169 
11170         VM&amp; vm = this-&gt;vm();
11171         lazySlowPath(
11172             [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11173                 return createLazyCallGenerator(vm, operationHandleTraps, InvalidGPRReg);
11174             });
11175         m_out.jump(continuation);
11176 
11177         m_out.appendTo(continuation, lastNext);
11178     }
11179 
11180     void compileRegExpExec()
11181     {
11182         LValue globalObject = lowCell(m_node-&gt;child1());
11183 
11184         if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
11185             LValue base = lowRegExpObject(m_node-&gt;child2());
11186 
11187             if (m_node-&gt;child3().useKind() == StringUse) {
11188                 LValue argument = lowString(m_node-&gt;child3());
11189                 LValue result = vmCall(
11190                     Int64, m_out.operation(operationRegExpExecString), m_callFrame, globalObject,
11191                     base, argument);
11192                 setJSValue(result);
11193                 return;
11194             }
11195 
11196             LValue argument = lowJSValue(m_node-&gt;child3());
11197             LValue result = vmCall(
11198                 Int64, m_out.operation(operationRegExpExec), m_callFrame, globalObject, base,
11199                 argument);
11200             setJSValue(result);
11201             return;
11202         }
11203 
11204         LValue base = lowJSValue(m_node-&gt;child2());
11205         LValue argument = lowJSValue(m_node-&gt;child3());
11206         LValue result = vmCall(
11207             Int64, m_out.operation(operationRegExpExecGeneric), m_callFrame, globalObject, base,
11208             argument);
11209         setJSValue(result);
11210     }
11211 
11212     void compileRegExpExecNonGlobalOrSticky()
11213     {
11214         LValue globalObject = lowCell(m_node-&gt;child1());
11215         LValue argument = lowString(m_node-&gt;child2());
11216         LValue result = vmCall(
11217             Int64, m_out.operation(operationRegExpExecNonGlobalOrSticky), m_callFrame, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);
11218         setJSValue(result);
11219     }
11220 
11221     void compileRegExpMatchFastGlobal()
11222     {
11223         LValue globalObject = lowCell(m_node-&gt;child1());
11224         LValue argument = lowString(m_node-&gt;child2());
11225         LValue result = vmCall(
11226             Int64, m_out.operation(operationRegExpMatchFastGlobalString), m_callFrame, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);
11227         setJSValue(result);
11228     }
11229 
11230     void compileRegExpTest()
11231     {
11232         LValue globalObject = lowCell(m_node-&gt;child1());
11233 
11234         if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
11235             LValue base = lowRegExpObject(m_node-&gt;child2());
11236 
11237             if (m_node-&gt;child3().useKind() == StringUse) {
11238                 LValue argument = lowString(m_node-&gt;child3());
11239                 LValue result = vmCall(
11240                     Int32, m_out.operation(operationRegExpTestString), m_callFrame, globalObject,
11241                     base, argument);
11242                 setBoolean(result);
11243                 return;
11244             }
11245 
11246             LValue argument = lowJSValue(m_node-&gt;child3());
11247             LValue result = vmCall(
11248                 Int32, m_out.operation(operationRegExpTest), m_callFrame, globalObject, base,
11249                 argument);
11250             setBoolean(result);
11251             return;
11252         }
11253 
11254         LValue base = lowJSValue(m_node-&gt;child2());
11255         LValue argument = lowJSValue(m_node-&gt;child3());
11256         LValue result = vmCall(
11257             Int32, m_out.operation(operationRegExpTestGeneric), m_callFrame, globalObject, base,
11258             argument);
11259         setBoolean(result);
11260     }
11261 
11262     void compileRegExpMatchFast()
11263     {
11264         LValue globalObject = lowCell(m_node-&gt;child1());
11265         LValue base = lowRegExpObject(m_node-&gt;child2());
11266         LValue argument = lowString(m_node-&gt;child3());
11267         LValue result = vmCall(
11268             Int64, m_out.operation(operationRegExpMatchFastString), m_callFrame, globalObject,
11269             base, argument);
11270         setJSValue(result);
11271     }
11272 
11273     void compileNewRegexp()
11274     {
11275         FrozenValue* regexp = m_node-&gt;cellOperand();
11276         LValue lastIndex = lowJSValue(m_node-&gt;child1());
11277         ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
<a name="98" id="anc98"></a><span class="line-removed">11278         ASSERT(m_node-&gt;castOperand&lt;RegExp*&gt;()-&gt;isValid());</span>
11279 
11280         LBasicBlock slowCase = m_out.newBlock();
11281         LBasicBlock continuation = m_out.newBlock();
11282 
11283         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
11284 
11285         auto structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;regExpStructure());
11286         LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
<a name="99" id="anc99"></a><span class="line-modified">11287         m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExp);</span>
11288         m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
<a name="100" id="anc100"></a><span class="line-removed">11289         m_out.store32As8(m_out.constInt32(true), m_out.address(fastResultValue, m_heaps.RegExpObject_lastIndexIsWritable));</span>
11290         mutatorFence();
11291         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
11292         m_out.jump(continuation);
11293 
11294         m_out.appendTo(slowCase, continuation);
11295         VM&amp; vm = this-&gt;vm();
11296         RegExp* regexpCell = regexp-&gt;cast&lt;RegExp*&gt;();
11297         LValue slowResultValue = lazySlowPath(
11298             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11299                 return createLazyCallGenerator(vm,
11300                     operationNewRegexpWithLastIndex, locations[0].directGPR(),
11301                     CCallHelpers::TrustedImmPtr(regexpCell), locations[1].directGPR());
11302             }, lastIndex);
11303         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
11304         m_out.jump(continuation);
11305 
11306         m_out.appendTo(continuation, lastNext);
11307         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
11308     }
11309 
11310     void compileSetFunctionName()
11311     {
11312         vmCall(Void, m_out.operation(operationSetFunctionName), m_callFrame,
11313             lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()));
11314     }
11315 
11316     void compileStringReplace()
11317     {
11318         if (m_node-&gt;child1().useKind() == StringUse
11319             &amp;&amp; m_node-&gt;child2().useKind() == RegExpObjectUse
11320             &amp;&amp; m_node-&gt;child3().useKind() == StringUse) {
11321 
11322             if (JSString* replace = m_node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
11323                 if (!replace-&gt;length()) {
11324                     LValue string = lowString(m_node-&gt;child1());
11325                     LValue regExp = lowRegExpObject(m_node-&gt;child2());
11326 
11327                     LValue result = vmCall(
11328                         pointerType(), m_out.operation(operationStringProtoFuncReplaceRegExpEmptyStr),
11329                         m_callFrame, string, regExp);
11330 
11331                     setJSValue(result);
11332                     return;
11333                 }
11334             }
11335 
11336             LValue string = lowString(m_node-&gt;child1());
11337             LValue regExp = lowRegExpObject(m_node-&gt;child2());
11338             LValue replace = lowString(m_node-&gt;child3());
11339 
11340             LValue result = vmCall(
11341                 pointerType(), m_out.operation(operationStringProtoFuncReplaceRegExpString),
11342                 m_callFrame, string, regExp, replace);
11343 
11344             setJSValue(result);
11345             return;
11346         }
11347 
11348         LValue search;
11349         if (m_node-&gt;child2().useKind() == StringUse)
11350             search = lowString(m_node-&gt;child2());
11351         else
11352             search = lowJSValue(m_node-&gt;child2());
11353 
11354         LValue result = vmCall(
11355             pointerType(), m_out.operation(operationStringProtoFuncReplaceGeneric), m_callFrame,
11356             lowJSValue(m_node-&gt;child1()), search,
11357             lowJSValue(m_node-&gt;child3()));
11358 
11359         setJSValue(result);
11360     }
11361 
11362     void compileGetRegExpObjectLastIndex()
11363     {
11364         setJSValue(m_out.load64(lowRegExpObject(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex));
11365     }
11366 
11367     void compileSetRegExpObjectLastIndex()
11368     {
11369         if (!m_node-&gt;ignoreLastIndexIsWritable()) {
11370             LValue regExp = lowRegExpObject(m_node-&gt;child1());
11371             LValue value = lowJSValue(m_node-&gt;child2());
11372 
11373             speculate(
11374                 ExoticObjectMode, noValue(), nullptr,
<a name="101" id="anc101"></a><span class="line-modified">11375                 m_out.isZero32(m_out.load8ZeroExt32(regExp, m_heaps.RegExpObject_lastIndexIsWritable)));</span>


11376 
11377             m_out.store64(value, regExp, m_heaps.RegExpObject_lastIndex);
11378             return;
11379         }
11380 
11381         m_out.store64(lowJSValue(m_node-&gt;child2()), lowCell(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex);
11382     }
11383 
11384     void compileLogShadowChickenPrologue()
11385     {
11386         LValue packet = ensureShadowChickenPacket();
11387         LValue scope = lowCell(m_node-&gt;child1());
11388 
11389         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
11390         m_out.storePtr(m_out.loadPtr(addressFor(0)), packet, m_heaps.ShadowChicken_Packet_callerFrame);
11391         m_out.storePtr(m_out.loadPtr(payloadFor(CallFrameSlot::callee)), packet, m_heaps.ShadowChicken_Packet_callee);
11392         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
11393     }
11394 
11395     void compileLogShadowChickenTail()
11396     {
11397         LValue packet = ensureShadowChickenPacket();
11398         LValue thisValue = lowJSValue(m_node-&gt;child1());
11399         LValue scope = lowCell(m_node-&gt;child2());
11400         CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(m_node-&gt;origin.semantic);
11401 
11402         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
11403         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(ShadowChicken::Packet::tailMarker())), packet, m_heaps.ShadowChicken_Packet_callee);
11404         m_out.store64(thisValue, packet, m_heaps.ShadowChicken_Packet_thisValue);
11405         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
11406         // We don&#39;t want the CodeBlock to have a weak pointer to itself because
11407         // that would cause it to always get collected.
11408         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), packet, m_heaps.ShadowChicken_Packet_codeBlock);
11409         m_out.store32(m_out.constInt32(callSiteIndex.bits()), packet, m_heaps.ShadowChicken_Packet_callSiteIndex);
11410     }
11411 
11412     void compileRecordRegExpCachedResult()
11413     {
11414         Edge globalObjectEdge = m_graph.varArgChild(m_node, 0);
11415         Edge regExpEdge = m_graph.varArgChild(m_node, 1);
11416         Edge stringEdge = m_graph.varArgChild(m_node, 2);
11417         Edge startEdge = m_graph.varArgChild(m_node, 3);
11418         Edge endEdge = m_graph.varArgChild(m_node, 4);
11419 
11420         LValue globalObject = lowCell(globalObjectEdge);
11421         LValue regExp = lowCell(regExpEdge);
11422         LValue string = lowCell(stringEdge);
11423         LValue start = lowInt32(startEdge);
11424         LValue end = lowInt32(endEdge);
11425 
11426         m_out.storePtr(regExp, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_lastRegExp);
11427         m_out.storePtr(string, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_lastInput);
11428         m_out.store32(start, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_result_start);
11429         m_out.store32(end, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_result_end);
11430         m_out.store32As8(
11431             m_out.constInt32(0),
11432             m_out.address(globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_reified));
11433     }
11434 
11435     struct ArgumentsLength {
11436         ArgumentsLength()
11437             : isKnown(false)
11438             , known(UINT_MAX)
11439             , value(nullptr)
11440         {
11441         }
11442 
11443         bool isKnown;
11444         unsigned known;
11445         LValue value;
11446     };
11447     ArgumentsLength getArgumentsLength(InlineCallFrame* inlineCallFrame)
11448     {
11449         ArgumentsLength length;
11450 
11451         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
11452             length.known = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
11453             length.isKnown = true;
11454             length.value = m_out.constInt32(length.known);
11455         } else {
11456             length.known = UINT_MAX;
11457             length.isKnown = false;
11458 
11459             VirtualRegister argumentCountRegister;
11460             if (!inlineCallFrame)
11461                 argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
11462             else
11463                 argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
11464             length.value = m_out.sub(m_out.load32(payloadFor(argumentCountRegister)), m_out.int32One);
11465         }
11466 
11467         return length;
11468     }
11469 
11470     ArgumentsLength getArgumentsLength()
11471     {
<a name="102" id="anc102"></a><span class="line-modified">11472         return getArgumentsLength(m_node-&gt;origin.semantic.inlineCallFrame);</span>
11473     }
11474 
11475     LValue getCurrentCallee()
11476     {
<a name="103" id="anc103"></a><span class="line-modified">11477         if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame) {</span>
11478             if (frame-&gt;isClosureCall)
11479                 return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
11480             return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
11481         }
11482         return m_out.loadPtr(addressFor(CallFrameSlot::callee));
11483     }
11484 
11485     LValue getArgumentsStart(InlineCallFrame* inlineCallFrame, unsigned offset = 0)
11486     {
11487         VirtualRegister start = AssemblyHelpers::argumentsStart(inlineCallFrame) + offset;
11488         return addressFor(start).value();
11489     }
11490 
11491     LValue getArgumentsStart()
11492     {
<a name="104" id="anc104"></a><span class="line-modified">11493         return getArgumentsStart(m_node-&gt;origin.semantic.inlineCallFrame);</span>
11494     }
11495 
11496     template&lt;typename Functor&gt;
11497     void checkStructure(
11498         LValue structureDiscriminant, const FormattedValue&amp; formattedValue, ExitKind exitKind,
11499         const RegisteredStructureSet&amp; set, const Functor&amp; weakStructureDiscriminant)
11500     {
11501         if (set.isEmpty()) {
11502             terminate(exitKind);
11503             return;
11504         }
11505 
11506         if (set.size() == 1) {
11507             speculate(
11508                 exitKind, formattedValue, 0,
11509                 m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set[0])));
11510             return;
11511         }
11512 
11513         LBasicBlock continuation = m_out.newBlock();
11514 
11515         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
11516         for (unsigned i = 0; i &lt; set.size() - 1; ++i) {
11517             LBasicBlock nextStructure = m_out.newBlock();
11518             m_out.branch(
11519                 m_out.equal(structureDiscriminant, weakStructureDiscriminant(set[i])),
11520                 unsure(continuation), unsure(nextStructure));
11521             m_out.appendTo(nextStructure);
11522         }
11523 
11524         speculate(
11525             exitKind, formattedValue, 0,
11526             m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set.last())));
11527 
11528         m_out.jump(continuation);
11529         m_out.appendTo(continuation, lastNext);
11530     }
11531 
11532     LValue numberOrNotCellToInt32(Edge edge, LValue value)
11533     {
11534         LBasicBlock intCase = m_out.newBlock();
11535         LBasicBlock notIntCase = m_out.newBlock();
11536         LBasicBlock doubleCase = 0;
11537         LBasicBlock notNumberCase = 0;
11538         if (edge.useKind() == NotCellUse) {
11539             doubleCase = m_out.newBlock();
11540             notNumberCase = m_out.newBlock();
11541         }
11542         LBasicBlock continuation = m_out.newBlock();
11543 
11544         Vector&lt;ValueFromBlock&gt; results;
11545 
11546         m_out.branch(isNotInt32(value), unsure(notIntCase), unsure(intCase));
11547 
11548         LBasicBlock lastNext = m_out.appendTo(intCase, notIntCase);
11549         results.append(m_out.anchor(unboxInt32(value)));
11550         m_out.jump(continuation);
11551 
11552         if (edge.useKind() == NumberUse) {
11553             m_out.appendTo(notIntCase, continuation);
11554             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecBytecodeNumber, isCellOrMisc(value));
11555             results.append(m_out.anchor(doubleToInt32(unboxDouble(value))));
11556             m_out.jump(continuation);
11557         } else {
11558             m_out.appendTo(notIntCase, doubleCase);
11559             m_out.branch(
11560                 isCellOrMisc(value, provenType(edge)), unsure(notNumberCase), unsure(doubleCase));
11561 
11562             m_out.appendTo(doubleCase, notNumberCase);
11563             results.append(m_out.anchor(doubleToInt32(unboxDouble(value))));
11564             m_out.jump(continuation);
11565 
11566             m_out.appendTo(notNumberCase, continuation);
11567 
11568             FTL_TYPE_CHECK(jsValueValue(value), edge, ~SpecCellCheck, isCell(value));
11569 
11570             LValue specialResult = m_out.select(
11571                 m_out.equal(value, m_out.constInt64(JSValue::encode(jsBoolean(true)))),
11572                 m_out.int32One, m_out.int32Zero);
11573             results.append(m_out.anchor(specialResult));
11574             m_out.jump(continuation);
11575         }
11576 
11577         m_out.appendTo(continuation, lastNext);
11578         return m_out.phi(Int32, results);
11579     }
11580 
11581     LValue loadProperty(LValue storage, unsigned identifierNumber, PropertyOffset offset)
11582     {
11583         return m_out.load64(addressOfProperty(storage, identifierNumber, offset));
11584     }
11585 
11586     void storeProperty(
11587         LValue value, LValue storage, unsigned identifierNumber, PropertyOffset offset)
11588     {
11589         m_out.store64(value, addressOfProperty(storage, identifierNumber, offset));
11590     }
11591 
11592     TypedPointer addressOfProperty(
11593         LValue storage, unsigned identifierNumber, PropertyOffset offset)
11594     {
11595         return m_out.address(
11596             m_heaps.properties[identifierNumber], storage, offsetRelativeToBase(offset));
11597     }
11598 
11599     LValue storageForTransition(
11600         LValue object, PropertyOffset offset,
11601         Structure* previousStructure, Structure* nextStructure)
11602     {
11603         if (isInlineOffset(offset))
11604             return object;
11605 
11606         if (previousStructure-&gt;outOfLineCapacity() == nextStructure-&gt;outOfLineCapacity())
11607             return m_out.loadPtr(object, m_heaps.JSObject_butterfly);
11608 
11609         LValue result;
11610         if (!previousStructure-&gt;outOfLineCapacity())
11611             result = allocatePropertyStorage(object, previousStructure);
11612         else {
11613             result = reallocatePropertyStorage(
11614                 object, m_out.loadPtr(object, m_heaps.JSObject_butterfly),
11615                 previousStructure, nextStructure);
11616         }
11617 
11618         nukeStructureAndSetButterfly(result, object);
11619         return result;
11620     }
11621 
11622     void initializeArrayElements(LValue indexingType, LValue begin, LValue end, LValue butterfly)
11623     {
11624 
11625         if (begin == end)
11626             return;
11627 
11628         if (indexingType-&gt;hasInt32()) {
11629             IndexingType rawIndexingType = static_cast&lt;IndexingType&gt;(indexingType-&gt;asInt32());
11630             if (hasUndecided(rawIndexingType))
11631                 return;
11632             IndexedAbstractHeap* heap = m_heaps.forIndexingType(rawIndexingType);
11633             DFG_ASSERT(m_graph, m_node, heap);
11634 
11635             LValue hole;
11636             if (hasDouble(rawIndexingType))
11637                 hole = m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN));
11638             else
11639                 hole = m_out.constInt64(JSValue::encode(JSValue()));
11640 
11641             splatWords(butterfly, begin, end, hole, heap-&gt;atAnyIndex());
11642         } else {
11643             LValue hole = m_out.select(
11644                 m_out.equal(m_out.bitAnd(indexingType, m_out.constInt32(IndexingShapeMask)), m_out.constInt32(DoubleShape)),
11645                 m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN)),
11646                 m_out.constInt64(JSValue::encode(JSValue())));
11647             splatWords(butterfly, begin, end, hole, m_heaps.root);
11648         }
11649     }
11650 
11651     void splatWords(LValue base, LValue begin, LValue end, LValue value, const AbstractHeap&amp; heap)
11652     {
11653         const uint64_t unrollingLimit = 10;
11654         if (begin-&gt;hasInt() &amp;&amp; end-&gt;hasInt()) {
11655             uint64_t beginConst = static_cast&lt;uint64_t&gt;(begin-&gt;asInt());
11656             uint64_t endConst = static_cast&lt;uint64_t&gt;(end-&gt;asInt());
11657 
11658             if (endConst - beginConst &lt;= unrollingLimit) {
11659                 for (uint64_t i = beginConst; i &lt; endConst; ++i) {
11660                     LValue pointer = m_out.add(base, m_out.constIntPtr(i * sizeof(uint64_t)));
11661                     m_out.store64(value, TypedPointer(heap, pointer));
11662                 }
11663                 return;
11664             }
11665         }
11666 
11667         LBasicBlock initLoop = m_out.newBlock();
11668         LBasicBlock initDone = m_out.newBlock();
11669 
11670         LBasicBlock lastNext = m_out.insertNewBlocksBefore(initLoop);
11671 
11672         ValueFromBlock originalIndex = m_out.anchor(end);
11673         ValueFromBlock originalPointer = m_out.anchor(
11674             m_out.add(base, m_out.shl(m_out.signExt32ToPtr(begin), m_out.constInt32(3))));
11675         m_out.branch(m_out.notEqual(end, begin), unsure(initLoop), unsure(initDone));
11676 
11677         m_out.appendTo(initLoop, initDone);
11678         LValue index = m_out.phi(Int32, originalIndex);
11679         LValue pointer = m_out.phi(pointerType(), originalPointer);
11680 
11681         m_out.store64(value, TypedPointer(heap, pointer));
11682 
11683         LValue nextIndex = m_out.sub(index, m_out.int32One);
11684         m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
11685         m_out.addIncomingToPhi(pointer, m_out.anchor(m_out.add(pointer, m_out.intPtrEight)));
11686         m_out.branch(
11687             m_out.notEqual(nextIndex, begin), unsure(initLoop), unsure(initDone));
11688 
11689         m_out.appendTo(initDone, lastNext);
11690     }
11691 
11692     LValue allocatePropertyStorage(LValue object, Structure* previousStructure)
11693     {
11694         if (previousStructure-&gt;couldHaveIndexingHeader()) {
11695             return vmCall(
11696                 pointerType(),
11697                 m_out.operation(operationAllocateComplexPropertyStorageWithInitialCapacity),
11698                 m_callFrame, object);
11699         }
11700 
11701         LValue result = allocatePropertyStorageWithSizeImpl(initialOutOfLineCapacity);
11702 
11703         splatWords(
11704             result,
11705             m_out.constInt32(-initialOutOfLineCapacity - 1), m_out.constInt32(-1),
11706             m_out.int64Zero, m_heaps.properties.atAnyNumber());
11707 
11708         return result;
11709     }
11710 
11711     LValue reallocatePropertyStorage(
11712         LValue object, LValue oldStorage, Structure* previous, Structure* next)
11713     {
11714         size_t oldSize = previous-&gt;outOfLineCapacity();
11715         size_t newSize = oldSize * outOfLineGrowthFactor;
11716 
11717         ASSERT_UNUSED(next, newSize == next-&gt;outOfLineCapacity());
11718 
11719         if (previous-&gt;couldHaveIndexingHeader()) {
11720             LValue newAllocSize = m_out.constIntPtr(newSize);
11721             return vmCall(pointerType(), m_out.operation(operationAllocateComplexPropertyStorage), m_callFrame, object, newAllocSize);
11722         }
11723 
11724         LValue result = allocatePropertyStorageWithSizeImpl(newSize);
11725 
11726         ptrdiff_t headerSize = -sizeof(IndexingHeader) - sizeof(void*);
11727         ptrdiff_t endStorage = headerSize - static_cast&lt;ptrdiff_t&gt;(oldSize * sizeof(JSValue));
11728 
11729         for (ptrdiff_t offset = headerSize; offset &gt; endStorage; offset -= sizeof(void*)) {
11730             LValue loaded =
11731                 m_out.loadPtr(m_out.address(m_heaps.properties.atAnyNumber(), oldStorage, offset));
11732             m_out.storePtr(loaded, m_out.address(m_heaps.properties.atAnyNumber(), result, offset));
11733         }
11734 
11735         splatWords(
11736             result,
11737             m_out.constInt32(-newSize - 1), m_out.constInt32(-oldSize - 1),
11738             m_out.int64Zero, m_heaps.properties.atAnyNumber());
11739 
11740         return result;
11741     }
11742 
11743     LValue allocatePropertyStorageWithSizeImpl(size_t sizeInValues)
11744     {
11745         LBasicBlock slowPath = m_out.newBlock();
11746         LBasicBlock continuation = m_out.newBlock();
11747 
11748         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
11749 
11750         size_t sizeInBytes = sizeInValues * sizeof(JSValue);
11751         Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(sizeInBytes, AllocatorForMode::AllocatorIfExists);
11752         LValue startOfStorage = allocateHeapCell(
11753             m_out.constIntPtr(allocator.localAllocator()), slowPath);
11754         ValueFromBlock fastButterfly = m_out.anchor(
11755             m_out.add(m_out.constIntPtr(sizeInBytes + sizeof(IndexingHeader)), startOfStorage));
11756         m_out.jump(continuation);
11757 
11758         m_out.appendTo(slowPath, continuation);
11759 
11760         LValue slowButterflyValue;
11761         VM&amp; vm = this-&gt;vm();
11762         if (sizeInValues == initialOutOfLineCapacity) {
11763             slowButterflyValue = lazySlowPath(
11764                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11765                     return createLazyCallGenerator(vm,
11766                         operationAllocateSimplePropertyStorageWithInitialCapacity,
11767                         locations[0].directGPR());
11768                 });
11769         } else {
11770             slowButterflyValue = lazySlowPath(
11771                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11772                     return createLazyCallGenerator(vm,
11773                         operationAllocateSimplePropertyStorage, locations[0].directGPR(),
11774                         CCallHelpers::TrustedImmPtr(sizeInValues));
11775                 });
11776         }
11777         ValueFromBlock slowButterfly = m_out.anchor(slowButterflyValue);
11778 
11779         m_out.jump(continuation);
11780 
11781         m_out.appendTo(continuation, lastNext);
11782 
11783         return m_out.phi(pointerType(), fastButterfly, slowButterfly);
11784     }
11785 
11786     LValue getById(LValue base, AccessType type)
11787     {
11788         Node* node = m_node;
11789         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
11790 
11791         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
11792         patchpoint-&gt;appendSomeRegister(base);
11793         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
11794         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
11795 
11796         // FIXME: If this is a GetByIdFlush/GetByIdDirectFlush, we might get some performance boost if we claim that it
11797         // clobbers volatile registers late. It&#39;s not necessary for correctness, though, since the
11798         // IC code is super smart about saving registers.
11799         // https://bugs.webkit.org/show_bug.cgi?id=152848
11800 
11801         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
11802 
11803         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
11804             preparePatchpointForExceptions(patchpoint);
11805 
11806         State* state = &amp;m_ftlState;
11807         patchpoint-&gt;setGenerator(
11808             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
11809                 AllowMacroScratchRegisterUsage allowScratch(jit);
11810 
11811                 CallSiteIndex callSiteIndex =
11812                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
11813 
11814                 // This is the direct exit target for operation calls.
11815                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
11816                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
11817 
11818                 // This is the exit for call IC&#39;s created by the getById for getters. We don&#39;t have
11819                 // to do anything weird other than call this, since it will associate the exit with
11820                 // the callsite index.
11821                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
11822 
11823                 auto generator = Box&lt;JITGetByIdGenerator&gt;::create(
11824                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
11825                     params.unavailableRegisters(), uid, JSValueRegs(params[1].gpr()),
11826                     JSValueRegs(params[0].gpr()), type);
11827 
11828                 generator-&gt;generateFastPath(jit);
11829                 CCallHelpers::Label done = jit.label();
11830 
11831                 params.addLatePath(
11832                     [=] (CCallHelpers&amp; jit) {
11833                         AllowMacroScratchRegisterUsage allowScratch(jit);
11834 
11835                         J_JITOperation_ESsiJI optimizationFunction = appropriateOptimizingGetByIdFunction(type);
11836 
11837                         generator-&gt;slowPathJump().link(&amp;jit);
11838                         CCallHelpers::Label slowPathBegin = jit.label();
11839                         CCallHelpers::Call slowPathCall = callOperation(
11840                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
11841                             exceptions.get(), optimizationFunction, params[0].gpr(),
11842                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
11843                             CCallHelpers::TrustedImmPtr(uid)).call();
11844                         jit.jump().linkTo(done, &amp;jit);
11845 
11846                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
11847 
11848                         jit.addLinkTask(
11849                             [=] (LinkBuffer&amp; linkBuffer) {
11850                                 generator-&gt;finalize(linkBuffer, linkBuffer);
11851                             });
11852                     });
11853             });
11854 
11855         return patchpoint;
11856     }
11857 
11858     LValue getByIdWithThis(LValue base, LValue thisValue)
11859     {
11860         Node* node = m_node;
11861         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
11862 
11863         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
11864         patchpoint-&gt;appendSomeRegister(base);
11865         patchpoint-&gt;appendSomeRegister(thisValue);
11866         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
11867         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
11868 
11869         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
11870 
11871         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
11872             preparePatchpointForExceptions(patchpoint);
11873 
11874         State* state = &amp;m_ftlState;
11875         patchpoint-&gt;setGenerator(
11876             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
11877                 AllowMacroScratchRegisterUsage allowScratch(jit);
11878 
11879                 CallSiteIndex callSiteIndex =
11880                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
11881 
11882                 // This is the direct exit target for operation calls.
11883                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
11884                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
11885 
11886                 // This is the exit for call IC&#39;s created by the getById for getters. We don&#39;t have
11887                 // to do anything weird other than call this, since it will associate the exit with
11888                 // the callsite index.
11889                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
11890 
11891                 auto generator = Box&lt;JITGetByIdWithThisGenerator&gt;::create(
11892                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
11893                     params.unavailableRegisters(), uid, JSValueRegs(params[0].gpr()),
11894                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), AccessType::GetWithThis);
11895 
11896                 generator-&gt;generateFastPath(jit);
11897                 CCallHelpers::Label done = jit.label();
11898 
11899                 params.addLatePath(
11900                     [=] (CCallHelpers&amp; jit) {
11901                         AllowMacroScratchRegisterUsage allowScratch(jit);
11902 
11903                         J_JITOperation_ESsiJJI optimizationFunction = operationGetByIdWithThisOptimize;
11904 
11905                         generator-&gt;slowPathJump().link(&amp;jit);
11906                         CCallHelpers::Label slowPathBegin = jit.label();
11907                         CCallHelpers::Call slowPathCall = callOperation(
11908                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
11909                             exceptions.get(), optimizationFunction, params[0].gpr(),
11910                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
11911                             params[2].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
11912                         jit.jump().linkTo(done, &amp;jit);
11913 
11914                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
11915 
11916                         jit.addLinkTask(
11917                             [=] (LinkBuffer&amp; linkBuffer) {
11918                                 generator-&gt;finalize(linkBuffer, linkBuffer);
11919                             });
11920                     });
11921             });
11922 
11923         return patchpoint;
11924     }
11925 
11926     LValue isFastTypedArray(LValue object)
11927     {
11928         return m_out.equal(
11929             m_out.load32(object, m_heaps.JSArrayBufferView_mode),
11930             m_out.constInt32(FastTypedArray));
11931     }
11932 
11933     TypedPointer baseIndex(IndexedAbstractHeap&amp; heap, LValue storage, LValue index, Edge edge, ptrdiff_t offset = 0)
11934     {
11935         return m_out.baseIndex(
11936             heap, storage, m_out.zeroExtPtr(index), provenValue(edge), offset);
11937     }
11938 
11939     template&lt;typename IntFunctor, typename DoubleFunctor&gt;
11940     void compare(
11941         const IntFunctor&amp; intFunctor, const DoubleFunctor&amp; doubleFunctor,
11942         C_JITOperation_TT stringIdentFunction,
11943         C_JITOperation_B_EJssJss stringFunction,
11944         S_JITOperation_EJJ fallbackFunction)
11945     {
11946         if (m_node-&gt;isBinaryUseKind(Int32Use)) {
11947             LValue left = lowInt32(m_node-&gt;child1());
11948             LValue right = lowInt32(m_node-&gt;child2());
11949             setBoolean(intFunctor(left, right));
11950             return;
11951         }
11952 
11953         if (m_node-&gt;isBinaryUseKind(Int52RepUse)) {
11954             Int52Kind kind;
11955             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
11956             LValue right = lowInt52(m_node-&gt;child2(), kind);
11957             setBoolean(intFunctor(left, right));
11958             return;
11959         }
11960 
11961         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
11962             LValue left = lowDouble(m_node-&gt;child1());
11963             LValue right = lowDouble(m_node-&gt;child2());
11964             setBoolean(doubleFunctor(left, right));
11965             return;
11966         }
11967 
11968         if (m_node-&gt;isBinaryUseKind(StringIdentUse)) {
11969             LValue left = lowStringIdent(m_node-&gt;child1());
11970             LValue right = lowStringIdent(m_node-&gt;child2());
11971             setBoolean(m_out.callWithoutSideEffects(Int32, stringIdentFunction, left, right));
11972             return;
11973         }
11974 
11975         if (m_node-&gt;isBinaryUseKind(StringUse)) {
11976             LValue left = lowCell(m_node-&gt;child1());
11977             LValue right = lowCell(m_node-&gt;child2());
11978             speculateString(m_node-&gt;child1(), left);
11979             speculateString(m_node-&gt;child2(), right);
11980 
11981             LValue result = vmCall(
11982                 Int32, m_out.operation(stringFunction),
11983                 m_callFrame, left, right);
11984             setBoolean(result);
11985             return;
11986         }
11987 
11988         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
11989         nonSpeculativeCompare(intFunctor, fallbackFunction);
11990     }
11991 
11992     void compileStringSlice()
11993     {
11994         LBasicBlock lengthCheckCase = m_out.newBlock();
11995         LBasicBlock emptyCase = m_out.newBlock();
11996         LBasicBlock notEmptyCase = m_out.newBlock();
11997         LBasicBlock oneCharCase = m_out.newBlock();
11998         LBasicBlock is8Bit = m_out.newBlock();
11999         LBasicBlock is16Bit = m_out.newBlock();
12000         LBasicBlock bitsContinuation = m_out.newBlock();
12001         LBasicBlock bigCharacter = m_out.newBlock();
12002         LBasicBlock slowCase = m_out.newBlock();
12003         LBasicBlock ropeSlowCase = m_out.newBlock();
12004         LBasicBlock continuation = m_out.newBlock();
12005 
12006         LValue string = lowString(m_node-&gt;child1());
12007         LValue start = lowInt32(m_node-&gt;child2());
12008         LValue end = nullptr;
12009         if (m_node-&gt;child3())
12010             end = lowInt32(m_node-&gt;child3());
12011         else
12012             end = m_out.constInt32(std::numeric_limits&lt;int32_t&gt;::max());
12013         m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropeSlowCase), usually(lengthCheckCase));
12014 
12015         LBasicBlock lastNext = m_out.appendTo(lengthCheckCase, emptyCase);
12016         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
12017         LValue length = m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length);
12018         auto range = populateSliceRange(start, end, length);
12019         LValue from = range.first;
12020         LValue to = range.second;
12021         LValue span = m_out.sub(to, from);
12022         m_out.branch(m_out.lessThanOrEqual(span, m_out.int32Zero), unsure(emptyCase), unsure(notEmptyCase));
12023 
12024         Vector&lt;ValueFromBlock, 5&gt; results;
12025 
12026         m_out.appendTo(emptyCase, notEmptyCase);
<a name="105" id="anc105"></a><span class="line-modified">12027         results.append(m_out.anchor(weakPointer(jsEmptyString(&amp;vm()))));</span>
12028         m_out.jump(continuation);
12029 
12030         m_out.appendTo(notEmptyCase, oneCharCase);
12031         m_out.branch(m_out.equal(span, m_out.int32One), unsure(oneCharCase), unsure(slowCase));
12032 
12033         m_out.appendTo(oneCharCase, is8Bit);
12034         LValue storage = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
12035         m_out.branch(
12036             m_out.testIsZero32(
12037                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
12038                 m_out.constInt32(StringImpl::flagIs8Bit())),
12039             unsure(is16Bit), unsure(is8Bit));
12040 
12041         m_out.appendTo(is8Bit, is16Bit);
12042         ValueFromBlock char8Bit = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, storage, m_out.zeroExtPtr(from))));
12043         m_out.jump(bitsContinuation);
12044 
12045         m_out.appendTo(is16Bit, bigCharacter);
12046         LValue char16BitValue = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(from)));
12047         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
12048         m_out.branch(
12049             m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
12050             rarely(bigCharacter), usually(bitsContinuation));
12051 
12052         m_out.appendTo(bigCharacter, bitsContinuation);
12053         results.append(m_out.anchor(vmCall(
12054             Int64, m_out.operation(operationSingleCharacterString),
12055             m_callFrame, char16BitValue)));
12056         m_out.jump(continuation);
12057 
12058         m_out.appendTo(bitsContinuation, slowCase);
12059         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
12060         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
12061         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
12062             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
12063         m_out.jump(continuation);
12064 
12065         m_out.appendTo(slowCase, ropeSlowCase);
12066         results.append(m_out.anchor(vmCall(pointerType(), m_out.operation(operationStringSubstr), m_callFrame, string, from, span)));
12067         m_out.jump(continuation);
12068 
12069         m_out.appendTo(ropeSlowCase, continuation);
12070         results.append(m_out.anchor(vmCall(pointerType(), m_out.operation(operationStringSlice), m_callFrame, string, start, end)));
12071         m_out.jump(continuation);
12072 
12073         m_out.appendTo(continuation, lastNext);
12074         setJSValue(m_out.phi(pointerType(), results));
12075     }
12076 
12077     void compileToLowerCase()
12078     {
12079         LBasicBlock notRope = m_out.newBlock();
12080         LBasicBlock is8Bit = m_out.newBlock();
12081         LBasicBlock loopTop = m_out.newBlock();
12082         LBasicBlock loopBody = m_out.newBlock();
12083         LBasicBlock slowPath = m_out.newBlock();
12084         LBasicBlock continuation = m_out.newBlock();
12085 
12086         LValue string = lowString(m_node-&gt;child1());
12087         ValueFromBlock startIndex = m_out.anchor(m_out.constInt32(0));
12088         ValueFromBlock startIndexForCall = m_out.anchor(m_out.constInt32(0));
12089         m_out.branch(isRopeString(string, m_node-&gt;child1()),
12090             unsure(slowPath), unsure(notRope));
12091 
12092         LBasicBlock lastNext = m_out.appendTo(notRope, is8Bit);
12093         LValue impl = m_out.loadPtr(string, m_heaps.JSString_value);
12094         m_out.branch(
12095             m_out.testIsZero32(
12096                 m_out.load32(impl, m_heaps.StringImpl_hashAndFlags),
12097                 m_out.constInt32(StringImpl::flagIs8Bit())),
12098             unsure(slowPath), unsure(is8Bit));
12099 
12100         m_out.appendTo(is8Bit, loopTop);
12101         LValue length = m_out.load32(impl, m_heaps.StringImpl_length);
12102         LValue buffer = m_out.loadPtr(impl, m_heaps.StringImpl_data);
12103         ValueFromBlock fastResult = m_out.anchor(string);
12104         m_out.jump(loopTop);
12105 
12106         m_out.appendTo(loopTop, loopBody);
12107         LValue index = m_out.phi(Int32, startIndex);
12108         ValueFromBlock indexFromBlock = m_out.anchor(index);
12109         m_out.branch(m_out.below(index, length),
12110             unsure(loopBody), unsure(continuation));
12111 
12112         m_out.appendTo(loopBody, slowPath);
12113 
12114         // FIXME: Strings needs to be caged.
12115         // https://bugs.webkit.org/show_bug.cgi?id=174924
12116         LValue byte = m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, buffer, m_out.zeroExtPtr(index)));
12117         LValue isInvalidAsciiRange = m_out.bitAnd(byte, m_out.constInt32(~0x7F));
12118         LValue isUpperCase = m_out.belowOrEqual(m_out.sub(byte, m_out.constInt32(&#39;A&#39;)), m_out.constInt32(&#39;Z&#39; - &#39;A&#39;));
12119         LValue isBadCharacter = m_out.bitOr(isInvalidAsciiRange, isUpperCase);
12120         m_out.addIncomingToPhi(index, m_out.anchor(m_out.add(index, m_out.int32One)));
12121         m_out.branch(isBadCharacter, unsure(slowPath), unsure(loopTop));
12122 
12123         m_out.appendTo(slowPath, continuation);
12124         LValue slowPathIndex = m_out.phi(Int32, startIndexForCall, indexFromBlock);
12125         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_out.operation(operationToLowerCase), m_callFrame, string, slowPathIndex));
12126         m_out.jump(continuation);
12127 
12128         m_out.appendTo(continuation, lastNext);
12129         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
12130     }
12131 
12132     void compileNumberToStringWithRadix()
12133     {
12134         bool validRadixIsGuaranteed = false;
12135         if (m_node-&gt;child2()-&gt;isInt32Constant()) {
12136             int32_t radix = m_node-&gt;child2()-&gt;asInt32();
12137             if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
12138                 validRadixIsGuaranteed = true;
12139         }
12140 
12141         switch (m_node-&gt;child1().useKind()) {
12142         case Int32Use:
12143             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString), m_callFrame, lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
12144             break;
12145         case Int52RepUse:
12146             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString), m_callFrame, lowStrictInt52(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
12147             break;
12148         case DoubleRepUse:
12149             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString), m_callFrame, lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
12150             break;
12151         default:
12152             RELEASE_ASSERT_NOT_REACHED();
12153         }
12154     }
12155 
12156     void compileNumberToStringWithValidRadixConstant()
12157     {
12158         switch (m_node-&gt;child1().useKind()) {
12159         case Int32Use:
12160             setJSValue(vmCall(pointerType(), m_out.operation(operationInt32ToStringWithValidRadix), m_callFrame, lowInt32(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));
12161             break;
12162         case Int52RepUse:
12163             setJSValue(vmCall(pointerType(), m_out.operation(operationInt52ToStringWithValidRadix), m_callFrame, lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));
12164             break;
12165         case DoubleRepUse:
12166             setJSValue(vmCall(pointerType(), m_out.operation(operationDoubleToStringWithValidRadix), m_callFrame, lowDouble(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));
12167             break;
12168         default:
12169             RELEASE_ASSERT_NOT_REACHED();
12170         }
12171     }
12172 
12173     void compileResolveScopeForHoistingFuncDeclInEval()
12174     {
12175         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12176         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScopeForHoistingFuncDeclInEval), m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12177     }
12178 
12179     void compileResolveScope()
12180     {
12181         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12182         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScope),
12183             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12184     }
12185 
12186     void compileGetDynamicVar()
12187     {
12188         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12189         setJSValue(vmCall(Int64, m_out.operation(operationGetDynamicVar),
12190             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12191     }
12192 
12193     void compilePutDynamicVar()
12194     {
12195         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<a name="106" id="anc106"></a><span class="line-modified">12196         setJSValue(vmCall(Void, m_out.operation(operationPutDynamicVar),</span>
12197             m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12198     }
12199 
12200     void compileUnreachable()
12201     {
12202         // It&#39;s so tempting to assert that AI has proved that this is unreachable. But that&#39;s
12203         // simply not a requirement of the Unreachable opcode at all. If you emit an opcode that
12204         // *you* know will not return, then it&#39;s fine to end the basic block with Unreachable
12205         // after that opcode. You don&#39;t have to also prove to AI that your opcode does not return.
12206         // Hence, there is nothing to do here but emit code that will crash, so that we catch
12207         // cases where you said Unreachable but you lied.
12208         //
12209         // It&#39;s also also worth noting that some clients emit this opcode because they&#39;re not 100% sure
12210         // if the code is unreachable, but they would really prefer if we crashed rather than kept going
12211         // if it did turn out to be reachable. Hence, this needs to deterministically crash.
12212 
12213         crash();
12214     }
12215 
12216     void compileCheckSubClass()
12217     {
12218         LValue cell = lowCell(m_node-&gt;child1());
12219 
12220         const ClassInfo* classInfo = m_node-&gt;classInfo();
12221         if (!classInfo-&gt;checkSubClassSnippet) {
12222             LBasicBlock loop = m_out.newBlock();
12223             LBasicBlock parentClass = m_out.newBlock();
12224             LBasicBlock continuation = m_out.newBlock();
12225 
12226             LValue structure = loadStructure(cell);
12227             LValue classInfo = m_out.loadPtr(structure, m_heaps.Structure_classInfo);
12228             ValueFromBlock otherAtStart = m_out.anchor(classInfo);
12229             m_out.jump(loop);
12230 
12231             LBasicBlock lastNext = m_out.appendTo(loop, parentClass);
12232             LValue other = m_out.phi(pointerType(), otherAtStart);
12233             m_out.branch(m_out.equal(other, m_out.constIntPtr(classInfo)), unsure(continuation), unsure(parentClass));
12234 
12235             m_out.appendTo(parentClass, continuation);
12236             LValue parent = m_out.loadPtr(other, m_heaps.ClassInfo_parentClass);
12237             speculate(BadType, jsValueValue(cell), m_node-&gt;child1().node(), m_out.isNull(parent));
12238             m_out.addIncomingToPhi(other, m_out.anchor(parent));
12239             m_out.jump(loop);
12240 
12241             m_out.appendTo(continuation, lastNext);
12242             return;
12243         }
12244 
12245         RefPtr&lt;Snippet&gt; domJIT = classInfo-&gt;checkSubClassSnippet();
12246         PatchpointValue* patchpoint = m_out.patchpoint(Void);
12247         patchpoint-&gt;appendSomeRegister(cell);
12248         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
12249         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
12250 
12251         NodeOrigin origin = m_origin;
12252         unsigned osrExitArgumentOffset = patchpoint-&gt;numChildren();
12253         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(jsValueValue(cell), m_node-&gt;child1().node());
12254         patchpoint-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, jsValueValue(cell)));
12255 
12256         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
12257         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
12258         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12259 
12260         State* state = &amp;m_ftlState;
12261         Node* node = m_node;
12262         JSValue child1Constant = m_state.forNode(m_node-&gt;child1()).value();
12263 
12264         patchpoint-&gt;setGenerator(
12265             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12266                 AllowMacroScratchRegisterUsage allowScratch(jit);
12267 
12268                 Vector&lt;GPRReg&gt; gpScratch;
12269                 Vector&lt;FPRReg&gt; fpScratch;
12270                 Vector&lt;SnippetParams::Value&gt; regs;
12271 
12272                 regs.append(SnippetParams::Value(params[0].gpr(), child1Constant));
12273 
12274                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
12275                     gpScratch.append(params.gpScratch(i));
12276 
12277                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
12278                     fpScratch.append(params.fpScratch(i));
12279 
12280                 RefPtr&lt;OSRExitHandle&gt; handle = exitDescriptor-&gt;emitOSRExitLater(*state, BadType, origin, params, osrExitArgumentOffset);
12281 
12282                 SnippetParams domJITParams(*state, params, node, nullptr, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
12283                 CCallHelpers::JumpList failureCases = domJIT-&gt;generator()-&gt;run(jit, domJITParams);
12284 
12285                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
12286                     linkBuffer.link(failureCases, linkBuffer.locationOf&lt;NoPtrTag&gt;(handle-&gt;label));
12287                 });
12288             });
12289         patchpoint-&gt;effects = Effects::forCheck();
12290     }
12291 
12292     void compileCallDOM()
12293     {
12294         const DOMJIT::Signature* signature = m_node-&gt;signature();
12295 
12296         // FIXME: We should have a way to call functions with the vector of registers.
12297         // https://bugs.webkit.org/show_bug.cgi?id=163099
12298         Vector&lt;LValue, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; operands;
12299 
12300         unsigned index = 0;
12301         DFG_NODE_DO_TO_CHILDREN(m_graph, m_node, [&amp;](Node*, Edge edge) {
12302             if (!index)
12303                 operands.append(lowCell(edge));
12304             else {
12305                 switch (signature-&gt;arguments[index - 1]) {
12306                 case SpecString:
12307                     operands.append(lowString(edge));
12308                     break;
12309                 case SpecInt32Only:
12310                     operands.append(lowInt32(edge));
12311                     break;
12312                 case SpecBoolean:
12313                     operands.append(lowBoolean(edge));
12314                     break;
12315                 default:
12316                     RELEASE_ASSERT_NOT_REACHED();
12317                     break;
12318                 }
12319             }
12320             ++index;
12321         });
12322 
12323         unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
12324         LValue result;
<a name="107" id="anc107"></a><span class="line-modified">12325         assertIsTaggedWith(reinterpret_cast&lt;void*&gt;(signature-&gt;unsafeFunction), CFunctionPtrTag);</span>
12326         switch (argumentCountIncludingThis) {
12327         case 1:
<a name="108" id="anc108"></a><span class="line-modified">12328             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0]);</span>
12329             break;
12330         case 2:
<a name="109" id="anc109"></a><span class="line-modified">12331             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0], operands[1]);</span>
12332             break;
12333         case 3:
<a name="110" id="anc110"></a><span class="line-modified">12334             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0], operands[1], operands[2]);</span>
12335             break;
12336         default:
12337             RELEASE_ASSERT_NOT_REACHED();
12338             break;
12339         }
12340 
12341         setJSValue(result);
12342     }
12343 
12344     void compileCallDOMGetter()
12345     {
12346         DOMJIT::CallDOMGetterSnippet* domJIT = m_node-&gt;callDOMGetterData()-&gt;snippet;
12347         if (!domJIT) {
12348             // The following function is not an operation: we directly call a custom accessor getter.
12349             // Since the getter does not have code setting topCallFrame, As is the same to IC, we should set topCallFrame in caller side.
12350             m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));
12351             setJSValue(
12352                 vmCall(Int64, m_out.operation(m_node-&gt;callDOMGetterData()-&gt;customAccessorGetter.retaggedExecutableAddress&lt;CFunctionPtrTag&gt;()),
12353                     m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;callDOMGetterData()-&gt;identifierNumber])));
12354             return;
12355         }
12356 
12357         Edge&amp; baseEdge = m_node-&gt;child1();
12358         LValue base = lowCell(baseEdge);
12359         JSValue baseConstant = m_state.forNode(baseEdge).value();
12360 
12361         LValue globalObject;
12362         JSValue globalObjectConstant;
12363         if (domJIT-&gt;requireGlobalObject) {
12364             Edge&amp; globalObjectEdge = m_node-&gt;child2();
12365             globalObject = lowCell(globalObjectEdge);
12366             globalObjectConstant = m_state.forNode(globalObjectEdge).value();
12367         }
12368 
12369         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12370         patchpoint-&gt;appendSomeRegister(base);
12371         if (domJIT-&gt;requireGlobalObject)
12372             patchpoint-&gt;appendSomeRegister(globalObject);
12373         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
12374         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
12375         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
12376         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12377         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
12378         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
<a name="111" id="anc111"></a><span class="line-modified">12379         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
12380 
12381         State* state = &amp;m_ftlState;
12382         Node* node = m_node;
12383         patchpoint-&gt;setGenerator(
12384             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12385                 AllowMacroScratchRegisterUsage allowScratch(jit);
12386 
12387                 Vector&lt;GPRReg&gt; gpScratch;
12388                 Vector&lt;FPRReg&gt; fpScratch;
12389                 Vector&lt;SnippetParams::Value&gt; regs;
12390 
12391                 regs.append(JSValueRegs(params[0].gpr()));
12392                 regs.append(SnippetParams::Value(params[1].gpr(), baseConstant));
12393                 if (domJIT-&gt;requireGlobalObject)
12394                     regs.append(SnippetParams::Value(params[2].gpr(), globalObjectConstant));
12395 
12396                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
12397                     gpScratch.append(params.gpScratch(i));
12398 
12399                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
12400                     fpScratch.append(params.fpScratch(i));
12401 
12402                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12403 
12404                 SnippetParams domJITParams(*state, params, node, exceptions, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
12405                 domJIT-&gt;generator()-&gt;run(jit, domJITParams);
12406             });
12407         patchpoint-&gt;effects = Effects::forCall();
12408         setJSValue(patchpoint);
12409     }
12410 
12411     void compileFilterICStatus()
12412     {
12413         m_interpreter.filterICStatus(m_node);
12414     }
12415 
12416     LValue byteSwap32(LValue value)
12417     {
12418         // FIXME: teach B3 byteswap
12419         // https://bugs.webkit.org/show_bug.cgi?id=188759
12420 
12421         RELEASE_ASSERT(value-&gt;type() == Int32);
12422         PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12423         patchpoint-&gt;appendSomeRegister(value);
12424         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12425             jit.move(params[1].gpr(), params[0].gpr());
12426             jit.byteSwap32(params[0].gpr());
12427         });
12428         patchpoint-&gt;effects = Effects::none();
12429         return patchpoint;
12430     }
12431 
12432     LValue byteSwap64(LValue value)
12433     {
12434         // FIXME: teach B3 byteswap
12435         // https://bugs.webkit.org/show_bug.cgi?id=188759
12436 
12437         RELEASE_ASSERT(value-&gt;type() == Int64);
12438         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12439         patchpoint-&gt;appendSomeRegister(value);
12440         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12441             jit.move(params[1].gpr(), params[0].gpr());
12442             jit.byteSwap64(params[0].gpr());
12443         });
12444         patchpoint-&gt;effects = Effects::none();
12445         return patchpoint;
12446     }
12447 
12448     template &lt;typename F1, typename F2&gt;
12449     LValue emitCodeBasedOnEndiannessBranch(LValue isLittleEndian, const F1&amp; emitLittleEndianCode, const F2&amp; emitBigEndianCode)
12450     {
12451         LType type;
12452 
12453         LBasicBlock bigEndianCase = m_out.newBlock();
12454         LBasicBlock littleEndianCase = m_out.newBlock();
12455         LBasicBlock continuation = m_out.newBlock();
12456 
12457         m_out.branch(m_out.testIsZero32(isLittleEndian, m_out.constInt32(1)),
12458             unsure(bigEndianCase), unsure(littleEndianCase));
12459 
12460         LBasicBlock lastNext = m_out.appendTo(bigEndianCase, littleEndianCase);
12461         LValue bigEndianValue = emitBigEndianCode();
12462         type = bigEndianValue ? bigEndianValue-&gt;type() : Void;
12463         ValueFromBlock bigEndianResult = bigEndianValue ? m_out.anchor(bigEndianValue) : ValueFromBlock();
12464         m_out.jump(continuation);
12465 
12466         m_out.appendTo(littleEndianCase, continuation);
12467         LValue littleEndianValue = emitLittleEndianCode();
12468         ValueFromBlock littleEndianResult = littleEndianValue ? m_out.anchor(littleEndianValue) : ValueFromBlock();
12469         RELEASE_ASSERT((!littleEndianValue &amp;&amp; !bigEndianValue) || type == littleEndianValue-&gt;type());
12470         m_out.jump(continuation);
12471 
12472         m_out.appendTo(continuation, lastNext);
12473         RELEASE_ASSERT(!!bigEndianResult == !!littleEndianResult);
12474         if (bigEndianResult)
12475             return m_out.phi(type, bigEndianResult, littleEndianResult);
12476         return nullptr;
12477     }
12478 
12479     void compileDataViewGet()
12480     {
12481         LValue dataView = lowDataViewObject(m_node-&gt;child1());
12482         LValue index = lowInt32(m_node-&gt;child2());
12483         LValue isLittleEndian = nullptr;
12484         if (m_node-&gt;child3())
12485             isLittleEndian = lowBoolean(m_node-&gt;child3());
12486 
12487         DataViewData data = m_node-&gt;dataViewData();
12488 
12489         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
12490         LValue indexToCheck = m_out.zeroExtPtr(index);
12491         if (data.byteSize &gt; 1)
12492             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12493         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12494 
<a name="112" id="anc112"></a><span class="line-modified">12495         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector));</span>
12496 
12497         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12498 
12499         if (m_node-&gt;op() == DataViewGetInt) {
12500             switch (data.byteSize) {
12501             case 1:
12502                 if (data.isSigned)
12503                     setInt32(m_out.load8SignExt32(pointer));
12504                 else
12505                     setInt32(m_out.load8ZeroExt32(pointer));
12506                 break;
12507             case 2: {
12508                 auto emitLittleEndianLoad = [&amp;] {
12509                     if (data.isSigned)
12510                         return m_out.load16SignExt32(pointer);
12511                     return m_out.load16ZeroExt32(pointer);
12512                 };
12513 
12514                 auto emitBigEndianLoad = [&amp;] {
12515                     LValue val = m_out.load16ZeroExt32(pointer);
12516 
12517                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12518                     patchpoint-&gt;appendSomeRegister(val);
12519                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12520                         jit.move(params[1].gpr(), params[0].gpr());
12521                         jit.byteSwap16(params[0].gpr());
12522                         if (data.isSigned)
12523                             jit.signExtend16To32(params[0].gpr(), params[0].gpr());
12524                     });
12525                     patchpoint-&gt;effects = Effects::none();
12526 
12527                     return patchpoint;
12528                 };
12529 
12530                 if (data.isLittleEndian == FalseTriState)
12531                     setInt32(emitBigEndianLoad());
12532                 else if (data.isLittleEndian == TrueTriState)
12533                     setInt32(emitLittleEndianLoad());
12534                 else
12535                     setInt32(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianLoad, emitBigEndianLoad));
12536 
12537                 break;
12538             }
12539             case 4: {
12540                 LValue loadedValue = m_out.load32(pointer);
12541 
12542                 if (data.isLittleEndian == FalseTriState)
12543                     loadedValue = byteSwap32(loadedValue);
12544                 else if (data.isLittleEndian == MixedTriState) {
12545                     auto emitLittleEndianCode = [&amp;] {
12546                         return loadedValue;
12547                     };
12548                     auto emitBigEndianCode = [&amp;] {
12549                         return byteSwap32(loadedValue);
12550                     };
12551 
12552                     loadedValue = emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12553                 }
12554 
12555                 if (data.isSigned)
12556                     setInt32(loadedValue);
12557                 else
12558                     setStrictInt52(m_out.zeroExt(loadedValue, Int64));
12559 
12560                 break;
12561             }
12562             default:
12563                 RELEASE_ASSERT_NOT_REACHED();
12564             }
12565         } else {
12566             switch (data.byteSize) {
12567             case 4: {
12568                 auto emitLittleEndianCode = [&amp;] {
12569                     return m_out.floatToDouble(m_out.loadFloat(pointer));
12570                 };
12571 
12572                 auto emitBigEndianCode = [&amp;] {
12573                     LValue loadedValue = m_out.load32(pointer);
12574                     PatchpointValue* patchpoint = m_out.patchpoint(Double);
12575                     patchpoint-&gt;appendSomeRegister(loadedValue);
12576                     patchpoint-&gt;numGPScratchRegisters = 1;
12577                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12578                         jit.move(params[1].gpr(), params.gpScratch(0));
12579                         jit.byteSwap32(params.gpScratch(0));
12580                         jit.move32ToFloat(params.gpScratch(0), params[0].fpr());
12581                         jit.convertFloatToDouble(params[0].fpr(), params[0].fpr());
12582                     });
12583                     patchpoint-&gt;effects = Effects::none();
12584                     return patchpoint;
12585                 };
12586 
12587                 if (data.isLittleEndian == TrueTriState)
12588                     setDouble(emitLittleEndianCode());
12589                 else if (data.isLittleEndian == FalseTriState)
12590                     setDouble(emitBigEndianCode());
12591                 else
12592                     setDouble(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode));
12593 
12594                 break;
12595             }
12596             case 8: {
12597                 auto emitLittleEndianCode = [&amp;] {
12598                     return m_out.loadDouble(pointer);
12599                 };
12600 
12601                 auto emitBigEndianCode = [&amp;] {
12602                     LValue loadedValue = m_out.load64(pointer);
12603                     loadedValue = byteSwap64(loadedValue);
12604                     return m_out.bitCast(loadedValue, Double);
12605                 };
12606 
12607                 if (data.isLittleEndian == TrueTriState)
12608                     setDouble(emitLittleEndianCode());
12609                 else if (data.isLittleEndian == FalseTriState)
12610                     setDouble(emitBigEndianCode());
12611                 else
12612                     setDouble(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode));
12613 
12614                 break;
12615             }
12616             default:
12617                 RELEASE_ASSERT_NOT_REACHED();
12618             }
12619         }
12620     }
12621 
12622     void compileDataViewSet()
12623     {
12624         LValue dataView = lowDataViewObject(m_graph.varArgChild(m_node, 0));
12625         LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
12626         LValue isLittleEndian = nullptr;
12627         if (m_graph.varArgChild(m_node, 3))
12628             isLittleEndian = lowBoolean(m_graph.varArgChild(m_node, 3));
12629 
12630         DataViewData data = m_node-&gt;dataViewData();
12631 
12632         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
12633         LValue indexToCheck = m_out.zeroExtPtr(index);
12634         if (data.byteSize &gt; 1)
12635             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12636         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12637 
12638         Edge&amp; valueEdge = m_graph.varArgChild(m_node, 2);
12639         LValue valueToStore;
12640         switch (valueEdge.useKind()) {
12641         case Int32Use:
12642             valueToStore = lowInt32(valueEdge);
12643             break;
12644         case DoubleRepUse:
12645             valueToStore = lowDouble(valueEdge);
12646             break;
12647         case Int52RepUse:
12648             valueToStore = lowStrictInt52(valueEdge);
12649             break;
12650         default:
12651             RELEASE_ASSERT_NOT_REACHED();
12652         }
12653 
<a name="113" id="anc113"></a><span class="line-modified">12654         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector));</span>
12655         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12656 
12657         if (data.isFloatingPoint) {
12658             if (data.byteSize == 4) {
12659                 valueToStore = m_out.doubleToFloat(valueToStore);
12660 
12661                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12662                     m_out.storeFloat(valueToStore, pointer);
12663                     return nullptr;
12664                 };
12665 
12666                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12667                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12668                     patchpoint-&gt;appendSomeRegister(valueToStore);
12669                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12670                         jit.moveFloatTo32(params[1].fpr(), params[0].gpr());
12671                         jit.byteSwap32(params[0].gpr());
12672                     });
12673                     patchpoint-&gt;effects = Effects::none();
12674                     m_out.store32(patchpoint, pointer);
12675                     return nullptr;
12676                 };
12677 
12678                 if (data.isLittleEndian == FalseTriState)
12679                     emitBigEndianCode();
12680                 else if (data.isLittleEndian == TrueTriState)
12681                     emitLittleEndianCode();
12682                 else
12683                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12684 
12685             } else {
12686                 RELEASE_ASSERT(data.byteSize == 8);
12687                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12688                     m_out.storeDouble(valueToStore, pointer);
12689                     return nullptr;
12690                 };
12691                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12692                     m_out.store64(byteSwap64(m_out.bitCast(valueToStore, Int64)), pointer);
12693                     return nullptr;
12694                 };
12695 
12696                 if (data.isLittleEndian == FalseTriState)
12697                     emitBigEndianCode();
12698                 else if (data.isLittleEndian == TrueTriState)
12699                     emitLittleEndianCode();
12700                 else
12701                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12702             }
12703         } else {
12704             switch (data.byteSize) {
12705             case 1:
12706                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
12707                 m_out.store32As8(valueToStore, pointer);
12708                 break;
12709             case 2: {
12710                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
12711 
12712                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12713                     m_out.store32As16(valueToStore, pointer);
12714                     return nullptr;
12715                 };
12716                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12717                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12718                     patchpoint-&gt;appendSomeRegister(valueToStore);
12719                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12720                         jit.move(params[1].gpr(), params[0].gpr());
12721                         jit.byteSwap16(params[0].gpr());
12722                     });
12723                     patchpoint-&gt;effects = Effects::none();
12724 
12725                     m_out.store32As16(patchpoint, pointer);
12726                     return nullptr;
12727                 };
12728 
12729                 if (data.isLittleEndian == FalseTriState)
12730                     emitBigEndianCode();
12731                 else if (data.isLittleEndian == TrueTriState)
12732                     emitLittleEndianCode();
12733                 else
12734                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12735                 break;
12736             }
12737             case 4: {
12738                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use || valueEdge.useKind() == Int52RepUse);
12739 
12740                 if (valueEdge.useKind() == Int52RepUse)
12741                     valueToStore = m_out.castToInt32(valueToStore);
12742 
12743                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12744                     m_out.store32(valueToStore, pointer);
12745                     return nullptr;
12746                 };
12747                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12748                     m_out.store32(byteSwap32(valueToStore), pointer);
12749                     return nullptr;
12750                 };
12751 
12752                 if (data.isLittleEndian == FalseTriState)
12753                     emitBigEndianCode();
12754                 else if (data.isLittleEndian == TrueTriState)
12755                     emitLittleEndianCode();
12756                 else
12757                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12758 
12759                 break;
12760             }
12761             default:
12762                 RELEASE_ASSERT_NOT_REACHED();
12763             }
12764         }
12765     }
12766 
12767     void emitSwitchForMultiByOffset(LValue base, bool structuresChecked, Vector&lt;SwitchCase, 2&gt;&amp; cases, LBasicBlock exit)
12768     {
12769         if (cases.isEmpty()) {
12770             m_out.jump(exit);
12771             return;
12772         }
12773 
12774         if (structuresChecked) {
12775             std::sort(
12776                 cases.begin(), cases.end(),
12777                 [&amp;] (const SwitchCase&amp; a, const SwitchCase&amp; b) -&gt; bool {
12778                     return a.value()-&gt;asInt() &lt; b.value()-&gt;asInt();
12779                 });
12780             SwitchCase last = cases.takeLast();
12781             m_out.switchInstruction(
12782                 m_out.load32(base, m_heaps.JSCell_structureID), cases, last.target(), Weight(0));
12783             return;
12784         }
12785 
12786         m_out.switchInstruction(
12787             m_out.load32(base, m_heaps.JSCell_structureID), cases, exit, Weight(0));
12788     }
12789 
12790     void compareEqObjectOrOtherToObject(Edge leftChild, Edge rightChild)
12791     {
12792         LValue rightCell = lowCell(rightChild);
12793         LValue leftValue = lowJSValue(leftChild, ManualOperandSpeculation);
12794 
12795         speculateTruthyObject(rightChild, rightCell, SpecObject);
12796 
12797         LBasicBlock leftCellCase = m_out.newBlock();
12798         LBasicBlock leftNotCellCase = m_out.newBlock();
12799         LBasicBlock continuation = m_out.newBlock();
12800 
12801         m_out.branch(
12802             isCell(leftValue, provenType(leftChild)),
12803             unsure(leftCellCase), unsure(leftNotCellCase));
12804 
12805         LBasicBlock lastNext = m_out.appendTo(leftCellCase, leftNotCellCase);
12806         speculateTruthyObject(leftChild, leftValue, SpecObject | (~SpecCellCheck));
12807         ValueFromBlock cellResult = m_out.anchor(m_out.equal(rightCell, leftValue));
12808         m_out.jump(continuation);
12809 
12810         m_out.appendTo(leftNotCellCase, continuation);
12811         FTL_TYPE_CHECK(
12812             jsValueValue(leftValue), leftChild, SpecOther | SpecCellCheck, isNotOther(leftValue));
12813         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
12814         m_out.jump(continuation);
12815 
12816         m_out.appendTo(continuation, lastNext);
12817         setBoolean(m_out.phi(Int32, cellResult, notCellResult));
12818     }
12819 
12820     void speculateTruthyObject(Edge edge, LValue cell, SpeculatedType filter)
12821     {
12822         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
12823             FTL_TYPE_CHECK(jsValueValue(cell), edge, filter, isNotObject(cell));
12824             return;
12825         }
12826 
12827         FTL_TYPE_CHECK(jsValueValue(cell), edge, filter, isNotObject(cell));
12828         speculate(
12829             BadType, jsValueValue(cell), edge.node(),
12830             m_out.testNonZero32(
12831                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
12832                 m_out.constInt32(MasqueradesAsUndefined)));
12833     }
12834 
12835     template&lt;typename IntFunctor&gt;
12836     void nonSpeculativeCompare(const IntFunctor&amp; intFunctor, S_JITOperation_EJJ helperFunction)
12837     {
12838         LValue left = lowJSValue(m_node-&gt;child1());
12839         LValue right = lowJSValue(m_node-&gt;child2());
12840 
12841         LBasicBlock leftIsInt = m_out.newBlock();
12842         LBasicBlock fastPath = m_out.newBlock();
12843         LBasicBlock slowPath = m_out.newBlock();
12844         LBasicBlock continuation = m_out.newBlock();
12845 
12846         m_out.branch(isNotInt32(left, provenType(m_node-&gt;child1())), rarely(slowPath), usually(leftIsInt));
12847 
12848         LBasicBlock lastNext = m_out.appendTo(leftIsInt, fastPath);
12849         m_out.branch(isNotInt32(right, provenType(m_node-&gt;child2())), rarely(slowPath), usually(fastPath));
12850 
12851         m_out.appendTo(fastPath, slowPath);
12852         ValueFromBlock fastResult = m_out.anchor(intFunctor(unboxInt32(left), unboxInt32(right)));
12853         m_out.jump(continuation);
12854 
12855         m_out.appendTo(slowPath, continuation);
12856         ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
12857             pointerType(), m_out.operation(helperFunction), m_callFrame, left, right)));
12858         m_out.jump(continuation);
12859 
12860         m_out.appendTo(continuation, lastNext);
12861         setBoolean(m_out.phi(Int32, fastResult, slowResult));
12862     }
12863 
12864     LValue stringsEqual(LValue leftJSString, LValue rightJSString, Edge leftJSStringEdge = Edge(), Edge rightJSStringEdge = Edge())
12865     {
12866         LBasicBlock notTriviallyUnequalCase = m_out.newBlock();
12867         LBasicBlock notEmptyCase = m_out.newBlock();
12868         LBasicBlock leftReadyCase = m_out.newBlock();
12869         LBasicBlock rightReadyCase = m_out.newBlock();
12870         LBasicBlock left8BitCase = m_out.newBlock();
12871         LBasicBlock right8BitCase = m_out.newBlock();
12872         LBasicBlock loop = m_out.newBlock();
12873         LBasicBlock bytesEqual = m_out.newBlock();
12874         LBasicBlock trueCase = m_out.newBlock();
12875         LBasicBlock falseCase = m_out.newBlock();
12876         LBasicBlock slowCase = m_out.newBlock();
12877         LBasicBlock continuation = m_out.newBlock();
12878 
12879         m_out.branch(isRopeString(leftJSString, leftJSStringEdge), rarely(slowCase), usually(leftReadyCase));
12880 
12881         LBasicBlock lastNext = m_out.appendTo(leftReadyCase, rightReadyCase);
12882         m_out.branch(isRopeString(rightJSString, rightJSStringEdge), rarely(slowCase), usually(rightReadyCase));
12883 
12884         m_out.appendTo(rightReadyCase, notTriviallyUnequalCase);
12885         LValue left = m_out.loadPtr(leftJSString, m_heaps.JSString_value);
12886         LValue right = m_out.loadPtr(rightJSString, m_heaps.JSString_value);
12887         LValue length = m_out.load32(left, m_heaps.StringImpl_length);
12888         m_out.branch(
12889             m_out.notEqual(length, m_out.load32(right, m_heaps.StringImpl_length)),
12890             unsure(falseCase), unsure(notTriviallyUnequalCase));
12891 
12892         m_out.appendTo(notTriviallyUnequalCase, notEmptyCase);
12893         m_out.branch(m_out.isZero32(length), unsure(trueCase), unsure(notEmptyCase));
12894 
12895         m_out.appendTo(notEmptyCase, left8BitCase);
12896         m_out.branch(
12897             m_out.testIsZero32(
12898                 m_out.load32(left, m_heaps.StringImpl_hashAndFlags),
12899                 m_out.constInt32(StringImpl::flagIs8Bit())),
12900             unsure(slowCase), unsure(left8BitCase));
12901 
12902         m_out.appendTo(left8BitCase, right8BitCase);
12903         m_out.branch(
12904             m_out.testIsZero32(
12905                 m_out.load32(right, m_heaps.StringImpl_hashAndFlags),
12906                 m_out.constInt32(StringImpl::flagIs8Bit())),
12907             unsure(slowCase), unsure(right8BitCase));
12908 
12909         m_out.appendTo(right8BitCase, loop);
12910 
12911         LValue leftData = m_out.loadPtr(left, m_heaps.StringImpl_data);
12912         LValue rightData = m_out.loadPtr(right, m_heaps.StringImpl_data);
12913 
12914         ValueFromBlock indexAtStart = m_out.anchor(length);
12915 
12916         m_out.jump(loop);
12917 
12918         m_out.appendTo(loop, bytesEqual);
12919 
12920         LValue indexAtLoopTop = m_out.phi(Int32, indexAtStart);
12921         LValue indexInLoop = m_out.sub(indexAtLoopTop, m_out.int32One);
12922 
12923         LValue leftByte = m_out.load8ZeroExt32(
12924             m_out.baseIndex(m_heaps.characters8, leftData, m_out.zeroExtPtr(indexInLoop)));
12925         LValue rightByte = m_out.load8ZeroExt32(
12926             m_out.baseIndex(m_heaps.characters8, rightData, m_out.zeroExtPtr(indexInLoop)));
12927 
12928         m_out.branch(m_out.notEqual(leftByte, rightByte), unsure(falseCase), unsure(bytesEqual));
12929 
12930         m_out.appendTo(bytesEqual, trueCase);
12931 
12932         ValueFromBlock indexForNextIteration = m_out.anchor(indexInLoop);
12933         m_out.addIncomingToPhi(indexAtLoopTop, indexForNextIteration);
12934         m_out.branch(m_out.notZero32(indexInLoop), unsure(loop), unsure(trueCase));
12935 
12936         m_out.appendTo(trueCase, falseCase);
12937 
12938         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
12939         m_out.jump(continuation);
12940 
12941         m_out.appendTo(falseCase, slowCase);
12942 
12943         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
12944         m_out.jump(continuation);
12945 
12946         m_out.appendTo(slowCase, continuation);
12947 
12948         LValue slowResultValue = vmCall(
12949             Int64, m_out.operation(operationCompareStringEq), m_callFrame,
12950             leftJSString, rightJSString);
12951         ValueFromBlock slowResult = m_out.anchor(unboxBoolean(slowResultValue));
12952         m_out.jump(continuation);
12953 
12954         m_out.appendTo(continuation, lastNext);
12955         return m_out.phi(Int32, trueResult, falseResult, slowResult);
12956     }
12957 
12958     enum ScratchFPRUsage {
12959         DontNeedScratchFPR,
12960         NeedScratchFPR
12961     };
12962     template&lt;typename BinaryArithOpGenerator, ScratchFPRUsage scratchFPRUsage = DontNeedScratchFPR&gt;
12963     void emitBinarySnippet(J_JITOperation_EJJ slowPathFunction)
12964     {
12965         Node* node = m_node;
12966 
12967         LValue left = lowJSValue(node-&gt;child1());
12968         LValue right = lowJSValue(node-&gt;child2());
12969 
12970         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
12971         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
12972 
12973         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12974         patchpoint-&gt;appendSomeRegister(left);
12975         patchpoint-&gt;appendSomeRegister(right);
12976         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
12977         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
12978         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
12979             preparePatchpointForExceptions(patchpoint);
12980         patchpoint-&gt;numGPScratchRegisters = 1;
12981         patchpoint-&gt;numFPScratchRegisters = 2;
12982         if (scratchFPRUsage == NeedScratchFPR)
12983             patchpoint-&gt;numFPScratchRegisters++;
12984         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<a name="114" id="anc114"></a><span class="line-modified">12985         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
12986         State* state = &amp;m_ftlState;
12987         patchpoint-&gt;setGenerator(
12988             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12989                 AllowMacroScratchRegisterUsage allowScratch(jit);
12990 
12991                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
12992                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12993 
12994                 auto generator = Box&lt;BinaryArithOpGenerator&gt;::create(
12995                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
12996                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
12997                     params.fpScratch(0), params.fpScratch(1), params.gpScratch(0),
12998                     scratchFPRUsage == NeedScratchFPR ? params.fpScratch(2) : InvalidFPRReg);
12999 
13000                 generator-&gt;generateFastPath(jit);
13001 
13002                 if (generator-&gt;didEmitFastPath()) {
13003                     generator-&gt;endJumpList().link(&amp;jit);
13004                     CCallHelpers::Label done = jit.label();
13005 
13006                     params.addLatePath(
13007                         [=] (CCallHelpers&amp; jit) {
13008                             AllowMacroScratchRegisterUsage allowScratch(jit);
13009 
13010                             generator-&gt;slowPathJumpList().link(&amp;jit);
13011                             callOperation(
13012                                 *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13013                                 exceptions.get(), slowPathFunction, params[0].gpr(),
13014                                 params[1].gpr(), params[2].gpr());
13015                             jit.jump().linkTo(done, &amp;jit);
13016                         });
13017                 } else {
13018                     callOperation(
13019                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13020                         exceptions.get(), slowPathFunction, params[0].gpr(), params[1].gpr(),
13021                         params[2].gpr());
13022                 }
13023             });
13024 
13025         setJSValue(patchpoint);
13026     }
13027 
13028     template&lt;typename BinaryBitOpGenerator&gt;
13029     void emitBinaryBitOpSnippet(J_JITOperation_EJJ slowPathFunction)
13030     {
13031         Node* node = m_node;
13032 
13033         LValue left = lowJSValue(node-&gt;child1());
13034         LValue right = lowJSValue(node-&gt;child2());
13035 
13036         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13037         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13038 
13039         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13040         patchpoint-&gt;appendSomeRegister(left);
13041         patchpoint-&gt;appendSomeRegister(right);
13042         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13043         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13044         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13045             preparePatchpointForExceptions(patchpoint);
13046         patchpoint-&gt;numGPScratchRegisters = 1;
13047         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<a name="115" id="anc115"></a><span class="line-modified">13048         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
13049         State* state = &amp;m_ftlState;
13050         patchpoint-&gt;setGenerator(
13051             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13052                 AllowMacroScratchRegisterUsage allowScratch(jit);
13053 
13054                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13055                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13056 
13057                 auto generator = Box&lt;BinaryBitOpGenerator&gt;::create(
13058                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13059                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.gpScratch(0));
13060 
13061                 generator-&gt;generateFastPath(jit);
13062                 generator-&gt;endJumpList().link(&amp;jit);
13063                 CCallHelpers::Label done = jit.label();
13064 
13065                 params.addLatePath(
13066                     [=] (CCallHelpers&amp; jit) {
13067                         AllowMacroScratchRegisterUsage allowScratch(jit);
13068 
13069                         generator-&gt;slowPathJumpList().link(&amp;jit);
13070                         callOperation(
13071                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13072                             exceptions.get(), slowPathFunction, params[0].gpr(),
13073                             params[1].gpr(), params[2].gpr());
13074                         jit.jump().linkTo(done, &amp;jit);
13075                     });
13076             });
13077 
13078         setJSValue(patchpoint);
13079     }
13080 
13081     void emitRightShiftSnippet(JITRightShiftGenerator::ShiftType shiftType)
13082     {
13083         Node* node = m_node;
13084 
13085         // FIXME: Make this do exceptions.
13086         // https://bugs.webkit.org/show_bug.cgi?id=151686
13087 
13088         LValue left = lowJSValue(node-&gt;child1());
13089         LValue right = lowJSValue(node-&gt;child2());
13090 
13091         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13092         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13093 
13094         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13095         patchpoint-&gt;appendSomeRegister(left);
13096         patchpoint-&gt;appendSomeRegister(right);
13097         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13098         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13099         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13100             preparePatchpointForExceptions(patchpoint);
13101         patchpoint-&gt;numGPScratchRegisters = 1;
13102         patchpoint-&gt;numFPScratchRegisters = 1;
13103         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<a name="116" id="anc116"></a><span class="line-modified">13104         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
13105         State* state = &amp;m_ftlState;
13106         patchpoint-&gt;setGenerator(
13107             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13108                 AllowMacroScratchRegisterUsage allowScratch(jit);
13109 
13110                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13111                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13112 
13113                 auto generator = Box&lt;JITRightShiftGenerator&gt;::create(
13114                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13115                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
13116                     params.fpScratch(0), params.gpScratch(0), InvalidFPRReg, shiftType);
13117 
13118                 generator-&gt;generateFastPath(jit);
13119                 generator-&gt;endJumpList().link(&amp;jit);
13120                 CCallHelpers::Label done = jit.label();
13121 
13122                 params.addLatePath(
13123                     [=] (CCallHelpers&amp; jit) {
13124                         AllowMacroScratchRegisterUsage allowScratch(jit);
13125 
13126                         generator-&gt;slowPathJumpList().link(&amp;jit);
13127 
13128                         J_JITOperation_EJJ slowPathFunction =
13129                             shiftType == JITRightShiftGenerator::SignedShift
13130                             ? operationValueBitRShift : operationValueBitURShift;
13131 
13132                         callOperation(
13133                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13134                             exceptions.get(), slowPathFunction, params[0].gpr(),
13135                             params[1].gpr(), params[2].gpr());
13136                         jit.jump().linkTo(done, &amp;jit);
13137                     });
13138             });
13139 
13140         setJSValue(patchpoint);
13141     }
13142 
13143     LValue allocateHeapCell(LValue allocator, LBasicBlock slowPath)
13144     {
13145         JITAllocator actualAllocator;
13146         if (allocator-&gt;hasIntPtr())
13147             actualAllocator = JITAllocator::constant(Allocator(bitwise_cast&lt;LocalAllocator*&gt;(allocator-&gt;asIntPtr())));
13148         else
13149             actualAllocator = JITAllocator::variable();
13150 
13151         if (actualAllocator.isConstant()) {
13152             if (!actualAllocator.allocator()) {
13153                 LBasicBlock haveAllocator = m_out.newBlock();
13154                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(haveAllocator);
13155                 m_out.jump(slowPath);
13156                 m_out.appendTo(haveAllocator, lastNext);
13157                 return m_out.intPtrZero;
13158             }
13159         } else {
13160             // This means that either we know that the allocator is null or we don&#39;t know what the
13161             // allocator is. In either case, we need the null check.
13162             LBasicBlock haveAllocator = m_out.newBlock();
13163             LBasicBlock lastNext = m_out.insertNewBlocksBefore(haveAllocator);
13164             m_out.branch(
13165                 m_out.notEqual(allocator, m_out.intPtrZero),
13166                 usually(haveAllocator), rarely(slowPath));
13167             m_out.appendTo(haveAllocator, lastNext);
13168         }
13169 
13170         LBasicBlock continuation = m_out.newBlock();
13171 
13172         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13173 
13174         PatchpointValue* patchpoint = m_out.patchpoint(pointerType());
13175         if (isARM64()) {
13176             // emitAllocateWithNonNullAllocator uses the scratch registers on ARM.
13177             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13178         }
13179         patchpoint-&gt;effects.terminal = true;
13180         if (actualAllocator.isConstant())
13181             patchpoint-&gt;numGPScratchRegisters++;
13182         else
13183             patchpoint-&gt;appendSomeRegisterWithClobber(allocator);
13184         patchpoint-&gt;numGPScratchRegisters++;
<a name="117" id="anc117"></a><span class="line-modified">13185         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
13186 
13187         m_out.appendSuccessor(usually(continuation));
13188         m_out.appendSuccessor(rarely(slowPath));
13189 
13190         patchpoint-&gt;setGenerator(
13191             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13192                 AllowMacroScratchRegisterUsageIf allowScratchIf(jit, isARM64());
13193                 CCallHelpers::JumpList jumpToSlowPath;
13194 
13195                 GPRReg allocatorGPR;
13196                 if (actualAllocator.isConstant())
13197                     allocatorGPR = params.gpScratch(1);
13198                 else
13199                     allocatorGPR = params[1].gpr();
13200 
13201                 // We use a patchpoint to emit the allocation path because whenever we mess with
13202                 // allocation paths, we already reason about them at the machine code level. We know
13203                 // exactly what instruction sequence we want. We&#39;re confident that no compiler
13204                 // optimization could make this code better. So, it&#39;s best to have the code in
13205                 // AssemblyHelpers::emitAllocate(). That way, the same optimized path is shared by
13206                 // all of the compiler tiers.
13207                 jit.emitAllocateWithNonNullAllocator(
13208                     params[0].gpr(), actualAllocator, allocatorGPR, params.gpScratch(0),
13209                     jumpToSlowPath);
13210 
13211                 CCallHelpers::Jump jumpToSuccess;
13212                 if (!params.fallsThroughToSuccessor(0))
13213                     jumpToSuccess = jit.jump();
13214 
13215                 Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; labels = params.successorLabels();
13216 
13217                 params.addLatePath(
13218                     [=] (CCallHelpers&amp; jit) {
13219                         jumpToSlowPath.linkTo(*labels[1], &amp;jit);
13220                         if (jumpToSuccess.isSet())
13221                             jumpToSuccess.linkTo(*labels[0], &amp;jit);
13222                     });
13223             });
13224 
13225         m_out.appendTo(continuation, lastNext);
13226         return patchpoint;
13227     }
13228 
13229     void storeStructure(LValue object, Structure* structure)
13230     {
13231         m_out.store32(m_out.constInt32(structure-&gt;id()), object, m_heaps.JSCell_structureID);
13232         m_out.store32(
13233             m_out.constInt32(structure-&gt;objectInitializationBlob()),
13234             object, m_heaps.JSCell_usefulBytes);
13235     }
13236 
13237     void storeStructure(LValue object, LValue structure)
13238     {
13239         if (structure-&gt;hasIntPtr()) {
13240             storeStructure(object, bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr()));
13241             return;
13242         }
13243 
13244         LValue id = m_out.load32(structure, m_heaps.Structure_structureID);
13245         m_out.store32(id, object, m_heaps.JSCell_structureID);
13246 
13247         LValue blob = m_out.load32(structure, m_heaps.Structure_indexingModeIncludingHistory);
13248         m_out.store32(blob, object, m_heaps.JSCell_usefulBytes);
13249     }
13250 
13251     template &lt;typename StructureType&gt;
13252     LValue allocateCell(LValue allocator, StructureType structure, LBasicBlock slowPath)
13253     {
13254         LValue result = allocateHeapCell(allocator, slowPath);
13255         storeStructure(result, structure);
13256         return result;
13257     }
13258 
13259     LValue allocateObject(LValue allocator, RegisteredStructure structure, LValue butterfly, LBasicBlock slowPath)
13260     {
13261         return allocateObject(allocator, weakStructure(structure), butterfly, slowPath);
13262     }
13263 
13264     LValue allocateObject(LValue allocator, LValue structure, LValue butterfly, LBasicBlock slowPath)
13265     {
13266         LValue result = allocateCell(allocator, structure, slowPath);
13267         if (structure-&gt;hasIntPtr()) {
13268             splatWords(
13269                 result,
13270                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
13271                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8 + bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;inlineCapacity()),
13272                 m_out.int64Zero,
13273                 m_heaps.properties.atAnyNumber());
13274         } else {
13275             LValue end = m_out.add(
13276                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
13277                 m_out.load8ZeroExt32(structure, m_heaps.Structure_inlineCapacity));
13278             splatWords(
13279                 result,
13280                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
13281                 end,
13282                 m_out.int64Zero,
13283                 m_heaps.properties.atAnyNumber());
13284         }
13285 
13286         m_out.storePtr(butterfly, result, m_heaps.JSObject_butterfly);
13287         return result;
13288     }
13289 
13290     template&lt;typename ClassType, typename StructureType&gt;
13291     LValue allocateObject(
13292         size_t size, StructureType structure, LValue butterfly, LBasicBlock slowPath)
13293     {
13294         Allocator allocator = allocatorForNonVirtualConcurrently&lt;ClassType&gt;(vm(), size, AllocatorForMode::AllocatorIfExists);
13295         return allocateObject(
13296             m_out.constIntPtr(allocator.localAllocator()), structure, butterfly, slowPath);
13297     }
13298 
13299     template&lt;typename ClassType, typename StructureType&gt;
13300     LValue allocateObject(StructureType structure, LValue butterfly, LBasicBlock slowPath)
13301     {
13302         return allocateObject&lt;ClassType&gt;(
13303             ClassType::allocationSize(0), structure, butterfly, slowPath);
13304     }
13305 
13306     LValue allocatorForSize(LValue subspace, LValue size, LBasicBlock slowPath)
13307     {
13308         static_assert(!(MarkedSpace::sizeStep &amp; (MarkedSpace::sizeStep - 1)), &quot;MarkedSpace::sizeStep must be a power of two.&quot;);
13309 
13310         // Try to do some constant-folding here.
13311         if (subspace-&gt;hasIntPtr() &amp;&amp; size-&gt;hasIntPtr()) {
13312             CompleteSubspace* actualSubspace = bitwise_cast&lt;CompleteSubspace*&gt;(subspace-&gt;asIntPtr());
13313             size_t actualSize = size-&gt;asIntPtr();
13314 
13315             Allocator actualAllocator = actualSubspace-&gt;allocatorForNonVirtual(actualSize, AllocatorForMode::AllocatorIfExists);
13316             if (!actualAllocator) {
13317                 LBasicBlock continuation = m_out.newBlock();
13318                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13319                 m_out.jump(slowPath);
13320                 m_out.appendTo(continuation, lastNext);
13321                 return m_out.intPtrZero;
13322             }
13323 
13324             return m_out.constIntPtr(actualAllocator.localAllocator());
13325         }
13326 
13327         unsigned stepShift = getLSBSet(MarkedSpace::sizeStep);
13328 
13329         LBasicBlock continuation = m_out.newBlock();
13330 
13331         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13332 
13333         LValue sizeClassIndex = m_out.lShr(
13334             m_out.add(size, m_out.constIntPtr(MarkedSpace::sizeStep - 1)),
13335             m_out.constInt32(stepShift));
13336 
13337         m_out.branch(
13338             m_out.above(sizeClassIndex, m_out.constIntPtr(MarkedSpace::largeCutoff &gt;&gt; stepShift)),
13339             rarely(slowPath), usually(continuation));
13340 
13341         m_out.appendTo(continuation, lastNext);
13342 
13343         return m_out.loadPtr(
13344             m_out.baseIndex(
13345                 m_heaps.CompleteSubspace_allocatorForSizeStep,
13346                 subspace, sizeClassIndex));
13347     }
13348 
13349     LValue allocatorForSize(CompleteSubspace&amp; subspace, LValue size, LBasicBlock slowPath)
13350     {
13351         return allocatorForSize(m_out.constIntPtr(&amp;subspace), size, slowPath);
13352     }
13353 
13354     template&lt;typename ClassType&gt;
13355     LValue allocateVariableSizedObject(
13356         LValue size, RegisteredStructure structure, LValue butterfly, LBasicBlock slowPath)
13357     {
13358         CompleteSubspace* subspace = subspaceForConcurrently&lt;ClassType&gt;(vm());
13359         RELEASE_ASSERT_WITH_MESSAGE(subspace, &quot;CompleteSubspace is always allocated&quot;);
13360         LValue allocator = allocatorForSize(*subspace, size, slowPath);
13361         return allocateObject(allocator, structure, butterfly, slowPath);
13362     }
13363 
13364     template&lt;typename ClassType&gt;
13365     LValue allocateVariableSizedCell(
13366         LValue size, Structure* structure, LBasicBlock slowPath)
13367     {
13368         CompleteSubspace* subspace = subspaceForConcurrently&lt;ClassType&gt;(vm());
13369         RELEASE_ASSERT_WITH_MESSAGE(subspace, &quot;CompleteSubspace is always allocated&quot;);
13370         LValue allocator = allocatorForSize(*subspace, size, slowPath);
13371         return allocateCell(allocator, structure, slowPath);
13372     }
13373 
13374     LValue allocateObject(RegisteredStructure structure)
13375     {
13376         size_t allocationSize = JSFinalObject::allocationSize(structure.get()-&gt;inlineCapacity());
13377         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
13378 
13379         // FIXME: If the allocator is null, we could simply emit a normal C call to the allocator
13380         // instead of putting it on the slow path.
13381         // https://bugs.webkit.org/show_bug.cgi?id=161062
13382 
13383         LBasicBlock slowPath = m_out.newBlock();
13384         LBasicBlock continuation = m_out.newBlock();
13385 
13386         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
13387 
13388         ValueFromBlock fastResult = m_out.anchor(allocateObject(
13389             m_out.constIntPtr(allocator.localAllocator()), structure, m_out.intPtrZero, slowPath));
13390 
13391         m_out.jump(continuation);
13392 
13393         m_out.appendTo(slowPath, continuation);
13394 
13395         VM&amp; vm = this-&gt;vm();
13396         LValue slowResultValue = lazySlowPath(
13397             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
13398                 return createLazyCallGenerator(vm,
13399                     operationNewObject, locations[0].directGPR(),
13400                     CCallHelpers::TrustedImmPtr(structure.get()));
13401             });
13402         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
13403         m_out.jump(continuation);
13404 
13405         m_out.appendTo(continuation, lastNext);
13406         return m_out.phi(pointerType(), fastResult, slowResult);
13407     }
13408 
13409     struct ArrayValues {
13410         ArrayValues()
13411             : array(0)
13412             , butterfly(0)
13413         {
13414         }
13415 
13416         ArrayValues(LValue array, LValue butterfly)
13417             : array(array)
13418             , butterfly(butterfly)
13419         {
13420         }
13421 
13422         LValue array;
13423         LValue butterfly;
13424     };
13425 
13426     ArrayValues allocateJSArray(LValue publicLength, LValue vectorLength, LValue structure, LValue indexingType, bool shouldInitializeElements = true, bool shouldLargeArraySizeCreateArrayStorage = true)
13427     {
13428         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
13429         if (indexingType-&gt;hasInt32()) {
13430             IndexingType type = static_cast&lt;IndexingType&gt;(indexingType-&gt;asInt32());
13431             ASSERT_UNUSED(type,
13432                 hasUndecided(type)
13433                 || hasInt32(type)
13434                 || hasDouble(type)
13435                 || hasContiguous(type));
13436         }
13437 
13438         LBasicBlock fastCase = m_out.newBlock();
13439         LBasicBlock largeCase = m_out.newBlock();
13440         LBasicBlock failCase = m_out.newBlock();
13441         LBasicBlock continuation = m_out.newBlock();
13442         LBasicBlock slowCase = m_out.newBlock();
13443 
13444         LBasicBlock lastNext = m_out.insertNewBlocksBefore(fastCase);
13445 
13446         Optional&lt;unsigned&gt; staticVectorLength;
13447         Optional&lt;unsigned&gt; staticVectorLengthFromPublicLength;
13448         if (structure-&gt;hasIntPtr()) {
13449             if (publicLength-&gt;hasInt32()) {
13450                 unsigned publicLengthConst = static_cast&lt;unsigned&gt;(publicLength-&gt;asInt32());
13451                 if (publicLengthConst &lt;= MAX_STORAGE_VECTOR_LENGTH) {
13452                     publicLengthConst = Butterfly::optimalContiguousVectorLength(
13453                         bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;outOfLineCapacity(), publicLengthConst);
13454                     staticVectorLengthFromPublicLength = publicLengthConst;
13455                 }
13456 
13457             }
13458             if (vectorLength-&gt;hasInt32()) {
13459                 unsigned vectorLengthConst = static_cast&lt;unsigned&gt;(vectorLength-&gt;asInt32());
13460                 if (vectorLengthConst &lt;= MAX_STORAGE_VECTOR_LENGTH) {
13461                     vectorLengthConst = Butterfly::optimalContiguousVectorLength(
13462                         bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;outOfLineCapacity(), vectorLengthConst);
13463                     vectorLength = m_out.constInt32(vectorLengthConst);
13464                     staticVectorLength = vectorLengthConst;
13465                 }
13466             }
13467         } else {
13468             // We don&#39;t compute the optimal vector length for new Array(blah) where blah is not
13469             // statically known, since the compute effort of doing it here is probably not worth it.
13470         }
13471 
13472         ValueFromBlock noButterfly = m_out.anchor(m_out.intPtrZero);
13473 
13474         LValue predicate;
13475         if (shouldLargeArraySizeCreateArrayStorage)
13476             predicate = m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
13477         else
13478             predicate = m_out.booleanFalse;
13479 
13480         m_out.branch(predicate, rarely(largeCase), usually(fastCase));
13481 
13482         m_out.appendTo(fastCase, largeCase);
13483 
13484         LValue payloadSize =
13485             m_out.shl(m_out.zeroExt(vectorLength, pointerType()), m_out.constIntPtr(3));
13486 
13487         LValue butterflySize = m_out.add(
13488             payloadSize, m_out.constIntPtr(sizeof(IndexingHeader)));
13489 
13490         LValue allocator = allocatorForSize(vm().jsValueGigacageAuxiliarySpace, butterflySize, failCase);
13491         LValue startOfStorage = allocateHeapCell(allocator, failCase);
13492 
13493         LValue butterfly = m_out.add(startOfStorage, m_out.constIntPtr(sizeof(IndexingHeader)));
13494 
13495         m_out.store32(publicLength, butterfly, m_heaps.Butterfly_publicLength);
13496         m_out.store32(vectorLength, butterfly, m_heaps.Butterfly_vectorLength);
13497 
13498         initializeArrayElements(
13499             indexingType,
13500             shouldInitializeElements ? m_out.int32Zero : publicLength, vectorLength,
13501             butterfly);
13502 
13503         ValueFromBlock haveButterfly = m_out.anchor(butterfly);
13504 
13505         LValue object = allocateObject&lt;JSArray&gt;(structure, butterfly, failCase);
13506 
13507         ValueFromBlock fastResult = m_out.anchor(object);
13508         ValueFromBlock fastButterfly = m_out.anchor(butterfly);
13509         m_out.jump(continuation);
13510 
13511         m_out.appendTo(largeCase, failCase);
13512         ValueFromBlock largeStructure = m_out.anchor(
13513             weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))));
13514         m_out.jump(slowCase);
13515 
13516         m_out.appendTo(failCase, slowCase);
13517         ValueFromBlock failStructure = m_out.anchor(structure);
13518         m_out.jump(slowCase);
13519 
13520         m_out.appendTo(slowCase, continuation);
13521         LValue structureValue = m_out.phi(pointerType(), largeStructure, failStructure);
13522         LValue butterflyValue = m_out.phi(pointerType(), noButterfly, haveButterfly);
13523 
13524         VM&amp; vm = this-&gt;vm();
13525         LValue slowResultValue = nullptr;
13526         if (vectorLength == publicLength
13527             || (staticVectorLengthFromPublicLength &amp;&amp; staticVectorLength &amp;&amp; staticVectorLength.value() == staticVectorLengthFromPublicLength.value())) {
13528             slowResultValue = lazySlowPath(
13529                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
13530                     return createLazyCallGenerator(vm,
13531                         operationNewArrayWithSize, locations[0].directGPR(),
13532                         locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR());
13533                 },
13534                 structureValue, publicLength, butterflyValue);
13535         } else {
13536             slowResultValue = lazySlowPath(
13537                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
13538                     return createLazyCallGenerator(vm,
13539                         operationNewArrayWithSizeAndHint, locations[0].directGPR(),
13540                         locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR(), locations[4].directGPR());
13541                 },
13542                 structureValue, publicLength, vectorLength, butterflyValue);
13543         }
13544 
13545         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
13546         ValueFromBlock slowButterfly = m_out.anchor(
13547             m_out.loadPtr(slowResultValue, m_heaps.JSObject_butterfly));
13548         m_out.jump(continuation);
13549 
13550         m_out.appendTo(continuation, lastNext);
13551         return ArrayValues(
13552             m_out.phi(pointerType(), fastResult, slowResult),
13553             m_out.phi(pointerType(), fastButterfly, slowButterfly));
13554     }
13555 
13556     ArrayValues allocateUninitializedContiguousJSArrayInternal(LValue publicLength, LValue vectorLength, RegisteredStructure structure)
13557     {
13558         bool shouldInitializeElements = false;
13559         bool shouldLargeArraySizeCreateArrayStorage = false;
13560         return allocateJSArray(
13561             publicLength, vectorLength, weakStructure(structure), m_out.constInt32(structure-&gt;indexingType()), shouldInitializeElements,
13562             shouldLargeArraySizeCreateArrayStorage);
13563     }
13564 
13565     ArrayValues allocateUninitializedContiguousJSArray(LValue publicLength, RegisteredStructure structure)
13566     {
13567         return allocateUninitializedContiguousJSArrayInternal(publicLength, publicLength, structure);
13568     }
13569 
13570     ArrayValues allocateUninitializedContiguousJSArray(unsigned publicLength, unsigned vectorLength, RegisteredStructure structure)
13571     {
13572         ASSERT(vectorLength &gt;= publicLength);
13573         return allocateUninitializedContiguousJSArrayInternal(m_out.constInt32(publicLength), m_out.constInt32(vectorLength), structure);
13574     }
13575 
13576     LValue ensureShadowChickenPacket()
13577     {
13578         ShadowChicken* shadowChicken = vm().shadowChicken();
13579         RELEASE_ASSERT(shadowChicken);
13580         LBasicBlock slowCase = m_out.newBlock();
13581         LBasicBlock continuation = m_out.newBlock();
13582 
13583         TypedPointer addressOfLogCursor = m_out.absolute(shadowChicken-&gt;addressOfLogCursor());
13584         LValue logCursor = m_out.loadPtr(addressOfLogCursor);
13585 
13586         ValueFromBlock fastResult = m_out.anchor(logCursor);
13587 
13588         m_out.branch(
13589             m_out.below(logCursor, m_out.constIntPtr(shadowChicken-&gt;logEnd())),
13590             usually(continuation), rarely(slowCase));
13591 
13592         LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
13593 
13594         vmCall(Void, m_out.operation(operationProcessShadowChickenLog), m_callFrame);
13595 
13596         ValueFromBlock slowResult = m_out.anchor(m_out.loadPtr(addressOfLogCursor));
13597         m_out.jump(continuation);
13598 
13599         m_out.appendTo(continuation, lastNext);
13600         LValue result = m_out.phi(pointerType(), fastResult, slowResult);
13601 
13602         m_out.storePtr(
13603             m_out.add(result, m_out.constIntPtr(sizeof(ShadowChicken::Packet))),
13604             addressOfLogCursor);
13605 
13606         return result;
13607     }
13608 
13609     LValue boolify(Edge edge)
13610     {
13611         switch (edge.useKind()) {
13612         case BooleanUse:
13613         case KnownBooleanUse:
13614             return lowBoolean(edge);
13615         case Int32Use:
13616             return m_out.notZero32(lowInt32(edge));
13617         case DoubleRepUse:
13618             return m_out.doubleNotEqualAndOrdered(lowDouble(edge), m_out.doubleZero);
13619         case ObjectOrOtherUse:
13620             return m_out.logicalNot(
13621                 equalNullOrUndefined(
13622                     edge, CellCaseSpeculatesObject, SpeculateNullOrUndefined,
13623                     ManualOperandSpeculation));
13624         case StringUse:
<a name="118" id="anc118"></a><span class="line-modified">13625             return m_out.notEqual(lowString(edge), weakPointer(jsEmptyString(&amp;m_graph.m_vm)));</span>
13626         case StringOrOtherUse: {
13627             LValue value = lowJSValue(edge, ManualOperandSpeculation);
13628 
13629             LBasicBlock cellCase = m_out.newBlock();
13630             LBasicBlock notCellCase = m_out.newBlock();
13631             LBasicBlock continuation = m_out.newBlock();
13632 
13633             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13634 
13635             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
13636             FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
<a name="119" id="anc119"></a><span class="line-modified">13637             ValueFromBlock stringResult = m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(&amp;m_graph.m_vm))));</span>
13638             m_out.jump(continuation);
13639 
13640             m_out.appendTo(notCellCase, continuation);
13641             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
13642             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
13643             m_out.jump(continuation);
13644 
13645             m_out.appendTo(continuation, lastNext);
13646             return m_out.phi(Int32, stringResult, notCellResult);
13647         }
13648         case UntypedUse: {
13649             LValue value = lowJSValue(edge);
13650 
13651             // Implements the following control flow structure:
13652             // if (value is cell) {
13653             //     if (value is string or value is BigInt)
13654             //         result = !!value-&gt;length
13655             //     else {
13656             //         do evil things for masquerades-as-undefined
13657             //         result = true
13658             //     }
13659             // } else if (value is int32) {
13660             //     result = !!unboxInt32(value)
13661             // } else if (value is number) {
13662             //     result = !!unboxDouble(value)
13663             // } else {
13664             //     result = value == jsTrue
13665             // }
13666 
13667             LBasicBlock cellCase = m_out.newBlock();
13668             LBasicBlock notStringCase = m_out.newBlock();
13669             LBasicBlock stringCase = m_out.newBlock();
13670             LBasicBlock bigIntCase = m_out.newBlock();
13671             LBasicBlock notStringOrBigIntCase = m_out.newBlock();
13672             LBasicBlock notCellCase = m_out.newBlock();
13673             LBasicBlock int32Case = m_out.newBlock();
13674             LBasicBlock notInt32Case = m_out.newBlock();
13675             LBasicBlock doubleCase = m_out.newBlock();
13676             LBasicBlock notDoubleCase = m_out.newBlock();
13677             LBasicBlock continuation = m_out.newBlock();
13678 
13679             Vector&lt;ValueFromBlock&gt; results;
13680 
13681             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13682 
13683             LBasicBlock lastNext = m_out.appendTo(cellCase, notStringCase);
13684             m_out.branch(
13685                 isString(value, provenType(edge) &amp; SpecCell),
13686                 unsure(stringCase), unsure(notStringCase));
13687 
13688             m_out.appendTo(notStringCase, stringCase);
13689             m_out.branch(
13690                 isBigInt(value, provenType(edge) &amp; (SpecCell - SpecString)),
13691                 unsure(bigIntCase), unsure(notStringOrBigIntCase));
13692 
13693             m_out.appendTo(stringCase, bigIntCase);
<a name="120" id="anc120"></a><span class="line-modified">13694             results.append(m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(&amp;m_graph.m_vm)))));</span>
13695             m_out.jump(continuation);
13696 
13697             m_out.appendTo(bigIntCase, notStringOrBigIntCase);
13698             LValue nonZeroBigInt = m_out.notZero32(
13699                 m_out.load32NonNegative(value, m_heaps.JSBigInt_length));
13700             results.append(m_out.anchor(nonZeroBigInt));
13701             m_out.jump(continuation);
13702 
13703             m_out.appendTo(notStringOrBigIntCase, notCellCase);
13704             LValue isTruthyObject;
13705             if (masqueradesAsUndefinedWatchpointIsStillValid())
13706                 isTruthyObject = m_out.booleanTrue;
13707             else {
13708                 LBasicBlock masqueradesCase = m_out.newBlock();
13709 
13710                 results.append(m_out.anchor(m_out.booleanTrue));
13711 
13712                 m_out.branch(
13713                     m_out.testIsZero32(
13714                         m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
13715                         m_out.constInt32(MasqueradesAsUndefined)),
13716                     usually(continuation), rarely(masqueradesCase));
13717 
13718                 m_out.appendTo(masqueradesCase);
13719 
13720                 isTruthyObject = m_out.notEqual(
13721                     weakPointer(m_graph.globalObjectFor(m_node-&gt;origin.semantic)),
13722                     m_out.loadPtr(loadStructure(value), m_heaps.Structure_globalObject));
13723             }
13724             results.append(m_out.anchor(isTruthyObject));
13725             m_out.jump(continuation);
13726 
13727             m_out.appendTo(notCellCase, int32Case);
13728             m_out.branch(
13729                 isInt32(value, provenType(edge) &amp; ~SpecCell),
13730                 unsure(int32Case), unsure(notInt32Case));
13731 
13732             m_out.appendTo(int32Case, notInt32Case);
13733             results.append(m_out.anchor(m_out.notZero32(unboxInt32(value))));
13734             m_out.jump(continuation);
13735 
13736             m_out.appendTo(notInt32Case, doubleCase);
13737             m_out.branch(
13738                 isNumber(value, provenType(edge) &amp; ~SpecCell),
13739                 unsure(doubleCase), unsure(notDoubleCase));
13740 
13741             m_out.appendTo(doubleCase, notDoubleCase);
13742             LValue doubleIsTruthy = m_out.doubleNotEqualAndOrdered(
13743                 unboxDouble(value), m_out.constDouble(0));
13744             results.append(m_out.anchor(doubleIsTruthy));
13745             m_out.jump(continuation);
13746 
13747             m_out.appendTo(notDoubleCase, continuation);
13748             LValue miscIsTruthy = m_out.equal(
13749                 value, m_out.constInt64(JSValue::encode(jsBoolean(true))));
13750             results.append(m_out.anchor(miscIsTruthy));
13751             m_out.jump(continuation);
13752 
13753             m_out.appendTo(continuation, lastNext);
13754             return m_out.phi(Int32, results);
13755         }
13756         default:
13757             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
13758             return 0;
13759         }
13760     }
13761 
13762     enum StringOrObjectMode {
13763         AllCellsAreFalse,
13764         CellCaseSpeculatesObject
13765     };
13766     enum EqualNullOrUndefinedMode {
13767         EqualNull,
13768         EqualUndefined,
13769         EqualNullOrUndefined,
13770         SpeculateNullOrUndefined
13771     };
13772     LValue equalNullOrUndefined(
13773         Edge edge, StringOrObjectMode cellMode, EqualNullOrUndefinedMode primitiveMode,
13774         OperandSpeculationMode operandMode = AutomaticOperandSpeculation)
13775     {
13776         bool validWatchpoint = masqueradesAsUndefinedWatchpointIsStillValid();
13777 
13778         LValue value = lowJSValue(edge, operandMode);
13779 
13780         LBasicBlock cellCase = m_out.newBlock();
13781         LBasicBlock primitiveCase = m_out.newBlock();
13782         LBasicBlock continuation = m_out.newBlock();
13783 
13784         m_out.branch(isNotCell(value, provenType(edge)), unsure(primitiveCase), unsure(cellCase));
13785 
13786         LBasicBlock lastNext = m_out.appendTo(cellCase, primitiveCase);
13787 
13788         Vector&lt;ValueFromBlock, 3&gt; results;
13789 
13790         switch (cellMode) {
13791         case AllCellsAreFalse:
13792             break;
13793         case CellCaseSpeculatesObject:
13794             FTL_TYPE_CHECK(
13795                 jsValueValue(value), edge, (~SpecCellCheck) | SpecObject, isNotObject(value));
13796             break;
13797         }
13798 
13799         if (validWatchpoint) {
13800             results.append(m_out.anchor(m_out.booleanFalse));
13801             m_out.jump(continuation);
13802         } else {
13803             LBasicBlock masqueradesCase =
13804                 m_out.newBlock();
13805 
13806             results.append(m_out.anchor(m_out.booleanFalse));
13807 
13808             m_out.branch(
13809                 m_out.testNonZero32(
13810                     m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
13811                     m_out.constInt32(MasqueradesAsUndefined)),
13812                 rarely(masqueradesCase), usually(continuation));
13813 
13814             m_out.appendTo(masqueradesCase, primitiveCase);
13815 
13816             LValue structure = loadStructure(value);
13817 
13818             results.append(m_out.anchor(
13819                 m_out.equal(
13820                     weakPointer(m_graph.globalObjectFor(m_node-&gt;origin.semantic)),
13821                     m_out.loadPtr(structure, m_heaps.Structure_globalObject))));
13822             m_out.jump(continuation);
13823         }
13824 
13825         m_out.appendTo(primitiveCase, continuation);
13826 
13827         LValue primitiveResult;
13828         switch (primitiveMode) {
13829         case EqualNull:
13830             primitiveResult = m_out.equal(value, m_out.constInt64(ValueNull));
13831             break;
13832         case EqualUndefined:
13833             primitiveResult = m_out.equal(value, m_out.constInt64(ValueUndefined));
13834             break;
13835         case EqualNullOrUndefined:
13836             primitiveResult = isOther(value, provenType(edge));
13837             break;
13838         case SpeculateNullOrUndefined:
13839             FTL_TYPE_CHECK(
13840                 jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
13841             primitiveResult = m_out.booleanTrue;
13842             break;
13843         }
13844         results.append(m_out.anchor(primitiveResult));
13845         m_out.jump(continuation);
13846 
13847         m_out.appendTo(continuation, lastNext);
13848 
13849         return m_out.phi(Int32, results);
13850     }
13851 
13852     template&lt;typename FunctionType&gt;
13853     void contiguousPutByValOutOfBounds(
13854         FunctionType slowPathFunction, LValue base, LValue storage, LValue index, LValue value,
13855         LBasicBlock continuation)
13856     {
13857         if (!m_node-&gt;arrayMode().isInBounds()) {
13858             LBasicBlock notInBoundsCase =
13859                 m_out.newBlock();
13860             LBasicBlock performStore =
13861                 m_out.newBlock();
13862 
13863             LValue isNotInBounds = m_out.aboveOrEqual(
13864                 index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength));
13865             m_out.branch(isNotInBounds, unsure(notInBoundsCase), unsure(performStore));
13866 
13867             LBasicBlock lastNext = m_out.appendTo(notInBoundsCase, performStore);
13868 
13869             LValue isOutOfBounds = m_out.aboveOrEqual(
13870                 index, m_out.load32NonNegative(storage, m_heaps.Butterfly_vectorLength));
13871 
13872             if (!m_node-&gt;arrayMode().isOutOfBounds())
13873                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
13874             else {
13875                 LBasicBlock outOfBoundsCase =
13876                     m_out.newBlock();
13877                 LBasicBlock holeCase =
13878                     m_out.newBlock();
13879 
13880                 m_out.branch(isOutOfBounds, rarely(outOfBoundsCase), usually(holeCase));
13881 
13882                 LBasicBlock innerLastNext = m_out.appendTo(outOfBoundsCase, holeCase);
13883 
13884                 vmCall(
13885                     Void, m_out.operation(slowPathFunction),
13886                     m_callFrame, base, index, value);
13887 
13888                 m_out.jump(continuation);
13889 
13890                 m_out.appendTo(holeCase, innerLastNext);
13891             }
13892 
13893             m_out.store32(
13894                 m_out.add(index, m_out.int32One),
13895                 storage, m_heaps.Butterfly_publicLength);
13896 
13897             m_out.jump(performStore);
13898             m_out.appendTo(performStore, lastNext);
13899         }
13900     }
13901 
<a name="121" id="anc121"></a><span class="line-modified">13902     LValue caged(Gigacage::Kind kind, LValue ptr)</span>
13903     {
<a name="122" id="anc122"></a>











































13904 #if GIGACAGE_ENABLED
13905         if (!Gigacage::isEnabled(kind))
<a name="123" id="anc123"></a><span class="line-modified">13906             return ptr;</span>
13907 
13908         if (kind == Gigacage::Primitive &amp;&amp; Gigacage::canPrimitiveGigacageBeDisabled()) {
13909             if (vm().primitiveGigacageEnabled().isStillValid())
13910                 m_graph.watchpoints().addLazily(vm().primitiveGigacageEnabled());
13911             else
<a name="124" id="anc124"></a><span class="line-modified">13912                 return ptr;</span>
13913         }
13914 
13915         LValue basePtr = m_out.constIntPtr(Gigacage::basePtr(kind));
13916         LValue mask = m_out.constIntPtr(Gigacage::mask(kind));
13917 
13918         LValue masked = m_out.bitAnd(ptr, mask);
13919         LValue result = m_out.add(masked, basePtr);
13920 
<a name="125" id="anc125"></a>













13921         // Make sure that B3 doesn&#39;t try to do smart reassociation of these pointer bits.
13922         // FIXME: In an ideal world, B3 would not do harmful reassociations, and if it did, it would be able
13923         // to undo them during constant hoisting and regalloc. As it stands, if you remove this then Octane
13924         // gets 1.6% slower and Kraken gets 5% slower. It&#39;s all because the basePtr, which is a constant,
13925         // gets reassociated out of the add above and into the address arithmetic. This disables hoisting of
13926         // the basePtr constant. Hoisting that constant is worth a lot more perf than the reassociation. One
13927         // way to make this all work happily is to combine offset legalization with constant hoisting, and
13928         // then teach it reassociation. So, Add(Add(a, b), const) where a is loop-invariant while b isn&#39;t
13929         // will turn into Add(Add(a, const), b) by the constant hoister. We would have to teach B3 to do this
13930         // and possibly other smart things if we want to be able to remove this opaque.
13931         // https://bugs.webkit.org/show_bug.cgi?id=175493
13932         return m_out.opaque(result);
<a name="126" id="anc126"></a><span class="line-removed">13933 #else</span>
<span class="line-removed">13934         UNUSED_PARAM(kind);</span>
<span class="line-removed">13935         return ptr;</span>
13936 #endif
<a name="127" id="anc127"></a>



13937     }
13938 
13939     void buildSwitch(SwitchData* data, LType type, LValue switchValue)
13940     {
13941         ASSERT(type == pointerType() || type == Int32);
13942 
13943         Vector&lt;SwitchCase&gt; cases;
13944         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
13945             SwitchCase newCase;
13946 
13947             if (type == pointerType()) {
13948                 newCase = SwitchCase(m_out.constIntPtr(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
13949                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
13950             } else if (type == Int32) {
13951                 newCase = SwitchCase(m_out.constInt32(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
13952                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
13953             } else
13954                 CRASH();
13955 
13956             cases.append(newCase);
13957         }
13958 
13959         m_out.switchInstruction(
13960             switchValue, cases,
13961             lowBlock(data-&gt;fallThrough.block), Weight(data-&gt;fallThrough.count));
13962     }
13963 
13964     void switchString(SwitchData* data, LValue string, Edge&amp; edge)
13965     {
13966         bool canDoBinarySwitch = true;
13967         unsigned totalLength = 0;
13968 
13969         for (DFG::SwitchCase myCase : data-&gt;cases) {
13970             StringImpl* string = myCase.value.stringImpl();
13971             if (!string-&gt;is8Bit()) {
13972                 canDoBinarySwitch = false;
13973                 break;
13974             }
13975             if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
13976                 canDoBinarySwitch = false;
13977                 break;
13978             }
13979             totalLength += string-&gt;length();
13980         }
13981 
13982         if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
13983             switchStringSlow(data, string);
13984             return;
13985         }
13986 
13987         LBasicBlock hasImplBlock = m_out.newBlock();
13988         LBasicBlock is8BitBlock = m_out.newBlock();
13989         LBasicBlock slowBlock = m_out.newBlock();
13990 
13991         m_out.branch(isRopeString(string, edge), unsure(slowBlock), unsure(hasImplBlock));
13992 
13993         LBasicBlock lastNext = m_out.appendTo(hasImplBlock, is8BitBlock);
13994 
13995         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
13996         LValue length = m_out.load32(stringImpl, m_heaps.StringImpl_length);
13997 
13998         m_out.branch(
13999             m_out.testIsZero32(
14000                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
14001                 m_out.constInt32(StringImpl::flagIs8Bit())),
14002             unsure(slowBlock), unsure(is8BitBlock));
14003 
14004         m_out.appendTo(is8BitBlock, slowBlock);
14005 
14006         LValue buffer = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
14007 
14008         // FIXME: We should propagate branch weight data to the cases of this switch.
14009         // https://bugs.webkit.org/show_bug.cgi?id=144368
14010 
14011         Vector&lt;StringSwitchCase&gt; cases;
14012         for (DFG::SwitchCase myCase : data-&gt;cases)
14013             cases.append(StringSwitchCase(myCase.value.stringImpl(), lowBlock(myCase.target.block)));
14014         std::sort(cases.begin(), cases.end());
14015         switchStringRecurse(data, buffer, length, cases, 0, 0, cases.size(), 0, false);
14016 
14017         m_out.appendTo(slowBlock, lastNext);
14018         switchStringSlow(data, string);
14019     }
14020 
14021     // The code for string switching is based closely on the same code in the DFG backend. While it
14022     // would be nice to reduce the amount of similar-looking code, it seems like this is one of
14023     // those algorithms where factoring out the common bits would result in more code than just
14024     // duplicating.
14025 
14026     struct StringSwitchCase {
14027         StringSwitchCase() { }
14028 
14029         StringSwitchCase(StringImpl* string, LBasicBlock target)
14030             : string(string)
14031             , target(target)
14032         {
14033         }
14034 
14035         bool operator&lt;(const StringSwitchCase&amp; other) const
14036         {
14037             return stringLessThan(*string, *other.string);
14038         }
14039 
14040         StringImpl* string;
14041         LBasicBlock target;
14042     };
14043 
14044     struct CharacterCase {
14045         CharacterCase()
14046             : character(0)
14047             , begin(0)
14048             , end(0)
14049         {
14050         }
14051 
14052         CharacterCase(LChar character, unsigned begin, unsigned end)
14053             : character(character)
14054             , begin(begin)
14055             , end(end)
14056         {
14057         }
14058 
14059         bool operator&lt;(const CharacterCase&amp; other) const
14060         {
14061             return character &lt; other.character;
14062         }
14063 
14064         LChar character;
14065         unsigned begin;
14066         unsigned end;
14067     };
14068 
14069     void switchStringRecurse(
14070         SwitchData* data, LValue buffer, LValue length, const Vector&lt;StringSwitchCase&gt;&amp; cases,
14071         unsigned numChecked, unsigned begin, unsigned end, unsigned alreadyCheckedLength,
14072         unsigned checkedExactLength)
14073     {
14074         LBasicBlock fallThrough = lowBlock(data-&gt;fallThrough.block);
14075 
14076         if (begin == end) {
14077             m_out.jump(fallThrough);
14078             return;
14079         }
14080 
14081         unsigned minLength = cases[begin].string-&gt;length();
14082         unsigned commonChars = minLength;
14083         bool allLengthsEqual = true;
14084         for (unsigned i = begin + 1; i &lt; end; ++i) {
14085             unsigned myCommonChars = numChecked;
14086             unsigned limit = std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
14087             for (unsigned j = numChecked; j &lt; limit; ++j) {
14088                 if (cases[begin].string-&gt;at(j) != cases[i].string-&gt;at(j))
14089                     break;
14090                 myCommonChars++;
14091             }
14092             commonChars = std::min(commonChars, myCommonChars);
14093             if (minLength != cases[i].string-&gt;length())
14094                 allLengthsEqual = false;
14095             minLength = std::min(minLength, cases[i].string-&gt;length());
14096         }
14097 
14098         if (checkedExactLength) {
14099             DFG_ASSERT(m_graph, m_node, alreadyCheckedLength == minLength, alreadyCheckedLength, minLength);
14100             DFG_ASSERT(m_graph, m_node, allLengthsEqual);
14101         }
14102 
14103         DFG_ASSERT(m_graph, m_node, minLength &gt;= commonChars, minLength, commonChars);
14104 
14105         if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
14106             m_out.check(m_out.below(length, m_out.constInt32(minLength)), unsure(fallThrough));
14107         if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
14108             m_out.check(m_out.notEqual(length, m_out.constInt32(minLength)), unsure(fallThrough));
14109 
14110         for (unsigned i = numChecked; i &lt; commonChars; ++i) {
14111             m_out.check(
14112                 m_out.notEqual(
14113                     m_out.load8ZeroExt32(buffer, m_heaps.characters8[i]),
14114                     m_out.constInt32(static_cast&lt;uint16_t&gt;(cases[begin].string-&gt;at(i)))),
14115                 unsure(fallThrough));
14116         }
14117 
14118         if (minLength == commonChars) {
14119             // This is the case where one of the cases is a prefix of all of the other cases.
14120             // We&#39;ve already checked that the input string is a prefix of all of the cases,
14121             // so we just check length to jump to that case.
14122 
14123             DFG_ASSERT(m_graph, m_node, cases[begin].string-&gt;length() == commonChars, cases[begin].string-&gt;length(), commonChars);
14124             for (unsigned i = begin + 1; i &lt; end; ++i)
14125                 DFG_ASSERT(m_graph, m_node, cases[i].string-&gt;length() &gt; commonChars, cases[i].string-&gt;length(), commonChars);
14126 
14127             if (allLengthsEqual) {
14128                 DFG_ASSERT(m_graph, m_node, end == begin + 1, end, begin);
14129                 m_out.jump(cases[begin].target);
14130                 return;
14131             }
14132 
14133             m_out.check(
14134                 m_out.equal(length, m_out.constInt32(commonChars)),
14135                 unsure(cases[begin].target));
14136 
14137             // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the length is
14138             // == commonChars. We get to this point if it is &gt;= minLength but not == commonChars.
14139             // Hence we know that it now must be &gt; minLength, i.e. that it&#39;s &gt;= minLength + 1.
14140             switchStringRecurse(
14141                 data, buffer, length, cases, commonChars, begin + 1, end, minLength + 1, false);
14142             return;
14143         }
14144 
14145         // At this point we know that the string is longer than commonChars, and we&#39;ve only verified
14146         // commonChars. Use a binary switch on the next unchecked character, i.e.
14147         // string[commonChars].
14148 
14149         DFG_ASSERT(m_graph, m_node, end &gt;= begin + 2, end, begin);
14150 
14151         LValue uncheckedChar = m_out.load8ZeroExt32(buffer, m_heaps.characters8[commonChars]);
14152 
14153         Vector&lt;CharacterCase&gt; characterCases;
14154         CharacterCase currentCase(cases[begin].string-&gt;at(commonChars), begin, begin + 1);
14155         for (unsigned i = begin + 1; i &lt; end; ++i) {
14156             LChar currentChar = cases[i].string-&gt;at(commonChars);
14157             if (currentChar != currentCase.character) {
14158                 currentCase.end = i;
14159                 characterCases.append(currentCase);
14160                 currentCase = CharacterCase(currentChar, i, i + 1);
14161             } else
14162                 currentCase.end = i + 1;
14163         }
14164         characterCases.append(currentCase);
14165 
14166         Vector&lt;LBasicBlock&gt; characterBlocks;
14167         for (unsigned i = characterCases.size(); i--;)
14168             characterBlocks.append(m_out.newBlock());
14169 
14170         Vector&lt;SwitchCase&gt; switchCases;
14171         for (unsigned i = 0; i &lt; characterCases.size(); ++i) {
14172             if (i)
14173                 DFG_ASSERT(m_graph, m_node, characterCases[i - 1].character &lt; characterCases[i].character);
14174             switchCases.append(SwitchCase(
14175                 m_out.constInt32(characterCases[i].character), characterBlocks[i], Weight()));
14176         }
14177         m_out.switchInstruction(uncheckedChar, switchCases, fallThrough, Weight());
14178 
14179         LBasicBlock lastNext = m_out.m_nextBlock;
14180         characterBlocks.append(lastNext); // Makes it convenient to set nextBlock.
14181         for (unsigned i = 0; i &lt; characterCases.size(); ++i) {
14182             m_out.appendTo(characterBlocks[i], characterBlocks[i + 1]);
14183             switchStringRecurse(
14184                 data, buffer, length, cases, commonChars + 1,
14185                 characterCases[i].begin, characterCases[i].end, minLength, allLengthsEqual);
14186         }
14187 
14188         DFG_ASSERT(m_graph, m_node, m_out.m_nextBlock == lastNext);
14189     }
14190 
14191     void switchStringSlow(SwitchData* data, LValue string)
14192     {
14193         // FIXME: We ought to be able to use computed gotos here. We would save the labels of the
14194         // blocks we want to jump to, and then request their addresses after compilation completes.
14195         // https://bugs.webkit.org/show_bug.cgi?id=144369
14196 
14197         LValue branchOffset = vmCall(
14198             Int32, m_out.operation(operationSwitchStringAndGetBranchOffset),
14199             m_callFrame, m_out.constIntPtr(data-&gt;switchTableIndex), string);
14200 
14201         StringJumpTable&amp; table = codeBlock()-&gt;stringSwitchJumpTable(data-&gt;switchTableIndex);
14202 
14203         Vector&lt;SwitchCase&gt; cases;
14204         // These may be negative, or zero, or probably other stuff, too. We don&#39;t want to mess with HashSet&#39;s corner cases and we don&#39;t really care about throughput here.
14205         StdUnorderedSet&lt;int32_t&gt; alreadyHandled;
14206         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
14207             // FIXME: The fact that we&#39;re using the bytecode&#39;s switch table means that the
14208             // following DFG IR transformation would be invalid.
14209             //
14210             // Original code:
14211             //     switch (v) {
14212             //     case &quot;foo&quot;:
14213             //     case &quot;bar&quot;:
14214             //         things();
14215             //         break;
14216             //     default:
14217             //         break;
14218             //     }
14219             //
14220             // New code:
14221             //     switch (v) {
14222             //     case &quot;foo&quot;:
14223             //         instrumentFoo();
14224             //         goto _things;
14225             //     case &quot;bar&quot;:
14226             //         instrumentBar();
14227             //     _things:
14228             //         things();
14229             //         break;
14230             //     default:
14231             //         break;
14232             //     }
14233             //
14234             // Luckily, we don&#39;t currently do any such transformation. But it&#39;s kind of silly that
14235             // this is an issue.
14236             // https://bugs.webkit.org/show_bug.cgi?id=144635
14237 
14238             DFG::SwitchCase myCase = data-&gt;cases[i];
14239             StringJumpTable::StringOffsetTable::iterator iter =
14240                 table.offsetTable.find(myCase.value.stringImpl());
14241             DFG_ASSERT(m_graph, m_node, iter != table.offsetTable.end());
14242 
14243             if (!alreadyHandled.insert(iter-&gt;value.branchOffset).second)
14244                 continue;
14245 
14246             cases.append(SwitchCase(
14247                 m_out.constInt32(iter-&gt;value.branchOffset),
14248                 lowBlock(myCase.target.block), Weight(myCase.target.count)));
14249         }
14250 
14251         m_out.switchInstruction(
14252             branchOffset, cases, lowBlock(data-&gt;fallThrough.block),
14253             Weight(data-&gt;fallThrough.count));
14254     }
14255 
14256     // Calls the functor at the point of code generation where we know what the result type is.
14257     // You can emit whatever code you like at that point. Expects you to terminate the basic block.
14258     // When buildTypeOf() returns, it will have terminated all basic blocks that it created. So, if
14259     // you aren&#39;t using this as the terminator of a high-level block, you should create your own
14260     // contination and set it as the nextBlock (m_out.insertNewBlocksBefore(continuation)) before
14261     // calling this. For example:
14262     //
14263     // LBasicBlock continuation = m_out.newBlock();
14264     // LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
14265     // buildTypeOf(
14266     //     child, value,
14267     //     [&amp;] (TypeofType type) {
14268     //          do things;
14269     //          m_out.jump(continuation);
14270     //     });
14271     // m_out.appendTo(continuation, lastNext);
14272     template&lt;typename Functor&gt;
14273     void buildTypeOf(Edge child, LValue value, const Functor&amp; functor)
14274     {
14275         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
14276 
14277         // Implements the following branching structure:
14278         //
14279         // if (is cell) {
14280         //     if (is object) {
14281         //         if (is function) {
14282         //             return function;
14283         //         } else if (doesn&#39;t have call trap and doesn&#39;t masquerade as undefined) {
14284         //             return object
14285         //         } else {
14286         //             return slowPath();
14287         //         }
14288         //     } else if (is string) {
14289         //         return string
14290         //     } else if (is bigint) {
14291         //         return bigint
14292         //     } else {
14293         //         return symbol
14294         //     }
14295         // } else if (is number) {
14296         //     return number
14297         // } else if (is null) {
14298         //     return object
14299         // } else if (is boolean) {
14300         //     return boolean
14301         // } else {
14302         //     return undefined
14303         // }
14304         //
14305         // FIXME: typeof Symbol should be more frequently seen than BigInt.
14306         // We should change the order of type detection based on this frequency.
14307         // https://bugs.webkit.org/show_bug.cgi?id=192650
14308 
14309         LBasicBlock cellCase = m_out.newBlock();
14310         LBasicBlock objectCase = m_out.newBlock();
14311         LBasicBlock functionCase = m_out.newBlock();
14312         LBasicBlock notFunctionCase = m_out.newBlock();
14313         LBasicBlock reallyObjectCase = m_out.newBlock();
14314         LBasicBlock slowPath = m_out.newBlock();
14315         LBasicBlock unreachable = m_out.newBlock();
14316         LBasicBlock notObjectCase = m_out.newBlock();
14317         LBasicBlock stringCase = m_out.newBlock();
14318         LBasicBlock notStringCase = m_out.newBlock();
14319         LBasicBlock bigIntCase = m_out.newBlock();
14320         LBasicBlock symbolCase = m_out.newBlock();
14321         LBasicBlock notCellCase = m_out.newBlock();
14322         LBasicBlock numberCase = m_out.newBlock();
14323         LBasicBlock notNumberCase = m_out.newBlock();
14324         LBasicBlock notNullCase = m_out.newBlock();
14325         LBasicBlock booleanCase = m_out.newBlock();
14326         LBasicBlock undefinedCase = m_out.newBlock();
14327 
14328         m_out.branch(isCell(value, provenType(child)), unsure(cellCase), unsure(notCellCase));
14329 
14330         LBasicBlock lastNext = m_out.appendTo(cellCase, objectCase);
14331         m_out.branch(isObject(value, provenType(child)), unsure(objectCase), unsure(notObjectCase));
14332 
14333         m_out.appendTo(objectCase, functionCase);
14334         m_out.branch(
14335             isFunction(value, provenType(child) &amp; SpecObject),
14336             unsure(functionCase), unsure(notFunctionCase));
14337 
14338         m_out.appendTo(functionCase, notFunctionCase);
14339         functor(TypeofType::Function);
14340 
14341         m_out.appendTo(notFunctionCase, reallyObjectCase);
14342         m_out.branch(
14343             isExoticForTypeof(value, provenType(child) &amp; (SpecObject - SpecFunction)),
14344             rarely(slowPath), usually(reallyObjectCase));
14345 
14346         m_out.appendTo(reallyObjectCase, slowPath);
14347         functor(TypeofType::Object);
14348 
14349         m_out.appendTo(slowPath, unreachable);
14350         VM&amp; vm = this-&gt;vm();
14351         LValue result = lazySlowPath(
14352             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14353                 return createLazyCallGenerator(vm,
14354                     operationTypeOfObjectAsTypeofType, locations[0].directGPR(),
14355                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
14356             }, value);
14357         Vector&lt;SwitchCase, 3&gt; cases;
14358         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Undefined)), undefinedCase));
14359         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Object)), reallyObjectCase));
14360         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Function)), functionCase));
14361         m_out.switchInstruction(m_out.castToInt32(result), cases, unreachable, Weight());
14362 
14363         m_out.appendTo(unreachable, notObjectCase);
14364         m_out.unreachable();
14365 
14366         m_out.appendTo(notObjectCase, stringCase);
14367         m_out.branch(
14368             isString(value, provenType(child) &amp; (SpecCell - SpecObject)),
14369             unsure(stringCase), unsure(notStringCase));
14370 
14371         m_out.appendTo(stringCase, notStringCase);
14372         functor(TypeofType::String);
14373 
14374         m_out.appendTo(notStringCase, bigIntCase);
14375         m_out.branch(
14376             isBigInt(value, provenType(child) &amp; (SpecCell - SpecObject - SpecString)),
14377             unsure(bigIntCase), unsure(symbolCase));
14378 
14379         m_out.appendTo(bigIntCase, symbolCase);
14380         functor(TypeofType::BigInt);
14381 
14382         m_out.appendTo(symbolCase, notCellCase);
14383         functor(TypeofType::Symbol);
14384 
14385         m_out.appendTo(notCellCase, numberCase);
14386         m_out.branch(
14387             isNumber(value, provenType(child) &amp; ~SpecCell),
14388             unsure(numberCase), unsure(notNumberCase));
14389 
14390         m_out.appendTo(numberCase, notNumberCase);
14391         functor(TypeofType::Number);
14392 
14393         m_out.appendTo(notNumberCase, notNullCase);
14394         LValue isNull;
14395         if (provenType(child) &amp; SpecOther)
14396             isNull = m_out.equal(value, m_out.constInt64(ValueNull));
14397         else
14398             isNull = m_out.booleanFalse;
14399         m_out.branch(isNull, unsure(reallyObjectCase), unsure(notNullCase));
14400 
14401         m_out.appendTo(notNullCase, booleanCase);
14402         m_out.branch(
14403             isBoolean(value, provenType(child) &amp; ~(SpecCell | SpecFullNumber)),
14404             unsure(booleanCase), unsure(undefinedCase));
14405 
14406         m_out.appendTo(booleanCase, undefinedCase);
14407         functor(TypeofType::Boolean);
14408 
14409         m_out.appendTo(undefinedCase, lastNext);
14410         functor(TypeofType::Undefined);
14411     }
14412 
14413     TypedPointer pointerIntoTypedArray(LValue storage, LValue index, TypedArrayType type)
14414     {
14415         LValue offset = m_out.shl(m_out.zeroExtPtr(index), m_out.constIntPtr(logElementSize(type)));
14416 
14417         return TypedPointer(
14418             m_heaps.typedArrayProperties,
14419             m_out.add(
14420                 storage,
14421                 offset
14422             ));
14423     }
14424 
14425     LValue loadFromIntTypedArray(TypedPointer pointer, TypedArrayType type)
14426     {
14427         switch (elementSize(type)) {
14428         case 1:
14429             return isSigned(type) ? m_out.load8SignExt32(pointer) : m_out.load8ZeroExt32(pointer);
14430         case 2:
14431             return isSigned(type) ? m_out.load16SignExt32(pointer) : m_out.load16ZeroExt32(pointer);
14432         case 4:
14433             return m_out.load32(pointer);
14434         default:
14435             DFG_CRASH(m_graph, m_node, &quot;Bad element size&quot;);
14436         }
14437     }
14438 
14439     Output::StoreType storeType(TypedArrayType type)
14440     {
14441         if (isInt(type)) {
14442             switch (elementSize(type)) {
14443             case 1:
14444                 return Output::Store32As8;
14445             case 2:
14446                 return Output::Store32As16;
14447             case 4:
14448                 return Output::Store32;
14449             default:
14450                 DFG_CRASH(m_graph, m_node, &quot;Bad element size&quot;);
14451                 return Output::Store32;
14452             }
14453         }
14454         switch (type) {
14455         case TypeFloat32:
14456             return Output::StoreFloat;
14457         case TypeFloat64:
14458             return Output::StoreDouble;
14459         default:
14460             DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
14461         }
14462     }
14463 
14464     void setIntTypedArrayLoadResult(LValue result, TypedArrayType type, bool canSpeculate = false)
14465     {
14466         if (elementSize(type) &lt; 4 || isSigned(type)) {
14467             setInt32(result);
14468             return;
14469         }
14470 
14471         if (m_node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
14472             speculate(
14473                 Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
14474             setInt32(result);
14475             return;
14476         }
14477 
<a name="128" id="anc128"></a><span class="line-modified">14478         if (m_node-&gt;shouldSpeculateAnyInt()) {</span>
14479             setStrictInt52(m_out.zeroExt(result, Int64));
14480             return;
14481         }
14482 
14483         setDouble(m_out.unsignedToDouble(result));
14484     }
14485 
14486     LValue getIntTypedArrayStoreOperand(Edge edge, bool isClamped = false)
14487     {
14488         LValue intValue;
14489         switch (edge.useKind()) {
14490         case Int52RepUse:
14491         case Int32Use: {
14492             if (edge.useKind() == Int32Use)
14493                 intValue = lowInt32(edge);
14494             else
14495                 intValue = m_out.castToInt32(lowStrictInt52(edge));
14496 
14497             if (isClamped) {
14498                 LBasicBlock atLeastZero = m_out.newBlock();
14499                 LBasicBlock continuation = m_out.newBlock();
14500 
14501                 Vector&lt;ValueFromBlock, 2&gt; intValues;
14502                 intValues.append(m_out.anchor(m_out.int32Zero));
14503                 m_out.branch(
14504                     m_out.lessThan(intValue, m_out.int32Zero),
14505                     unsure(continuation), unsure(atLeastZero));
14506 
14507                 LBasicBlock lastNext = m_out.appendTo(atLeastZero, continuation);
14508 
14509                 intValues.append(m_out.anchor(m_out.select(
14510                     m_out.greaterThan(intValue, m_out.constInt32(255)),
14511                     m_out.constInt32(255),
14512                     intValue)));
14513                 m_out.jump(continuation);
14514 
14515                 m_out.appendTo(continuation, lastNext);
14516                 intValue = m_out.phi(Int32, intValues);
14517             }
14518             break;
14519         }
14520 
14521         case DoubleRepUse: {
14522             LValue doubleValue = lowDouble(edge);
14523 
14524             if (isClamped) {
14525                 LBasicBlock atLeastZero = m_out.newBlock();
14526                 LBasicBlock withinRange = m_out.newBlock();
14527                 LBasicBlock continuation = m_out.newBlock();
14528 
14529                 Vector&lt;ValueFromBlock, 3&gt; intValues;
14530                 intValues.append(m_out.anchor(m_out.int32Zero));
14531                 m_out.branch(
14532                     m_out.doubleLessThanOrUnordered(doubleValue, m_out.doubleZero),
14533                     unsure(continuation), unsure(atLeastZero));
14534 
14535                 LBasicBlock lastNext = m_out.appendTo(atLeastZero, withinRange);
14536                 intValues.append(m_out.anchor(m_out.constInt32(255)));
14537                 m_out.branch(
14538                     m_out.doubleGreaterThan(doubleValue, m_out.constDouble(255)),
14539                     unsure(continuation), unsure(withinRange));
14540 
14541                 m_out.appendTo(withinRange, continuation);
14542                 intValues.append(m_out.anchor(m_out.doubleToInt(doubleValue)));
14543                 m_out.jump(continuation);
14544 
14545                 m_out.appendTo(continuation, lastNext);
14546                 intValue = m_out.phi(Int32, intValues);
14547             } else
14548                 intValue = doubleToInt32(doubleValue);
14549             break;
14550         }
14551 
14552         default:
14553             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
14554         }
14555 
14556         return intValue;
14557     }
14558 
14559     LValue doubleToInt32(LValue doubleValue, double low, double high, bool isSigned = true)
14560     {
14561         LBasicBlock greatEnough = m_out.newBlock();
14562         LBasicBlock withinRange = m_out.newBlock();
14563         LBasicBlock slowPath = m_out.newBlock();
14564         LBasicBlock continuation = m_out.newBlock();
14565 
14566         Vector&lt;ValueFromBlock, 2&gt; results;
14567 
14568         m_out.branch(
14569             m_out.doubleGreaterThanOrEqual(doubleValue, m_out.constDouble(low)),
14570             unsure(greatEnough), unsure(slowPath));
14571 
14572         LBasicBlock lastNext = m_out.appendTo(greatEnough, withinRange);
14573         m_out.branch(
14574             m_out.doubleLessThanOrEqual(doubleValue, m_out.constDouble(high)),
14575             unsure(withinRange), unsure(slowPath));
14576 
14577         m_out.appendTo(withinRange, slowPath);
14578         LValue fastResult;
14579         if (isSigned)
14580             fastResult = m_out.doubleToInt(doubleValue);
14581         else
14582             fastResult = m_out.doubleToUInt(doubleValue);
14583         results.append(m_out.anchor(fastResult));
14584         m_out.jump(continuation);
14585 
14586         m_out.appendTo(slowPath, continuation);
14587         results.append(m_out.anchor(m_out.call(Int32, m_out.operation(operationToInt32), doubleValue)));
14588         m_out.jump(continuation);
14589 
14590         m_out.appendTo(continuation, lastNext);
14591         return m_out.phi(Int32, results);
14592     }
14593 
14594     LValue doubleToInt32(LValue doubleValue)
14595     {
14596 #if CPU(ARM64)
14597         if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics()) {
14598             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
14599             patchpoint-&gt;append(ConstrainedValue(doubleValue, B3::ValueRep::SomeRegister));
14600             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14601                 jit.convertDoubleToInt32UsingJavaScriptSemantics(params[1].fpr(), params[0].gpr());
14602             });
14603             patchpoint-&gt;effects = Effects::none();
14604             return patchpoint;
14605         }
14606 #endif
14607 
14608         if (hasSensibleDoubleToInt())
14609             return sensibleDoubleToInt32(doubleValue);
14610 
14611         double limit = pow(2, 31) - 1;
14612         return doubleToInt32(doubleValue, -limit, limit);
14613     }
14614 
14615     LValue sensibleDoubleToInt32(LValue doubleValue)
14616     {
14617         LBasicBlock slowPath = m_out.newBlock();
14618         LBasicBlock continuation = m_out.newBlock();
14619 
14620         LValue fastResultValue = m_out.doubleToInt(doubleValue);
14621         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
14622         m_out.branch(
14623             m_out.equal(fastResultValue, m_out.constInt32(0x80000000)),
14624             rarely(slowPath), usually(continuation));
14625 
14626         LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
14627         ValueFromBlock slowResult = m_out.anchor(
14628             m_out.call(Int32, m_out.operation(operationToInt32SensibleSlow), doubleValue));
14629         m_out.jump(continuation);
14630 
14631         m_out.appendTo(continuation, lastNext);
14632         return m_out.phi(Int32, fastResult, slowResult);
14633     }
14634 
14635     // This is a mechanism for creating a code generator that fills in a gap in the code using our
14636     // own MacroAssembler. This is useful for slow paths that involve a lot of code and we don&#39;t want
14637     // to pay the price of B3 optimizing it. A lazy slow path will only be generated if it actually
14638     // executes. On the other hand, a lazy slow path always incurs the cost of two additional jumps.
14639     // Also, the lazy slow path&#39;s register allocation state is slaved to whatever B3 did, so you
14640     // have to use a ScratchRegisterAllocator to try to use some unused registers and you may have
14641     // to spill to top of stack if there aren&#39;t enough registers available.
14642     //
14643     // Lazy slow paths involve three different stages of execution. Each stage has unique
14644     // capabilities and knowledge. The stages are:
14645     //
14646     // 1) DFG-&gt;B3 lowering, i.e. code that runs in this phase. Lowering is the last time you will
14647     //    have access to LValues. If there is an LValue that needs to be fed as input to a lazy slow
14648     //    path, then you must pass it as an argument here (as one of the varargs arguments after the
14649     //    functor). But, lowering doesn&#39;t know which registers will be used for those LValues. Hence
14650     //    you pass a lambda to lazySlowPath() and that lambda will run during stage (2):
14651     //
14652     // 2) FTLCompile.cpp&#39;s fixFunctionBasedOnStackMaps. This code is the only stage at which we know
14653     //    the mapping from arguments passed to this method in (1) and the registers that B3
14654     //    selected for those arguments. You don&#39;t actually want to generate any code here, since then
14655     //    the slow path wouldn&#39;t actually be lazily generated. Instead, you want to save the
14656     //    registers being used for the arguments and defer code generation to stage (3) by creating
14657     //    and returning a LazySlowPath::Generator:
14658     //
14659     // 3) LazySlowPath&#39;s generate() method. This code runs in response to the lazy slow path
14660     //    executing for the first time. It will call the generator you created in stage (2).
14661     //
14662     // Note that each time you invoke stage (1), stage (2) may be invoked zero, one, or many times.
14663     // Stage (2) will usually be invoked once for stage (1). But, B3 may kill the code, in which
14664     // case stage (2) won&#39;t run. B3 may duplicate the code (for example via tail duplication),
14665     // leading to many calls to your stage (2) lambda. Stage (3) may be called zero or once for each
14666     // stage (2). It will be called zero times if the slow path never runs. This is what you hope for
14667     // whenever you use the lazySlowPath() mechanism.
14668     //
14669     // A typical use of lazySlowPath() will look like the example below, which just creates a slow
14670     // path that adds some value to the input and returns it.
14671     //
14672     // // Stage (1) is here. This is your last chance to figure out which LValues to use as inputs.
14673     // // Notice how we pass &quot;input&quot; as an argument to lazySlowPath().
14674     // LValue input = ...;
14675     // int addend = ...;
14676     // LValue output = lazySlowPath(
14677     //     [=] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14678     //         // Stage (2) is here. This is your last chance to figure out which registers are used
14679     //         // for which values. Location zero is always the return value. You can ignore it if
14680     //         // you don&#39;t want to return anything. Location 1 is the register for the first
14681     //         // argument to the lazySlowPath(), i.e. &quot;input&quot;. Note that the Location object could
14682     //         // also hold an FPR, if you are passing a double.
14683     //         GPRReg outputGPR = locations[0].directGPR();
14684     //         GPRReg inputGPR = locations[1].directGPR();
14685     //         return LazySlowPath::createGenerator(
14686     //             [=] (CCallHelpers&amp; jit, LazySlowPath::GenerationParams&amp; params) {
14687     //                 // Stage (3) is here. This is when you generate code. You have access to the
14688     //                 // registers you collected in stage (2) because this lambda closes over those
14689     //                 // variables (outputGPR and inputGPR). You also have access to whatever extra
14690     //                 // data you collected in stage (1), such as the addend in this case.
14691     //                 jit.add32(TrustedImm32(addend), inputGPR, outputGPR);
14692     //                 // You have to end by jumping to done. There is nothing to fall through to.
14693     //                 // You can also jump to the exception handler (see LazySlowPath.h for more
14694     //                 // info). Note that currently you cannot OSR exit.
14695     //                 params.doneJumps.append(jit.jump());
14696     //             });
14697     //     },
14698     //     input);
14699     //
14700     // You can basically pass as many inputs as you like, either using this varargs form, or by
14701     // passing a Vector of LValues.
14702     //
14703     // Note that if your slow path is only doing a call, you can use the createLazyCallGenerator()
14704     // helper. For example:
14705     //
14706     // LValue input = ...;
14707     // LValue output = lazySlowPath(
14708     //     [=] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14709     //         return createLazyCallGenerator(
14710     //             operationDoThings, locations[0].directGPR(), locations[1].directGPR());
14711     //     }, input);
14712     //
14713     // Finally, note that all of the lambdas - both the stage (2) lambda and the stage (3) lambda -
14714     // run after the function that created them returns. Hence, you should not use by-reference
14715     // capture (i.e. [&amp;]) in any of these lambdas.
14716     template&lt;typename Functor, typename... ArgumentTypes&gt;
14717     PatchpointValue* lazySlowPath(const Functor&amp; functor, ArgumentTypes... arguments)
14718     {
14719         return lazySlowPath(functor, Vector&lt;LValue&gt;{ arguments... });
14720     }
14721 
14722     template&lt;typename Functor&gt;
14723     PatchpointValue* lazySlowPath(const Functor&amp; functor, const Vector&lt;LValue&gt;&amp; userArguments)
14724     {
14725         CodeOrigin origin = m_node-&gt;origin.semantic;
14726 
14727         PatchpointValue* result = m_out.patchpoint(B3::Int64);
14728         for (LValue arg : userArguments)
14729             result-&gt;append(ConstrainedValue(arg, B3::ValueRep::SomeRegister));
14730 
14731         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
14732             preparePatchpointForExceptions(result);
14733 
14734         result-&gt;clobber(RegisterSet::macroScratchRegisters());
14735         State* state = &amp;m_ftlState;
14736 
14737         result-&gt;setGenerator(
14738             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14739                 Vector&lt;Location&gt; locations;
14740                 for (const B3::ValueRep&amp; rep : params)
14741                     locations.append(Location::forValueRep(rep));
14742 
14743                 RefPtr&lt;LazySlowPath::Generator&gt; generator = functor(locations);
14744 
14745                 CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
14746                 CCallHelpers::Label done = jit.label();
14747 
14748                 RegisterSet usedRegisters = params.unavailableRegisters();
14749 
14750                 RefPtr&lt;ExceptionTarget&gt; exceptionTarget =
14751                     exceptionHandle-&gt;scheduleExitCreation(params);
14752 
14753                 // FIXME: As part of handling exceptions, we need to create a concrete OSRExit here.
14754                 // Doing so should automagically register late paths that emit exit thunks.
14755 
14756                 params.addLatePath(
14757                     [=] (CCallHelpers&amp; jit) {
14758                         AllowMacroScratchRegisterUsage allowScratch(jit);
14759                         patchableJump.m_jump.link(&amp;jit);
14760                         unsigned index = state-&gt;jitCode-&gt;lazySlowPaths.size();
14761                         state-&gt;jitCode-&gt;lazySlowPaths.append(nullptr);
14762                         jit.pushToSaveImmediateWithoutTouchingRegisters(
14763                             CCallHelpers::TrustedImm32(index));
14764                         CCallHelpers::Jump generatorJump = jit.jump();
14765 
14766                         // Note that so long as we&#39;re here, we don&#39;t really know if our late path
14767                         // runs before or after any other late paths that we might depend on, like
14768                         // the exception thunk.
14769 
14770                         RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode;
14771                         VM* vm = &amp;state-&gt;graph.m_vm;
14772 
14773                         jit.addLinkTask(
14774                             [=] (LinkBuffer&amp; linkBuffer) {
14775                                 linkBuffer.link(generatorJump,
14776                                     CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(lazySlowPathGenerationThunkGenerator).code()));
14777 
<a name="129" id="anc129"></a><span class="line-modified">14778                                 std::unique_ptr&lt;LazySlowPath&gt; lazySlowPath = std::make_unique&lt;LazySlowPath&gt;();</span>
14779 
14780                                 auto linkedPatchableJump = CodeLocationJump&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump));
14781 
14782                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; linkedDone = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(done);
14783 
14784                                 CallSiteIndex callSiteIndex =
14785                                     jitCode-&gt;common.addUniqueCallSiteIndex(origin);
14786 
14787                                 lazySlowPath-&gt;initialize(
14788                                         linkedPatchableJump, linkedDone,
14789                                         exceptionTarget-&gt;label(linkBuffer), usedRegisters,
14790                                         callSiteIndex, generator);
14791 
14792                                 jitCode-&gt;lazySlowPaths[index] = WTFMove(lazySlowPath);
14793                             });
14794                     });
14795             });
14796         return result;
14797     }
14798 
14799     void speculate(
14800         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition)
14801     {
14802         appendOSRExit(kind, lowValue, highValue, failCondition, m_origin);
14803     }
14804 
14805     void speculate(
14806         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition)
14807     {
14808         appendOSRExit(kind, lowValue, profile, failCondition, m_origin);
14809     }
14810 
14811     void terminate(ExitKind kind)
14812     {
14813         speculate(kind, noValue(), nullptr, m_out.booleanTrue);
14814         didAlreadyTerminate();
14815     }
14816 
14817     void didAlreadyTerminate()
14818     {
14819         m_state.setIsValid(false);
14820     }
14821 
14822     void simulatedTypeCheck(Edge highValue, SpeculatedType typesPassedThrough)
14823     {
14824         m_interpreter.filter(highValue, typesPassedThrough);
14825     }
14826 
14827     void typeCheck(
14828         FormattedValue lowValue, Edge highValue, SpeculatedType typesPassedThrough,
14829         LValue failCondition, ExitKind exitKind = BadType)
14830     {
14831         appendTypeCheck(lowValue, highValue, typesPassedThrough, failCondition, exitKind);
14832     }
14833 
14834     void appendTypeCheck(
14835         FormattedValue lowValue, Edge highValue, SpeculatedType typesPassedThrough,
14836         LValue failCondition, ExitKind exitKind)
14837     {
14838         if (!m_interpreter.needsTypeCheck(highValue, typesPassedThrough))
14839             return;
14840         ASSERT(mayHaveTypeCheck(highValue.useKind()));
14841         appendOSRExit(exitKind, lowValue, highValue.node(), failCondition, m_origin);
14842         m_interpreter.filter(highValue, typesPassedThrough);
14843     }
14844 
14845     LValue lowInt32(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
14846     {
14847         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || (edge.useKind() == Int32Use || edge.useKind() == KnownInt32Use));
14848 
14849         if (edge-&gt;hasConstant()) {
14850             JSValue value = edge-&gt;asJSValue();
14851             simulatedTypeCheck(edge, SpecInt32Only);
14852             if (!value.isInt32()) {
14853                 if (mayHaveTypeCheck(edge.useKind()))
14854                     terminate(Uncountable);
14855                 return m_out.int32Zero;
14856             }
14857             LValue result = m_out.constInt32(value.asInt32());
14858             result-&gt;setOrigin(B3::Origin(edge.node()));
14859             return result;
14860         }
14861 
14862         LoweredNodeValue value = m_int32Values.get(edge.node());
14863         if (isValid(value)) {
14864             simulatedTypeCheck(edge, SpecInt32Only);
14865             return value.value();
14866         }
14867 
14868         value = m_strictInt52Values.get(edge.node());
14869         if (isValid(value))
14870             return strictInt52ToInt32(edge, value.value());
14871 
14872         value = m_int52Values.get(edge.node());
14873         if (isValid(value))
14874             return strictInt52ToInt32(edge, int52ToStrictInt52(value.value()));
14875 
14876         value = m_jsValueValues.get(edge.node());
14877         if (isValid(value)) {
14878             LValue boxedResult = value.value();
14879             FTL_TYPE_CHECK(
14880                 jsValueValue(boxedResult), edge, SpecInt32Only, isNotInt32(boxedResult));
14881             LValue result = unboxInt32(boxedResult);
14882             setInt32(edge.node(), result);
14883             return result;
14884         }
14885 
14886         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecInt32Only), provenType(edge));
14887         if (mayHaveTypeCheck(edge.useKind()))
14888             terminate(Uncountable);
14889         return m_out.int32Zero;
14890     }
14891 
14892     enum Int52Kind { StrictInt52, Int52 };
14893     LValue lowInt52(Edge edge, Int52Kind kind)
14894     {
14895         DFG_ASSERT(m_graph, m_node, edge.useKind() == Int52RepUse, edge.useKind());
14896 
14897         LoweredNodeValue value;
14898 
14899         switch (kind) {
14900         case Int52:
14901             value = m_int52Values.get(edge.node());
14902             if (isValid(value))
14903                 return value.value();
14904 
14905             value = m_strictInt52Values.get(edge.node());
14906             if (isValid(value))
14907                 return strictInt52ToInt52(value.value());
14908             break;
14909 
14910         case StrictInt52:
14911             value = m_strictInt52Values.get(edge.node());
14912             if (isValid(value))
14913                 return value.value();
14914 
14915             value = m_int52Values.get(edge.node());
14916             if (isValid(value))
14917                 return int52ToStrictInt52(value.value());
14918             break;
14919         }
14920 
14921         DFG_ASSERT(m_graph, m_node, !provenType(edge), provenType(edge));
14922         if (mayHaveTypeCheck(edge.useKind()))
14923             terminate(Uncountable);
14924         return m_out.int64Zero;
14925     }
14926 
14927     LValue lowInt52(Edge edge)
14928     {
14929         return lowInt52(edge, Int52);
14930     }
14931 
14932     LValue lowStrictInt52(Edge edge)
14933     {
14934         return lowInt52(edge, StrictInt52);
14935     }
14936 
14937     bool betterUseStrictInt52(Node* node)
14938     {
14939         return !isValid(m_int52Values.get(node));
14940     }
14941     bool betterUseStrictInt52(Edge edge)
14942     {
14943         return betterUseStrictInt52(edge.node());
14944     }
14945     template&lt;typename T&gt;
14946     Int52Kind bestInt52Kind(T node)
14947     {
14948         return betterUseStrictInt52(node) ? StrictInt52 : Int52;
14949     }
14950     Int52Kind opposite(Int52Kind kind)
14951     {
14952         switch (kind) {
14953         case Int52:
14954             return StrictInt52;
14955         case StrictInt52:
14956             return Int52;
14957         }
14958         DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
14959         return Int52;
14960     }
14961 
14962     LValue lowWhicheverInt52(Edge edge, Int52Kind&amp; kind)
14963     {
14964         kind = bestInt52Kind(edge);
14965         return lowInt52(edge, kind);
14966     }
14967 
14968     LValue lowCell(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
14969     {
14970         DFG_ASSERT(m_graph, m_node, mode == ManualOperandSpeculation || DFG::isCell(edge.useKind()), edge.useKind());
14971 
14972         if (edge-&gt;op() == JSConstant) {
14973             FrozenValue* value = edge-&gt;constant();
14974             simulatedTypeCheck(edge, SpecCellCheck);
14975             if (!value-&gt;value().isCell()) {
14976                 if (mayHaveTypeCheck(edge.useKind()))
14977                     terminate(Uncountable);
14978                 return m_out.intPtrZero;
14979             }
14980             LValue result = frozenPointer(value);
14981             result-&gt;setOrigin(B3::Origin(edge.node()));
14982             return result;
14983         }
14984 
14985         LoweredNodeValue value = m_jsValueValues.get(edge.node());
14986         if (isValid(value)) {
14987             LValue uncheckedValue = value.value();
14988             FTL_TYPE_CHECK(
14989                 jsValueValue(uncheckedValue), edge, SpecCellCheck, isNotCell(uncheckedValue));
14990             return uncheckedValue;
14991         }
14992 
14993         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecCellCheck), provenType(edge));
14994         if (mayHaveTypeCheck(edge.useKind()))
14995             terminate(Uncountable);
14996         return m_out.intPtrZero;
14997     }
14998 
14999     LValue lowObject(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15000     {
15001         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == ObjectUse);
15002 
15003         LValue result = lowCell(edge, mode);
15004         speculateObject(edge, result);
15005         return result;
15006     }
15007 
15008     LValue lowRegExpObject(Edge edge)
15009     {
15010         LValue result = lowCell(edge);
15011         speculateRegExpObject(edge, result);
15012         return result;
15013     }
15014 
15015     LValue lowMapObject(Edge edge)
15016     {
15017         LValue result = lowCell(edge);
15018         speculateMapObject(edge, result);
15019         return result;
15020     }
15021 
15022     LValue lowSetObject(Edge edge)
15023     {
15024         LValue result = lowCell(edge);
15025         speculateSetObject(edge, result);
15026         return result;
15027     }
15028 
15029     LValue lowWeakMapObject(Edge edge)
15030     {
15031         LValue result = lowCell(edge);
15032         speculateWeakMapObject(edge, result);
15033         return result;
15034     }
15035 
15036     LValue lowWeakSetObject(Edge edge)
15037     {
15038         LValue result = lowCell(edge);
15039         speculateWeakSetObject(edge, result);
15040         return result;
15041     }
15042 
15043     LValue lowDataViewObject(Edge edge)
15044     {
15045         LValue result = lowCell(edge);
15046         speculateDataViewObject(edge, result);
15047         return result;
15048     }
15049 
15050     LValue lowString(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15051     {
15052         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == StringUse || edge.useKind() == KnownStringUse || edge.useKind() == StringIdentUse);
15053 
15054         LValue result = lowCell(edge, mode);
15055         speculateString(edge, result);
15056         return result;
15057     }
15058 
15059     LValue lowStringIdent(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15060     {
15061         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == StringIdentUse);
15062 
15063         LValue string = lowString(edge, mode);
15064         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
15065         speculateStringIdent(edge, string, stringImpl);
15066         return stringImpl;
15067     }
15068 
15069     LValue lowSymbol(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15070     {
15071         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == SymbolUse);
15072 
15073         LValue result = lowCell(edge, mode);
15074         speculateSymbol(edge, result);
15075         return result;
15076     }
15077 
15078     LValue lowBigInt(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15079     {
15080         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == BigIntUse);
15081 
15082         LValue result = lowCell(edge, mode);
15083         speculateBigInt(edge, result);
15084         return result;
15085     }
15086 
15087     LValue lowNonNullObject(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15088     {
15089         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == ObjectUse);
15090 
15091         LValue result = lowCell(edge, mode);
15092         speculateNonNullObject(edge, result);
15093         return result;
15094     }
15095 
15096     LValue lowBoolean(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15097     {
15098         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == BooleanUse || edge.useKind() == KnownBooleanUse);
15099 
15100         if (edge-&gt;hasConstant()) {
15101             JSValue value = edge-&gt;asJSValue();
15102             simulatedTypeCheck(edge, SpecBoolean);
15103             if (!value.isBoolean()) {
15104                 if (mayHaveTypeCheck(edge.useKind()))
15105                     terminate(Uncountable);
15106                 return m_out.booleanFalse;
15107             }
15108             LValue result = m_out.constBool(value.asBoolean());
15109             result-&gt;setOrigin(B3::Origin(edge.node()));
15110             return result;
15111         }
15112 
15113         LoweredNodeValue value = m_booleanValues.get(edge.node());
15114         if (isValid(value)) {
15115             simulatedTypeCheck(edge, SpecBoolean);
15116             return value.value();
15117         }
15118 
15119         value = m_jsValueValues.get(edge.node());
15120         if (isValid(value)) {
15121             LValue unboxedResult = value.value();
15122             FTL_TYPE_CHECK(
15123                 jsValueValue(unboxedResult), edge, SpecBoolean, isNotBoolean(unboxedResult));
15124             LValue result = unboxBoolean(unboxedResult);
15125             setBoolean(edge.node(), result);
15126             return result;
15127         }
15128 
15129         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecBoolean), provenType(edge));
15130         if (mayHaveTypeCheck(edge.useKind()))
15131             terminate(Uncountable);
15132         return m_out.booleanFalse;
15133     }
15134 
15135     LValue lowDouble(Edge edge)
15136     {
15137         DFG_ASSERT(m_graph, m_node, isDouble(edge.useKind()), edge.useKind());
15138 
15139         LoweredNodeValue value = m_doubleValues.get(edge.node());
15140         if (isValid(value))
15141             return value.value();
15142         DFG_ASSERT(m_graph, m_node, !provenType(edge), provenType(edge));
15143         if (mayHaveTypeCheck(edge.useKind()))
15144             terminate(Uncountable);
15145         return m_out.doubleZero;
15146     }
15147 
15148     LValue lowJSValue(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15149     {
15150         DFG_ASSERT(m_graph, m_node, mode == ManualOperandSpeculation || edge.useKind() == UntypedUse, m_node-&gt;op(), edge.useKind());
15151         DFG_ASSERT(m_graph, m_node, !isDouble(edge.useKind()), m_node-&gt;op(), edge.useKind());
15152         DFG_ASSERT(m_graph, m_node, edge.useKind() != Int52RepUse, m_node-&gt;op(), edge.useKind());
15153 
15154         if (edge-&gt;hasConstant()) {
15155             LValue result = m_out.constInt64(JSValue::encode(edge-&gt;asJSValue()));
15156             result-&gt;setOrigin(B3::Origin(edge.node()));
15157             return result;
15158         }
15159 
15160         LoweredNodeValue value = m_jsValueValues.get(edge.node());
15161         if (isValid(value))
15162             return value.value();
15163 
15164         value = m_int32Values.get(edge.node());
15165         if (isValid(value)) {
15166             LValue result = boxInt32(value.value());
15167             setJSValue(edge.node(), result);
15168             return result;
15169         }
15170 
15171         value = m_booleanValues.get(edge.node());
15172         if (isValid(value)) {
15173             LValue result = boxBoolean(value.value());
15174             setJSValue(edge.node(), result);
15175             return result;
15176         }
15177 
<a name="130" id="anc130"></a><span class="line-modified">15178         DFG_CRASH(m_graph, m_node, &quot;Value not defined&quot;);</span>
15179         return 0;
15180     }
15181 
15182     LValue lowNotCell(Edge edge)
15183     {
15184         LValue result = lowJSValue(edge, ManualOperandSpeculation);
15185         FTL_TYPE_CHECK(jsValueValue(result), edge, ~SpecCellCheck, isCell(result));
15186         return result;
15187     }
15188 
15189     LValue lowStorage(Edge edge)
15190     {
15191         LoweredNodeValue value = m_storageValues.get(edge.node());
15192         if (isValid(value))
15193             return value.value();
15194 
15195         LValue result = lowCell(edge);
15196         setStorage(edge.node(), result);
15197         return result;
15198     }
15199 
15200     LValue strictInt52ToInt32(Edge edge, LValue value)
15201     {
15202         LValue result = m_out.castToInt32(value);
15203         FTL_TYPE_CHECK(
15204             noValue(), edge, SpecInt32Only,
15205             m_out.notEqual(m_out.signExt32To64(result), value));
15206         setInt32(edge.node(), result);
15207         return result;
15208     }
15209 
15210     LValue strictInt52ToDouble(LValue value)
15211     {
15212         return m_out.intToDouble(value);
15213     }
15214 
15215     LValue strictInt52ToJSValue(LValue value)
15216     {
15217         LBasicBlock isInt32 = m_out.newBlock();
15218         LBasicBlock isDouble = m_out.newBlock();
15219         LBasicBlock continuation = m_out.newBlock();
15220 
15221         Vector&lt;ValueFromBlock, 2&gt; results;
15222 
15223         LValue int32Value = m_out.castToInt32(value);
15224         m_out.branch(
15225             m_out.equal(m_out.signExt32To64(int32Value), value),
15226             unsure(isInt32), unsure(isDouble));
15227 
15228         LBasicBlock lastNext = m_out.appendTo(isInt32, isDouble);
15229 
15230         results.append(m_out.anchor(boxInt32(int32Value)));
15231         m_out.jump(continuation);
15232 
15233         m_out.appendTo(isDouble, continuation);
15234 
15235         results.append(m_out.anchor(boxDouble(m_out.intToDouble(value))));
15236         m_out.jump(continuation);
15237 
15238         m_out.appendTo(continuation, lastNext);
15239         return m_out.phi(Int64, results);
15240     }
15241 
15242     LValue strictInt52ToInt52(LValue value)
15243     {
15244         return m_out.shl(value, m_out.constInt64(JSValue::int52ShiftAmount));
15245     }
15246 
15247     LValue int52ToStrictInt52(LValue value)
15248     {
15249         return m_out.aShr(value, m_out.constInt64(JSValue::int52ShiftAmount));
15250     }
15251 
15252     LValue isInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
15253     {
15254         if (LValue proven = isProvenValue(type, SpecInt32Only))
15255             return proven;
15256         return m_out.aboveOrEqual(jsValue, m_tagTypeNumber);
15257     }
15258     LValue isNotInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
15259     {
15260         if (LValue proven = isProvenValue(type, ~SpecInt32Only))
15261             return proven;
15262         return m_out.below(jsValue, m_tagTypeNumber);
15263     }
15264     LValue unboxInt32(LValue jsValue)
15265     {
15266         return m_out.castToInt32(jsValue);
15267     }
15268     LValue boxInt32(LValue value)
15269     {
15270         return m_out.add(m_out.zeroExt(value, Int64), m_tagTypeNumber);
15271     }
15272 
15273     LValue isCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
15274     {
15275         if (LValue proven = isProvenValue(type, SpecCellCheck | SpecMisc))
15276             return proven;
15277         return m_out.testIsZero64(jsValue, m_tagTypeNumber);
15278     }
15279     LValue isNotCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
15280     {
15281         if (LValue proven = isProvenValue(type, ~(SpecCellCheck | SpecMisc)))
15282             return proven;
15283         return m_out.testNonZero64(jsValue, m_tagTypeNumber);
15284     }
15285 
15286     LValue unboxDouble(LValue jsValue, LValue* unboxedAsInt = nullptr)
15287     {
15288         LValue asInt = m_out.add(jsValue, m_tagTypeNumber);
15289         if (unboxedAsInt)
15290             *unboxedAsInt = asInt;
15291         return m_out.bitCast(asInt, Double);
15292     }
15293     LValue boxDouble(LValue doubleValue)
15294     {
15295         return m_out.sub(m_out.bitCast(doubleValue, Int64), m_tagTypeNumber);
15296     }
15297 
15298     LValue jsValueToStrictInt52(Edge edge, LValue boxedValue)
15299     {
15300         LBasicBlock intCase = m_out.newBlock();
15301         LBasicBlock doubleCase = m_out.newBlock();
15302         LBasicBlock continuation = m_out.newBlock();
15303 
15304         LValue isNotInt32;
15305         if (!m_interpreter.needsTypeCheck(edge, SpecInt32Only))
15306             isNotInt32 = m_out.booleanFalse;
15307         else if (!m_interpreter.needsTypeCheck(edge, ~SpecInt32Only))
15308             isNotInt32 = m_out.booleanTrue;
15309         else
15310             isNotInt32 = this-&gt;isNotInt32(boxedValue);
15311         m_out.branch(isNotInt32, unsure(doubleCase), unsure(intCase));
15312 
15313         LBasicBlock lastNext = m_out.appendTo(intCase, doubleCase);
15314 
15315         ValueFromBlock intToInt52 = m_out.anchor(
15316             m_out.signExt32To64(unboxInt32(boxedValue)));
15317         m_out.jump(continuation);
15318 
15319         m_out.appendTo(doubleCase, continuation);
15320 
15321         LValue possibleResult = m_out.call(
15322             Int64, m_out.operation(operationConvertBoxedDoubleToInt52), boxedValue);
15323         FTL_TYPE_CHECK(
15324             jsValueValue(boxedValue), edge, SpecInt32Only | SpecAnyIntAsDouble,
15325             m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));
15326 
15327         ValueFromBlock doubleToInt52 = m_out.anchor(possibleResult);
15328         m_out.jump(continuation);
15329 
15330         m_out.appendTo(continuation, lastNext);
15331 
15332         return m_out.phi(Int64, intToInt52, doubleToInt52);
15333     }
15334 
15335     LValue doubleToStrictInt52(Edge edge, LValue value)
15336     {
15337         LValue possibleResult = m_out.call(
15338             Int64, m_out.operation(operationConvertDoubleToInt52), value);
15339         FTL_TYPE_CHECK_WITH_EXIT_KIND(Int52Overflow,
15340             doubleValue(value), edge, SpecAnyIntAsDouble,
15341             m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));
15342 
15343         return possibleResult;
15344     }
15345 
15346     LValue convertDoubleToInt32(LValue value, bool shouldCheckNegativeZero)
15347     {
15348         LValue integerValue = m_out.doubleToInt(value);
15349         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
15350         LValue valueNotConvertibleToInteger = m_out.doubleNotEqualOrUnordered(value, integerValueConvertedToDouble);
15351         speculate(Overflow, FormattedValue(DataFormatDouble, value), m_node, valueNotConvertibleToInteger);
15352 
15353         if (shouldCheckNegativeZero) {
15354             LBasicBlock valueIsZero = m_out.newBlock();
15355             LBasicBlock continuation = m_out.newBlock();
15356             m_out.branch(m_out.isZero32(integerValue), unsure(valueIsZero), unsure(continuation));
15357 
15358             LBasicBlock lastNext = m_out.appendTo(valueIsZero, continuation);
15359 
15360             LValue doubleBitcastToInt64 = m_out.bitCast(value, Int64);
15361             LValue signBitSet = m_out.lessThan(doubleBitcastToInt64, m_out.constInt64(0));
15362 
15363             speculate(NegativeZero, FormattedValue(DataFormatDouble, value), m_node, signBitSet);
15364             m_out.jump(continuation);
15365             m_out.appendTo(continuation, lastNext);
15366         }
15367         return integerValue;
15368     }
15369 
15370     LValue isNumber(LValue jsValue, SpeculatedType type = SpecFullTop)
15371     {
15372         if (LValue proven = isProvenValue(type, SpecFullNumber))
15373             return proven;
15374         return isNotCellOrMisc(jsValue);
15375     }
15376     LValue isNotNumber(LValue jsValue, SpeculatedType type = SpecFullTop)
15377     {
15378         if (LValue proven = isProvenValue(type, ~SpecFullNumber))
15379             return proven;
15380         return isCellOrMisc(jsValue);
15381     }
15382 
15383     LValue isNotCell(LValue jsValue, SpeculatedType type = SpecFullTop)
15384     {
15385         if (LValue proven = isProvenValue(type, ~SpecCellCheck))
15386             return proven;
15387         return m_out.testNonZero64(jsValue, m_tagMask);
15388     }
15389 
15390     LValue isCell(LValue jsValue, SpeculatedType type = SpecFullTop)
15391     {
15392         if (LValue proven = isProvenValue(type, SpecCellCheck))
15393             return proven;
15394         return m_out.testIsZero64(jsValue, m_tagMask);
15395     }
15396 
15397     LValue isNotMisc(LValue value, SpeculatedType type = SpecFullTop)
15398     {
15399         if (LValue proven = isProvenValue(type, ~SpecMisc))
15400             return proven;
15401         return m_out.above(value, m_out.constInt64(TagBitTypeOther | TagBitBool | TagBitUndefined));
15402     }
15403 
15404     LValue isMisc(LValue value, SpeculatedType type = SpecFullTop)
15405     {
15406         if (LValue proven = isProvenValue(type, SpecMisc))
15407             return proven;
15408         return m_out.logicalNot(isNotMisc(value));
15409     }
15410 
15411     LValue isNotBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
15412     {
15413         if (LValue proven = isProvenValue(type, ~SpecBoolean))
15414             return proven;
15415         return m_out.testNonZero64(
15416             m_out.bitXor(jsValue, m_out.constInt64(ValueFalse)),
15417             m_out.constInt64(~1));
15418     }
15419     LValue isBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
15420     {
15421         if (LValue proven = isProvenValue(type, SpecBoolean))
15422             return proven;
15423         return m_out.logicalNot(isNotBoolean(jsValue));
15424     }
15425     LValue unboxBoolean(LValue jsValue)
15426     {
15427         // We want to use a cast that guarantees that B3 knows that even the integer
15428         // value is just 0 or 1. But for now we do it the dumb way.
15429         return m_out.notZero64(m_out.bitAnd(jsValue, m_out.constInt64(1)));
15430     }
15431     LValue boxBoolean(LValue value)
15432     {
15433         return m_out.select(
15434             value, m_out.constInt64(ValueTrue), m_out.constInt64(ValueFalse));
15435     }
15436 
15437     LValue isNotOther(LValue value, SpeculatedType type = SpecFullTop)
15438     {
15439         if (LValue proven = isProvenValue(type, ~SpecOther))
15440             return proven;
15441         return m_out.notEqual(
15442             m_out.bitAnd(value, m_out.constInt64(~TagBitUndefined)),
15443             m_out.constInt64(ValueNull));
15444     }
15445     LValue isOther(LValue value, SpeculatedType type = SpecFullTop)
15446     {
15447         if (LValue proven = isProvenValue(type, SpecOther))
15448             return proven;
15449         return m_out.equal(
15450             m_out.bitAnd(value, m_out.constInt64(~TagBitUndefined)),
15451             m_out.constInt64(ValueNull));
15452     }
15453 
15454     LValue isProvenValue(SpeculatedType provenType, SpeculatedType wantedType)
15455     {
15456         if (!(provenType &amp; ~wantedType))
15457             return m_out.booleanTrue;
15458         if (!(provenType &amp; wantedType))
15459             return m_out.booleanFalse;
15460         return nullptr;
15461     }
15462 
15463     void speculate(Edge edge)
15464     {
15465         switch (edge.useKind()) {
15466         case UntypedUse:
15467             break;
15468         case KnownInt32Use:
15469         case KnownStringUse:
15470         case KnownPrimitiveUse:
15471         case KnownOtherUse:
15472         case DoubleRepUse:
15473         case Int52RepUse:
15474         case KnownCellUse:
15475         case KnownBooleanUse:
15476             ASSERT(!m_interpreter.needsTypeCheck(edge));
15477             break;
15478         case Int32Use:
15479             speculateInt32(edge);
15480             break;
15481         case CellUse:
15482             speculateCell(edge);
15483             break;
15484         case CellOrOtherUse:
15485             speculateCellOrOther(edge);
15486             break;
15487         case AnyIntUse:
15488             speculateAnyInt(edge);
15489             break;
15490         case ObjectUse:
15491             speculateObject(edge);
15492             break;
15493         case ArrayUse:
15494             speculateArray(edge);
15495             break;
15496         case FunctionUse:
15497             speculateFunction(edge);
15498             break;
15499         case ObjectOrOtherUse:
15500             speculateObjectOrOther(edge);
15501             break;
15502         case FinalObjectUse:
15503             speculateFinalObject(edge);
15504             break;
15505         case RegExpObjectUse:
15506             speculateRegExpObject(edge);
15507             break;
15508         case ProxyObjectUse:
15509             speculateProxyObject(edge);
15510             break;
15511         case DerivedArrayUse:
15512             speculateDerivedArray(edge);
15513             break;
15514         case MapObjectUse:
15515             speculateMapObject(edge);
15516             break;
15517         case SetObjectUse:
15518             speculateSetObject(edge);
15519             break;
15520         case WeakMapObjectUse:
15521             speculateWeakMapObject(edge);
15522             break;
15523         case WeakSetObjectUse:
15524             speculateWeakSetObject(edge);
15525             break;
15526         case DataViewObjectUse:
15527             speculateDataViewObject(edge);
15528             break;
15529         case StringUse:
15530             speculateString(edge);
15531             break;
15532         case StringOrOtherUse:
15533             speculateStringOrOther(edge);
15534             break;
15535         case StringIdentUse:
15536             speculateStringIdent(edge);
15537             break;
15538         case SymbolUse:
15539             speculateSymbol(edge);
15540             break;
15541         case StringObjectUse:
15542             speculateStringObject(edge);
15543             break;
15544         case StringOrStringObjectUse:
15545             speculateStringOrStringObject(edge);
15546             break;
15547         case NumberUse:
15548             speculateNumber(edge);
15549             break;
15550         case RealNumberUse:
15551             speculateRealNumber(edge);
15552             break;
15553         case DoubleRepRealUse:
15554             speculateDoubleRepReal(edge);
15555             break;
15556         case DoubleRepAnyIntUse:
15557             speculateDoubleRepAnyInt(edge);
15558             break;
15559         case BooleanUse:
15560             speculateBoolean(edge);
15561             break;
15562         case BigIntUse:
15563             speculateBigInt(edge);
15564             break;
15565         case NotStringVarUse:
15566             speculateNotStringVar(edge);
15567             break;
15568         case NotSymbolUse:
15569             speculateNotSymbol(edge);
15570             break;
15571         case NotCellUse:
15572             speculateNotCell(edge);
15573             break;
15574         case OtherUse:
15575             speculateOther(edge);
15576             break;
15577         case MiscUse:
15578             speculateMisc(edge);
15579             break;
15580         default:
15581             DFG_CRASH(m_graph, m_node, &quot;Unsupported speculation use kind&quot;);
15582         }
15583     }
15584 
15585     void speculate(Node*, Edge edge)
15586     {
15587         speculate(edge);
15588     }
15589 
15590     void speculateInt32(Edge edge)
15591     {
15592         lowInt32(edge);
15593     }
15594 
15595     void speculateCell(Edge edge)
15596     {
15597         lowCell(edge);
15598     }
15599 
15600     void speculateNotCell(Edge edge)
15601     {
15602         if (!m_interpreter.needsTypeCheck(edge))
15603             return;
15604         lowNotCell(edge);
15605     }
15606 
15607     void speculateCellOrOther(Edge edge)
15608     {
15609         if (shouldNotHaveTypeCheck(edge.useKind()))
15610             return;
15611 
15612         LValue value = lowJSValue(edge, ManualOperandSpeculation);
15613 
15614         LBasicBlock isNotCell = m_out.newBlock();
15615         LBasicBlock continuation = m_out.newBlock();
15616 
15617         m_out.branch(isCell(value, provenType(edge)), unsure(continuation), unsure(isNotCell));
15618 
15619         LBasicBlock lastNext = m_out.appendTo(isNotCell, continuation);
15620         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
15621         m_out.jump(continuation);
15622 
15623         m_out.appendTo(continuation, lastNext);
15624     }
15625 
15626     void speculateAnyInt(Edge edge)
15627     {
15628         if (!m_interpreter.needsTypeCheck(edge))
15629             return;
15630 
15631         jsValueToStrictInt52(edge, lowJSValue(edge, ManualOperandSpeculation));
15632     }
15633 
15634     LValue isCellWithType(LValue cell, JSType queriedType, SpeculatedType speculatedTypeForQuery, SpeculatedType type = SpecFullTop)
15635     {
15636         if (LValue proven = isProvenValue(type &amp; SpecCell, speculatedTypeForQuery))
15637             return proven;
15638         return m_out.equal(
15639             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15640             m_out.constInt32(queriedType));
15641     }
15642 
15643     LValue isTypedArrayView(LValue cell, SpeculatedType type = SpecFullTop)
15644     {
15645         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecTypedArrayView))
15646             return proven;
15647         LValue jsType = m_out.sub(
15648             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15649             m_out.constInt32(FirstTypedArrayType));
15650         return m_out.below(
15651             jsType,
15652             m_out.constInt32(NumberOfTypedArrayTypesExcludingDataView));
15653     }
15654 
15655     LValue isObject(LValue cell, SpeculatedType type = SpecFullTop)
15656     {
15657         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecObject))
15658             return proven;
15659         return m_out.aboveOrEqual(
15660             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15661             m_out.constInt32(ObjectType));
15662     }
15663 
15664     LValue isNotObject(LValue cell, SpeculatedType type = SpecFullTop)
15665     {
15666         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecObject))
15667             return proven;
15668         return m_out.below(
15669             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15670             m_out.constInt32(ObjectType));
15671     }
15672 
15673     LValue isNotString(LValue cell, SpeculatedType type = SpecFullTop)
15674     {
15675         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecString))
15676             return proven;
15677         return m_out.notEqual(
15678             m_out.load32(cell, m_heaps.JSCell_structureID),
15679             m_out.constInt32(vm().stringStructure-&gt;id()));
15680     }
15681 
15682     LValue isString(LValue cell, SpeculatedType type = SpecFullTop)
15683     {
15684         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecString))
15685             return proven;
15686         return m_out.equal(
15687             m_out.load32(cell, m_heaps.JSCell_structureID),
15688             m_out.constInt32(vm().stringStructure-&gt;id()));
15689     }
15690 
15691     LValue isRopeString(LValue string, Edge edge = Edge())
15692     {
15693         if (edge) {
15694             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
15695                 return m_out.booleanFalse;
15696             if (JSValue value = provenValue(edge)) {
15697                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
15698                     return m_out.booleanFalse;
15699             }
<a name="131" id="anc131"></a>




15700         }
15701 
15702         return m_out.testNonZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
15703     }
15704 
15705     LValue isNotRopeString(LValue string, Edge edge = Edge())
15706     {
15707         if (edge) {
15708             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
15709                 return m_out.booleanTrue;
15710             if (JSValue value = provenValue(edge)) {
15711                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
15712                     return m_out.booleanTrue;
15713             }
<a name="132" id="anc132"></a>




15714         }
15715 
15716         return m_out.testIsZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
15717     }
15718 
15719     LValue isNotSymbol(LValue cell, SpeculatedType type = SpecFullTop)
15720     {
15721         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecSymbol))
15722             return proven;
15723         return m_out.notEqual(
15724             m_out.load32(cell, m_heaps.JSCell_structureID),
15725             m_out.constInt32(vm().symbolStructure-&gt;id()));
15726     }
15727 
15728     LValue isSymbol(LValue cell, SpeculatedType type = SpecFullTop)
15729     {
15730         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecSymbol))
15731             return proven;
15732         return m_out.equal(
15733             m_out.load32(cell, m_heaps.JSCell_structureID),
15734             m_out.constInt32(vm().symbolStructure-&gt;id()));
15735     }
15736 
15737     LValue isNotBigInt(LValue cell, SpeculatedType type = SpecFullTop)
15738     {
15739         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecBigInt))
15740             return proven;
15741         return m_out.notEqual(
15742             m_out.load32(cell, m_heaps.JSCell_structureID),
15743             m_out.constInt32(vm().bigIntStructure-&gt;id()));
15744     }
15745 
15746     LValue isBigInt(LValue cell, SpeculatedType type = SpecFullTop)
15747     {
15748         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecBigInt))
15749             return proven;
15750         return m_out.equal(
15751             m_out.load32(cell, m_heaps.JSCell_structureID),
15752             m_out.constInt32(vm().bigIntStructure-&gt;id()));
15753     }
15754 
15755     LValue isArrayTypeForArrayify(LValue cell, ArrayMode arrayMode)
15756     {
15757         switch (arrayMode.type()) {
15758         case Array::Int32:
15759         case Array::Double:
15760         case Array::Contiguous:
15761         case Array::Undecided:
15762         case Array::ArrayStorage: {
15763             IndexingType indexingModeMask = IsArray | IndexingShapeMask;
15764             if (arrayMode.action() == Array::Write)
15765                 indexingModeMask |= CopyOnWrite;
15766 
15767             IndexingType shape = arrayMode.shapeMask();
15768             LValue indexingType = m_out.load8ZeroExt32(cell, m_heaps.JSCell_indexingTypeAndMisc);
15769 
15770             switch (arrayMode.arrayClass()) {
15771             case Array::OriginalArray:
15772             case Array::OriginalCopyOnWriteArray:
15773                 DFG_CRASH(m_graph, m_node, &quot;Unexpected original array&quot;);
15774                 return nullptr;
15775 
15776             case Array::Array:
15777                 return m_out.equal(
15778                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask)),
15779                     m_out.constInt32(IsArray | shape));
15780 
15781             case Array::NonArray:
15782             case Array::OriginalNonArray:
15783                 return m_out.equal(
15784                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask)),
15785                     m_out.constInt32(shape));
15786 
15787             case Array::PossiblyArray:
15788                 return m_out.equal(
15789                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask &amp; ~IsArray)),
15790                     m_out.constInt32(shape));
15791             }
15792             break;
15793         }
15794 
15795         case Array::SlowPutArrayStorage: {
15796             ASSERT(!arrayMode.isJSArrayWithOriginalStructure());
15797             LValue indexingType = m_out.load8ZeroExt32(cell, m_heaps.JSCell_indexingTypeAndMisc);
15798 
15799             LBasicBlock trueCase = m_out.newBlock();
15800             LBasicBlock checkCase = m_out.newBlock();
15801             LBasicBlock continuation = m_out.newBlock();
15802 
15803             ValueFromBlock falseValue = m_out.anchor(m_out.booleanFalse);
15804             LValue isAnArrayStorageShape = m_out.belowOrEqual(
15805                 m_out.sub(
15806                     m_out.bitAnd(indexingType, m_out.constInt32(IndexingShapeMask)),
15807                     m_out.constInt32(ArrayStorageShape)),
15808                 m_out.constInt32(SlowPutArrayStorageShape - ArrayStorageShape));
15809             m_out.branch(isAnArrayStorageShape, unsure(checkCase), unsure(continuation));
15810 
15811             LBasicBlock lastNext = m_out.appendTo(checkCase, trueCase);
15812             switch (arrayMode.arrayClass()) {
15813             case Array::OriginalArray:
15814             case Array::OriginalCopyOnWriteArray:
15815                 DFG_CRASH(m_graph, m_node, &quot;Unexpected original array&quot;);
15816                 return nullptr;
15817 
15818             case Array::Array:
15819                 m_out.branch(
15820                     m_out.testNonZero32(indexingType, m_out.constInt32(IsArray)),
15821                     unsure(trueCase), unsure(continuation));
15822                 break;
15823 
15824             case Array::NonArray:
15825             case Array::OriginalNonArray:
15826                 m_out.branch(
15827                     m_out.testIsZero32(indexingType, m_out.constInt32(IsArray)),
15828                     unsure(trueCase), unsure(continuation));
15829                 break;
15830 
15831             case Array::PossiblyArray:
15832                 m_out.jump(trueCase);
15833                 break;
15834             }
15835 
15836             m_out.appendTo(trueCase, continuation);
15837             ValueFromBlock trueValue = m_out.anchor(m_out.booleanTrue);
15838             m_out.jump(continuation);
15839 
15840             m_out.appendTo(continuation, lastNext);
15841             return m_out.phi(Int32, falseValue, trueValue);
15842         }
15843 
15844         default:
15845             break;
15846         }
15847         DFG_CRASH(m_graph, m_node, &quot;Corrupt array class&quot;);
15848     }
15849 
15850     LValue isArrayTypeForCheckArray(LValue cell, ArrayMode arrayMode)
15851     {
15852         switch (arrayMode.type()) {
15853         case Array::Int32:
15854         case Array::Double:
15855         case Array::Contiguous:
15856         case Array::Undecided:
15857         case Array::ArrayStorage:
15858         case Array::SlowPutArrayStorage:
15859             return isArrayTypeForArrayify(cell, arrayMode);
15860 
15861         case Array::DirectArguments:
15862             return m_out.equal(
15863                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15864                 m_out.constInt32(DirectArgumentsType));
15865 
15866         case Array::ScopedArguments:
15867             return m_out.equal(
15868                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15869                 m_out.constInt32(ScopedArgumentsType));
15870 
15871         default:
15872             return m_out.equal(
15873                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15874                 m_out.constInt32(typeForTypedArrayType(arrayMode.typedArrayType())));
15875         }
15876     }
15877 
15878     LValue isFunction(LValue cell, SpeculatedType type = SpecFullTop)
15879     {
15880         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecFunction))
15881             return proven;
15882         return isType(cell, JSFunctionType);
15883     }
15884     LValue isNotFunction(LValue cell, SpeculatedType type = SpecFullTop)
15885     {
15886         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecFunction))
15887             return proven;
15888         return isNotType(cell, JSFunctionType);
15889     }
15890 
15891     LValue isExoticForTypeof(LValue cell, SpeculatedType type = SpecFullTop)
15892     {
15893         if (!(type &amp; SpecObjectOther))
15894             return m_out.booleanFalse;
15895         return m_out.testNonZero32(
15896             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
15897             m_out.constInt32(MasqueradesAsUndefined | OverridesGetCallData));
15898     }
15899 
15900     LValue isType(LValue cell, JSType type)
15901     {
15902         return m_out.equal(
15903             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15904             m_out.constInt32(type));
15905     }
15906 
15907     LValue isNotType(LValue cell, JSType type)
15908     {
15909         return m_out.logicalNot(isType(cell, type));
15910     }
15911 
15912     void speculateObject(Edge edge, LValue cell)
15913     {
15914         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecObject, isNotObject(cell));
15915     }
15916 
15917     void speculateObject(Edge edge)
15918     {
15919         speculateObject(edge, lowCell(edge));
15920     }
15921 
15922     void speculateArray(Edge edge, LValue cell)
15923     {
15924         FTL_TYPE_CHECK(
15925             jsValueValue(cell), edge, SpecArray, isNotType(cell, ArrayType));
15926     }
15927 
15928     void speculateArray(Edge edge)
15929     {
15930         speculateArray(edge, lowCell(edge));
15931     }
15932 
15933     void speculateFunction(Edge edge, LValue cell)
15934     {
15935         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecFunction, isNotFunction(cell));
15936     }
15937 
15938     void speculateFunction(Edge edge)
15939     {
15940         speculateFunction(edge, lowCell(edge));
15941     }
15942 
15943     void speculateObjectOrOther(Edge edge)
15944     {
15945         if (!m_interpreter.needsTypeCheck(edge))
15946             return;
15947 
15948         LValue value = lowJSValue(edge, ManualOperandSpeculation);
15949 
15950         LBasicBlock cellCase = m_out.newBlock();
15951         LBasicBlock primitiveCase = m_out.newBlock();
15952         LBasicBlock continuation = m_out.newBlock();
15953 
15954         m_out.branch(isNotCell(value, provenType(edge)), unsure(primitiveCase), unsure(cellCase));
15955 
15956         LBasicBlock lastNext = m_out.appendTo(cellCase, primitiveCase);
15957 
15958         FTL_TYPE_CHECK(
15959             jsValueValue(value), edge, (~SpecCellCheck) | SpecObject, isNotObject(value));
15960 
15961         m_out.jump(continuation);
15962 
15963         m_out.appendTo(primitiveCase, continuation);
15964 
15965         FTL_TYPE_CHECK(
15966             jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
15967 
15968         m_out.jump(continuation);
15969 
15970         m_out.appendTo(continuation, lastNext);
15971     }
15972 
15973     void speculateFinalObject(Edge edge, LValue cell)
15974     {
15975         FTL_TYPE_CHECK(
15976             jsValueValue(cell), edge, SpecFinalObject, isNotType(cell, FinalObjectType));
15977     }
15978 
15979     void speculateFinalObject(Edge edge)
15980     {
15981         speculateFinalObject(edge, lowCell(edge));
15982     }
15983 
15984     void speculateRegExpObject(Edge edge, LValue cell)
15985     {
15986         FTL_TYPE_CHECK(
15987             jsValueValue(cell), edge, SpecRegExpObject, isNotType(cell, RegExpObjectType));
15988     }
15989 
15990     void speculateRegExpObject(Edge edge)
15991     {
15992         speculateRegExpObject(edge, lowCell(edge));
15993     }
15994 
15995     void speculateProxyObject(Edge edge, LValue cell)
15996     {
15997         FTL_TYPE_CHECK(
15998             jsValueValue(cell), edge, SpecProxyObject, isNotType(cell, ProxyObjectType));
15999     }
16000 
16001     void speculateProxyObject(Edge edge)
16002     {
16003         speculateProxyObject(edge, lowCell(edge));
16004     }
16005 
16006     void speculateDerivedArray(Edge edge, LValue cell)
16007     {
16008         FTL_TYPE_CHECK(
16009             jsValueValue(cell), edge, SpecDerivedArray, isNotType(cell, DerivedArrayType));
16010     }
16011 
16012     void speculateDerivedArray(Edge edge)
16013     {
16014         speculateDerivedArray(edge, lowCell(edge));
16015     }
16016 
16017     void speculateMapObject(Edge edge, LValue cell)
16018     {
16019         FTL_TYPE_CHECK(
16020             jsValueValue(cell), edge, SpecMapObject, isNotType(cell, JSMapType));
16021     }
16022 
16023     void speculateMapObject(Edge edge)
16024     {
16025         speculateMapObject(edge, lowCell(edge));
16026     }
16027 
16028     void speculateSetObject(Edge edge, LValue cell)
16029     {
16030         FTL_TYPE_CHECK(
16031             jsValueValue(cell), edge, SpecSetObject, isNotType(cell, JSSetType));
16032     }
16033 
16034     void speculateSetObject(Edge edge)
16035     {
16036         speculateSetObject(edge, lowCell(edge));
16037     }
16038 
16039     void speculateWeakMapObject(Edge edge, LValue cell)
16040     {
16041         FTL_TYPE_CHECK(
16042             jsValueValue(cell), edge, SpecWeakMapObject, isNotType(cell, JSWeakMapType));
16043     }
16044 
16045     void speculateWeakMapObject(Edge edge)
16046     {
16047         speculateWeakMapObject(edge, lowCell(edge));
16048     }
16049 
16050     void speculateWeakSetObject(Edge edge, LValue cell)
16051     {
16052         FTL_TYPE_CHECK(
16053             jsValueValue(cell), edge, SpecWeakSetObject, isNotType(cell, JSWeakSetType));
16054     }
16055 
16056     void speculateWeakSetObject(Edge edge)
16057     {
16058         speculateWeakSetObject(edge, lowCell(edge));
16059     }
16060 
16061     void speculateDataViewObject(Edge edge, LValue cell)
16062     {
16063         FTL_TYPE_CHECK(
16064             jsValueValue(cell), edge, SpecDataViewObject, isNotType(cell, DataViewType));
16065     }
16066 
16067     void speculateDataViewObject(Edge edge)
16068     {
16069         speculateDataViewObject(edge, lowCell(edge));
16070     }
16071 
16072     void speculateString(Edge edge, LValue cell)
16073     {
16074         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecString, isNotString(cell));
16075     }
16076 
16077     void speculateString(Edge edge)
16078     {
16079         speculateString(edge, lowCell(edge));
16080     }
16081 
16082     void speculateStringOrOther(Edge edge, LValue value)
16083     {
16084         if (!m_interpreter.needsTypeCheck(edge))
16085             return;
16086 
16087         LBasicBlock cellCase = m_out.newBlock();
16088         LBasicBlock notCellCase = m_out.newBlock();
16089         LBasicBlock continuation = m_out.newBlock();
16090 
16091         m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
16092 
16093         LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
16094 
16095         FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
16096 
16097         m_out.jump(continuation);
16098         m_out.appendTo(notCellCase, continuation);
16099 
16100         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
16101 
16102         m_out.jump(continuation);
16103         m_out.appendTo(continuation, lastNext);
16104     }
16105 
16106     void speculateStringOrOther(Edge edge)
16107     {
16108         speculateStringOrOther(edge, lowJSValue(edge, ManualOperandSpeculation));
16109     }
16110 
16111     void speculateStringIdent(Edge edge, LValue string, LValue stringImpl)
16112     {
16113         if (!m_interpreter.needsTypeCheck(edge, SpecStringIdent | ~SpecString))
16114             return;
16115 
16116         speculate(BadType, jsValueValue(string), edge.node(), isRopeString(string));
16117         speculate(
16118             BadType, jsValueValue(string), edge.node(),
16119             m_out.testIsZero32(
16120                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
<a name="133" id="anc133"></a><span class="line-modified">16121                 m_out.constInt32(StringImpl::flagIsAtomic())));</span>
16122         m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
16123     }
16124 
16125     void speculateStringIdent(Edge edge)
16126     {
16127         lowStringIdent(edge);
16128     }
16129 
16130     void speculateStringObject(Edge edge)
16131     {
16132         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
16133             return;
16134 
16135         speculateStringObjectForCell(edge, lowCell(edge));
16136     }
16137 
16138     void speculateStringOrStringObject(Edge edge)
16139     {
16140         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
16141             return;
16142 
16143         LValue cellBase = lowCell(edge);
16144         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
16145             return;
16146 
16147         LBasicBlock notString = m_out.newBlock();
16148         LBasicBlock continuation = m_out.newBlock();
16149 
16150         LValue type = m_out.load8ZeroExt32(cellBase, m_heaps.JSCell_typeInfoType);
16151         m_out.branch(
16152             m_out.equal(type, m_out.constInt32(StringType)),
16153             unsure(continuation), unsure(notString));
16154 
16155         LBasicBlock lastNext = m_out.appendTo(notString, continuation);
16156         speculate(
16157             BadType, jsValueValue(cellBase), edge.node(),
16158             m_out.notEqual(type, m_out.constInt32(StringObjectType)));
16159         m_out.jump(continuation);
16160 
16161         m_out.appendTo(continuation, lastNext);
16162         m_interpreter.filter(edge, SpecString | SpecStringObject);
16163     }
16164 
16165     void speculateStringObjectForCell(Edge edge, LValue cell)
16166     {
16167         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
16168             return;
16169 
16170         LValue type = m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType);
16171         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecStringObject, m_out.notEqual(type, m_out.constInt32(StringObjectType)));
16172     }
16173 
16174     void speculateSymbol(Edge edge, LValue cell)
16175     {
16176         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecSymbol, isNotSymbol(cell));
16177     }
16178 
16179     void speculateSymbol(Edge edge)
16180     {
16181         speculateSymbol(edge, lowCell(edge));
16182     }
16183 
16184     void speculateBigInt(Edge edge, LValue cell)
16185     {
16186         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecBigInt, isNotBigInt(cell));
16187     }
16188 
16189     void speculateBigInt(Edge edge)
16190     {
16191         speculateBigInt(edge, lowCell(edge));
16192     }
16193 
16194     void speculateNonNullObject(Edge edge, LValue cell)
16195     {
16196         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecObject, isNotObject(cell));
16197         if (masqueradesAsUndefinedWatchpointIsStillValid())
16198             return;
16199 
16200         speculate(
16201             BadType, jsValueValue(cell), edge.node(),
16202             m_out.testNonZero32(
16203                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
16204                 m_out.constInt32(MasqueradesAsUndefined)));
16205     }
16206 
16207     void speculateNumber(Edge edge)
16208     {
16209         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16210         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecBytecodeNumber, isNotNumber(value));
16211     }
16212 
16213     void speculateRealNumber(Edge edge)
16214     {
16215         // Do an early return here because lowDouble() can create a lot of control flow.
16216         if (!m_interpreter.needsTypeCheck(edge))
16217             return;
16218 
16219         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16220         LValue doubleValue = unboxDouble(value);
16221 
16222         LBasicBlock intCase = m_out.newBlock();
16223         LBasicBlock continuation = m_out.newBlock();
16224 
16225         m_out.branch(
16226             m_out.doubleEqual(doubleValue, doubleValue),
16227             usually(continuation), rarely(intCase));
16228 
16229         LBasicBlock lastNext = m_out.appendTo(intCase, continuation);
16230 
16231         typeCheck(
16232             jsValueValue(value), m_node-&gt;child1(), SpecBytecodeRealNumber,
16233             isNotInt32(value, provenType(m_node-&gt;child1()) &amp; ~SpecFullDouble));
16234         m_out.jump(continuation);
16235 
16236         m_out.appendTo(continuation, lastNext);
16237     }
16238 
16239     void speculateDoubleRepReal(Edge edge)
16240     {
16241         // Do an early return here because lowDouble() can create a lot of control flow.
16242         if (!m_interpreter.needsTypeCheck(edge))
16243             return;
16244 
16245         LValue value = lowDouble(edge);
16246         FTL_TYPE_CHECK(
16247             doubleValue(value), edge, SpecDoubleReal,
16248             m_out.doubleNotEqualOrUnordered(value, value));
16249     }
16250 
16251     void speculateDoubleRepAnyInt(Edge edge)
16252     {
16253         if (!m_interpreter.needsTypeCheck(edge))
16254             return;
16255 
16256         doubleToStrictInt52(edge, lowDouble(edge));
16257     }
16258 
16259     void speculateBoolean(Edge edge)
16260     {
16261         lowBoolean(edge);
16262     }
16263 
16264     void speculateNotStringVar(Edge edge)
16265     {
16266         if (!m_interpreter.needsTypeCheck(edge, ~SpecStringVar))
16267             return;
16268 
16269         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16270 
16271         LBasicBlock isCellCase = m_out.newBlock();
16272         LBasicBlock isStringCase = m_out.newBlock();
16273         LBasicBlock continuation = m_out.newBlock();
16274 
16275         m_out.branch(isCell(value, provenType(edge)), unsure(isCellCase), unsure(continuation));
16276 
16277         LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
16278         m_out.branch(isString(value, provenType(edge)), unsure(isStringCase), unsure(continuation));
16279 
16280         m_out.appendTo(isStringCase, continuation);
16281         speculateStringIdent(edge, value, m_out.loadPtr(value, m_heaps.JSString_value));
16282         m_out.jump(continuation);
16283 
16284         m_out.appendTo(continuation, lastNext);
16285     }
16286 
16287     void speculateNotSymbol(Edge edge)
16288     {
16289         if (!m_interpreter.needsTypeCheck(edge, ~SpecSymbol))
16290             return;
16291 
16292         ASSERT(mayHaveTypeCheck(edge.useKind()));
16293         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16294 
16295         LBasicBlock isCellCase = m_out.newBlock();
16296         LBasicBlock continuation = m_out.newBlock();
16297 
16298         m_out.branch(isCell(value, provenType(edge)), unsure(isCellCase), unsure(continuation));
16299 
16300         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
16301         speculate(BadType, jsValueValue(value), edge.node(), isSymbol(value));
16302         m_out.jump(continuation);
16303 
16304         m_out.appendTo(continuation, lastNext);
16305 
16306         m_interpreter.filter(edge, ~SpecSymbol);
16307     }
16308 
16309     void speculateOther(Edge edge)
16310     {
16311         if (!m_interpreter.needsTypeCheck(edge))
16312             return;
16313 
16314         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16315         typeCheck(jsValueValue(value), edge, SpecOther, isNotOther(value));
16316     }
16317 
16318     void speculateMisc(Edge edge)
16319     {
16320         if (!m_interpreter.needsTypeCheck(edge))
16321             return;
16322 
16323         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16324         typeCheck(jsValueValue(value), edge, SpecMisc, isNotMisc(value));
16325     }
16326 
16327     void speculateTypedArrayIsNotNeutered(LValue base)
16328     {
16329         LBasicBlock isWasteful = m_out.newBlock();
16330         LBasicBlock continuation = m_out.newBlock();
16331 
16332         LValue mode = m_out.load32(base, m_heaps.JSArrayBufferView_mode);
16333         m_out.branch(m_out.equal(mode, m_out.constInt32(WastefulTypedArray)),
16334             unsure(isWasteful), unsure(continuation));
16335 
16336         LBasicBlock lastNext = m_out.appendTo(isWasteful, continuation);
16337         LValue vector = m_out.loadPtr(base, m_heaps.JSArrayBufferView_vector);
<a name="134" id="anc134"></a>


16338         speculate(Uncountable, jsValueValue(vector), m_node, m_out.isZero64(vector));
16339         m_out.jump(continuation);
16340 
16341         m_out.appendTo(continuation, lastNext);
16342     }
16343 
16344     bool masqueradesAsUndefinedWatchpointIsStillValid()
16345     {
16346         return m_graph.masqueradesAsUndefinedWatchpointIsStillValid(m_node-&gt;origin.semantic);
16347     }
16348 
16349     LValue loadCellState(LValue base)
16350     {
16351         return m_out.load8ZeroExt32(base, m_heaps.JSCell_cellState);
16352     }
16353 
16354     void emitStoreBarrier(LValue base, bool isFenced)
16355     {
16356         LBasicBlock recheckPath = nullptr;
16357         if (isFenced)
16358             recheckPath = m_out.newBlock();
16359         LBasicBlock slowPath = m_out.newBlock();
16360         LBasicBlock continuation = m_out.newBlock();
16361 
16362         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isFenced ? recheckPath : slowPath);
16363 
16364         LValue threshold;
16365         if (isFenced)
16366             threshold = m_out.load32(m_out.absolute(vm().heap.addressOfBarrierThreshold()));
16367         else
16368             threshold = m_out.constInt32(blackThreshold);
16369 
16370         m_out.branch(
16371             m_out.above(loadCellState(base), threshold),
16372             usually(continuation), rarely(isFenced ? recheckPath : slowPath));
16373 
16374         if (isFenced) {
16375             m_out.appendTo(recheckPath, slowPath);
16376 
16377             m_out.fence(&amp;m_heaps.root, &amp;m_heaps.JSCell_cellState);
16378 
16379             m_out.branch(
16380                 m_out.above(loadCellState(base), m_out.constInt32(blackThreshold)),
16381                 usually(continuation), rarely(slowPath));
16382         }
16383 
16384         m_out.appendTo(slowPath, continuation);
16385 
16386         LValue call = vmCall(Void, m_out.operation(operationWriteBarrierSlowPath), m_callFrame, base);
16387         m_heaps.decorateCCallRead(&amp;m_heaps.root, call);
16388         m_heaps.decorateCCallWrite(&amp;m_heaps.JSCell_cellState, call);
16389 
16390         m_out.jump(continuation);
16391 
16392         m_out.appendTo(continuation, lastNext);
16393     }
16394 
16395     void mutatorFence()
16396     {
16397         if (isX86()) {
16398             m_out.fence(&amp;m_heaps.root, nullptr);
16399             return;
16400         }
16401 
16402         LBasicBlock slowPath = m_out.newBlock();
16403         LBasicBlock continuation = m_out.newBlock();
16404 
16405         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
16406 
16407         m_out.branch(
16408             m_out.load8ZeroExt32(m_out.absolute(vm().heap.addressOfMutatorShouldBeFenced())),
16409             rarely(slowPath), usually(continuation));
16410 
16411         m_out.appendTo(slowPath, continuation);
16412 
16413         m_out.fence(&amp;m_heaps.root, nullptr);
16414         m_out.jump(continuation);
16415 
16416         m_out.appendTo(continuation, lastNext);
16417     }
16418 
16419     void nukeStructureAndSetButterfly(LValue butterfly, LValue object)
16420     {
16421         if (isX86()) {
16422             m_out.store32(
16423                 m_out.bitOr(
16424                     m_out.load32(object, m_heaps.JSCell_structureID),
16425                     m_out.constInt32(nukedStructureIDBit())),
16426                 object, m_heaps.JSCell_structureID);
16427             m_out.fence(&amp;m_heaps.root, nullptr);
16428             m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
16429             m_out.fence(&amp;m_heaps.root, nullptr);
16430             return;
16431         }
16432 
16433         LBasicBlock fastPath = m_out.newBlock();
16434         LBasicBlock slowPath = m_out.newBlock();
16435         LBasicBlock continuation = m_out.newBlock();
16436 
16437         LBasicBlock lastNext = m_out.insertNewBlocksBefore(fastPath);
16438 
16439         m_out.branch(
16440             m_out.load8ZeroExt32(m_out.absolute(vm().heap.addressOfMutatorShouldBeFenced())),
16441             rarely(slowPath), usually(fastPath));
16442 
16443         m_out.appendTo(fastPath, slowPath);
16444 
16445         m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
16446         m_out.jump(continuation);
16447 
16448         m_out.appendTo(slowPath, continuation);
16449 
16450         m_out.store32(
16451             m_out.bitOr(
16452                 m_out.load32(object, m_heaps.JSCell_structureID),
16453                 m_out.constInt32(nukedStructureIDBit())),
16454             object, m_heaps.JSCell_structureID);
16455         m_out.fence(&amp;m_heaps.root, nullptr);
16456         m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
16457         m_out.fence(&amp;m_heaps.root, nullptr);
16458         m_out.jump(continuation);
16459 
16460         m_out.appendTo(continuation, lastNext);
16461     }
16462 
16463     LValue preciseIndexMask64(LValue value, LValue index, LValue limit)
16464     {
16465         return m_out.bitAnd(
16466             value,
16467             m_out.aShr(
16468                 m_out.sub(
16469                     index,
16470                     m_out.opaque(limit)),
16471                 m_out.constInt32(63)));
16472     }
16473 
16474     LValue preciseIndexMask32(LValue value, LValue index, LValue limit)
16475     {
16476         return preciseIndexMask64(value, m_out.zeroExt(index, Int64), m_out.zeroExt(limit, Int64));
16477     }
16478 
16479     template&lt;typename... Args&gt;
16480     LValue vmCall(LType type, LValue function, Args&amp;&amp;... args)
16481     {
16482         callPreflight();
16483         LValue result = m_out.call(type, function, std::forward&lt;Args&gt;(args)...);
16484         if (mayExit(m_graph, m_node))
16485             callCheck();
16486         else {
16487             // We can&#39;t exit due to an exception, so we also can&#39;t throw an exception.
16488 #ifndef NDEBUG
16489             LBasicBlock crash = m_out.newBlock();
16490             LBasicBlock continuation = m_out.newBlock();
16491 
16492             LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
16493             LValue hadException = m_out.notZero64(exception);
16494 
16495             m_out.branch(
16496                 hadException, rarely(crash), usually(continuation));
16497 
16498             LBasicBlock lastNext = m_out.appendTo(crash, continuation);
16499             m_out.unreachable();
16500 
16501             m_out.appendTo(continuation, lastNext);
16502 #endif
16503         }
16504         return result;
16505     }
16506 
16507     void callPreflight(CodeOrigin codeOrigin)
16508     {
16509         CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(codeOrigin);
16510         m_out.store32(
16511             m_out.constInt32(callSiteIndex.bits()),
16512             tagFor(CallFrameSlot::argumentCount));
16513     }
16514 
16515     void callPreflight()
16516     {
16517         callPreflight(codeOriginDescriptionOfCallSite());
16518     }
16519 
16520     CodeOrigin codeOriginDescriptionOfCallSite() const
16521     {
16522         CodeOrigin codeOrigin = m_node-&gt;origin.semantic;
16523         if (m_node-&gt;op() == TailCallInlinedCaller
16524             || m_node-&gt;op() == TailCallVarargsInlinedCaller
16525             || m_node-&gt;op() == TailCallForwardVarargsInlinedCaller
16526             || m_node-&gt;op() == DirectTailCallInlinedCaller) {
16527             // This case arises when you have a situation like this:
16528             // foo makes a call to bar, bar is inlined in foo. bar makes a call
16529             // to baz and baz is inlined in bar. And then baz makes a tail-call to jaz,
16530             // and jaz is inlined in baz. We want the callframe for jaz to appear to
16531             // have caller be bar.
<a name="135" id="anc135"></a><span class="line-modified">16532             codeOrigin = *codeOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls();</span>
16533         }
16534 
16535         return codeOrigin;
16536     }
16537 
16538     void callCheck()
16539     {
16540         if (Options::useExceptionFuzz())
16541             m_out.call(Void, m_out.operation(operationExceptionFuzz), m_callFrame);
16542 
16543         LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
16544         LValue hadException = m_out.notZero64(exception);
16545 
16546         CodeOrigin opCatchOrigin;
16547         HandlerInfo* exceptionHandler;
16548         if (m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler)) {
16549             bool exitOK = true;
16550             bool isExceptionHandler = true;
16551             appendOSRExit(
16552                 ExceptionCheck, noValue(), nullptr, hadException,
16553                 m_origin.withForExitAndExitOK(opCatchOrigin, exitOK), isExceptionHandler);
16554             return;
16555         }
16556 
16557         LBasicBlock continuation = m_out.newBlock();
16558 
16559         m_out.branch(
16560             hadException, rarely(m_handleExceptions), usually(continuation));
16561 
16562         m_out.appendTo(continuation);
16563     }
16564 
16565     RefPtr&lt;PatchpointExceptionHandle&gt; preparePatchpointForExceptions(PatchpointValue* value)
16566     {
16567         CodeOrigin opCatchOrigin;
16568         HandlerInfo* exceptionHandler;
16569         bool willCatchException = m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler);
16570         if (!willCatchException)
16571             return PatchpointExceptionHandle::defaultHandle(m_ftlState);
16572 
<a name="136" id="anc136"></a><span class="line-modified">16573         if (verboseCompilationEnabled()) {</span>
<span class="line-removed">16574             dataLog(&quot;    Patchpoint exception OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap(), &quot;\n&quot;);</span>
<span class="line-removed">16575             if (!m_availableRecoveries.isEmpty())</span>
<span class="line-removed">16576                 dataLog(&quot;        Available recoveries: &quot;, listDump(m_availableRecoveries), &quot;\n&quot;);</span>
<span class="line-removed">16577         }</span>
16578 
16579         bool exitOK = true;
16580         NodeOrigin origin = m_origin.withForExitAndExitOK(opCatchOrigin, exitOK);
16581 
16582         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(noValue(), nullptr);
16583 
16584         // Compute the offset into the StackmapGenerationParams where we will find the exit arguments
16585         // we are about to append. We need to account for both the children we&#39;ve already added, and
16586         // for the possibility of a result value if the patchpoint is not void.
16587         unsigned offset = value-&gt;numChildren();
16588         if (value-&gt;type() != Void)
16589             offset++;
16590 
16591         // Use LateColdAny to ensure that the stackmap arguments interfere with the patchpoint&#39;s
16592         // result and with any late-clobbered registers.
16593         value-&gt;appendVectorWithRep(
16594             buildExitArguments(exitDescriptor, opCatchOrigin, noValue()),
16595             ValueRep::LateColdAny);
16596 
16597         return PatchpointExceptionHandle::create(
16598             m_ftlState, exitDescriptor, origin, offset, *exceptionHandler);
16599     }
16600 
16601     LBasicBlock lowBlock(DFG::BasicBlock* block)
16602     {
16603         return m_blocks.get(block);
16604     }
16605 
16606     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, Node* highValue)
16607     {
16608         return appendOSRExitDescriptor(lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue));
16609     }
16610 
16611     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile)
16612     {
16613         return &amp;m_ftlState.jitCode-&gt;osrExitDescriptors.alloc(
16614             lowValue.format(), profile,
16615             availabilityMap().m_locals.numberOfArguments(),
16616             availabilityMap().m_locals.numberOfLocals());
16617     }
16618 
16619     void appendOSRExit(
16620         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition,
16621         NodeOrigin origin, bool isExceptionHandler = false)
16622     {
16623         return appendOSRExit(kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue),
16624             failCondition, origin, isExceptionHandler);
16625     }
16626 
16627     void appendOSRExit(
16628         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition,
16629         NodeOrigin origin, bool isExceptionHandler = false)
16630     {
<a name="137" id="anc137"></a><span class="line-modified">16631         if (verboseCompilationEnabled()) {</span>
<span class="line-removed">16632             dataLog(&quot;    OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap(), &quot;\n&quot;);</span>
<span class="line-removed">16633             if (!m_availableRecoveries.isEmpty())</span>
<span class="line-removed">16634                 dataLog(&quot;        Available recoveries: &quot;, listDump(m_availableRecoveries), &quot;\n&quot;);</span>
<span class="line-removed">16635         }</span>
16636 
16637         DFG_ASSERT(m_graph, m_node, origin.exitOK);
16638 
16639         if (!isExceptionHandler
16640             &amp;&amp; Options::useOSRExitFuzz()
16641             &amp;&amp; canUseOSRExitFuzzing(m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic))
16642             &amp;&amp; doOSRExitFuzzing()) {
16643             LValue numberOfFuzzChecks = m_out.add(
16644                 m_out.load32(m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks)),
16645                 m_out.int32One);
16646 
16647             m_out.store32(numberOfFuzzChecks, m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks));
16648 
16649             if (unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter()) {
16650                 failCondition = m_out.bitOr(
16651                     failCondition,
16652                     m_out.aboveOrEqual(numberOfFuzzChecks, m_out.constInt32(atOrAfter)));
16653             }
16654             if (unsigned at = Options::fireOSRExitFuzzAt()) {
16655                 failCondition = m_out.bitOr(
16656                     failCondition,
16657                     m_out.equal(numberOfFuzzChecks, m_out.constInt32(at)));
16658             }
16659         }
16660 
16661         if (failCondition == m_out.booleanFalse)
16662             return;
16663 
16664         blessSpeculation(
16665             m_out.speculate(failCondition), kind, lowValue, profile, origin);
16666     }
16667 
16668     void blessSpeculation(CheckValue* value, ExitKind kind, FormattedValue lowValue, Node* highValue, NodeOrigin origin)
16669     {
16670         blessSpeculation(value, kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue), origin);
16671     }
16672 
16673     void blessSpeculation(CheckValue* value, ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, NodeOrigin origin)
16674     {
16675         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(lowValue, profile);
16676 
16677         value-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, lowValue));
16678 
16679         State* state = &amp;m_ftlState;
16680         value-&gt;setGenerator(
16681             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
16682                 exitDescriptor-&gt;emitOSRExit(
16683                     *state, kind, origin, jit, params, 0);
16684             });
16685     }
16686 
16687     StackmapArgumentList buildExitArguments(
16688         OSRExitDescriptor* exitDescriptor, CodeOrigin exitOrigin, FormattedValue lowValue,
16689         unsigned offsetOfExitArgumentsInStackmapLocations = 0)
16690     {
16691         StackmapArgumentList result;
16692         buildExitArguments(
16693             exitDescriptor, exitOrigin, result, lowValue, offsetOfExitArgumentsInStackmapLocations);
16694         return result;
16695     }
16696 
16697     void buildExitArguments(
16698         OSRExitDescriptor* exitDescriptor, CodeOrigin exitOrigin, StackmapArgumentList&amp; arguments, FormattedValue lowValue,
16699         unsigned offsetOfExitArgumentsInStackmapLocations = 0)
16700     {
16701         if (!!lowValue)
16702             arguments.append(lowValue.value());
16703 
16704         AvailabilityMap availabilityMap = this-&gt;availabilityMap();
16705         availabilityMap.pruneByLiveness(m_graph, exitOrigin);
16706 
16707         HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt; map;
16708         availabilityMap.forEachAvailability(
16709             [&amp;] (Availability availability) {
16710                 if (!availability.shouldUseNode())
16711                     return;
16712 
16713                 Node* node = availability.node();
16714                 if (!node-&gt;isPhantomAllocation())
16715                     return;
16716 
16717                 auto result = map.add(node, nullptr);
16718                 if (result.isNewEntry) {
16719                     result.iterator-&gt;value =
16720                         exitDescriptor-&gt;m_materializations.add(node-&gt;op(), node-&gt;origin.semantic);
16721                 }
16722             });
16723 
16724         for (unsigned i = 0; i &lt; exitDescriptor-&gt;m_values.size(); ++i) {
16725             int operand = exitDescriptor-&gt;m_values.operandForIndex(i);
16726 
16727             Availability availability = availabilityMap.m_locals[i];
16728 
16729             if (Options::validateFTLOSRExitLiveness()
16730                 &amp;&amp; m_graph.m_plan.mode() != FTLForOSREntryMode) {
16731 
16732                 if (availability.isDead() &amp;&amp; m_graph.isLiveInBytecode(VirtualRegister(operand), exitOrigin))
16733                     DFG_CRASH(m_graph, m_node, toCString(&quot;Live bytecode local not available: operand = &quot;, VirtualRegister(operand), &quot;, availability = &quot;, availability, &quot;, origin = &quot;, exitOrigin).data());
16734             }
16735             ExitValue exitValue = exitValueForAvailability(arguments, map, availability);
16736             if (exitValue.hasIndexInStackmapLocations())
16737                 exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
16738             exitDescriptor-&gt;m_values[i] = exitValue;
16739         }
16740 
16741         for (auto heapPair : availabilityMap.m_heap) {
16742             Node* node = heapPair.key.base();
16743             ExitTimeObjectMaterialization* materialization = map.get(node);
16744             if (!materialization)
16745                 DFG_CRASH(m_graph, m_node, toCString(&quot;Could not find materialization for &quot;, node, &quot; in &quot;, availabilityMap).data());
16746             ExitValue exitValue = exitValueForAvailability(arguments, map, heapPair.value);
16747             if (exitValue.hasIndexInStackmapLocations())
16748                 exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
16749             materialization-&gt;add(
16750                 heapPair.key.descriptor(),
16751                 exitValue);
16752         }
16753 
16754         if (verboseCompilationEnabled()) {
16755             dataLog(&quot;        Exit values: &quot;, exitDescriptor-&gt;m_values, &quot;\n&quot;);
16756             if (!exitDescriptor-&gt;m_materializations.isEmpty()) {
16757                 dataLog(&quot;        Materializations: \n&quot;);
16758                 for (ExitTimeObjectMaterialization* materialization : exitDescriptor-&gt;m_materializations)
16759                     dataLog(&quot;            &quot;, pointerDump(materialization), &quot;\n&quot;);
16760             }
16761         }
16762     }
16763 
16764     ExitValue exitValueForAvailability(
16765         StackmapArgumentList&amp; arguments, const HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt;&amp; map,
16766         Availability availability)
16767     {
16768         FlushedAt flush = availability.flushedAt();
16769         switch (flush.format()) {
16770         case DeadFlush:
16771         case ConflictingFlush:
16772             if (availability.hasNode())
16773                 return exitValueForNode(arguments, map, availability.node());
16774 
16775             // This means that the value is dead. It could be dead in bytecode or it could have
16776             // been killed by our DCE, which can sometimes kill things even if they were live in
16777             // bytecode.
16778             return ExitValue::dead();
16779 
16780         case FlushedJSValue:
16781         case FlushedCell:
16782         case FlushedBoolean:
16783             return ExitValue::inJSStack(flush.virtualRegister());
16784 
16785         case FlushedInt32:
16786             return ExitValue::inJSStackAsInt32(flush.virtualRegister());
16787 
16788         case FlushedInt52:
16789             return ExitValue::inJSStackAsInt52(flush.virtualRegister());
16790 
16791         case FlushedDouble:
16792             return ExitValue::inJSStackAsDouble(flush.virtualRegister());
16793         }
16794 
16795         DFG_CRASH(m_graph, m_node, &quot;Invalid flush format&quot;);
16796         return ExitValue::dead();
16797     }
16798 
16799     ExitValue exitValueForNode(
16800         StackmapArgumentList&amp; arguments, const HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt;&amp; map,
16801         Node* node)
16802     {
16803         // NOTE: In FTL-&gt;B3, we cannot generate code here, because m_output is positioned after the
16804         // stackmap value. Like all values, the stackmap value cannot use a child that is defined after
16805         // it.
16806 
16807         ASSERT(node-&gt;shouldGenerate());
16808         ASSERT(node-&gt;hasResult());
16809 
16810         if (node) {
16811             switch (node-&gt;op()) {
16812             case BottomValue:
16813                 // This might arise in object materializations. I actually doubt that it would,
16814                 // but it seems worthwhile to be conservative.
16815                 return ExitValue::dead();
16816 
16817             case JSConstant:
16818             case Int52Constant:
16819             case DoubleConstant:
16820                 return ExitValue::constant(node-&gt;asJSValue());
16821 
16822             default:
16823                 if (node-&gt;isPhantomAllocation())
16824                     return ExitValue::materializeNewObject(map.get(node));
16825                 break;
16826             }
16827         }
16828 
<a name="138" id="anc138"></a><span class="line-removed">16829         for (unsigned i = 0; i &lt; m_availableRecoveries.size(); ++i) {</span>
<span class="line-removed">16830             AvailableRecovery recovery = m_availableRecoveries[i];</span>
<span class="line-removed">16831             if (recovery.node() != node)</span>
<span class="line-removed">16832                 continue;</span>
<span class="line-removed">16833             ExitValue result = ExitValue::recovery(</span>
<span class="line-removed">16834                 recovery.opcode(), arguments.size(), arguments.size() + 1,</span>
<span class="line-removed">16835                 recovery.format());</span>
<span class="line-removed">16836             arguments.append(recovery.left());</span>
<span class="line-removed">16837             arguments.append(recovery.right());</span>
<span class="line-removed">16838             return result;</span>
<span class="line-removed">16839         }</span>
<span class="line-removed">16840 </span>
16841         LoweredNodeValue value = m_int32Values.get(node);
16842         if (isValid(value))
16843             return exitArgument(arguments, DataFormatInt32, value.value());
16844 
16845         value = m_int52Values.get(node);
16846         if (isValid(value))
16847             return exitArgument(arguments, DataFormatInt52, value.value());
16848 
16849         value = m_strictInt52Values.get(node);
16850         if (isValid(value))
16851             return exitArgument(arguments, DataFormatStrictInt52, value.value());
16852 
16853         value = m_booleanValues.get(node);
16854         if (isValid(value))
16855             return exitArgument(arguments, DataFormatBoolean, value.value());
16856 
16857         value = m_jsValueValues.get(node);
16858         if (isValid(value))
16859             return exitArgument(arguments, DataFormatJS, value.value());
16860 
16861         value = m_doubleValues.get(node);
16862         if (isValid(value))
16863             return exitArgument(arguments, DataFormatDouble, value.value());
16864 
16865         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
16866         return ExitValue::dead();
16867     }
16868 
16869     ExitValue exitArgument(StackmapArgumentList&amp; arguments, DataFormat format, LValue value)
16870     {
16871         ExitValue result = ExitValue::exitArgument(ExitArgument(format, arguments.size()));
16872         arguments.append(value);
16873         return result;
16874     }
16875 
16876     ExitValue exitValueForTailCall(StackmapArgumentList&amp; arguments, Node* node)
16877     {
16878         ASSERT(node-&gt;shouldGenerate());
16879         ASSERT(node-&gt;hasResult());
16880 
16881         switch (node-&gt;op()) {
16882         case JSConstant:
16883         case Int52Constant:
16884         case DoubleConstant:
16885             return ExitValue::constant(node-&gt;asJSValue());
16886 
16887         default:
16888             break;
16889         }
16890 
16891         LoweredNodeValue value = m_jsValueValues.get(node);
16892         if (isValid(value))
16893             return exitArgument(arguments, DataFormatJS, value.value());
16894 
16895         value = m_int32Values.get(node);
16896         if (isValid(value))
16897             return exitArgument(arguments, DataFormatJS, boxInt32(value.value()));
16898 
16899         value = m_booleanValues.get(node);
16900         if (isValid(value))
16901             return exitArgument(arguments, DataFormatJS, boxBoolean(value.value()));
16902 
16903         // Doubles and Int52 have been converted by ValueRep()
16904         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
16905     }
16906 
<a name="139" id="anc139"></a><span class="line-removed">16907     void addAvailableRecovery(</span>
<span class="line-removed">16908         Node* node, RecoveryOpcode opcode, LValue left, LValue right, DataFormat format)</span>
<span class="line-removed">16909     {</span>
<span class="line-removed">16910         m_availableRecoveries.append(AvailableRecovery(node, opcode, left, right, format));</span>
<span class="line-removed">16911     }</span>
<span class="line-removed">16912 </span>
<span class="line-removed">16913     void addAvailableRecovery(</span>
<span class="line-removed">16914         Edge edge, RecoveryOpcode opcode, LValue left, LValue right, DataFormat format)</span>
<span class="line-removed">16915     {</span>
<span class="line-removed">16916         addAvailableRecovery(edge.node(), opcode, left, right, format);</span>
<span class="line-removed">16917     }</span>
<span class="line-removed">16918 </span>
16919     void setInt32(Node* node, LValue value)
16920     {
16921         m_int32Values.set(node, LoweredNodeValue(value, m_highBlock));
16922     }
16923     void setInt52(Node* node, LValue value)
16924     {
16925         m_int52Values.set(node, LoweredNodeValue(value, m_highBlock));
16926     }
16927     void setStrictInt52(Node* node, LValue value)
16928     {
16929         m_strictInt52Values.set(node, LoweredNodeValue(value, m_highBlock));
16930     }
16931     void setInt52(Node* node, LValue value, Int52Kind kind)
16932     {
16933         switch (kind) {
16934         case Int52:
16935             setInt52(node, value);
16936             return;
16937 
16938         case StrictInt52:
16939             setStrictInt52(node, value);
16940             return;
16941         }
16942 
16943         DFG_CRASH(m_graph, m_node, &quot;Corrupt int52 kind&quot;);
16944     }
16945     void setJSValue(Node* node, LValue value)
16946     {
16947         m_jsValueValues.set(node, LoweredNodeValue(value, m_highBlock));
16948     }
16949     void setBoolean(Node* node, LValue value)
16950     {
16951         m_booleanValues.set(node, LoweredNodeValue(value, m_highBlock));
16952     }
16953     void setStorage(Node* node, LValue value)
16954     {
16955         m_storageValues.set(node, LoweredNodeValue(value, m_highBlock));
16956     }
16957     void setDouble(Node* node, LValue value)
16958     {
16959         m_doubleValues.set(node, LoweredNodeValue(value, m_highBlock));
16960     }
16961 
16962     void setInt32(LValue value)
16963     {
16964         setInt32(m_node, value);
16965     }
16966     void setInt52(LValue value)
16967     {
16968         setInt52(m_node, value);
16969     }
16970     void setStrictInt52(LValue value)
16971     {
16972         setStrictInt52(m_node, value);
16973     }
16974     void setInt52(LValue value, Int52Kind kind)
16975     {
16976         setInt52(m_node, value, kind);
16977     }
16978     void setJSValue(LValue value)
16979     {
16980         setJSValue(m_node, value);
16981     }
16982     void setBoolean(LValue value)
16983     {
16984         setBoolean(m_node, value);
16985     }
16986     void setStorage(LValue value)
16987     {
16988         setStorage(m_node, value);
16989     }
16990     void setDouble(LValue value)
16991     {
16992         setDouble(m_node, value);
16993     }
16994 
16995     bool isValid(const LoweredNodeValue&amp; value)
16996     {
16997         if (!value)
16998             return false;
16999         if (!m_graph.m_ssaDominators-&gt;dominates(value.block(), m_highBlock))
17000             return false;
17001         return true;
17002     }
17003 
17004     void keepAlive(LValue value)
17005     {
17006         PatchpointValue* patchpoint = m_out.patchpoint(Void);
17007         patchpoint-&gt;effects = Effects::none();
17008         patchpoint-&gt;effects.writesLocalState = true;
<a name="140" id="anc140"></a>
17009         patchpoint-&gt;append(value, ValueRep::ColdAny);
17010         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
17011     }
17012 
17013     void addWeakReference(JSCell* target)
17014     {
17015         m_graph.m_plan.weakReferences().addLazily(target);
17016     }
17017 
17018     LValue loadStructure(LValue value)
17019     {
17020         LValue structureID = m_out.load32(value, m_heaps.JSCell_structureID);
17021         LValue tableBase = m_out.loadPtr(m_out.absolute(vm().heap.structureIDTable().base()));
17022         LValue tableIndex = m_out.aShr(structureID, m_out.constInt32(StructureIDTable::s_numberOfEntropyBits));
17023         LValue entropyBits = m_out.shl(m_out.zeroExtPtr(structureID), m_out.constInt32(StructureIDTable::s_entropyBitsShiftForStructurePointer));
17024         TypedPointer address = m_out.baseIndex(m_heaps.structureTable, tableBase, m_out.zeroExtPtr(tableIndex));
17025         LValue encodedStructureBits = m_out.loadPtr(address);
17026         return m_out.bitXor(encodedStructureBits, entropyBits);
17027     }
17028 
17029     LValue weakPointer(JSCell* pointer)
17030     {
17031         addWeakReference(pointer);
17032         return m_out.weakPointer(m_graph, pointer);
17033     }
17034 
17035     LValue frozenPointer(FrozenValue* value)
17036     {
17037         return m_out.weakPointer(value);
17038     }
17039 
17040     LValue weakStructureID(RegisteredStructure structure)
17041     {
17042         return m_out.constInt32(structure-&gt;id());
17043     }
17044 
17045     LValue weakStructure(RegisteredStructure structure)
17046     {
17047         ASSERT(!!structure.get());
17048         return m_out.weakPointer(m_graph, structure.get());
17049     }
17050 
17051     TypedPointer addressFor(LValue base, int operand, ptrdiff_t offset = 0)
17052     {
17053         return m_out.address(base, m_heaps.variables[operand], offset);
17054     }
17055     TypedPointer payloadFor(LValue base, int operand)
17056     {
17057         return addressFor(base, operand, PayloadOffset);
17058     }
17059     TypedPointer tagFor(LValue base, int operand)
17060     {
17061         return addressFor(base, operand, TagOffset);
17062     }
17063     TypedPointer addressFor(int operand, ptrdiff_t offset = 0)
17064     {
17065         return addressFor(VirtualRegister(operand), offset);
17066     }
17067     TypedPointer addressFor(VirtualRegister operand, ptrdiff_t offset = 0)
17068     {
17069         if (operand.isLocal())
17070             return addressFor(m_captured, operand.offset(), offset);
17071         return addressFor(m_callFrame, operand.offset(), offset);
17072     }
17073     TypedPointer payloadFor(int operand)
17074     {
17075         return payloadFor(VirtualRegister(operand));
17076     }
17077     TypedPointer payloadFor(VirtualRegister operand)
17078     {
17079         return addressFor(operand, PayloadOffset);
17080     }
17081     TypedPointer tagFor(int operand)
17082     {
17083         return tagFor(VirtualRegister(operand));
17084     }
17085     TypedPointer tagFor(VirtualRegister operand)
17086     {
17087         return addressFor(operand, TagOffset);
17088     }
17089 
17090     AbstractValue abstractValue(Node* node)
17091     {
17092         return m_state.forNode(node);
17093     }
17094     AbstractValue abstractValue(Edge edge)
17095     {
17096         return abstractValue(edge.node());
17097     }
17098 
17099     SpeculatedType provenType(Node* node)
17100     {
17101         return abstractValue(node).m_type;
17102     }
17103     SpeculatedType provenType(Edge edge)
17104     {
17105         return provenType(edge.node());
17106     }
17107 
17108     JSValue provenValue(Node* node)
17109     {
17110         return abstractValue(node).m_value;
17111     }
17112     JSValue provenValue(Edge edge)
17113     {
17114         return provenValue(edge.node());
17115     }
17116 
17117     StructureAbstractValue abstractStructure(Node* node)
17118     {
17119         return abstractValue(node).m_structure;
17120     }
17121     StructureAbstractValue abstractStructure(Edge edge)
17122     {
17123         return abstractStructure(edge.node());
17124     }
17125 
17126     void crash()
17127     {
17128         crash(m_highBlock, m_node);
17129     }
17130     void crash(DFG::BasicBlock* block, Node* node)
17131     {
17132         BlockIndex blockIndex = block-&gt;index;
17133         unsigned nodeIndex = node ? node-&gt;index() : UINT_MAX;
17134 #if ASSERT_DISABLED
17135         m_out.patchpoint(Void)-&gt;setGenerator(
17136             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
17137                 AllowMacroScratchRegisterUsage allowScratch(jit);
17138 
17139                 jit.move(CCallHelpers::TrustedImm32(blockIndex), GPRInfo::regT0);
17140                 jit.move(CCallHelpers::TrustedImm32(nodeIndex), GPRInfo::regT1);
17141                 if (node)
17142                     jit.move(CCallHelpers::TrustedImm32(node-&gt;op()), GPRInfo::regT2);
17143                 jit.abortWithReason(FTLCrash);
17144             });
17145 #else
17146         m_out.call(
17147             Void,
17148             m_out.constIntPtr(ftlUnreachable),
17149             // We don&#39;t want the CodeBlock to have a weak pointer to itself because
17150             // that would cause it to always get collected.
17151             m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), m_out.constInt32(blockIndex),
17152             m_out.constInt32(nodeIndex));
17153 #endif
17154         m_out.unreachable();
17155     }
17156 
17157     AvailabilityMap&amp; availabilityMap() { return m_availabilityCalculator.m_availability; }
17158 
17159     VM&amp; vm() { return m_graph.m_vm; }
17160     CodeBlock* codeBlock() { return m_graph.m_codeBlock; }
17161 
17162     Graph&amp; m_graph;
17163     State&amp; m_ftlState;
17164     AbstractHeapRepository m_heaps;
17165     Output m_out;
17166     Procedure&amp; m_proc;
17167 
17168     LBasicBlock m_handleExceptions;
17169     HashMap&lt;DFG::BasicBlock*, LBasicBlock&gt; m_blocks;
17170 
17171     LValue m_callFrame;
17172     LValue m_captured;
17173     LValue m_tagTypeNumber;
17174     LValue m_tagMask;
17175 
17176     HashMap&lt;Node*, LoweredNodeValue&gt; m_int32Values;
17177     HashMap&lt;Node*, LoweredNodeValue&gt; m_strictInt52Values;
17178     HashMap&lt;Node*, LoweredNodeValue&gt; m_int52Values;
17179     HashMap&lt;Node*, LoweredNodeValue&gt; m_jsValueValues;
17180     HashMap&lt;Node*, LoweredNodeValue&gt; m_booleanValues;
17181     HashMap&lt;Node*, LoweredNodeValue&gt; m_storageValues;
17182     HashMap&lt;Node*, LoweredNodeValue&gt; m_doubleValues;
17183 
17184     HashMap&lt;Node*, LValue&gt; m_phis;
17185 
17186     LocalOSRAvailabilityCalculator m_availabilityCalculator;
17187 
<a name="141" id="anc141"></a><span class="line-removed">17188     Vector&lt;AvailableRecovery, 3&gt; m_availableRecoveries;</span>
<span class="line-removed">17189 </span>
17190     InPlaceAbstractState m_state;
17191     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
17192     DFG::BasicBlock* m_highBlock;
17193     DFG::BasicBlock* m_nextHighBlock;
17194     LBasicBlock m_nextLowBlock;
17195 
17196     enum IndexMaskingMode { IndexMaskingDisabled, IndexMaskingEnabled };
17197 
17198     IndexMaskingMode m_indexMaskingMode;
17199 
17200     NodeOrigin m_origin;
17201     unsigned m_nodeIndex;
17202     Node* m_node;
<a name="142" id="anc142"></a>




17203 };
17204 
17205 } // anonymous namespace
17206 
17207 void lowerDFGToB3(State&amp; state)
17208 {
17209     LowerDFGToB3 lowering(state);
17210     lowering.lower();
17211 }
17212 
17213 } } // namespace JSC::FTL
17214 
17215 #endif // ENABLE(FTL_JIT)
17216 
<a name="143" id="anc143"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="143" type="hidden" />
</body>
</html>