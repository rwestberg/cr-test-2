<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007, 2014-2015 Apple Inc.  All rights reserved.
   3  * Copyright (C) 2013 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 //# sourceURL=__InjectedScript_InjectedScriptSource.js
  31 
  32 (function (InjectedScriptHost, inspectedGlobalObject, injectedScriptId) {
  33 
  34 // FIXME: &lt;https://webkit.org/b/152294&gt; Web Inspector: Parse InjectedScriptSource as a built-in to get guaranteed non-user-overridden built-ins
  35 
  36 var Object = {}.constructor;
  37 
  38 function toString(obj)
  39 {
  40     return String(obj);
  41 }
  42 
  43 function toStringDescription(obj)
  44 {
  45     if (obj === 0 &amp;&amp; 1 / obj &lt; 0)
  46         return &quot;-0&quot;;
  47 
  48     if (isBigInt(obj))
  49         return toString(obj) + &quot;n&quot;;
  50 
  51     return toString(obj);
  52 }
  53 
  54 function isUInt32(obj)
  55 {
  56     if (typeof obj === &quot;number&quot;)
  57         return obj &gt;&gt;&gt; 0 === obj &amp;&amp; (obj &gt; 0 || 1 / obj &gt; 0);
  58     return &quot;&quot; + (obj &gt;&gt;&gt; 0) === obj;
  59 }
  60 
  61 function isSymbol(value)
  62 {
  63     return typeof value === &quot;symbol&quot;;
  64 }
  65 
  66 function isBigInt(value)
  67 {
  68     return typeof value === &quot;bigint&quot;;
  69 }
  70 
  71 function isEmptyObject(object)
  72 {
  73     for (let key in object)
  74         return false;
  75     return true;
  76 }
  77 
  78 function isDefined(value)
  79 {
  80     return !!value || InjectedScriptHost.isHTMLAllCollection(value);
  81 }
  82 
  83 function isPrimitiveValue(value)
  84 {
  85     switch (typeof value) {
  86     case &quot;boolean&quot;:
  87     case &quot;number&quot;:
  88     case &quot;string&quot;:
  89         return true;
  90     case &quot;undefined&quot;:
  91         return !InjectedScriptHost.isHTMLAllCollection(value);
  92     default:
  93         return false;
  94     }
  95 }
  96 
  97 // -------
  98 
  99 let InjectedScript = class InjectedScript
 100 {
 101     constructor()
 102     {
 103         this._lastBoundObjectId = 1;
 104         this._idToWrappedObject = {};
 105         this._idToObjectGroupName = {};
 106         this._objectGroups = {};
 107         this._modules = {};
 108         this._nextSavedResultIndex = 1;
 109         this._savedResults = [];
 110     }
 111 
 112     // InjectedScript C++ API
 113 
 114     execute(functionString, objectGroup, includeCommandLineAPI, returnByValue, generatePreview, saveResult, args)
 115     {
 116         return this._wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 117             const isEvalOnCallFrame = false;
 118             return this._evaluateOn(InjectedScriptHost.evaluateWithScopeExtension, InjectedScriptHost, functionString, isEvalOnCallFrame, includeCommandLineAPI).apply(undefined, args);
 119         });
 120     }
 121 
 122     evaluate(expression, objectGroup, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 123     {
 124         const isEvalOnCallFrame = false;
 125         return this._evaluateAndWrap(InjectedScriptHost.evaluateWithScopeExtension, InjectedScriptHost, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult);
 126     }
 127 
 128     awaitPromise(promiseObjectId, returnByValue, generatePreview, saveResult, callback)
 129     {
 130         let parsedPromiseObjectId = this._parseObjectId(promiseObjectId);
 131         let promiseObject = this._objectForId(parsedPromiseObjectId);
 132         let promiseObjectGroupName = this._idToObjectGroupName[parsedPromiseObjectId.id];
 133 
 134         if (!isDefined(promiseObject)) {
 135             callback(&quot;Could not find object with given id&quot;);
 136             return;
 137         }
 138 
 139         if (!(promiseObject instanceof Promise)) {
 140             callback(&quot;Object with given id is not a Promise&quot;);
 141             return;
 142         }
 143 
 144         let resolve = (value) =&gt; {
 145             let returnObject = {
 146                 wasThrown: false,
 147                 result: RemoteObject.create(value, promiseObjectGroupName, returnByValue, generatePreview),
 148             };
 149 
 150             if (saveResult) {
 151                 this._savedResultIndex = 0;
 152                 this._saveResult(returnObject.result);
 153                 if (this._savedResultIndex)
 154                     returnObject.savedResultIndex = this._savedResultIndex;
 155             }
 156 
 157             callback(returnObject);
 158         };
 159         let reject = (reason) =&gt; {
 160             callback(this._createThrownValue(reason, promiseObjectGroupName));
 161         };
 162         promiseObject.then(resolve, reject);
 163     }
 164 
 165     evaluateOnCallFrame(topCallFrame, callFrameId, expression, objectGroup, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 166     {
 167         let callFrame = this._callFrameForId(topCallFrame, callFrameId);
 168         if (!callFrame)
 169             return &quot;Could not find call frame with given id&quot;;
 170         const isEvalOnCallFrame = true;
 171         return this._evaluateAndWrap(callFrame.evaluateWithScopeExtension, callFrame, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult);
 172     }
 173 
 174     callFunctionOn(objectId, expression, args, returnByValue, generatePreview)
 175     {
 176         let parsedObjectId = this._parseObjectId(objectId);
 177         let object = this._objectForId(parsedObjectId);
 178         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 179 
 180         if (!isDefined(object))
 181             return &quot;Could not find object with given id&quot;;
 182 
 183         let resolvedArgs = [];
 184         if (args) {
 185             let callArgs = InjectedScriptHost.evaluate(args);
 186             for (let i = 0; i &lt; callArgs.length; ++i) {
 187                 try {
 188                     resolvedArgs[i] = this._resolveCallArgument(callArgs[i]);
 189                 } catch (e) {
 190                     return String(e);
 191                 }
 192             }
 193         }
 194 
 195         try {
 196             let func = InjectedScriptHost.evaluate(&quot;(&quot; + expression + &quot;)&quot;);
 197             if (typeof func !== &quot;function&quot;)
 198                 return &quot;Given expression does not evaluate to a function&quot;;
 199 
 200             return {
 201                 wasThrown: false,
 202                 result: RemoteObject.create(func.apply(object, resolvedArgs), objectGroupName, returnByValue, generatePreview)
 203             };
 204         } catch (e) {
 205             return this._createThrownValue(e, objectGroupName);
 206         }
 207     }
 208 
 209     getFunctionDetails(objectId)
 210     {
 211         let parsedObjectId = this._parseObjectId(objectId);
 212         let object = this._objectForId(parsedObjectId);
 213         if (typeof object !== &quot;function&quot;)
 214             return &quot;Cannot resolve function by id.&quot;;
 215         return this.functionDetails(object);
 216     }
 217 
 218     functionDetails(func)
 219     {
 220         let details = InjectedScriptHost.functionDetails(func);
 221         if (!details)
 222             return &quot;Cannot resolve function details.&quot;;
 223         return details;
 224     }
 225 
 226     getPreview(objectId)
 227     {
 228         let parsedObjectId = this._parseObjectId(objectId);
 229         let object = this._objectForId(parsedObjectId);
 230         return RemoteObject.createObjectPreviewForValue(object, true);
 231     }
 232 
 233     getProperties(objectId, ownProperties, generatePreview)
 234     {
 235         let nativeGettersAsValues = false;
 236         let collectionMode = ownProperties ? InjectedScript.CollectionMode.OwnProperties : InjectedScript.CollectionMode.AllProperties;
 237         return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);
 238     }
 239 
 240     getDisplayableProperties(objectId, generatePreview)
 241     {
 242         let nativeGettersAsValues = true;
 243         let collectionMode = InjectedScript.CollectionMode.OwnProperties | InjectedScript.CollectionMode.NativeGetterProperties;
 244         return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);
 245     }
 246 
 247     getInternalProperties(objectId, generatePreview)
 248     {
 249         let parsedObjectId = this._parseObjectId(objectId);
 250         let object = this._objectForId(parsedObjectId);
 251         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 252 
 253         if (!isDefined(object))
 254             return false;
 255 
 256         if (isSymbol(object))
 257             return false;
 258 
 259         let descriptors = this._internalPropertyDescriptors(object);
 260         if (!descriptors)
 261             return [];
 262 
 263         for (let i = 0; i &lt; descriptors.length; ++i) {
 264             let descriptor = descriptors[i];
 265             if (&quot;value&quot; in descriptor)
 266                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
 267         }
 268 
 269         return descriptors;
 270     }
 271 
 272     getCollectionEntries(objectId, objectGroupName, startIndex, numberToFetch)
 273     {
 274         let parsedObjectId = this._parseObjectId(objectId);
 275         let object = this._objectForId(parsedObjectId);
 276         objectGroupName = objectGroupName || this._idToObjectGroupName[parsedObjectId.id];
 277 
 278         if (!isDefined(object))
 279             return;
 280 
 281         if (typeof object !== &quot;object&quot;)
 282             return;
 283 
 284         let entries = this._entries(object, InjectedScriptHost.subtype(object), startIndex, numberToFetch);
 285         return entries.map(function(entry) {
 286             entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
 287             if (&quot;key&quot; in entry)
 288                 entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
 289             return entry;
 290         });
 291     }
 292 
 293     saveResult(callArgumentJSON)
 294     {
 295         this._savedResultIndex = 0;
 296 
 297         try {
 298             let callArgument = InjectedScriptHost.evaluate(&quot;(&quot; + callArgumentJSON + &quot;)&quot;);
 299             let value = this._resolveCallArgument(callArgument);
 300             this._saveResult(value);
 301         } catch { }
 302 
 303         return this._savedResultIndex;
 304     }
 305 
 306     wrapCallFrames(callFrame)
 307     {
 308         if (!callFrame)
 309             return false;
 310 
 311         let result = [];
 312         let depth = 0;
 313         do {
 314             result.push(new InjectedScript.CallFrameProxy(depth++, callFrame));
 315             callFrame = callFrame.caller;
 316         } while (callFrame);
 317         return result;
 318     }
 319 
 320     wrapObject(object, groupName, canAccessInspectedGlobalObject, generatePreview)
 321     {
 322         if (!canAccessInspectedGlobalObject)
 323             return this._fallbackWrapper(object);
 324 
 325         return RemoteObject.create(object, groupName, false, generatePreview);
 326     }
 327 
 328     wrapJSONString(jsonString, groupName, generatePreview)
 329     {
 330         try {
 331             return this.wrapObject(JSON.parse(jsonString), groupName, true, generatePreview);
 332         } catch {
 333             return null;
 334         }
 335     }
 336 
 337     wrapTable(canAccessInspectedGlobalObject, table, columns)
 338     {
 339         if (!canAccessInspectedGlobalObject)
 340             return this._fallbackWrapper(table);
 341 
 342         // FIXME: Currently columns are ignored. Instead, the frontend filters all
 343         // properties based on the provided column names and in the provided order.
 344         // We could filter here to avoid sending very large preview objects.
 345 
 346         let columnNames = null;
 347         if (typeof columns === &quot;string&quot;)
 348             columns = [columns];
 349 
 350         if (InjectedScriptHost.subtype(columns) === &quot;array&quot;) {
 351             columnNames = [];
 352             for (let i = 0; i &lt; columns.length; ++i)
 353                 columnNames.push(toString(columns[i]));
 354         }
 355 
 356         return RemoteObject.create(table, &quot;console&quot;, false, true, columnNames);
 357     }
 358 
 359     previewValue(value)
 360     {
 361         return RemoteObject.createObjectPreviewForValue(value, true);
 362     }
 363 
 364     setEventValue(value)
 365     {
 366         this._eventValue = value;
 367     }
 368 
 369     clearEventValue()
 370     {
 371         delete this._eventValue;
 372     }
 373 
 374     setExceptionValue(value)
 375     {
 376         this._exceptionValue = value;
 377     }
 378 
 379     clearExceptionValue()
 380     {
 381         delete this._exceptionValue;
 382     }
 383 
 384     findObjectById(objectId)
 385     {
 386         let parsedObjectId = this._parseObjectId(objectId);
 387         return this._objectForId(parsedObjectId);
 388     }
 389 
 390     releaseObject(objectId)
 391     {
 392         let parsedObjectId = this._parseObjectId(objectId);
 393         this._releaseObject(parsedObjectId.id);
 394     }
 395 
 396     releaseObjectGroup(objectGroupName)
 397     {
 398         if (objectGroupName === &quot;console&quot;) {
 399             delete this._lastResult;
 400             this._nextSavedResultIndex = 1;
 401             this._savedResults = [];
 402         }
 403 
 404         let group = this._objectGroups[objectGroupName];
 405         if (!group)
 406             return;
 407 
 408         for (let i = 0; i &lt; group.length; i++)
 409             this._releaseObject(group[i]);
 410 
 411         delete this._objectGroups[objectGroupName];
 412     }
 413 
 414     // CommandLineAPI
 415 
 416     inspectObject(object)
 417     {
 418         if (this._inspectObject)
 419             this._inspectObject(object);
 420     }
 421 
 422     // InjectedScriptModule C++ API
 423 
 424     hasInjectedModule(name)
 425     {
 426         return this._modules[name];
 427     }
 428 
 429     injectModule(name, source, host)
 430     {
 431         this._modules[name] = false;
 432 
 433         let moduleFunction = InjectedScriptHost.evaluate(&quot;(&quot; + source + &quot;)&quot;);
 434         if (typeof moduleFunction !== &quot;function&quot;)
 435             throw &quot;Error: Web Inspector: a function was expected for injectModule&quot;;
 436         moduleFunction(InjectedScriptHost, inspectedGlobalObject, injectedScriptId, this, {RemoteObject, CommandLineAPI}, host);
 437 
 438         this._modules[name] = true;
 439     }
 440 
 441     // InjectedScriptModule JavaScript API
 442 
 443     isPrimitiveValue(value)
 444     {
 445         return isPrimitiveValue(value);
 446     }
 447 
 448     // Private
 449 
 450     _parseObjectId(objectId)
 451     {
 452         return InjectedScriptHost.evaluate(&quot;(&quot; + objectId + &quot;)&quot;);
 453     }
 454 
 455     _objectForId(objectId)
 456     {
 457         return this._idToWrappedObject[objectId.id];
 458     }
 459 
 460     _bind(object, objectGroupName)
 461     {
 462         let id = this._lastBoundObjectId++;
 463         let objectId = `{&quot;injectedScriptId&quot;:${injectedScriptId},&quot;id&quot;:${id}}`;
 464 
 465         this._idToWrappedObject[id] = object;
 466 
 467         if (objectGroupName) {
 468             let group = this._objectGroups[objectGroupName];
 469             if (!group) {
 470                 group = [];
 471                 this._objectGroups[objectGroupName] = group;
 472             }
 473             group.push(id);
 474             this._idToObjectGroupName[id] = objectGroupName;
 475         }
 476 
 477         return objectId;
 478     }
 479 
 480     _releaseObject(id)
 481     {
 482         delete this._idToWrappedObject[id];
 483         delete this._idToObjectGroupName[id];
 484     }
 485 
 486     _fallbackWrapper(object)
 487     {
 488         let result = {};
 489         result.type = typeof object;
 490         if (isPrimitiveValue(object))
 491             result.value = object;
 492         else
 493             result.description = toStringDescription(object);
 494         return result;
 495     }
 496 
 497     _resolveCallArgument(callArgumentJSON)
 498     {
 499         if (&quot;value&quot; in callArgumentJSON)
 500             return callArgumentJSON.value;
 501 
 502         let objectId = callArgumentJSON.objectId;
 503         if (objectId) {
 504             let parsedArgId = this._parseObjectId(objectId);
 505             if (!parsedArgId || parsedArgId[&quot;injectedScriptId&quot;] !== injectedScriptId)
 506                 throw &quot;Arguments should belong to the same JavaScript world as the target object.&quot;;
 507 
 508             let resolvedArg = this._objectForId(parsedArgId);
 509             if (!isDefined(resolvedArg))
 510                 throw &quot;Could not find object with given id&quot;;
 511 
 512             return resolvedArg;
 513         }
 514 
 515         return undefined;
 516     }
 517 
 518     _createThrownValue(value, objectGroup)
 519     {
 520         let remoteObject = RemoteObject.create(value, objectGroup);
 521         try {
 522             remoteObject.description = toStringDescription(value);
 523         } catch { }
 524         return {
 525             wasThrown: true,
 526             result: remoteObject
 527         };
 528     }
 529 
 530     _evaluateAndWrap(evalFunction, object, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 531     {
 532         return this._wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 533             return this._evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI);
 534         });
 535     }
 536 
 537     _wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, func)
 538     {
 539         return this._wrapCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 540             let result = func();
 541             if (saveResult)
 542                 this._saveResult(result);
 543             return result;
 544         });
 545     }
 546 
 547     _wrapCall(objectGroup, returnByValue, generatePreview, saveResult, func)
 548     {
 549         try {
 550             this._savedResultIndex = 0;
 551 
 552             let returnObject = {
 553                 wasThrown: false,
 554                 result: RemoteObject.create(func(), objectGroup, returnByValue, generatePreview)
 555             };
 556 
 557             if (saveResult &amp;&amp; this._savedResultIndex)
 558                 returnObject.savedResultIndex = this._savedResultIndex;
 559 
 560             return returnObject;
 561         } catch (e) {
 562             return this._createThrownValue(e, objectGroup);
 563         }
 564     }
 565 
 566     _evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI)
 567     {
 568         let commandLineAPI = null;
 569         if (includeCommandLineAPI)
 570             commandLineAPI = new CommandLineAPI(isEvalOnCallFrame ? object : null);
 571         return evalFunction.call(object, expression, commandLineAPI);
 572     }
 573 
 574     _callFrameForId(topCallFrame, callFrameId)
 575     {
 576         let parsedCallFrameId = InjectedScriptHost.evaluate(&quot;(&quot; + callFrameId + &quot;)&quot;);
 577         let ordinal = parsedCallFrameId[&quot;ordinal&quot;];
 578         let callFrame = topCallFrame;
 579         while (--ordinal &gt;= 0 &amp;&amp; callFrame)
 580             callFrame = callFrame.caller;
 581         return callFrame;
 582     }
 583 
 584     _getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues)
 585     {
 586         let parsedObjectId = this._parseObjectId(objectId);
 587         let object = this._objectForId(parsedObjectId);
 588         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 589 
 590         if (!isDefined(object))
 591             return false;
 592 
 593         if (isSymbol(object))
 594             return false;
 595 
 596         let descriptors = this._propertyDescriptors(object, collectionMode, nativeGettersAsValues);
 597 
 598         for (let i = 0; i &lt; descriptors.length; ++i) {
 599             let descriptor = descriptors[i];
 600             if (&quot;get&quot; in descriptor)
 601                 descriptor.get = RemoteObject.create(descriptor.get, objectGroupName);
 602             if (&quot;set&quot; in descriptor)
 603                 descriptor.set = RemoteObject.create(descriptor.set, objectGroupName);
 604             if (&quot;value&quot; in descriptor)
 605                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
 606             if (!(&quot;configurable&quot; in descriptor))
 607                 descriptor.configurable = false;
 608             if (!(&quot;enumerable&quot; in descriptor))
 609                 descriptor.enumerable = false;
 610             if (&quot;symbol&quot; in descriptor)
 611                 descriptor.symbol = RemoteObject.create(descriptor.symbol, objectGroupName);
 612         }
 613 
 614         return descriptors;
 615     }
 616 
 617     _internalPropertyDescriptors(object, completeDescriptor)
 618     {
 619         let internalProperties = InjectedScriptHost.getInternalProperties(object);
 620         if (!internalProperties)
 621             return null;
 622 
 623         let descriptors = [];
 624         for (let i = 0; i &lt; internalProperties.length; i++) {
 625             let property = internalProperties[i];
 626             let descriptor = {name: property.name, value: property.value};
 627             if (completeDescriptor) {
 628                 descriptor.writable = false;
 629                 descriptor.configurable = false;
 630                 descriptor.enumerable = false;
 631                 descriptor.isOwn = true;
 632             }
 633             descriptors.push(descriptor);
 634         }
 635         return descriptors;
 636     }
 637 
 638     _propertyDescriptors(object, collectionMode, nativeGettersAsValues)
 639     {
 640         if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
 641             return [];
 642 
 643         let descriptors = [];
 644         let nameProcessed = new Set;
 645 
 646         function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
 647         {
 648             try {
 649                 let fakeDescriptor = {name, value: object[name], writable: descriptor.writable || false, configurable: descriptor.configurable || false, enumerable: descriptor.enumerable || false};
 650                 if (possibleNativeBindingGetter)
 651                     fakeDescriptor.nativeGetter = true;
 652                 if (isOwnProperty)
 653                     fakeDescriptor.isOwn = true;
 654                 if (symbol)
 655                     fakeDescriptor.symbol = symbol;
 656                 // Silence any possible unhandledrejection exceptions created from accessing a native accessor with a wrong this object.
 657                 if (fakeDescriptor.value instanceof Promise &amp;&amp; InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError(fakeDescriptor.value))
 658                     fakeDescriptor.value.catch(function(){});
 659                 return fakeDescriptor;
 660             } catch (e) {
 661                 let errorDescriptor = {name, value: e, wasThrown: true};
 662                 if (isOwnProperty)
 663                     errorDescriptor.isOwn = true;
 664                 if (symbol)
 665                     errorDescriptor.symbol = symbol;
 666                 return errorDescriptor;
 667             }
 668         }
 669 
 670         function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
 671         {
 672             // All properties.
 673             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties) {
 674                 descriptors.push(descriptor);
 675                 return;
 676             }
 677 
 678             // Own properties.
 679             if (collectionMode &amp; InjectedScript.CollectionMode.OwnProperties &amp;&amp; isOwnProperty) {
 680                 descriptors.push(descriptor);
 681                 return;
 682             }
 683 
 684             // Native Getter properties.
 685             if (collectionMode &amp; InjectedScript.CollectionMode.NativeGetterProperties) {
 686                 if (possibleNativeBindingGetter) {
 687                     descriptors.push(descriptor);
 688                     return;
 689                 }
 690             }
 691         }
 692 
 693         function processProperties(o, properties, isOwnProperty)
 694         {
 695             for (let i = 0; i &lt; properties.length; ++i) {
 696                 let property = properties[i];
 697                 if (nameProcessed.has(property) || property === &quot;__proto__&quot;)
 698                     continue;
 699 
 700                 nameProcessed.add(property);
 701 
 702                 let name = toString(property);
 703                 let symbol = isSymbol(property) ? property : null;
 704 
 705                 let descriptor = Object.getOwnPropertyDescriptor(o, property);
 706                 if (!descriptor) {
 707                     // FIXME: Bad descriptor. Can we get here?
 708                     // Fall back to very restrictive settings.
 709                     let fakeDescriptor = createFakeValueDescriptor(name, symbol, {writable: false, configurable: false, enumerable: false}, isOwnProperty);
 710                     processDescriptor(fakeDescriptor, isOwnProperty);
 711                     continue;
 712                 }
 713 
 714                 if (nativeGettersAsValues) {
 715                     if (String(descriptor.get).endsWith(&quot;[native code]\n}&quot;) || (!descriptor.get &amp;&amp; descriptor.hasOwnProperty(&quot;get&quot;) &amp;&amp; !descriptor.set &amp;&amp; descriptor.hasOwnProperty(&quot;set&quot;))) {
 716                         // Developers may create such a descriptor, so we should be resilient:
 717                         // let x = {}; Object.defineProperty(x, &quot;p&quot;, {get:undefined}); Object.getOwnPropertyDescriptor(x, &quot;p&quot;)
 718                         let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);
 719                         processDescriptor(fakeDescriptor, isOwnProperty, true);
 720                         continue;
 721                     }
 722                 }
 723 
 724                 descriptor.name = name;
 725                 if (isOwnProperty)
 726                     descriptor.isOwn = true;
 727                 if (symbol)
 728                     descriptor.symbol = symbol;
 729                 processDescriptor(descriptor, isOwnProperty);
 730             }
 731         }
 732 
 733         function arrayIndexPropertyNames(o, length)
 734         {
 735             let array = [];
 736             for (let i = 0; i &lt; length; ++i) {
 737                 if (i in o)
 738                     array.push(&quot;&quot; + i);
 739             }
 740             return array;
 741         }
 742 
 743         // FIXME: &lt;https://webkit.org/b/143589&gt; Web Inspector: Better handling for large collections in Object Trees
 744         // For array types with a large length we attempt to skip getOwnPropertyNames and instead just sublist of indexes.
 745         let isArrayLike = false;
 746         try {
 747             isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
 748         } catch { }
 749 
 750         for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
 751             let isOwnProperty = o === object;
 752 
 753             if (isArrayLike &amp;&amp; isOwnProperty)
 754                 processProperties(o, arrayIndexPropertyNames(o, Math.min(object.length, 100)), isOwnProperty);
 755             else {
 756                 processProperties(o, Object.getOwnPropertyNames(o), isOwnProperty);
 757                 if (Object.getOwnPropertySymbols)
 758                     processProperties(o, Object.getOwnPropertySymbols(o), isOwnProperty);
 759             }
 760 
 761             if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
 762                 break;
 763         }
 764 
 765         // Always include __proto__ at the end.
 766         try {
 767             if (object.__proto__)
 768                 descriptors.push({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, enumerable: false, isOwn: true});
 769         } catch { }
 770 
 771         return descriptors;
 772     }
 773 
 774     _getSetEntries(object, skip, numberToFetch)
 775     {
 776         let entries = [];
 777 
 778         // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
 779         for (let value of object) {
 780             if (skip &gt; 0) {
 781                 skip--;
 782                 continue;
 783             }
 784 
 785             entries.push({value});
 786 
 787             if (numberToFetch &amp;&amp; entries.length === numberToFetch)
 788                 break;
 789         }
 790 
 791         return entries;
 792     }
 793 
 794     _getMapEntries(object, skip, numberToFetch)
 795     {
 796         let entries = [];
 797 
 798         // FIXME: This is observable if the page overrides Map.prototype[Symbol.iterator].
 799         for (let [key, value] of object) {
 800             if (skip &gt; 0) {
 801                 skip--;
 802                 continue;
 803             }
 804 
 805             entries.push({key, value});
 806 
 807             if (numberToFetch &amp;&amp; entries.length === numberToFetch)
 808                 break;
 809         }
 810 
 811         return entries;
 812     }
 813 
 814     _getWeakMapEntries(object, numberToFetch)
 815     {
 816         return InjectedScriptHost.weakMapEntries(object, numberToFetch);
 817     }
 818 
 819     _getWeakSetEntries(object, numberToFetch)
 820     {
 821         return InjectedScriptHost.weakSetEntries(object, numberToFetch);
 822     }
 823 
 824     _getIteratorEntries(object, numberToFetch)
 825     {
 826         return InjectedScriptHost.iteratorEntries(object, numberToFetch);
 827     }
 828 
 829     _entries(object, subtype, startIndex, numberToFetch)
 830     {
 831         if (subtype === &quot;set&quot;)
 832             return this._getSetEntries(object, startIndex, numberToFetch);
 833         if (subtype === &quot;map&quot;)
 834             return this._getMapEntries(object, startIndex, numberToFetch);
 835         if (subtype === &quot;weakmap&quot;)
 836             return this._getWeakMapEntries(object, numberToFetch);
 837         if (subtype === &quot;weakset&quot;)
 838             return this._getWeakSetEntries(object, numberToFetch);
 839         if (subtype === &quot;iterator&quot;)
 840             return this._getIteratorEntries(object, numberToFetch);
 841 
 842         throw &quot;unexpected type&quot;;
 843     }
 844 
 845     _saveResult(result)
 846     {
 847         this._lastResult = result;
 848 
 849         if (result === undefined || result === null)
 850             return;
 851 
 852         let existingIndex = this._savedResults.indexOf(result);
 853         if (existingIndex !== -1) {
 854             this._savedResultIndex = existingIndex;
 855             return;
 856         }
 857 
 858         this._savedResultIndex = this._nextSavedResultIndex;
 859         this._savedResults[this._nextSavedResultIndex++] = result;
 860 
 861         // $n is limited from $1-$99. $0 is special.
 862         if (this._nextSavedResultIndex &gt;= 100)
 863             this._nextSavedResultIndex = 1;
 864     }
 865 };
 866 
 867 InjectedScript.CollectionMode = {
 868     OwnProperties: 1 &lt;&lt; 0,          // own properties.
 869     NativeGetterProperties: 1 &lt;&lt; 1, // native getter properties in the prototype chain.
 870     AllProperties: 1 &lt;&lt; 2,          // all properties in the prototype chain.
 871 };
 872 
 873 var injectedScript = new InjectedScript;
 874 
 875 // -------
 876 
 877 let RemoteObject = class RemoteObject
 878 {
 879     constructor(object, objectGroupName, forceValueType, generatePreview, columnNames)
 880     {
 881         this.type = typeof object;
 882 
 883         if (this.type === &quot;undefined&quot; &amp;&amp; InjectedScriptHost.isHTMLAllCollection(object))
 884             this.type = &quot;object&quot;;
 885 
 886         if (isPrimitiveValue(object) || isBigInt(object) || object === null || forceValueType) {
 887             // We don&#39;t send undefined values over JSON.
 888             // BigInt values are not JSON serializable.
 889             if (this.type !== &quot;undefined&quot; &amp;&amp; this.type !== &quot;bigint&quot;)
 890                 this.value = object;
 891 
 892             // Null object is object with &#39;null&#39; subtype.
 893             if (object === null)
 894                 this.subtype = &quot;null&quot;;
 895 
 896             // Provide user-friendly number values.
 897             if (this.type === &quot;number&quot; || this.type === &quot;bigint&quot;)
 898                 this.description = toStringDescription(object);
 899 
 900             return;
 901         }
 902 
 903         this.objectId = injectedScript._bind(object, objectGroupName);
 904 
 905         let subtype = RemoteObject.subtype(object);
 906         if (subtype)
 907             this.subtype = subtype;
 908 
 909         this.className = InjectedScriptHost.internalConstructorName(object);
 910         this.description = RemoteObject.describe(object);
 911 
 912         if (subtype === &quot;array&quot;)
 913             this.size = typeof object.length === &quot;number&quot; ? object.length : 0;
 914         else if (subtype === &quot;set&quot; || subtype === &quot;map&quot;)
 915             this.size = object.size;
 916         else if (subtype === &quot;weakmap&quot;)
 917             this.size = InjectedScriptHost.weakMapSize(object);
 918         else if (subtype === &quot;weakset&quot;)
 919             this.size = InjectedScriptHost.weakSetSize(object);
 920         else if (subtype === &quot;class&quot;) {
 921             this.classPrototype = RemoteObject.create(object.prototype, objectGroupName);
 922             this.className = object.name;
 923         }
 924 
 925         if (generatePreview &amp;&amp; this.type === &quot;object&quot;) {
 926             if (subtype === &quot;proxy&quot;) {
 927                 this.preview = this._generatePreview(InjectedScriptHost.proxyTargetValue(object));
 928                 this.preview.lossless = false;
 929             } else
 930                 this.preview = this._generatePreview(object, undefined, columnNames);
 931         }
 932     }
 933 
 934     // Static
 935 
 936     static create(object, objectGroupName, forceValueType, generatePreview, columnNames)
 937     {
 938         try {
 939             return new RemoteObject(object, objectGroupName, forceValueType, generatePreview, columnNames);
 940         } catch (e) {
 941             let description;
 942             try {
 943                 description = RemoteObject.describe(e);
 944             } catch (ex) {
 945                 alert(ex.message);
 946                 description = &quot;&lt;failed to convert exception to string&gt;&quot;;
 947             }
 948             return new RemoteObject(description);
 949         }
 950     }
 951 
 952     static createObjectPreviewForValue(value, generatePreview, columnNames)
 953     {
 954         let remoteObject = new RemoteObject(value, undefined, false, generatePreview, columnNames);
 955         if (remoteObject.objectId)
 956             injectedScript.releaseObject(remoteObject.objectId);
 957         if (remoteObject.classPrototype &amp;&amp; remoteObject.classPrototype.objectId)
 958             injectedScript.releaseObject(remoteObject.classPrototype.objectId);
 959         return remoteObject.preview || remoteObject._emptyPreview();
 960     }
 961 
 962     static subtype(value)
 963     {
 964         if (value === null)
 965             return &quot;null&quot;;
 966 
 967         if (isPrimitiveValue(value) || isBigInt(value) || isSymbol(value))
 968             return null;
 969 
 970         if (InjectedScriptHost.isHTMLAllCollection(value))
 971             return &quot;array&quot;;
 972 
 973         let preciseType = InjectedScriptHost.subtype(value);
 974         if (preciseType)
 975             return preciseType;
 976 
 977         // FireBug&#39;s array detection.
 978         try {
 979             if (typeof value.splice === &quot;function&quot; &amp;&amp; isFinite(value.length))
 980                 return &quot;array&quot;;
 981         } catch { }
 982 
 983         return null;
 984     }
 985 
 986     static describe(value)
 987     {
 988         if (isPrimitiveValue(value))
 989             return null;
 990 
 991         if (isBigInt(value))
 992             return null;
 993 
 994         if (isSymbol(value))
 995             return toString(value);
 996 
 997         let subtype = RemoteObject.subtype(value);
 998 
 999         if (subtype === &quot;regexp&quot;)
1000             return toString(value);
1001 
1002         if (subtype === &quot;date&quot;)
1003             return toString(value);
1004 
1005         if (subtype === &quot;error&quot;)
1006             return toString(value);
1007 
1008         if (subtype === &quot;proxy&quot;)
1009             return &quot;Proxy&quot;;
1010 
1011         if (subtype === &quot;node&quot;)
1012             return RemoteObject.nodePreview(value);
1013 
1014         let className = InjectedScriptHost.internalConstructorName(value);
1015         if (subtype === &quot;array&quot;)
1016             return className;
1017 
1018         if (subtype === &quot;iterator&quot; &amp;&amp; Symbol.toStringTag in value)
1019             return value[Symbol.toStringTag];
1020 
1021         // NodeList in JSC is a function, check for array prior to this.
1022         if (typeof value === &quot;function&quot;)
1023             return value.toString();
1024 
1025         // If Object, try for a better name from the constructor.
1026         if (className === &quot;Object&quot;) {
1027             let constructorName = value.constructor &amp;&amp; value.constructor.name;
1028             if (constructorName)
1029                 return constructorName;
1030         }
1031 
1032         return className;
1033     }
1034 
1035     static nodePreview(node)
1036     {
1037         let isXMLDocument = node.ownerDocument &amp;&amp; !!node.ownerDocument.xmlVersion;
1038         let nodeName = isXMLDocument ? node.nodeName : node.nodeName.toLowerCase();
1039 
1040         switch (node.nodeType) {
1041         case 1: // Node.ELEMENT_NODE
1042             if (node.id)
1043                 return &quot;&lt;&quot; + nodeName + &quot; id=\&quot;&quot; + node.id + &quot;\&quot;&gt;&quot;;
1044             if (node.classList.length)
1045                 return &quot;&lt;&quot; + nodeName + &quot; class=\&quot;&quot; + node.classList.toString().replace(/\s+/, &quot; &quot;) + &quot;\&quot;&gt;&quot;;
1046             if (nodeName === &quot;input&quot; &amp;&amp; node.type)
1047                 return &quot;&lt;&quot; + nodeName + &quot; type=\&quot;&quot; + node.type + &quot;\&quot;&gt;&quot;;
1048             return &quot;&lt;&quot; + nodeName + &quot;&gt;&quot;;
1049 
1050         case 3: // Node.TEXT_NODE
1051             return nodeName + &quot; \&quot;&quot; + node.nodeValue + &quot;\&quot;&quot;;
1052 
1053         case 8: // Node.COMMENT_NODE
1054             return &quot;&lt;!--&quot; + node.nodeValue + &quot;--&gt;&quot;;
1055 
1056         case 10: // Node.DOCUMENT_TYPE_NODE
1057             return &quot;&lt;!DOCTYPE &quot; + nodeName + &quot;&gt;&quot;;
1058 
1059         default:
1060             return nodeName;
1061         }
1062     }
1063 
1064     // Private
1065 
1066     _initialPreview()
1067     {
1068         let preview = {
1069             type: this.type,
1070             description: this.description || toString(this.value),
1071             lossless: true,
1072         };
1073 
1074         if (this.subtype) {
1075             preview.subtype = this.subtype;
1076             if (this.subtype !== &quot;null&quot;) {
1077                 preview.overflow = false;
1078                 preview.properties = [];
1079             }
1080         }
1081 
1082         if (&quot;size&quot; in this)
1083             preview.size = this.size;
1084 
1085         return preview;
1086     }
1087 
1088     _emptyPreview()
1089     {
1090         let preview = this._initialPreview();
1091 
1092         if (this.subtype === &quot;map&quot; || this.subtype === &quot;set&quot; || this.subtype === &quot;weakmap&quot; || this.subtype === &quot;weakset&quot; || this.subtype === &quot;iterator&quot;) {
1093             if (this.size) {
1094                 preview.entries = [];
1095                 preview.lossless = false;
1096                 preview.overflow = true;
1097             }
1098         }
1099 
1100         return preview;
1101     }
1102 
1103     _generatePreview(object, firstLevelKeys, secondLevelKeys)
1104     {
1105         let preview = this._initialPreview();
1106         let isTableRowsRequest = secondLevelKeys === null || secondLevelKeys;
1107         let firstLevelKeysCount = firstLevelKeys ? firstLevelKeys.length : 0;
1108 
1109         let propertiesThreshold = {
1110             properties: isTableRowsRequest ? 1000 : Math.max(5, firstLevelKeysCount),
1111             indexes: isTableRowsRequest ? 1000 : Math.max(10, firstLevelKeysCount)
1112         };
1113 
1114         try {
1115             // Maps, Sets, and Iterators have entries.
1116             if (this.subtype === &quot;map&quot; || this.subtype === &quot;set&quot; || this.subtype === &quot;weakmap&quot; || this.subtype === &quot;weakset&quot; || this.subtype === &quot;iterator&quot;)
1117                 this._appendEntryPreviews(object, preview);
1118 
1119             preview.properties = [];
1120 
1121             // Internal Properties.
1122             let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
1123             if (internalPropertyDescriptors) {
1124                 this._appendPropertyPreviews(object, preview, internalPropertyDescriptors, true, propertiesThreshold, firstLevelKeys, secondLevelKeys);
1125                 if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1126                     return preview;
1127             }
1128 
1129             if (preview.entries)
1130                 return preview;
1131 
1132             // Properties.
1133             let nativeGettersAsValues = true;
1134             let descriptors = injectedScript._propertyDescriptors(object, InjectedScript.CollectionMode.AllProperties, nativeGettersAsValues);
1135             this._appendPropertyPreviews(object, preview, descriptors, false, propertiesThreshold, firstLevelKeys, secondLevelKeys);
1136             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1137                 return preview;
1138         } catch {
1139             preview.lossless = false;
1140         }
1141 
1142         return preview;
1143     }
1144 
1145     _appendPropertyPreviews(object, preview, descriptors, internal, propertiesThreshold, firstLevelKeys, secondLevelKeys)
1146     {
1147         for (let i = 0; i &lt; descriptors.length; ++i) {
1148             let descriptor = descriptors[i];
1149 
1150             // Seen enough.
1151             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1152                 break;
1153 
1154             // Error in descriptor.
1155             if (descriptor.wasThrown) {
1156                 preview.lossless = false;
1157                 continue;
1158             }
1159 
1160             // Do not show &quot;__proto__&quot; in preview.
1161             let name = descriptor.name;
1162             if (name === &quot;__proto__&quot;) {
1163                 // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.
1164                 if (descriptor.value &amp;&amp; descriptor.value.constructor
1165                     &amp;&amp; descriptor.value.constructor !== Object
1166                     &amp;&amp; descriptor.value.constructor !== Array
1167                     &amp;&amp; descriptor.value.constructor !== RegExp)
1168                     preview.lossless = false;
1169                 continue;
1170             }
1171 
1172             // For arrays, only allow indexes.
1173             if (this.subtype === &quot;array&quot; &amp;&amp; !isUInt32(name))
1174                 continue;
1175 
1176             // Do not show non-enumerable non-own properties.
1177             // Special case to allow array indexes that may be on the prototype.
1178             // Special case to allow native getters on non-RegExp objects.
1179             if (!descriptor.enumerable &amp;&amp; !descriptor.isOwn &amp;&amp; !(this.subtype === &quot;array&quot; || (this.subtype !== &quot;regexp&quot; &amp;&amp; descriptor.nativeGetter)))
1180                 continue;
1181 
1182             // If we have a filter, only show properties in the filter.
1183             // FIXME: Currently these filters do nothing on the backend.
1184             if (firstLevelKeys &amp;&amp; !firstLevelKeys.includes(name))
1185                 continue;
1186 
1187             // Getter/setter.
1188             if (!(&quot;value&quot; in descriptor)) {
1189                 preview.lossless = false;
1190                 this._appendPropertyPreview(preview, internal, {name, type: &quot;accessor&quot;}, propertiesThreshold);
1191                 continue;
1192             }
1193 
1194             // Null value.
1195             let value = descriptor.value;
1196             if (value === null) {
1197                 this._appendPropertyPreview(preview, internal, {name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;}, propertiesThreshold);
1198                 continue;
1199             }
1200 
1201             // Ignore non-enumerable functions.
1202             let type = typeof value;
1203             if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)
1204                 continue;
1205 
1206             // Fix type of document.all.
1207             if (InjectedScriptHost.isHTMLAllCollection(value))
1208                 type = &quot;object&quot;;
1209 
1210             // Primitive.
1211             const maxLength = 100;
1212             if (isPrimitiveValue(value) || isBigInt(value)) {
1213                 if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {
1214                     value = this._abbreviateString(value, maxLength, true);
1215                     preview.lossless = false;
1216                 }
1217                 this._appendPropertyPreview(preview, internal, {name, type, value: toStringDescription(value)}, propertiesThreshold);
1218                 continue;
1219             }
1220 
1221             // Symbol.
1222             if (isSymbol(value)) {
1223                 let symbolString = toString(value);
1224                 if (symbolString.length &gt; maxLength) {
1225                     symbolString = this._abbreviateString(symbolString, maxLength, true);
1226                     preview.lossless = false;
1227                 }
1228                 this._appendPropertyPreview(preview, internal, {name, type, value: symbolString}, propertiesThreshold);
1229                 continue;
1230             }
1231 
1232             // Object.
1233             let property = {name, type};
1234             let subtype = RemoteObject.subtype(value);
1235             if (subtype)
1236                 property.subtype = subtype;
1237 
1238             // Second level.
1239             if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {
1240                 // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.
1241                 let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);
1242                 property.valuePreview = subPreview;
1243                 if (!subPreview.lossless)
1244                     preview.lossless = false;
1245                 if (subPreview.overflow)
1246                     preview.overflow = true;
1247             } else {
1248                 let description = &quot;&quot;;
1249                 if (type !== &quot;function&quot; || subtype === &quot;class&quot;) {
1250                     let fullDescription;
1251                     if (subtype === &quot;class&quot;)
1252                         fullDescription = &quot;class &quot; + value.name;
1253                     else if (subtype === &quot;node&quot;)
1254                         fullDescription = RemoteObject.nodePreview(value);
1255                     else
1256                         fullDescription = RemoteObject.describe(value);
1257                     description = this._abbreviateString(fullDescription, maxLength, subtype === &quot;regexp&quot;);
1258                 }
1259                 property.value = description;
1260                 preview.lossless = false;
1261             }
1262 
1263             this._appendPropertyPreview(preview, internal, property, propertiesThreshold);
1264         }
1265     }
1266 
1267     _appendPropertyPreview(preview, internal, property, propertiesThreshold)
1268     {
1269         if (toString(property.name &gt;&gt;&gt; 0) === property.name)
1270             propertiesThreshold.indexes--;
1271         else
1272             propertiesThreshold.properties--;
1273 
1274         if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0) {
1275             preview.overflow = true;
1276             preview.lossless = false;
1277             return;
1278         }
1279 
1280         if (internal)
1281             property.internal = true;
1282 
1283         preview.properties.push(property);
1284     }
1285 
1286     _appendEntryPreviews(object, preview)
1287     {
1288         // Fetch 6, but only return 5, so we can tell if we overflowed.
1289         let entries = injectedScript._entries(object, this.subtype, 0, 6);
1290         if (!entries)
1291             return;
1292 
1293         if (entries.length &gt; 5) {
1294             entries.pop();
1295             preview.overflow = true;
1296             preview.lossless = false;
1297         }
1298 
1299         function updateMainPreview(subPreview) {
1300             if (!subPreview.lossless)
1301                 preview.lossless = false;
1302         }
1303 
1304         preview.entries = entries.map(function(entry) {
1305             entry.value = RemoteObject.createObjectPreviewForValue(entry.value, entry.value !== object);
1306             updateMainPreview(entry.value);
1307             if (&quot;key&quot; in entry) {
1308                 entry.key = RemoteObject.createObjectPreviewForValue(entry.key, entry.key !== object);
1309                 updateMainPreview(entry.key);
1310             }
1311             return entry;
1312         });
1313     }
1314 
1315     _isPreviewableObject(value, object)
1316     {
1317         let set = new Set;
1318         set.add(object);
1319 
1320         return this._isPreviewableObjectInternal(value, set, 1);
1321     }
1322 
1323     _isPreviewableObjectInternal(object, knownObjects, depth)
1324     {
1325         // Deep object.
1326         if (depth &gt; 3)
1327             return false;
1328 
1329         // Primitive.
1330         if (isPrimitiveValue(object) || isBigInt(object) || isSymbol(object))
1331             return true;
1332 
1333         // Null.
1334         if (object === null)
1335             return true;
1336 
1337         // Cyclic objects.
1338         if (knownObjects.has(object))
1339             return false;
1340 
1341         ++depth;
1342         knownObjects.add(object);
1343 
1344         // Arrays are simple if they have 5 or less simple objects.
1345         let subtype = RemoteObject.subtype(object);
1346         if (subtype === &quot;array&quot;) {
1347             let length = object.length;
1348             if (length &gt; 5)
1349                 return false;
1350             for (let i = 0; i &lt; length; ++i) {
1351                 if (!this._isPreviewableObjectInternal(object[i], knownObjects, depth))
1352                     return false;
1353             }
1354             return true;
1355         }
1356 
1357         // Not a basic object.
1358         if (object.__proto__ &amp;&amp; object.__proto__.__proto__)
1359             return false;
1360 
1361         // Objects are simple if they have 3 or less simple value properties.
1362         let ownPropertyNames = Object.getOwnPropertyNames(object);
1363         if (ownPropertyNames.length &gt; 3)
1364             return false;
1365         for (let i = 0; i &lt; ownPropertyNames.length; ++i) {
1366             let propertyName = ownPropertyNames[i];
1367             let descriptor = Object.getOwnPropertyDescriptor(object, propertyName);
1368             if (descriptor &amp;&amp; !(&quot;value&quot; in descriptor))
1369                 return false;
1370             if (!this._isPreviewableObjectInternal(object[propertyName], knownObjects, depth))
1371                 return false;
1372         }
1373 
1374         return true;
1375     }
1376 
1377     _abbreviateString(string, maxLength, middle)
1378     {
1379         if (string.length &lt;= maxLength)
1380             return string;
1381 
1382         if (middle) {
1383             let leftHalf = maxLength &gt;&gt; 1;
1384             let rightHalf = maxLength - leftHalf - 1;
1385             return string.substr(0, leftHalf) + &quot;\u2026&quot; + string.substr(string.length - rightHalf, rightHalf);
1386         }
1387 
1388         return string.substr(0, maxLength) + &quot;\u2026&quot;;
1389     }
1390 };
1391 
1392 // -------
1393 
1394 InjectedScript.CallFrameProxy = function(ordinal, callFrame)
1395 {
1396     this.callFrameId = `{&quot;ordinal&quot;:${ordinal},&quot;injectedScriptId&quot;:${injectedScriptId}}`;
1397     this.functionName = callFrame.functionName;
1398     this.location = {scriptId: String(callFrame.sourceID), lineNumber: callFrame.line, columnNumber: callFrame.column};
1399     this.scopeChain = this._wrapScopeChain(callFrame);
1400     this.this = RemoteObject.create(callFrame.thisObject, &quot;backtrace&quot;);
1401     this.isTailDeleted = callFrame.isTailDeleted;
1402 };
1403 
1404 InjectedScript.CallFrameProxy.prototype = {
1405     _wrapScopeChain(callFrame)
1406     {
1407         let scopeChain = callFrame.scopeChain;
1408         let scopeDescriptions = callFrame.scopeDescriptions();
1409 
1410         let scopeChainProxy = [];
1411         for (let i = 0; i &lt; scopeChain.length; i++)
1412             scopeChainProxy[i] = InjectedScript.CallFrameProxy._createScopeJson(scopeChain[i], scopeDescriptions[i], &quot;backtrace&quot;);
1413         return scopeChainProxy;
1414     }
1415 };
1416 
1417 InjectedScript.CallFrameProxy._scopeTypeNames = {
1418     0: &quot;global&quot;, // GLOBAL_SCOPE
1419     1: &quot;with&quot;, // WITH_SCOPE
1420     2: &quot;closure&quot;, // CLOSURE_SCOPE
1421     3: &quot;catch&quot;, // CATCH_SCOPE
1422     4: &quot;functionName&quot;, // FUNCTION_NAME_SCOPE
1423     5: &quot;globalLexicalEnvironment&quot;, // GLOBAL_LEXICAL_ENVIRONMENT_SCOPE
1424     6: &quot;nestedLexical&quot;, // NESTED_LEXICAL_SCOPE
1425 };
1426 
1427 InjectedScript.CallFrameProxy._createScopeJson = function(object, {name, type, location}, groupId)
1428 {
1429     let scope = {
1430         object: RemoteObject.create(object, groupId),
1431         type: InjectedScript.CallFrameProxy._scopeTypeNames[type],
1432     };
1433 
1434     if (name)
1435         scope.name = name;
1436 
1437     if (location)
1438         scope.location = location;
1439 
1440     if (isEmptyObject(object))
1441         scope.empty = true;
1442 
1443     return scope;
1444 }
1445 
1446 // -------
1447 
1448 function CommandLineAPI(callFrame)
1449 {
1450     let savedResultAlias = InjectedScriptHost.savedResultAlias;
1451 
1452     let defineGetter = (key, value) =&gt; {
1453         if (typeof value !== &quot;function&quot;) {
1454             let originalValue = value;
1455             value = function() { return originalValue; };
1456         }
1457 
1458         this.__defineGetter__(&quot;$&quot; + key, value);
1459         if (savedResultAlias &amp;&amp; savedResultAlias !== &quot;$&quot;)
1460             this.__defineGetter__(savedResultAlias + key, value);
1461     };
1462 
1463     if (&quot;_lastResult&quot; in injectedScript)
1464         defineGetter(&quot;_&quot;, injectedScript._lastResult);
1465 
1466     if (&quot;_exceptionValue&quot; in injectedScript)
1467         defineGetter(&quot;exception&quot;, injectedScript._exceptionValue);
1468 
1469     if (&quot;_eventValue&quot; in injectedScript)
1470         defineGetter(&quot;event&quot;, injectedScript._eventValue);
1471 
1472     // $1-$99
1473     for (let i = 1; i &lt; injectedScript._savedResults.length; ++i)
1474         defineGetter(i, injectedScript._savedResults[i]);
1475 
1476     for (let name in CommandLineAPI.getters)
1477         defineGetter(name, CommandLineAPI.getters[name]);
1478 
1479     for (let name in CommandLineAPI.methods)
1480         this[name] = CommandLineAPI.methods[name];
1481 }
1482 
1483 CommandLineAPI.getters = {};
1484 
1485 CommandLineAPI.methods = {};
1486 
1487 CommandLineAPI.methods[&quot;keys&quot;] = function(object) { return Object.keys(object); };
1488 CommandLineAPI.methods[&quot;values&quot;] = function(object) { return Object.values(object); };
1489 
1490 CommandLineAPI.methods[&quot;queryInstances&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1491 CommandLineAPI.methods[&quot;queryObjects&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1492 CommandLineAPI.methods[&quot;queryHolders&quot;] = function() { return InjectedScriptHost.queryHolders(...arguments); };
1493 
1494 CommandLineAPI.methods[&quot;inspect&quot;] = function(object) { return injectedScript.inspectObject(object); };
1495 
1496 CommandLineAPI.methods[&quot;assert&quot;] = function() { return inspectedGlobalObject.console.assert(...arguments); };
1497 CommandLineAPI.methods[&quot;clear&quot;] = function() { return inspectedGlobalObject.console.clear(...arguments); };
1498 CommandLineAPI.methods[&quot;count&quot;] = function() { return inspectedGlobalObject.console.count(...arguments); };
1499 CommandLineAPI.methods[&quot;countReset&quot;] = function() { return inspectedGlobalObject.console.countReset(...arguments); };
1500 CommandLineAPI.methods[&quot;debug&quot;] = function() { return inspectedGlobalObject.console.debug(...arguments); };
1501 CommandLineAPI.methods[&quot;dir&quot;] = function() { return inspectedGlobalObject.console.dir(...arguments); };
1502 CommandLineAPI.methods[&quot;dirxml&quot;] = function() { return inspectedGlobalObject.console.dirxml(...arguments); };
1503 CommandLineAPI.methods[&quot;error&quot;] = function() { return inspectedGlobalObject.console.error(...arguments); };
1504 CommandLineAPI.methods[&quot;group&quot;] = function() { return inspectedGlobalObject.console.group(...arguments); };
1505 CommandLineAPI.methods[&quot;groupCollapsed&quot;] = function() { return inspectedGlobalObject.console.groupCollapsed(...arguments); };
1506 CommandLineAPI.methods[&quot;groupEnd&quot;] = function() { return inspectedGlobalObject.console.groupEnd(...arguments); };
1507 CommandLineAPI.methods[&quot;info&quot;] = function() { return inspectedGlobalObject.console.info(...arguments); };
1508 CommandLineAPI.methods[&quot;log&quot;] = function() { return inspectedGlobalObject.console.log(...arguments); };
1509 CommandLineAPI.methods[&quot;profile&quot;] = function() { return inspectedGlobalObject.console.profile(...arguments); };
1510 CommandLineAPI.methods[&quot;profileEnd&quot;] = function() { return inspectedGlobalObject.console.profileEnd(...arguments); };
1511 CommandLineAPI.methods[&quot;record&quot;] = function() { return inspectedGlobalObject.console.record(...arguments); };
1512 CommandLineAPI.methods[&quot;recordEnd&quot;] = function() { return inspectedGlobalObject.console.recordEnd(...arguments); };
1513 CommandLineAPI.methods[&quot;screenshot&quot;] = function() { return inspectedGlobalObject.console.screenshot(...arguments); };
1514 CommandLineAPI.methods[&quot;table&quot;] = function() { return inspectedGlobalObject.console.table(...arguments); };
1515 CommandLineAPI.methods[&quot;takeHeapSnapshot&quot;] = function() { return inspectedGlobalObject.console.takeHeapSnapshot(...arguments); };
1516 CommandLineAPI.methods[&quot;time&quot;] = function() { return inspectedGlobalObject.console.time(...arguments); };
1517 CommandLineAPI.methods[&quot;timeEnd&quot;] = function() { return inspectedGlobalObject.console.timeEnd(...arguments); };
1518 CommandLineAPI.methods[&quot;timeLog&quot;] = function() { return inspectedGlobalObject.console.timeLog(...arguments); };
1519 CommandLineAPI.methods[&quot;timeStamp&quot;] = function() { return inspectedGlobalObject.console.timeStamp(...arguments); };
1520 CommandLineAPI.methods[&quot;trace&quot;] = function() { return inspectedGlobalObject.console.trace(...arguments); };
1521 CommandLineAPI.methods[&quot;warn&quot;] = function() { return inspectedGlobalObject.console.warn(...arguments); };
1522 
1523 for (let name in CommandLineAPI.methods)
1524     CommandLineAPI.methods[name].toString = function() { return &quot;function &quot; + name + &quot;() { [Command Line API] }&quot;; };
1525 
1526 return injectedScript;
1527 })
    </pre>
  </body>
</html>