<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerBacking.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerCompositor.h&quot;
  29 
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;ChromeClient.h&quot;
  35 #include &quot;DocumentTimeline.h&quot;
  36 #include &quot;Frame.h&quot;
  37 #include &quot;FrameView.h&quot;

  38 #include &quot;GraphicsLayer.h&quot;
  39 #include &quot;HTMLCanvasElement.h&quot;
  40 #include &quot;HTMLIFrameElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HitTestResult.h&quot;
  43 #include &quot;InspectorInstrumentation.h&quot;


  44 #include &quot;Logging.h&quot;
  45 #include &quot;NodeList.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PageOverlayController.h&quot;
  48 #include &quot;RenderEmbeddedObject.h&quot;
  49 #include &quot;RenderFragmentedFlow.h&quot;
  50 #include &quot;RenderFullScreen.h&quot;
  51 #include &quot;RenderGeometryMap.h&quot;
  52 #include &quot;RenderIFrame.h&quot;

  53 #include &quot;RenderLayerBacking.h&quot;
  54 #include &quot;RenderReplica.h&quot;
  55 #include &quot;RenderVideo.h&quot;
  56 #include &quot;RenderView.h&quot;
  57 #include &quot;RuntimeEnabledFeatures.h&quot;
  58 #include &quot;ScrollingConstraints.h&quot;
  59 #include &quot;ScrollingCoordinator.h&quot;
  60 #include &quot;Settings.h&quot;
  61 #include &quot;TiledBacking.h&quot;
  62 #include &quot;TransformState.h&quot;
  63 #include &lt;wtf/HexNumber.h&gt;
  64 #include &lt;wtf/MemoryPressureHandler.h&gt;
  65 #include &lt;wtf/SetForScope.h&gt;
  66 #include &lt;wtf/text/CString.h&gt;
  67 #include &lt;wtf/text/StringBuilder.h&gt;
  68 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  69 #include &lt;wtf/text/TextStream.h&gt;
  70 
  71 #if PLATFORM(IOS_FAMILY)
  72 #include &quot;LegacyTileCache.h&quot;
</pre>
<hr />
<pre>
  94 
  95 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
  96 static const int canvasAreaThresholdRequiringCompositing = 50 * 100;
  97 #endif
  98 // During page loading delay layer flushes up to this many seconds to allow them coalesce, reducing workload.
  99 #if PLATFORM(IOS_FAMILY)
 100 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 101 static const Seconds throttledLayerFlushDelay { 1.5_s };
 102 #else
 103 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 104 static const Seconds throttledLayerFlushDelay { 500_ms };
 105 #endif
 106 
 107 using namespace HTMLNames;
 108 
 109 struct ScrollingTreeState {
 110     Optional&lt;ScrollingNodeID&gt; parentNodeID;
 111     size_t nextChildIndex { 0 };
 112 };
 113 
<span class="line-modified"> 114 class OverlapMapContainer {</span>
<span class="line-modified"> 115 public:</span>
<span class="line-modified"> 116     void add(const LayoutRect&amp; bounds)</span>
<span class="line-modified"> 117     {</span>
<span class="line-modified"> 118         m_layerRects.append(bounds);</span>
<span class="line-removed"> 119         m_boundingBox.unite(bounds);</span>
<span class="line-removed"> 120     }</span>
<span class="line-removed"> 121 </span>
<span class="line-removed"> 122     bool overlapsLayers(const LayoutRect&amp; bounds) const</span>
<span class="line-removed"> 123     {</span>
<span class="line-removed"> 124         // Checking with the bounding box will quickly reject cases when</span>
<span class="line-removed"> 125         // layers are created for lists of items going in one direction and</span>
<span class="line-removed"> 126         // never overlap with each other.</span>
<span class="line-removed"> 127         if (!bounds.intersects(m_boundingBox))</span>
<span class="line-removed"> 128             return false;</span>
<span class="line-removed"> 129         for (const auto&amp; layerRect : m_layerRects) {</span>
<span class="line-removed"> 130             if (layerRect.intersects(bounds))</span>
<span class="line-removed"> 131                 return true;</span>
<span class="line-removed"> 132         }</span>
<span class="line-removed"> 133         return false;</span>
<span class="line-removed"> 134     }</span>
 135 
<span class="line-modified"> 136     void unite(const OverlapMapContainer&amp; otherContainer)</span>
<span class="line-removed"> 137     {</span>
<span class="line-removed"> 138         m_layerRects.appendVector(otherContainer.m_layerRects);</span>
<span class="line-removed"> 139         m_boundingBox.unite(otherContainer.m_boundingBox);</span>
<span class="line-removed"> 140     }</span>
<span class="line-removed"> 141 private:</span>
<span class="line-removed"> 142     Vector&lt;LayoutRect&gt; m_layerRects;</span>
<span class="line-removed"> 143     LayoutRect m_boundingBox;</span>
 144 };
 145 
<span class="line-modified"> 146 class RenderLayerCompositor::OverlapMap {</span>
<span class="line-modified"> 147     WTF_MAKE_NONCOPYABLE(OverlapMap);</span>
<span class="line-modified"> 148 public:</span>
<span class="line-modified"> 149     OverlapMap()</span>
<span class="line-removed"> 150         : m_geometryMap(UseTransforms)</span>
 151     {
<span class="line-removed"> 152         // Begin assuming the root layer will be composited so that there is</span>
<span class="line-removed"> 153         // something on the stack. The root layer should also never get an</span>
<span class="line-removed"> 154         // popCompositingContainer call.</span>
<span class="line-removed"> 155         pushCompositingContainer();</span>
 156     }
 157 
<span class="line-modified"> 158     void add(const LayoutRect&amp; bounds)</span>
 159     {
<span class="line-modified"> 160         // Layers do not contribute to overlap immediately--instead, they will</span>
<span class="line-modified"> 161         // contribute to overlap as soon as their composited ancestor has been</span>
<span class="line-modified"> 162         // recursively processed and popped off the stack.</span>
<span class="line-modified"> 163         ASSERT(m_overlapStack.size() &gt;= 2);</span>
<span class="line-modified"> 164         m_overlapStack[m_overlapStack.size() - 2].add(bounds);</span>
<span class="line-modified"> 165         m_isEmpty = false;</span>














 166     }
 167 
<span class="line-modified"> 168     bool overlapsLayers(const LayoutRect&amp; bounds) const</span>
 169     {
<span class="line-modified"> 170         return m_overlapStack.last().overlapsLayers(bounds);</span>
<span class="line-modified"> 171     }</span>











 172 
<span class="line-modified"> 173     bool isEmpty() const</span>
<span class="line-modified"> 174     {</span>
<span class="line-modified"> 175         return m_isEmpty;</span>

 176     }
 177 
<span class="line-modified"> 178     void pushCompositingContainer()</span>
 179     {
<span class="line-modified"> 180         m_overlapStack.append(OverlapMapContainer());</span>
 181     }
 182 
<span class="line-modified"> 183     void popCompositingContainer()</span>























 184     {
<span class="line-modified"> 185         m_overlapStack[m_overlapStack.size() - 2].unite(m_overlapStack.last());</span>
<span class="line-modified"> 186         m_overlapStack.removeLast();</span>
 187     }
 188 
<span class="line-modified"> 189     const RenderGeometryMap&amp; geometryMap() const { return m_geometryMap; }</span>
<span class="line-modified"> 190     RenderGeometryMap&amp; geometryMap() { return m_geometryMap; }</span>
 191 
 192 private:
<span class="line-modified"> 193     struct RectList {</span>
<span class="line-removed"> 194         Vector&lt;LayoutRect&gt; rects;</span>
<span class="line-removed"> 195         LayoutRect boundingRect;</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197         void append(const LayoutRect&amp; rect)</span>
<span class="line-removed"> 198         {</span>
<span class="line-removed"> 199             rects.append(rect);</span>
<span class="line-removed"> 200             boundingRect.unite(rect);</span>
<span class="line-removed"> 201         }</span>
 202 
<span class="line-modified"> 203         void append(const RectList&amp; rectList)</span>
<span class="line-modified"> 204         {</span>
<span class="line-removed"> 205             rects.appendVector(rectList.rects);</span>
<span class="line-removed"> 206             boundingRect.unite(rectList.boundingRect);</span>
<span class="line-removed"> 207         }</span>
 208 
<span class="line-modified"> 209         bool intersects(const LayoutRect&amp; rect) const</span>
<span class="line-modified"> 210         {</span>
<span class="line-modified"> 211             if (!rects.size() || !boundingRect.intersects(rect))</span>
<span class="line-modified"> 212                 return false;</span>
 213 
<span class="line-modified"> 214             for (const auto&amp; currentRect : rects) {</span>
<span class="line-modified"> 215                 if (currentRect.intersects(rect))</span>
<span class="line-modified"> 216                     return true;</span>
<span class="line-modified"> 217             }</span>
<span class="line-removed"> 218             return false;</span>
<span class="line-removed"> 219         }</span>
<span class="line-removed"> 220     };</span>
 221 
<span class="line-modified"> 222     Vector&lt;OverlapMapContainer&gt; m_overlapStack;</span>
<span class="line-modified"> 223     RenderGeometryMap m_geometryMap;</span>
<span class="line-modified"> 224     bool m_isEmpty { true };</span>
<span class="line-removed"> 225 };</span>
 226 
<span class="line-modified"> 227 struct RenderLayerCompositor::CompositingState {</span>
<span class="line-modified"> 228     CompositingState(RenderLayer* compAncestor, bool testOverlap = true)</span>
<span class="line-modified"> 229         : compositingAncestor(compAncestor)</span>
<span class="line-modified"> 230         , testingOverlap(testOverlap)</span>
<span class="line-modified"> 231     {</span>
 232     }
 233 
<span class="line-modified"> 234     CompositingState(const CompositingState&amp; other)</span>
<span class="line-modified"> 235         : compositingAncestor(other.compositingAncestor)</span>
<span class="line-modified"> 236         , subtreeIsCompositing(other.subtreeIsCompositing)</span>
<span class="line-modified"> 237         , testingOverlap(other.testingOverlap)</span>
<span class="line-modified"> 238         , fullPaintOrderTraversalRequired(other.fullPaintOrderTraversalRequired)</span>
<span class="line-modified"> 239         , descendantsRequireCompositingUpdate(other.descendantsRequireCompositingUpdate)</span>
<span class="line-modified"> 240         , ancestorHasTransformAnimation(other.ancestorHasTransformAnimation)</span>
<span class="line-modified"> 241 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified"> 242         , hasNotIsolatedCompositedBlendingDescendants(other.hasNotIsolatedCompositedBlendingDescendants)</span>
<span class="line-modified"> 243 #endif</span>
<span class="line-modified"> 244 #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed"> 245         , depth(other.depth + 1)</span>
<span class="line-removed"> 246 #endif</span>
<span class="line-removed"> 247     {</span>
 248     }

 249 
<span class="line-modified"> 250     RenderLayer* compositingAncestor;</span>
<span class="line-modified"> 251     bool subtreeIsCompositing { false };</span>
<span class="line-modified"> 252     bool testingOverlap { true };</span>
<span class="line-modified"> 253     bool fullPaintOrderTraversalRequired { false };</span>
<span class="line-modified"> 254     bool descendantsRequireCompositingUpdate { false };</span>
<span class="line-modified"> 255     bool ancestorHasTransformAnimation { false };</span>
<span class="line-modified"> 256 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed"> 257     bool hasNotIsolatedCompositedBlendingDescendants { false };</span>
<span class="line-removed"> 258 #endif</span>
<span class="line-removed"> 259 #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed"> 260     int depth { 0 };</span>
<span class="line-removed"> 261 #endif</span>
<span class="line-removed"> 262 };</span>
 263 
<span class="line-modified"> 264 struct RenderLayerCompositor::OverlapExtent {</span>
<span class="line-modified"> 265     LayoutRect bounds;</span>
<span class="line-modified"> 266     bool extentComputed { false };</span>
<span class="line-modified"> 267     bool hasTransformAnimation { false };</span>
<span class="line-modified"> 268     bool animationCausesExtentUncertainty { false };</span>



 269 
<span class="line-modified"> 270     bool knownToBeHaveExtentUncertainty() const { return extentComputed &amp;&amp; animationCausesExtentUncertainty; }</span>
<span class="line-modified"> 271 };</span>

 272 
<span class="line-modified"> 273 #if !LOG_DISABLED</span>
 274 static inline bool compositingLogEnabled()
 275 {
<span class="line-modified"> 276     return LogCompositing.state == WTFLogChannelOn;</span>





 277 }
 278 #endif
 279 
 280 RenderLayerCompositor::RenderLayerCompositor(RenderView&amp; renderView)
 281     : m_renderView(renderView)
 282     , m_updateCompositingLayersTimer(*this, &amp;RenderLayerCompositor::updateCompositingLayersTimerFired)
 283     , m_layerFlushTimer(*this, &amp;RenderLayerCompositor::layerFlushTimerFired)
 284 {
 285 #if PLATFORM(IOS_FAMILY)
 286     if (m_renderView.frameView().platformWidget())
<span class="line-modified"> 287         m_legacyScrollingLayerCoordinator = std::make_unique&lt;LegacyWebKitScrollingLayerCoordinator&gt;(page().chrome().client(), isMainFrameCompositor());</span>
 288 #endif
 289 }
 290 
 291 RenderLayerCompositor::~RenderLayerCompositor()
 292 {
 293     // Take care that the owned GraphicsLayers are deleted first as their destructors may call back here.
<span class="line-modified"> 294     m_clipLayer = nullptr;</span>
<span class="line-modified"> 295     m_scrolledContentsLayer = nullptr;</span>



















 296     ASSERT(m_rootLayerAttachment == RootLayerUnattached);
 297 }
 298 
 299 void RenderLayerCompositor::enableCompositingMode(bool enable /* = true */)
 300 {
 301     if (enable != m_compositing) {
 302         m_compositing = enable;
 303 
 304         if (m_compositing) {
 305             ensureRootLayer();
 306             notifyIFramesOfCompositingChange();
 307         } else
 308             destroyRootLayer();
 309 
 310 
 311         m_renderView.layer()-&gt;setNeedsPostLayoutCompositingUpdate();
 312     }
 313 }
 314 
 315 void RenderLayerCompositor::cacheAcceleratedCompositingFlags()
</pre>
<hr />
<pre>
 411 }
 412 
 413 void RenderLayerCompositor::customPositionForVisibleRectComputation(const GraphicsLayer* graphicsLayer, FloatPoint&amp; position) const
 414 {
 415     if (graphicsLayer != m_scrolledContentsLayer.get())
 416         return;
 417 
 418     FloatPoint scrollPosition = -position;
 419 
 420     if (m_renderView.frameView().scrollBehaviorForFixedElements() == StickToDocumentBounds)
 421         scrollPosition = m_renderView.frameView().constrainScrollPositionForOverhang(roundedIntPoint(scrollPosition));
 422 
 423     position = -scrollPosition;
 424 }
 425 
 426 void RenderLayerCompositor::notifyFlushRequired(const GraphicsLayer* layer)
 427 {
 428     scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
 429 }
 430 
<span class="line-removed"> 431 void RenderLayerCompositor::scheduleLayerFlushNow()</span>
<span class="line-removed"> 432 {</span>
<span class="line-removed"> 433     m_hasPendingLayerFlush = false;</span>
<span class="line-removed"> 434     page().chrome().client().scheduleCompositingLayerFlush();</span>
<span class="line-removed"> 435 }</span>
<span class="line-removed"> 436 </span>
 437 void RenderLayerCompositor::scheduleLayerFlush(bool canThrottle)
 438 {
 439     ASSERT(!m_flushingLayers);
 440 
 441     if (canThrottle)
 442         startInitialLayerFlushTimerIfNeeded();
 443 
<span class="line-modified"> 444     if (canThrottle &amp;&amp; isThrottlingLayerFlushes()) {</span>
 445         m_hasPendingLayerFlush = true;
<span class="line-modified"> 446         return;</span>


 447     }
<span class="line-removed"> 448     scheduleLayerFlushNow();</span>
 449 }
 450 
 451 FloatRect RenderLayerCompositor::visibleRectForLayerFlushing() const
 452 {
 453     const FrameView&amp; frameView = m_renderView.frameView();
 454 #if PLATFORM(IOS_FAMILY)
 455     return frameView.exposedContentRect();
 456 #else
 457     // Having a m_scrolledContentsLayer indicates that we&#39;re doing scrolling via GraphicsLayers.
 458     FloatRect visibleRect = m_scrolledContentsLayer ? FloatRect({ }, frameView.sizeForVisibleContent()) : frameView.visibleContentRect();
 459 
 460     if (frameView.viewExposedRect())
 461         visibleRect.intersect(frameView.viewExposedRect().value());
 462 
 463     return visibleRect;
 464 #endif
 465 }
 466 
 467 void RenderLayerCompositor::flushPendingLayerChanges(bool isFlushRoot)
 468 {
</pre>
<hr />
<pre>
 478         startLayerFlushTimerIfNeeded();
 479 #endif
 480         m_shouldFlushOnReattach = true;
 481         return;
 482     }
 483 
 484     auto&amp; frameView = m_renderView.frameView();
 485     AnimationUpdateBlock animationUpdateBlock(&amp;frameView.frame().animation());
 486 
 487     ASSERT(!m_flushingLayers);
 488     {
 489         SetForScope&lt;bool&gt; flushingLayersScope(m_flushingLayers, true);
 490 
 491         if (auto* rootLayer = rootGraphicsLayer()) {
 492             FloatRect visibleRect = visibleRectForLayerFlushing();
 493             LOG_WITH_STREAM(Compositing,  stream &lt;&lt; &quot;\nRenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; flushPendingLayerChanges (is root &quot; &lt;&lt; isFlushRoot &lt;&lt; &quot;) visible rect &quot; &lt;&lt; visibleRect);
 494             rootLayer-&gt;flushCompositingState(visibleRect);
 495         }
 496 
 497         ASSERT(m_flushingLayers);







 498     }
 499 
 500 #if PLATFORM(IOS_FAMILY)
 501     updateScrollCoordinatedLayersAfterFlushIncludingSubframes();
 502 
 503     if (isFlushRoot)
 504         page().chrome().client().didFlushCompositingLayers();
 505 #endif
 506 
 507     ++m_layerFlushCount;
 508     startLayerFlushTimerIfNeeded();
 509 }
 510 
 511 #if PLATFORM(IOS_FAMILY)
 512 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlushIncludingSubframes()
 513 {
 514     updateScrollCoordinatedLayersAfterFlush();
 515 
 516     auto&amp; frame = m_renderView.frameView().frame();
 517     for (Frame* subframe = frame.tree().firstChild(); subframe; subframe = subframe-&gt;tree().traverseNext(&amp;frame)) {
 518         auto* view = subframe-&gt;contentRenderer();
 519         if (!view)
 520             continue;
 521 
 522         view-&gt;compositor().updateScrollCoordinatedLayersAfterFlush();
 523     }
 524 }
 525 
 526 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlush()
 527 {
 528     if (m_legacyScrollingLayerCoordinator) {
 529         m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
<span class="line-modified"> 530         m_legacyScrollingLayerCoordinator-&gt;registerScrollingLayersNeedingUpdate();</span>
 531     }
 532 }
 533 #endif
 534 
 535 void RenderLayerCompositor::didChangePlatformLayerForLayer(RenderLayer&amp; layer, const GraphicsLayer*)
 536 {
<span class="line-removed"> 537 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 538     if (m_legacyScrollingLayerCoordinator)</span>
<span class="line-removed"> 539         m_legacyScrollingLayerCoordinator-&gt;didChangePlatformLayerForLayer(layer);</span>
<span class="line-removed"> 540 #endif</span>
<span class="line-removed"> 541 </span>
 542     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
 543     if (!scrollingCoordinator)
 544         return;
 545 
 546     auto* backing = layer.backing();
<span class="line-modified"> 547     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))</span>
<span class="line-modified"> 548         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });</span>
 549 
<span class="line-modified"> 550     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling)) {</span>
<span class="line-modified"> 551         // FIXME: would be nice to not have to special-case the root.</span>
<span class="line-removed"> 552         ScrollingCoordinator::NodeLayers nodeLayers;</span>
<span class="line-removed"> 553         if (layer.isRenderViewLayer())</span>
<span class="line-removed"> 554             nodeLayers = { nullptr, scrollContainerLayer(), scrolledContentsLayer(), fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer() };</span>
<span class="line-removed"> 555         else</span>
<span class="line-removed"> 556             nodeLayers = { layer.backing()-&gt;graphicsLayer(), backing-&gt;scrollContainerLayer(), backing-&gt;scrolledContentsLayer() };</span>
 557 
<span class="line-modified"> 558         scrollingCoordinator-&gt;setNodeLayers(nodeID, nodeLayers);</span>
<span class="line-modified"> 559     }</span>
 560 
 561     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 562         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });



 563 }
 564 
 565 void RenderLayerCompositor::didPaintBacking(RenderLayerBacking*)
 566 {
 567     auto&amp; frameView = m_renderView.frameView();
 568     frameView.setLastPaintTime(MonotonicTime::now());
 569     if (frameView.milestonesPendingPaint())
 570         frameView.firePaintRelatedMilestonesIfNeeded();
 571 }
 572 
 573 void RenderLayerCompositor::didChangeVisibleRect()
 574 {
 575     auto* rootLayer = rootGraphicsLayer();
 576     if (!rootLayer)
 577         return;
 578 
 579     FloatRect visibleRect = visibleRectForLayerFlushing();
 580     bool requiresFlush = rootLayer-&gt;visibleRectChangeRequiresFlush(visibleRect);
 581     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor::didChangeVisibleRect &quot; &lt;&lt; visibleRect &lt;&lt; &quot; requiresFlush &quot; &lt;&lt; requiresFlush);
 582     if (requiresFlush)
<span class="line-modified"> 583         scheduleLayerFlushNow();</span>
 584 }
 585 
 586 void RenderLayerCompositor::notifyFlushBeforeDisplayRefresh(const GraphicsLayer*)
 587 {
 588     if (!m_layerUpdater) {
 589         PlatformDisplayID displayID = page().chrome().displayID();
<span class="line-modified"> 590         m_layerUpdater = std::make_unique&lt;GraphicsLayerUpdater&gt;(*this, displayID);</span>
 591     }
 592 
 593     m_layerUpdater-&gt;scheduleUpdate();
 594 }
 595 
 596 void RenderLayerCompositor::flushLayersSoon(GraphicsLayerUpdater&amp;)
 597 {
 598     scheduleLayerFlush(true);
 599 }
 600 
 601 void RenderLayerCompositor::layerTiledBackingUsageChanged(const GraphicsLayer* graphicsLayer, bool usingTiledBacking)
 602 {
 603     if (usingTiledBacking) {
 604         ++m_layersWithTiledBackingCount;
 605         graphicsLayer-&gt;tiledBacking()-&gt;setIsInWindow(page().isInWindow());
 606     } else {
 607         ASSERT(m_layersWithTiledBackingCount &gt; 0);
 608         --m_layersWithTiledBackingCount;
 609     }
 610 }
</pre>
<hr />
<pre>
 649         return frameHostingNodeID;
 650 
 651     return { };
 652 }
 653 
 654 // Returns true on a successful update.
 655 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 656 {
 657     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
 658 
 659 #if ENABLE(TREE_DEBUGGING)
 660     if (compositingLogEnabled())
 661         showPaintOrderTree(m_renderView.layer());
 662 #endif
 663 
 664     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
 665         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 666 
 667     m_updateCompositingLayersTimer.stop();
 668 
<span class="line-modified"> 669     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);</span>

 670 
 671     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
 672     if (!m_renderView.document().visualUpdatesAllowed())
 673         return false;
 674 
 675     // Avoid updating the layers with old values. Compositing layers will be updated after the layout is finished.
 676     // This happens when m_updateCompositingLayersTimer fires before layout is updated.
 677     if (m_renderView.needsLayout()) {
 678         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; - m_renderView.needsLayout, bailing &quot;);
 679         return false;
 680     }
 681 
 682     if (!m_compositing &amp;&amp; (m_forceCompositingMode || (isMainFrameCompositor() &amp;&amp; page().pageOverlayController().overlayCount())))
 683         enableCompositingMode(true);
 684 
 685     bool isPageScroll = !updateRoot || updateRoot == &amp;rootRenderLayer();
 686     updateRoot = &amp;rootRenderLayer();
 687 
 688     if (updateType == CompositingUpdateType::OnScroll || updateType == CompositingUpdateType::OnCompositedScroll) {
 689         // We only get here if we didn&#39;t scroll on the scrolling thread, so this update needs to re-position viewport-constrained layers.
 690         if (m_renderView.settings().acceleratedCompositingForFixedPositionEnabled() &amp;&amp; isPageScroll) {
 691             if (auto* viewportConstrainedObjects = m_renderView.frameView().viewportConstrainedObjects()) {
 692                 for (auto* renderer : *viewportConstrainedObjects) {
 693                     if (auto* layer = renderer-&gt;layer())
 694                         layer-&gt;setNeedsCompositingGeometryUpdate();
 695                 }
 696             }
 697         }
 698 
 699         // Scrolling can affect overlap. FIXME: avoid for page scrolling.
 700         updateRoot-&gt;setDescendantsNeedCompositingRequirementsTraversal();
 701     }
 702 





 703     if (!updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !m_compositing) {
 704         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; no compositing work to do&quot;);
 705         return true;
 706     }
 707 
 708     if (!updateRoot-&gt;needsAnyCompositingTraversal()) {
 709         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; updateRoot has no dirty child and doesn&#39;t need update&quot;);
 710         return true;
 711     }
 712 
 713     ++m_compositingUpdateCount;
 714 
 715     AnimationUpdateBlock animationUpdateBlock(&amp;m_renderView.frameView().frame().animation());
 716 
 717     SetForScope&lt;bool&gt; postLayoutChange(m_inPostLayoutUpdate, true);
 718 
 719 #if !LOG_DISABLED
 720     MonotonicTime startTime;
 721     if (compositingLogEnabled()) {
 722         ++m_rootLayerUpdateCount;
 723         startTime = MonotonicTime::now();
 724     }
 725 
 726     if (compositingLogEnabled()) {
 727         m_obligateCompositedLayerCount = 0;
 728         m_secondaryCompositedLayerCount = 0;
 729         m_obligatoryBackingStoreBytes = 0;
 730         m_secondaryBackingStoreBytes = 0;
 731 
 732         auto&amp; frame = m_renderView.frameView().frame();
 733         bool isMainFrame = isMainFrameCompositor();
 734         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;\nUpdate &quot; &lt;&lt; m_rootLayerUpdateCount &lt;&lt; &quot; of &quot; &lt;&lt; (isMainFrame ? &quot;main frame&quot; : frame.tree().uniqueName().string().utf8().data()) &lt;&lt; &quot; - compositing policy is &quot; &lt;&lt; m_compositingPolicy);
 735     }
 736 #endif
 737 
 738     // FIXME: optimize root-only update.
 739     if (updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() || updateRoot-&gt;needsCompositingRequirementsTraversal()) {

 740         CompositingState compositingState(updateRoot);
<span class="line-modified"> 741         OverlapMap overlapMap;</span>

 742 
 743         bool descendantHas3DTransform = false;
<span class="line-modified"> 744         computeCompositingRequirements(nullptr, rootRenderLayer(), overlapMap, compositingState, descendantHas3DTransform);</span>
 745     }
 746 
 747     LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
 748 #if ENABLE(TREE_DEBUGGING)
 749     if (compositingLogEnabled())
 750         showPaintOrderTree(m_renderView.layer());
 751 #endif
 752 
 753     if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
 754         ScrollingTreeState scrollingTreeState = { 0, 0 };
 755         if (!m_renderView.frame().isMainFrame())
 756             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 757 
 758         Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
 759         updateBackingAndHierarchy(*updateRoot, childList, scrollingTreeState);
 760 
 761         // Host the document layer in the RenderView&#39;s root layer.
 762         appendDocumentOverlayLayers(childList);
 763         // Even when childList is empty, don&#39;t drop out of compositing mode if there are
 764         // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
</pre>
<hr />
<pre>
 769     }
 770 
 771 #if !LOG_DISABLED
 772     if (compositingLogEnabled()) {
 773         MonotonicTime endTime = MonotonicTime::now();
 774         LOG(Compositing, &quot;Total layers   primary   secondary   obligatory backing (KB)   secondary backing(KB)   total backing (KB)  update time (ms)\n&quot;);
 775 
 776         LOG(Compositing, &quot;%8d %11d %9d %20.2f %22.2f %22.2f %18.2f\n&quot;,
 777             m_obligateCompositedLayerCount + m_secondaryCompositedLayerCount, m_obligateCompositedLayerCount,
 778             m_secondaryCompositedLayerCount, m_obligatoryBackingStoreBytes / 1024, m_secondaryBackingStoreBytes / 1024, (m_obligatoryBackingStoreBytes + m_secondaryBackingStoreBytes) / 1024, (endTime - startTime).milliseconds());
 779     }
 780 #endif
 781 
 782     // FIXME: Only do if dirty.
 783     updateRootLayerPosition();
 784 
 785 #if ENABLE(TREE_DEBUGGING)
 786     if (compositingLogEnabled()) {
 787         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - post&quot;);
 788         showPaintOrderTree(m_renderView.layer());
<span class="line-removed"> 789         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - GraphicsLayers post, contentLayersCount %d&quot;, m_contentLayersCount);</span>
<span class="line-removed"> 790         showGraphicsLayerTree(m_rootContentsLayer.get());</span>
 791     }
 792 #endif
 793 
 794     InspectorInstrumentation::layerTreeDidChange(&amp;page());
 795 
 796     return true;
 797 }
 798 
<span class="line-modified"> 799 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, OverlapMap&amp; overlapMap, CompositingState&amp; compositingState, bool&amp; descendantHas3DTransform)</span>
 800 {
<span class="line-modified"> 801     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !layer.needsCompositingRequirementsTraversal() &amp;&amp; !compositingState.fullPaintOrderTraversalRequired &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {</span>
<span class="line-modified"> 802         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, descendantHas3DTransform);</span>












 803         return;
 804     }
 805 
<span class="line-modified"> 806 #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed"> 807     LOG(Compositing, &quot;%*p computeCompositingRequirements&quot;, 12 + compositingState.depth * 2, &amp;layer);</span>
<span class="line-removed"> 808 #endif</span>
 809 
 810     // FIXME: maybe we can avoid updating all remaining layers in paint order.
 811     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
 812     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 813 
 814     layer.updateDescendantDependentFlags();
 815     layer.updateLayerListsIfNeeded();
 816 
 817     layer.setHasCompositingDescendant(false);
 818 
 819     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
 820     RequiresCompositingData queryData;
 821     bool willBeComposited = layer.isComposited();



 822     if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
<span class="line-modified"> 823         layer.setIndirectCompositingReason(RenderLayer::IndirectCompositingReason::None);</span>
 824         willBeComposited = needsToBeComposited(layer, queryData);
 825     }
 826 








 827     compositingState.fullPaintOrderTraversalRequired |= layer.subsequentLayersNeedCompositingRequirementsTraversal();
 828 
 829     OverlapExtent layerExtent;
 830     // Use the fact that we&#39;re composited as a hint to check for an animating transform.
 831     // FIXME: Maybe needsToBeComposited() should return a bitmask of reasons, to avoid the need to recompute things.
 832     if (willBeComposited &amp;&amp; !layer.isRenderViewLayer())
 833         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
 834 
 835     bool respectTransforms = !layerExtent.hasTransformAnimation;
 836     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
 837 
<span class="line-removed"> 838     RenderLayer::IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? RenderLayer::IndirectCompositingReason::Stacking : RenderLayer::IndirectCompositingReason::None;</span>
<span class="line-removed"> 839 </span>
 840     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
<span class="line-modified"> 841     if (!willBeComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap) {</span>
<span class="line-removed"> 842         computeExtent(overlapMap, layer, layerExtent);</span>
 843         // If we&#39;re testing for overlap, we only need to composite if we overlap something that is already composited.
<span class="line-modified"> 844         compositingReason = overlapMap.overlapsLayers(layerExtent.bounds) ? RenderLayer::IndirectCompositingReason::Overlap : RenderLayer::IndirectCompositingReason::None;</span>



 845     }
 846 
 847 #if ENABLE(VIDEO)
 848     // Video is special. It&#39;s the only RenderLayer type that can both have
 849     // RenderLayer children and whose children can&#39;t use its backing to render
 850     // into. These children (the controls) always need to be promoted into their
 851     // own layers to draw on top of the accelerated video.
 852     if (compositingState.compositingAncestor &amp;&amp; compositingState.compositingAncestor-&gt;renderer().isVideo())
<span class="line-modified"> 853         compositingReason = RenderLayer::IndirectCompositingReason::Overlap;</span>
 854 #endif
 855 
<span class="line-modified"> 856     if (compositingReason != RenderLayer::IndirectCompositingReason::None)</span>
 857         layer.setIndirectCompositingReason(compositingReason);
 858 
 859     // Check if the computed indirect reason will force the layer to become composited.
<span class="line-modified"> 860     if (!willBeComposited &amp;&amp; layer.mustCompositeForIndirectReasons() &amp;&amp; canBeComposited(layer))</span>

 861         willBeComposited = true;


 862 
 863     // The children of this layer don&#39;t need to composite, unless there is
 864     // a compositing layer among them, so start by inheriting the compositing
 865     // ancestor with subtreeIsCompositing set to false.
<span class="line-modified"> 866     CompositingState childState(compositingState);</span>
<span class="line-modified"> 867     childState.subtreeIsCompositing = false;</span>
<span class="line-removed"> 868 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed"> 869     childState.hasNotIsolatedCompositedBlendingDescendants = false;</span>
<span class="line-removed"> 870 #endif</span>
 871 
<span class="line-modified"> 872     if (willBeComposited) {</span>
<span class="line-removed"> 873         // Tell the parent it has compositing descendants.</span>
<span class="line-removed"> 874         compositingState.subtreeIsCompositing = true;</span>
<span class="line-removed"> 875         // This layer now acts as the ancestor for kids.</span>
<span class="line-removed"> 876         childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed"> 877 </span>
<span class="line-removed"> 878         overlapMap.pushCompositingContainer();</span>
 879         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
 880         // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified"> 881         childState.testingOverlap = true;</span>




























 882 
 883         computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified"> 884         childState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
 885         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
 886         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;





 887     }
 888 


 889 #if !ASSERT_DISABLED
 890     LayerListMutationDetector mutationChecker(layer);
 891 #endif
 892 
 893     bool anyDescendantHas3DTransform = false;

 894 
 895     for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified"> 896         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
 897 
 898         // If we have to make a layer for this child, make one now so we can have a contents layer
 899         // (since we need to ensure that the -ve z-order child renders underneath our contents).
<span class="line-modified"> 900         if (!willBeComposited &amp;&amp; childState.subtreeIsCompositing) {</span>
<span class="line-modified"> 901             // make layer compositing</span>
<span class="line-modified"> 902             layer.setIndirectCompositingReason(RenderLayer::IndirectCompositingReason::BackgroundLayer);</span>
<span class="line-removed"> 903             childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed"> 904             overlapMap.pushCompositingContainer();</span>
<span class="line-removed"> 905             // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an</span>
<span class="line-removed"> 906             // animation running behind this layer, meaning they can rely on the overlap map testing again</span>
<span class="line-removed"> 907             childState.testingOverlap = true;</span>
<span class="line-removed"> 908             willBeComposited = true;</span>
 909         }
 910     }
 911 
 912     for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified"> 913         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
 914 
 915     for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified"> 916         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>



 917 
 918     // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
 919     if (layer.isRenderViewLayer()) {
 920         if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
 921             willBeComposited = true;
 922     }
 923 
<span class="line-removed"> 924     // All layers (even ones that aren&#39;t being composited) need to get added to</span>
<span class="line-removed"> 925     // the overlap map. Layers that do not composite will draw into their</span>
<span class="line-removed"> 926     // compositing ancestor&#39;s backing, and so are still considered for overlap.</span>
<span class="line-removed"> 927     // FIXME: When layerExtent has taken animation bounds into account, we also know that the bounds</span>
<span class="line-removed"> 928     // include descendants, so we don&#39;t need to add them all to the overlap map.</span>
<span class="line-removed"> 929     if (childState.compositingAncestor &amp;&amp; !childState.compositingAncestor-&gt;isRenderViewLayer())</span>
<span class="line-removed"> 930         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-removed"> 931 </span>
 932 #if ENABLE(CSS_COMPOSITING)
<span class="line-modified"> 933     layer.setHasNotIsolatedCompositedBlendingDescendants(childState.hasNotIsolatedCompositedBlendingDescendants);</span>






 934     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
 935 #endif
 936     // Now check for reasons to become composited that depend on the state of descendant layers.
<span class="line-modified"> 937     RenderLayer::IndirectCompositingReason indirectCompositingReason;</span>
 938     if (!willBeComposited &amp;&amp; canBeComposited(layer)
<span class="line-modified"> 939         &amp;&amp; requiresCompositingForIndirectReason(layer.renderer(), childState.subtreeIsCompositing, anyDescendantHas3DTransform, indirectCompositingReason)) {</span>
 940         layer.setIndirectCompositingReason(indirectCompositingReason);
<span class="line-modified"> 941         childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed"> 942         overlapMap.pushCompositingContainer();</span>
<span class="line-removed"> 943         addToOverlapMapRecursive(overlapMap, layer);</span>
<span class="line-removed"> 944         willBeComposited = true;</span>
 945     }
 946 
 947     if (layer.reflectionLayer()) {
 948         // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
<span class="line-modified"> 949         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? RenderLayer::IndirectCompositingReason::Stacking : RenderLayer::IndirectCompositingReason::None);</span>
 950     }
 951 
<span class="line-modified"> 952     // Subsequent layers in the parent stacking context also need to composite.</span>
<span class="line-removed"> 953     compositingState.subtreeIsCompositing |= childState.subtreeIsCompositing;</span>
<span class="line-removed"> 954     compositingState.fullPaintOrderTraversalRequired |= childState.fullPaintOrderTraversalRequired;</span>
<span class="line-removed"> 955 </span>
<span class="line-removed"> 956     // Set the flag to say that this layer has compositing children.</span>
<span class="line-removed"> 957     layer.setHasCompositingDescendant(childState.subtreeIsCompositing);</span>
<span class="line-removed"> 958 </span>
<span class="line-removed"> 959     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that again.</span>
 960     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);
<span class="line-modified"> 961 </span>
<span class="line-modified"> 962     // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.</span>
<span class="line-removed"> 963     // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because</span>
<span class="line-removed"> 964     // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.</span>
<span class="line-removed"> 965     if ((!childState.testingOverlap &amp;&amp; !isCompositedClippingLayer) || layerExtent.knownToBeHaveExtentUncertainty())</span>
<span class="line-removed"> 966         compositingState.testingOverlap = false;</span>
<span class="line-removed"> 967 </span>
<span class="line-removed"> 968     if (isCompositedClippingLayer) {</span>
<span class="line-removed"> 969         if (!willBeComposited) {</span>
<span class="line-removed"> 970             childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed"> 971             overlapMap.pushCompositingContainer();</span>
<span class="line-removed"> 972             addToOverlapMapRecursive(overlapMap, layer);</span>
<span class="line-removed"> 973             willBeComposited = true;</span>
<span class="line-removed"> 974         }</span>
<span class="line-removed"> 975     }</span>
<span class="line-removed"> 976 </span>
<span class="line-removed"> 977 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed"> 978     if ((willBeComposited &amp;&amp; layer.hasBlendMode())</span>
<span class="line-removed"> 979         || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))</span>
<span class="line-removed"> 980         compositingState.hasNotIsolatedCompositedBlendingDescendants = true;</span>
<span class="line-removed"> 981 #endif</span>
<span class="line-removed"> 982 </span>
<span class="line-removed"> 983     if (childState.compositingAncestor == &amp;layer &amp;&amp; !layer.isRenderViewLayer())</span>
<span class="line-removed"> 984         overlapMap.popCompositingContainer();</span>
 985 
 986     // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
 987     // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
 988     // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
 989     RequiresCompositingData rootLayerQueryData;
<span class="line-modified"> 990     if (layer.isRenderViewLayer() &amp;&amp; !childState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {</span>
 991         // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
 992 #if !PLATFORM(IOS_FAMILY)
 993         enableCompositingMode(false);
 994         willBeComposited = false;
 995 #endif
 996     }
 997 
 998     ASSERT(willBeComposited == needsToBeComposited(layer, queryData));
 999 
1000     // Create or destroy backing here. However, we can&#39;t update geometry because layers above us may become composited
1001     // during post-order traversal (e.g. for clipping).
1002     if (updateBacking(layer, queryData, CompositingChangeRepaintNow, willBeComposited ? BackingRequired::Yes : BackingRequired::No)) {
1003         layer.setNeedsCompositingLayerConnection();
1004         // Child layers need to get a geometry update to recompute their position.
1005         layer.setChildrenNeedCompositingGeometryUpdate();
1006         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
1007         layer.setNeedsCompositingGeometryUpdateOnAncestors();
1008     }
1009 

1010     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))
1011         layer.setNeedsCompositingLayerConnection();
1012 
<span class="line-removed">1013     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>
<span class="line-removed">1014 </span>
1015     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
1016     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
1017         layer.setChildrenNeedCompositingGeometryUpdate();
1018         layer.setNeedsCompositingLayerConnection();
1019     }
1020 
<span class="line-removed">1021 #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed">1022     LOG(Compositing, &quot;%*p computeCompositingRequirements - willBeComposited %d&quot;, 12 + compositingState.depth * 2, &amp;layer, willBeComposited);</span>
<span class="line-removed">1023 #endif</span>
<span class="line-removed">1024 </span>
1025     layer.clearCompositingRequirementsTraversalState();
1026 











1027     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);


1028 }
1029 
1030 // We have to traverse unchanged layers to fill in the overlap map.
<span class="line-modified">1031 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, OverlapMap&amp; overlapMap, CompositingState&amp; compositingState, bool&amp; descendantHas3DTransform)</span>
1032 {
1033     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
1034     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
1035     ASSERT(!layer.needsCompositingRequirementsTraversal());
1036 
<span class="line-modified">1037 #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed">1038     LOG(Compositing, &quot;%*p traverseUnchangedSubtree&quot;, 12 + compositingState.depth * 2, &amp;layer);</span>
<span class="line-removed">1039 #endif</span>
1040 
1041     layer.updateDescendantDependentFlags();
1042     layer.updateLayerListsIfNeeded();
1043 
1044     bool layerIsComposited = layer.isComposited();


1045 
1046     OverlapExtent layerExtent;
1047     if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
1048         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
1049 
1050     bool respectTransforms = !layerExtent.hasTransformAnimation;
1051     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
1052 
1053     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
1054     if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
1055         computeExtent(overlapMap, layer, layerExtent);
1056 
<span class="line-modified">1057     CompositingState childState(compositingState);</span>
<span class="line-modified">1058     childState.subtreeIsCompositing = false;</span>
<span class="line-modified">1059 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified">1060     childState.hasNotIsolatedCompositedBlendingDescendants = false;</span>
<span class="line-modified">1061 #endif</span>

1062 
<span class="line-modified">1063     if (layerIsComposited) {</span>
<span class="line-removed">1064         // Tell the parent it has compositing descendants.</span>
<span class="line-removed">1065         compositingState.subtreeIsCompositing = true;</span>
<span class="line-removed">1066         // This layer now acts as the ancestor for kids.</span>
<span class="line-removed">1067         childState.compositingAncestor = &amp;layer;</span>
1068 
<span class="line-modified">1069         overlapMap.pushCompositingContainer();</span>
1070         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
1071         // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified">1072         childState.testingOverlap = true;</span>






1073 
1074         computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified">1075         childState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
1076         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
1077         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;





1078     }
1079 


1080 #if !ASSERT_DISABLED
1081     LayerListMutationDetector mutationChecker(layer);
1082 #endif
1083 
1084     bool anyDescendantHas3DTransform = false;
1085 
1086     for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified">1087         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
<span class="line-modified">1088         if (childState.subtreeIsCompositing)</span>
1089             ASSERT(layerIsComposited);
1090     }
1091 
1092     for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified">1093         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
1094 
1095     for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified">1096         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
<span class="line-removed">1097 </span>
<span class="line-removed">1098     // All layers (even ones that aren&#39;t being composited) need to get added to</span>
<span class="line-removed">1099     // the overlap map. Layers that do not composite will draw into their</span>
<span class="line-removed">1100     // compositing ancestor&#39;s backing, and so are still considered for overlap.</span>
<span class="line-removed">1101     // FIXME: When layerExtent has taken animation bounds into account, we also know that the bounds</span>
<span class="line-removed">1102     // include descendants, so we don&#39;t need to add them all to the overlap map.</span>
<span class="line-removed">1103     if (childState.compositingAncestor &amp;&amp; !childState.compositingAncestor-&gt;isRenderViewLayer())</span>
<span class="line-removed">1104         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-removed">1105 </span>
<span class="line-removed">1106     // Subsequent layers in the parent stacking context also need to composite.</span>
<span class="line-removed">1107     if (childState.subtreeIsCompositing)</span>
<span class="line-removed">1108         compositingState.subtreeIsCompositing = true;</span>
1109 
1110     // Set the flag to say that this layer has compositing children.
<span class="line-modified">1111     ASSERT(layer.hasCompositingDescendant() == childState.subtreeIsCompositing);</span>
<span class="line-modified">1112 </span>
<span class="line-removed">1113     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that again.</span>
<span class="line-removed">1114     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);</span>
1115 
<span class="line-modified">1116     // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.</span>
<span class="line-removed">1117     // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because</span>
<span class="line-removed">1118     // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.</span>
<span class="line-removed">1119     if ((!childState.testingOverlap &amp;&amp; !isCompositedClippingLayer) || layerExtent.knownToBeHaveExtentUncertainty())</span>
<span class="line-removed">1120         compositingState.testingOverlap = false;</span>
<span class="line-removed">1121 </span>
<span class="line-removed">1122     if (isCompositedClippingLayer)</span>
<span class="line-removed">1123         ASSERT(layerIsComposited);</span>
1124 
<span class="line-modified">1125 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified">1126     if ((layerIsComposited &amp;&amp; layer.hasBlendMode())</span>
<span class="line-modified">1127         || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))</span>
<span class="line-removed">1128         compositingState.hasNotIsolatedCompositedBlendingDescendants = true;</span>
<span class="line-removed">1129 #endif</span>
1130 
<span class="line-modified">1131     if (childState.compositingAncestor == &amp;layer &amp;&amp; !layer.isRenderViewLayer())</span>
<span class="line-modified">1132         overlapMap.popCompositingContainer();</span>
1133 
<span class="line-modified">1134     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>
1135 
1136     ASSERT(!layer.needsCompositingRequirementsTraversal());
<span class="line-removed">1137 </span>
<span class="line-removed">1138     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
1139 }
1140 
1141 void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)
1142 {
1143     layer.updateDescendantDependentFlags();
1144     layer.updateLayerListsIfNeeded();
1145 
1146     bool layerNeedsUpdate = !updateLevel.isEmpty();
1147     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
1148         updateLevel.add(UpdateLevel::AllDescendants);
1149 
1150     ScrollingTreeState stateForDescendants = scrollingTreeState;
1151 
1152     auto* layerBacking = layer.backing();
1153     if (layerBacking) {
1154         updateLevel.remove(UpdateLevel::CompositedChildren);
1155 
1156         // We updated the composited bounds in RenderLayerBacking::updateAfterLayout(), but it may have changed
1157         // based on which descendants are now composited.
1158         if (layerBacking-&gt;updateCompositedBounds()) {
1159             layer.setNeedsCompositingGeometryUpdate();
1160             // Our geometry can affect descendants.
1161             updateLevel.add(UpdateLevel::CompositedChildren);
1162         }
1163 
1164         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
1165             if (layerBacking-&gt;updateConfiguration()) {
1166                 layerNeedsUpdate = true; // We also need to update geometry.
1167                 layer.setNeedsCompositingLayerConnection();
1168             }
1169 
1170             layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1171         }
1172 
1173         OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
<span class="line-modified">1174         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate() || layer.needsScrollingTreeUpdate()) {</span>
1175             layerBacking-&gt;updateGeometry();
1176             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
<span class="line-modified">1177         }</span>






1178 
1179         if (auto* reflection = layer.reflectionLayer()) {
1180             if (auto* reflectionBacking = reflection-&gt;backing()) {
1181                 reflectionBacking-&gt;updateCompositedBounds();
1182                 reflectionBacking-&gt;updateGeometry();
1183                 reflectionBacking-&gt;updateAfterDescendants();
1184             }
1185         }
1186 
1187         if (!layer.parent())
1188             updateRootLayerPosition();
1189 
1190         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
1191         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
<span class="line-modified">1192         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, layerBacking-&gt;coordinatedScrollingRoles(), scrollingNodeChanges);</span>
1193         stateForDescendants.nextChildIndex = 0;
1194 
1195 #if !LOG_DISABLED
1196         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);
1197 #else
1198         UNUSED_PARAM(depth);
1199 #endif
1200     }
1201 
1202     if (layer.childrenNeedCompositingGeometryUpdate())
1203         updateLevel.add(UpdateLevel::CompositedChildren);
1204 
1205     // If this layer has backing, then we are collecting its children, otherwise appending
1206     // to the compositing child list of an enclosing layer.
1207     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; layerChildren;
1208     auto&amp; childList = layerBacking ? layerChildren : childLayersOfEnclosingLayer;
1209 
1210     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
1211         || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
1212 
1213     bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
1214 
1215 #if !ASSERT_DISABLED
1216     LayerListMutationDetector mutationChecker(layer);
1217 #endif
1218 
<span class="line-modified">1219     auto appendForegroundLayerIfNecessary = [&amp;] () {</span>
1220         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
1221         if (layer.negativeZOrderLayers().size()) {
1222             if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
1223                 childList.append(*layerBacking-&gt;foregroundLayer());
1224         }
1225     };
1226 
1227     if (requireDescendantTraversal) {
1228         for (auto* renderLayer : layer.negativeZOrderLayers())
1229             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1230 
1231         appendForegroundLayerIfNecessary();
1232 
1233         for (auto* renderLayer : layer.normalFlowLayers())
1234             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1235 
1236         for (auto* renderLayer : layer.positiveZOrderLayers())
1237             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1238     } else if (requiresChildRebuild)
1239         appendForegroundLayerIfNecessary();
</pre>
<hr />
<pre>
1307 #if !LOG_DISABLED
1308 void RenderLayerCompositor::logLayerInfo(const RenderLayer&amp; layer, const char* phase, int depth)
1309 {
1310     if (!compositingLogEnabled())
1311         return;
1312 
1313     auto* backing = layer.backing();
1314     RequiresCompositingData queryData;
1315     if (requiresCompositingLayer(layer, queryData) || layer.isRenderViewLayer()) {
1316         ++m_obligateCompositedLayerCount;
1317         m_obligatoryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1318     } else {
1319         ++m_secondaryCompositedLayerCount;
1320         m_secondaryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1321     }
1322 
1323     LayoutRect absoluteBounds = backing-&gt;compositedBounds();
1324     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
1325 
1326     StringBuilder logString;
<span class="line-modified">1327     logString.append(makeString(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;));</span>
1328 
1329     if (!layer.renderer().style().hasAutoZIndex())
<span class="line-modified">1330         logString.append(makeString(&quot; z-index: &quot;, layer.renderer().style().zIndex()));</span>
1331 
<span class="line-modified">1332     logString.appendLiteral(&quot; (&quot;);</span>
<span class="line-removed">1333     logString.append(logReasonsForCompositing(layer));</span>
<span class="line-removed">1334     logString.appendLiteral(&quot;) &quot;);</span>
1335 
1336     if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1337         logString.append(&#39;[&#39;);
1338         bool prependSpace = false;
1339         if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
1340             logString.appendLiteral(&quot;opaque&quot;);
1341             prependSpace = true;
1342         }
1343 
1344         if (backing-&gt;paintsIntoCompositedAncestor()) {
1345             if (prependSpace)
1346                 logString.appendLiteral(&quot;, &quot;);
1347             logString.appendLiteral(&quot;paints into ancestor&quot;);
1348             prependSpace = true;
1349         }
1350 
1351         if (backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1352             if (prependSpace)
1353                 logString.appendLiteral(&quot;, &quot;);
1354             if (backing-&gt;foregroundLayer() &amp;&amp; backing-&gt;backgroundLayer()) {
</pre>
<hr />
<pre>
1375     logString.append(layer.name());
1376 
1377     logString.appendLiteral(&quot; - &quot;);
1378     logString.append(phase);
1379 
1380     LOG(Compositing, &quot;%s&quot;, logString.toString().utf8().data());
1381 }
1382 #endif
1383 
1384 static bool clippingChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
1385 {
1386     return oldStyle.overflowX() != newStyle.overflowX() || oldStyle.overflowY() != newStyle.overflowY()
1387         || oldStyle.hasClip() != newStyle.hasClip() || oldStyle.clip() != newStyle.clip();
1388 }
1389 
1390 static bool styleAffectsLayerGeometry(const RenderStyle&amp; style)
1391 {
1392     return style.hasClip() || style.clipPath() || style.hasBorderRadius();
1393 }
1394 














1395 void RenderLayerCompositor::layerStyleChanged(StyleDifference diff, RenderLayer&amp; layer, const RenderStyle* oldStyle)
1396 {
1397     if (diff == StyleDifference::Equal)
1398         return;
1399 
1400     // Create or destroy backing here so that code that runs during layout can reliably use isComposited() (though this
1401     // is only true for layers composited for direct reasons).
1402     // Also, it allows us to avoid a tree walk in updateCompositingLayers() when no layer changed its compositing state.
1403     RequiresCompositingData queryData;
1404     queryData.layoutUpToDate = LayoutUpToDate::No;
1405 
1406     bool layerChanged = updateBacking(layer, queryData, CompositingChangeRepaintNow);
1407     if (layerChanged) {
1408         layer.setChildrenNeedCompositingGeometryUpdate();
1409         layer.setNeedsCompositingLayerConnection();
1410         layer.setSubsequentLayersNeedCompositingRequirementsTraversal();
1411         // Ancestor layers that composited for indirect reasons (things listed in styleChangeMayAffectIndirectCompositingReasons()) need to get updated.
1412         // This could be optimized by only setting this flag on layers with the relevant styles.
1413         layer.setNeedsPostLayoutCompositingUpdateOnAncestors();
1414     }
1415 
1416     if (queryData.reevaluateAfterLayout)
1417         layer.setNeedsPostLayoutCompositingUpdate();
1418 
<span class="line-modified">1419     if (diff &gt;= StyleDifference::LayoutPositionedMovementOnly &amp;&amp; hasContentCompositingLayers()) {</span>
<span class="line-modified">1420         layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-modified">1421         layer.setNeedsCompositingGeometryUpdate();</span>

























1422     }
1423 
1424     auto* backing = layer.backing();
1425     if (!backing)
1426         return;
1427 
1428     backing-&gt;updateConfigurationAfterStyleChange();
1429 
<span class="line-removed">1430     const auto&amp; newStyle = layer.renderer().style();</span>
<span class="line-removed">1431 </span>
1432     if (diff &gt;= StyleDifference::Repaint) {
1433         // Visibility change may affect geometry of the enclosing composited layer.
1434         if (oldStyle &amp;&amp; oldStyle-&gt;visibility() != newStyle.visibility())
1435             layer.setNeedsCompositingGeometryUpdate();
1436 
1437         // We&#39;ll get a diff of Repaint when things like clip-path change; these might affect layer or inner-layer geometry.
1438         if (layer.isComposited() &amp;&amp; oldStyle) {
1439             if (styleAffectsLayerGeometry(*oldStyle) || styleAffectsLayerGeometry(newStyle))
1440                 layer.setNeedsCompositingGeometryUpdate();
1441         }
1442     }
1443 
1444     // This is necessary to get iframe layers hooked up in response to scheduleInvalidateStyleAndLayerComposition().
1445     if (diff == StyleDifference::RecompositeLayer &amp;&amp; layer.isComposited() &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer()))
1446         layer.setNeedsCompositingConfigurationUpdate();
1447 
<span class="line-modified">1448     if (diff &gt;= StyleDifference::RecompositeLayer &amp;&amp; oldStyle) {</span>
<span class="line-modified">1449         if (oldStyle-&gt;transform() != newStyle.transform()) {</span>
<span class="line-modified">1450             // FIXME: transform changes really need to trigger layout. See RenderElement::adjustStyleDifference().</span>
<span class="line-removed">1451             layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-removed">1452             layer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-removed">1453         }</span>
<span class="line-removed">1454     }</span>
<span class="line-removed">1455 </span>
<span class="line-removed">1456     if (diff &gt;= StyleDifference::Layout) {</span>
<span class="line-removed">1457         // FIXME: only set flags here if we know we have a composited descendant, but we might not know at this point.</span>
<span class="line-removed">1458         if (oldStyle &amp;&amp; clippingChanged(*oldStyle, newStyle)) {</span>
<span class="line-removed">1459             if (layer.isStackingContext()) {</span>
<span class="line-removed">1460                 layer.setNeedsPostLayoutCompositingUpdate(); // Layer needs to become composited if it has composited descendants.</span>
<span class="line-removed">1461                 layer.setNeedsCompositingConfigurationUpdate(); // If already composited, layer needs to create/destroy clipping layer.</span>
<span class="line-removed">1462             } else {</span>
<span class="line-removed">1463                 // Descendant (in containing block order) compositing layers need to re-evaluate their clipping,</span>
<span class="line-removed">1464                 // but they might be siblings in z-order so go up to our stacking context.</span>
<span class="line-removed">1465                 if (auto* stackingContext = layer.stackingContext())</span>
<span class="line-removed">1466                     stackingContext-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
<span class="line-removed">1467             }</span>
<span class="line-removed">1468         }</span>
<span class="line-removed">1469 </span>
<span class="line-removed">1470         // These properties trigger compositing if some descendant is composited.</span>
<span class="line-removed">1471         if (oldStyle &amp;&amp; styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))</span>
<span class="line-removed">1472             layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-removed">1473 </span>
1474         layer.setNeedsCompositingGeometryUpdate();
1475     }
1476 }
1477 
1478 bool RenderLayerCompositor::needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp; layer, const RenderStyle* oldStyle) const
1479 {
1480     // Needed for scroll bars.
1481     if (layer.isRenderViewLayer())
1482         return true;
1483 
1484     if (!oldStyle)
1485         return false;
1486 
1487     const RenderStyle&amp; newStyle = layer.renderer().style();
1488     // Visibility change may affect geometry of the enclosing composited layer.
1489     if (oldStyle-&gt;visibility() != newStyle.visibility())
1490         return true;
1491 
1492     // We don&#39;t have any direct reasons for this style change to affect layer composition. Test if it might affect things indirectly.
1493     if (styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
</pre>
<hr />
<pre>
1519 
1520     return *renderer;
1521 }
1522 
1523 void RenderLayerCompositor::updateRootContentLayerClipping()
1524 {
1525     m_rootContentsLayer-&gt;setMasksToBounds(!m_renderView.settings().backgroundShouldExtendBeyondPage());
1526 }
1527 
1528 bool RenderLayerCompositor::updateBacking(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint, BackingRequired backingRequired)
1529 {
1530     bool layerChanged = false;
1531     if (backingRequired == BackingRequired::Unknown)
1532         backingRequired = needsToBeComposited(layer, queryData) ? BackingRequired::Yes : BackingRequired::No;
1533     else {
1534         // Need to fetch viewportConstrainedNotCompositedReason, but without doing all the work that needsToBeComposited does.
1535         requiresCompositingForPosition(rendererForCompositingTests(layer), layer, queryData);
1536     }
1537 
1538     if (backingRequired == BackingRequired::Yes) {


1539         enableCompositingMode();
1540 
1541         if (!layer.backing()) {
1542             // If we need to repaint, do so before making backing
1543             if (shouldRepaint == CompositingChangeRepaintNow)
<span class="line-modified">1544                 repaintOnCompositingChange(layer);</span>
1545 
1546             layer.ensureBacking();
1547 
1548             if (layer.isRenderViewLayer() &amp;&amp; useCoordinatedScrollingForLayer(layer)) {
1549                 auto&amp; frameView = m_renderView.frameView();
1550                 if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1551                     scrollingCoordinator-&gt;frameViewRootLayerDidChange(frameView);
1552 #if ENABLE(RUBBER_BANDING)
1553                 updateLayerForHeader(frameView.headerHeight());
1554                 updateLayerForFooter(frameView.footerHeight());
1555 #endif
1556                 updateRootContentLayerClipping();
1557 
1558                 if (auto* tiledBacking = layer.backing()-&gt;tiledBacking())
1559                     tiledBacking-&gt;setTopContentInset(frameView.topContentInset());
1560             }
1561 
1562             // This layer and all of its descendants have cached repaints rects that are relative to
1563             // the repaint container, so change when compositing changes; we need to update them here.
1564             if (layer.parent())
</pre>
<hr />
<pre>
1671         return;
1672 
1673     ASSERT(compositedAncestor-&gt;backing());
1674     LayoutRect repaintRect = rect;
1675     repaintRect.move(layer.offsetFromAncestor(compositedAncestor));
1676     compositedAncestor-&gt;setBackingNeedsRepaintInRect(repaintRect);
1677 
1678     // The contents of this layer may be moving from a GraphicsLayer to the window,
1679     // so we need to make sure the window system synchronizes those changes on the screen.
1680     if (compositedAncestor-&gt;isRenderViewLayer())
1681         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1682 }
1683 
1684 // FIXME: remove.
1685 void RenderLayerCompositor::layerWasAdded(RenderLayer&amp;, RenderLayer&amp;)
1686 {
1687 }
1688 
1689 void RenderLayerCompositor::layerWillBeRemoved(RenderLayer&amp; parent, RenderLayer&amp; child)
1690 {
<span class="line-modified">1691     if (!child.isComposited() || parent.renderer().renderTreeBeingDestroyed())</span>
1692         return;
1693 
<span class="line-modified">1694     repaintInCompositedAncestor(child, child.backing()-&gt;compositedBounds()); // FIXME: do via dirty bits?</span>








1695 
1696     child.setNeedsCompositingLayerConnection();
1697 }
1698 
1699 RenderLayer* RenderLayerCompositor::enclosingNonStackingClippingLayer(const RenderLayer&amp; layer) const
1700 {
1701     for (auto* parent = layer.parent(); parent; parent = parent-&gt;parent()) {
1702         if (parent-&gt;isStackingContext())
1703             return nullptr;
1704         if (parent-&gt;renderer().hasClipOrOverflowClip())
1705             return parent;
1706     }
1707     return nullptr;
1708 }
1709 
<span class="line-modified">1710 void RenderLayerCompositor::computeExtent(const OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const</span>
1711 {
1712     if (extent.extentComputed)
1713         return;
1714 
1715     LayoutRect layerBounds;
1716     if (extent.hasTransformAnimation)
1717         extent.animationCausesExtentUncertainty = !layer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(layerBounds);
1718     else
1719         layerBounds = layer.overlapBounds();
1720 
1721     // In the animating transform case, we avoid double-accounting for the transform because
1722     // we told pushMappingsToAncestor() to ignore transforms earlier.
1723     extent.bounds = enclosingLayoutRect(overlapMap.geometryMap().absoluteRect(layerBounds));
1724 
1725     // Empty rects never intersect, but we need them to for the purposes of overlap testing.
1726     if (extent.bounds.isEmpty())
1727         extent.bounds.setSize(LayoutSize(1, 1));
1728 
<span class="line-removed">1729 </span>
1730     RenderLayerModelObject&amp; renderer = layer.renderer();
1731     if (renderer.isFixedPositioned() &amp;&amp; renderer.container() == &amp;m_renderView) {
1732         // Because fixed elements get moved around without re-computing overlap, we have to compute an overlap
1733         // rect that covers all the locations that the fixed element could move to.
1734         // FIXME: need to handle sticky too.
1735         extent.bounds = m_renderView.frameView().fixedScrollableAreaBoundsInflatedForScrolling(extent.bounds);
1736     }
1737 
1738     extent.extentComputed = true;
1739 }
1740 
<span class="line-modified">1741 void RenderLayerCompositor::addToOverlapMap(OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent)</span>



























































1742 {
1743     if (layer.isRenderViewLayer())
1744         return;
1745 
1746     computeExtent(overlapMap, layer, extent);
1747 
<span class="line-modified">1748     LayoutRect clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.</span>

















1749 
<span class="line-modified">1750     // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="line-modified">1751     if (!m_renderView.settings().delegatesPageScaling())</span>
<span class="line-modified">1752         clipRect.scale(pageScaleFactor());</span>
<span class="line-modified">1753     clipRect.intersect(extent.bounds);</span>
<span class="line-removed">1754     overlapMap.add(clipRect);</span>
1755 }
1756 
<span class="line-modified">1757 void RenderLayerCompositor::addToOverlapMapRecursive(OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer)</span>
1758 {
1759     if (!canBeComposited(layer))
1760         return;
1761 
1762     // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
<span class="line-modified">1763     if (ancestorLayer)</span>
1764         overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
1765 
<span class="line-modified">1766     OverlapExtent layerExtent;</span>
<span class="line-modified">1767     addToOverlapMap(overlapMap, layer, layerExtent);</span>

1768 
1769 #if !ASSERT_DISABLED
1770     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
1771 #endif
1772 
<span class="line-modified">1773     for (auto* renderLayer : layer.negativeZOrderLayers())</span>
<span class="line-modified">1774         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>























1775 
<span class="line-modified">1776     for (auto* renderLayer : layer.normalFlowLayers())</span>
<span class="line-modified">1777         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>



1778 
<span class="line-modified">1779     for (auto* renderLayer : layer.positiveZOrderLayers())</span>
<span class="line-modified">1780         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>

1781 
<span class="line-modified">1782     if (ancestorLayer)</span>
<span class="line-modified">1783         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
1784 }
1785 
1786 #if ENABLE(VIDEO)
1787 bool RenderLayerCompositor::canAccelerateVideoRendering(RenderVideo&amp; video) const
1788 {
1789     if (!m_hasAcceleratedCompositing)
1790         return false;
1791 
1792     return video.supportsAcceleratedRendering();
1793 }
1794 #endif
1795 
1796 void RenderLayerCompositor::frameViewDidChangeLocation(const IntPoint&amp; contentsOffset)
1797 {
1798     if (m_overflowControlsHostLayer)
1799         m_overflowControlsHostLayer-&gt;setPosition(contentsOffset);
1800 }
1801 
1802 void RenderLayerCompositor::frameViewDidChangeSize()
1803 {
1804     if (auto* layer = m_renderView.layer())
1805         layer-&gt;setNeedsCompositingGeometryUpdate();
1806 
1807     if (m_scrolledContentsLayer) {
1808         updateScrollLayerClipping();
1809         frameViewDidScroll();
1810         updateOverflowControlsLayers();
1811 
1812 #if ENABLE(RUBBER_BANDING)
1813         if (m_layerForOverhangAreas) {
1814             auto&amp; frameView = m_renderView.frameView();
1815             m_layerForOverhangAreas-&gt;setSize(frameView.frameRect().size());
1816             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, frameView.topContentInset()));
1817         }
1818 #endif
1819     }
1820 }
1821 


















1822 bool RenderLayerCompositor::hasCoordinatedScrolling() const
1823 {
1824     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
1825     return scrollingCoordinator &amp;&amp; scrollingCoordinator-&gt;coordinatesScrollingForFrameView(m_renderView.frameView());
1826 }
1827 
1828 void RenderLayerCompositor::updateScrollLayerPosition()
1829 {
1830     ASSERT(!hasCoordinatedScrolling());
1831     ASSERT(m_scrolledContentsLayer);
1832 
1833     auto&amp; frameView = m_renderView.frameView();
1834     IntPoint scrollPosition = frameView.scrollPosition();
1835 

1836     m_scrolledContentsLayer-&gt;setPosition(FloatPoint(-scrollPosition.x(), -scrollPosition.y()));
1837 
1838     if (auto* fixedBackgroundLayer = fixedRootBackgroundLayer())
1839         fixedBackgroundLayer-&gt;setPosition(frameView.scrollPositionForFixedPosition());
1840 }
1841 
1842 void RenderLayerCompositor::updateScrollLayerClipping()
1843 {
1844     auto* layerForClipping = this-&gt;layerForClipping();
1845     if (!layerForClipping)
1846         return;
1847 
1848     layerForClipping-&gt;setSize(m_renderView.frameView().sizeForVisibleContent());
1849     layerForClipping-&gt;setPosition(positionForClipLayer());
1850 }
1851 
1852 FloatPoint RenderLayerCompositor::positionForClipLayer() const
1853 {
1854     auto&amp; frameView = m_renderView.frameView();
1855 
1856     return FloatPoint(
1857         frameView.shouldPlaceBlockDirectionScrollbarOnLeft() ? frameView.horizontalScrollbarIntrusion() : 0,
1858         FrameView::yPositionForInsetClipLayer(frameView.scrollPosition(), frameView.topContentInset()));
1859 }
1860 
1861 void RenderLayerCompositor::frameViewDidScroll()
1862 {
1863     if (!m_scrolledContentsLayer)
1864         return;
1865 
1866     // If there&#39;s a scrolling coordinator that manages scrolling for this frame view,
1867     // it will also manage updating the scroll layer position.
1868     if (hasCoordinatedScrolling()) {
1869         // We have to schedule a flush in order for the main TiledBacking to update its tile coverage.
<span class="line-modified">1870         scheduleLayerFlushNow();</span>
1871         return;
1872     }
1873 
1874     updateScrollLayerPosition();
1875 }
1876 
1877 void RenderLayerCompositor::frameViewDidAddOrRemoveScrollbars()
1878 {
1879     updateOverflowControlsLayers();
1880 }
1881 
1882 void RenderLayerCompositor::frameViewDidLayout()
1883 {
1884     if (auto* renderViewBacking = m_renderView.layer()-&gt;backing())
1885         renderViewBacking-&gt;adjustTiledBackingCoverage();
1886 }
1887 
1888 void RenderLayerCompositor::rootLayerConfigurationChanged()
1889 {
1890     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
1891     if (renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking()) {
1892         m_renderView.layer()-&gt;setNeedsCompositingConfigurationUpdate();
1893         scheduleCompositingLayerUpdate();
1894     }
1895 }
1896 
1897 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
1898 {
1899     updateCompositingLayers(CompositingUpdateType::AfterLayout);
1900 
1901     if (!m_rootContentsLayer)
1902         return String();
1903 
1904     flushPendingLayerChanges(true);

1905 
1906     LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
1907     if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
1908         layerTreeBehavior |= LayerTreeAsTextDebug;
1909     if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
1910         layerTreeBehavior |= LayerTreeAsTextIncludeVisibleRects;
1911     if (flags &amp; LayerTreeFlagsIncludeTileCaches)
1912         layerTreeBehavior |= LayerTreeAsTextIncludeTileCaches;
1913     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
1914         layerTreeBehavior |= LayerTreeAsTextIncludeRepaintRects;
1915     if (flags &amp; LayerTreeFlagsIncludePaintingPhases)
1916         layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
1917     if (flags &amp; LayerTreeFlagsIncludeContentLayers)
1918         layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
1919     if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
1920         layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;


1921     if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
1922         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
1923     if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
1924         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;


1925 
1926     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
1927     // similar between platforms.
1928     String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
1929 
1930     // Dump an empty layer tree only if the only composited layer is the main frame&#39;s tiled backing,
1931     // so that tests expecting us to drop out of accelerated compositing when there are no layers succeed.
1932     if (!hasContentCompositingLayers() &amp;&amp; documentUsesTiledBacking() &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeTileCaches) &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeRootLayerProperties))
1933         layerTreeText = emptyString();
1934 
1935     // The true root layer is not included in the dump, so if we want to report
1936     // its repaint rects, they must be included here.
1937     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
1938         return m_renderView.frameView().trackedRepaintRectsAsText() + layerTreeText;
1939 
1940     return layerTreeText;
1941 }
1942 
1943 static RenderView* frameContentsRenderView(RenderWidget&amp; renderer)
1944 {
</pre>
<hr />
<pre>
2144     if (m_hasAcceleratedCompositing &amp;&amp; layer.isSelfPaintingLayer()) {
2145         if (!layer.isInsideFragmentedFlow())
2146             return true;
2147 
2148         // CSS Regions flow threads do not need to be composited as we use composited RenderFragmentContainers
2149         // to render the background of the RenderFragmentedFlow.
2150         if (layer.isRenderFragmentedFlow())
2151             return false;
2152 
2153         return true;
2154     }
2155     return false;
2156 }
2157 
2158 #if ENABLE(FULLSCREEN_API)
2159 enum class FullScreenDescendant { Yes, No, NotApplicable };
2160 static FullScreenDescendant isDescendantOfFullScreenLayer(const RenderLayer&amp; layer)
2161 {
2162     auto&amp; document = layer.renderer().document();
2163 
<span class="line-modified">2164     if (!document.webkitIsFullScreen() || !document.fullScreenRenderer())</span>
2165         return FullScreenDescendant::NotApplicable;
2166 
<span class="line-modified">2167     auto* fullScreenLayer = document.fullScreenRenderer()-&gt;layer();</span>
2168     if (!fullScreenLayer) {
2169         ASSERT_NOT_REACHED();
2170         return FullScreenDescendant::NotApplicable;
2171     }
2172 
2173     return layer.isDescendantOf(*fullScreenLayer) ? FullScreenDescendant::Yes : FullScreenDescendant::No;
2174 }
2175 #endif
2176 
2177 bool RenderLayerCompositor::requiresOwnBackingStore(const RenderLayer&amp; layer, const RenderLayer* compositingAncestorLayer, const LayoutRect&amp; layerCompositedBoundsInAncestor, const LayoutRect&amp; ancestorCompositedBounds) const
2178 {
2179     auto&amp; renderer = layer.renderer();
2180 
2181     if (compositingAncestorLayer
2182         &amp;&amp; !(compositingAncestorLayer-&gt;backing()-&gt;graphicsLayer()-&gt;drawsContent()
2183             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoWindow()
2184             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoCompositedAncestor()))
2185         return true;
2186 
2187     RequiresCompositingData queryData;
</pre>
<hr />
<pre>
2190         || requiresCompositingForAnimation(renderer)
2191         || requiresCompositingForPosition(renderer, layer, queryData)
2192         || requiresCompositingForCanvas(renderer)
2193         || requiresCompositingForFilters(renderer)
2194         || requiresCompositingForWillChange(renderer)
2195         || requiresCompositingForBackfaceVisibility(renderer)
2196         || requiresCompositingForVideo(renderer)
2197         || requiresCompositingForFrame(renderer, queryData)
2198         || requiresCompositingForPlugin(renderer, queryData)
2199         || requiresCompositingForEditableImage(renderer)
2200         || requiresCompositingForOverflowScrolling(layer, queryData)
2201         || needsContentsCompositingLayer(layer)
2202         || renderer.isTransparent()
2203         || renderer.hasMask()
2204         || renderer.hasReflection()
2205         || renderer.hasFilter()
2206         || renderer.hasBackdropFilter())
2207         return true;
2208 
2209     if (layer.mustCompositeForIndirectReasons()) {
<span class="line-modified">2210         RenderLayer::IndirectCompositingReason reason = layer.indirectCompositingReason();</span>
<span class="line-modified">2211         return reason == RenderLayer::IndirectCompositingReason::Overlap</span>
<span class="line-modified">2212             || reason == RenderLayer::IndirectCompositingReason::Stacking</span>
<span class="line-modified">2213             || reason == RenderLayer::IndirectCompositingReason::BackgroundLayer</span>
<span class="line-modified">2214             || reason == RenderLayer::IndirectCompositingReason::GraphicalEffect</span>
<span class="line-modified">2215             || reason == RenderLayer::IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.</span>

2216     }
2217 
2218     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
2219         return true;
2220 



2221     return false;
2222 }
2223 
2224 OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
2225 {
2226     OptionSet&lt;CompositingReason&gt; reasons;
2227 
2228     if (!layer.isComposited())
2229         return reasons;
2230 
2231     RequiresCompositingData queryData;
2232 
2233     auto&amp; renderer = rendererForCompositingTests(layer);
2234 
2235     if (requiresCompositingForTransform(renderer))
2236         reasons.add(CompositingReason::Transform3D);
2237 
2238     if (requiresCompositingForVideo(renderer))
2239         reasons.add(CompositingReason::Video);
2240     else if (requiresCompositingForCanvas(renderer))
</pre>
<hr />
<pre>
2248 
2249     if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
2250         reasons.add(CompositingReason::BackfaceVisibilityHidden);
2251 
2252     if (clipsCompositingDescendants(*renderer.layer()))
2253         reasons.add(CompositingReason::ClipsCompositingDescendants);
2254 
2255     if (requiresCompositingForAnimation(renderer))
2256         reasons.add(CompositingReason::Animation);
2257 
2258     if (requiresCompositingForFilters(renderer))
2259         reasons.add(CompositingReason::Filters);
2260 
2261     if (requiresCompositingForWillChange(renderer))
2262         reasons.add(CompositingReason::WillChange);
2263 
2264     if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
2265         reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
2266 
2267     if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
<span class="line-modified">2268         reasons.add(CompositingReason::OverflowScrollingTouch);</span>
2269 
2270     switch (renderer.layer()-&gt;indirectCompositingReason()) {
<span class="line-modified">2271     case RenderLayer::IndirectCompositingReason::None:</span>
2272         break;
<span class="line-modified">2273     case RenderLayer::IndirectCompositingReason::Stacking:</span>
2274         reasons.add(CompositingReason::Stacking);
2275         break;
<span class="line-modified">2276     case RenderLayer::IndirectCompositingReason::Overlap:</span>



2277         reasons.add(CompositingReason::Overlap);
2278         break;
<span class="line-modified">2279     case RenderLayer::IndirectCompositingReason::BackgroundLayer:</span>
2280         reasons.add(CompositingReason::NegativeZIndexChildren);
2281         break;
<span class="line-modified">2282     case RenderLayer::IndirectCompositingReason::GraphicalEffect:</span>
2283         if (renderer.hasTransform())
2284             reasons.add(CompositingReason::TransformWithCompositedDescendants);
2285 
2286         if (renderer.isTransparent())
2287             reasons.add(CompositingReason::OpacityWithCompositedDescendants);
2288 
2289         if (renderer.hasMask())
2290             reasons.add(CompositingReason::MaskWithCompositedDescendants);
2291 
2292         if (renderer.hasReflection())
2293             reasons.add(CompositingReason::ReflectionWithCompositedDescendants);
2294 
2295         if (renderer.hasFilter() || renderer.hasBackdropFilter())
2296             reasons.add(CompositingReason::FilterWithCompositedDescendants);
2297 
2298 #if ENABLE(CSS_COMPOSITING)
2299         if (layer.isolatesCompositedBlending())
2300             reasons.add(CompositingReason::IsolatesCompositedBlendingDescendants);
2301 
2302         if (layer.hasBlendMode())
2303             reasons.add(CompositingReason::BlendingWithCompositedDescendants);
2304 #endif
2305         break;
<span class="line-modified">2306     case RenderLayer::IndirectCompositingReason::Perspective:</span>
2307         reasons.add(CompositingReason::Perspective);
2308         break;
<span class="line-modified">2309     case RenderLayer::IndirectCompositingReason::Preserve3D:</span>
2310         reasons.add(CompositingReason::Preserve3D);
2311         break;
2312     }
2313 
2314     if (usesCompositing() &amp;&amp; renderer.layer()-&gt;isRenderViewLayer())
2315         reasons.add(CompositingReason::Root);
2316 
2317     return reasons;
2318 }
2319 
2320 #if !LOG_DISABLED
2321 const char* RenderLayerCompositor::logReasonsForCompositing(const RenderLayer&amp; layer)
2322 {
2323     OptionSet&lt;CompositingReason&gt; reasons = reasonsForCompositing(layer);
2324 
2325     if (reasons &amp; CompositingReason::Transform3D)
2326         return &quot;3D transform&quot;;
2327 
2328     if (reasons &amp; CompositingReason::Video)
2329         return &quot;video&quot;;
</pre>
<hr />
<pre>
2338         return &quot;iframe&quot;;
2339 
2340     if (reasons &amp; CompositingReason::BackfaceVisibilityHidden)
2341         return &quot;backface-visibility: hidden&quot;;
2342 
2343     if (reasons &amp; CompositingReason::ClipsCompositingDescendants)
2344         return &quot;clips compositing descendants&quot;;
2345 
2346     if (reasons &amp; CompositingReason::Animation)
2347         return &quot;animation&quot;;
2348 
2349     if (reasons &amp; CompositingReason::Filters)
2350         return &quot;filters&quot;;
2351 
2352     if (reasons &amp; CompositingReason::PositionFixed)
2353         return &quot;position: fixed&quot;;
2354 
2355     if (reasons &amp; CompositingReason::PositionSticky)
2356         return &quot;position: sticky&quot;;
2357 
<span class="line-modified">2358     if (reasons &amp; CompositingReason::OverflowScrollingTouch)</span>
<span class="line-modified">2359         return &quot;-webkit-overflow-scrolling: touch&quot;;</span>
2360 
2361     if (reasons &amp; CompositingReason::Stacking)
2362         return &quot;stacking&quot;;
2363 
2364     if (reasons &amp; CompositingReason::Overlap)
2365         return &quot;overlap&quot;;
2366 
2367     if (reasons &amp; CompositingReason::NegativeZIndexChildren)
2368         return &quot;negative z-index children&quot;;
2369 
2370     if (reasons &amp; CompositingReason::TransformWithCompositedDescendants)
2371         return &quot;transform with composited descendants&quot;;
2372 
2373     if (reasons &amp; CompositingReason::OpacityWithCompositedDescendants)
2374         return &quot;opacity with composited descendants&quot;;
2375 
2376     if (reasons &amp; CompositingReason::MaskWithCompositedDescendants)
2377         return &quot;mask with composited descendants&quot;;
2378 
2379     if (reasons &amp; CompositingReason::ReflectionWithCompositedDescendants)
</pre>
<hr />
<pre>
2392 
2393     if (reasons &amp; CompositingReason::Perspective)
2394         return &quot;perspective&quot;;
2395 
2396     if (reasons &amp; CompositingReason::Preserve3D)
2397         return &quot;preserve-3d&quot;;
2398 
2399     if (reasons &amp; CompositingReason::Root)
2400         return &quot;root&quot;;
2401 
2402     return &quot;&quot;;
2403 }
2404 #endif
2405 
2406 // Return true if the given layer has some ancestor in the RenderLayer hierarchy that clips,
2407 // up to the enclosing compositing ancestor. This is required because compositing layers are parented
2408 // according to the z-order hierarchy, yet clipping goes down the renderer hierarchy.
2409 // Thus, a RenderLayer can be clipped by a RenderLayer that is an ancestor in the renderer hierarchy,
2410 // but a sibling in the z-order hierarchy.
2411 // FIXME: can we do this without a tree walk?
<span class="line-modified">2412 bool RenderLayerCompositor::clippedByAncestor(RenderLayer&amp; layer) const</span>
2413 {
2414     ASSERT(layer.isComposited());
<span class="line-removed">2415     if (!layer.parent())</span>
<span class="line-removed">2416         return false;</span>
<span class="line-removed">2417 </span>
<span class="line-removed">2418     // On first pass in WK1, the root may not have become composited yet.</span>
<span class="line-removed">2419     auto* compositingAncestor = layer.ancestorCompositingLayer();</span>
2420     if (!compositingAncestor)
2421         return false;
2422 
2423     // If the compositingAncestor clips, that will be taken care of by clipsCompositingDescendants(),
2424     // so we only care about clipping between its first child that is our ancestor (the computeClipRoot),
2425     // and layer. The exception is when the compositingAncestor isolates composited blending children,
2426     // in this case it is not allowed to clipsCompositingDescendants() and each of its children
2427     // will be clippedByAncestor()s, including the compositingAncestor.
2428     auto* computeClipRoot = compositingAncestor;
2429     if (!compositingAncestor-&gt;isolatesCompositedBlending()) {
2430         computeClipRoot = nullptr;
2431         auto* parent = &amp;layer;
2432         while (parent) {
2433             auto* next = parent-&gt;parent();
2434             if (next == compositingAncestor) {
2435                 computeClipRoot = parent;
2436                 break;
2437             }
2438             parent = next;
2439         }
2440 
2441         if (!computeClipRoot || computeClipRoot == &amp;layer)
2442             return false;
2443     }
2444 
2445     return !layer.backgroundClipRect(RenderLayer::ClipRectsContext(computeClipRoot, TemporaryClipRects)).isInfinite(); // FIXME: Incorrect for CSS regions.
2446 }
2447 



































































































2448 // Return true if the given layer is a stacking context and has compositing child
2449 // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
2450 // into the hierarchy between this layer and its children in the z-order hierarchy.
<span class="line-modified">2451 bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer) const</span>
2452 {
2453     return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
2454 }
2455 
2456 bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
2457 {
2458     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2459         return false;
2460 
2461     if (auto* element = renderer.element()) {
2462         if (auto* timeline = element-&gt;document().existingTimeline()) {
2463             if (timeline-&gt;runningAnimationsForElementAreAllAccelerated(*element))
2464                 return true;
2465         }
2466     }
2467 
2468     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
2469         return false;
2470 
2471     auto&amp; animController = renderer.animation();
</pre>
<hr />
<pre>
2670         return m_renderView.isComposited();
2671     }
2672 
2673     return m_renderView.frameView().isScrollable();
2674 }
2675 
2676 bool RenderLayerCompositor::requiresCompositingForPosition(RenderLayerModelObject&amp; renderer, const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2677 {
2678     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
2679     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
2680     // z-index and clipping will be broken.
2681     if (!renderer.isPositioned())
2682         return false;
2683 
2684 #if ENABLE(FULLSCREEN_API)
2685     if (isDescendantOfFullScreenLayer(layer) == FullScreenDescendant::No)
2686         return false;
2687 #endif
2688 
2689     auto position = renderer.style().position();
<span class="line-modified">2690     bool isFixed = renderer.isOutOfFlowPositioned() &amp;&amp; position == PositionType::Fixed;</span>
2691     if (isFixed &amp;&amp; !layer.isStackingContext())
2692         return false;
2693 
2694     bool isSticky = renderer.isInFlowPositioned() &amp;&amp; position == PositionType::Sticky;
2695     if (!isFixed &amp;&amp; !isSticky)
2696         return false;
2697 
2698     // FIXME: acceleratedCompositingForFixedPositionEnabled should probably be renamed acceleratedCompositingForViewportConstrainedPositionEnabled().
2699     if (!m_renderView.settings().acceleratedCompositingForFixedPositionEnabled())
2700         return false;
2701 
2702     if (isSticky)
2703         return isAsyncScrollableStickyLayer(layer);
2704 
2705     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2706         queryData.reevaluateAfterLayout = true;
2707         return layer.isComposited();
2708     }
2709 
2710     auto container = renderer.container();
2711     ASSERT(container);
2712 
2713     // Don&#39;t promote fixed position elements that are descendants of a non-view container, e.g. transformed elements.
<span class="line-modified">2714     // They will stay fixed wrt the container rather than the enclosing frame.j</span>
2715     if (container != &amp;m_renderView) {
2716         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNonViewContainer;
2717         return false;
2718     }
2719 
2720     bool paintsContent = layer.isVisuallyNonEmpty() || layer.hasVisibleDescendant();
2721     if (!paintsContent) {
2722         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNoVisibleContent;
2723         return false;
2724     }
2725 
2726     bool intersectsViewport = fixedLayerIntersectsViewport(layer);
2727     if (!intersectsViewport) {
2728         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForBoundsOutOfView;
2729         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is outside the viewport&quot;);
2730         return false;
2731     }
2732 
2733     return true;
2734 }
2735 
2736 bool RenderLayerCompositor::requiresCompositingForOverflowScrolling(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2737 {
2738     if (!layer.canUseCompositedScrolling())
2739         return false;
2740 
2741     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2742         queryData.reevaluateAfterLayout = true;
2743         return layer.isComposited();
2744     }
2745 
2746     return layer.hasCompositedScrollableOverflow();
2747 }
2748 
2749 // FIXME: why doesn&#39;t this handle the clipping cases?
<span class="line-modified">2750 bool RenderLayerCompositor::requiresCompositingForIndirectReason(RenderLayerModelObject&amp; renderer, bool hasCompositedDescendants, bool has3DTransformedDescendants, RenderLayer::IndirectCompositingReason&amp; reason) const</span>
2751 {
<span class="line-removed">2752     auto&amp; layer = *downcast&lt;RenderBoxModelObject&gt;(renderer).layer();</span>
<span class="line-removed">2753 </span>
2754     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
2755     // via compositing so that they also apply to those composited descendants.

2756     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {
<span class="line-modified">2757         reason = RenderLayer::IndirectCompositingReason::GraphicalEffect;</span>
2758         return true;
2759     }
2760 
2761     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
2762     // will be affected by the preserve-3d or perspective.
2763     if (has3DTransformedDescendants) {
2764         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {
<span class="line-modified">2765             reason = RenderLayer::IndirectCompositingReason::Preserve3D;</span>
2766             return true;
2767         }
2768 
2769         if (renderer.style().hasPerspective()) {
<span class="line-modified">2770             reason = RenderLayer::IndirectCompositingReason::Perspective;</span>









2771             return true;
2772         }
2773     }
2774 
<span class="line-modified">2775     reason = RenderLayer::IndirectCompositingReason::None;</span>
2776     return false;
2777 }
2778 
2779 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
2780 {
2781     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
2782         return true;
2783     if (newStyle.isolation() != oldStyle.isolation())
2784         return true;
2785     if (newStyle.hasTransform() != oldStyle.hasTransform())
2786         return true;
2787     if (newStyle.boxReflect() != oldStyle.boxReflect())
2788         return true;
2789     if (newStyle.transformStyle3D() != oldStyle.transformStyle3D())
2790         return true;
2791     if (newStyle.hasPerspective() != oldStyle.hasPerspective())
2792         return true;
2793 
2794     return false;
2795 }
2796 
2797 bool RenderLayerCompositor::isAsyncScrollableStickyLayer(const RenderLayer&amp; layer, const RenderLayer** enclosingAcceleratedOverflowLayer) const
2798 {
2799     ASSERT(layer.renderer().isStickilyPositioned());
2800 
2801     auto* enclosingOverflowLayer = layer.enclosingOverflowClipLayer(ExcludeSelf);
2802 
<span class="line-removed">2803 #if PLATFORM(IOS_FAMILY)</span>
2804     if (enclosingOverflowLayer &amp;&amp; enclosingOverflowLayer-&gt;hasCompositedScrollableOverflow()) {
2805         if (enclosingAcceleratedOverflowLayer)
2806             *enclosingAcceleratedOverflowLayer = enclosingOverflowLayer;
2807         return true;
2808     }
<span class="line-modified">2809 #else</span>
<span class="line-removed">2810     UNUSED_PARAM(enclosingAcceleratedOverflowLayer);</span>
<span class="line-removed">2811 #endif</span>
2812     // If the layer is inside normal overflow, it&#39;s not async-scrollable.
2813     if (enclosingOverflowLayer)
2814         return false;
2815 
2816     // No overflow ancestor, so see if the frame supports async scrolling.
2817     if (hasCoordinatedScrolling())
2818         return true;
2819 
2820 #if PLATFORM(IOS_FAMILY)
2821     // iOS WK1 has fixed/sticky support in the main frame via WebFixedPositionContent.
2822     return isMainFrameCompositor();
2823 #else
2824     return false;
2825 #endif
2826 }
2827 
2828 bool RenderLayerCompositor::isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp; layer) const
2829 {
2830     if (layer.renderer().isStickilyPositioned())
2831         return isAsyncScrollableStickyLayer(layer);
2832 
<span class="line-modified">2833     if (layer.renderer().style().position() != PositionType::Fixed)</span>
2834         return false;
2835 
2836     // FIXME: Handle fixed inside of a transform, which should not behave as fixed.
<span class="line-modified">2837     for (auto* stackingContext = layer.stackingContext(); stackingContext; stackingContext = stackingContext-&gt;stackingContext()) {</span>
<span class="line-modified">2838         if (stackingContext-&gt;isComposited() &amp;&amp; stackingContext-&gt;renderer().isFixedPositioned())</span>


2839             return false;
2840     }
2841 
2842     return true;
2843 }
2844 
2845 bool RenderLayerCompositor::fixedLayerIntersectsViewport(const RenderLayer&amp; layer) const
2846 {
<span class="line-modified">2847     ASSERT(layer.renderer().style().position() == PositionType::Fixed);</span>
2848 
2849     // Fixed position elements that are invisible in the current view don&#39;t get their own layer.
2850     // FIXME: We shouldn&#39;t have to check useFixedLayout() here; one of the viewport rects needs to give the correct answer.
2851     LayoutRect viewBounds;
2852     if (m_renderView.frameView().useFixedLayout())
2853         viewBounds = m_renderView.unscaledDocumentRect();
2854     else
2855         viewBounds = m_renderView.frameView().rectForFixedPositionLayout();
2856 
2857     LayoutRect layerBounds = layer.calculateLayerBounds(&amp;layer, LayoutSize(), { RenderLayer::UseLocalClipRectIfPossible, RenderLayer::IncludeFilterOutsets, RenderLayer::UseFragmentBoxesExcludingCompositing,
2858         RenderLayer::ExcludeHiddenDescendants, RenderLayer::DontConstrainForMask, RenderLayer::IncludeCompositedDescendants });
2859     // Map to m_renderView to ignore page scale.
2860     FloatRect absoluteBounds = layer.renderer().localToContainerQuad(FloatRect(layerBounds), &amp;m_renderView).boundingBox();
2861     return viewBounds.intersects(enclosingIntRect(absoluteBounds));
2862 }
2863 
2864 bool RenderLayerCompositor::useCoordinatedScrollingForLayer(const RenderLayer&amp; layer) const
2865 {
2866     if (layer.isRenderViewLayer() &amp;&amp; hasCoordinatedScrolling())
2867         return true;
2868 
2869     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
2870         return scrollingCoordinator-&gt;coordinatesScrollingForOverflowLayer(layer);
2871 
2872     return false;
2873 }
2874 


























































































































2875 bool RenderLayerCompositor::isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp; layer) const
2876 {
2877     if (!is&lt;RenderWidget&gt;(layer.renderer()))
2878         return false;
2879 
2880     auto* contentDocument = downcast&lt;RenderWidget&gt;(layer.renderer()).frameOwnerElement().contentDocument();
2881     if (!contentDocument)
2882         return false;
2883 
2884     auto* view = contentDocument-&gt;renderView();
2885     if (!view)
2886         return false;
2887 
2888     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
2889         return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(view-&gt;frameView());
2890 
2891     return false;
2892 }
2893 
2894 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
2895 {
2896     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2897         return false;
2898 
2899     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2900         if (auto* element = renderer.element()) {
2901             if (auto* timeline = element-&gt;document().existingTimeline())
2902                 return timeline-&gt;isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2903         }
2904         return false;
2905     }
2906     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2907 }
2908 
<span class="line-modified">2909 // If an element has negative z-index children, those children render in front of the</span>
2910 // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
2911 bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
2912 {
<span class="line-modified">2913     return layer.hasNegativeZOrderLayers();</span>





2914 }
2915 
2916 bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
2917 {
2918     auto&amp; frameView = m_renderView.frameView();
2919 
2920     // This applies when the application UI handles scrolling, in which case RenderLayerCompositor doesn&#39;t need to manage it.
2921     if (frameView.delegatesScrolling() &amp;&amp; isMainFrameCompositor())
2922         return false;
2923 
2924     // We need to handle our own scrolling if we&#39;re:
2925     return !m_renderView.frameView().platformWidget() // viewless (i.e. non-Mac, or Mac in WebKit2)
2926         || attachment == RootLayerAttachedViaEnclosingFrame; // a composited frame on Mac
2927 }
2928 
2929 void paintScrollbar(Scrollbar* scrollbar, GraphicsContext&amp; context, const IntRect&amp; clip)
2930 {
2931     if (!scrollbar)
2932         return;
2933 
2934     context.save();
2935     const IntRect&amp; scrollbarRect = scrollbar-&gt;frameRect();
2936     context.translate(-scrollbarRect.location());
2937     IntRect transformedClip = clip;
2938     transformedClip.moveBy(scrollbarRect.location());
2939     scrollbar-&gt;paint(context, transformedClip);
2940     context.restore();
2941 }
2942 
<span class="line-modified">2943 void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, GraphicsLayerPaintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
2944 {
2945 #if PLATFORM(MAC)
2946     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
2947 #endif
2948 
2949     IntRect pixelSnappedRectForIntegralPositionedItems = snappedIntRect(LayoutRect(clip));
2950     if (graphicsLayer == layerForHorizontalScrollbar())
2951         paintScrollbar(m_renderView.frameView().horizontalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
2952     else if (graphicsLayer == layerForVerticalScrollbar())
2953         paintScrollbar(m_renderView.frameView().verticalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
2954     else if (graphicsLayer == layerForScrollCorner()) {
2955         const IntRect&amp; scrollCorner = m_renderView.frameView().scrollCornerRect();
2956         context.save();
2957         context.translate(-scrollCorner.location());
2958         IntRect transformedClip = pixelSnappedRectForIntegralPositionedItems;
2959         transformedClip.moveBy(scrollCorner.location());
2960         m_renderView.frameView().paintScrollCorner(context, transformedClip);
2961         context.restore();
2962     }
2963 }
</pre>
<hr />
<pre>
3348         GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3349 
3350     if (requiresContentShadowLayer()) {
3351         if (!m_contentShadowLayer) {
3352             m_contentShadowLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3353             m_contentShadowLayer-&gt;setName(&quot;content shadow&quot;);
3354             m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
3355             m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
3356             m_contentShadowLayer-&gt;setAnchorPoint(FloatPoint3D());
3357             m_contentShadowLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingShadow);
3358 
3359             m_scrolledContentsLayer-&gt;addChildBelow(*m_contentShadowLayer, m_rootContentsLayer.get());
3360         }
3361     } else
3362         GraphicsLayer::unparentAndClear(m_contentShadowLayer);
3363 #endif
3364 
3365     if (requiresHorizontalScrollbarLayer()) {
3366         if (!m_layerForHorizontalScrollbar) {
3367             m_layerForHorizontalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">3368             m_layerForHorizontalScrollbar-&gt;setCanDetachBackingStore(false);</span>
3369             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3370             m_layerForHorizontalScrollbar-&gt;setName(&quot;horizontal scrollbar container&quot;);
3371 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3372             m_layerForHorizontalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3373 #endif
3374             m_overflowControlsHostLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
3375 
3376             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3377                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3378         }
3379     } else if (m_layerForHorizontalScrollbar) {
3380         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3381 
3382         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3383             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3384     }
3385 
3386     if (requiresVerticalScrollbarLayer()) {
3387         if (!m_layerForVerticalScrollbar) {
3388             m_layerForVerticalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">3389             m_layerForVerticalScrollbar-&gt;setCanDetachBackingStore(false);</span>
3390             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3391             m_layerForVerticalScrollbar-&gt;setName(&quot;vertical scrollbar container&quot;);
3392 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3393             m_layerForVerticalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3394 #endif
3395             m_overflowControlsHostLayer-&gt;addChild(*m_layerForVerticalScrollbar);
3396 
3397             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3398                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3399         }
3400     } else if (m_layerForVerticalScrollbar) {
3401         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3402 
3403         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3404             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3405     }
3406 
3407     if (requiresScrollCornerLayer()) {
3408         if (!m_layerForScrollCorner) {
3409             m_layerForScrollCorner = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">3410             m_layerForScrollCorner-&gt;setCanDetachBackingStore(false);</span>
3411             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
3412             m_layerForScrollCorner-&gt;setName(&quot;scroll corner&quot;);
3413 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3414             m_layerForScrollCorner-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3415 #endif
3416             m_overflowControlsHostLayer-&gt;addChild(*m_layerForScrollCorner);
3417         }
3418     } else
3419         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3420 
3421     m_renderView.frameView().positionScrollbarLayers();
3422 }
3423 
3424 void RenderLayerCompositor::ensureRootLayer()
3425 {
3426     RootLayerAttachment expectedAttachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
3427     if (expectedAttachment == m_rootLayerAttachment)
3428          return;
3429 
3430     if (!m_rootContentsLayer) {
</pre>
<hr />
<pre>
3437 #if PLATFORM(IOS_FAMILY)
3438         // Page scale is applied above this on iOS, so we&#39;ll just say that our root layer applies it.
3439         auto&amp; frame = m_renderView.frameView().frame();
3440         if (frame.isMainFrame())
3441             m_rootContentsLayer-&gt;setAppliesPageScale();
3442 #endif
3443 
3444         // Need to clip to prevent transformed content showing outside this frame
3445         updateRootContentLayerClipping();
3446     }
3447 
3448     if (requiresScrollLayer(expectedAttachment)) {
3449         if (!m_overflowControlsHostLayer) {
3450             ASSERT(!m_scrolledContentsLayer);
3451             ASSERT(!m_clipLayer);
3452 
3453             // Create a layer to host the clipping layer and the overflow controls layers.
3454             m_overflowControlsHostLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3455             m_overflowControlsHostLayer-&gt;setName(&quot;overflow controls host&quot;);
3456 
<span class="line-modified">3457             m_scrolledContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);</span>
3458             m_scrolledContentsLayer-&gt;setName(&quot;scrolled contents&quot;);
3459             m_scrolledContentsLayer-&gt;setAnchorPoint({ });
3460 
3461 #if PLATFORM(IOS_FAMILY)
3462             if (m_renderView.settings().asyncFrameScrollingEnabled()) {
3463                 m_scrollContainerLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrollContainer);
3464 
3465                 m_scrollContainerLayer-&gt;setName(&quot;scroll container&quot;);
3466                 m_scrollContainerLayer-&gt;setMasksToBounds(true);
3467                 m_scrollContainerLayer-&gt;setAnchorPoint({ });
3468 
3469                 m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
3470                 m_overflowControlsHostLayer-&gt;addChild(*m_scrollContainerLayer);
3471             }
3472 #endif


3473             if (!m_scrollContainerLayer) {
3474                 m_clipLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3475                 m_clipLayer-&gt;setName(&quot;frame clipping&quot;);
3476                 m_clipLayer-&gt;setMasksToBounds(true);
3477                 m_clipLayer-&gt;setAnchorPoint({ });
3478 
3479                 m_clipLayer-&gt;addChild(*m_scrolledContentsLayer);
3480                 m_overflowControlsHostLayer-&gt;addChild(*m_clipLayer);
3481             }
3482 
3483             m_scrolledContentsLayer-&gt;addChild(*m_rootContentsLayer);
3484 
3485             updateScrollLayerClipping();
3486             updateOverflowControlsLayers();
3487 
3488             if (hasCoordinatedScrolling())
3489                 scheduleLayerFlush(true);
3490             else
3491                 updateScrollLayerPosition();
3492         }
</pre>
<hr />
<pre>
3562             ASSERT_NOT_REACHED();
3563             break;
3564         case RootLayerAttachedViaChromeClient: {
3565             auto&amp; frame = m_renderView.frameView().frame();
3566             page().chrome().client().attachRootGraphicsLayer(frame, rootGraphicsLayer());
3567             break;
3568         }
3569         case RootLayerAttachedViaEnclosingFrame: {
3570             // The layer will get hooked up via RenderLayerBacking::updateConfiguration()
3571             // for the frame&#39;s renderer in the parent document.
3572             if (auto* ownerElement = m_renderView.document().ownerElement())
3573                 ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
3574             break;
3575         }
3576     }
3577 
3578     m_rootLayerAttachment = attachment;
3579     rootLayerAttachmentChanged();
3580 
3581     if (m_shouldFlushOnReattach) {
<span class="line-modified">3582         scheduleLayerFlushNow();</span>
3583         m_shouldFlushOnReattach = false;
3584     }
3585 }
3586 
3587 void RenderLayerCompositor::detachRootLayer()
3588 {
3589     if (!m_rootContentsLayer || m_rootLayerAttachment == RootLayerUnattached)
3590         return;
3591 
3592     switch (m_rootLayerAttachment) {
3593     case RootLayerAttachedViaEnclosingFrame: {
3594         // The layer will get unhooked up via RenderLayerBacking::updateConfiguration()
3595         // for the frame&#39;s renderer in the parent document.
3596         if (m_overflowControlsHostLayer)
3597             m_overflowControlsHostLayer-&gt;removeFromParent();
3598         else
3599             m_rootContentsLayer-&gt;removeFromParent();
3600 
3601         if (auto* ownerElement = m_renderView.document().ownerElement())
3602             ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
</pre>
<hr />
<pre>
3685     }
3686 
3687     return false;
3688 }
3689 
3690 void RenderLayerCompositor::deviceOrPageScaleFactorChanged()
3691 {
3692     // Page scale will only be applied at to the RenderView and sublayers, but the device scale factor
3693     // needs to be applied at the level of rootGraphicsLayer().
3694     if (auto* rootLayer = rootGraphicsLayer())
3695         rootLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
3696 }
3697 
3698 void RenderLayerCompositor::removeFromScrollCoordinatedLayers(RenderLayer&amp; layer)
3699 {
3700 #if PLATFORM(IOS_FAMILY)
3701     if (m_legacyScrollingLayerCoordinator)
3702         m_legacyScrollingLayerCoordinator-&gt;removeLayer(layer);
3703 #endif
3704 
<span class="line-modified">3705     detachScrollCoordinatedLayer(layer, { ScrollCoordinationRole::Scrolling, ScrollCoordinationRole::ViewportConstrained, ScrollCoordinationRole::FrameHosting });</span>
3706 }
3707 
3708 FixedPositionViewportConstraints RenderLayerCompositor::computeFixedViewportConstraints(RenderLayer&amp; layer) const
3709 {
3710     ASSERT(layer.isComposited());
3711 
3712     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
3713 
3714     FixedPositionViewportConstraints constraints;
3715     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
3716     constraints.setViewportRectAtLastLayout(m_renderView.frameView().rectForFixedPositionLayout());
3717     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
3718 
3719     const RenderStyle&amp; style = layer.renderer().style();
3720     if (!style.left().isAuto())
3721         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
3722 
3723     if (!style.right().isAuto())
3724         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
3725 
3726     if (!style.top().isAuto())
3727         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
3728 
3729     if (!style.bottom().isAuto())
3730         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
3731 
3732     // If left and right are auto, use left.
3733     if (style.left().isAuto() &amp;&amp; style.right().isAuto())
3734         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
3735 
3736     // If top and bottom are auto, use top.
3737     if (style.top().isAuto() &amp;&amp; style.bottom().isAuto())
3738         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
3739 
3740     return constraints;
3741 }
3742 
3743 StickyPositionViewportConstraints RenderLayerCompositor::computeStickyViewportConstraints(RenderLayer&amp; layer) const
3744 {
3745     ASSERT(layer.isComposited());
<span class="line-removed">3746 #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">3747     // We should never get here for stickies constrained by an enclosing clipping layer.</span>
<span class="line-removed">3748     // FIXME: Why does this assertion fail on iOS?</span>
<span class="line-removed">3749     ASSERT(!layer.enclosingOverflowClipLayer(ExcludeSelf));</span>
<span class="line-removed">3750 #endif</span>
3751 
3752     auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(layer.renderer());
3753 
3754     StickyPositionViewportConstraints constraints;
3755     renderer.computeStickyPositionConstraints(constraints, renderer.constrainingRectForStickyPosition());
3756 
3757     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
3758     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
3759     constraints.setStickyOffsetAtLastLayout(renderer.stickyPositionOffset());
3760     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
3761 
3762     return constraints;
3763 }
3764 
3765 static inline ScrollCoordinationRole scrollCoordinationRoleForNodeType(ScrollingNodeType nodeType)
3766 {
3767     switch (nodeType) {
3768     case ScrollingNodeType::MainFrame:
3769     case ScrollingNodeType::Subframe:
3770     case ScrollingNodeType::Overflow:
3771         return ScrollCoordinationRole::Scrolling;


3772     case ScrollingNodeType::FrameHosting:
3773         return ScrollCoordinationRole::FrameHosting;
3774     case ScrollingNodeType::Fixed:
3775     case ScrollingNodeType::Sticky:
3776         return ScrollCoordinationRole::ViewportConstrained;


3777     }
3778     ASSERT_NOT_REACHED();
3779     return ScrollCoordinationRole::Scrolling;
3780 }
3781 
3782 ScrollingNodeID RenderLayerCompositor::attachScrollingNode(RenderLayer&amp; layer, ScrollingNodeType nodeType, ScrollingTreeState&amp; treeState)
3783 {
3784     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3785     auto* backing = layer.backing();
3786     // Crash logs suggest that backing can be null here, but we don&#39;t know how: rdar://problem/18545452.
3787     ASSERT(backing);
3788     if (!backing)
3789         return 0;
3790 
3791     ASSERT(treeState.parentNodeID || nodeType == ScrollingNodeType::Subframe);
3792     ASSERT_IMPLIES(nodeType == ScrollingNodeType::MainFrame, !treeState.parentNodeID.value());
3793 
3794     ScrollCoordinationRole role = scrollCoordinationRoleForNodeType(nodeType);
3795     ScrollingNodeID nodeID = backing-&gt;scrollingNodeIDForRole(role);
<span class="line-modified">3796     if (!nodeID)</span>
<span class="line-modified">3797         nodeID = scrollingCoordinator-&gt;uniqueScrollingNodeID();</span>
3798 
3799     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; attachScrollingNode &quot; &lt;&lt; nodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; backing-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) type &quot; &lt;&lt; nodeType &lt;&lt; &quot; parent &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
3800 














3801     if (nodeType == ScrollingNodeType::Subframe &amp;&amp; !treeState.parentNodeID)
<span class="line-modified">3802         nodeID = scrollingCoordinator-&gt;createNode(nodeType, nodeID);</span>
3803     else {
<span class="line-modified">3804         auto newNodeID = scrollingCoordinator-&gt;insertNode(nodeType, nodeID, treeState.parentNodeID.valueOr(0), treeState.nextChildIndex);</span>
3805         if (newNodeID != nodeID) {
3806             // We&#39;ll get a new nodeID if the type changed (and not if the node is new).
<span class="line-modified">3807             scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(nodeID);</span>
3808             m_scrollingNodeToLayerMap.remove(nodeID);
3809         }
3810         nodeID = newNodeID;
3811     }
3812 
3813     ASSERT(nodeID);
3814     if (!nodeID)
3815         return 0;
3816 
<span class="line-removed">3817     backing-&gt;setScrollingNodeIDForRole(nodeID, role);</span>
<span class="line-removed">3818     m_scrollingNodeToLayerMap.add(nodeID, &amp;layer);</span>
<span class="line-removed">3819 </span>
3820     ++treeState.nextChildIndex;
3821     return nodeID;
3822 }
3823 
3824 void RenderLayerCompositor::detachScrollCoordinatedLayerWithRole(RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator, ScrollCoordinationRole role)
3825 {
























3826     auto nodeID = layer.backing()-&gt;scrollingNodeIDForRole(role);
3827     if (!nodeID)
3828         return;
3829 
<span class="line-modified">3830     auto childNodes = scrollingCoordinator.childrenOfNode(nodeID);</span>
<span class="line-removed">3831     for (auto childNodeID : childNodes) {</span>
<span class="line-removed">3832         // FIXME: The child might be in a child frame. Need to do something that crosses frame boundaries.</span>
<span class="line-removed">3833         if (auto* layer = m_scrollingNodeToLayerMap.get(childNodeID))</span>
<span class="line-removed">3834             layer-&gt;setNeedsScrollingTreeUpdate();</span>
<span class="line-removed">3835     }</span>
<span class="line-removed">3836 </span>
<span class="line-removed">3837     m_scrollingNodeToLayerMap.remove(nodeID);</span>
3838 }
3839 
3840 void RenderLayerCompositor::detachScrollCoordinatedLayer(RenderLayer&amp; layer, OptionSet&lt;ScrollCoordinationRole&gt; roles)
3841 {
3842     auto* backing = layer.backing();
3843     if (!backing)
3844         return;
3845 
3846     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3847 
3848     if (roles.contains(ScrollCoordinationRole::Scrolling))
3849         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
3850 



3851     if (roles.contains(ScrollCoordinationRole::FrameHosting))
3852         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
3853 
3854     if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
3855         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
3856 



3857     backing-&gt;detachFromScrollingCoordinator(roles);
3858 }
3859 
<span class="line-modified">3860 ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollCoordinationRole&gt; roles, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>



























3861 {
<span class="line-modified">3862     bool isViewportConstrained = roles.contains(ScrollCoordinationRole::ViewportConstrained);</span>

3863 #if PLATFORM(IOS_FAMILY)
3864     if (m_legacyScrollingLayerCoordinator) {
<span class="line-modified">3865         if (isViewportConstrained)</span>
3866             m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
3867         else
3868             m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
3869     }
3870 #endif
3871 
<span class="line-removed">3872     // GraphicsLayers need to know whether they are viewport-constrained.</span>
<span class="line-removed">3873     layer.backing()-&gt;setIsScrollCoordinatedWithViewportConstrainedRole(isViewportConstrained);</span>
<span class="line-removed">3874 </span>
3875     if (!hasCoordinatedScrolling()) {
3876         // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
3877         return 0;
3878     }
3879 
3880     auto newNodeID = treeState.parentNodeID.valueOr(0);
3881 
<span class="line-modified">3882     ScrollingTreeState viewportConstrainedChildTreeState;</span>
3883     ScrollingTreeState* currentTreeState = &amp;treeState;
3884 
<span class="line-modified">3885     // If a node plays both roles, fixed/sticky is always the ancestor node of scrolling/frame hosting.</span>
















3886     if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
3887         newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
3888         // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
<span class="line-modified">3889         viewportConstrainedChildTreeState.parentNodeID = newNodeID;</span>
<span class="line-modified">3890         currentTreeState = &amp;viewportConstrainedChildTreeState;</span>
3891     } else
3892         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ViewportConstrained);
3893 
3894     if (roles.contains(ScrollCoordinationRole::Scrolling))
3895         newNodeID = updateScrollingNodeForScrollingRole(layer, *currentTreeState, changes);
3896     else
3897         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Scrolling);
3898 
3899     if (roles.contains(ScrollCoordinationRole::FrameHosting))
3900         newNodeID = updateScrollingNodeForFrameHostingRole(layer, *currentTreeState, changes);
3901     else
3902         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::FrameHosting);
3903 
3904     return newNodeID;
3905 }
3906 
3907 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
3908 {
3909     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3910 
3911     auto nodeType = ScrollingNodeType::Fixed;
3912     if (layer.renderer().style().position() == PositionType::Sticky)
3913         nodeType = ScrollingNodeType::Sticky;
3914     else
3915         ASSERT(layer.renderer().isFixedPositioned());
3916 
3917     auto newNodeID = attachScrollingNode(layer, nodeType, treeState);
3918     if (!newNodeID) {
3919         ASSERT_NOT_REACHED();
3920         return treeState.parentNodeID.valueOr(0);
3921     }
3922 
3923     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Registering ViewportConstrained &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) as child of &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
3924 
3925     if (changes &amp; ScrollingNodeChangeFlags::Layer)
3926         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
3927 
3928     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
3929         switch (nodeType) {
3930         case ScrollingNodeType::Fixed:
<span class="line-modified">3931             scrollingCoordinator-&gt;setViewportConstraintedNodeGeometry(newNodeID, computeFixedViewportConstraints(layer));</span>
3932             break;
3933         case ScrollingNodeType::Sticky:
<span class="line-modified">3934             scrollingCoordinator-&gt;setViewportConstraintedNodeGeometry(newNodeID, computeStickyViewportConstraints(layer));</span>
3935             break;
<span class="line-modified">3936         case ScrollingNodeType::MainFrame:</span>
<span class="line-removed">3937         case ScrollingNodeType::Subframe:</span>
<span class="line-removed">3938         case ScrollingNodeType::FrameHosting:</span>
<span class="line-removed">3939         case ScrollingNodeType::Overflow:</span>
3940             break;
3941         }
3942     }
3943 
3944     return newNodeID;
3945 }
3946 
<span class="line-modified">3947 void RenderLayerCompositor::computeFrameScrollingGeometry(ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const</span>
3948 {
3949     auto&amp; frameView = m_renderView.frameView();
3950 
3951     if (m_renderView.frame().isMainFrame())
<span class="line-modified">3952         scrollingGeometry.parentRelativeScrollableRect = frameView.frameRect();</span>
<span class="line-removed">3953     else</span>
<span class="line-removed">3954         scrollingGeometry.parentRelativeScrollableRect = LayoutRect({ }, LayoutSize(frameView.size()));</span>
3955 
<span class="line-modified">3956     scrollingGeometry.scrollOrigin = frameView.scrollOrigin();</span>
<span class="line-removed">3957     scrollingGeometry.scrollableAreaSize = frameView.visibleContentRect().size();</span>
<span class="line-removed">3958     scrollingGeometry.contentSize = frameView.totalContentsSize();</span>
<span class="line-removed">3959     scrollingGeometry.reachableContentSize = frameView.totalContentsSize();</span>
<span class="line-removed">3960 #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-removed">3961     frameView.updateSnapOffsets();</span>
<span class="line-removed">3962     updateScrollSnapPropertiesWithFrameView(frameView);</span>
<span class="line-removed">3963 #endif</span>
3964 }
3965 
<span class="line-modified">3966 void RenderLayerCompositor::computeFrameHostingGeometry(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const</span>
3967 {
3968     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
<span class="line-modified">3969     if (ancestorLayer) {</span>
<span class="line-modified">3970         LayoutRect scrollableRect;</span>
<span class="line-removed">3971         if (is&lt;RenderBox&gt;(layer.renderer()))</span>
<span class="line-removed">3972             scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();</span>
3973 
<span class="line-modified">3974         auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.</span>
<span class="line-modified">3975         scrollableRect.setLocation(offset);</span>
<span class="line-modified">3976         scrollingGeometry.parentRelativeScrollableRect = scrollableRect;</span>
<span class="line-modified">3977     }</span>



3978 }
3979 
<span class="line-modified">3980 void RenderLayerCompositor::computeOverflowScrollingGeometry(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const</span>
3981 {
<span class="line-modified">3982     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.</span>
<span class="line-modified">3983     if (ancestorLayer) {</span>
<span class="line-modified">3984         LayoutRect scrollableRect;</span>
<span class="line-modified">3985         if (is&lt;RenderBox&gt;(layer.renderer()))</span>
<span class="line-modified">3986             scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();</span>
<span class="line-modified">3987 </span>
<span class="line-modified">3988         auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.</span>
<span class="line-modified">3989         scrollableRect.setLocation(offset);</span>
<span class="line-modified">3990         scrollingGeometry.parentRelativeScrollableRect = scrollableRect;</span>



3991     }
<span class="line-removed">3992 </span>
<span class="line-removed">3993     scrollingGeometry.scrollOrigin = layer.scrollOrigin();</span>
<span class="line-removed">3994     scrollingGeometry.scrollPosition = layer.scrollPosition();</span>
<span class="line-removed">3995     scrollingGeometry.scrollableAreaSize = layer.visibleSize();</span>
<span class="line-removed">3996     scrollingGeometry.contentSize = layer.contentsSize();</span>
<span class="line-removed">3997     scrollingGeometry.reachableContentSize = layer.scrollableContentsSize();</span>
<span class="line-removed">3998 #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-removed">3999     if (auto* offsets = layer.horizontalSnapOffsets())</span>
<span class="line-removed">4000         scrollingGeometry.horizontalSnapOffsets = *offsets;</span>
<span class="line-removed">4001     if (auto* offsets = layer.verticalSnapOffsets())</span>
<span class="line-removed">4002         scrollingGeometry.verticalSnapOffsets = *offsets;</span>
<span class="line-removed">4003     if (auto* ranges = layer.horizontalSnapOffsetRanges())</span>
<span class="line-removed">4004         scrollingGeometry.horizontalSnapOffsetRanges = *ranges;</span>
<span class="line-removed">4005     if (auto* ranges = layer.verticalSnapOffsetRanges())</span>
<span class="line-removed">4006         scrollingGeometry.verticalSnapOffsetRanges = *ranges;</span>
<span class="line-removed">4007     scrollingGeometry.currentHorizontalSnapPointIndex = layer.currentHorizontalSnapPointIndex();</span>
<span class="line-removed">4008     scrollingGeometry.currentVerticalSnapPointIndex = layer.currentVerticalSnapPointIndex();</span>
<span class="line-removed">4009 #endif</span>
4010 }
4011 
4012 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4013 {
4014     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4015 
4016     ScrollingNodeID newNodeID = 0;
4017 
4018     if (layer.isRenderViewLayer()) {
4019         FrameView&amp; frameView = m_renderView.frameView();
4020         ASSERT_UNUSED(frameView, scrollingCoordinator-&gt;coordinatesScrollingForFrameView(frameView));
4021 
4022         newNodeID = attachScrollingNode(*m_renderView.layer(), m_renderView.frame().isMainFrame() ? ScrollingNodeType::MainFrame : ScrollingNodeType::Subframe, treeState);
4023 
4024         if (!newNodeID) {
4025             ASSERT_NOT_REACHED();
4026             return treeState.parentNodeID.valueOr(0);
4027         }
4028 
4029         if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">4030             scrollingCoordinator-&gt;setNodeLayers(newNodeID, { nullptr, scrollContainerLayer(), scrolledContentsLayer(), fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer() });</span>
4031 
4032         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
<span class="line-modified">4033             ScrollingCoordinator::ScrollingGeometry scrollingGeometry;</span>
<span class="line-modified">4034             computeFrameScrollingGeometry(scrollingGeometry);</span>
<span class="line-modified">4035             scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);</span>
4036         }
4037     } else {
4038         newNodeID = attachScrollingNode(layer, ScrollingNodeType::Overflow, treeState);
4039         if (!newNodeID) {
4040             ASSERT_NOT_REACHED();
4041             return treeState.parentNodeID.valueOr(0);
4042         }
4043 
4044         if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">4045             scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer(), layer.backing()-&gt;scrollContainerLayer(), layer.backing()-&gt;scrolledContentsLayer() });</span>
4046 
4047         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4048             RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">4049             ScrollingCoordinator::ScrollingGeometry scrollingGeometry;</span>
<span class="line-modified">4050             computeOverflowScrollingGeometry(layer, scrollingAncestorLayer, scrollingGeometry);</span>
<span class="line-removed">4051             scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);</span>
4052         }
4053     }
4054 
4055     return newNodeID;
4056 }
4057 













































4058 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForFrameHostingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4059 {
4060     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4061 
4062     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
4063     if (!newNodeID) {
4064         ASSERT_NOT_REACHED();
4065         return treeState.parentNodeID.valueOr(0);
4066     }
4067 
4068     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4069         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4070 
4071     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4072         RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">4073         ScrollingCoordinator::ScrollingGeometry scrollingGeometry;</span>
<span class="line-modified">4074         computeFrameHostingGeometry(layer, scrollingAncestorLayer, scrollingGeometry);</span>
<span class="line-modified">4075         scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);</span>





























4076     }
4077 
4078     return newNodeID;
4079 }
4080 
4081 ScrollableArea* RenderLayerCompositor::scrollableAreaForScrollLayerID(ScrollingNodeID nodeID) const
4082 {
4083     if (!nodeID)
4084         return nullptr;
4085 
4086     return m_scrollingNodeToLayerMap.get(nodeID);
4087 }
4088 
4089 void RenderLayerCompositor::willRemoveScrollingLayerWithBacking(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4090 {
4091     if (scrollingCoordinator())
4092         return;
4093 
4094 #if PLATFORM(IOS_FAMILY)
4095     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
</pre>
<hr />
<pre>
4123 }
4124 
4125 ScrollingCoordinator* RenderLayerCompositor::scrollingCoordinator() const
4126 {
4127     return page().scrollingCoordinator();
4128 }
4129 
4130 GraphicsLayerFactory* RenderLayerCompositor::graphicsLayerFactory() const
4131 {
4132     return page().chrome().client().graphicsLayerFactory();
4133 }
4134 
4135 void RenderLayerCompositor::setLayerFlushThrottlingEnabled(bool enabled)
4136 {
4137     m_layerFlushThrottlingEnabled = enabled;
4138     if (m_layerFlushThrottlingEnabled)
4139         return;
4140     m_layerFlushTimer.stop();
4141     if (!m_hasPendingLayerFlush)
4142         return;
<span class="line-modified">4143     scheduleLayerFlushNow();</span>
4144 }
4145 
4146 void RenderLayerCompositor::disableLayerFlushThrottlingTemporarilyForInteraction()
4147 {
4148     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4149         return;
4150     m_layerFlushThrottlingTemporarilyDisabledForInteraction = true;
4151 }
4152 
4153 bool RenderLayerCompositor::isThrottlingLayerFlushes() const
4154 {
4155     if (!m_layerFlushThrottlingEnabled)
4156         return false;
4157     if (!m_layerFlushTimer.isActive())
4158         return false;
4159     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4160         return false;
4161     return true;
4162 }
4163 
</pre>
<hr />
<pre>
4166     m_layerFlushThrottlingTemporarilyDisabledForInteraction = false;
4167     m_layerFlushTimer.stop();
4168     if (!m_layerFlushThrottlingEnabled)
4169         return;
4170     m_layerFlushTimer.startOneShot(throttledLayerFlushDelay);
4171 }
4172 
4173 void RenderLayerCompositor::startInitialLayerFlushTimerIfNeeded()
4174 {
4175     if (!m_layerFlushThrottlingEnabled)
4176         return;
4177     if (m_layerFlushTimer.isActive())
4178         return;
4179     m_layerFlushTimer.startOneShot(throttledLayerFlushInitialDelay);
4180 }
4181 
4182 void RenderLayerCompositor::layerFlushTimerFired()
4183 {
4184     if (!m_hasPendingLayerFlush)
4185         return;
<span class="line-modified">4186     scheduleLayerFlushNow();</span>
4187 }
4188 
4189 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
4190 RefPtr&lt;DisplayRefreshMonitor&gt; RenderLayerCompositor::createDisplayRefreshMonitor(PlatformDisplayID displayID) const
4191 {
4192     if (auto monitor = page().chrome().client().createDisplayRefreshMonitor(displayID))
4193         return monitor;
4194 
4195     return DisplayRefreshMonitor::createDefaultDisplayRefreshMonitor(displayID);
4196 }
4197 #endif
4198 
4199 #if ENABLE(CSS_SCROLL_SNAP)
4200 void RenderLayerCompositor::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView) const
4201 {
4202     if (auto* coordinator = scrollingCoordinator())
4203         coordinator-&gt;updateScrollSnapPropertiesWithFrameView(frameView);
4204 }
4205 #endif
4206 
</pre>
<hr />
<pre>
4229     return ts;
4230 }
4231 
4232 #if PLATFORM(IOS_FAMILY)
4233 typedef HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt; LayerMap;
4234 typedef HashMap&lt;PlatformLayer*, PlatformLayer*&gt; StickyContainerMap;
4235 
4236 void LegacyWebKitScrollingLayerCoordinator::registerAllViewportConstrainedLayers(RenderLayerCompositor&amp; compositor)
4237 {
4238     if (!m_coordinateViewportConstrainedLayers)
4239         return;
4240 
4241     LayerMap layerMap;
4242     StickyContainerMap stickyContainerMap;
4243 
4244     for (auto* layer : m_viewportConstrainedLayers) {
4245         ASSERT(layer-&gt;isComposited());
4246 
4247         std::unique_ptr&lt;ViewportConstraints&gt; constraints;
4248         if (layer-&gt;renderer().isStickilyPositioned()) {
<span class="line-modified">4249             constraints = std::make_unique&lt;StickyPositionViewportConstraints&gt;(compositor.computeStickyViewportConstraints(*layer));</span>
4250             const RenderLayer* enclosingTouchScrollableLayer = nullptr;
4251             if (compositor.isAsyncScrollableStickyLayer(*layer, &amp;enclosingTouchScrollableLayer) &amp;&amp; enclosingTouchScrollableLayer) {
4252                 ASSERT(enclosingTouchScrollableLayer-&gt;isComposited());
4253                 // what
4254                 stickyContainerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), enclosingTouchScrollableLayer-&gt;backing()-&gt;scrollContainerLayer()-&gt;platformLayer());
4255             }
4256         } else if (layer-&gt;renderer().isFixedPositioned())
<span class="line-modified">4257             constraints = std::make_unique&lt;FixedPositionViewportConstraints&gt;(compositor.computeFixedViewportConstraints(*layer));</span>
4258         else
4259             continue;
4260 
4261         layerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), WTFMove(constraints));
4262     }
4263 
4264     m_chromeClient.updateViewportConstrainedLayers(layerMap, stickyContainerMap);
4265 }
4266 
4267 void LegacyWebKitScrollingLayerCoordinator::unregisterAllViewportConstrainedLayers()
4268 {
4269     if (!m_coordinateViewportConstrainedLayers)
4270         return;
4271 
4272     LayerMap layerMap;
4273     m_chromeClient.updateViewportConstrainedLayers(layerMap, { });
4274 }
4275 
<span class="line-removed">4276 static bool scrollbarHasDisplayNone(Scrollbar* scrollbar)</span>
<span class="line-removed">4277 {</span>
<span class="line-removed">4278     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())</span>
<span class="line-removed">4279         return false;</span>
<span class="line-removed">4280 </span>
<span class="line-removed">4281     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);</span>
<span class="line-removed">4282     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-removed">4283 }</span>
<span class="line-removed">4284 </span>
4285 void LegacyWebKitScrollingLayerCoordinator::updateScrollingLayer(RenderLayer&amp; layer)
4286 {
4287     auto* backing = layer.backing();
4288     ASSERT(backing);
4289 
<span class="line-modified">4290     bool allowHorizontalScrollbar = !scrollbarHasDisplayNone(layer.horizontalScrollbar());</span>
<span class="line-modified">4291     bool allowVerticalScrollbar = !scrollbarHasDisplayNone(layer.verticalScrollbar());</span>

4292     m_chromeClient.addOrUpdateScrollingLayer(layer.renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer(),
<span class="line-modified">4293         layer.scrollableContentsSize(), allowHorizontalScrollbar, allowVerticalScrollbar);</span>
4294 }
4295 
4296 void LegacyWebKitScrollingLayerCoordinator::registerAllScrollingLayers()
4297 {
4298     for (auto* layer : m_scrollingLayers)
4299         updateScrollingLayer(*layer);
4300 }
4301 
<span class="line-removed">4302 void LegacyWebKitScrollingLayerCoordinator::registerScrollingLayersNeedingUpdate()</span>
<span class="line-removed">4303 {</span>
<span class="line-removed">4304     for (auto* layer : m_scrollingLayersNeedingUpdate)</span>
<span class="line-removed">4305         updateScrollingLayer(*layer);</span>
<span class="line-removed">4306 </span>
<span class="line-removed">4307     m_scrollingLayersNeedingUpdate.clear();</span>
<span class="line-removed">4308 }</span>
<span class="line-removed">4309 </span>
4310 void LegacyWebKitScrollingLayerCoordinator::unregisterAllScrollingLayers()
4311 {
4312     for (auto* layer : m_scrollingLayers) {
4313         auto* backing = layer-&gt;backing();
4314         ASSERT(backing);
4315         m_chromeClient.removeScrollingLayer(layer-&gt;renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer());
4316     }
4317 }
4318 
4319 void LegacyWebKitScrollingLayerCoordinator::addScrollingLayer(RenderLayer&amp; layer)
4320 {
4321     m_scrollingLayers.add(&amp;layer);
<span class="line-removed">4322     m_scrollingLayersNeedingUpdate.add(&amp;layer);</span>
4323 }
4324 
4325 void LegacyWebKitScrollingLayerCoordinator::removeScrollingLayer(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4326 {
<span class="line-removed">4327     m_scrollingLayersNeedingUpdate.remove(&amp;layer);</span>
4328     if (m_scrollingLayers.remove(&amp;layer)) {
4329         auto* scrollContainerLayer = backing.scrollContainerLayer()-&gt;platformLayer();
4330         auto* scrolledContentsLayer = backing.scrolledContentsLayer()-&gt;platformLayer();
4331         m_chromeClient.removeScrollingLayer(layer.renderer().element(), scrollContainerLayer, scrolledContentsLayer);
4332     }
4333 }
4334 
4335 void LegacyWebKitScrollingLayerCoordinator::removeLayer(RenderLayer&amp; layer)
4336 {
4337     removeScrollingLayer(layer, *layer.backing());
4338 
4339     // We&#39;ll put the new set of layers to the client via registerAllViewportConstrainedLayers() at flush time.
4340     m_viewportConstrainedLayers.remove(&amp;layer);
4341 }
4342 
4343 void LegacyWebKitScrollingLayerCoordinator::addViewportConstrainedLayer(RenderLayer&amp; layer)
4344 {
4345     m_viewportConstrainedLayers.add(&amp;layer);
4346 }
4347 
4348 void LegacyWebKitScrollingLayerCoordinator::removeViewportConstrainedLayer(RenderLayer&amp; layer)
4349 {
4350     m_viewportConstrainedLayers.remove(&amp;layer);
4351 }
4352 
<span class="line-removed">4353 void LegacyWebKitScrollingLayerCoordinator::didChangePlatformLayerForLayer(RenderLayer&amp; layer)</span>
<span class="line-removed">4354 {</span>
<span class="line-removed">4355     if (m_scrollingLayers.contains(&amp;layer))</span>
<span class="line-removed">4356         m_scrollingLayersNeedingUpdate.add(&amp;layer);</span>
<span class="line-removed">4357 }</span>
<span class="line-removed">4358 </span>
4359 #endif
4360 
4361 } // namespace WebCore
4362 
4363 #if ENABLE(TREE_DEBUGGING)
4364 void showGraphicsLayerTreeForCompositor(WebCore::RenderLayerCompositor&amp; compositor)
4365 {
4366     showGraphicsLayerTree(compositor.rootGraphicsLayer());
4367 }
4368 #endif
</pre>
</td>
<td>
<hr />
<pre>
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerCompositor.h&quot;
  29 
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;ChromeClient.h&quot;
  35 #include &quot;DocumentTimeline.h&quot;
  36 #include &quot;Frame.h&quot;
  37 #include &quot;FrameView.h&quot;
<span class="line-added">  38 #include &quot;FullscreenManager.h&quot;</span>
  39 #include &quot;GraphicsLayer.h&quot;
  40 #include &quot;HTMLCanvasElement.h&quot;
  41 #include &quot;HTMLIFrameElement.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;HitTestResult.h&quot;
  44 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">  45 #include &quot;LayerAncestorClippingStack.h&quot;</span>
<span class="line-added">  46 #include &quot;LayerOverlapMap.h&quot;</span>
  47 #include &quot;Logging.h&quot;
  48 #include &quot;NodeList.h&quot;
  49 #include &quot;Page.h&quot;
  50 #include &quot;PageOverlayController.h&quot;
  51 #include &quot;RenderEmbeddedObject.h&quot;
  52 #include &quot;RenderFragmentedFlow.h&quot;
  53 #include &quot;RenderFullScreen.h&quot;
  54 #include &quot;RenderGeometryMap.h&quot;
  55 #include &quot;RenderIFrame.h&quot;
<span class="line-added">  56 #include &quot;RenderImage.h&quot;</span>
  57 #include &quot;RenderLayerBacking.h&quot;
  58 #include &quot;RenderReplica.h&quot;
  59 #include &quot;RenderVideo.h&quot;
  60 #include &quot;RenderView.h&quot;
  61 #include &quot;RuntimeEnabledFeatures.h&quot;
  62 #include &quot;ScrollingConstraints.h&quot;
  63 #include &quot;ScrollingCoordinator.h&quot;
  64 #include &quot;Settings.h&quot;
  65 #include &quot;TiledBacking.h&quot;
  66 #include &quot;TransformState.h&quot;
  67 #include &lt;wtf/HexNumber.h&gt;
  68 #include &lt;wtf/MemoryPressureHandler.h&gt;
  69 #include &lt;wtf/SetForScope.h&gt;
  70 #include &lt;wtf/text/CString.h&gt;
  71 #include &lt;wtf/text/StringBuilder.h&gt;
  72 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  73 #include &lt;wtf/text/TextStream.h&gt;
  74 
  75 #if PLATFORM(IOS_FAMILY)
  76 #include &quot;LegacyTileCache.h&quot;
</pre>
<hr />
<pre>
  98 
  99 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
 100 static const int canvasAreaThresholdRequiringCompositing = 50 * 100;
 101 #endif
 102 // During page loading delay layer flushes up to this many seconds to allow them coalesce, reducing workload.
 103 #if PLATFORM(IOS_FAMILY)
 104 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 105 static const Seconds throttledLayerFlushDelay { 1.5_s };
 106 #else
 107 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 108 static const Seconds throttledLayerFlushDelay { 500_ms };
 109 #endif
 110 
 111 using namespace HTMLNames;
 112 
 113 struct ScrollingTreeState {
 114     Optional&lt;ScrollingNodeID&gt; parentNodeID;
 115     size_t nextChildIndex { 0 };
 116 };
 117 
<span class="line-modified"> 118 struct RenderLayerCompositor::OverlapExtent {</span>
<span class="line-modified"> 119     LayoutRect bounds;</span>
<span class="line-modified"> 120     bool extentComputed { false };</span>
<span class="line-modified"> 121     bool hasTransformAnimation { false };</span>
<span class="line-modified"> 122     bool animationCausesExtentUncertainty { false };</span>
















 123 
<span class="line-modified"> 124     bool knownToBeHaveExtentUncertainty() const { return extentComputed &amp;&amp; animationCausesExtentUncertainty; }</span>







 125 };
 126 
<span class="line-modified"> 127 struct RenderLayerCompositor::CompositingState {</span>
<span class="line-modified"> 128     CompositingState(RenderLayer* compAncestor, bool testOverlap = true)</span>
<span class="line-modified"> 129         : compositingAncestor(compAncestor)</span>
<span class="line-modified"> 130         , testingOverlap(testOverlap)</span>

 131     {




 132     }
 133 
<span class="line-modified"> 134     CompositingState stateForPaintOrderChildren(RenderLayer&amp; layer) const</span>
 135     {
<span class="line-modified"> 136         UNUSED_PARAM(layer);</span>
<span class="line-modified"> 137         CompositingState childState(compositingAncestor);</span>
<span class="line-modified"> 138         if (layer.isStackingContext())</span>
<span class="line-modified"> 139             childState.stackingContextAncestor = &amp;layer;</span>
<span class="line-modified"> 140         else</span>
<span class="line-modified"> 141             childState.stackingContextAncestor = stackingContextAncestor;</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143         childState.backingSharingAncestor = backingSharingAncestor;</span>
<span class="line-added"> 144         childState.subtreeIsCompositing = false;</span>
<span class="line-added"> 145         childState.testingOverlap = testingOverlap;</span>
<span class="line-added"> 146         childState.fullPaintOrderTraversalRequired = fullPaintOrderTraversalRequired;</span>
<span class="line-added"> 147         childState.descendantsRequireCompositingUpdate = descendantsRequireCompositingUpdate;</span>
<span class="line-added"> 148         childState.ancestorHasTransformAnimation = ancestorHasTransformAnimation;</span>
<span class="line-added"> 149 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added"> 150         childState.hasNotIsolatedCompositedBlendingDescendants = false; // FIXME: should this only be reset for stacking contexts?</span>
<span class="line-added"> 151 #endif</span>
<span class="line-added"> 152 #if !LOG_DISABLED</span>
<span class="line-added"> 153         childState.depth = depth + 1;</span>
<span class="line-added"> 154 #endif</span>
<span class="line-added"> 155         return childState;</span>
 156     }
 157 
<span class="line-modified"> 158     void updateWithDescendantStateAndLayer(const CompositingState&amp; childState, const RenderLayer&amp; layer, const OverlapExtent&amp; layerExtent, bool isUnchangedSubtree = false)</span>
 159     {
<span class="line-modified"> 160         // Subsequent layers in the parent stacking context also need to composite.</span>
<span class="line-modified"> 161         subtreeIsCompositing |= childState.subtreeIsCompositing | layer.isComposited();</span>
<span class="line-added"> 162         if (!isUnchangedSubtree)</span>
<span class="line-added"> 163             fullPaintOrderTraversalRequired |= childState.fullPaintOrderTraversalRequired;</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165         // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.</span>
<span class="line-added"> 166         // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because</span>
<span class="line-added"> 167         // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.</span>
<span class="line-added"> 168         auto canReenableOverlapTesting = [&amp;layer]() {</span>
<span class="line-added"> 169             return layer.isComposited() &amp;&amp; RenderLayerCompositor::clipsCompositingDescendants(layer);</span>
<span class="line-added"> 170         };</span>
<span class="line-added"> 171         if ((!childState.testingOverlap &amp;&amp; !canReenableOverlapTesting()) || layerExtent.knownToBeHaveExtentUncertainty())</span>
<span class="line-added"> 172             testingOverlap = false;</span>
 173 
<span class="line-modified"> 174 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified"> 175         if ((layer.isComposited() &amp;&amp; layer.hasBlendMode()) || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))</span>
<span class="line-modified"> 176             hasNotIsolatedCompositedBlendingDescendants = true;</span>
<span class="line-added"> 177 #endif</span>
 178     }
 179 
<span class="line-modified"> 180     bool hasNonRootCompositedAncestor() const</span>
 181     {
<span class="line-modified"> 182         return compositingAncestor &amp;&amp; !compositingAncestor-&gt;isRenderViewLayer();</span>
 183     }
 184 
<span class="line-modified"> 185     RenderLayer* compositingAncestor;</span>
<span class="line-added"> 186     RenderLayer* backingSharingAncestor { nullptr };</span>
<span class="line-added"> 187     RenderLayer* stackingContextAncestor { nullptr };</span>
<span class="line-added"> 188     bool subtreeIsCompositing { false };</span>
<span class="line-added"> 189     bool testingOverlap { true };</span>
<span class="line-added"> 190     bool fullPaintOrderTraversalRequired { false };</span>
<span class="line-added"> 191     bool descendantsRequireCompositingUpdate { false };</span>
<span class="line-added"> 192     bool ancestorHasTransformAnimation { false };</span>
<span class="line-added"> 193 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added"> 194     bool hasNotIsolatedCompositedBlendingDescendants { false };</span>
<span class="line-added"> 195 #endif</span>
<span class="line-added"> 196 #if !LOG_DISABLED</span>
<span class="line-added"> 197     unsigned depth { 0 };</span>
<span class="line-added"> 198 #endif</span>
<span class="line-added"> 199 };</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201 class RenderLayerCompositor::BackingSharingState {</span>
<span class="line-added"> 202     WTF_MAKE_NONCOPYABLE(BackingSharingState);</span>
<span class="line-added"> 203 public:</span>
<span class="line-added"> 204     BackingSharingState() = default;</span>
<span class="line-added"> 205 </span>
<span class="line-added"> 206     RenderLayer* backingProviderCandidate() const { return m_backingProviderCandidate; };</span>
<span class="line-added"> 207 </span>
<span class="line-added"> 208     void appendSharingLayer(RenderLayer&amp; layer)</span>
 209     {
<span class="line-modified"> 210         ASSERT(m_backingProviderCandidate);</span>
<span class="line-modified"> 211         m_backingSharingLayers.append(makeWeakPtr(layer));</span>
 212     }
 213 
<span class="line-modified"> 214     void updateBeforeDescendantTraversal(RenderLayer&amp;, bool willBeComposited);</span>
<span class="line-modified"> 215     void updateAfterDescendantTraversal(RenderLayer&amp;, RenderLayer* stackingContextAncestor);</span>
 216 
 217 private:
<span class="line-modified"> 218     void layerWillBeComposited(RenderLayer&amp;);</span>








 219 
<span class="line-modified"> 220     void startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext);</span>
<span class="line-modified"> 221     void endBackingSharingSequence();</span>



 222 
<span class="line-modified"> 223     RenderLayer* m_backingProviderCandidate { nullptr };</span>
<span class="line-modified"> 224     RenderLayer* m_backingProviderStackingContext { nullptr };</span>
<span class="line-modified"> 225     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;</span>
<span class="line-modified"> 226 };</span>
 227 
<span class="line-modified"> 228 void RenderLayerCompositor::BackingSharingState::startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext)</span>
<span class="line-modified"> 229 {</span>
<span class="line-modified"> 230     ASSERT(!m_backingProviderCandidate);</span>
<span class="line-modified"> 231     ASSERT(m_backingSharingLayers.isEmpty());</span>



 232 
<span class="line-modified"> 233     m_backingProviderCandidate = &amp;candidateLayer;</span>
<span class="line-modified"> 234     m_backingProviderStackingContext = candidateStackingContext;</span>
<span class="line-modified"> 235 }</span>

 236 
<span class="line-modified"> 237 void RenderLayerCompositor::BackingSharingState::endBackingSharingSequence()</span>
<span class="line-modified"> 238 {</span>
<span class="line-modified"> 239     if (m_backingProviderCandidate) {</span>
<span class="line-modified"> 240         m_backingProviderCandidate-&gt;backing()-&gt;setBackingSharingLayers(WTFMove(m_backingSharingLayers));</span>
<span class="line-modified"> 241         m_backingSharingLayers.clear();</span>
 242     }
 243 
<span class="line-modified"> 244     m_backingProviderCandidate = nullptr;</span>
<span class="line-modified"> 245 }</span>
<span class="line-modified"> 246 </span>
<span class="line-modified"> 247 void RenderLayerCompositor::BackingSharingState::updateBeforeDescendantTraversal(RenderLayer&amp; layer, bool willBeComposited)</span>
<span class="line-modified"> 248 {</span>
<span class="line-modified"> 249     layer.setBackingProviderLayer(nullptr);</span>
<span class="line-modified"> 250 </span>
<span class="line-modified"> 251     // A layer that composites resets backing-sharing, since subsequent layers need to composite to overlap it.</span>
<span class="line-modified"> 252     if (willBeComposited) {</span>
<span class="line-modified"> 253         m_backingSharingLayers.removeAll(&amp;layer);</span>
<span class="line-modified"> 254         endBackingSharingSequence();</span>



 255     }
<span class="line-added"> 256 }</span>
 257 
<span class="line-modified"> 258 void RenderLayerCompositor::BackingSharingState::updateAfterDescendantTraversal(RenderLayer&amp; layer, RenderLayer* stackingContextAncestor)</span>
<span class="line-modified"> 259 {</span>
<span class="line-modified"> 260     if (layer.isComposited()) {</span>
<span class="line-modified"> 261         // If this layer is being composited, clean up sharing-related state.</span>
<span class="line-modified"> 262         layer.disconnectFromBackingProviderLayer();</span>
<span class="line-modified"> 263         m_backingSharingLayers.removeAll(&amp;layer);</span>
<span class="line-modified"> 264     }</span>






 265 
<span class="line-modified"> 266     if (m_backingProviderCandidate &amp;&amp; &amp;layer == m_backingProviderStackingContext) {</span>
<span class="line-modified"> 267         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;End of stacking context for backing provider &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot;, ending sharing sequence with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);</span>
<span class="line-modified"> 268         endBackingSharingSequence();</span>
<span class="line-modified"> 269     } else if (!m_backingProviderCandidate &amp;&amp; layer.isComposited()) {</span>
<span class="line-modified"> 270         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Post-descendant compositing of &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;, ending sharing sequence for &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot; with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);</span>
<span class="line-added"> 271         endBackingSharingSequence();</span>
<span class="line-added"> 272         startBackingSharingSequence(layer, stackingContextAncestor);</span>
<span class="line-added"> 273     }</span>
 274 
<span class="line-modified"> 275     if (&amp;layer != m_backingProviderCandidate &amp;&amp; layer.isComposited())</span>
<span class="line-modified"> 276         layer.backing()-&gt;clearBackingSharingLayers();</span>
<span class="line-added"> 277 }</span>
 278 
<span class="line-modified"> 279 #if !LOG_DISABLED || ENABLE(TREE_DEBUGGING)</span>
 280 static inline bool compositingLogEnabled()
 281 {
<span class="line-modified"> 282     return LogCompositing.state == WTFLogChannelState::On;</span>
<span class="line-added"> 283 }</span>
<span class="line-added"> 284 </span>
<span class="line-added"> 285 static inline bool layersLogEnabled()</span>
<span class="line-added"> 286 {</span>
<span class="line-added"> 287     return LogLayers.state == WTFLogChannelState::On;</span>
 288 }
 289 #endif
 290 
 291 RenderLayerCompositor::RenderLayerCompositor(RenderView&amp; renderView)
 292     : m_renderView(renderView)
 293     , m_updateCompositingLayersTimer(*this, &amp;RenderLayerCompositor::updateCompositingLayersTimerFired)
 294     , m_layerFlushTimer(*this, &amp;RenderLayerCompositor::layerFlushTimerFired)
 295 {
 296 #if PLATFORM(IOS_FAMILY)
 297     if (m_renderView.frameView().platformWidget())
<span class="line-modified"> 298         m_legacyScrollingLayerCoordinator = makeUnique&lt;LegacyWebKitScrollingLayerCoordinator&gt;(page().chrome().client(), isMainFrameCompositor());</span>
 299 #endif
 300 }
 301 
 302 RenderLayerCompositor::~RenderLayerCompositor()
 303 {
 304     // Take care that the owned GraphicsLayers are deleted first as their destructors may call back here.
<span class="line-modified"> 305     GraphicsLayer::unparentAndClear(m_rootContentsLayer);</span>
<span class="line-modified"> 306 </span>
<span class="line-added"> 307     GraphicsLayer::unparentAndClear(m_clipLayer);</span>
<span class="line-added"> 308     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);</span>
<span class="line-added"> 309     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);</span>
<span class="line-added"> 310 </span>
<span class="line-added"> 311     GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313     GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);</span>
<span class="line-added"> 314     GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);</span>
<span class="line-added"> 315     GraphicsLayer::unparentAndClear(m_layerForScrollCorner);</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317 #if ENABLE(RUBBER_BANDING)</span>
<span class="line-added"> 318     GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);</span>
<span class="line-added"> 319     GraphicsLayer::unparentAndClear(m_contentShadowLayer);</span>
<span class="line-added"> 320     GraphicsLayer::unparentAndClear(m_layerForTopOverhangArea);</span>
<span class="line-added"> 321     GraphicsLayer::unparentAndClear(m_layerForBottomOverhangArea);</span>
<span class="line-added"> 322     GraphicsLayer::unparentAndClear(m_layerForHeader);</span>
<span class="line-added"> 323     GraphicsLayer::unparentAndClear(m_layerForFooter);</span>
<span class="line-added"> 324 #endif</span>
<span class="line-added"> 325 </span>
 326     ASSERT(m_rootLayerAttachment == RootLayerUnattached);
 327 }
 328 
 329 void RenderLayerCompositor::enableCompositingMode(bool enable /* = true */)
 330 {
 331     if (enable != m_compositing) {
 332         m_compositing = enable;
 333 
 334         if (m_compositing) {
 335             ensureRootLayer();
 336             notifyIFramesOfCompositingChange();
 337         } else
 338             destroyRootLayer();
 339 
 340 
 341         m_renderView.layer()-&gt;setNeedsPostLayoutCompositingUpdate();
 342     }
 343 }
 344 
 345 void RenderLayerCompositor::cacheAcceleratedCompositingFlags()
</pre>
<hr />
<pre>
 441 }
 442 
 443 void RenderLayerCompositor::customPositionForVisibleRectComputation(const GraphicsLayer* graphicsLayer, FloatPoint&amp; position) const
 444 {
 445     if (graphicsLayer != m_scrolledContentsLayer.get())
 446         return;
 447 
 448     FloatPoint scrollPosition = -position;
 449 
 450     if (m_renderView.frameView().scrollBehaviorForFixedElements() == StickToDocumentBounds)
 451         scrollPosition = m_renderView.frameView().constrainScrollPositionForOverhang(roundedIntPoint(scrollPosition));
 452 
 453     position = -scrollPosition;
 454 }
 455 
 456 void RenderLayerCompositor::notifyFlushRequired(const GraphicsLayer* layer)
 457 {
 458     scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
 459 }
 460 






 461 void RenderLayerCompositor::scheduleLayerFlush(bool canThrottle)
 462 {
 463     ASSERT(!m_flushingLayers);
 464 
 465     if (canThrottle)
 466         startInitialLayerFlushTimerIfNeeded();
 467 
<span class="line-modified"> 468     if (canThrottle &amp;&amp; isThrottlingLayerFlushes())</span>
 469         m_hasPendingLayerFlush = true;
<span class="line-modified"> 470     else {</span>
<span class="line-added"> 471         m_hasPendingLayerFlush = false;</span>
<span class="line-added"> 472         page().renderingUpdateScheduler().scheduleRenderingUpdate();</span>
 473     }

 474 }
 475 
 476 FloatRect RenderLayerCompositor::visibleRectForLayerFlushing() const
 477 {
 478     const FrameView&amp; frameView = m_renderView.frameView();
 479 #if PLATFORM(IOS_FAMILY)
 480     return frameView.exposedContentRect();
 481 #else
 482     // Having a m_scrolledContentsLayer indicates that we&#39;re doing scrolling via GraphicsLayers.
 483     FloatRect visibleRect = m_scrolledContentsLayer ? FloatRect({ }, frameView.sizeForVisibleContent()) : frameView.visibleContentRect();
 484 
 485     if (frameView.viewExposedRect())
 486         visibleRect.intersect(frameView.viewExposedRect().value());
 487 
 488     return visibleRect;
 489 #endif
 490 }
 491 
 492 void RenderLayerCompositor::flushPendingLayerChanges(bool isFlushRoot)
 493 {
</pre>
<hr />
<pre>
 503         startLayerFlushTimerIfNeeded();
 504 #endif
 505         m_shouldFlushOnReattach = true;
 506         return;
 507     }
 508 
 509     auto&amp; frameView = m_renderView.frameView();
 510     AnimationUpdateBlock animationUpdateBlock(&amp;frameView.frame().animation());
 511 
 512     ASSERT(!m_flushingLayers);
 513     {
 514         SetForScope&lt;bool&gt; flushingLayersScope(m_flushingLayers, true);
 515 
 516         if (auto* rootLayer = rootGraphicsLayer()) {
 517             FloatRect visibleRect = visibleRectForLayerFlushing();
 518             LOG_WITH_STREAM(Compositing,  stream &lt;&lt; &quot;\nRenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; flushPendingLayerChanges (is root &quot; &lt;&lt; isFlushRoot &lt;&lt; &quot;) visible rect &quot; &lt;&lt; visibleRect);
 519             rootLayer-&gt;flushCompositingState(visibleRect);
 520         }
 521 
 522         ASSERT(m_flushingLayers);
<span class="line-added"> 523 </span>
<span class="line-added"> 524 #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-added"> 525         if (layersLogEnabled()) {</span>
<span class="line-added"> 526             LOG(Layers, &quot;RenderLayerCompositor::flushPendingLayerChanges&quot;);</span>
<span class="line-added"> 527             showGraphicsLayerTree(rootGraphicsLayer());</span>
<span class="line-added"> 528         }</span>
<span class="line-added"> 529 #endif</span>
 530     }
 531 
 532 #if PLATFORM(IOS_FAMILY)
 533     updateScrollCoordinatedLayersAfterFlushIncludingSubframes();
 534 
 535     if (isFlushRoot)
 536         page().chrome().client().didFlushCompositingLayers();
 537 #endif
 538 
 539     ++m_layerFlushCount;
 540     startLayerFlushTimerIfNeeded();
 541 }
 542 
 543 #if PLATFORM(IOS_FAMILY)
 544 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlushIncludingSubframes()
 545 {
 546     updateScrollCoordinatedLayersAfterFlush();
 547 
 548     auto&amp; frame = m_renderView.frameView().frame();
 549     for (Frame* subframe = frame.tree().firstChild(); subframe; subframe = subframe-&gt;tree().traverseNext(&amp;frame)) {
 550         auto* view = subframe-&gt;contentRenderer();
 551         if (!view)
 552             continue;
 553 
 554         view-&gt;compositor().updateScrollCoordinatedLayersAfterFlush();
 555     }
 556 }
 557 
 558 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlush()
 559 {
 560     if (m_legacyScrollingLayerCoordinator) {
 561         m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
<span class="line-modified"> 562         m_legacyScrollingLayerCoordinator-&gt;registerAllScrollingLayers();</span>
 563     }
 564 }
 565 #endif
 566 
 567 void RenderLayerCompositor::didChangePlatformLayerForLayer(RenderLayer&amp; layer, const GraphicsLayer*)
 568 {





 569     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
 570     if (!scrollingCoordinator)
 571         return;
 572 
 573     auto* backing = layer.backing();
<span class="line-modified"> 574     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))</span>
<span class="line-modified"> 575         updateScrollingNodeLayers(nodeID, layer, *scrollingCoordinator);</span>
 576 
<span class="line-modified"> 577     if (auto* clippingStack = layer.backing()-&gt;ancestorClippingStack())</span>
<span class="line-modified"> 578         clippingStack-&gt;updateScrollingNodeLayers(*scrollingCoordinator);</span>





 579 
<span class="line-modified"> 580     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))</span>
<span class="line-modified"> 581         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });</span>
 582 
 583     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 584         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
<span class="line-added"> 585 </span>
<span class="line-added"> 586     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Positioning))</span>
<span class="line-added"> 587         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });</span>
 588 }
 589 
 590 void RenderLayerCompositor::didPaintBacking(RenderLayerBacking*)
 591 {
 592     auto&amp; frameView = m_renderView.frameView();
 593     frameView.setLastPaintTime(MonotonicTime::now());
 594     if (frameView.milestonesPendingPaint())
 595         frameView.firePaintRelatedMilestonesIfNeeded();
 596 }
 597 
 598 void RenderLayerCompositor::didChangeVisibleRect()
 599 {
 600     auto* rootLayer = rootGraphicsLayer();
 601     if (!rootLayer)
 602         return;
 603 
 604     FloatRect visibleRect = visibleRectForLayerFlushing();
 605     bool requiresFlush = rootLayer-&gt;visibleRectChangeRequiresFlush(visibleRect);
 606     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor::didChangeVisibleRect &quot; &lt;&lt; visibleRect &lt;&lt; &quot; requiresFlush &quot; &lt;&lt; requiresFlush);
 607     if (requiresFlush)
<span class="line-modified"> 608         scheduleLayerFlush();</span>
 609 }
 610 
 611 void RenderLayerCompositor::notifyFlushBeforeDisplayRefresh(const GraphicsLayer*)
 612 {
 613     if (!m_layerUpdater) {
 614         PlatformDisplayID displayID = page().chrome().displayID();
<span class="line-modified"> 615         m_layerUpdater = makeUnique&lt;GraphicsLayerUpdater&gt;(*this, displayID);</span>
 616     }
 617 
 618     m_layerUpdater-&gt;scheduleUpdate();
 619 }
 620 
 621 void RenderLayerCompositor::flushLayersSoon(GraphicsLayerUpdater&amp;)
 622 {
 623     scheduleLayerFlush(true);
 624 }
 625 
 626 void RenderLayerCompositor::layerTiledBackingUsageChanged(const GraphicsLayer* graphicsLayer, bool usingTiledBacking)
 627 {
 628     if (usingTiledBacking) {
 629         ++m_layersWithTiledBackingCount;
 630         graphicsLayer-&gt;tiledBacking()-&gt;setIsInWindow(page().isInWindow());
 631     } else {
 632         ASSERT(m_layersWithTiledBackingCount &gt; 0);
 633         --m_layersWithTiledBackingCount;
 634     }
 635 }
</pre>
<hr />
<pre>
 674         return frameHostingNodeID;
 675 
 676     return { };
 677 }
 678 
 679 // Returns true on a successful update.
 680 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 681 {
 682     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
 683 
 684 #if ENABLE(TREE_DEBUGGING)
 685     if (compositingLogEnabled())
 686         showPaintOrderTree(m_renderView.layer());
 687 #endif
 688 
 689     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
 690         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 691 
 692     m_updateCompositingLayersTimer.stop();
 693 
<span class="line-modified"> 694     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache</span>
<span class="line-added"> 695         || m_renderView.document().pageCacheState() == Document::AboutToEnterPageCache);</span>
 696 
 697     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
 698     if (!m_renderView.document().visualUpdatesAllowed())
 699         return false;
 700 
 701     // Avoid updating the layers with old values. Compositing layers will be updated after the layout is finished.
 702     // This happens when m_updateCompositingLayersTimer fires before layout is updated.
 703     if (m_renderView.needsLayout()) {
 704         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; - m_renderView.needsLayout, bailing &quot;);
 705         return false;
 706     }
 707 
 708     if (!m_compositing &amp;&amp; (m_forceCompositingMode || (isMainFrameCompositor() &amp;&amp; page().pageOverlayController().overlayCount())))
 709         enableCompositingMode(true);
 710 
 711     bool isPageScroll = !updateRoot || updateRoot == &amp;rootRenderLayer();
 712     updateRoot = &amp;rootRenderLayer();
 713 
 714     if (updateType == CompositingUpdateType::OnScroll || updateType == CompositingUpdateType::OnCompositedScroll) {
 715         // We only get here if we didn&#39;t scroll on the scrolling thread, so this update needs to re-position viewport-constrained layers.
 716         if (m_renderView.settings().acceleratedCompositingForFixedPositionEnabled() &amp;&amp; isPageScroll) {
 717             if (auto* viewportConstrainedObjects = m_renderView.frameView().viewportConstrainedObjects()) {
 718                 for (auto* renderer : *viewportConstrainedObjects) {
 719                     if (auto* layer = renderer-&gt;layer())
 720                         layer-&gt;setNeedsCompositingGeometryUpdate();
 721                 }
 722             }
 723         }
 724 
 725         // Scrolling can affect overlap. FIXME: avoid for page scrolling.
 726         updateRoot-&gt;setDescendantsNeedCompositingRequirementsTraversal();
 727     }
 728 
<span class="line-added"> 729     if (updateType == CompositingUpdateType::AfterLayout) {</span>
<span class="line-added"> 730         // Ensure that post-layout updates push new scroll position and viewport rects onto the root node.</span>
<span class="line-added"> 731         rootRenderLayer().setNeedsScrollingTreeUpdate();</span>
<span class="line-added"> 732     }</span>
<span class="line-added"> 733 </span>
 734     if (!updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !m_compositing) {
 735         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; no compositing work to do&quot;);
 736         return true;
 737     }
 738 
 739     if (!updateRoot-&gt;needsAnyCompositingTraversal()) {
 740         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; updateRoot has no dirty child and doesn&#39;t need update&quot;);
 741         return true;
 742     }
 743 
 744     ++m_compositingUpdateCount;
 745 
 746     AnimationUpdateBlock animationUpdateBlock(&amp;m_renderView.frameView().frame().animation());
 747 
 748     SetForScope&lt;bool&gt; postLayoutChange(m_inPostLayoutUpdate, true);
 749 
 750 #if !LOG_DISABLED
 751     MonotonicTime startTime;
 752     if (compositingLogEnabled()) {
 753         ++m_rootLayerUpdateCount;
 754         startTime = MonotonicTime::now();
 755     }
 756 
 757     if (compositingLogEnabled()) {
 758         m_obligateCompositedLayerCount = 0;
 759         m_secondaryCompositedLayerCount = 0;
 760         m_obligatoryBackingStoreBytes = 0;
 761         m_secondaryBackingStoreBytes = 0;
 762 
 763         auto&amp; frame = m_renderView.frameView().frame();
 764         bool isMainFrame = isMainFrameCompositor();
 765         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;\nUpdate &quot; &lt;&lt; m_rootLayerUpdateCount &lt;&lt; &quot; of &quot; &lt;&lt; (isMainFrame ? &quot;main frame&quot; : frame.tree().uniqueName().string().utf8().data()) &lt;&lt; &quot; - compositing policy is &quot; &lt;&lt; m_compositingPolicy);
 766     }
 767 #endif
 768 
 769     // FIXME: optimize root-only update.
 770     if (updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() || updateRoot-&gt;needsCompositingRequirementsTraversal()) {
<span class="line-added"> 771         auto&amp; rootLayer = rootRenderLayer();</span>
 772         CompositingState compositingState(updateRoot);
<span class="line-modified"> 773         BackingSharingState backingSharingState;</span>
<span class="line-added"> 774         LayerOverlapMap overlapMap(rootLayer);</span>
 775 
 776         bool descendantHas3DTransform = false;
<span class="line-modified"> 777         computeCompositingRequirements(nullptr, rootLayer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);</span>
 778     }
 779 
 780     LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
 781 #if ENABLE(TREE_DEBUGGING)
 782     if (compositingLogEnabled())
 783         showPaintOrderTree(m_renderView.layer());
 784 #endif
 785 
 786     if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
 787         ScrollingTreeState scrollingTreeState = { 0, 0 };
 788         if (!m_renderView.frame().isMainFrame())
 789             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 790 
 791         Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
 792         updateBackingAndHierarchy(*updateRoot, childList, scrollingTreeState);
 793 
 794         // Host the document layer in the RenderView&#39;s root layer.
 795         appendDocumentOverlayLayers(childList);
 796         // Even when childList is empty, don&#39;t drop out of compositing mode if there are
 797         // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
</pre>
<hr />
<pre>
 802     }
 803 
 804 #if !LOG_DISABLED
 805     if (compositingLogEnabled()) {
 806         MonotonicTime endTime = MonotonicTime::now();
 807         LOG(Compositing, &quot;Total layers   primary   secondary   obligatory backing (KB)   secondary backing(KB)   total backing (KB)  update time (ms)\n&quot;);
 808 
 809         LOG(Compositing, &quot;%8d %11d %9d %20.2f %22.2f %22.2f %18.2f\n&quot;,
 810             m_obligateCompositedLayerCount + m_secondaryCompositedLayerCount, m_obligateCompositedLayerCount,
 811             m_secondaryCompositedLayerCount, m_obligatoryBackingStoreBytes / 1024, m_secondaryBackingStoreBytes / 1024, (m_obligatoryBackingStoreBytes + m_secondaryBackingStoreBytes) / 1024, (endTime - startTime).milliseconds());
 812     }
 813 #endif
 814 
 815     // FIXME: Only do if dirty.
 816     updateRootLayerPosition();
 817 
 818 #if ENABLE(TREE_DEBUGGING)
 819     if (compositingLogEnabled()) {
 820         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - post&quot;);
 821         showPaintOrderTree(m_renderView.layer());


 822     }
 823 #endif
 824 
 825     InspectorInstrumentation::layerTreeDidChange(&amp;page());
 826 
 827     return true;
 828 }
 829 
<span class="line-modified"> 830 static bool backingProviderLayerCanIncludeLayer(const RenderLayer&amp; sharedLayer, const RenderLayer&amp; layer)</span>
 831 {
<span class="line-modified"> 832     // Disable sharing when painting shared layers doesn&#39;t work correctly.</span>
<span class="line-modified"> 833     if (layer.hasReflection())</span>
<span class="line-added"> 834         return false;</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836     return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);</span>
<span class="line-added"> 837 }</span>
<span class="line-added"> 838 </span>
<span class="line-added"> 839 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)</span>
<span class="line-added"> 840 {</span>
<span class="line-added"> 841     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()</span>
<span class="line-added"> 842         &amp;&amp; !layer.needsCompositingRequirementsTraversal()</span>
<span class="line-added"> 843         &amp;&amp; !compositingState.fullPaintOrderTraversalRequired</span>
<span class="line-added"> 844         &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {</span>
<span class="line-added"> 845         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);</span>
 846         return;
 847     }
 848 
<span class="line-modified"> 849     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; computeCompositingRequirements (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);</span>


 850 
 851     // FIXME: maybe we can avoid updating all remaining layers in paint order.
 852     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
 853     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 854 
 855     layer.updateDescendantDependentFlags();
 856     layer.updateLayerListsIfNeeded();
 857 
 858     layer.setHasCompositingDescendant(false);
 859 
 860     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
 861     RequiresCompositingData queryData;
 862     bool willBeComposited = layer.isComposited();
<span class="line-added"> 863     bool becameCompositedAfterDescendantTraversal = false;</span>
<span class="line-added"> 864     IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None;</span>
<span class="line-added"> 865 </span>
 866     if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
<span class="line-modified"> 867         layer.setIndirectCompositingReason(IndirectCompositingReason::None);</span>
 868         willBeComposited = needsToBeComposited(layer, queryData);
 869     }
 870 
<span class="line-added"> 871     bool layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added"> 872     if (!willBeComposited &amp;&amp; compositingState.subtreeIsCompositing &amp;&amp; backingSharingState.backingProviderCandidate() &amp;&amp; canBeComposited(layer) &amp;&amp; backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer)) {</span>
<span class="line-added"> 873         backingSharingState.appendSharingLayer(layer);</span>
<span class="line-added"> 874         LOG(Compositing, &quot; layer %p can share with %p&quot;, &amp;layer, backingSharingState.backingProviderCandidate());</span>
<span class="line-added"> 875         compositingReason = IndirectCompositingReason::None;</span>
<span class="line-added"> 876         layerPaintsIntoProvidedBacking = true;</span>
<span class="line-added"> 877     }</span>
<span class="line-added"> 878 </span>
 879     compositingState.fullPaintOrderTraversalRequired |= layer.subsequentLayersNeedCompositingRequirementsTraversal();
 880 
 881     OverlapExtent layerExtent;
 882     // Use the fact that we&#39;re composited as a hint to check for an animating transform.
 883     // FIXME: Maybe needsToBeComposited() should return a bitmask of reasons, to avoid the need to recompute things.
 884     if (willBeComposited &amp;&amp; !layer.isRenderViewLayer())
 885         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
 886 
 887     bool respectTransforms = !layerExtent.hasTransformAnimation;
 888     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
 889 


 890     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
<span class="line-modified"> 891     if (!willBeComposited &amp;&amp; !layerPaintsIntoProvidedBacking &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap) {</span>

 892         // If we&#39;re testing for overlap, we only need to composite if we overlap something that is already composited.
<span class="line-modified"> 893         if (layerOverlaps(overlapMap, layer, layerExtent))</span>
<span class="line-added"> 894             compositingReason = IndirectCompositingReason::Overlap;</span>
<span class="line-added"> 895         else</span>
<span class="line-added"> 896             compositingReason = IndirectCompositingReason::None;</span>
 897     }
 898 
 899 #if ENABLE(VIDEO)
 900     // Video is special. It&#39;s the only RenderLayer type that can both have
 901     // RenderLayer children and whose children can&#39;t use its backing to render
 902     // into. These children (the controls) always need to be promoted into their
 903     // own layers to draw on top of the accelerated video.
 904     if (compositingState.compositingAncestor &amp;&amp; compositingState.compositingAncestor-&gt;renderer().isVideo())
<span class="line-modified"> 905         compositingReason = IndirectCompositingReason::Overlap;</span>
 906 #endif
 907 
<span class="line-modified"> 908     if (compositingReason != IndirectCompositingReason::None)</span>
 909         layer.setIndirectCompositingReason(compositingReason);
 910 
 911     // Check if the computed indirect reason will force the layer to become composited.
<span class="line-modified"> 912     if (!willBeComposited &amp;&amp; layer.mustCompositeForIndirectReasons() &amp;&amp; canBeComposited(layer)) {</span>
<span class="line-added"> 913         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; compositing for indirect reason &quot; &lt;&lt; layer.indirectCompositingReason() &lt;&lt; &quot; (was sharing: &quot; &lt;&lt; layerPaintsIntoProvidedBacking &lt;&lt; &quot;)&quot;);</span>
 914         willBeComposited = true;
<span class="line-added"> 915         layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added"> 916     }</span>
 917 
 918     // The children of this layer don&#39;t need to composite, unless there is
 919     // a compositing layer among them, so start by inheriting the compositing
 920     // ancestor with subtreeIsCompositing set to false.
<span class="line-modified"> 921     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);</span>
<span class="line-modified"> 922     bool didPushOverlapContainer = false;</span>



 923 
<span class="line-modified"> 924     auto layerWillComposite = [&amp;] {</span>






 925         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
 926         // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified"> 927         currentState.testingOverlap = true;</span>
<span class="line-added"> 928         // This layer now acts as the ancestor for kids.</span>
<span class="line-added"> 929         currentState.compositingAncestor = &amp;layer;</span>
<span class="line-added"> 930         // Compositing turns off backing sharing.</span>
<span class="line-added"> 931         currentState.backingSharingAncestor = nullptr;</span>
<span class="line-added"> 932 </span>
<span class="line-added"> 933         if (layerPaintsIntoProvidedBacking) {</span>
<span class="line-added"> 934             layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added"> 935             // layerPaintsIntoProvidedBacking was only true for layers that would otherwise composite because of overlap. If we can</span>
<span class="line-added"> 936             // no longer share, put this this indirect reason back on the layer so that requiresOwnBackingStore() sees it.</span>
<span class="line-added"> 937             layer.setIndirectCompositingReason(IndirectCompositingReason::Overlap);</span>
<span class="line-added"> 938             LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; was sharing now will composite&quot;);</span>
<span class="line-added"> 939         } else {</span>
<span class="line-added"> 940             overlapMap.pushCompositingContainer();</span>
<span class="line-added"> 941             didPushOverlapContainer = true;</span>
<span class="line-added"> 942             LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);</span>
<span class="line-added"> 943         }</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945         willBeComposited = true;</span>
<span class="line-added"> 946     };</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948     auto layerWillCompositePostDescendants = [&amp;] {</span>
<span class="line-added"> 949         layerWillComposite();</span>
<span class="line-added"> 950         currentState.subtreeIsCompositing = true;</span>
<span class="line-added"> 951         becameCompositedAfterDescendantTraversal = true;</span>
<span class="line-added"> 952     };</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954     if (willBeComposited) {</span>
<span class="line-added"> 955         layerWillComposite();</span>
 956 
 957         computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified"> 958         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
 959         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
 960         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
<span class="line-added"> 961     } else if (layerPaintsIntoProvidedBacking) {</span>
<span class="line-added"> 962         currentState.backingSharingAncestor = &amp;layer;</span>
<span class="line-added"> 963         overlapMap.pushCompositingContainer();</span>
<span class="line-added"> 964         didPushOverlapContainer = true;</span>
<span class="line-added"> 965         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);</span>
 966     }
 967 
<span class="line-added"> 968     backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);</span>
<span class="line-added"> 969 </span>
 970 #if !ASSERT_DISABLED
 971     LayerListMutationDetector mutationChecker(layer);
 972 #endif
 973 
 974     bool anyDescendantHas3DTransform = false;
<span class="line-added"> 975     bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();</span>
 976 
 977     for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified"> 978         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
 979 
 980         // If we have to make a layer for this child, make one now so we can have a contents layer
 981         // (since we need to ensure that the -ve z-order child renders underneath our contents).
<span class="line-modified"> 982         if (!willBeComposited &amp;&amp; currentState.subtreeIsCompositing) {</span>
<span class="line-modified"> 983             layer.setIndirectCompositingReason(IndirectCompositingReason::BackgroundLayer);</span>
<span class="line-modified"> 984             layerWillComposite();</span>






 985         }
 986     }
 987 
 988     for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified"> 989         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
 990 
 991     for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified"> 992         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
<span class="line-added"> 993 </span>
<span class="line-added"> 994     // Set the flag to say that this layer has compositing children.</span>
<span class="line-added"> 995     layer.setHasCompositingDescendant(currentState.subtreeIsCompositing);</span>
 996 
 997     // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
 998     if (layer.isRenderViewLayer()) {
 999         if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
1000             willBeComposited = true;
1001     }
1002 








1003 #if ENABLE(CSS_COMPOSITING)
<span class="line-modified">1004     bool isolatedCompositedBlending = layer.isolatesCompositedBlending();</span>
<span class="line-added">1005     layer.setHasNotIsolatedCompositedBlendingDescendants(currentState.hasNotIsolatedCompositedBlendingDescendants);</span>
<span class="line-added">1006     if (layer.isolatesCompositedBlending() != isolatedCompositedBlending) {</span>
<span class="line-added">1007         // isolatedCompositedBlending affects the result of clippedByAncestor().</span>
<span class="line-added">1008         layer.setChildrenNeedCompositingGeometryUpdate();</span>
<span class="line-added">1009     }</span>
<span class="line-added">1010 </span>
1011     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
1012 #endif
1013     // Now check for reasons to become composited that depend on the state of descendant layers.
<span class="line-modified">1014     IndirectCompositingReason indirectCompositingReason;</span>
1015     if (!willBeComposited &amp;&amp; canBeComposited(layer)
<span class="line-modified">1016         &amp;&amp; requiresCompositingForIndirectReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking, indirectCompositingReason)) {</span>
1017         layer.setIndirectCompositingReason(indirectCompositingReason);
<span class="line-modified">1018         layerWillCompositePostDescendants();</span>



1019     }
1020 
1021     if (layer.reflectionLayer()) {
1022         // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
<span class="line-modified">1023         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);</span>
1024     }
1025 
<span class="line-modified">1026     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that now.</span>







1027     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);
<span class="line-modified">1028     if (isCompositedClippingLayer &amp; !willBeComposited)</span>
<span class="line-modified">1029         layerWillCompositePostDescendants();</span>






















1030 
1031     // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
1032     // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
1033     // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
1034     RequiresCompositingData rootLayerQueryData;
<span class="line-modified">1035     if (layer.isRenderViewLayer() &amp;&amp; !currentState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {</span>
1036         // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
1037 #if !PLATFORM(IOS_FAMILY)
1038         enableCompositingMode(false);
1039         willBeComposited = false;
1040 #endif
1041     }
1042 
1043     ASSERT(willBeComposited == needsToBeComposited(layer, queryData));
1044 
1045     // Create or destroy backing here. However, we can&#39;t update geometry because layers above us may become composited
1046     // during post-order traversal (e.g. for clipping).
1047     if (updateBacking(layer, queryData, CompositingChangeRepaintNow, willBeComposited ? BackingRequired::Yes : BackingRequired::No)) {
1048         layer.setNeedsCompositingLayerConnection();
1049         // Child layers need to get a geometry update to recompute their position.
1050         layer.setChildrenNeedCompositingGeometryUpdate();
1051         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
1052         layer.setNeedsCompositingGeometryUpdateOnAncestors();
1053     }
1054 
<span class="line-added">1055     // Update layer state bits.</span>
1056     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))
1057         layer.setNeedsCompositingLayerConnection();
1058 


1059     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
1060     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
1061         layer.setChildrenNeedCompositingGeometryUpdate();
1062         layer.setNeedsCompositingLayerConnection();
1063     }
1064 




1065     layer.clearCompositingRequirementsTraversalState();
1066 
<span class="line-added">1067     // Compute state passed to the caller.</span>
<span class="line-added">1068     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>
<span class="line-added">1069     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent);</span>
<span class="line-added">1070     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);</span>
<span class="line-added">1071 </span>
<span class="line-added">1072     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;</span>
<span class="line-added">1073     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap, becameCompositedAfterDescendantTraversal &amp;&amp; !descendantsAddedToOverlap);</span>
<span class="line-added">1074 </span>
<span class="line-added">1075     if (layer.isComposited())</span>
<span class="line-added">1076         layer.backing()-&gt;updateAllowsBackingStoreDetaching(layerExtent.bounds);</span>
<span class="line-added">1077 </span>
1078     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
<span class="line-added">1079 </span>
<span class="line-added">1080     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; &quot; computeCompositingRequirements - willBeComposited &quot; &lt;&lt; willBeComposited &lt;&lt; &quot; (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);</span>
1081 }
1082 
1083 // We have to traverse unchanged layers to fill in the overlap map.
<span class="line-modified">1084 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)</span>
1085 {
1086     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
1087     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
1088     ASSERT(!layer.needsCompositingRequirementsTraversal());
1089 
<span class="line-modified">1090     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; traverseUnchangedSubtree&quot;);</span>


1091 
1092     layer.updateDescendantDependentFlags();
1093     layer.updateLayerListsIfNeeded();
1094 
1095     bool layerIsComposited = layer.isComposited();
<span class="line-added">1096     bool layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added">1097     bool didPushOverlapContainer = false;</span>
1098 
1099     OverlapExtent layerExtent;
1100     if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
1101         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
1102 
1103     bool respectTransforms = !layerExtent.hasTransformAnimation;
1104     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
1105 
1106     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
1107     if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
1108         computeExtent(overlapMap, layer, layerExtent);
1109 
<span class="line-modified">1110     if (layer.paintsIntoProvidedBacking()) {</span>
<span class="line-modified">1111         ASSERT(backingSharingState.backingProviderCandidate());</span>
<span class="line-modified">1112         ASSERT(backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer));</span>
<span class="line-modified">1113         backingSharingState.appendSharingLayer(layer);</span>
<span class="line-modified">1114         layerPaintsIntoProvidedBacking = true;</span>
<span class="line-added">1115     }</span>
1116 
<span class="line-modified">1117     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);</span>




1118 
<span class="line-modified">1119     if (layerIsComposited) {</span>
1120         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
1121         // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified">1122         currentState.testingOverlap = true;</span>
<span class="line-added">1123         // This layer now acts as the ancestor for kids.</span>
<span class="line-added">1124         currentState.compositingAncestor = &amp;layer;</span>
<span class="line-added">1125         currentState.backingSharingAncestor = nullptr;</span>
<span class="line-added">1126         overlapMap.pushCompositingContainer();</span>
<span class="line-added">1127         didPushOverlapContainer = true;</span>
<span class="line-added">1128         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);</span>
1129 
1130         computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified">1131         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
1132         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
1133         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
<span class="line-added">1134     } else if (layerPaintsIntoProvidedBacking) {</span>
<span class="line-added">1135         overlapMap.pushCompositingContainer();</span>
<span class="line-added">1136         currentState.backingSharingAncestor = &amp;layer;</span>
<span class="line-added">1137         didPushOverlapContainer = true;</span>
<span class="line-added">1138         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);</span>
1139     }
1140 
<span class="line-added">1141     backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);</span>
<span class="line-added">1142 </span>
1143 #if !ASSERT_DISABLED
1144     LayerListMutationDetector mutationChecker(layer);
1145 #endif
1146 
1147     bool anyDescendantHas3DTransform = false;
1148 
1149     for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified">1150         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
<span class="line-modified">1151         if (currentState.subtreeIsCompositing)</span>
1152             ASSERT(layerIsComposited);
1153     }
1154 
1155     for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified">1156         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
1157 
1158     for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified">1159         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>












1160 
1161     // Set the flag to say that this layer has compositing children.
<span class="line-modified">1162     ASSERT(layer.hasCompositingDescendant() == currentState.subtreeIsCompositing);</span>
<span class="line-modified">1163     ASSERT_IMPLIES(canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer), layerIsComposited);</span>


1164 
<span class="line-modified">1165     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>







1166 
<span class="line-modified">1167     ASSERT(!currentState.fullPaintOrderTraversalRequired);</span>
<span class="line-modified">1168     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent, true);</span>
<span class="line-modified">1169     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);</span>


1170 
<span class="line-modified">1171     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;</span>
<span class="line-modified">1172     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap);</span>
1173 
<span class="line-modified">1174     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
1175 
1176     ASSERT(!layer.needsCompositingRequirementsTraversal());


1177 }
1178 
1179 void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)
1180 {
1181     layer.updateDescendantDependentFlags();
1182     layer.updateLayerListsIfNeeded();
1183 
1184     bool layerNeedsUpdate = !updateLevel.isEmpty();
1185     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
1186         updateLevel.add(UpdateLevel::AllDescendants);
1187 
1188     ScrollingTreeState stateForDescendants = scrollingTreeState;
1189 
1190     auto* layerBacking = layer.backing();
1191     if (layerBacking) {
1192         updateLevel.remove(UpdateLevel::CompositedChildren);
1193 
1194         // We updated the composited bounds in RenderLayerBacking::updateAfterLayout(), but it may have changed
1195         // based on which descendants are now composited.
1196         if (layerBacking-&gt;updateCompositedBounds()) {
1197             layer.setNeedsCompositingGeometryUpdate();
1198             // Our geometry can affect descendants.
1199             updateLevel.add(UpdateLevel::CompositedChildren);
1200         }
1201 
1202         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
1203             if (layerBacking-&gt;updateConfiguration()) {
1204                 layerNeedsUpdate = true; // We also need to update geometry.
1205                 layer.setNeedsCompositingLayerConnection();
1206             }
1207 
1208             layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1209         }
1210 
1211         OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
<span class="line-modified">1212         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {</span>
1213             layerBacking-&gt;updateGeometry();
1214             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
<span class="line-modified">1215         } else if (layer.needsScrollingTreeUpdate())</span>
<span class="line-added">1216             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);</span>
<span class="line-added">1217 </span>
<span class="line-added">1218         // This needs to happen after any geometry update.</span>
<span class="line-added">1219         // FIXME: Use separate bit for event region invalidation.</span>
<span class="line-added">1220         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate())</span>
<span class="line-added">1221             layerBacking-&gt;updateEventRegion();</span>
1222 
1223         if (auto* reflection = layer.reflectionLayer()) {
1224             if (auto* reflectionBacking = reflection-&gt;backing()) {
1225                 reflectionBacking-&gt;updateCompositedBounds();
1226                 reflectionBacking-&gt;updateGeometry();
1227                 reflectionBacking-&gt;updateAfterDescendants();
1228             }
1229         }
1230 
1231         if (!layer.parent())
1232             updateRootLayerPosition();
1233 
1234         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
1235         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
<span class="line-modified">1236         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, scrollingNodeChanges);</span>
1237         stateForDescendants.nextChildIndex = 0;
1238 
1239 #if !LOG_DISABLED
1240         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);
1241 #else
1242         UNUSED_PARAM(depth);
1243 #endif
1244     }
1245 
1246     if (layer.childrenNeedCompositingGeometryUpdate())
1247         updateLevel.add(UpdateLevel::CompositedChildren);
1248 
1249     // If this layer has backing, then we are collecting its children, otherwise appending
1250     // to the compositing child list of an enclosing layer.
1251     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; layerChildren;
1252     auto&amp; childList = layerBacking ? layerChildren : childLayersOfEnclosingLayer;
1253 
1254     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
1255         || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
1256 
1257     bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
1258 
1259 #if !ASSERT_DISABLED
1260     LayerListMutationDetector mutationChecker(layer);
1261 #endif
1262 
<span class="line-modified">1263     auto appendForegroundLayerIfNecessary = [&amp;] {</span>
1264         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
1265         if (layer.negativeZOrderLayers().size()) {
1266             if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
1267                 childList.append(*layerBacking-&gt;foregroundLayer());
1268         }
1269     };
1270 
1271     if (requireDescendantTraversal) {
1272         for (auto* renderLayer : layer.negativeZOrderLayers())
1273             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1274 
1275         appendForegroundLayerIfNecessary();
1276 
1277         for (auto* renderLayer : layer.normalFlowLayers())
1278             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1279 
1280         for (auto* renderLayer : layer.positiveZOrderLayers())
1281             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1282     } else if (requiresChildRebuild)
1283         appendForegroundLayerIfNecessary();
</pre>
<hr />
<pre>
1351 #if !LOG_DISABLED
1352 void RenderLayerCompositor::logLayerInfo(const RenderLayer&amp; layer, const char* phase, int depth)
1353 {
1354     if (!compositingLogEnabled())
1355         return;
1356 
1357     auto* backing = layer.backing();
1358     RequiresCompositingData queryData;
1359     if (requiresCompositingLayer(layer, queryData) || layer.isRenderViewLayer()) {
1360         ++m_obligateCompositedLayerCount;
1361         m_obligatoryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1362     } else {
1363         ++m_secondaryCompositedLayerCount;
1364         m_secondaryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1365     }
1366 
1367     LayoutRect absoluteBounds = backing-&gt;compositedBounds();
1368     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
1369 
1370     StringBuilder logString;
<span class="line-modified">1371     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);</span>
1372 
1373     if (!layer.renderer().style().hasAutoZIndex())
<span class="line-modified">1374         logString.append(&quot; z-index: &quot;, layer.renderer().style().zIndex());</span>
1375 
<span class="line-modified">1376     logString.append(&quot; (&quot;, logReasonsForCompositing(layer), &quot;) &quot;);</span>


1377 
1378     if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1379         logString.append(&#39;[&#39;);
1380         bool prependSpace = false;
1381         if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
1382             logString.appendLiteral(&quot;opaque&quot;);
1383             prependSpace = true;
1384         }
1385 
1386         if (backing-&gt;paintsIntoCompositedAncestor()) {
1387             if (prependSpace)
1388                 logString.appendLiteral(&quot;, &quot;);
1389             logString.appendLiteral(&quot;paints into ancestor&quot;);
1390             prependSpace = true;
1391         }
1392 
1393         if (backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1394             if (prependSpace)
1395                 logString.appendLiteral(&quot;, &quot;);
1396             if (backing-&gt;foregroundLayer() &amp;&amp; backing-&gt;backgroundLayer()) {
</pre>
<hr />
<pre>
1417     logString.append(layer.name());
1418 
1419     logString.appendLiteral(&quot; - &quot;);
1420     logString.append(phase);
1421 
1422     LOG(Compositing, &quot;%s&quot;, logString.toString().utf8().data());
1423 }
1424 #endif
1425 
1426 static bool clippingChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
1427 {
1428     return oldStyle.overflowX() != newStyle.overflowX() || oldStyle.overflowY() != newStyle.overflowY()
1429         || oldStyle.hasClip() != newStyle.hasClip() || oldStyle.clip() != newStyle.clip();
1430 }
1431 
1432 static bool styleAffectsLayerGeometry(const RenderStyle&amp; style)
1433 {
1434     return style.hasClip() || style.clipPath() || style.hasBorderRadius();
1435 }
1436 
<span class="line-added">1437 static bool recompositeChangeRequiresGeometryUpdate(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)</span>
<span class="line-added">1438 {</span>
<span class="line-added">1439     return oldStyle.transform() != newStyle.transform()</span>
<span class="line-added">1440         || oldStyle.transformOriginX() != newStyle.transformOriginX()</span>
<span class="line-added">1441         || oldStyle.transformOriginY() != newStyle.transformOriginY()</span>
<span class="line-added">1442         || oldStyle.transformOriginZ() != newStyle.transformOriginZ()</span>
<span class="line-added">1443         || oldStyle.transformStyle3D() != newStyle.transformStyle3D()</span>
<span class="line-added">1444         || oldStyle.perspective() != newStyle.perspective()</span>
<span class="line-added">1445         || oldStyle.perspectiveOriginX() != newStyle.perspectiveOriginX()</span>
<span class="line-added">1446         || oldStyle.perspectiveOriginY() != newStyle.perspectiveOriginY()</span>
<span class="line-added">1447         || oldStyle.backfaceVisibility() != newStyle.backfaceVisibility()</span>
<span class="line-added">1448         || !arePointingToEqualData(oldStyle.clipPath(), newStyle.clipPath());</span>
<span class="line-added">1449 }</span>
<span class="line-added">1450 </span>
1451 void RenderLayerCompositor::layerStyleChanged(StyleDifference diff, RenderLayer&amp; layer, const RenderStyle* oldStyle)
1452 {
1453     if (diff == StyleDifference::Equal)
1454         return;
1455 
1456     // Create or destroy backing here so that code that runs during layout can reliably use isComposited() (though this
1457     // is only true for layers composited for direct reasons).
1458     // Also, it allows us to avoid a tree walk in updateCompositingLayers() when no layer changed its compositing state.
1459     RequiresCompositingData queryData;
1460     queryData.layoutUpToDate = LayoutUpToDate::No;
1461 
1462     bool layerChanged = updateBacking(layer, queryData, CompositingChangeRepaintNow);
1463     if (layerChanged) {
1464         layer.setChildrenNeedCompositingGeometryUpdate();
1465         layer.setNeedsCompositingLayerConnection();
1466         layer.setSubsequentLayersNeedCompositingRequirementsTraversal();
1467         // Ancestor layers that composited for indirect reasons (things listed in styleChangeMayAffectIndirectCompositingReasons()) need to get updated.
1468         // This could be optimized by only setting this flag on layers with the relevant styles.
1469         layer.setNeedsPostLayoutCompositingUpdateOnAncestors();
1470     }
1471 
1472     if (queryData.reevaluateAfterLayout)
1473         layer.setNeedsPostLayoutCompositingUpdate();
1474 
<span class="line-modified">1475     const auto&amp; newStyle = layer.renderer().style();</span>
<span class="line-modified">1476 </span>
<span class="line-modified">1477     if (hasContentCompositingLayers()) {</span>
<span class="line-added">1478         if (diff &gt;= StyleDifference::LayoutPositionedMovementOnly) {</span>
<span class="line-added">1479             layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-added">1480             layer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-added">1481         }</span>
<span class="line-added">1482 </span>
<span class="line-added">1483         if (diff &gt;= StyleDifference::Layout) {</span>
<span class="line-added">1484             // FIXME: only set flags here if we know we have a composited descendant, but we might not know at this point.</span>
<span class="line-added">1485             if (oldStyle &amp;&amp; clippingChanged(*oldStyle, newStyle)) {</span>
<span class="line-added">1486                 if (layer.isStackingContext()) {</span>
<span class="line-added">1487                     layer.setNeedsPostLayoutCompositingUpdate(); // Layer needs to become composited if it has composited descendants.</span>
<span class="line-added">1488                     layer.setNeedsCompositingConfigurationUpdate(); // If already composited, layer needs to create/destroy clipping layer.</span>
<span class="line-added">1489                 } else {</span>
<span class="line-added">1490                     // Descendant (in containing block order) compositing layers need to re-evaluate their clipping,</span>
<span class="line-added">1491                     // but they might be siblings in z-order so go up to our stacking context.</span>
<span class="line-added">1492                     if (auto* stackingContext = layer.stackingContext())</span>
<span class="line-added">1493                         stackingContext-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
<span class="line-added">1494                 }</span>
<span class="line-added">1495             }</span>
<span class="line-added">1496 </span>
<span class="line-added">1497             // These properties trigger compositing if some descendant is composited.</span>
<span class="line-added">1498             if (oldStyle &amp;&amp; styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))</span>
<span class="line-added">1499                 layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-added">1500 </span>
<span class="line-added">1501             layer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-added">1502         }</span>
1503     }
1504 
1505     auto* backing = layer.backing();
1506     if (!backing)
1507         return;
1508 
1509     backing-&gt;updateConfigurationAfterStyleChange();
1510 


1511     if (diff &gt;= StyleDifference::Repaint) {
1512         // Visibility change may affect geometry of the enclosing composited layer.
1513         if (oldStyle &amp;&amp; oldStyle-&gt;visibility() != newStyle.visibility())
1514             layer.setNeedsCompositingGeometryUpdate();
1515 
1516         // We&#39;ll get a diff of Repaint when things like clip-path change; these might affect layer or inner-layer geometry.
1517         if (layer.isComposited() &amp;&amp; oldStyle) {
1518             if (styleAffectsLayerGeometry(*oldStyle) || styleAffectsLayerGeometry(newStyle))
1519                 layer.setNeedsCompositingGeometryUpdate();
1520         }
1521     }
1522 
1523     // This is necessary to get iframe layers hooked up in response to scheduleInvalidateStyleAndLayerComposition().
1524     if (diff == StyleDifference::RecompositeLayer &amp;&amp; layer.isComposited() &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer()))
1525         layer.setNeedsCompositingConfigurationUpdate();
1526 
<span class="line-modified">1527     if (diff &gt;= StyleDifference::RecompositeLayer &amp;&amp; oldStyle &amp;&amp; recompositeChangeRequiresGeometryUpdate(*oldStyle, newStyle)) {</span>
<span class="line-modified">1528         // FIXME: transform changes really need to trigger layout. See RenderElement::adjustStyleDifference().</span>
<span class="line-modified">1529         layer.setNeedsPostLayoutCompositingUpdate();</span>























1530         layer.setNeedsCompositingGeometryUpdate();
1531     }
1532 }
1533 
1534 bool RenderLayerCompositor::needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp; layer, const RenderStyle* oldStyle) const
1535 {
1536     // Needed for scroll bars.
1537     if (layer.isRenderViewLayer())
1538         return true;
1539 
1540     if (!oldStyle)
1541         return false;
1542 
1543     const RenderStyle&amp; newStyle = layer.renderer().style();
1544     // Visibility change may affect geometry of the enclosing composited layer.
1545     if (oldStyle-&gt;visibility() != newStyle.visibility())
1546         return true;
1547 
1548     // We don&#39;t have any direct reasons for this style change to affect layer composition. Test if it might affect things indirectly.
1549     if (styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
</pre>
<hr />
<pre>
1575 
1576     return *renderer;
1577 }
1578 
1579 void RenderLayerCompositor::updateRootContentLayerClipping()
1580 {
1581     m_rootContentsLayer-&gt;setMasksToBounds(!m_renderView.settings().backgroundShouldExtendBeyondPage());
1582 }
1583 
1584 bool RenderLayerCompositor::updateBacking(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint, BackingRequired backingRequired)
1585 {
1586     bool layerChanged = false;
1587     if (backingRequired == BackingRequired::Unknown)
1588         backingRequired = needsToBeComposited(layer, queryData) ? BackingRequired::Yes : BackingRequired::No;
1589     else {
1590         // Need to fetch viewportConstrainedNotCompositedReason, but without doing all the work that needsToBeComposited does.
1591         requiresCompositingForPosition(rendererForCompositingTests(layer), layer, queryData);
1592     }
1593 
1594     if (backingRequired == BackingRequired::Yes) {
<span class="line-added">1595         layer.disconnectFromBackingProviderLayer();</span>
<span class="line-added">1596 </span>
1597         enableCompositingMode();
1598 
1599         if (!layer.backing()) {
1600             // If we need to repaint, do so before making backing
1601             if (shouldRepaint == CompositingChangeRepaintNow)
<span class="line-modified">1602                 repaintOnCompositingChange(layer); // wrong backing</span>
1603 
1604             layer.ensureBacking();
1605 
1606             if (layer.isRenderViewLayer() &amp;&amp; useCoordinatedScrollingForLayer(layer)) {
1607                 auto&amp; frameView = m_renderView.frameView();
1608                 if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1609                     scrollingCoordinator-&gt;frameViewRootLayerDidChange(frameView);
1610 #if ENABLE(RUBBER_BANDING)
1611                 updateLayerForHeader(frameView.headerHeight());
1612                 updateLayerForFooter(frameView.footerHeight());
1613 #endif
1614                 updateRootContentLayerClipping();
1615 
1616                 if (auto* tiledBacking = layer.backing()-&gt;tiledBacking())
1617                     tiledBacking-&gt;setTopContentInset(frameView.topContentInset());
1618             }
1619 
1620             // This layer and all of its descendants have cached repaints rects that are relative to
1621             // the repaint container, so change when compositing changes; we need to update them here.
1622             if (layer.parent())
</pre>
<hr />
<pre>
1729         return;
1730 
1731     ASSERT(compositedAncestor-&gt;backing());
1732     LayoutRect repaintRect = rect;
1733     repaintRect.move(layer.offsetFromAncestor(compositedAncestor));
1734     compositedAncestor-&gt;setBackingNeedsRepaintInRect(repaintRect);
1735 
1736     // The contents of this layer may be moving from a GraphicsLayer to the window,
1737     // so we need to make sure the window system synchronizes those changes on the screen.
1738     if (compositedAncestor-&gt;isRenderViewLayer())
1739         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1740 }
1741 
1742 // FIXME: remove.
1743 void RenderLayerCompositor::layerWasAdded(RenderLayer&amp;, RenderLayer&amp;)
1744 {
1745 }
1746 
1747 void RenderLayerCompositor::layerWillBeRemoved(RenderLayer&amp; parent, RenderLayer&amp; child)
1748 {
<span class="line-modified">1749     if (parent.renderer().renderTreeBeingDestroyed())</span>
1750         return;
1751 
<span class="line-modified">1752     if (child.isComposited())</span>
<span class="line-added">1753         repaintInCompositedAncestor(child, child.backing()-&gt;compositedBounds()); // FIXME: do via dirty bits?</span>
<span class="line-added">1754     else if (child.paintsIntoProvidedBacking()) {</span>
<span class="line-added">1755         auto* backingProviderLayer = child.backingProviderLayer();</span>
<span class="line-added">1756         // FIXME: Optimize this repaint.</span>
<span class="line-added">1757         backingProviderLayer-&gt;setBackingNeedsRepaint();</span>
<span class="line-added">1758         backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(child);</span>
<span class="line-added">1759     } else</span>
<span class="line-added">1760         return;</span>
1761 
1762     child.setNeedsCompositingLayerConnection();
1763 }
1764 
1765 RenderLayer* RenderLayerCompositor::enclosingNonStackingClippingLayer(const RenderLayer&amp; layer) const
1766 {
1767     for (auto* parent = layer.parent(); parent; parent = parent-&gt;parent()) {
1768         if (parent-&gt;isStackingContext())
1769             return nullptr;
1770         if (parent-&gt;renderer().hasClipOrOverflowClip())
1771             return parent;
1772     }
1773     return nullptr;
1774 }
1775 
<span class="line-modified">1776 void RenderLayerCompositor::computeExtent(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const</span>
1777 {
1778     if (extent.extentComputed)
1779         return;
1780 
1781     LayoutRect layerBounds;
1782     if (extent.hasTransformAnimation)
1783         extent.animationCausesExtentUncertainty = !layer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(layerBounds);
1784     else
1785         layerBounds = layer.overlapBounds();
1786 
1787     // In the animating transform case, we avoid double-accounting for the transform because
1788     // we told pushMappingsToAncestor() to ignore transforms earlier.
1789     extent.bounds = enclosingLayoutRect(overlapMap.geometryMap().absoluteRect(layerBounds));
1790 
1791     // Empty rects never intersect, but we need them to for the purposes of overlap testing.
1792     if (extent.bounds.isEmpty())
1793         extent.bounds.setSize(LayoutSize(1, 1));
1794 

1795     RenderLayerModelObject&amp; renderer = layer.renderer();
1796     if (renderer.isFixedPositioned() &amp;&amp; renderer.container() == &amp;m_renderView) {
1797         // Because fixed elements get moved around without re-computing overlap, we have to compute an overlap
1798         // rect that covers all the locations that the fixed element could move to.
1799         // FIXME: need to handle sticky too.
1800         extent.bounds = m_renderView.frameView().fixedScrollableAreaBoundsInflatedForScrolling(extent.bounds);
1801     }
1802 
1803     extent.extentComputed = true;
1804 }
1805 
<span class="line-modified">1806 enum class AncestorTraversal { Continue, Stop };</span>
<span class="line-added">1807 </span>
<span class="line-added">1808 // This is a simplified version of containing block walking that only handles absolute position.</span>
<span class="line-added">1809 template &lt;typename Function&gt;</span>
<span class="line-added">1810 static AncestorTraversal traverseAncestorLayers(const RenderLayer&amp; layer, Function&amp;&amp; function)</span>
<span class="line-added">1811 {</span>
<span class="line-added">1812     bool containingBlockCanSkipLayers = layer.renderer().isAbsolutelyPositioned();</span>
<span class="line-added">1813     RenderLayer* nextPaintOrderParent = layer.paintOrderParent();</span>
<span class="line-added">1814 </span>
<span class="line-added">1815     for (const auto* ancestorLayer = layer.parent(); ancestorLayer; ancestorLayer = ancestorLayer-&gt;parent()) {</span>
<span class="line-added">1816         bool inContainingBlockChain = true;</span>
<span class="line-added">1817 </span>
<span class="line-added">1818         if (containingBlockCanSkipLayers)</span>
<span class="line-added">1819             inContainingBlockChain = ancestorLayer-&gt;renderer().canContainAbsolutelyPositionedObjects();</span>
<span class="line-added">1820 </span>
<span class="line-added">1821         if (function(*ancestorLayer, inContainingBlockChain, ancestorLayer == nextPaintOrderParent) == AncestorTraversal::Stop)</span>
<span class="line-added">1822             return AncestorTraversal::Stop;</span>
<span class="line-added">1823 </span>
<span class="line-added">1824         if (inContainingBlockChain)</span>
<span class="line-added">1825             containingBlockCanSkipLayers = ancestorLayer-&gt;renderer().isAbsolutelyPositioned();</span>
<span class="line-added">1826 </span>
<span class="line-added">1827         if (ancestorLayer == nextPaintOrderParent)</span>
<span class="line-added">1828             nextPaintOrderParent = ancestorLayer-&gt;paintOrderParent();</span>
<span class="line-added">1829     }</span>
<span class="line-added">1830 </span>
<span class="line-added">1831     return AncestorTraversal::Continue;</span>
<span class="line-added">1832 }</span>
<span class="line-added">1833 </span>
<span class="line-added">1834 static bool createsClippingScope(const RenderLayer&amp; layer)</span>
<span class="line-added">1835 {</span>
<span class="line-added">1836     return layer.hasCompositedScrollableOverflow();</span>
<span class="line-added">1837 }</span>
<span class="line-added">1838 </span>
<span class="line-added">1839 static Vector&lt;LayerOverlapMap::LayerAndBounds&gt; enclosingClippingScopes(const RenderLayer&amp; layer, const RenderLayer&amp; rootLayer)</span>
<span class="line-added">1840 {</span>
<span class="line-added">1841     Vector&lt;LayerOverlapMap::LayerAndBounds&gt; clippingScopes;</span>
<span class="line-added">1842     clippingScopes.append({ const_cast&lt;RenderLayer&amp;&gt;(rootLayer), { } });</span>
<span class="line-added">1843 </span>
<span class="line-added">1844     if (!layer.hasCompositedScrollingAncestor())</span>
<span class="line-added">1845         return clippingScopes;</span>
<span class="line-added">1846 </span>
<span class="line-added">1847     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {</span>
<span class="line-added">1848         if (inContainingBlockChain &amp;&amp; createsClippingScope(ancestorLayer)) {</span>
<span class="line-added">1849             LayoutRect clipRect;</span>
<span class="line-added">1850             if (is&lt;RenderBox&gt;(ancestorLayer.renderer())) {</span>
<span class="line-added">1851                 // FIXME: This is expensive. Broken with transforms.</span>
<span class="line-added">1852                 LayoutPoint offsetFromRoot = ancestorLayer.convertToLayerCoords(&amp;rootLayer, { });</span>
<span class="line-added">1853                 clipRect = downcast&lt;RenderBox&gt;(ancestorLayer.renderer()).overflowClipRect(offsetFromRoot);</span>
<span class="line-added">1854             }</span>
<span class="line-added">1855 </span>
<span class="line-added">1856             LayerOverlapMap::LayerAndBounds layerAndBounds { const_cast&lt;RenderLayer&amp;&gt;(ancestorLayer), clipRect };</span>
<span class="line-added">1857             clippingScopes.insert(1, layerAndBounds); // Order is roots to leaves.</span>
<span class="line-added">1858         }</span>
<span class="line-added">1859         return AncestorTraversal::Continue;</span>
<span class="line-added">1860     });</span>
<span class="line-added">1861 </span>
<span class="line-added">1862     return clippingScopes;</span>
<span class="line-added">1863 }</span>
<span class="line-added">1864 </span>
<span class="line-added">1865 void RenderLayerCompositor::addToOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const</span>
1866 {
1867     if (layer.isRenderViewLayer())
1868         return;
1869 
1870     computeExtent(overlapMap, layer, extent);
1871 
<span class="line-modified">1872     // FIXME: constrain the scopes (by composited stacking context ancestor I think).</span>
<span class="line-added">1873     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());</span>
<span class="line-added">1874 </span>
<span class="line-added">1875     LayoutRect clipRect;</span>
<span class="line-added">1876     if (layer.hasCompositedScrollingAncestor()) {</span>
<span class="line-added">1877         // Compute a clip up to the composited scrolling ancestor, then convert it to absolute coordinates.</span>
<span class="line-added">1878         auto&amp; scrollingScope = clippingScopes.last();</span>
<span class="line-added">1879         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;scrollingScope.layer, TemporaryClipRects, IgnoreOverlayScrollbarSize, IgnoreOverflowClip)).rect();</span>
<span class="line-added">1880         if (!clipRect.isInfinite())</span>
<span class="line-added">1881             clipRect.setLocation(layer.convertToLayerCoords(&amp;rootRenderLayer(), clipRect.location()));</span>
<span class="line-added">1882     } else</span>
<span class="line-added">1883         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.</span>
<span class="line-added">1884 </span>
<span class="line-added">1885     auto clippedBounds = extent.bounds;</span>
<span class="line-added">1886     if (!clipRect.isInfinite()) {</span>
<span class="line-added">1887         // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="line-added">1888         if (!m_renderView.settings().delegatesPageScaling())</span>
<span class="line-added">1889             clipRect.scale(pageScaleFactor());</span>
1890 
<span class="line-modified">1891         clippedBounds.intersect(clipRect);</span>
<span class="line-modified">1892     }</span>
<span class="line-modified">1893 </span>
<span class="line-modified">1894     overlapMap.add(layer, clippedBounds, clippingScopes);</span>

1895 }
1896 
<span class="line-modified">1897 void RenderLayerCompositor::addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const</span>
1898 {
1899     if (!canBeComposited(layer))
1900         return;
1901 
1902     // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
<span class="line-modified">1903     if (ancestorLayer) {</span>
1904         overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
1905 
<span class="line-modified">1906         OverlapExtent layerExtent;</span>
<span class="line-modified">1907         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-added">1908     }</span>
1909 
1910 #if !ASSERT_DISABLED
1911     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
1912 #endif
1913 
<span class="line-modified">1914     for (auto* renderLayer : layer.negativeZOrderLayers())</span>
<span class="line-modified">1915         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
<span class="line-added">1916 </span>
<span class="line-added">1917     for (auto* renderLayer : layer.normalFlowLayers())</span>
<span class="line-added">1918         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
<span class="line-added">1919 </span>
<span class="line-added">1920     for (auto* renderLayer : layer.positiveZOrderLayers())</span>
<span class="line-added">1921         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
<span class="line-added">1922 </span>
<span class="line-added">1923     if (ancestorLayer)</span>
<span class="line-added">1924         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
<span class="line-added">1925 }</span>
<span class="line-added">1926 </span>
<span class="line-added">1927 void RenderLayerCompositor::updateOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap) const</span>
<span class="line-added">1928 {</span>
<span class="line-added">1929     if (addLayerToOverlap) {</span>
<span class="line-added">1930         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-added">1931         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; contributes to overlap, added to map &quot; &lt;&lt; overlapMap);</span>
<span class="line-added">1932     }</span>
<span class="line-added">1933 </span>
<span class="line-added">1934     if (addDescendantsToOverlap) {</span>
<span class="line-added">1935         // If this is the first non-root layer to composite, we need to add all the descendants we already traversed to the overlap map.</span>
<span class="line-added">1936         addDescendantsToOverlapMapRecursive(overlapMap, layer);</span>
<span class="line-added">1937         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; composited post descendant traversal, added recursive &quot; &lt;&lt; overlapMap);</span>
<span class="line-added">1938     }</span>
1939 
<span class="line-modified">1940     if (didPushContainer) {</span>
<span class="line-modified">1941         overlapMap.popCompositingContainer();</span>
<span class="line-added">1942         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is composited or shared, popped container &quot; &lt;&lt; overlapMap);</span>
<span class="line-added">1943     }</span>
<span class="line-added">1944 }</span>
1945 
<span class="line-modified">1946 bool RenderLayerCompositor::layerOverlaps(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent) const</span>
<span class="line-modified">1947 {</span>
<span class="line-added">1948     computeExtent(overlapMap, layer, layerExtent);</span>
1949 
<span class="line-modified">1950     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());</span>
<span class="line-modified">1951     return overlapMap.overlapsLayers(layer, layerExtent.bounds, clippingScopes);</span>
1952 }
1953 
1954 #if ENABLE(VIDEO)
1955 bool RenderLayerCompositor::canAccelerateVideoRendering(RenderVideo&amp; video) const
1956 {
1957     if (!m_hasAcceleratedCompositing)
1958         return false;
1959 
1960     return video.supportsAcceleratedRendering();
1961 }
1962 #endif
1963 
1964 void RenderLayerCompositor::frameViewDidChangeLocation(const IntPoint&amp; contentsOffset)
1965 {
1966     if (m_overflowControlsHostLayer)
1967         m_overflowControlsHostLayer-&gt;setPosition(contentsOffset);
1968 }
1969 
1970 void RenderLayerCompositor::frameViewDidChangeSize()
1971 {
1972     if (auto* layer = m_renderView.layer())
1973         layer-&gt;setNeedsCompositingGeometryUpdate();
1974 
1975     if (m_scrolledContentsLayer) {
1976         updateScrollLayerClipping();
1977         frameViewDidScroll();
1978         updateOverflowControlsLayers();
1979 
1980 #if ENABLE(RUBBER_BANDING)
1981         if (m_layerForOverhangAreas) {
1982             auto&amp; frameView = m_renderView.frameView();
1983             m_layerForOverhangAreas-&gt;setSize(frameView.frameRect().size());
1984             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, frameView.topContentInset()));
1985         }
1986 #endif
1987     }
1988 }
1989 
<span class="line-added">1990 void RenderLayerCompositor::widgetDidChangeSize(RenderWidget&amp; widget)</span>
<span class="line-added">1991 {</span>
<span class="line-added">1992     if (!widget.hasLayer())</span>
<span class="line-added">1993         return;</span>
<span class="line-added">1994 </span>
<span class="line-added">1995     auto&amp; layer = *widget.layer();</span>
<span class="line-added">1996 </span>
<span class="line-added">1997     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; widgetDidChangeSize (layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">1998 </span>
<span class="line-added">1999     // Widget size affects answer to requiresCompositingForFrame() so we need to trigger</span>
<span class="line-added">2000     // a compositing update.</span>
<span class="line-added">2001     layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-added">2002     scheduleCompositingLayerUpdate();</span>
<span class="line-added">2003 </span>
<span class="line-added">2004     if (layer.isComposited())</span>
<span class="line-added">2005         layer.backing()-&gt;updateAfterWidgetResize();</span>
<span class="line-added">2006 }</span>
<span class="line-added">2007 </span>
2008 bool RenderLayerCompositor::hasCoordinatedScrolling() const
2009 {
2010     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
2011     return scrollingCoordinator &amp;&amp; scrollingCoordinator-&gt;coordinatesScrollingForFrameView(m_renderView.frameView());
2012 }
2013 
2014 void RenderLayerCompositor::updateScrollLayerPosition()
2015 {
2016     ASSERT(!hasCoordinatedScrolling());
2017     ASSERT(m_scrolledContentsLayer);
2018 
2019     auto&amp; frameView = m_renderView.frameView();
2020     IntPoint scrollPosition = frameView.scrollPosition();
2021 
<span class="line-added">2022     // We use scroll position here because the root content layer is offset to account for scrollOrigin (see FrameView::positionForRootContentLayer).</span>
2023     m_scrolledContentsLayer-&gt;setPosition(FloatPoint(-scrollPosition.x(), -scrollPosition.y()));
2024 
2025     if (auto* fixedBackgroundLayer = fixedRootBackgroundLayer())
2026         fixedBackgroundLayer-&gt;setPosition(frameView.scrollPositionForFixedPosition());
2027 }
2028 
2029 void RenderLayerCompositor::updateScrollLayerClipping()
2030 {
2031     auto* layerForClipping = this-&gt;layerForClipping();
2032     if (!layerForClipping)
2033         return;
2034 
2035     layerForClipping-&gt;setSize(m_renderView.frameView().sizeForVisibleContent());
2036     layerForClipping-&gt;setPosition(positionForClipLayer());
2037 }
2038 
2039 FloatPoint RenderLayerCompositor::positionForClipLayer() const
2040 {
2041     auto&amp; frameView = m_renderView.frameView();
2042 
2043     return FloatPoint(
2044         frameView.shouldPlaceBlockDirectionScrollbarOnLeft() ? frameView.horizontalScrollbarIntrusion() : 0,
2045         FrameView::yPositionForInsetClipLayer(frameView.scrollPosition(), frameView.topContentInset()));
2046 }
2047 
2048 void RenderLayerCompositor::frameViewDidScroll()
2049 {
2050     if (!m_scrolledContentsLayer)
2051         return;
2052 
2053     // If there&#39;s a scrolling coordinator that manages scrolling for this frame view,
2054     // it will also manage updating the scroll layer position.
2055     if (hasCoordinatedScrolling()) {
2056         // We have to schedule a flush in order for the main TiledBacking to update its tile coverage.
<span class="line-modified">2057         scheduleLayerFlush();</span>
2058         return;
2059     }
2060 
2061     updateScrollLayerPosition();
2062 }
2063 
2064 void RenderLayerCompositor::frameViewDidAddOrRemoveScrollbars()
2065 {
2066     updateOverflowControlsLayers();
2067 }
2068 
2069 void RenderLayerCompositor::frameViewDidLayout()
2070 {
2071     if (auto* renderViewBacking = m_renderView.layer()-&gt;backing())
2072         renderViewBacking-&gt;adjustTiledBackingCoverage();
2073 }
2074 
2075 void RenderLayerCompositor::rootLayerConfigurationChanged()
2076 {
2077     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
2078     if (renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking()) {
2079         m_renderView.layer()-&gt;setNeedsCompositingConfigurationUpdate();
2080         scheduleCompositingLayerUpdate();
2081     }
2082 }
2083 
2084 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
2085 {
2086     updateCompositingLayers(CompositingUpdateType::AfterLayout);
2087 
2088     if (!m_rootContentsLayer)
2089         return String();
2090 
2091     flushPendingLayerChanges(true);
<span class="line-added">2092     page().renderingUpdateScheduler().scheduleImmediateRenderingUpdate();</span>
2093 
2094     LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
2095     if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
2096         layerTreeBehavior |= LayerTreeAsTextDebug;
2097     if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
2098         layerTreeBehavior |= LayerTreeAsTextIncludeVisibleRects;
2099     if (flags &amp; LayerTreeFlagsIncludeTileCaches)
2100         layerTreeBehavior |= LayerTreeAsTextIncludeTileCaches;
2101     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2102         layerTreeBehavior |= LayerTreeAsTextIncludeRepaintRects;
2103     if (flags &amp; LayerTreeFlagsIncludePaintingPhases)
2104         layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
2105     if (flags &amp; LayerTreeFlagsIncludeContentLayers)
2106         layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
2107     if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
2108         layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;
<span class="line-added">2109     if (flags &amp; LayerTreeFlagsIncludeClipping)</span>
<span class="line-added">2110         layerTreeBehavior |= LayerTreeAsTextIncludeClipping;</span>
2111     if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
2112         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
2113     if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
2114         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
<span class="line-added">2115     if (flags &amp; LayerTreeFlagsIncludeEventRegion)</span>
<span class="line-added">2116         layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;</span>
2117 
2118     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
2119     // similar between platforms.
2120     String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
2121 
2122     // Dump an empty layer tree only if the only composited layer is the main frame&#39;s tiled backing,
2123     // so that tests expecting us to drop out of accelerated compositing when there are no layers succeed.
2124     if (!hasContentCompositingLayers() &amp;&amp; documentUsesTiledBacking() &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeTileCaches) &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeRootLayerProperties))
2125         layerTreeText = emptyString();
2126 
2127     // The true root layer is not included in the dump, so if we want to report
2128     // its repaint rects, they must be included here.
2129     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2130         return m_renderView.frameView().trackedRepaintRectsAsText() + layerTreeText;
2131 
2132     return layerTreeText;
2133 }
2134 
2135 static RenderView* frameContentsRenderView(RenderWidget&amp; renderer)
2136 {
</pre>
<hr />
<pre>
2336     if (m_hasAcceleratedCompositing &amp;&amp; layer.isSelfPaintingLayer()) {
2337         if (!layer.isInsideFragmentedFlow())
2338             return true;
2339 
2340         // CSS Regions flow threads do not need to be composited as we use composited RenderFragmentContainers
2341         // to render the background of the RenderFragmentedFlow.
2342         if (layer.isRenderFragmentedFlow())
2343             return false;
2344 
2345         return true;
2346     }
2347     return false;
2348 }
2349 
2350 #if ENABLE(FULLSCREEN_API)
2351 enum class FullScreenDescendant { Yes, No, NotApplicable };
2352 static FullScreenDescendant isDescendantOfFullScreenLayer(const RenderLayer&amp; layer)
2353 {
2354     auto&amp; document = layer.renderer().document();
2355 
<span class="line-modified">2356     if (!document.fullscreenManager().isFullscreen() || !document.fullscreenManager().fullscreenRenderer())</span>
2357         return FullScreenDescendant::NotApplicable;
2358 
<span class="line-modified">2359     auto* fullScreenLayer = document.fullscreenManager().fullscreenRenderer()-&gt;layer();</span>
2360     if (!fullScreenLayer) {
2361         ASSERT_NOT_REACHED();
2362         return FullScreenDescendant::NotApplicable;
2363     }
2364 
2365     return layer.isDescendantOf(*fullScreenLayer) ? FullScreenDescendant::Yes : FullScreenDescendant::No;
2366 }
2367 #endif
2368 
2369 bool RenderLayerCompositor::requiresOwnBackingStore(const RenderLayer&amp; layer, const RenderLayer* compositingAncestorLayer, const LayoutRect&amp; layerCompositedBoundsInAncestor, const LayoutRect&amp; ancestorCompositedBounds) const
2370 {
2371     auto&amp; renderer = layer.renderer();
2372 
2373     if (compositingAncestorLayer
2374         &amp;&amp; !(compositingAncestorLayer-&gt;backing()-&gt;graphicsLayer()-&gt;drawsContent()
2375             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoWindow()
2376             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoCompositedAncestor()))
2377         return true;
2378 
2379     RequiresCompositingData queryData;
</pre>
<hr />
<pre>
2382         || requiresCompositingForAnimation(renderer)
2383         || requiresCompositingForPosition(renderer, layer, queryData)
2384         || requiresCompositingForCanvas(renderer)
2385         || requiresCompositingForFilters(renderer)
2386         || requiresCompositingForWillChange(renderer)
2387         || requiresCompositingForBackfaceVisibility(renderer)
2388         || requiresCompositingForVideo(renderer)
2389         || requiresCompositingForFrame(renderer, queryData)
2390         || requiresCompositingForPlugin(renderer, queryData)
2391         || requiresCompositingForEditableImage(renderer)
2392         || requiresCompositingForOverflowScrolling(layer, queryData)
2393         || needsContentsCompositingLayer(layer)
2394         || renderer.isTransparent()
2395         || renderer.hasMask()
2396         || renderer.hasReflection()
2397         || renderer.hasFilter()
2398         || renderer.hasBackdropFilter())
2399         return true;
2400 
2401     if (layer.mustCompositeForIndirectReasons()) {
<span class="line-modified">2402         IndirectCompositingReason reason = layer.indirectCompositingReason();</span>
<span class="line-modified">2403         return reason == IndirectCompositingReason::Overlap</span>
<span class="line-modified">2404             || reason == IndirectCompositingReason::OverflowScrollPositioning</span>
<span class="line-modified">2405             || reason == IndirectCompositingReason::Stacking</span>
<span class="line-modified">2406             || reason == IndirectCompositingReason::BackgroundLayer</span>
<span class="line-modified">2407             || reason == IndirectCompositingReason::GraphicalEffect</span>
<span class="line-added">2408             || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.</span>
2409     }
2410 
2411     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
2412         return true;
2413 
<span class="line-added">2414     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="line-added">2415         return true;</span>
<span class="line-added">2416 </span>
2417     return false;
2418 }
2419 
2420 OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
2421 {
2422     OptionSet&lt;CompositingReason&gt; reasons;
2423 
2424     if (!layer.isComposited())
2425         return reasons;
2426 
2427     RequiresCompositingData queryData;
2428 
2429     auto&amp; renderer = rendererForCompositingTests(layer);
2430 
2431     if (requiresCompositingForTransform(renderer))
2432         reasons.add(CompositingReason::Transform3D);
2433 
2434     if (requiresCompositingForVideo(renderer))
2435         reasons.add(CompositingReason::Video);
2436     else if (requiresCompositingForCanvas(renderer))
</pre>
<hr />
<pre>
2444 
2445     if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
2446         reasons.add(CompositingReason::BackfaceVisibilityHidden);
2447 
2448     if (clipsCompositingDescendants(*renderer.layer()))
2449         reasons.add(CompositingReason::ClipsCompositingDescendants);
2450 
2451     if (requiresCompositingForAnimation(renderer))
2452         reasons.add(CompositingReason::Animation);
2453 
2454     if (requiresCompositingForFilters(renderer))
2455         reasons.add(CompositingReason::Filters);
2456 
2457     if (requiresCompositingForWillChange(renderer))
2458         reasons.add(CompositingReason::WillChange);
2459 
2460     if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
2461         reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
2462 
2463     if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
<span class="line-modified">2464         reasons.add(CompositingReason::OverflowScrolling);</span>
2465 
2466     switch (renderer.layer()-&gt;indirectCompositingReason()) {
<span class="line-modified">2467     case IndirectCompositingReason::None:</span>
2468         break;
<span class="line-modified">2469     case IndirectCompositingReason::Stacking:</span>
2470         reasons.add(CompositingReason::Stacking);
2471         break;
<span class="line-modified">2472     case IndirectCompositingReason::OverflowScrollPositioning:</span>
<span class="line-added">2473         reasons.add(CompositingReason::OverflowScrollPositioning);</span>
<span class="line-added">2474         break;</span>
<span class="line-added">2475     case IndirectCompositingReason::Overlap:</span>
2476         reasons.add(CompositingReason::Overlap);
2477         break;
<span class="line-modified">2478     case IndirectCompositingReason::BackgroundLayer:</span>
2479         reasons.add(CompositingReason::NegativeZIndexChildren);
2480         break;
<span class="line-modified">2481     case IndirectCompositingReason::GraphicalEffect:</span>
2482         if (renderer.hasTransform())
2483             reasons.add(CompositingReason::TransformWithCompositedDescendants);
2484 
2485         if (renderer.isTransparent())
2486             reasons.add(CompositingReason::OpacityWithCompositedDescendants);
2487 
2488         if (renderer.hasMask())
2489             reasons.add(CompositingReason::MaskWithCompositedDescendants);
2490 
2491         if (renderer.hasReflection())
2492             reasons.add(CompositingReason::ReflectionWithCompositedDescendants);
2493 
2494         if (renderer.hasFilter() || renderer.hasBackdropFilter())
2495             reasons.add(CompositingReason::FilterWithCompositedDescendants);
2496 
2497 #if ENABLE(CSS_COMPOSITING)
2498         if (layer.isolatesCompositedBlending())
2499             reasons.add(CompositingReason::IsolatesCompositedBlendingDescendants);
2500 
2501         if (layer.hasBlendMode())
2502             reasons.add(CompositingReason::BlendingWithCompositedDescendants);
2503 #endif
2504         break;
<span class="line-modified">2505     case IndirectCompositingReason::Perspective:</span>
2506         reasons.add(CompositingReason::Perspective);
2507         break;
<span class="line-modified">2508     case IndirectCompositingReason::Preserve3D:</span>
2509         reasons.add(CompositingReason::Preserve3D);
2510         break;
2511     }
2512 
2513     if (usesCompositing() &amp;&amp; renderer.layer()-&gt;isRenderViewLayer())
2514         reasons.add(CompositingReason::Root);
2515 
2516     return reasons;
2517 }
2518 
2519 #if !LOG_DISABLED
2520 const char* RenderLayerCompositor::logReasonsForCompositing(const RenderLayer&amp; layer)
2521 {
2522     OptionSet&lt;CompositingReason&gt; reasons = reasonsForCompositing(layer);
2523 
2524     if (reasons &amp; CompositingReason::Transform3D)
2525         return &quot;3D transform&quot;;
2526 
2527     if (reasons &amp; CompositingReason::Video)
2528         return &quot;video&quot;;
</pre>
<hr />
<pre>
2537         return &quot;iframe&quot;;
2538 
2539     if (reasons &amp; CompositingReason::BackfaceVisibilityHidden)
2540         return &quot;backface-visibility: hidden&quot;;
2541 
2542     if (reasons &amp; CompositingReason::ClipsCompositingDescendants)
2543         return &quot;clips compositing descendants&quot;;
2544 
2545     if (reasons &amp; CompositingReason::Animation)
2546         return &quot;animation&quot;;
2547 
2548     if (reasons &amp; CompositingReason::Filters)
2549         return &quot;filters&quot;;
2550 
2551     if (reasons &amp; CompositingReason::PositionFixed)
2552         return &quot;position: fixed&quot;;
2553 
2554     if (reasons &amp; CompositingReason::PositionSticky)
2555         return &quot;position: sticky&quot;;
2556 
<span class="line-modified">2557     if (reasons &amp; CompositingReason::OverflowScrolling)</span>
<span class="line-modified">2558         return &quot;async overflow scrolling&quot;;</span>
2559 
2560     if (reasons &amp; CompositingReason::Stacking)
2561         return &quot;stacking&quot;;
2562 
2563     if (reasons &amp; CompositingReason::Overlap)
2564         return &quot;overlap&quot;;
2565 
2566     if (reasons &amp; CompositingReason::NegativeZIndexChildren)
2567         return &quot;negative z-index children&quot;;
2568 
2569     if (reasons &amp; CompositingReason::TransformWithCompositedDescendants)
2570         return &quot;transform with composited descendants&quot;;
2571 
2572     if (reasons &amp; CompositingReason::OpacityWithCompositedDescendants)
2573         return &quot;opacity with composited descendants&quot;;
2574 
2575     if (reasons &amp; CompositingReason::MaskWithCompositedDescendants)
2576         return &quot;mask with composited descendants&quot;;
2577 
2578     if (reasons &amp; CompositingReason::ReflectionWithCompositedDescendants)
</pre>
<hr />
<pre>
2591 
2592     if (reasons &amp; CompositingReason::Perspective)
2593         return &quot;perspective&quot;;
2594 
2595     if (reasons &amp; CompositingReason::Preserve3D)
2596         return &quot;preserve-3d&quot;;
2597 
2598     if (reasons &amp; CompositingReason::Root)
2599         return &quot;root&quot;;
2600 
2601     return &quot;&quot;;
2602 }
2603 #endif
2604 
2605 // Return true if the given layer has some ancestor in the RenderLayer hierarchy that clips,
2606 // up to the enclosing compositing ancestor. This is required because compositing layers are parented
2607 // according to the z-order hierarchy, yet clipping goes down the renderer hierarchy.
2608 // Thus, a RenderLayer can be clipped by a RenderLayer that is an ancestor in the renderer hierarchy,
2609 // but a sibling in the z-order hierarchy.
2610 // FIXME: can we do this without a tree walk?
<span class="line-modified">2611 bool RenderLayerCompositor::clippedByAncestor(RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
2612 {
2613     ASSERT(layer.isComposited());





2614     if (!compositingAncestor)
2615         return false;
2616 
2617     // If the compositingAncestor clips, that will be taken care of by clipsCompositingDescendants(),
2618     // so we only care about clipping between its first child that is our ancestor (the computeClipRoot),
2619     // and layer. The exception is when the compositingAncestor isolates composited blending children,
2620     // in this case it is not allowed to clipsCompositingDescendants() and each of its children
2621     // will be clippedByAncestor()s, including the compositingAncestor.
2622     auto* computeClipRoot = compositingAncestor;
2623     if (!compositingAncestor-&gt;isolatesCompositedBlending()) {
2624         computeClipRoot = nullptr;
2625         auto* parent = &amp;layer;
2626         while (parent) {
2627             auto* next = parent-&gt;parent();
2628             if (next == compositingAncestor) {
2629                 computeClipRoot = parent;
2630                 break;
2631             }
2632             parent = next;
2633         }
2634 
2635         if (!computeClipRoot || computeClipRoot == &amp;layer)
2636             return false;
2637     }
2638 
2639     return !layer.backgroundClipRect(RenderLayer::ClipRectsContext(computeClipRoot, TemporaryClipRects)).isInfinite(); // FIXME: Incorrect for CSS regions.
2640 }
2641 
<span class="line-added">2642 bool RenderLayerCompositor::updateAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
<span class="line-added">2643 {</span>
<span class="line-added">2644     ASSERT(layer.isComposited());</span>
<span class="line-added">2645 </span>
<span class="line-added">2646     auto clippingStack = computeAncestorClippingStack(layer, compositingAncestor);</span>
<span class="line-added">2647     return layer.backing()-&gt;updateAncestorClippingStack(WTFMove(clippingStack));</span>
<span class="line-added">2648 }</span>
<span class="line-added">2649 </span>
<span class="line-added">2650 Vector&lt;CompositedClipData&gt; RenderLayerCompositor::computeAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
<span class="line-added">2651 {</span>
<span class="line-added">2652     // On first pass in WK1, the root may not have become composited yet.</span>
<span class="line-added">2653     if (!compositingAncestor)</span>
<span class="line-added">2654         return { };</span>
<span class="line-added">2655 </span>
<span class="line-added">2656     // We&#39;ll start by building a child-to-ancestors stack.</span>
<span class="line-added">2657     Vector&lt;CompositedClipData&gt; newStack;</span>
<span class="line-added">2658 </span>
<span class="line-added">2659     // Walk up the containing block chain to composited ancestor, prepending an entry to the clip stack for:</span>
<span class="line-added">2660     // * each composited scrolling layer</span>
<span class="line-added">2661     // * each set of RenderLayers which contribute a clip.</span>
<span class="line-added">2662     bool haveNonScrollableClippingIntermediateLayer = false;</span>
<span class="line-added">2663     const RenderLayer* currentClippedLayer = &amp;layer;</span>
<span class="line-added">2664 </span>
<span class="line-added">2665     auto pushNonScrollableClip = [&amp;](const RenderLayer&amp; clippedLayer, const RenderLayer&amp; clippingRoot, ShouldRespectOverflowClip respectClip = IgnoreOverflowClip) {</span>
<span class="line-added">2666         // Pass IgnoreOverflowClip to ignore overflow contributed by clippingRoot (which may be a scroller).</span>
<span class="line-added">2667         auto clipRect = clippedLayer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;clippingRoot, TemporaryClipRects, IgnoreOverlayScrollbarSize, respectClip)).rect();</span>
<span class="line-added">2668         auto offset = layer.convertToLayerCoords(&amp;clippingRoot, { }, RenderLayer::AdjustForColumns);</span>
<span class="line-added">2669         clipRect.moveBy(-offset);</span>
<span class="line-added">2670 </span>
<span class="line-added">2671         CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;clippedLayer), clipRect, false };</span>
<span class="line-added">2672         newStack.insert(0, WTFMove(clipData));</span>
<span class="line-added">2673     };</span>
<span class="line-added">2674 </span>
<span class="line-added">2675     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {</span>
<span class="line-added">2676         if (&amp;ancestorLayer == compositingAncestor) {</span>
<span class="line-added">2677 </span>
<span class="line-added">2678             if (haveNonScrollableClippingIntermediateLayer)</span>
<span class="line-added">2679                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, ancestorLayer.isolatesCompositedBlending() ? RespectOverflowClip : IgnoreOverflowClip);</span>
<span class="line-added">2680             else if (ancestorLayer.isolatesCompositedBlending() &amp;&amp; newStack.isEmpty())</span>
<span class="line-added">2681                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, RespectOverflowClip);</span>
<span class="line-added">2682 </span>
<span class="line-added">2683             return AncestorTraversal::Stop;</span>
<span class="line-added">2684         }</span>
<span class="line-added">2685 </span>
<span class="line-added">2686         if (isContainingBlockChain &amp;&amp; ancestorLayer.renderer().hasClipOrOverflowClip()) {</span>
<span class="line-added">2687             if (ancestorLayer.hasCompositedScrollableOverflow()) {</span>
<span class="line-added">2688                 if (haveNonScrollableClippingIntermediateLayer) {</span>
<span class="line-added">2689                     pushNonScrollableClip(*currentClippedLayer, ancestorLayer);</span>
<span class="line-added">2690                     haveNonScrollableClippingIntermediateLayer = false;</span>
<span class="line-added">2691                 }</span>
<span class="line-added">2692 </span>
<span class="line-added">2693                 auto clipRect = parentRelativeScrollableRect(ancestorLayer, &amp;ancestorLayer);</span>
<span class="line-added">2694                 auto offset = layer.convertToLayerCoords(&amp;ancestorLayer, { }, RenderLayer::AdjustForColumns);</span>
<span class="line-added">2695                 clipRect.moveBy(-offset);</span>
<span class="line-added">2696 </span>
<span class="line-added">2697                 CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;ancestorLayer), clipRect, true };</span>
<span class="line-added">2698                 newStack.insert(0, WTFMove(clipData));</span>
<span class="line-added">2699                 currentClippedLayer = &amp;ancestorLayer;</span>
<span class="line-added">2700             } else</span>
<span class="line-added">2701                 haveNonScrollableClippingIntermediateLayer = true;</span>
<span class="line-added">2702         }</span>
<span class="line-added">2703 </span>
<span class="line-added">2704         return AncestorTraversal::Continue;</span>
<span class="line-added">2705     });</span>
<span class="line-added">2706 </span>
<span class="line-added">2707     return newStack;</span>
<span class="line-added">2708 }</span>
<span class="line-added">2709 </span>
<span class="line-added">2710 // Note that this returns the ScrollingNodeID of the scroller this layer is embedded in, not the layer&#39;s own ScrollingNodeID if it has one.</span>
<span class="line-added">2711 ScrollingNodeID RenderLayerCompositor::asyncScrollableContainerNodeID(const RenderObject&amp; renderer)</span>
<span class="line-added">2712 {</span>
<span class="line-added">2713     auto* enclosingLayer = renderer.enclosingLayer();</span>
<span class="line-added">2714     if (!enclosingLayer)</span>
<span class="line-added">2715         return 0;</span>
<span class="line-added">2716 </span>
<span class="line-added">2717     auto layerScrollingNodeID = [](const RenderLayer&amp; layer) -&gt; ScrollingNodeID {</span>
<span class="line-added">2718         if (layer.isComposited())</span>
<span class="line-added">2719             return layer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">2720         return 0;</span>
<span class="line-added">2721     };</span>
<span class="line-added">2722 </span>
<span class="line-added">2723     // If the renderer is inside the layer, we care about the layer&#39;s scrollability. Otherwise, we let traverseAncestorLayers look at ancestors.</span>
<span class="line-added">2724     if (!renderer.hasLayer()) {</span>
<span class="line-added">2725         if (auto scrollingNodeID = layerScrollingNodeID(*enclosingLayer))</span>
<span class="line-added">2726             return scrollingNodeID;</span>
<span class="line-added">2727     }</span>
<span class="line-added">2728 </span>
<span class="line-added">2729     ScrollingNodeID containerScrollingNodeID = 0;</span>
<span class="line-added">2730     traverseAncestorLayers(*enclosingLayer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {</span>
<span class="line-added">2731         if (isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow()) {</span>
<span class="line-added">2732             containerScrollingNodeID = layerScrollingNodeID(ancestorLayer);</span>
<span class="line-added">2733             return AncestorTraversal::Stop;</span>
<span class="line-added">2734         }</span>
<span class="line-added">2735         return AncestorTraversal::Continue;</span>
<span class="line-added">2736     });</span>
<span class="line-added">2737 </span>
<span class="line-added">2738     return containerScrollingNodeID;</span>
<span class="line-added">2739 }</span>
<span class="line-added">2740 </span>
2741 // Return true if the given layer is a stacking context and has compositing child
2742 // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
2743 // into the hierarchy between this layer and its children in the z-order hierarchy.
<span class="line-modified">2744 bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer)</span>
2745 {
2746     return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
2747 }
2748 
2749 bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
2750 {
2751     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2752         return false;
2753 
2754     if (auto* element = renderer.element()) {
2755         if (auto* timeline = element-&gt;document().existingTimeline()) {
2756             if (timeline-&gt;runningAnimationsForElementAreAllAccelerated(*element))
2757                 return true;
2758         }
2759     }
2760 
2761     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
2762         return false;
2763 
2764     auto&amp; animController = renderer.animation();
</pre>
<hr />
<pre>
2963         return m_renderView.isComposited();
2964     }
2965 
2966     return m_renderView.frameView().isScrollable();
2967 }
2968 
2969 bool RenderLayerCompositor::requiresCompositingForPosition(RenderLayerModelObject&amp; renderer, const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2970 {
2971     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
2972     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
2973     // z-index and clipping will be broken.
2974     if (!renderer.isPositioned())
2975         return false;
2976 
2977 #if ENABLE(FULLSCREEN_API)
2978     if (isDescendantOfFullScreenLayer(layer) == FullScreenDescendant::No)
2979         return false;
2980 #endif
2981 
2982     auto position = renderer.style().position();
<span class="line-modified">2983     bool isFixed = renderer.isFixedPositioned();</span>
2984     if (isFixed &amp;&amp; !layer.isStackingContext())
2985         return false;
2986 
2987     bool isSticky = renderer.isInFlowPositioned() &amp;&amp; position == PositionType::Sticky;
2988     if (!isFixed &amp;&amp; !isSticky)
2989         return false;
2990 
2991     // FIXME: acceleratedCompositingForFixedPositionEnabled should probably be renamed acceleratedCompositingForViewportConstrainedPositionEnabled().
2992     if (!m_renderView.settings().acceleratedCompositingForFixedPositionEnabled())
2993         return false;
2994 
2995     if (isSticky)
2996         return isAsyncScrollableStickyLayer(layer);
2997 
2998     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2999         queryData.reevaluateAfterLayout = true;
3000         return layer.isComposited();
3001     }
3002 
3003     auto container = renderer.container();
3004     ASSERT(container);
3005 
3006     // Don&#39;t promote fixed position elements that are descendants of a non-view container, e.g. transformed elements.
<span class="line-modified">3007     // They will stay fixed wrt the container rather than the enclosing frame.</span>
3008     if (container != &amp;m_renderView) {
3009         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNonViewContainer;
3010         return false;
3011     }
3012 
3013     bool paintsContent = layer.isVisuallyNonEmpty() || layer.hasVisibleDescendant();
3014     if (!paintsContent) {
3015         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNoVisibleContent;
3016         return false;
3017     }
3018 
3019     bool intersectsViewport = fixedLayerIntersectsViewport(layer);
3020     if (!intersectsViewport) {
3021         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForBoundsOutOfView;
3022         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is outside the viewport&quot;);
3023         return false;
3024     }
3025 
3026     return true;
3027 }
3028 
3029 bool RenderLayerCompositor::requiresCompositingForOverflowScrolling(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
3030 {
3031     if (!layer.canUseCompositedScrolling())
3032         return false;
3033 
3034     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
3035         queryData.reevaluateAfterLayout = true;
3036         return layer.isComposited();
3037     }
3038 
3039     return layer.hasCompositedScrollableOverflow();
3040 }
3041 
3042 // FIXME: why doesn&#39;t this handle the clipping cases?
<span class="line-modified">3043 bool RenderLayerCompositor::requiresCompositingForIndirectReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason&amp; reason) const</span>
3044 {


3045     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
3046     // via compositing so that they also apply to those composited descendants.
<span class="line-added">3047     auto&amp; renderer = layer.renderer();</span>
3048     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {
<span class="line-modified">3049         reason = IndirectCompositingReason::GraphicalEffect;</span>
3050         return true;
3051     }
3052 
3053     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
3054     // will be affected by the preserve-3d or perspective.
3055     if (has3DTransformedDescendants) {
3056         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {
<span class="line-modified">3057             reason = IndirectCompositingReason::Preserve3D;</span>
3058             return true;
3059         }
3060 
3061         if (renderer.style().hasPerspective()) {
<span class="line-modified">3062             reason = IndirectCompositingReason::Perspective;</span>
<span class="line-added">3063             return true;</span>
<span class="line-added">3064         }</span>
<span class="line-added">3065     }</span>
<span class="line-added">3066 </span>
<span class="line-added">3067     // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.</span>
<span class="line-added">3068     if (!paintsIntoProvidedBacking &amp;&amp; layer.hasCompositedScrollingAncestor()) {</span>
<span class="line-added">3069         auto* paintDestination = layer.paintOrderParent();</span>
<span class="line-added">3070         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None) {</span>
<span class="line-added">3071             reason = IndirectCompositingReason::OverflowScrollPositioning;</span>
3072             return true;
3073         }
3074     }
3075 
<span class="line-modified">3076     reason = IndirectCompositingReason::None;</span>
3077     return false;
3078 }
3079 
3080 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
3081 {
3082     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
3083         return true;
3084     if (newStyle.isolation() != oldStyle.isolation())
3085         return true;
3086     if (newStyle.hasTransform() != oldStyle.hasTransform())
3087         return true;
3088     if (newStyle.boxReflect() != oldStyle.boxReflect())
3089         return true;
3090     if (newStyle.transformStyle3D() != oldStyle.transformStyle3D())
3091         return true;
3092     if (newStyle.hasPerspective() != oldStyle.hasPerspective())
3093         return true;
3094 
3095     return false;
3096 }
3097 
3098 bool RenderLayerCompositor::isAsyncScrollableStickyLayer(const RenderLayer&amp; layer, const RenderLayer** enclosingAcceleratedOverflowLayer) const
3099 {
3100     ASSERT(layer.renderer().isStickilyPositioned());
3101 
3102     auto* enclosingOverflowLayer = layer.enclosingOverflowClipLayer(ExcludeSelf);
3103 

3104     if (enclosingOverflowLayer &amp;&amp; enclosingOverflowLayer-&gt;hasCompositedScrollableOverflow()) {
3105         if (enclosingAcceleratedOverflowLayer)
3106             *enclosingAcceleratedOverflowLayer = enclosingOverflowLayer;
3107         return true;
3108     }
<span class="line-modified">3109 </span>


3110     // If the layer is inside normal overflow, it&#39;s not async-scrollable.
3111     if (enclosingOverflowLayer)
3112         return false;
3113 
3114     // No overflow ancestor, so see if the frame supports async scrolling.
3115     if (hasCoordinatedScrolling())
3116         return true;
3117 
3118 #if PLATFORM(IOS_FAMILY)
3119     // iOS WK1 has fixed/sticky support in the main frame via WebFixedPositionContent.
3120     return isMainFrameCompositor();
3121 #else
3122     return false;
3123 #endif
3124 }
3125 
3126 bool RenderLayerCompositor::isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp; layer) const
3127 {
3128     if (layer.renderer().isStickilyPositioned())
3129         return isAsyncScrollableStickyLayer(layer);
3130 
<span class="line-modified">3131     if (!layer.renderer().isFixedPositioned())</span>
3132         return false;
3133 
3134     // FIXME: Handle fixed inside of a transform, which should not behave as fixed.
<span class="line-modified">3135     for (auto* ancestor = layer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {</span>
<span class="line-modified">3136         if (ancestor-&gt;hasCompositedScrollableOverflow())</span>
<span class="line-added">3137             return true;</span>
<span class="line-added">3138         if (ancestor-&gt;isStackingContext() &amp;&amp; ancestor-&gt;isComposited() &amp;&amp; ancestor-&gt;renderer().isFixedPositioned())</span>
3139             return false;
3140     }
3141 
3142     return true;
3143 }
3144 
3145 bool RenderLayerCompositor::fixedLayerIntersectsViewport(const RenderLayer&amp; layer) const
3146 {
<span class="line-modified">3147     ASSERT(layer.renderer().isFixedPositioned());</span>
3148 
3149     // Fixed position elements that are invisible in the current view don&#39;t get their own layer.
3150     // FIXME: We shouldn&#39;t have to check useFixedLayout() here; one of the viewport rects needs to give the correct answer.
3151     LayoutRect viewBounds;
3152     if (m_renderView.frameView().useFixedLayout())
3153         viewBounds = m_renderView.unscaledDocumentRect();
3154     else
3155         viewBounds = m_renderView.frameView().rectForFixedPositionLayout();
3156 
3157     LayoutRect layerBounds = layer.calculateLayerBounds(&amp;layer, LayoutSize(), { RenderLayer::UseLocalClipRectIfPossible, RenderLayer::IncludeFilterOutsets, RenderLayer::UseFragmentBoxesExcludingCompositing,
3158         RenderLayer::ExcludeHiddenDescendants, RenderLayer::DontConstrainForMask, RenderLayer::IncludeCompositedDescendants });
3159     // Map to m_renderView to ignore page scale.
3160     FloatRect absoluteBounds = layer.renderer().localToContainerQuad(FloatRect(layerBounds), &amp;m_renderView).boundingBox();
3161     return viewBounds.intersects(enclosingIntRect(absoluteBounds));
3162 }
3163 
3164 bool RenderLayerCompositor::useCoordinatedScrollingForLayer(const RenderLayer&amp; layer) const
3165 {
3166     if (layer.isRenderViewLayer() &amp;&amp; hasCoordinatedScrolling())
3167         return true;
3168 
3169     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3170         return scrollingCoordinator-&gt;coordinatesScrollingForOverflowLayer(layer);
3171 
3172     return false;
3173 }
3174 
<span class="line-added">3175 static bool isScrolledByOverflowScrollLayer(const RenderLayer&amp; layer, const RenderLayer&amp; overflowScrollLayer)</span>
<span class="line-added">3176 {</span>
<span class="line-added">3177     bool scrolledByOverflowScroll = false;</span>
<span class="line-added">3178     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {</span>
<span class="line-added">3179         if (&amp;ancestorLayer == &amp;overflowScrollLayer) {</span>
<span class="line-added">3180             scrolledByOverflowScroll = inContainingBlockChain;</span>
<span class="line-added">3181             return AncestorTraversal::Stop;</span>
<span class="line-added">3182         }</span>
<span class="line-added">3183         return AncestorTraversal::Continue;</span>
<span class="line-added">3184     });</span>
<span class="line-added">3185     return scrolledByOverflowScroll;</span>
<span class="line-added">3186 }</span>
<span class="line-added">3187 </span>
<span class="line-added">3188 static RenderLayer* enclosingCompositedScrollingLayer(const RenderLayer&amp; layer, const RenderLayer&amp; intermediateLayer, bool&amp; sawIntermediateLayer)</span>
<span class="line-added">3189 {</span>
<span class="line-added">3190     const auto* ancestorLayer = layer.parent();</span>
<span class="line-added">3191     while (ancestorLayer) {</span>
<span class="line-added">3192         if (ancestorLayer == &amp;intermediateLayer)</span>
<span class="line-added">3193             sawIntermediateLayer = true;</span>
<span class="line-added">3194 </span>
<span class="line-added">3195         if (ancestorLayer-&gt;hasCompositedScrollableOverflow())</span>
<span class="line-added">3196             return const_cast&lt;RenderLayer*&gt;(ancestorLayer);</span>
<span class="line-added">3197 </span>
<span class="line-added">3198         ancestorLayer = ancestorLayer-&gt;parent();</span>
<span class="line-added">3199     }</span>
<span class="line-added">3200 </span>
<span class="line-added">3201     return nullptr;</span>
<span class="line-added">3202 }</span>
<span class="line-added">3203 </span>
<span class="line-added">3204 ScrollPositioningBehavior RenderLayerCompositor::layerScrollBehahaviorRelativeToCompositedAncestor(const RenderLayer&amp; layer, const RenderLayer&amp; compositedAncestor)</span>
<span class="line-added">3205 {</span>
<span class="line-added">3206     if (!layer.hasCompositedScrollingAncestor())</span>
<span class="line-added">3207         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3208 </span>
<span class="line-added">3209     bool compositedAncestorIsInsideScroller = false;</span>
<span class="line-added">3210     auto* scrollingAncestor = enclosingCompositedScrollingLayer(layer, compositedAncestor, compositedAncestorIsInsideScroller);</span>
<span class="line-added">3211     if (!scrollingAncestor) {</span>
<span class="line-added">3212         ASSERT_NOT_REACHED(); // layer.hasCompositedScrollingAncestor() should guarantee we have one.</span>
<span class="line-added">3213         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3214     }</span>
<span class="line-added">3215 </span>
<span class="line-added">3216     bool ancestorMovedByScroller = &amp;compositedAncestor == scrollingAncestor || (compositedAncestorIsInsideScroller &amp;&amp; isScrolledByOverflowScrollLayer(compositedAncestor, *scrollingAncestor));</span>
<span class="line-added">3217     bool layerMovedByScroller = isScrolledByOverflowScrollLayer(layer, *scrollingAncestor);</span>
<span class="line-added">3218 </span>
<span class="line-added">3219     if (ancestorMovedByScroller == layerMovedByScroller)</span>
<span class="line-added">3220         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3221 </span>
<span class="line-added">3222     return layerMovedByScroller ? ScrollPositioningBehavior::Moves : ScrollPositioningBehavior::Stationary;</span>
<span class="line-added">3223 }</span>
<span class="line-added">3224 </span>
<span class="line-added">3225 static void collectStationaryLayerRelatedOverflowNodes(const RenderLayer&amp; layer, const RenderLayer&amp;, Vector&lt;ScrollingNodeID&gt;&amp; scrollingNodes)</span>
<span class="line-added">3226 {</span>
<span class="line-added">3227     ASSERT(layer.isComposited());</span>
<span class="line-added">3228 </span>
<span class="line-added">3229     auto appendOverflowLayerNodeID = [&amp;scrollingNodes] (const RenderLayer&amp; overflowLayer) {</span>
<span class="line-added">3230         ASSERT(overflowLayer.isComposited());</span>
<span class="line-added">3231         auto scrollingNodeID = overflowLayer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">3232         if (scrollingNodeID)</span>
<span class="line-added">3233             scrollingNodes.append(scrollingNodeID);</span>
<span class="line-added">3234         else</span>
<span class="line-added">3235             LOG(Scrolling, &quot;Layer %p doesn&#39;t have scrolling node ID yet&quot;, &amp;overflowLayer);</span>
<span class="line-added">3236     };</span>
<span class="line-added">3237 </span>
<span class="line-added">3238     // Collect all the composited scrollers which affect the position of this layer relative to its compositing ancestor (which might be inside the scroller or the scroller itself).</span>
<span class="line-added">3239     bool seenPaintOrderAncestor = false;</span>
<span class="line-added">3240     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool isPaintOrderAncestor) {</span>
<span class="line-added">3241         seenPaintOrderAncestor |= isPaintOrderAncestor;</span>
<span class="line-added">3242         if (isContainingBlockChain &amp;&amp; isPaintOrderAncestor)</span>
<span class="line-added">3243             return AncestorTraversal::Stop;</span>
<span class="line-added">3244 </span>
<span class="line-added">3245         if (seenPaintOrderAncestor &amp;&amp; !isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow())</span>
<span class="line-added">3246             appendOverflowLayerNodeID(ancestorLayer);</span>
<span class="line-added">3247 </span>
<span class="line-added">3248         return AncestorTraversal::Continue;</span>
<span class="line-added">3249     });</span>
<span class="line-added">3250 }</span>
<span class="line-added">3251 </span>
<span class="line-added">3252 ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer) const</span>
<span class="line-added">3253 {</span>
<span class="line-added">3254     if (layer.isRenderViewLayer())</span>
<span class="line-added">3255         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3256 </span>
<span class="line-added">3257     if (layer.renderer().isFixedPositioned())</span>
<span class="line-added">3258         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3259 </span>
<span class="line-added">3260     if (!layer.hasCompositedScrollingAncestor())</span>
<span class="line-added">3261         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3262 </span>
<span class="line-added">3263     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();</span>
<span class="line-added">3264     if (!scrollingCoordinator)</span>
<span class="line-added">3265         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3266 </span>
<span class="line-added">3267     auto* compositedAncestor = layer.ancestorCompositingLayer();</span>
<span class="line-added">3268     if (!compositedAncestor) {</span>
<span class="line-added">3269         ASSERT_NOT_REACHED();</span>
<span class="line-added">3270         return ScrollPositioningBehavior::None;</span>
<span class="line-added">3271     }</span>
<span class="line-added">3272 </span>
<span class="line-added">3273     return layerScrollBehahaviorRelativeToCompositedAncestor(layer, *compositedAncestor);</span>
<span class="line-added">3274 }</span>
<span class="line-added">3275 </span>
<span class="line-added">3276 static Vector&lt;ScrollingNodeID&gt; collectRelatedCoordinatedScrollingNodes(const RenderLayer&amp; layer, ScrollPositioningBehavior positioningBehavior)</span>
<span class="line-added">3277 {</span>
<span class="line-added">3278     Vector&lt;ScrollingNodeID&gt; overflowNodeIDs;</span>
<span class="line-added">3279 </span>
<span class="line-added">3280     switch (positioningBehavior) {</span>
<span class="line-added">3281     case ScrollPositioningBehavior::Stationary: {</span>
<span class="line-added">3282         auto* compositedAncestor = layer.ancestorCompositingLayer();</span>
<span class="line-added">3283         if (!compositedAncestor)</span>
<span class="line-added">3284             return overflowNodeIDs;</span>
<span class="line-added">3285         collectStationaryLayerRelatedOverflowNodes(layer, *compositedAncestor, overflowNodeIDs);</span>
<span class="line-added">3286         break;</span>
<span class="line-added">3287     }</span>
<span class="line-added">3288     case ScrollPositioningBehavior::Moves:</span>
<span class="line-added">3289     case ScrollPositioningBehavior::None:</span>
<span class="line-added">3290         ASSERT_NOT_REACHED();</span>
<span class="line-added">3291         break;</span>
<span class="line-added">3292     }</span>
<span class="line-added">3293 </span>
<span class="line-added">3294     return overflowNodeIDs;</span>
<span class="line-added">3295 }</span>
<span class="line-added">3296 </span>
3297 bool RenderLayerCompositor::isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp; layer) const
3298 {
3299     if (!is&lt;RenderWidget&gt;(layer.renderer()))
3300         return false;
3301 
3302     auto* contentDocument = downcast&lt;RenderWidget&gt;(layer.renderer()).frameOwnerElement().contentDocument();
3303     if (!contentDocument)
3304         return false;
3305 
3306     auto* view = contentDocument-&gt;renderView();
3307     if (!view)
3308         return false;
3309 
3310     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3311         return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(view-&gt;frameView());
3312 
3313     return false;
3314 }
3315 
3316 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
3317 {
3318     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
3319         return false;
3320 
3321     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
3322         if (auto* element = renderer.element()) {
3323             if (auto* timeline = element-&gt;document().existingTimeline())
3324                 return timeline-&gt;isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
3325         }
3326         return false;
3327     }
3328     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
3329 }
3330 
<span class="line-modified">3331 // If an element has composited negative z-index children, those children render in front of the</span>
3332 // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
3333 bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
3334 {
<span class="line-modified">3335     for (auto* layer : layer.negativeZOrderLayers()) {</span>
<span class="line-added">3336         if (layer-&gt;isComposited() || layer-&gt;hasCompositingDescendant())</span>
<span class="line-added">3337             return true;</span>
<span class="line-added">3338     }</span>
<span class="line-added">3339 </span>
<span class="line-added">3340     return false;</span>
3341 }
3342 
3343 bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
3344 {
3345     auto&amp; frameView = m_renderView.frameView();
3346 
3347     // This applies when the application UI handles scrolling, in which case RenderLayerCompositor doesn&#39;t need to manage it.
3348     if (frameView.delegatesScrolling() &amp;&amp; isMainFrameCompositor())
3349         return false;
3350 
3351     // We need to handle our own scrolling if we&#39;re:
3352     return !m_renderView.frameView().platformWidget() // viewless (i.e. non-Mac, or Mac in WebKit2)
3353         || attachment == RootLayerAttachedViaEnclosingFrame; // a composited frame on Mac
3354 }
3355 
3356 void paintScrollbar(Scrollbar* scrollbar, GraphicsContext&amp; context, const IntRect&amp; clip)
3357 {
3358     if (!scrollbar)
3359         return;
3360 
3361     context.save();
3362     const IntRect&amp; scrollbarRect = scrollbar-&gt;frameRect();
3363     context.translate(-scrollbarRect.location());
3364     IntRect transformedClip = clip;
3365     transformedClip.moveBy(scrollbarRect.location());
3366     scrollbar-&gt;paint(context, transformedClip);
3367     context.restore();
3368 }
3369 
<span class="line-modified">3370 void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
3371 {
3372 #if PLATFORM(MAC)
3373     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
3374 #endif
3375 
3376     IntRect pixelSnappedRectForIntegralPositionedItems = snappedIntRect(LayoutRect(clip));
3377     if (graphicsLayer == layerForHorizontalScrollbar())
3378         paintScrollbar(m_renderView.frameView().horizontalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3379     else if (graphicsLayer == layerForVerticalScrollbar())
3380         paintScrollbar(m_renderView.frameView().verticalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3381     else if (graphicsLayer == layerForScrollCorner()) {
3382         const IntRect&amp; scrollCorner = m_renderView.frameView().scrollCornerRect();
3383         context.save();
3384         context.translate(-scrollCorner.location());
3385         IntRect transformedClip = pixelSnappedRectForIntegralPositionedItems;
3386         transformedClip.moveBy(scrollCorner.location());
3387         m_renderView.frameView().paintScrollCorner(context, transformedClip);
3388         context.restore();
3389     }
3390 }
</pre>
<hr />
<pre>
3775         GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3776 
3777     if (requiresContentShadowLayer()) {
3778         if (!m_contentShadowLayer) {
3779             m_contentShadowLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3780             m_contentShadowLayer-&gt;setName(&quot;content shadow&quot;);
3781             m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
3782             m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
3783             m_contentShadowLayer-&gt;setAnchorPoint(FloatPoint3D());
3784             m_contentShadowLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingShadow);
3785 
3786             m_scrolledContentsLayer-&gt;addChildBelow(*m_contentShadowLayer, m_rootContentsLayer.get());
3787         }
3788     } else
3789         GraphicsLayer::unparentAndClear(m_contentShadowLayer);
3790 #endif
3791 
3792     if (requiresHorizontalScrollbarLayer()) {
3793         if (!m_layerForHorizontalScrollbar) {
3794             m_layerForHorizontalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">3795             m_layerForHorizontalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
3796             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3797             m_layerForHorizontalScrollbar-&gt;setName(&quot;horizontal scrollbar container&quot;);
3798 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3799             m_layerForHorizontalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3800 #endif
3801             m_overflowControlsHostLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
3802 
3803             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3804                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3805         }
3806     } else if (m_layerForHorizontalScrollbar) {
3807         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3808 
3809         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3810             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3811     }
3812 
3813     if (requiresVerticalScrollbarLayer()) {
3814         if (!m_layerForVerticalScrollbar) {
3815             m_layerForVerticalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">3816             m_layerForVerticalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
3817             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3818             m_layerForVerticalScrollbar-&gt;setName(&quot;vertical scrollbar container&quot;);
3819 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3820             m_layerForVerticalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3821 #endif
3822             m_overflowControlsHostLayer-&gt;addChild(*m_layerForVerticalScrollbar);
3823 
3824             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3825                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3826         }
3827     } else if (m_layerForVerticalScrollbar) {
3828         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3829 
3830         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3831             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3832     }
3833 
3834     if (requiresScrollCornerLayer()) {
3835         if (!m_layerForScrollCorner) {
3836             m_layerForScrollCorner = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">3837             m_layerForScrollCorner-&gt;setAllowsBackingStoreDetaching(false);</span>
3838             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
3839             m_layerForScrollCorner-&gt;setName(&quot;scroll corner&quot;);
3840 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3841             m_layerForScrollCorner-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3842 #endif
3843             m_overflowControlsHostLayer-&gt;addChild(*m_layerForScrollCorner);
3844         }
3845     } else
3846         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3847 
3848     m_renderView.frameView().positionScrollbarLayers();
3849 }
3850 
3851 void RenderLayerCompositor::ensureRootLayer()
3852 {
3853     RootLayerAttachment expectedAttachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
3854     if (expectedAttachment == m_rootLayerAttachment)
3855          return;
3856 
3857     if (!m_rootContentsLayer) {
</pre>
<hr />
<pre>
3864 #if PLATFORM(IOS_FAMILY)
3865         // Page scale is applied above this on iOS, so we&#39;ll just say that our root layer applies it.
3866         auto&amp; frame = m_renderView.frameView().frame();
3867         if (frame.isMainFrame())
3868             m_rootContentsLayer-&gt;setAppliesPageScale();
3869 #endif
3870 
3871         // Need to clip to prevent transformed content showing outside this frame
3872         updateRootContentLayerClipping();
3873     }
3874 
3875     if (requiresScrollLayer(expectedAttachment)) {
3876         if (!m_overflowControlsHostLayer) {
3877             ASSERT(!m_scrolledContentsLayer);
3878             ASSERT(!m_clipLayer);
3879 
3880             // Create a layer to host the clipping layer and the overflow controls layers.
3881             m_overflowControlsHostLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3882             m_overflowControlsHostLayer-&gt;setName(&quot;overflow controls host&quot;);
3883 
<span class="line-modified">3884             m_scrolledContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrolledContents);</span>
3885             m_scrolledContentsLayer-&gt;setName(&quot;scrolled contents&quot;);
3886             m_scrolledContentsLayer-&gt;setAnchorPoint({ });
3887 
3888 #if PLATFORM(IOS_FAMILY)
3889             if (m_renderView.settings().asyncFrameScrollingEnabled()) {
3890                 m_scrollContainerLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrollContainer);
3891 
3892                 m_scrollContainerLayer-&gt;setName(&quot;scroll container&quot;);
3893                 m_scrollContainerLayer-&gt;setMasksToBounds(true);
3894                 m_scrollContainerLayer-&gt;setAnchorPoint({ });
3895 
3896                 m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
3897                 m_overflowControlsHostLayer-&gt;addChild(*m_scrollContainerLayer);
3898             }
3899 #endif
<span class="line-added">3900             // FIXME: m_scrollContainerLayer and m_clipLayer have similar roles here, but m_clipLayer has some special positioning to</span>
<span class="line-added">3901             // account for clipping and top content inset (see FrameView::yPositionForInsetClipLayer()).</span>
3902             if (!m_scrollContainerLayer) {
3903                 m_clipLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3904                 m_clipLayer-&gt;setName(&quot;frame clipping&quot;);
3905                 m_clipLayer-&gt;setMasksToBounds(true);
3906                 m_clipLayer-&gt;setAnchorPoint({ });
3907 
3908                 m_clipLayer-&gt;addChild(*m_scrolledContentsLayer);
3909                 m_overflowControlsHostLayer-&gt;addChild(*m_clipLayer);
3910             }
3911 
3912             m_scrolledContentsLayer-&gt;addChild(*m_rootContentsLayer);
3913 
3914             updateScrollLayerClipping();
3915             updateOverflowControlsLayers();
3916 
3917             if (hasCoordinatedScrolling())
3918                 scheduleLayerFlush(true);
3919             else
3920                 updateScrollLayerPosition();
3921         }
</pre>
<hr />
<pre>
3991             ASSERT_NOT_REACHED();
3992             break;
3993         case RootLayerAttachedViaChromeClient: {
3994             auto&amp; frame = m_renderView.frameView().frame();
3995             page().chrome().client().attachRootGraphicsLayer(frame, rootGraphicsLayer());
3996             break;
3997         }
3998         case RootLayerAttachedViaEnclosingFrame: {
3999             // The layer will get hooked up via RenderLayerBacking::updateConfiguration()
4000             // for the frame&#39;s renderer in the parent document.
4001             if (auto* ownerElement = m_renderView.document().ownerElement())
4002                 ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4003             break;
4004         }
4005     }
4006 
4007     m_rootLayerAttachment = attachment;
4008     rootLayerAttachmentChanged();
4009 
4010     if (m_shouldFlushOnReattach) {
<span class="line-modified">4011         scheduleLayerFlush();</span>
4012         m_shouldFlushOnReattach = false;
4013     }
4014 }
4015 
4016 void RenderLayerCompositor::detachRootLayer()
4017 {
4018     if (!m_rootContentsLayer || m_rootLayerAttachment == RootLayerUnattached)
4019         return;
4020 
4021     switch (m_rootLayerAttachment) {
4022     case RootLayerAttachedViaEnclosingFrame: {
4023         // The layer will get unhooked up via RenderLayerBacking::updateConfiguration()
4024         // for the frame&#39;s renderer in the parent document.
4025         if (m_overflowControlsHostLayer)
4026             m_overflowControlsHostLayer-&gt;removeFromParent();
4027         else
4028             m_rootContentsLayer-&gt;removeFromParent();
4029 
4030         if (auto* ownerElement = m_renderView.document().ownerElement())
4031             ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
</pre>
<hr />
<pre>
4114     }
4115 
4116     return false;
4117 }
4118 
4119 void RenderLayerCompositor::deviceOrPageScaleFactorChanged()
4120 {
4121     // Page scale will only be applied at to the RenderView and sublayers, but the device scale factor
4122     // needs to be applied at the level of rootGraphicsLayer().
4123     if (auto* rootLayer = rootGraphicsLayer())
4124         rootLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
4125 }
4126 
4127 void RenderLayerCompositor::removeFromScrollCoordinatedLayers(RenderLayer&amp; layer)
4128 {
4129 #if PLATFORM(IOS_FAMILY)
4130     if (m_legacyScrollingLayerCoordinator)
4131         m_legacyScrollingLayerCoordinator-&gt;removeLayer(layer);
4132 #endif
4133 
<span class="line-modified">4134     detachScrollCoordinatedLayer(layer, allScrollCoordinationRoles());</span>
4135 }
4136 
4137 FixedPositionViewportConstraints RenderLayerCompositor::computeFixedViewportConstraints(RenderLayer&amp; layer) const
4138 {
4139     ASSERT(layer.isComposited());
4140 
4141     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4142 
4143     FixedPositionViewportConstraints constraints;
4144     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4145     constraints.setViewportRectAtLastLayout(m_renderView.frameView().rectForFixedPositionLayout());
4146     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4147 
4148     const RenderStyle&amp; style = layer.renderer().style();
4149     if (!style.left().isAuto())
4150         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
4151 
4152     if (!style.right().isAuto())
4153         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
4154 
4155     if (!style.top().isAuto())
4156         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
4157 
4158     if (!style.bottom().isAuto())
4159         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
4160 
4161     // If left and right are auto, use left.
4162     if (style.left().isAuto() &amp;&amp; style.right().isAuto())
4163         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
4164 
4165     // If top and bottom are auto, use top.
4166     if (style.top().isAuto() &amp;&amp; style.bottom().isAuto())
4167         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
4168 
4169     return constraints;
4170 }
4171 
4172 StickyPositionViewportConstraints RenderLayerCompositor::computeStickyViewportConstraints(RenderLayer&amp; layer) const
4173 {
4174     ASSERT(layer.isComposited());





4175 
4176     auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(layer.renderer());
4177 
4178     StickyPositionViewportConstraints constraints;
4179     renderer.computeStickyPositionConstraints(constraints, renderer.constrainingRectForStickyPosition());
4180 
4181     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4182     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4183     constraints.setStickyOffsetAtLastLayout(renderer.stickyPositionOffset());
4184     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4185 
4186     return constraints;
4187 }
4188 
4189 static inline ScrollCoordinationRole scrollCoordinationRoleForNodeType(ScrollingNodeType nodeType)
4190 {
4191     switch (nodeType) {
4192     case ScrollingNodeType::MainFrame:
4193     case ScrollingNodeType::Subframe:
4194     case ScrollingNodeType::Overflow:
4195         return ScrollCoordinationRole::Scrolling;
<span class="line-added">4196     case ScrollingNodeType::OverflowProxy:</span>
<span class="line-added">4197         return ScrollCoordinationRole::ScrollingProxy;</span>
4198     case ScrollingNodeType::FrameHosting:
4199         return ScrollCoordinationRole::FrameHosting;
4200     case ScrollingNodeType::Fixed:
4201     case ScrollingNodeType::Sticky:
4202         return ScrollCoordinationRole::ViewportConstrained;
<span class="line-added">4203     case ScrollingNodeType::Positioned:</span>
<span class="line-added">4204         return ScrollCoordinationRole::Positioning;</span>
4205     }
4206     ASSERT_NOT_REACHED();
4207     return ScrollCoordinationRole::Scrolling;
4208 }
4209 
4210 ScrollingNodeID RenderLayerCompositor::attachScrollingNode(RenderLayer&amp; layer, ScrollingNodeType nodeType, ScrollingTreeState&amp; treeState)
4211 {
4212     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4213     auto* backing = layer.backing();
4214     // Crash logs suggest that backing can be null here, but we don&#39;t know how: rdar://problem/18545452.
4215     ASSERT(backing);
4216     if (!backing)
4217         return 0;
4218 
4219     ASSERT(treeState.parentNodeID || nodeType == ScrollingNodeType::Subframe);
4220     ASSERT_IMPLIES(nodeType == ScrollingNodeType::MainFrame, !treeState.parentNodeID.value());
4221 
4222     ScrollCoordinationRole role = scrollCoordinationRoleForNodeType(nodeType);
4223     ScrollingNodeID nodeID = backing-&gt;scrollingNodeIDForRole(role);
<span class="line-modified">4224 </span>
<span class="line-modified">4225     nodeID = registerScrollingNodeID(*scrollingCoordinator, nodeID, nodeType, treeState);</span>
4226 
4227     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; attachScrollingNode &quot; &lt;&lt; nodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; backing-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) type &quot; &lt;&lt; nodeType &lt;&lt; &quot; parent &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
4228 
<span class="line-added">4229     if (!nodeID)</span>
<span class="line-added">4230         return 0;</span>
<span class="line-added">4231 </span>
<span class="line-added">4232     backing-&gt;setScrollingNodeIDForRole(nodeID, role);</span>
<span class="line-added">4233     m_scrollingNodeToLayerMap.add(nodeID, &amp;layer);</span>
<span class="line-added">4234 </span>
<span class="line-added">4235     return nodeID;</span>
<span class="line-added">4236 }</span>
<span class="line-added">4237 </span>
<span class="line-added">4238 ScrollingNodeID RenderLayerCompositor::registerScrollingNodeID(ScrollingCoordinator&amp; scrollingCoordinator, ScrollingNodeID nodeID, ScrollingNodeType nodeType, struct ScrollingTreeState&amp; treeState)</span>
<span class="line-added">4239 {</span>
<span class="line-added">4240     if (!nodeID)</span>
<span class="line-added">4241         nodeID = scrollingCoordinator.uniqueScrollingNodeID();</span>
<span class="line-added">4242 </span>
4243     if (nodeType == ScrollingNodeType::Subframe &amp;&amp; !treeState.parentNodeID)
<span class="line-modified">4244         nodeID = scrollingCoordinator.createNode(nodeType, nodeID);</span>
4245     else {
<span class="line-modified">4246         auto newNodeID = scrollingCoordinator.insertNode(nodeType, nodeID, treeState.parentNodeID.valueOr(0), treeState.nextChildIndex);</span>
4247         if (newNodeID != nodeID) {
4248             // We&#39;ll get a new nodeID if the type changed (and not if the node is new).
<span class="line-modified">4249             scrollingCoordinator.unparentChildrenAndDestroyNode(nodeID);</span>
4250             m_scrollingNodeToLayerMap.remove(nodeID);
4251         }
4252         nodeID = newNodeID;
4253     }
4254 
4255     ASSERT(nodeID);
4256     if (!nodeID)
4257         return 0;
4258 



4259     ++treeState.nextChildIndex;
4260     return nodeID;
4261 }
4262 
4263 void RenderLayerCompositor::detachScrollCoordinatedLayerWithRole(RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator, ScrollCoordinationRole role)
4264 {
<span class="line-added">4265     auto unregisterNode = [&amp;](ScrollingNodeID nodeID) {</span>
<span class="line-added">4266         auto childNodes = scrollingCoordinator.childrenOfNode(nodeID);</span>
<span class="line-added">4267         for (auto childNodeID : childNodes) {</span>
<span class="line-added">4268             if (auto* layer = m_scrollingNodeToLayerMap.get(childNodeID))</span>
<span class="line-added">4269                 layer-&gt;setNeedsScrollingTreeUpdate();</span>
<span class="line-added">4270         }</span>
<span class="line-added">4271 </span>
<span class="line-added">4272         m_scrollingNodeToLayerMap.remove(nodeID);</span>
<span class="line-added">4273     };</span>
<span class="line-added">4274 </span>
<span class="line-added">4275     if (role == ScrollCoordinationRole::ScrollingProxy) {</span>
<span class="line-added">4276         ASSERT(layer.isComposited());</span>
<span class="line-added">4277         auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();</span>
<span class="line-added">4278         if (!clippingStack)</span>
<span class="line-added">4279             return;</span>
<span class="line-added">4280 </span>
<span class="line-added">4281         auto&amp; stack = clippingStack-&gt;stack();</span>
<span class="line-added">4282         for (auto&amp; entry : stack) {</span>
<span class="line-added">4283             if (entry.overflowScrollProxyNodeID)</span>
<span class="line-added">4284                 unregisterNode(entry.overflowScrollProxyNodeID);</span>
<span class="line-added">4285         }</span>
<span class="line-added">4286         return;</span>
<span class="line-added">4287     }</span>
<span class="line-added">4288 </span>
4289     auto nodeID = layer.backing()-&gt;scrollingNodeIDForRole(role);
4290     if (!nodeID)
4291         return;
4292 
<span class="line-modified">4293     unregisterNode(nodeID);</span>







4294 }
4295 
4296 void RenderLayerCompositor::detachScrollCoordinatedLayer(RenderLayer&amp; layer, OptionSet&lt;ScrollCoordinationRole&gt; roles)
4297 {
4298     auto* backing = layer.backing();
4299     if (!backing)
4300         return;
4301 
4302     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4303 
4304     if (roles.contains(ScrollCoordinationRole::Scrolling))
4305         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
4306 
<span class="line-added">4307     if (roles.contains(ScrollCoordinationRole::ScrollingProxy))</span>
<span class="line-added">4308         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ScrollingProxy);</span>
<span class="line-added">4309 </span>
4310     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4311         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
4312 
4313     if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4314         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
4315 
<span class="line-added">4316     if (roles.contains(ScrollCoordinationRole::Positioning))</span>
<span class="line-added">4317         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);</span>
<span class="line-added">4318 </span>
4319     backing-&gt;detachFromScrollingCoordinator(roles);
4320 }
4321 
<span class="line-modified">4322 OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer) const</span>
<span class="line-added">4323 {</span>
<span class="line-added">4324     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;</span>
<span class="line-added">4325     if (isViewportConstrainedFixedOrStickyLayer(layer))</span>
<span class="line-added">4326         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);</span>
<span class="line-added">4327 </span>
<span class="line-added">4328     if (useCoordinatedScrollingForLayer(layer))</span>
<span class="line-added">4329         coordinationRoles.add(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">4330 </span>
<span class="line-added">4331     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer);</span>
<span class="line-added">4332     switch (coordinatedPositioning) {</span>
<span class="line-added">4333     case ScrollPositioningBehavior::Moves:</span>
<span class="line-added">4334         coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);</span>
<span class="line-added">4335         break;</span>
<span class="line-added">4336     case ScrollPositioningBehavior::Stationary:</span>
<span class="line-added">4337         coordinationRoles.add(ScrollCoordinationRole::Positioning);</span>
<span class="line-added">4338         break;</span>
<span class="line-added">4339     case ScrollPositioningBehavior::None:</span>
<span class="line-added">4340         break;</span>
<span class="line-added">4341     }</span>
<span class="line-added">4342 </span>
<span class="line-added">4343     if (isLayerForIFrameWithScrollCoordinatedContents(layer))</span>
<span class="line-added">4344         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);</span>
<span class="line-added">4345 </span>
<span class="line-added">4346     return coordinationRoles;</span>
<span class="line-added">4347 }</span>
<span class="line-added">4348 </span>
<span class="line-added">4349 ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
4350 {
<span class="line-modified">4351     auto roles = coordinatedScrollingRolesForLayer(layer);</span>
<span class="line-added">4352 </span>
4353 #if PLATFORM(IOS_FAMILY)
4354     if (m_legacyScrollingLayerCoordinator) {
<span class="line-modified">4355         if (roles.contains(ScrollCoordinationRole::ViewportConstrained))</span>
4356             m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
4357         else
4358             m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
4359     }
4360 #endif
4361 



4362     if (!hasCoordinatedScrolling()) {
4363         // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
4364         return 0;
4365     }
4366 
4367     auto newNodeID = treeState.parentNodeID.valueOr(0);
4368 
<span class="line-modified">4369     ScrollingTreeState childTreeState;</span>
4370     ScrollingTreeState* currentTreeState = &amp;treeState;
4371 
<span class="line-modified">4372     // If there&#39;s a positioning node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.</span>
<span class="line-added">4373     if (roles.contains(ScrollCoordinationRole::Positioning)) {</span>
<span class="line-added">4374         newNodeID = updateScrollingNodeForPositioningRole(layer, *currentTreeState, changes);</span>
<span class="line-added">4375         childTreeState.parentNodeID = newNodeID;</span>
<span class="line-added">4376         currentTreeState = &amp;childTreeState;</span>
<span class="line-added">4377     } else</span>
<span class="line-added">4378         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);</span>
<span class="line-added">4379 </span>
<span class="line-added">4380     // If there&#39;s a scrolling proxy node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.</span>
<span class="line-added">4381     if (roles.contains(ScrollCoordinationRole::ScrollingProxy)) {</span>
<span class="line-added">4382         newNodeID = updateScrollingNodeForScrollingProxyRole(layer, *currentTreeState, changes);</span>
<span class="line-added">4383         childTreeState.parentNodeID = newNodeID;</span>
<span class="line-added">4384         currentTreeState = &amp;childTreeState;</span>
<span class="line-added">4385     } else</span>
<span class="line-added">4386         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ScrollingProxy);</span>
<span class="line-added">4387 </span>
<span class="line-added">4388     // If is fixed or sticky, it&#39;s the parent scrolling node for scrolling/frame hosting.</span>
4389     if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
4390         newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
4391         // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
<span class="line-modified">4392         childTreeState.parentNodeID = newNodeID;</span>
<span class="line-modified">4393         currentTreeState = &amp;childTreeState;</span>
4394     } else
4395         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ViewportConstrained);
4396 
4397     if (roles.contains(ScrollCoordinationRole::Scrolling))
4398         newNodeID = updateScrollingNodeForScrollingRole(layer, *currentTreeState, changes);
4399     else
4400         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Scrolling);
4401 
4402     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4403         newNodeID = updateScrollingNodeForFrameHostingRole(layer, *currentTreeState, changes);
4404     else
4405         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::FrameHosting);
4406 
4407     return newNodeID;
4408 }
4409 
4410 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4411 {
4412     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4413 
4414     auto nodeType = ScrollingNodeType::Fixed;
4415     if (layer.renderer().style().position() == PositionType::Sticky)
4416         nodeType = ScrollingNodeType::Sticky;
4417     else
4418         ASSERT(layer.renderer().isFixedPositioned());
4419 
4420     auto newNodeID = attachScrollingNode(layer, nodeType, treeState);
4421     if (!newNodeID) {
4422         ASSERT_NOT_REACHED();
4423         return treeState.parentNodeID.valueOr(0);
4424     }
4425 
4426     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Registering ViewportConstrained &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) as child of &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
4427 
4428     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4429         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4430 
4431     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4432         switch (nodeType) {
4433         case ScrollingNodeType::Fixed:
<span class="line-modified">4434             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeFixedViewportConstraints(layer));</span>
4435             break;
4436         case ScrollingNodeType::Sticky:
<span class="line-modified">4437             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeStickyViewportConstraints(layer));</span>
4438             break;
<span class="line-modified">4439         default:</span>



4440             break;
4441         }
4442     }
4443 
4444     return newNodeID;
4445 }
4446 
<span class="line-modified">4447 LayoutRect RenderLayerCompositor::rootParentRelativeScrollableRect() const</span>
4448 {
4449     auto&amp; frameView = m_renderView.frameView();
4450 
4451     if (m_renderView.frame().isMainFrame())
<span class="line-modified">4452         return frameView.frameRect();</span>


4453 
<span class="line-modified">4454     return LayoutRect({ }, LayoutSize(frameView.size()));</span>







4455 }
4456 
<span class="line-modified">4457 LayoutRect RenderLayerCompositor::parentRelativeScrollableRect(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const</span>
4458 {
4459     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
<span class="line-modified">4460     if (!ancestorLayer)</span>
<span class="line-modified">4461         return LayoutRect({ }, LayoutSize(layer.visibleSize()));</span>


4462 
<span class="line-modified">4463     LayoutRect scrollableRect;</span>
<span class="line-modified">4464     if (is&lt;RenderBox&gt;(layer.renderer()))</span>
<span class="line-modified">4465         scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();</span>
<span class="line-modified">4466 </span>
<span class="line-added">4467     auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.</span>
<span class="line-added">4468     scrollableRect.setLocation(offset);</span>
<span class="line-added">4469     return scrollableRect;</span>
4470 }
4471 
<span class="line-modified">4472 void RenderLayerCompositor::updateScrollingNodeLayers(ScrollingNodeID nodeID, RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator)</span>
4473 {
<span class="line-modified">4474     if (layer.isRenderViewLayer()) {</span>
<span class="line-modified">4475         FrameView&amp; frameView = m_renderView.frameView();</span>
<span class="line-modified">4476         scrollingCoordinator.setNodeLayers(nodeID, { nullptr,</span>
<span class="line-modified">4477             scrollContainerLayer(), scrolledContentsLayer(),</span>
<span class="line-modified">4478             fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer(),</span>
<span class="line-modified">4479             frameView.layerForHorizontalScrollbar(), frameView.layerForVerticalScrollbar() });</span>
<span class="line-modified">4480     } else {</span>
<span class="line-modified">4481         auto&amp; backing = *layer.backing();</span>
<span class="line-modified">4482         scrollingCoordinator.setNodeLayers(nodeID, { backing.graphicsLayer(),</span>
<span class="line-added">4483             backing.scrollContainerLayer(), backing.scrolledContentsLayer(),</span>
<span class="line-added">4484             nullptr, nullptr, nullptr,</span>
<span class="line-added">4485             layer.layerForHorizontalScrollbar(), layer.layerForVerticalScrollbar() });</span>
4486     }


















4487 }
4488 
4489 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4490 {
4491     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4492 
4493     ScrollingNodeID newNodeID = 0;
4494 
4495     if (layer.isRenderViewLayer()) {
4496         FrameView&amp; frameView = m_renderView.frameView();
4497         ASSERT_UNUSED(frameView, scrollingCoordinator-&gt;coordinatesScrollingForFrameView(frameView));
4498 
4499         newNodeID = attachScrollingNode(*m_renderView.layer(), m_renderView.frame().isMainFrame() ? ScrollingNodeType::MainFrame : ScrollingNodeType::Subframe, treeState);
4500 
4501         if (!newNodeID) {
4502             ASSERT_NOT_REACHED();
4503             return treeState.parentNodeID.valueOr(0);
4504         }
4505 
4506         if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">4507             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);</span>
4508 
4509         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
<span class="line-modified">4510             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, rootParentRelativeScrollableRect());</span>
<span class="line-modified">4511             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, frameView);</span>
<span class="line-modified">4512             scrollingCoordinator-&gt;setFrameScrollingNodeState(newNodeID, frameView);</span>
4513         }
4514     } else {
4515         newNodeID = attachScrollingNode(layer, ScrollingNodeType::Overflow, treeState);
4516         if (!newNodeID) {
4517             ASSERT_NOT_REACHED();
4518             return treeState.parentNodeID.valueOr(0);
4519         }
4520 
4521         if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">4522             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);</span>
4523 
4524         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4525             RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">4526             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));</span>
<span class="line-modified">4527             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, layer);</span>

4528         }
4529     }
4530 
4531     return newNodeID;
4532 }
4533 
<span class="line-added">4534 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingProxyRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
<span class="line-added">4535 {</span>
<span class="line-added">4536     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();</span>
<span class="line-added">4537     auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();</span>
<span class="line-added">4538     if (!clippingStack) {</span>
<span class="line-added">4539         ASSERT_NOT_REACHED();</span>
<span class="line-added">4540         return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">4541     }</span>
<span class="line-added">4542 </span>
<span class="line-added">4543     ScrollingNodeID nodeID = 0;</span>
<span class="line-added">4544     for (auto&amp; entry : clippingStack-&gt;stack()) {</span>
<span class="line-added">4545         if (!entry.clipData.isOverflowScroll)</span>
<span class="line-added">4546             continue;</span>
<span class="line-added">4547 </span>
<span class="line-added">4548         nodeID = registerScrollingNodeID(*scrollingCoordinator, entry.overflowScrollProxyNodeID, ScrollingNodeType::OverflowProxy, treeState);</span>
<span class="line-added">4549         if (!nodeID) {</span>
<span class="line-added">4550             ASSERT_NOT_REACHED();</span>
<span class="line-added">4551             return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">4552         }</span>
<span class="line-added">4553         entry.overflowScrollProxyNodeID = nodeID;</span>
<span class="line-added">4554 </span>
<span class="line-added">4555         if (changes &amp; ScrollingNodeChangeFlags::Layer)</span>
<span class="line-added">4556             scrollingCoordinator-&gt;setNodeLayers(entry.overflowScrollProxyNodeID, { entry.clippingLayer.get() });</span>
<span class="line-added">4557 </span>
<span class="line-added">4558         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {</span>
<span class="line-added">4559             ASSERT(entry.clipData.clippingLayer);</span>
<span class="line-added">4560             ASSERT(entry.clipData.clippingLayer-&gt;isComposited());</span>
<span class="line-added">4561 </span>
<span class="line-added">4562             ScrollingNodeID overflowScrollNodeID = 0;</span>
<span class="line-added">4563             if (auto* backing = entry.clipData.clippingLayer-&gt;backing())</span>
<span class="line-added">4564                 overflowScrollNodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">4565 </span>
<span class="line-added">4566             Vector&lt;ScrollingNodeID&gt; scrollingNodeIDs;</span>
<span class="line-added">4567             if (overflowScrollNodeID)</span>
<span class="line-added">4568                 scrollingNodeIDs.append(overflowScrollNodeID);</span>
<span class="line-added">4569             scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(entry.overflowScrollProxyNodeID, WTFMove(scrollingNodeIDs));</span>
<span class="line-added">4570         }</span>
<span class="line-added">4571     }</span>
<span class="line-added">4572 </span>
<span class="line-added">4573     if (!nodeID)</span>
<span class="line-added">4574         return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">4575 </span>
<span class="line-added">4576     return nodeID;</span>
<span class="line-added">4577 }</span>
<span class="line-added">4578 </span>
4579 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForFrameHostingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4580 {
4581     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4582 
4583     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
4584     if (!newNodeID) {
4585         ASSERT_NOT_REACHED();
4586         return treeState.parentNodeID.valueOr(0);
4587     }
4588 
4589     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4590         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4591 
4592     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4593         RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">4594         scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));</span>
<span class="line-modified">4595     }</span>
<span class="line-modified">4596 </span>
<span class="line-added">4597     return newNodeID;</span>
<span class="line-added">4598 }</span>
<span class="line-added">4599 </span>
<span class="line-added">4600 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
<span class="line-added">4601 {</span>
<span class="line-added">4602     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();</span>
<span class="line-added">4603 </span>
<span class="line-added">4604     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);</span>
<span class="line-added">4605     if (!newNodeID) {</span>
<span class="line-added">4606         ASSERT_NOT_REACHED();</span>
<span class="line-added">4607         return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">4608     }</span>
<span class="line-added">4609 </span>
<span class="line-added">4610     if (changes &amp; ScrollingNodeChangeFlags::Layer) {</span>
<span class="line-added">4611         auto&amp; backing = *layer.backing();</span>
<span class="line-added">4612         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { backing.graphicsLayer() });</span>
<span class="line-added">4613     }</span>
<span class="line-added">4614 </span>
<span class="line-added">4615     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {</span>
<span class="line-added">4616         // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.</span>
<span class="line-added">4617         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer);</span>
<span class="line-added">4618         auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);</span>
<span class="line-added">4619         scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));</span>
<span class="line-added">4620 </span>
<span class="line-added">4621         auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();</span>
<span class="line-added">4622         AbsolutePositionConstraints constraints;</span>
<span class="line-added">4623         constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());</span>
<span class="line-added">4624         constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());</span>
<span class="line-added">4625         scrollingCoordinator-&gt;setPositionedNodeConstraints(newNodeID, constraints);</span>
4626     }
4627 
4628     return newNodeID;
4629 }
4630 
4631 ScrollableArea* RenderLayerCompositor::scrollableAreaForScrollLayerID(ScrollingNodeID nodeID) const
4632 {
4633     if (!nodeID)
4634         return nullptr;
4635 
4636     return m_scrollingNodeToLayerMap.get(nodeID);
4637 }
4638 
4639 void RenderLayerCompositor::willRemoveScrollingLayerWithBacking(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4640 {
4641     if (scrollingCoordinator())
4642         return;
4643 
4644 #if PLATFORM(IOS_FAMILY)
4645     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
</pre>
<hr />
<pre>
4673 }
4674 
4675 ScrollingCoordinator* RenderLayerCompositor::scrollingCoordinator() const
4676 {
4677     return page().scrollingCoordinator();
4678 }
4679 
4680 GraphicsLayerFactory* RenderLayerCompositor::graphicsLayerFactory() const
4681 {
4682     return page().chrome().client().graphicsLayerFactory();
4683 }
4684 
4685 void RenderLayerCompositor::setLayerFlushThrottlingEnabled(bool enabled)
4686 {
4687     m_layerFlushThrottlingEnabled = enabled;
4688     if (m_layerFlushThrottlingEnabled)
4689         return;
4690     m_layerFlushTimer.stop();
4691     if (!m_hasPendingLayerFlush)
4692         return;
<span class="line-modified">4693     scheduleLayerFlush();</span>
4694 }
4695 
4696 void RenderLayerCompositor::disableLayerFlushThrottlingTemporarilyForInteraction()
4697 {
4698     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4699         return;
4700     m_layerFlushThrottlingTemporarilyDisabledForInteraction = true;
4701 }
4702 
4703 bool RenderLayerCompositor::isThrottlingLayerFlushes() const
4704 {
4705     if (!m_layerFlushThrottlingEnabled)
4706         return false;
4707     if (!m_layerFlushTimer.isActive())
4708         return false;
4709     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4710         return false;
4711     return true;
4712 }
4713 
</pre>
<hr />
<pre>
4716     m_layerFlushThrottlingTemporarilyDisabledForInteraction = false;
4717     m_layerFlushTimer.stop();
4718     if (!m_layerFlushThrottlingEnabled)
4719         return;
4720     m_layerFlushTimer.startOneShot(throttledLayerFlushDelay);
4721 }
4722 
4723 void RenderLayerCompositor::startInitialLayerFlushTimerIfNeeded()
4724 {
4725     if (!m_layerFlushThrottlingEnabled)
4726         return;
4727     if (m_layerFlushTimer.isActive())
4728         return;
4729     m_layerFlushTimer.startOneShot(throttledLayerFlushInitialDelay);
4730 }
4731 
4732 void RenderLayerCompositor::layerFlushTimerFired()
4733 {
4734     if (!m_hasPendingLayerFlush)
4735         return;
<span class="line-modified">4736     scheduleLayerFlush();</span>
4737 }
4738 
4739 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
4740 RefPtr&lt;DisplayRefreshMonitor&gt; RenderLayerCompositor::createDisplayRefreshMonitor(PlatformDisplayID displayID) const
4741 {
4742     if (auto monitor = page().chrome().client().createDisplayRefreshMonitor(displayID))
4743         return monitor;
4744 
4745     return DisplayRefreshMonitor::createDefaultDisplayRefreshMonitor(displayID);
4746 }
4747 #endif
4748 
4749 #if ENABLE(CSS_SCROLL_SNAP)
4750 void RenderLayerCompositor::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView) const
4751 {
4752     if (auto* coordinator = scrollingCoordinator())
4753         coordinator-&gt;updateScrollSnapPropertiesWithFrameView(frameView);
4754 }
4755 #endif
4756 
</pre>
<hr />
<pre>
4779     return ts;
4780 }
4781 
4782 #if PLATFORM(IOS_FAMILY)
4783 typedef HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt; LayerMap;
4784 typedef HashMap&lt;PlatformLayer*, PlatformLayer*&gt; StickyContainerMap;
4785 
4786 void LegacyWebKitScrollingLayerCoordinator::registerAllViewportConstrainedLayers(RenderLayerCompositor&amp; compositor)
4787 {
4788     if (!m_coordinateViewportConstrainedLayers)
4789         return;
4790 
4791     LayerMap layerMap;
4792     StickyContainerMap stickyContainerMap;
4793 
4794     for (auto* layer : m_viewportConstrainedLayers) {
4795         ASSERT(layer-&gt;isComposited());
4796 
4797         std::unique_ptr&lt;ViewportConstraints&gt; constraints;
4798         if (layer-&gt;renderer().isStickilyPositioned()) {
<span class="line-modified">4799             constraints = makeUnique&lt;StickyPositionViewportConstraints&gt;(compositor.computeStickyViewportConstraints(*layer));</span>
4800             const RenderLayer* enclosingTouchScrollableLayer = nullptr;
4801             if (compositor.isAsyncScrollableStickyLayer(*layer, &amp;enclosingTouchScrollableLayer) &amp;&amp; enclosingTouchScrollableLayer) {
4802                 ASSERT(enclosingTouchScrollableLayer-&gt;isComposited());
4803                 // what
4804                 stickyContainerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), enclosingTouchScrollableLayer-&gt;backing()-&gt;scrollContainerLayer()-&gt;platformLayer());
4805             }
4806         } else if (layer-&gt;renderer().isFixedPositioned())
<span class="line-modified">4807             constraints = makeUnique&lt;FixedPositionViewportConstraints&gt;(compositor.computeFixedViewportConstraints(*layer));</span>
4808         else
4809             continue;
4810 
4811         layerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), WTFMove(constraints));
4812     }
4813 
4814     m_chromeClient.updateViewportConstrainedLayers(layerMap, stickyContainerMap);
4815 }
4816 
4817 void LegacyWebKitScrollingLayerCoordinator::unregisterAllViewportConstrainedLayers()
4818 {
4819     if (!m_coordinateViewportConstrainedLayers)
4820         return;
4821 
4822     LayerMap layerMap;
4823     m_chromeClient.updateViewportConstrainedLayers(layerMap, { });
4824 }
4825 









4826 void LegacyWebKitScrollingLayerCoordinator::updateScrollingLayer(RenderLayer&amp; layer)
4827 {
4828     auto* backing = layer.backing();
4829     ASSERT(backing);
4830 
<span class="line-modified">4831     bool allowHorizontalScrollbar = !layer.horizontalScrollbarHiddenByStyle();</span>
<span class="line-modified">4832     bool allowVerticalScrollbar = !layer.verticalScrollbarHiddenByStyle();</span>
<span class="line-added">4833 </span>
4834     m_chromeClient.addOrUpdateScrollingLayer(layer.renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer(),
<span class="line-modified">4835         layer.reachableTotalContentsSize(), allowHorizontalScrollbar, allowVerticalScrollbar);</span>
4836 }
4837 
4838 void LegacyWebKitScrollingLayerCoordinator::registerAllScrollingLayers()
4839 {
4840     for (auto* layer : m_scrollingLayers)
4841         updateScrollingLayer(*layer);
4842 }
4843 








4844 void LegacyWebKitScrollingLayerCoordinator::unregisterAllScrollingLayers()
4845 {
4846     for (auto* layer : m_scrollingLayers) {
4847         auto* backing = layer-&gt;backing();
4848         ASSERT(backing);
4849         m_chromeClient.removeScrollingLayer(layer-&gt;renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer());
4850     }
4851 }
4852 
4853 void LegacyWebKitScrollingLayerCoordinator::addScrollingLayer(RenderLayer&amp; layer)
4854 {
4855     m_scrollingLayers.add(&amp;layer);

4856 }
4857 
4858 void LegacyWebKitScrollingLayerCoordinator::removeScrollingLayer(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4859 {

4860     if (m_scrollingLayers.remove(&amp;layer)) {
4861         auto* scrollContainerLayer = backing.scrollContainerLayer()-&gt;platformLayer();
4862         auto* scrolledContentsLayer = backing.scrolledContentsLayer()-&gt;platformLayer();
4863         m_chromeClient.removeScrollingLayer(layer.renderer().element(), scrollContainerLayer, scrolledContentsLayer);
4864     }
4865 }
4866 
4867 void LegacyWebKitScrollingLayerCoordinator::removeLayer(RenderLayer&amp; layer)
4868 {
4869     removeScrollingLayer(layer, *layer.backing());
4870 
4871     // We&#39;ll put the new set of layers to the client via registerAllViewportConstrainedLayers() at flush time.
4872     m_viewportConstrainedLayers.remove(&amp;layer);
4873 }
4874 
4875 void LegacyWebKitScrollingLayerCoordinator::addViewportConstrainedLayer(RenderLayer&amp; layer)
4876 {
4877     m_viewportConstrainedLayers.add(&amp;layer);
4878 }
4879 
4880 void LegacyWebKitScrollingLayerCoordinator::removeViewportConstrainedLayer(RenderLayer&amp; layer)
4881 {
4882     m_viewportConstrainedLayers.remove(&amp;layer);
4883 }
4884 






4885 #endif
4886 
4887 } // namespace WebCore
4888 
4889 #if ENABLE(TREE_DEBUGGING)
4890 void showGraphicsLayerTreeForCompositor(WebCore::RenderLayerCompositor&amp; compositor)
4891 {
4892     showGraphicsLayerTree(compositor.rootGraphicsLayer());
4893 }
4894 #endif
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerBacking.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>