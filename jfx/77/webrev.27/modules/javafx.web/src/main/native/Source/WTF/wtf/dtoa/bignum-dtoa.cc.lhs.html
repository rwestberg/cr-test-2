<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/bignum-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2010 the V8 project authors. All rights reserved.
  2 // Redistribution and use in source and binary forms, with or without
  3 // modification, are permitted provided that the following conditions are
  4 // met:
  5 //
  6 //     * Redistributions of source code must retain the above copyright
  7 //       notice, this list of conditions and the following disclaimer.
  8 //     * Redistributions in binary form must reproduce the above
  9 //       copyright notice, this list of conditions and the following
 10 //       disclaimer in the documentation and/or other materials provided
 11 //       with the distribution.
 12 //     * Neither the name of Google Inc. nor the names of its
 13 //       contributors may be used to endorse or promote products derived
 14 //       from this software without specific prior written permission.
 15 //
 16 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27 
 28 #include &quot;config.h&quot;
 29 
 30 #include &lt;cmath&gt;
 31 
 32 #include &lt;wtf/dtoa/bignum-dtoa.h&gt;
 33 
 34 #include &lt;wtf/dtoa/bignum.h&gt;
 35 #include &lt;wtf/dtoa/ieee.h&gt;
 36 
 37 namespace WTF {
 38 namespace double_conversion {
<a name="1" id="anc1"></a><span class="line-modified"> 39     </span>
 40 static int NormalizedExponent(uint64_t significand, int exponent) {
<a name="2" id="anc2"></a><span class="line-modified"> 41         ASSERT(significand != 0);</span>
<span class="line-modified"> 42         while ((significand &amp; Double::kHiddenBit) == 0) {</span>
<span class="line-modified"> 43             significand = significand &lt;&lt; 1;</span>
<span class="line-modified"> 44             exponent = exponent - 1;</span>
<span class="line-modified"> 45         }</span>
<span class="line-modified"> 46         return exponent;</span>
 47 }
<a name="3" id="anc3"></a><span class="line-modified"> 48     </span>
<span class="line-modified"> 49     </span>
 50 // Forward declarations:
 51 // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k.
 52 static int EstimatePower(int exponent);
 53 // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
 54 // and denominator.
 55 static void InitialScaledStartValues(uint64_t significand,
 56                                      int exponent,
 57                                      bool lower_boundary_is_closer,
<a name="4" id="anc4"></a><span class="line-modified"> 58                                          int estimated_power,</span>
<span class="line-modified"> 59                                          bool need_boundary_deltas,</span>
<span class="line-modified"> 60                                          Bignum* numerator,</span>
<span class="line-modified"> 61                                          Bignum* denominator,</span>
<span class="line-modified"> 62                                          Bignum* delta_minus,</span>
<span class="line-modified"> 63                                          Bignum* delta_plus);</span>
 64 // Multiplies numerator/denominator so that its values lies in the range 1-10.
 65 // Returns decimal_point s.t.
 66 //  v = numerator&#39;/denominator&#39; * 10^(decimal_point-1)
 67 //     where numerator&#39; and denominator&#39; are the values of numerator and
 68 //     denominator after the call to this function.
 69 static void FixupMultiply10(int estimated_power, bool is_even,
<a name="5" id="anc5"></a><span class="line-modified"> 70                                 int* decimal_point,</span>
<span class="line-modified"> 71                                 Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified"> 72                                 Bignum* delta_minus, Bignum* delta_plus);</span>
 73 // Generates digits from the left to the right and stops when the generated
 74 // digits yield the shortest decimal representation of v.
 75 static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<a name="6" id="anc6"></a><span class="line-modified"> 76                                        Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="line-modified"> 77                                        bool is_even,</span>
<span class="line-modified"> 78                                        BufferReference&lt;char&gt; buffer, int* length);</span>
 79 // Generates &#39;requested_digits&#39; after the decimal point.
 80 static void BignumToFixed(int requested_digits, int* decimal_point,
<a name="7" id="anc7"></a><span class="line-modified"> 81                               Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified"> 82                               BufferReference&lt;char&gt;(buffer), int* length);</span>
 83 // Generates &#39;count&#39; digits of numerator/denominator.
 84 // Once &#39;count&#39; digits have been produced rounds the result depending on the
 85 // remainder (remainders of exactly .5 round upwards). Might update the
 86 // decimal_point when rounding up (for example for 0.9999).
 87 static void GenerateCountedDigits(int count, int* decimal_point,
<a name="8" id="anc8"></a><span class="line-modified"> 88                                       Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified"> 89                                       BufferReference&lt;char&gt;(buffer), int* length);</span>
<span class="line-modified"> 90     </span>
<span class="line-modified"> 91     </span>
 92 void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
<a name="9" id="anc9"></a><span class="line-modified"> 93                     BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {</span>
<span class="line-modified"> 94         ASSERT(v &gt; 0);</span>
<span class="line-modified"> 95         ASSERT(!Double(v).IsSpecial());</span>
 96   uint64_t significand;
 97   int exponent;
 98   bool lower_boundary_is_closer;
 99   if (mode == BIGNUM_DTOA_SHORTEST_SINGLE) {
100     float f = static_cast&lt;float&gt;(v);
101     ASSERT(f == v);
102     significand = Single(f).Significand();
103     exponent = Single(f).Exponent();
104     lower_boundary_is_closer = Single(f).LowerBoundaryIsCloser();
105   } else {
106     significand = Double(v).Significand();
107     exponent = Double(v).Exponent();
108     lower_boundary_is_closer = Double(v).LowerBoundaryIsCloser();
109   }
110   bool need_boundary_deltas =
111       (mode == BIGNUM_DTOA_SHORTEST || mode == BIGNUM_DTOA_SHORTEST_SINGLE);
112 
<a name="10" id="anc10"></a><span class="line-modified">113         bool is_even = (significand &amp; 1) == 0;</span>
<span class="line-modified">114         int normalized_exponent = NormalizedExponent(significand, exponent);</span>
<span class="line-modified">115         // estimated_power might be too low by 1.</span>
<span class="line-modified">116         int estimated_power = EstimatePower(normalized_exponent);</span>
<span class="line-modified">117         </span>
<span class="line-modified">118         // Shortcut for Fixed.</span>
<span class="line-modified">119         // The requested digits correspond to the digits after the point. If the</span>
<span class="line-modified">120         // number is much too small, then there is no need in trying to get any</span>
<span class="line-modified">121         // digits.</span>
<span class="line-modified">122         if (mode == BIGNUM_DTOA_FIXED &amp;&amp; -estimated_power - 1 &gt; requested_digits) {</span>
<span class="line-modified">123             buffer[0] = &#39;\0&#39;;</span>
<span class="line-modified">124             *length = 0;</span>
<span class="line-modified">125             // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="line-modified">126             // Note that it should not have any effect anyways since the string is</span>
<span class="line-modified">127             // empty.</span>
<span class="line-modified">128             *decimal_point = -requested_digits;</span>
<span class="line-modified">129             return;</span>
<span class="line-modified">130         }</span>
<span class="line-modified">131         </span>
<span class="line-modified">132         Bignum numerator;</span>
<span class="line-modified">133         Bignum denominator;</span>
<span class="line-modified">134         Bignum delta_minus;</span>
<span class="line-modified">135         Bignum delta_plus;</span>
<span class="line-modified">136         // Make sure the bignum can grow large enough. The smallest double equals</span>
<span class="line-modified">137         // 4e-324. In this case the denominator needs fewer than 324*4 binary digits.</span>
<span class="line-modified">138         // The maximum double is 1.7976931348623157e308 which needs fewer than</span>
<span class="line-modified">139         // 308*4 binary digits.</span>
<span class="line-modified">140         ASSERT(Bignum::kMaxSignificantBits &gt;= 324*4);</span>
141   InitialScaledStartValues(significand, exponent, lower_boundary_is_closer,
142                            estimated_power, need_boundary_deltas,
<a name="11" id="anc11"></a><span class="line-modified">143                                  &amp;numerator, &amp;denominator,</span>
<span class="line-modified">144                                  &amp;delta_minus, &amp;delta_plus);</span>
<span class="line-modified">145         // We now have v = (numerator / denominator) * 10^estimated_power.</span>
<span class="line-modified">146         FixupMultiply10(estimated_power, is_even, decimal_point,</span>
<span class="line-modified">147                         &amp;numerator, &amp;denominator,</span>
<span class="line-modified">148                         &amp;delta_minus, &amp;delta_plus);</span>
<span class="line-modified">149         // We now have v = (numerator / denominator) * 10^(decimal_point-1), and</span>
<span class="line-modified">150         //  1 &lt;= (numerator + delta_plus) / denominator &lt; 10</span>
<span class="line-modified">151         switch (mode) {</span>
<span class="line-modified">152             case BIGNUM_DTOA_SHORTEST:</span>
153     case BIGNUM_DTOA_SHORTEST_SINGLE:
<a name="12" id="anc12"></a><span class="line-modified">154                 GenerateShortestDigits(&amp;numerator, &amp;denominator,</span>
<span class="line-modified">155                                        &amp;delta_minus, &amp;delta_plus,</span>
<span class="line-modified">156                                        is_even, buffer, length);</span>
<span class="line-modified">157                 break;</span>
<span class="line-modified">158             case BIGNUM_DTOA_FIXED:</span>
<span class="line-modified">159                 BignumToFixed(requested_digits, decimal_point,</span>
<span class="line-modified">160                               &amp;numerator, &amp;denominator,</span>
<span class="line-modified">161                               buffer, length);</span>
<span class="line-modified">162                 break;</span>
<span class="line-modified">163             case BIGNUM_DTOA_PRECISION:</span>
<span class="line-modified">164                 GenerateCountedDigits(requested_digits, decimal_point,</span>
<span class="line-modified">165                                       &amp;numerator, &amp;denominator,</span>
<span class="line-modified">166                                       buffer, length);</span>
<span class="line-modified">167                 break;</span>
<span class="line-modified">168             default:</span>
<span class="line-modified">169                 UNREACHABLE();</span>
<span class="line-modified">170         }</span>
<span class="line-modified">171         buffer[*length] = &#39;\0&#39;;</span>
172 }
<a name="13" id="anc13"></a><span class="line-modified">173     </span>
<span class="line-modified">174     </span>
175 // The procedure starts generating digits from the left to the right and stops
176 // when the generated digits yield the shortest decimal representation of v. A
177 // decimal representation of v is a number lying closer to v than to any other
178 // double, so it converts to v when read.
179 //
180 // This is true if d, the decimal representation, is between m- and m+, the
181 // upper and lower boundaries. d must be strictly between them if !is_even.
182 //           m- := (numerator - delta_minus) / denominator
183 //           m+ := (numerator + delta_plus) / denominator
184 //
185 // Precondition: 0 &lt;= (numerator+delta_plus) / denominator &lt; 10.
186 //   If 1 &lt;= (numerator+delta_plus) / denominator &lt; 10 then no leading 0 digit
187 //   will be produced. This should be the standard precondition.
188 static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<a name="14" id="anc14"></a><span class="line-modified">189                                        Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="line-modified">190                                        bool is_even,</span>
<span class="line-modified">191                                        BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">192         // Small optimization: if delta_minus and delta_plus are the same just reuse</span>
<span class="line-modified">193         // one of the two bignums.</span>
<span class="line-modified">194         if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="line-modified">195             delta_plus = delta_minus;</span>
<span class="line-modified">196         }</span>
<span class="line-modified">197         *length = 0;</span>
198   for (;;) {
<a name="15" id="anc15"></a><span class="line-modified">199             uint16_t digit;</span>
<span class="line-modified">200             digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">201             ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="line-modified">202             // digit = numerator / denominator (integer division).</span>
<span class="line-modified">203             // numerator = numerator % denominator.</span>
204     buffer[(*length)++] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<a name="16" id="anc16"></a><span class="line-modified">205             </span>
<span class="line-modified">206             // Can we stop already?</span>
<span class="line-modified">207             // If the remainder of the division is less than the distance to the lower</span>
<span class="line-modified">208             // boundary we can stop. In this case we simply round down (discarding the</span>
<span class="line-modified">209             // remainder).</span>
<span class="line-modified">210             // Similarly we test if we can round up (using the upper boundary).</span>
<span class="line-modified">211             bool in_delta_room_minus;</span>
<span class="line-modified">212             bool in_delta_room_plus;</span>
<span class="line-modified">213             if (is_even) {</span>
<span class="line-modified">214                 in_delta_room_minus = Bignum::LessEqual(*numerator, *delta_minus);</span>
<span class="line-modified">215             } else {</span>
<span class="line-modified">216                 in_delta_room_minus = Bignum::Less(*numerator, *delta_minus);</span>
<span class="line-modified">217             }</span>
<span class="line-modified">218             if (is_even) {</span>
<span class="line-modified">219                 in_delta_room_plus =</span>
<span class="line-modified">220                 Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="line-modified">221             } else {</span>
<span class="line-modified">222                 in_delta_room_plus =</span>
<span class="line-modified">223                 Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="line-modified">224             }</span>
<span class="line-modified">225             if (!in_delta_room_minus &amp;&amp; !in_delta_room_plus) {</span>
<span class="line-modified">226                 // Prepare for next iteration.</span>
<span class="line-modified">227                 numerator-&gt;Times10();</span>
<span class="line-modified">228                 delta_minus-&gt;Times10();</span>
<span class="line-modified">229                 // We optimized delta_plus to be equal to delta_minus (if they share the</span>
<span class="line-modified">230                 // same value). So don&#39;t multiply delta_plus if they point to the same</span>
<span class="line-modified">231                 // object.</span>
<span class="line-modified">232                 if (delta_minus != delta_plus) {</span>
<span class="line-modified">233                     delta_plus-&gt;Times10();</span>
<span class="line-modified">234                 }</span>
<span class="line-modified">235             } else if (in_delta_room_minus &amp;&amp; in_delta_room_plus) {</span>
<span class="line-modified">236                 // Let&#39;s see if 2*numerator &lt; denominator.</span>
<span class="line-modified">237                 // If yes, then the next digit would be &lt; 5 and we can round down.</span>
<span class="line-modified">238                 int compare = Bignum::PlusCompare(*numerator, *numerator, *denominator);</span>
<span class="line-modified">239                 if (compare &lt; 0) {</span>
<span class="line-modified">240                     // Remaining digits are less than .5. -&gt; Round down (== do nothing).</span>
<span class="line-modified">241                 } else if (compare &gt; 0) {</span>
<span class="line-modified">242                     // Remaining digits are more than .5 of denominator. -&gt; Round up.</span>
<span class="line-modified">243                     // Note that the last digit could not be a &#39;9&#39; as otherwise the whole</span>
<span class="line-modified">244                     // loop would have stopped earlier.</span>
<span class="line-modified">245                     // We still have an assert here in case the preconditions were not</span>
<span class="line-modified">246                     // satisfied.</span>
<span class="line-modified">247                     ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="line-modified">248                     buffer[(*length) - 1]++;</span>
<span class="line-modified">249                 } else {</span>
<span class="line-modified">250                     // Halfway case.</span>
<span class="line-modified">251                     // TODO(floitsch): need a way to solve half-way cases.</span>
<span class="line-modified">252                     //   For now let&#39;s round towards even (since this is what Gay seems to</span>
<span class="line-modified">253                     //   do).</span>
<span class="line-modified">254                     </span>
<span class="line-modified">255                     if ((buffer[(*length) - 1] - &#39;0&#39;) % 2 == 0) {</span>
<span class="line-modified">256                         // Round down =&gt; Do nothing.</span>
<span class="line-modified">257                     } else {</span>
<span class="line-modified">258                         ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="line-modified">259                         buffer[(*length) - 1]++;</span>
<span class="line-removed">260                     }</span>
<span class="line-removed">261                 }</span>
<span class="line-removed">262                 return;</span>
<span class="line-removed">263             } else if (in_delta_room_minus) {</span>
<span class="line-removed">264                 // Round down (== do nothing).</span>
<span class="line-removed">265                 return;</span>
<span class="line-removed">266             } else {  // in_delta_room_plus</span>
<span class="line-removed">267                 // Round up.</span>
<span class="line-removed">268                 // Note again that the last digit could not be &#39;9&#39; since this would have</span>
<span class="line-removed">269                 // stopped the loop earlier.</span>
<span class="line-removed">270                 // We still have an ASSERT here, in case the preconditions were not</span>
<span class="line-removed">271                 // satisfied.</span>
<span class="line-removed">272                 ASSERT(buffer[(*length) -1] != &#39;9&#39;);</span>
<span class="line-removed">273                 buffer[(*length) - 1]++;</span>
<span class="line-removed">274                 return;</span>
<span class="line-removed">275             }</span>
276         }
<a name="17" id="anc17"></a>















277 }
<a name="18" id="anc18"></a><span class="line-modified">278     </span>
<span class="line-modified">279     </span>
280 // Let v = numerator / denominator &lt; 10.
281 // Then we generate &#39;count&#39; digits of d = x.xxxxx... (without the decimal point)
282 // from left to right. Once &#39;count&#39; digits have been produced we decide wether
283 // to round up or down. Remainders of exactly .5 round upwards. Numbers such
284 // as 9.999999 propagate a carry all the way, and change the
285 // exponent (decimal_point), when rounding upwards.
286 static void GenerateCountedDigits(int count, int* decimal_point,
<a name="19" id="anc19"></a><span class="line-modified">287                                       Bignum* numerator, Bignum* denominator,</span>
288                                   BufferReference&lt;char&gt; buffer, int* length) {
<a name="20" id="anc20"></a><span class="line-modified">289         ASSERT(count &gt;= 0);</span>
<span class="line-modified">290         for (int i = 0; i &lt; count - 1; ++i) {</span>
<span class="line-modified">291             uint16_t digit;</span>
<span class="line-modified">292             digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">293             ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="line-modified">294             // digit = numerator / denominator (integer division).</span>
<span class="line-modified">295             // numerator = numerator % denominator.</span>
296     buffer[i] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<a name="21" id="anc21"></a><span class="line-modified">297             // Prepare for next iteration.</span>
<span class="line-modified">298             numerator-&gt;Times10();</span>
<span class="line-modified">299         }</span>
<span class="line-modified">300         // Generate the last digit.</span>
<span class="line-modified">301         uint16_t digit;</span>
<span class="line-modified">302         digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">303         if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="line-modified">304             digit++;</span>
<span class="line-modified">305         }</span>
306   ASSERT(digit &lt;= 10);
307   buffer[count - 1] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<a name="22" id="anc22"></a><span class="line-modified">308         // Correct bad digits (in case we had a sequence of &#39;9&#39;s). Propagate the</span>
<span class="line-modified">309         // carry until we hat a non-&#39;9&#39; or til we reach the first digit.</span>
<span class="line-modified">310         for (int i = count - 1; i &gt; 0; --i) {</span>
<span class="line-modified">311             if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="line-modified">312             buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">313             buffer[i - 1]++;</span>
<span class="line-modified">314         }</span>
<span class="line-modified">315         if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">316             // Propagate a carry past the top place.</span>
<span class="line-modified">317             buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">318             (*decimal_point)++;</span>
<span class="line-modified">319         }</span>
<span class="line-modified">320         *length = count;</span>
321 }
<a name="23" id="anc23"></a><span class="line-modified">322     </span>
<span class="line-modified">323     </span>
324 // Generates &#39;requested_digits&#39; after the decimal point. It might omit
325 // trailing &#39;0&#39;s. If the input number is too small then no digits at all are
326 // generated (ex.: 2 fixed digits for 0.00001).
327 //
328 // Input verifies:  1 &lt;= (numerator + delta) / denominator &lt; 10.
329 static void BignumToFixed(int requested_digits, int* decimal_point,
<a name="24" id="anc24"></a><span class="line-modified">330                               Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">331                               BufferReference&lt;char&gt;(buffer), int* length) {</span>
<span class="line-modified">332         // Note that we have to look at more than just the requested_digits, since</span>
<span class="line-modified">333         // a number could be rounded up. Example: v=0.5 with requested_digits=0.</span>
<span class="line-modified">334         // Even though the power of v equals 0 we can&#39;t just stop here.</span>
<span class="line-modified">335         if (-(*decimal_point) &gt; requested_digits) {</span>
<span class="line-modified">336             // The number is definitively too small.</span>
<span class="line-modified">337             // Ex: 0.001 with requested_digits == 1.</span>
<span class="line-modified">338             // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="line-modified">339             // Note that it should not have any effect anyways since the string is</span>
<span class="line-modified">340             // empty.</span>
<span class="line-modified">341             *decimal_point = -requested_digits;</span>
<span class="line-modified">342             *length = 0;</span>
<span class="line-modified">343             return;</span>
<span class="line-modified">344         } else if (-(*decimal_point) == requested_digits) {</span>
<span class="line-modified">345             // We only need to verify if the number rounds down or up.</span>
<span class="line-modified">346             // Ex: 0.04 and 0.06 with requested_digits == 1.</span>
<span class="line-modified">347             ASSERT(*decimal_point == -requested_digits);</span>
<span class="line-modified">348             // Initially the fraction lies in range (1, 10]. Multiply the denominator</span>
<span class="line-modified">349             // by 10 so that we can compare more easily.</span>
<span class="line-modified">350             denominator-&gt;Times10();</span>
<span class="line-modified">351             if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="line-modified">352                 // If the fraction is &gt;= 0.5 then we have to include the rounded</span>
<span class="line-modified">353                 // digit.</span>
<span class="line-modified">354                 buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">355                 *length = 1;</span>
<span class="line-modified">356                 (*decimal_point)++;</span>
<span class="line-modified">357             } else {</span>
<span class="line-modified">358                 // Note that we caught most of similar cases earlier.</span>
<span class="line-modified">359                 *length = 0;</span>
<span class="line-modified">360             }</span>
<span class="line-modified">361             return;</span>
<span class="line-modified">362         } else {</span>
<span class="line-modified">363             // The requested digits correspond to the digits after the point.</span>
<span class="line-modified">364             // The variable &#39;needed_digits&#39; includes the digits before the point.</span>
<span class="line-modified">365             int needed_digits = (*decimal_point) + requested_digits;</span>
<span class="line-modified">366             GenerateCountedDigits(needed_digits, decimal_point,</span>
<span class="line-modified">367                                   numerator, denominator,</span>
<span class="line-modified">368                                   buffer, length);</span>
<span class="line-modified">369         }</span>
370 }
<a name="25" id="anc25"></a><span class="line-modified">371     </span>
<span class="line-modified">372     </span>
373 // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k where
374 // v = f * 2^exponent and 2^52 &lt;= f &lt; 2^53.
375 // v is hence a normalized double with the given exponent. The output is an
376 // approximation for the exponent of the decimal approimation .digits * 10^k.
377 //
378 // The result might undershoot by 1 in which case 10^k &lt;= v &lt; 10^k+1.
379 // Note: this property holds for v&#39;s upper boundary m+ too.
380 //    10^k &lt;= m+ &lt; 10^k+1.
381 //   (see explanation below).
382 //
383 // Examples:
384 //  EstimatePower(0)   =&gt; 16
385 //  EstimatePower(-52) =&gt; 0
386 //
387 // Note: e &gt;= 0 =&gt; EstimatedPower(e) &gt; 0. No similar claim can be made for e&lt;0.
388 static int EstimatePower(int exponent) {
<a name="26" id="anc26"></a><span class="line-modified">389         // This function estimates log10 of v where v = f*2^e (with e == exponent).</span>
<span class="line-modified">390         // Note that 10^floor(log10(v)) &lt;= v, but v &lt;= 10^ceil(log10(v)).</span>
<span class="line-modified">391         // Note that f is bounded by its container size. Let p = 53 (the double&#39;s</span>
<span class="line-modified">392         // significand size). Then 2^(p-1) &lt;= f &lt; 2^p.</span>
<span class="line-modified">393         //</span>
<span class="line-modified">394         // Given that log10(v) == log2(v)/log2(10) and e+(len(f)-1) is quite close</span>
<span class="line-modified">395         // to log2(v) the function is simplified to (e+(len(f)-1)/log2(10)).</span>
<span class="line-modified">396         // The computed number undershoots by less than 0.631 (when we compute log3</span>
<span class="line-modified">397         // and not log10).</span>
<span class="line-modified">398         //</span>
<span class="line-modified">399         // Optimization: since we only need an approximated result this computation</span>
<span class="line-modified">400         // can be performed on 64 bit integers. On x86/x64 architecture the speedup is</span>
<span class="line-modified">401         // not really measurable, though.</span>
<span class="line-modified">402         //</span>
<span class="line-modified">403         // Since we want to avoid overshooting we decrement by 1e10 so that</span>
<span class="line-modified">404         // floating-point imprecisions don&#39;t affect us.</span>
<span class="line-modified">405         //</span>
<span class="line-modified">406         // Explanation for v&#39;s boundary m+: the computation takes advantage of</span>
<span class="line-modified">407         // the fact that 2^(p-1) &lt;= f &lt; 2^p. Boundaries still satisfy this requirement</span>
<span class="line-modified">408         // (even for denormals where the delta can be much more important).</span>
<span class="line-modified">409         </span>
<span class="line-modified">410         const double k1Log10 = 0.30102999566398114;  // 1/lg(10)</span>
<span class="line-modified">411         </span>
<span class="line-modified">412         // For doubles len(f) == 53 (don&#39;t forget the hidden bit).</span>
413   const int kSignificandSize = Double::kSignificandSize;
<a name="27" id="anc27"></a><span class="line-modified">414         double estimate = ceil((exponent + kSignificandSize - 1) * k1Log10 - 1e-10);</span>
<span class="line-modified">415         return static_cast&lt;int&gt;(estimate);</span>
416 }
<a name="28" id="anc28"></a><span class="line-modified">417     </span>
<span class="line-modified">418     </span>
419 // See comments for InitialScaledStartValues.
420 static void InitialScaledStartValuesPositiveExponent(
421     uint64_t significand, int exponent,
422     int estimated_power, bool need_boundary_deltas,
<a name="29" id="anc29"></a><span class="line-modified">423                                                          Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">424                                                          Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">425         // A positive exponent implies a positive power.</span>
<span class="line-modified">426         ASSERT(estimated_power &gt;= 0);</span>
<span class="line-modified">427         // Since the estimated_power is positive we simply multiply the denominator</span>
<span class="line-modified">428         // by 10^estimated_power.</span>
<span class="line-modified">429         </span>
<span class="line-modified">430         // numerator = v.</span>
431   numerator-&gt;AssignUInt64(significand);
432   numerator-&gt;ShiftLeft(exponent);
<a name="30" id="anc30"></a><span class="line-modified">433         // denominator = 10^estimated_power.</span>
<span class="line-modified">434         denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="line-modified">435         </span>
<span class="line-modified">436         if (need_boundary_deltas) {</span>
<span class="line-modified">437             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">438             // integers.</span>
<span class="line-modified">439             denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">440             numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">441             // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="line-modified">442             // denominator (of 2) delta_plus equals 2^e.</span>
<span class="line-modified">443             delta_plus-&gt;AssignUInt16(1);</span>
444     delta_plus-&gt;ShiftLeft(exponent);
445     // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<a name="31" id="anc31"></a><span class="line-modified">446             delta_minus-&gt;AssignUInt16(1);</span>
447     delta_minus-&gt;ShiftLeft(exponent);
<a name="32" id="anc32"></a><span class="line-modified">448     }</span>
449 }
<a name="33" id="anc33"></a><span class="line-modified">450     </span>
<span class="line-modified">451     </span>
452 // See comments for InitialScaledStartValues
453 static void InitialScaledStartValuesNegativeExponentPositivePower(
454     uint64_t significand, int exponent,
455     int estimated_power, bool need_boundary_deltas,
<a name="34" id="anc34"></a><span class="line-modified">456                                                                       Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">457                                                                       Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">458         // v = f * 2^e with e &lt; 0, and with estimated_power &gt;= 0.</span>
<span class="line-modified">459         // This means that e is close to 0 (have a look at how estimated_power is</span>
<span class="line-modified">460         // computed).</span>
<span class="line-modified">461         </span>
<span class="line-modified">462         // numerator = significand</span>
<span class="line-modified">463         //  since v = significand * 2^exponent this is equivalent to</span>
<span class="line-modified">464         //  numerator = v * / 2^-exponent</span>
<span class="line-modified">465         numerator-&gt;AssignUInt64(significand);</span>
<span class="line-modified">466         // denominator = 10^estimated_power * 2^-exponent (with exponent &lt; 0)</span>
<span class="line-modified">467         denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="line-modified">468         denominator-&gt;ShiftLeft(-exponent);</span>
<span class="line-modified">469         </span>
<span class="line-modified">470         if (need_boundary_deltas) {</span>
<span class="line-modified">471             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">472             // integers.</span>
<span class="line-modified">473             denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">474             numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">475             // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="line-modified">476             // denominator (of 2) delta_plus equals 2^e.</span>
<span class="line-modified">477             // Given that the denominator already includes v&#39;s exponent the distance</span>
<span class="line-modified">478             // to the boundaries is simply 1.</span>
<span class="line-modified">479             delta_plus-&gt;AssignUInt16(1);</span>
480     // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<a name="35" id="anc35"></a><span class="line-modified">481             delta_minus-&gt;AssignUInt16(1);</span>
<span class="line-modified">482     }</span>
483 }
<a name="36" id="anc36"></a><span class="line-modified">484     </span>
<span class="line-modified">485     </span>
486 // See comments for InitialScaledStartValues
487 static void InitialScaledStartValuesNegativeExponentNegativePower(
488     uint64_t significand, int exponent,
489     int estimated_power, bool need_boundary_deltas,
<a name="37" id="anc37"></a><span class="line-modified">490                                                                       Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">491                                                                       Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">492         // Instead of multiplying the denominator with 10^estimated_power we</span>
<span class="line-modified">493         // multiply all values (numerator and deltas) by 10^-estimated_power.</span>
<span class="line-modified">494         </span>
<span class="line-modified">495         // Use numerator as temporary container for power_ten.</span>
<span class="line-modified">496         Bignum* power_ten = numerator;</span>
<span class="line-modified">497         power_ten-&gt;AssignPowerUInt16(10, -estimated_power);</span>
<span class="line-modified">498         </span>
<span class="line-modified">499         if (need_boundary_deltas) {</span>
<span class="line-modified">500             // Since power_ten == numerator we must make a copy of 10^estimated_power</span>
<span class="line-modified">501             // before we complete the computation of the numerator.</span>
<span class="line-modified">502             // delta_plus = delta_minus = 10^estimated_power</span>
<span class="line-modified">503             delta_plus-&gt;AssignBignum(*power_ten);</span>
<span class="line-modified">504             delta_minus-&gt;AssignBignum(*power_ten);</span>
<span class="line-modified">505         }</span>
<span class="line-modified">506         </span>
<span class="line-modified">507         // numerator = significand * 2 * 10^-estimated_power</span>
<span class="line-modified">508         //  since v = significand * 2^exponent this is equivalent to</span>
<span class="line-modified">509         // numerator = v * 10^-estimated_power * 2 * 2^-exponent.</span>
<span class="line-modified">510         // Remember: numerator has been abused as power_ten. So no need to assign it</span>
<span class="line-modified">511         //  to itself.</span>
<span class="line-modified">512         ASSERT(numerator == power_ten);</span>
<span class="line-modified">513         numerator-&gt;MultiplyByUInt64(significand);</span>
<span class="line-modified">514         </span>
<span class="line-modified">515         // denominator = 2 * 2^-exponent with exponent &lt; 0.</span>
<span class="line-modified">516         denominator-&gt;AssignUInt16(1);</span>
<span class="line-modified">517         denominator-&gt;ShiftLeft(-exponent);</span>
<span class="line-modified">518         </span>
<span class="line-modified">519         if (need_boundary_deltas) {</span>
<span class="line-modified">520             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">521             // integers.</span>
<span class="line-modified">522             numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">523             denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">524             // With this shift the boundaries have their correct value, since</span>
<span class="line-modified">525             // delta_plus = 10^-estimated_power, and</span>
<span class="line-modified">526             // delta_minus = 10^-estimated_power.</span>
<span class="line-modified">527             // These assignments have been done earlier.</span>
528     // The adjustments if f == 2^p-1 (lower boundary is closer) are done later.
<a name="38" id="anc38"></a><span class="line-modified">529     }</span>
530 }
<a name="39" id="anc39"></a><span class="line-modified">531     </span>
<span class="line-modified">532     </span>
533 // Let v = significand * 2^exponent.
534 // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
535 // and denominator. The functions GenerateShortestDigits and
536 // GenerateCountedDigits will then convert this ratio to its decimal
537 // representation d, with the required accuracy.
538 // Then d * 10^estimated_power is the representation of v.
539 // (Note: the fraction and the estimated_power might get adjusted before
540 // generating the decimal representation.)
541 //
542 // The initial start values consist of:
543 //  - a scaled numerator: s.t. numerator/denominator == v / 10^estimated_power.
544 //  - a scaled (common) denominator.
545 //  optionally (used by GenerateShortestDigits to decide if it has the shortest
546 //  decimal converting back to v):
547 //  - v - m-: the distance to the lower boundary.
548 //  - m+ - v: the distance to the upper boundary.
549 //
550 // v, m+, m-, and therefore v - m- and m+ - v all share the same denominator.
551 //
552 // Let ep == estimated_power, then the returned values will satisfy:
553 //  v / 10^ep = numerator / denominator.
554 //  v&#39;s boundarys m- and m+:
555 //    m- / 10^ep == v / 10^ep - delta_minus / denominator
556 //    m+ / 10^ep == v / 10^ep + delta_plus / denominator
557 //  Or in other words:
558 //    m- == v - delta_minus * 10^ep / denominator;
559 //    m+ == v + delta_plus * 10^ep / denominator;
560 //
561 // Since 10^(k-1) &lt;= v &lt; 10^k    (with k == estimated_power)
562 //  or       10^k &lt;= v &lt; 10^(k+1)
563 //  we then have 0.1 &lt;= numerator/denominator &lt; 1
564 //           or    1 &lt;= numerator/denominator &lt; 10
565 //
566 // It is then easy to kickstart the digit-generation routine.
567 //
568 // The boundary-deltas are only filled if the mode equals BIGNUM_DTOA_SHORTEST
569 // or BIGNUM_DTOA_SHORTEST_SINGLE.
570 
571 static void InitialScaledStartValues(uint64_t significand,
572                                      int exponent,
573                                      bool lower_boundary_is_closer,
<a name="40" id="anc40"></a><span class="line-modified">574                                          int estimated_power,</span>
<span class="line-modified">575                                          bool need_boundary_deltas,</span>
<span class="line-modified">576                                          Bignum* numerator,</span>
<span class="line-modified">577                                          Bignum* denominator,</span>
<span class="line-modified">578                                          Bignum* delta_minus,</span>
<span class="line-modified">579                                          Bignum* delta_plus) {</span>
580   if (exponent &gt;= 0) {
<a name="41" id="anc41"></a><span class="line-modified">581             InitialScaledStartValuesPositiveExponent(</span>
582         significand, exponent, estimated_power, need_boundary_deltas,
<a name="42" id="anc42"></a><span class="line-modified">583                                                      numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">584         } else if (estimated_power &gt;= 0) {</span>
<span class="line-modified">585             InitialScaledStartValuesNegativeExponentPositivePower(</span>
586         significand, exponent, estimated_power, need_boundary_deltas,
<a name="43" id="anc43"></a><span class="line-modified">587                                                                   numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">588         } else {</span>
<span class="line-modified">589             InitialScaledStartValuesNegativeExponentNegativePower(</span>
590         significand, exponent, estimated_power, need_boundary_deltas,
<a name="44" id="anc44"></a><span class="line-modified">591                                                                   numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">592         }</span>
593 
594   if (need_boundary_deltas &amp;&amp; lower_boundary_is_closer) {
595     // The lower boundary is closer at half the distance of &quot;normal&quot; numbers.
596     // Increase the common denominator and adapt all but the delta_minus.
597     denominator-&gt;ShiftLeft(1);  // *2
598     numerator-&gt;ShiftLeft(1);    // *2
599     delta_plus-&gt;ShiftLeft(1);   // *2
<a name="45" id="anc45"></a><span class="line-modified">600     }</span>
601 }
<a name="46" id="anc46"></a><span class="line-modified">602     </span>
<span class="line-modified">603     </span>
604 // This routine multiplies numerator/denominator so that its values lies in the
605 // range 1-10. That is after a call to this function we have:
606 //    1 &lt;= (numerator + delta_plus) /denominator &lt; 10.
607 // Let numerator the input before modification and numerator&#39; the argument
608 // after modification, then the output-parameter decimal_point is such that
609 //  numerator / denominator * 10^estimated_power ==
610 //    numerator&#39; / denominator&#39; * 10^(decimal_point - 1)
611 // In some cases estimated_power was too low, and this is already the case. We
612 // then simply adjust the power so that 10^(k-1) &lt;= v &lt; 10^k (with k ==
613 // estimated_power) but do not touch the numerator or denominator.
614 // Otherwise the routine multiplies the numerator and the deltas by 10.
615 static void FixupMultiply10(int estimated_power, bool is_even,
<a name="47" id="anc47"></a><span class="line-modified">616                                 int* decimal_point,</span>
<span class="line-modified">617                                 Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">618                                 Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">619         bool in_range;</span>
<span class="line-modified">620         if (is_even) {</span>
<span class="line-modified">621             // For IEEE doubles half-way cases (in decimal system numbers ending with 5)</span>
<span class="line-modified">622             // are rounded to the closest floating-point number with even significand.</span>
<span class="line-modified">623             in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="line-modified">624         } else {</span>
<span class="line-modified">625             in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="line-modified">626         }</span>
<span class="line-modified">627         if (in_range) {</span>
<span class="line-modified">628             // Since numerator + delta_plus &gt;= denominator we already have</span>
<span class="line-modified">629             // 1 &lt;= numerator/denominator &lt; 10. Simply update the estimated_power.</span>
<span class="line-modified">630             *decimal_point = estimated_power + 1;</span>
<span class="line-modified">631         } else {</span>
<span class="line-modified">632             *decimal_point = estimated_power;</span>
<span class="line-modified">633             numerator-&gt;Times10();</span>
<span class="line-modified">634             if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="line-modified">635                 delta_minus-&gt;Times10();</span>
<span class="line-modified">636                 delta_plus-&gt;AssignBignum(*delta_minus);</span>
<span class="line-modified">637             } else {</span>
<span class="line-modified">638                 delta_minus-&gt;Times10();</span>
<span class="line-modified">639                 delta_plus-&gt;Times10();</span>
<span class="line-modified">640             }</span>
<span class="line-modified">641         }</span>
642 }
<a name="48" id="anc48"></a><span class="line-modified">643     </span>
644 }  // namespace double_conversion
<a name="49" id="anc49"></a><span class="line-modified">645 } // namespace WTF</span>
<a name="50" id="anc50"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="50" type="hidden" />
</body>
</html>