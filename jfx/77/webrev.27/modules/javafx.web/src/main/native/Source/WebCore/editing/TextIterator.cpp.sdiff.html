<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextGranularity.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextIterator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 318 
 319     m_singleCharacter = 0;
 320     m_string = WTFMove(string);
 321     m_offset = offset;
 322     m_length = length;
 323 }
 324 
 325 inline void TextIteratorCopyableText::set(UChar singleCharacter)
 326 {
 327     m_singleCharacter = singleCharacter;
 328     m_string = String();
 329     m_offset = 0;
 330     m_length = 0;
 331 }
 332 
 333 void TextIteratorCopyableText::appendToStringBuilder(StringBuilder&amp; builder) const
 334 {
 335     if (m_singleCharacter)
 336         builder.append(m_singleCharacter);
 337     else
<span class="line-modified"> 338         builder.append(m_string, m_offset, m_length);</span>
 339 }
 340 
 341 // --------
 342 
 343 
 344 TextIterator::TextIterator(Position start, Position end, TextIteratorBehavior behavior)
 345     : m_behavior(behavior)
 346 {
 347     if (start.isNull() || end.isNull())
 348         return;
 349     ASSERT(comparePositions(start, end) &lt;= 0);
 350 
 351     RELEASE_ASSERT(behavior &amp; TextIteratorTraversesFlatTree || start.treeScope() == end.treeScope());
 352 
 353     start.document()-&gt;updateLayoutIgnorePendingStylesheets();
 354 
 355     // FIXME: Use Position / PositionIterator instead to avoid offset computation.
 356     m_startContainer = start.containerNode();
 357     m_startOffset = start.computeOffsetInContainerNode();
 358 
</pre>
<hr />
<pre>
 633         emitText(textNode, renderer, runStart, runEnd);
 634         return true;
 635     }
 636 
 637     if (const auto* layout = renderer.simpleLineLayout()) {
 638         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 639             return true;
 640         ASSERT(renderer.parent());
 641         ASSERT(is&lt;RenderBlockFlow&gt;(*renderer.parent()));
 642         const auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());
 643         // Use the simple layout runs to iterate over the text content.
 644         bool isNewTextNode = m_previousSimpleTextNodeInFlow &amp;&amp; m_previousSimpleTextNodeInFlow != &amp;textNode;
 645         // Simple line layout run positions are all absolute to the parent flow.
 646         // Offsetting is required when multiple renderers are present.
 647         m_accumulatedSimpleTextLengthInFlow += isNewTextNode ? m_previousSimpleTextNodeInFlow-&gt;renderer()-&gt;text().length() : 0;
 648         m_previousSimpleTextNodeInFlow = &amp;textNode;
 649 
 650         unsigned endPosition = (m_node == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : rendererText.length();
 651         if (!m_flowRunResolverCache || &amp;m_flowRunResolverCache-&gt;flow() != &amp;blockFlow) {
 652             m_accumulatedSimpleTextLengthInFlow = m_flowRunResolverCache ? 0 : textNodeOffsetInFlow(textNode);
<span class="line-modified"> 653             m_flowRunResolverCache = std::make_unique&lt;SimpleLineLayout::RunResolver&gt;(blockFlow, *layout);</span>
 654         }
 655         // Skip to m_offset position.
 656         auto range = m_flowRunResolverCache-&gt;rangeForRenderer(renderer);
 657         auto it = range.begin();
 658         auto end = range.end();
 659         auto startPosition = static_cast&lt;unsigned&gt;(m_offset) + m_accumulatedSimpleTextLengthInFlow;
 660         while (it != end &amp;&amp; (*it).end() &lt;= startPosition)
 661             ++it;
 662         if (m_nextRunNeedsWhitespace &amp;&amp; rendererText[m_offset - 1] == &#39;\n&#39;) {
 663             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);
 664             return it == end;
 665         }
 666         if (it == end) {
 667             // Collapsed trailing whitespace.
 668             m_offset = endPosition;
 669             m_lastTextNodeEndedWithCollapsedSpace = true;
 670             return true;
 671         }
 672         if (m_nextRunNeedsWhitespace) {
 673             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);
</pre>
<hr />
<pre>
1462 
1463     return firstLetterRenderer;
1464 }
1465 
1466 bool SimplifiedBackwardsTextIterator::handleReplacedElement()
1467 {
1468     unsigned index = m_node-&gt;computeNodeIndex();
1469     // We want replaced elements to behave like punctuation for boundary
1470     // finding, and to simply take up space for the selection preservation
1471     // code in moveParagraphs, so we use a comma. Unconditionally emit
1472     // here because this iterator is only used for boundary finding.
1473     emitCharacter(&#39;,&#39;, *m_node-&gt;parentNode(), index, index + 1);
1474     return true;
1475 }
1476 
1477 bool SimplifiedBackwardsTextIterator::handleNonTextNode()
1478 {
1479     // We can use a linefeed in place of a tab because this simple iterator is only used to
1480     // find boundaries, not actual content. A linefeed breaks words, sentences, and paragraphs.
1481     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineAfterNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
<span class="line-modified">1482         unsigned index = m_node-&gt;computeNodeIndex();</span>
<span class="line-modified">1483         // The start of this emitted range is wrong. Ensuring correctness would require</span>
<span class="line-modified">1484         // VisiblePositions and so would be slow. previousBoundary expects this.</span>
<span class="line-modified">1485         emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), index + 1, index + 1);</span>



1486     }
1487     return true;
1488 }
1489 
1490 void SimplifiedBackwardsTextIterator::exitNode()
1491 {
1492     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineBeforeNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
1493         // The start of this emitted range is wrong. Ensuring correctness would require
1494         // VisiblePositions and so would be slow. previousBoundary expects this.
1495         emitCharacter(&#39;\n&#39;, *m_node, 0, 0);
1496     }
1497 }
1498 
1499 void SimplifiedBackwardsTextIterator::emitCharacter(UChar c, Node&amp; node, int startOffset, int endOffset)
1500 {
1501     m_positionNode = &amp;node;
1502     m_positionStartOffset = startOffset;
1503     m_positionEndOffset = endOffset;
1504     m_copyableText.set(c);
1505     m_text = m_copyableText.text();
</pre>
<hr />
<pre>
1511     if (!next)
1512         return false;
1513     m_havePassedStartContainer |= m_node == m_startContainer;
1514     if (m_havePassedStartContainer)
1515         return false;
1516     m_node = next;
1517     return true;
1518 }
1519 
1520 Ref&lt;Range&gt; SimplifiedBackwardsTextIterator::range() const
1521 {
1522     ASSERT(!atEnd());
1523 
1524     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1525 }
1526 
1527 // --------
1528 
1529 CharacterIterator::CharacterIterator(const Range&amp; range, TextIteratorBehavior behavior)
1530     : m_underlyingIterator(&amp;range, behavior)
<span class="line-modified">1531     , m_offset(0)</span>
<span class="line-modified">1532     , m_runOffset(0)</span>
<span class="line-modified">1533     , m_atBreak(true)</span>




1534 {
1535     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1536         m_underlyingIterator.advance();
1537 }
1538 
1539 Ref&lt;Range&gt; CharacterIterator::range() const
1540 {
1541     Ref&lt;Range&gt; range = m_underlyingIterator.range();
1542     if (!m_underlyingIterator.atEnd()) {
1543         if (m_underlyingIterator.text().length() &lt;= 1) {
1544             ASSERT(m_runOffset == 0);
1545         } else {
1546             Node&amp; node = range-&gt;startContainer();
1547             ASSERT(&amp;node == &amp;range-&gt;endContainer());
1548             int offset = range-&gt;startOffset() + m_runOffset;
1549             range-&gt;setStart(node, offset);
1550             range-&gt;setEnd(node, offset + 1);
1551         }
1552     }
1553     return range;
</pre>
<hr />
<pre>
1758 {
1759     switch (c) {
1760         case hebrewPunctuationGershayim:
1761         case leftDoubleQuotationMark:
1762         case leftLowDoubleQuotationMark:
1763         case rightDoubleQuotationMark:
1764             return &#39;&quot;&#39;;
1765         case hebrewPunctuationGeresh:
1766         case leftSingleQuotationMark:
1767         case leftLowSingleQuotationMark:
1768         case rightSingleQuotationMark:
1769             return &#39;\&#39;&#39;;
1770         default:
1771             return c;
1772     }
1773 }
1774 
1775 // FIXME: We&#39;d like to tailor the searcher to fold quote marks for us instead
1776 // of doing it in a separate replacement pass here, but ICU doesn&#39;t offer a way
1777 // to add tailoring on top of the locale-specific tailoring as of this writing.
<span class="line-modified">1778 static inline String foldQuoteMarks(String string)</span>
<span class="line-modified">1779 {</span>
<span class="line-modified">1780     string.replace(hebrewPunctuationGeresh, &#39;\&#39;&#39;);</span>
<span class="line-modified">1781     string.replace(hebrewPunctuationGershayim, &#39;&quot;&#39;);</span>
<span class="line-modified">1782     string.replace(leftDoubleQuotationMark, &#39;&quot;&#39;);</span>
<span class="line-modified">1783     string.replace(leftLowDoubleQuotationMark, &#39;&quot;&#39;);</span>
<span class="line-modified">1784     string.replace(leftSingleQuotationMark, &#39;\&#39;&#39;);</span>
<span class="line-modified">1785     string.replace(leftLowSingleQuotationMark, &#39;\&#39;&#39;);</span>
<span class="line-modified">1786     string.replace(rightDoubleQuotationMark, &#39;&quot;&#39;);</span>
<span class="line-modified">1787     string.replace(rightSingleQuotationMark, &#39;\&#39;&#39;);</span>

1788 
<span class="line-modified">1789     return string;</span>
1790 }
1791 
1792 #if !UCONFIG_NO_COLLATION
1793 
1794 const size_t minimumSearchBufferSize = 8192;
1795 
1796 #ifndef NDEBUG
1797 static bool searcherInUse;
1798 #endif
1799 
1800 static UStringSearch* createSearcher()
1801 {
1802     // Provide a non-empty pattern and non-empty text so usearch_open will not fail,
1803     // but it doesn&#39;t matter exactly what it is, since we don&#39;t perform any searches
1804     // without setting both the pattern and the text.
1805     UErrorCode status = U_ZERO_ERROR;
1806     String searchCollatorName = makeString(currentSearchLocaleID(), &quot;@collation=search&quot;);
1807     UStringSearch* searcher = usearch_open(&amp;newlineCharacter, 1, &amp;newlineCharacter, 1, searchCollatorName.utf8().data(), 0, &amp;status);
1808     ASSERT(status == U_ZERO_ERROR || status == U_USING_FALLBACK_WARNING || status == U_USING_DEFAULT_WARNING);
1809     return searcher;
</pre>
<hr />
<pre>
2020     const UNormalizer2* normalizer = unorm2_getNFCInstance(&amp;status);
2021     ASSERT(U_SUCCESS(status));
2022 
2023     buffer.resize(length);
2024 
2025     auto normalizedLength = unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
2026     ASSERT(U_SUCCESS(status) || status == U_BUFFER_OVERFLOW_ERROR);
2027 
2028     buffer.resize(normalizedLength);
2029 
2030     if (U_SUCCESS(status))
2031         return;
2032 
2033     status = U_ZERO_ERROR;
2034     unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
2035     ASSERT(U_SUCCESS(status));
2036 }
2037 
2038 static bool isNonLatin1Separator(UChar32 character)
2039 {
<span class="line-modified">2040     ASSERT_ARG(character, character &gt;= 256);</span>
2041 
2042     return U_GET_GC_MASK(character) &amp; (U_GC_S_MASK | U_GC_P_MASK | U_GC_Z_MASK | U_GC_CF_MASK);
2043 }
2044 
2045 static inline bool isSeparator(UChar32 character)
2046 {
2047     static const bool latin1SeparatorTable[256] = {
2048         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2049         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2050         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // space ! &quot; # $ % &amp; &#39; ( ) * + , - . /
2051         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, //                         : ; &lt; = &gt; ?
2052         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   @
2053         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, //                         [ \ ] ^ _
2054         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   `
2055         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, //                           { | } ~
2056         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2057         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2058         0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
2059         1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
2060         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2061         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
2062         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2063         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0
2064     };
2065 
<span class="line-modified">2066     if (character &lt; 256)</span>
2067         return latin1SeparatorTable[character];
2068 
2069     return isNonLatin1Separator(character);
2070 }
2071 
2072 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
2073     : m_target(foldQuoteMarks(target))
2074     , m_targetCharacters(StringView(m_target).upconvertedCharacters())
2075     , m_options(options)
2076     , m_prefixLength(0)
2077     , m_atBreak(true)
2078     , m_needsMoreContext(options.contains(AtWordStarts))
2079     , m_targetRequiresKanaWorkaround(containsKanaLetters(m_target))
2080 {
2081     ASSERT(!m_target.isEmpty());
2082 
2083     size_t targetLength = m_target.length();
2084     m_buffer.reserveInitialCapacity(std::max(targetLength * 8, minimumSearchBufferSize));
2085     m_overlap = m_buffer.capacity() / 4;
2086 
</pre>
<hr />
<pre>
2386     if (isBadMatch(m_buffer.data() + matchStart, matchedLength)
2387         || (m_options.contains(AtWordStarts) &amp;&amp; !isWordStartMatch(matchStart, matchedLength))
2388         || (m_options.contains(AtWordEnds) &amp;&amp; !isWordEndMatch(matchStart, matchedLength))) {
2389         matchStart = usearch_next(searcher, &amp;status);
2390         ASSERT(status == U_ZERO_ERROR);
2391         goto nextMatch;
2392     }
2393 
2394     size_t newSize = size - (matchStart + 1);
2395     memmove(m_buffer.data(), m_buffer.data() + matchStart + 1, newSize * sizeof(UChar));
2396     m_prefixLength -= std::min&lt;size_t&gt;(m_prefixLength, matchStart + 1);
2397     m_buffer.shrink(newSize);
2398 
2399     start = size - matchStart;
2400     return matchedLength;
2401 }
2402 
2403 #else
2404 
2405 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
<span class="line-modified">2406     : m_target(options &amp; CaseInsensitive ? target.foldCase() : target)</span>
2407     , m_options(options)
2408     , m_buffer(m_target.length())
2409     , m_isCharacterStartBuffer(m_target.length())
2410     , m_isBufferFull(false)
2411     , m_cursor(0)
2412 {
2413     ASSERT(!m_target.isEmpty());
2414     m_target.replace(noBreakSpace, &#39; &#39;);
<span class="line-removed">2415     foldQuoteMarks(m_target);</span>
2416 }
2417 
2418 inline SearchBuffer::~SearchBuffer() = default;
2419 
2420 inline void SearchBuffer::reachedBreak()
2421 {
2422     m_cursor = 0;
2423     m_isBufferFull = false;
2424 }
2425 
2426 inline bool SearchBuffer::atBreak() const
2427 {
2428     return !m_cursor &amp;&amp; !m_isBufferFull;
2429 }
2430 
2431 inline void SearchBuffer::append(UChar c, bool isStart)
2432 {
2433     m_buffer[m_cursor] = c == noBreakSpace ? &#39; &#39; : foldQuoteMark(c);
2434     m_isCharacterStartBuffer[m_cursor] = isStart;
2435     if (++m_cursor == m_target.length()) {
</pre>
<hr />
<pre>
2533     Node* node = iterator.node();
2534     return node &amp;&amp; isRendererReplacedElement(node-&gt;renderer());
2535 }
2536 
2537 RefPtr&lt;Range&gt; TextIterator::rangeFromLocationAndLength(ContainerNode* scope, int rangeLocation, int rangeLength, bool forSelectionPreservation)
2538 {
2539     Ref&lt;Range&gt; resultRange = scope-&gt;document().createRange();
2540 
2541     int docTextPosition = 0;
2542     int rangeEnd = rangeLocation + rangeLength;
2543     bool startRangeFound = false;
2544 
2545     Ref&lt;Range&gt; textRunRange = rangeOfContents(*scope);
2546 
2547     TextIterator it(textRunRange.ptr(), forSelectionPreservation ? TextIteratorEmitsCharactersBetweenAllVisiblePositions : TextIteratorDefaultBehavior);
2548 
2549     // FIXME: the atEnd() check shouldn&#39;t be necessary, workaround for &lt;http://bugs.webkit.org/show_bug.cgi?id=6289&gt;.
2550     if (!rangeLocation &amp;&amp; !rangeLength &amp;&amp; it.atEnd()) {
2551         resultRange-&gt;setStart(textRunRange-&gt;startContainer(), 0);
2552         resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), 0);
<span class="line-modified">2553         return WTFMove(resultRange);</span>
2554     }
2555 
2556     for (; !it.atEnd(); it.advance()) {
2557         int length = it.text().length();
2558         textRunRange = it.range();
2559 
2560         bool foundStart = rangeLocation &gt;= docTextPosition &amp;&amp; rangeLocation &lt;= docTextPosition + length;
2561         bool foundEnd = rangeEnd &gt;= docTextPosition &amp;&amp; rangeEnd &lt;= docTextPosition + length;
2562 
2563         if (foundEnd) {
2564             // FIXME: This is a workaround for the fact that the end of a run is often at the wrong
2565             // position for emitted &#39;\n&#39;s or if the renderer of the current node is a replaced element.
2566             if (length == 1 &amp;&amp; (it.text()[0] == &#39;\n&#39; || isInsideReplacedElement(it))) {
2567                 it.advance();
2568                 if (!it.atEnd()) {
2569                     Ref&lt;Range&gt; range = it.range();
2570                     textRunRange-&gt;setEnd(range-&gt;startContainer(), range-&gt;startOffset());
2571                 } else {
2572                     Position runStart = textRunRange-&gt;startPosition();
2573                     Position runEnd = VisiblePosition(runStart).next().deepEquivalent();
</pre>
<hr />
<pre>
2596                 resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), offset + textRunRange-&gt;startOffset());
2597             } else {
2598                 if (rangeEnd == docTextPosition)
2599                     resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), textRunRange-&gt;startOffset());
2600                 else
2601                     resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2602             }
2603             docTextPosition += length;
2604             break;
2605         }
2606 
2607         docTextPosition += length;
2608     }
2609 
2610     if (!startRangeFound)
2611         return nullptr;
2612 
2613     if (rangeLength &amp;&amp; rangeEnd &gt; docTextPosition) // rangeEnd is out of bounds
2614         resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2615 
<span class="line-modified">2616     return WTFMove(resultRange);</span>
2617 }
2618 
2619 bool TextIterator::getLocationAndLengthFromRange(Node* scope, const Range* range, size_t&amp; location, size_t&amp; length)
2620 {
2621     location = notFound;
2622     length = 0;
2623 
2624     // The critical assumption is that this only gets called with ranges that
2625     // concentrate on a given area containing the selection root. This is done
2626     // because of text fields and textareas. The DOM for those is not
2627     // directly in the document DOM, so ensure that the range does not cross a
2628     // boundary of one of those.
2629     if (&amp;range-&gt;startContainer() != scope &amp;&amp; !range-&gt;startContainer().isDescendantOf(scope))
2630         return false;
2631     if (&amp;range-&gt;endContainer() != scope &amp;&amp; !range-&gt;endContainer().isDescendantOf(scope))
2632         return false;
2633 
2634     Ref&lt;Range&gt; testRange = Range::create(scope-&gt;document(), scope, 0, &amp;range-&gt;startContainer(), range-&gt;startOffset());
2635     ASSERT(&amp;testRange-&gt;startContainer() == scope);
2636     location = TextIterator::rangeLength(testRange.ptr());
</pre>
<hr />
<pre>
2667     TextIteratorBehavior behavior = defaultBehavior;
2668     if (!isDisplayString)
2669         behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsTextsWithoutTranscoding);
2670 
2671     for (TextIterator it(start, end, behavior); !it.atEnd(); it.advance()) {
2672         it.appendTextToStringBuilder(builder);
2673         bufferLength += it.text().length();
2674     }
2675 
2676     if (!bufferLength)
2677         return emptyString();
2678 
2679     String result = builder.toString();
2680 
2681     if (isDisplayString)
2682         document-&gt;displayStringModifiedByEncoding(result);
2683 
2684     return result;
2685 }
2686 





2687 String plainText(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2688 {
2689     if (!range)
2690         return emptyString();
2691     return plainText(range-&gt;startPosition(), range-&gt;endPosition(), defaultBehavior, isDisplayString);
2692 }
2693 








2694 String plainTextReplacingNoBreakSpace(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2695 {
2696     return plainText(range, defaultBehavior, isDisplayString).replace(noBreakSpace, &#39; &#39;);
2697 }
2698 
2699 static Ref&lt;Range&gt; collapsedToBoundary(const Range&amp; range, bool forward)
2700 {
2701     Ref&lt;Range&gt; result = range.cloneRange();
2702     result-&gt;collapse(!forward);
2703     return result;
2704 }
2705 
2706 static TextIteratorBehavior findIteratorOptions(FindOptions options)
2707 {
2708     TextIteratorBehavior iteratorOptions = TextIteratorEntersTextControls | TextIteratorClipsToFrameAncestors;
2709     if (!options.contains(DoNotTraverseFlatTree))
2710         iteratorOptions |= TextIteratorTraversesFlatTree;
2711     return iteratorOptions;
2712 }
2713 
</pre>
</td>
<td>
<hr />
<pre>
 318 
 319     m_singleCharacter = 0;
 320     m_string = WTFMove(string);
 321     m_offset = offset;
 322     m_length = length;
 323 }
 324 
 325 inline void TextIteratorCopyableText::set(UChar singleCharacter)
 326 {
 327     m_singleCharacter = singleCharacter;
 328     m_string = String();
 329     m_offset = 0;
 330     m_length = 0;
 331 }
 332 
 333 void TextIteratorCopyableText::appendToStringBuilder(StringBuilder&amp; builder) const
 334 {
 335     if (m_singleCharacter)
 336         builder.append(m_singleCharacter);
 337     else
<span class="line-modified"> 338         builder.appendSubstring(m_string, m_offset, m_length);</span>
 339 }
 340 
 341 // --------
 342 
 343 
 344 TextIterator::TextIterator(Position start, Position end, TextIteratorBehavior behavior)
 345     : m_behavior(behavior)
 346 {
 347     if (start.isNull() || end.isNull())
 348         return;
 349     ASSERT(comparePositions(start, end) &lt;= 0);
 350 
 351     RELEASE_ASSERT(behavior &amp; TextIteratorTraversesFlatTree || start.treeScope() == end.treeScope());
 352 
 353     start.document()-&gt;updateLayoutIgnorePendingStylesheets();
 354 
 355     // FIXME: Use Position / PositionIterator instead to avoid offset computation.
 356     m_startContainer = start.containerNode();
 357     m_startOffset = start.computeOffsetInContainerNode();
 358 
</pre>
<hr />
<pre>
 633         emitText(textNode, renderer, runStart, runEnd);
 634         return true;
 635     }
 636 
 637     if (const auto* layout = renderer.simpleLineLayout()) {
 638         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 639             return true;
 640         ASSERT(renderer.parent());
 641         ASSERT(is&lt;RenderBlockFlow&gt;(*renderer.parent()));
 642         const auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());
 643         // Use the simple layout runs to iterate over the text content.
 644         bool isNewTextNode = m_previousSimpleTextNodeInFlow &amp;&amp; m_previousSimpleTextNodeInFlow != &amp;textNode;
 645         // Simple line layout run positions are all absolute to the parent flow.
 646         // Offsetting is required when multiple renderers are present.
 647         m_accumulatedSimpleTextLengthInFlow += isNewTextNode ? m_previousSimpleTextNodeInFlow-&gt;renderer()-&gt;text().length() : 0;
 648         m_previousSimpleTextNodeInFlow = &amp;textNode;
 649 
 650         unsigned endPosition = (m_node == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : rendererText.length();
 651         if (!m_flowRunResolverCache || &amp;m_flowRunResolverCache-&gt;flow() != &amp;blockFlow) {
 652             m_accumulatedSimpleTextLengthInFlow = m_flowRunResolverCache ? 0 : textNodeOffsetInFlow(textNode);
<span class="line-modified"> 653             m_flowRunResolverCache = makeUnique&lt;SimpleLineLayout::RunResolver&gt;(blockFlow, *layout);</span>
 654         }
 655         // Skip to m_offset position.
 656         auto range = m_flowRunResolverCache-&gt;rangeForRenderer(renderer);
 657         auto it = range.begin();
 658         auto end = range.end();
 659         auto startPosition = static_cast&lt;unsigned&gt;(m_offset) + m_accumulatedSimpleTextLengthInFlow;
 660         while (it != end &amp;&amp; (*it).end() &lt;= startPosition)
 661             ++it;
 662         if (m_nextRunNeedsWhitespace &amp;&amp; rendererText[m_offset - 1] == &#39;\n&#39;) {
 663             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);
 664             return it == end;
 665         }
 666         if (it == end) {
 667             // Collapsed trailing whitespace.
 668             m_offset = endPosition;
 669             m_lastTextNodeEndedWithCollapsedSpace = true;
 670             return true;
 671         }
 672         if (m_nextRunNeedsWhitespace) {
 673             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);
</pre>
<hr />
<pre>
1462 
1463     return firstLetterRenderer;
1464 }
1465 
1466 bool SimplifiedBackwardsTextIterator::handleReplacedElement()
1467 {
1468     unsigned index = m_node-&gt;computeNodeIndex();
1469     // We want replaced elements to behave like punctuation for boundary
1470     // finding, and to simply take up space for the selection preservation
1471     // code in moveParagraphs, so we use a comma. Unconditionally emit
1472     // here because this iterator is only used for boundary finding.
1473     emitCharacter(&#39;,&#39;, *m_node-&gt;parentNode(), index, index + 1);
1474     return true;
1475 }
1476 
1477 bool SimplifiedBackwardsTextIterator::handleNonTextNode()
1478 {
1479     // We can use a linefeed in place of a tab because this simple iterator is only used to
1480     // find boundaries, not actual content. A linefeed breaks words, sentences, and paragraphs.
1481     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineAfterNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
<span class="line-modified">1482         if (m_lastCharacter != &#39;\n&#39;) {</span>
<span class="line-modified">1483             // Corresponds to the same check in TextIterator::exitNode.</span>
<span class="line-modified">1484             unsigned index = m_node-&gt;computeNodeIndex();</span>
<span class="line-modified">1485             // The start of this emitted range is wrong. Ensuring correctness would require</span>
<span class="line-added">1486             // VisiblePositions and so would be slow. previousBoundary expects this.</span>
<span class="line-added">1487             emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), index + 1, index + 1);</span>
<span class="line-added">1488         }</span>
1489     }
1490     return true;
1491 }
1492 
1493 void SimplifiedBackwardsTextIterator::exitNode()
1494 {
1495     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineBeforeNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
1496         // The start of this emitted range is wrong. Ensuring correctness would require
1497         // VisiblePositions and so would be slow. previousBoundary expects this.
1498         emitCharacter(&#39;\n&#39;, *m_node, 0, 0);
1499     }
1500 }
1501 
1502 void SimplifiedBackwardsTextIterator::emitCharacter(UChar c, Node&amp; node, int startOffset, int endOffset)
1503 {
1504     m_positionNode = &amp;node;
1505     m_positionStartOffset = startOffset;
1506     m_positionEndOffset = endOffset;
1507     m_copyableText.set(c);
1508     m_text = m_copyableText.text();
</pre>
<hr />
<pre>
1514     if (!next)
1515         return false;
1516     m_havePassedStartContainer |= m_node == m_startContainer;
1517     if (m_havePassedStartContainer)
1518         return false;
1519     m_node = next;
1520     return true;
1521 }
1522 
1523 Ref&lt;Range&gt; SimplifiedBackwardsTextIterator::range() const
1524 {
1525     ASSERT(!atEnd());
1526 
1527     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1528 }
1529 
1530 // --------
1531 
1532 CharacterIterator::CharacterIterator(const Range&amp; range, TextIteratorBehavior behavior)
1533     : m_underlyingIterator(&amp;range, behavior)
<span class="line-modified">1534 {</span>
<span class="line-modified">1535     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())</span>
<span class="line-modified">1536         m_underlyingIterator.advance();</span>
<span class="line-added">1537 }</span>
<span class="line-added">1538 </span>
<span class="line-added">1539 CharacterIterator::CharacterIterator(Position start, Position end, TextIteratorBehavior behavior)</span>
<span class="line-added">1540     : m_underlyingIterator(start, end, behavior)</span>
1541 {
1542     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1543         m_underlyingIterator.advance();
1544 }
1545 
1546 Ref&lt;Range&gt; CharacterIterator::range() const
1547 {
1548     Ref&lt;Range&gt; range = m_underlyingIterator.range();
1549     if (!m_underlyingIterator.atEnd()) {
1550         if (m_underlyingIterator.text().length() &lt;= 1) {
1551             ASSERT(m_runOffset == 0);
1552         } else {
1553             Node&amp; node = range-&gt;startContainer();
1554             ASSERT(&amp;node == &amp;range-&gt;endContainer());
1555             int offset = range-&gt;startOffset() + m_runOffset;
1556             range-&gt;setStart(node, offset);
1557             range-&gt;setEnd(node, offset + 1);
1558         }
1559     }
1560     return range;
</pre>
<hr />
<pre>
1765 {
1766     switch (c) {
1767         case hebrewPunctuationGershayim:
1768         case leftDoubleQuotationMark:
1769         case leftLowDoubleQuotationMark:
1770         case rightDoubleQuotationMark:
1771             return &#39;&quot;&#39;;
1772         case hebrewPunctuationGeresh:
1773         case leftSingleQuotationMark:
1774         case leftLowSingleQuotationMark:
1775         case rightSingleQuotationMark:
1776             return &#39;\&#39;&#39;;
1777         default:
1778             return c;
1779     }
1780 }
1781 
1782 // FIXME: We&#39;d like to tailor the searcher to fold quote marks for us instead
1783 // of doing it in a separate replacement pass here, but ICU doesn&#39;t offer a way
1784 // to add tailoring on top of the locale-specific tailoring as of this writing.
<span class="line-modified">1785 String foldQuoteMarks(const String&amp; stringToFold)</span>
<span class="line-modified">1786 {</span>
<span class="line-modified">1787     String result(stringToFold);</span>
<span class="line-modified">1788     result.replace(hebrewPunctuationGeresh, &#39;\&#39;&#39;);</span>
<span class="line-modified">1789     result.replace(hebrewPunctuationGershayim, &#39;&quot;&#39;);</span>
<span class="line-modified">1790     result.replace(leftDoubleQuotationMark, &#39;&quot;&#39;);</span>
<span class="line-modified">1791     result.replace(leftLowDoubleQuotationMark, &#39;&quot;&#39;);</span>
<span class="line-modified">1792     result.replace(leftSingleQuotationMark, &#39;\&#39;&#39;);</span>
<span class="line-modified">1793     result.replace(leftLowSingleQuotationMark, &#39;\&#39;&#39;);</span>
<span class="line-modified">1794     result.replace(rightDoubleQuotationMark, &#39;&quot;&#39;);</span>
<span class="line-added">1795     result.replace(rightSingleQuotationMark, &#39;\&#39;&#39;);</span>
1796 
<span class="line-modified">1797     return result;</span>
1798 }
1799 
1800 #if !UCONFIG_NO_COLLATION
1801 
1802 const size_t minimumSearchBufferSize = 8192;
1803 
1804 #ifndef NDEBUG
1805 static bool searcherInUse;
1806 #endif
1807 
1808 static UStringSearch* createSearcher()
1809 {
1810     // Provide a non-empty pattern and non-empty text so usearch_open will not fail,
1811     // but it doesn&#39;t matter exactly what it is, since we don&#39;t perform any searches
1812     // without setting both the pattern and the text.
1813     UErrorCode status = U_ZERO_ERROR;
1814     String searchCollatorName = makeString(currentSearchLocaleID(), &quot;@collation=search&quot;);
1815     UStringSearch* searcher = usearch_open(&amp;newlineCharacter, 1, &amp;newlineCharacter, 1, searchCollatorName.utf8().data(), 0, &amp;status);
1816     ASSERT(status == U_ZERO_ERROR || status == U_USING_FALLBACK_WARNING || status == U_USING_DEFAULT_WARNING);
1817     return searcher;
</pre>
<hr />
<pre>
2028     const UNormalizer2* normalizer = unorm2_getNFCInstance(&amp;status);
2029     ASSERT(U_SUCCESS(status));
2030 
2031     buffer.resize(length);
2032 
2033     auto normalizedLength = unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
2034     ASSERT(U_SUCCESS(status) || status == U_BUFFER_OVERFLOW_ERROR);
2035 
2036     buffer.resize(normalizedLength);
2037 
2038     if (U_SUCCESS(status))
2039         return;
2040 
2041     status = U_ZERO_ERROR;
2042     unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
2043     ASSERT(U_SUCCESS(status));
2044 }
2045 
2046 static bool isNonLatin1Separator(UChar32 character)
2047 {
<span class="line-modified">2048     ASSERT_ARG(character, !isLatin1(character));</span>
2049 
2050     return U_GET_GC_MASK(character) &amp; (U_GC_S_MASK | U_GC_P_MASK | U_GC_Z_MASK | U_GC_CF_MASK);
2051 }
2052 
2053 static inline bool isSeparator(UChar32 character)
2054 {
2055     static const bool latin1SeparatorTable[256] = {
2056         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2057         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2058         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // space ! &quot; # $ % &amp; &#39; ( ) * + , - . /
2059         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, //                         : ; &lt; = &gt; ?
2060         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   @
2061         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, //                         [ \ ] ^ _
2062         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   `
2063         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, //                           { | } ~
2064         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2065         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2066         0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
2067         1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
2068         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2069         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
2070         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2071         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0
2072     };
2073 
<span class="line-modified">2074     if (isLatin1(character))</span>
2075         return latin1SeparatorTable[character];
2076 
2077     return isNonLatin1Separator(character);
2078 }
2079 
2080 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
2081     : m_target(foldQuoteMarks(target))
2082     , m_targetCharacters(StringView(m_target).upconvertedCharacters())
2083     , m_options(options)
2084     , m_prefixLength(0)
2085     , m_atBreak(true)
2086     , m_needsMoreContext(options.contains(AtWordStarts))
2087     , m_targetRequiresKanaWorkaround(containsKanaLetters(m_target))
2088 {
2089     ASSERT(!m_target.isEmpty());
2090 
2091     size_t targetLength = m_target.length();
2092     m_buffer.reserveInitialCapacity(std::max(targetLength * 8, minimumSearchBufferSize));
2093     m_overlap = m_buffer.capacity() / 4;
2094 
</pre>
<hr />
<pre>
2394     if (isBadMatch(m_buffer.data() + matchStart, matchedLength)
2395         || (m_options.contains(AtWordStarts) &amp;&amp; !isWordStartMatch(matchStart, matchedLength))
2396         || (m_options.contains(AtWordEnds) &amp;&amp; !isWordEndMatch(matchStart, matchedLength))) {
2397         matchStart = usearch_next(searcher, &amp;status);
2398         ASSERT(status == U_ZERO_ERROR);
2399         goto nextMatch;
2400     }
2401 
2402     size_t newSize = size - (matchStart + 1);
2403     memmove(m_buffer.data(), m_buffer.data() + matchStart + 1, newSize * sizeof(UChar));
2404     m_prefixLength -= std::min&lt;size_t&gt;(m_prefixLength, matchStart + 1);
2405     m_buffer.shrink(newSize);
2406 
2407     start = size - matchStart;
2408     return matchedLength;
2409 }
2410 
2411 #else
2412 
2413 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
<span class="line-modified">2414     : m_target(foldQuoteMarks(options &amp; CaseInsensitive ? target.foldCase() : target))</span>
2415     , m_options(options)
2416     , m_buffer(m_target.length())
2417     , m_isCharacterStartBuffer(m_target.length())
2418     , m_isBufferFull(false)
2419     , m_cursor(0)
2420 {
2421     ASSERT(!m_target.isEmpty());
2422     m_target.replace(noBreakSpace, &#39; &#39;);

2423 }
2424 
2425 inline SearchBuffer::~SearchBuffer() = default;
2426 
2427 inline void SearchBuffer::reachedBreak()
2428 {
2429     m_cursor = 0;
2430     m_isBufferFull = false;
2431 }
2432 
2433 inline bool SearchBuffer::atBreak() const
2434 {
2435     return !m_cursor &amp;&amp; !m_isBufferFull;
2436 }
2437 
2438 inline void SearchBuffer::append(UChar c, bool isStart)
2439 {
2440     m_buffer[m_cursor] = c == noBreakSpace ? &#39; &#39; : foldQuoteMark(c);
2441     m_isCharacterStartBuffer[m_cursor] = isStart;
2442     if (++m_cursor == m_target.length()) {
</pre>
<hr />
<pre>
2540     Node* node = iterator.node();
2541     return node &amp;&amp; isRendererReplacedElement(node-&gt;renderer());
2542 }
2543 
2544 RefPtr&lt;Range&gt; TextIterator::rangeFromLocationAndLength(ContainerNode* scope, int rangeLocation, int rangeLength, bool forSelectionPreservation)
2545 {
2546     Ref&lt;Range&gt; resultRange = scope-&gt;document().createRange();
2547 
2548     int docTextPosition = 0;
2549     int rangeEnd = rangeLocation + rangeLength;
2550     bool startRangeFound = false;
2551 
2552     Ref&lt;Range&gt; textRunRange = rangeOfContents(*scope);
2553 
2554     TextIterator it(textRunRange.ptr(), forSelectionPreservation ? TextIteratorEmitsCharactersBetweenAllVisiblePositions : TextIteratorDefaultBehavior);
2555 
2556     // FIXME: the atEnd() check shouldn&#39;t be necessary, workaround for &lt;http://bugs.webkit.org/show_bug.cgi?id=6289&gt;.
2557     if (!rangeLocation &amp;&amp; !rangeLength &amp;&amp; it.atEnd()) {
2558         resultRange-&gt;setStart(textRunRange-&gt;startContainer(), 0);
2559         resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), 0);
<span class="line-modified">2560         return resultRange;</span>
2561     }
2562 
2563     for (; !it.atEnd(); it.advance()) {
2564         int length = it.text().length();
2565         textRunRange = it.range();
2566 
2567         bool foundStart = rangeLocation &gt;= docTextPosition &amp;&amp; rangeLocation &lt;= docTextPosition + length;
2568         bool foundEnd = rangeEnd &gt;= docTextPosition &amp;&amp; rangeEnd &lt;= docTextPosition + length;
2569 
2570         if (foundEnd) {
2571             // FIXME: This is a workaround for the fact that the end of a run is often at the wrong
2572             // position for emitted &#39;\n&#39;s or if the renderer of the current node is a replaced element.
2573             if (length == 1 &amp;&amp; (it.text()[0] == &#39;\n&#39; || isInsideReplacedElement(it))) {
2574                 it.advance();
2575                 if (!it.atEnd()) {
2576                     Ref&lt;Range&gt; range = it.range();
2577                     textRunRange-&gt;setEnd(range-&gt;startContainer(), range-&gt;startOffset());
2578                 } else {
2579                     Position runStart = textRunRange-&gt;startPosition();
2580                     Position runEnd = VisiblePosition(runStart).next().deepEquivalent();
</pre>
<hr />
<pre>
2603                 resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), offset + textRunRange-&gt;startOffset());
2604             } else {
2605                 if (rangeEnd == docTextPosition)
2606                     resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), textRunRange-&gt;startOffset());
2607                 else
2608                     resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2609             }
2610             docTextPosition += length;
2611             break;
2612         }
2613 
2614         docTextPosition += length;
2615     }
2616 
2617     if (!startRangeFound)
2618         return nullptr;
2619 
2620     if (rangeLength &amp;&amp; rangeEnd &gt; docTextPosition) // rangeEnd is out of bounds
2621         resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2622 
<span class="line-modified">2623     return resultRange;</span>
2624 }
2625 
2626 bool TextIterator::getLocationAndLengthFromRange(Node* scope, const Range* range, size_t&amp; location, size_t&amp; length)
2627 {
2628     location = notFound;
2629     length = 0;
2630 
2631     // The critical assumption is that this only gets called with ranges that
2632     // concentrate on a given area containing the selection root. This is done
2633     // because of text fields and textareas. The DOM for those is not
2634     // directly in the document DOM, so ensure that the range does not cross a
2635     // boundary of one of those.
2636     if (&amp;range-&gt;startContainer() != scope &amp;&amp; !range-&gt;startContainer().isDescendantOf(scope))
2637         return false;
2638     if (&amp;range-&gt;endContainer() != scope &amp;&amp; !range-&gt;endContainer().isDescendantOf(scope))
2639         return false;
2640 
2641     Ref&lt;Range&gt; testRange = Range::create(scope-&gt;document(), scope, 0, &amp;range-&gt;startContainer(), range-&gt;startOffset());
2642     ASSERT(&amp;testRange-&gt;startContainer() == scope);
2643     location = TextIterator::rangeLength(testRange.ptr());
</pre>
<hr />
<pre>
2674     TextIteratorBehavior behavior = defaultBehavior;
2675     if (!isDisplayString)
2676         behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsTextsWithoutTranscoding);
2677 
2678     for (TextIterator it(start, end, behavior); !it.atEnd(); it.advance()) {
2679         it.appendTextToStringBuilder(builder);
2680         bufferLength += it.text().length();
2681     }
2682 
2683     if (!bufferLength)
2684         return emptyString();
2685 
2686     String result = builder.toString();
2687 
2688     if (isDisplayString)
2689         document-&gt;displayStringModifiedByEncoding(result);
2690 
2691     return result;
2692 }
2693 
<span class="line-added">2694 String plainTextReplacingNoBreakSpace(Position start, Position end, TextIteratorBehavior defaultBehavior, bool isDisplayString)</span>
<span class="line-added">2695 {</span>
<span class="line-added">2696     return plainText(start, end, defaultBehavior, isDisplayString).replace(noBreakSpace, &#39; &#39;);</span>
<span class="line-added">2697 }</span>
<span class="line-added">2698 </span>
2699 String plainText(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2700 {
2701     if (!range)
2702         return emptyString();
2703     return plainText(range-&gt;startPosition(), range-&gt;endPosition(), defaultBehavior, isDisplayString);
2704 }
2705 
<span class="line-added">2706 String plainTextUsingBackwardsTextIteratorForTesting(const Range&amp; range)</span>
<span class="line-added">2707 {</span>
<span class="line-added">2708     String result;</span>
<span class="line-added">2709     for (SimplifiedBackwardsTextIterator backwardsIterator(range); !backwardsIterator.atEnd(); backwardsIterator.advance())</span>
<span class="line-added">2710         result.insert(backwardsIterator.text().toString(), 0);</span>
<span class="line-added">2711     return result;</span>
<span class="line-added">2712 }</span>
<span class="line-added">2713 </span>
2714 String plainTextReplacingNoBreakSpace(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2715 {
2716     return plainText(range, defaultBehavior, isDisplayString).replace(noBreakSpace, &#39; &#39;);
2717 }
2718 
2719 static Ref&lt;Range&gt; collapsedToBoundary(const Range&amp; range, bool forward)
2720 {
2721     Ref&lt;Range&gt; result = range.cloneRange();
2722     result-&gt;collapse(!forward);
2723     return result;
2724 }
2725 
2726 static TextIteratorBehavior findIteratorOptions(FindOptions options)
2727 {
2728     TextIteratorBehavior iteratorOptions = TextIteratorEntersTextControls | TextIteratorClipsToFrameAncestors;
2729     if (!options.contains(DoNotTraverseFlatTree))
2730         iteratorOptions |= TextIteratorTraversesFlatTree;
2731     return iteratorOptions;
2732 }
2733 
</pre>
</td>
</tr>
</table>
<center><a href="TextGranularity.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextIterator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>