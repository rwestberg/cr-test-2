<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameTracers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackVisitor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
</pre>
<hr />
<pre>
  64 #include &quot;LiteralParser.h&quot;
  65 #include &quot;ModuleProgramCodeBlock.h&quot;
  66 #include &quot;ObjectPrototype.h&quot;
  67 #include &quot;Parser.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
  69 #include &quot;ProtoCallFrame.h&quot;
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;Register.h&quot;
  72 #include &quot;RegisterAtOffsetList.h&quot;
  73 #include &quot;ScopedArguments.h&quot;
  74 #include &quot;StackAlignment.h&quot;
  75 #include &quot;StackFrame.h&quot;
  76 #include &quot;StackVisitor.h&quot;
  77 #include &quot;StrictEvalActivation.h&quot;
  78 #include &quot;StrongInlines.h&quot;
  79 #include &quot;Symbol.h&quot;
  80 #include &quot;VMEntryScope.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;VMInspector.h&quot;
  83 #include &quot;VirtualRegister.h&quot;
<span class="line-removed">  84 </span>
  85 #include &lt;limits.h&gt;
  86 #include &lt;stdio.h&gt;
  87 #include &lt;wtf/NeverDestroyed.h&gt;
  88 #include &lt;wtf/StackStats.h&gt;
  89 #include &lt;wtf/StdLibExtras.h&gt;
  90 #include &lt;wtf/StringPrintStream.h&gt;
  91 #include &lt;wtf/Threading.h&gt;
  92 #include &lt;wtf/text/StringBuilder.h&gt;
  93 
  94 #if ENABLE(JIT)
  95 #include &quot;JIT.h&quot;
  96 #endif
  97 





  98 namespace JSC {
  99 
 100 JSValue eval(CallFrame* callFrame)
 101 {
 102     VM&amp; vm = callFrame-&gt;vm();
 103     auto scope = DECLARE_THROW_SCOPE(vm);
 104 
 105     if (!callFrame-&gt;argumentCount())
 106         return jsUndefined();
 107 
 108     JSValue program = callFrame-&gt;argument(0);
 109     if (!program.isString())
 110         return program;
 111 
 112     TopCallFrameSetter topCallFrame(vm, callFrame);
 113     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject();
 114     if (!globalObject-&gt;evalEnabled()) {
 115         throwException(callFrame, scope, createEvalError(callFrame, globalObject-&gt;evalDisabledErrorMessage()));
 116         return jsUndefined();
 117     }
</pre>
<hr />
<pre>
 532         , m_codeBlock(codeBlock)
 533         , m_handler(handler)
 534     {
 535     }
 536 
 537     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 538     {
 539         visitor.unwindToMachineCodeBlockFrame();
 540         m_callFrame = visitor-&gt;callFrame();
 541         m_codeBlock = visitor-&gt;codeBlock();
 542 
 543         m_handler = nullptr;
 544         if (!m_isTermination) {
 545             if (m_codeBlock) {
 546                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
 547                 if (m_handler)
 548                     return StackVisitor::Done;
 549             }
 550         }
 551 







 552         notifyDebuggerOfUnwinding(m_vm, m_callFrame);
 553 
 554         copyCalleeSavesToEntryFrameCalleeSavesBuffer(visitor);
 555 
 556         bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
 557         if (shouldStopUnwinding)
 558             return StackVisitor::Done;
 559 
 560         return StackVisitor::Continue;
 561     }
 562 
 563 private:
 564     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
 565     {
<span class="line-modified"> 566 #if !ENABLE(C_LOOP) &amp;&amp; NUMBER_OF_CALLEE_SAVES_REGISTERS &gt; 0</span>
<span class="line-modified"> 567         const RegisterAtOffsetList* currentCalleeSaves = visitor-&gt;calleeSaveRegisters();</span>
 568 
 569         if (!currentCalleeSaves)
 570             return;
 571 
 572         RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
 573         RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();
 574         CPURegister* frame = reinterpret_cast&lt;CPURegister*&gt;(m_callFrame-&gt;registers());
 575 
 576         unsigned registerCount = currentCalleeSaves-&gt;size();
 577         VMEntryRecord* record = vmEntryRecord(m_vm.topEntryFrame);
 578         for (unsigned i = 0; i &lt; registerCount; i++) {
 579             RegisterAtOffset currentEntry = currentCalleeSaves-&gt;at(i);
 580             if (dontCopyRegisters.get(currentEntry.reg()))
 581                 continue;
 582             RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
 583 
 584             record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()] = *(frame + currentEntry.offsetAsIndex());
 585         }
 586 #else
 587         UNUSED_PARAM(visitor);
</pre>
<hr />
<pre>
 634         bool hasCatchHandler;
 635         bool isTermination = isTerminatedExecutionException(vm, exception);
 636         if (isTermination)
 637             hasCatchHandler = false;
 638         else {
 639             GetCatchHandlerFunctor functor;
 640             StackVisitor::visit(callFrame, &amp;vm, functor);
 641             HandlerInfo* handler = functor.handler();
 642             ASSERT(!handler || handler-&gt;isCatchHandler());
 643             hasCatchHandler = !!handler;
 644         }
 645 
 646         debugger-&gt;exception(callFrame, exception-&gt;value(), hasCatchHandler);
 647     }
 648     exception-&gt;setDidNotifyInspectorOfThrow();
 649 }
 650 
 651 JSValue Interpreter::executeProgram(const SourceCode&amp; source, CallFrame* callFrame, JSObject* thisObj)
 652 {
 653     JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
<span class="line-modified"> 654     VM&amp; vm = *scope-&gt;vm();</span>
 655     auto throwScope = DECLARE_THROW_SCOPE(vm);
 656 
 657     ProgramExecutable* program = ProgramExecutable::create(callFrame, source);
 658     EXCEPTION_ASSERT(throwScope.exception() || program);
 659     RETURN_IF_EXCEPTION(throwScope, { });
 660 
 661     throwScope.assertNoException();
 662     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 663     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
 664     if (vm.isCollectorBusyOnCurrentThread())
 665         return jsNull();
 666 
 667     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 668         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 669 
 670     // First check if the &quot;program&quot; is actually just a JSON object. If so,
 671     // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
 672     // below at failedJSONP.
 673 
 674     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);
</pre>
<hr />
<pre>
 791             }
 792             result = JSONPValue;
 793         }
 794         return result;
 795     }
 796 failedJSONP:
 797     // If we get here, then we have already proven that the script is not a JSON
 798     // object.
 799 
 800     VMEntryScope entryScope(vm, globalObject);
 801 
 802     // Compile source to bytecode if necessary:
 803     JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope);
 804     EXCEPTION_ASSERT(!throwScope.exception() || !error);
 805     if (UNLIKELY(error))
 806         return checkedReturn(throwException(callFrame, throwScope, error));
 807 
 808     ProgramCodeBlock* codeBlock;
 809     {
 810         CodeBlock* tempCodeBlock;
<span class="line-modified"> 811         JSObject* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified"> 812         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
 813         if (UNLIKELY(error))
 814             return checkedReturn(error);
 815         codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
 816     }
 817 
 818     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 819     if (UNLIKELY(vm.needTrapHandling(mask))) {
 820         vm.handleTraps(callFrame, mask);
 821         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 822     }
 823 
 824     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
 825         scope-&gt;flattenDictionaryObject(vm);
 826 
 827     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
 828 
 829     ProtoCallFrame protoCallFrame;
 830     protoCallFrame.init(codeBlock, JSCallee::create(vm, globalObject, scope), thisObj, 1);
 831 
 832     // Execute the code:
</pre>
<hr />
<pre>
 849     JSScope* scope = nullptr;
 850     CodeBlock* newCodeBlock;
 851     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 852 
 853     JSGlobalObject* globalObject;
 854 
 855     if (isJSCall) {
 856         scope = callData.js.scope;
 857         globalObject = scope-&gt;globalObject(vm);
 858     } else {
 859         ASSERT(callType == CallType::Host);
 860         globalObject = function-&gt;globalObject(vm);
 861     }
 862 
 863     VMEntryScope entryScope(vm, globalObject);
 864     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 865         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 866 
 867     if (isJSCall) {
 868         // Compile the callee:
<span class="line-modified"> 869         JSObject* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);</span>
<span class="line-modified"> 870         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));</span>
 871         if (UNLIKELY(!!compileError))
 872             return checkedReturn(compileError);
 873 
 874         ASSERT(!!newCodeBlock);
 875         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 876     } else
 877         newCodeBlock = 0;
 878 
 879     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 880     if (UNLIKELY(vm.needTrapHandling(mask))) {
 881         vm.handleTraps(callFrame, mask);
 882         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 883     }
 884 
 885     ProtoCallFrame protoCallFrame;
 886     protoCallFrame.init(newCodeBlock, function, thisValue, argsCount, args.data());
 887 
 888     JSValue result;
 889     {
 890         // Execute the code:
</pre>
<hr />
<pre>
 892             throwScope.release();
 893             result = callData.js.functionExecutable-&gt;generatedJITCodeForCall()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 894         } else {
 895             result = JSValue::decode(vmEntryToNative(callData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 896             RETURN_IF_EXCEPTION(throwScope, JSValue());
 897         }
 898     }
 899 
 900     return checkedReturn(result);
 901 }
 902 
 903 JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)
 904 {
 905     VM&amp; vm = callFrame-&gt;vm();
 906     auto throwScope = DECLARE_THROW_SCOPE(vm);
 907 
 908     throwScope.assertNoException();
 909     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 910     // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
 911     // already in an invalid state.
<span class="line-modified"> 912     if (vm.isCollectorBusyOnCurrentThread())</span>
<span class="line-modified"> 913         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>


 914 
 915     bool isJSConstruct = (constructType == ConstructType::JS);
 916     JSScope* scope = nullptr;
 917     CodeBlock* newCodeBlock;
 918     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 919 
 920     JSGlobalObject* globalObject;
 921 
 922     if (isJSConstruct) {
 923         scope = constructData.js.scope;
 924         globalObject = scope-&gt;globalObject(vm);
 925     } else {
 926         ASSERT(constructType == ConstructType::Host);
 927         globalObject = constructor-&gt;globalObject(vm);
 928     }
 929 
 930     VMEntryScope entryScope(vm, globalObject);
<span class="line-modified"> 931     if (UNLIKELY(!vm.isSafeToRecurseSoft()))</span>
<span class="line-modified"> 932         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>


 933 
 934     if (isJSConstruct) {
 935         // Compile the callee:
<span class="line-modified"> 936         JSObject* compileError = constructData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(constructor), scope, CodeForConstruct, newCodeBlock);</span>
<span class="line-modified"> 937         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));</span>
 938         if (UNLIKELY(!!compileError))
<span class="line-modified"> 939             return checkedReturn(compileError);</span>
 940 
 941         ASSERT(!!newCodeBlock);
 942         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 943     } else
 944         newCodeBlock = 0;
 945 
 946     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 947     if (UNLIKELY(vm.needTrapHandling(mask))) {
 948         vm.handleTraps(callFrame, mask);
<span class="line-modified"> 949         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());</span>
 950     }
 951 
 952     ProtoCallFrame protoCallFrame;
 953     protoCallFrame.init(newCodeBlock, constructor, newTarget, argsCount, args.data());
 954 
 955     JSValue result;
 956     {
 957         // Execute the code.
 958         if (isJSConstruct)
 959             result = constructData.js.functionExecutable-&gt;generatedJITCodeForConstruct()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 960         else {
 961             result = JSValue::decode(vmEntryToNative(constructData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 962 
 963             if (LIKELY(!throwScope.exception()))
 964                 RELEASE_ASSERT(result.isObject());
 965         }
 966     }
 967 
 968     RETURN_IF_EXCEPTION(throwScope, 0);
 969     ASSERT(result.isObject());
 970     return checkedReturn(asObject(result));
 971 }
 972 
 973 CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* functionExecutable, CallFrame* callFrame, ProtoCallFrame* protoCallFrame, JSFunction* function, int argumentCountIncludingThis, JSScope* scope, const ArgList&amp; args)
 974 {
<span class="line-modified"> 975     VM&amp; vm = *scope-&gt;vm();</span>
 976     auto throwScope = DECLARE_THROW_SCOPE(vm);
 977     throwScope.assertNoException();
 978 
 979     if (vm.isCollectorBusyOnCurrentThread())
 980         return CallFrameClosure();
 981 
 982     // Compile the callee:
 983     CodeBlock* newCodeBlock;
<span class="line-modified"> 984     JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, CodeForCall, newCodeBlock);</span>
<span class="line-modified"> 985     EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
 986     if (UNLIKELY(error))
 987         return CallFrameClosure();
 988     newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 989 
 990     size_t argsCount = argumentCountIncludingThis;
 991 
 992     protoCallFrame-&gt;init(newCodeBlock, function, jsUndefined(), argsCount, args.data());
 993     // Return the successful closure:
 994     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
 995     return result;
 996 }
 997 
 998 JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, JSScope* scope)
 999 {
<span class="line-modified">1000     VM&amp; vm = *scope-&gt;vm();</span>
1001     auto throwScope = DECLARE_THROW_SCOPE(vm);
1002 
1003     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1004     throwScope.assertNoException();
1005     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1006     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1007     if (vm.isCollectorBusyOnCurrentThread())
1008         return jsNull();
1009 
1010     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1011     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1012         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1013 
1014     unsigned numVariables = eval-&gt;numVariables();
1015     unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
1016     unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
1017 
1018     JSScope* variableObject;
1019     if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<span class="line-modified">1020         scope = StrictEvalActivation::create(callFrame, scope);</span>
1021         variableObject = scope;
1022     } else {
1023         for (JSScope* node = scope; ; node = node-&gt;next()) {
1024             RELEASE_ASSERT(node);
1025             if (node-&gt;isGlobalObject()) {
1026                 variableObject = node;
1027                 break;
1028             }
1029             if (node-&gt;isJSLexicalEnvironment()) {
1030                 JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(node);
1031                 if (lexicalEnvironment-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope) {
1032                     variableObject = node;
1033                     break;
1034                 }
1035             }
1036         }
1037     }
1038 
1039     EvalCodeBlock* codeBlock;
1040     {
1041         CodeBlock* tempCodeBlock;
<span class="line-modified">1042         JSObject* compileError = eval-&gt;prepareForExecution&lt;EvalExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified">1043         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));</span>
1044         if (UNLIKELY(!!compileError))
1045             return checkedReturn(compileError);
1046         codeBlock = jsCast&lt;EvalCodeBlock*&gt;(tempCodeBlock);
1047     }
1048     UnlinkedEvalCodeBlock* unlinkedCodeBlock = codeBlock-&gt;unlinkedEvalCodeBlock();
1049 
1050     // We can&#39;t declare a &quot;var&quot;/&quot;function&quot; that overwrites a global &quot;let&quot;/&quot;const&quot;/&quot;class&quot; in a sloppy-mode eval.
1051     if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
1052         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
1053         for (unsigned i = 0; i &lt; numVariables; ++i) {
1054             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1055             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
1056             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, ident, slot)) {
1057                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));
1058             }
1059         }
1060 
1061         for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1062             FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1063             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
</pre>
<hr />
<pre>
1129     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1130     if (UNLIKELY(vm.needTrapHandling(mask))) {
1131         vm.handleTraps(callFrame, mask);
1132         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1133     }
1134 
1135     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1136 
1137     ProtoCallFrame protoCallFrame;
1138     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), thisValue, 1);
1139 
1140     // Execute the code:
1141     throwScope.release();
1142     JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1143 
1144     return checkedReturn(result);
1145 }
1146 
1147 JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, CallFrame* callFrame, JSModuleEnvironment* scope)
1148 {
<span class="line-modified">1149     VM&amp; vm = *scope-&gt;vm();</span>
1150     auto throwScope = DECLARE_THROW_SCOPE(vm);
1151 
1152     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1153     throwScope.assertNoException();
1154     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1155     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1156     if (vm.isCollectorBusyOnCurrentThread())
1157         return jsNull();
1158 
1159     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1160     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1161         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1162 
1163     ModuleProgramCodeBlock* codeBlock;
1164     {
1165         CodeBlock* tempCodeBlock;
<span class="line-modified">1166         JSObject* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified">1167         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(compileError));</span>
1168         if (UNLIKELY(!!compileError))
1169             return checkedReturn(compileError);
1170         codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
1171     }
1172 
1173     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1174     if (UNLIKELY(vm.needTrapHandling(mask))) {
1175         vm.handleTraps(callFrame, mask);
1176         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1177     }
1178 
1179     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
1180         scope-&gt;flattenDictionaryObject(vm);
1181 
1182     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1183 
1184     // The |this| of the module is always `undefined`.
1185     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
1186     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
1187     ProtoCallFrame protoCallFrame;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
</pre>
<hr />
<pre>
  64 #include &quot;LiteralParser.h&quot;
  65 #include &quot;ModuleProgramCodeBlock.h&quot;
  66 #include &quot;ObjectPrototype.h&quot;
  67 #include &quot;Parser.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
  69 #include &quot;ProtoCallFrame.h&quot;
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;Register.h&quot;
  72 #include &quot;RegisterAtOffsetList.h&quot;
  73 #include &quot;ScopedArguments.h&quot;
  74 #include &quot;StackAlignment.h&quot;
  75 #include &quot;StackFrame.h&quot;
  76 #include &quot;StackVisitor.h&quot;
  77 #include &quot;StrictEvalActivation.h&quot;
  78 #include &quot;StrongInlines.h&quot;
  79 #include &quot;Symbol.h&quot;
  80 #include &quot;VMEntryScope.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;VMInspector.h&quot;
  83 #include &quot;VirtualRegister.h&quot;

  84 #include &lt;limits.h&gt;
  85 #include &lt;stdio.h&gt;
  86 #include &lt;wtf/NeverDestroyed.h&gt;
  87 #include &lt;wtf/StackStats.h&gt;
  88 #include &lt;wtf/StdLibExtras.h&gt;
  89 #include &lt;wtf/StringPrintStream.h&gt;
  90 #include &lt;wtf/Threading.h&gt;
  91 #include &lt;wtf/text/StringBuilder.h&gt;
  92 
  93 #if ENABLE(JIT)
  94 #include &quot;JIT.h&quot;
  95 #endif
  96 
<span class="line-added">  97 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">  98 #include &quot;WasmContextInlines.h&quot;</span>
<span class="line-added">  99 #include &quot;WebAssemblyFunction.h&quot;</span>
<span class="line-added"> 100 #endif</span>
<span class="line-added"> 101 </span>
 102 namespace JSC {
 103 
 104 JSValue eval(CallFrame* callFrame)
 105 {
 106     VM&amp; vm = callFrame-&gt;vm();
 107     auto scope = DECLARE_THROW_SCOPE(vm);
 108 
 109     if (!callFrame-&gt;argumentCount())
 110         return jsUndefined();
 111 
 112     JSValue program = callFrame-&gt;argument(0);
 113     if (!program.isString())
 114         return program;
 115 
 116     TopCallFrameSetter topCallFrame(vm, callFrame);
 117     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject();
 118     if (!globalObject-&gt;evalEnabled()) {
 119         throwException(callFrame, scope, createEvalError(callFrame, globalObject-&gt;evalDisabledErrorMessage()));
 120         return jsUndefined();
 121     }
</pre>
<hr />
<pre>
 536         , m_codeBlock(codeBlock)
 537         , m_handler(handler)
 538     {
 539     }
 540 
 541     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 542     {
 543         visitor.unwindToMachineCodeBlockFrame();
 544         m_callFrame = visitor-&gt;callFrame();
 545         m_codeBlock = visitor-&gt;codeBlock();
 546 
 547         m_handler = nullptr;
 548         if (!m_isTermination) {
 549             if (m_codeBlock) {
 550                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
 551                 if (m_handler)
 552                     return StackVisitor::Done;
 553             }
 554         }
 555 
<span class="line-added"> 556 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 557         if (visitor-&gt;callee().isCell()) {</span>
<span class="line-added"> 558             if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(m_vm, visitor-&gt;callee().asCell()))</span>
<span class="line-added"> 559                 m_vm.wasmContext.store(jsToWasmICCallee-&gt;function()-&gt;previousInstance(m_callFrame), m_vm.softStackLimit());</span>
<span class="line-added"> 560         }</span>
<span class="line-added"> 561 #endif</span>
<span class="line-added"> 562 </span>
 563         notifyDebuggerOfUnwinding(m_vm, m_callFrame);
 564 
 565         copyCalleeSavesToEntryFrameCalleeSavesBuffer(visitor);
 566 
 567         bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
 568         if (shouldStopUnwinding)
 569             return StackVisitor::Done;
 570 
 571         return StackVisitor::Continue;
 572     }
 573 
 574 private:
 575     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
 576     {
<span class="line-modified"> 577 #if ENABLE(ASSEMBLER)</span>
<span class="line-modified"> 578         Optional&lt;RegisterAtOffsetList&gt; currentCalleeSaves = visitor-&gt;calleeSaveRegistersForUnwinding();</span>
 579 
 580         if (!currentCalleeSaves)
 581             return;
 582 
 583         RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
 584         RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();
 585         CPURegister* frame = reinterpret_cast&lt;CPURegister*&gt;(m_callFrame-&gt;registers());
 586 
 587         unsigned registerCount = currentCalleeSaves-&gt;size();
 588         VMEntryRecord* record = vmEntryRecord(m_vm.topEntryFrame);
 589         for (unsigned i = 0; i &lt; registerCount; i++) {
 590             RegisterAtOffset currentEntry = currentCalleeSaves-&gt;at(i);
 591             if (dontCopyRegisters.get(currentEntry.reg()))
 592                 continue;
 593             RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
 594 
 595             record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()] = *(frame + currentEntry.offsetAsIndex());
 596         }
 597 #else
 598         UNUSED_PARAM(visitor);
</pre>
<hr />
<pre>
 645         bool hasCatchHandler;
 646         bool isTermination = isTerminatedExecutionException(vm, exception);
 647         if (isTermination)
 648             hasCatchHandler = false;
 649         else {
 650             GetCatchHandlerFunctor functor;
 651             StackVisitor::visit(callFrame, &amp;vm, functor);
 652             HandlerInfo* handler = functor.handler();
 653             ASSERT(!handler || handler-&gt;isCatchHandler());
 654             hasCatchHandler = !!handler;
 655         }
 656 
 657         debugger-&gt;exception(callFrame, exception-&gt;value(), hasCatchHandler);
 658     }
 659     exception-&gt;setDidNotifyInspectorOfThrow();
 660 }
 661 
 662 JSValue Interpreter::executeProgram(const SourceCode&amp; source, CallFrame* callFrame, JSObject* thisObj)
 663 {
 664     JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
<span class="line-modified"> 665     VM&amp; vm = scope-&gt;vm();</span>
 666     auto throwScope = DECLARE_THROW_SCOPE(vm);
 667 
 668     ProgramExecutable* program = ProgramExecutable::create(callFrame, source);
 669     EXCEPTION_ASSERT(throwScope.exception() || program);
 670     RETURN_IF_EXCEPTION(throwScope, { });
 671 
 672     throwScope.assertNoException();
 673     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 674     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
 675     if (vm.isCollectorBusyOnCurrentThread())
 676         return jsNull();
 677 
 678     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 679         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 680 
 681     // First check if the &quot;program&quot; is actually just a JSON object. If so,
 682     // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
 683     // below at failedJSONP.
 684 
 685     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);
</pre>
<hr />
<pre>
 802             }
 803             result = JSONPValue;
 804         }
 805         return result;
 806     }
 807 failedJSONP:
 808     // If we get here, then we have already proven that the script is not a JSON
 809     // object.
 810 
 811     VMEntryScope entryScope(vm, globalObject);
 812 
 813     // Compile source to bytecode if necessary:
 814     JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope);
 815     EXCEPTION_ASSERT(!throwScope.exception() || !error);
 816     if (UNLIKELY(error))
 817         return checkedReturn(throwException(callFrame, throwScope, error));
 818 
 819     ProgramCodeBlock* codeBlock;
 820     {
 821         CodeBlock* tempCodeBlock;
<span class="line-modified"> 822         Exception* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified"> 823         EXCEPTION_ASSERT(throwScope.exception() == error);</span>
 824         if (UNLIKELY(error))
 825             return checkedReturn(error);
 826         codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
 827     }
 828 
 829     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 830     if (UNLIKELY(vm.needTrapHandling(mask))) {
 831         vm.handleTraps(callFrame, mask);
 832         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 833     }
 834 
 835     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
 836         scope-&gt;flattenDictionaryObject(vm);
 837 
 838     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
 839 
 840     ProtoCallFrame protoCallFrame;
 841     protoCallFrame.init(codeBlock, JSCallee::create(vm, globalObject, scope), thisObj, 1);
 842 
 843     // Execute the code:
</pre>
<hr />
<pre>
 860     JSScope* scope = nullptr;
 861     CodeBlock* newCodeBlock;
 862     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 863 
 864     JSGlobalObject* globalObject;
 865 
 866     if (isJSCall) {
 867         scope = callData.js.scope;
 868         globalObject = scope-&gt;globalObject(vm);
 869     } else {
 870         ASSERT(callType == CallType::Host);
 871         globalObject = function-&gt;globalObject(vm);
 872     }
 873 
 874     VMEntryScope entryScope(vm, globalObject);
 875     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
 876         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
 877 
 878     if (isJSCall) {
 879         // Compile the callee:
<span class="line-modified"> 880         Exception* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);</span>
<span class="line-modified"> 881         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
 882         if (UNLIKELY(!!compileError))
 883             return checkedReturn(compileError);
 884 
 885         ASSERT(!!newCodeBlock);
 886         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 887     } else
 888         newCodeBlock = 0;
 889 
 890     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 891     if (UNLIKELY(vm.needTrapHandling(mask))) {
 892         vm.handleTraps(callFrame, mask);
 893         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 894     }
 895 
 896     ProtoCallFrame protoCallFrame;
 897     protoCallFrame.init(newCodeBlock, function, thisValue, argsCount, args.data());
 898 
 899     JSValue result;
 900     {
 901         // Execute the code:
</pre>
<hr />
<pre>
 903             throwScope.release();
 904             result = callData.js.functionExecutable-&gt;generatedJITCodeForCall()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 905         } else {
 906             result = JSValue::decode(vmEntryToNative(callData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 907             RETURN_IF_EXCEPTION(throwScope, JSValue());
 908         }
 909     }
 910 
 911     return checkedReturn(result);
 912 }
 913 
 914 JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)
 915 {
 916     VM&amp; vm = callFrame-&gt;vm();
 917     auto throwScope = DECLARE_THROW_SCOPE(vm);
 918 
 919     throwScope.assertNoException();
 920     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 921     // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
 922     // already in an invalid state.
<span class="line-modified"> 923     if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {</span>
<span class="line-modified"> 924         throwStackOverflowError(callFrame, throwScope);</span>
<span class="line-added"> 925         return nullptr;</span>
<span class="line-added"> 926     }</span>
 927 
 928     bool isJSConstruct = (constructType == ConstructType::JS);
 929     JSScope* scope = nullptr;
 930     CodeBlock* newCodeBlock;
 931     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 932 
 933     JSGlobalObject* globalObject;
 934 
 935     if (isJSConstruct) {
 936         scope = constructData.js.scope;
 937         globalObject = scope-&gt;globalObject(vm);
 938     } else {
 939         ASSERT(constructType == ConstructType::Host);
 940         globalObject = constructor-&gt;globalObject(vm);
 941     }
 942 
 943     VMEntryScope entryScope(vm, globalObject);
<span class="line-modified"> 944     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {</span>
<span class="line-modified"> 945         throwStackOverflowError(callFrame, throwScope);</span>
<span class="line-added"> 946         return nullptr;</span>
<span class="line-added"> 947     }</span>
 948 
 949     if (isJSConstruct) {
 950         // Compile the callee:
<span class="line-modified"> 951         Exception* compileError = constructData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(constructor), scope, CodeForConstruct, newCodeBlock);</span>
<span class="line-modified"> 952         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
 953         if (UNLIKELY(!!compileError))
<span class="line-modified"> 954             return nullptr;</span>
 955 
 956         ASSERT(!!newCodeBlock);
 957         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 958     } else
 959         newCodeBlock = 0;
 960 
 961     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
 962     if (UNLIKELY(vm.needTrapHandling(mask))) {
 963         vm.handleTraps(callFrame, mask);
<span class="line-modified"> 964         RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
 965     }
 966 
 967     ProtoCallFrame protoCallFrame;
 968     protoCallFrame.init(newCodeBlock, constructor, newTarget, argsCount, args.data());
 969 
 970     JSValue result;
 971     {
 972         // Execute the code.
 973         if (isJSConstruct)
 974             result = constructData.js.functionExecutable-&gt;generatedJITCodeForConstruct()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 975         else {
 976             result = JSValue::decode(vmEntryToNative(constructData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 977 
 978             if (LIKELY(!throwScope.exception()))
 979                 RELEASE_ASSERT(result.isObject());
 980         }
 981     }
 982 
 983     RETURN_IF_EXCEPTION(throwScope, 0);
 984     ASSERT(result.isObject());
 985     return checkedReturn(asObject(result));
 986 }
 987 
 988 CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* functionExecutable, CallFrame* callFrame, ProtoCallFrame* protoCallFrame, JSFunction* function, int argumentCountIncludingThis, JSScope* scope, const ArgList&amp; args)
 989 {
<span class="line-modified"> 990     VM&amp; vm = scope-&gt;vm();</span>
 991     auto throwScope = DECLARE_THROW_SCOPE(vm);
 992     throwScope.assertNoException();
 993 
 994     if (vm.isCollectorBusyOnCurrentThread())
 995         return CallFrameClosure();
 996 
 997     // Compile the callee:
 998     CodeBlock* newCodeBlock;
<span class="line-modified"> 999     Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, CodeForCall, newCodeBlock);</span>
<span class="line-modified">1000     EXCEPTION_ASSERT(throwScope.exception() == error);</span>
1001     if (UNLIKELY(error))
1002         return CallFrameClosure();
1003     newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
1004 
1005     size_t argsCount = argumentCountIncludingThis;
1006 
1007     protoCallFrame-&gt;init(newCodeBlock, function, jsUndefined(), argsCount, args.data());
1008     // Return the successful closure:
1009     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
1010     return result;
1011 }
1012 
1013 JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, JSScope* scope)
1014 {
<span class="line-modified">1015     VM&amp; vm = scope-&gt;vm();</span>
1016     auto throwScope = DECLARE_THROW_SCOPE(vm);
1017 
1018     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1019     throwScope.assertNoException();
1020     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1021     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1022     if (vm.isCollectorBusyOnCurrentThread())
1023         return jsNull();
1024 
1025     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1026     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1027         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1028 
1029     unsigned numVariables = eval-&gt;numVariables();
1030     unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
1031     unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
1032 
1033     JSScope* variableObject;
1034     if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<span class="line-modified">1035         scope = StrictEvalActivation::create(vm, callFrame-&gt;lexicalGlobalObject()-&gt;strictEvalActivationStructure(), scope);</span>
1036         variableObject = scope;
1037     } else {
1038         for (JSScope* node = scope; ; node = node-&gt;next()) {
1039             RELEASE_ASSERT(node);
1040             if (node-&gt;isGlobalObject()) {
1041                 variableObject = node;
1042                 break;
1043             }
1044             if (node-&gt;isJSLexicalEnvironment()) {
1045                 JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(node);
1046                 if (lexicalEnvironment-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope) {
1047                     variableObject = node;
1048                     break;
1049                 }
1050             }
1051         }
1052     }
1053 
1054     EvalCodeBlock* codeBlock;
1055     {
1056         CodeBlock* tempCodeBlock;
<span class="line-modified">1057         Exception* compileError = eval-&gt;prepareForExecution&lt;EvalExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified">1058         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
1059         if (UNLIKELY(!!compileError))
1060             return checkedReturn(compileError);
1061         codeBlock = jsCast&lt;EvalCodeBlock*&gt;(tempCodeBlock);
1062     }
1063     UnlinkedEvalCodeBlock* unlinkedCodeBlock = codeBlock-&gt;unlinkedEvalCodeBlock();
1064 
1065     // We can&#39;t declare a &quot;var&quot;/&quot;function&quot; that overwrites a global &quot;let&quot;/&quot;const&quot;/&quot;class&quot; in a sloppy-mode eval.
1066     if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
1067         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
1068         for (unsigned i = 0; i &lt; numVariables; ++i) {
1069             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1070             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
1071             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, ident, slot)) {
1072                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));
1073             }
1074         }
1075 
1076         for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1077             FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1078             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
</pre>
<hr />
<pre>
1144     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1145     if (UNLIKELY(vm.needTrapHandling(mask))) {
1146         vm.handleTraps(callFrame, mask);
1147         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1148     }
1149 
1150     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1151 
1152     ProtoCallFrame protoCallFrame;
1153     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), thisValue, 1);
1154 
1155     // Execute the code:
1156     throwScope.release();
1157     JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1158 
1159     return checkedReturn(result);
1160 }
1161 
1162 JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, CallFrame* callFrame, JSModuleEnvironment* scope)
1163 {
<span class="line-modified">1164     VM&amp; vm = scope-&gt;vm();</span>
1165     auto throwScope = DECLARE_THROW_SCOPE(vm);
1166 
1167     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());
1168     throwScope.assertNoException();
1169     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1170     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1171     if (vm.isCollectorBusyOnCurrentThread())
1172         return jsNull();
1173 
1174     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1175     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
1176         return checkedReturn(throwStackOverflowError(callFrame, throwScope));
1177 
1178     ModuleProgramCodeBlock* codeBlock;
1179     {
1180         CodeBlock* tempCodeBlock;
<span class="line-modified">1181         Exception* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);</span>
<span class="line-modified">1182         EXCEPTION_ASSERT(throwScope.exception() == compileError);</span>
1183         if (UNLIKELY(!!compileError))
1184             return checkedReturn(compileError);
1185         codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
1186     }
1187 
1188     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
1189     if (UNLIKELY(vm.needTrapHandling(mask))) {
1190         vm.handleTraps(callFrame, mask);
1191         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1192     }
1193 
1194     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
1195         scope-&gt;flattenDictionaryObject(vm);
1196 
1197     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1198 
1199     // The |this| of the module is always `undefined`.
1200     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
1201     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
1202     ProtoCallFrame protoCallFrame;
</pre>
</td>
</tr>
</table>
<center><a href="FrameTracers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackVisitor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>