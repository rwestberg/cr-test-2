<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ArgList.h&quot;
  26 #include &quot;CallFrame.h&quot;
  27 #include &quot;CommonIdentifiers.h&quot;
  28 #include &quot;Identifier.h&quot;
  29 #include &quot;PropertyDescriptor.h&quot;
  30 #include &quot;PropertySlot.h&quot;
  31 #include &quot;Structure.h&quot;
  32 #include &quot;ThrowScope.h&quot;
  33 #include &lt;array&gt;
  34 #include &lt;wtf/CheckedArithmetic.h&gt;
  35 #include &lt;wtf/ForbidHeapAllocation.h&gt;
  36 #include &lt;wtf/text/StringView.h&gt;
  37 
  38 namespace JSC {
  39 
  40 class JSString;
  41 class JSRopeString;
  42 class LLIntOffsetsExtractor;
  43 
<a name="1" id="anc1"></a><span class="line-modified">  44 JSString* jsEmptyString(VM*);</span>
<span class="line-modified">  45 JSString* jsEmptyString(ExecState*);</span>
<span class="line-removed">  46 JSString* jsString(VM*, const String&amp;); // returns empty string if passed null string</span>
<span class="line-removed">  47 JSString* jsString(ExecState*, const String&amp;); // returns empty string if passed null string</span>
  48 
<a name="2" id="anc2"></a><span class="line-modified">  49 JSString* jsSingleCharacterString(VM*, UChar);</span>
<span class="line-modified">  50 JSString* jsSingleCharacterString(ExecState*, UChar);</span>
<span class="line-removed">  51 JSString* jsSubstring(VM*, const String&amp;, unsigned offset, unsigned length);</span>
<span class="line-removed">  52 JSString* jsSubstring(ExecState*, const String&amp;, unsigned offset, unsigned length);</span>
  53 
  54 // Non-trivial strings are two or more characters long.
  55 // These functions are faster than just calling jsString.
<a name="3" id="anc3"></a><span class="line-modified">  56 JSString* jsNontrivialString(VM*, const String&amp;);</span>
<span class="line-modified">  57 JSString* jsNontrivialString(ExecState*, const String&amp;);</span>
<span class="line-removed">  58 JSString* jsNontrivialString(ExecState*, String&amp;&amp;);</span>
  59 
  60 // Should be used for strings that are owned by an object that will
  61 // likely outlive the JSValue this makes, such as the parse tree or a
  62 // DOM object that contains a String
<a name="4" id="anc4"></a><span class="line-modified">  63 JSString* jsOwnedString(VM*, const String&amp;);</span>
<span class="line-removed">  64 JSString* jsOwnedString(ExecState*, const String&amp;);</span>
  65 
  66 bool isJSString(JSCell*);
  67 bool isJSString(JSValue);
  68 JSString* asString(JSValue);
  69 
  70 // In 64bit architecture, JSString and JSRopeString have the following memory layout to make sizeof(JSString) == 16 and sizeof(JSRopeString) == 32.
  71 // JSString has only one pointer. We use it for String. length() and is8Bit() queries go to StringImpl. In JSRopeString, we reuse the above pointer
  72 // place for the 1st fiber. JSRopeString has three fibers so its size is 48. To keep length and is8Bit flag information in JSRopeString, JSRopeString
  73 // encodes these information into the fiber pointers. is8Bit flag is encoded in the 1st fiber pointer. length is embedded directly, and two fibers
  74 // are compressed into 12bytes. isRope information is encoded in the first fiber&#39;s LSB.
  75 //
  76 // Since length of JSRopeString should be frequently accessed compared to each fiber, we put length in contiguous 32byte field, and compress 2nd
  77 // and 3rd fibers into the following 80byte fields. One problem is that now 2nd and 3rd fibers are split. Storing and loading 2nd and 3rd fibers
  78 // are not one pointer load operation. To make concurrent collector work correctly, we must initialize 2nd and 3rd fibers at JSRopeString creation
  79 // and we must not modify these part later.
  80 //
  81 //              0                        8        10               16                       32                                     48
  82 // JSString     [   ID      ][  header  ][   String pointer      0]
<a name="5" id="anc5"></a><span class="line-modified">  83 // JSRopeString [   ID      ][  header  ][ flags ][ 1st fiber    1][  length  ][2nd lower32][2nd upper16][3rd lower16][3rd upper32]</span>
  84 //                                                               ^
<a name="6" id="anc6"></a><span class="line-modified">  85 //                                                            isRope bit</span>
  86 class JSString : public JSCell {
  87 public:
  88     friend class JIT;
  89     friend class VM;
  90     friend class SpecializedThunkJIT;
  91     friend class JSRopeString;
  92     friend class MarkStack;
  93     friend class SlotVisitor;
  94     friend class SmallStrings;
  95 
  96     typedef JSCell Base;
  97     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | StructureIsImmortal | OverridesToThis;
  98 
  99     static const bool needsDestruction = true;
 100     static void destroy(JSCell*);
 101 
 102     // We specialize the string subspace to get the fastest possible sweep. This wouldn&#39;t be
 103     // necessary if JSString didn&#39;t have a destructor.
 104     template&lt;typename, SubspaceAccess&gt;
 105     static CompleteSubspace* subspaceFor(VM&amp; vm)
 106     {
 107         return &amp;vm.stringSpace;
 108     }
 109 
 110     // We employ overflow checks in many places with the assumption that MaxLength
 111     // is INT_MAX. Hence, it cannot be changed into another length value without
 112     // breaking all the bounds and overflow checks that assume this.
 113     static constexpr unsigned MaxLength = std::numeric_limits&lt;int32_t&gt;::max();
 114     static_assert(MaxLength == String::MaxLength, &quot;&quot;);
 115 
 116     static constexpr uintptr_t isRopeInPointer = 0x1;
 117 
 118 private:
 119     String&amp; uninitializedValueInternal() const
 120     {
 121         return *bitwise_cast&lt;String*&gt;(&amp;m_fiber);
 122     }
 123 
 124     String&amp; valueInternal() const
 125     {
 126         ASSERT(!isRope());
 127         return uninitializedValueInternal();
 128     }
 129 
 130     JSString(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 131         : JSCell(vm, vm.stringStructure.get())
 132     {
 133         new (&amp;uninitializedValueInternal()) String(WTFMove(value));
 134     }
 135 
 136     JSString(VM&amp; vm)
 137         : JSCell(vm, vm.stringStructure.get())
 138         , m_fiber(isRopeInPointer)
 139     {
 140     }
 141 
 142     void finishCreation(VM&amp; vm, unsigned length)
 143     {
 144         ASSERT_UNUSED(length, length &gt; 0);
 145         ASSERT(!valueInternal().isNull());
 146         Base::finishCreation(vm);
 147     }
 148 
 149     void finishCreation(VM&amp; vm, unsigned length, size_t cost)
 150     {
 151         ASSERT_UNUSED(length, length &gt; 0);
 152         ASSERT(!valueInternal().isNull());
 153         Base::finishCreation(vm);
 154         vm.heap.reportExtraMemoryAllocated(cost);
 155     }
 156 
 157     static JSString* createEmptyString(VM&amp;);
 158 
 159     static JSString* create(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 160     {
 161         unsigned length = value-&gt;length();
 162         ASSERT(length &gt; 0);
 163         size_t cost = value-&gt;cost();
 164         JSString* newString = new (NotNull, allocateCell&lt;JSString&gt;(vm.heap)) JSString(vm, WTFMove(value));
 165         newString-&gt;finishCreation(vm, length, cost);
 166         return newString;
 167     }
 168     static JSString* createHasOtherOwner(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 169     {
 170         unsigned length = value-&gt;length();
 171         JSString* newString = new (NotNull, allocateCell&lt;JSString&gt;(vm.heap)) JSString(vm, WTFMove(value));
 172         newString-&gt;finishCreation(vm, length);
 173         return newString;
 174     }
 175 
 176 protected:
 177     void finishCreation(VM&amp; vm)
 178     {
 179         Base::finishCreation(vm);
 180     }
 181 
 182 public:
 183     ~JSString();
 184 
 185     Identifier toIdentifier(ExecState*) const;
<a name="7" id="anc7"></a><span class="line-modified"> 186     AtomicString toAtomicString(ExecState*) const;</span>
<span class="line-modified"> 187     RefPtr&lt;AtomicStringImpl&gt; toExistingAtomicString(ExecState*) const;</span>
 188 
 189     StringViewWithUnderlyingString viewWithUnderlyingString(ExecState*) const;
 190 
 191     inline bool equal(ExecState*, JSString* other) const;
 192     const String&amp; value(ExecState*) const;
 193     inline const String&amp; tryGetValue(bool allocationAllowed = true) const;
 194     const StringImpl* tryGetValueImpl() const;
 195     ALWAYS_INLINE unsigned length() const;
 196 
 197     JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;
 198     bool toBoolean() const { return !!length(); }
 199     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;) const;
 200     JSObject* toObject(ExecState*, JSGlobalObject*) const;
 201     double toNumber(ExecState*) const;
 202 
 203     bool getStringPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);
 204     bool getStringPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);
 205     bool getStringPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);
 206 
 207     bool canGetIndex(unsigned i) { return i &lt; length(); }
 208     JSString* getIndex(ExecState*, unsigned);
 209 
 210     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue);
 211 
 212     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(JSString, m_fiber); }
 213 
 214     DECLARE_EXPORT_INFO;
 215 
 216     static void dumpToStream(const JSCell*, PrintStream&amp;);
 217     static size_t estimatedSize(JSCell*, VM&amp;);
 218     static void visitChildren(JSCell*, SlotVisitor&amp;);
 219 
 220     ALWAYS_INLINE bool isRope() const
 221     {
 222         return m_fiber &amp; isRopeInPointer;
 223     }
 224 
 225     bool is8Bit() const;
 226 
 227 protected:
 228     friend class JSValue;
 229 
 230     JS_EXPORT_PRIVATE bool equalSlowCase(ExecState*, JSString* other) const;
 231     bool isSubstring() const;
 232 
 233     mutable uintptr_t m_fiber;
 234 
 235 private:
 236     friend class LLIntOffsetsExtractor;
 237 
 238     static JSValue toThis(JSCell*, ExecState*, ECMAMode);
 239 
 240     StringView unsafeView(ExecState*) const;
 241 
<a name="8" id="anc8"></a><span class="line-modified"> 242     friend JSString* jsString(VM*, const String&amp;);</span>
 243     friend JSString* jsString(ExecState*, JSString*, JSString*);
 244     friend JSString* jsString(ExecState*, const String&amp;, JSString*);
 245     friend JSString* jsString(ExecState*, JSString*, const String&amp;);
 246     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;);
 247     friend JSString* jsString(ExecState*, JSString*, JSString*, JSString*);
 248     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;, const String&amp;);
<a name="9" id="anc9"></a><span class="line-modified"> 249     friend JSString* jsSingleCharacterString(VM*, UChar);</span>
<span class="line-modified"> 250     friend JSString* jsNontrivialString(VM*, const String&amp;);</span>
<span class="line-modified"> 251     friend JSString* jsNontrivialString(VM*, String&amp;&amp;);</span>
<span class="line-modified"> 252     friend JSString* jsSubstring(VM*, const String&amp;, unsigned, unsigned);</span>
 253     friend JSString* jsSubstring(VM&amp;, ExecState*, JSString*, unsigned, unsigned);
 254     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
<a name="10" id="anc10"></a><span class="line-modified"> 255     friend JSString* jsOwnedString(VM*, const String&amp;);</span>
 256 };
 257 
 258 // NOTE: This class cannot override JSString&#39;s destructor. JSString&#39;s destructor is called directly
 259 // from JSStringSubspace::
 260 class JSRopeString final : public JSString {
 261     friend class JSString;
 262 public:
<a name="11" id="anc11"></a>






 263 #if CPU(ADDRESS64)
 264     static_assert(sizeof(uintptr_t) == sizeof(uint64_t), &quot;&quot;);
<a name="12" id="anc12"></a><span class="line-removed"> 265     static constexpr uintptr_t flagMask = 0xffff000000000000ULL;</span>
<span class="line-removed"> 266     static constexpr uintptr_t stringMask = ~(flagMask | isRopeInPointer);</span>
<span class="line-removed"> 267     static_assert(StringImpl::flagIs8Bit() == 0b100, &quot;&quot;);</span>
<span class="line-removed"> 268     static constexpr uintptr_t is8BitInPointer = static_cast&lt;uintptr_t&gt;(StringImpl::flagIs8Bit()) &lt;&lt; 48;</span>
<span class="line-removed"> 269 </span>
 270     class CompactFibers {
 271     public:
<a name="13" id="anc13"></a>
 272         JSString* fiber1() const
 273         {
<a name="14" id="anc14"></a>


 274             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber1Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber1Upper) &lt;&lt; 32));
<a name="15" id="anc15"></a>
 275         }
 276 
 277         void initializeFiber1(JSString* fiber)
 278         {
 279             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 280             m_fiber1Lower = static_cast&lt;uint32_t&gt;(pointer);
 281             m_fiber1Upper = static_cast&lt;uint16_t&gt;(pointer &gt;&gt; 32);
 282         }
 283 
 284         JSString* fiber2() const
 285         {
<a name="16" id="anc16"></a><span class="line-modified"> 286             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber2Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber2Upper) &lt;&lt; 32));</span>







 287         }
 288         void initializeFiber2(JSString* fiber)
 289         {
 290             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
<a name="17" id="anc17"></a><span class="line-modified"> 291             m_fiber2Lower = static_cast&lt;uint32_t&gt;(pointer);</span>
<span class="line-modified"> 292             m_fiber2Upper = static_cast&lt;uint16_t&gt;(pointer &gt;&gt; 32);</span>
 293         }
 294 
 295         unsigned length() const { return m_length; }
 296         void initializeLength(unsigned length)
 297         {
 298             m_length = length;
 299         }
 300 
 301         static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
<a name="18" id="anc18"></a><span class="line-modified"> 302         static ptrdiff_t offsetOfFiber1Lower() { return OBJECT_OFFSETOF(CompactFibers, m_fiber1Lower); }</span>
<span class="line-modified"> 303         static ptrdiff_t offsetOfFiber1Upper() { return OBJECT_OFFSETOF(CompactFibers, m_fiber1Upper); }</span>
<span class="line-removed"> 304         static ptrdiff_t offsetOfFiber2Lower() { return OBJECT_OFFSETOF(CompactFibers, m_fiber2Lower); }</span>
<span class="line-removed"> 305         static ptrdiff_t offsetOfFiber2Upper() { return OBJECT_OFFSETOF(CompactFibers, m_fiber2Upper); }</span>
 306 
 307     private:
<a name="19" id="anc19"></a>

 308         uint32_t m_length { 0 };
 309         uint32_t m_fiber1Lower { 0 };
 310         uint16_t m_fiber1Upper { 0 };
<a name="20" id="anc20"></a><span class="line-modified"> 311         uint16_t m_fiber2Upper { 0 };</span>
<span class="line-modified"> 312         uint32_t m_fiber2Lower { 0 };</span>
 313     };
 314     static_assert(sizeof(CompactFibers) == sizeof(void*) * 2, &quot;&quot;);
 315 #else
<a name="21" id="anc21"></a><span class="line-removed"> 316     static constexpr uintptr_t stringMask = ~(isRopeInPointer);</span>
<span class="line-removed"> 317 </span>
 318     class CompactFibers {
 319     public:
 320         JSString* fiber1() const
 321         {
 322             return m_fiber1;
 323         }
 324         void initializeFiber1(JSString* fiber)
 325         {
 326             m_fiber1 = fiber;
 327         }
 328 
 329         JSString* fiber2() const
 330         {
 331             return m_fiber2;
 332         }
 333         void initializeFiber2(JSString* fiber)
 334         {
 335             m_fiber2 = fiber;
 336         }
 337 
 338         unsigned length() const { return m_length; }
 339         void initializeLength(unsigned length)
 340         {
 341             m_length = length;
 342         }
 343 
<a name="22" id="anc22"></a><span class="line-removed"> 344         void initializeIs8Bit(bool flag)</span>
<span class="line-removed"> 345         {</span>
<span class="line-removed"> 346             if (flag)</span>
<span class="line-removed"> 347                 m_flags |= static_cast&lt;uintptr_t&gt;(StringImpl::flagIs8Bit());</span>
<span class="line-removed"> 348             else</span>
<span class="line-removed"> 349                 m_flags &amp;= ~static_cast&lt;uintptr_t&gt;(StringImpl::flagIs8Bit());</span>
<span class="line-removed"> 350         }</span>
<span class="line-removed"> 351 </span>
<span class="line-removed"> 352         bool is8Bit()</span>
<span class="line-removed"> 353         {</span>
<span class="line-removed"> 354             return m_flags &amp; static_cast&lt;uintptr_t&gt;(StringImpl::flagIs8Bit());</span>
<span class="line-removed"> 355         }</span>
<span class="line-removed"> 356 </span>
 357         static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
<a name="23" id="anc23"></a>

 358 
 359     private:
<a name="24" id="anc24"></a>

 360         uint32_t m_length { 0 };
<a name="25" id="anc25"></a><span class="line-removed"> 361         uint32_t m_flags { 0 };</span>
 362         JSString* m_fiber1 { nullptr };
 363         JSString* m_fiber2 { nullptr };
 364     };
 365 #endif
 366 
 367     template &lt;class OverflowHandler = CrashOnOverflow&gt;
 368     class RopeBuilder : public OverflowHandler {
 369         WTF_FORBID_HEAP_ALLOCATION;
 370     public:
 371         RopeBuilder(VM&amp; vm)
 372             : m_vm(vm)
 373         {
 374         }
 375 
 376         bool append(JSString* jsString)
 377         {
 378             if (UNLIKELY(this-&gt;hasOverflowed()))
 379                 return false;
 380             if (!jsString-&gt;length())
 381                 return true;
 382             if (m_strings.size() == JSRopeString::s_maxInternalRopeLength)
 383                 expand();
 384 
 385             static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
 386             auto sum = checkedSum&lt;int32_t&gt;(m_length, jsString-&gt;length());
 387             if (sum.hasOverflowed()) {
 388                 this-&gt;overflowed();
 389                 return false;
 390             }
 391             ASSERT(static_cast&lt;unsigned&gt;(sum.unsafeGet()) &lt;= MaxLength);
 392             m_strings.append(jsString);
 393             m_length = static_cast&lt;unsigned&gt;(sum.unsafeGet());
 394             return true;
 395         }
 396 
 397         JSString* release()
 398         {
 399             RELEASE_ASSERT(!this-&gt;hasOverflowed());
 400             JSString* result = nullptr;
 401             switch (m_strings.size()) {
 402             case 0: {
 403                 ASSERT(!m_length);
<a name="26" id="anc26"></a><span class="line-modified"> 404                 result = jsEmptyString(&amp;m_vm);</span>
 405                 break;
 406             }
 407             case 1: {
 408                 result = asString(m_strings.at(0));
 409                 break;
 410             }
 411             case 2: {
 412                 result = JSRopeString::create(m_vm, asString(m_strings.at(0)), asString(m_strings.at(1)));
 413                 break;
 414             }
 415             case 3: {
 416                 result = JSRopeString::create(m_vm, asString(m_strings.at(0)), asString(m_strings.at(1)), asString(m_strings.at(2)));
 417                 break;
 418             }
 419             default:
 420                 ASSERT_NOT_REACHED();
 421                 break;
 422             }
 423             ASSERT(result-&gt;length() == m_length);
 424             m_strings.clear();
 425             m_length = 0;
 426             return result;
 427         }
 428 
 429         unsigned length() const
 430         {
 431             ASSERT(!this-&gt;hasOverflowed());
 432             return m_length;
 433         }
 434 
 435     private:
 436         void expand();
 437 
 438         VM&amp; m_vm;
 439         MarkedArgumentBuffer m_strings;
 440         unsigned m_length { 0 };
 441     };
 442 
 443     inline unsigned length() const
 444     {
 445         return m_compactFibers.length();
 446     }
 447 
 448 private:
<a name="27" id="anc27"></a>

 449     void convertToNonRope(String&amp;&amp;) const;
 450 
 451     void initializeIs8Bit(bool flag) const
 452     {
<a name="28" id="anc28"></a><span class="line-removed"> 453 #if CPU(ADDRESS64)</span>
 454         if (flag)
 455             m_fiber |= is8BitInPointer;
 456         else
 457             m_fiber &amp;= ~is8BitInPointer;
<a name="29" id="anc29"></a><span class="line-modified"> 458 #else</span>
<span class="line-modified"> 459         m_compactFibers.initializeIs8Bit(flag);</span>
<span class="line-modified"> 460 #endif</span>





 461     }
 462 
 463     ALWAYS_INLINE void initializeLength(unsigned length)
 464     {
 465         ASSERT(length &lt;= MaxLength);
 466         m_compactFibers.initializeLength(length);
 467     }
 468 
<a name="30" id="anc30"></a>










 469     JSRopeString(VM&amp; vm, JSString* s1, JSString* s2)
 470         : JSString(vm)
 471     {
 472         ASSERT(!sumOverflows&lt;int32_t&gt;(s1-&gt;length(), s2-&gt;length()));
 473         initializeIsSubstring(false);
 474         initializeLength(s1-&gt;length() + s2-&gt;length());
 475         initializeIs8Bit(s1-&gt;is8Bit() &amp;&amp; s2-&gt;is8Bit());
 476         initializeFiber0(s1);
 477         initializeFiber1(s2);
 478         initializeFiber2(nullptr);
 479         ASSERT((s1-&gt;length() + s2-&gt;length()) == length());
 480     }
 481 
 482     JSRopeString(VM&amp; vm, JSString* s1, JSString* s2, JSString* s3)
 483         : JSString(vm)
 484     {
 485         ASSERT(!sumOverflows&lt;int32_t&gt;(s1-&gt;length(), s2-&gt;length(), s3-&gt;length()));
 486         initializeIsSubstring(false);
 487         initializeLength(s1-&gt;length() + s2-&gt;length() + s3-&gt;length());
 488         initializeIs8Bit(s1-&gt;is8Bit() &amp;&amp; s2-&gt;is8Bit() &amp;&amp;  s3-&gt;is8Bit());
 489         initializeFiber0(s1);
 490         initializeFiber1(s2);
 491         initializeFiber2(s3);
 492         ASSERT((s1-&gt;length() + s2-&gt;length() + s3-&gt;length()) == length());
 493     }
 494 
 495     JSRopeString(VM&amp; vm, JSString* base, unsigned offset, unsigned length)
 496         : JSString(vm)
<a name="31" id="anc31"></a><span class="line-removed"> 497     {</span>
<span class="line-removed"> 498         RELEASE_ASSERT(!sumOverflows&lt;int32_t&gt;(offset, length));</span>
<span class="line-removed"> 499         RELEASE_ASSERT(offset + length &lt;= base-&gt;length());</span>
<span class="line-removed"> 500         initializeIsSubstring(true);</span>
<span class="line-removed"> 501         initializeLength(length);</span>
<span class="line-removed"> 502         initializeIs8Bit(base-&gt;is8Bit());</span>
<span class="line-removed"> 503         if (base-&gt;isSubstring()) {</span>
<span class="line-removed"> 504             JSRopeString* baseRope = jsCast&lt;JSRopeString*&gt;(base);</span>
<span class="line-removed"> 505             initializeSubstringBase(baseRope-&gt;substringBase());</span>
<span class="line-removed"> 506             initializeSubstringOffset(baseRope-&gt;substringOffset() + offset);</span>
<span class="line-removed"> 507         } else {</span>
<span class="line-removed"> 508             initializeSubstringBase(base);</span>
<span class="line-removed"> 509             initializeSubstringOffset(offset);</span>
<span class="line-removed"> 510         }</span>
<span class="line-removed"> 511         ASSERT(length == this-&gt;length());</span>
<span class="line-removed"> 512     }</span>
<span class="line-removed"> 513 </span>
<span class="line-removed"> 514     enum SubstringOfResolvedTag { SubstringOfResolved };</span>
<span class="line-removed"> 515     JSRopeString(SubstringOfResolvedTag, VM&amp; vm, JSString* base, unsigned offset, unsigned length)</span>
<span class="line-removed"> 516         : JSString(vm)</span>
 517     {
 518         RELEASE_ASSERT(!sumOverflows&lt;int32_t&gt;(offset, length));
 519         RELEASE_ASSERT(offset + length &lt;= base-&gt;length());
 520         initializeIsSubstring(true);
 521         initializeLength(length);
 522         initializeIs8Bit(base-&gt;is8Bit());
 523         initializeSubstringBase(base);
 524         initializeSubstringOffset(offset);
 525         ASSERT(length == this-&gt;length());
<a name="32" id="anc32"></a><span class="line-modified"> 526     }</span>
<span class="line-removed"> 527 </span>
<span class="line-removed"> 528     ALWAYS_INLINE void finishCreationSubstring(VM&amp; vm, ExecState* exec)</span>
<span class="line-removed"> 529     {</span>
<span class="line-removed"> 530         Base::finishCreation(vm);</span>
<span class="line-removed"> 531         JSString* updatedBase = substringBase();</span>
<span class="line-removed"> 532         // For now, let&#39;s not allow substrings with a rope base.</span>
<span class="line-removed"> 533         // Resolve non-substring rope bases so we don&#39;t have to deal with it.</span>
<span class="line-removed"> 534         // FIXME: Evaluate if this would be worth adding more branches.</span>
<span class="line-removed"> 535         if (updatedBase-&gt;isRope())</span>
<span class="line-removed"> 536             jsCast&lt;JSRopeString*&gt;(updatedBase)-&gt;resolveRope(exec);</span>
 537     }
 538 
 539     ALWAYS_INLINE void finishCreationSubstringOfResolved(VM&amp; vm)
 540     {
 541         Base::finishCreation(vm);
 542     }
 543 
 544 public:
 545     static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfLength(); } // 32byte width.
<a name="33" id="anc33"></a>
 546     static ptrdiff_t offsetOfFiber0() { return offsetOfValue(); }
<a name="34" id="anc34"></a><span class="line-modified"> 547 #if CPU(ADDRESS64)</span>
<span class="line-modified"> 548     static ptrdiff_t offsetOfFlags() { return offsetOfValue() + sizeof(uint16_t) * 3; } // 16byte width.</span>
<span class="line-removed"> 549     static ptrdiff_t offsetOfFiber1Lower() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfFiber1Lower(); } // 32byte width.</span>
<span class="line-removed"> 550     static ptrdiff_t offsetOfFiber1Upper() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfFiber1Upper(); } // 16byte width.</span>
<span class="line-removed"> 551     static ptrdiff_t offsetOfFiber2Lower() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfFiber2Lower(); } // 32byte width.</span>
<span class="line-removed"> 552     static ptrdiff_t offsetOfFiber2Upper() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfFiber2Upper(); } // 16byte width.</span>
<span class="line-removed"> 553 #elif USE(JSVALUE64)</span>
<span class="line-removed"> 554     // FIXME: This is an temporary workaround to make JSC built on ARM64_32. Once we start calculating bits before storing them to JSRopeString,</span>
<span class="line-removed"> 555     // we do not need to have such a detailed information as an offset. After that, what we only need is offsetOfFiber0, offsetOfFiber1, and offsetOfFiber2.</span>
<span class="line-removed"> 556     // https://bugs.webkit.org/show_bug.cgi?id=195234</span>
<span class="line-removed"> 557     static ptrdiff_t offsetOfFlags() { ASSERT_NOT_REACHED(); return 0; }</span>
<span class="line-removed"> 558     static ptrdiff_t offsetOfFiber1Lower() { ASSERT_NOT_REACHED(); return 0; }</span>
<span class="line-removed"> 559     static ptrdiff_t offsetOfFiber1Upper() { ASSERT_NOT_REACHED(); return 0; }</span>
<span class="line-removed"> 560     static ptrdiff_t offsetOfFiber2Lower() { ASSERT_NOT_REACHED(); return 0; }</span>
<span class="line-removed"> 561     static ptrdiff_t offsetOfFiber2Upper() { ASSERT_NOT_REACHED(); return 0; }</span>
<span class="line-removed"> 562 #endif</span>
 563 
 564     static constexpr unsigned s_maxInternalRopeLength = 3;
 565 
<a name="35" id="anc35"></a>















 566 private:
 567     static JSRopeString* create(VM&amp; vm, JSString* s1, JSString* s2)
 568     {
 569         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm, s1, s2);
 570         newString-&gt;finishCreation(vm);
 571         ASSERT(newString-&gt;length());
<a name="36" id="anc36"></a>
 572         return newString;
 573     }
 574     static JSRopeString* create(VM&amp; vm, JSString* s1, JSString* s2, JSString* s3)
 575     {
 576         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm, s1, s2, s3);
 577         newString-&gt;finishCreation(vm);
 578         ASSERT(newString-&gt;length());
<a name="37" id="anc37"></a><span class="line-modified"> 579         return newString;</span>
<span class="line-removed"> 580     }</span>
<span class="line-removed"> 581 </span>
<span class="line-removed"> 582     static JSRopeString* create(VM&amp; vm, ExecState* exec, JSString* base, unsigned offset, unsigned length)</span>
<span class="line-removed"> 583     {</span>
<span class="line-removed"> 584         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm, base, offset, length);</span>
<span class="line-removed"> 585         newString-&gt;finishCreationSubstring(vm, exec);</span>
<span class="line-removed"> 586         ASSERT(newString-&gt;length());</span>
 587         return newString;
 588     }
 589 
 590     ALWAYS_INLINE static JSRopeString* createSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* base, unsigned offset, unsigned length)
 591     {
<a name="38" id="anc38"></a><span class="line-modified"> 592         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap, deferralContext)) JSRopeString(SubstringOfResolved, vm, base, offset, length);</span>
 593         newString-&gt;finishCreationSubstringOfResolved(vm);
 594         ASSERT(newString-&gt;length());
<a name="39" id="anc39"></a>
 595         return newString;
 596     }
 597 
 598     friend JSValue jsStringFromRegisterArray(ExecState*, Register*, unsigned);
 599     friend JSValue jsStringFromArguments(ExecState*, JSValue);
 600 
 601     // If nullOrExecForOOM is null, resolveRope() will be do nothing in the event of an OOM error.
 602     // The rope value will remain a null string in that case.
 603     JS_EXPORT_PRIVATE const String&amp; resolveRope(ExecState* nullOrExecForOOM) const;
 604     template&lt;typename Function&gt; const String&amp; resolveRopeWithFunction(ExecState* nullOrExecForOOM, Function&amp;&amp;) const;
<a name="40" id="anc40"></a><span class="line-modified"> 605     JS_EXPORT_PRIVATE AtomicString resolveRopeToAtomicString(ExecState*) const;</span>
<span class="line-modified"> 606     JS_EXPORT_PRIVATE RefPtr&lt;AtomicStringImpl&gt; resolveRopeToExistingAtomicString(ExecState*) const;</span>
 607     void resolveRopeSlowCase8(LChar*) const;
 608     void resolveRopeSlowCase(UChar*) const;
 609     void outOfMemory(ExecState* nullOrExecForOOM) const;
 610     void resolveRopeInternal8(LChar*) const;
 611     void resolveRopeInternal8NoSubstring(LChar*) const;
 612     void resolveRopeInternal16(UChar*) const;
 613     void resolveRopeInternal16NoSubstring(UChar*) const;
 614     StringView unsafeView(ExecState*) const;
 615     StringViewWithUnderlyingString viewWithUnderlyingString(ExecState*) const;
 616 
 617     JSString* fiber0() const
 618     {
 619         return bitwise_cast&lt;JSString*&gt;(m_fiber &amp; stringMask);
 620     }
 621 
 622     JSString* fiber1() const
 623     {
 624         return m_compactFibers.fiber1();
 625     }
 626 
 627     JSString* fiber2() const
 628     {
 629         return m_compactFibers.fiber2();
 630     }
 631 
 632     JSString* fiber(unsigned i) const
 633     {
 634         ASSERT(!isSubstring());
 635         ASSERT(i &lt; s_maxInternalRopeLength);
 636         switch (i) {
 637         case 0:
 638             return fiber0();
 639         case 1:
 640             return fiber1();
 641         case 2:
 642             return fiber2();
 643         }
 644         ASSERT_NOT_REACHED();
 645         return nullptr;
 646     }
 647 
 648     void initializeFiber0(JSString* fiber)
 649     {
 650         uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 651         ASSERT(!(pointer &amp; ~stringMask));
 652         m_fiber = (pointer | (m_fiber &amp; ~stringMask));
 653     }
 654 
 655     void initializeFiber1(JSString* fiber)
 656     {
 657         m_compactFibers.initializeFiber1(fiber);
 658     }
 659 
 660     void initializeFiber2(JSString* fiber)
 661     {
 662         m_compactFibers.initializeFiber2(fiber);
 663     }
 664 
 665     void initializeSubstringBase(JSString* fiber)
 666     {
 667         initializeFiber1(fiber);
 668     }
 669 
 670     JSString* substringBase() const { return fiber1(); }
 671 
 672     void initializeSubstringOffset(unsigned offset)
 673     {
 674         m_compactFibers.initializeFiber2(bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(offset)));
 675     }
 676 
 677     unsigned substringOffset() const
 678     {
 679         return static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(fiber2()));
 680     }
 681 
<a name="41" id="anc41"></a><span class="line-removed"> 682     static constexpr uintptr_t notSubstringSentinel()</span>
<span class="line-removed"> 683     {</span>
<span class="line-removed"> 684         return 0;</span>
<span class="line-removed"> 685     }</span>
<span class="line-removed"> 686 </span>
<span class="line-removed"> 687     static constexpr uintptr_t substringSentinel()</span>
<span class="line-removed"> 688     {</span>
<span class="line-removed"> 689         return 2;</span>
<span class="line-removed"> 690     }</span>
<span class="line-removed"> 691 </span>
<span class="line-removed"> 692     bool isSubstring() const</span>
<span class="line-removed"> 693     {</span>
<span class="line-removed"> 694         return (m_fiber &amp; stringMask) == substringSentinel();</span>
<span class="line-removed"> 695     }</span>
<span class="line-removed"> 696 </span>
<span class="line-removed"> 697     void initializeIsSubstring(bool isSubstring)</span>
<span class="line-removed"> 698     {</span>
<span class="line-removed"> 699         m_fiber |= (isSubstring ? substringSentinel() : notSubstringSentinel());</span>
<span class="line-removed"> 700     }</span>
<span class="line-removed"> 701 </span>
 702     static_assert(s_maxInternalRopeLength &gt;= 2, &quot;&quot;);
 703     mutable CompactFibers m_compactFibers;
 704 
 705     friend JSString* jsString(ExecState*, JSString*, JSString*);
 706     friend JSString* jsString(ExecState*, const String&amp;, JSString*);
 707     friend JSString* jsString(ExecState*, JSString*, const String&amp;);
 708     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;);
 709     friend JSString* jsString(ExecState*, JSString*, JSString*, JSString*);
 710     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;, const String&amp;);
 711     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
 712     friend JSString* jsSubstring(VM&amp;, ExecState*, JSString*, unsigned, unsigned);
 713 };
 714 
 715 JS_EXPORT_PRIVATE JSString* jsStringWithCacheSlowCase(VM&amp;, StringImpl&amp;);
 716 
 717 // JSString::is8Bit is safe to be called concurrently. Concurrent threads can access is8Bit even if the main thread
 718 // is in the middle of converting JSRopeString to JSString.
 719 ALWAYS_INLINE bool JSString::is8Bit() const
 720 {
 721     uintptr_t pointer = m_fiber;
 722     if (pointer &amp; isRopeInPointer) {
<a name="42" id="anc42"></a><span class="line-removed"> 723 #if CPU(ADDRESS64)</span>
 724         // Do not load m_fiber twice. We should use the information in pointer.
 725         // Otherwise, JSRopeString may be converted to JSString between the first and second accesses.
 726         return pointer &amp; JSRopeString::is8BitInPointer;
<a name="43" id="anc43"></a><span class="line-removed"> 727 #else</span>
<span class="line-removed"> 728         // It is OK to load flag since even if JSRopeString is converted to JSString, this flag still exists.</span>
<span class="line-removed"> 729         return jsCast&lt;const JSRopeString*&gt;(this)-&gt;m_compactFibers.is8Bit();</span>
<span class="line-removed"> 730 #endif</span>
 731     }
 732     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;is8Bit();
 733 }
 734 
 735 // JSString::length is safe to be called concurrently. Concurrent threads can access length even if the main thread
 736 // is in the middle of converting JSRopeString to JSString. This is OK because we never override the length bits
 737 // when we resolve a JSRopeString.
 738 ALWAYS_INLINE unsigned JSString::length() const
 739 {
 740     uintptr_t pointer = m_fiber;
 741     if (pointer &amp; isRopeInPointer)
 742         return jsCast&lt;const JSRopeString*&gt;(this)-&gt;length();
 743     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;length();
 744 }
 745 
 746 inline const StringImpl* JSString::tryGetValueImpl() const
 747 {
 748     uintptr_t pointer = m_fiber;
 749     if (pointer &amp; isRopeInPointer)
 750         return nullptr;
 751     return bitwise_cast&lt;StringImpl*&gt;(pointer);
 752 }
 753 
 754 inline JSString* asString(JSValue value)
 755 {
 756     ASSERT(value.asCell()-&gt;isString());
 757     return jsCast&lt;JSString*&gt;(value.asCell());
 758 }
 759 
 760 // This MUST NOT GC.
<a name="44" id="anc44"></a><span class="line-modified"> 761 inline JSString* jsEmptyString(VM* vm)</span>
 762 {
<a name="45" id="anc45"></a><span class="line-modified"> 763     return vm-&gt;smallStrings.emptyString();</span>
 764 }
 765 
<a name="46" id="anc46"></a><span class="line-modified"> 766 ALWAYS_INLINE JSString* jsSingleCharacterString(VM* vm, UChar c)</span>
 767 {
 768     if (validateDFGDoesGC)
<a name="47" id="anc47"></a><span class="line-modified"> 769         RELEASE_ASSERT(vm-&gt;heap.expectDoesGC());</span>
 770     if (c &lt;= maxSingleCharacterString)
<a name="48" id="anc48"></a><span class="line-modified"> 771         return vm-&gt;smallStrings.singleCharacterString(c);</span>
<span class="line-modified"> 772     return JSString::create(*vm, StringImpl::create(&amp;c, 1));</span>
 773 }
 774 
<a name="49" id="anc49"></a><span class="line-modified"> 775 inline JSString* jsNontrivialString(VM* vm, const String&amp; s)</span>
 776 {
 777     ASSERT(s.length() &gt; 1);
<a name="50" id="anc50"></a><span class="line-modified"> 778     return JSString::create(*vm, *s.impl());</span>
 779 }
 780 
<a name="51" id="anc51"></a><span class="line-modified"> 781 inline JSString* jsNontrivialString(VM* vm, String&amp;&amp; s)</span>
 782 {
 783     ASSERT(s.length() &gt; 1);
<a name="52" id="anc52"></a><span class="line-modified"> 784     return JSString::create(*vm, s.releaseImpl().releaseNonNull());</span>
 785 }
 786 
 787 ALWAYS_INLINE Identifier JSString::toIdentifier(ExecState* exec) const
 788 {
<a name="53" id="anc53"></a><span class="line-modified"> 789     return Identifier::fromString(exec, toAtomicString(exec));</span>




 790 }
 791 
<a name="54" id="anc54"></a><span class="line-modified"> 792 ALWAYS_INLINE AtomicString JSString::toAtomicString(ExecState* exec) const</span>
 793 {
 794     if (validateDFGDoesGC)
<a name="55" id="anc55"></a><span class="line-modified"> 795         RELEASE_ASSERT(vm()-&gt;heap.expectDoesGC());</span>
 796     if (isRope())
<a name="56" id="anc56"></a><span class="line-modified"> 797         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToAtomicString(exec);</span>
<span class="line-modified"> 798     return AtomicString(valueInternal());</span>
 799 }
 800 
<a name="57" id="anc57"></a><span class="line-modified"> 801 ALWAYS_INLINE RefPtr&lt;AtomicStringImpl&gt; JSString::toExistingAtomicString(ExecState* exec) const</span>
 802 {
 803     if (validateDFGDoesGC)
<a name="58" id="anc58"></a><span class="line-modified"> 804         RELEASE_ASSERT(vm()-&gt;heap.expectDoesGC());</span>
 805     if (isRope())
<a name="59" id="anc59"></a><span class="line-modified"> 806         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToExistingAtomicString(exec);</span>
<span class="line-modified"> 807     if (valueInternal().impl()-&gt;isAtomic())</span>
<span class="line-modified"> 808         return static_cast&lt;AtomicStringImpl*&gt;(valueInternal().impl());</span>
<span class="line-modified"> 809     return AtomicStringImpl::lookUp(valueInternal().impl());</span>
 810 }
 811 
 812 inline const String&amp; JSString::value(ExecState* exec) const
 813 {
 814     if (validateDFGDoesGC)
<a name="60" id="anc60"></a><span class="line-modified"> 815         RELEASE_ASSERT(vm()-&gt;heap.expectDoesGC());</span>
 816     if (isRope())
 817         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(exec);
 818     return valueInternal();
 819 }
 820 
 821 inline const String&amp; JSString::tryGetValue(bool allocationAllowed) const
 822 {
 823     if (allocationAllowed) {
 824         if (validateDFGDoesGC)
<a name="61" id="anc61"></a><span class="line-modified"> 825             RELEASE_ASSERT(vm()-&gt;heap.expectDoesGC());</span>
<span class="line-modified"> 826     if (isRope()) {</span>
<span class="line-modified"> 827         // Pass nullptr for the ExecState so that resolveRope does not throw in the event of an OOM error.</span>
 828             return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(nullptr);
<a name="62" id="anc62"></a><span class="line-modified"> 829     }</span>
 830     } else
 831         RELEASE_ASSERT(!isRope());
 832     return valueInternal();
 833 }
 834 
 835 inline JSString* JSString::getIndex(ExecState* exec, unsigned i)
 836 {
 837     VM&amp; vm = exec-&gt;vm();
 838     auto scope = DECLARE_THROW_SCOPE(vm);
 839     ASSERT(canGetIndex(i));
 840     StringView view = unsafeView(exec);
 841     RETURN_IF_EXCEPTION(scope, nullptr);
<a name="63" id="anc63"></a><span class="line-modified"> 842     return jsSingleCharacterString(exec, view[i]);</span>
 843 }
 844 
<a name="64" id="anc64"></a><span class="line-modified"> 845 inline JSString* jsString(VM* vm, const String&amp; s)</span>
 846 {
 847     int size = s.length();
 848     if (!size)
<a name="65" id="anc65"></a><span class="line-modified"> 849         return vm-&gt;smallStrings.emptyString();</span>
 850     if (size == 1) {
 851         UChar c = s.characterAt(0);
 852         if (c &lt;= maxSingleCharacterString)
<a name="66" id="anc66"></a><span class="line-modified"> 853             return vm-&gt;smallStrings.singleCharacterString(c);</span>
 854     }
<a name="67" id="anc67"></a><span class="line-modified"> 855     return JSString::create(*vm, *s.impl());</span>
 856 }
 857 
<a name="68" id="anc68"></a><span class="line-modified"> 858 inline JSString* jsSubstring(VM&amp; vm, ExecState* exec, JSString* s, unsigned offset, unsigned length)</span>
 859 {
<a name="69" id="anc69"></a><span class="line-modified"> 860     ASSERT(offset &lt;= s-&gt;length());</span>
<span class="line-modified"> 861     ASSERT(length &lt;= s-&gt;length());</span>
<span class="line-modified"> 862     ASSERT(offset + length &lt;= s-&gt;length());</span>


 863     if (!length)
 864         return vm.smallStrings.emptyString();
<a name="70" id="anc70"></a><span class="line-modified"> 865     if (!offset &amp;&amp; length == s-&gt;length())</span>
<span class="line-modified"> 866         return s;</span>
<span class="line-modified"> 867     return JSRopeString::create(vm, exec, s, offset, length);</span>













 868 }
 869 
 870 inline JSString* jsSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* s, unsigned offset, unsigned length)
 871 {
 872     ASSERT(offset &lt;= s-&gt;length());
 873     ASSERT(length &lt;= s-&gt;length());
 874     ASSERT(offset + length &lt;= s-&gt;length());
<a name="71" id="anc71"></a>
 875     if (!length)
 876         return vm.smallStrings.emptyString();
 877     if (!offset &amp;&amp; length == s-&gt;length())
 878         return s;
<a name="72" id="anc72"></a>





 879     return JSRopeString::createSubstringOfResolved(vm, deferralContext, s, offset, length);
 880 }
 881 
 882 inline JSString* jsSubstringOfResolved(VM&amp; vm, JSString* s, unsigned offset, unsigned length)
 883 {
 884     return jsSubstringOfResolved(vm, nullptr, s, offset, length);
 885 }
 886 
 887 inline JSString* jsSubstring(ExecState* exec, JSString* s, unsigned offset, unsigned length)
 888 {
 889     return jsSubstring(exec-&gt;vm(), exec, s, offset, length);
 890 }
 891 
<a name="73" id="anc73"></a><span class="line-modified"> 892 inline JSString* jsSubstring(VM* vm, const String&amp; s, unsigned offset, unsigned length)</span>
 893 {
 894     ASSERT(offset &lt;= s.length());
 895     ASSERT(length &lt;= s.length());
 896     ASSERT(offset + length &lt;= s.length());
 897     if (!length)
<a name="74" id="anc74"></a><span class="line-modified"> 898         return vm-&gt;smallStrings.emptyString();</span>
 899     if (length == 1) {
 900         UChar c = s.characterAt(offset);
 901         if (c &lt;= maxSingleCharacterString)
<a name="75" id="anc75"></a><span class="line-modified"> 902             return vm-&gt;smallStrings.singleCharacterString(c);</span>
 903     }
 904     auto impl = StringImpl::createSubstringSharingImpl(*s.impl(), offset, length);
 905     if (impl-&gt;isSubString())
<a name="76" id="anc76"></a><span class="line-modified"> 906         return JSString::createHasOtherOwner(*vm, WTFMove(impl));</span>
<span class="line-modified"> 907     return JSString::create(*vm, WTFMove(impl));</span>
 908 }
 909 
<a name="77" id="anc77"></a><span class="line-modified"> 910 inline JSString* jsOwnedString(VM* vm, const String&amp; s)</span>
 911 {
 912     int size = s.length();
 913     if (!size)
<a name="78" id="anc78"></a><span class="line-modified"> 914         return vm-&gt;smallStrings.emptyString();</span>
 915     if (size == 1) {
 916         UChar c = s.characterAt(0);
 917         if (c &lt;= maxSingleCharacterString)
<a name="79" id="anc79"></a><span class="line-modified"> 918             return vm-&gt;smallStrings.singleCharacterString(c);</span>
 919     }
<a name="80" id="anc80"></a><span class="line-modified"> 920     return JSString::createHasOtherOwner(*vm, *s.impl());</span>
 921 }
 922 
<a name="81" id="anc81"></a><span class="line-removed"> 923 inline JSString* jsEmptyString(ExecState* exec) { return jsEmptyString(&amp;exec-&gt;vm()); }</span>
<span class="line-removed"> 924 inline JSString* jsString(ExecState* exec, const String&amp; s) { return jsString(&amp;exec-&gt;vm(), s); }</span>
<span class="line-removed"> 925 inline JSString* jsSingleCharacterString(ExecState* exec, UChar c) { return jsSingleCharacterString(&amp;exec-&gt;vm(), c); }</span>
<span class="line-removed"> 926 inline JSString* jsSubstring(ExecState* exec, const String&amp; s, unsigned offset, unsigned length) { return jsSubstring(&amp;exec-&gt;vm(), s, offset, length); }</span>
<span class="line-removed"> 927 inline JSString* jsNontrivialString(ExecState* exec, const String&amp; s) { return jsNontrivialString(&amp;exec-&gt;vm(), s); }</span>
<span class="line-removed"> 928 inline JSString* jsNontrivialString(ExecState* exec, String&amp;&amp; s) { return jsNontrivialString(&amp;exec-&gt;vm(), WTFMove(s)); }</span>
<span class="line-removed"> 929 inline JSString* jsOwnedString(ExecState* exec, const String&amp; s) { return jsOwnedString(&amp;exec-&gt;vm(), s); }</span>
<span class="line-removed"> 930 </span>
 931 ALWAYS_INLINE JSString* jsStringWithCache(ExecState* exec, const String&amp; s)
 932 {
 933     VM&amp; vm = exec-&gt;vm();
 934     StringImpl* stringImpl = s.impl();
 935     if (!stringImpl || !stringImpl-&gt;length())
<a name="82" id="anc82"></a><span class="line-modified"> 936         return jsEmptyString(&amp;vm);</span>
 937 
 938     if (stringImpl-&gt;length() == 1) {
 939         UChar singleCharacter = (*stringImpl)[0u];
 940         if (singleCharacter &lt;= maxSingleCharacterString)
 941             return vm.smallStrings.singleCharacterString(static_cast&lt;unsigned char&gt;(singleCharacter));
 942     }
 943 
 944     if (JSString* lastCachedString = vm.lastCachedString.get()) {
 945         if (lastCachedString-&gt;tryGetValueImpl() == stringImpl)
 946             return lastCachedString;
 947     }
 948 
 949     return jsStringWithCacheSlowCase(vm, *stringImpl);
 950 }
 951 
 952 ALWAYS_INLINE bool JSString::getStringPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 953 {
 954     VM&amp; vm = exec-&gt;vm();
 955     auto scope = DECLARE_THROW_SCOPE(vm);
 956 
 957     if (propertyName == vm.propertyNames-&gt;length) {
 958         slot.setValue(this, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, jsNumber(length()));
 959         return true;
 960     }
 961 
 962     Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 963     if (index &amp;&amp; index.value() &lt; length()) {
 964         JSValue value = getIndex(exec, index.value());
 965         RETURN_IF_EXCEPTION(scope, false);
 966         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 967         return true;
 968     }
 969 
 970     return false;
 971 }
 972 
 973 ALWAYS_INLINE bool JSString::getStringPropertySlot(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)
 974 {
 975     VM&amp; vm = exec-&gt;vm();
 976     auto scope = DECLARE_THROW_SCOPE(vm);
 977 
 978     if (propertyName &lt; length()) {
 979         JSValue value = getIndex(exec, propertyName);
 980         RETURN_IF_EXCEPTION(scope, false);
 981         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 982         return true;
 983     }
 984 
 985     return false;
 986 }
 987 
 988 inline bool isJSString(JSCell* cell)
 989 {
 990     return cell-&gt;type() == StringType;
 991 }
 992 
 993 inline bool isJSString(JSValue v)
 994 {
 995     return v.isCell() &amp;&amp; isJSString(v.asCell());
 996 }
 997 
 998 ALWAYS_INLINE StringView JSRopeString::unsafeView(ExecState* exec) const
 999 {
1000     if (validateDFGDoesGC)
<a name="83" id="anc83"></a><span class="line-modified">1001         RELEASE_ASSERT(vm()-&gt;heap.expectDoesGC());</span>
1002     if (isSubstring()) {
1003         auto&amp; base = substringBase()-&gt;valueInternal();
1004         if (base.is8Bit())
1005             return StringView(base.characters8() + substringOffset(), length());
1006         return StringView(base.characters16() + substringOffset(), length());
1007     }
1008     return resolveRope(exec);
1009 }
1010 
1011 ALWAYS_INLINE StringViewWithUnderlyingString JSRopeString::viewWithUnderlyingString(ExecState* exec) const
1012 {
1013     if (validateDFGDoesGC)
<a name="84" id="anc84"></a><span class="line-modified">1014         RELEASE_ASSERT(vm()-&gt;heap.expectDoesGC());</span>
1015     if (isSubstring()) {
1016         auto&amp; base = substringBase()-&gt;valueInternal();
1017         if (base.is8Bit())
1018             return { { base.characters8() + substringOffset(), length() }, base };
1019         return { { base.characters16() + substringOffset(), length() }, base };
1020     }
1021     auto&amp; string = resolveRope(exec);
1022     return { string, string };
1023 }
1024 
1025 ALWAYS_INLINE StringView JSString::unsafeView(ExecState* exec) const
1026 {
1027     if (validateDFGDoesGC)
<a name="85" id="anc85"></a><span class="line-modified">1028         RELEASE_ASSERT(vm()-&gt;heap.expectDoesGC());</span>
1029     if (isRope())
1030         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;unsafeView(exec);
1031     return valueInternal();
1032 }
1033 
1034 ALWAYS_INLINE StringViewWithUnderlyingString JSString::viewWithUnderlyingString(ExecState* exec) const
1035 {
1036     if (isRope())
1037         return static_cast&lt;const JSRopeString&amp;&gt;(*this).viewWithUnderlyingString(exec);
1038     return { valueInternal(), valueInternal() };
1039 }
1040 
1041 inline bool JSString::isSubstring() const
1042 {
<a name="86" id="anc86"></a><span class="line-modified">1043     return isRope() &amp;&amp; static_cast&lt;const JSRopeString*&gt;(this)-&gt;isSubstring();</span>
1044 }
1045 
1046 // --- JSValue inlines ----------------------------
1047 
1048 inline bool JSValue::toBoolean(ExecState* exec) const
1049 {
1050     if (isInt32())
1051         return asInt32();
1052     if (isDouble())
1053         return asDouble() &gt; 0.0 || asDouble() &lt; 0.0; // false for NaN
1054     if (isCell())
1055         return asCell()-&gt;toBoolean(exec);
1056     return isTrue(); // false, null, and undefined all convert to false.
1057 }
1058 
1059 inline JSString* JSValue::toString(ExecState* exec) const
1060 {
1061     if (isString())
1062         return asString(asCell());
1063     bool returnEmptyStringOnError = true;
1064     return toStringSlowCase(exec, returnEmptyStringOnError);
1065 }
1066 
1067 inline JSString* JSValue::toStringOrNull(ExecState* exec) const
1068 {
1069     if (isString())
1070         return asString(asCell());
1071     bool returnEmptyStringOnError = false;
1072     return toStringSlowCase(exec, returnEmptyStringOnError);
1073 }
1074 
1075 inline String JSValue::toWTFString(ExecState* exec) const
1076 {
1077     if (isString())
1078         return static_cast&lt;JSString*&gt;(asCell())-&gt;value(exec);
1079     return toWTFStringSlowCase(exec);
1080 }
1081 
1082 } // namespace JSC
<a name="87" id="anc87"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="87" type="hidden" />
</body>
</html>