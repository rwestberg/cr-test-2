<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerBacking.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 
 28 #include &quot;FloatPoint.h&quot;
 29 #include &quot;FloatPoint3D.h&quot;
 30 #include &quot;GraphicsLayer.h&quot;
 31 #include &quot;GraphicsLayerClient.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderLayerCompositor.h&quot;
 34 #include &quot;ScrollingCoordinator.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class KeyframeList;
 39 class PaintedContentsInfo;
 40 class RenderLayerCompositor;
 41 class TiledBacking;
 42 class TransformationMatrix;
 43 
 44 enum CompositingLayerType {
 45     NormalCompositingLayer, // non-tiled layer with backing store
 46     TiledCompositingLayer, // tiled layer (always has backing store)
<span class="line-modified"> 47     MediaCompositingLayer, // layer that contains an image, video, webGL or plugin</span>
 48     ContainerCompositingLayer // layer with no backing store
 49 };
 50 
 51 // RenderLayerBacking controls the compositing behavior for a single RenderLayer.
 52 // It holds the various GraphicsLayers, and makes decisions about intra-layer rendering
 53 // optimizations.
 54 //
 55 // There is one RenderLayerBacking for each RenderLayer that is composited.
 56 
 57 class RenderLayerBacking final : public GraphicsLayerClient {
 58     WTF_MAKE_NONCOPYABLE(RenderLayerBacking); WTF_MAKE_FAST_ALLOCATED;
 59 public:
 60     explicit RenderLayerBacking(RenderLayer&amp;);
 61     ~RenderLayerBacking();
 62 
 63 #if PLATFORM(IOS_FAMILY)
 64     void layerWillBeDestroyed();
 65 #endif
 66 
 67     // Do cleanup while layer-&gt;backing() is still valid.
 68     void willBeDestroyed();
 69 
 70     RenderLayer&amp; owningLayer() const { return m_owningLayer; }
 71 









 72     void updateConfigurationAfterStyleChange();
 73 
 74     // Returns true if layer configuration changed.
 75     bool updateConfiguration();
 76 
 77     // Update graphics layer position and bounds.
 78     void updateGeometry();
 79 
 80     // Update state the requires that descendant layers have been updated.
 81     void updateAfterDescendants();
 82 
 83     // Update contents and clipping structure.
 84     void updateDrawsContent();
 85 
<span class="line-modified"> 86     void updateAfterLayout(bool needsFullRepaint);</span>
 87 
 88     GraphicsLayer* graphicsLayer() const { return m_graphicsLayer.get(); }
 89 
 90     // Layer to clip children
 91     bool hasClippingLayer() const { return (m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking); }
 92     GraphicsLayer* clippingLayer() const { return !m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
 93 
<span class="line-modified"> 94     // Layer to get clipped by ancestor</span>
<span class="line-modified"> 95     bool hasAncestorClippingLayer() const { return m_ancestorClippingLayer != nullptr; }</span>
<span class="line-modified"> 96     GraphicsLayer* ancestorClippingLayer() const { return m_ancestorClippingLayer.get(); }</span>
 97 
 98     GraphicsLayer* contentsContainmentLayer() const { return m_contentsContainmentLayer.get(); }
 99 
100     GraphicsLayer* foregroundLayer() const { return m_foregroundLayer.get(); }
101     GraphicsLayer* backgroundLayer() const { return m_backgroundLayer.get(); }
102     bool backgroundLayerPaintsFixedRootBackground() const { return m_backgroundLayerPaintsFixedRootBackground; }
103 
104     bool requiresBackgroundLayer() const { return m_requiresBackgroundLayer; }
105     void setRequiresBackgroundLayer(bool);
106 
107     bool hasScrollingLayer() const { return m_scrollContainerLayer != nullptr; }
108     GraphicsLayer* scrollContainerLayer() const { return m_scrollContainerLayer.get(); }
109     GraphicsLayer* scrolledContentsLayer() const { return m_scrolledContentsLayer.get(); }
110 
<span class="line-removed">111     OptionSet&lt;ScrollCoordinationRole&gt; coordinatedScrollingRoles() const;</span>
<span class="line-removed">112 </span>
113     void detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt;);
114 
115     ScrollingNodeID scrollingNodeIDForRole(ScrollCoordinationRole role) const
116     {
117         switch (role) {
118         case ScrollCoordinationRole::Scrolling:
119             return m_scrollingNodeID;




120         case ScrollCoordinationRole::FrameHosting:
121             return m_frameHostingNodeID;
122         case ScrollCoordinationRole::ViewportConstrained:
123             return m_viewportConstrainedNodeID;


124         }
125         return 0;
126     }
127 
128     void setScrollingNodeIDForRole(ScrollingNodeID nodeID, ScrollCoordinationRole role)
129     {
130         switch (role) {
131         case ScrollCoordinationRole::Scrolling:
132             m_scrollingNodeID = nodeID;
133             break;




134         case ScrollCoordinationRole::FrameHosting:
135             m_frameHostingNodeID = nodeID;
136             break;
137         case ScrollCoordinationRole::ViewportConstrained:
138             m_viewportConstrainedNodeID = nodeID;
<span class="line-modified">139             setIsScrollCoordinatedWithViewportConstrainedRole(nodeID);</span>


140             break;
141         }
142     }
143 
<span class="line-modified">144     ScrollingNodeID scrollingNodeIDForChildren() const</span>
<span class="line-removed">145     {</span>
<span class="line-removed">146         return m_frameHostingNodeID ? m_frameHostingNodeID : (m_scrollingNodeID ? m_scrollingNodeID : m_viewportConstrainedNodeID);</span>
<span class="line-removed">147     }</span>
<span class="line-removed">148 </span>
<span class="line-removed">149     void setIsScrollCoordinatedWithViewportConstrainedRole(bool);</span>
150 
151     bool hasMaskLayer() const { return m_maskLayer; }
152     bool hasChildClippingMaskLayer() const { return m_childClippingMaskLayer != nullptr; }
153 
154     GraphicsLayer* parentForSublayers() const;
155     GraphicsLayer* childForSuperlayers() const;
156 
157     // RenderLayers with backing normally short-circuit paintLayer() because
158     // their content is rendered via callbacks from GraphicsLayer. However, the document
159     // layer is special, because it has a GraphicsLayer to act as a container for the GraphicsLayers
160     // for descendants, but its contents usually render into the window (in which case this returns true).
161     // This returns false for other layers, and when the document layer actually needs to paint into its backing store
162     // for some reason.
163     bool paintsIntoWindow() const;
164 
165     // Returns true for a composited layer that has no backing store of its own, so
166     // paints into some ancestor layer.
167     bool paintsIntoCompositedAncestor() const { return !m_requiresOwnBackingStore; }
168 
169     void setRequiresOwnBackingStore(bool);
170 
171     void setContentsNeedDisplay(GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
172     // r is in the coordinate space of the layer&#39;s render object
173     void setContentsNeedDisplayInRect(const LayoutRect&amp;, GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
174 
175     // Notification from the renderer that its content changed.
176     void contentChanged(ContentChangeType);
177 
178     // Interface to start, finish, suspend and resume animations and transitions
179     bool startTransition(double, CSSPropertyID, const RenderStyle* fromStyle, const RenderStyle* toStyle);
180     void transitionPaused(double timeOffset, CSSPropertyID);
181     void transitionFinished(CSSPropertyID);
182 
<span class="line-modified">183     bool startAnimation(double timeOffset, const Animation* anim, const KeyframeList&amp; keyframes);</span>
184     void animationPaused(double timeOffset, const String&amp; name);
185     void animationSeeked(double timeOffset, const String&amp; name);
186     void animationFinished(const String&amp; name);
187 
188     void suspendAnimations(MonotonicTime = MonotonicTime());
189     void resumeAnimations();
190 
191     LayoutRect compositedBounds() const;
192     // Returns true if changed.
193     bool setCompositedBounds(const LayoutRect&amp;);
194     // Returns true if changed.
195     bool updateCompositedBounds();
196 




197     void updateAfterWidgetResize();
198     void positionOverflowControlsLayers();
199 
200     bool isFrameLayerWithTiledBacking() const { return m_isFrameLayerWithTiledBacking; }
201 
202     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
203     void adjustTiledBackingCoverage();
204     void setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom);
205 
206     void updateDebugIndicators(bool showBorder, bool showRepaintCounter);
207     bool paintsSubpixelAntialiasedText() const { return m_paintsSubpixelAntialiasedText; }
208 
209     // GraphicsLayerClient interface
210     void tiledBackingUsageChanged(const GraphicsLayer*, bool /*usingTiledBacking*/) override;
211     void notifyAnimationStarted(const GraphicsLayer*, const String&amp; animationKey, MonotonicTime startTime) override;
212     void notifyFlushRequired(const GraphicsLayer*) override;
213     void notifyFlushBeforeDisplayRefresh(const GraphicsLayer*) override;
214 
<span class="line-modified">215     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, GraphicsLayerPaintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior) override;</span>
216 
217     float deviceScaleFactor() const override;
218     float contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const override;
219 
220     bool paintsOpaquelyAtNonIntegralScales(const GraphicsLayer*) const override;
221 
222     float pageScaleFactor() const override;
223     float zoomedOutPageScaleFactor() const override;
224 
225     void didChangePlatformLayerForLayer(const GraphicsLayer*) override;
226     bool getCurrentTransform(const GraphicsLayer*, TransformationMatrix&amp;) const override;
227 
228     bool isTrackingRepaints() const override;
229     bool shouldSkipLayerInDump(const GraphicsLayer*, LayerTreeAsTextBehavior) const override;
230     bool shouldDumpPropertyForLayer(const GraphicsLayer*, const char* propertyName, LayerTreeAsTextBehavior) const override;
231 
232     bool shouldAggressivelyRetainTiles(const GraphicsLayer*) const override;
233     bool shouldTemporarilyRetainTileCohorts(const GraphicsLayer*) const override;
234     bool useGiantTiles() const override;
235     void logFilledVisibleFreshTile(unsigned) override;
</pre>
<hr />
<pre>
271 
272 private:
273     friend class PaintedContentsInfo;
274 
275     FloatRect backgroundBoxForSimpleContainerPainting() const;
276 
277     void createPrimaryGraphicsLayer();
278     void destroyGraphicsLayers();
279 
280     void willDestroyLayer(const GraphicsLayer*);
281 
282     LayoutRect compositedBoundsIncludingMargin() const;
283 
284     Ref&lt;GraphicsLayer&gt; createGraphicsLayer(const String&amp;, GraphicsLayer::Type = GraphicsLayer::Type::Normal);
285 
286     RenderLayerModelObject&amp; renderer() const { return m_owningLayer.renderer(); }
287     RenderBox* renderBox() const { return m_owningLayer.renderBox(); }
288     RenderLayerCompositor&amp; compositor() const { return m_owningLayer.compositor(); }
289 
290     void updateInternalHierarchy();
<span class="line-modified">291     bool updateAncestorClippingLayer(bool needsAncestorClip);</span>
292     bool updateDescendantClippingLayer(bool needsDescendantClip);
293     bool updateOverflowControlsLayers(bool needsHorizontalScrollbarLayer, bool needsVerticalScrollbarLayer, bool needsScrollCornerLayer);
294     bool updateForegroundLayer(bool needsForegroundLayer);
295     bool updateBackgroundLayer(bool needsBackgroundLayer);
<span class="line-modified">296     void updateMaskingLayer(bool hasMask, bool hasClipPath);</span>
297     bool requiresHorizontalScrollbarLayer() const;
298     bool requiresVerticalScrollbarLayer() const;
299     bool requiresScrollCornerLayer() const;
300     bool updateScrollingLayers(bool scrollingLayers);
301 
302     void updateScrollOffset(ScrollOffset);
303     void setLocationOfScrolledContents(ScrollOffset, ScrollingLayerPositionAction);
304 
305     void updateChildClippingStrategy(bool needsDescendantsClippingLayer);
<span class="line-removed">306 </span>
307     void updateMaskingLayerGeometry();
<span class="line-removed">308 </span>
309     void updateRootLayerConfiguration();

310 
311     void setBackgroundLayerPaintsFixedRootBackground(bool);
312 
<span class="line-modified">313     GraphicsLayerPaintingPhase paintingPhaseForPrimaryLayer() const;</span>
<span class="line-removed">314 </span>
<span class="line-removed">315     LayoutSize contentOffsetInCompostingLayer() const;</span>
316     // Result is transform origin in device pixels.
317     FloatPoint3D computeTransformOriginForPainting(const LayoutRect&amp; borderBox) const;
318 
319     void updateOpacity(const RenderStyle&amp;);
320     void updateTransform(const RenderStyle&amp;);
321     void updateFilters(const RenderStyle&amp;);
322 #if ENABLE(FILTERS_LEVEL_2)
323     void updateBackdropFilters(const RenderStyle&amp;);
324     void updateBackdropFiltersGeometry();
325 #endif
326 #if ENABLE(CSS_COMPOSITING)
327     void updateBlendMode(const RenderStyle&amp;);
328 #endif
329     void updateCustomAppearance(const RenderStyle&amp;);
330 
331     // Return the opacity value that this layer should use for compositing.
332     float compositingOpacity(float rendererOpacity) const;
333     Color rendererBackgroundColor() const;
334 
335     bool isMainFrameRenderViewLayer() const;
</pre>
<hr />
<pre>
344     // Returns true if this layer has content that needs to be rendered by painting into the backing store.
345     bool containsPaintedContent(PaintedContentsInfo&amp;) const;
346     // Returns true if the RenderLayer just contains an image that we can composite directly.
347     bool isDirectlyCompositedImage() const;
348     void updateImageContents(PaintedContentsInfo&amp;);
349 
350     void updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
351     void updateDirectlyCompositedBackgroundColor(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
352     void updateDirectlyCompositedBackgroundImage(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
353 
354     void resetContentsRect();
355 
356     bool isPaintDestinationForDescendantLayers(RenderLayer::PaintedContentRequest&amp;) const;
357     bool hasVisibleNonCompositedDescendants() const;
358 
359     bool shouldClipCompositedBounds() const;
360 
361     bool hasTiledBackingFlatteningLayer() const { return (m_childContainmentLayer &amp;&amp; m_isFrameLayerWithTiledBacking); }
362     GraphicsLayer* tileCacheFlatteningLayer() const { return m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
363 
<span class="line-modified">364     void paintIntoLayer(const GraphicsLayer*, GraphicsContext&amp;, const IntRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt;, GraphicsLayerPaintingPhase);</span>


365 
366     static CSSPropertyID graphicsLayerToCSSProperty(AnimatedPropertyID);
367     static AnimatedPropertyID cssToGraphicsLayerProperty(CSSPropertyID);
368 
369     bool canIssueSetNeedsDisplay() const { return !paintsIntoWindow() &amp;&amp; !paintsIntoCompositedAncestor(); }
<span class="line-modified">370     LayoutRect computeParentGraphicsLayerRect(RenderLayer* compositedAncestor, LayoutSize&amp; ancestorClippingLayerOffset) const;</span>
371     LayoutRect computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const;
372 
373     RenderLayer&amp; m_owningLayer;
374 
<span class="line-modified">375     RefPtr&lt;GraphicsLayer&gt; m_ancestorClippingLayer; // Only used if we are clipped by an ancestor which is not a stacking context.</span>




376     RefPtr&lt;GraphicsLayer&gt; m_contentsContainmentLayer; // Only used if we have a background layer; takes the transform.
377     RefPtr&lt;GraphicsLayer&gt; m_graphicsLayer;
378     RefPtr&lt;GraphicsLayer&gt; m_foregroundLayer; // Only used in cases where we need to draw the foreground separately.
379     RefPtr&lt;GraphicsLayer&gt; m_backgroundLayer; // Only used in cases where we need to draw the background separately.
380     RefPtr&lt;GraphicsLayer&gt; m_childContainmentLayer; // Only used if we have clipping on a stacking context with compositing children, or if the layer has a tile cache.
381     RefPtr&lt;GraphicsLayer&gt; m_maskLayer; // Only used if we have a mask and/or clip-path.
382     RefPtr&lt;GraphicsLayer&gt; m_childClippingMaskLayer; // Only used if we have to clip child layers or accelerated contents with border radius or clip-path.
383 
384     RefPtr&lt;GraphicsLayer&gt; m_layerForHorizontalScrollbar;
385     RefPtr&lt;GraphicsLayer&gt; m_layerForVerticalScrollbar;
386     RefPtr&lt;GraphicsLayer&gt; m_layerForScrollCorner;
387 
388     RefPtr&lt;GraphicsLayer&gt; m_scrollContainerLayer; // Only used if the layer is using composited scrolling.
389     RefPtr&lt;GraphicsLayer&gt; m_scrolledContentsLayer; // Only used if the layer is using composited scrolling.
390 
391     LayoutRect m_compositedBounds;
392     LayoutSize m_subpixelOffsetFromRenderer; // This is the subpixel distance between the primary graphics layer and the associated renderer&#39;s bounds.
393     LayoutSize m_compositedBoundsOffsetFromGraphicsLayer; // This is the subpixel distance between the primary graphics layer and the render layer bounds.
394 
395     ScrollingNodeID m_viewportConstrainedNodeID { 0 };
396     ScrollingNodeID m_scrollingNodeID { 0 };
397     ScrollingNodeID m_frameHostingNodeID { 0 };

398 
399     bool m_artificiallyInflatedBounds { false }; // bounds had to be made non-zero to make transform-origin work
400     bool m_isMainFrameRenderViewLayer { false };
401     bool m_isFrameLayerWithTiledBacking { false };
402     bool m_requiresOwnBackingStore { true };
403     bool m_canCompositeFilters { false };
404 #if ENABLE(FILTERS_LEVEL_2)
405     bool m_canCompositeBackdropFilters { false };
406 #endif
407     bool m_backgroundLayerPaintsFixedRootBackground { false };
408     bool m_requiresBackgroundLayer { false };

409     bool m_paintsSubpixelAntialiasedText { false }; // This is for logging only.
410 };
411 
412 enum CanvasCompositingStrategy {
413     UnacceleratedCanvas,
414     CanvasPaintedToLayer,
415     CanvasAsLayerContents
416 };
417 CanvasCompositingStrategy canvasCompositingStrategy(const RenderObject&amp;);
418 
419 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayerBacking&amp;);
420 
421 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 27 
 28 #include &quot;FloatPoint.h&quot;
 29 #include &quot;FloatPoint3D.h&quot;
 30 #include &quot;GraphicsLayer.h&quot;
 31 #include &quot;GraphicsLayerClient.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderLayerCompositor.h&quot;
 34 #include &quot;ScrollingCoordinator.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class KeyframeList;
 39 class PaintedContentsInfo;
 40 class RenderLayerCompositor;
 41 class TiledBacking;
 42 class TransformationMatrix;
 43 
 44 enum CompositingLayerType {
 45     NormalCompositingLayer, // non-tiled layer with backing store
 46     TiledCompositingLayer, // tiled layer (always has backing store)
<span class="line-modified"> 47     MediaCompositingLayer, // layer that contains an image, video, WebGL or plugin</span>
 48     ContainerCompositingLayer // layer with no backing store
 49 };
 50 
 51 // RenderLayerBacking controls the compositing behavior for a single RenderLayer.
 52 // It holds the various GraphicsLayers, and makes decisions about intra-layer rendering
 53 // optimizations.
 54 //
 55 // There is one RenderLayerBacking for each RenderLayer that is composited.
 56 
 57 class RenderLayerBacking final : public GraphicsLayerClient {
 58     WTF_MAKE_NONCOPYABLE(RenderLayerBacking); WTF_MAKE_FAST_ALLOCATED;
 59 public:
 60     explicit RenderLayerBacking(RenderLayer&amp;);
 61     ~RenderLayerBacking();
 62 
 63 #if PLATFORM(IOS_FAMILY)
 64     void layerWillBeDestroyed();
 65 #endif
 66 
 67     // Do cleanup while layer-&gt;backing() is still valid.
 68     void willBeDestroyed();
 69 
 70     RenderLayer&amp; owningLayer() const { return m_owningLayer; }
 71 
<span class="line-added"> 72     // Included layers are non-z-order descendant layers that are painted into this backing.</span>
<span class="line-added"> 73     const Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; backingSharingLayers() const { return m_backingSharingLayers; }</span>
<span class="line-added"> 74     void setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp;);</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76     bool hasBackingSharingLayers() const { return !m_backingSharingLayers.isEmpty(); }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78     void removeBackingSharingLayer(RenderLayer&amp;);</span>
<span class="line-added"> 79     void clearBackingSharingLayers();</span>
<span class="line-added"> 80 </span>
 81     void updateConfigurationAfterStyleChange();
 82 
 83     // Returns true if layer configuration changed.
 84     bool updateConfiguration();
 85 
 86     // Update graphics layer position and bounds.
 87     void updateGeometry();
 88 
 89     // Update state the requires that descendant layers have been updated.
 90     void updateAfterDescendants();
 91 
 92     // Update contents and clipping structure.
 93     void updateDrawsContent();
 94 
<span class="line-modified"> 95     void updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint);</span>
 96 
 97     GraphicsLayer* graphicsLayer() const { return m_graphicsLayer.get(); }
 98 
 99     // Layer to clip children
100     bool hasClippingLayer() const { return (m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking); }
101     GraphicsLayer* clippingLayer() const { return !m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
102 
<span class="line-modified">103     bool hasAncestorClippingLayers() const { return !!m_ancestorClippingStack; }</span>
<span class="line-modified">104     LayerAncestorClippingStack* ancestorClippingStack() const { return m_ancestorClippingStack.get(); }</span>
<span class="line-modified">105     bool updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp;);</span>
106 
107     GraphicsLayer* contentsContainmentLayer() const { return m_contentsContainmentLayer.get(); }
108 
109     GraphicsLayer* foregroundLayer() const { return m_foregroundLayer.get(); }
110     GraphicsLayer* backgroundLayer() const { return m_backgroundLayer.get(); }
111     bool backgroundLayerPaintsFixedRootBackground() const { return m_backgroundLayerPaintsFixedRootBackground; }
112 
113     bool requiresBackgroundLayer() const { return m_requiresBackgroundLayer; }
114     void setRequiresBackgroundLayer(bool);
115 
116     bool hasScrollingLayer() const { return m_scrollContainerLayer != nullptr; }
117     GraphicsLayer* scrollContainerLayer() const { return m_scrollContainerLayer.get(); }
118     GraphicsLayer* scrolledContentsLayer() const { return m_scrolledContentsLayer.get(); }
119 


120     void detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt;);
121 
122     ScrollingNodeID scrollingNodeIDForRole(ScrollCoordinationRole role) const
123     {
124         switch (role) {
125         case ScrollCoordinationRole::Scrolling:
126             return m_scrollingNodeID;
<span class="line-added">127         case ScrollCoordinationRole::ScrollingProxy:</span>
<span class="line-added">128             // These nodeIDs are stored in m_ancestorClippingStack.</span>
<span class="line-added">129             ASSERT_NOT_REACHED();</span>
<span class="line-added">130             return 0;</span>
131         case ScrollCoordinationRole::FrameHosting:
132             return m_frameHostingNodeID;
133         case ScrollCoordinationRole::ViewportConstrained:
134             return m_viewportConstrainedNodeID;
<span class="line-added">135         case ScrollCoordinationRole::Positioning:</span>
<span class="line-added">136             return m_positioningNodeID;</span>
137         }
138         return 0;
139     }
140 
141     void setScrollingNodeIDForRole(ScrollingNodeID nodeID, ScrollCoordinationRole role)
142     {
143         switch (role) {
144         case ScrollCoordinationRole::Scrolling:
145             m_scrollingNodeID = nodeID;
146             break;
<span class="line-added">147         case ScrollCoordinationRole::ScrollingProxy:</span>
<span class="line-added">148             // These nodeIDs are stored in m_ancestorClippingStack.</span>
<span class="line-added">149             ASSERT_NOT_REACHED();</span>
<span class="line-added">150             break;</span>
151         case ScrollCoordinationRole::FrameHosting:
152             m_frameHostingNodeID = nodeID;
153             break;
154         case ScrollCoordinationRole::ViewportConstrained:
155             m_viewportConstrainedNodeID = nodeID;
<span class="line-modified">156             break;</span>
<span class="line-added">157         case ScrollCoordinationRole::Positioning:</span>
<span class="line-added">158             m_positioningNodeID = nodeID;</span>
159             break;
160         }
161     }
162 
<span class="line-modified">163     ScrollingNodeID scrollingNodeIDForChildren() const;</span>





164 
165     bool hasMaskLayer() const { return m_maskLayer; }
166     bool hasChildClippingMaskLayer() const { return m_childClippingMaskLayer != nullptr; }
167 
168     GraphicsLayer* parentForSublayers() const;
169     GraphicsLayer* childForSuperlayers() const;
170 
171     // RenderLayers with backing normally short-circuit paintLayer() because
172     // their content is rendered via callbacks from GraphicsLayer. However, the document
173     // layer is special, because it has a GraphicsLayer to act as a container for the GraphicsLayers
174     // for descendants, but its contents usually render into the window (in which case this returns true).
175     // This returns false for other layers, and when the document layer actually needs to paint into its backing store
176     // for some reason.
177     bool paintsIntoWindow() const;
178 
179     // Returns true for a composited layer that has no backing store of its own, so
180     // paints into some ancestor layer.
181     bool paintsIntoCompositedAncestor() const { return !m_requiresOwnBackingStore; }
182 
183     void setRequiresOwnBackingStore(bool);
184 
185     void setContentsNeedDisplay(GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
186     // r is in the coordinate space of the layer&#39;s render object
187     void setContentsNeedDisplayInRect(const LayoutRect&amp;, GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
188 
189     // Notification from the renderer that its content changed.
190     void contentChanged(ContentChangeType);
191 
192     // Interface to start, finish, suspend and resume animations and transitions
193     bool startTransition(double, CSSPropertyID, const RenderStyle* fromStyle, const RenderStyle* toStyle);
194     void transitionPaused(double timeOffset, CSSPropertyID);
195     void transitionFinished(CSSPropertyID);
196 
<span class="line-modified">197     bool startAnimation(double timeOffset, const Animation&amp;, const KeyframeList&amp;);</span>
198     void animationPaused(double timeOffset, const String&amp; name);
199     void animationSeeked(double timeOffset, const String&amp; name);
200     void animationFinished(const String&amp; name);
201 
202     void suspendAnimations(MonotonicTime = MonotonicTime());
203     void resumeAnimations();
204 
205     LayoutRect compositedBounds() const;
206     // Returns true if changed.
207     bool setCompositedBounds(const LayoutRect&amp;);
208     // Returns true if changed.
209     bool updateCompositedBounds();
210 
<span class="line-added">211     void updateAllowsBackingStoreDetaching(const LayoutRect&amp; absoluteBounds);</span>
<span class="line-added">212 </span>
<span class="line-added">213     void updateEventRegion();</span>
<span class="line-added">214 </span>
215     void updateAfterWidgetResize();
216     void positionOverflowControlsLayers();
217 
218     bool isFrameLayerWithTiledBacking() const { return m_isFrameLayerWithTiledBacking; }
219 
220     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
221     void adjustTiledBackingCoverage();
222     void setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom);
223 
224     void updateDebugIndicators(bool showBorder, bool showRepaintCounter);
225     bool paintsSubpixelAntialiasedText() const { return m_paintsSubpixelAntialiasedText; }
226 
227     // GraphicsLayerClient interface
228     void tiledBackingUsageChanged(const GraphicsLayer*, bool /*usingTiledBacking*/) override;
229     void notifyAnimationStarted(const GraphicsLayer*, const String&amp; animationKey, MonotonicTime startTime) override;
230     void notifyFlushRequired(const GraphicsLayer*) override;
231     void notifyFlushBeforeDisplayRefresh(const GraphicsLayer*) override;
232 
<span class="line-modified">233     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior) override;</span>
234 
235     float deviceScaleFactor() const override;
236     float contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const override;
237 
238     bool paintsOpaquelyAtNonIntegralScales(const GraphicsLayer*) const override;
239 
240     float pageScaleFactor() const override;
241     float zoomedOutPageScaleFactor() const override;
242 
243     void didChangePlatformLayerForLayer(const GraphicsLayer*) override;
244     bool getCurrentTransform(const GraphicsLayer*, TransformationMatrix&amp;) const override;
245 
246     bool isTrackingRepaints() const override;
247     bool shouldSkipLayerInDump(const GraphicsLayer*, LayerTreeAsTextBehavior) const override;
248     bool shouldDumpPropertyForLayer(const GraphicsLayer*, const char* propertyName, LayerTreeAsTextBehavior) const override;
249 
250     bool shouldAggressivelyRetainTiles(const GraphicsLayer*) const override;
251     bool shouldTemporarilyRetainTileCohorts(const GraphicsLayer*) const override;
252     bool useGiantTiles() const override;
253     void logFilledVisibleFreshTile(unsigned) override;
</pre>
<hr />
<pre>
289 
290 private:
291     friend class PaintedContentsInfo;
292 
293     FloatRect backgroundBoxForSimpleContainerPainting() const;
294 
295     void createPrimaryGraphicsLayer();
296     void destroyGraphicsLayers();
297 
298     void willDestroyLayer(const GraphicsLayer*);
299 
300     LayoutRect compositedBoundsIncludingMargin() const;
301 
302     Ref&lt;GraphicsLayer&gt; createGraphicsLayer(const String&amp;, GraphicsLayer::Type = GraphicsLayer::Type::Normal);
303 
304     RenderLayerModelObject&amp; renderer() const { return m_owningLayer.renderer(); }
305     RenderBox* renderBox() const { return m_owningLayer.renderBox(); }
306     RenderLayerCompositor&amp; compositor() const { return m_owningLayer.compositor(); }
307 
308     void updateInternalHierarchy();
<span class="line-modified">309     bool updateAncestorClipping(bool needsAncestorClip, const RenderLayer* compositingAncestor);</span>
310     bool updateDescendantClippingLayer(bool needsDescendantClip);
311     bool updateOverflowControlsLayers(bool needsHorizontalScrollbarLayer, bool needsVerticalScrollbarLayer, bool needsScrollCornerLayer);
312     bool updateForegroundLayer(bool needsForegroundLayer);
313     bool updateBackgroundLayer(bool needsBackgroundLayer);
<span class="line-modified">314     bool updateMaskingLayer(bool hasMask, bool hasClipPath);</span>
315     bool requiresHorizontalScrollbarLayer() const;
316     bool requiresVerticalScrollbarLayer() const;
317     bool requiresScrollCornerLayer() const;
318     bool updateScrollingLayers(bool scrollingLayers);
319 
320     void updateScrollOffset(ScrollOffset);
321     void setLocationOfScrolledContents(ScrollOffset, ScrollingLayerPositionAction);
322 
323     void updateChildClippingStrategy(bool needsDescendantsClippingLayer);

324     void updateMaskingLayerGeometry();

325     void updateRootLayerConfiguration();
<span class="line-added">326     void updatePaintingPhases();</span>
327 
328     void setBackgroundLayerPaintsFixedRootBackground(bool);
329 
<span class="line-modified">330     LayoutSize contentOffsetInCompositingLayer() const;</span>


331     // Result is transform origin in device pixels.
332     FloatPoint3D computeTransformOriginForPainting(const LayoutRect&amp; borderBox) const;
333 
334     void updateOpacity(const RenderStyle&amp;);
335     void updateTransform(const RenderStyle&amp;);
336     void updateFilters(const RenderStyle&amp;);
337 #if ENABLE(FILTERS_LEVEL_2)
338     void updateBackdropFilters(const RenderStyle&amp;);
339     void updateBackdropFiltersGeometry();
340 #endif
341 #if ENABLE(CSS_COMPOSITING)
342     void updateBlendMode(const RenderStyle&amp;);
343 #endif
344     void updateCustomAppearance(const RenderStyle&amp;);
345 
346     // Return the opacity value that this layer should use for compositing.
347     float compositingOpacity(float rendererOpacity) const;
348     Color rendererBackgroundColor() const;
349 
350     bool isMainFrameRenderViewLayer() const;
</pre>
<hr />
<pre>
359     // Returns true if this layer has content that needs to be rendered by painting into the backing store.
360     bool containsPaintedContent(PaintedContentsInfo&amp;) const;
361     // Returns true if the RenderLayer just contains an image that we can composite directly.
362     bool isDirectlyCompositedImage() const;
363     void updateImageContents(PaintedContentsInfo&amp;);
364 
365     void updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
366     void updateDirectlyCompositedBackgroundColor(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
367     void updateDirectlyCompositedBackgroundImage(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
368 
369     void resetContentsRect();
370 
371     bool isPaintDestinationForDescendantLayers(RenderLayer::PaintedContentRequest&amp;) const;
372     bool hasVisibleNonCompositedDescendants() const;
373 
374     bool shouldClipCompositedBounds() const;
375 
376     bool hasTiledBackingFlatteningLayer() const { return (m_childContainmentLayer &amp;&amp; m_isFrameLayerWithTiledBacking); }
377     GraphicsLayer* tileCacheFlatteningLayer() const { return m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
378 
<span class="line-modified">379     void paintIntoLayer(const GraphicsLayer*, GraphicsContext&amp;, const IntRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;GraphicsLayerPaintingPhase&gt;);</span>
<span class="line-added">380 </span>
<span class="line-added">381     void paintDebugOverlays(const GraphicsLayer*, GraphicsContext&amp;);</span>
382 
383     static CSSPropertyID graphicsLayerToCSSProperty(AnimatedPropertyID);
384     static AnimatedPropertyID cssToGraphicsLayerProperty(CSSPropertyID);
385 
386     bool canIssueSetNeedsDisplay() const { return !paintsIntoWindow() &amp;&amp; !paintsIntoCompositedAncestor(); }
<span class="line-modified">387     LayoutRect computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const;</span>
388     LayoutRect computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const;
389 
390     RenderLayer&amp; m_owningLayer;
391 
<span class="line-modified">392     // A list other layers that paint into this backing store, later than m_owningLayer in paint order.</span>
<span class="line-added">393     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;</span>
<span class="line-added">394 </span>
<span class="line-added">395     std::unique_ptr&lt;LayerAncestorClippingStack&gt; m_ancestorClippingStack; // Only used if we are clipped by an ancestor which is not a stacking context.</span>
<span class="line-added">396 </span>
397     RefPtr&lt;GraphicsLayer&gt; m_contentsContainmentLayer; // Only used if we have a background layer; takes the transform.
398     RefPtr&lt;GraphicsLayer&gt; m_graphicsLayer;
399     RefPtr&lt;GraphicsLayer&gt; m_foregroundLayer; // Only used in cases where we need to draw the foreground separately.
400     RefPtr&lt;GraphicsLayer&gt; m_backgroundLayer; // Only used in cases where we need to draw the background separately.
401     RefPtr&lt;GraphicsLayer&gt; m_childContainmentLayer; // Only used if we have clipping on a stacking context with compositing children, or if the layer has a tile cache.
402     RefPtr&lt;GraphicsLayer&gt; m_maskLayer; // Only used if we have a mask and/or clip-path.
403     RefPtr&lt;GraphicsLayer&gt; m_childClippingMaskLayer; // Only used if we have to clip child layers or accelerated contents with border radius or clip-path.
404 
405     RefPtr&lt;GraphicsLayer&gt; m_layerForHorizontalScrollbar;
406     RefPtr&lt;GraphicsLayer&gt; m_layerForVerticalScrollbar;
407     RefPtr&lt;GraphicsLayer&gt; m_layerForScrollCorner;
408 
409     RefPtr&lt;GraphicsLayer&gt; m_scrollContainerLayer; // Only used if the layer is using composited scrolling.
410     RefPtr&lt;GraphicsLayer&gt; m_scrolledContentsLayer; // Only used if the layer is using composited scrolling.
411 
412     LayoutRect m_compositedBounds;
413     LayoutSize m_subpixelOffsetFromRenderer; // This is the subpixel distance between the primary graphics layer and the associated renderer&#39;s bounds.
414     LayoutSize m_compositedBoundsOffsetFromGraphicsLayer; // This is the subpixel distance between the primary graphics layer and the render layer bounds.
415 
416     ScrollingNodeID m_viewportConstrainedNodeID { 0 };
417     ScrollingNodeID m_scrollingNodeID { 0 };
418     ScrollingNodeID m_frameHostingNodeID { 0 };
<span class="line-added">419     ScrollingNodeID m_positioningNodeID { 0 };</span>
420 
421     bool m_artificiallyInflatedBounds { false }; // bounds had to be made non-zero to make transform-origin work
422     bool m_isMainFrameRenderViewLayer { false };
423     bool m_isFrameLayerWithTiledBacking { false };
424     bool m_requiresOwnBackingStore { true };
425     bool m_canCompositeFilters { false };
426 #if ENABLE(FILTERS_LEVEL_2)
427     bool m_canCompositeBackdropFilters { false };
428 #endif
429     bool m_backgroundLayerPaintsFixedRootBackground { false };
430     bool m_requiresBackgroundLayer { false };
<span class="line-added">431     bool m_hasSubpixelRounding { false };</span>
432     bool m_paintsSubpixelAntialiasedText { false }; // This is for logging only.
433 };
434 
435 enum CanvasCompositingStrategy {
436     UnacceleratedCanvas,
437     CanvasPaintedToLayer,
438     CanvasAsLayerContents
439 };
440 CanvasCompositingStrategy canvasCompositingStrategy(const RenderObject&amp;);
441 
442 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayerBacking&amp;);
443 
444 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerBacking.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>