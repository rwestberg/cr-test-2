<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITOpcodes32_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -74,10 +74,11 @@</span>
  #include &quot;SuperSampler.h&quot;
  #include &quot;TestRunnerUtils.h&quot;
  #include &quot;ThunkGenerators.h&quot;
  #include &quot;TypeProfilerLog.h&quot;
  #include &quot;VMInlines.h&quot;
<span class="udiff-line-added">+ #include &quot;WebAssemblyFunction.h&quot;</span>
  #include &lt;wtf/InlineASM.h&gt;
  
  namespace JSC {
  
  extern &quot;C&quot; {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,61 +91,71 @@</span>
  #else
  #define OUR_RETURN_ADDRESS __builtin_return_address(0)
  #endif
  
  #if ENABLE(OPCODE_SAMPLING)
<span class="udiff-line-modified-removed">- #define CTI_SAMPLER vm-&gt;interpreter-&gt;sampler()</span>
<span class="udiff-line-modified-added">+ #define CTI_SAMPLER vm.interpreter-&gt;sampler()</span>
  #else
  #define CTI_SAMPLER 0
  #endif
  
  
  void JIT_OPERATION operationThrowStackOverflowError(ExecState* exec, CodeBlock* codeBlock)
  {
      // We pass in our own code block, because the callframe hasn&#39;t been populated.
<span class="udiff-line-modified-removed">-     VM* vm = codeBlock-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-removed">-     exec-&gt;convertToStackOverflowFrame(*vm, codeBlock);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-modified-added">+     exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
      NativeCallFrameTracer tracer(vm, exec);
      throwStackOverflowError(exec, scope);
  }
  
<span class="udiff-line-added">+ void JIT_OPERATION throwStackOverflowErrorFromThunk(VM* vmPointer, ExecState* exec)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-added">+     throwStackOverflowError(exec, scope);</span>
<span class="udiff-line-added">+     genericUnwind(vm, exec);</span>
<span class="udiff-line-added">+     ASSERT(vm.targetMachinePCForThrow);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  int32_t JIT_OPERATION operationCallArityCheck(ExecState* exec)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="udiff-line-modified-removed">-     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, *vm, CodeForCall);</span>
<span class="udiff-line-modified-added">+     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);</span>
      if (UNLIKELY(missingArgCount &lt; 0)) {
          CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);
<span class="udiff-line-modified-removed">-         exec-&gt;convertToStackOverflowFrame(*vm, codeBlock);</span>
<span class="udiff-line-modified-added">+         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
          NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-         throwStackOverflowError(vm-&gt;topCallFrame, scope);</span>
<span class="udiff-line-modified-added">+         throwStackOverflowError(vm.topCallFrame, scope);</span>
      }
  
      return missingArgCount;
  }
  
  int32_t JIT_OPERATION operationConstructArityCheck(ExecState* exec)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="udiff-line-modified-removed">-     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, *vm, CodeForConstruct);</span>
<span class="udiff-line-modified-added">+     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);</span>
      if (UNLIKELY(missingArgCount &lt; 0)) {
          CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);
<span class="udiff-line-modified-removed">-         exec-&gt;convertToStackOverflowFrame(*vm, codeBlock);</span>
<span class="udiff-line-modified-added">+         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
          NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-         throwStackOverflowError(vm-&gt;topCallFrame, scope);</span>
<span class="udiff-line-modified-added">+         throwStackOverflowError(vm.topCallFrame, scope);</span>
      }
  
      return missingArgCount;
  }
  
  EncodedJSValue JIT_OPERATION operationTryGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      Identifier ident = Identifier::fromUid(vm, uid);
      stubInfo-&gt;tookSlowPath = true;
  
      JSValue baseValue = JSValue::decode(base);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -155,11 +166,11 @@</span>
  }
  
  
  EncodedJSValue JIT_OPERATION operationTryGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      Identifier ident = Identifier::fromUid(vm, uid);
  
      JSValue baseValue = JSValue::decode(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,33 +179,33 @@</span>
      return JSValue::encode(slot.getPureResult());
  }
  
  EncodedJSValue JIT_OPERATION operationTryGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
      Identifier ident = Identifier::fromUid(vm, uid);
  
      JSValue baseValue = JSValue::decode(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
  
      baseValue.getPropertySlot(exec, ident, slot);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()) &amp;&amp; !slot.isTaintedByOpaqueObject() &amp;&amp; (slot.isCacheableValue() || slot.isCacheableGetter() || slot.isUnset()))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()) &amp;&amp; !slot.isTaintedByOpaqueObject() &amp;&amp; (slot.isCacheableValue() || slot.isCacheableGetter() || slot.isUnset()))</span>
          repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Try);
  
      return JSValue::encode(slot.getPureResult());
  }
  
  EncodedJSValue JIT_OPERATION operationGetByIdDirect(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
      stubInfo-&gt;tookSlowPath = true;
  
      JSValue baseValue = JSValue::decode(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -205,13 +216,13 @@</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByIdDirectGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
  
      JSValue baseValue = JSValue::decode(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
  
      bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -221,80 +232,87 @@</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByIdDirectOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
  
      JSValue baseValue = JSValue::decode(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
  
      bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
          repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Direct);
  
      RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));
  }
  
  EncodedJSValue JIT_OPERATION operationGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      stubInfo-&gt;tookSlowPath = true;
  
      JSValue baseValue = JSValue::decode(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
      Identifier ident = Identifier::fromUid(vm, uid);
<span class="udiff-line-added">+     JSValue result = baseValue.get(exec, ident, slot);</span>
  
<span class="udiff-line-modified-removed">-     LOG_IC((ICEvent::OperationGetById, baseValue.classInfoOrNull(*vm), ident));</span>
<span class="udiff-line-modified-removed">-     return JSValue::encode(baseValue.get(exec, ident, slot));</span>
<span class="udiff-line-modified-added">+     LOG_IC((ICEvent::OperationGetById, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     return JSValue::encode(result);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue baseValue = JSValue::decode(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
      Identifier ident = Identifier::fromUid(vm, uid);
<span class="udiff-line-modified-removed">-     LOG_IC((ICEvent::OperationGetByIdGeneric, baseValue.classInfoOrNull(*vm), ident));</span>
<span class="udiff-line-modified-removed">-     return JSValue::encode(baseValue.get(exec, ident, slot));</span>
<span class="udiff-line-modified-added">+     JSValue result = baseValue.get(exec, ident, slot);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationGetByIdGeneric, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return JSValue::encode(result);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      Identifier ident = Identifier::fromUid(vm, uid);
  
      JSValue baseValue = JSValue::decode(base);
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationGetByIdOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
  
      return JSValue::encode(baseValue.getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
<span class="udiff-line-modified-removed">-         if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         LOG_IC((ICEvent::OperationGetByIdOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
              repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Normal);
          return found ? slot.getValue(exec, ident) : jsUndefined();
      }));
  }
  
  EncodedJSValue JIT_OPERATION operationGetByIdWithThis(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      Identifier ident = Identifier::fromUid(vm, uid);
  
      stubInfo-&gt;tookSlowPath = true;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -307,11 +325,11 @@</span>
  
  EncodedJSValue JIT_OPERATION operationGetByIdWithThisGeneric(ExecState* exec, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      Identifier ident = Identifier::fromUid(vm, uid);
  
      JSValue baseValue = JSValue::decode(base);
      JSValue thisValue = JSValue::decode(thisEncoded);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -322,37 +340,38 @@</span>
  
  EncodedJSValue JIT_OPERATION operationGetByIdWithThisOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      Identifier ident = Identifier::fromUid(vm, uid);
  
      JSValue baseValue = JSValue::decode(base);
      JSValue thisValue = JSValue::decode(thisEncoded);
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationGetByIdWithThisOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
  
      PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
      return JSValue::encode(baseValue.getPropertySlot(exec, ident, slot, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
<span class="udiff-line-modified-removed">-         if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
<span class="udiff-line-modified-added">+         LOG_IC((ICEvent::OperationGetByIdWithThisOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
              repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::WithThis);
          return found ? slot.getValue(exec, ident) : jsUndefined();
      }));
  }
  
  EncodedJSValue JIT_OPERATION operationInById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      stubInfo-&gt;tookSlowPath = true;
  
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
  
      JSValue baseValue = JSValue::decode(base);
      if (!baseValue.isObject()) {
          throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
          return JSValue::encode(jsUndefined());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,14 +388,14 @@</span>
  EncodedJSValue JIT_OPERATION operationInByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
  
      JSValue baseValue = JSValue::decode(base);
      if (!baseValue.isObject()) {
          throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
          return JSValue::encode(jsUndefined());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -393,14 +412,14 @@</span>
  EncodedJSValue JIT_OPERATION operationInByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
  
      JSValue baseValue = JSValue::decode(base);
      if (!baseValue.isObject()) {
          throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
          return JSValue::encode(jsUndefined());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -410,197 +429,208 @@</span>
      LOG_IC((ICEvent::OperationInByIdOptimize, baseObject-&gt;classInfo(vm), ident));
  
      scope.release();
      PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
      bool found = baseObject-&gt;getPropertySlot(exec, ident, slot);
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseObject-&gt;structure(vm)))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseObject-&gt;structure(vm)))</span>
          repatchInByID(exec, baseObject, ident, found, slot, *stubInfo);
      return JSValue::encode(jsBoolean(found));
  }
  
  EncodedJSValue JIT_OPERATION operationInByVal(ExecState* exec, JSCell* base, EncodedJSValue key)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(jsBoolean(CommonSlowPaths::opInByVal(exec, base, JSValue::decode(key))));
  }
  
  void JIT_OPERATION operationPutByIdStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      stubInfo-&gt;tookSlowPath = true;
  
      JSValue baseValue = JSValue::decode(encodedBase);
      Identifier ident = Identifier::fromUid(vm, uid);
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdStrict, baseValue.classInfoOrNull(*vm), ident));</span>
<span class="udiff-line-removed">- </span>
      PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());
      baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
  }
  
  void JIT_OPERATION operationPutByIdNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      stubInfo-&gt;tookSlowPath = true;
  
      JSValue baseValue = JSValue::decode(encodedBase);
      Identifier ident = Identifier::fromUid(vm, uid);
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdNonStrict, baseValue.classInfoOrNull(*vm), ident));</span>
      PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());
      baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
  }
  
  void JIT_OPERATION operationPutByIdDirectStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      stubInfo-&gt;tookSlowPath = true;
  
      JSValue baseValue = JSValue::decode(encodedBase);
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdDirectStrict, baseValue.classInfoOrNull(vm), ident));</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
      PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());
      CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdDirectStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
  }
  
  void JIT_OPERATION operationPutByIdDirectNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      stubInfo-&gt;tookSlowPath = true;
  
      JSValue baseValue = JSValue::decode(encodedBase);
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdDirectNonStrict, baseValue.classInfoOrNull(vm), ident));</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
      PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());
      CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdDirectNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
  }
  
  void JIT_OPERATION operationPutByIdStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      Identifier ident = Identifier::fromUid(vm, uid);
      AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
  
      JSValue value = JSValue::decode(encodedValue);
      JSValue baseValue = JSValue::decode(encodedBase);
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdStrictOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      PutPropertySlot slot(baseValue, true, codeBlock-&gt;putByIdContext());
  
<span class="udiff-line-modified-removed">-     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(*vm) : nullptr;</span>
<span class="udiff-line-modified-added">+     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;</span>
      baseValue.putInline(exec, ident, value, slot);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
<span class="udiff-line-added">+ </span>
      RETURN_IF_EXCEPTION(scope, void());
  
      if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
          return;
  
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
          repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);
  }
  
  void JIT_OPERATION operationPutByIdNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      Identifier ident = Identifier::fromUid(vm, uid);
      AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
  
      JSValue value = JSValue::decode(encodedValue);
      JSValue baseValue = JSValue::decode(encodedBase);
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdNonStrictOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      PutPropertySlot slot(baseValue, false, codeBlock-&gt;putByIdContext());
  
<span class="udiff-line-modified-removed">-     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(*vm) : nullptr;</span>
<span class="udiff-line-modified-added">+     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;</span>
      baseValue.putInline(exec, ident, value, slot);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdNonStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
<span class="udiff-line-added">+ </span>
      RETURN_IF_EXCEPTION(scope, void());
  
      if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
          return;
  
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
          repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);
  }
  
  void JIT_OPERATION operationPutByIdDirectStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
      AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
  
      JSValue value = JSValue::decode(encodedValue);
      JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdDirectStrictOptimize, baseObject-&gt;classInfo(vm), ident));</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      PutPropertySlot slot(baseObject, true, codeBlock-&gt;putByIdContext());
      Structure* structure = nullptr;
      CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdDirectStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));</span>
<span class="udiff-line-added">+ </span>
      RETURN_IF_EXCEPTION(scope, void());
  
      if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
          return;
  
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
          repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);
  }
  
  void JIT_OPERATION operationPutByIdDirectNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="udiff-line-modified-added">+     Identifier ident = Identifier::fromUid(vm, uid);</span>
      AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
  
      JSValue value = JSValue::decode(encodedValue);
      JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="udiff-line-removed">-     LOG_IC((ICEvent::OperationPutByIdDirectNonStrictOptimize, baseObject-&gt;classInfo(vm), ident));</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      PutPropertySlot slot(baseObject, false, codeBlock-&gt;putByIdContext());
      Structure* structure = nullptr;
      CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LOG_IC((ICEvent::OperationPutByIdDirectNonStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));</span>
<span class="udiff-line-added">+ </span>
      RETURN_IF_EXCEPTION(scope, void());
  
      if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
          return;
  
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
          repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);
  }
  
  ALWAYS_INLINE static bool isStringOrSymbol(JSValue value)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -614,27 +644,28 @@</span>
      if (LIKELY(subscript.isUInt32())) {
          byValInfo-&gt;tookSlowPath = true;
          uint32_t i = subscript.asUInt32();
          if (baseValue.isObject()) {
              JSObject* object = asObject(baseValue);
<span class="udiff-line-modified-removed">-             if (object-&gt;canSetIndexQuickly(i)) {</span>
<span class="udiff-line-modified-added">+             if (object-&gt;canSetIndexQuickly(i, value)) {</span>
                  object-&gt;setIndexQuickly(vm, i, value);
                  return;
              }
  
<span class="udiff-line-removed">-             // FIXME: This will make us think that in-bounds typed array accesses are actually</span>
<span class="udiff-line-removed">-             // out-of-bounds.</span>
<span class="udiff-line-removed">-             // https://bugs.webkit.org/show_bug.cgi?id=149886</span>
              byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
              scope.release();
              object-&gt;methodTable(vm)-&gt;putByIndex(object, callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());
              return;
          }
  
          scope.release();
          baseValue.putByIndex(callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());
          return;
<span class="udiff-line-added">+     } else if (subscript.isInt32()) {</span>
<span class="udiff-line-added">+         byValInfo-&gt;tookSlowPath = true;</span>
<span class="udiff-line-added">+         if (baseValue.isObject())</span>
<span class="udiff-line-added">+             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();</span>
      }
  
      auto property = subscript.toPropertyKey(callFrame);
      // Don&#39;t put to an object if toString threw an exception.
      RETURN_IF_EXCEPTION(scope, void());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -718,10 +749,11 @@</span>
  {
      // See if it&#39;s worth optimizing at all.
      OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      if (baseValue.isObject() &amp;&amp; isCopyOnWrite(baseValue.getObject()-&gt;indexingMode()))
          return OptimizationResult::GiveUp;
  
      if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -736,11 +768,11 @@</span>
              JITArrayMode arrayMode = jitArrayModeForStructure(structure);
              if (jitArrayModePermitsPut(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
                  CodeBlock* codeBlock = exec-&gt;codeBlock();
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
                  byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
<span class="udiff-line-modified-removed">-                 JIT::compilePutByVal(locker, &amp;vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
<span class="udiff-line-modified-added">+                 JIT::compilePutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
                  optimizationResult = OptimizationResult::Optimized;
              }
          }
  
          // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -748,16 +780,17 @@</span>
              optimizationResult = OptimizationResult::GiveUp;
      }
  
      if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
          const Identifier propertyName = subscript.toPropertyKey(exec);
<span class="udiff-line-added">+         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);</span>
          if (subscript.isSymbol() || !parseIndex(propertyName)) {
              ASSERT(exec-&gt;bytecodeOffset());
              ASSERT(!byValInfo-&gt;stubRoutine);
              if (byValInfo-&gt;seen) {
                  if (byValInfo-&gt;cachedId == propertyName) {
<span class="udiff-line-modified-removed">-                     JIT::compilePutByValWithCachedId&lt;OpPutByVal&gt;(&amp;vm, exec-&gt;codeBlock(), byValInfo, returnAddress, NotDirect, propertyName);</span>
<span class="udiff-line-modified-added">+                     JIT::compilePutByValWithCachedId&lt;OpPutByVal&gt;(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, NotDirect, propertyName);</span>
                      optimizationResult = OptimizationResult::Optimized;
                  } else {
                      // Seem like a generic property access site.
                      optimizationResult = OptimizationResult::GiveUp;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -787,29 +820,33 @@</span>
  }
  
  void JIT_OPERATION operationPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      JSValue subscript = JSValue::decode(encodedSubscript);
      JSValue value = JSValue::decode(encodedValue);
<span class="udiff-line-modified-removed">-     if (tryPutByValOptimize(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS)) == OptimizationResult::GiveUp) {</span>
<span class="udiff-line-modified-added">+     OptimizationResult result = tryPutByValOptimize(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="udiff-line-added">+     if (result == OptimizationResult::GiveUp) {</span>
          // Don&#39;t ever try to optimize.
          byValInfo-&gt;tookSlowPath = true;
          ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationPutByValGeneric);
      }
<span class="udiff-line-modified-removed">-     putByVal(exec, baseValue, subscript, value, byValInfo);</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, putByVal(exec, baseValue, subscript, value, byValInfo));</span>
  }
  
  static OptimizationResult tryDirectPutByValOptimize(ExecState* exec, JSObject* object, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
  {
      // See if it&#39;s worth optimizing at all.
      OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      if (subscript.isInt32()) {
          ASSERT(exec-&gt;bytecodeOffset());
          ASSERT(!byValInfo-&gt;stubRoutine);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -820,26 +857,27 @@</span>
              if (jitArrayModePermitsPutDirect(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
                  CodeBlock* codeBlock = exec-&gt;codeBlock();
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
                  byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
  
<span class="udiff-line-modified-removed">-                 JIT::compileDirectPutByVal(locker, &amp;vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
<span class="udiff-line-modified-added">+                 JIT::compileDirectPutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
                  optimizationResult = OptimizationResult::Optimized;
              }
          }
  
          // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
          if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
              optimizationResult = OptimizationResult::GiveUp;
      } else if (isStringOrSymbol(subscript)) {
          const Identifier propertyName = subscript.toPropertyKey(exec);
<span class="udiff-line-added">+         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);</span>
          if (subscript.isSymbol() || !parseIndex(propertyName)) {
              ASSERT(exec-&gt;bytecodeOffset());
              ASSERT(!byValInfo-&gt;stubRoutine);
              if (byValInfo-&gt;seen) {
                  if (byValInfo-&gt;cachedId == propertyName) {
<span class="udiff-line-modified-removed">-                     JIT::compilePutByValWithCachedId&lt;OpPutByValDirect&gt;(&amp;vm, exec-&gt;codeBlock(), byValInfo, returnAddress, Direct, propertyName);</span>
<span class="udiff-line-modified-added">+                     JIT::compilePutByValWithCachedId&lt;OpPutByValDirect&gt;(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, Direct, propertyName);</span>
                      optimizationResult = OptimizationResult::Optimized;
                  } else {
                      // Seem like a generic property access site.
                      optimizationResult = OptimizationResult::GiveUp;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -869,30 +907,33 @@</span>
  }
  
  void JIT_OPERATION operationDirectPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      JSValue subscript = JSValue::decode(encodedSubscript);
      JSValue value = JSValue::decode(encodedValue);
      RELEASE_ASSERT(baseValue.isObject());
      JSObject* object = asObject(baseValue);
<span class="udiff-line-modified-removed">-     if (tryDirectPutByValOptimize(exec, object, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS)) == OptimizationResult::GiveUp) {</span>
<span class="udiff-line-modified-added">+     OptimizationResult result = tryDirectPutByValOptimize(exec, object, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="udiff-line-added">+     if (result == OptimizationResult::GiveUp) {</span>
          // Don&#39;t ever try to optimize.
          byValInfo-&gt;tookSlowPath = true;
          ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationDirectPutByValGeneric);
      }
  
<span class="udiff-line-modified-removed">-     directPutByVal(exec, object, subscript, value, byValInfo);</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, directPutByVal(exec, object, subscript, value, byValInfo));</span>
  }
  
  void JIT_OPERATION operationPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      JSValue subscript = JSValue::decode(encodedSubscript);
      JSValue value = JSValue::decode(encodedValue);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -901,23 +942,23 @@</span>
  
  
  void JIT_OPERATION operationDirectPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      JSValue subscript = JSValue::decode(encodedSubscript);
      JSValue value = JSValue::decode(encodedValue);
      RELEASE_ASSERT(baseValue.isObject());
      directPutByVal(exec, asObject(baseValue), subscript, value, byValInfo);
  }
  
  EncodedJSValue JIT_OPERATION operationCallEval(ExecState* exec, ExecState* execCallee)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      execCallee-&gt;setCodeBlock(0);
  
      if (!isHostFunction(execCallee-&gt;guaranteedJSValueCallee(), globalFuncEval))
          return JSValue::encode(JSValue());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -929,28 +970,28 @@</span>
  }
  
  static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CallLinkInfo* callLinkInfo)
  {
      ExecState* exec = execCallee-&gt;callerFrame();
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      execCallee-&gt;setCodeBlock(0);
  
      if (callLinkInfo-&gt;specializationKind() == CodeForCall) {
          CallData callData;
<span class="udiff-line-modified-removed">-         CallType callType = getCallData(*vm, callee, callData);</span>
<span class="udiff-line-modified-added">+         CallType callType = getCallData(vm, callee, callData);</span>
  
          ASSERT(callType != CallType::JS);
  
          if (callType == CallType::Host) {
              NativeCallFrameTracer tracer(vm, execCallee);
              execCallee-&gt;setCallee(asObject(callee));
<span class="udiff-line-modified-removed">-             vm-&gt;hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));</span>
<span class="udiff-line-modified-added">+             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));</span>
              if (UNLIKELY(scope.exception())) {
                  return encodeResult(
<span class="udiff-line-modified-removed">-                     vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
<span class="udiff-line-modified-added">+                     vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
                      reinterpret_cast&lt;void*&gt;(KeepTheFrame));
              }
  
              return encodeResult(
                  tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -958,57 +999,57 @@</span>
          }
  
          ASSERT(callType == CallType::None);
          throwException(exec, scope, createNotAFunctionError(exec, callee));
          return encodeResult(
<span class="udiff-line-modified-removed">-             vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
<span class="udiff-line-modified-added">+             vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
              reinterpret_cast&lt;void*&gt;(KeepTheFrame));
      }
  
      ASSERT(callLinkInfo-&gt;specializationKind() == CodeForConstruct);
  
      ConstructData constructData;
<span class="udiff-line-modified-removed">-     ConstructType constructType = getConstructData(*vm, callee, constructData);</span>
<span class="udiff-line-modified-added">+     ConstructType constructType = getConstructData(vm, callee, constructData);</span>
  
      ASSERT(constructType != ConstructType::JS);
  
      if (constructType == ConstructType::Host) {
          NativeCallFrameTracer tracer(vm, execCallee);
          execCallee-&gt;setCallee(asObject(callee));
<span class="udiff-line-modified-removed">-         vm-&gt;hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));</span>
<span class="udiff-line-modified-added">+         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));</span>
          if (UNLIKELY(scope.exception())) {
              return encodeResult(
<span class="udiff-line-modified-removed">-                 vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
<span class="udiff-line-modified-added">+                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
                  reinterpret_cast&lt;void*&gt;(KeepTheFrame));
          }
  
          return encodeResult(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue), reinterpret_cast&lt;void*&gt;(KeepTheFrame));
      }
  
      ASSERT(constructType == ConstructType::None);
      throwException(exec, scope, createNotAConstructorError(exec, callee));
      return encodeResult(
<span class="udiff-line-modified-removed">-         vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
<span class="udiff-line-modified-added">+         vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
          reinterpret_cast&lt;void*&gt;(KeepTheFrame));
  }
  
  SlowPathReturnType JIT_OPERATION operationLinkCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)
  {
      ExecState* exec = execCallee-&gt;callerFrame();
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
  
      CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
      NativeCallFrameTracer tracer(vm, exec);
  
      RELEASE_ASSERT(!callLinkInfo-&gt;isDirect());
  
      JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();
      JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
      if (!calleeAsFunctionCell) {
<span class="udiff-line-modified-removed">-         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(*vm, calleeAsValue)) {</span>
<span class="udiff-line-modified-removed">-             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm-&gt;getCTIInternalFunctionTrampolineFor(kind);</span>
<span class="udiff-line-modified-added">+         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {</span>
<span class="udiff-line-modified-added">+             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);</span>
              RELEASE_ASSERT(!!codePtr);
  
              if (!callLinkInfo-&gt;seenOnce())
                  callLinkInfo-&gt;setSeen();
              else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1024,50 +1065,53 @@</span>
      JSScope* scope = callee-&gt;scopeUnchecked();
      ExecutableBase* executable = callee-&gt;executable();
  
      MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
      CodeBlock* codeBlock = nullptr;
<span class="udiff-line-modified-removed">-     if (executable-&gt;isHostFunction())</span>
<span class="udiff-line-modified-removed">-         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="udiff-line-modified-removed">-     else {</span>
<span class="udiff-line-modified-added">+     if (executable-&gt;isHostFunction()) {</span>
<span class="udiff-line-modified-added">+         codePtr = jsToWasmICCodePtr(vm, kind, callee);</span>
<span class="udiff-line-modified-added">+         if (!codePtr)</span>
<span class="udiff-line-added">+             codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="udiff-line-added">+     } else {</span>
          FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
  
          auto handleThrowException = [&amp;] () {
<span class="udiff-line-modified-removed">-             void* throwTarget = vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress();</span>
<span class="udiff-line-modified-added">+             void* throwTarget = vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress();</span>
              return encodeResult(throwTarget, reinterpret_cast&lt;void*&gt;(KeepTheFrame));
          };
  
          if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
              throwException(exec, throwScope, createNotAConstructorError(exec, callee));
              return handleThrowException();
          }
  
          CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="udiff-line-modified-removed">-         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(*vm, callee, scope, kind, *codeBlockSlot);</span>
<span class="udiff-line-modified-removed">-         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
<span class="udiff-line-modified-removed">-         if (error)</span>
<span class="udiff-line-modified-added">+         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);</span>
<span class="udiff-line-modified-added">+         EXCEPTION_ASSERT(throwScope.exception() == error);</span>
<span class="udiff-line-modified-added">+         if (UNLIKELY(error))</span>
              return handleThrowException();
          codeBlock = *codeBlockSlot;
          ArityCheckMode arity;
          if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo-&gt;isVarargs())
              arity = MustCheckArity;
          else
              arity = ArityCheckNotRequired;
          codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
      }
<span class="udiff-line-added">+ </span>
      if (!callLinkInfo-&gt;seenOnce())
          callLinkInfo-&gt;setSeen();
      else
          linkFor(execCallee, *callLinkInfo, codeBlock, callee, codePtr);
  
      return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
  }
  
  void JIT_OPERATION operationLinkDirectCall(ExecState* exec, CallLinkInfo* callLinkInfo, JSFunction* callee)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
  
      CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
      NativeCallFrameTracer tracer(vm, exec);
  
      RELEASE_ASSERT(callLinkInfo-&gt;isDirect());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1096,13 +1140,13 @@</span>
      else {
          FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
  
          RELEASE_ASSERT(isCall(kind) || functionExecutable-&gt;constructAbility() != ConstructAbility::CannotConstruct);
  
<span class="udiff-line-modified-removed">-         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(*vm, callee, scope, kind, codeBlock);</span>
<span class="udiff-line-modified-removed">-         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
<span class="udiff-line-modified-removed">-         if (error)</span>
<span class="udiff-line-modified-added">+         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, codeBlock);</span>
<span class="udiff-line-modified-added">+         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == error);</span>
<span class="udiff-line-modified-added">+         if (UNLIKELY(error))</span>
              return;
          unsigned argumentStackSlots = callLinkInfo-&gt;maxNumArguments();
          if (argumentStackSlots &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))
              codePtr = functionExecutable-&gt;entrypointFor(kind, MustCheckArity);
          else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1114,21 +1158,21 @@</span>
  
  inline SlowPathReturnType virtualForWithFunction(
      ExecState* execCallee, CallLinkInfo* callLinkInfo, JSCell*&amp; calleeAsFunctionCell)
  {
      ExecState* exec = execCallee-&gt;callerFrame();
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
  
      CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();
      calleeAsFunctionCell = getJSFunction(calleeAsValue);
      if (UNLIKELY(!calleeAsFunctionCell)) {
<span class="udiff-line-modified-removed">-         if (jsDynamicCast&lt;InternalFunction*&gt;(*vm, calleeAsValue)) {</span>
<span class="udiff-line-modified-removed">-             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm-&gt;getCTIInternalFunctionTrampolineFor(kind);</span>
<span class="udiff-line-modified-added">+         if (jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {</span>
<span class="udiff-line-modified-added">+             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);</span>
              ASSERT(!!codePtr);
              return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
          }
          RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, callLinkInfo));
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1140,20 +1184,20 @@</span>
          FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
  
          if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
              throwException(exec, throwScope, createNotAConstructorError(exec, function));
              return encodeResult(
<span class="udiff-line-modified-removed">-                 vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
<span class="udiff-line-modified-added">+                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
                  reinterpret_cast&lt;void*&gt;(KeepTheFrame));
          }
  
          CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="udiff-line-modified-removed">-         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(*vm, function, scope, kind, *codeBlockSlot);</span>
<span class="udiff-line-modified-removed">-         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
<span class="udiff-line-modified-removed">-         if (error) {</span>
<span class="udiff-line-modified-added">+         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, kind, *codeBlockSlot);</span>
<span class="udiff-line-modified-added">+         EXCEPTION_ASSERT(throwScope.exception() == error);</span>
<span class="udiff-line-modified-added">+         if (UNLIKELY(error)) {</span>
              return encodeResult(
<span class="udiff-line-modified-removed">-                 vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
<span class="udiff-line-modified-added">+                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
                  reinterpret_cast&lt;void*&gt;(KeepTheFrame));
          }
      }
      return encodeResult(executable-&gt;entrypointFor(
          kind, MustCheckArity).executableAddress(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1177,43 +1221,43 @@</span>
      return virtualForWithFunction(execCallee, callLinkInfo, calleeAsFunctionCellIgnored);
  }
  
  size_t JIT_OPERATION operationCompareLess(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return jsLess&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
  }
  
  size_t JIT_OPERATION operationCompareLessEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return jsLessEq&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
  }
  
  size_t JIT_OPERATION operationCompareGreater(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return jsLess&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));
  }
  
  size_t JIT_OPERATION operationCompareGreaterEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return jsLessEq&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));
  }
  
  size_t JIT_OPERATION operationCompareEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::equalSlowCaseInline(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1221,11 +1265,11 @@</span>
  EncodedJSValue JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)
  #else
  size_t JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)
  #endif
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      bool result = asString(left)-&gt;equal(exec, asString(right));
  #if USE(JSVALUE64)
      return JSValue::encode(jsBoolean(result));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1234,29 +1278,29 @@</span>
  #endif
  }
  
  size_t JIT_OPERATION operationCompareStrictEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue src1 = JSValue::decode(encodedOp1);
      JSValue src2 = JSValue::decode(encodedOp2);
  
      return JSValue::strictEqual(exec, src1, src2);
  }
  
  EncodedJSValue JIT_OPERATION operationNewArrayWithProfile(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, int size)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      return JSValue::encode(constructArrayNegativeIndexed(exec, profile, values, size));
  }
  
  EncodedJSValue JIT_OPERATION operationNewArrayWithSizeAndProfile(ExecState* exec, ArrayAllocationProfile* profile, EncodedJSValue size)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      JSValue sizeValue = JSValue::decode(size);
      return JSValue::encode(constructArrayWithSizeQuirk(exec, profile, exec-&gt;lexicalGlobalObject(), sizeValue));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1265,11 +1309,11 @@</span>
  template&lt;typename FunctionType&gt;
  static EncodedJSValue operationNewFunctionCommon(ExecState* exec, JSScope* scope, JSCell* functionExecutable, bool isInvalidated)
  {
      VM&amp; vm = exec-&gt;vm();
      ASSERT(functionExecutable-&gt;inherits&lt;FunctionExecutable&gt;(vm));
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      if (isInvalidated)
          return JSValue::encode(FunctionType::createWithInvalidatedReallocationWatchpoint(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
      return JSValue::encode(FunctionType::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1315,31 +1359,31 @@</span>
      return operationNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(exec, scope, functionExecutable, true);
  }
  
  void JIT_OPERATION operationSetFunctionName(ExecState* exec, JSCell* funcCell, EncodedJSValue encodedName)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSFunction* func = jsCast&lt;JSFunction*&gt;(funcCell);
      JSValue name = JSValue::decode(encodedName);
      func-&gt;setFunctionName(exec, name);
  }
  
  JSCell* JIT_OPERATION operationNewObject(ExecState* exec, Structure* structure)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return constructEmptyObject(exec, structure);
  }
  
  JSCell* JIT_OPERATION operationNewRegexp(ExecState* exec, JSCell* regexpPtr)
  {
      SuperSamplerScope superSamplerScope(false);
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
      ASSERT(regexp-&gt;isValid());
      return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1349,20 +1393,20 @@</span>
  // in the DFG. If a DFG slow path generator that supports a void return type is added in the
  // future, we can switch to using that then.
  UnusedPtr JIT_OPERATION operationHandleTraps(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      ASSERT(vm.needTrapHandling());
      vm.handleTraps(exec);
      return nullptr;
  }
  
  void JIT_OPERATION operationDebug(ExecState* exec, int32_t debugHookType)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      vm.interpreter-&gt;debug(exec, static_cast&lt;DebugHookType&gt;(debugHookType));
  }
  
  #if ENABLE(DFG_JIT)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1373,11 +1417,11 @@</span>
  }
  
  SlowPathReturnType JIT_OPERATION operationOptimize(ExecState* exec, uint32_t bytecodeIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      // Defer GC for a while so that it doesn&#39;t run between when we enter into this
      // slow path and when we figure out the state of our code block. This prevents
      // a number of awkward reentrancy scenarios, including:
      //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1392,11 +1436,11 @@</span>
      // that case we would have already planted the optimized code block into the JS
      // stack.
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock = exec-&gt;codeBlock();
<span class="udiff-line-modified-removed">-     if (UNLIKELY(codeBlock-&gt;jitType() != JITCode::BaselineJIT)) {</span>
<span class="udiff-line-modified-added">+     if (UNLIKELY(codeBlock-&gt;jitType() != JITType::BaselineJIT)) {</span>
          dataLog(&quot;Unexpected code block in Baseline-&gt;DFG tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      if (bytecodeIndex) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1618,19 +1662,19 @@</span>
  }
  
  char* JIT_OPERATION operationTryOSREnterAtCatch(ExecState* exec, uint32_t bytecodeIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      CodeBlock* optimizedReplacement = exec-&gt;codeBlock()-&gt;replacement();
      if (UNLIKELY(!optimizedReplacement))
          return nullptr;
  
      switch (optimizedReplacement-&gt;jitType()) {
<span class="udiff-line-modified-removed">-     case JITCode::DFGJIT:</span>
<span class="udiff-line-modified-removed">-     case JITCode::FTLJIT: {</span>
<span class="udiff-line-modified-added">+     case JITType::DFGJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::FTLJIT: {</span>
          MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);
          return entry.executableAddress&lt;char*&gt;();
      }
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1639,20 +1683,20 @@</span>
  }
  
  char* JIT_OPERATION operationTryOSREnterAtCatchAndValueProfile(ExecState* exec, uint32_t bytecodeIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      CodeBlock* optimizedReplacement = codeBlock-&gt;replacement();
      if (UNLIKELY(!optimizedReplacement))
          return nullptr;
  
      switch (optimizedReplacement-&gt;jitType()) {
<span class="udiff-line-modified-removed">-     case JITCode::DFGJIT:</span>
<span class="udiff-line-modified-removed">-     case JITCode::FTLJIT: {</span>
<span class="udiff-line-modified-added">+     case JITType::DFGJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::FTLJIT: {</span>
          MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);
          return entry.executableAddress&lt;char*&gt;();
      }
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1660,22 +1704,22 @@</span>
  
      codeBlock-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(bytecodeIndex);
      auto bytecode = codeBlock-&gt;instructions().at(bytecodeIndex)-&gt;as&lt;OpCatch&gt;();
      auto&amp; metadata = bytecode.metadata(codeBlock);
      metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
<span class="udiff-line-modified-removed">-         profile.m_profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
<span class="udiff-line-modified-added">+         profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
      });
  
      return nullptr;
  }
  
  #endif
  
  void JIT_OPERATION operationPutByIndex(ExecState* exec, EncodedJSValue encodedArrayValue, int32_t index, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue arrayValue = JSValue::decode(encodedArrayValue);
      ASSERT(isJSArray(arrayValue));
      asArray(arrayValue)-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1700,11 +1744,11 @@</span>
  }
  
  void JIT_OPERATION operationPutGetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* getter)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(object &amp;&amp; object-&gt;isObject());
      JSObject* baseObj = object-&gt;getObject();
  
      ASSERT(getter-&gt;isObject());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1712,11 +1756,11 @@</span>
  }
  
  void JIT_OPERATION operationPutSetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* setter)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(object &amp;&amp; object-&gt;isObject());
      JSObject* baseObj = object-&gt;getObject();
  
      ASSERT(setter-&gt;isObject());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1724,28 +1768,28 @@</span>
  }
  
  void JIT_OPERATION operationPutGetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* getter)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(getter), AccessorType::Getter);
  }
  
  void JIT_OPERATION operationPutSetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* setter)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(setter), AccessorType::Setter);
  }
  
  #if USE(JSVALUE64)
  void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, EncodedJSValue encodedGetterValue, EncodedJSValue encodedSetterValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(object &amp;&amp; object-&gt;isObject());
      JSObject* baseObject = asObject(object);
  
      JSValue getter = JSValue::decode(encodedGetterValue);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1757,11 +1801,11 @@</span>
  
  #else
  void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, JSCell* getterCell, JSCell* setterCell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(object &amp;&amp; object-&gt;isObject());
      JSObject* baseObject = asObject(object);
  
      ASSERT(getterCell || setterCell);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1773,26 +1817,24 @@</span>
  #endif
  
  void JIT_OPERATION operationPopScope(ExecState* exec, int32_t scopeReg)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSScope* scope = exec-&gt;uncheckedR(scopeReg).Register::scope();
      exec-&gt;uncheckedR(scopeReg) = scope-&gt;next();
  }
  
  int32_t JIT_OPERATION operationInstanceOfCustom(ExecState* exec, EncodedJSValue encodedValue, JSObject* constructor, EncodedJSValue encodedHasInstance)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue value = JSValue::decode(encodedValue);
      JSValue hasInstanceValue = JSValue::decode(encodedHasInstance);
  
<span class="udiff-line-removed">-     ASSERT(hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction() || !constructor-&gt;structure(vm)-&gt;typeInfo().implementsDefaultHasInstance());</span>
<span class="udiff-line-removed">- </span>
      if (constructor-&gt;hasInstance(exec, value, hasInstanceValue))
          return 1;
      return 0;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1804,28 +1846,30 @@</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="udiff-line-modified-removed">-             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="udiff-line-modified-removed">-                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get())) {</span>
<span class="udiff-line-modified-added">+             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
<span class="udiff-line-modified-added">+             RETURN_IF_EXCEPTION(scope, JSValue());</span>
<span class="udiff-line-added">+             if (existingAtomString) {</span>
<span class="udiff-line-added">+                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get())) {</span>
                      ASSERT(exec-&gt;bytecodeOffset());
<span class="udiff-line-modified-removed">-                     if (byValInfo-&gt;stubInfo &amp;&amp; byValInfo-&gt;cachedId.impl() != existingAtomicString)</span>
<span class="udiff-line-modified-added">+                     if (byValInfo-&gt;stubInfo &amp;&amp; byValInfo-&gt;cachedId.impl() != existingAtomString)</span>
                          byValInfo-&gt;tookSlowPath = true;
                      return result;
                  }
              }
          }
      }
  
<span class="udiff-line-modified-removed">-     if (subscript.isUInt32()) {</span>
<span class="udiff-line-modified-added">+     if (subscript.isInt32()) {</span>
          ASSERT(exec-&gt;bytecodeOffset());
          byValInfo-&gt;tookSlowPath = true;
  
<span class="udiff-line-modified-removed">-         uint32_t i = subscript.asUInt32();</span>
<span class="udiff-line-modified-added">+         int32_t i = subscript.asInt32();</span>
          if (isJSString(baseValue)) {
<span class="udiff-line-modified-removed">-             if (asString(baseValue)-&gt;canGetIndex(i)) {</span>
<span class="udiff-line-modified-added">+             if (i &gt;= 0 &amp;&amp; asString(baseValue)-&gt;canGetIndex(i)) {</span>
                  ctiPatchCallByReturnAddress(returnAddress, operationGetByValString);
                  RELEASE_AND_RETURN(scope, asString(baseValue)-&gt;getIndex(exec, i));
              }
              byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
          } else if (baseValue.isObject()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1833,11 +1877,11 @@</span>
              if (object-&gt;canGetIndexQuickly(i))
                  return object-&gt;getIndexQuickly(i);
  
              bool skipMarkingOutOfBounds = false;
  
<span class="udiff-line-modified-removed">-             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &lt; object-&gt;butterfly()-&gt;publicLength()) {</span>
<span class="udiff-line-modified-added">+             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &gt;= 0 &amp;&amp; static_cast&lt;uint32_t&gt;(i) &lt; object-&gt;butterfly()-&gt;publicLength()) {</span>
                  // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
                  // https://bugs.webkit.org/show_bug.cgi?id=182940
                  auto* globalObject = object-&gt;globalObject(vm);
                  skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1848,11 +1892,12 @@</span>
                  // https://bugs.webkit.org/show_bug.cgi?id=149886
                  byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
              }
          }
  
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, baseValue.get(exec, i));</span>
<span class="udiff-line-modified-added">+         if (i &gt;= 0)</span>
<span class="udiff-line-added">+             RELEASE_AND_RETURN(scope, baseValue.get(exec, static_cast&lt;uint32_t&gt;(i)));</span>
      }
  
      baseValue.requireObjectCoercible(exec);
      RETURN_IF_EXCEPTION(scope, JSValue());
      auto property = subscript.toPropertyKey(exec);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1869,10 +1914,11 @@</span>
  {
      // See if it&#39;s worth optimizing this at all.
      OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
  
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
          JSObject* object = asObject(baseValue);
  
          ASSERT(exec-&gt;bytecodeOffset());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1887,11 +1933,11 @@</span>
                  // Let&#39;s update the profile to do better next time.
                  CodeBlock* codeBlock = exec-&gt;codeBlock();
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
                  byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
  
<span class="udiff-line-modified-removed">-                 JIT::compileGetByVal(locker, &amp;vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
<span class="udiff-line-modified-added">+                 JIT::compileGetByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
                  optimizationResult = OptimizationResult::Optimized;
              }
          }
  
          // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1899,16 +1945,17 @@</span>
              optimizationResult = OptimizationResult::GiveUp;
      }
  
      if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
          const Identifier propertyName = subscript.toPropertyKey(exec);
<span class="udiff-line-added">+         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);</span>
          if (subscript.isSymbol() || !parseIndex(propertyName)) {
              ASSERT(exec-&gt;bytecodeOffset());
              ASSERT(!byValInfo-&gt;stubRoutine);
              if (byValInfo-&gt;seen) {
                  if (byValInfo-&gt;cachedId == propertyName) {
<span class="udiff-line-modified-removed">-                     JIT::compileGetByValWithCachedId(&amp;vm, exec-&gt;codeBlock(), byValInfo, returnAddress, propertyName);</span>
<span class="udiff-line-modified-added">+                     JIT::compileGetByValWithCachedId(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, propertyName);</span>
                      optimizationResult = OptimizationResult::Optimized;
                  } else {
                      // Seem like a generic property access site.
                      optimizationResult = OptimizationResult::GiveUp;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1940,44 +1987,47 @@</span>
  extern &quot;C&quot; {
  
  EncodedJSValue JIT_OPERATION operationGetByValGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      JSValue result = getByVal(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));
      return JSValue::encode(result);
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValOptimize(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue subscript = JSValue::decode(encodedSubscript);
      ReturnAddressPtr returnAddress = ReturnAddressPtr(OUR_RETURN_ADDRESS);
<span class="udiff-line-modified-removed">-     if (tryGetByValOptimize(exec, baseValue, subscript, byValInfo, returnAddress) == OptimizationResult::GiveUp) {</span>
<span class="udiff-line-modified-added">+     OptimizationResult result = tryGetByValOptimize(exec, baseValue, subscript, byValInfo, returnAddress);</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="udiff-line-added">+     if (result == OptimizationResult::GiveUp) {</span>
          // Don&#39;t ever try to optimize.
          byValInfo-&gt;tookSlowPath = true;
          ctiPatchCallByReturnAddress(returnAddress, operationGetByValGeneric);
      }
  
<span class="udiff-line-modified-removed">-     return JSValue::encode(getByVal(exec, baseValue, subscript, byValInfo, returnAddress));</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, JSValue::encode(getByVal(exec, baseValue, subscript, byValInfo, returnAddress)));</span>
  }
  
  EncodedJSValue JIT_OPERATION operationHasIndexedPropertyDefault(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      ASSERT(baseValue.isObject());
<span class="udiff-line-modified-removed">-     ASSERT(subscript.isUInt32());</span>
<span class="udiff-line-modified-added">+     ASSERT(subscript.isUInt32AsAnyInt());</span>
  
      JSObject* object = asObject(baseValue);
      bool didOptimize = false;
  
      ASSERT(exec-&gt;bytecodeOffset());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1985,11 +2035,11 @@</span>
  
      if (hasOptimizableIndexing(object-&gt;structure(vm))) {
          // Attempt to optimize.
          JITArrayMode arrayMode = jitArrayModeForStructure(object-&gt;structure(vm));
          if (arrayMode != byValInfo-&gt;arrayMode) {
<span class="udiff-line-modified-removed">-             JIT::compileHasIndexedProperty(&amp;vm, exec-&gt;codeBlock(), byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS), arrayMode);</span>
<span class="udiff-line-modified-added">+             JIT::compileHasIndexedProperty(vm, exec-&gt;codeBlock(), byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS), arrayMode);</span>
              didOptimize = true;
          }
      }
  
      if (!didOptimize) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2003,51 +2053,43 @@</span>
              // Don&#39;t ever try to optimize.
              ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationHasIndexedPropertyGeneric);
          }
      }
  
<span class="udiff-line-modified-removed">-     uint32_t index = subscript.asUInt32();</span>
<span class="udiff-line-modified-added">+     uint32_t index = subscript.asUInt32AsAnyInt();</span>
      if (object-&gt;canGetIndexQuickly(index))
          return JSValue::encode(JSValue(JSValue::JSTrue));
  
<span class="udiff-line-modified-removed">-     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index)) {</span>
<span class="udiff-line-removed">-         // FIXME: This will make us think that in-bounds typed array accesses are actually</span>
<span class="udiff-line-removed">-         // out-of-bounds.</span>
<span class="udiff-line-removed">-         // https://bugs.webkit.org/show_bug.cgi?id=149886</span>
<span class="udiff-line-modified-added">+     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))</span>
          byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="udiff-line-removed">-     }</span>
      return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, index, PropertySlot::InternalMethodType::GetOwnProperty)));
  }
  
  EncodedJSValue JIT_OPERATION operationHasIndexedPropertyGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      ASSERT(baseValue.isObject());
<span class="udiff-line-modified-removed">-     ASSERT(subscript.isUInt32());</span>
<span class="udiff-line-modified-added">+     ASSERT(subscript.isUInt32AsAnyInt());</span>
  
      JSObject* object = asObject(baseValue);
<span class="udiff-line-modified-removed">-     uint32_t index = subscript.asUInt32();</span>
<span class="udiff-line-modified-added">+     uint32_t index = subscript.asUInt32AsAnyInt();</span>
      if (object-&gt;canGetIndexQuickly(index))
          return JSValue::encode(JSValue(JSValue::JSTrue));
  
<span class="udiff-line-modified-removed">-     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index)) {</span>
<span class="udiff-line-removed">-         // FIXME: This will make us think that in-bounds typed array accesses are actually</span>
<span class="udiff-line-removed">-         // out-of-bounds.</span>
<span class="udiff-line-removed">-         // https://bugs.webkit.org/show_bug.cgi?id=149886</span>
<span class="udiff-line-modified-added">+     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))</span>
          byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">-     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, subscript.asUInt32(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
<span class="udiff-line-modified-added">+     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, index, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValString(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      JSValue result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2081,18 +2123,18 @@</span>
  }
  
  size_t JIT_OPERATION operationDeleteById(ExecState* exec, EncodedJSValue encodedBase, UniquedStringImpl* uid)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);
      RETURN_IF_EXCEPTION(scope, false);
      if (!baseObj)
          return false;
<span class="udiff-line-modified-removed">-     bool couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, Identifier::fromUid(&amp;vm, uid));</span>
<span class="udiff-line-modified-added">+     bool couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, Identifier::fromUid(vm, uid));</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
          throwTypeError(exec, scope, UnableToDeletePropertyError);
      return couldDelete;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2103,11 +2145,11 @@</span>
  }
  
  size_t JIT_OPERATION operationDeleteByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedKey)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);
      RETURN_IF_EXCEPTION(scope, false);
      JSValue key = JSValue::decode(encodedKey);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2130,11 +2172,11 @@</span>
  }
  
  JSCell* JIT_OPERATION operationPushWithScope(ExecState* exec, JSCell* currentScopeCell, EncodedJSValue objectValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* object = JSValue::decode(objectValue).toObject(exec);
      RETURN_IF_EXCEPTION(scope, nullptr);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2144,30 +2186,30 @@</span>
  }
  
  JSCell* JIT_OPERATION operationPushWithScopeObject(ExecState* exec, JSCell* currentScopeCell, JSObject* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
      return JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, object);
  }
  
  EncodedJSValue JIT_OPERATION operationInstanceOf(ExecState* exec, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue value = JSValue::decode(encodedValue);
      JSValue proto = JSValue::decode(encodedProto);
  
      bool result = JSObject::defaultHasInstance(exec, value, proto);
      return JSValue::encode(jsBoolean(result));
  }
  
  EncodedJSValue JIT_OPERATION operationInstanceOfGeneric(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue value = JSValue::decode(encodedValue);
      JSValue proto = JSValue::decode(encodedProto);
  
      stubInfo-&gt;tookSlowPath = true;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2176,60 +2218,60 @@</span>
  }
  
  EncodedJSValue JIT_OPERATION operationInstanceOfOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue value = JSValue::decode(encodedValue);
      JSValue proto = JSValue::decode(encodedProto);
  
      bool result = JSObject::defaultHasInstance(exec, value, proto);
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
<span class="udiff-line-modified-removed">-     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), value.structureOrNull()))</span>
<span class="udiff-line-modified-added">+     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), value.structureOrNull()))</span>
          repatchInstanceOf(exec, value, proto, *stubInfo, result);
  
      return JSValue::encode(jsBoolean(result));
  }
  
  int32_t JIT_OPERATION operationSizeFrameForForwardArguments(ExecState* exec, EncodedJSValue, int32_t numUsedStackSlots, int32_t)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      return sizeFrameForForwardArguments(exec, vm, numUsedStackSlots);
  }
  
  int32_t JIT_OPERATION operationSizeFrameForVarargs(ExecState* exec, EncodedJSValue encodedArguments, int32_t numUsedStackSlots, int32_t firstVarArgOffset)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
      return sizeFrameForVarargs(exec, vm, arguments, numUsedStackSlots, firstVarArgOffset);
  }
  
  CallFrame* JIT_OPERATION operationSetupForwardArgumentsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue, int32_t, int32_t length)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      setupForwardArgumentsFrame(exec, newCallFrame, length);
      return newCallFrame;
  }
  
  CallFrame* JIT_OPERATION operationSetupVarargsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue encodedArguments, int32_t firstVarArgOffset, int32_t length)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
      setupVarargsFrame(exec, newCallFrame, arguments, firstVarArgOffset, length);
      return newCallFrame;
  }
  
  char* JIT_OPERATION operationSwitchCharWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue key = JSValue::decode(encodedKey);
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
      void* result = jumpTable.ctiDefault.executableAddress();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2245,11 +2287,11 @@</span>
  }
  
  char* JIT_OPERATION operationSwitchImmWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue key = JSValue::decode(encodedKey);
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
      void* result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2264,19 +2306,23 @@</span>
  }
  
  char* JIT_OPERATION operationSwitchStringWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue key = JSValue::decode(encodedKey);
      CodeBlock* codeBlock = exec-&gt;codeBlock();
<span class="udiff-line-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
  
      void* result;
      StringJumpTable&amp; jumpTable = codeBlock-&gt;stringSwitchJumpTable(tableIndex);
  
      if (key.isString()) {
          StringImpl* value = asString(key)-&gt;value(exec).impl();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
<span class="udiff-line-added">+ </span>
          result = jumpTable.ctiForValue(value).executableAddress();
      } else
          result = jumpTable.ctiDefault.executableAddress();
  
      assertIsTaggedWith(result, JSSwitchPtrTag);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2284,11 +2330,11 @@</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetFromScope(ExecState* exec, const Instruction* pc)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2325,11 +2371,11 @@</span>
  }
  
  void JIT_OPERATION operationPutToScope(ExecState* exec, const Instruction* pc)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
      auto&amp; metadata = bytecode.metadata(codeBlock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2349,11 +2395,11 @@</span>
              set-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
          return;
      }
  
      bool hasProperty = scope-&gt;hasProperty(exec, ident);
<span class="udiff-line-modified-removed">-     EXCEPTION_ASSERT(!throwScope.exception() || !hasProperty);</span>
<span class="udiff-line-modified-added">+     RETURN_IF_EXCEPTION(throwScope, void());</span>
      if (hasProperty
          &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
          &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
          // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
          PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2377,13 +2423,13 @@</span>
      CommonSlowPaths::tryCachePutToScopeGlobal(exec, codeBlock, bytecode, scope, slot, ident);
  }
  
  void JIT_OPERATION operationThrow(ExecState* exec, EncodedJSValue encodedExceptionValue)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue exceptionValue = JSValue::decode(encodedExceptionValue);
      throwException(exec, scope, exceptionValue);
  
      // Results stored out-of-band in vm.targetMachinePCForThrow &amp; vm.callFrameForCatch
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2391,47 +2437,48 @@</span>
  }
  
  char* JIT_OPERATION operationReallocateButterflyToHavePropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
      Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity);
      object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
      return reinterpret_cast&lt;char*&gt;(result);
  }
  
  char* JIT_OPERATION operationReallocateButterflyToGrowPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize);
      object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
      return reinterpret_cast&lt;char*&gt;(result);
  }
  
  void JIT_OPERATION operationOSRWriteBarrier(ExecState* exec, JSCell* cell)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-     vm-&gt;heap.writeBarrier(cell);</span>
<span class="udiff-line-modified-added">+     vm.heap.writeBarrier(cell);</span>
  }
  
  void JIT_OPERATION operationWriteBarrierSlowPath(ExecState* exec, JSCell* cell)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-     vm-&gt;heap.writeBarrierSlowPath(cell);</span>
<span class="udiff-line-modified-added">+     vm.heap.writeBarrierSlowPath(cell);</span>
  }
  
<span class="udiff-line-modified-removed">- void JIT_OPERATION lookupExceptionHandler(VM* vm, ExecState* exec)</span>
<span class="udiff-line-modified-added">+ void JIT_OPERATION lookupExceptionHandler(VM* vmPointer, ExecState* exec)</span>
  {
<span class="udiff-line-added">+     VM&amp; vm = *vmPointer;</span>
      NativeCallFrameTracer tracer(vm, exec);
      genericUnwind(vm, exec);
<span class="udiff-line-modified-removed">-     ASSERT(vm-&gt;targetMachinePCForThrow);</span>
<span class="udiff-line-modified-added">+     ASSERT(vm.targetMachinePCForThrow);</span>
  }
  
  void JIT_OPERATION lookupExceptionHandlerFromCallerFrame(VM* vm, ExecState* exec)
  {
      ASSERT(exec-&gt;isStackOverflowFrame());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2439,11 +2486,11 @@</span>
      lookupExceptionHandler(vm, exec);
  }
  
  void JIT_OPERATION operationVMHandleException(ExecState* exec)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      genericUnwind(vm, exec);
  }
  
  // This function &quot;should&quot; just take the ExecState*, but doing so would make it more difficult
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2451,34 +2498,34 @@</span>
  // ourselves to play some gnarly ABI tricks just to simplify the calling convention. This is
  // particularly safe here since this is never called on the critical path - it&#39;s only for
  // testing.
  void JIT_OPERATION operationExceptionFuzz(ExecState* exec)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="udiff-line-modified-removed">-     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="udiff-line-modified-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
      UNUSED_PARAM(scope);
  #if COMPILER(GCC_COMPATIBLE)
      void* returnPC = __builtin_return_address(0);
      doExceptionFuzzing(exec, scope, &quot;JITOperations&quot;, returnPC);
  #endif // COMPILER(GCC_COMPATIBLE)
  }
  
  ALWAYS_INLINE static EncodedJSValue unprofiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
      return JSValue::encode(jsAdd(exec, op1, op2));
  }
  
  ALWAYS_INLINE static EncodedJSValue profiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2500,11 +2547,11 @@</span>
      return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);
  }
  
  EncodedJSValue JIT_OPERATION operationValueAddProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2524,21 +2571,21 @@</span>
      return JSValue::encode(result);
  }
  
  EncodedJSValue JIT_OPERATION operationValueAddProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      ArithProfile* arithProfile = addIC-&gt;arithProfile();
      ASSERT(arithProfile);
      return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);
  }
  
  EncodedJSValue JIT_OPERATION operationValueAddOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2554,11 +2601,11 @@</span>
      return JSValue::encode(jsAdd(exec, op1, op2));
  }
  
  EncodedJSValue JIT_OPERATION operationValueAddNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC*)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2591,27 +2638,27 @@</span>
      return JSValue::encode(result);
  }
  
  EncodedJSValue JIT_OPERATION operationValueMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return unprofiledMul(exec, encodedOp1, encodedOp2);
  }
  
  EncodedJSValue JIT_OPERATION operationValueMulNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC*)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return unprofiledMul(exec, encodedOp1, encodedOp2);
  }
  
  EncodedJSValue JIT_OPERATION operationValueMulOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      auto nonOptimizeVariant = operationValueMulNoOptimize;
      if (ArithProfile* arithProfile = mulIC-&gt;arithProfile())
          arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2624,20 +2671,20 @@</span>
      return unprofiledMul(exec, encodedOp1, encodedOp2);
  }
  
  EncodedJSValue JIT_OPERATION operationValueMulProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      ASSERT(arithProfile);
      return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);
  }
  
  EncodedJSValue JIT_OPERATION operationValueMulProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      ArithProfile* arithProfile = mulIC-&gt;arithProfile();
      ASSERT(arithProfile);
      arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2651,11 +2698,11 @@</span>
      return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile, false);
  }
  
  EncodedJSValue JIT_OPERATION operationValueMulProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      ArithProfile* arithProfile = mulIC-&gt;arithProfile();
      ASSERT(arithProfile);
      return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2663,11 +2710,11 @@</span>
  
  ALWAYS_INLINE static EncodedJSValue unprofiledNegate(ExecState* exec, EncodedJSValue encodedOperand)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue operand = JSValue::decode(encodedOperand);
  
      JSValue primValue = operand.toPrimitive(exec, PreferNumber);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2682,11 +2729,11 @@</span>
  
  ALWAYS_INLINE static EncodedJSValue profiledNegate(ExecState* exec, EncodedJSValue encodedOperand, ArithProfile&amp; arithProfile)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue operand = JSValue::decode(encodedOperand);
      arithProfile.observeLHS(operand);
  
      JSValue primValue = operand.toPrimitive(exec);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2719,11 +2766,11 @@</span>
  
  EncodedJSValue JIT_OPERATION operationArithNegateProfiledOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue operand = JSValue::decode(encodedOperand);
  
      ArithProfile* arithProfile = negIC-&gt;arithProfile();
      ASSERT(arithProfile);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2752,11 +2799,11 @@</span>
  
  EncodedJSValue JIT_OPERATION operationArithNegateOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue operand = JSValue::decode(encodedOperand);
  
      if (ArithProfile* arithProfile = negIC-&gt;arithProfile())
          arithProfile-&gt;observeLHS(operand);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2801,28 +2848,28 @@</span>
      return JSValue::encode(result);
  }
  
  EncodedJSValue JIT_OPERATION operationValueSub(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      return unprofiledSub(exec, encodedOp1, encodedOp2);
  }
  
  EncodedJSValue JIT_OPERATION operationValueSubProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
  {
      ASSERT(arithProfile);
  
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
<span class="udiff-line-modified-removed">-     return profiledSub(*vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
<span class="udiff-line-modified-added">+     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueSubOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      auto nonOptimizeVariant = operationValueSubNoOptimize;
      if (ArithProfile* arithProfile = subIC-&gt;arithProfile())
          arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2835,19 +2882,19 @@</span>
      return unprofiledSub(exec, encodedOp1, encodedOp2);
  }
  
  EncodedJSValue JIT_OPERATION operationValueSubNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC*)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return unprofiledSub(exec, encodedOp1, encodedOp2);
  }
  
  EncodedJSValue JIT_OPERATION operationValueSubProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      ArithProfile* arithProfile = subIC-&gt;arithProfile();
      ASSERT(arithProfile);
      arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2856,47 +2903,47 @@</span>
  
  #if ENABLE(MATH_IC_STATS)
      exec-&gt;codeBlock()-&gt;dumpMathICStats();
  #endif
  
<span class="udiff-line-modified-removed">-     return profiledSub(*vm, exec, encodedOp1, encodedOp2, *arithProfile, false);</span>
<span class="udiff-line-modified-added">+     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile, false);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueSubProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
  {
<span class="udiff-line-modified-removed">-     VM* vm = &amp;exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      ArithProfile* arithProfile = subIC-&gt;arithProfile();
      ASSERT(arithProfile);
<span class="udiff-line-modified-removed">-     return profiledSub(*vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
<span class="udiff-line-modified-added">+     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
  }
  
  void JIT_OPERATION operationProcessTypeProfilerLog(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside baseline JIT&quot;_s);
  }
  
  void JIT_OPERATION operationProcessShadowChickenLog(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      RELEASE_ASSERT(vm.shadowChicken());
      vm.shadowChicken()-&gt;update(vm, exec);
  }
  
  int32_t JIT_OPERATION operationCheckIfExceptionIsUncatchableAndNotifyProfiler(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      RELEASE_ASSERT(!!scope.exception());
  
      if (isTerminatedExecutionException(vm, scope.exception())) {
<span class="udiff-line-modified-removed">-         genericUnwind(&amp;vm, exec);</span>
<span class="udiff-line-modified-added">+         genericUnwind(vm, exec);</span>
          return 1;
      }
      return 0;
  }
  
</pre>
<center><a href="JITOpcodes32_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>