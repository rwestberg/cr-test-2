<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTableColElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLTableCellElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTableColElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTableColElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 44 using namespace HTMLNames;
 45 
 46 inline HTMLTableColElement::HTMLTableColElement(const QualifiedName&amp; tagName, Document&amp; document)
 47     : HTMLTablePartElement(tagName, document)
 48     , m_span(1)
 49 {
 50 }
 51 
 52 Ref&lt;HTMLTableColElement&gt; HTMLTableColElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 53 {
 54     return adoptRef(*new HTMLTableColElement(tagName, document));
 55 }
 56 
 57 bool HTMLTableColElement::isPresentationAttribute(const QualifiedName&amp; name) const
 58 {
 59     if (name == widthAttr)
 60         return true;
 61     return HTMLTablePartElement::isPresentationAttribute(name);
 62 }
 63 
<span class="line-modified"> 64 void HTMLTableColElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
 65 {
 66     if (name == widthAttr)
 67         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
 68     else
 69         HTMLTablePartElement::collectStyleForPresentationAttribute(name, value, style);
 70 }
 71 
<span class="line-modified"> 72 void HTMLTableColElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 73 {
 74     if (name == spanAttr) {
 75         m_span = clampHTMLNonNegativeIntegerToRange(value, minSpan, maxSpan, defaultSpan);
 76         if (is&lt;RenderTableCol&gt;(renderer()))
 77             downcast&lt;RenderTableCol&gt;(*renderer()).updateFromElement();
 78     } else if (name == widthAttr) {
 79         if (!value.isEmpty()) {
 80             if (is&lt;RenderTableCol&gt;(renderer())) {
 81                 RenderTableCol&amp; col = downcast&lt;RenderTableCol&gt;(*renderer());
 82                 int newWidth = width().toInt();
 83                 if (newWidth != col.width())
 84                     col.setNeedsLayoutAndPrefWidthsRecalc();
 85             }
 86         }
 87     } else
 88         HTMLTablePartElement::parseAttribute(name, value);
 89 }
 90 
 91 const StyleProperties* HTMLTableColElement::additionalPresentationAttributeStyle() const
 92 {
</pre>
</td>
<td>
<hr />
<pre>
 44 using namespace HTMLNames;
 45 
 46 inline HTMLTableColElement::HTMLTableColElement(const QualifiedName&amp; tagName, Document&amp; document)
 47     : HTMLTablePartElement(tagName, document)
 48     , m_span(1)
 49 {
 50 }
 51 
 52 Ref&lt;HTMLTableColElement&gt; HTMLTableColElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 53 {
 54     return adoptRef(*new HTMLTableColElement(tagName, document));
 55 }
 56 
 57 bool HTMLTableColElement::isPresentationAttribute(const QualifiedName&amp; name) const
 58 {
 59     if (name == widthAttr)
 60         return true;
 61     return HTMLTablePartElement::isPresentationAttribute(name);
 62 }
 63 
<span class="line-modified"> 64 void HTMLTableColElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 65 {
 66     if (name == widthAttr)
 67         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
 68     else
 69         HTMLTablePartElement::collectStyleForPresentationAttribute(name, value, style);
 70 }
 71 
<span class="line-modified"> 72 void HTMLTableColElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
 73 {
 74     if (name == spanAttr) {
 75         m_span = clampHTMLNonNegativeIntegerToRange(value, minSpan, maxSpan, defaultSpan);
 76         if (is&lt;RenderTableCol&gt;(renderer()))
 77             downcast&lt;RenderTableCol&gt;(*renderer()).updateFromElement();
 78     } else if (name == widthAttr) {
 79         if (!value.isEmpty()) {
 80             if (is&lt;RenderTableCol&gt;(renderer())) {
 81                 RenderTableCol&amp; col = downcast&lt;RenderTableCol&gt;(*renderer());
 82                 int newWidth = width().toInt();
 83                 if (newWidth != col.width())
 84                     col.setNeedsLayoutAndPrefWidthsRecalc();
 85             }
 86         }
 87     } else
 88         HTMLTablePartElement::parseAttribute(name, value);
 89 }
 90 
 91 const StyleProperties* HTMLTableColElement::additionalPresentationAttributeStyle() const
 92 {
</pre>
</td>
</tr>
</table>
<center><a href="HTMLTableCellElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTableColElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>