<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Intel Corporation. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 571         break;
 572     case DirectTailCallInlinedCaller:
 573         callType = CallLinkInfo::DirectCall;
 574         isEmulatedTail = true;
 575         isDirect = true;
 576         break;
 577     default:
 578         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 579         break;
 580     }
 581 
 582     Edge calleeEdge = m_jit.graph().child(node, 0);
 583     GPRReg calleeTagGPR = InvalidGPRReg;
 584     GPRReg calleePayloadGPR = InvalidGPRReg;
 585     CallFrameShuffleData shuffleData;
 586 
 587     ExecutableBase* executable = nullptr;
 588     FunctionExecutable* functionExecutable = nullptr;
 589     if (isDirect) {
 590         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
<span class="line-modified"> 591         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(*m_jit.vm(), executable);</span>
 592     }
 593 
 594     unsigned numPassedArgs = 0;
 595     unsigned numAllocatedArgs = 0;
 596 
 597     // Gotta load the arguments somehow. Varargs is trickier.
 598     if (isVarargs || isForwardVarargs) {
 599         RELEASE_ASSERT(!isDirect);
 600         CallVarargsData* data = node-&gt;callVarargsData();
 601 
 602         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 603 
 604         if (isForwardVarargs) {
 605             flushRegisters();
 606             if (node-&gt;child3())
 607                 use(node-&gt;child3());
 608 
 609             GPRReg scratchGPR1;
 610             GPRReg scratchGPR2;
 611             GPRReg scratchGPR3;
 612 
 613             scratchGPR1 = JITCompiler::selectScratchGPR();
 614             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 615             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 616 
 617             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 618             JITCompiler::JumpList slowCase;
 619             InlineCallFrame* inlineCallFrame;
 620             if (node-&gt;child3())
<span class="line-modified"> 621                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame;</span>
 622             else
<span class="line-modified"> 623                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;</span>
 624             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
<span class="line-modified"> 625             emitSetupVarargsFrameFastCase(*m_jit.vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);</span>
 626             JITCompiler::Jump done = m_jit.jump();
 627             slowCase.link(&amp;m_jit);
 628             callOperation(operationThrowStackOverflowForVarargs);
 629             m_jit.exceptionCheck();
 630             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 631             done.link(&amp;m_jit);
 632         } else {
 633             GPRReg argumentsPayloadGPR;
 634             GPRReg argumentsTagGPR;
 635             GPRReg scratchGPR1;
 636             GPRReg scratchGPR2;
 637             GPRReg scratchGPR3;
 638 
 639             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 640                 if (reservedGPR != InvalidGPRReg)
 641                     lock(reservedGPR);
 642                 JSValueOperand arguments(this, node-&gt;child3());
 643                 argumentsTagGPR = arguments.tagGPR();
 644                 argumentsPayloadGPR = arguments.payloadGPR();
 645                 if (reservedGPR != InvalidGPRReg)
</pre>
<hr />
<pre>
 751                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 752         }
 753     }
 754 
 755     if (!isTail || isVarargs || isForwardVarargs) {
 756         JSValueOperand callee(this, calleeEdge);
 757         calleeTagGPR = callee.tagGPR();
 758         calleePayloadGPR = callee.payloadGPR();
 759         use(calleeEdge);
 760         m_jit.store32(calleePayloadGPR, m_jit.calleeFramePayloadSlot(CallFrameSlot::callee));
 761         m_jit.store32(calleeTagGPR, m_jit.calleeFrameTagSlot(CallFrameSlot::callee));
 762 
 763         if (!isTail)
 764             flushRegisters();
 765     }
 766 
 767     JITCompiler::DataLabelPtr targetToCheck;
 768     JITCompiler::JumpList slowPath;
 769 
 770     CodeOrigin staticOrigin = node-&gt;origin.semantic;
<span class="line-modified"> 771     ASSERT(!isTail || !staticOrigin.inlineCallFrame || !staticOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls());</span>
<span class="line-modified"> 772     ASSERT(!isEmulatedTail || (staticOrigin.inlineCallFrame &amp;&amp; staticOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls()));</span>

 773     CodeOrigin dynamicOrigin =
<span class="line-modified"> 774         isEmulatedTail ? *staticOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls() : staticOrigin;</span>
 775     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(dynamicOrigin, m_stream-&gt;size());
 776 
 777     CallLinkInfo* info = m_jit.codeBlock()-&gt;addCallLinkInfo();
 778     info-&gt;setUpCall(callType, node-&gt;origin.semantic, calleePayloadGPR);
 779 
 780     auto setResultAndResetStack = [&amp;] () {
 781         JSValueRegsFlushedCallResult result(this);
 782         JSValueRegs resultRegs = result.regs();
 783 
 784         m_jit.setupResults(resultRegs);
 785 
 786         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 787         // After the calls are done, we need to reestablish our stack
 788         // pointer. We rely on this for varargs calls, calls with arity
 789         // mismatch (the callframe is slided) and tail calls.
 790         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 791     };
 792 
 793     if (node-&gt;op() == CallEval) {
 794         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
</pre>
<hr />
<pre>
 799         m_jit.emitStoreCallSiteIndex(callSite);
 800         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 801         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 802 
 803         // Now we need to make room for:
 804         // - The caller frame and PC of a call to operationCallEval.
 805         // - Potentially two arguments on the stack.
 806         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;
 807         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 808         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 809         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);
 810         prepareForExternalCall();
 811         m_jit.appendCall(operationCallEval);
 812         m_jit.exceptionCheck();
 813         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR2);
 814 
 815         // This is the part where we meant to make a normal call. Oops.
 816         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 817         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(PayloadOffset), GPRInfo::regT0);
 818         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(TagOffset), GPRInfo::regT1);
<span class="line-modified"> 819         m_jit.emitDumbVirtualCall(*m_jit.vm(), info);</span>
 820 
 821         done.link(&amp;m_jit);
 822         setResultAndResetStack();
 823         return;
 824     }
 825 
 826     if (isDirect) {
 827         info-&gt;setExecutableDuringCompilation(executable);
 828         info-&gt;setMaxNumArguments(numAllocatedArgs);
 829 
 830         if (isTail) {
 831             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 832 
 833             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 834             JITCompiler::Label mainPath = m_jit.label();
 835 
 836             m_jit.emitStoreCallSiteIndex(callSite);
 837 
 838             info-&gt;setFrameShuffleData(shuffleData);
 839             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
</pre>
<hr />
<pre>
1552         m_jit.move(TrustedImm32(0), resultPayload.gpr());
1553         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1554         m_jit.move(TrustedImm32(1), resultPayload.gpr());
1555         nonZero.link(&amp;m_jit);
1556         booleanResult(resultPayload.gpr(), node);
1557         return;
1558     }
1559 
1560     case UntypedUse: {
1561         JSValueOperand arg1(this, node-&gt;child1());
1562         GPRTemporary result(this);
1563         GPRTemporary temp(this);
1564         FPRTemporary valueFPR(this);
1565         FPRTemporary tempFPR(this);
1566 
1567         GPRReg resultGPR = result.gpr();
1568 
1569         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1570         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1571         bool negateResult = true;
<span class="line-modified">1572         m_jit.emitConvertValueToBoolean(*m_jit.vm(), arg1.jsValueRegs(), resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);</span>
1573         booleanResult(resultGPR, node);
1574         return;
1575     }
1576     case StringUse:
1577         return compileStringZeroLength(node);
1578 
1579     case StringOrOtherUse:
1580         return compileLogicalNotStringOrOther(node);
1581 
1582     default:
1583         RELEASE_ASSERT_NOT_REACHED();
1584         break;
1585     }
1586 }
1587 
1588 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1589 {
1590     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1591     GPRTemporary scratch(this);
1592     GPRReg valueTagGPR = value.tagGPR();
</pre>
<hr />
<pre>
1697         jump(notTaken);
1698 
1699         noResult(node);
1700         return;
1701     }
1702 
1703     case UntypedUse: {
1704         JSValueOperand value(this, node-&gt;child1());
1705         FPRTemporary valueFPR(this);
1706         FPRTemporary tempFPR(this);
1707         GPRTemporary result(this);
1708         GPRTemporary temp(this);
1709 
1710         JSValueRegs valueRegs = value.jsValueRegs();
1711         GPRReg resultGPR = result.gpr();
1712 
1713         use(node-&gt;child1());
1714 
1715         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1716         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
<span class="line-modified">1717         auto falsey = m_jit.branchIfFalsey(*m_jit.vm(), valueRegs, resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject);</span>
1718         addBranch(falsey, notTaken);
1719         jump(taken, ForceJump);
1720 
1721         noResult(node, UseChildrenCalledExplicitly);
1722         return;
1723     }
1724 
1725     default:
1726         RELEASE_ASSERT_NOT_REACHED();
1727         break;
1728     }
1729 }
1730 
1731 template&lt;typename BaseOperandType, typename PropertyOperandType, typename ValueOperandType, typename TagType&gt;
1732 void SpeculativeJIT::compileContiguousPutByVal(Node* node, BaseOperandType&amp; base, PropertyOperandType&amp; property, ValueOperandType&amp; value, GPRReg valuePayloadReg, TagType valueTag)
1733 {
1734     Edge child4 = m_jit.graph().varArgChild(node, 3);
1735 
1736     ArrayMode arrayMode = node-&gt;arrayMode();
1737 
</pre>
<hr />
<pre>
1767 
1768         m_jit.add32(TrustedImm32(1), propertyReg);
1769         m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1770         m_jit.sub32(TrustedImm32(1), propertyReg);
1771 
1772         inBounds.link(&amp;m_jit);
1773     }
1774 
1775     m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1776     m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1777 
1778     base.use();
1779     property.use();
1780     value.use();
1781     storage.use();
1782 
1783     if (arrayMode.isOutOfBounds()) {
1784         if (node-&gt;op() == PutByValDirect) {
1785             addSlowPathGenerator(slowPathCall(
1786                 slowCase, this,
<span class="line-modified">1787                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,</span>
1788                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1789         } else {
1790             addSlowPathGenerator(slowPathCall(
1791                 slowCase, this,
<span class="line-modified">1792                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,</span>
1793                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1794         }
1795     }
1796 
1797     noResult(node, UseChildrenCalledExplicitly);
1798 }
1799 
1800 void SpeculativeJIT::compile(Node* node)
1801 {
1802     NodeType op = node-&gt;op();
1803 
1804 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1805     m_jit.clearRegisterAllocationOffsets();
1806 #endif
1807 
1808     switch (op) {
1809     case JSConstant:
1810     case DoubleConstant:
1811     case PhantomDirectArguments:
1812     case PhantomClonedArguments:
</pre>
<hr />
<pre>
1954             recordSetLocal(DataFormatBoolean);
1955             break;
1956         }
1957 
1958         case FlushedJSValue: {
1959             JSValueOperand value(this, node-&gt;child1());
1960             m_jit.store32(value.payloadGPR(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1961             m_jit.store32(value.tagGPR(), JITCompiler::tagFor(node-&gt;machineLocal()));
1962             noResult(node);
1963             recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1964             break;
1965         }
1966 
1967         default:
1968             RELEASE_ASSERT_NOT_REACHED();
1969             break;
1970         }
1971         break;
1972     }
1973 
<span class="line-modified">1974     case SetArgument:</span>

1975         // This is a no-op; it just marks the fact that the argument is being used.
1976         // But it may be profitable to use this as a hook to run speculation checks
1977         // on arguments, thereby allowing us to trivially eliminate such checks if
1978         // the argument is not used.
1979         recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1980         break;
1981 
1982     case ValueBitOr:
1983     case ValueBitAnd:
1984     case ValueBitXor:
1985         compileValueBitwiseOp(node);
1986         break;
1987 
1988     case ArithBitAnd:
1989     case ArithBitOr:
1990     case ArithBitXor:
1991         compileBitwiseOp(node);
1992         break;
1993 




1994     case ArithBitNot:
1995         compileBitwiseNot(node);
1996         break;
1997 




1998     case BitRShift:
<span class="line-modified">1999     case BitLShift:</span>
2000     case BitURShift:
2001         compileShiftOp(node);
2002         break;
2003 
2004     case UInt32ToNumber: {
2005         compileUInt32ToNumber(node);
2006         break;
2007     }
2008 
2009     case DoubleAsInt32: {
2010         compileDoubleAsInt32(node);
2011         break;
2012     }
2013 
2014     case ValueToInt32: {
2015         compileValueToInt32(node);
2016         break;
2017     }
2018 
2019     case DoubleRep: {
</pre>
<hr />
<pre>
2064         break;
2065 
2066     case ArithMul:
2067         compileArithMul(node);
2068         break;
2069 
2070     case ValueMul:
2071         compileValueMul(node);
2072         break;
2073 
2074     case ValueDiv: {
2075         compileValueDiv(node);
2076         break;
2077     }
2078 
2079     case ArithDiv: {
2080         compileArithDiv(node);
2081         break;
2082     }
2083 





2084     case ArithMod: {
2085         compileArithMod(node);
2086         break;
2087     }
2088 





2089     case ArithPow: {
2090         compileArithPow(node);
2091         break;
2092     }
2093 
2094     case ArithAbs:
2095         compileArithAbs(node);
2096         break;
2097 
2098     case ArithMin:
2099     case ArithMax: {
2100         compileArithMinMax(node);
2101         break;
2102     }
2103 
2104     case ArithSqrt:
2105         compileArithSqrt(node);
2106         break;
2107 
2108     case ArithFRound:
</pre>
<hr />
<pre>
2532                     alreadyHandled = true;
2533                     break;
2534                 }
2535 
2536                 if (child2.useKind() == SymbolUse) {
2537                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2538                     alreadyHandled = true;
2539                     break;
2540                 }
2541             }
2542 
2543             SpeculateCellOperand base(this, child1); // Save a register, speculate cell. We&#39;ll probably be right.
2544             JSValueOperand property(this, child2);
2545             JSValueOperand value(this, child3);
2546             GPRReg baseGPR = base.gpr();
2547             JSValueRegs propertyRegs = property.jsValueRegs();
2548             JSValueRegs valueRegs = value.jsValueRegs();
2549 
2550             flushRegisters();
2551             if (node-&gt;op() == PutByValDirect)
<span class="line-modified">2552                 callOperation(m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2553             else
<span class="line-modified">2554                 callOperation(m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValCellStrict : operationPutByValCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2555             m_jit.exceptionCheck();
2556 
2557             noResult(node);
2558             alreadyHandled = true;
2559             break;
2560         }
2561         default:
2562             break;
2563         }
2564 
2565         if (alreadyHandled)
2566             break;
2567 
2568         SpeculateCellOperand base(this, child1);
2569         SpeculateStrictInt32Operand property(this, child2);
2570 
2571         GPRReg baseReg = base.gpr();
2572         GPRReg propertyReg = property.gpr();
2573 
2574         switch (arrayMode.type()) {
</pre>
<hr />
<pre>
2645                     m_jit.sub32(TrustedImm32(1), propertyReg);
2646 
2647                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2648                 }
2649                 notHoleValue.link(&amp;m_jit);
2650             }
2651 
2652             // Store the value to the array.
2653             m_jit.store32(valueTagReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2654             m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2655 
2656             base.use();
2657             property.use();
2658             value.use();
2659             storage.use();
2660 
2661             if (!slowCases.empty()) {
2662                 if (node-&gt;op() == PutByValDirect) {
2663                     addSlowPathGenerator(slowPathCall(
2664                         slowCases, this,
<span class="line-modified">2665                         m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,</span>
2666                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2667                 } else {
2668                     addSlowPathGenerator(slowPathCall(
2669                         slowCases, this,
<span class="line-modified">2670                         m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,</span>
2671                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2672                 }
2673             }
2674 
2675             noResult(node, UseChildrenCalledExplicitly);
2676             break;
2677         }
2678 
2679         default: {
2680             TypedArrayType type = arrayMode.typedArrayType();
2681             if (isInt(type))
2682                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2683             else
2684                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2685         } }
2686         break;
2687     }
2688 
2689     case PutByValWithThis: {
2690 #if CPU(X86)
</pre>
<hr />
<pre>
3866         GPRReg tempGPR = temp.gpr();
3867         GPRReg hashGPR = hash.gpr();
3868         GPRReg structureIDGPR = structureID.gpr();
3869         GPRReg resultGPR = result.gpr();
3870 
3871         speculateObject(node-&gt;child1());
3872 
3873         MacroAssembler::JumpList slowPath;
3874         switch (node-&gt;child2().useKind()) {
3875         case SymbolUse: {
3876             speculateSymbol(node-&gt;child2(), keyRegs.payloadGPR());
3877             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3878             break;
3879         }
3880         case StringUse: {
3881             speculateString(node-&gt;child2(), keyRegs.payloadGPR());
3882             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3883             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3884             slowPath.append(m_jit.branchTest32(
3885                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<span class="line-modified">3886                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtomic())));</span>
3887             break;
3888         }
3889         case UntypedUse: {
3890             slowPath.append(m_jit.branchIfNotCell(keyRegs));
3891             auto isNotString = m_jit.branchIfNotString(keyRegs.payloadGPR());
3892             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3893             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3894             slowPath.append(m_jit.branchTest32(
3895                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<span class="line-modified">3896                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtomic())));</span>
3897             auto hasUniquedImpl = m_jit.jump();
3898 
3899             isNotString.link(&amp;m_jit);
3900             slowPath.append(m_jit.branchIfNotSymbol(keyRegs.payloadGPR()));
3901             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3902 
3903             hasUniquedImpl.link(&amp;m_jit);
3904             break;
3905         }
3906         default:
3907             RELEASE_ASSERT_NOT_REACHED();
3908         }
3909 
<span class="line-modified">3910         // Note that we don&#39;t test if the hash is zero here. AtomicStringImpl&#39;s can&#39;t have a zero</span>
3911         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
3912         // ever load the result from the cache if the cache entry matches what we are querying for.
3913         // So we either get super lucky and use zero for the hash and somehow collide with the entity
3914         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
3915         // slow path anyways.
3916         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
3917         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
3918         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
3919         m_jit.add32(structureIDGPR, hashGPR);
3920         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
3921         m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
<span class="line-modified">3922         ASSERT(m_jit.vm()-&gt;hasOwnPropertyCache());</span>
<span class="line-modified">3923         m_jit.move(TrustedImmPtr(m_jit.vm()-&gt;hasOwnPropertyCache()), tempGPR);</span>
3924         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
3925             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
3926         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
3927         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
3928         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
3929         auto done = m_jit.jump();
3930 
3931         slowPath.link(&amp;m_jit);
3932         silentSpillAllRegisters(resultGPR);
3933         if (node-&gt;child2().useKind() != UntypedUse) {
3934             m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), tempGPR);
3935             keyRegs = JSValueRegs(tempGPR, keyRegs.payloadGPR());
3936         }
3937         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);
3938         silentFillAllRegisters();
3939         m_jit.exceptionCheck();
3940 
3941         done.link(&amp;m_jit);
3942         booleanResult(resultGPR, node);
3943 #endif // CPU(X86)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Intel Corporation. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 571         break;
 572     case DirectTailCallInlinedCaller:
 573         callType = CallLinkInfo::DirectCall;
 574         isEmulatedTail = true;
 575         isDirect = true;
 576         break;
 577     default:
 578         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 579         break;
 580     }
 581 
 582     Edge calleeEdge = m_jit.graph().child(node, 0);
 583     GPRReg calleeTagGPR = InvalidGPRReg;
 584     GPRReg calleePayloadGPR = InvalidGPRReg;
 585     CallFrameShuffleData shuffleData;
 586 
 587     ExecutableBase* executable = nullptr;
 588     FunctionExecutable* functionExecutable = nullptr;
 589     if (isDirect) {
 590         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
<span class="line-modified"> 591         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);</span>
 592     }
 593 
 594     unsigned numPassedArgs = 0;
 595     unsigned numAllocatedArgs = 0;
 596 
 597     // Gotta load the arguments somehow. Varargs is trickier.
 598     if (isVarargs || isForwardVarargs) {
 599         RELEASE_ASSERT(!isDirect);
 600         CallVarargsData* data = node-&gt;callVarargsData();
 601 
 602         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 603 
 604         if (isForwardVarargs) {
 605             flushRegisters();
 606             if (node-&gt;child3())
 607                 use(node-&gt;child3());
 608 
 609             GPRReg scratchGPR1;
 610             GPRReg scratchGPR2;
 611             GPRReg scratchGPR3;
 612 
 613             scratchGPR1 = JITCompiler::selectScratchGPR();
 614             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 615             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 616 
 617             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 618             JITCompiler::JumpList slowCase;
 619             InlineCallFrame* inlineCallFrame;
 620             if (node-&gt;child3())
<span class="line-modified"> 621                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();</span>
 622             else
<span class="line-modified"> 623                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
 624             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
<span class="line-modified"> 625             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);</span>
 626             JITCompiler::Jump done = m_jit.jump();
 627             slowCase.link(&amp;m_jit);
 628             callOperation(operationThrowStackOverflowForVarargs);
 629             m_jit.exceptionCheck();
 630             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 631             done.link(&amp;m_jit);
 632         } else {
 633             GPRReg argumentsPayloadGPR;
 634             GPRReg argumentsTagGPR;
 635             GPRReg scratchGPR1;
 636             GPRReg scratchGPR2;
 637             GPRReg scratchGPR3;
 638 
 639             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 640                 if (reservedGPR != InvalidGPRReg)
 641                     lock(reservedGPR);
 642                 JSValueOperand arguments(this, node-&gt;child3());
 643                 argumentsTagGPR = arguments.tagGPR();
 644                 argumentsPayloadGPR = arguments.payloadGPR();
 645                 if (reservedGPR != InvalidGPRReg)
</pre>
<hr />
<pre>
 751                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 752         }
 753     }
 754 
 755     if (!isTail || isVarargs || isForwardVarargs) {
 756         JSValueOperand callee(this, calleeEdge);
 757         calleeTagGPR = callee.tagGPR();
 758         calleePayloadGPR = callee.payloadGPR();
 759         use(calleeEdge);
 760         m_jit.store32(calleePayloadGPR, m_jit.calleeFramePayloadSlot(CallFrameSlot::callee));
 761         m_jit.store32(calleeTagGPR, m_jit.calleeFrameTagSlot(CallFrameSlot::callee));
 762 
 763         if (!isTail)
 764             flushRegisters();
 765     }
 766 
 767     JITCompiler::DataLabelPtr targetToCheck;
 768     JITCompiler::JumpList slowPath;
 769 
 770     CodeOrigin staticOrigin = node-&gt;origin.semantic;
<span class="line-modified"> 771     InlineCallFrame* staticInlineCallFrame = staticOrigin.inlineCallFrame();</span>
<span class="line-modified"> 772     ASSERT(!isTail || !staticInlineCallFrame || !staticInlineCallFrame-&gt;getCallerSkippingTailCalls());</span>
<span class="line-added"> 773     ASSERT(!isEmulatedTail || (staticInlineCallFrame &amp;&amp; staticInlineCallFrame-&gt;getCallerSkippingTailCalls()));</span>
 774     CodeOrigin dynamicOrigin =
<span class="line-modified"> 775         isEmulatedTail ? *staticInlineCallFrame-&gt;getCallerSkippingTailCalls() : staticOrigin;</span>
 776     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(dynamicOrigin, m_stream-&gt;size());
 777 
 778     CallLinkInfo* info = m_jit.codeBlock()-&gt;addCallLinkInfo();
 779     info-&gt;setUpCall(callType, node-&gt;origin.semantic, calleePayloadGPR);
 780 
 781     auto setResultAndResetStack = [&amp;] () {
 782         JSValueRegsFlushedCallResult result(this);
 783         JSValueRegs resultRegs = result.regs();
 784 
 785         m_jit.setupResults(resultRegs);
 786 
 787         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 788         // After the calls are done, we need to reestablish our stack
 789         // pointer. We rely on this for varargs calls, calls with arity
 790         // mismatch (the callframe is slided) and tail calls.
 791         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 792     };
 793 
 794     if (node-&gt;op() == CallEval) {
 795         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
</pre>
<hr />
<pre>
 800         m_jit.emitStoreCallSiteIndex(callSite);
 801         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 802         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 803 
 804         // Now we need to make room for:
 805         // - The caller frame and PC of a call to operationCallEval.
 806         // - Potentially two arguments on the stack.
 807         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;
 808         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 809         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 810         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);
 811         prepareForExternalCall();
 812         m_jit.appendCall(operationCallEval);
 813         m_jit.exceptionCheck();
 814         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR2);
 815 
 816         // This is the part where we meant to make a normal call. Oops.
 817         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 818         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(PayloadOffset), GPRInfo::regT0);
 819         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(TagOffset), GPRInfo::regT1);
<span class="line-modified"> 820         m_jit.emitDumbVirtualCall(vm(), info);</span>
 821 
 822         done.link(&amp;m_jit);
 823         setResultAndResetStack();
 824         return;
 825     }
 826 
 827     if (isDirect) {
 828         info-&gt;setExecutableDuringCompilation(executable);
 829         info-&gt;setMaxNumArguments(numAllocatedArgs);
 830 
 831         if (isTail) {
 832             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 833 
 834             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 835             JITCompiler::Label mainPath = m_jit.label();
 836 
 837             m_jit.emitStoreCallSiteIndex(callSite);
 838 
 839             info-&gt;setFrameShuffleData(shuffleData);
 840             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
</pre>
<hr />
<pre>
1553         m_jit.move(TrustedImm32(0), resultPayload.gpr());
1554         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1555         m_jit.move(TrustedImm32(1), resultPayload.gpr());
1556         nonZero.link(&amp;m_jit);
1557         booleanResult(resultPayload.gpr(), node);
1558         return;
1559     }
1560 
1561     case UntypedUse: {
1562         JSValueOperand arg1(this, node-&gt;child1());
1563         GPRTemporary result(this);
1564         GPRTemporary temp(this);
1565         FPRTemporary valueFPR(this);
1566         FPRTemporary tempFPR(this);
1567 
1568         GPRReg resultGPR = result.gpr();
1569 
1570         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1571         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1572         bool negateResult = true;
<span class="line-modified">1573         m_jit.emitConvertValueToBoolean(vm(), arg1.jsValueRegs(), resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);</span>
1574         booleanResult(resultGPR, node);
1575         return;
1576     }
1577     case StringUse:
1578         return compileStringZeroLength(node);
1579 
1580     case StringOrOtherUse:
1581         return compileLogicalNotStringOrOther(node);
1582 
1583     default:
1584         RELEASE_ASSERT_NOT_REACHED();
1585         break;
1586     }
1587 }
1588 
1589 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1590 {
1591     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1592     GPRTemporary scratch(this);
1593     GPRReg valueTagGPR = value.tagGPR();
</pre>
<hr />
<pre>
1698         jump(notTaken);
1699 
1700         noResult(node);
1701         return;
1702     }
1703 
1704     case UntypedUse: {
1705         JSValueOperand value(this, node-&gt;child1());
1706         FPRTemporary valueFPR(this);
1707         FPRTemporary tempFPR(this);
1708         GPRTemporary result(this);
1709         GPRTemporary temp(this);
1710 
1711         JSValueRegs valueRegs = value.jsValueRegs();
1712         GPRReg resultGPR = result.gpr();
1713 
1714         use(node-&gt;child1());
1715 
1716         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1717         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
<span class="line-modified">1718         auto falsey = m_jit.branchIfFalsey(vm(), valueRegs, resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject);</span>
1719         addBranch(falsey, notTaken);
1720         jump(taken, ForceJump);
1721 
1722         noResult(node, UseChildrenCalledExplicitly);
1723         return;
1724     }
1725 
1726     default:
1727         RELEASE_ASSERT_NOT_REACHED();
1728         break;
1729     }
1730 }
1731 
1732 template&lt;typename BaseOperandType, typename PropertyOperandType, typename ValueOperandType, typename TagType&gt;
1733 void SpeculativeJIT::compileContiguousPutByVal(Node* node, BaseOperandType&amp; base, PropertyOperandType&amp; property, ValueOperandType&amp; value, GPRReg valuePayloadReg, TagType valueTag)
1734 {
1735     Edge child4 = m_jit.graph().varArgChild(node, 3);
1736 
1737     ArrayMode arrayMode = node-&gt;arrayMode();
1738 
</pre>
<hr />
<pre>
1768 
1769         m_jit.add32(TrustedImm32(1), propertyReg);
1770         m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1771         m_jit.sub32(TrustedImm32(1), propertyReg);
1772 
1773         inBounds.link(&amp;m_jit);
1774     }
1775 
1776     m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1777     m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1778 
1779     base.use();
1780     property.use();
1781     value.use();
1782     storage.use();
1783 
1784     if (arrayMode.isOutOfBounds()) {
1785         if (node-&gt;op() == PutByValDirect) {
1786             addSlowPathGenerator(slowPathCall(
1787                 slowCase, this,
<span class="line-modified">1788                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,</span>
1789                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1790         } else {
1791             addSlowPathGenerator(slowPathCall(
1792                 slowCase, this,
<span class="line-modified">1793                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,</span>
1794                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1795         }
1796     }
1797 
1798     noResult(node, UseChildrenCalledExplicitly);
1799 }
1800 
1801 void SpeculativeJIT::compile(Node* node)
1802 {
1803     NodeType op = node-&gt;op();
1804 
1805 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1806     m_jit.clearRegisterAllocationOffsets();
1807 #endif
1808 
1809     switch (op) {
1810     case JSConstant:
1811     case DoubleConstant:
1812     case PhantomDirectArguments:
1813     case PhantomClonedArguments:
</pre>
<hr />
<pre>
1955             recordSetLocal(DataFormatBoolean);
1956             break;
1957         }
1958 
1959         case FlushedJSValue: {
1960             JSValueOperand value(this, node-&gt;child1());
1961             m_jit.store32(value.payloadGPR(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1962             m_jit.store32(value.tagGPR(), JITCompiler::tagFor(node-&gt;machineLocal()));
1963             noResult(node);
1964             recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1965             break;
1966         }
1967 
1968         default:
1969             RELEASE_ASSERT_NOT_REACHED();
1970             break;
1971         }
1972         break;
1973     }
1974 
<span class="line-modified">1975     case SetArgumentDefinitely:</span>
<span class="line-added">1976     case SetArgumentMaybe:</span>
1977         // This is a no-op; it just marks the fact that the argument is being used.
1978         // But it may be profitable to use this as a hook to run speculation checks
1979         // on arguments, thereby allowing us to trivially eliminate such checks if
1980         // the argument is not used.
1981         recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1982         break;
1983 
1984     case ValueBitOr:
1985     case ValueBitAnd:
1986     case ValueBitXor:
1987         compileValueBitwiseOp(node);
1988         break;
1989 
1990     case ArithBitAnd:
1991     case ArithBitOr:
1992     case ArithBitXor:
1993         compileBitwiseOp(node);
1994         break;
1995 
<span class="line-added">1996     case ValueBitNot:</span>
<span class="line-added">1997         compileValueBitNot(node);</span>
<span class="line-added">1998         break;</span>
<span class="line-added">1999 </span>
2000     case ArithBitNot:
2001         compileBitwiseNot(node);
2002         break;
2003 
<span class="line-added">2004     case ValueBitLShift:</span>
<span class="line-added">2005         compileValueLShiftOp(node);</span>
<span class="line-added">2006         break;</span>
<span class="line-added">2007 </span>
2008     case BitRShift:
<span class="line-modified">2009     case ArithBitLShift:</span>
2010     case BitURShift:
2011         compileShiftOp(node);
2012         break;
2013 
2014     case UInt32ToNumber: {
2015         compileUInt32ToNumber(node);
2016         break;
2017     }
2018 
2019     case DoubleAsInt32: {
2020         compileDoubleAsInt32(node);
2021         break;
2022     }
2023 
2024     case ValueToInt32: {
2025         compileValueToInt32(node);
2026         break;
2027     }
2028 
2029     case DoubleRep: {
</pre>
<hr />
<pre>
2074         break;
2075 
2076     case ArithMul:
2077         compileArithMul(node);
2078         break;
2079 
2080     case ValueMul:
2081         compileValueMul(node);
2082         break;
2083 
2084     case ValueDiv: {
2085         compileValueDiv(node);
2086         break;
2087     }
2088 
2089     case ArithDiv: {
2090         compileArithDiv(node);
2091         break;
2092     }
2093 
<span class="line-added">2094     case ValueMod: {</span>
<span class="line-added">2095         compileValueMod(node);</span>
<span class="line-added">2096         break;</span>
<span class="line-added">2097     }</span>
<span class="line-added">2098 </span>
2099     case ArithMod: {
2100         compileArithMod(node);
2101         break;
2102     }
2103 
<span class="line-added">2104     case ValuePow: {</span>
<span class="line-added">2105         compileValuePow(node);</span>
<span class="line-added">2106         break;</span>
<span class="line-added">2107     }</span>
<span class="line-added">2108 </span>
2109     case ArithPow: {
2110         compileArithPow(node);
2111         break;
2112     }
2113 
2114     case ArithAbs:
2115         compileArithAbs(node);
2116         break;
2117 
2118     case ArithMin:
2119     case ArithMax: {
2120         compileArithMinMax(node);
2121         break;
2122     }
2123 
2124     case ArithSqrt:
2125         compileArithSqrt(node);
2126         break;
2127 
2128     case ArithFRound:
</pre>
<hr />
<pre>
2552                     alreadyHandled = true;
2553                     break;
2554                 }
2555 
2556                 if (child2.useKind() == SymbolUse) {
2557                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2558                     alreadyHandled = true;
2559                     break;
2560                 }
2561             }
2562 
2563             SpeculateCellOperand base(this, child1); // Save a register, speculate cell. We&#39;ll probably be right.
2564             JSValueOperand property(this, child2);
2565             JSValueOperand value(this, child3);
2566             GPRReg baseGPR = base.gpr();
2567             JSValueRegs propertyRegs = property.jsValueRegs();
2568             JSValueRegs valueRegs = value.jsValueRegs();
2569 
2570             flushRegisters();
2571             if (node-&gt;op() == PutByValDirect)
<span class="line-modified">2572                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2573             else
<span class="line-modified">2574                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2575             m_jit.exceptionCheck();
2576 
2577             noResult(node);
2578             alreadyHandled = true;
2579             break;
2580         }
2581         default:
2582             break;
2583         }
2584 
2585         if (alreadyHandled)
2586             break;
2587 
2588         SpeculateCellOperand base(this, child1);
2589         SpeculateStrictInt32Operand property(this, child2);
2590 
2591         GPRReg baseReg = base.gpr();
2592         GPRReg propertyReg = property.gpr();
2593 
2594         switch (arrayMode.type()) {
</pre>
<hr />
<pre>
2665                     m_jit.sub32(TrustedImm32(1), propertyReg);
2666 
2667                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2668                 }
2669                 notHoleValue.link(&amp;m_jit);
2670             }
2671 
2672             // Store the value to the array.
2673             m_jit.store32(valueTagReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2674             m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2675 
2676             base.use();
2677             property.use();
2678             value.use();
2679             storage.use();
2680 
2681             if (!slowCases.empty()) {
2682                 if (node-&gt;op() == PutByValDirect) {
2683                     addSlowPathGenerator(slowPathCall(
2684                         slowCases, this,
<span class="line-modified">2685                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,</span>
2686                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2687                 } else {
2688                     addSlowPathGenerator(slowPathCall(
2689                         slowCases, this,
<span class="line-modified">2690                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,</span>
2691                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2692                 }
2693             }
2694 
2695             noResult(node, UseChildrenCalledExplicitly);
2696             break;
2697         }
2698 
2699         default: {
2700             TypedArrayType type = arrayMode.typedArrayType();
2701             if (isInt(type))
2702                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2703             else
2704                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2705         } }
2706         break;
2707     }
2708 
2709     case PutByValWithThis: {
2710 #if CPU(X86)
</pre>
<hr />
<pre>
3886         GPRReg tempGPR = temp.gpr();
3887         GPRReg hashGPR = hash.gpr();
3888         GPRReg structureIDGPR = structureID.gpr();
3889         GPRReg resultGPR = result.gpr();
3890 
3891         speculateObject(node-&gt;child1());
3892 
3893         MacroAssembler::JumpList slowPath;
3894         switch (node-&gt;child2().useKind()) {
3895         case SymbolUse: {
3896             speculateSymbol(node-&gt;child2(), keyRegs.payloadGPR());
3897             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3898             break;
3899         }
3900         case StringUse: {
3901             speculateString(node-&gt;child2(), keyRegs.payloadGPR());
3902             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3903             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3904             slowPath.append(m_jit.branchTest32(
3905                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<span class="line-modified">3906                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
3907             break;
3908         }
3909         case UntypedUse: {
3910             slowPath.append(m_jit.branchIfNotCell(keyRegs));
3911             auto isNotString = m_jit.branchIfNotString(keyRegs.payloadGPR());
3912             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3913             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3914             slowPath.append(m_jit.branchTest32(
3915                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<span class="line-modified">3916                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
3917             auto hasUniquedImpl = m_jit.jump();
3918 
3919             isNotString.link(&amp;m_jit);
3920             slowPath.append(m_jit.branchIfNotSymbol(keyRegs.payloadGPR()));
3921             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3922 
3923             hasUniquedImpl.link(&amp;m_jit);
3924             break;
3925         }
3926         default:
3927             RELEASE_ASSERT_NOT_REACHED();
3928         }
3929 
<span class="line-modified">3930         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero</span>
3931         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
3932         // ever load the result from the cache if the cache entry matches what we are querying for.
3933         // So we either get super lucky and use zero for the hash and somehow collide with the entity
3934         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
3935         // slow path anyways.
3936         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
3937         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
3938         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
3939         m_jit.add32(structureIDGPR, hashGPR);
3940         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
3941         m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
<span class="line-modified">3942         ASSERT(vm().hasOwnPropertyCache());</span>
<span class="line-modified">3943         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);</span>
3944         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
3945             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
3946         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
3947         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
3948         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
3949         auto done = m_jit.jump();
3950 
3951         slowPath.link(&amp;m_jit);
3952         silentSpillAllRegisters(resultGPR);
3953         if (node-&gt;child2().useKind() != UntypedUse) {
3954             m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), tempGPR);
3955             keyRegs = JSValueRegs(tempGPR, keyRegs.payloadGPR());
3956         }
3957         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);
3958         silentFillAllRegisters();
3959         m_jit.exceptionCheck();
3960 
3961         done.link(&amp;m_jit);
3962         booleanResult(resultGPR, node);
3963 #endif // CPU(X86)
</pre>
</td>
</tr>
</table>
<center><a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>