<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorStyleSheet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorOverlay.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstrumentingAgents.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorStyleSheet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  29 #include &quot;CSSKeyframesRule.h&quot;
  30 #include &quot;CSSMediaRule.h&quot;
  31 #include &quot;CSSParser.h&quot;
  32 #include &quot;CSSParserObserver.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CSSPropertyParser.h&quot;
  35 #include &quot;CSSPropertySourceData.h&quot;
  36 #include &quot;CSSRule.h&quot;
  37 #include &quot;CSSRuleList.h&quot;
  38 #include &quot;CSSStyleRule.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CSSSupportsRule.h&quot;
  41 #include &quot;ContentSecurityPolicy.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;Element.h&quot;
  44 #include &quot;HTMLHeadElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLParserIdioms.h&quot;
  47 #include &quot;HTMLStyleElement.h&quot;
  48 #include &quot;InspectorCSSAgent.h&quot;

  49 #include &quot;InspectorPageAgent.h&quot;
  50 #include &quot;MediaList.h&quot;
  51 #include &quot;Node.h&quot;
  52 #include &quot;SVGElement.h&quot;
  53 #include &quot;SVGStyleElement.h&quot;
  54 #include &quot;StyleProperties.h&quot;
  55 #include &quot;StyleResolver.h&quot;
  56 #include &quot;StyleRule.h&quot;
  57 #include &quot;StyleRuleImport.h&quot;
  58 #include &quot;StyleSheetContents.h&quot;
  59 #include &quot;StyleSheetList.h&quot;
  60 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  61 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  62 #include &lt;wtf/text/StringBuilder.h&gt;
  63 
  64 using JSON::ArrayOf;
  65 using WebCore::RuleSourceDataList;
  66 using WebCore::CSSRuleSourceData;
  67 
  68 class ParsedStyleSheet {
</pre>
<hr />
<pre>
  99 
 100 static void flattenSourceData(RuleSourceDataList&amp; dataList, RuleSourceDataList&amp; target)
 101 {
 102     for (auto&amp; data : dataList) {
 103         if (data-&gt;type == WebCore::StyleRule::Style)
 104             target.append(data.copyRef());
 105         else if (data-&gt;type == WebCore::StyleRule::Media)
 106             flattenSourceData(data-&gt;childRules, target);
 107         else if (data-&gt;type == WebCore::StyleRule::Supports)
 108             flattenSourceData(data-&gt;childRules, target);
 109     }
 110 }
 111 
 112 void ParsedStyleSheet::setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt; sourceData)
 113 {
 114     if (!sourceData) {
 115         m_sourceData.reset();
 116         return;
 117     }
 118 
<span class="line-modified"> 119     m_sourceData = std::make_unique&lt;RuleSourceDataList&gt;();</span>
 120 
 121     // FIXME: This is a temporary solution to retain the original flat sourceData structure
 122     // containing only style rules, even though CSSParser now provides the full rule source data tree.
 123     // Normally, we should just assign m_sourceData = sourceData;
 124     flattenSourceData(*sourceData, *m_sourceData);
 125 }
 126 
 127 WebCore::CSSRuleSourceData* ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
 128 {
 129     if (!hasSourceData() || index &gt;= m_sourceData-&gt;size())
 130         return nullptr;
 131 
 132     return m_sourceData-&gt;at(index).ptr();
 133 }
 134 
 135 
 136 namespace WebCore {
 137 
 138 using namespace Inspector;
 139 
</pre>
<hr />
<pre>
 361 
 362     // FIXME: Use the actual rule type rather than STYLE_RULE?
 363     RuleSourceDataList sourceData;
 364 
 365     StyleSheetHandler handler(commentText, m_document, &amp;sourceData);
 366     CSSParser::parseDeclarationForInspector(parserContextForDocument(m_document), commentText, handler);
 367     Vector&lt;CSSPropertySourceData&gt;&amp; commentPropertyData = sourceData.first()-&gt;styleSourceData-&gt;propertyData;
 368     if (commentPropertyData.size() != 1)
 369         return;
 370     CSSPropertySourceData&amp; propertyData = commentPropertyData.at(0);
 371     bool parsedOk = propertyData.parsedOk || propertyData.name.startsWith(&quot;-moz-&quot;) || propertyData.name.startsWith(&quot;-o-&quot;) || propertyData.name.startsWith(&quot;-webkit-&quot;) || propertyData.name.startsWith(&quot;-ms-&quot;);
 372     if (!parsedOk || propertyData.range.length() != commentText.length())
 373         return;
 374 
 375     // FIXME-NEWPARSER: The property range is relative to the declaration start offset, but no
 376     // good reason for it, and it complicates fixUnparsedProperties.
 377     SourceRange&amp; topRuleBodyRange = m_currentRuleDataStack.last()-&gt;ruleBodyRange;
 378     m_currentRuleDataStack.last()-&gt;styleSourceData-&gt;propertyData.append(CSSPropertySourceData(propertyData.name, propertyData.value, false, true, true, SourceRange(startOffset - topRuleBodyRange.start, endOffset - topRuleBodyRange.start)));
 379 }
 380 
<span class="line-removed"> 381 enum MediaListSource {</span>
<span class="line-removed"> 382     MediaListSourceLinkedSheet,</span>
<span class="line-removed"> 383     MediaListSourceInlineSheet,</span>
<span class="line-removed"> 384     MediaListSourceMediaRule,</span>
<span class="line-removed"> 385     MediaListSourceImportRule</span>
<span class="line-removed"> 386 };</span>
<span class="line-removed"> 387 </span>
 388 static RefPtr&lt;Inspector::Protocol::CSS::SourceRange&gt; buildSourceRangeObject(const SourceRange&amp; range, const Vector&lt;size_t&gt;&amp; lineEndings, int* endingLine = nullptr)
 389 {
 390     if (lineEndings.isEmpty())
 391         return nullptr;
 392 
 393     TextPosition start = ContentSearchUtilities::textPositionFromOffset(range.start, lineEndings);
 394     TextPosition end = ContentSearchUtilities::textPositionFromOffset(range.end, lineEndings);
 395 
 396     if (endingLine)
 397         *endingLine = end.m_line.zeroBasedInt();
 398 
 399     return Inspector::Protocol::CSS::SourceRange::create()
 400         .setStartLine(start.m_line.zeroBasedInt())
 401         .setStartColumn(start.m_column.zeroBasedInt())
 402         .setEndLine(end.m_line.zeroBasedInt())
 403         .setEndColumn(end.m_column.zeroBasedInt())
 404         .release();
 405 }
 406 
<span class="line-removed"> 407 static Ref&lt;Inspector::Protocol::CSS::CSSMedia&gt; buildMediaObject(const MediaList* media, MediaListSource mediaListSource, const String&amp; sourceURL)</span>
<span class="line-removed"> 408 {</span>
<span class="line-removed"> 409     // Make certain compilers happy by initializing |source| up-front.</span>
<span class="line-removed"> 410     Inspector::Protocol::CSS::CSSMedia::Source source = Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;</span>
<span class="line-removed"> 411     switch (mediaListSource) {</span>
<span class="line-removed"> 412     case MediaListSourceMediaRule:</span>
<span class="line-removed"> 413         source = Inspector::Protocol::CSS::CSSMedia::Source::MediaRule;</span>
<span class="line-removed"> 414         break;</span>
<span class="line-removed"> 415     case MediaListSourceImportRule:</span>
<span class="line-removed"> 416         source = Inspector::Protocol::CSS::CSSMedia::Source::ImportRule;</span>
<span class="line-removed"> 417         break;</span>
<span class="line-removed"> 418     case MediaListSourceLinkedSheet:</span>
<span class="line-removed"> 419         source = Inspector::Protocol::CSS::CSSMedia::Source::LinkedSheet;</span>
<span class="line-removed"> 420         break;</span>
<span class="line-removed"> 421     case MediaListSourceInlineSheet:</span>
<span class="line-removed"> 422         source = Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;</span>
<span class="line-removed"> 423         break;</span>
<span class="line-removed"> 424     }</span>
<span class="line-removed"> 425 </span>
<span class="line-removed"> 426     auto mediaObject = Inspector::Protocol::CSS::CSSMedia::create()</span>
<span class="line-removed"> 427         .setText(media-&gt;mediaText())</span>
<span class="line-removed"> 428         .setSource(source)</span>
<span class="line-removed"> 429         .release();</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431     if (!sourceURL.isEmpty()) {</span>
<span class="line-removed"> 432         mediaObject-&gt;setSourceURL(sourceURL);</span>
<span class="line-removed"> 433         mediaObject-&gt;setSourceLine(media-&gt;queries()-&gt;lastLine());</span>
<span class="line-removed"> 434     }</span>
<span class="line-removed"> 435     return mediaObject;</span>
<span class="line-removed"> 436 }</span>
<span class="line-removed"> 437 </span>
 438 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSStyleSheet* styleSheet)
 439 {
 440     if (!styleSheet)
 441         return nullptr;
 442 
 443     auto list = StaticCSSRuleList::create();
 444     Vector&lt;RefPtr&lt;CSSRule&gt;&gt;&amp; listRules = list-&gt;rules();
 445     for (unsigned i = 0, size = styleSheet-&gt;length(); i &lt; size; ++i)
 446         listRules.append(styleSheet-&gt;item(i));
<span class="line-modified"> 447     return WTFMove(list);</span>
 448 }
 449 
 450 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSRule* rule)
 451 {
 452     if (!rule)
 453         return nullptr;
 454 
 455     if (is&lt;CSSMediaRule&gt;(*rule))
 456         return &amp;downcast&lt;CSSMediaRule&gt;(*rule).cssRules();
 457 
 458     if (is&lt;CSSKeyframesRule&gt;(*rule))
 459         return &amp;downcast&lt;CSSKeyframesRule&gt;(*rule).cssRules();
 460 
 461     if (is&lt;CSSSupportsRule&gt;(*rule))
 462         return &amp;downcast&lt;CSSSupportsRule&gt;(*rule).cssRules();
 463 
 464     return nullptr;
 465 }
 466 
<span class="line-modified"> 467 static void fillMediaListChain(CSSRule* rule, JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSMedia&gt;&amp; mediaArray)</span>
 468 {
<span class="line-modified"> 469     MediaList* mediaList;</span>
<span class="line-modified"> 470     CSSRule* parentRule = rule;</span>
<span class="line-modified"> 471     String sourceURL;</span>
 472     while (parentRule) {
<span class="line-modified"> 473         CSSStyleSheet* parentStyleSheet = nullptr;</span>
<span class="line-modified"> 474         bool isMediaRule = true;</span>
<span class="line-modified"> 475         if (is&lt;CSSMediaRule&gt;(*parentRule)) {</span>
<span class="line-modified"> 476             CSSMediaRule&amp; mediaRule = downcast&lt;CSSMediaRule&gt;(*parentRule);</span>
<span class="line-modified"> 477             mediaList = mediaRule.media();</span>
<span class="line-modified"> 478             parentStyleSheet = mediaRule.parentStyleSheet();</span>
<span class="line-modified"> 479         } else if (is&lt;CSSImportRule&gt;(*parentRule)) {</span>
<span class="line-modified"> 480             CSSImportRule&amp; importRule = downcast&lt;CSSImportRule&gt;(*parentRule);</span>
<span class="line-modified"> 481             mediaList = &amp;importRule.media();</span>
<span class="line-modified"> 482             parentStyleSheet = importRule.parentStyleSheet();</span>
<span class="line-modified"> 483             isMediaRule = false;</span>
<span class="line-modified"> 484         } else</span>
<span class="line-modified"> 485             mediaList = nullptr;</span>
<span class="line-modified"> 486 </span>
<span class="line-modified"> 487         if (parentStyleSheet) {</span>
<span class="line-modified"> 488             sourceURL = parentStyleSheet-&gt;contents().baseURL();</span>
<span class="line-modified"> 489             if (sourceURL.isEmpty())</span>
<span class="line-modified"> 490                 sourceURL = InspectorDOMAgent::documentURLString(parentStyleSheet-&gt;ownerDocument());</span>
<span class="line-modified"> 491         } else</span>
<span class="line-modified"> 492             sourceURL = emptyString();</span>
<span class="line-modified"> 493 </span>
<span class="line-modified"> 494         if (mediaList &amp;&amp; mediaList-&gt;length())</span>
<span class="line-modified"> 495             mediaArray.addItem(buildMediaObject(mediaList, isMediaRule ? MediaListSourceMediaRule : MediaListSourceImportRule, sourceURL));</span>
<span class="line-modified"> 496 </span>
<span class="line-modified"> 497         if (parentRule-&gt;parentRule())</span>
<span class="line-modified"> 498             parentRule = parentRule-&gt;parentRule();</span>
<span class="line-modified"> 499         else {</span>
<span class="line-modified"> 500             CSSStyleSheet* styleSheet = parentRule-&gt;parentStyleSheet();</span>
<span class="line-modified"> 501             while (styleSheet) {</span>
<span class="line-modified"> 502                 mediaList = styleSheet-&gt;media();</span>
<span class="line-modified"> 503                 if (mediaList &amp;&amp; mediaList-&gt;length()) {</span>
<span class="line-removed"> 504                     Document* doc = styleSheet-&gt;ownerDocument();</span>
<span class="line-removed"> 505                     if (doc)</span>
<span class="line-removed"> 506                         sourceURL = doc-&gt;url();</span>
<span class="line-removed"> 507                     else if (!styleSheet-&gt;contents().baseURL().isEmpty())</span>
<span class="line-removed"> 508                         sourceURL = styleSheet-&gt;contents().baseURL();</span>
<span class="line-removed"> 509                     else</span>
<span class="line-removed"> 510                         sourceURL = emptyString();</span>
<span class="line-removed"> 511                     mediaArray.addItem(buildMediaObject(mediaList, styleSheet-&gt;ownerNode() ? MediaListSourceLinkedSheet : MediaListSourceInlineSheet, sourceURL));</span>
 512                 }
<span class="line-modified"> 513                 parentRule = styleSheet-&gt;ownerRule();</span>
<span class="line-modified"> 514                 if (parentRule)</span>
<span class="line-removed"> 515                     break;</span>
<span class="line-removed"> 516                 styleSheet = styleSheet-&gt;parentStyleSheet();</span>
 517             }


































 518         }
 519     }


 520 }
 521 
 522 Ref&lt;InspectorStyle&gt; InspectorStyle::create(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 523 {
 524     return adoptRef(*new InspectorStyle(styleId, WTFMove(style), parentStyleSheet));
 525 }
 526 
 527 InspectorStyle::InspectorStyle(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 528     : m_styleId(styleId)
 529     , m_style(WTFMove(style))
 530     , m_parentStyleSheet(parentStyleSheet)
 531 {
 532 }
 533 
 534 InspectorStyle::~InspectorStyle() = default;
 535 
 536 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::buildObjectForStyle() const
 537 {
 538     Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = styleWithProperties();
 539     if (!m_styleId.isEmpty())
 540         result-&gt;setStyleId(m_styleId.asProtocolValue&lt;Inspector::Protocol::CSS::CSSStyleId&gt;());
 541 
 542     result-&gt;setWidth(m_style-&gt;getPropertyValue(&quot;width&quot;));
 543     result-&gt;setHeight(m_style-&gt;getPropertyValue(&quot;height&quot;));
 544 
 545     RefPtr&lt;CSSRuleSourceData&gt; sourceData = extractSourceData();
 546     if (sourceData)
 547         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleBodyRange, m_parentStyleSheet-&gt;lineEndings()));
 548 
<span class="line-modified"> 549     return WTFMove(result);</span>
 550 }
 551 
 552 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;&gt; InspectorStyle::buildArrayForComputedStyle() const
 553 {
 554     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;::create();
 555     Vector&lt;InspectorStyleProperty&gt; properties;
 556     populateAllProperties(&amp;properties);
 557 
 558     for (auto&amp; property : properties) {
 559         const CSSPropertySourceData&amp; propertyEntry = property.sourceData;
 560         auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
 561             .setName(propertyEntry.name)
 562             .setValue(propertyEntry.value)
 563             .release();
 564         result-&gt;addItem(WTFMove(entry));
 565     }
 566 
 567     return result;
 568 }
 569 
</pre>
<hr />
<pre>
1000     return id.ordinal() &gt;= m_flatRules.size() ? nullptr : m_flatRules.at(id.ordinal()).get();
1001 }
1002 
1003 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetBody&gt; InspectorStyleSheet::buildObjectForStyleSheet()
1004 {
1005     CSSStyleSheet* styleSheet = pageStyleSheet();
1006     if (!styleSheet)
1007         return nullptr;
1008 
1009     RefPtr&lt;CSSRuleList&gt; cssRuleList = asCSSRuleList(styleSheet);
1010 
1011     auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
1012         .setStyleSheetId(id())
1013         .setRules(buildArrayForRuleList(cssRuleList.get()))
1014         .release();
1015 
1016     auto styleSheetText = text();
1017     if (!styleSheetText.hasException())
1018         result-&gt;setText(styleSheetText.releaseReturnValue());
1019 
<span class="line-modified">1020     return WTFMove(result);</span>
1021 }
1022 
1023 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetHeader&gt; InspectorStyleSheet::buildObjectForStyleSheetInfo()
1024 {
1025     CSSStyleSheet* styleSheet = pageStyleSheet();
1026     if (!styleSheet)
1027         return nullptr;
1028 
1029     Document* document = styleSheet-&gt;ownerDocument();
1030     Frame* frame = document ? document-&gt;frame() : nullptr;
1031     return Inspector::Protocol::CSS::CSSStyleSheetHeader::create()
1032         .setStyleSheetId(id())
1033         .setOrigin(m_origin)
1034         .setDisabled(styleSheet-&gt;disabled())
1035         .setSourceURL(finalURL())
1036         .setTitle(styleSheet-&gt;title())
1037         .setFrameId(m_pageAgent-&gt;frameId(frame))
1038         .setIsInline(styleSheet-&gt;isInline() &amp;&amp; styleSheet-&gt;startPosition() != TextPosition())
1039         .setStartLine(styleSheet-&gt;startPosition().m_line.zeroBasedInt())
1040         .setStartColumn(styleSheet-&gt;startPosition().m_column.zeroBasedInt())
</pre>
<hr />
<pre>
1155         return nullptr;
1156 
1157     int endingLine = 0;
1158     auto result = Inspector::Protocol::CSS::CSSRule::create()
1159         .setSelectorList(buildObjectForSelectorList(rule, element, endingLine))
1160         .setSourceLine(endingLine)
1161         .setOrigin(m_origin)
1162         .setStyle(buildObjectForStyle(&amp;rule-&gt;style()))
1163         .release();
1164 
1165     // &quot;sourceURL&quot; is present only for regular rules, otherwise &quot;origin&quot; should be used in the frontend.
1166     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Regular)
1167         result-&gt;setSourceURL(finalURL());
1168 
1169     if (canBind()) {
1170         InspectorCSSId id(ruleId(rule));
1171         if (!id.isEmpty())
1172             result-&gt;setRuleId(id.asProtocolValue&lt;Inspector::Protocol::CSS::CSSRuleId&gt;());
1173     }
1174 
<span class="line-modified">1175     auto mediaArray = ArrayOf&lt;Inspector::Protocol::CSS::CSSMedia&gt;::create();</span>
<span class="line-modified">1176 </span>
<span class="line-modified">1177     fillMediaListChain(rule, mediaArray.get());</span>
<span class="line-removed">1178     if (mediaArray-&gt;length())</span>
<span class="line-removed">1179         result-&gt;setMedia(WTFMove(mediaArray));</span>
1180 
<span class="line-modified">1181     return WTFMove(result);</span>
1182 }
1183 
1184 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
1185 {
1186     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1187     if (ensureParsedDataReady())
1188         sourceData = ruleSourceDataFor(style);
1189 
1190     InspectorCSSId id = ruleOrStyleId(style);
1191     if (id.isEmpty()) {
1192         return Inspector::Protocol::CSS::CSSStyle::create()
1193             .setCssProperties(ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create())
1194             .setShorthandEntries(ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create())
1195             .release();
1196     }
1197     RefPtr&lt;InspectorStyle&gt; inspectorStyle = inspectorStyleForId(id);
1198     RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = inspectorStyle-&gt;buildObjectForStyle();
1199 
1200     // Style text cannot be retrieved without stylesheet, so set cssText here.
1201     if (sourceData) {
</pre>
<hr />
<pre>
1316         return true;
1317 
1318     String text;
1319     bool success = originalStyleSheetText(&amp;text);
1320     if (success)
1321         m_parsedStyleSheet-&gt;setText(text);
1322     // No need to clear m_flatRules here - it&#39;s empty.
1323 
1324     return success;
1325 }
1326 
1327 bool InspectorStyleSheet::ensureSourceData()
1328 {
1329     if (m_parsedStyleSheet-&gt;hasSourceData())
1330         return true;
1331 
1332     if (!m_parsedStyleSheet-&gt;hasText())
1333         return false;
1334 
1335     auto newStyleSheet = StyleSheetContents::create();
<span class="line-modified">1336     auto ruleSourceDataResult = std::make_unique&lt;RuleSourceDataList&gt;();</span>
1337 
1338     CSSParserContext context(parserContextForDocument(m_pageStyleSheet-&gt;ownerDocument()));
1339     StyleSheetHandler handler(m_parsedStyleSheet-&gt;text(), m_pageStyleSheet-&gt;ownerDocument(), ruleSourceDataResult.get());
1340     CSSParser::parseSheetForInspector(context, newStyleSheet.ptr(), m_parsedStyleSheet-&gt;text(), handler);
1341     m_parsedStyleSheet-&gt;setSourceData(WTFMove(ruleSourceDataResult));
1342     return m_parsedStyleSheet-&gt;hasSourceData();
1343 }
1344 
1345 void InspectorStyleSheet::ensureFlatRules() const
1346 {
1347     // We are fine with redoing this for empty stylesheets as this will run fast.
1348     if (m_flatRules.isEmpty())
1349         collectFlatRules(asCSSRuleList(pageStyleSheet()), &amp;m_flatRules);
1350 }
1351 
1352 ExceptionOr&lt;void&gt; InspectorStyleSheet::setStyleText(CSSStyleDeclaration* style, const String&amp; text)
1353 {
1354     if (!m_pageStyleSheet)
1355         return Exception { NotFoundError };
1356     if (!ensureParsedDataReady())
</pre>
</td>
<td>
<hr />
<pre>
  29 #include &quot;CSSKeyframesRule.h&quot;
  30 #include &quot;CSSMediaRule.h&quot;
  31 #include &quot;CSSParser.h&quot;
  32 #include &quot;CSSParserObserver.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CSSPropertyParser.h&quot;
  35 #include &quot;CSSPropertySourceData.h&quot;
  36 #include &quot;CSSRule.h&quot;
  37 #include &quot;CSSRuleList.h&quot;
  38 #include &quot;CSSStyleRule.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CSSSupportsRule.h&quot;
  41 #include &quot;ContentSecurityPolicy.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;Element.h&quot;
  44 #include &quot;HTMLHeadElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLParserIdioms.h&quot;
  47 #include &quot;HTMLStyleElement.h&quot;
  48 #include &quot;InspectorCSSAgent.h&quot;
<span class="line-added">  49 #include &quot;InspectorDOMAgent.h&quot;</span>
  50 #include &quot;InspectorPageAgent.h&quot;
  51 #include &quot;MediaList.h&quot;
  52 #include &quot;Node.h&quot;
  53 #include &quot;SVGElement.h&quot;
  54 #include &quot;SVGStyleElement.h&quot;
  55 #include &quot;StyleProperties.h&quot;
  56 #include &quot;StyleResolver.h&quot;
  57 #include &quot;StyleRule.h&quot;
  58 #include &quot;StyleRuleImport.h&quot;
  59 #include &quot;StyleSheetContents.h&quot;
  60 #include &quot;StyleSheetList.h&quot;
  61 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  62 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  63 #include &lt;wtf/text/StringBuilder.h&gt;
  64 
  65 using JSON::ArrayOf;
  66 using WebCore::RuleSourceDataList;
  67 using WebCore::CSSRuleSourceData;
  68 
  69 class ParsedStyleSheet {
</pre>
<hr />
<pre>
 100 
 101 static void flattenSourceData(RuleSourceDataList&amp; dataList, RuleSourceDataList&amp; target)
 102 {
 103     for (auto&amp; data : dataList) {
 104         if (data-&gt;type == WebCore::StyleRule::Style)
 105             target.append(data.copyRef());
 106         else if (data-&gt;type == WebCore::StyleRule::Media)
 107             flattenSourceData(data-&gt;childRules, target);
 108         else if (data-&gt;type == WebCore::StyleRule::Supports)
 109             flattenSourceData(data-&gt;childRules, target);
 110     }
 111 }
 112 
 113 void ParsedStyleSheet::setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt; sourceData)
 114 {
 115     if (!sourceData) {
 116         m_sourceData.reset();
 117         return;
 118     }
 119 
<span class="line-modified"> 120     m_sourceData = makeUnique&lt;RuleSourceDataList&gt;();</span>
 121 
 122     // FIXME: This is a temporary solution to retain the original flat sourceData structure
 123     // containing only style rules, even though CSSParser now provides the full rule source data tree.
 124     // Normally, we should just assign m_sourceData = sourceData;
 125     flattenSourceData(*sourceData, *m_sourceData);
 126 }
 127 
 128 WebCore::CSSRuleSourceData* ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
 129 {
 130     if (!hasSourceData() || index &gt;= m_sourceData-&gt;size())
 131         return nullptr;
 132 
 133     return m_sourceData-&gt;at(index).ptr();
 134 }
 135 
 136 
 137 namespace WebCore {
 138 
 139 using namespace Inspector;
 140 
</pre>
<hr />
<pre>
 362 
 363     // FIXME: Use the actual rule type rather than STYLE_RULE?
 364     RuleSourceDataList sourceData;
 365 
 366     StyleSheetHandler handler(commentText, m_document, &amp;sourceData);
 367     CSSParser::parseDeclarationForInspector(parserContextForDocument(m_document), commentText, handler);
 368     Vector&lt;CSSPropertySourceData&gt;&amp; commentPropertyData = sourceData.first()-&gt;styleSourceData-&gt;propertyData;
 369     if (commentPropertyData.size() != 1)
 370         return;
 371     CSSPropertySourceData&amp; propertyData = commentPropertyData.at(0);
 372     bool parsedOk = propertyData.parsedOk || propertyData.name.startsWith(&quot;-moz-&quot;) || propertyData.name.startsWith(&quot;-o-&quot;) || propertyData.name.startsWith(&quot;-webkit-&quot;) || propertyData.name.startsWith(&quot;-ms-&quot;);
 373     if (!parsedOk || propertyData.range.length() != commentText.length())
 374         return;
 375 
 376     // FIXME-NEWPARSER: The property range is relative to the declaration start offset, but no
 377     // good reason for it, and it complicates fixUnparsedProperties.
 378     SourceRange&amp; topRuleBodyRange = m_currentRuleDataStack.last()-&gt;ruleBodyRange;
 379     m_currentRuleDataStack.last()-&gt;styleSourceData-&gt;propertyData.append(CSSPropertySourceData(propertyData.name, propertyData.value, false, true, true, SourceRange(startOffset - topRuleBodyRange.start, endOffset - topRuleBodyRange.start)));
 380 }
 381 







 382 static RefPtr&lt;Inspector::Protocol::CSS::SourceRange&gt; buildSourceRangeObject(const SourceRange&amp; range, const Vector&lt;size_t&gt;&amp; lineEndings, int* endingLine = nullptr)
 383 {
 384     if (lineEndings.isEmpty())
 385         return nullptr;
 386 
 387     TextPosition start = ContentSearchUtilities::textPositionFromOffset(range.start, lineEndings);
 388     TextPosition end = ContentSearchUtilities::textPositionFromOffset(range.end, lineEndings);
 389 
 390     if (endingLine)
 391         *endingLine = end.m_line.zeroBasedInt();
 392 
 393     return Inspector::Protocol::CSS::SourceRange::create()
 394         .setStartLine(start.m_line.zeroBasedInt())
 395         .setStartColumn(start.m_column.zeroBasedInt())
 396         .setEndLine(end.m_line.zeroBasedInt())
 397         .setEndColumn(end.m_column.zeroBasedInt())
 398         .release();
 399 }
 400 































 401 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSStyleSheet* styleSheet)
 402 {
 403     if (!styleSheet)
 404         return nullptr;
 405 
 406     auto list = StaticCSSRuleList::create();
 407     Vector&lt;RefPtr&lt;CSSRule&gt;&gt;&amp; listRules = list-&gt;rules();
 408     for (unsigned i = 0, size = styleSheet-&gt;length(); i &lt; size; ++i)
 409         listRules.append(styleSheet-&gt;item(i));
<span class="line-modified"> 410     return list;</span>
 411 }
 412 
 413 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSRule* rule)
 414 {
 415     if (!rule)
 416         return nullptr;
 417 
 418     if (is&lt;CSSMediaRule&gt;(*rule))
 419         return &amp;downcast&lt;CSSMediaRule&gt;(*rule).cssRules();
 420 
 421     if (is&lt;CSSKeyframesRule&gt;(*rule))
 422         return &amp;downcast&lt;CSSKeyframesRule&gt;(*rule).cssRules();
 423 
 424     if (is&lt;CSSSupportsRule&gt;(*rule))
 425         return &amp;downcast&lt;CSSSupportsRule&gt;(*rule).cssRules();
 426 
 427     return nullptr;
 428 }
 429 
<span class="line-modified"> 430 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::Grouping&gt;&gt; buildArrayForGroupings(CSSRule&amp; rule)</span>
 431 {
<span class="line-modified"> 432     auto groupingsPayload = JSON::ArrayOf&lt;Inspector::Protocol::CSS::Grouping&gt;::create();</span>
<span class="line-modified"> 433 </span>
<span class="line-modified"> 434     auto* parentRule = &amp;rule;</span>
 435     while (parentRule) {
<span class="line-modified"> 436         RefPtr&lt;Inspector::Protocol::CSS::Grouping&gt; ruleGroupingPayload;</span>
<span class="line-modified"> 437 </span>
<span class="line-modified"> 438         if (is&lt;CSSMediaRule&gt;(parentRule)) {</span>
<span class="line-modified"> 439             auto* media = downcast&lt;CSSMediaRule&gt;(parentRule)-&gt;media();</span>
<span class="line-modified"> 440             if (media &amp;&amp; media-&gt;length() &amp;&amp; media-&gt;mediaText() != &quot;all&quot;) {</span>
<span class="line-modified"> 441                 ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()</span>
<span class="line-modified"> 442                     .setText(media-&gt;mediaText())</span>
<span class="line-modified"> 443                     .setType(Inspector::Protocol::CSS::Grouping::Type::MediaRule)</span>
<span class="line-modified"> 444                     .release();</span>
<span class="line-modified"> 445             }</span>
<span class="line-modified"> 446         } else if (is&lt;CSSImportRule&gt;(parentRule)) {</span>
<span class="line-modified"> 447             auto&amp; media = downcast&lt;CSSImportRule&gt;(parentRule)-&gt;media();</span>
<span class="line-modified"> 448             if (media.length() &amp;&amp; media.mediaText() != &quot;all&quot;) {</span>
<span class="line-modified"> 449                 ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()</span>
<span class="line-modified"> 450                     .setText(media.mediaText())</span>
<span class="line-modified"> 451                     .setType(Inspector::Protocol::CSS::Grouping::Type::MediaImportRule)</span>
<span class="line-modified"> 452                     .release();</span>
<span class="line-modified"> 453             }</span>
<span class="line-modified"> 454         } else if (is&lt;CSSSupportsRule&gt;(parentRule)) {</span>
<span class="line-modified"> 455             ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()</span>
<span class="line-modified"> 456                 .setText(downcast&lt;CSSSupportsRule&gt;(parentRule)-&gt;conditionText())</span>
<span class="line-modified"> 457                 .setType(Inspector::Protocol::CSS::Grouping::Type::SupportsRule)</span>
<span class="line-modified"> 458                 .release();</span>
<span class="line-modified"> 459         }</span>
<span class="line-modified"> 460 </span>
<span class="line-modified"> 461         if (ruleGroupingPayload) {</span>
<span class="line-modified"> 462             if (auto* parentStyleSheet = parentRule-&gt;parentStyleSheet()) {</span>
<span class="line-modified"> 463                 String sourceURL = parentStyleSheet-&gt;contents().baseURL();</span>
<span class="line-modified"> 464                 if (sourceURL.isEmpty()) {</span>
<span class="line-modified"> 465                     if (auto* ownerDocument = parentStyleSheet-&gt;ownerDocument())</span>
<span class="line-modified"> 466                         sourceURL = InspectorDOMAgent::documentURLString(ownerDocument);</span>








 467                 }
<span class="line-modified"> 468                 if (!sourceURL.isEmpty())</span>
<span class="line-modified"> 469                     ruleGroupingPayload-&gt;setSourceURL(sourceURL);</span>


 470             }
<span class="line-added"> 471 </span>
<span class="line-added"> 472             groupingsPayload-&gt;addItem(WTFMove(ruleGroupingPayload));</span>
<span class="line-added"> 473         }</span>
<span class="line-added"> 474 </span>
<span class="line-added"> 475         if (parentRule-&gt;parentRule()) {</span>
<span class="line-added"> 476             parentRule = parentRule-&gt;parentRule();</span>
<span class="line-added"> 477             continue;</span>
<span class="line-added"> 478         }</span>
<span class="line-added"> 479 </span>
<span class="line-added"> 480         auto* styleSheet = parentRule-&gt;parentStyleSheet();</span>
<span class="line-added"> 481         while (styleSheet) {</span>
<span class="line-added"> 482             auto* media = styleSheet-&gt;media();</span>
<span class="line-added"> 483             if (media &amp;&amp; media-&gt;length() &amp;&amp; media-&gt;mediaText() != &quot;all&quot;) {</span>
<span class="line-added"> 484                 auto sheetGroupingPayload = Inspector::Protocol::CSS::Grouping::create()</span>
<span class="line-added"> 485                     .setText(media-&gt;mediaText())</span>
<span class="line-added"> 486                     .setType(is&lt;HTMLStyleElement&gt;(styleSheet-&gt;ownerNode()) ? Inspector::Protocol::CSS::Grouping::Type::MediaStyleNode: Inspector::Protocol::CSS::Grouping::Type::MediaLinkNode)</span>
<span class="line-added"> 487                     .release();</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489                 String sourceURL;</span>
<span class="line-added"> 490                 if (auto* ownerDocument = styleSheet-&gt;ownerDocument())</span>
<span class="line-added"> 491                     sourceURL = ownerDocument-&gt;url();</span>
<span class="line-added"> 492                 else if (!styleSheet-&gt;contents().baseURL().isEmpty())</span>
<span class="line-added"> 493                     sourceURL = styleSheet-&gt;contents().baseURL();</span>
<span class="line-added"> 494                 if (!sourceURL.isEmpty())</span>
<span class="line-added"> 495                     sheetGroupingPayload-&gt;setSourceURL(sourceURL);</span>
<span class="line-added"> 496 </span>
<span class="line-added"> 497                 groupingsPayload-&gt;addItem(WTFMove(sheetGroupingPayload));</span>
<span class="line-added"> 498             }</span>
<span class="line-added"> 499 </span>
<span class="line-added"> 500             parentRule = styleSheet-&gt;ownerRule();</span>
<span class="line-added"> 501             if (parentRule)</span>
<span class="line-added"> 502                 break;</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504             styleSheet = styleSheet-&gt;parentStyleSheet();</span>
 505         }
 506     }
<span class="line-added"> 507 </span>
<span class="line-added"> 508     return groupingsPayload;</span>
 509 }
 510 
 511 Ref&lt;InspectorStyle&gt; InspectorStyle::create(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 512 {
 513     return adoptRef(*new InspectorStyle(styleId, WTFMove(style), parentStyleSheet));
 514 }
 515 
 516 InspectorStyle::InspectorStyle(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 517     : m_styleId(styleId)
 518     , m_style(WTFMove(style))
 519     , m_parentStyleSheet(parentStyleSheet)
 520 {
 521 }
 522 
 523 InspectorStyle::~InspectorStyle() = default;
 524 
 525 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::buildObjectForStyle() const
 526 {
 527     Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = styleWithProperties();
 528     if (!m_styleId.isEmpty())
 529         result-&gt;setStyleId(m_styleId.asProtocolValue&lt;Inspector::Protocol::CSS::CSSStyleId&gt;());
 530 
 531     result-&gt;setWidth(m_style-&gt;getPropertyValue(&quot;width&quot;));
 532     result-&gt;setHeight(m_style-&gt;getPropertyValue(&quot;height&quot;));
 533 
 534     RefPtr&lt;CSSRuleSourceData&gt; sourceData = extractSourceData();
 535     if (sourceData)
 536         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleBodyRange, m_parentStyleSheet-&gt;lineEndings()));
 537 
<span class="line-modified"> 538     return result;</span>
 539 }
 540 
 541 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;&gt; InspectorStyle::buildArrayForComputedStyle() const
 542 {
 543     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;::create();
 544     Vector&lt;InspectorStyleProperty&gt; properties;
 545     populateAllProperties(&amp;properties);
 546 
 547     for (auto&amp; property : properties) {
 548         const CSSPropertySourceData&amp; propertyEntry = property.sourceData;
 549         auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
 550             .setName(propertyEntry.name)
 551             .setValue(propertyEntry.value)
 552             .release();
 553         result-&gt;addItem(WTFMove(entry));
 554     }
 555 
 556     return result;
 557 }
 558 
</pre>
<hr />
<pre>
 989     return id.ordinal() &gt;= m_flatRules.size() ? nullptr : m_flatRules.at(id.ordinal()).get();
 990 }
 991 
 992 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetBody&gt; InspectorStyleSheet::buildObjectForStyleSheet()
 993 {
 994     CSSStyleSheet* styleSheet = pageStyleSheet();
 995     if (!styleSheet)
 996         return nullptr;
 997 
 998     RefPtr&lt;CSSRuleList&gt; cssRuleList = asCSSRuleList(styleSheet);
 999 
1000     auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
1001         .setStyleSheetId(id())
1002         .setRules(buildArrayForRuleList(cssRuleList.get()))
1003         .release();
1004 
1005     auto styleSheetText = text();
1006     if (!styleSheetText.hasException())
1007         result-&gt;setText(styleSheetText.releaseReturnValue());
1008 
<span class="line-modified">1009     return result;</span>
1010 }
1011 
1012 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetHeader&gt; InspectorStyleSheet::buildObjectForStyleSheetInfo()
1013 {
1014     CSSStyleSheet* styleSheet = pageStyleSheet();
1015     if (!styleSheet)
1016         return nullptr;
1017 
1018     Document* document = styleSheet-&gt;ownerDocument();
1019     Frame* frame = document ? document-&gt;frame() : nullptr;
1020     return Inspector::Protocol::CSS::CSSStyleSheetHeader::create()
1021         .setStyleSheetId(id())
1022         .setOrigin(m_origin)
1023         .setDisabled(styleSheet-&gt;disabled())
1024         .setSourceURL(finalURL())
1025         .setTitle(styleSheet-&gt;title())
1026         .setFrameId(m_pageAgent-&gt;frameId(frame))
1027         .setIsInline(styleSheet-&gt;isInline() &amp;&amp; styleSheet-&gt;startPosition() != TextPosition())
1028         .setStartLine(styleSheet-&gt;startPosition().m_line.zeroBasedInt())
1029         .setStartColumn(styleSheet-&gt;startPosition().m_column.zeroBasedInt())
</pre>
<hr />
<pre>
1144         return nullptr;
1145 
1146     int endingLine = 0;
1147     auto result = Inspector::Protocol::CSS::CSSRule::create()
1148         .setSelectorList(buildObjectForSelectorList(rule, element, endingLine))
1149         .setSourceLine(endingLine)
1150         .setOrigin(m_origin)
1151         .setStyle(buildObjectForStyle(&amp;rule-&gt;style()))
1152         .release();
1153 
1154     // &quot;sourceURL&quot; is present only for regular rules, otherwise &quot;origin&quot; should be used in the frontend.
1155     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Regular)
1156         result-&gt;setSourceURL(finalURL());
1157 
1158     if (canBind()) {
1159         InspectorCSSId id(ruleId(rule));
1160         if (!id.isEmpty())
1161             result-&gt;setRuleId(id.asProtocolValue&lt;Inspector::Protocol::CSS::CSSRuleId&gt;());
1162     }
1163 
<span class="line-modified">1164     auto groupingsPayload = buildArrayForGroupings(*rule);</span>
<span class="line-modified">1165     if (groupingsPayload-&gt;length())</span>
<span class="line-modified">1166         result-&gt;setGroupings(WTFMove(groupingsPayload));</span>


1167 
<span class="line-modified">1168     return result;</span>
1169 }
1170 
1171 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
1172 {
1173     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1174     if (ensureParsedDataReady())
1175         sourceData = ruleSourceDataFor(style);
1176 
1177     InspectorCSSId id = ruleOrStyleId(style);
1178     if (id.isEmpty()) {
1179         return Inspector::Protocol::CSS::CSSStyle::create()
1180             .setCssProperties(ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create())
1181             .setShorthandEntries(ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create())
1182             .release();
1183     }
1184     RefPtr&lt;InspectorStyle&gt; inspectorStyle = inspectorStyleForId(id);
1185     RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = inspectorStyle-&gt;buildObjectForStyle();
1186 
1187     // Style text cannot be retrieved without stylesheet, so set cssText here.
1188     if (sourceData) {
</pre>
<hr />
<pre>
1303         return true;
1304 
1305     String text;
1306     bool success = originalStyleSheetText(&amp;text);
1307     if (success)
1308         m_parsedStyleSheet-&gt;setText(text);
1309     // No need to clear m_flatRules here - it&#39;s empty.
1310 
1311     return success;
1312 }
1313 
1314 bool InspectorStyleSheet::ensureSourceData()
1315 {
1316     if (m_parsedStyleSheet-&gt;hasSourceData())
1317         return true;
1318 
1319     if (!m_parsedStyleSheet-&gt;hasText())
1320         return false;
1321 
1322     auto newStyleSheet = StyleSheetContents::create();
<span class="line-modified">1323     auto ruleSourceDataResult = makeUnique&lt;RuleSourceDataList&gt;();</span>
1324 
1325     CSSParserContext context(parserContextForDocument(m_pageStyleSheet-&gt;ownerDocument()));
1326     StyleSheetHandler handler(m_parsedStyleSheet-&gt;text(), m_pageStyleSheet-&gt;ownerDocument(), ruleSourceDataResult.get());
1327     CSSParser::parseSheetForInspector(context, newStyleSheet.ptr(), m_parsedStyleSheet-&gt;text(), handler);
1328     m_parsedStyleSheet-&gt;setSourceData(WTFMove(ruleSourceDataResult));
1329     return m_parsedStyleSheet-&gt;hasSourceData();
1330 }
1331 
1332 void InspectorStyleSheet::ensureFlatRules() const
1333 {
1334     // We are fine with redoing this for empty stylesheets as this will run fast.
1335     if (m_flatRules.isEmpty())
1336         collectFlatRules(asCSSRuleList(pageStyleSheet()), &amp;m_flatRules);
1337 }
1338 
1339 ExceptionOr&lt;void&gt; InspectorStyleSheet::setStyleText(CSSStyleDeclaration* style, const String&amp; text)
1340 {
1341     if (!m_pageStyleSheet)
1342         return Exception { NotFoundError };
1343     if (!ensureParsedDataReady())
</pre>
</td>
</tr>
</table>
<center><a href="InspectorOverlay.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstrumentingAgents.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>