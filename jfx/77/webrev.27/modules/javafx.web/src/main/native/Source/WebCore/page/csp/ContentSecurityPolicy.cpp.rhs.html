<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/csp/ContentSecurityPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google, Inc. All rights reserved.
  3  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;ContentSecurityPolicy.h&quot;
 29 
 30 #include &quot;ContentSecurityPolicyClient.h&quot;
 31 #include &quot;ContentSecurityPolicyDirective.h&quot;
 32 #include &quot;ContentSecurityPolicyDirectiveList.h&quot;
 33 #include &quot;ContentSecurityPolicyDirectiveNames.h&quot;
 34 #include &quot;ContentSecurityPolicyHash.h&quot;
 35 #include &quot;ContentSecurityPolicySource.h&quot;
 36 #include &quot;ContentSecurityPolicySourceList.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 37 #include &quot;CustomHeaderFields.h&quot;</span>
 38 #include &quot;DOMStringList.h&quot;
 39 #include &quot;Document.h&quot;
 40 #include &quot;DocumentLoader.h&quot;
 41 #include &quot;EventNames.h&quot;
 42 #include &quot;FormData.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;HTMLParserIdioms.h&quot;
 45 #include &quot;InspectorInstrumentation.h&quot;
 46 #include &quot;JSExecState.h&quot;
 47 #include &quot;JSWindowProxy.h&quot;
 48 #include &quot;ParsingUtilities.h&quot;
 49 #include &quot;PingLoader.h&quot;
 50 #include &quot;ResourceRequest.h&quot;
 51 #include &quot;RuntimeEnabledFeatures.h&quot;
 52 #include &quot;SchemeRegistry.h&quot;
 53 #include &quot;SecurityOrigin.h&quot;
 54 #include &quot;SecurityPolicyViolationEvent.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;TextEncoding.h&quot;
 57 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 58 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 59 #include &lt;pal/crypto/CryptoDigest.h&gt;
 60 #include &lt;wtf/JSONValues.h&gt;
 61 #include &lt;wtf/SetForScope.h&gt;
 62 #include &lt;wtf/text/StringBuilder.h&gt;
 63 #include &lt;wtf/text/TextPosition.h&gt;
 64 
 65 
 66 namespace WebCore {
 67 using namespace Inspector;
 68 
 69 static String consoleMessageForViolation(const char* effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const char* prefix, const char* subject = &quot;it&quot;)
 70 {
 71     StringBuilder result;
 72     if (violatedDirective.directiveList().isReportOnly())
 73         result.appendLiteral(&quot;[Report Only] &quot;);
 74     result.append(prefix);
 75     if (!blockedURL.isEmpty()) {
 76         result.append(&#39; &#39;);
 77         result.append(blockedURL.stringCenterEllipsizedToLength());
 78     }
 79     result.appendLiteral(&quot; because &quot;);
 80     result.append(subject);
 81     if (violatedDirective.isDefaultSrc()) {
 82         result.appendLiteral(&quot; appears in neither the &quot;);
 83         result.append(effectiveViolatedDirective);
 84         result.appendLiteral(&quot; directive nor the default-src directive of the Content Security Policy.&quot;);
 85     } else {
 86         result.appendLiteral(&quot; does not appear in the &quot;);
 87         result.append(effectiveViolatedDirective);
 88         result.appendLiteral(&quot; directive of the Content Security Policy.&quot;);
 89     }
 90     return result.toString();
 91 }
 92 
 93 ContentSecurityPolicy::ContentSecurityPolicy(URL&amp;&amp; protectedURL, ContentSecurityPolicyClient* client)
 94     : m_client { client }
 95     , m_protectedURL { WTFMove(protectedURL) }
 96 {
 97     updateSourceSelf(SecurityOrigin::create(m_protectedURL).get());
 98 }
 99 
100 ContentSecurityPolicy::ContentSecurityPolicy(URL&amp;&amp; protectedURL, ScriptExecutionContext&amp; scriptExecutionContext)
101     : m_scriptExecutionContext(&amp;scriptExecutionContext)
102     , m_protectedURL { WTFMove(protectedURL) }
103 {
104     ASSERT(scriptExecutionContext.securityOrigin());
105     updateSourceSelf(*scriptExecutionContext.securityOrigin());
106 }
107 
108 ContentSecurityPolicy::~ContentSecurityPolicy() = default;
109 
110 void ContentSecurityPolicy::copyStateFrom(const ContentSecurityPolicy* other)
111 {
112     if (m_hasAPIPolicy)
113         return;
114     ASSERT(m_policies.isEmpty());
115     for (auto&amp; policy : other-&gt;m_policies)
116         didReceiveHeader(policy-&gt;header(), policy-&gt;headerType(), ContentSecurityPolicy::PolicyFrom::Inherited, String { });
117     m_referrer = other-&gt;m_referrer;
118     m_httpStatusCode = other-&gt;m_httpStatusCode;
119 }
120 
121 void ContentSecurityPolicy::createPolicyForPluginDocumentFrom(const ContentSecurityPolicy&amp; other)
122 {
123     if (m_hasAPIPolicy)
124         return;
125     ASSERT(m_policies.isEmpty());
126     for (auto&amp; policy : other.m_policies)
127         didReceiveHeader(policy-&gt;header(), policy-&gt;headerType(), ContentSecurityPolicy::PolicyFrom::InheritedForPluginDocument, String { });
128     m_referrer = other.m_referrer;
129     m_httpStatusCode = other.m_httpStatusCode;
130 }
131 
132 void ContentSecurityPolicy::copyUpgradeInsecureRequestStateFrom(const ContentSecurityPolicy&amp; other)
133 {
134     m_upgradeInsecureRequests = other.m_upgradeInsecureRequests;
135     m_insecureNavigationRequestsToUpgrade.add(other.m_insecureNavigationRequestsToUpgrade.begin(), other.m_insecureNavigationRequestsToUpgrade.end());
136 }
137 
138 bool ContentSecurityPolicy::allowRunningOrDisplayingInsecureContent(const URL&amp; url)
139 {
140     bool allow = true;
141     bool isReportOnly = false;
142     for (auto&amp; policy : m_policies) {
143         if (!policy-&gt;hasBlockAllMixedContentDirective())
144             continue;
145 
146         isReportOnly = policy-&gt;isReportOnly();
147 
148         StringBuilder consoleMessage;
149         if (isReportOnly)
150             consoleMessage.appendLiteral(&quot;[Report Only] &quot;);
151         consoleMessage.append(&quot;Blocked mixed content &quot;);
152         consoleMessage.append(url.stringCenterEllipsizedToLength());
153         consoleMessage.appendLiteral(&quot; because &quot;);
154         consoleMessage.append(&quot;&#39;block-all-mixed-content&#39; appears in the Content Security Policy.&quot;);
155         reportViolation(ContentSecurityPolicyDirectiveNames::blockAllMixedContent, ContentSecurityPolicyDirectiveNames::blockAllMixedContent, *policy, url, consoleMessage.toString());
156 
157         if (!isReportOnly)
158             allow = false;
159     }
160     return allow;
161 }
162 
163 void ContentSecurityPolicy::didCreateWindowProxy(JSWindowProxy&amp; windowProxy) const
164 {
165     auto* window = windowProxy.window();
166     ASSERT(window);
167     ASSERT(window-&gt;scriptExecutionContext());
168     ASSERT(window-&gt;scriptExecutionContext()-&gt;contentSecurityPolicy() == this);
169     if (!windowProxy.world().isNormal()) {
170         window-&gt;setEvalEnabled(true);
171         return;
172     }
173     window-&gt;setEvalEnabled(m_lastPolicyEvalDisabledErrorMessage.isNull(), m_lastPolicyEvalDisabledErrorMessage);
174     window-&gt;setWebAssemblyEnabled(m_lastPolicyWebAssemblyDisabledErrorMessage.isNull(), m_lastPolicyWebAssemblyDisabledErrorMessage);
175 }
176 
177 ContentSecurityPolicyResponseHeaders ContentSecurityPolicy::responseHeaders() const
178 {
179     if (!m_cachedResponseHeaders) {
180         ContentSecurityPolicyResponseHeaders result;
181         result.m_headers.reserveInitialCapacity(m_policies.size());
182         for (auto&amp; policy : m_policies)
183             result.m_headers.uncheckedAppend({ policy-&gt;header(), policy-&gt;headerType() });
184         result.m_httpStatusCode = m_httpStatusCode;
185         m_cachedResponseHeaders = WTFMove(result);
186     }
187     return *m_cachedResponseHeaders;
188 }
189 
190 void ContentSecurityPolicy::didReceiveHeaders(const ContentSecurityPolicyResponseHeaders&amp; headers, String&amp;&amp; referrer, ReportParsingErrors reportParsingErrors)
191 {
192     SetForScope&lt;bool&gt; isReportingEnabled(m_isReportingEnabled, reportParsingErrors == ReportParsingErrors::Yes);
193     for (auto&amp; header : headers.m_headers)
194         didReceiveHeader(header.first, header.second, ContentSecurityPolicy::PolicyFrom::HTTPHeader, String { });
195     m_referrer = WTFMove(referrer);
196     m_httpStatusCode = headers.m_httpStatusCode;
197 }
198 
199 void ContentSecurityPolicy::didReceiveHeader(const String&amp; header, ContentSecurityPolicyHeaderType type, ContentSecurityPolicy::PolicyFrom policyFrom, String&amp;&amp; referrer, int httpStatusCode)
200 {
201     if (m_hasAPIPolicy)
202         return;
203 
204     m_referrer = WTFMove(referrer);
205     m_httpStatusCode = httpStatusCode;
206 
207     if (policyFrom == PolicyFrom::API) {
208         ASSERT(m_policies.isEmpty());
209         m_hasAPIPolicy = true;
210     }
211 
212     m_cachedResponseHeaders = WTF::nullopt;
213 
214     // RFC2616, section 4.2 specifies that headers appearing multiple times can
215     // be combined with a comma. Walk the header string, and parse each comma
216     // separated chunk as a separate header.
217     auto characters = StringView(header).upconvertedCharacters();
218     const UChar* begin = characters;
219     const UChar* position = begin;
220     const UChar* end = begin + header.length();
221     while (position &lt; end) {
222         skipUntil&lt;UChar&gt;(position, end, &#39;,&#39;);
223 
224         // header1,header2 OR header1
225         //        ^                  ^
226         m_policies.append(ContentSecurityPolicyDirectiveList::create(*this, String(begin, position - begin), type, policyFrom));
227 
228         // Skip the comma, and begin the next header from the current position.
229         ASSERT(position == end || *position == &#39;,&#39;);
230         skipExactly&lt;UChar&gt;(position, end, &#39;,&#39;);
231         begin = position;
232     }
233 
234     if (m_scriptExecutionContext)
235         applyPolicyToScriptExecutionContext();
236 }
237 
238 void ContentSecurityPolicy::updateSourceSelf(const SecurityOrigin&amp; securityOrigin)
239 {
240     m_selfSourceProtocol = securityOrigin.protocol();
<a name="2" id="anc2"></a><span class="line-modified">241     m_selfSource = makeUnique&lt;ContentSecurityPolicySource&gt;(*this, m_selfSourceProtocol, securityOrigin.host(), securityOrigin.port(), emptyString(), false, false);</span>
242 }
243 
244 void ContentSecurityPolicy::applyPolicyToScriptExecutionContext()
245 {
246     ASSERT(m_scriptExecutionContext);
247 
248     // Update source self as the security origin may have changed between the time we were created and now.
249     // For instance, we may have been initially created for an about:blank iframe that later inherited the
250     // security origin of its owner document.
251     ASSERT(m_scriptExecutionContext-&gt;securityOrigin());
252     updateSourceSelf(*m_scriptExecutionContext-&gt;securityOrigin());
253 
254     bool enableStrictMixedContentMode = false;
255     for (auto&amp; policy : m_policies) {
256         const ContentSecurityPolicyDirective* violatedDirective = policy-&gt;violatedDirectiveForUnsafeEval();
257         if (violatedDirective &amp;&amp; !violatedDirective-&gt;directiveList().isReportOnly()) {
258             m_lastPolicyEvalDisabledErrorMessage = policy-&gt;evalDisabledErrorMessage();
259             m_lastPolicyWebAssemblyDisabledErrorMessage = policy-&gt;webAssemblyDisabledErrorMessage();
260         }
261         if (policy-&gt;hasBlockAllMixedContentDirective() &amp;&amp; !policy-&gt;isReportOnly())
262             enableStrictMixedContentMode = true;
263     }
264 
265     if (!m_lastPolicyEvalDisabledErrorMessage.isNull())
266         m_scriptExecutionContext-&gt;disableEval(m_lastPolicyEvalDisabledErrorMessage);
267     if (!m_lastPolicyWebAssemblyDisabledErrorMessage.isNull())
268         m_scriptExecutionContext-&gt;disableWebAssembly(m_lastPolicyWebAssemblyDisabledErrorMessage);
269     if (m_sandboxFlags != SandboxNone &amp;&amp; is&lt;Document&gt;(m_scriptExecutionContext))
270         m_scriptExecutionContext-&gt;enforceSandboxFlags(m_sandboxFlags);
271     if (enableStrictMixedContentMode)
272         m_scriptExecutionContext-&gt;setStrictMixedContentMode(true);
273 }
274 
275 void ContentSecurityPolicy::setOverrideAllowInlineStyle(bool value)
276 {
277     m_overrideInlineStyleAllowed = value;
278 }
279 
280 bool ContentSecurityPolicy::urlMatchesSelf(const URL&amp; url) const
281 {
282     return m_selfSource-&gt;matches(url);
283 }
284 
285 bool ContentSecurityPolicy::allowContentSecurityPolicySourceStarToMatchAnyProtocol() const
286 {
287     if (is&lt;Document&gt;(m_scriptExecutionContext))
288         return downcast&lt;Document&gt;(*m_scriptExecutionContext).settings().allowContentSecurityPolicySourceStarToMatchAnyProtocol();
289     return false;
290 }
291 
292 bool ContentSecurityPolicy::protocolMatchesSelf(const URL&amp; url) const
293 {
294     if (equalLettersIgnoringASCIICase(m_selfSourceProtocol, &quot;http&quot;))
295         return url.protocolIsInHTTPFamily();
296     return equalIgnoringASCIICase(url.protocol(), m_selfSourceProtocol);
297 }
298 
299 template&lt;typename Predicate, typename... Args&gt;
300 typename std::enable_if&lt;!std::is_convertible&lt;Predicate, ContentSecurityPolicy::ViolatedDirectiveCallback&gt;::value, bool&gt;::type ContentSecurityPolicy::allPoliciesWithDispositionAllow(Disposition disposition, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
301 {
302     bool isReportOnly = disposition == ContentSecurityPolicy::Disposition::ReportOnly;
303     for (auto&amp; policy : m_policies) {
304         if (policy-&gt;isReportOnly() != isReportOnly)
305             continue;
306         if ((policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...))
307             return false;
308     }
309     return true;
310 }
311 
312 template&lt;typename Predicate, typename... Args&gt;
313 bool ContentSecurityPolicy::allPoliciesWithDispositionAllow(Disposition disposition, ViolatedDirectiveCallback&amp;&amp; callback, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
314 {
315     bool isReportOnly = disposition == ContentSecurityPolicy::Disposition::ReportOnly;
316     bool isAllowed = true;
317     for (auto&amp; policy : m_policies) {
318         if (policy-&gt;isReportOnly() != isReportOnly)
319             continue;
320         if (const ContentSecurityPolicyDirective* violatedDirective = (policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...)) {
321             isAllowed = false;
322             callback(*violatedDirective);
323         }
324     }
325     return isAllowed;
326 }
327 
328 template&lt;typename Predicate, typename... Args&gt;
329 bool ContentSecurityPolicy::allPoliciesAllow(ViolatedDirectiveCallback&amp;&amp; callback, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
330 {
331     bool isAllowed = true;
332     for (auto&amp; policy : m_policies) {
333         if (const ContentSecurityPolicyDirective* violatedDirective = (policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...)) {
334             if (!violatedDirective-&gt;directiveList().isReportOnly())
335                 isAllowed = false;
336             callback(*violatedDirective);
337         }
338     }
339     return isAllowed;
340 }
341 
342 template&lt;typename Predicate&gt;
343 ContentSecurityPolicy::HashInEnforcedAndReportOnlyPoliciesPair ContentSecurityPolicy::findHashOfContentInPolicies(Predicate&amp;&amp; predicate, const String&amp; content, OptionSet&lt;ContentSecurityPolicyHashAlgorithm&gt; algorithms) const
344 {
345     if (algorithms.isEmpty() || content.isEmpty())
346         return { false, false };
347 
348     // FIXME: We should compute the document encoding once and cache it instead of computing it on each invocation.
349     TextEncoding documentEncoding;
350     if (is&lt;Document&gt;(m_scriptExecutionContext))
351         documentEncoding = downcast&lt;Document&gt;(*m_scriptExecutionContext).textEncoding();
352     const TextEncoding&amp; encodingToUse = documentEncoding.isValid() ? documentEncoding : UTF8Encoding();
353 
354     // FIXME: Compute the digest with respect to the raw bytes received from the page.
355     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=155184&gt;.
356     auto encodedContent = encodingToUse.encode(content, UnencodableHandling::Entities);
357     bool foundHashInEnforcedPolicies = false;
358     bool foundHashInReportOnlyPolicies = false;
359     for (auto algorithm : algorithms) {
360         ContentSecurityPolicyHash hash = cryptographicDigestForBytes(algorithm, encodedContent.data(), encodedContent.size());
361         if (!foundHashInEnforcedPolicies &amp;&amp; allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, std::forward&lt;Predicate&gt;(predicate), hash))
362             foundHashInEnforcedPolicies = true;
363         if (!foundHashInReportOnlyPolicies &amp;&amp; allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, std::forward&lt;Predicate&gt;(predicate), hash))
364             foundHashInReportOnlyPolicies = true;
365         if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
366             break;
367     }
368     return { foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies };
369 }
370 
371 bool ContentSecurityPolicy::allowJavaScriptURLs(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, bool overrideContentSecurityPolicy) const
372 {
373     if (overrideContentSecurityPolicy)
374         return true;
375     bool didNotifyInspector = false;
376     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
377         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
378         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
379         if (!didNotifyInspector &amp;&amp; violatedDirective.directiveList().isReportOnly()) {
380             reportBlockedScriptExecutionToInspector(violatedDirective.text());
381             didNotifyInspector = true;
382         }
383     };
384     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
385 }
386 
387 bool ContentSecurityPolicy::allowInlineEventHandlers(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, bool overrideContentSecurityPolicy) const
388 {
389     if (overrideContentSecurityPolicy)
390         return true;
391     bool didNotifyInspector = false;
392     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
393         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script for an inline event handler&quot;, &quot;&#39;unsafe-inline&#39;&quot;);
394         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
395         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
396             reportBlockedScriptExecutionToInspector(violatedDirective.text());
397             didNotifyInspector = true;
398         }
399     };
400     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
401 }
402 
403 bool ContentSecurityPolicy::allowScriptWithNonce(const String&amp; nonce, bool overrideContentSecurityPolicy) const
404 {
405     if (overrideContentSecurityPolicy)
406         return true;
407     String strippedNonce = stripLeadingAndTrailingHTMLSpaces(nonce);
408     if (strippedNonce.isEmpty())
409         return false;
410     // FIXME: We need to report violations in report-only policies. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159830&gt;.
411     return allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScriptNonce, strippedNonce);
412 }
413 
414 bool ContentSecurityPolicy::allowStyleWithNonce(const String&amp; nonce, bool overrideContentSecurityPolicy) const
415 {
416     if (overrideContentSecurityPolicy)
417         return true;
418     String strippedNonce = stripLeadingAndTrailingHTMLSpaces(nonce);
419     if (strippedNonce.isEmpty())
420         return false;
421     // FIXME: We need to report violations in report-only policies. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159830&gt;.
422     return allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleNonce, strippedNonce);
423 }
424 
425 bool ContentSecurityPolicy::allowInlineScript(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; scriptContent, bool overrideContentSecurityPolicy) const
426 {
427     if (overrideContentSecurityPolicy)
428         return true;
429     bool didNotifyInspector = false;
<a name="3" id="anc3"></a><span class="line-modified">430     auto [foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies] = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScriptHash, scriptContent, m_hashAlgorithmsForInlineScripts);</span>


431     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
432         return true;
433     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
434         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
435         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
436         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
437             reportBlockedScriptExecutionToInspector(violatedDirective.text());
438             didNotifyInspector = true;
439         }
440     };
441     // FIXME: We should not report that the inline script violated a policy when its hash matched a source
442     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
443     if (!foundHashInReportOnlyPolicies)
444         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
445     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
446 }
447 
448 bool ContentSecurityPolicy::allowInlineStyle(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; styleContent, bool overrideContentSecurityPolicy) const
449 {
450     if (overrideContentSecurityPolicy)
451         return true;
452     if (m_overrideInlineStyleAllowed)
453         return true;
<a name="4" id="anc4"></a><span class="line-modified">454     auto [foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies] = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleHash, styleContent, m_hashAlgorithmsForInlineStylesheets);</span>


455     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
456         return true;
457     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
458         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), &quot;Refused to apply a stylesheet&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
459         reportViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
460     };
461     // FIXME: We should not report that the inline stylesheet violated a policy when its hash matched a source
462     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
463     if (!foundHashInReportOnlyPolicies)
464         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
465     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
466 }
467 
468 bool ContentSecurityPolicy::allowEval(JSC::ExecState* state, bool overrideContentSecurityPolicy) const
469 {
470     if (overrideContentSecurityPolicy)
471         return true;
472     bool didNotifyInspector = false;
473     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
474         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;&#39;unsafe-eval&#39;&quot;);
475         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, state);
476         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
477             reportBlockedScriptExecutionToInspector(violatedDirective.text());
478             didNotifyInspector = true;
479         }
480     };
481     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeEval);
482 }
483 
484 bool ContentSecurityPolicy::allowFrameAncestors(const Frame&amp; frame, const URL&amp; url, bool overrideContentSecurityPolicy) const
485 {
486     if (overrideContentSecurityPolicy)
487         return true;
488     Frame&amp; topFrame = frame.tree().top();
489     if (&amp;frame == &amp;topFrame)
490         return true;
491     String sourceURL;
492     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
493     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
494         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, &quot;Refused to load&quot;);
495         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
496     };
497     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestor, frame);
498 }
499 
<a name="5" id="anc5"></a><span class="line-added">500 bool ContentSecurityPolicy::overridesXFrameOptions() const</span>
<span class="line-added">501 {</span>
<span class="line-added">502     // If a resource is delivered with an policy that includes a directive named frame-ancestors and whose disposition</span>
<span class="line-added">503     // is &quot;enforce&quot;, then the X-Frame-Options header MUST be ignored.</span>
<span class="line-added">504     // https://www.w3.org/TR/CSP3/#frame-ancestors-and-frame-options</span>
<span class="line-added">505     for (auto&amp; policy : m_policies) {</span>
<span class="line-added">506         if (!policy-&gt;isReportOnly() &amp;&amp; policy-&gt;hasFrameAncestorsDirective())</span>
<span class="line-added">507             return true;</span>
<span class="line-added">508     }</span>
<span class="line-added">509     return false;</span>
<span class="line-added">510 }</span>
<span class="line-added">511 </span>
512 bool ContentSecurityPolicy::allowFrameAncestors(const Vector&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; ancestorOrigins, const URL&amp; url, bool overrideContentSecurityPolicy) const
513 {
514     if (overrideContentSecurityPolicy)
515         return true;
516     bool isTopLevelFrame = ancestorOrigins.isEmpty();
517     if (isTopLevelFrame)
518         return true;
519     String sourceURL;
520     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
521     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
522         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, &quot;Refused to load&quot;);
523         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
524     };
525     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestorOrigins, ancestorOrigins);
526 }
527 
528 bool ContentSecurityPolicy::allowPluginType(const String&amp; type, const String&amp; typeAttribute, const URL&amp; url, bool overrideContentSecurityPolicy) const
529 {
530     if (overrideContentSecurityPolicy)
531         return true;
532     String sourceURL;
533     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
534     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
535         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, &quot;Refused to load&quot;, &quot;its MIME type&quot;);
536         reportViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
537     };
538     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForPluginType, type, typeAttribute);
539 }
540 
541 bool ContentSecurityPolicy::allowObjectFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
542 {
543     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
544         return true;
545     // As per section object-src of the Content Security Policy Level 3 spec., &lt;http://w3c.github.io/webappsec-csp&gt; (Editor&#39;s Draft, 29 February 2016),
546     // &quot;If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based
547     // on the specified type), it MUST be blocked if object-src&#39;s value is &#39;none&#39;, but will otherwise be allowed&quot;.
548     String sourceURL;
549     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
550     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
551         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, &quot;Refused to load&quot;);
552         reportViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
553     };
554     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForObjectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes, ContentSecurityPolicySourceListDirective::ShouldAllowEmptyURLIfSourceListIsNotNone::Yes);
555 }
556 
557 bool ContentSecurityPolicy::allowChildFrameFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
558 {
559     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
560         return true;
561     String sourceURL;
562     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
563     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
564         const char* effectiveViolatedDirective = violatedDirective.name() == ContentSecurityPolicyDirectiveNames::frameSrc ? ContentSecurityPolicyDirectiveNames::frameSrc : ContentSecurityPolicyDirectiveNames::childSrc;
565         String consoleMessage = consoleMessageForViolation(effectiveViolatedDirective, violatedDirective, url, &quot;Refused to load&quot;);
566         reportViolation(effectiveViolatedDirective, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
567     };
568     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrame, url, redirectResponseReceived == RedirectResponseReceived::Yes);
569 }
570 
571 bool ContentSecurityPolicy::allowResourceFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived, const char* name, ResourcePredicate resourcePredicate) const
572 {
573     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
574         return true;
575     String sourceURL;
576     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
577     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
578         String consoleMessage = consoleMessageForViolation(name, violatedDirective, url, &quot;Refused to load&quot;);
579         reportViolation(name, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
580     };
581     return allPoliciesAllow(WTFMove(handleViolatedDirective), resourcePredicate, url, redirectResponseReceived == RedirectResponseReceived::Yes);
582 }
583 
584 bool ContentSecurityPolicy::allowChildContextFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
585 {
586     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::childSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForChildContext);
587 }
588 
589 bool ContentSecurityPolicy::allowScriptFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
590 {
591     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::scriptSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScript);
592 }
593 
594 bool ContentSecurityPolicy::allowImageFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
595 {
596     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::imgSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForImage);
597 }
598 
599 bool ContentSecurityPolicy::allowStyleFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
600 {
601     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::styleSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyle);
602 }
603 
604 bool ContentSecurityPolicy::allowFontFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
605 {
606     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::fontSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFont);
607 }
608 
609 #if ENABLE(APPLICATION_MANIFEST)
610 bool ContentSecurityPolicy::allowManifestFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
611 {
612     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::manifestSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForManifest);
613 }
614 #endif // ENABLE(APPLICATION_MANIFEST)
615 
616 bool ContentSecurityPolicy::allowMediaFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
617 {
618     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::mediaSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForMedia);
619 }
620 
621 bool ContentSecurityPolicy::allowConnectToSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
622 {
623     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
624         return true;
625     String sourceURL;
626     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
627     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
628         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, &quot;Refused to connect to&quot;);
629         reportViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
630     };
631     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForConnectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes);
632 }
633 
634 bool ContentSecurityPolicy::allowFormAction(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
635 {
636     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::formAction, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFormAction);
637 }
638 
639 bool ContentSecurityPolicy::allowBaseURI(const URL&amp; url, bool overrideContentSecurityPolicy) const
640 {
641     if (overrideContentSecurityPolicy)
642         return true;
643     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
644         return true;
645     String sourceURL;
646     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
647     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
648         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, &quot;Refused to change the document base URL to&quot;);
649         reportViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
650     };
651     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForBaseURI, url);
652 }
653 
654 String ContentSecurityPolicy::deprecatedURLForReporting(const URL&amp; url) const
655 {
656     if (!url.isValid())
657         return { };
658     if (!url.isHierarchical() || url.protocolIs(&quot;file&quot;))
659         return url.protocol().toString();
660     return static_cast&lt;SecurityOriginData&gt;(*m_selfSource).securityOrigin()-&gt;canRequest(url) ? url.strippedForUseAsReferrer() : SecurityOrigin::create(url)-&gt;toString();
661 }
662 
663 void ContentSecurityPolicy::reportViolation(const String&amp; violatedDirective, const ContentSecurityPolicyDirective&amp; effectiveViolatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::ExecState* state) const
664 {
665     // FIXME: Extract source file and source position from JSC::ExecState.
666     return reportViolation(violatedDirective, effectiveViolatedDirective.text(), effectiveViolatedDirective.directiveList(), blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
667 }
668 
669 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::ExecState* state) const
670 {
671     // FIXME: Extract source file and source position from JSC::ExecState.
672     return reportViolation(effectiveViolatedDirective, violatedDirective, violatedDirectiveList, blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
673 }
674 
675 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::ExecState* state) const
676 {
677     return reportViolation(effectiveViolatedDirective, violatedDirective.text(), violatedDirective.directiveList(), blockedURL, consoleMessage, sourceURL, sourcePosition, state);
678 }
679 
680 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::ExecState* state) const
681 {
<a name="6" id="anc6"></a><span class="line-modified">682     logToConsole(consoleMessage, sourceURL, sourcePosition.m_line, sourcePosition.m_column, state);</span>
683 
684     if (!m_isReportingEnabled)
685         return;
686 
687     // FIXME: Support sending reports from worker.
688     CSPInfo info;
689     info.documentURI = blockedURL;
690     if (m_client)
691         m_client-&gt;willSendCSPViolationReport(info);
692     else {
693         if (!is&lt;Document&gt;(m_scriptExecutionContext))
694             return;
695 
696         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
697         auto* frame = document.frame();
698         if (!frame)
699             return;
700 
701         info.documentURI = document.url().strippedForUseAsReferrer();
702 
703         auto stack = createScriptCallStack(JSExecState::currentState(), 2);
704         auto* callFrame = stack-&gt;firstNonNativeCallFrame();
705         if (callFrame &amp;&amp; callFrame-&gt;lineNumber()) {
706             info.sourceFile = deprecatedURLForReporting(URL { URL { }, callFrame-&gt;sourceURL() });
707             info.lineNumber = callFrame-&gt;lineNumber();
708             info.columnNumber = callFrame-&gt;columnNumber();
709         }
710     }
711     ASSERT(m_client || is&lt;Document&gt;(m_scriptExecutionContext));
712 
713     String blockedURI = deprecatedURLForReporting(blockedURL);
714     // FIXME: Is it policy to not use the status code for HTTPS, or is that a bug?
715     unsigned short httpStatusCode = m_selfSourceProtocol == &quot;http&quot; ? m_httpStatusCode : 0;
716 
717     // 1. Dispatch violation event.
718     SecurityPolicyViolationEvent::Init violationEventInit;
719     violationEventInit.documentURI = info.documentURI;
720     violationEventInit.referrer = m_referrer;
721     violationEventInit.blockedURI = blockedURI;
722     violationEventInit.violatedDirective = violatedDirective;
723     violationEventInit.effectiveDirective = effectiveViolatedDirective;
724     violationEventInit.originalPolicy = violatedDirectiveList.header();
725     violationEventInit.sourceFile = info.sourceFile;
726     violationEventInit.statusCode = httpStatusCode;
727     violationEventInit.lineNumber =  info.lineNumber;
728     violationEventInit.columnNumber = info.columnNumber;
729     if (m_client)
730         m_client-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(violationEventInit));
731     else
732         downcast&lt;Document&gt;(*m_scriptExecutionContext).enqueueSecurityPolicyViolationEvent(WTFMove(violationEventInit));
733 
734     // 2. Send violation report (if applicable).
735     auto&amp; reportURIs = violatedDirectiveList.reportURIs();
736     if (reportURIs.isEmpty())
737         return;
738 
739     // We need to be careful here when deciding what information to send to the
740     // report-uri. Currently, we send only the current document&#39;s URL and the
741     // directive that was violated. The document&#39;s URL is safe to send because
742     // it&#39;s the document itself that&#39;s requesting that it be sent. You could
743     // make an argument that we shouldn&#39;t send HTTPS document URLs to HTTP
744     // report-uris (for the same reasons that we suppress the Referer in that
745     // case), but the Referer is sent implicitly whereas this request is only
746     // sent explicitly. As for which directive was violated, that&#39;s pretty
747     // harmless information.
748 
749     auto cspReport = JSON::Object::create();
750     cspReport-&gt;setString(&quot;document-uri&quot;_s, info.documentURI);
751     cspReport-&gt;setString(&quot;referrer&quot;_s, m_referrer);
752     cspReport-&gt;setString(&quot;violated-directive&quot;_s, violatedDirective);
753     cspReport-&gt;setString(&quot;effective-directive&quot;_s, effectiveViolatedDirective);
754     cspReport-&gt;setString(&quot;original-policy&quot;_s, violatedDirectiveList.header());
755     cspReport-&gt;setString(&quot;blocked-uri&quot;_s, blockedURI);
756     cspReport-&gt;setInteger(&quot;status-code&quot;_s, httpStatusCode);
757     if (!info.sourceFile.isNull()) {
758         cspReport-&gt;setString(&quot;source-file&quot;_s, info.sourceFile);
759         cspReport-&gt;setInteger(&quot;line-number&quot;_s, info.lineNumber);
760         cspReport-&gt;setInteger(&quot;column-number&quot;_s, info.columnNumber);
761     }
762 
763     auto reportObject = JSON::Object::create();
764     reportObject-&gt;setObject(&quot;csp-report&quot;_s, WTFMove(cspReport));
765 
766     auto report = FormData::create(reportObject-&gt;toJSONString().utf8());
767 
768     if (m_client) {
769         for (const auto&amp; url : reportURIs)
770             m_client-&gt;sendCSPViolationReport(URL { m_protectedURL, url }, report.copyRef());
771     } else {
772         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
773         for (const auto&amp; url : reportURIs)
774             PingLoader::sendViolationReport(*document.frame(), URL { m_protectedURL, url }, report.copyRef(), ViolationReportType::ContentSecurityPolicy);
775     }
776 }
777 
778 void ContentSecurityPolicy::reportUnsupportedDirective(const String&amp; name) const
779 {
780     String message;
781     if (equalLettersIgnoringASCIICase(name, &quot;allow&quot;))
782         message = &quot;The &#39;allow&#39; directive has been replaced with &#39;default-src&#39;. Please use that directive instead, as &#39;allow&#39; has no effect.&quot;_s;
783     else if (equalLettersIgnoringASCIICase(name, &quot;options&quot;))
784         message = &quot;The &#39;options&#39; directive has been replaced with &#39;unsafe-inline&#39; and &#39;unsafe-eval&#39; source expressions for the &#39;script-src&#39; and &#39;style-src&#39; directives. Please use those directives instead, as &#39;options&#39; has no effect.&quot;_s;
785     else if (equalLettersIgnoringASCIICase(name, &quot;policy-uri&quot;))
786         message = &quot;The &#39;policy-uri&#39; directive has been removed from the specification. Please specify a complete policy via the Content-Security-Policy header.&quot;_s;
787     else
788         message = makeString(&quot;Unrecognized Content-Security-Policy directive &#39;&quot;, name, &quot;&#39;.\n&quot;); // FIXME: Why does this include a newline?
789 
790     logToConsole(message);
791 }
792 
793 void ContentSecurityPolicy::reportDirectiveAsSourceExpression(const String&amp; directiveName, const String&amp; sourceExpression) const
794 {
795     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; contains &#39;&quot; + sourceExpression + &quot;&#39; as a source expression. Did you mean &#39;&quot; + directiveName + &quot; ...; &quot; + sourceExpression + &quot;...&#39; (note the semicolon)?&quot;);
796 }
797 
798 void ContentSecurityPolicy::reportDuplicateDirective(const String&amp; name) const
799 {
800     logToConsole(makeString(&quot;Ignoring duplicate Content-Security-Policy directive &#39;&quot;, name, &quot;&#39;.\n&quot;));
801 }
802 
803 void ContentSecurityPolicy::reportInvalidPluginTypes(const String&amp; pluginType) const
804 {
805     String message;
806     if (pluginType.isNull())
807         message = &quot;&#39;plugin-types&#39; Content Security Policy directive is empty; all plugins will be blocked.\n&quot;;
808     else
809         message = makeString(&quot;Invalid plugin type in &#39;plugin-types&#39; Content Security Policy directive: &#39;&quot;, pluginType, &quot;&#39;.\n&quot;);
810     logToConsole(message);
811 }
812 
813 void ContentSecurityPolicy::reportInvalidSandboxFlags(const String&amp; invalidFlags) const
814 {
815     logToConsole(&quot;Error while parsing the &#39;sandbox&#39; Content Security Policy directive: &quot; + invalidFlags);
816 }
817 
818 void ContentSecurityPolicy::reportInvalidDirectiveInReportOnlyMode(const String&amp; directiveName) const
819 {
820     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; is ignored when delivered in a report-only policy.&quot;);
821 }
822 
823 void ContentSecurityPolicy::reportInvalidDirectiveInHTTPEquivMeta(const String&amp; directiveName) const
824 {
825     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; is ignored when delivered via an HTML meta element.&quot;);
826 }
827 
828 void ContentSecurityPolicy::reportInvalidDirectiveValueCharacter(const String&amp; directiveName, const String&amp; value) const
829 {
830     String message = makeString(&quot;The value for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid character: &#39;&quot;, value, &quot;&#39;. Non-whitespace characters outside ASCII 0x21-0x7E must be percent-encoded, as described in RFC 3986, section 2.1: http://tools.ietf.org/html/rfc3986#section-2.1.&quot;);
831     logToConsole(message);
832 }
833 
834 void ContentSecurityPolicy::reportInvalidPathCharacter(const String&amp; directiveName, const String&amp; value, const char invalidChar) const
835 {
836     ASSERT(invalidChar == &#39;#&#39; || invalidChar == &#39;?&#39;);
837 
838     String ignoring;
839     if (invalidChar == &#39;?&#39;)
840         ignoring = &quot;The query component, including the &#39;?&#39;, will be ignored.&quot;;
841     else
842         ignoring = &quot;The fragment identifier, including the &#39;#&#39;, will be ignored.&quot;;
843 
844     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains a source with an invalid path: &#39;&quot;, value, &quot;&#39;. &quot;, ignoring);
845     logToConsole(message);
846 }
847 
848 void ContentSecurityPolicy::reportInvalidSourceExpression(const String&amp; directiveName, const String&amp; source) const
849 {
850     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid source: &#39;&quot;, source, &quot;&#39;. It will be ignored.&quot;);
851     if (equalLettersIgnoringASCIICase(source, &quot;&#39;none&#39;&quot;))
852         message = makeString(message, &quot; Note that &#39;none&#39; has no effect unless it is the only expression in the source list.&quot;);
853     logToConsole(message);
854 }
855 
856 void ContentSecurityPolicy::reportMissingReportURI(const String&amp; policy) const
857 {
858     logToConsole(&quot;The Content Security Policy &#39;&quot; + policy + &quot;&#39; was delivered in report-only mode, but does not specify a &#39;report-uri&#39;; the policy will have no effect. Please either add a &#39;report-uri&#39; directive, or deliver the policy via the &#39;Content-Security-Policy&#39; header.&quot;);
859 }
860 
<a name="7" id="anc7"></a><span class="line-modified">861 void ContentSecurityPolicy::logToConsole(const String&amp; message, const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const WTF::OrdinalNumber&amp; contextColumn, JSC::ExecState* state) const</span>
862 {
863     if (!m_isReportingEnabled)
864         return;
865 
<a name="8" id="anc8"></a>
866     if (m_client)
867         m_client-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, 0);
868     else if (m_scriptExecutionContext)
<a name="9" id="anc9"></a><span class="line-modified">869         m_scriptExecutionContext-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, contextURL, contextLine.oneBasedInt(), contextColumn.oneBasedInt(), state);</span>
870 }
871 
872 void ContentSecurityPolicy::reportBlockedScriptExecutionToInspector(const String&amp; directiveText) const
873 {
874     if (m_scriptExecutionContext)
875         InspectorInstrumentation::scriptExecutionBlockedByCSP(m_scriptExecutionContext, directiveText);
876 }
877 
878 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(ResourceRequest&amp; request, InsecureRequestType requestType) const
879 {
880     URL url = request.url();
881     upgradeInsecureRequestIfNeeded(url, requestType);
882     request.setURL(url);
883 }
884 
885 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(URL&amp; url, InsecureRequestType requestType) const
886 {
887     if (!url.protocolIs(&quot;http&quot;) &amp;&amp; !url.protocolIs(&quot;ws&quot;))
888         return;
889 
890     bool upgradeRequest = m_insecureNavigationRequestsToUpgrade.contains(SecurityOriginData::fromURL(url));
891     if (requestType == InsecureRequestType::Load || requestType == InsecureRequestType::FormSubmission)
892         upgradeRequest |= m_upgradeInsecureRequests;
893 
894     if (!upgradeRequest)
895         return;
896 
897     if (url.protocolIs(&quot;http&quot;))
898         url.setProtocol(&quot;https&quot;);
899     else {
900         ASSERT(url.protocolIs(&quot;ws&quot;));
901         url.setProtocol(&quot;wss&quot;);
902     }
903 
904     if (url.port() &amp;&amp; url.port().value() == 80)
905         url.setPort(443);
906 }
907 
908 void ContentSecurityPolicy::setUpgradeInsecureRequests(bool upgradeInsecureRequests)
909 {
910     m_upgradeInsecureRequests = upgradeInsecureRequests;
911     if (!m_upgradeInsecureRequests)
912         return;
913 
914     if (!m_scriptExecutionContext)
915         return;
916 
917     // Store the upgrade domain as an &#39;insecure&#39; protocol so we can quickly identify
918     // origins we should upgrade.
919     URL upgradeURL = m_scriptExecutionContext-&gt;url();
920     if (upgradeURL.protocolIs(&quot;https&quot;))
921         upgradeURL.setProtocol(&quot;http&quot;);
922     else if (upgradeURL.protocolIs(&quot;wss&quot;))
923         upgradeURL.setProtocol(&quot;ws&quot;);
924 
925     m_insecureNavigationRequestsToUpgrade.add(SecurityOriginData::fromURL(upgradeURL));
926 }
927 
928 void ContentSecurityPolicy::inheritInsecureNavigationRequestsToUpgradeFromOpener(const ContentSecurityPolicy&amp; other)
929 {
930     m_insecureNavigationRequestsToUpgrade.add(other.m_insecureNavigationRequestsToUpgrade.begin(), other.m_insecureNavigationRequestsToUpgrade.end());
931 }
932 
933 HashSet&lt;SecurityOriginData&gt; ContentSecurityPolicy::takeNavigationRequestsToUpgrade()
934 {
935     return WTFMove(m_insecureNavigationRequestsToUpgrade);
936 }
937 
938 void ContentSecurityPolicy::setInsecureNavigationRequestsToUpgrade(HashSet&lt;SecurityOriginData&gt;&amp;&amp; insecureNavigationRequests)
939 {
940     m_insecureNavigationRequestsToUpgrade = WTFMove(insecureNavigationRequests);
941 }
942 
943 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>