<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;LLIntSlowPaths.h&quot;
  28 
  29 #include &quot;ArrayConstructor.h&quot;
  30 #include &quot;CallFrame.h&quot;
  31 #include &quot;CommonSlowPaths.h&quot;
  32 #include &quot;Error.h&quot;
  33 #include &quot;ErrorHandlingScope.h&quot;
  34 #include &quot;EvalCodeBlock.h&quot;
  35 #include &quot;Exception.h&quot;
  36 #include &quot;ExceptionFuzz.h&quot;
  37 #include &quot;ExecutableBaseInlines.h&quot;
  38 #include &quot;FrameTracers.h&quot;
  39 #include &quot;FunctionCodeBlock.h&quot;
  40 #include &quot;FunctionWhitelist.h&quot;
  41 #include &quot;GetterSetter.h&quot;
  42 #include &quot;HostCallReturnValue.h&quot;
  43 #include &quot;InterpreterInlines.h&quot;
  44 #include &quot;IteratorOperations.h&quot;
  45 #include &quot;JIT.h&quot;
  46 #include &quot;JITExceptions.h&quot;
  47 #include &quot;JITWorklist.h&quot;
  48 #include &quot;JSAsyncFunction.h&quot;
  49 #include &quot;JSAsyncGeneratorFunction.h&quot;
  50 #include &quot;JSCInlines.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;JSGeneratorFunction.h&quot;
  53 #include &quot;JSGlobalObjectFunctions.h&quot;
  54 #include &quot;JSLexicalEnvironment.h&quot;
  55 #include &quot;JSString.h&quot;
  56 #include &quot;JSWithScope.h&quot;
  57 #include &quot;LLIntCommon.h&quot;
  58 #include &quot;LLIntData.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LLIntPrototypeLoadAdaptiveStructureWatchpoint.h&quot;
  61 #include &quot;LowLevelInterpreter.h&quot;
  62 #include &quot;ModuleProgramCodeBlock.h&quot;
  63 #include &quot;ObjectConstructor.h&quot;
  64 #include &quot;ObjectPropertyConditionSet.h&quot;
  65 #include &quot;OpcodeInlines.h&quot;
  66 #include &quot;ProgramCodeBlock.h&quot;
  67 #include &quot;ProtoCallFrame.h&quot;
  68 #include &quot;RegExpObject.h&quot;
  69 #include &quot;ShadowChicken.h&quot;
  70 #include &quot;StructureRareDataInlines.h&quot;
  71 #include &quot;SuperSampler.h&quot;
  72 #include &quot;VMInlines.h&quot;
  73 #include &lt;wtf/NeverDestroyed.h&gt;
  74 #include &lt;wtf/StringPrintStream.h&gt;
  75 
  76 namespace JSC { namespace LLInt {
  77 
  78 #define LLINT_BEGIN_NO_SET_PC() \
  79     VM&amp; vm = exec-&gt;vm();      \
<a name="1" id="anc1"></a><span class="line-modified">  80     NativeCallFrameTracer tracer(&amp;vm, exec); \</span>
  81     auto throwScope = DECLARE_THROW_SCOPE(vm)
  82 
  83 #ifndef NDEBUG
  84 #define LLINT_SET_PC_FOR_STUBS() do { \
  85         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \
  86         exec-&gt;setCurrentVPC(pc); \
  87     } while (false)
  88 #else
  89 #define LLINT_SET_PC_FOR_STUBS() do { \
  90         exec-&gt;setCurrentVPC(pc); \
  91     } while (false)
  92 #endif
  93 
  94 #define LLINT_BEGIN()                           \
  95     LLINT_BEGIN_NO_SET_PC();                    \
  96     LLINT_SET_PC_FOR_STUBS()
  97 
  98 inline JSValue getNonConstantOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;uncheckedR(operand.offset()).jsValue(); }
  99 inline JSValue getOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;r(operand.offset()).jsValue(); }
 100 
 101 #define LLINT_RETURN_TWO(first, second) do {       \
 102         return encodeResult(first, second);        \
 103     } while (false)
 104 
 105 #define LLINT_END_IMPL() LLINT_RETURN_TWO(pc, 0)
 106 
 107 #define LLINT_THROW(exceptionToThrow) do {                        \
 108         throwException(exec, throwScope, exceptionToThrow);       \
 109         pc = returnToThrow(exec);                                 \
 110         LLINT_END_IMPL();                                         \
 111     } while (false)
 112 
 113 #define LLINT_CHECK_EXCEPTION() do {                    \
 114         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;LLIntSlowPaths&quot;, pc);    \
 115         if (UNLIKELY(throwScope.exception())) {         \
 116             pc = returnToThrow(exec);                   \
 117             LLINT_END_IMPL();                           \
 118         }                                               \
 119     } while (false)
 120 
 121 #define LLINT_END() do {                        \
 122         LLINT_CHECK_EXCEPTION();                \
 123         LLINT_END_IMPL();                       \
 124     } while (false)
 125 
 126 #define JUMP_OFFSET(targetOffset) \
 127     ((targetOffset) ? (targetOffset) : exec-&gt;codeBlock()-&gt;outOfLineJumpOffset(pc))
 128 
 129 #define JUMP_TO(target) do { \
 130         pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + (target)); \
 131     } while (false)
 132 
 133 #define LLINT_BRANCH(condition) do {                  \
 134         bool __b_condition = (condition);                         \
 135         LLINT_CHECK_EXCEPTION();                                  \
 136         if (__b_condition)                                        \
 137             JUMP_TO(JUMP_OFFSET(bytecode.m_targetLabel));         \
 138         else                                                      \
 139             JUMP_TO(pc-&gt;size()); \
 140         LLINT_END_IMPL();                                         \
 141     } while (false)
 142 
 143 #define LLINT_RETURN(value) do {                \
 144         JSValue __r_returnValue = (value);      \
 145         LLINT_CHECK_EXCEPTION();                \
 146         exec-&gt;uncheckedR(bytecode.m_dst) = __r_returnValue;          \
 147         LLINT_END_IMPL();                       \
 148     } while (false)
 149 
 150 #define LLINT_RETURN_PROFILED(value) do {               \
 151         JSValue __rp_returnValue = (value);                     \
 152         LLINT_CHECK_EXCEPTION();                                \
 153         exec-&gt;uncheckedR(bytecode.m_dst) = __rp_returnValue;                         \
 154         LLINT_PROFILE_VALUE(__rp_returnValue);          \
 155         LLINT_END_IMPL();                                       \
 156     } while (false)
 157 
 158 #define LLINT_PROFILE_VALUE(value) do { \
 159         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \
 160     } while (false)
 161 
 162 #define LLINT_CALL_END_IMPL(exec, callTarget, callTargetTag) \
 163     LLINT_RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))
 164 
 165 #define LLINT_CALL_THROW(exec, exceptionToThrow) do {                   \
 166         ExecState* __ct_exec = (exec);                                  \
 167         throwException(__ct_exec, throwScope, exceptionToThrow);        \
 168         LLINT_CALL_END_IMPL(0, callToThrow(__ct_exec), ExceptionHandlerPtrTag);                 \
 169     } while (false)
 170 
 171 #define LLINT_CALL_CHECK_EXCEPTION(exec, execCallee) do {               \
 172         ExecState* __cce_exec = (exec);                                 \
 173         ExecState* __cce_execCallee = (execCallee);                     \
 174         doExceptionFuzzingIfEnabled(__cce_exec, throwScope, &quot;LLIntSlowPaths/call&quot;, nullptr); \
 175         if (UNLIKELY(throwScope.exception()))                           \
 176             LLINT_CALL_END_IMPL(0, callToThrow(__cce_execCallee), ExceptionHandlerPtrTag); \
 177     } while (false)
 178 
 179 #define LLINT_CALL_RETURN(exec, execCallee, callTarget, callTargetTag) do { \
 180         ExecState* __cr_exec = (exec);                                  \
 181         ExecState* __cr_execCallee = (execCallee);                      \
 182         void* __cr_callTarget = (callTarget);                           \
 183         LLINT_CALL_CHECK_EXCEPTION(__cr_exec, __cr_execCallee);         \
 184         LLINT_CALL_END_IMPL(__cr_execCallee, __cr_callTarget, callTargetTag); \
 185     } while (false)
 186 
 187 #define LLINT_RETURN_CALLEE_FRAME(execCallee) do {                      \
 188         ExecState* __rcf_exec = (execCallee);                           \
 189         LLINT_RETURN_TWO(pc, __rcf_exec);                               \
 190     } while (false)
 191 
 192 #if LLINT_TRACING
 193 
 194 template&lt;typename... Types&gt;
 195 void slowPathLog(const Types&amp;... values)
 196 {
 197     dataLogIf(Options::traceLLIntSlowPath(), values...);
 198 }
 199 
 200 template&lt;typename... Types&gt;
 201 void slowPathLn(const Types&amp;... values)
 202 {
 203     dataLogLnIf(Options::traceLLIntSlowPath(), values...);
 204 }
 205 
 206 template&lt;typename... Types&gt;
 207 void slowPathLogF(const char* format, const Types&amp;... values)
 208 {
 209     ALLOW_NONLITERAL_FORMAT_BEGIN
 210     IGNORE_WARNINGS_BEGIN(&quot;format-security&quot;)
 211     if (Options::traceLLIntSlowPath())
 212         dataLogF(format, values...);
 213     IGNORE_WARNINGS_END
 214     ALLOW_NONLITERAL_FORMAT_END
 215 }
 216 
 217 #else // not LLINT_TRACING
 218 
 219 template&lt;typename... Types&gt; void slowPathLog(const Types&amp;...) { }
 220 template&lt;typename... Types&gt; void slowPathLogLn(const Types&amp;...) { }
 221 template&lt;typename... Types&gt; void slowPathLogF(const char*, const Types&amp;...) { }
 222 
 223 #endif // LLINT_TRACING
 224 
 225 extern &quot;C&quot; SlowPathReturnType llint_trace_operand(ExecState* exec, const Instruction* pc, int fromWhere, int operand)
 226 {
 227     if (!Options::traceLLIntExecution())
 228         LLINT_END_IMPL();
 229 
 230     LLINT_BEGIN();
 231     dataLogF(
 232         &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d\n&quot;,
 233         &amp;Thread::current(),
 234         exec-&gt;codeBlock(),
 235         exec,
 236         static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),
 237         pc-&gt;opcodeID(),
 238         fromWhere,
 239         operand);
 240     LLINT_END();
 241 }
 242 
 243 extern &quot;C&quot; SlowPathReturnType llint_trace_value(ExecState* exec, const Instruction* pc, int fromWhere, VirtualRegister operand)
 244 {
 245     if (!Options::traceLLIntExecution())
 246         LLINT_END_IMPL();
 247 
 248     JSValue value = getOperand(exec, operand);
 249     union {
 250         struct {
 251             uint32_t tag;
 252             uint32_t payload;
 253         } bits;
 254         EncodedJSValue asValue;
 255     } u;
 256     u.asValue = JSValue::encode(value);
 257     dataLogF(
 258         &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d: %08x:%08x: %s\n&quot;,
 259         &amp;Thread::current(),
 260         exec-&gt;codeBlock(),
 261         exec,
 262         static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),
 263         pc-&gt;opcodeID(),
 264         fromWhere,
 265         operand.offset(),
 266         u.bits.tag,
 267         u.bits.payload,
 268         toCString(value).data());
 269     LLINT_END_IMPL();
 270 }
 271 
 272 LLINT_SLOW_PATH_DECL(trace_prologue)
 273 {
 274     if (!Options::traceLLIntExecution())
 275         LLINT_END_IMPL();
 276 
 277     dataLogF(&quot;&lt;%p&gt; %p / %p: in prologue of &quot;, &amp;Thread::current(), exec-&gt;codeBlock(), exec);
 278     dataLog(exec-&gt;codeBlock(), &quot;\n&quot;);
 279     LLINT_END_IMPL();
 280 }
 281 
 282 static void traceFunctionPrologue(ExecState* exec, const char* comment, CodeSpecializationKind kind)
 283 {
 284     if (!Options::traceLLIntExecution())
 285         return;
 286 
 287     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());
 288     FunctionExecutable* executable = callee-&gt;jsExecutable();
 289     CodeBlock* codeBlock = executable-&gt;codeBlockFor(kind);
 290     dataLogF(&quot;&lt;%p&gt; %p / %p: in %s of &quot;, &amp;Thread::current(), codeBlock, exec, comment);
 291     dataLog(codeBlock);
 292     dataLogF(&quot; function %p, executable %p; numVars = %u, numParameters = %u, numCalleeLocals = %u, caller = %p.\n&quot;,
 293         callee, executable, codeBlock-&gt;numVars(), codeBlock-&gt;numParameters(), codeBlock-&gt;numCalleeLocals(), exec-&gt;callerFrame());
 294 }
 295 
 296 LLINT_SLOW_PATH_DECL(trace_prologue_function_for_call)
 297 {
 298     traceFunctionPrologue(exec, &quot;call prologue&quot;, CodeForCall);
 299     LLINT_END_IMPL();
 300 }
 301 
 302 LLINT_SLOW_PATH_DECL(trace_prologue_function_for_construct)
 303 {
 304     traceFunctionPrologue(exec, &quot;construct prologue&quot;, CodeForConstruct);
 305     LLINT_END_IMPL();
 306 }
 307 
 308 LLINT_SLOW_PATH_DECL(trace_arityCheck_for_call)
 309 {
 310     traceFunctionPrologue(exec, &quot;call arity check&quot;, CodeForCall);
 311     LLINT_END_IMPL();
 312 }
 313 
 314 LLINT_SLOW_PATH_DECL(trace_arityCheck_for_construct)
 315 {
 316     traceFunctionPrologue(exec, &quot;construct arity check&quot;, CodeForConstruct);
 317     LLINT_END_IMPL();
 318 }
 319 
 320 LLINT_SLOW_PATH_DECL(trace)
 321 {
 322     if (!Options::traceLLIntExecution())
 323         LLINT_END_IMPL();
 324 
 325     OpcodeID opcodeID = pc-&gt;opcodeID();
 326     dataLogF(&quot;&lt;%p&gt; %p / %p: executing bc#%zu, %s, pc = %p\n&quot;,
 327             &amp;Thread::current(),
 328             exec-&gt;codeBlock(),
 329             exec,
 330             static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),
 331             pc-&gt;name(),
 332             pc);
 333     if (opcodeID == op_enter) {
 334         dataLogF(&quot;Frame will eventually return to %p\n&quot;, exec-&gt;returnPC().value());
 335         *removeCodePtrTag&lt;volatile char*&gt;(exec-&gt;returnPC().value());
 336     }
 337     if (opcodeID == op_ret) {
 338         dataLogF(&quot;Will be returning to %p\n&quot;, exec-&gt;returnPC().value());
 339         dataLogF(&quot;The new cfr will be %p\n&quot;, exec-&gt;callerFrame());
 340     }
 341     LLINT_END_IMPL();
 342 }
 343 
 344 enum EntryKind { Prologue, ArityCheck };
 345 
 346 #if ENABLE(JIT)
 347 static FunctionWhitelist&amp; ensureGlobalJITWhitelist()
 348 {
 349     static LazyNeverDestroyed&lt;FunctionWhitelist&gt; baselineWhitelist;
 350     static std::once_flag initializeWhitelistFlag;
 351     std::call_once(initializeWhitelistFlag, [] {
 352         const char* functionWhitelistFile = Options::jitWhitelist();
 353         baselineWhitelist.construct(functionWhitelistFile);
 354     });
 355     return baselineWhitelist;
 356 }
 357 
 358 inline bool shouldJIT(CodeBlock* codeBlock)
 359 {
<a name="2" id="anc2"></a><span class="line-modified"> 360     if (!Options::bytecodeRangeToJITCompile().isInRange(codeBlock-&gt;instructionCount())</span>
 361         || !ensureGlobalJITWhitelist().contains(codeBlock))
 362         return false;
 363 
 364     return VM::canUseJIT() &amp;&amp; Options::useBaselineJIT();
 365 }
 366 
 367 // Returns true if we should try to OSR.
 368 inline bool jitCompileAndSetHeuristics(CodeBlock* codeBlock, ExecState* exec, unsigned loopOSREntryBytecodeOffset = 0)
 369 {
 370     VM&amp; vm = exec-&gt;vm();
 371     DeferGCForAWhile deferGC(vm.heap); // My callers don&#39;t set top callframe, so we don&#39;t want to GC here at all.
 372     ASSERT(VM::canUseJIT());
 373 
 374     codeBlock-&gt;updateAllValueProfilePredictions();
 375 
 376     if (!codeBlock-&gt;checkIfJITThresholdReached()) {
 377         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayJITCompile&quot;, (&quot;threshold not reached, counter = &quot;, codeBlock-&gt;llintExecuteCounter()));
 378         if (Options::verboseOSR())
 379             dataLogF(&quot;    JIT threshold should be lifted.\n&quot;);
 380         return false;
 381     }
 382 
 383     JITWorklist::ensureGlobalWorklist().poll(vm);
 384 
 385     switch (codeBlock-&gt;jitType()) {
<a name="3" id="anc3"></a><span class="line-modified"> 386     case JITCode::BaselineJIT: {</span>
 387         if (Options::verboseOSR())
 388             dataLogF(&quot;    Code was already compiled.\n&quot;);
 389         codeBlock-&gt;jitSoon();
 390         return true;
 391     }
<a name="4" id="anc4"></a><span class="line-modified"> 392     case JITCode::InterpreterThunk: {</span>
 393         JITWorklist::ensureGlobalWorklist().compileLater(codeBlock, loopOSREntryBytecodeOffset);
<a name="5" id="anc5"></a><span class="line-modified"> 394         return codeBlock-&gt;jitType() == JITCode::BaselineJIT;</span>
 395     }
 396     default:
 397         dataLog(&quot;Unexpected code block in LLInt: &quot;, *codeBlock, &quot;\n&quot;);
 398         RELEASE_ASSERT_NOT_REACHED();
 399         return false;
 400     }
 401 }
 402 
 403 static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char *name, EntryKind kind)
 404 {
 405     if (Options::verboseOSR()) {
 406         dataLog(
 407             *codeBlock, &quot;: Entered &quot;, name, &quot; with executeCounter = &quot;,
 408             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);
 409     }
 410 
 411     if (!shouldJIT(codeBlock)) {
 412         codeBlock-&gt;dontJITAnytimeSoon();
 413         LLINT_RETURN_TWO(0, 0);
 414     }
 415     if (!jitCompileAndSetHeuristics(codeBlock, exec))
 416         LLINT_RETURN_TWO(0, 0);
 417 
 418     CODEBLOCK_LOG_EVENT(codeBlock, &quot;OSR entry&quot;, (&quot;in prologue&quot;));
 419 
 420     if (kind == Prologue)
 421         LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;executableAddress(), 0);
 422     ASSERT(kind == ArityCheck);
 423     LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;addressForCall(MustCheckArity).executableAddress(), 0);
 424 }
 425 #else // ENABLE(JIT)
 426 static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char*, EntryKind)
 427 {
 428     codeBlock-&gt;dontJITAnytimeSoon();
 429     LLINT_RETURN_TWO(0, exec);
 430 }
 431 #endif // ENABLE(JIT)
 432 
 433 LLINT_SLOW_PATH_DECL(entry_osr)
 434 {
 435     return entryOSR(exec, pc, exec-&gt;codeBlock(), &quot;entry_osr&quot;, Prologue);
 436 }
 437 
 438 LLINT_SLOW_PATH_DECL(entry_osr_function_for_call)
 439 {
 440     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call&quot;, Prologue);
 441 }
 442 
 443 LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct)
 444 {
 445     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct&quot;, Prologue);
 446 }
 447 
 448 LLINT_SLOW_PATH_DECL(entry_osr_function_for_call_arityCheck)
 449 {
 450     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call_arityCheck&quot;, ArityCheck);
 451 }
 452 
 453 LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct_arityCheck)
 454 {
 455     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct_arityCheck&quot;, ArityCheck);
 456 }
 457 
 458 LLINT_SLOW_PATH_DECL(loop_osr)
 459 {
 460     LLINT_BEGIN_NO_SET_PC();
 461     UNUSED_PARAM(throwScope);
 462     CodeBlock* codeBlock = exec-&gt;codeBlock();
 463 
 464 #if ENABLE(JIT)
 465     if (Options::verboseOSR()) {
 466         dataLog(
 467             *codeBlock, &quot;: Entered loop_osr with executeCounter = &quot;,
 468             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);
 469     }
 470 
 471     unsigned loopOSREntryBytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);
 472 
 473     if (!shouldJIT(codeBlock)) {
 474         codeBlock-&gt;dontJITAnytimeSoon();
 475         LLINT_RETURN_TWO(0, 0);
 476     }
 477 
 478     if (!jitCompileAndSetHeuristics(codeBlock, exec, loopOSREntryBytecodeOffset))
 479         LLINT_RETURN_TWO(0, 0);
 480 
 481     CODEBLOCK_LOG_EVENT(codeBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, loopOSREntryBytecodeOffset));
 482 
<a name="6" id="anc6"></a><span class="line-modified"> 483     ASSERT(codeBlock-&gt;jitType() == JITCode::BaselineJIT);</span>
 484 
 485     const JITCodeMap&amp; codeMap = codeBlock-&gt;jitCodeMap();
 486     CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(loopOSREntryBytecodeOffset);
 487     ASSERT(codeLocation);
 488 
 489     void* jumpTarget = codeLocation.executableAddress();
 490     ASSERT(jumpTarget);
 491 
 492     LLINT_RETURN_TWO(jumpTarget, exec-&gt;topOfFrame());
 493 #else // ENABLE(JIT)
 494     UNUSED_PARAM(pc);
 495     codeBlock-&gt;dontJITAnytimeSoon();
 496     LLINT_RETURN_TWO(0, 0);
 497 #endif // ENABLE(JIT)
 498 }
 499 
 500 LLINT_SLOW_PATH_DECL(replace)
 501 {
 502     LLINT_BEGIN_NO_SET_PC();
 503     UNUSED_PARAM(throwScope);
 504     CodeBlock* codeBlock = exec-&gt;codeBlock();
 505 
 506 #if ENABLE(JIT)
 507     if (Options::verboseOSR()) {
 508         dataLog(
 509             *codeBlock, &quot;: Entered replace with executeCounter = &quot;,
 510             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);
 511     }
 512 
 513     if (shouldJIT(codeBlock))
 514         jitCompileAndSetHeuristics(codeBlock, exec);
 515     else
 516         codeBlock-&gt;dontJITAnytimeSoon();
 517     LLINT_END_IMPL();
 518 #else // ENABLE(JIT)
 519     codeBlock-&gt;dontJITAnytimeSoon();
 520     LLINT_END_IMPL();
 521 #endif // ENABLE(JIT)
 522 }
 523 
 524 LLINT_SLOW_PATH_DECL(stack_check)
 525 {
 526     VM&amp; vm = exec-&gt;vm();
 527     auto throwScope = DECLARE_THROW_SCOPE(vm);
 528 
 529     // It&#39;s ok to create the NativeCallFrameTracer here before we
 530     // convertToStackOverflowFrame() because this function is always called
 531     // after the frame has been propulated with a proper CodeBlock and callee.
<a name="7" id="anc7"></a><span class="line-modified"> 532     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 533 
 534     LLINT_SET_PC_FOR_STUBS();
 535 
 536     CodeBlock* codeBlock = exec-&gt;codeBlock();
 537     slowPathLogF(&quot;Checking stack height with exec = %p.\n&quot;, exec);
 538     slowPathLog(&quot;CodeBlock = &quot;, codeBlock, &quot;\n&quot;);
 539     if (codeBlock) {
 540         slowPathLogF(&quot;Num callee registers = %u.\n&quot;, codeBlock-&gt;numCalleeLocals());
 541         slowPathLogF(&quot;Num vars = %u.\n&quot;, codeBlock-&gt;numVars());
 542     }
 543     slowPathLogF(&quot;Current OS stack end is at %p.\n&quot;, vm.softStackLimit());
 544 #if ENABLE(C_LOOP)
 545     slowPathLogF(&quot;Current C Loop stack end is at %p.\n&quot;, vm.cloopStackLimit());
 546 #endif
 547 
 548     // If the stack check succeeds and we don&#39;t need to throw the error, then
 549     // we&#39;ll return 0 instead. The prologue will check for a non-zero value
 550     // when determining whether to set the callFrame or not.
 551 
 552     // For JIT enabled builds which uses the C stack, the stack is not growable.
 553     // Hence, if we get here, then we know a stack overflow is imminent. So, just
 554     // throw the StackOverflowError unconditionally.
 555 #if ENABLE(C_LOOP)
 556     Register* topOfFrame = exec-&gt;topOfFrame();
 557     if (LIKELY(topOfFrame &lt; reinterpret_cast&lt;Register*&gt;(exec))) {
 558         ASSERT(!vm.interpreter-&gt;cloopStack().containsAddress(topOfFrame));
 559         if (LIKELY(vm.ensureStackCapacityFor(topOfFrame)))
 560             LLINT_RETURN_TWO(pc, 0);
 561     }
 562 #endif
 563 
 564     exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
 565     ErrorHandlingScope errorScope(vm);
 566     throwStackOverflowError(exec, throwScope);
 567     pc = returnToThrow(exec);
 568     LLINT_RETURN_TWO(pc, exec);
 569 }
 570 
 571 LLINT_SLOW_PATH_DECL(slow_path_new_object)
 572 {
 573     LLINT_BEGIN();
 574     auto bytecode = pc-&gt;as&lt;OpNewObject&gt;();
 575     auto&amp; metadata = bytecode.metadata(exec);
 576     LLINT_RETURN(constructEmptyObject(exec, metadata.m_objectAllocationProfile.structure()));
 577 }
 578 
 579 LLINT_SLOW_PATH_DECL(slow_path_new_array)
 580 {
 581     LLINT_BEGIN();
 582     auto bytecode = pc-&gt;as&lt;OpNewArray&gt;();
 583     auto&amp; metadata = bytecode.metadata(exec);
 584     LLINT_RETURN(constructArrayNegativeIndexed(exec, &amp;metadata.m_arrayAllocationProfile, bitwise_cast&lt;JSValue*&gt;(&amp;exec-&gt;uncheckedR(bytecode.m_argv)), bytecode.m_argc));
 585 }
 586 
 587 LLINT_SLOW_PATH_DECL(slow_path_new_array_with_size)
 588 {
 589     LLINT_BEGIN();
 590     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSize&gt;();
 591     auto&amp; metadata = bytecode.metadata(exec);
 592     LLINT_RETURN(constructArrayWithSizeQuirk(exec, &amp;metadata.m_arrayAllocationProfile, exec-&gt;lexicalGlobalObject(), getOperand(exec, bytecode.m_length)));
 593 }
 594 
 595 LLINT_SLOW_PATH_DECL(slow_path_new_regexp)
 596 {
 597     LLINT_BEGIN();
 598     auto bytecode = pc-&gt;as&lt;OpNewRegexp&gt;();
 599     RegExp* regExp = jsCast&lt;RegExp*&gt;(getOperand(exec, bytecode.m_regexp));
 600     ASSERT(regExp-&gt;isValid());
 601     LLINT_RETURN(RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regExp));
 602 }
 603 
 604 LLINT_SLOW_PATH_DECL(slow_path_instanceof)
 605 {
 606     LLINT_BEGIN();
 607     auto bytecode = pc-&gt;as&lt;OpInstanceof&gt;();
 608     JSValue value = getOperand(exec, bytecode.m_value);
 609     JSValue proto = getOperand(exec, bytecode.m_prototype);
 610     LLINT_RETURN(jsBoolean(JSObject::defaultHasInstance(exec, value, proto)));
 611 }
 612 
 613 LLINT_SLOW_PATH_DECL(slow_path_instanceof_custom)
 614 {
 615     LLINT_BEGIN();
 616 
 617     auto bytecode = pc-&gt;as&lt;OpInstanceofCustom&gt;();
 618     JSValue value = getOperand(exec, bytecode.m_value);
 619     JSValue constructor = getOperand(exec, bytecode.m_constructor);
 620     JSValue hasInstanceValue = getOperand(exec, bytecode.m_hasInstanceValue);
 621 
 622     ASSERT(constructor.isObject());
 623     ASSERT(hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction() || !constructor.getObject()-&gt;structure(vm)-&gt;typeInfo().implementsDefaultHasInstance());
 624 
 625     JSValue result = jsBoolean(constructor.getObject()-&gt;hasInstance(exec, value, hasInstanceValue));
 626     LLINT_RETURN(result);
 627 }
 628 
 629 LLINT_SLOW_PATH_DECL(slow_path_try_get_by_id)
 630 {
 631     LLINT_BEGIN();
 632     auto bytecode = pc-&gt;as&lt;OpTryGetById&gt;();
 633     CodeBlock* codeBlock = exec-&gt;codeBlock();
 634     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 635     JSValue baseValue = getOperand(exec, bytecode.m_base);
 636     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::VMInquiry);
 637 
 638     baseValue.getPropertySlot(exec, ident, slot);
 639     JSValue result = slot.getPureResult();
 640 
 641     LLINT_RETURN_PROFILED(result);
 642 }
 643 
 644 LLINT_SLOW_PATH_DECL(slow_path_get_by_id_direct)
 645 {
 646     LLINT_BEGIN();
 647     auto bytecode = pc-&gt;as&lt;OpGetByIdDirect&gt;();
 648     CodeBlock* codeBlock = exec-&gt;codeBlock();
 649     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 650     JSValue baseValue = getOperand(exec, bytecode.m_base);
 651     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::GetOwnProperty);
 652 
 653     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
 654     LLINT_CHECK_EXCEPTION();
 655     JSValue result = found ? slot.getValue(exec, ident) : jsUndefined();
 656     LLINT_CHECK_EXCEPTION();
 657 
 658     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; slot.isCacheable()) {
 659         auto&amp; metadata = bytecode.metadata(exec);
 660         {
 661             StructureID oldStructureID = metadata.m_structureID;
 662             if (oldStructureID) {
 663                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 664                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 665 
 666                 if (Structure::shouldConvertToPolyProto(a, b)) {
 667                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 668                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 669                 }
 670             }
 671         }
 672 
 673         JSCell* baseCell = baseValue.asCell();
 674         Structure* structure = baseCell-&gt;structure(vm);
 675         if (slot.isValue()) {
 676             // Start out by clearing out the old cache.
 677             metadata.m_structureID = 0;
 678             metadata.m_offset = 0;
 679 
<a name="8" id="anc8"></a><span class="line-modified"> 680             if (structure-&gt;propertyAccessesAreCacheable()</span>
<span class="line-modified"> 681                 &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>




 682                 vm.heap.writeBarrier(codeBlock);
<a name="9" id="anc9"></a><span class="line-removed"> 683 </span>
<span class="line-removed"> 684                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed"> 685 </span>
<span class="line-removed"> 686                 metadata.m_structureID = structure-&gt;id();</span>
<span class="line-removed"> 687                 metadata.m_offset = slot.cachedOffset();</span>
 688             }
 689         }
 690     }
 691 
 692     LLINT_RETURN_PROFILED(result);
 693 }
 694 
 695 
 696 static void setupGetByIdPrototypeCache(ExecState* exec, VM&amp; vm, const Instruction* pc, OpGetById::Metadata&amp; metadata, JSCell* baseCell, PropertySlot&amp; slot, const Identifier&amp; ident)
 697 {
 698     CodeBlock* codeBlock = exec-&gt;codeBlock();
 699     Structure* structure = baseCell-&gt;structure(vm);
 700 
 701     if (structure-&gt;typeInfo().prohibitsPropertyCaching())
 702         return;
 703 
 704     if (structure-&gt;needImpurePropertyWatchpoint())
 705         return;
 706 
 707     if (structure-&gt;isDictionary()) {
 708         if (structure-&gt;hasBeenFlattenedBefore())
 709             return;
 710         structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
 711     }
 712 
 713     ObjectPropertyConditionSet conditions;
 714     if (slot.isUnset())
 715         conditions = generateConditionsForPropertyMiss(vm, codeBlock, exec, structure, ident.impl());
 716     else
 717         conditions = generateConditionsForPrototypePropertyHit(vm, codeBlock, exec, structure, slot.slotBase(), ident.impl());
 718 
 719     if (!conditions.isValid())
 720         return;
 721 
<a name="10" id="anc10"></a>
 722     PropertyOffset offset = invalidOffset;
 723     CodeBlock::StructureWatchpointMap&amp; watchpointMap = codeBlock-&gt;llintGetByIdWatchpointMap();
<a name="11" id="anc11"></a><span class="line-modified"> 724     Bag&lt;LLIntPrototypeLoadAdaptiveStructureWatchpoint&gt; watchpoints;</span>

 725     for (ObjectPropertyCondition condition : conditions) {
 726         if (!condition.isWatchable())
 727             return;
 728         if (condition.condition().kind() == PropertyCondition::Presence)
 729             offset = condition.condition().offset();
<a name="12" id="anc12"></a><span class="line-modified"> 730         watchpoints.add(condition, metadata)-&gt;install(vm);</span>

 731     }
 732 
 733     ASSERT((offset == invalidOffset) == slot.isUnset());
<a name="13" id="anc13"></a><span class="line-modified"> 734     auto result = watchpointMap.add(std::make_tuple(structure, pc), WTFMove(watchpoints));</span>
 735     ASSERT_UNUSED(result, result.isNewEntry);
 736 
<a name="14" id="anc14"></a><span class="line-modified"> 737     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-modified"> 738 </span>
<span class="line-modified"> 739     if (slot.isUnset()) {</span>
<span class="line-modified"> 740         metadata.m_mode = GetByIdMode::Unset;</span>
<span class="line-modified"> 741         metadata.m_modeMetadata.unsetMode.structureID = structure-&gt;id();</span>
<span class="line-modified"> 742         return;</span>


 743     }
<a name="15" id="anc15"></a><span class="line-modified"> 744     ASSERT(slot.isValue());</span>
<span class="line-removed"> 745 </span>
<span class="line-removed"> 746     metadata.m_mode = GetByIdMode::ProtoLoad;</span>
<span class="line-removed"> 747     metadata.m_modeMetadata.protoLoadMode.structureID = structure-&gt;id();</span>
<span class="line-removed"> 748     metadata.m_modeMetadata.protoLoadMode.cachedOffset = offset;</span>
<span class="line-removed"> 749     metadata.m_modeMetadata.protoLoadMode.cachedSlot = slot.slotBase();</span>
<span class="line-removed"> 750     // We know that this pointer will remain valid because it will be cleared by either a watchpoint fire or</span>
<span class="line-removed"> 751     // during GC when we clear the LLInt caches.</span>
<span class="line-removed"> 752     metadata.m_modeMetadata.protoLoadMode.cachedSlot = slot.slotBase();</span>
 753 }
 754 
 755 
 756 LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
 757 {
 758     LLINT_BEGIN();
 759     auto bytecode = pc-&gt;as&lt;OpGetById&gt;();
 760     auto&amp; metadata = bytecode.metadata(exec);
 761     CodeBlock* codeBlock = exec-&gt;codeBlock();
 762     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 763     JSValue baseValue = getOperand(exec, bytecode.m_base);
 764     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::Get);
 765 
 766     JSValue result = baseValue.get(exec, ident, slot);
 767     LLINT_CHECK_EXCEPTION();
 768     exec-&gt;uncheckedR(bytecode.m_dst) = result;
 769 
 770     if (!LLINT_ALWAYS_ACCESS_SLOW
 771         &amp;&amp; baseValue.isCell()
 772         &amp;&amp; slot.isCacheable()) {
 773         {
 774             StructureID oldStructureID;
<a name="16" id="anc16"></a><span class="line-modified"> 775             auto mode = metadata.m_mode;</span>
<span class="line-removed"> 776             switch (mode) {</span>
 777             case GetByIdMode::Default:
 778                 oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
 779                 break;
 780             case GetByIdMode::Unset:
 781                 oldStructureID = metadata.m_modeMetadata.unsetMode.structureID;
 782                 break;
 783             case GetByIdMode::ProtoLoad:
 784                 oldStructureID = metadata.m_modeMetadata.protoLoadMode.structureID;
 785                 break;
 786             default:
 787                 oldStructureID = 0;
 788             }
 789             if (oldStructureID) {
 790                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 791                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 792 
 793                 if (Structure::shouldConvertToPolyProto(a, b)) {
 794                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 795                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 796                 }
 797             }
 798         }
 799 
 800         JSCell* baseCell = baseValue.asCell();
 801         Structure* structure = baseCell-&gt;structure(vm);
 802         if (slot.isValue() &amp;&amp; slot.slotBase() == baseValue) {
<a name="17" id="anc17"></a>
 803             // Start out by clearing out the old cache.
<a name="18" id="anc18"></a><span class="line-modified"> 804             metadata.m_mode = GetByIdMode::Default;</span>
<span class="line-removed"> 805             metadata.m_modeMetadata.defaultMode.structureID = 0;</span>
<span class="line-removed"> 806             metadata.m_modeMetadata.defaultMode.cachedOffset = 0;</span>
 807 
 808             // Prevent the prototype cache from ever happening.
<a name="19" id="anc19"></a><span class="line-modified"> 809             metadata.m_hitCountForLLIntCaching = 0;</span>
<span class="line-removed"> 810 </span>
<span class="line-removed"> 811             if (structure-&gt;propertyAccessesAreCacheable()</span>
<span class="line-removed"> 812                 &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>
<span class="line-removed"> 813                 vm.heap.writeBarrier(codeBlock);</span>
<span class="line-removed"> 814 </span>
<span class="line-removed"> 815                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
 816 
<a name="20" id="anc20"></a>
 817                 metadata.m_modeMetadata.defaultMode.structureID = structure-&gt;id();
 818                 metadata.m_modeMetadata.defaultMode.cachedOffset = slot.cachedOffset();
<a name="21" id="anc21"></a>
 819             }
<a name="22" id="anc22"></a><span class="line-modified"> 820         } else if (UNLIKELY(metadata.m_hitCountForLLIntCaching &amp;&amp; (slot.isValue() || slot.isUnset()))) {</span>
 821             ASSERT(slot.slotBase() != baseValue);
 822 
<a name="23" id="anc23"></a><span class="line-modified"> 823             if (!(--metadata.m_hitCountForLLIntCaching))</span>
 824                 setupGetByIdPrototypeCache(exec, vm, pc, metadata, baseCell, slot, ident);
 825         }
<a name="24" id="anc24"></a><span class="line-modified"> 826     } else if (!LLINT_ALWAYS_ACCESS_SLOW</span>
<span class="line-modified"> 827         &amp;&amp; isJSArray(baseValue)</span>
<span class="line-modified"> 828         &amp;&amp; ident == vm.propertyNames-&gt;length) {</span>
<span class="line-modified"> 829         metadata.m_mode = GetByIdMode::ArrayLength;</span>
<span class="line-modified"> 830         new (&amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile) ArrayProfile(codeBlock-&gt;bytecodeOffset(pc));</span>
<span class="line-modified"> 831         metadata.m_modeMetadata.arrayLengthMode.arrayProfile.observeStructure(baseValue.asCell()-&gt;structure(vm));</span>
<span class="line-modified"> 832 </span>
<span class="line-removed"> 833         // Prevent the prototype cache from ever happening.</span>
<span class="line-removed"> 834         metadata.m_hitCountForLLIntCaching = 0;</span>
 835     }
 836 
 837     LLINT_PROFILE_VALUE(result);
 838     LLINT_END();
 839 }
 840 
 841 LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
 842 {
 843     LLINT_BEGIN();
 844     auto bytecode = pc-&gt;as&lt;OpPutById&gt;();
 845     auto&amp; metadata = bytecode.metadata(exec);
 846     CodeBlock* codeBlock = exec-&gt;codeBlock();
 847     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 848 
 849     JSValue baseValue = getOperand(exec, bytecode.m_base);
 850     PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
 851     if (bytecode.m_flags &amp; PutByIdIsDirect)
 852         CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, getOperand(exec, bytecode.m_value), slot);
 853     else
 854         baseValue.putInline(exec, ident, getOperand(exec, bytecode.m_value), slot);
 855     LLINT_CHECK_EXCEPTION();
 856 
 857     if (!LLINT_ALWAYS_ACCESS_SLOW
 858         &amp;&amp; baseValue.isCell()
 859         &amp;&amp; slot.isCacheablePut()) {
 860 
 861         {
 862             StructureID oldStructureID = metadata.m_oldStructureID;
 863             if (oldStructureID) {
 864                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 865                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 866                 if (slot.type() == PutPropertySlot::NewProperty)
 867                     b = b-&gt;previousID();
 868 
 869                 if (Structure::shouldConvertToPolyProto(a, b)) {
 870                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 871                     b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 872                 }
 873             }
 874         }
 875 
 876         // Start out by clearing out the old cache.
 877         metadata.m_oldStructureID = 0;
 878         metadata.m_offset = 0;
 879         metadata.m_newStructureID = 0;
 880         metadata.m_structureChain.clear();
 881 
 882         JSCell* baseCell = baseValue.asCell();
 883         Structure* structure = baseCell-&gt;structure(vm);
 884 
<a name="25" id="anc25"></a><span class="line-modified"> 885         if (!structure-&gt;isUncacheableDictionary()</span>
<span class="line-removed"> 886             &amp;&amp; !structure-&gt;typeInfo().prohibitsPropertyCaching()</span>
<span class="line-removed"> 887             &amp;&amp; baseCell == slot.base()) {</span>
<span class="line-removed"> 888 </span>
<span class="line-removed"> 889             vm.heap.writeBarrier(codeBlock);</span>
<span class="line-removed"> 890 </span>
 891             if (slot.type() == PutPropertySlot::NewProperty) {
 892                 GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
<a name="26" id="anc26"></a><span class="line-removed"> 893 </span>
 894                 if (!structure-&gt;isDictionary() &amp;&amp; structure-&gt;previousID()-&gt;outOfLineCapacity() == structure-&gt;outOfLineCapacity()) {
 895                     ASSERT(structure-&gt;previousID()-&gt;transitionWatchpointSetHasBeenInvalidated());
 896 
 897                     bool sawPolyProto = false;
 898                     auto result = normalizePrototypeChain(exec, baseCell, sawPolyProto);
 899                     if (result != InvalidPrototypeChain &amp;&amp; !sawPolyProto) {
 900                         ASSERT(structure-&gt;previousID()-&gt;isObject());
 901                         metadata.m_oldStructureID = structure-&gt;previousID()-&gt;id();
 902                         metadata.m_offset = slot.cachedOffset();
 903                         metadata.m_newStructureID = structure-&gt;id();
 904                         if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {
 905                             StructureChain* chain = structure-&gt;prototypeChain(exec, asObject(baseCell));
 906                             ASSERT(chain);
 907                             metadata.m_structureChain.set(vm, codeBlock, chain);
 908                         }
<a name="27" id="anc27"></a>
 909                     }
 910                 }
 911             } else {
 912                 structure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());
<a name="28" id="anc28"></a><span class="line-modified"> 913                 metadata.m_oldStructureID = structure-&gt;id();</span>
<span class="line-modified"> 914                 metadata.m_offset = slot.cachedOffset();</span>




 915             }
 916         }
 917     }
 918 
 919     LLINT_END();
 920 }
 921 
 922 LLINT_SLOW_PATH_DECL(slow_path_del_by_id)
 923 {
 924     LLINT_BEGIN();
 925     auto bytecode = pc-&gt;as&lt;OpDelById&gt;();
 926     CodeBlock* codeBlock = exec-&gt;codeBlock();
 927     JSObject* baseObject = getOperand(exec, bytecode.m_base).toObject(exec);
 928     LLINT_CHECK_EXCEPTION();
 929     bool couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, codeBlock-&gt;identifier(bytecode.m_property));
 930     LLINT_CHECK_EXCEPTION();
 931     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
 932         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));
 933     LLINT_RETURN(jsBoolean(couldDelete));
 934 }
 935 
 936 static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, ExecState* exec, OpGetByVal bytecode)
 937 {
 938     JSValue baseValue = getOperand(exec, bytecode.m_base);
 939     JSValue subscript = getOperand(exec, bytecode.m_property);
 940     auto scope = DECLARE_THROW_SCOPE(vm);
 941 
 942     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
 943         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
 944         if (JSCell::canUseFastGetOwnProperty(structure)) {
<a name="29" id="anc29"></a><span class="line-modified"> 945             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified"> 946                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>


 947                     return result;
 948             }
 949         }
 950     }
 951 
 952     if (subscript.isUInt32()) {
 953         uint32_t i = subscript.asUInt32();
 954         auto&amp; metadata = bytecode.metadata(exec);
 955         ArrayProfile* arrayProfile = &amp;metadata.m_arrayProfile;
 956 
 957         if (isJSString(baseValue)) {
 958             if (asString(baseValue)-&gt;canGetIndex(i)) {
 959                 scope.release();
 960                 return asString(baseValue)-&gt;getIndex(exec, i);
 961             }
 962             arrayProfile-&gt;setOutOfBounds();
 963         } else if (baseValue.isObject()) {
 964             JSObject* object = asObject(baseValue);
 965             if (object-&gt;canGetIndexQuickly(i))
 966                 return object-&gt;getIndexQuickly(i);
 967 
 968             bool skipMarkingOutOfBounds = false;
 969 
 970             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &lt; object-&gt;butterfly()-&gt;publicLength()) {
 971                 // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
 972                 // https://bugs.webkit.org/show_bug.cgi?id=182940
 973                 auto* globalObject = object-&gt;globalObject(vm);
 974                 skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
 975             }
 976 
 977             if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i))
 978                 arrayProfile-&gt;setOutOfBounds();
 979         }
 980 
 981         scope.release();
 982         return baseValue.get(exec, i);
 983     }
 984 
 985     baseValue.requireObjectCoercible(exec);
 986     RETURN_IF_EXCEPTION(scope, JSValue());
 987     auto property = subscript.toPropertyKey(exec);
 988     RETURN_IF_EXCEPTION(scope, JSValue());
 989     scope.release();
 990     return baseValue.get(exec, property);
 991 }
 992 
 993 LLINT_SLOW_PATH_DECL(slow_path_get_by_val)
 994 {
 995     LLINT_BEGIN();
 996     auto bytecode = pc-&gt;as&lt;OpGetByVal&gt;();
 997     LLINT_RETURN_PROFILED(getByVal(vm, exec, bytecode));
 998 }
 999 
1000 LLINT_SLOW_PATH_DECL(slow_path_put_by_val)
1001 {
1002     LLINT_BEGIN();
1003 
1004     auto bytecode = pc-&gt;as&lt;OpPutByVal&gt;();
1005     JSValue baseValue = getOperand(exec, bytecode.m_base);
1006     JSValue subscript = getOperand(exec, bytecode.m_property);
1007     JSValue value = getOperand(exec, bytecode.m_value);
1008     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();
1009 
1010     if (LIKELY(subscript.isUInt32())) {
1011         uint32_t i = subscript.asUInt32();
1012         if (baseValue.isObject()) {
1013             JSObject* object = asObject(baseValue);
<a name="30" id="anc30"></a><span class="line-modified">1014             if (object-&gt;canSetIndexQuickly(i))</span>
1015                 object-&gt;setIndexQuickly(vm, i, value);
1016             else
1017                 object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, i, value, isStrictMode);
1018             LLINT_END();
1019         }
1020         baseValue.putByIndex(exec, i, value, isStrictMode);
1021         LLINT_END();
1022     }
1023 
1024     auto property = subscript.toPropertyKey(exec);
1025     LLINT_CHECK_EXCEPTION();
1026     PutPropertySlot slot(baseValue, isStrictMode);
1027     baseValue.put(exec, property, value, slot);
1028     LLINT_END();
1029 }
1030 
1031 LLINT_SLOW_PATH_DECL(slow_path_put_by_val_direct)
1032 {
1033     LLINT_BEGIN();
1034 
1035     auto bytecode = pc-&gt;as&lt;OpPutByValDirect&gt;();
1036     JSValue baseValue = getOperand(exec, bytecode.m_base);
1037     JSValue subscript = getOperand(exec, bytecode.m_property);
1038     JSValue value = getOperand(exec, bytecode.m_value);
1039     RELEASE_ASSERT(baseValue.isObject());
1040     JSObject* baseObject = asObject(baseValue);
1041     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();
1042     if (LIKELY(subscript.isUInt32())) {
1043         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
1044         ASSERT(isIndex(subscript.asUInt32()));
1045         baseObject-&gt;putDirectIndex(exec, subscript.asUInt32(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
1046         LLINT_END();
1047     }
1048 
1049     if (subscript.isDouble()) {
1050         double subscriptAsDouble = subscript.asDouble();
1051         uint32_t subscriptAsUInt32 = static_cast&lt;uint32_t&gt;(subscriptAsDouble);
1052         if (subscriptAsDouble == subscriptAsUInt32 &amp;&amp; isIndex(subscriptAsUInt32)) {
1053             baseObject-&gt;putDirectIndex(exec, subscriptAsUInt32, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
1054             LLINT_END();
1055         }
1056     }
1057 
1058     // Don&#39;t put to an object if toString threw an exception.
1059     auto property = subscript.toPropertyKey(exec);
1060     if (UNLIKELY(throwScope.exception()))
1061         LLINT_END();
1062 
1063     if (Optional&lt;uint32_t&gt; index = parseIndex(property))
1064         baseObject-&gt;putDirectIndex(exec, index.value(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
1065     else {
1066         PutPropertySlot slot(baseObject, isStrictMode);
1067         CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, property, value, slot);
1068     }
1069     LLINT_END();
1070 }
1071 
1072 LLINT_SLOW_PATH_DECL(slow_path_del_by_val)
1073 {
1074     LLINT_BEGIN();
1075     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
1076     JSValue baseValue = getOperand(exec, bytecode.m_base);
1077     JSObject* baseObject = baseValue.toObject(exec);
1078     LLINT_CHECK_EXCEPTION();
1079 
1080     JSValue subscript = getOperand(exec, bytecode.m_property);
1081 
1082     bool couldDelete;
1083 
1084     uint32_t i;
1085     if (subscript.getUInt32(i))
1086         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);
1087     else {
1088         LLINT_CHECK_EXCEPTION();
1089         auto property = subscript.toPropertyKey(exec);
1090         LLINT_CHECK_EXCEPTION();
1091         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);
1092     }
1093     LLINT_CHECK_EXCEPTION();
1094 
1095     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
1096         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));
1097 
1098     LLINT_RETURN(jsBoolean(couldDelete));
1099 }
1100 
1101 LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_id)
1102 {
1103     LLINT_BEGIN();
1104     auto bytecode = pc-&gt;as&lt;OpPutGetterById&gt;();
1105     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());
1106     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));
1107 
1108     unsigned options = bytecode.m_attributes;
1109 
1110     JSValue getter = getNonConstantOperand(exec, bytecode.m_accessor);
1111     ASSERT(getter.isObject());
1112 
1113     baseObj-&gt;putGetter(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), asObject(getter), options);
1114     LLINT_END();
1115 }
1116 
1117 LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_id)
1118 {
1119     LLINT_BEGIN();
1120     auto bytecode = pc-&gt;as&lt;OpPutSetterById&gt;();
1121     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());
1122     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));
1123 
1124     unsigned options = bytecode.m_attributes;
1125 
1126     JSValue setter = getNonConstantOperand(exec, bytecode.m_accessor);
1127     ASSERT(setter.isObject());
1128 
1129     baseObj-&gt;putSetter(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), asObject(setter), options);
1130     LLINT_END();
1131 }
1132 
1133 LLINT_SLOW_PATH_DECL(slow_path_put_getter_setter_by_id)
1134 {
1135     LLINT_BEGIN();
1136     auto bytecode = pc-&gt;as&lt;OpPutGetterSetterById&gt;();
1137     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());
1138     JSObject* baseObject = asObject(getNonConstantOperand(exec, bytecode.m_base));
1139 
1140     JSValue getter = getNonConstantOperand(exec, bytecode.m_getter);
1141     JSValue setter = getNonConstantOperand(exec, bytecode.m_setter);
1142     ASSERT(getter.isObject() || setter.isObject());
1143     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
1144 
1145     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), accessor, bytecode.m_attributes);
1146     LLINT_END();
1147 }
1148 
1149 LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_val)
1150 {
1151     LLINT_BEGIN();
1152     auto bytecode = pc-&gt;as&lt;OpPutGetterByVal&gt;();
1153     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());
1154     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));
1155     JSValue subscript = getOperand(exec, bytecode.m_property);
1156 
1157     unsigned options = bytecode.m_attributes;
1158 
1159     JSValue getter = getNonConstantOperand(exec, bytecode.m_accessor);
1160     ASSERT(getter.isObject());
1161 
1162     auto property = subscript.toPropertyKey(exec);
1163     LLINT_CHECK_EXCEPTION();
1164 
1165     baseObj-&gt;putGetter(exec, property, asObject(getter), options);
1166     LLINT_END();
1167 }
1168 
1169 LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_val)
1170 {
1171     LLINT_BEGIN();
1172     auto bytecode = pc-&gt;as&lt;OpPutSetterByVal&gt;();
1173     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());
1174     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));
1175     JSValue subscript = getOperand(exec, bytecode.m_property);
1176 
1177     unsigned options = bytecode.m_attributes;
1178 
1179     JSValue setter = getNonConstantOperand(exec, bytecode.m_accessor);
1180     ASSERT(setter.isObject());
1181 
1182     auto property = subscript.toPropertyKey(exec);
1183     LLINT_CHECK_EXCEPTION();
1184 
1185     baseObj-&gt;putSetter(exec, property, asObject(setter), options);
1186     LLINT_END();
1187 }
1188 
1189 LLINT_SLOW_PATH_DECL(slow_path_jtrue)
1190 {
1191     LLINT_BEGIN();
1192     auto bytecode = pc-&gt;as&lt;OpJtrue&gt;();
1193     LLINT_BRANCH(getOperand(exec, bytecode.m_condition).toBoolean(exec));
1194 }
1195 
1196 LLINT_SLOW_PATH_DECL(slow_path_jfalse)
1197 {
1198     LLINT_BEGIN();
1199     auto bytecode = pc-&gt;as&lt;OpJfalse&gt;();
1200     LLINT_BRANCH(!getOperand(exec, bytecode.m_condition).toBoolean(exec));
1201 }
1202 
1203 LLINT_SLOW_PATH_DECL(slow_path_jless)
1204 {
1205     LLINT_BEGIN();
1206     auto bytecode = pc-&gt;as&lt;OpJless&gt;();
1207     LLINT_BRANCH(jsLess&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1208 }
1209 
1210 LLINT_SLOW_PATH_DECL(slow_path_jnless)
1211 {
1212     LLINT_BEGIN();
1213     auto bytecode = pc-&gt;as&lt;OpJnless&gt;();
1214     LLINT_BRANCH(!jsLess&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1215 }
1216 
1217 LLINT_SLOW_PATH_DECL(slow_path_jgreater)
1218 {
1219     LLINT_BEGIN();
1220     auto bytecode = pc-&gt;as&lt;OpJgreater&gt;();
1221     LLINT_BRANCH(jsLess&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));
1222 }
1223 
1224 LLINT_SLOW_PATH_DECL(slow_path_jngreater)
1225 {
1226     LLINT_BEGIN();
1227     auto bytecode = pc-&gt;as&lt;OpJngreater&gt;();
1228     LLINT_BRANCH(!jsLess&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));
1229 }
1230 
1231 LLINT_SLOW_PATH_DECL(slow_path_jlesseq)
1232 {
1233     LLINT_BEGIN();
1234     auto bytecode = pc-&gt;as&lt;OpJlesseq&gt;();
1235     LLINT_BRANCH(jsLessEq&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1236 }
1237 
1238 LLINT_SLOW_PATH_DECL(slow_path_jnlesseq)
1239 {
1240     LLINT_BEGIN();
1241     auto bytecode = pc-&gt;as&lt;OpJnlesseq&gt;();
1242     LLINT_BRANCH(!jsLessEq&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1243 }
1244 
1245 LLINT_SLOW_PATH_DECL(slow_path_jgreatereq)
1246 {
1247     LLINT_BEGIN();
1248     auto bytecode = pc-&gt;as&lt;OpJgreatereq&gt;();
1249     LLINT_BRANCH(jsLessEq&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));
1250 }
1251 
1252 LLINT_SLOW_PATH_DECL(slow_path_jngreatereq)
1253 {
1254     LLINT_BEGIN();
1255     auto bytecode = pc-&gt;as&lt;OpJngreatereq&gt;();
1256     LLINT_BRANCH(!jsLessEq&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));
1257 }
1258 
1259 LLINT_SLOW_PATH_DECL(slow_path_jeq)
1260 {
1261     LLINT_BEGIN();
1262     auto bytecode = pc-&gt;as&lt;OpJeq&gt;();
1263     LLINT_BRANCH(JSValue::equal(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1264 }
1265 
1266 LLINT_SLOW_PATH_DECL(slow_path_jneq)
1267 {
1268     LLINT_BEGIN();
1269     auto bytecode = pc-&gt;as&lt;OpJneq&gt;();
1270     LLINT_BRANCH(!JSValue::equal(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1271 }
1272 
1273 LLINT_SLOW_PATH_DECL(slow_path_jstricteq)
1274 {
1275     LLINT_BEGIN();
1276     auto bytecode = pc-&gt;as&lt;OpJstricteq&gt;();
1277     LLINT_BRANCH(JSValue::strictEqual(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1278 }
1279 
1280 LLINT_SLOW_PATH_DECL(slow_path_jnstricteq)
1281 {
1282     LLINT_BEGIN();
1283     auto bytecode = pc-&gt;as&lt;OpJnstricteq&gt;();
1284     LLINT_BRANCH(!JSValue::strictEqual(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));
1285 }
1286 
1287 LLINT_SLOW_PATH_DECL(slow_path_switch_imm)
1288 {
1289     LLINT_BEGIN();
1290     auto bytecode = pc-&gt;as&lt;OpSwitchImm&gt;();
1291     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);
1292     ASSERT(scrutinee.isDouble());
1293     double value = scrutinee.asDouble();
1294     int32_t intValue = static_cast&lt;int32_t&gt;(value);
1295     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1296     if (value == intValue) {
1297         CodeBlock* codeBlock = exec-&gt;codeBlock();
1298         JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue(intValue, defaultOffset));
1299     } else
1300         JUMP_TO(defaultOffset);
1301     LLINT_END();
1302 }
1303 
1304 LLINT_SLOW_PATH_DECL(slow_path_switch_char)
1305 {
1306     LLINT_BEGIN();
1307     auto bytecode = pc-&gt;as&lt;OpSwitchChar&gt;();
1308     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);
1309     ASSERT(scrutinee.isString());
1310     JSString* string = asString(scrutinee);
1311     ASSERT(string-&gt;length() == 1);
1312     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1313     StringImpl* impl = string-&gt;value(exec).impl();
1314     CodeBlock* codeBlock = exec-&gt;codeBlock();
1315     JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue((*impl)[0], defaultOffset));
1316     LLINT_END();
1317 }
1318 
1319 LLINT_SLOW_PATH_DECL(slow_path_switch_string)
1320 {
1321     LLINT_BEGIN();
1322     auto bytecode = pc-&gt;as&lt;OpSwitchString&gt;();
1323     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);
1324     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1325     if (!scrutinee.isString())
1326         JUMP_TO(defaultOffset);
1327     else {
<a name="31" id="anc31"></a>



1328         CodeBlock* codeBlock = exec-&gt;codeBlock();
<a name="32" id="anc32"></a><span class="line-modified">1329         JUMP_TO(codeBlock-&gt;stringSwitchJumpTable(bytecode.m_tableIndex).offsetForValue(asString(scrutinee)-&gt;value(exec).impl(), defaultOffset));</span>

1330     }
1331     LLINT_END();
1332 }
1333 
1334 LLINT_SLOW_PATH_DECL(slow_path_new_func)
1335 {
1336     LLINT_BEGIN();
1337     auto bytecode = pc-&gt;as&lt;OpNewFunc&gt;();
1338     CodeBlock* codeBlock = exec-&gt;codeBlock();
1339     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1340     slowPathLogF(&quot;Creating function!\n&quot;);
1341     LLINT_RETURN(JSFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1342 }
1343 
1344 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func)
1345 {
1346     LLINT_BEGIN();
1347     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFunc&gt;();
1348     CodeBlock* codeBlock = exec-&gt;codeBlock();
1349     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1350     slowPathLogF(&quot;Creating function!\n&quot;);
1351     LLINT_RETURN(JSGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1352 }
1353 
1354 LLINT_SLOW_PATH_DECL(slow_path_new_async_func)
1355 {
1356     LLINT_BEGIN();
1357     auto bytecode = pc-&gt;as&lt;OpNewAsyncFunc&gt;();
1358     CodeBlock* codeBlock = exec-&gt;codeBlock();
1359     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1360     slowPathLogF(&quot;Creating async function!\n&quot;);
1361     LLINT_RETURN(JSAsyncFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1362 }
1363 
1364 LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func)
1365 {
1366     LLINT_BEGIN();
1367     auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFunc&gt;();
1368     CodeBlock* codeBlock = exec-&gt;codeBlock();
1369     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1370     slowPathLogF(&quot;Creating async generator function!\n&quot;);
1371     LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1372 }
1373 
1374 LLINT_SLOW_PATH_DECL(slow_path_new_func_exp)
1375 {
1376     LLINT_BEGIN();
1377 
1378     auto bytecode = pc-&gt;as&lt;OpNewFuncExp&gt;();
1379     CodeBlock* codeBlock = exec-&gt;codeBlock();
1380     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1381     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1382 
1383     LLINT_RETURN(JSFunction::create(vm, executable, scope));
1384 }
1385 
1386 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func_exp)
1387 {
1388     LLINT_BEGIN();
1389 
1390     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFuncExp&gt;();
1391     CodeBlock* codeBlock = exec-&gt;codeBlock();
1392     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1393     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1394 
1395     LLINT_RETURN(JSGeneratorFunction::create(vm, executable, scope));
1396 }
1397 
1398 LLINT_SLOW_PATH_DECL(slow_path_new_async_func_exp)
1399 {
1400     LLINT_BEGIN();
1401 
1402     auto bytecode = pc-&gt;as&lt;OpNewAsyncFuncExp&gt;();
1403     CodeBlock* codeBlock = exec-&gt;codeBlock();
1404     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1405     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1406 
1407     LLINT_RETURN(JSAsyncFunction::create(vm, executable, scope));
1408 }
1409 
1410 LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func_exp)
1411 {
1412     LLINT_BEGIN();
1413 
1414     auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFuncExp&gt;();
1415     CodeBlock* codeBlock = exec-&gt;codeBlock();
1416     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1417     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1418 
1419     LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, executable, scope));
1420 }
1421 
1422 LLINT_SLOW_PATH_DECL(slow_path_set_function_name)
1423 {
1424     LLINT_BEGIN();
1425     auto bytecode = pc-&gt;as&lt;OpSetFunctionName&gt;();
1426     JSFunction* func = jsCast&lt;JSFunction*&gt;(getNonConstantOperand(exec, bytecode.m_function));
1427     JSValue name = getOperand(exec, bytecode.m_name);
1428     func-&gt;setFunctionName(exec, name);
1429     LLINT_END();
1430 }
1431 
1432 static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CodeSpecializationKind kind)
1433 {
1434     slowPathLog(&quot;Performing host call.\n&quot;);
1435 
1436     ExecState* exec = execCallee-&gt;callerFrame();
1437     VM&amp; vm = exec-&gt;vm();
1438     auto throwScope = DECLARE_THROW_SCOPE(vm);
1439 
1440     execCallee-&gt;setCodeBlock(0);
1441     execCallee-&gt;clearReturnPC();
1442 
1443     if (kind == CodeForCall) {
1444         CallData callData;
1445         CallType callType = getCallData(vm, callee, callData);
1446 
1447         ASSERT(callType != CallType::JS);
1448 
1449         if (callType == CallType::Host) {
<a name="33" id="anc33"></a><span class="line-modified">1450             NativeCallFrameTracer tracer(&amp;vm, execCallee);</span>
1451             execCallee-&gt;setCallee(asObject(callee));
1452             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));
1453             LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1454         }
1455 
1456         slowPathLog(&quot;Call callee is not a function: &quot;, callee, &quot;\n&quot;);
1457 
1458         ASSERT(callType == CallType::None);
1459         LLINT_CALL_THROW(exec, createNotAFunctionError(exec, callee));
1460     }
1461 
1462     ASSERT(kind == CodeForConstruct);
1463 
1464     ConstructData constructData;
1465     ConstructType constructType = getConstructData(vm, callee, constructData);
1466 
1467     ASSERT(constructType != ConstructType::JS);
1468 
1469     if (constructType == ConstructType::Host) {
<a name="34" id="anc34"></a><span class="line-modified">1470         NativeCallFrameTracer tracer(&amp;vm, execCallee);</span>
1471         execCallee-&gt;setCallee(asObject(callee));
1472         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));
1473         LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1474     }
1475 
1476     slowPathLog(&quot;Constructor callee is not a function: &quot;, callee, &quot;\n&quot;);
1477 
1478     ASSERT(constructType == ConstructType::None);
1479     LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));
1480 }
1481 
1482 inline SlowPathReturnType setUpCall(ExecState* execCallee, CodeSpecializationKind kind, JSValue calleeAsValue, LLIntCallLinkInfo* callLinkInfo = nullptr)
1483 {
1484     ExecState* exec = execCallee-&gt;callerFrame();
1485     VM&amp; vm = exec-&gt;vm();
1486     auto throwScope = DECLARE_THROW_SCOPE(vm);
1487 
1488     slowPathLogF(&quot;Performing call with recorded PC = %p\n&quot;, exec-&gt;currentVPC());
1489 
1490     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1491     if (!calleeAsFunctionCell) {
1492         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1493             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1494             ASSERT(!!codePtr);
1495 
1496             if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
1497                 CodeBlock* callerCodeBlock = exec-&gt;codeBlock();
1498 
1499                 ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
<a name="35" id="anc35"></a><span class="line-modified">1500 </span>
<span class="line-removed">1501                 if (callLinkInfo-&gt;isOnList())</span>
<span class="line-removed">1502                     callLinkInfo-&gt;remove();</span>
<span class="line-removed">1503                 callLinkInfo-&gt;callee.set(vm, callerCodeBlock, internalFunction);</span>
<span class="line-removed">1504                 callLinkInfo-&gt;lastSeenCallee.set(vm, callerCodeBlock, internalFunction);</span>
<span class="line-removed">1505                 callLinkInfo-&gt;machineCodeTarget = codePtr;</span>
1506             }
1507 
1508             assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
1509             LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);
1510         }
1511         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, kind));
1512     }
1513     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1514     JSScope* scope = callee-&gt;scopeUnchecked();
1515     ExecutableBase* executable = callee-&gt;executable();
1516 
1517     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1518     CodeBlock* codeBlock = 0;
1519     if (executable-&gt;isHostFunction())
1520         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1521     else {
1522         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1523 
1524         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
1525             LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));
1526 
1527         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<a name="36" id="anc36"></a><span class="line-modified">1528         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);</span>
1529         EXCEPTION_ASSERT(throwScope.exception() == error);
1530         if (UNLIKELY(error))
1531             LLINT_CALL_THROW(exec, error);
1532         codeBlock = *codeBlockSlot;
1533         ASSERT(codeBlock);
1534         ArityCheckMode arity;
1535         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))
1536             arity = MustCheckArity;
1537         else
1538             arity = ArityCheckNotRequired;
1539         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1540     }
1541 
1542     ASSERT(!!codePtr);
1543 
1544     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
1545         CodeBlock* callerCodeBlock = exec-&gt;codeBlock();
1546 
1547         ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
<a name="37" id="anc37"></a><span class="line-modified">1548 </span>
<span class="line-removed">1549         if (callLinkInfo-&gt;isOnList())</span>
<span class="line-removed">1550             callLinkInfo-&gt;remove();</span>
<span class="line-removed">1551         callLinkInfo-&gt;callee.set(vm, callerCodeBlock, callee);</span>
<span class="line-removed">1552         callLinkInfo-&gt;lastSeenCallee.set(vm, callerCodeBlock, callee);</span>
<span class="line-removed">1553         callLinkInfo-&gt;machineCodeTarget = codePtr;</span>
1554         if (codeBlock)
1555             codeBlock-&gt;linkIncomingCall(exec, callLinkInfo);
1556     }
1557 
1558     assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
1559     LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);
1560 }
1561 
1562 template&lt;typename Op&gt;
1563 inline SlowPathReturnType genericCall(ExecState* exec, Op&amp;&amp; bytecode, CodeSpecializationKind kind)
1564 {
1565     // This needs to:
1566     // - Set up a call frame.
1567     // - Figure out what to call and compile it if necessary.
1568     // - If possible, link the call&#39;s inline cache.
1569     // - Return a tuple of machine code address to call and the new call frame.
1570 
1571     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);
1572 
1573     ExecState* execCallee = exec - bytecode.m_argv;
1574 
1575     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);
1576     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;
1577     execCallee-&gt;setCallerFrame(exec);
1578 
1579     auto&amp; metadata = bytecode.metadata(exec);
1580     return setUpCall(execCallee, kind, calleeAsValue, &amp;metadata.m_callLinkInfo);
1581 }
1582 
1583 LLINT_SLOW_PATH_DECL(slow_path_call)
1584 {
1585     LLINT_BEGIN_NO_SET_PC();
1586     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpCall&gt;(), CodeForCall));
1587 }
1588 
1589 LLINT_SLOW_PATH_DECL(slow_path_tail_call)
1590 {
1591     LLINT_BEGIN_NO_SET_PC();
1592     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpTailCall&gt;(), CodeForCall));
1593 }
1594 
1595 LLINT_SLOW_PATH_DECL(slow_path_construct)
1596 {
1597     LLINT_BEGIN_NO_SET_PC();
1598     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpConstruct&gt;(), CodeForConstruct));
1599 }
1600 
1601 LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_varargs)
1602 {
1603     LLINT_BEGIN();
1604     // This needs to:
1605     // - Set up a call frame while respecting the variable arguments.
1606 
1607     unsigned numUsedStackSlots;
1608     JSValue arguments;
1609     int firstVarArg;
1610     switch (pc-&gt;opcodeID()) {
1611     case op_call_varargs: {
1612         auto bytecode = pc-&gt;as&lt;OpCallVarargs&gt;();
1613         numUsedStackSlots = -bytecode.m_firstFree.offset();
1614         arguments = getOperand(exec, bytecode.m_arguments);
1615         firstVarArg = bytecode.m_firstVarArg;
1616         break;
1617     }
1618     case op_tail_call_varargs: {
1619         auto bytecode = pc-&gt;as&lt;OpTailCallVarargs&gt;();
1620         numUsedStackSlots = -bytecode.m_firstFree.offset();
1621         arguments = getOperand(exec, bytecode.m_arguments);
1622         firstVarArg = bytecode.m_firstVarArg;
1623         break;
1624     }
1625     case op_construct_varargs: {
1626         auto bytecode = pc-&gt;as&lt;OpConstructVarargs&gt;();
1627         numUsedStackSlots = -bytecode.m_firstFree.offset();
1628         arguments = getOperand(exec, bytecode.m_arguments);
1629         firstVarArg = bytecode.m_firstVarArg;
1630         break;
1631     }
1632     default:
1633         RELEASE_ASSERT_NOT_REACHED();
1634     }
1635     unsigned length = sizeFrameForVarargs(exec, vm, arguments, numUsedStackSlots, firstVarArg);
1636     LLINT_CALL_CHECK_EXCEPTION(exec, exec);
1637 
1638     ExecState* execCallee = calleeFrameForVarargs(exec, numUsedStackSlots, length + 1);
1639     vm.varargsLength = length;
1640     vm.newCallFrameReturnValue = execCallee;
1641 
1642     LLINT_RETURN_CALLEE_FRAME(execCallee);
1643 }
1644 
1645 LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_forward_arguments)
1646 {
1647     LLINT_BEGIN();
1648     // This needs to:
1649     // - Set up a call frame with the same arguments as the current frame.
1650 
1651     auto bytecode = pc-&gt;as&lt;OpTailCallForwardArguments&gt;();
1652     unsigned numUsedStackSlots = -bytecode.m_firstFree.offset();
1653 
1654     unsigned arguments = sizeFrameForForwardArguments(exec, vm, numUsedStackSlots);
1655     LLINT_CALL_CHECK_EXCEPTION(exec, exec);
1656 
1657     ExecState* execCallee = calleeFrameForVarargs(exec, numUsedStackSlots, arguments + 1);
1658 
1659     vm.varargsLength = arguments;
1660     vm.newCallFrameReturnValue = execCallee;
1661 
1662     LLINT_RETURN_CALLEE_FRAME(execCallee);
1663 }
1664 
1665 enum class SetArgumentsWith {
1666     Object,
1667     CurrentArguments
1668 };
1669 
1670 template&lt;typename Op&gt;
1671 inline SlowPathReturnType varargsSetup(ExecState* exec, const Instruction* pc, CodeSpecializationKind kind, SetArgumentsWith set)
1672 {
1673     LLINT_BEGIN_NO_SET_PC();
1674     // This needs to:
1675     // - Figure out what to call and compile it if necessary.
1676     // - Return a tuple of machine code address to call and the new call frame.
1677 
1678     auto bytecode = pc-&gt;as&lt;Op&gt;();
1679     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);
1680 
1681     ExecState* execCallee = vm.newCallFrameReturnValue;
1682 
1683     if (set == SetArgumentsWith::Object) {
1684         setupVarargsFrameAndSetThis(exec, execCallee, getOperand(exec, bytecode.m_thisValue), getOperand(exec, bytecode.m_arguments), bytecode.m_firstVarArg, vm.varargsLength);
1685         LLINT_CALL_CHECK_EXCEPTION(exec, exec);
1686     } else
1687         setupForwardArgumentsFrameAndSetThis(exec, execCallee, getOperand(exec, bytecode.m_thisValue), vm.varargsLength);
1688 
1689     execCallee-&gt;setCallerFrame(exec);
1690     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;
1691     exec-&gt;setCurrentVPC(pc);
1692 
1693     RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, kind, calleeAsValue));
1694 }
1695 
1696 LLINT_SLOW_PATH_DECL(slow_path_call_varargs)
1697 {
1698     return varargsSetup&lt;OpCallVarargs&gt;(exec, pc, CodeForCall, SetArgumentsWith::Object);
1699 }
1700 
1701 LLINT_SLOW_PATH_DECL(slow_path_tail_call_varargs)
1702 {
1703     return varargsSetup&lt;OpTailCallVarargs&gt;(exec, pc, CodeForCall, SetArgumentsWith::Object);
1704 }
1705 
1706 LLINT_SLOW_PATH_DECL(slow_path_tail_call_forward_arguments)
1707 {
1708     return varargsSetup&lt;OpTailCallForwardArguments&gt;(exec, pc, CodeForCall, SetArgumentsWith::CurrentArguments);
1709 }
1710 
1711 LLINT_SLOW_PATH_DECL(slow_path_construct_varargs)
1712 {
1713     return varargsSetup&lt;OpConstructVarargs&gt;(exec, pc, CodeForConstruct, SetArgumentsWith::Object);
1714 }
1715 
1716 inline SlowPathReturnType commonCallEval(ExecState* exec, const Instruction* pc, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; returnPoint)
1717 {
1718     LLINT_BEGIN_NO_SET_PC();
1719     auto bytecode = pc-&gt;as&lt;OpCallEval&gt;();
1720     JSValue calleeAsValue = getNonConstantOperand(exec, bytecode.m_callee);
1721 
1722     ExecState* execCallee = exec - bytecode.m_argv;
1723 
1724     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);
1725     execCallee-&gt;setCallerFrame(exec);
1726     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;
1727     execCallee-&gt;setReturnPC(returnPoint.executableAddress());
1728     execCallee-&gt;setCodeBlock(0);
1729     exec-&gt;setCurrentVPC(pc);
1730 
1731     if (!isHostFunction(calleeAsValue, globalFuncEval))
1732         RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, CodeForCall, calleeAsValue));
1733 
1734     vm.hostCallReturnValue = eval(execCallee);
1735     LLINT_CALL_RETURN(exec, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1736 }
1737 
1738 LLINT_SLOW_PATH_DECL(slow_path_call_eval)
1739 {
1740     return commonCallEval(exec, pc, LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));
1741 }
1742 
<a name="38" id="anc38"></a><span class="line-modified">1743 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide)</span>





1744 {
<a name="39" id="anc39"></a><span class="line-modified">1745     return commonCallEval(exec, pc, LLInt::getWideCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1746 }
1747 
1748 LLINT_SLOW_PATH_DECL(slow_path_strcat)
1749 {
1750     LLINT_BEGIN();
1751     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
1752     LLINT_RETURN(jsStringFromRegisterArray(exec, &amp;exec-&gt;uncheckedR(bytecode.m_src), bytecode.m_count));
1753 }
1754 
1755 LLINT_SLOW_PATH_DECL(slow_path_to_primitive)
1756 {
1757     LLINT_BEGIN();
1758     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
1759     LLINT_RETURN(getOperand(exec, bytecode.m_src).toPrimitive(exec));
1760 }
1761 
1762 LLINT_SLOW_PATH_DECL(slow_path_throw)
1763 {
1764     LLINT_BEGIN();
1765     auto bytecode = pc-&gt;as&lt;OpThrow&gt;();
1766     LLINT_THROW(getOperand(exec, bytecode.m_value));
1767 }
1768 
1769 LLINT_SLOW_PATH_DECL(slow_path_handle_traps)
1770 {
1771     LLINT_BEGIN_NO_SET_PC();
1772     ASSERT(vm.needTrapHandling());
1773     vm.handleTraps(exec);
1774     UNUSED_PARAM(pc);
1775     LLINT_RETURN_TWO(throwScope.exception(), exec);
1776 }
1777 
1778 LLINT_SLOW_PATH_DECL(slow_path_debug)
1779 {
1780     LLINT_BEGIN();
1781     auto bytecode = pc-&gt;as&lt;OpDebug&gt;();
1782     vm.interpreter-&gt;debug(exec, bytecode.m_debugHookType);
1783 
1784     LLINT_END();
1785 }
1786 
1787 LLINT_SLOW_PATH_DECL(slow_path_handle_exception)
1788 {
1789     LLINT_BEGIN_NO_SET_PC();
1790     UNUSED_PARAM(throwScope);
<a name="40" id="anc40"></a><span class="line-modified">1791     genericUnwind(&amp;vm, exec);</span>
1792     LLINT_END_IMPL();
1793 }
1794 
1795 LLINT_SLOW_PATH_DECL(slow_path_get_from_scope)
1796 {
1797     LLINT_BEGIN();
1798     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
1799     auto&amp; metadata = bytecode.metadata(exec);
1800     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_var);
1801     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));
1802 
1803     // ModuleVar is always converted to ClosureVar for get_from_scope.
1804     ASSERT(metadata.m_getPutInfo.resolveType() != ModuleVar);
1805 
1806     LLINT_RETURN(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
1807         if (!found) {
1808             if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound)
1809                 return throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
1810             return jsUndefined();
1811         }
1812 
1813         JSValue result = JSValue();
1814         if (scope-&gt;isGlobalLexicalEnvironment()) {
1815             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
1816             result = slot.getValue(exec, ident);
1817             if (result == jsTDZValue())
1818                 return throwException(exec, throwScope, createTDZError(exec));
1819         }
1820 
1821         CommonSlowPaths::tryCacheGetFromScopeGlobal(exec, vm, bytecode, scope, slot, ident);
1822 
1823         if (!result)
1824             return slot.getValue(exec, ident);
1825         return result;
1826     }));
1827 }
1828 
1829 LLINT_SLOW_PATH_DECL(slow_path_put_to_scope)
1830 {
1831     LLINT_BEGIN();
1832 
1833     auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
1834     auto&amp; metadata = bytecode.metadata(exec);
1835     CodeBlock* codeBlock = exec-&gt;codeBlock();
1836     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
1837     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));
1838     JSValue value = getOperand(exec, bytecode.m_value);
1839     if (metadata.m_getPutInfo.resolveType() == LocalClosureVar) {
1840         JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
1841         environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
1842 
1843         // Have to do this *after* the write, because if this puts the set into IsWatched, then we need
1844         // to have already changed the value of the variable. Otherwise we might watch and constant-fold
1845         // to the Undefined value from before the assignment.
1846         if (metadata.m_watchpointSet)
1847             metadata.m_watchpointSet-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
1848         LLINT_END();
1849     }
1850 
1851     bool hasProperty = scope-&gt;hasProperty(exec, ident);
1852     LLINT_CHECK_EXCEPTION();
1853     if (hasProperty
1854         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
1855         &amp;&amp; !isInitialization(metadata.m_getPutInfo.initializationMode())) {
1856         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
1857         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
1858         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);
1859         if (slot.getValue(exec, ident) == jsTDZValue())
1860             LLINT_THROW(createTDZError(exec));
1861     }
1862 
1863     if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty)
1864         LLINT_THROW(createUndefinedVariableError(exec, ident));
1865 
1866     PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(metadata.m_getPutInfo.initializationMode()));
1867     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, value, slot);
1868 
1869     CommonSlowPaths::tryCachePutToScopeGlobal(exec, codeBlock, bytecode, scope, slot, ident);
1870 
1871     LLINT_END();
1872 }
1873 
1874 LLINT_SLOW_PATH_DECL(slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
1875 {
1876     LLINT_BEGIN();
1877     RELEASE_ASSERT(!!throwScope.exception());
1878 
1879     if (isTerminatedExecutionException(vm, throwScope.exception()))
1880         LLINT_RETURN_TWO(pc, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)));
1881     LLINT_RETURN_TWO(pc, 0);
1882 }
1883 
1884 LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_prologue)
1885 {
1886     LLINT_BEGIN();
1887 
1888     auto bytecode = pc-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
1889     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1890     ShadowChicken* shadowChicken = vm.shadowChicken();
1891     RELEASE_ASSERT(shadowChicken);
1892     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::prologue(exec-&gt;jsCallee(), exec, exec-&gt;callerFrame(), scope));
1893 
1894     LLINT_END();
1895 }
1896 
1897 LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_tail)
1898 {
1899     LLINT_BEGIN();
1900 
1901     auto bytecode = pc-&gt;as&lt;OpLogShadowChickenTail&gt;();
1902     JSValue thisValue = getNonConstantOperand(exec, bytecode.m_thisValue);
1903     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1904 
1905 #if USE(JSVALUE64)
1906     CallSiteIndex callSiteIndex(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc));
1907 #else
1908     CallSiteIndex callSiteIndex(pc);
1909 #endif
1910     ShadowChicken* shadowChicken = vm.shadowChicken();
1911     RELEASE_ASSERT(shadowChicken);
1912     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::tail(exec, thisValue, scope, exec-&gt;codeBlock(), callSiteIndex));
1913 
1914     LLINT_END();
1915 }
1916 
1917 LLINT_SLOW_PATH_DECL(slow_path_profile_catch)
1918 {
1919     LLINT_BEGIN();
1920 
1921     exec-&gt;codeBlock()-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(exec-&gt;bytecodeOffset());
1922 
1923     auto bytecode = pc-&gt;as&lt;OpCatch&gt;();
1924     auto&amp; metadata = bytecode.metadata(exec);
1925     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
<a name="41" id="anc41"></a><span class="line-modified">1926         profile.m_profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1927     });
1928 
1929     LLINT_END();
1930 }
1931 
1932 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_begin)
1933 {
1934     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1935     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
1936     UNUSED_PARAM(exec);
1937     g_superSamplerCount++;
1938     LLINT_END_IMPL();
1939 }
1940 
1941 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_end)
1942 {
1943     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1944     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
1945     UNUSED_PARAM(exec);
1946     g_superSamplerCount--;
1947     LLINT_END_IMPL();
1948 }
1949 
1950 LLINT_SLOW_PATH_DECL(slow_path_out_of_line_jump_target)
1951 {
1952     CodeBlock* codeBlock = exec-&gt;codeBlock();
1953     pc = codeBlock-&gt;outOfLineJumpTarget(pc);
1954     LLINT_END_IMPL();
1955 }
1956 
1957 extern &quot;C&quot; SlowPathReturnType llint_throw_stack_overflow_error(VM* vm, ProtoCallFrame* protoFrame)
1958 {
1959     ExecState* exec = vm-&gt;topCallFrame;
1960     auto scope = DECLARE_THROW_SCOPE(*vm);
1961 
1962     if (!exec)
1963         exec = protoFrame-&gt;callee()-&gt;globalObject(*vm)-&gt;globalExec();
1964     throwStackOverflowError(exec, scope);
1965     return encodeResult(0, 0);
1966 }
1967 
1968 #if ENABLE(C_LOOP)
1969 extern &quot;C&quot; SlowPathReturnType llint_stack_check_at_vm_entry(VM* vm, Register* newTopOfStack)
1970 {
1971     bool success = vm-&gt;ensureStackCapacityFor(newTopOfStack);
1972     return encodeResult(reinterpret_cast&lt;void*&gt;(success), 0);
1973 }
1974 #endif
1975 
1976 extern &quot;C&quot; void llint_write_barrier_slow(ExecState* exec, JSCell* cell)
1977 {
1978     VM&amp; vm = exec-&gt;vm();
1979     vm.heap.writeBarrier(cell);
1980 }
1981 
1982 extern &quot;C&quot; NO_RETURN_DUE_TO_CRASH void llint_crash()
1983 {
1984     CRASH();
1985 }
1986 
1987 } } // namespace JSC::LLInt
<a name="42" id="anc42"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="42" type="hidden" />
</body>
</html>