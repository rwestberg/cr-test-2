<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;HTMLMediaElement.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ApplicationCacheHost.h&quot;
  32 #include &quot;ApplicationCacheResource.h&quot;
  33 #include &quot;Attribute.h&quot;
  34 #include &quot;Blob.h&quot;
  35 #include &quot;CSSPropertyNames.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;CommonVM.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  39 #include &quot;ContentRuleListResults.h&quot;</span>
  40 #include &quot;ContentSecurityPolicy.h&quot;
  41 #include &quot;ContentType.h&quot;
  42 #include &quot;CookieJar.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  43 #include &quot;CustomHeaderFields.h&quot;</span>
  44 #include &quot;DeprecatedGlobalSettings.h&quot;
  45 #include &quot;DiagnosticLoggingClient.h&quot;
  46 #include &quot;DiagnosticLoggingKeys.h&quot;
  47 #include &quot;Document.h&quot;
  48 #include &quot;DocumentLoader.h&quot;
  49 #include &quot;ElementChildIterator.h&quot;
  50 #include &quot;EventNames.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameView.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  55 #include &quot;FullscreenManager.h&quot;</span>
  56 #include &quot;HTMLParserIdioms.h&quot;
  57 #include &quot;HTMLSourceElement.h&quot;
  58 #include &quot;HTMLVideoElement.h&quot;
  59 #include &quot;InspectorInstrumentation.h&quot;
  60 #include &quot;JSDOMException.h&quot;
  61 #include &quot;JSDOMPromiseDeferred.h&quot;
  62 #include &quot;JSHTMLMediaElement.h&quot;
  63 #include &quot;Logging.h&quot;
  64 #include &quot;MIMETypeRegistry.h&quot;
  65 #include &quot;MediaController.h&quot;
  66 #include &quot;MediaControls.h&quot;
  67 #include &quot;MediaDocument.h&quot;
  68 #include &quot;MediaError.h&quot;
  69 #include &quot;MediaFragmentURIParser.h&quot;
  70 #include &quot;MediaList.h&quot;
  71 #include &quot;MediaPlayer.h&quot;
  72 #include &quot;MediaQueryEvaluator.h&quot;
  73 #include &quot;MediaResourceLoader.h&quot;
  74 #include &quot;NetworkingContext.h&quot;
  75 #include &quot;Page.h&quot;
  76 #include &quot;PageGroup.h&quot;
  77 #include &quot;PlatformMediaSessionManager.h&quot;
  78 #include &quot;ProgressTracker.h&quot;
<a name="5" id="anc5"></a>
  79 #include &quot;Quirks.h&quot;
<a name="6" id="anc6"></a><span class="line-added">  80 #include &quot;RegistrableDomain.h&quot;</span>
  81 #include &quot;RenderLayerCompositor.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderVideo.h&quot;
  84 #include &quot;RenderView.h&quot;
  85 #include &quot;ResourceLoadInfo.h&quot;
  86 #include &quot;ScriptController.h&quot;
  87 #include &quot;ScriptDisallowedScope.h&quot;
  88 #include &quot;ScriptSourceCode.h&quot;
  89 #include &quot;SecurityOriginData.h&quot;
  90 #include &quot;SecurityPolicy.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;ShadowRoot.h&quot;
  93 #include &quot;TimeRanges.h&quot;
  94 #include &quot;UserContentController.h&quot;
  95 #include &quot;UserGestureIndicator.h&quot;
  96 #include &quot;VideoPlaybackQuality.h&quot;
  97 #include &lt;JavaScriptCore/Uint8Array.h&gt;
  98 #include &lt;limits&gt;
  99 #include &lt;pal/SessionID.h&gt;
 100 #include &lt;pal/system/SleepDisabler.h&gt;
 101 #include &lt;wtf/Algorithms.h&gt;
 102 #include &lt;wtf/IsoMallocInlines.h&gt;
 103 #include &lt;wtf/Language.h&gt;
 104 #include &lt;wtf/MathExtras.h&gt;
 105 #include &lt;wtf/MemoryPressureHandler.h&gt;
 106 #include &lt;wtf/Ref.h&gt;
 107 #include &lt;wtf/text/CString.h&gt;
 108 
 109 #if ENABLE(VIDEO_TRACK)
 110 #include &quot;AudioTrackList.h&quot;
 111 #include &quot;HTMLTrackElement.h&quot;
 112 #include &quot;InbandGenericTextTrack.h&quot;
 113 #include &quot;InbandTextTrackPrivate.h&quot;
 114 #include &quot;InbandWebVTTTextTrack.h&quot;
 115 #include &quot;RuntimeEnabledFeatures.h&quot;
 116 #include &quot;TextTrackCueList.h&quot;
 117 #include &quot;TextTrackList.h&quot;
 118 #include &quot;VideoTrackList.h&quot;
 119 #endif
 120 
 121 #if ENABLE(WEB_AUDIO)
 122 #include &quot;AudioSourceProvider.h&quot;
 123 #include &quot;MediaElementAudioSourceNode.h&quot;
 124 #endif
 125 
 126 #if PLATFORM(IOS_FAMILY)
 127 #include &quot;RuntimeApplicationChecks.h&quot;
 128 #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
 129 #endif
 130 
 131 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 132 #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
 133 #endif
 134 
 135 #if ENABLE(MEDIA_SESSION)
 136 #include &quot;MediaSession.h&quot;
 137 #endif
 138 
 139 #if ENABLE(MEDIA_SOURCE)
 140 #include &quot;DOMWindow.h&quot;
 141 #include &quot;MediaSource.h&quot;
 142 #endif
 143 
 144 #if ENABLE(MEDIA_STREAM)
 145 #include &quot;DOMURL.h&quot;
 146 #include &quot;MediaStream.h&quot;
<a name="7" id="anc7"></a>
 147 #endif
 148 
 149 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 150 #include &quot;WebKitMediaKeyNeededEvent.h&quot;
 151 #include &quot;WebKitMediaKeys.h&quot;
 152 #endif
 153 
 154 #if ENABLE(ENCRYPTED_MEDIA)
 155 #include &quot;MediaEncryptedEvent.h&quot;
 156 #include &quot;MediaKeys.h&quot;
 157 #endif
 158 
 159 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 160 #include &quot;JSMediaControlsHost.h&quot;
 161 #include &quot;MediaControlsHost.h&quot;
 162 #include &lt;JavaScriptCore/ScriptObject.h&gt;
 163 #endif
 164 
 165 #if ENABLE(ENCRYPTED_MEDIA)
 166 #include &quot;NotImplemented.h&quot;
 167 #endif
 168 
 169 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 170 #include &quot;VideoFullscreenModel.h&quot;
 171 #endif
 172 
 173 namespace WTF {
 174 template &lt;&gt;
 175 struct LogArgument&lt;URL&gt; {
 176     static String toString(const URL&amp; url)
 177     {
 178 #if !LOG_DISABLED
 179         static const unsigned maximumURLLengthForLogging = 512;
 180 
 181         if (url.string().length() &lt; maximumURLLengthForLogging)
 182             return url.string();
 183         return url.string().substring(0, maximumURLLengthForLogging) + &quot;...&quot;;
 184 #else
 185         UNUSED_PARAM(url);
 186         return &quot;[url]&quot;;
 187 #endif
 188     }
 189 };
 190 }
 191 
 192 
 193 namespace WebCore {
 194 
 195 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLMediaElement);
 196 
 197 using namespace PAL;
 198 
 199 static const Seconds SeekRepeatDelay { 100_ms };
 200 static const double SeekTime = 0.2;
 201 static const Seconds ScanRepeatDelay { 1.5_s };
 202 static const double ScanMaximumRate = 8;
 203 static const double AutoplayInterferenceTimeThreshold = 10;
 204 static const Seconds hideMediaControlsAfterEndedDelay { 6_s };
 205 
 206 #ifndef LOG_CACHED_TIME_WARNINGS
 207 // Default to not logging warnings about excessive drift in the cached media time because it adds a
 208 // fair amount of overhead and logging.
 209 #define LOG_CACHED_TIME_WARNINGS 0
 210 #endif
 211 
 212 #if ENABLE(MEDIA_SOURCE)
 213 // URL protocol used to signal that the media source API is being used.
 214 static const char* mediaSourceBlobProtocol = &quot;blob&quot;;
 215 #endif
 216 
 217 #if ENABLE(MEDIA_STREAM)
 218 // URL protocol used to signal that the media stream API is being used.
 219 static const char* mediaStreamBlobProtocol = &quot;blob&quot;;
 220 #endif
 221 
 222 using namespace HTMLNames;
 223 
 224 String convertEnumerationToString(HTMLMediaElement::ReadyState enumerationValue)
 225 {
 226     static const NeverDestroyed&lt;String&gt; values[] = {
 227         MAKE_STATIC_STRING_IMPL(&quot;HAVE_NOTHING&quot;),
 228         MAKE_STATIC_STRING_IMPL(&quot;HAVE_METADATA&quot;),
 229         MAKE_STATIC_STRING_IMPL(&quot;HAVE_CURRENT_DATA&quot;),
 230         MAKE_STATIC_STRING_IMPL(&quot;HAVE_FUTURE_DATA&quot;),
 231         MAKE_STATIC_STRING_IMPL(&quot;HAVE_ENOUGH_DATA&quot;),
 232     };
 233     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_NOTHING) == 0, &quot;HTMLMediaElementEnums::HAVE_NOTHING is not 0 as expected&quot;);
 234     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_METADATA) == 1, &quot;HTMLMediaElementEnums::HAVE_METADATA is not 1 as expected&quot;);
 235     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_CURRENT_DATA) == 2, &quot;HTMLMediaElementEnums::HAVE_CURRENT_DATA is not 2 as expected&quot;);
 236     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_FUTURE_DATA) == 3, &quot;HTMLMediaElementEnums::HAVE_FUTURE_DATA is not 3 as expected&quot;);
 237     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_ENOUGH_DATA) == 4, &quot;HTMLMediaElementEnums::HAVE_ENOUGH_DATA is not 4 as expected&quot;);
 238     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 239     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 240 }
 241 
 242 String convertEnumerationToString(HTMLMediaElement::NetworkState enumerationValue)
 243 {
 244     static const NeverDestroyed&lt;String&gt; values[] = {
 245         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_EMPTY&quot;),
 246         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_IDLE&quot;),
 247         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_LOADING&quot;),
 248         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_NO_SOURCE&quot;),
 249     };
 250     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_EMPTY) == 0, &quot;HTMLMediaElementEnums::NETWORK_EMPTY is not 0 as expected&quot;);
 251     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_IDLE) == 1, &quot;HTMLMediaElementEnums::NETWORK_IDLE is not 1 as expected&quot;);
 252     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_LOADING) == 2, &quot;HTMLMediaElementEnums::NETWORK_LOADING is not 2 as expected&quot;);
 253     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_NO_SOURCE) == 3, &quot;HTMLMediaElementEnums::NETWORK_NO_SOURCE is not 3 as expected&quot;);
 254     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 255     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 256 }
 257 
 258 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState enumerationValue)
 259 {
 260     static const NeverDestroyed&lt;String&gt; values[] = {
 261         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
 262         MAKE_STATIC_STRING_IMPL(&quot;PreventedAutoplay&quot;),
 263         MAKE_STATIC_STRING_IMPL(&quot;StartedWithUserGesture&quot;),
 264         MAKE_STATIC_STRING_IMPL(&quot;StartedWithoutUserGesture&quot;),
 265     };
 266     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::None) == 0, &quot;AutoplayEventPlaybackState::None is not 0 as expected&quot;);
 267     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::PreventedAutoplay) == 1, &quot;AutoplayEventPlaybackState::PreventedAutoplay is not 1 as expected&quot;);
 268     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithUserGesture) == 2, &quot;AutoplayEventPlaybackState::StartedWithUserGesture is not 2 as expected&quot;);
 269     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithoutUserGesture) == 3, &quot;AutoplayEventPlaybackState::StartedWithoutUserGesture is not 3 as expected&quot;);
 270     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 271     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 272 }
 273 
 274 typedef HashMap&lt;Document*, HashSet&lt;HTMLMediaElement*&gt;&gt; DocumentElementSetMap;
 275 static DocumentElementSetMap&amp; documentToElementSetMap()
 276 {
 277     static NeverDestroyed&lt;DocumentElementSetMap&gt; map;
 278     return map;
 279 }
 280 
 281 static void addElementToDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)
 282 {
 283     DocumentElementSetMap&amp; map = documentToElementSetMap();
 284     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);
 285     set.add(&amp;element);
 286     map.add(&amp;document, set);
 287 }
 288 
 289 static void removeElementFromDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)
 290 {
 291     DocumentElementSetMap&amp; map = documentToElementSetMap();
 292     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);
 293     set.remove(&amp;element);
 294     if (!set.isEmpty())
 295         map.add(&amp;document, set);
 296 }
 297 
 298 #if ENABLE(VIDEO_TRACK)
 299 
 300 class TrackDisplayUpdateScope {
 301 public:
 302     TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
 303         : m_element(element)
 304     {
 305         m_element.beginIgnoringTrackDisplayUpdateRequests();
 306     }
 307     ~TrackDisplayUpdateScope()
 308     {
 309         m_element.endIgnoringTrackDisplayUpdateRequests();
 310     }
 311 
 312 private:
 313     HTMLMediaElement&amp; m_element;
 314 };
 315 
<a name="8" id="anc8"></a><span class="line-added"> 316 #endif</span>
 317 
 318 struct HTMLMediaElement::TrackGroup {
 319     enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
 320 
 321     TrackGroup(GroupKind kind)
 322         : kind(kind)
 323     {
 324     }
 325 
 326     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracks;
 327     RefPtr&lt;TextTrack&gt; visibleTrack;
 328     RefPtr&lt;TextTrack&gt; defaultTrack;
 329     GroupKind kind;
 330     bool hasSrcLang { false };
 331 };
<a name="9" id="anc9"></a>
 332 
 333 HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
 334 {
 335     static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
 336     return elements;
 337 }
 338 
 339 #if ENABLE(MEDIA_SESSION)
 340 typedef HashMap&lt;uint64_t, HTMLMediaElement*&gt; IDToElementMap;
 341 
 342 static IDToElementMap&amp; elementIDsToElements()
 343 {
 344     static NeverDestroyed&lt;IDToElementMap&gt; map;
 345     return map;
 346 }
 347 
 348 HTMLMediaElement* HTMLMediaElement::elementWithID(uint64_t id)
 349 {
 350     if (id == HTMLMediaElementInvalidID)
 351         return nullptr;
 352 
 353     return elementIDsToElements().get(id);
 354 }
 355 
 356 static uint64_t nextElementID()
 357 {
 358     static uint64_t elementID = 0;
 359     return ++elementID;
 360 }
 361 #endif
 362 
 363 struct MediaElementSessionInfo {
 364     const MediaElementSession* session;
 365     MediaElementSession::PlaybackControlsPurpose purpose;
 366 
 367     MonotonicTime timeOfLastUserInteraction;
 368     bool canShowControlsManager : 1;
 369     bool isVisibleInViewportOrFullscreen : 1;
 370     bool isLargeEnoughForMainContent : 1;
 371     bool isPlayingAudio : 1;
 372 };
 373 
 374 static MediaElementSessionInfo mediaElementSessionInfoForSession(const MediaElementSession&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 375 {
 376     const HTMLMediaElement&amp; element = session.element();
 377     return {
 378         &amp;session,
 379         purpose,
 380         session.mostRecentUserInteractionTime(),
 381         session.canShowControlsManager(purpose),
 382         element.isFullscreen() || element.isVisibleInViewport(),
 383         session.isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls),
 384         element.isPlaying() &amp;&amp; element.hasAudio() &amp;&amp; !element.muted()
 385     };
 386 }
 387 
 388 static bool preferMediaControlsForCandidateSessionOverOtherCandidateSession(const MediaElementSessionInfo&amp; session, const MediaElementSessionInfo&amp; otherSession)
 389 {
 390     MediaElementSession::PlaybackControlsPurpose purpose = session.purpose;
 391     ASSERT(purpose == otherSession.purpose);
 392 
 393     // For the controls manager, prioritize visible media over offscreen media.
 394     if (purpose == MediaElementSession::PlaybackControlsPurpose::ControlsManager &amp;&amp; session.isVisibleInViewportOrFullscreen != otherSession.isVisibleInViewportOrFullscreen)
 395         return session.isVisibleInViewportOrFullscreen;
 396 
 397     // For Now Playing, prioritize elements that would normally satisfy main content.
 398     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying &amp;&amp; session.isLargeEnoughForMainContent != otherSession.isLargeEnoughForMainContent)
 399         return session.isLargeEnoughForMainContent;
 400 
 401     // As a tiebreaker, prioritize elements that the user recently interacted with.
 402     return session.timeOfLastUserInteraction &gt; otherSession.timeOfLastUserInteraction;
 403 }
 404 
 405 static bool mediaSessionMayBeConfusedWithMainContent(const MediaElementSessionInfo&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 406 {
 407     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying)
 408         return session.isPlayingAudio;
 409 
 410     if (!session.isVisibleInViewportOrFullscreen)
 411         return false;
 412 
 413     if (!session.isLargeEnoughForMainContent)
 414         return false;
 415 
 416     // Even if this video is not a candidate, if it is visible to the user and large enough
 417     // to be main content, it poses a risk for being confused with main content.
 418     return true;
 419 }
 420 
<a name="10" id="anc10"></a>







 421 HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 422     : HTMLElement(tagName, document)
 423     , ActiveDOMObject(document)
 424     , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
 425     , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
 426     , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
 427     , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
 428     , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
 429     , m_asyncEventQueue(*this)
 430     , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
 431     , m_firstTimePlaying(true)
 432     , m_playing(false)
 433     , m_isWaitingUntilMediaCanStart(false)
 434     , m_shouldDelayLoadEvent(false)
 435     , m_haveFiredLoadedData(false)
 436     , m_inActiveDocument(true)
 437     , m_autoplaying(true)
 438     , m_muted(false)
 439     , m_explicitlyMuted(false)
 440     , m_initiallyMuted(false)
 441     , m_paused(true)
 442     , m_seeking(false)
 443     , m_seekRequested(false)
 444     , m_sentStalledEvent(false)
 445     , m_sentEndEvent(false)
 446     , m_pausedInternal(false)
 447     , m_closedCaptionsVisible(false)
 448     , m_webkitLegacyClosedCaptionOverride(false)
 449     , m_completelyLoaded(false)
 450     , m_havePreparedToPlay(false)
 451     , m_parsingInProgress(createdByParser)
<a name="11" id="anc11"></a>
 452     , m_elementIsHidden(document.hidden())
 453     , m_creatingControls(false)
 454     , m_receivedLayoutSizeChanged(false)
 455     , m_hasEverNotifiedAboutPlaying(false)
 456     , m_hasEverHadAudio(false)
 457     , m_hasEverHadVideo(false)
 458 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 459     , m_mediaControlsDependOnPageScaleFactor(false)
 460     , m_haveSetUpCaptionContainer(false)
 461 #endif
 462     , m_isScrubbingRemotely(false)
 463 #if ENABLE(VIDEO_TRACK)
 464     , m_tracksAreReady(true)
 465     , m_haveVisibleTextTrack(false)
 466     , m_processingPreferenceChange(false)
 467 #endif
 468 #if !RELEASE_LOG_DISABLED
 469     , m_logger(&amp;document.logger())
<a name="12" id="anc12"></a><span class="line-modified"> 470     , m_logIdentifier(uniqueLogIdentifier())</span>
 471 #endif
 472 {
 473     allMediaElements().add(this);
 474 
 475     ALWAYS_LOG(LOGIDENTIFIER);
 476 
 477     setHasCustomStyleResolveCallbacks();
 478 
 479     InspectorInstrumentation::addEventListenersToNode(*this);
 480 }
 481 
 482 void HTMLMediaElement::finishInitialization()
 483 {
<a name="13" id="anc13"></a><span class="line-modified"> 484     m_mediaSession = makeUnique&lt;MediaElementSession&gt;(*this);</span>
 485 
 486     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 487     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
 488 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 489     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
 490 #endif
 491     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
 492     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
 493 
 494     auto&amp; document = this-&gt;document();
 495     auto* page = document.page();
 496 
 497     if (document.settings().invisibleAutoplayNotPermitted())
 498         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted);
 499 
 500     if (document.ownerElement() || !document.isMediaDocument()) {
 501         const auto&amp; topDocument = document.topDocument();
 502         const bool isProcessingUserGesture = processingUserGestureForMedia();
 503         const bool shouldAudioPlaybackRequireUserGesture = topDocument.audioPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 504         const bool shouldVideoPlaybackRequireUserGesture = topDocument.videoPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 505 
 506         if (shouldVideoPlaybackRequireUserGesture) {
 507             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
 508             if (document.settings().requiresUserGestureToLoadVideo())
 509                 m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForLoad);
 510         }
 511 
 512         if (page &amp;&amp; page-&gt;isLowPowerModeEnabled())
 513             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
 514 
 515         if (shouldAudioPlaybackRequireUserGesture)
 516             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
 517 
 518 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 519         if (shouldVideoPlaybackRequireUserGesture || shouldAudioPlaybackRequireUserGesture)
 520             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker);
 521 #endif
 522 
 523         if (!document.settings().mediaDataLoadsAutomatically())
 524             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::AutoPreloadingNotPermitted);
 525 
 526         if (document.settings().mainContentUserGestureOverrideEnabled())
 527             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::OverrideUserGestureRequirementForMainContent);
 528     }
 529 
 530 #if PLATFORM(IOS_FAMILY)
 531     if (!document.settings().videoPlaybackRequiresUserGesture() &amp;&amp; !document.settings().audioPlaybackRequiresUserGesture()) {
 532         // Relax RequireUserGestureForFullscreen when videoPlaybackRequiresUserGesture and audioPlaybackRequiresUserGesture is not set:
 533         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 534     }
 535 #endif
 536 
 537 #if ENABLE(MEDIA_SESSION)
 538     m_elementID = nextElementID();
 539     elementIDsToElements().add(m_elementID, this);
 540 
 541     setSessionInternal(document.defaultMediaSession());
 542 #endif
 543 
 544     registerWithDocument(document);
 545 
 546 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 547     AudioSession::sharedSession().addMutedStateObserver(this);
 548 #endif
 549 
 550     mediaSession().clientWillBeginAutoplaying();
 551 }
 552 
 553 // FIXME: Remove this code once https://webkit.org/b/185284 is fixed.
 554 static unsigned s_destructorCount = 0;
 555 
 556 bool HTMLMediaElement::isRunningDestructor()
 557 {
 558     return !!s_destructorCount;
 559 }
 560 
 561 class HTMLMediaElementDestructorScope {
 562 public:
 563     HTMLMediaElementDestructorScope() { ++s_destructorCount; }
 564     ~HTMLMediaElementDestructorScope() { --s_destructorCount; }
 565 };
 566 
 567 HTMLMediaElement::~HTMLMediaElement()
 568 {
 569     HTMLMediaElementDestructorScope destructorScope;
 570     ALWAYS_LOG(LOGIDENTIFIER);
 571 
 572     beginIgnoringTrackDisplayUpdateRequests();
 573     allMediaElements().remove(this);
 574 
 575     m_asyncEventQueue.close();
 576 
 577     setShouldDelayLoadEvent(false);
 578     unregisterWithDocument(document());
 579 
 580 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 581     AudioSession::sharedSession().removeMutedStateObserver(this);
 582 #endif
 583 
 584 #if ENABLE(VIDEO_TRACK)
 585     if (m_audioTracks)
 586         m_audioTracks-&gt;clearElement();
 587     if (m_textTracks)
 588         m_textTracks-&gt;clearElement();
 589     if (m_videoTracks)
 590         m_videoTracks-&gt;clearElement();
 591 #endif
 592 
 593 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 594     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
 595         m_hasPlaybackTargetAvailabilityListeners = false;
 596         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
 597         updateMediaState();
 598     }
 599 #endif
 600 
 601     if (m_mediaController) {
 602         m_mediaController-&gt;removeMediaElement(*this);
 603         m_mediaController = nullptr;
 604     }
 605 
 606 #if ENABLE(MEDIA_SOURCE)
 607     detachMediaSource();
 608 #endif
 609 
 610 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 611     webkitSetMediaKeys(nullptr);
 612 #endif
 613 
 614 #if ENABLE(ENCRYPTED_MEDIA)
 615     if (m_mediaKeys) {
 616         m_mediaKeys-&gt;detachCDMClient(*this);
 617         if (m_player)
 618             m_player-&gt;cdmInstanceDetached(m_mediaKeys-&gt;cdmInstance());
 619     }
 620 #endif
 621 
 622 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 623     if (m_isolatedWorld)
 624         m_isolatedWorld-&gt;clearWrappers();
 625 #endif
 626 
 627 #if ENABLE(MEDIA_SESSION)
 628     if (m_session) {
 629         m_session-&gt;removeMediaElement(*this);
 630         m_session = nullptr;
 631     }
 632 
 633     elementIDsToElements().remove(m_elementID);
 634 #endif
 635 
 636     m_seekTaskQueue.close();
 637     m_resumeTaskQueue.close();
 638     m_promiseTaskQueue.close();
 639     m_pauseAfterDetachedTaskQueue.close();
 640     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
 641     m_resourceSelectionTaskQueue.close();
 642     m_visibilityChangeTaskQueue.close();
 643 #if ENABLE(ENCRYPTED_MEDIA)
 644     m_encryptedMediaQueue.close();
 645 #endif
 646 
 647     m_completelyLoaded = true;
 648 
 649     if (m_player) {
 650         m_player-&gt;invalidate();
 651         m_player = nullptr;
 652     }
 653 
 654     m_mediaSession = nullptr;
 655     schedulePlaybackControlsManagerUpdate();
 656 }
<a name="14" id="anc14"></a>










 657 RefPtr&lt;HTMLMediaElement&gt; HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose purpose)
 658 {
<a name="15" id="anc15"></a>



 659     Vector&lt;MediaElementSessionInfo&gt; candidateSessions;
 660     bool atLeastOneNonCandidateMayBeConfusedForMainContent = false;
<a name="16" id="anc16"></a><span class="line-modified"> 661     PlatformMediaSessionManager::sharedManager().forEachMatchingSession([](auto&amp; session) {</span>
<span class="line-modified"> 662         return is&lt;MediaElementSession&gt;(session);</span>
<span class="line-added"> 663     }, [&amp;](auto&amp; session) {</span>
<span class="line-added"> 664         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(session), purpose);</span>
 665         if (mediaElementSessionInfo.canShowControlsManager)
 666             candidateSessions.append(mediaElementSessionInfo);
 667         else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
 668             atLeastOneNonCandidateMayBeConfusedForMainContent = true;
<a name="17" id="anc17"></a><span class="line-modified"> 669     });</span>
 670 
 671     if (!candidateSessions.size())
 672         return nullptr;
 673 
 674     std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
 675     auto strongestSessionCandidate = candidateSessions.first();
 676     if (!strongestSessionCandidate.isVisibleInViewportOrFullscreen &amp;&amp; !strongestSessionCandidate.isPlayingAudio &amp;&amp; atLeastOneNonCandidateMayBeConfusedForMainContent)
 677         return nullptr;
 678 
 679     return &amp;strongestSessionCandidate.session-&gt;element();
 680 }
 681 
 682 void HTMLMediaElement::registerWithDocument(Document&amp; document)
 683 {
 684     m_mediaSession-&gt;registerWithDocument(document);
 685 
 686     if (m_isWaitingUntilMediaCanStart)
 687         document.addMediaCanStartListener(*this);
 688 
 689 #if !PLATFORM(IOS_FAMILY)
 690     document.registerForMediaVolumeCallbacks(*this);
 691     document.registerForPrivateBrowsingStateChangedCallbacks(*this);
 692 #endif
 693 
 694     document.registerForVisibilityStateChangedCallbacks(*this);
 695 
 696 #if ENABLE(VIDEO_TRACK)
 697     if (m_requireCaptionPreferencesChangedCallbacks)
 698         document.registerForCaptionPreferencesChangedCallbacks(*this);
 699 #endif
 700 
 701 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 702     if (m_mediaControlsDependOnPageScaleFactor)
 703         document.registerForPageScaleFactorChangedCallbacks(*this);
 704     document.registerForUserInterfaceLayoutDirectionChangedCallbacks(*this);
 705 #endif
 706 
 707 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 708     document.registerForDocumentSuspensionCallbacks(*this);
 709 #endif
 710 
 711     document.registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);
 712 
 713     document.addAudioProducer(*this);
 714     addElementToDocumentMap(*this, document);
 715 
 716 #if ENABLE(MEDIA_STREAM)
 717     document.registerForMediaStreamStateChangeCallbacks(*this);
 718 #endif
 719 
 720     document.addApplicationStateChangeListener(*this);
 721 }
 722 
 723 void HTMLMediaElement::unregisterWithDocument(Document&amp; document)
 724 {
 725     m_mediaSession-&gt;unregisterWithDocument(document);
 726 
 727     if (m_isWaitingUntilMediaCanStart)
 728         document.removeMediaCanStartListener(*this);
 729 
 730 #if !PLATFORM(IOS_FAMILY)
 731     document.unregisterForMediaVolumeCallbacks(*this);
 732     document.unregisterForPrivateBrowsingStateChangedCallbacks(*this);
 733 #endif
 734 
 735     document.unregisterForVisibilityStateChangedCallbacks(*this);
 736 
 737 #if ENABLE(VIDEO_TRACK)
 738     if (m_requireCaptionPreferencesChangedCallbacks)
 739         document.unregisterForCaptionPreferencesChangedCallbacks(*this);
 740 #endif
 741 
 742 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 743     if (m_mediaControlsDependOnPageScaleFactor)
 744         document.unregisterForPageScaleFactorChangedCallbacks(*this);
 745     document.unregisterForUserInterfaceLayoutDirectionChangedCallbacks(*this);
 746 #endif
 747 
 748 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 749     document.unregisterForDocumentSuspensionCallbacks(*this);
 750 #endif
 751 
 752     document.unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);
 753 
 754     document.removeAudioProducer(*this);
 755     removeElementFromDocumentMap(*this, document);
 756 
 757 #if ENABLE(MEDIA_STREAM)
 758     document.unregisterForMediaStreamStateChangeCallbacks(*this);
 759 #endif
 760 
 761     document.removeApplicationStateChangeListener(*this);
 762 }
 763 
 764 void HTMLMediaElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 765 {
 766     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
 767     if (m_shouldDelayLoadEvent) {
 768         oldDocument.decrementLoadEventDelayCount();
 769         newDocument.incrementLoadEventDelayCount();
 770     }
 771 
 772     unregisterWithDocument(oldDocument);
 773     registerWithDocument(newDocument);
 774 
 775     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
 776     updateShouldAutoplay();
 777 }
 778 
 779 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 780 void HTMLMediaElement::prepareForDocumentSuspension()
 781 {
 782     m_mediaSession-&gt;unregisterWithDocument(document());
 783 }
 784 
 785 void HTMLMediaElement::resumeFromDocumentSuspension()
 786 {
 787     m_mediaSession-&gt;registerWithDocument(document());
 788     updateShouldAutoplay();
 789 }
 790 #endif
 791 
 792 bool HTMLMediaElement::supportsFocus() const
 793 {
 794     if (document().isMediaDocument())
 795         return false;
 796 
 797     // If no controls specified, we should still be able to focus the element if it has tabIndex.
 798     return controls() ||  HTMLElement::supportsFocus();
 799 }
 800 
 801 bool HTMLMediaElement::isMouseFocusable() const
 802 {
 803     return false;
 804 }
 805 
<a name="18" id="anc18"></a><span class="line-modified"> 806 bool HTMLMediaElement::isInteractiveContent() const</span>
<span class="line-added"> 807 {</span>
<span class="line-added"> 808     return controls();</span>
<span class="line-added"> 809 }</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811 void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
 812 {
 813     if (name == srcAttr) {
 814         // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
 815         // Location of the Media Resource
 816         // 12 February 2017
 817 
 818         // If a src attribute of a media element is set or changed, the user
 819         // agent must invoke the media element&#39;s media element load algorithm.
 820         if (!value.isNull())
 821             prepareForLoad();
 822     } else if (name == controlsAttr)
 823         configureMediaControls();
 824     else if (name == loopAttr)
 825         updateSleepDisabling();
 826     else if (name == preloadAttr) {
 827         if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
 828             m_preload = MediaPlayer::None;
 829         else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
 830             m_preload = MediaPlayer::MetaData;
 831         else {
 832             // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
 833             // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
 834             m_preload = MediaPlayer::Auto;
 835         }
 836 
 837         // The attribute must be ignored if the autoplay attribute is present
 838         if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
 839             m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
 840 
 841     } else if (name == mediagroupAttr)
 842         setMediaGroup(value);
 843     else if (name == autoplayAttr) {
 844         if (processingUserGestureForMedia())
<a name="19" id="anc19"></a><span class="line-modified"> 845             removeBehaviorRestrictionsAfterFirstUserGesture();</span>
 846     } else if (name == titleAttr) {
 847         if (m_mediaSession)
 848             m_mediaSession-&gt;clientCharacteristicsChanged();
 849     }
 850     else
 851         HTMLElement::parseAttribute(name, value);
 852 }
 853 
 854 void HTMLMediaElement::finishParsingChildren()
 855 {
 856     HTMLElement::finishParsingChildren();
 857     m_parsingInProgress = false;
 858 
 859 #if ENABLE(VIDEO_TRACK)
 860     if (childrenOfType&lt;HTMLTrackElement&gt;(*this).first())
 861         scheduleConfigureTextTracks();
 862 #endif
 863 }
 864 
 865 bool HTMLMediaElement::rendererIsNeeded(const RenderStyle&amp; style)
 866 {
 867     return controls() &amp;&amp; HTMLElement::rendererIsNeeded(style);
 868 }
 869 
 870 RenderPtr&lt;RenderElement&gt; HTMLMediaElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 871 {
 872     return createRenderer&lt;RenderMedia&gt;(*this, WTFMove(style));
 873 }
 874 
 875 bool HTMLMediaElement::childShouldCreateRenderer(const Node&amp; child) const
 876 {
 877 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 878     return hasShadowRootParent(child) &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
 879 #else
 880     if (!hasMediaControls())
 881         return false;
 882     // &lt;media&gt; doesn&#39;t allow its content, including shadow subtree, to
 883     // be rendered. So this should return false for most of the children.
 884     // One exception is a shadow tree built for rendering controls which should be visible.
 885     // So we let them go here by comparing its subtree root with one of the controls.
 886     return &amp;mediaControls()-&gt;treeScope() == &amp;child.treeScope()
 887         &amp;&amp; hasShadowRootParent(child)
 888         &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
 889 #endif
 890 }
 891 
 892 Node::InsertedIntoAncestorResult HTMLMediaElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 893 {
 894     INFO_LOG(LOGIDENTIFIER);
 895 
 896     HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 897     if (insertionType.connectedToDocument)
 898         setInActiveDocument(true);
 899 
 900     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
 901 }
 902 
 903 void HTMLMediaElement::didFinishInsertingNode()
 904 {
 905     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
 906 
 907     INFO_LOG(LOGIDENTIFIER);
 908 
 909     if (m_inActiveDocument &amp;&amp; m_networkState == NETWORK_EMPTY &amp;&amp; !attributeWithoutSynchronization(srcAttr).isEmpty())
 910         prepareForLoad();
 911 
 912     if (!m_explicitlyMuted) {
 913         m_explicitlyMuted = true;
 914         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
 915         m_mediaSession-&gt;canProduceAudioChanged();
 916     }
 917 
 918     configureMediaControls();
 919 }
 920 
 921 void HTMLMediaElement::pauseAfterDetachedTask()
 922 {
 923     // If we were re-inserted into an active document, no need to pause.
 924     if (m_inActiveDocument)
 925         return;
 926 
 927     if (hasMediaControls())
 928         mediaControls()-&gt;hide();
 929     if (m_networkState &gt; NETWORK_EMPTY)
 930         pause();
 931     if (m_videoFullscreenMode != VideoFullscreenModeNone)
 932         exitFullscreen();
 933 
 934     if (!m_player)
 935         return;
 936 
 937     size_t extraMemoryCost = m_player-&gt;extraMemoryCost();
 938     if (extraMemoryCost &gt; m_reportedExtraMemoryCost) {
 939         JSC::VM&amp; vm = commonVM();
 940         JSC::JSLockHolder lock(vm);
 941 
 942         size_t extraMemoryCostDelta = extraMemoryCost - m_reportedExtraMemoryCost;
 943         m_reportedExtraMemoryCost = extraMemoryCost;
 944         // FIXME: Adopt reportExtraMemoryVisited, and switch to reportExtraMemoryAllocated.
 945         // https://bugs.webkit.org/show_bug.cgi?id=142595
 946         vm.heap.deprecatedReportExtraMemory(extraMemoryCostDelta);
 947     }
 948 }
 949 
 950 void HTMLMediaElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
 951 {
 952     INFO_LOG(LOGIDENTIFIER);
 953 
 954     setInActiveDocument(false);
 955     if (removalType.disconnectedFromDocument) {
 956         // Pause asynchronously to let the operation that removed us finish, in case we get inserted back into a document.
 957         m_pauseAfterDetachedTaskQueue.enqueueTask(std::bind(&amp;HTMLMediaElement::pauseAfterDetachedTask, this));
 958     }
 959 
 960     if (m_mediaSession)
 961         m_mediaSession-&gt;clientCharacteristicsChanged();
 962 
 963     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 964 }
 965 
 966 void HTMLMediaElement::willAttachRenderers()
 967 {
 968     ASSERT(!renderer());
 969 }
 970 
 971 inline void HTMLMediaElement::updateRenderer()
 972 {
 973     if (auto* renderer = this-&gt;renderer())
 974         renderer-&gt;updateFromElement();
 975 }
 976 
 977 void HTMLMediaElement::didAttachRenderers()
 978 {
 979     if (auto* renderer = this-&gt;renderer()) {
 980         renderer-&gt;updateFromElement();
 981         if (m_mediaSession &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay())
 982             renderer-&gt;registerForVisibleInViewportCallback();
 983     }
 984     updateShouldAutoplay();
 985 }
 986 
 987 void HTMLMediaElement::willDetachRenderers()
 988 {
 989     if (auto* renderer = this-&gt;renderer())
 990         renderer-&gt;unregisterForVisibleInViewportCallback();
 991 }
 992 
 993 void HTMLMediaElement::didDetachRenderers()
 994 {
 995     updateShouldAutoplay();
 996 }
 997 
 998 void HTMLMediaElement::didRecalcStyle(Style::Change)
 999 {
1000     updateRenderer();
1001 }
1002 
1003 void HTMLMediaElement::scheduleNextSourceChild()
1004 {
1005     // Schedule the timer to try the next &lt;source&gt; element WITHOUT resetting state ala prepareForLoad.
1006     m_resourceSelectionTaskQueue.enqueueTask([this] {
1007         loadNextSourceChild();
1008     });
1009 }
1010 
1011 void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*)
1012 {
1013     m_hasEverHadAudio |= hasAudio();
1014     m_hasEverHadVideo |= hasVideo();
1015 }
1016 
<a name="20" id="anc20"></a><span class="line-modified">1017 void HTMLMediaElement::scheduleEvent(const AtomString&amp; eventName)</span>
1018 {
1019     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
1020 
1021     // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
1022     // will trigger an ASSERT if this element has been marked for deletion.
1023 
1024     m_asyncEventQueue.enqueueEvent(WTFMove(event));
1025 }
1026 
1027 void HTMLMediaElement::scheduleResolvePendingPlayPromises()
1028 {
1029     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1030         resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1031     });
1032 }
1033 
1034 void HTMLMediaElement::scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp; error)
1035 {
1036     m_promiseTaskQueue.enqueueTask([this, error = WTFMove(error), pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1037         rejectPendingPlayPromises(WTFMove(pendingPlayPromises), WTFMove(error));
1038     });
1039 }
1040 
1041 void HTMLMediaElement::rejectPendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises, Ref&lt;DOMException&gt;&amp;&amp; error)
1042 {
1043     for (auto&amp; promise : pendingPlayPromises)
1044         promise.rejectType&lt;IDLInterface&lt;DOMException&gt;&gt;(error);
1045 }
1046 
1047 void HTMLMediaElement::resolvePendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises)
1048 {
1049     for (auto&amp; promise : pendingPlayPromises)
1050         promise.resolve();
1051 }
1052 
1053 void HTMLMediaElement::scheduleNotifyAboutPlaying()
1054 {
1055     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1056         notifyAboutPlaying(WTFMove(pendingPlayPromises));
1057     });
1058 }
1059 
1060 void HTMLMediaElement::notifyAboutPlaying(PlayPromiseVector&amp;&amp; pendingPlayPromises)
1061 {
1062     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // The &#39;playing&#39; event can make arbitrary DOM mutations.
1063     m_playbackStartedTime = currentMediaTime().toDouble();
1064     m_hasEverNotifiedAboutPlaying = true;
1065     dispatchEvent(Event::create(eventNames().playingEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
1066     resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1067 
1068     schedulePlaybackControlsManagerUpdate();
1069 }
1070 
1071 bool HTMLMediaElement::hasEverNotifiedAboutPlaying() const
1072 {
1073     return m_hasEverNotifiedAboutPlaying;
1074 }
1075 
1076 void HTMLMediaElement::scheduleCheckPlaybackTargetCompatability()
1077 {
1078     if (m_checkPlaybackTargetCompatablityTask.hasPendingTask())
1079         return;
1080 
1081     auto logSiteIdentifier = LOGIDENTIFIER;
1082     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
1083     m_checkPlaybackTargetCompatablityTask.scheduleTask([this, logSiteIdentifier] {
1084         UNUSED_PARAM(logSiteIdentifier);
1085         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1086         checkPlaybackTargetCompatablity();
1087     });
1088 }
1089 
1090 void HTMLMediaElement::checkPlaybackTargetCompatablity()
1091 {
1092 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="21" id="anc21"></a><span class="line-added">1093     auto logSiteIdentifier = LOGIDENTIFIER;</span>
<span class="line-added">1094     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);</span>
1095     if (m_isPlayingToWirelessTarget &amp;&amp; !m_player-&gt;canPlayToWirelessPlaybackTarget()) {
<a name="22" id="anc22"></a><span class="line-modified">1096         UNUSED_PARAM(logSiteIdentifier);</span>
<span class="line-added">1097         INFO_LOG(logSiteIdentifier, &quot;calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
1098         m_failedToPlayToWirelessTarget = true;
1099         m_player-&gt;setShouldPlayToPlaybackTarget(false);
1100     }
1101 #endif
1102 }
1103 
1104 MediaError* HTMLMediaElement::error() const
1105 {
1106     return m_error.get();
1107 }
1108 
1109 void HTMLMediaElement::setSrcObject(MediaProvider&amp;&amp; mediaProvider)
1110 {
1111     // FIXME: Setting the srcObject attribute may cause other changes to the media element&#39;s internal state:
1112     // Specifically, if srcObject is specified, the UA must use it as the source of media, even if the src
1113     // attribute is also set or children are present. If the value of srcObject is replaced or set to null
1114     // the UA must re-run the media element load algorithm.
1115     //
1116     // https://bugs.webkit.org/show_bug.cgi?id=124896
1117 
1118 
1119     // https://www.w3.org/TR/html51/semantics-embedded-content.html#dom-htmlmediaelement-srcobject
1120     // 4.7.14.2. Location of the media resource
1121     // srcObject: On setting, it must set the element’s assigned media provider object to the new
1122     // value, and then invoke the element’s media element load algorithm.
1123     INFO_LOG(LOGIDENTIFIER);
1124     m_mediaProvider = WTFMove(mediaProvider);
1125     prepareForLoad();
1126 }
1127 
<a name="23" id="anc23"></a><span class="line-modified">1128 void HTMLMediaElement::setCrossOrigin(const AtomString&amp; value)</span>
1129 {
1130     setAttributeWithoutSynchronization(crossoriginAttr, value);
1131 }
1132 
1133 String HTMLMediaElement::crossOrigin() const
1134 {
1135     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
1136 }
1137 
1138 HTMLMediaElement::NetworkState HTMLMediaElement::networkState() const
1139 {
1140     return m_networkState;
1141 }
1142 
1143 String HTMLMediaElement::canPlayType(const String&amp; mimeType) const
1144 {
1145     MediaEngineSupportParameters parameters;
1146     ContentType contentType(mimeType);
1147     parameters.type = contentType;
1148     parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
1149     MediaPlayer::SupportsType support = MediaPlayer::supportsType(parameters);
1150     String canPlay;
1151 
1152     // 4.8.10.3
1153     switch (support)
1154     {
1155         case MediaPlayer::IsNotSupported:
1156             canPlay = emptyString();
1157             break;
1158         case MediaPlayer::MayBeSupported:
1159             canPlay = &quot;maybe&quot;_s;
1160             break;
1161         case MediaPlayer::IsSupported:
1162             canPlay = &quot;probably&quot;_s;
1163             break;
1164     }
1165 
<a name="24" id="anc24"></a><span class="line-modified">1166     INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);</span>
1167 
1168     return canPlay;
1169 }
1170 
1171 double HTMLMediaElement::getStartDate() const
1172 {
1173     if (!m_player)
1174         return std::numeric_limits&lt;double&gt;::quiet_NaN();
1175     return m_player-&gt;getStartDate().toDouble();
1176 }
1177 
1178 void HTMLMediaElement::load()
1179 {
1180     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
1181 
1182     INFO_LOG(LOGIDENTIFIER);
1183 
<a name="25" id="anc25"></a>


1184     prepareForLoad();
1185     m_resourceSelectionTaskQueue.enqueueTask([this] {
1186         prepareToPlay();
1187     });
1188 }
1189 
1190 void HTMLMediaElement::prepareForLoad()
1191 {
1192     // https://html.spec.whatwg.org/multipage/embedded-content.html#media-element-load-algorithm
1193     // The Media Element Load Algorithm
1194     // 12 February 2017
1195 
<a name="26" id="anc26"></a><span class="line-modified">1196     ALWAYS_LOG(LOGIDENTIFIER, &quot;gesture = &quot;, processingUserGestureForMedia());</span>
<span class="line-added">1197 </span>
<span class="line-added">1198     if (processingUserGestureForMedia())</span>
<span class="line-added">1199         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
1200 
1201     // 1 - Abort any already-running instance of the resource selection algorithm for this element.
1202     // Perform the cleanup required for the resource load algorithm to run.
1203     stopPeriodicTimers();
1204     m_resourceSelectionTaskQueue.cancelAllTasks();
1205     // FIXME: Figure out appropriate place to reset LoadTextTrackResource if necessary and set m_pendingActionFlags to 0 here.
1206     m_sentEndEvent = false;
1207     m_sentStalledEvent = false;
1208     m_haveFiredLoadedData = false;
1209     m_completelyLoaded = false;
1210     m_havePreparedToPlay = false;
1211     m_displayMode = Unknown;
1212     m_currentSrc = URL();
1213 
1214 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1215     m_failedToPlayToWirelessTarget = false;
1216 #endif
1217 
1218     m_loadState = WaitingForSource;
1219     m_currentSourceNode = nullptr;
1220 
1221     if (!document().hasBrowsingContext())
1222         return;
1223 
1224     createMediaPlayer();
1225 
1226     // 2 - Let pending tasks be a list of all tasks from the media element&#39;s media element event task source in one of the task queues.
1227     // 3 - For each task in pending tasks that would resolve pending play promises or reject pending play promises, immediately resolve or reject those promises in the order the corresponding tasks were queued.
1228     // 4 - Remove each task in pending tasks from its task queue
1229     cancelPendingEventsAndCallbacks();
1230 
1231     // 5 - If the media element&#39;s networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue
1232     // a task to fire a simple event named abort at the media element.
1233     if (m_networkState == NETWORK_LOADING || m_networkState == NETWORK_IDLE)
1234         scheduleEvent(eventNames().abortEvent);
1235 
1236     // 6 - If the media element&#39;s networkState is not set to NETWORK_EMPTY, then run these substeps
1237     if (m_networkState != NETWORK_EMPTY) {
1238         // 6.1 - Queue a task to fire a simple event named emptied at the media element.
1239         scheduleEvent(eventNames().emptiedEvent);
1240 
1241         // 6.2 - If a fetching process is in progress for the media element, the user agent should stop it.
1242         m_networkState = NETWORK_EMPTY;
1243 
1244         // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
1245 #if ENABLE(MEDIA_SOURCE)
1246         detachMediaSource();
1247 #endif
1248 
<a name="27" id="anc27"></a>
1249         // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
1250         forgetResourceSpecificTracks();
<a name="28" id="anc28"></a>
1251 
1252         // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
1253         m_readyState = HAVE_NOTHING;
1254         m_readyStateMaximum = HAVE_NOTHING;
1255 
1256         // 6.6 - If the paused attribute is false, then set it to true.
1257         m_paused = true;
1258 
1259         // 6.7 - If seeking is true, set it to false.
1260         clearSeeking();
1261 
1262         // 6.8 - Set the current playback position to 0.
1263         //       Set the official playback position to 0.
1264         //       If this changed the official playback position, then queue a task to fire a simple event named timeupdate at the media element.
1265         m_lastSeekTime = MediaTime::zeroTime();
1266         m_playedTimeRanges = TimeRanges::create();
1267         // FIXME: Add support for firing this event. e.g., scheduleEvent(eventNames().timeUpdateEvent);
1268 
1269         // 4.9 - Set the initial playback position to 0.
1270         // FIXME: Make this less subtle. The position only becomes 0 because of the createMediaPlayer() call
1271         // above.
1272         refreshCachedTime();
1273 
1274         invalidateCachedTime();
1275 
1276         // 4.10 - Set the timeline offset to Not-a-Number (NaN).
1277         // 4.11 - Update the duration attribute to Not-a-Number (NaN).
1278 
1279         updateMediaController();
1280 #if ENABLE(VIDEO_TRACK)
1281         updateActiveTextTrackCues(MediaTime::zeroTime());
1282 #endif
1283     }
1284 
1285     // 7 - Set the playbackRate attribute to the value of the defaultPlaybackRate attribute.
1286     setPlaybackRate(defaultPlaybackRate());
1287 
1288     // 8 - Set the error attribute to null and the autoplaying flag to true.
1289     m_error = nullptr;
1290     m_autoplaying = true;
1291     mediaSession().clientWillBeginAutoplaying();
1292 
1293     if (!MediaPlayer::isAvailable())
1294         noneSupported();
1295     else {
1296         // 9 - Invoke the media element&#39;s resource selection algorithm.
1297         // Note, unless the restriction on requiring user action has been removed,
1298         // do not begin downloading data.
1299         if (m_mediaSession-&gt;dataLoadingPermitted())
1300             selectMediaResource();
1301     }
1302 
1303     // 10 - Note: Playback of any previously playing media resource for this element stops.
1304 
1305     configureMediaControls();
1306 }
1307 
1308 void HTMLMediaElement::selectMediaResource()
1309 {
1310     // https://www.w3.org/TR/2016/REC-html51-20161101/semantics-embedded-content.html#resource-selection-algorithm
1311     // The Resource Selection Algorithm
1312 
1313     // 1. Set the element’s networkState attribute to the NETWORK_NO_SOURCE value.
1314     m_networkState = NETWORK_NO_SOURCE;
1315 
1316     // 2. Set the element’s show poster flag to true.
1317     setDisplayMode(Poster);
1318 
1319     // 3. Set the media element’s delaying-the-load-event flag to true (this delays the load event).
1320     setShouldDelayLoadEvent(true);
1321 
1322     // 4. in parallel await a stable state, allowing the task that invoked this algorithm to continue.
1323     if (m_resourceSelectionTaskQueue.hasPendingTasks())
1324         return;
1325 
1326     if (!m_mediaSession-&gt;pageAllowsDataLoading()) {
1327         ALWAYS_LOG(LOGIDENTIFIER, &quot;not allowed to load in background, waiting&quot;);
1328         setShouldDelayLoadEvent(false);
1329         if (m_isWaitingUntilMediaCanStart)
1330             return;
1331         m_isWaitingUntilMediaCanStart = true;
1332         document().addMediaCanStartListener(*this);
1333         return;
1334     }
1335 
1336     // Once the page has allowed an element to load media, it is free to load at will. This allows a
1337     // playlist that starts in a foreground tab to continue automatically if the tab is subsequently
1338     // put into the background.
1339     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
1340 
1341     auto logSiteIdentifier = LOGIDENTIFIER;
1342     UNUSED_PARAM(logSiteIdentifier);
1343 
1344     m_resourceSelectionTaskQueue.enqueueTask([this, logSiteIdentifier]  {
1345 
1346         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1347 
1348         // 5. If the media element’s blocked-on-parser flag is false, then populate the list of pending text tracks.
1349 #if ENABLE(VIDEO_TRACK)
1350         if (hasMediaControls())
1351             mediaControls()-&gt;changedClosedCaptionsVisibility();
1352 
1353         // HTMLMediaElement::textTracksAreReady will need &quot;... the text tracks whose mode was not in the
1354         // disabled state when the element&#39;s resource selection algorithm last started&quot;.
1355         // FIXME: Update this to match &quot;populate the list of pending text tracks&quot; step.
1356         m_textTracksWhenResourceSelectionBegan.clear();
1357         if (m_textTracks) {
1358             for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
1359                 RefPtr&lt;TextTrack&gt; track = m_textTracks-&gt;item(i);
1360                 if (track-&gt;mode() != TextTrack::Mode::Disabled)
1361                     m_textTracksWhenResourceSelectionBegan.append(track);
1362             }
1363         }
1364 #endif
1365 
1366         enum Mode { None, Object, Attribute, Children };
1367         Mode mode = None;
1368 
1369         if (m_mediaProvider) {
1370             // 6. If the media element has an assigned media provider object, then let mode be object.
1371             mode = Object;
1372         } else if (hasAttributeWithoutSynchronization(srcAttr)) {
1373             //    Otherwise, if the media element has no assigned media provider object but has a src attribute, then let mode be attribute.
1374             mode = Attribute;
1375             ASSERT(m_player);
1376             if (!m_player) {
1377                 ERROR_LOG(logSiteIdentifier, &quot; has srcAttr but m_player is not created&quot;);
1378                 return;
1379             }
1380         } else if (auto firstSource = childrenOfType&lt;HTMLSourceElement&gt;(*this).first()) {
1381             //    Otherwise, if the media element does not have an assigned media provider object and does not have a src attribute,
1382             //    but does have a source element child, then let mode be children and let candidate be the first such source element
1383             //    child in tree order.
1384             mode = Children;
1385             m_nextChildNodeToConsider = firstSource;
1386             m_currentSourceNode = nullptr;
1387         } else {
1388             //  Otherwise the media element has no assigned media provider object and has neither a src attribute nor a source
1389             //  element child: set the networkState to NETWORK_EMPTY, and abort these steps; the synchronous section ends.
1390             m_loadState = WaitingForSource;
1391             setShouldDelayLoadEvent(false);
1392             m_networkState = NETWORK_EMPTY;
1393 
1394             ALWAYS_LOG(logSiteIdentifier, &quot;nothing to load&quot;);
1395             return;
1396         }
1397 
1398         // 7. Set the media element’s networkState to NETWORK_LOADING.
1399         m_networkState = NETWORK_LOADING;
1400 
1401         // 8. Queue a task to fire a simple event named loadstart at the media element.
1402         scheduleEvent(eventNames().loadstartEvent);
1403 
1404         // 9. Run the appropriate steps from the following list:
1405         // ↳ If mode is object
1406         if (mode == Object) {
1407             // 1. Set the currentSrc attribute to the empty string.
1408             m_currentSrc = URL();
1409 
1410             // 2. End the synchronous section, continuing the remaining steps in parallel.
1411             // 3. Run the resource fetch algorithm with the assigned media provider object.
1412             switchOn(m_mediaProvider.value(),
1413 #if ENABLE(MEDIA_STREAM)
1414                 [this](RefPtr&lt;MediaStream&gt; stream) { m_mediaStreamSrcObject = stream; },
1415 #endif
1416 #if ENABLE(MEDIA_SOURCE)
1417                 [this](RefPtr&lt;MediaSource&gt; source) { m_mediaSource = source; },
1418 #endif
1419                 [this](RefPtr&lt;Blob&gt; blob) { m_blob = blob; }
1420             );
1421 
1422             ContentType contentType;
1423             loadResource(URL(), contentType, String());
1424             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;srcObject&#39; property&quot;);
1425 
1426             //    If that algorithm returns without aborting this one, then the load failed.
1427             // 4. Failed with media provider: Reaching this step indicates that the media resource
1428             //    failed to load. Queue a task to run the dedicated media source failure steps.
1429             // 5. Wait for the task queued by the previous step to have executed.
1430             // 6. Abort these steps. The element won’t attempt to load another resource until this
1431             //    algorithm is triggered again.
1432             return;
1433         }
1434 
1435         // ↳ If mode is attribute
1436         if (mode == Attribute) {
1437             m_loadState = LoadingFromSrcAttr;
1438 
1439             // 1. If the src attribute’s value is the empty string, then end the synchronous section,
1440             //    and jump down to the failed with attribute step below.
1441             // 2. Let absolute URL be the absolute URL that would have resulted from parsing the URL
1442             //    specified by the src attribute’s value relative to the media element when the src
1443             //    attribute was last changed.
1444             URL absoluteURL = getNonEmptyURLAttribute(srcAttr);
1445             if (absoluteURL.isEmpty()) {
1446                 mediaLoadingFailed(MediaPlayer::FormatError);
1447                 ALWAYS_LOG(logSiteIdentifier, &quot;empty &#39;src&#39;&quot;);
1448                 return;
1449             }
1450 
1451             if (!isSafeToLoadURL(absoluteURL, Complain) || !dispatchBeforeLoadEvent(absoluteURL.string())) {
1452                 mediaLoadingFailed(MediaPlayer::FormatError);
1453                 return;
1454             }
1455 
1456             // 3. If absolute URL was obtained successfully, set the currentSrc attribute to absolute URL.
1457             m_currentSrc = absoluteURL;
1458 
1459             // 4. End the synchronous section, continuing the remaining steps in parallel.
1460             // 5. If absolute URL was obtained successfully, run the resource fetch algorithm with absolute
1461             //    URL. If that algorithm returns without aborting this one, then the load failed.
1462 
1463             // No type or key system information is available when the url comes
1464             // from the &#39;src&#39; attribute so MediaPlayer
1465             // will have to pick a media engine based on the file extension.
1466             ContentType contentType;
1467             loadResource(absoluteURL, contentType, String());
1468             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;src&#39; attribute url&quot;);
1469 
1470             // 6. Failed with attribute: Reaching this step indicates that the media resource failed to load
1471             //    or that the given URL could not be resolved. Queue a task to run the dedicated media source failure steps.
1472             // 7. Wait for the task queued by the previous step to have executed.
1473             // 8. Abort these steps. The element won’t attempt to load another resource until this algorithm is triggered again.
1474             return;
1475         }
1476 
1477         // ↳ Otherwise (mode is children)
1478         // (Ctd. in loadNextSourceChild())
1479         loadNextSourceChild();
1480     });
1481 }
1482 
1483 void HTMLMediaElement::loadNextSourceChild()
1484 {
1485     ContentType contentType;
1486     String keySystem;
1487     URL mediaURL = selectNextSourceChild(&amp;contentType, &amp;keySystem, Complain);
1488     if (!mediaURL.isValid()) {
1489         waitForSourceChange();
1490         return;
1491     }
1492 
1493     // Recreate the media player for the new url
1494     createMediaPlayer();
1495 
1496     m_loadState = LoadingFromSourceElement;
1497     loadResource(mediaURL, contentType, keySystem);
1498 }
1499 
1500 void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
1501 {
1502     ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
1503 
<a name="29" id="anc29"></a><span class="line-modified">1504     INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);</span>
1505 
1506     RefPtr&lt;Frame&gt; frame = document().frame();
1507     if (!frame) {
1508         mediaLoadingFailed(MediaPlayer::FormatError);
1509         return;
1510     }
1511 
1512     Page* page = frame-&gt;page();
1513     if (!page) {
1514         mediaLoadingFailed(MediaPlayer::FormatError);
1515         return;
1516     }
1517 
1518     URL url = initialURL;
1519     if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
1520         mediaLoadingFailed(MediaPlayer::FormatError);
1521         return;
1522     }
1523 
1524 #if ENABLE(CONTENT_EXTENSIONS)
1525     if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
<a name="30" id="anc30"></a><span class="line-modified">1526         if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {</span>
1527             mediaLoadingFailed(MediaPlayer::FormatError);
1528             return;
1529         }
1530     }
1531 #endif
1532 
1533     // The resource fetch algorithm
1534     m_networkState = NETWORK_LOADING;
1535 
1536     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
1537     ApplicationCacheResource* resource = nullptr;
1538     if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
1539         // Resources that are not present in the manifest will always fail to load (at least, after the
1540         // cache has been primed the first time), making the testing of offline applications simpler.
1541         if (!resource || resource-&gt;path().isEmpty()) {
1542             mediaLoadingFailed(MediaPlayer::NetworkError);
1543             return;
1544         }
1545     }
1546 
1547     // Log that we started loading a media element.
1548     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
1549 
1550     m_firstTimePlaying = true;
1551 
1552     // Set m_currentSrc *before* changing to the cache URL, the fact that we are loading from the app
1553     // cache is an internal detail not exposed through the media element API.
1554     m_currentSrc = url;
1555 
1556     if (resource) {
1557         url = ApplicationCacheHost::createFileURL(resource-&gt;path());
<a name="31" id="anc31"></a><span class="line-modified">1558         INFO_LOG(LOGIDENTIFIER, &quot;will load from app cache &quot;, url);</span>
1559     }
1560 
1561     INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
1562 
1563     startProgressEventTimer();
1564 
1565     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();
1566     m_player-&gt;setPrivateBrowsingMode(privateMode);
1567 
1568     // Reset display mode to force a recalculation of what to show because we are resetting the player.
1569     setDisplayMode(Unknown);
1570 
1571     if (!autoplay() &amp;&amp; !m_havePreparedToPlay)
1572         m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
1573     m_player-&gt;setPreservesPitch(m_webkitPreservesPitch);
1574 
1575     if (!m_explicitlyMuted) {
1576         m_explicitlyMuted = true;
1577         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
1578         m_mediaSession-&gt;canProduceAudioChanged();
1579     }
1580 
1581     updateVolume();
1582 
1583     bool loadAttempted = false;
1584 #if ENABLE(MEDIA_SOURCE)
1585     if (!m_mediaSource &amp;&amp; url.protocolIs(mediaSourceBlobProtocol))
1586         m_mediaSource = MediaSource::lookup(url.string());
1587 
1588     if (m_mediaSource) {
1589         loadAttempted = true;
1590 
1591         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
1592         if (!m_mediaSource-&gt;attachToElement(*this) || !m_player-&gt;load(url, contentType, m_mediaSource.get())) {
1593             // Forget our reference to the MediaSource, so we leave it alone
1594             // while processing remainder of load failure.
1595             m_mediaSource = nullptr;
1596             mediaLoadingFailed(MediaPlayer::FormatError);
1597         }
1598     }
1599 #endif
<a name="32" id="anc32"></a>
1600 #if ENABLE(MEDIA_STREAM)
<a name="33" id="anc33"></a><span class="line-modified">1601     if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {</span>
<span class="line-modified">1602         loadAttempted = true;</span>
<span class="line-modified">1603         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);</span>
<span class="line-modified">1604         if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))</span>
<span class="line-modified">1605             mediaLoadingFailed(MediaPlayer::FormatError);</span>





1606     }
1607 #endif
1608 
1609     if (!loadAttempted &amp;&amp; m_blob) {
1610         loadAttempted = true;
1611         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
1612         if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
1613             mediaLoadingFailed(MediaPlayer::FormatError);
1614     }
1615 
1616     if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
1617         mediaLoadingFailed(MediaPlayer::FormatError);
1618 
1619     // If there is no poster to display, allow the media engine to render video frames as soon as
1620     // they are available.
1621     updateDisplayState();
1622 
1623     updateRenderer();
1624 }
1625 
1626 #if ENABLE(VIDEO_TRACK)
1627 
1628 static bool trackIndexCompare(TextTrack* a, TextTrack* b)
1629 {
1630     return a-&gt;trackIndex() - b-&gt;trackIndex() &lt; 0;
1631 }
1632 
1633 static bool eventTimeCueCompare(const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; a, const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; b)
1634 {
1635     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1636     // times first).
1637     if (a.first != b.first)
1638         return a.first - b.first &lt; MediaTime::zeroTime();
1639 
1640     // If the cues belong to different text tracks, it doesn&#39;t make sense to
1641     // compare the two tracks by the relative cue order, so return the relative
1642     // track order.
1643     if (a.second-&gt;track() != b.second-&gt;track())
1644         return trackIndexCompare(a.second-&gt;track(), b.second-&gt;track());
1645 
1646     // 12 - Further sort tasks in events that have the same time by the
1647     // relative text track cue order of the text track cues associated
1648     // with these tasks.
1649     return a.second-&gt;isOrderedBefore(b.second);
1650 }
1651 
1652 static bool compareCueInterval(const CueInterval&amp; one, const CueInterval&amp; two)
1653 {
1654     return one.data()-&gt;isOrderedBefore(two.data());
1655 }
1656 
1657 static bool compareCueIntervalEndTime(const CueInterval&amp; one, const CueInterval&amp; two)
1658 {
1659     return one.data()-&gt;endMediaTime() &gt; two.data()-&gt;endMediaTime();
1660 }
1661 
1662 void HTMLMediaElement::updateActiveTextTrackCues(const MediaTime&amp; movieTime)
1663 {
1664     // 4.8.10.8 Playing the media resource
1665 
1666     //  If the current playback position changes while the steps are running,
1667     //  then the user agent must wait for the steps to complete, and then must
1668     //  immediately rerun the steps.
1669     if (ignoreTrackDisplayUpdateRequests())
1670         return;
1671 
1672     // 1 - Let current cues be a list of cues, initialized to contain all the
1673     // cues of all the hidden, showing, or showing by default text tracks of the
1674     // media element (not the disabled ones) whose start times are less than or
1675     // equal to the current playback position and whose end times are greater
1676     // than the current playback position.
1677     CueList currentCues;
1678 
1679     // The user agent must synchronously unset [the text track cue active] flag
1680     // whenever ... the media element&#39;s readyState is changed back to HAVE_NOTHING.
1681     auto movieTimeInterval = m_cueTree.createInterval(movieTime, movieTime);
1682     if (m_readyState != HAVE_NOTHING &amp;&amp; m_player) {
1683         currentCues = m_cueTree.allOverlaps(movieTimeInterval);
1684         if (currentCues.size() &gt; 1)
1685             std::sort(currentCues.begin(), currentCues.end(), &amp;compareCueInterval);
1686     }
1687 
1688     CueList previousCues;
1689     CueList missedCues;
1690 
1691     // 2 - Let other cues be a list of cues, initialized to contain all the cues
1692     // of hidden, showing, and showing by default text tracks of the media
1693     // element that are not present in current cues.
1694     previousCues = m_currentlyActiveCues;
1695 
1696     // 3 - Let last time be the current playback position at the time this
1697     // algorithm was last run for this media element, if this is not the first
1698     // time it has run.
1699     MediaTime lastTime = m_lastTextTrackUpdateTime;
1700 
1701     // 4 - If the current playback position has, since the last time this
1702     // algorithm was run, only changed through its usual monotonic increase
1703     // during normal playback, then let missed cues be the list of cues in other
1704     // cues whose start times are greater than or equal to last time and whose
1705     // end times are less than or equal to the current playback position.
1706     // Otherwise, let missed cues be an empty list.
1707     if (lastTime &gt;= MediaTime::zeroTime() &amp;&amp; m_lastSeekTime &lt; movieTime) {
1708         for (auto&amp; cue : m_cueTree.allOverlaps(m_cueTree.createInterval(lastTime, movieTime))) {
1709             // Consider cues that may have been missed since the last seek time.
1710             if (cue.low() &gt; std::max(m_lastSeekTime, lastTime) &amp;&amp; cue.high() &lt; movieTime)
1711                 missedCues.append(cue);
1712         }
1713     }
1714 
1715     m_lastTextTrackUpdateTime = movieTime;
1716 
1717     // 5 - If the time was reached through the usual monotonic increase of the
1718     // current playback position during normal playback, and if the user agent
1719     // has not fired a timeupdate event at the element in the past 15 to 250ms
1720     // and is not still running event handlers for such an event, then the user
1721     // agent must queue a task to fire a simple event named timeupdate at the
1722     // element. (In the other cases, such as explicit seeks, relevant events get
1723     // fired as part of the overall process of changing the current playback
1724     // position.)
1725     if (!m_paused &amp;&amp; m_lastSeekTime &lt;= lastTime)
1726         scheduleTimeupdateEvent(false);
1727 
1728     // Explicitly cache vector sizes, as their content is constant from here.
1729     size_t currentCuesSize = currentCues.size();
1730     size_t missedCuesSize = missedCues.size();
1731     size_t previousCuesSize = previousCues.size();
1732 
1733     // 6 - If all of the cues in current cues have their text track cue active
1734     // flag set, none of the cues in other cues have their text track cue active
1735     // flag set, and missed cues is empty, then abort these steps.
1736     bool activeSetChanged = missedCuesSize;
1737 
1738     for (size_t i = 0; !activeSetChanged &amp;&amp; i &lt; previousCuesSize; ++i)
1739         if (!currentCues.contains(previousCues[i]) &amp;&amp; previousCues[i].data()-&gt;isActive())
1740             activeSetChanged = true;
1741 
1742     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1743         RefPtr&lt;TextTrackCue&gt; cue = currentCues[i].data();
1744 
1745         if (cue-&gt;isRenderable())
1746             toVTTCue(cue.get())-&gt;updateDisplayTree(movieTime);
1747 
1748         if (!cue-&gt;isActive())
1749             activeSetChanged = true;
1750     }
1751 
1752     MediaTime nextInterestingTime = MediaTime::invalidTime();
1753     if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
1754         nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
1755 
1756     Optional&lt;CueInterval&gt; nextCue = m_cueTree.nextIntervalAfter(movieTimeInterval);
1757     if (nextCue)
1758         nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
1759 
1760     INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
1761 
1762     if (nextInterestingTime.isValid() &amp;&amp; m_player) {
1763         m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
1764             if (!weakThis)
1765                 return;
1766 
<a name="34" id="anc34"></a><span class="line-modified">1767             auto currentMediaTime = this-&gt;currentMediaTime();</span>
<span class="line-modified">1768             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime: &quot;, currentMediaTime);</span>
<span class="line-modified">1769             this-&gt;updateActiveTextTrackCues(currentMediaTime);</span>
1770         }, nextInterestingTime);
1771     }
1772 
1773     if (!activeSetChanged)
1774         return;
1775 
1776     // 7 - If the time was reached through the usual monotonic increase of the
1777     // current playback position during normal playback, and there are cues in
1778     // other cues that have their text track cue pause-on-exi flag set and that
1779     // either have their text track cue active flag set or are also in missed
1780     // cues, then immediately pause the media element.
1781     for (size_t i = 0; !m_paused &amp;&amp; i &lt; previousCuesSize; ++i) {
1782         if (previousCues[i].data()-&gt;pauseOnExit()
1783             &amp;&amp; previousCues[i].data()-&gt;isActive()
1784             &amp;&amp; !currentCues.contains(previousCues[i]))
1785             pause();
1786     }
1787 
1788     for (size_t i = 0; !m_paused &amp;&amp; i &lt; missedCuesSize; ++i) {
1789         if (missedCues[i].data()-&gt;pauseOnExit())
1790             pause();
1791     }
1792 
1793     // 8 - Let events be a list of tasks, initially empty. Each task in this
1794     // list will be associated with a text track, a text track cue, and a time,
1795     // which are used to sort the list before the tasks are queued.
1796     Vector&lt;std::pair&lt;MediaTime, TextTrackCue*&gt;&gt; eventTasks;
1797 
1798     // 8 - Let affected tracks be a list of text tracks, initially empty.
1799     Vector&lt;TextTrack*&gt; affectedTracks;
1800 
1801     for (size_t i = 0; i &lt; missedCuesSize; ++i) {
1802         // 9 - For each text track cue in missed cues, prepare an event named enter
1803         // for the TextTrackCue object with the text track cue start time.
1804         eventTasks.append({ missedCues[i].data()-&gt;startMediaTime(), missedCues[i].data() });
1805 
1806         // 10 - For each text track [...] in missed cues, prepare an event
1807         // named exit for the TextTrackCue object with the  with the later of
1808         // the text track cue end time and the text track cue start time.
1809 
1810         // Note: An explicit task is added only if the cue is NOT a zero or
1811         // negative length cue. Otherwise, the need for an exit event is
1812         // checked when these tasks are actually queued below. This doesn&#39;t
1813         // affect sorting events before dispatch either, because the exit
1814         // event has the same time as the enter event.
1815         if (missedCues[i].data()-&gt;startMediaTime() &lt; missedCues[i].data()-&gt;endMediaTime())
1816             eventTasks.append({ missedCues[i].data()-&gt;endMediaTime(), missedCues[i].data() });
1817     }
1818 
1819     for (size_t i = 0; i &lt; previousCuesSize; ++i) {
1820         // 10 - For each text track cue in other cues that has its text
1821         // track cue active flag set prepare an event named exit for the
1822         // TextTrackCue object with the text track cue end time.
1823         if (!currentCues.contains(previousCues[i]))
1824             eventTasks.append({ previousCues[i].data()-&gt;endMediaTime(), previousCues[i].data() });
1825     }
1826 
1827     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1828         // 11 - For each text track cue in current cues that does not have its
1829         // text track cue active flag set, prepare an event named enter for the
1830         // TextTrackCue object with the text track cue start time.
1831         if (!previousCues.contains(currentCues[i]))
1832             eventTasks.append({ currentCues[i].data()-&gt;startMediaTime(), currentCues[i].data() });
1833     }
1834 
1835     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1836     // times first).
1837     std::sort(eventTasks.begin(), eventTasks.end(), eventTimeCueCompare);
1838 
1839     for (auto&amp; eventTask : eventTasks) {
1840         if (!affectedTracks.contains(eventTask.second-&gt;track()))
1841             affectedTracks.append(eventTask.second-&gt;track());
1842 
1843         // 13 - Queue each task in events, in list order.
1844 
1845         // Each event in eventTasks may be either an enterEvent or an exitEvent,
1846         // depending on the time that is associated with the event. This
1847         // correctly identifies the type of the event, if the startTime is
1848         // less than the endTime in the cue.
1849         if (eventTask.second-&gt;startTime() &gt;= eventTask.second-&gt;endTime()) {
1850             auto enterEvent = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1851             enterEvent-&gt;setTarget(eventTask.second);
1852             m_asyncEventQueue.enqueueEvent(WTFMove(enterEvent));
1853 
1854             auto exitEvent = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1855             exitEvent-&gt;setTarget(eventTask.second);
1856             m_asyncEventQueue.enqueueEvent(WTFMove(exitEvent));
1857         } else {
1858             RefPtr&lt;Event&gt; event;
1859             if (eventTask.first == eventTask.second-&gt;startMediaTime())
1860                 event = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1861             else
1862                 event = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1863             event-&gt;setTarget(eventTask.second);
1864             m_asyncEventQueue.enqueueEvent(WTFMove(event));
1865         }
1866     }
1867 
1868     // 14 - Sort affected tracks in the same order as the text tracks appear in
1869     // the media element&#39;s list of text tracks, and remove duplicates.
1870     std::sort(affectedTracks.begin(), affectedTracks.end(), trackIndexCompare);
1871 
1872     // 15 - For each text track in affected tracks, in the list order, queue a
1873     // task to fire a simple event named cuechange at the TextTrack object, and, ...
1874     for (auto&amp; affectedTrack : affectedTracks) {
1875         auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1876         event-&gt;setTarget(affectedTrack);
1877         m_asyncEventQueue.enqueueEvent(WTFMove(event));
1878 
1879         // ... if the text track has a corresponding track element, to then fire a
1880         // simple event named cuechange at the track element as well.
1881         if (is&lt;LoadableTextTrack&gt;(*affectedTrack)) {
1882             auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1883             auto trackElement = makeRefPtr(downcast&lt;LoadableTextTrack&gt;(*affectedTrack).trackElement());
1884             ASSERT(trackElement);
1885             event-&gt;setTarget(trackElement);
1886             m_asyncEventQueue.enqueueEvent(WTFMove(event));
1887         }
1888     }
1889 
1890     // 16 - Set the text track cue active flag of all the cues in the current
1891     // cues, and unset the text track cue active flag of all the cues in the
1892     // other cues.
1893     for (size_t i = 0; i &lt; currentCuesSize; ++i)
1894         currentCues[i].data()-&gt;setIsActive(true);
1895 
1896     for (size_t i = 0; i &lt; previousCuesSize; ++i)
1897         if (!currentCues.contains(previousCues[i]))
1898             previousCues[i].data()-&gt;setIsActive(false);
1899 
1900     // Update the current active cues.
1901     m_currentlyActiveCues = currentCues;
1902 
1903     if (activeSetChanged)
1904         updateTextTrackDisplay();
1905 }
1906 
1907 bool HTMLMediaElement::textTracksAreReady() const
1908 {
1909     // 4.8.10.12.1 Text track model
1910     // ...
1911     // The text tracks of a media element are ready if all the text tracks whose mode was not
1912     // in the disabled state when the element&#39;s resource selection algorithm last started now
1913     // have a text track readiness state of loaded or failed to load.
1914     for (unsigned i = 0; i &lt; m_textTracksWhenResourceSelectionBegan.size(); ++i) {
1915         if (m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::Loading
1916             || m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::NotLoaded)
1917             return false;
1918     }
1919 
1920     return true;
1921 }
1922 
1923 void HTMLMediaElement::textTrackReadyStateChanged(TextTrack* track)
1924 {
1925     if (track-&gt;readinessState() != TextTrack::Loading
1926         &amp;&amp; track-&gt;mode() != TextTrack::Mode::Disabled) {
1927         // The display trees exist as long as the track is active, in this case,
1928         // and if the same track is loaded again (for example if the src attribute was changed),
1929         // cues can be accumulated with the old ones, that&#39;s why they needs to be flushed
1930         if (hasMediaControls())
1931             mediaControls()-&gt;clearTextDisplayContainer();
1932         updateTextTrackDisplay();
1933     }
1934     if (m_player &amp;&amp; m_textTracksWhenResourceSelectionBegan.contains(track)) {
1935         if (track-&gt;readinessState() != TextTrack::Loading)
1936             setReadyState(m_player-&gt;readyState());
1937     } else {
1938         // The track readiness state might have changed as a result of the user
1939         // clicking the captions button. In this case, a check whether all the
1940         // resources have failed loading should be done in order to hide the CC button.
1941         if (hasMediaControls() &amp;&amp; track-&gt;readinessState() == TextTrack::FailedToLoad)
1942             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
1943     }
1944 }
1945 
1946 void HTMLMediaElement::audioTrackEnabledChanged(AudioTrack&amp; track)
1947 {
1948     if (m_audioTracks &amp;&amp; m_audioTracks-&gt;contains(track))
1949         m_audioTracks-&gt;scheduleChangeEvent();
1950     if (processingUserGestureForMedia())
<a name="35" id="anc35"></a><span class="line-modified">1951         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
1952 }
1953 
1954 void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
1955 {
1956     bool trackIsLoaded = true;
1957     if (track.trackType() == TextTrack::TrackElement) {
1958         trackIsLoaded = false;
1959         for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
1960             if (&amp;trackElement.track() == &amp;track) {
1961                 if (trackElement.readyState() == HTMLTrackElement::LOADING || trackElement.readyState() == HTMLTrackElement::LOADED)
1962                     trackIsLoaded = true;
1963                 break;
1964             }
1965         }
1966     }
1967 
1968     // If this is the first added track, create the list of text tracks.
1969     if (!m_textTracks)
1970         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
1971 
1972     // Mark this track as &quot;configured&quot; so configureTextTracks won&#39;t change the mode again.
1973     track.setHasBeenConfigured(true);
1974 
1975     if (track.mode() != TextTrack::Mode::Disabled &amp;&amp; trackIsLoaded)
1976         textTrackAddCues(track, *track.cues());
1977 
1978     configureTextTrackDisplay(AssumeTextTrackVisibilityChanged);
1979 
1980     if (m_textTracks &amp;&amp; m_textTracks-&gt;contains(track))
1981         m_textTracks-&gt;scheduleChangeEvent();
1982 
1983 #if ENABLE(AVF_CAPTIONS)
1984     if (track.trackType() == TextTrack::TrackElement &amp;&amp; m_player)
1985         m_player-&gt;notifyTrackModeChanged();
1986 #endif
1987 }
1988 
1989 void HTMLMediaElement::videoTrackSelectedChanged(VideoTrack&amp; track)
1990 {
1991     if (m_videoTracks &amp;&amp; m_videoTracks-&gt;contains(track))
1992         m_videoTracks-&gt;scheduleChangeEvent();
1993 }
1994 
1995 void HTMLMediaElement::textTrackKindChanged(TextTrack&amp; track)
1996 {
1997     if (track.kind() != TextTrack::Kind::Captions &amp;&amp; track.kind() != TextTrack::Kind::Subtitles &amp;&amp; track.mode() == TextTrack::Mode::Showing)
1998         track.setMode(TextTrack::Mode::Hidden);
1999 }
2000 
2001 void HTMLMediaElement::beginIgnoringTrackDisplayUpdateRequests()
2002 {
2003     ++m_ignoreTrackDisplayUpdate;
2004 }
2005 
2006 void HTMLMediaElement::endIgnoringTrackDisplayUpdateRequests()
2007 {
2008     ASSERT(m_ignoreTrackDisplayUpdate);
2009     --m_ignoreTrackDisplayUpdate;
2010     if (!m_ignoreTrackDisplayUpdate &amp;&amp; m_inActiveDocument)
2011         updateActiveTextTrackCues(currentMediaTime());
2012 }
2013 
2014 void HTMLMediaElement::textTrackAddCues(TextTrack&amp; track, const TextTrackCueList&amp; cues)
2015 {
2016     if (track.mode() == TextTrack::Mode::Disabled)
2017         return;
2018 
2019     TrackDisplayUpdateScope scope { *this };
2020     for (unsigned i = 0; i &lt; cues.length(); ++i)
2021         textTrackAddCue(track, *cues.item(i));
2022 }
2023 
2024 void HTMLMediaElement::textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp; cues)
2025 {
2026     TrackDisplayUpdateScope scope { *this };
2027     for (unsigned i = 0; i &lt; cues.length(); ++i) {
2028         auto&amp; cue = *cues.item(i);
2029         textTrackRemoveCue(*cue.track(), cue);
2030     }
2031 }
2032 
2033 void HTMLMediaElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
2034 {
2035     if (track.mode() == TextTrack::Mode::Disabled)
2036         return;
2037 
2038     // Negative duration cues need be treated in the interval tree as
2039     // zero-length cues.
2040     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2041 
2042     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);
2043     if (!m_cueTree.contains(interval))
2044         m_cueTree.add(interval);
2045     updateActiveTextTrackCues(currentMediaTime());
2046 }
2047 
2048 void HTMLMediaElement::textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp; cue)
2049 {
2050     // Negative duration cues need to be treated in the interval tree as
2051     // zero-length cues.
2052     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2053 
2054     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);
2055     m_cueTree.remove(interval);
2056 
2057     // Since the cue will be removed from the media element and likely the
2058     // TextTrack might also be destructed, notifying the region of the cue
2059     // removal shouldn&#39;t be done.
2060     if (cue.isRenderable())
2061         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(false);
2062 
2063     size_t index = m_currentlyActiveCues.find(interval);
2064     if (index != notFound) {
2065         cue.setIsActive(false);
2066         m_currentlyActiveCues.remove(index);
2067     }
2068 
2069     if (cue.isRenderable())
2070         toVTTCue(&amp;cue)-&gt;removeDisplayTree();
2071     updateActiveTextTrackCues(currentMediaTime());
2072 
2073     if (cue.isRenderable())
2074         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(true);
2075 }
2076 
2077 #endif
2078 
2079 static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
2080 {
2081     // Elements in user agent show tree should load whatever the embedding document policy is.
2082     if (isInUserAgentShadowTree)
2083         return true;
2084 
2085     ASSERT(element.document().contentSecurityPolicy());
2086     return element.document().contentSecurityPolicy()-&gt;allowMediaFromSource(url);
2087 }
2088 
2089 bool HTMLMediaElement::isSafeToLoadURL(const URL&amp; url, InvalidURLAction actionIfInvalid)
2090 {
2091     if (!url.isValid()) {
2092         ERROR_LOG(LOGIDENTIFIER, url, &quot; is invalid&quot;);
2093         return false;
2094     }
2095 
2096     RefPtr&lt;Frame&gt; frame = document().frame();
2097     if (!frame || !document().securityOrigin().canDisplay(url)) {
<a name="36" id="anc36"></a><span class="line-modified">2098         if (actionIfInvalid == Complain) {</span>
2099             FrameLoader::reportLocalLoadFailed(frame.get(), url.stringCenterEllipsizedToLength());
2100             ERROR_LOG(LOGIDENTIFIER, url , &quot; was rejected by SecurityOrigin&quot;);
<a name="37" id="anc37"></a><span class="line-added">2101         }</span>
2102         return false;
2103     }
2104 
2105     if (!isAllowedToLoadMediaURL(*this, url, isInUserAgentShadowTree())) {
2106         ERROR_LOG(LOGIDENTIFIER, url, &quot; was rejected by Content Security Policy&quot;);
2107         return false;
2108     }
2109 
2110     return true;
2111 }
2112 
2113 void HTMLMediaElement::startProgressEventTimer()
2114 {
2115     if (m_progressEventTimer.isActive())
2116         return;
2117 
2118     m_previousProgressTime = MonotonicTime::now();
2119     // 350ms is not magic, it is in the spec!
2120     m_progressEventTimer.startRepeating(350_ms);
2121 }
2122 
2123 void HTMLMediaElement::waitForSourceChange()
2124 {
2125     INFO_LOG(LOGIDENTIFIER);
2126 
2127     stopPeriodicTimers();
2128     m_loadState = WaitingForSource;
2129 
2130     // 6.17 - Waiting: Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value
2131     m_networkState = NETWORK_NO_SOURCE;
2132 
2133     // 6.18 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2134     setShouldDelayLoadEvent(false);
2135 
2136     updateDisplayState();
2137     updateRenderer();
2138 }
2139 
2140 void HTMLMediaElement::noneSupported()
2141 {
2142     if (m_error)
2143         return;
2144 
2145     INFO_LOG(LOGIDENTIFIER);
2146 
2147     stopPeriodicTimers();
2148     m_loadState = WaitingForSource;
2149     m_currentSourceNode = nullptr;
2150 
2151     // 4.8.10.5
2152     // 6 - Reaching this step indicates that the media resource failed to load or that the given
2153     // URL could not be resolved. In one atomic operation, run the following steps:
2154 
2155     // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
2156     // MEDIA_ERR_SRC_NOT_SUPPORTED.
2157     m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
2158 
<a name="38" id="anc38"></a>
2159     // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
2160     forgetResourceSpecificTracks();
<a name="39" id="anc39"></a>
2161 
2162     // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
2163     m_networkState = NETWORK_NO_SOURCE;
2164 
2165     // 7 - Queue a task to fire a simple event named error at the media element.
2166     scheduleEvent(eventNames().errorEvent);
2167 
2168     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(NotSupportedError));
2169 
2170 #if ENABLE(MEDIA_SOURCE)
2171     detachMediaSource();
2172 #endif
2173 
2174     // 8 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2175     setShouldDelayLoadEvent(false);
2176 
2177     // 9 - Abort these steps. Until the load() method is invoked or the src attribute is changed,
2178     // the element won&#39;t attempt to load another resource.
2179 
2180     updateDisplayState();
2181     updateRenderer();
2182 }
2183 
2184 void HTMLMediaElement::mediaLoadingFailedFatally(MediaPlayer::NetworkState error)
2185 {
2186     // 1 - The user agent should cancel the fetching process.
2187     stopPeriodicTimers();
2188     m_loadState = WaitingForSource;
2189 
2190     // 2 - Set the error attribute to a new MediaError object whose code attribute is
2191     // set to MEDIA_ERR_NETWORK/MEDIA_ERR_DECODE.
2192     if (error == MediaPlayer::NetworkError)
2193         m_error = MediaError::create(MediaError::MEDIA_ERR_NETWORK);
2194     else if (error == MediaPlayer::DecodeError)
2195         m_error = MediaError::create(MediaError::MEDIA_ERR_DECODE);
2196     else
2197         ASSERT_NOT_REACHED();
2198 
2199     // 3 - Queue a task to fire a simple event named error at the media element.
2200     scheduleEvent(eventNames().errorEvent);
2201 
2202 #if ENABLE(MEDIA_SOURCE)
2203     detachMediaSource();
2204 #endif
2205 
2206     // 4 - Set the element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a
2207     // task to fire a simple event called emptied at the element.
2208     m_networkState = NETWORK_EMPTY;
2209     scheduleEvent(eventNames().emptiedEvent);
2210 
2211     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2212     setShouldDelayLoadEvent(false);
2213 
2214     // 6 - Abort the overall resource selection algorithm.
2215     m_currentSourceNode = nullptr;
2216 
2217 #if PLATFORM(COCOA)
2218     if (is&lt;MediaDocument&gt;(document()))
2219         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();
2220 #endif
2221 }
2222 
2223 void HTMLMediaElement::cancelPendingEventsAndCallbacks()
2224 {
2225     INFO_LOG(LOGIDENTIFIER);
2226     m_asyncEventQueue.cancelAllEvents();
2227 
2228     for (auto&amp; source : childrenOfType&lt;HTMLSourceElement&gt;(*this))
2229         source.cancelPendingErrorEvent();
2230 
2231     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(AbortError));
2232 }
2233 
2234 void HTMLMediaElement::mediaPlayerNetworkStateChanged(MediaPlayer*)
2235 {
2236     beginProcessingMediaPlayerCallback();
2237     setNetworkState(m_player-&gt;networkState());
2238     endProcessingMediaPlayerCallback();
2239 }
2240 
2241 static void logMediaLoadRequest(Page* page, const String&amp; mediaEngine, const String&amp; errorMessage, bool succeeded)
2242 {
2243     if (!page)
2244         return;
2245 
2246     DiagnosticLoggingClient&amp; diagnosticLoggingClient = page-&gt;diagnosticLoggingClient();
2247     if (!succeeded) {
2248         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::mediaLoadingFailedKey(), errorMessage, DiagnosticLoggingResultFail, ShouldSample::No);
2249         return;
2250     }
2251 
2252     diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::mediaLoadedKey(), mediaEngine, ShouldSample::No);
2253 
2254     if (!page-&gt;hasSeenAnyMediaEngine())
2255         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsAtLeastOneMediaEngineKey(), emptyString(), ShouldSample::No);
2256 
2257     if (!page-&gt;hasSeenMediaEngine(mediaEngine))
2258         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsMediaEngineKey(), mediaEngine, ShouldSample::No);
2259 
2260     page-&gt;sawMediaEngine(mediaEngine);
2261 }
2262 
2263 static String stringForNetworkState(MediaPlayer::NetworkState state)
2264 {
2265     switch (state) {
2266     case MediaPlayer::Empty: return &quot;Empty&quot;_s;
2267     case MediaPlayer::Idle: return &quot;Idle&quot;_s;
2268     case MediaPlayer::Loading: return &quot;Loading&quot;_s;
2269     case MediaPlayer::Loaded: return &quot;Loaded&quot;_s;
2270     case MediaPlayer::FormatError: return &quot;FormatError&quot;_s;
2271     case MediaPlayer::NetworkError: return &quot;NetworkError&quot;_s;
2272     case MediaPlayer::DecodeError: return &quot;DecodeError&quot;_s;
2273     default: return emptyString();
2274     }
2275 }
2276 
2277 void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
2278 {
2279     stopPeriodicTimers();
2280 
2281     // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
2282     // &lt;source&gt; children, schedule the next one
2283     if (m_readyState &lt; HAVE_METADATA &amp;&amp; m_loadState == LoadingFromSourceElement) {
2284 
2285         // resource selection algorithm
2286         // Step 9.Otherwise.9 - Failed with elements: Queue a task, using the DOM manipulation task source, to fire a simple event named error at the candidate element.
2287         if (m_currentSourceNode)
2288             m_currentSourceNode-&gt;scheduleErrorEvent();
2289         else
2290             INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
2291 
2292         // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
2293 
<a name="40" id="anc40"></a>
2294         // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
2295         forgetResourceSpecificTracks();
<a name="41" id="anc41"></a>
2296 
2297         if (havePotentialSourceChild()) {
2298             INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
2299             scheduleNextSourceChild();
2300         } else {
2301             INFO_LOG(LOGIDENTIFIER, &quot;no more &lt;source&gt; elements, waiting&quot;);
2302             waitForSourceChange();
2303         }
2304 
2305         return;
2306     }
2307 
2308     if ((error == MediaPlayer::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::DecodeError)
2309         mediaLoadingFailedFatally(error);
2310     else if ((error == MediaPlayer::FormatError || error == MediaPlayer::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)
2311         noneSupported();
2312 
2313     updateDisplayState();
2314     if (hasMediaControls()) {
2315         mediaControls()-&gt;reset();
2316         mediaControls()-&gt;reportedError();
2317     }
2318 
2319     ERROR_LOG(LOGIDENTIFIER, &quot;error = &quot;, static_cast&lt;int&gt;(error));
2320 
2321     logMediaLoadRequest(document().page(), String(), stringForNetworkState(error), false);
2322 
2323     m_mediaSession-&gt;clientCharacteristicsChanged();
2324 }
2325 
2326 void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
2327 {
2328     if (static_cast&lt;int&gt;(state) != static_cast&lt;int&gt;(m_networkState))
2329         ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_networkState);
2330 
2331     if (state == MediaPlayer::Empty) {
2332         // Just update the cached state and leave, we can&#39;t do anything.
2333         m_networkState = NETWORK_EMPTY;
2334         return;
2335     }
2336 
2337     if (state == MediaPlayer::FormatError || state == MediaPlayer::NetworkError || state == MediaPlayer::DecodeError) {
2338         mediaLoadingFailed(state);
2339         return;
2340     }
2341 
2342     if (state == MediaPlayer::Idle) {
2343         if (m_networkState &gt; NETWORK_IDLE) {
2344             changeNetworkStateFromLoadingToIdle();
2345             setShouldDelayLoadEvent(false);
2346         } else {
2347             m_networkState = NETWORK_IDLE;
2348         }
2349     }
2350 
2351     if (state == MediaPlayer::Loading) {
2352         if (m_networkState &lt; NETWORK_LOADING || m_networkState == NETWORK_NO_SOURCE)
2353             startProgressEventTimer();
2354         m_networkState = NETWORK_LOADING;
2355     }
2356 
2357     if (state == MediaPlayer::Loaded) {
2358         if (m_networkState != NETWORK_IDLE)
2359             changeNetworkStateFromLoadingToIdle();
2360         m_completelyLoaded = true;
2361     }
2362 
2363     if (hasMediaControls())
2364         mediaControls()-&gt;updateStatusDisplay();
2365 }
2366 
2367 void HTMLMediaElement::changeNetworkStateFromLoadingToIdle()
2368 {
2369     m_progressEventTimer.stop();
2370     if (hasMediaControls() &amp;&amp; m_player-&gt;didLoadingProgress())
2371         mediaControls()-&gt;bufferingProgressed();
2372 
2373     // Schedule one last progress event so we guarantee that at least one is fired
2374     // for files that load very quickly.
2375     scheduleEvent(eventNames().progressEvent);
2376     scheduleEvent(eventNames().suspendEvent);
2377     m_networkState = NETWORK_IDLE;
2378 }
2379 
2380 void HTMLMediaElement::mediaPlayerReadyStateChanged(MediaPlayer*)
2381 {
2382     beginProcessingMediaPlayerCallback();
2383 
2384     setReadyState(m_player-&gt;readyState());
2385 
2386     endProcessingMediaPlayerCallback();
2387 }
2388 
2389 SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
2390 {
<a name="42" id="anc42"></a><span class="line-modified">2391     if (m_readyState != HAVE_ENOUGH_DATA) {</span>
<span class="line-modified">2392         ALWAYS_LOG(LOGIDENTIFIER, &quot;m_readyState != HAVE_ENOUGH_DATA&quot;);</span>
<span class="line-modified">2393         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-modified">2394     }</span>
<span class="line-modified">2395     if (!isAutoplaying()) {</span>
<span class="line-modified">2396         ALWAYS_LOG(LOGIDENTIFIER, &quot;!isAutoplaying&quot;);</span>
<span class="line-modified">2397         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-modified">2398     }</span>
<span class="line-added">2399     if (!mediaSession().autoplayPermitted()) {</span>
<span class="line-added">2400         ALWAYS_LOG(LOGIDENTIFIER, &quot;!mediaSession().autoplayPermitted&quot;);</span>
<span class="line-added">2401         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2402     }</span>
<span class="line-added">2403     if (!paused()) {</span>
<span class="line-added">2404         ALWAYS_LOG(LOGIDENTIFIER, &quot;!paused&quot;);</span>
<span class="line-added">2405         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2406     }</span>
<span class="line-added">2407     if (!autoplay()) {</span>
<span class="line-added">2408         ALWAYS_LOG(LOGIDENTIFIER, &quot;!autoplay&quot;);</span>
<span class="line-added">2409         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2410     }</span>
<span class="line-added">2411     if (pausedForUserInteraction()) {</span>
<span class="line-added">2412         ALWAYS_LOG(LOGIDENTIFIER, &quot;pausedForUserInteraction&quot;);</span>
<span class="line-added">2413         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2414     }</span>
<span class="line-added">2415     if (document().isSandboxed(SandboxAutomaticFeatures)) {</span>
<span class="line-added">2416         ALWAYS_LOG(LOGIDENTIFIER, &quot;isSandboxed&quot;);</span>
<span class="line-added">2417         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2418     }</span>
2419 
<a name="43" id="anc43"></a><span class="line-modified">2420     auto permitted = mediaSession().playbackPermitted();</span>
<span class="line-modified">2421 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">2422     if (!permitted)</span>
<span class="line-added">2423         ALWAYS_LOG(LOGIDENTIFIER, permitted.value());</span>
<span class="line-added">2424     else</span>
<span class="line-added">2425         ALWAYS_LOG(LOGIDENTIFIER, &quot;can transition!&quot;);</span>
<span class="line-added">2426 #endif</span>
<span class="line-added">2427 </span>
<span class="line-added">2428     return permitted;</span>
2429 }
2430 
2431 void HTMLMediaElement::dispatchPlayPauseEventsIfNeedsQuirks()
2432 {
<a name="44" id="anc44"></a><span class="line-modified">2433     if (!document().quirks().needsAutoplayPlayPauseEvents())</span>

2434         return;
2435 
2436     ALWAYS_LOG(LOGIDENTIFIER);
2437     scheduleEvent(eventNames().playingEvent);
2438     scheduleEvent(eventNames().pauseEvent);
2439 }
2440 
2441 void HTMLMediaElement::setReadyState(MediaPlayer::ReadyState state)
2442 {
2443     // Set &quot;wasPotentiallyPlaying&quot; BEFORE updating m_readyState, potentiallyPlaying() uses it
2444     bool wasPotentiallyPlaying = potentiallyPlaying();
2445 
2446     ReadyState oldState = m_readyState;
2447     ReadyState newState = static_cast&lt;ReadyState&gt;(state);
2448 
2449 #if ENABLE(VIDEO_TRACK)
2450     bool tracksAreReady = textTracksAreReady();
2451 
2452     if (newState == oldState &amp;&amp; m_tracksAreReady == tracksAreReady)
2453         return;
2454 
2455     m_tracksAreReady = tracksAreReady;
2456 #else
2457     if (newState == oldState)
2458         return;
2459     bool tracksAreReady = true;
2460 #endif
2461 
2462     ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_readyState);
2463 
2464     if (tracksAreReady)
2465         m_readyState = newState;
2466     else {
2467         // If a media file has text tracks the readyState may not progress beyond HAVE_FUTURE_DATA until
2468         // the text tracks are ready, regardless of the state of the media file.
2469         if (newState &lt;= HAVE_METADATA)
2470             m_readyState = newState;
2471         else
2472             m_readyState = HAVE_CURRENT_DATA;
2473     }
2474 
2475     if (oldState &gt; m_readyStateMaximum)
2476         m_readyStateMaximum = oldState;
2477 
2478     if (m_networkState == NETWORK_EMPTY)
2479         return;
2480 
2481     if (m_seeking) {
2482         // 4.8.10.9, step 11
2483         if (wasPotentiallyPlaying &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
2484             scheduleEvent(eventNames().waitingEvent);
2485 
2486         // 4.8.10.10 step 14 &amp; 15.
2487         if (m_seekRequested &amp;&amp; !m_player-&gt;seeking() &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA)
2488             finishSeek();
2489     } else {
2490         if (wasPotentiallyPlaying &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA) {
2491             // 4.8.10.8
2492             invalidateCachedTime();
2493             scheduleTimeupdateEvent(false);
2494             scheduleEvent(eventNames().waitingEvent);
2495         }
2496     }
2497 
2498     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; oldState &lt; HAVE_METADATA) {
2499         prepareMediaFragmentURI();
2500         scheduleEvent(eventNames().durationchangeEvent);
2501         scheduleResizeEvent();
2502         scheduleEvent(eventNames().loadedmetadataEvent);
2503 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2504         if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent))
2505             enqueuePlaybackTargetAvailabilityChangedEvent();
2506 #endif
2507         m_initiallyMuted = m_volume &lt; 0.05 || muted();
2508 
2509         if (hasMediaControls())
2510             mediaControls()-&gt;loadedMetadata();
2511         updateRenderer();
2512 
2513         if (is&lt;MediaDocument&gt;(document()))
2514             downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
2515 
2516         logMediaLoadRequest(document().page(), m_player-&gt;engineDescription(), String(), true);
2517 
2518 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2519         scheduleUpdateMediaState();
2520 #endif
2521 
2522         m_mediaSession-&gt;clientCharacteristicsChanged();
2523     }
2524 
2525     bool shouldUpdateDisplayState = false;
2526 
2527     if (m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; oldState &lt; HAVE_CURRENT_DATA) {
2528         if (!m_haveFiredLoadedData) {
2529             m_haveFiredLoadedData = true;
2530             scheduleEvent(eventNames().loadeddataEvent);
2531             // FIXME: It&#39;s not clear that it&#39;s correct to skip these two operations just
2532             // because m_haveFiredLoadedData is already true. At one time we were skipping
2533             // the call to setShouldDelayLoadEvent, which was definitely incorrect.
2534             shouldUpdateDisplayState = true;
2535             applyMediaFragmentURI();
2536         }
2537         setShouldDelayLoadEvent(false);
2538     }
2539 
2540     if (m_readyState == HAVE_FUTURE_DATA &amp;&amp; oldState &lt;= HAVE_CURRENT_DATA &amp;&amp; tracksAreReady) {
2541         scheduleEvent(eventNames().canplayEvent);
2542         shouldUpdateDisplayState = true;
2543     }
2544 
2545     if (m_readyState == HAVE_ENOUGH_DATA &amp;&amp; oldState &lt; HAVE_ENOUGH_DATA &amp;&amp; tracksAreReady) {
2546         if (oldState &lt;= HAVE_CURRENT_DATA)
2547             scheduleEvent(eventNames().canplayEvent);
2548 
2549         scheduleEvent(eventNames().canplaythroughEvent);
2550 
2551         auto success = canTransitionFromAutoplayToPlay();
2552         if (success) {
2553             m_paused = false;
2554             invalidateCachedTime();
2555             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
2556             m_playbackStartedTime = currentMediaTime().toDouble();
2557             scheduleEvent(eventNames().playEvent);
2558         } else if (success.value() == MediaPlaybackDenialReason::UserGestureRequired) {
2559             ALWAYS_LOG(LOGIDENTIFIER, &quot;Autoplay blocked, user gesture required&quot;);
2560             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
2561         }
2562 
2563         shouldUpdateDisplayState = true;
2564     }
2565 
2566     // If we transition to the Future Data state and we&#39;re about to begin playing, ensure playback is actually permitted first,
2567     // honoring any playback denial reasons such as the requirement of a user gesture.
2568     if (m_readyState == HAVE_FUTURE_DATA &amp;&amp; oldState &lt; HAVE_FUTURE_DATA &amp;&amp; potentiallyPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
2569         auto canTransition = canTransitionFromAutoplayToPlay();
2570         if (canTransition &amp;&amp; canTransition.value() == MediaPlaybackDenialReason::UserGestureRequired)
2571             ALWAYS_LOG(LOGIDENTIFIER, &quot;Autoplay blocked, user gesture required&quot;);
2572 
2573         pauseInternal();
2574         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
2575     }
2576 
2577     if (shouldUpdateDisplayState) {
2578         updateDisplayState();
2579         if (hasMediaControls()) {
2580             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
2581             mediaControls()-&gt;updateStatusDisplay();
2582         }
2583     }
2584 
2585     updatePlayState();
2586     updateMediaController();
2587 #if ENABLE(VIDEO_TRACK)
2588     updateActiveTextTrackCues(currentMediaTime());
2589 #endif
2590 }
2591 
2592 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
2593 RefPtr&lt;ArrayBuffer&gt; HTMLMediaElement::mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const
2594 {
2595     return m_webKitMediaKeys ? m_webKitMediaKeys-&gt;cachedKeyForKeyId(keyId) : nullptr;
2596 }
2597 
2598 bool HTMLMediaElement::mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array* initData)
2599 {
2600     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2601         return false;
2602 
2603     if (!hasEventListeners(&quot;webkitneedkey&quot;)
2604 #if ENABLE(ENCRYPTED_MEDIA)
2605         // Only fire an error if ENCRYPTED_MEDIA is not enabled, to give clients of the
2606         // &quot;encrypted&quot; event a chance to handle it without resulting in a synthetic error.
2607         &amp;&amp; (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2608 #endif
2609         ) {
2610         m_error = MediaError::create(MediaError::MEDIA_ERR_ENCRYPTED);
2611         scheduleEvent(eventNames().errorEvent);
2612         return false;
2613     }
2614 
2615     auto event = WebKitMediaKeyNeededEvent::create(eventNames().webkitneedkeyEvent, initData);
2616     event-&gt;setTarget(this);
2617     m_asyncEventQueue.enqueueEvent(WTFMove(event));
2618 
2619     return true;
2620 }
2621 
2622 String HTMLMediaElement::mediaPlayerMediaKeysStorageDirectory() const
2623 {
2624     auto* page = document().page();
2625     if (!page || page-&gt;usesEphemeralSession())
2626         return emptyString();
2627 
2628     String storageDirectory = document().settings().mediaKeysStorageDirectory();
2629     if (storageDirectory.isEmpty())
2630         return emptyString();
2631 
2632     return FileSystem::pathByAppendingComponent(storageDirectory, document().securityOrigin().data().databaseIdentifier());
2633 }
2634 
2635 void HTMLMediaElement::webkitSetMediaKeys(WebKitMediaKeys* mediaKeys)
2636 {
2637     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2638         return;
2639 
2640     if (m_webKitMediaKeys == mediaKeys)
2641         return;
2642 
2643     if (m_webKitMediaKeys)
2644         m_webKitMediaKeys-&gt;setMediaElement(nullptr);
2645     m_webKitMediaKeys = mediaKeys;
2646     if (m_webKitMediaKeys)
2647         m_webKitMediaKeys-&gt;setMediaElement(this);
2648 }
2649 
2650 void HTMLMediaElement::keyAdded()
2651 {
2652     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2653         return;
2654 
2655     if (m_player)
2656         m_player-&gt;keyAdded();
2657 }
2658 
2659 #endif
2660 
2661 #if ENABLE(ENCRYPTED_MEDIA)
2662 
2663 MediaKeys* HTMLMediaElement::mediaKeys() const
2664 {
2665     return m_mediaKeys.get();
2666 }
2667 
2668 void HTMLMediaElement::setMediaKeys(MediaKeys* mediaKeys, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
2669 {
2670     // https://w3c.github.io/encrypted-media/#dom-htmlmediaelement-setmediakeys
2671     // W3C Editor&#39;s Draft 23 June 2017
2672 
2673     // 1. If this object&#39;s attaching media keys value is true, return a promise rejected with an InvalidStateError.
2674     if (m_attachingMediaKeys) {
2675         promise-&gt;reject(InvalidStateError);
2676         return;
2677     }
2678 
2679     // 2. If mediaKeys and the mediaKeys attribute are the same object, return a resolved promise.
2680     if (mediaKeys == m_mediaKeys) {
2681         promise-&gt;resolve();
2682         return;
2683     }
2684 
2685     // 3. Let this object&#39;s attaching media keys value be true.
2686     m_attachingMediaKeys = true;
2687 
2688     // 4. Let promise be a new promise.
2689     // 5. Run the following steps in parallel:
2690     m_encryptedMediaQueue.enqueueTask([this, mediaKeys = RefPtr&lt;MediaKeys&gt;(mediaKeys), promise = WTFMove(promise)]() mutable {
2691         // 5.1. If all the following conditions hold:
2692         //      - mediaKeys is not null,
2693         //      - the CDM instance represented by mediaKeys is already in use by another media element
2694         //      - the user agent is unable to use it with this element
2695         //      then let this object&#39;s attaching media keys value be false and reject promise with a QuotaExceededError.
2696         // FIXME: ^
2697 
2698         // 5.2. If the mediaKeys attribute is not null, run the following steps:
2699         if (m_mediaKeys) {
2700             // 5.2.1. If the user agent or CDM do not support removing the association, let this object&#39;s attaching media keys value be false and reject promise with a NotSupportedError.
2701             // 5.2.2. If the association cannot currently be removed, let this object&#39;s attaching media keys value be false and reject promise with an InvalidStateError.
2702             // 5.2.3. Stop using the CDM instance represented by the mediaKeys attribute to decrypt media data and remove the association with the media element.
2703             // 5.2.4. If the preceding step failed, let this object&#39;s attaching media keys value be false and reject promise with the appropriate error name.
2704             // FIXME: ^
2705 
2706             m_mediaKeys-&gt;detachCDMClient(*this);
2707             if (m_player)
2708                 m_player-&gt;cdmInstanceDetached(m_mediaKeys-&gt;cdmInstance());
2709         }
2710 
2711         // 5.3. If mediaKeys is not null, run the following steps:
2712         if (mediaKeys) {
2713             // 5.3.1. Associate the CDM instance represented by mediaKeys with the media element for decrypting media data.
2714             mediaKeys-&gt;attachCDMClient(*this);
2715             if (m_player)
2716                 m_player-&gt;cdmInstanceAttached(mediaKeys-&gt;cdmInstance());
2717 
2718             // 5.3.2. If the preceding step failed, run the following steps:
2719             //   5.3.2.1. Set the mediaKeys attribute to null.
2720             //   5.3.2.2. Let this object&#39;s attaching media keys value be false.
2721             //   5.3.2.3. Reject promise with a new DOMException whose name is the appropriate error name.
2722             // FIXME: ^
2723 
2724             // 5.3.3. Queue a task to run the Attempt to Resume Playback If Necessary algorithm on the media element.
2725             m_encryptedMediaQueue.enqueueTask([this] {
2726                 attemptToResumePlaybackIfNecessary();
2727             });
2728         }
2729 
2730         // 5.4. Set the mediaKeys attribute to mediaKeys.
2731         // 5.5. Let this object&#39;s attaching media keys value be false.
2732         // 5.6. Resolve promise.
2733         m_mediaKeys = WTFMove(mediaKeys);
2734         m_attachingMediaKeys = false;
2735         promise-&gt;resolve();
2736     });
2737 
2738     // 6. Return promise.
2739 }
2740 
2741 void HTMLMediaElement::mediaPlayerInitializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
2742 {
2743     if (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2744         return;
2745 
2746     // https://w3c.github.io/encrypted-media/#initdata-encountered
2747     // W3C Editor&#39;s Draft 23 June 2017
2748 
2749     // 1. Let the media element be the specified HTMLMediaElement object.
2750     // 2. Let initDataType be the empty string.
2751     // 3. Let initData be null.
2752     // 4. If the media data is CORS-same-origin and not mixed content, run the following steps:
2753     //   4.1. Let initDataType be the string representing the Initialization Data Type of the Initialization Data.
2754     //   4.2. Let initData be the Initialization Data.
2755     // FIXME: ^
2756 
2757     // 5. Queue a task to create an event named encrypted that does not bubble and is not cancellable using the
2758     //    MediaEncryptedEvent interface with its type attribute set to encrypted and its isTrusted attribute
2759     //    initialized to true, and dispatch it at the media element.
2760     //    The event interface MediaEncryptedEvent has:
2761     //      initDataType = initDataType
2762     //      initData = initData
2763     MediaEncryptedEventInit initializer { initDataType, WTFMove(initData) };
2764     m_asyncEventQueue.enqueueEvent(MediaEncryptedEvent::create(eventNames().encryptedEvent, initializer, Event::IsTrusted::Yes));
2765 }
2766 
2767 void HTMLMediaElement::mediaPlayerWaitingForKeyChanged()
2768 {
2769     if (!m_player)
2770         return;
2771 
2772     if (!m_player-&gt;waitingForKey() &amp;&amp; m_playbackBlockedWaitingForKey) {
2773         // https://w3c.github.io/encrypted-media/#resume-playback
2774         // W3C Editor&#39;s Draft 23 June 2017
2775 
2776         // NOTE: continued from HTMLMediaElement::attemptToDecrypt().
2777         // 4. If the user agent can advance the current playback position in the direction of playback:
2778         //   4.1. Set the media element&#39;s decryption blocked waiting for key value to false.
2779         // FIXME: ^
2780         //   4.2. Set the media element&#39;s playback blocked waiting for key value to false.
2781         m_playbackBlockedWaitingForKey = false;
2782 
2783         //   4.3. Set the media element&#39;s readyState value to HAVE_CURRENT_DATA, HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA as appropriate.
2784         setReadyState(m_player-&gt;readyState());
2785 
2786         return;
2787     }
2788 
2789     // https://www.w3.org/TR/encrypted-media/#wait-for-key
2790     // W3C Recommendation 18 September 2017
2791 
2792     // The Wait for Key algorithm queues a waitingforkey event and
2793     // updates readyState. It should only be called when the
2794     // HTMLMediaElement object is potentially playing and its
2795     // readyState is equal to HAVE_FUTURE_DATA or greater. Requests to
2796     // run this algorithm include a target HTMLMediaElement object.
2797 
2798     // The following steps are run:
2799 
2800     // 1. Let the media element be the specified HTMLMediaElement
2801     // object.
2802     // 2. If the media element&#39;s playback blocked waiting for key
2803     // value is true, abort these steps.
2804     if (m_playbackBlockedWaitingForKey)
2805         return;
2806 
2807     // 3. Set the media element&#39;s playback blocked waiting for key
2808     // value to true.
2809     m_playbackBlockedWaitingForKey = true;
2810 
2811     // NOTE
2812     // As a result of the above step, the media element will become a
2813     // blocked media element if it wasn&#39;t already. In that case, the
2814     // media element will stop playback.
2815 
2816     // 4. Follow the steps for the first matching condition from the
2817     // following list:
2818 
2819     // If data for the immediate current playback position is
2820     // available
2821     // Set the readyState of media element to HAVE_CURRENT_DATA.
2822     // Otherwise
2823     // Set the readyState of media element to HAVE_METADATA.
2824     ReadyState nextReadyState = buffered()-&gt;contain(currentTime()) ? HAVE_CURRENT_DATA : HAVE_METADATA;
2825     if (nextReadyState &lt; m_readyState)
2826         setReadyState(static_cast&lt;MediaPlayer::ReadyState&gt;(nextReadyState));
2827 
2828     // NOTE
2829     // In other words, if the video frame and audio data for the
2830     // current playback position have been decoded because they were
2831     // unencrypted and/or successfully decrypted, set readyState to
2832     // HAVE_CURRENT_DATA. Otherwise, including if this was previously
2833     // the case but the data is no longer available, set readyState to
2834     // HAVE_METADATA.
2835 
2836     // 5. Queue a task to fire a simple event named waitingforkey at the
2837     // media element.
2838     scheduleEvent(eventNames().waitingforkeyEvent);
2839 
2840     // 6. Suspend playback.
2841     // GStreamer handles this without suspending explicitly.
2842 }
2843 
2844 void HTMLMediaElement::attemptToDecrypt()
2845 {
2846     // https://w3c.github.io/encrypted-media/#attempt-to-decrypt
2847     // W3C Editor&#39;s Draft 23 June 2017
2848 
2849     // 1. Let the media element be the specified HTMLMediaElement object.
2850     // 2. If the media element&#39;s encrypted block queue is empty, abort these steps.
2851     // FIXME: ^
2852 
2853     // 3. If the media element&#39;s mediaKeys attribute is not null, run the following steps:
2854     if (m_mediaKeys) {
2855         // 3.1. Let media keys be the MediaKeys object referenced by that attribute.
2856         // 3.2. Let cdm be the CDM instance represented by media keys&#39;s cdm instance value.
2857         auto&amp; cdmInstance = m_mediaKeys-&gt;cdmInstance();
2858 
2859         // 3.3. If cdm is no longer usable for any reason, run the following steps:
2860         //   3.3.1. Run the media data is corrupted steps of the resource fetch algorithm.
2861         //   3.3.2. Run the CDM Unavailable algorithm on media keys.
2862         //   3.3.3. Abort these steps.
2863         // FIXME: ^
2864 
2865         // 3.4. If there is at least one MediaKeySession created by the media keys that is not closed, run the following steps:
2866         if (m_mediaKeys-&gt;hasOpenSessions()) {
2867             // Continued in MediaPlayer::attemptToDecryptWithInstance().
2868             if (m_player)
2869                 m_player-&gt;attemptToDecryptWithInstance(cdmInstance);
2870         }
2871     }
2872 
2873     // 4. Set the media element&#39;s decryption blocked waiting for key value to true.
2874     // FIXME: ^
2875 }
2876 
2877 void HTMLMediaElement::attemptToResumePlaybackIfNecessary()
2878 {
2879     // https://w3c.github.io/encrypted-media/#resume-playback
2880     // W3C Editor&#39;s Draft 23 June 2017
2881 
2882     // 1. Let the media element be the specified HTMLMediaElement object.
2883     // 2. If the media element&#39;s playback blocked waiting for key is false, abort these steps.
2884     if (!m_playbackBlockedWaitingForKey)
2885         return;
2886 
2887     // 3. Run the Attempt to Decrypt algorithm on the media element.
2888     attemptToDecrypt();
2889 
2890     // NOTE: continued in HTMLMediaElement::waitingForKeyChanged()
2891 }
2892 
2893 void HTMLMediaElement::cdmClientAttemptToResumePlaybackIfNecessary()
2894 {
2895     attemptToResumePlaybackIfNecessary();
2896 }
2897 
2898 #endif // ENABLE(ENCRYPTED_MEDIA)
2899 
2900 void HTMLMediaElement::progressEventTimerFired()
2901 {
2902     ASSERT(m_player);
2903     if (m_networkState != NETWORK_LOADING)
2904         return;
2905 
2906     MonotonicTime time = MonotonicTime::now();
2907     Seconds timedelta = time - m_previousProgressTime;
2908 
2909     if (m_player-&gt;didLoadingProgress()) {
2910         scheduleEvent(eventNames().progressEvent);
2911         m_previousProgressTime = time;
2912         m_sentStalledEvent = false;
2913         updateRenderer();
2914         if (hasMediaControls())
2915             mediaControls()-&gt;bufferingProgressed();
2916     } else if (timedelta &gt; 3_s &amp;&amp; !m_sentStalledEvent) {
2917         scheduleEvent(eventNames().stalledEvent);
2918         m_sentStalledEvent = true;
2919         setShouldDelayLoadEvent(false);
2920     }
2921 }
2922 
2923 void HTMLMediaElement::rewind(double timeDelta)
2924 {
2925     setCurrentTime(std::max(currentMediaTime() - MediaTime::createWithDouble(timeDelta), minTimeSeekable()));
2926 }
2927 
2928 void HTMLMediaElement::returnToRealtime()
2929 {
2930     setCurrentTime(maxTimeSeekable());
2931 }
2932 
2933 void HTMLMediaElement::addPlayedRange(const MediaTime&amp; start, const MediaTime&amp; end)
2934 {
2935     DEBUG_LOG(LOGIDENTIFIER, MediaTimeRange { start, end });
2936     if (!m_playedTimeRanges)
2937         m_playedTimeRanges = TimeRanges::create();
2938     m_playedTimeRanges-&gt;ranges().add(start, end);
2939 }
2940 
2941 bool HTMLMediaElement::supportsScanning() const
2942 {
2943     return m_player ? m_player-&gt;supportsScanning() : false;
2944 }
2945 
2946 void HTMLMediaElement::prepareToPlay()
2947 {
2948     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2949 
2950     INFO_LOG(LOGIDENTIFIER);
2951     if (m_havePreparedToPlay || !document().hasBrowsingContext())
2952         return;
2953     m_havePreparedToPlay = true;
2954     if (m_player)
2955         m_player-&gt;prepareToPlay();
2956 }
2957 
2958 void HTMLMediaElement::fastSeek(double time)
2959 {
2960     fastSeek(MediaTime::createWithDouble(time));
2961 }
2962 
2963 void HTMLMediaElement::fastSeek(const MediaTime&amp; time)
2964 {
2965     INFO_LOG(LOGIDENTIFIER, time);
2966     // 4.7.10.9 Seeking
2967     // 9. If the approximate-for-speed flag is set, adjust the new playback position to a value that will
2968     // allow for playback to resume promptly. If new playback position before this step is before current
2969     // playback position, then the adjusted new playback position must also be before the current playback
2970     // position. Similarly, if the new playback position before this step is after current playback position,
2971     // then the adjusted new playback position must also be after the current playback position.
2972     refreshCachedTime();
2973 
2974     MediaTime delta = time - currentMediaTime();
2975     MediaTime negativeTolerance = delta &lt; MediaTime::zeroTime() ? MediaTime::positiveInfiniteTime() : delta;
2976     seekWithTolerance(time, negativeTolerance, MediaTime::zeroTime(), true);
2977 }
2978 
2979 void HTMLMediaElement::seek(const MediaTime&amp; time)
2980 {
2981     INFO_LOG(LOGIDENTIFIER, time);
2982     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), true);
2983 }
2984 
2985 void HTMLMediaElement::seekInternal(const MediaTime&amp; time)
2986 {
2987     INFO_LOG(LOGIDENTIFIER, time);
2988     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), false);
2989 }
2990 
2991 void HTMLMediaElement::seekWithTolerance(const MediaTime&amp; inTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM)
2992 {
2993     // 4.8.10.9 Seeking
2994     MediaTime time = inTime;
2995 
2996     // 1 - Set the media element&#39;s show poster flag to false.
2997     setDisplayMode(Video);
2998 
2999     // 2 - If the media element&#39;s readyState is HAVE_NOTHING, abort these steps.
3000     if (m_readyState == HAVE_NOTHING || !m_player)
3001         return;
3002 
3003     // If the media engine has been told to postpone loading data, let it go ahead now.
3004     if (m_preload &lt; MediaPlayer::Auto &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
3005         prepareToPlay();
3006 
3007     // Get the current time before setting m_seeking, m_lastSeekTime is returned once it is set.
3008     refreshCachedTime();
3009     MediaTime now = currentMediaTime();
3010 
3011     // 3 - If the element&#39;s seeking IDL attribute is true, then another instance of this algorithm is
3012     // already running. Abort that other instance of the algorithm without waiting for the step that
3013     // it is running to complete.
3014     if (m_seekTaskQueue.hasPendingTask()) {
3015         INFO_LOG(LOGIDENTIFIER, &quot;cancelling pending seeks&quot;);
3016         m_seekTaskQueue.cancelTask();
3017         if (m_pendingSeek) {
3018             now = m_pendingSeek-&gt;now;
3019             m_pendingSeek = nullptr;
3020         }
3021         m_pendingSeekType = NoSeek;
3022     }
3023 
3024     // 4 - Set the seeking IDL attribute to true.
3025     // The flag will be cleared when the engine tells us the time has actually changed.
3026     m_seeking = true;
3027     if (m_playing) {
3028         if (m_lastSeekTime &lt; now)
3029             addPlayedRange(m_lastSeekTime, now);
3030     }
3031     m_lastSeekTime = time;
3032 
3033     // 5 - If the seek was in response to a DOM method call or setting of an IDL attribute, then continue
3034     // the script. The remainder of these steps must be run asynchronously.
<a name="45" id="anc45"></a><span class="line-modified">3035     m_pendingSeek = makeUnique&lt;PendingSeek&gt;(now, time, negativeTolerance, positiveTolerance);</span>
3036     if (fromDOM) {
3037         INFO_LOG(LOGIDENTIFIER, &quot;enqueuing seek from &quot;, now, &quot; to &quot;, time);
3038         m_seekTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::seekTask, this));
3039     } else
3040         seekTask();
3041 
3042     if (processingUserGestureForMedia())
3043         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3044 }
3045 
3046 void HTMLMediaElement::seekTask()
3047 {
3048     INFO_LOG(LOGIDENTIFIER);
3049 
3050     if (!m_player) {
3051         clearSeeking();
3052         return;
3053     }
3054 
3055     ASSERT(m_pendingSeek);
3056     MediaTime now = m_pendingSeek-&gt;now;
3057     MediaTime time = m_pendingSeek-&gt;targetTime;
3058     MediaTime negativeTolerance = m_pendingSeek-&gt;negativeTolerance;
3059     MediaTime positiveTolerance = m_pendingSeek-&gt;positiveTolerance;
3060     m_pendingSeek = nullptr;
3061 
3062     ASSERT(negativeTolerance &gt;= MediaTime::zeroTime());
3063 
3064     // 6 - If the new playback position is later than the end of the media resource, then let it be the end
3065     // of the media resource instead.
3066     time = std::min(time, durationMediaTime());
3067 
3068     // 7 - If the new playback position is less than the earliest possible position, let it be that position instead.
3069     MediaTime earliestTime = m_player-&gt;startTime();
3070     time = std::max(time, earliestTime);
3071 
3072     // Ask the media engine for the time value in the movie&#39;s time scale before comparing with current time. This
3073     // is necessary because if the seek time is not equal to currentTime but the delta is less than the movie&#39;s
3074     // time scale, we will ask the media engine to &quot;seek&quot; to the current movie time, which may be a noop and
3075     // not generate a timechanged callback. This means m_seeking will never be cleared and we will never
3076     // fire a &#39;seeked&#39; event.
<a name="46" id="anc46"></a><span class="line-modified">3077     if (willLog(WTFLogLevel::Debug)) {</span>
3078         MediaTime mediaTime = m_player-&gt;mediaTimeForTimeValue(time);
3079         if (time != mediaTime)
<a name="47" id="anc47"></a><span class="line-modified">3080             INFO_LOG(LOGIDENTIFIER, time, &quot; media timeline equivalent is &quot;, mediaTime);</span>
3081     }
3082 
3083     time = m_player-&gt;mediaTimeForTimeValue(time);
3084 
3085     // 8 - If the (possibly now changed) new playback position is not in one of the ranges given in the
3086     // seekable attribute, then let it be the position in one of the ranges given in the seekable attribute
3087     // that is the nearest to the new playback position. ... If there are no ranges given in the seekable
3088     // attribute then set the seeking IDL attribute to false and abort these steps.
3089     RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
3090     bool noSeekRequired = !seekableRanges-&gt;length();
3091 
3092     // Short circuit seeking to the current time by just firing the events if no seek is required.
3093     // Don&#39;t skip calling the media engine if 1) we are in poster mode (because a seek should always cancel
3094     // poster display), or 2) if there is a pending fast seek, or 3) if this seek is not an exact seek
3095     SeekType thisSeekType = (negativeTolerance == MediaTime::zeroTime() &amp;&amp; positiveTolerance == MediaTime::zeroTime()) ? Precise : Fast;
3096     if (!noSeekRequired &amp;&amp; time == now &amp;&amp; thisSeekType == Precise &amp;&amp; m_pendingSeekType != Fast &amp;&amp; displayMode() != Poster)
3097         noSeekRequired = true;
3098 
3099 #if ENABLE(MEDIA_SOURCE)
3100     // Always notify the media engine of a seek if the source is not closed. This ensures that the source is
3101     // always in a flushed state when the &#39;seeking&#39; event fires.
3102     if (m_mediaSource &amp;&amp; !m_mediaSource-&gt;isClosed())
3103         noSeekRequired = false;
3104 #endif
3105 
3106     if (noSeekRequired) {
<a name="48" id="anc48"></a><span class="line-modified">3107         INFO_LOG(LOGIDENTIFIER, &quot;ignored seek to &quot;, time);</span>
3108         if (time == now) {
3109             scheduleEvent(eventNames().seekingEvent);
3110             scheduleTimeupdateEvent(false);
3111             scheduleEvent(eventNames().seekedEvent);
3112         }
3113         clearSeeking();
3114         return;
3115     }
3116     time = seekableRanges-&gt;ranges().nearest(time);
3117 
3118     m_sentEndEvent = false;
3119     m_lastSeekTime = time;
3120     m_pendingSeekType = thisSeekType;
3121     m_seeking = true;
3122 
3123     // 10 - Queue a task to fire a simple event named seeking at the element.
3124     scheduleEvent(eventNames().seekingEvent);
3125 
3126     // 11 - Set the current playback position to the given new playback position
3127     m_seekRequested = true;
3128     m_player-&gt;seekWithTolerance(time, negativeTolerance, positiveTolerance);
3129 
3130     // 12 - Wait until the user agent has established whether or not the media data for the new playback
3131     // position is available, and, if it is, until it has decoded enough data to play back that position.
3132     // 13 - Await a stable state. The synchronous section consists of all the remaining steps of this algorithm.
3133 }
3134 
3135 void HTMLMediaElement::clearSeeking()
3136 {
3137     m_seeking = false;
3138     m_seekRequested = false;
3139     m_pendingSeekType = NoSeek;
3140     invalidateCachedTime();
3141 }
3142 
3143 void HTMLMediaElement::finishSeek()
3144 {
3145     // 4.8.10.9 Seeking
3146     // 14 - Set the seeking IDL attribute to false.
3147     clearSeeking();
3148 
3149     INFO_LOG(LOGIDENTIFIER, &quot;current time = &quot;, currentMediaTime());
3150 
3151     // 15 - Run the time maches on steps.
3152     // Handled by mediaPlayerTimeChanged().
3153 
3154     // 16 - Queue a task to fire a simple event named timeupdate at the element.
3155     scheduleEvent(eventNames().timeupdateEvent);
3156 
3157     // 17 - Queue a task to fire a simple event named seeked at the element.
3158     scheduleEvent(eventNames().seekedEvent);
3159 
3160     if (m_mediaSession)
3161         m_mediaSession-&gt;clientCharacteristicsChanged();
3162 
3163 #if ENABLE(MEDIA_SOURCE)
3164     if (m_mediaSource)
3165         m_mediaSource-&gt;monitorSourceBuffers();
3166 #endif
3167 }
3168 
3169 HTMLMediaElement::ReadyState HTMLMediaElement::readyState() const
3170 {
3171     return m_readyState;
3172 }
3173 
3174 MediaPlayer::MovieLoadType HTMLMediaElement::movieLoadType() const
3175 {
3176     return m_player ? m_player-&gt;movieLoadType() : MediaPlayer::Unknown;
3177 }
3178 
3179 bool HTMLMediaElement::hasAudio() const
3180 {
3181     return m_player ? m_player-&gt;hasAudio() : false;
3182 }
3183 
3184 bool HTMLMediaElement::seeking() const
3185 {
3186     return m_seeking;
3187 }
3188 
3189 void HTMLMediaElement::refreshCachedTime() const
3190 {
3191     if (!m_player)
3192         return;
3193 
3194     m_cachedTime = m_player-&gt;currentTime();
3195     if (!m_cachedTime) {
3196         // Do not use m_cachedTime until the media engine returns a non-zero value because we can&#39;t
3197         // estimate current time until playback actually begins.
3198         invalidateCachedTime();
3199         return;
3200     }
3201 
3202     m_clockTimeAtLastCachedTimeUpdate = MonotonicTime::now();
3203 }
3204 
3205 void HTMLMediaElement::invalidateCachedTime() const
3206 {
3207     m_cachedTime = MediaTime::invalidTime();
3208     if (!m_player || !m_player-&gt;maximumDurationToCacheMediaTime())
3209         return;
3210 
3211     // Don&#39;t try to cache movie time when playback first starts as the time reported by the engine
3212     // sometimes fluctuates for a short amount of time, so the cached time will be off if we take it
3213     // too early.
3214     static const Seconds minimumTimePlayingBeforeCacheSnapshot = 500_ms;
3215 
3216     m_minimumClockTimeToUpdateCachedTime = MonotonicTime::now() + minimumTimePlayingBeforeCacheSnapshot;
3217 }
3218 
3219 // playback state
3220 double HTMLMediaElement::currentTime() const
3221 {
3222     return currentMediaTime().toDouble();
3223 }
3224 
3225 MediaTime HTMLMediaElement::currentMediaTime() const
3226 {
3227 #if LOG_CACHED_TIME_WARNINGS
3228     static const MediaTime minCachedDeltaForWarning = MediaTime::create(1, 100);
3229 #endif
3230 
3231     if (!m_player)
3232         return MediaTime::zeroTime();
3233 
3234     if (m_seeking) {
3235         INFO_LOG(LOGIDENTIFIER, &quot;seeking, returning&quot;, m_lastSeekTime);
3236         return m_lastSeekTime;
3237     }
3238 
3239     if (m_cachedTime.isValid() &amp;&amp; m_paused) {
3240 #if LOG_CACHED_TIME_WARNINGS
3241         MediaTime delta = m_cachedTime - m_player-&gt;currentTime();
3242         if (delta &gt; minCachedDeltaForWarning)
3243             WARNING_LOG(LOGIDENTIFIER, &quot;cached time is &quot;, delta, &quot; seconds off of media time when paused&quot;);
3244 #endif
3245         return m_cachedTime;
3246     }
3247 
3248     // Is it too soon use a cached time?
3249     MonotonicTime now = MonotonicTime::now();
3250     double maximumDurationToCacheMediaTime = m_player-&gt;maximumDurationToCacheMediaTime();
3251 
3252     if (maximumDurationToCacheMediaTime &amp;&amp; m_cachedTime.isValid() &amp;&amp; !m_paused &amp;&amp; now &gt; m_minimumClockTimeToUpdateCachedTime) {
3253         Seconds clockDelta = now - m_clockTimeAtLastCachedTimeUpdate;
3254 
3255         // Not too soon, use the cached time only if it hasn&#39;t expired.
3256         if (clockDelta.seconds() &lt; maximumDurationToCacheMediaTime) {
3257             MediaTime adjustedCacheTime = m_cachedTime + MediaTime::createWithDouble(effectivePlaybackRate() * clockDelta.seconds());
3258 
3259 #if LOG_CACHED_TIME_WARNINGS
3260             MediaTime delta = adjustedCacheTime - m_player-&gt;currentTime();
3261             if (delta &gt; minCachedDeltaForWarning)
3262                 WARNING_LOG(LOGIDENTIFIER, &quot;cached time is &quot;, delta, &quot; seconds off of media time when playing&quot;);
3263 #endif
3264             return adjustedCacheTime;
3265         }
3266     }
3267 
3268 #if LOG_CACHED_TIME_WARNINGS
3269     if (maximumDurationToCacheMediaTime &amp;&amp; now &gt; m_minimumClockTimeToUpdateCachedTime &amp;&amp; m_cachedTime != MediaPlayer::invalidTime()) {
3270         Seconds clockDelta = now - m_clockTimeAtLastCachedTimeUpdate;
3271         MediaTime delta = m_cachedTime + MediaTime::createWithDouble(effectivePlaybackRate() * clockDelta.seconds()) - m_player-&gt;currentTime();
3272         WARNING_LOG(LOGIDENTIFIER, &quot;cached time was &quot;, delta, &quot; seconds off of media time when it expired&quot;);
3273     }
3274 #endif
3275 
3276     refreshCachedTime();
3277 
3278     if (m_cachedTime.isInvalid())
3279         return MediaTime::zeroTime();
3280 
3281     return m_cachedTime;
3282 }
3283 
3284 void HTMLMediaElement::setCurrentTime(double time)
3285 {
3286     setCurrentTime(MediaTime::createWithDouble(time));
3287 }
3288 
3289 void HTMLMediaElement::setCurrentTimeWithTolerance(double time, double toleranceBefore, double toleranceAfter)
3290 {
3291     seekWithTolerance(MediaTime::createWithDouble(time), MediaTime::createWithDouble(toleranceBefore), MediaTime::createWithDouble(toleranceAfter), true);
3292 }
3293 
3294 void HTMLMediaElement::setCurrentTime(const MediaTime&amp; time)
3295 {
3296     if (m_mediaController)
3297         return;
3298 
3299     seekInternal(time);
3300 }
3301 
3302 ExceptionOr&lt;void&gt; HTMLMediaElement::setCurrentTimeForBindings(double time)
3303 {
3304     if (m_mediaController)
3305         return Exception { InvalidStateError };
3306     seek(MediaTime::createWithDouble(time));
3307     return { };
3308 }
3309 
3310 double HTMLMediaElement::duration() const
3311 {
3312     return durationMediaTime().toDouble();
3313 }
3314 
3315 MediaTime HTMLMediaElement::durationMediaTime() const
3316 {
3317     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA)
3318         return m_player-&gt;duration();
3319 
3320     return MediaTime::invalidTime();
3321 }
3322 
3323 bool HTMLMediaElement::paused() const
3324 {
3325     // As of this writing, JavaScript garbage collection calls this function directly. In the past
3326     // we had problems where this was called on an object after a bad cast. The assertion below
3327     // made our regression test detect the problem, so we should keep it because of that. But note
3328     // that the value of the assertion relies on the compiler not being smart enough to know that
3329     // isHTMLUnknownElement is guaranteed to return false for an HTMLMediaElement.
3330     ASSERT(!isHTMLUnknownElement());
3331 
3332     return m_paused;
3333 }
3334 
3335 double HTMLMediaElement::defaultPlaybackRate() const
3336 {
3337 #if ENABLE(MEDIA_STREAM)
3338     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3339     // &quot;defaultPlaybackRate&quot; - On setting: ignored. On getting: return 1.0
3340     // A MediaStream is not seekable. Therefore, this attribute must always have the
3341     // value 1.0 and any attempt to alter it must be ignored. Note that this also means
3342     // that the ratechange event will not fire.
3343     if (m_mediaStreamSrcObject)
3344         return 1;
3345 #endif
3346 
3347     return m_defaultPlaybackRate;
3348 }
3349 
3350 void HTMLMediaElement::setDefaultPlaybackRate(double rate)
3351 {
3352 #if ENABLE(MEDIA_STREAM)
3353     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3354     // &quot;defaultPlaybackRate&quot; - On setting: ignored. On getting: return 1.0
3355     // A MediaStream is not seekable. Therefore, this attribute must always have the
3356     // value 1.0 and any attempt to alter it must be ignored. Note that this also means
3357     // that the ratechange event will not fire.
3358     if (m_mediaStreamSrcObject)
3359         return;
3360 #endif
3361 
3362     if (m_defaultPlaybackRate == rate)
3363         return;
3364 
3365     ALWAYS_LOG(LOGIDENTIFIER, rate);
3366     m_defaultPlaybackRate = rate;
3367     scheduleEvent(eventNames().ratechangeEvent);
3368 }
3369 
3370 double HTMLMediaElement::effectivePlaybackRate() const
3371 {
3372     return m_mediaController ? m_mediaController-&gt;playbackRate() : m_reportedPlaybackRate;
3373 }
3374 
3375 double HTMLMediaElement::requestedPlaybackRate() const
3376 {
3377     return m_mediaController ? m_mediaController-&gt;playbackRate() : m_requestedPlaybackRate;
3378 }
3379 
3380 double HTMLMediaElement::playbackRate() const
3381 {
3382 #if ENABLE(MEDIA_STREAM)
3383     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3384     // &quot;playbackRate&quot; - A MediaStream is not seekable. Therefore, this attribute must always
3385     // have the value 1.0 and any attempt to alter it must be ignored. Note that this also
3386     // means that the ratechange event will not fire.
3387     if (m_mediaStreamSrcObject)
3388         return 1;
3389 #endif
3390 
3391     return m_requestedPlaybackRate;
3392 }
3393 
3394 void HTMLMediaElement::setPlaybackRate(double rate)
3395 {
3396     ALWAYS_LOG(LOGIDENTIFIER, rate);
3397 
3398 #if ENABLE(MEDIA_STREAM)
3399     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3400     // &quot;playbackRate&quot; - A MediaStream is not seekable. Therefore, this attribute must always
3401     // have the value 1.0 and any attempt to alter it must be ignored. Note that this also
3402     // means that the ratechange event will not fire.
3403     if (m_mediaStreamSrcObject)
3404         return;
3405 #endif
3406 
3407     if (m_player &amp;&amp; potentiallyPlaying() &amp;&amp; m_player-&gt;rate() != rate &amp;&amp; !m_mediaController)
3408         m_player-&gt;setRate(rate);
3409 
3410     if (m_requestedPlaybackRate != rate) {
3411         m_reportedPlaybackRate = m_requestedPlaybackRate = rate;
3412         invalidateCachedTime();
3413         scheduleEvent(eventNames().ratechangeEvent);
3414     }
3415 }
3416 
3417 void HTMLMediaElement::updatePlaybackRate()
3418 {
3419     double requestedRate = requestedPlaybackRate();
3420     if (m_player &amp;&amp; potentiallyPlaying() &amp;&amp; m_player-&gt;rate() != requestedRate)
3421         m_player-&gt;setRate(requestedRate);
3422 }
3423 
3424 bool HTMLMediaElement::webkitPreservesPitch() const
3425 {
3426     return m_webkitPreservesPitch;
3427 }
3428 
3429 void HTMLMediaElement::setWebkitPreservesPitch(bool preservesPitch)
3430 {
3431     INFO_LOG(LOGIDENTIFIER, preservesPitch);
3432 
3433     m_webkitPreservesPitch = preservesPitch;
3434 
3435     if (!m_player)
3436         return;
3437 
3438     m_player-&gt;setPreservesPitch(preservesPitch);
3439 }
3440 
3441 bool HTMLMediaElement::ended() const
3442 {
3443 #if ENABLE(MEDIA_STREAM)
3444     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3445     // When the MediaStream state moves from the active to the inactive state, the User Agent
3446     // must raise an ended event on the HTMLMediaElement and set its ended attribute to true.
3447     if (m_mediaStreamSrcObject &amp;&amp; m_player &amp;&amp; m_player-&gt;ended())
3448         return true;
3449 #endif
3450 
3451     // 4.8.10.8 Playing the media resource
3452     // The ended attribute must return true if the media element has ended
3453     // playback and the direction of playback is forwards, and false otherwise.
3454     return endedPlayback() &amp;&amp; requestedPlaybackRate() &gt; 0;
3455 }
3456 
3457 bool HTMLMediaElement::autoplay() const
3458 {
3459     return hasAttributeWithoutSynchronization(autoplayAttr);
3460 }
3461 
3462 String HTMLMediaElement::preload() const
3463 {
3464 #if ENABLE(MEDIA_STREAM)
3465     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3466     // &quot;preload&quot; - On getting: none. On setting: ignored.
3467     if (m_mediaStreamSrcObject)
3468         return &quot;none&quot;_s;
3469 #endif
3470 
3471     switch (m_preload) {
3472     case MediaPlayer::None:
3473         return &quot;none&quot;_s;
3474     case MediaPlayer::MetaData:
3475         return &quot;metadata&quot;_s;
3476     case MediaPlayer::Auto:
3477         return &quot;auto&quot;_s;
3478     }
3479 
3480     ASSERT_NOT_REACHED();
3481     return String();
3482 }
3483 
3484 void HTMLMediaElement::setPreload(const String&amp; preload)
3485 {
3486     INFO_LOG(LOGIDENTIFIER, preload);
3487 #if ENABLE(MEDIA_STREAM)
3488     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3489     // &quot;preload&quot; - On getting: none. On setting: ignored.
3490     if (m_mediaStreamSrcObject)
3491         return;
3492 #endif
3493 
3494     setAttributeWithoutSynchronization(preloadAttr, preload);
3495 }
3496 
3497 void HTMLMediaElement::play(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
3498 {
3499     ALWAYS_LOG(LOGIDENTIFIER);
3500 
3501     auto success = m_mediaSession-&gt;playbackPermitted();
3502     if (!success) {
3503         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3504             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3505         promise.reject(NotAllowedError);
3506         return;
3507     }
3508 
3509     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED) {
3510         promise.reject(NotSupportedError, &quot;The operation is not supported.&quot;);
3511         return;
3512     }
3513 
3514     if (processingUserGestureForMedia())
<a name="49" id="anc49"></a><span class="line-modified">3515         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
3516 
3517     m_pendingPlayPromises.append(WTFMove(promise));
3518     playInternal();
3519 }
3520 
3521 void HTMLMediaElement::play()
3522 {
3523     ALWAYS_LOG(LOGIDENTIFIER);
3524 
3525     auto success = m_mediaSession-&gt;playbackPermitted();
3526     if (!success) {
3527         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3528             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3529         return;
3530     }
3531     if (processingUserGestureForMedia())
<a name="50" id="anc50"></a><span class="line-modified">3532         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
3533 
3534     playInternal();
3535 }
3536 
3537 void HTMLMediaElement::playInternal()
3538 {
3539     ALWAYS_LOG(LOGIDENTIFIER);
3540 
3541     if (isSuspended()) {
<a name="51" id="anc51"></a><span class="line-modified">3542         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);</span>
3543         return;
3544     }
3545 
3546     if (!document().hasBrowsingContext()) {
<a name="52" id="anc52"></a><span class="line-modified">3547         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);</span>
3548         return;
3549     }
3550 
3551     if (!m_mediaSession-&gt;clientWillBeginPlayback()) {
<a name="53" id="anc53"></a><span class="line-modified">3552         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);</span>
3553         return;
3554     }
3555 
3556     // 4.8.10.9. Playing the media resource
3557     if (!m_player || m_networkState == NETWORK_EMPTY)
3558         selectMediaResource();
3559 
3560     if (endedPlayback())
3561         seekInternal(MediaTime::zeroTime());
3562 
3563     if (m_mediaController)
3564         m_mediaController-&gt;bringElementUpToSpeed(*this);
3565 
3566     if (m_paused) {
3567         m_paused = false;
3568         invalidateCachedTime();
<a name="54" id="anc54"></a><span class="line-modified">3569 </span>
<span class="line-added">3570         // This avoids the first timeUpdated event after playback starts, when currentTime is still</span>
<span class="line-added">3571         // the same as it was when the video was paused (and the time hasn&#39;t changed yet).</span>
<span class="line-added">3572         m_lastTimeUpdateEventMovieTime = currentMediaTime();</span>
<span class="line-added">3573         m_playbackStartedTime = m_lastTimeUpdateEventMovieTime.toDouble();</span>
<span class="line-added">3574 </span>
3575         scheduleEvent(eventNames().playEvent);
3576 
3577 #if ENABLE(MEDIA_SESSION)
3578         // 6.3 Activating a media session from a media element
3579         // When the play() method is invoked, the paused attribute is true, and the readyState attribute has the value
3580         // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then
3581         // 1. Let media session be the value of the current media session.
3582         // 2. If we are not currently in media session&#39;s list of active participating media elements then append
3583         //    ourselves to this list.
3584         // 3. Let activated be the result of running the media session invocation algorithm for media session.
3585         // 4. If activated is failure, pause ourselves.
3586         if (m_readyState == HAVE_ENOUGH_DATA || m_readyState == HAVE_FUTURE_DATA) {
3587             if (m_session) {
3588                 m_session-&gt;addActiveMediaElement(*this);
3589 
3590                 if (m_session-&gt;kind() == MediaSessionKind::Content) {
3591                     if (Page* page = document().page())
3592                         page-&gt;chrome().client().focusedContentMediaElementDidChange(m_elementID);
3593                 }
3594 
3595                 if (!m_session-&gt;invoke()) {
3596                     pause();
3597                     return;
3598                 }
3599             }
3600         }
3601 #endif
3602         if (m_readyState &lt;= HAVE_CURRENT_DATA)
3603             scheduleEvent(eventNames().waitingEvent);
3604     } else if (m_readyState &gt;= HAVE_FUTURE_DATA)
3605         scheduleResolvePendingPlayPromises();
3606 
3607     if (processingUserGestureForMedia()) {
3608         if (m_autoplayEventPlaybackState == AutoplayEventPlaybackState::PreventedAutoplay) {
3609             handleAutoplayEvent(AutoplayEvent::DidPlayMediaWithUserGesture);
3610             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3611         } else
3612             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithUserGesture);
3613     } else
3614         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
3615 
3616     m_autoplaying = false;
3617     updatePlayState();
3618 }
3619 
3620 void HTMLMediaElement::pause()
3621 {
3622     ALWAYS_LOG(LOGIDENTIFIER);
3623 
3624     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
3625 
3626     if (m_waitingToEnterFullscreen)
3627         m_waitingToEnterFullscreen = false;
3628 
3629     if (!m_mediaSession-&gt;playbackPermitted())
3630         return;
3631 
3632     if (processingUserGestureForMedia())
<a name="55" id="anc55"></a><span class="line-modified">3633         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3634 
3635     pauseInternal();
3636 }
3637 
3638 
3639 void HTMLMediaElement::pauseInternal()
3640 {
3641     ALWAYS_LOG(LOGIDENTIFIER);
3642 
3643     if (isSuspended()) {
<a name="56" id="anc56"></a><span class="line-modified">3644         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);</span>
3645         return;
3646     }
3647 
3648     if (!document().hasBrowsingContext()) {
<a name="57" id="anc57"></a><span class="line-modified">3649         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);</span>
3650         return;
3651     }
3652 
3653     if (!m_mediaSession-&gt;clientWillPausePlayback()) {
<a name="58" id="anc58"></a><span class="line-modified">3654         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);</span>
3655         return;
3656     }
3657 
3658     // 4.8.10.9. Playing the media resource
3659     if (!m_player || m_networkState == NETWORK_EMPTY) {
3660         // Unless the restriction on media requiring user action has been lifted
3661         // don&#39;t trigger loading if a script calls pause().
3662         if (!m_mediaSession-&gt;playbackPermitted())
3663             return;
3664         selectMediaResource();
3665     }
3666 
3667     m_autoplaying = false;
3668 
3669     if (processingUserGestureForMedia())
3670         userDidInterfereWithAutoplay();
3671 
3672     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3673 
3674     if (!m_paused) {
3675         m_paused = true;
3676         scheduleTimeupdateEvent(false);
3677         scheduleEvent(eventNames().pauseEvent);
3678         scheduleRejectPendingPlayPromises(DOMException::create(AbortError));
3679         if (MemoryPressureHandler::singleton().isUnderMemoryPressure())
3680             purgeBufferedDataIfPossible();
3681     }
3682 
3683     updatePlayState();
3684 }
3685 
3686 #if ENABLE(MEDIA_SOURCE)
3687 
3688 void HTMLMediaElement::detachMediaSource()
3689 {
3690     if (!m_mediaSource)
3691         return;
3692 
3693     m_mediaSource-&gt;detachFromElement(*this);
3694     m_mediaSource = nullptr;
3695 }
3696 
3697 #endif
3698 
3699 bool HTMLMediaElement::loop() const
3700 {
3701     return hasAttributeWithoutSynchronization(loopAttr);
3702 }
3703 
<a name="59" id="anc59"></a><span class="line-modified">3704 void HTMLMediaElement::setLoop(bool loop)</span>
3705 {
<a name="60" id="anc60"></a><span class="line-modified">3706     INFO_LOG(LOGIDENTIFIER, loop);</span>
<span class="line-modified">3707     setBooleanAttribute(loopAttr, loop);</span>
3708 }
3709 
3710 bool HTMLMediaElement::controls() const
3711 {
3712     RefPtr&lt;Frame&gt; frame = document().frame();
3713 
3714     // always show controls when scripting is disabled
3715     if (frame &amp;&amp; !frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
3716         return true;
3717 
3718     return hasAttributeWithoutSynchronization(controlsAttr);
3719 }
3720 
<a name="61" id="anc61"></a><span class="line-modified">3721 void HTMLMediaElement::setControls(bool controls)</span>
3722 {
<a name="62" id="anc62"></a><span class="line-modified">3723     INFO_LOG(LOGIDENTIFIER, controls);</span>
<span class="line-modified">3724     setBooleanAttribute(controlsAttr, controls);</span>
3725 }
3726 
3727 double HTMLMediaElement::volume() const
3728 {
3729     return m_volume;
3730 }
3731 
3732 ExceptionOr&lt;void&gt; HTMLMediaElement::setVolume(double volume)
3733 {
3734     INFO_LOG(LOGIDENTIFIER, volume);
3735 
3736     if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
3737         return Exception { IndexSizeError };
3738 
<a name="63" id="anc63"></a>
3739     if (m_volume == volume)
3740         return { };
3741 
<a name="64" id="anc64"></a><span class="line-added">3742 #if !PLATFORM(IOS_FAMILY)</span>
3743     if (volume &amp;&amp; processingUserGestureForMedia())
<a name="65" id="anc65"></a><span class="line-modified">3744         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3745 
3746     m_volume = volume;
3747     m_volumeInitialized = true;
3748     updateVolume();
3749     scheduleEvent(eventNames().volumechangeEvent);
3750 
3751     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
3752         pauseInternal();
3753         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3754     }
<a name="66" id="anc66"></a><span class="line-added">3755 #else</span>
<span class="line-added">3756     auto oldVolume = m_volume;</span>
<span class="line-added">3757     m_volume = volume;</span>
<span class="line-added">3758 </span>
<span class="line-added">3759     if (m_volumeRevertTaskQueue.hasPendingTask())</span>
<span class="line-added">3760         return { };</span>
<span class="line-added">3761 </span>
<span class="line-added">3762     m_volumeRevertTaskQueue.scheduleTask([this, oldVolume] {</span>
<span class="line-added">3763         m_volume = oldVolume;</span>
<span class="line-added">3764     });</span>
<span class="line-added">3765 </span>
3766 #endif
<a name="67" id="anc67"></a><span class="line-added">3767 </span>
3768     return { };
3769 }
3770 
3771 bool HTMLMediaElement::muted() const
3772 {
3773     return m_explicitlyMuted ? m_muted : hasAttributeWithoutSynchronization(mutedAttr);
3774 }
3775 
3776 void HTMLMediaElement::setMuted(bool muted)
3777 {
3778     INFO_LOG(LOGIDENTIFIER, muted);
3779 
3780     bool mutedStateChanged = m_muted != muted;
3781     if (mutedStateChanged || !m_explicitlyMuted) {
3782         if (processingUserGestureForMedia()) {
<a name="68" id="anc68"></a><span class="line-modified">3783             removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3784 
3785             if (hasAudio() &amp;&amp; muted)
3786                 userDidInterfereWithAutoplay();
3787         }
3788 
3789         m_muted = muted;
3790         m_explicitlyMuted = true;
3791 
3792         // Avoid recursion when the player reports volume changes.
3793         if (!processingMediaPlayerCallback()) {
3794             if (m_player) {
3795                 m_player-&gt;setMuted(effectiveMuted());
3796                 if (hasMediaControls())
3797                     mediaControls()-&gt;changedMute();
3798             }
3799         }
3800 
3801         if (mutedStateChanged)
3802             scheduleEvent(eventNames().volumechangeEvent);
3803 
3804         updateShouldPlay();
3805 
3806 #if ENABLE(MEDIA_SESSION)
3807         document().updateIsPlayingMedia(m_elementID);
3808 #else
3809         document().updateIsPlayingMedia();
3810 #endif
3811 
3812 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3813         scheduleUpdateMediaState();
3814 #endif
3815         m_mediaSession-&gt;canProduceAudioChanged();
3816     }
3817 
3818     schedulePlaybackControlsManagerUpdate();
3819 }
3820 
3821 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
3822 void HTMLMediaElement::hardwareMutedStateDidChange(AudioSession* session)
3823 {
3824     if (!session-&gt;isMuted())
3825         return;
3826 
3827     if (!hasAudio())
3828         return;
3829 
3830     if (effectiveMuted() || !volume())
3831         return;
3832 
3833     INFO_LOG(LOGIDENTIFIER);
3834     userDidInterfereWithAutoplay();
3835 }
3836 #endif
3837 
3838 void HTMLMediaElement::togglePlayState()
3839 {
3840     INFO_LOG(LOGIDENTIFIER, &quot;canPlay() is &quot;, canPlay());
3841 
3842     // We can safely call the internal play/pause methods, which don&#39;t check restrictions, because
3843     // this method is only called from the built-in media controller
3844     if (canPlay()) {
3845         updatePlaybackRate();
3846         playInternal();
3847     } else
3848         pauseInternal();
3849 }
3850 
3851 void HTMLMediaElement::beginScrubbing()
3852 {
3853     INFO_LOG(LOGIDENTIFIER, &quot;paused() is &quot;, paused());
3854 
3855     if (!paused()) {
3856         if (ended()) {
3857             // Because a media element stays in non-paused state when it reaches end, playback resumes
3858             // when the slider is dragged from the end to another position unless we pause first. Do
3859             // a &quot;hard pause&quot; so an event is generated, since we want to stay paused after scrubbing finishes.
3860             pause();
3861         } else {
3862             // Not at the end but we still want to pause playback so the media engine doesn&#39;t try to
3863             // continue playing during scrubbing. Pause without generating an event as we will
3864             // unpause after scrubbing finishes.
3865             setPausedInternal(true);
3866         }
3867     }
3868 
3869     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3870 }
3871 
3872 void HTMLMediaElement::endScrubbing()
3873 {
3874     INFO_LOG(LOGIDENTIFIER, &quot;m_pausedInternal is&quot;, m_pausedInternal);
3875 
3876     if (m_pausedInternal)
3877         setPausedInternal(false);
3878 }
3879 
3880 void HTMLMediaElement::beginScanning(ScanDirection direction)
3881 {
3882     m_scanType = supportsScanning() ? Scan : Seek;
3883     m_scanDirection = direction;
3884 
3885     if (m_scanType == Seek) {
3886         // Scanning by seeking requires the video to be paused during scanning.
3887         m_actionAfterScan = paused() ? Nothing : Play;
3888         pause();
3889     } else {
3890         // Scanning by scanning requires the video to be playing during scanninging.
3891         m_actionAfterScan = paused() ? Pause : Nothing;
3892         play();
3893         setPlaybackRate(nextScanRate());
3894     }
3895 
3896     m_scanTimer.start(0_s, m_scanType == Seek ? SeekRepeatDelay : ScanRepeatDelay);
3897 }
3898 
3899 void HTMLMediaElement::endScanning()
3900 {
3901     if (m_scanType == Scan)
3902         setPlaybackRate(defaultPlaybackRate());
3903 
3904     if (m_actionAfterScan == Play)
3905         play();
3906     else if (m_actionAfterScan == Pause)
3907         pause();
3908 
3909     if (m_scanTimer.isActive())
3910         m_scanTimer.stop();
3911 }
3912 
3913 double HTMLMediaElement::nextScanRate()
3914 {
3915     double rate = std::min(ScanMaximumRate, fabs(playbackRate() * 2));
3916     if (m_scanDirection == Backward)
3917         rate *= -1;
3918 #if PLATFORM(IOS_FAMILY)
3919     rate = std::min(std::max(rate, minFastReverseRate()), maxFastForwardRate());
3920 #endif
3921     return rate;
3922 }
3923 
3924 void HTMLMediaElement::scanTimerFired()
3925 {
3926     if (m_scanType == Seek) {
3927         double seekTime = m_scanDirection == Forward ? SeekTime : -SeekTime;
3928         setCurrentTime(currentTime() + seekTime);
3929     } else
3930         setPlaybackRate(nextScanRate());
3931 }
3932 
3933 // The spec says to fire periodic timeupdate events (those sent while playing) every
3934 // &quot;15 to 250ms&quot;, we choose the slowest frequency
3935 static const Seconds maxTimeupdateEventFrequency { 250_ms };
3936 
3937 void HTMLMediaElement::startPlaybackProgressTimer()
3938 {
3939     if (m_playbackProgressTimer.isActive())
3940         return;
3941 
3942     m_previousProgressTime = MonotonicTime::now();
3943     m_playbackProgressTimer.startRepeating(maxTimeupdateEventFrequency);
3944 }
3945 
3946 void HTMLMediaElement::playbackProgressTimerFired()
3947 {
3948     ASSERT(m_player);
3949 
3950     if (m_fragmentEndTime.isValid() &amp;&amp; currentMediaTime() &gt;= m_fragmentEndTime &amp;&amp; requestedPlaybackRate() &gt; 0) {
3951         m_fragmentEndTime = MediaTime::invalidTime();
3952         if (!m_mediaController &amp;&amp; !m_paused) {
3953             // changes paused to true and fires a simple event named pause at the media element.
3954             pauseInternal();
3955         }
3956     }
3957 
3958     scheduleTimeupdateEvent(true);
3959 
3960     if (!requestedPlaybackRate())
3961         return;
3962 
3963     if (!m_paused &amp;&amp; hasMediaControls())
3964         mediaControls()-&gt;playbackProgressed();
3965 
3966 #if ENABLE(VIDEO_TRACK)
3967     updateActiveTextTrackCues(currentMediaTime());
3968 #endif
3969 
3970 #if ENABLE(MEDIA_SOURCE)
3971     if (m_mediaSource)
3972         m_mediaSource-&gt;monitorSourceBuffers();
3973 #endif
3974 
3975     bool playbackStarted = m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithUserGesture || m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithoutUserGesture;
3976     if (!seeking() &amp;&amp; playbackStarted &amp;&amp; currentTime() - playbackStartedTime() &gt; AutoplayInterferenceTimeThreshold) {
3977         handleAutoplayEvent(m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithoutUserGesture ? AutoplayEvent::DidAutoplayMediaPastThresholdWithoutUserInterference : AutoplayEvent::DidPlayMediaWithUserGesture);
3978         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3979     }
3980 }
3981 
3982 void HTMLMediaElement::scheduleTimeupdateEvent(bool periodicEvent)
3983 {
3984     MonotonicTime now = MonotonicTime::now();
3985     Seconds timedelta = now - m_clockTimeAtLastUpdateEvent;
3986 
3987     // throttle the periodic events
3988     if (periodicEvent &amp;&amp; timedelta &lt; maxTimeupdateEventFrequency)
3989         return;
3990 
3991     // Some media engines make multiple &quot;time changed&quot; callbacks at the same time, but we only want one
3992     // event at a given time so filter here
3993     MediaTime movieTime = currentMediaTime();
3994     if (movieTime != m_lastTimeUpdateEventMovieTime) {
3995         scheduleEvent(eventNames().timeupdateEvent);
3996         m_clockTimeAtLastUpdateEvent = now;
3997         m_lastTimeUpdateEventMovieTime = movieTime;
3998     }
3999 }
4000 
4001 bool HTMLMediaElement::canPlay() const
4002 {
4003     return paused() || ended() || m_readyState &lt; HAVE_METADATA;
4004 }
4005 
4006 double HTMLMediaElement::percentLoaded() const
4007 {
4008     if (!m_player)
4009         return 0;
4010     MediaTime duration = m_player-&gt;duration();
4011 
4012     if (!duration || duration.isPositiveInfinite() || duration.isNegativeInfinite())
4013         return 0;
4014 
4015     MediaTime buffered = MediaTime::zeroTime();
4016     bool ignored;
4017     std::unique_ptr&lt;PlatformTimeRanges&gt; timeRanges = m_player-&gt;buffered();
4018     for (unsigned i = 0; i &lt; timeRanges-&gt;length(); ++i) {
4019         MediaTime start = timeRanges-&gt;start(i, ignored);
4020         MediaTime end = timeRanges-&gt;end(i, ignored);
4021         buffered += end - start;
4022     }
4023     return buffered.toDouble() / duration.toDouble();
4024 }
4025 
4026 #if ENABLE(VIDEO_TRACK)
4027 
4028 void HTMLMediaElement::mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp; track)
4029 {
4030     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
4031         pauseInternal();
4032         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
4033     }
4034 
4035     addAudioTrack(AudioTrack::create(*this, track));
4036 }
4037 
4038 void HTMLMediaElement::mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp; track)
4039 {
4040     // 4.8.10.12.2 Sourcing in-band text tracks
4041     // 1. Associate the relevant data with a new text track and its corresponding new TextTrack object.
4042     auto textTrack = InbandTextTrack::create(*ActiveDOMObject::scriptExecutionContext(), *this, track);
4043     textTrack-&gt;setMediaElement(this);
4044 
4045     // 2. Set the new text track&#39;s kind, label, and language based on the semantics of the relevant data,
4046     // as defined by the relevant specification. If there is no label in that data, then the label must
4047     // be set to the empty string.
4048     // 3. Associate the text track list of cues with the rules for updating the text track rendering appropriate
4049     // for the format in question.
4050     // 4. If the new text track&#39;s kind is metadata, then set the text track in-band metadata track dispatch type
4051     // as follows, based on the type of the media resource:
4052     // 5. Populate the new text track&#39;s list of cues with the cues parsed so far, folllowing the guidelines for exposing
4053     // cues, and begin updating it dynamically as necessary.
4054     //   - Thess are all done by the media engine.
4055 
4056     // 6. Set the new text track&#39;s readiness state to loaded.
4057     textTrack-&gt;setReadinessState(TextTrack::Loaded);
4058 
4059     // 7. Set the new text track&#39;s mode to the mode consistent with the user&#39;s preferences and the requirements of
4060     // the relevant specification for the data.
4061     //  - This will happen in configureTextTracks()
4062     scheduleConfigureTextTracks();
4063 
4064     // 8. Add the new text track to the media element&#39;s list of text tracks.
4065     // 9. Fire an event with the name addtrack, that does not bubble and is not cancelable, and that uses the TrackEvent
4066     // interface, with the track attribute initialized to the text track&#39;s TextTrack object, at the media element&#39;s
4067     // textTracks attribute&#39;s TextTrackList object.
4068     addTextTrack(WTFMove(textTrack));
4069 }
4070 
4071 void HTMLMediaElement::mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp; track)
4072 {
4073     addVideoTrack(VideoTrack::create(*this, track));
4074 }
4075 
4076 void HTMLMediaElement::mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp; track)
4077 {
4078     track.willBeRemoved();
4079 }
4080 
4081 void HTMLMediaElement::mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp; track)
4082 {
4083     track.willBeRemoved();
4084 }
4085 
4086 void HTMLMediaElement::mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp; track)
4087 {
4088     track.willBeRemoved();
4089 }
4090 
4091 void HTMLMediaElement::closeCaptionTracksChanged()
4092 {
4093     if (hasMediaControls())
4094         mediaControls()-&gt;closedCaptionTracksChanged();
4095 }
4096 
4097 void HTMLMediaElement::addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp; track)
4098 {
4099     ensureAudioTracks().append(WTFMove(track));
4100 }
4101 
4102 void HTMLMediaElement::addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp; track)
4103 {
4104     if (!m_requireCaptionPreferencesChangedCallbacks) {
4105         m_requireCaptionPreferencesChangedCallbacks = true;
4106         Document&amp; document = this-&gt;document();
4107         document.registerForCaptionPreferencesChangedCallbacks(*this);
4108         if (Page* page = document.page())
4109             m_captionDisplayMode = page-&gt;group().captionPreferences().captionDisplayMode();
4110     }
4111 
4112     ensureTextTracks().append(WTFMove(track));
4113 
4114     closeCaptionTracksChanged();
4115 }
4116 
4117 void HTMLMediaElement::addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp; track)
4118 {
4119     ensureVideoTracks().append(WTFMove(track));
4120 }
4121 
4122 void HTMLMediaElement::removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp; track)
4123 {
4124     track-&gt;clearClient();
4125     m_audioTracks-&gt;remove(track.get());
4126 }
4127 
4128 void HTMLMediaElement::removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp; track, bool scheduleEvent)
4129 {
4130     TrackDisplayUpdateScope scope { *this };
4131     if (auto cues = makeRefPtr(track-&gt;cues()))
4132         textTrackRemoveCues(track, *cues);
4133     track-&gt;clearClient();
4134     if (m_textTracks)
4135         m_textTracks-&gt;remove(track, scheduleEvent);
4136 
4137     closeCaptionTracksChanged();
4138 }
4139 
4140 void HTMLMediaElement::removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp; track)
4141 {
4142     track-&gt;clearClient();
4143     m_videoTracks-&gt;remove(track);
4144 }
4145 
4146 void HTMLMediaElement::forgetResourceSpecificTracks()
4147 {
4148     while (m_audioTracks &amp;&amp;  m_audioTracks-&gt;length())
4149         removeAudioTrack(*m_audioTracks-&gt;lastItem());
4150 
4151     if (m_textTracks) {
4152         TrackDisplayUpdateScope scope { *this };
4153         for (int i = m_textTracks-&gt;length() - 1; i &gt;= 0; --i) {
4154             auto track = makeRef(*m_textTracks-&gt;item(i));
4155             if (track-&gt;trackType() == TextTrack::InBand)
4156                 removeTextTrack(WTFMove(track), false);
4157         }
4158     }
4159 
4160     while (m_videoTracks &amp;&amp;  m_videoTracks-&gt;length())
4161         removeVideoTrack(*m_videoTracks-&gt;lastItem());
4162 }
4163 
4164 ExceptionOr&lt;TextTrack&amp;&gt; HTMLMediaElement::addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language)
4165 {
4166     // 4.8.10.12.4 Text track API
4167     // The addTextTrack(kind, label, language) method of media elements, when invoked, must run the following steps:
4168 
4169     // 1. If kind is not one of the following strings, then throw a SyntaxError exception and abort these steps
4170     if (!TextTrack::isValidKindKeyword(kind))
4171         return Exception { TypeError };
4172 
4173     // 2. If the label argument was omitted, let label be the empty string.
4174     // 3. If the language argument was omitted, let language be the empty string.
4175     // 4. Create a new TextTrack object.
4176 
4177     // 5. Create a new text track corresponding to the new object, and set its text track kind to kind, its text
4178     // track label to label, its text track language to language...
4179     auto track = TextTrack::create(ActiveDOMObject::scriptExecutionContext(), this, kind, emptyString(), label, language);
4180     auto&amp; trackReference = track.get();
4181 
4182     // Note, due to side effects when changing track parameters, we have to
4183     // first append the track to the text track list.
4184 
4185     // 6. Add the new text track to the media element&#39;s list of text tracks.
4186     addTextTrack(WTFMove(track));
4187 
4188     // ... its text track readiness state to the text track loaded state ...
4189     trackReference.setReadinessState(TextTrack::Loaded);
4190 
4191     // ... its text track mode to the text track hidden mode, and its text track list of cues to an empty list ...
4192     trackReference.setMode(TextTrack::Mode::Hidden);
4193 
4194     return trackReference;
4195 }
4196 
4197 AudioTrackList&amp; HTMLMediaElement::ensureAudioTracks()
4198 {
4199     if (!m_audioTracks)
4200         m_audioTracks = AudioTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
4201 
4202     return *m_audioTracks;
4203 }
4204 
4205 TextTrackList&amp; HTMLMediaElement::ensureTextTracks()
4206 {
4207     if (!m_textTracks)
4208         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
4209 
4210     return *m_textTracks;
4211 }
4212 
4213 VideoTrackList&amp; HTMLMediaElement::ensureVideoTracks()
4214 {
4215     if (!m_videoTracks)
4216         m_videoTracks = VideoTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
4217 
4218     return *m_videoTracks;
4219 }
4220 
4221 void HTMLMediaElement::didAddTextTrack(HTMLTrackElement&amp; trackElement)
4222 {
4223     ASSERT(trackElement.hasTagName(trackTag));
4224 
4225     // 4.8.10.12.3 Sourcing out-of-band text tracks
4226     // When a track element&#39;s parent element changes and the new parent is a media element,
4227     // then the user agent must add the track element&#39;s corresponding text track to the
4228     // media element&#39;s list of text tracks ... [continues in TextTrackList::append]
4229     addTextTrack(trackElement.track());
4230 
4231     // Do not schedule the track loading until parsing finishes so we don&#39;t start before all tracks
4232     // in the markup have been added.
4233     if (!m_parsingInProgress)
4234         scheduleConfigureTextTracks();
4235 
4236     if (hasMediaControls())
4237         mediaControls()-&gt;closedCaptionTracksChanged();
4238 }
4239 
4240 void HTMLMediaElement::didRemoveTextTrack(HTMLTrackElement&amp; trackElement)
4241 {
4242     ASSERT(trackElement.hasTagName(trackTag));
4243 
4244     auto&amp; textTrack = trackElement.track();
4245 
4246     textTrack.setHasBeenConfigured(false);
4247 
4248     if (!m_textTracks)
4249         return;
4250 
4251     // 4.8.10.12.3 Sourcing out-of-band text tracks
4252     // When a track element&#39;s parent element changes and the old parent was a media element,
4253     // then the user agent must remove the track element&#39;s corresponding text track from the
4254     // media element&#39;s list of text tracks.
4255     removeTextTrack(textTrack);
4256 
4257     m_textTracksWhenResourceSelectionBegan.removeFirst(&amp;textTrack);
4258 }
4259 
<a name="69" id="anc69"></a>
4260 void HTMLMediaElement::configureTextTrackGroup(const TrackGroup&amp; group)
4261 {
4262     ASSERT(group.tracks.size());
4263 
4264     Page* page = document().page();
4265     CaptionUserPreferences* captionPreferences = page ? &amp;page-&gt;group().captionPreferences() : 0;
4266     CaptionUserPreferences::CaptionDisplayMode displayMode = captionPreferences ? captionPreferences-&gt;captionDisplayMode() : CaptionUserPreferences::Automatic;
4267 
4268     // First, find the track in the group that should be enabled (if any).
4269     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; currentlyEnabledTracks;
4270     RefPtr&lt;TextTrack&gt; trackToEnable;
4271     RefPtr&lt;TextTrack&gt; defaultTrack;
4272     RefPtr&lt;TextTrack&gt; fallbackTrack;
4273     RefPtr&lt;TextTrack&gt; forcedSubitleTrack;
4274     int highestTrackScore = 0;
4275     int highestForcedScore = 0;
4276 
4277     // If there is a visible track, it has already been configured so it won&#39;t be considered in the loop below. We don&#39;t want to choose another
4278     // track if it is less suitable, and we do want to disable it if another track is more suitable.
4279     int alreadyVisibleTrackScore = 0;
4280     if (group.visibleTrack &amp;&amp; captionPreferences) {
4281         alreadyVisibleTrackScore = captionPreferences-&gt;textTrackSelectionScore(group.visibleTrack.get(), this);
4282         currentlyEnabledTracks.append(group.visibleTrack);
4283     }
4284 
4285     for (size_t i = 0; i &lt; group.tracks.size(); ++i) {
4286         RefPtr&lt;TextTrack&gt; textTrack = group.tracks[i];
4287 
4288         if (m_processingPreferenceChange &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing)
4289             currentlyEnabledTracks.append(textTrack);
4290 
4291         int trackScore = captionPreferences ? captionPreferences-&gt;textTrackSelectionScore(textTrack.get(), this) : 0;
4292         INFO_LOG(LOGIDENTIFIER, &quot;&#39;&quot;, textTrack-&gt;kindKeyword(), &quot;&#39; track with language &#39;&quot;, textTrack-&gt;language(), &quot;&#39; and BCP 47 language &#39;&quot;, textTrack-&gt;validBCP47Language(), &quot;&#39; has score &quot;, trackScore);
4293 
4294         if (trackScore) {
4295 
4296             // * If the text track kind is { [subtitles or captions] [descriptions] } and the user has indicated an interest in having a
4297             // track with this text track kind, text track language, and text track label enabled, and there is no
4298             // other text track in the media element&#39;s list of text tracks with a text track kind of either subtitles
4299             // or captions whose text track mode is showing
4300             // ...
4301             // * If the text track kind is chapters and the text track language is one that the user agent has reason
4302             // to believe is appropriate for the user, and there is no other text track in the media element&#39;s list of
4303             // text tracks with a text track kind of chapters whose text track mode is showing
4304             //    Let the text track mode be showing.
4305             if (trackScore &gt; highestTrackScore &amp;&amp; trackScore &gt; alreadyVisibleTrackScore) {
4306                 highestTrackScore = trackScore;
4307                 trackToEnable = textTrack;
4308             }
4309 
4310             if (!defaultTrack &amp;&amp; textTrack-&gt;isDefault())
4311                 defaultTrack = textTrack;
4312             if (!defaultTrack &amp;&amp; !fallbackTrack)
4313                 fallbackTrack = textTrack;
4314             if (textTrack-&gt;containsOnlyForcedSubtitles() &amp;&amp; trackScore &gt; highestForcedScore) {
4315                 forcedSubitleTrack = textTrack;
4316                 highestForcedScore = trackScore;
4317             }
4318         } else if (!group.visibleTrack &amp;&amp; !defaultTrack &amp;&amp; textTrack-&gt;isDefault()) {
4319             // * If the track element has a default attribute specified, and there is no other text track in the media
4320             // element&#39;s list of text tracks whose text track mode is showing or showing by default
4321             //    Let the text track mode be showing by default.
4322             if (group.kind != TrackGroup::CaptionsAndSubtitles || displayMode != CaptionUserPreferences::ForcedOnly)
4323                 defaultTrack = textTrack;
4324         }
4325     }
4326 
4327     if (displayMode != CaptionUserPreferences::Manual) {
4328         if (!trackToEnable &amp;&amp; defaultTrack)
4329             trackToEnable = defaultTrack;
4330 
4331         // If no track matches the user&#39;s preferred language, none was marked as &#39;default&#39;, and there is a forced subtitle track
4332         // in the same language as the language of the primary audio track, enable it.
4333         if (!trackToEnable &amp;&amp; forcedSubitleTrack)
4334             trackToEnable = forcedSubitleTrack;
4335 
4336         // If no track matches, don&#39;t disable an already visible track unless preferences say they all should be off.
4337         if (group.kind != TrackGroup::CaptionsAndSubtitles || displayMode != CaptionUserPreferences::ForcedOnly) {
4338             if (!trackToEnable &amp;&amp; !defaultTrack &amp;&amp; group.visibleTrack)
4339                 trackToEnable = group.visibleTrack;
4340         }
4341 
4342         // If no track matches the user&#39;s preferred language and non was marked &#39;default&#39;, enable the first track
4343         // because the user has explicitly stated a preference for this kind of track.
4344         if (!trackToEnable &amp;&amp; fallbackTrack)
4345             trackToEnable = fallbackTrack;
4346 
4347         if (trackToEnable)
4348             m_subtitleTrackLanguage = trackToEnable-&gt;language();
4349         else
4350             m_subtitleTrackLanguage = emptyString();
4351     }
4352 
4353     if (currentlyEnabledTracks.size()) {
4354         for (size_t i = 0; i &lt; currentlyEnabledTracks.size(); ++i) {
4355             RefPtr&lt;TextTrack&gt; textTrack = currentlyEnabledTracks[i];
4356             if (textTrack != trackToEnable)
4357                 textTrack-&gt;setMode(TextTrack::Mode::Disabled);
4358         }
4359     }
4360 
4361     if (trackToEnable) {
4362         trackToEnable-&gt;setMode(TextTrack::Mode::Showing);
4363 
4364         // If user preferences indicate we should always display captions, make sure we reflect the
4365         // proper status via the webkitClosedCaptionsVisible API call:
4366         if (!webkitClosedCaptionsVisible() &amp;&amp; closedCaptionsVisible() &amp;&amp; displayMode == CaptionUserPreferences::AlwaysOn)
4367             m_webkitLegacyClosedCaptionOverride = true;
4368     }
4369 
4370     m_processingPreferenceChange = false;
4371 }
<a name="70" id="anc70"></a><span class="line-modified">4372 </span>
4373 static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)
4374 {
4375     JSC::VM&amp; vm = globalObject.vm();
4376     auto scope = DECLARE_THROW_SCOPE(vm);
4377     auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);
4378 
4379     // Retrieve the controller through the JS object graph
4380     JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
4381     if (!mediaJSWrapperObject)
4382         return JSC::jsNull();
4383 
<a name="71" id="anc71"></a><span class="line-modified">4384     JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);</span>
4385     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);
4386     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4387 
4388     JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
4389     if (!controlsHostJSWrapperObject)
4390         return JSC::jsNull();
4391 
<a name="72" id="anc72"></a><span class="line-modified">4392     JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);</span>
4393     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);
4394     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4395 
4396     return controllerJSWrapper;
4397 }
4398 
4399 void HTMLMediaElement::ensureMediaControlsShadowRoot()
4400 {
4401     ASSERT(!m_creatingControls);
4402     m_creatingControls = true;
4403     ensureUserAgentShadowRoot();
4404     m_creatingControls = false;
4405 }
4406 
4407 bool HTMLMediaElement::setupAndCallJS(const JSSetupFunction&amp; task)
4408 {
4409     Page* page = document().page();
4410     if (!page)
4411         return false;
4412 
4413     auto pendingActivity = makePendingActivity(*this);
4414     auto&amp; world = ensureIsolatedWorld();
4415     auto&amp; scriptController = document().frame()-&gt;script();
4416     auto* globalObject = JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(world));
4417     auto&amp; vm = globalObject-&gt;vm();
4418     JSC::JSLockHolder lock(vm);
4419     auto scope = DECLARE_THROW_SCOPE(vm);
4420     auto* exec = globalObject-&gt;globalExec();
4421 
4422     RETURN_IF_EXCEPTION(scope, false);
4423 
4424     return task(*globalObject, *exec, scriptController, world);
4425 }
4426 
4427 void HTMLMediaElement::updateCaptionContainer()
4428 {
4429 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4430     if (m_haveSetUpCaptionContainer)
4431         return;
4432 
4433     if (!ensureMediaControlsInjectedScript())
4434         return;
4435 
4436     ensureMediaControlsShadowRoot();
4437 
4438     if (!m_mediaControlsHost)
4439         m_mediaControlsHost = MediaControlsHost::create(this);
4440 
4441     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
4442         auto&amp; vm = globalObject.vm();
4443         auto scope = DECLARE_CATCH_SCOPE(vm);
4444         auto controllerValue = controllerJSValue(exec, globalObject, *this);
4445         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
4446         if (!controllerObject)
4447             return false;
4448 
4449         // The media controls script must provide a method on the Controller object with the following details.
4450         // Name: updateCaptionContainer
4451         // Parameters:
4452         //     None
4453         // Return value:
4454         //     None
<a name="73" id="anc73"></a><span class="line-modified">4455         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
4456         auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
4457         if (!methodObject)
4458             return false;
4459 
4460         JSC::CallData callData;
4461         auto callType = methodObject-&gt;methodTable(vm)-&gt;getCallData(methodObject, callData);
4462         if (callType == JSC::CallType::None)
4463             return false;
4464 
4465         JSC::MarkedArgumentBuffer noArguments;
4466         ASSERT(!noArguments.hasOverflowed());
4467         JSC::call(&amp;exec, methodObject, callType, callData, controllerObject, noArguments);
4468         scope.clearException();
4469 
4470         m_haveSetUpCaptionContainer = true;
4471 
4472         return true;
4473     });
4474 
4475 #endif
4476 }
4477 
4478 void HTMLMediaElement::layoutSizeChanged()
4479 {
4480 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4481     if (auto frameView = makeRefPtr(document().view())) {
4482         auto task = [this, protectedThis = makeRef(*this)] {
4483             if (auto root = userAgentShadowRoot())
4484                 root-&gt;dispatchEvent(Event::create(&quot;resize&quot;, Event::CanBubble::No, Event::IsCancelable::No));
4485         };
4486         frameView-&gt;queuePostLayoutCallback(WTFMove(task));
4487     }
4488 #endif
4489 
4490     if (!m_receivedLayoutSizeChanged) {
4491         m_receivedLayoutSizeChanged = true;
4492         schedulePlaybackControlsManagerUpdate();
4493     }
4494 
4495     // If the video is a candidate for main content, we should register it for viewport visibility callbacks
4496     // if it hasn&#39;t already been registered.
4497     if (renderer() &amp;&amp; m_mediaSession &amp;&amp; !m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay() &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForMediaControls())
4498         renderer()-&gt;registerForVisibleInViewportCallback();
4499 }
4500 
4501 void HTMLMediaElement::visibilityDidChange()
4502 {
4503     updateShouldAutoplay();
4504 }
4505 
4506 void HTMLMediaElement::setSelectedTextTrack(TextTrack* trackToSelect)
4507 {
4508     auto* trackList = textTracks();
4509     if (!trackList || !trackList-&gt;length())
4510         return;
4511 
4512     if (trackToSelect == TextTrack::captionMenuAutomaticItem()) {
4513         if (captionDisplayMode() != CaptionUserPreferences::Automatic)
4514             m_textTracks-&gt;scheduleChangeEvent();
4515     } else if (trackToSelect == TextTrack::captionMenuOffItem()) {
4516         for (int i = 0, length = trackList-&gt;length(); i &lt; length; ++i)
4517             trackList-&gt;item(i)-&gt;setMode(TextTrack::Mode::Disabled);
4518 
4519         if (captionDisplayMode() != CaptionUserPreferences::ForcedOnly &amp;&amp; !trackList-&gt;isChangeEventScheduled())
4520             m_textTracks-&gt;scheduleChangeEvent();
4521     } else {
4522         if (!trackToSelect || !trackList-&gt;contains(*trackToSelect))
4523             return;
4524 
4525         for (int i = 0, length = trackList-&gt;length(); i &lt; length; ++i) {
4526             auto&amp; track = *trackList-&gt;item(i);
4527             if (&amp;track != trackToSelect)
4528                 track.setMode(TextTrack::Mode::Disabled);
4529             else
4530                 track.setMode(TextTrack::Mode::Showing);
4531         }
4532     }
4533 
4534     if (!document().page())
4535         return;
4536 
4537     auto&amp; captionPreferences = document().page()-&gt;group().captionPreferences();
4538     CaptionUserPreferences::CaptionDisplayMode displayMode;
4539     if (trackToSelect == TextTrack::captionMenuOffItem())
4540         displayMode = CaptionUserPreferences::ForcedOnly;
4541     else if (trackToSelect == TextTrack::captionMenuAutomaticItem())
4542         displayMode = CaptionUserPreferences::Automatic;
4543     else {
4544         displayMode = CaptionUserPreferences::AlwaysOn;
4545         if (trackToSelect-&gt;validBCP47Language().length())
4546             captionPreferences.setPreferredLanguage(trackToSelect-&gt;validBCP47Language());
4547     }
4548 
4549     captionPreferences.setCaptionDisplayMode(displayMode);
4550 }
4551 
4552 void HTMLMediaElement::scheduleConfigureTextTracks()
4553 {
4554     if (m_configureTextTracksTask.hasPendingTask())
4555         return;
4556 
4557     auto logSiteIdentifier = LOGIDENTIFIER;
4558     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
4559     m_configureTextTracksTask.scheduleTask([this, logSiteIdentifier] {
4560         UNUSED_PARAM(logSiteIdentifier);
4561         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
4562         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // configureTextTracks calls methods that can trigger arbitrary DOM mutations.
4563         configureTextTracks();
4564     });
4565 }
4566 
4567 void HTMLMediaElement::configureTextTracks()
4568 {
4569     TrackGroup captionAndSubtitleTracks(TrackGroup::CaptionsAndSubtitles);
4570     TrackGroup descriptionTracks(TrackGroup::Description);
4571     TrackGroup chapterTracks(TrackGroup::Chapter);
4572     TrackGroup metadataTracks(TrackGroup::Metadata);
4573     TrackGroup otherTracks(TrackGroup::Other);
4574 
4575     if (!m_textTracks)
4576         return;
4577 
4578     for (size_t i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
4579         RefPtr&lt;TextTrack&gt; textTrack = m_textTracks-&gt;item(i);
4580         if (!textTrack)
4581             continue;
4582 
4583         auto kind = textTrack-&gt;kind();
4584         TrackGroup* currentGroup;
4585         if (kind == TextTrack::Kind::Subtitles || kind == TextTrack::Kind::Captions || kind == TextTrack::Kind::Forced)
4586             currentGroup = &amp;captionAndSubtitleTracks;
4587         else if (kind == TextTrack::Kind::Descriptions)
4588             currentGroup = &amp;descriptionTracks;
4589         else if (kind == TextTrack::Kind::Chapters)
4590             currentGroup = &amp;chapterTracks;
4591         else if (kind == TextTrack::Kind::Metadata)
4592             currentGroup = &amp;metadataTracks;
4593         else
4594             currentGroup = &amp;otherTracks;
4595 
4596         if (!currentGroup-&gt;visibleTrack &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing)
4597             currentGroup-&gt;visibleTrack = textTrack;
4598         if (!currentGroup-&gt;defaultTrack &amp;&amp; textTrack-&gt;isDefault())
4599             currentGroup-&gt;defaultTrack = textTrack;
4600 
4601         // Do not add this track to the group if it has already been automatically configured
4602         // as we only want to call configureTextTrack once per track so that adding another
4603         // track after the initial configuration doesn&#39;t reconfigure every track - only those
4604         // that should be changed by the new addition. For example all metadata tracks are
4605         // disabled by default, and we don&#39;t want a track that has been enabled by script
4606         // to be disabled automatically when a new metadata track is added later.
4607         if (textTrack-&gt;hasBeenConfigured())
4608             continue;
4609 
4610         if (textTrack-&gt;language().length())
4611             currentGroup-&gt;hasSrcLang = true;
4612         currentGroup-&gt;tracks.append(textTrack);
4613     }
4614 
4615     if (captionAndSubtitleTracks.tracks.size())
4616         configureTextTrackGroup(captionAndSubtitleTracks);
4617     if (descriptionTracks.tracks.size())
4618         configureTextTrackGroup(descriptionTracks);
4619     if (chapterTracks.tracks.size())
4620         configureTextTrackGroup(chapterTracks);
4621     if (metadataTracks.tracks.size())
4622         configureTextTrackGroup(metadataTracks);
4623     if (otherTracks.tracks.size())
4624         configureTextTrackGroup(otherTracks);
4625 
4626     updateCaptionContainer();
4627     configureTextTrackDisplay();
4628     if (hasMediaControls())
4629         mediaControls()-&gt;closedCaptionTracksChanged();
4630 }
4631 #endif
4632 
4633 bool HTMLMediaElement::havePotentialSourceChild()
4634 {
4635     // Stash the current &lt;source&gt; node and next nodes so we can restore them after checking
4636     // to see there is another potential.
4637     RefPtr&lt;HTMLSourceElement&gt; currentSourceNode = m_currentSourceNode;
4638     RefPtr&lt;HTMLSourceElement&gt; nextNode = m_nextChildNodeToConsider;
4639 
4640     URL nextURL = selectNextSourceChild(0, 0, DoNothing);
4641 
4642     m_currentSourceNode = currentSourceNode;
4643     m_nextChildNodeToConsider = nextNode;
4644 
4645     return nextURL.isValid();
4646 }
4647 
4648 URL HTMLMediaElement::selectNextSourceChild(ContentType* contentType, String* keySystem, InvalidURLAction actionIfInvalid)
4649 {
4650     UNUSED_PARAM(keySystem);
4651 
4652     // Don&#39;t log if this was just called to find out if there are any valid &lt;source&gt; elements.
<a name="74" id="anc74"></a><span class="line-modified">4653     bool shouldLog = willLog(WTFLogLevel::Debug) &amp;&amp; actionIfInvalid != DoNothing;</span>
4654     if (shouldLog)
4655         INFO_LOG(LOGIDENTIFIER);
4656 
4657     if (!m_nextChildNodeToConsider) {
4658         if (shouldLog)
4659             INFO_LOG(LOGIDENTIFIER, &quot;end of list, stopping&quot;);
4660         return URL();
4661     }
4662 
4663     // Because the DOM may be mutated in the course of the following algorithm,
4664     // keep strong references to each of the child source nodes, and verify that
4665     // each still is a child of this media element before using.
4666     Vector&lt;Ref&lt;HTMLSourceElement&gt;&gt; potentialSourceNodes;
4667     auto sources = childrenOfType&lt;HTMLSourceElement&gt;(*this);
4668     for (auto next = m_nextChildNodeToConsider ? sources.beginAt(*m_nextChildNodeToConsider) : sources.begin(), end = sources.end(); next != end; ++next)
4669         potentialSourceNodes.append(*next);
4670 
4671     for (auto&amp; source : potentialSourceNodes) {
4672         if (source-&gt;parentNode() != this)
4673             continue;
4674 
4675         // If candidate does not have a src attribute, or if its src attribute&#39;s value is the empty string ... jump down to the failed step below
4676         auto mediaURL = source-&gt;getNonEmptyURLAttribute(srcAttr);
4677         String type;
4678         if (shouldLog)
4679             INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, mediaURL);
4680         if (mediaURL.isEmpty())
4681             goto CheckAgain;
4682 
4683         if (auto* media = source-&gt;parsedMediaAttribute(document())) {
4684             if (shouldLog)
4685                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;media&#39; is &quot;, source-&gt;attributeWithoutSynchronization(mediaAttr));
4686             auto* renderer = this-&gt;renderer();
4687             LOG(MediaQueries, &quot;HTMLMediaElement %p selectNextSourceChild evaluating media queries&quot;, this);
4688             if (!MediaQueryEvaluator { &quot;screen&quot;, document(), renderer ? &amp;renderer-&gt;style() : nullptr }.evaluate(*media))
4689                 goto CheckAgain;
4690         }
4691 
4692         type = source-&gt;attributeWithoutSynchronization(typeAttr);
4693         if (type.isEmpty() &amp;&amp; mediaURL.protocolIsData())
4694             type = mimeTypeFromDataURL(mediaURL);
4695         if (!type.isEmpty()) {
4696             if (shouldLog)
4697                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;type&#39; is &quot;, type);
4698             MediaEngineSupportParameters parameters;
4699             parameters.type = ContentType(type);
4700             parameters.url = mediaURL;
4701 #if ENABLE(MEDIA_SOURCE)
4702             parameters.isMediaSource = mediaURL.protocolIs(mediaSourceBlobProtocol);
4703 #endif
4704 #if ENABLE(MEDIA_STREAM)
4705             parameters.isMediaStream = mediaURL.protocolIs(mediaStreamBlobProtocol);
4706 #endif
4707             if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback() || Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source))
4708                 parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
4709 
4710             if (!MediaPlayer::supportsType(parameters))
4711                 goto CheckAgain;
4712         }
4713 
4714         // Is it safe to load this url?
4715         if (!isSafeToLoadURL(mediaURL, actionIfInvalid) || !dispatchBeforeLoadEvent(mediaURL.string()))
4716             goto CheckAgain;
4717 
4718         // A &#39;beforeload&#39; event handler can mutate the DOM, so check to see if the source element is still a child node.
4719         if (source-&gt;parentNode() != this) {
4720             INFO_LOG(LOGIDENTIFIER, &quot;&#39;beforeload&#39; removed current element&quot;);
4721             continue;
4722         }
4723 
4724         // Making it this far means the &lt;source&gt; looks reasonable.
4725         if (contentType)
4726             *contentType = ContentType(type);
4727         m_nextChildNodeToConsider = Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source);
4728         m_currentSourceNode = WTFMove(source);
4729 
4730         if (shouldLog)
4731             INFO_LOG(LOGIDENTIFIER, &quot; = &quot;, mediaURL);
4732 
4733         return mediaURL;
4734 
4735 CheckAgain:
4736         if (actionIfInvalid == Complain)
4737             source-&gt;scheduleErrorEvent();
4738     }
4739 
4740     m_currentSourceNode = nullptr;
4741     m_nextChildNodeToConsider = nullptr;
4742 
4743 #if !LOG_DISABLED
4744     if (shouldLog)
4745         INFO_LOG(LOGIDENTIFIER, &quot;failed&quot;);
4746 #endif
4747     return URL();
4748 }
4749 
4750 void HTMLMediaElement::sourceWasAdded(HTMLSourceElement&amp; source)
4751 {
<a name="75" id="anc75"></a><span class="line-modified">4752     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4753         URL url = source.getNonEmptyURLAttribute(srcAttr);
4754         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4755     }
4756 
4757     if (!document().hasBrowsingContext()) {
4758         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted inside a document without a browsing context is not loaded&quot;);
4759         return;
4760     }
4761 
4762     // We should only consider a &lt;source&gt; element when there is not src attribute at all.
4763     if (hasAttributeWithoutSynchronization(srcAttr))
4764         return;
4765 
4766     // 4.8.8 - If a source element is inserted as a child of a media element that has no src
4767     // attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke
4768     // the media element&#39;s resource selection algorithm.
4769     if (m_networkState == NETWORK_EMPTY) {
4770         m_nextChildNodeToConsider = &amp;source;
4771 #if PLATFORM(IOS_FAMILY)
4772         if (m_mediaSession-&gt;dataLoadingPermitted())
4773 #endif
4774             selectMediaResource();
4775         return;
4776     }
4777 
4778     if (m_currentSourceNode &amp;&amp; &amp;source == Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode)) {
4779         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted immediately after current source&quot;);
4780         m_nextChildNodeToConsider = &amp;source;
4781         return;
4782     }
4783 
4784     if (m_nextChildNodeToConsider)
4785         return;
4786 
4787     // 4.8.9.5, resource selection algorithm, source elements section:
4788     // 21. Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)
4789     // 22. Asynchronously await a stable state...
4790     // 23. Set the element&#39;s delaying-the-load-event flag back to true (this delays the load event again, in case
4791     // it hasn&#39;t been fired yet).
4792     setShouldDelayLoadEvent(true);
4793 
4794     // 24. Set the networkState back to NETWORK_LOADING.
4795     m_networkState = NETWORK_LOADING;
4796 
4797     // 25. Jump back to the find next candidate step above.
4798     m_nextChildNodeToConsider = &amp;source;
4799     scheduleNextSourceChild();
4800 }
4801 
4802 void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement&amp; source)
4803 {
<a name="76" id="anc76"></a><span class="line-modified">4804     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4805         URL url = source.getNonEmptyURLAttribute(srcAttr);
4806         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4807     }
4808 
4809     if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
4810         return;
4811 
4812     if (&amp;source == m_nextChildNodeToConsider) {
4813         m_nextChildNodeToConsider = m_currentSourceNode ? Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode) : nullptr;
4814         INFO_LOG(LOGIDENTIFIER);
4815     } else if (&amp;source == m_currentSourceNode) {
4816         // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
4817         // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
4818         // inserted in a video or audio element will have no effect.
4819         m_currentSourceNode = nullptr;
<a name="77" id="anc77"></a><span class="line-modified">4820         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);</span>
4821     }
4822 }
4823 
4824 void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)
4825 {
4826     INFO_LOG(LOGIDENTIFIER);
4827 
4828 #if ENABLE(VIDEO_TRACK)
4829     updateActiveTextTrackCues(currentMediaTime());
4830 #endif
4831 
4832     beginProcessingMediaPlayerCallback();
4833 
4834     invalidateCachedTime();
4835     bool wasSeeking = seeking();
4836 
4837     // 4.8.10.9 step 14 &amp; 15.  Needed if no ReadyState change is associated with the seek.
4838     if (m_seekRequested &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; !m_player-&gt;seeking())
4839         finishSeek();
4840 
4841     // Always call scheduleTimeupdateEvent when the media engine reports a time discontinuity,
4842     // it will only queue a &#39;timeupdate&#39; event if we haven&#39;t already posted one at the current
4843     // movie time.
4844     else
4845         scheduleTimeupdateEvent(false);
4846 
4847     MediaTime now = currentMediaTime();
4848     MediaTime dur = durationMediaTime();
4849     double playbackRate = requestedPlaybackRate();
4850 
4851     // When the current playback position reaches the end of the media resource then the user agent must follow these steps:
4852     if (dur &amp;&amp; dur.isValid() &amp;&amp; !dur.isPositiveInfinite() &amp;&amp; !dur.isNegativeInfinite()) {
4853         // If the media element has a loop attribute specified and does not have a current media controller,
4854         if (loop() &amp;&amp; !m_mediaController &amp;&amp; playbackRate &gt; 0) {
4855             m_sentEndEvent = false;
4856             // then seek to the earliest possible position of the media resource and abort these steps when the direction of
4857             // playback is forwards,
4858             if (now &gt;= dur)
4859                 seekInternal(MediaTime::zeroTime());
4860         } else if ((now &lt;= MediaTime::zeroTime() &amp;&amp; playbackRate &lt; 0) || (now &gt;= dur &amp;&amp; playbackRate &gt; 0)) {
4861             // If the media element does not have a current media controller, and the media element
4862             // has still ended playback and paused is false,
4863             if (!m_mediaController &amp;&amp; !m_paused) {
4864                 // changes paused to true and fires a simple event named pause at the media element.
4865                 m_paused = true;
4866                 scheduleEvent(eventNames().pauseEvent);
4867                 m_mediaSession-&gt;clientWillPausePlayback();
4868             }
4869             // Queue a task to fire a simple event named ended at the media element.
4870             if (!m_sentEndEvent) {
4871                 m_sentEndEvent = true;
4872                 scheduleEvent(eventNames().endedEvent);
4873                 if (!wasSeeking)
4874                     addBehaviorRestrictionsOnEndIfNecessary();
4875                 setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
4876             }
4877             setPlaying(false);
4878             // If the media element has a current media controller, then report the controller state
4879             // for the media element&#39;s current media controller.
4880             updateMediaController();
4881         } else
4882             m_sentEndEvent = false;
4883     } else {
4884 #if ENABLE(MEDIA_STREAM)
4885         if (m_mediaStreamSrcObject) {
4886             // http://w3c.github.io/mediacapture-main/#event-mediastream-inactive
4887             // 6. MediaStreams in Media Elements
4888             // When the MediaStream state moves from the active to the inactive state, the User Agent
4889             // must raise an ended event on the HTMLMediaElement and set its ended attribute to true.
4890             // Note that once ended equals true the HTMLMediaElement will not play media even if new
4891             // MediaStreamTrack&#39;s are added to the MediaStream (causing it to return to the active
4892             // state) unless autoplay is true or the web application restarts the element, e.g.,
4893             // by calling play()
4894             if (!m_sentEndEvent &amp;&amp; m_player &amp;&amp; m_player-&gt;ended()) {
4895                 m_sentEndEvent = true;
4896                 scheduleEvent(eventNames().endedEvent);
4897                 if (!wasSeeking)
4898                     addBehaviorRestrictionsOnEndIfNecessary();
4899                 m_paused = true;
4900                 setPlaying(false);
4901             }
4902         } else
4903 #endif
4904         m_sentEndEvent = false;
4905     }
4906 
4907     scheduleUpdatePlayState();
4908     endProcessingMediaPlayerCallback();
4909 }
4910 
4911 void HTMLMediaElement::addBehaviorRestrictionsOnEndIfNecessary()
4912 {
4913     if (isFullscreen())
4914         return;
4915 
4916     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
4917     m_playbackControlsManagerBehaviorRestrictionsTimer.stop();
4918     m_playbackControlsManagerBehaviorRestrictionsTimer.startOneShot(hideMediaControlsAfterEndedDelay);
4919 }
4920 
4921 void HTMLMediaElement::handleSeekToPlaybackPosition(double position)
4922 {
4923 #if PLATFORM(MAC)
4924     // FIXME: This should ideally use faskSeek, but this causes MediaRemote&#39;s playhead to flicker upon release.
4925     // Please see &lt;rdar://problem/28457219&gt; for more details.
4926     seek(MediaTime::createWithDouble(position));
4927     m_seekToPlaybackPositionEndedTimer.stop();
4928     m_seekToPlaybackPositionEndedTimer.startOneShot(500_ms);
4929 
4930     if (!m_isScrubbingRemotely) {
4931         m_isScrubbingRemotely = true;
4932         if (!paused())
4933             pauseInternal();
4934     }
4935 #else
4936     fastSeek(position);
4937 #endif
4938 }
4939 
4940 void HTMLMediaElement::seekToPlaybackPositionEndedTimerFired()
4941 {
4942 #if PLATFORM(MAC)
4943     if (!m_isScrubbingRemotely)
4944         return;
4945 
4946     PlatformMediaSessionManager::sharedManager().sessionDidEndRemoteScrubbing(*m_mediaSession);
4947     m_isScrubbingRemotely = false;
4948     m_seekToPlaybackPositionEndedTimer.stop();
4949 #endif
4950 }
4951 
4952 void HTMLMediaElement::mediaPlayerVolumeChanged(MediaPlayer*)
4953 {
4954     INFO_LOG(LOGIDENTIFIER);
4955 
4956     beginProcessingMediaPlayerCallback();
4957     if (m_player) {
4958         double vol = m_player-&gt;volume();
4959         if (vol != m_volume) {
4960             m_volume = vol;
4961             updateVolume();
4962             scheduleEvent(eventNames().volumechangeEvent);
4963         }
4964     }
4965     endProcessingMediaPlayerCallback();
4966 }
4967 
4968 void HTMLMediaElement::mediaPlayerMuteChanged(MediaPlayer*)
4969 {
4970     INFO_LOG(LOGIDENTIFIER);
4971 
4972     beginProcessingMediaPlayerCallback();
4973     if (m_player)
4974         setMuted(m_player-&gt;muted());
4975     endProcessingMediaPlayerCallback();
4976 }
4977 
4978 void HTMLMediaElement::mediaPlayerDurationChanged(MediaPlayer* player)
4979 {
4980     INFO_LOG(LOGIDENTIFIER);
4981 
4982     beginProcessingMediaPlayerCallback();
4983 
4984     scheduleEvent(eventNames().durationchangeEvent);
4985     mediaPlayerCharacteristicChanged(player);
4986 
4987     MediaTime now = currentMediaTime();
4988     MediaTime dur = durationMediaTime();
4989     if (now &gt; dur)
4990         seekInternal(dur);
4991 
4992     endProcessingMediaPlayerCallback();
4993 }
4994 
4995 void HTMLMediaElement::mediaPlayerRateChanged(MediaPlayer*)
4996 {
4997     beginProcessingMediaPlayerCallback();
4998 
4999     // Stash the rate in case the one we tried to set isn&#39;t what the engine is
5000     // using (eg. it can&#39;t handle the rate we set)
5001     m_reportedPlaybackRate = m_player-&gt;rate();
5002 
5003     INFO_LOG(LOGIDENTIFIER, &quot;rate: &quot;, m_reportedPlaybackRate);
5004 
5005     if (m_playing)
5006         invalidateCachedTime();
5007 
5008     updateSleepDisabling();
5009 
5010     endProcessingMediaPlayerCallback();
5011 }
5012 
5013 void HTMLMediaElement::mediaPlayerPlaybackStateChanged(MediaPlayer*)
5014 {
5015     INFO_LOG(LOGIDENTIFIER);
5016 
5017     if (!m_player || m_pausedInternal)
5018         return;
5019 
5020     beginProcessingMediaPlayerCallback();
5021     if (m_player-&gt;paused())
5022         pauseInternal();
5023     else
5024         playInternal();
5025 
5026     updateSleepDisabling();
5027 
5028     endProcessingMediaPlayerCallback();
5029 }
5030 
5031 void HTMLMediaElement::mediaPlayerSawUnsupportedTracks(MediaPlayer*)
5032 {
5033     INFO_LOG(LOGIDENTIFIER);
5034 
5035     // The MediaPlayer came across content it cannot completely handle.
5036     // This is normally acceptable except when we are in a standalone
5037     // MediaDocument. If so, tell the document what has happened.
5038     if (is&lt;MediaDocument&gt;(document()))
5039         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();
5040 }
5041 
5042 void HTMLMediaElement::mediaPlayerResourceNotSupported(MediaPlayer*)
5043 {
5044     INFO_LOG(LOGIDENTIFIER);
5045 
5046     // The MediaPlayer came across content which no installed engine supports.
5047     mediaLoadingFailed(MediaPlayer::FormatError);
5048 }
5049 
5050 // MediaPlayerPresentation methods
5051 void HTMLMediaElement::mediaPlayerRepaint(MediaPlayer*)
5052 {
5053     beginProcessingMediaPlayerCallback();
5054     updateDisplayState();
5055     if (auto* renderer = this-&gt;renderer())
5056         renderer-&gt;repaint();
5057     endProcessingMediaPlayerCallback();
5058 }
5059 
5060 void HTMLMediaElement::mediaPlayerSizeChanged(MediaPlayer*)
5061 {
5062     INFO_LOG(LOGIDENTIFIER);
5063 
5064     if (is&lt;MediaDocument&gt;(document()) &amp;&amp; m_player)
5065         downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
5066 
5067     beginProcessingMediaPlayerCallback();
5068     if (m_readyState &gt; HAVE_NOTHING)
5069         scheduleResizeEventIfSizeChanged();
5070     updateRenderer();
5071     endProcessingMediaPlayerCallback();
5072 }
5073 
5074 bool HTMLMediaElement::mediaPlayerRenderingCanBeAccelerated(MediaPlayer*)
5075 {
5076     auto* renderer = this-&gt;renderer();
5077     return is&lt;RenderVideo&gt;(renderer)
5078         &amp;&amp; downcast&lt;RenderVideo&gt;(*renderer).view().compositor().canAccelerateVideoRendering(downcast&lt;RenderVideo&gt;(*renderer));
5079 }
5080 
5081 void HTMLMediaElement::mediaPlayerRenderingModeChanged(MediaPlayer*)
5082 {
5083     INFO_LOG(LOGIDENTIFIER);
5084 
5085     // Kick off a fake recalcStyle that will update the compositing tree.
5086     invalidateStyleAndLayerComposition();
5087 }
5088 
5089 bool HTMLMediaElement::mediaPlayerAcceleratedCompositingEnabled()
5090 {
5091     return document().settings().acceleratedCompositingEnabled();
5092 }
5093 
5094 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
5095 
5096 GraphicsDeviceAdapter* HTMLMediaElement::mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const
5097 {
5098     auto* page = document().page();
5099     if (!page)
5100         return nullptr;
5101     return page-&gt;chrome().client().graphicsDeviceAdapter();
5102 }
5103 
5104 #endif
5105 
5106 void HTMLMediaElement::scheduleMediaEngineWasUpdated()
5107 {
5108     if (m_mediaEngineUpdatedTask.hasPendingTask())
5109         return;
5110 
5111     auto logSiteIdentifier = LOGIDENTIFIER;
5112     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5113     m_mediaEngineUpdatedTask.scheduleTask([this, logSiteIdentifier] {
5114         UNUSED_PARAM(logSiteIdentifier);
5115         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5116         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // mediaEngineWasUpdated calls methods that can trigger arbitrary DOM mutations.
5117         mediaEngineWasUpdated();
5118     });
5119 }
5120 
5121 void HTMLMediaElement::mediaEngineWasUpdated()
5122 {
5123     INFO_LOG(LOGIDENTIFIER);
5124     beginProcessingMediaPlayerCallback();
5125     updateRenderer();
5126     endProcessingMediaPlayerCallback();
5127 
5128     m_mediaSession-&gt;mediaEngineUpdated();
5129 
5130 #if ENABLE(WEB_AUDIO)
5131     if (m_audioSourceNode &amp;&amp; audioSourceProvider()) {
5132         m_audioSourceNode-&gt;lock();
5133         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
5134         m_audioSourceNode-&gt;unlock();
5135     }
5136 #endif
5137 
5138 #if ENABLE(ENCRYPTED_MEDIA)
5139     if (m_player &amp;&amp; m_mediaKeys)
5140         m_player-&gt;cdmInstanceAttached(m_mediaKeys-&gt;cdmInstance());
5141 #endif
5142 
5143 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
5144     if (!m_player)
5145         return;
5146     m_player-&gt;setVideoFullscreenFrame(m_videoFullscreenFrame);
5147     m_player-&gt;setVideoFullscreenGravity(m_videoFullscreenGravity);
5148     m_player-&gt;setVideoFullscreenLayer(m_videoFullscreenLayer.get());
5149 #endif
5150 
5151 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5152     scheduleUpdateMediaState();
5153 #endif
5154 }
5155 
5156 void HTMLMediaElement::mediaPlayerEngineUpdated(MediaPlayer*)
5157 {
5158     INFO_LOG(LOGIDENTIFIER);
5159 
5160 #if ENABLE(MEDIA_SOURCE)
5161     m_droppedVideoFrames = 0;
5162 #endif
5163 
5164     m_havePreparedToPlay = false;
5165 
5166     scheduleMediaEngineWasUpdated();
5167 }
5168 
5169 void HTMLMediaElement::mediaPlayerFirstVideoFrameAvailable(MediaPlayer*)
5170 {
5171     INFO_LOG(LOGIDENTIFIER, &quot;current display mode = &quot;, (int)displayMode());
5172 
5173     beginProcessingMediaPlayerCallback();
5174     if (displayMode() == PosterWaitingForVideo) {
5175         setDisplayMode(Video);
5176         mediaPlayerRenderingModeChanged(m_player.get());
5177     }
5178     endProcessingMediaPlayerCallback();
5179 }
5180 
5181 void HTMLMediaElement::mediaPlayerCharacteristicChanged(MediaPlayer*)
5182 {
5183     INFO_LOG(LOGIDENTIFIER);
5184 
5185     beginProcessingMediaPlayerCallback();
5186 
5187 #if ENABLE(VIDEO_TRACK)
5188     if (captionDisplayMode() == CaptionUserPreferences::Automatic &amp;&amp; m_subtitleTrackLanguage != m_player-&gt;languageOfPrimaryAudioTrack())
5189         markCaptionAndSubtitleTracksAsUnconfigured(AfterDelay);
5190 #endif
5191 
5192     if (potentiallyPlaying() &amp;&amp; displayMode() == PosterWaitingForVideo) {
5193         setDisplayMode(Video);
5194         mediaPlayerRenderingModeChanged(m_player.get());
5195     }
5196 
5197     if (hasMediaControls())
5198         mediaControls()-&gt;reset();
5199     updateRenderer();
5200 
5201     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
5202         pauseInternal();
5203         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
5204     }
5205 
5206 #if ENABLE(MEDIA_SESSION)
5207     document().updateIsPlayingMedia(m_elementID);
5208 #else
5209     document().updateIsPlayingMedia();
5210 #endif
5211 
5212     m_hasEverHadAudio |= hasAudio();
5213     m_hasEverHadVideo |= hasVideo();
5214 
5215     m_mediaSession-&gt;canProduceAudioChanged();
5216 
5217     updateSleepDisabling();
5218 
5219     endProcessingMediaPlayerCallback();
5220 }
5221 
5222 Ref&lt;TimeRanges&gt; HTMLMediaElement::buffered() const
5223 {
5224     if (!m_player)
5225         return TimeRanges::create();
5226 
5227 #if ENABLE(MEDIA_SOURCE)
5228     if (m_mediaSource)
5229         return TimeRanges::create(*m_mediaSource-&gt;buffered());
5230 #endif
5231 
5232     return TimeRanges::create(*m_player-&gt;buffered());
5233 }
5234 
5235 double HTMLMediaElement::maxBufferedTime() const
5236 {
5237     auto bufferedRanges = buffered();
5238     unsigned numRanges = bufferedRanges-&gt;length();
5239     if (!numRanges)
5240         return 0;
5241     return bufferedRanges.get().ranges().end(numRanges - 1).toDouble();
5242 }
5243 
5244 Ref&lt;TimeRanges&gt; HTMLMediaElement::played()
5245 {
5246     if (m_playing) {
5247         MediaTime time = currentMediaTime();
5248         if (time &gt; m_lastSeekTime)
5249             addPlayedRange(m_lastSeekTime, time);
5250     }
5251 
5252     if (!m_playedTimeRanges)
5253         m_playedTimeRanges = TimeRanges::create();
5254 
5255     return m_playedTimeRanges-&gt;copy();
5256 }
5257 
5258 Ref&lt;TimeRanges&gt; HTMLMediaElement::seekable() const
5259 {
5260 #if ENABLE(MEDIA_SOURCE)
5261     if (m_mediaSource)
5262         return m_mediaSource-&gt;seekable();
5263 #endif
5264 
5265     if (m_player)
5266         return TimeRanges::create(*m_player-&gt;seekable());
5267 
5268     return TimeRanges::create();
5269 }
5270 
5271 double HTMLMediaElement::seekableTimeRangesLastModifiedTime() const
5272 {
5273     return m_player ? m_player-&gt;seekableTimeRangesLastModifiedTime() : 0;
5274 }
5275 
5276 double HTMLMediaElement::liveUpdateInterval() const
5277 {
5278     return m_player ? m_player-&gt;liveUpdateInterval() : 0;
5279 }
5280 
5281 bool HTMLMediaElement::potentiallyPlaying() const
5282 {
5283     if (isBlockedOnMediaController())
5284         return false;
5285 
5286     if (!couldPlayIfEnoughData())
5287         return false;
5288 
5289     if (m_readyState &gt;= HAVE_FUTURE_DATA)
5290         return true;
5291 
5292     return m_readyStateMaximum &gt;= HAVE_FUTURE_DATA &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA;
5293 }
5294 
5295 bool HTMLMediaElement::couldPlayIfEnoughData() const
5296 {
5297     if (paused())
5298         return false;
5299 
5300     if (endedPlayback())
5301         return false;
5302 
5303     if (stoppedDueToErrors())
5304         return false;
5305 
5306     if (pausedForUserInteraction())
5307         return false;
5308 
5309     return true;
5310 }
5311 
5312 bool HTMLMediaElement::endedPlayback() const
5313 {
5314     MediaTime dur = durationMediaTime();
5315     if (!m_player || !dur.isValid())
5316         return false;
5317 
5318     // 4.8.10.8 Playing the media resource
5319 
5320     // A media element is said to have ended playback when the element&#39;s
5321     // readyState attribute is HAVE_METADATA or greater,
5322     if (m_readyState &lt; HAVE_METADATA)
5323         return false;
5324 
5325     // and the current playback position is the end of the media resource and the direction
5326     // of playback is forwards, Either the media element does not have a loop attribute specified,
5327     // or the media element has a current media controller.
5328     MediaTime now = currentMediaTime();
5329     if (requestedPlaybackRate() &gt; 0)
5330         return dur &gt; MediaTime::zeroTime() &amp;&amp; now &gt;= dur &amp;&amp; (!loop() || m_mediaController);
5331 
5332     // or the current playback position is the earliest possible position and the direction
5333     // of playback is backwards
5334     if (requestedPlaybackRate() &lt; 0)
5335         return now &lt;= MediaTime::zeroTime();
5336 
5337     return false;
5338 }
5339 
5340 bool HTMLMediaElement::stoppedDueToErrors() const
5341 {
5342     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; m_error) {
5343         RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
5344         if (!seekableRanges-&gt;contain(currentTime()))
5345             return true;
5346     }
5347 
5348     return false;
5349 }
5350 
5351 bool HTMLMediaElement::pausedForUserInteraction() const
5352 {
5353     if (m_mediaSession-&gt;state() == PlatformMediaSession::Interrupted)
5354         return true;
5355 
5356     return false;
5357 }
5358 
5359 MediaTime HTMLMediaElement::minTimeSeekable() const
5360 {
5361     return m_player ? m_player-&gt;minTimeSeekable() : MediaTime::zeroTime();
5362 }
5363 
5364 MediaTime HTMLMediaElement::maxTimeSeekable() const
5365 {
5366     return m_player ? m_player-&gt;maxTimeSeekable() : MediaTime::zeroTime();
5367 }
5368 
5369 void HTMLMediaElement::updateVolume()
5370 {
5371     if (!m_player)
5372         return;
5373 #if PLATFORM(IOS_FAMILY)
5374     // Only the user can change audio volume so update the cached volume and post the changed event.
5375     float volume = m_player-&gt;volume();
5376     if (m_volume != volume) {
5377         m_volume = volume;
5378         scheduleEvent(eventNames().volumechangeEvent);
5379     }
5380 #else
5381     // Avoid recursion when the player reports volume changes.
5382     if (!processingMediaPlayerCallback()) {
<a name="78" id="anc78"></a><span class="line-modified">5383         m_player-&gt;setMuted(effectiveMuted());</span>
<span class="line-modified">5384         m_player-&gt;setVolume(effectiveVolume());</span>














5385     }
5386 
5387 #if ENABLE(MEDIA_SESSION)
5388     document().updateIsPlayingMedia(m_elementID);
5389 #else
5390     document().updateIsPlayingMedia();
5391 #endif
5392 
5393     if (hasMediaControls())
5394         mediaControls()-&gt;changedVolume();
5395 #endif
5396 }
5397 
5398 void HTMLMediaElement::scheduleUpdatePlayState()
5399 {
5400     if (m_updatePlayStateTask.hasPendingTask())
5401         return;
5402 
5403     auto logSiteIdentifier = LOGIDENTIFIER;
5404     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5405     m_updatePlayStateTask.scheduleTask([this, logSiteIdentifier] {
5406         UNUSED_PARAM(logSiteIdentifier);
5407         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5408         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updatePlayState calls methods that can trigger arbitrary DOM mutations.
5409         updatePlayState();
5410     });
5411 }
5412 
5413 void HTMLMediaElement::updatePlayState()
5414 {
5415     if (!m_player)
5416         return;
5417 
5418     if (m_pausedInternal) {
5419         if (!m_player-&gt;paused())
5420             m_player-&gt;pause();
5421         refreshCachedTime();
5422         m_playbackProgressTimer.stop();
5423         if (hasMediaControls())
5424             mediaControls()-&gt;playbackStopped();
5425         return;
5426     }
5427 
5428     bool shouldBePlaying = potentiallyPlaying();
5429     bool playerPaused = m_player-&gt;paused();
5430 
5431     INFO_LOG(LOGIDENTIFIER, &quot;shouldBePlaying = &quot;, shouldBePlaying, &quot;, playerPaused = &quot;, playerPaused);
5432 
5433     if (shouldBePlaying &amp;&amp; playerPaused &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; (m_waitingToEnterFullscreen || !isFullscreen())) {
5434         if (!m_waitingToEnterFullscreen)
5435             enterFullscreen();
5436 
5437 #if PLATFORM(WATCHOS)
5438         // FIXME: Investigate doing this for all builds.
5439         return;
5440 #endif
5441     }
5442 
5443     if (shouldBePlaying) {
5444         schedulePlaybackControlsManagerUpdate();
5445 
5446         setDisplayMode(Video);
5447         invalidateCachedTime();
5448 
5449         if (playerPaused) {
5450             m_mediaSession-&gt;clientWillBeginPlayback();
5451 
<a name="79" id="anc79"></a><span class="line-modified">5452             // Set rate, muted and volume before calling play in case they were set before the media engine was set up.</span>
<span class="line-modified">5453             // The media engine should just stash the rate, muted and volume values since it isn&#39;t already playing.</span>
5454             m_player-&gt;setRate(requestedPlaybackRate());
5455             m_player-&gt;setMuted(effectiveMuted());
<a name="80" id="anc80"></a><span class="line-added">5456             m_player-&gt;setVolume(effectiveVolume());</span>
5457 
5458             if (m_firstTimePlaying) {
5459                 // Log that a media element was played.
5460                 if (auto* page = document().page())
5461                     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::playedKey(), ShouldSample::No);
5462                 m_firstTimePlaying = false;
5463             }
5464 
5465             m_player-&gt;play();
5466         }
5467 
5468         if (hasMediaControls())
5469             mediaControls()-&gt;playbackStarted();
5470 
5471         startPlaybackProgressTimer();
5472         setPlaying(true);
5473     } else {
5474         schedulePlaybackControlsManagerUpdate();
5475 
5476         if (!playerPaused)
5477             m_player-&gt;pause();
5478         refreshCachedTime();
5479 
5480         m_playbackProgressTimer.stop();
5481         setPlaying(false);
5482         MediaTime time = currentMediaTime();
5483         if (time &gt; m_lastSeekTime)
5484             addPlayedRange(m_lastSeekTime, time);
5485 
5486         if (couldPlayIfEnoughData())
5487             prepareToPlay();
5488 
5489         if (hasMediaControls())
5490             mediaControls()-&gt;playbackStopped();
5491     }
5492 
5493     updateMediaController();
5494     updateRenderer();
5495 
5496     m_hasEverHadAudio |= hasAudio();
5497     m_hasEverHadVideo |= hasVideo();
5498 }
5499 
5500 void HTMLMediaElement::setPlaying(bool playing)
5501 {
5502     if (playing &amp;&amp; m_mediaSession)
5503         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
5504 
5505     if (m_playing == playing)
5506         return;
5507 
5508     m_playing = playing;
5509 
5510     if (m_playing)
5511         scheduleNotifyAboutPlaying();
5512 
5513 #if ENABLE(MEDIA_SESSION)
5514     document().updateIsPlayingMedia(m_elementID);
5515 #else
5516     document().updateIsPlayingMedia();
5517 #endif
5518 
5519 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5520     scheduleUpdateMediaState();
5521 #endif
5522 }
5523 
5524 void HTMLMediaElement::setPausedInternal(bool b)
5525 {
5526     m_pausedInternal = b;
5527     scheduleUpdatePlayState();
5528 }
5529 
5530 void HTMLMediaElement::stopPeriodicTimers()
5531 {
5532     m_progressEventTimer.stop();
5533     m_playbackProgressTimer.stop();
5534 }
5535 
5536 void HTMLMediaElement::cancelPendingTasks()
5537 {
5538     m_configureTextTracksTask.cancelTask();
5539     m_checkPlaybackTargetCompatablityTask.cancelTask();
5540     m_updateMediaStateTask.cancelTask();
5541     m_mediaEngineUpdatedTask.cancelTask();
5542     m_updatePlayStateTask.cancelTask();
<a name="81" id="anc81"></a><span class="line-added">5543 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">5544     m_volumeRevertTaskQueue.cancelTask();</span>
<span class="line-added">5545 #endif</span>
5546 }
5547 
5548 void HTMLMediaElement::userCancelledLoad()
5549 {
5550     INFO_LOG(LOGIDENTIFIER);
5551 
5552     // FIXME: We should look to reconcile the iOS and non-iOS code (below).
5553 #if PLATFORM(IOS_FAMILY)
5554     if (m_networkState == NETWORK_EMPTY || m_readyState &gt;= HAVE_METADATA)
5555         return;
5556 #else
5557     if (m_networkState == NETWORK_EMPTY || m_completelyLoaded)
5558         return;
5559 #endif
5560 
5561     // If the media data fetching process is aborted by the user:
5562 
5563     // 1 - The user agent should cancel the fetching process.
5564     clearMediaPlayer();
5565 
5566     // 2 - Set the error attribute to a new MediaError object whose code attribute is set to MEDIA_ERR_ABORTED.
5567     m_error = MediaError::create(MediaError::MEDIA_ERR_ABORTED);
5568 
5569     // 3 - Queue a task to fire a simple event named error at the media element.
5570     scheduleEvent(eventNames().abortEvent);
5571 
5572 #if ENABLE(MEDIA_SOURCE)
5573     detachMediaSource();
5574 #endif
5575 
5576     // 4 - If the media element&#39;s readyState attribute has a value equal to HAVE_NOTHING, set the
5577     // element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a task to fire a
5578     // simple event named emptied at the element. Otherwise, set the element&#39;s networkState
5579     // attribute to the NETWORK_IDLE value.
5580     if (m_readyState == HAVE_NOTHING) {
5581         m_networkState = NETWORK_EMPTY;
5582         scheduleEvent(eventNames().emptiedEvent);
5583     }
5584     else
5585         m_networkState = NETWORK_IDLE;
5586 
5587     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
5588     setShouldDelayLoadEvent(false);
5589 
5590     // 6 - Abort the overall resource selection algorithm.
5591     m_currentSourceNode = nullptr;
5592 
5593     // Reset m_readyState since m_player is gone.
5594     m_readyState = HAVE_NOTHING;
5595     updateMediaController();
5596 
5597 #if ENABLE(VIDEO_TRACK)
5598     auto* context = scriptExecutionContext();
5599     if (!context || context-&gt;activeDOMObjectsAreStopped())
5600         return; // Document is about to be destructed. Avoid updating layout in updateActiveTextTrackCues.
5601 
5602     updateActiveTextTrackCues(MediaTime::zeroTime());
5603 #endif
5604 }
5605 
5606 void HTMLMediaElement::clearMediaPlayer()
5607 {
5608 #if ENABLE(MEDIA_STREAM)
5609     if (!m_settingMediaStreamSrcObject)
5610         m_mediaStreamSrcObject = nullptr;
5611 #endif
5612 
5613 #if ENABLE(MEDIA_SOURCE)
5614     detachMediaSource();
5615 #endif
5616 
5617     m_blob = nullptr;
5618 
5619 #if ENABLE(VIDEO_TRACK)
5620     forgetResourceSpecificTracks();
5621 #endif
5622 
5623 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5624     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
5625         m_hasPlaybackTargetAvailabilityListeners = false;
5626         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5627 
5628         // Send an availability event in case scripts want to hide the picker when the element
5629         // doesn&#39;t support playback to a target.
5630         enqueuePlaybackTargetAvailabilityChangedEvent();
5631     }
5632 
5633     if (m_isPlayingToWirelessTarget)
5634         setIsPlayingToWirelessTarget(false);
5635 #endif
5636 
5637     if (m_isWaitingUntilMediaCanStart) {
5638         m_isWaitingUntilMediaCanStart = false;
5639         document().removeMediaCanStartListener(*this);
5640     }
5641 
5642     if (m_player) {
5643         m_player-&gt;invalidate();
5644         m_player = nullptr;
5645     }
5646     schedulePlaybackControlsManagerUpdate();
5647 
5648     stopPeriodicTimers();
5649     cancelPendingTasks();
5650 
5651     m_loadState = WaitingForSource;
5652 
5653 #if ENABLE(VIDEO_TRACK)
5654     if (m_textTracks)
5655         configureTextTrackDisplay();
5656 #endif
5657 
5658     m_mediaSession-&gt;clientCharacteristicsChanged();
5659     m_mediaSession-&gt;canProduceAudioChanged();
5660 
5661     m_resourceSelectionTaskQueue.cancelAllTasks();
5662 
5663     updateSleepDisabling();
5664 }
5665 
5666 bool HTMLMediaElement::canSuspendForDocumentSuspension() const
5667 {
5668     return true;
5669 }
5670 
5671 const char* HTMLMediaElement::activeDOMObjectName() const
5672 {
5673     return &quot;HTMLMediaElement&quot;;
5674 }
5675 
5676 void HTMLMediaElement::stopWithoutDestroyingMediaPlayer()
5677 {
5678     INFO_LOG(LOGIDENTIFIER);
5679 
5680     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5681         exitFullscreen();
5682 
5683     setPreparedToReturnVideoLayerToInline(true);
5684 
5685     schedulePlaybackControlsManagerUpdate();
5686     setInActiveDocument(false);
5687 
5688     // Stop the playback without generating events
5689     setPlaying(false);
5690     setPausedInternal(true);
5691     m_mediaSession-&gt;stopSession();
5692 
5693     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
5694 
5695     userCancelledLoad();
5696 
5697     updateRenderer();
5698 
5699     stopPeriodicTimers();
5700 
5701     updateSleepDisabling();
5702 }
5703 
5704 void HTMLMediaElement::closeTaskQueues()
5705 {
5706     m_configureTextTracksTask.close();
5707     m_checkPlaybackTargetCompatablityTask.close();
5708     m_updateMediaStateTask.close();
5709     m_mediaEngineUpdatedTask.close();
5710     m_updatePlayStateTask.close();
5711     m_resumeTaskQueue.close();
5712     m_seekTaskQueue.close();
5713     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
5714     m_seekTaskQueue.close();
5715     m_resumeTaskQueue.close();
5716     m_promiseTaskQueue.close();
5717     m_pauseAfterDetachedTaskQueue.close();
5718     m_resourceSelectionTaskQueue.close();
5719     m_visibilityChangeTaskQueue.close();
5720 #if ENABLE(ENCRYPTED_MEDIA)
5721     m_encryptedMediaQueue.close();
5722 #endif
5723     m_asyncEventQueue.close();
<a name="82" id="anc82"></a><span class="line-added">5724 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">5725     m_volumeRevertTaskQueue.close();</span>
<span class="line-added">5726 #endif</span>
5727 }
5728 
5729 void HTMLMediaElement::contextDestroyed()
5730 {
5731     closeTaskQueues();
5732     m_pendingPlayPromises.clear();
5733 
5734     ActiveDOMObject::contextDestroyed();
5735 }
5736 
5737 void HTMLMediaElement::stop()
5738 {
5739     INFO_LOG(LOGIDENTIFIER);
5740 
5741     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5742     stopWithoutDestroyingMediaPlayer();
5743     closeTaskQueues();
5744 
5745     // Once an active DOM object has been stopped it can not be restarted, so we can deallocate
5746     // the media player now. Note that userCancelledLoad will already called clearMediaPlayer
5747     // if the media was not fully loaded, but we need the same cleanup if the file was completely
5748     // loaded and calling it again won&#39;t cause any problems.
5749     clearMediaPlayer();
5750 
5751     m_mediaSession-&gt;stopSession();
5752 }
5753 
5754 void HTMLMediaElement::suspend(ReasonForSuspension reason)
5755 {
5756     INFO_LOG(LOGIDENTIFIER);
5757     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5758 
5759     m_resumeTaskQueue.cancelTask();
5760 
5761     switch (reason) {
5762     case ReasonForSuspension::PageCache:
5763         stopWithoutDestroyingMediaPlayer();
5764         m_asyncEventQueue.suspend();
<a name="83" id="anc83"></a><span class="line-modified">5765         setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);</span>
5766         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5767         break;
5768     case ReasonForSuspension::PageWillBeSuspended:
5769     case ReasonForSuspension::JavaScriptDebuggerPaused:
5770     case ReasonForSuspension::WillDeferLoading:
5771         // Do nothing, we don&#39;t pause media playback in these cases.
5772         break;
5773     }
5774 }
5775 
5776 void HTMLMediaElement::resume()
5777 {
5778     INFO_LOG(LOGIDENTIFIER);
5779 
5780     setInActiveDocument(true);
5781 
5782     m_asyncEventQueue.resume();
5783 
<a name="84" id="anc84"></a>

5784     if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
5785         document().addMediaCanStartListener(*this);
5786     else
5787         setPausedInternal(false);
5788 
5789     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
<a name="85" id="anc85"></a><span class="line-added">5790     m_mediaSession-&gt;updateBufferingPolicy();</span>
5791 
5792     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
5793         // Restart the load if it was aborted in the middle by moving the document to the page cache.
5794         // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
5795         //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
5796         // This behavior is not specified but it seems like a sensible thing to do.
5797         // As it is not safe to immedately start loading now, let&#39;s schedule a load.
5798         m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
5799     }
5800 
5801     updateRenderer();
5802 }
5803 
5804 bool HTMLMediaElement::hasPendingActivity() const
5805 {
5806     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue.hasPendingEvents() || m_creatingControls;
5807 }
5808 
5809 void HTMLMediaElement::mediaVolumeDidChange()
5810 {
5811     INFO_LOG(LOGIDENTIFIER);
5812     updateVolume();
5813 }
5814 
5815 void HTMLMediaElement::visibilityStateChanged()
5816 {
5817     bool elementIsHidden = document().hidden() &amp;&amp; m_videoFullscreenMode != VideoFullscreenModePictureInPicture;
5818     if (elementIsHidden == m_elementIsHidden)
5819         return;
5820 
5821     m_elementIsHidden = elementIsHidden;
5822     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, !m_elementIsHidden);
5823 
5824     updateSleepDisabling();
5825     m_mediaSession-&gt;visibilityChanged();
5826     if (m_player)
5827         m_player-&gt;setVisible(!m_elementIsHidden);
5828 
5829     bool isPlayingAudio = isPlaying() &amp;&amp; hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
5830     if (!isPlayingAudio) {
5831         if (m_elementIsHidden) {
5832             ALWAYS_LOG(LOGIDENTIFIER, &quot;Suspending playback after going to the background&quot;);
5833             m_mediaSession-&gt;beginInterruption(PlatformMediaSession::EnteringBackground);
5834         } else {
5835             ALWAYS_LOG(LOGIDENTIFIER, &quot;Resuming playback after entering foreground&quot;);
5836             m_mediaSession-&gt;endInterruption(PlatformMediaSession::MayResumePlaying);
5837         }
5838     }
5839 }
5840 
5841 #if ENABLE(VIDEO_TRACK)
5842 bool HTMLMediaElement::requiresTextTrackRepresentation() const
5843 {
5844     return (m_videoFullscreenMode != VideoFullscreenModeNone) &amp;&amp; m_player ? m_player-&gt;requiresTextTrackRepresentation() : false;
5845 }
5846 
5847 void HTMLMediaElement::setTextTrackRepresentation(TextTrackRepresentation* representation)
5848 {
5849     if (m_player)
5850         m_player-&gt;setTextTrackRepresentation(representation);
5851 }
5852 
5853 void HTMLMediaElement::syncTextTrackBounds()
5854 {
5855     if (m_player)
5856         m_player-&gt;syncTextTrackBounds();
5857 }
5858 #endif // ENABLE(VIDEO_TRACK)
5859 
5860 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5861 void HTMLMediaElement::webkitShowPlaybackTargetPicker()
5862 {
5863     ALWAYS_LOG(LOGIDENTIFIER);
5864     if (processingUserGestureForMedia())
<a name="86" id="anc86"></a><span class="line-modified">5865         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
5866     m_mediaSession-&gt;showPlaybackTargetPicker();
5867 }
5868 
5869 void HTMLMediaElement::wirelessRoutesAvailableDidChange()
5870 {
5871     enqueuePlaybackTargetAvailabilityChangedEvent();
5872 }
5873 
5874 void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*)
5875 {
5876     setIsPlayingToWirelessTarget(m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless());
5877 }
5878 
5879 void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
5880 {
5881     m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
5882         if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
5883             return;
5884         m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
5885 
5886         ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5887         configureMediaControls();
5888         m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
5889         m_mediaSession-&gt;canProduceAudioChanged();
5890         scheduleUpdateMediaState();
5891         updateSleepDisabling();
5892 
5893         m_failedToPlayToWirelessTarget = false;
5894         scheduleCheckPlaybackTargetCompatability();
5895 
5896         dispatchEvent(Event::create(eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
5897     });
5898 }
5899 
5900 void HTMLMediaElement::dispatchEvent(Event&amp; event)
5901 {
<a name="87" id="anc87"></a><span class="line-modified">5902     DEBUG_LOG(LOGIDENTIFIER, event.type());</span>
<span class="line-added">5903 </span>
<span class="line-added">5904     if (m_removedBehaviorRestrictionsAfterFirstUserGesture &amp;&amp; event.type() == eventNames().endedEvent)</span>
<span class="line-added">5905         document().userActivatedMediaFinishedPlaying();</span>
5906 
5907     HTMLElement::dispatchEvent(event);
5908 }
5909 
<a name="88" id="anc88"></a><span class="line-modified">5910 bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
5911 {
5912     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5913         return Node::addEventListener(eventType, WTFMove(listener), options);
5914 
5915     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5916     if (!Node::addEventListener(eventType, WTFMove(listener), options))
5917         return false;
5918 
5919     if (isFirstAvailabilityChangedListener) {
5920         m_hasPlaybackTargetAvailabilityListeners = true;
5921         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
5922     }
5923 
5924     INFO_LOG(LOGIDENTIFIER, &quot;&#39;webkitplaybacktargetavailabilitychanged&#39;&quot;);
5925 
5926     enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
5927     return true;
5928 }
5929 
<a name="89" id="anc89"></a><span class="line-modified">5930 bool HTMLMediaElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
5931 {
5932     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5933         return Node::removeEventListener(eventType, listener, options);
5934 
5935     if (!Node::removeEventListener(eventType, listener, options))
5936         return false;
5937 
5938     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5939     INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
5940     if (didRemoveLastAvailabilityChangedListener) {
5941         m_hasPlaybackTargetAvailabilityListeners = false;
5942         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5943         scheduleUpdateMediaState();
5944     }
5945 
5946     return true;
5947 }
5948 
5949 void HTMLMediaElement::enqueuePlaybackTargetAvailabilityChangedEvent()
5950 {
5951     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();
5952     INFO_LOG(LOGIDENTIFIER, &quot;hasTargets = &quot;, hasTargets);
5953     auto event = WebKitPlaybackTargetAvailabilityEvent::create(eventNames().webkitplaybacktargetavailabilitychangedEvent, hasTargets);
5954     event-&gt;setTarget(this);
5955     m_asyncEventQueue.enqueueEvent(WTFMove(event));
5956     scheduleUpdateMediaState();
5957 }
5958 
5959 void HTMLMediaElement::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
5960 {
5961     ALWAYS_LOG(LOGIDENTIFIER);
5962     if (m_player)
5963         m_player-&gt;setWirelessPlaybackTarget(WTFMove(device));
5964 }
5965 
5966 void HTMLMediaElement::setShouldPlayToPlaybackTarget(bool shouldPlay)
5967 {
5968     ALWAYS_LOG(LOGIDENTIFIER, shouldPlay);
5969 
5970     if (m_player)
5971         m_player-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
5972 }
5973 
5974 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
5975 
5976 bool HTMLMediaElement::webkitCurrentPlaybackTargetIsWireless() const
5977 {
5978     INFO_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5979     return m_isPlayingToWirelessTarget;
5980 }
5981 
5982 void HTMLMediaElement::setPlayingOnSecondScreen(bool value)
5983 {
5984     if (value == m_playingOnSecondScreen)
5985         return;
5986 
5987     m_playingOnSecondScreen = value;
5988 
5989 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5990     scheduleUpdateMediaState();
5991 #endif
5992 }
5993 
5994 double HTMLMediaElement::minFastReverseRate() const
5995 {
5996     return m_player ? m_player-&gt;minFastReverseRate() : 0;
5997 }
5998 
5999 double HTMLMediaElement::maxFastForwardRate() const
6000 {
6001     return m_player ? m_player-&gt;maxFastForwardRate() : 0;
6002 }
6003 
6004 bool HTMLMediaElement::isFullscreen() const
6005 {
6006     if (m_videoFullscreenMode != VideoFullscreenModeNone)
6007         return true;
6008 
6009 #if ENABLE(FULLSCREEN_API)
<a name="90" id="anc90"></a><span class="line-modified">6010     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)</span>
6011         return true;
6012 #endif
6013 
6014     return false;
6015 }
6016 
6017 bool HTMLMediaElement::isStandardFullscreen() const
6018 {
6019 #if ENABLE(FULLSCREEN_API)
<a name="91" id="anc91"></a><span class="line-modified">6020     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)</span>
6021         return true;
6022 #endif
6023 
6024     return m_videoFullscreenMode == VideoFullscreenModeStandard;
6025 }
6026 
6027 void HTMLMediaElement::toggleStandardFullscreenState()
6028 {
6029     if (isStandardFullscreen())
6030         exitFullscreen();
6031     else
6032         enterFullscreen();
6033 }
6034 
6035 void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
6036 {
6037     INFO_LOG(LOGIDENTIFIER);
6038     ASSERT(mode != VideoFullscreenModeNone);
6039 
6040     if (m_videoFullscreenMode == mode)
6041         return;
6042 
6043     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
6044     m_waitingToEnterFullscreen = true;
6045 
6046 #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
6047     if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
<a name="92" id="anc92"></a><span class="line-modified">6048         document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::ExemptIFrameAllowFullscreenRequirement);</span>
6049         return;
6050     }
6051 #endif
6052 
6053     m_fullscreenTaskQueue.enqueueTask([this, mode] {
6054         if (document().hidden()) {
6055             ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because document is hidden&quot;);
6056             return;
6057         }
6058 
6059         fullscreenModeChanged(mode);
6060         configureMediaControls();
6061         if (hasMediaControls())
6062             mediaControls()-&gt;enteredFullscreen();
6063         if (is&lt;HTMLVideoElement&gt;(*this)) {
6064             HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
6065             if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {
6066                 document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
6067                 scheduleEvent(eventNames().webkitbeginfullscreenEvent);
6068             }
6069         }
6070     });
6071 }
6072 
6073 void HTMLMediaElement::enterFullscreen()
6074 {
6075     enterFullscreen(VideoFullscreenModeStandard);
6076 }
6077 
6078 void HTMLMediaElement::exitFullscreen()
6079 {
6080     INFO_LOG(LOGIDENTIFIER);
6081 
6082     m_waitingToEnterFullscreen = false;
6083 
6084 #if ENABLE(FULLSCREEN_API)
<a name="93" id="anc93"></a><span class="line-modified">6085     if (document().settings().fullScreenEnabled() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this) {</span>
<span class="line-modified">6086         if (document().fullscreenManager().isFullscreen())</span>
<span class="line-modified">6087             document().fullscreenManager().cancelFullscreen();</span>
6088 
6089         if (m_videoFullscreenMode == VideoFullscreenModeStandard)
6090             return;
6091     }
6092 #endif
6093 
6094     ASSERT(m_videoFullscreenMode != VideoFullscreenModeNone);
6095     VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6096     fullscreenModeChanged(VideoFullscreenModeNone);
6097 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6098     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaControlsAfterPresentationModeChange calls methods that can trigger arbitrary DOM mutations.
6099     updateMediaControlsAfterPresentationModeChange();
6100 #endif
6101     if (hasMediaControls())
6102         mediaControls()-&gt;exitedFullscreen();
6103 
6104     if (!document().page() || !is&lt;HTMLVideoElement&gt;(*this))
6105         return;
6106 
6107     if (!paused() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback()) {
6108         if (!document().settings().allowsInlineMediaPlaybackAfterFullscreen() || isVideoTooSmallForInlinePlayback())
6109             pauseInternal();
6110         else {
6111             // Allow inline playback, but set a flag so pausing and starting again (e.g. when scrubbing or looping) won&#39;t go back to fullscreen.
6112             // Also set the controls attribute so the user will be able to control playback.
6113             m_temporarilyAllowingInlinePlaybackAfterFullscreen = true;
6114             setControls(true);
6115         }
6116     }
6117 
6118 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6119     if (document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
6120         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(downcast&lt;HTMLVideoElement&gt;(*this), VideoFullscreenModeNone);
6121     else
6122 #endif
6123     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(oldVideoFullscreenMode)) {
6124         if (m_videoFullscreenStandby)
6125             document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6126         else
6127             document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6128         scheduleEvent(eventNames().webkitendfullscreenEvent);
<a name="94" id="anc94"></a>
6129     }
6130 }
6131 
6132 WEBCORE_EXPORT void HTMLMediaElement::setVideoFullscreenStandby(bool value)
6133 {
6134     ASSERT(is&lt;HTMLVideoElement&gt;(*this));
6135     if (m_videoFullscreenStandby == value)
6136         return;
6137 
6138     if (!document().page())
6139         return;
6140 
6141     if (!document().page()-&gt;chrome().client().supportsVideoFullscreenStandby())
6142         return;
6143 
6144     m_videoFullscreenStandby = value;
6145 
6146 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6147     if (m_player)
6148         m_player-&gt;videoFullscreenStandbyChanged();
6149 #endif
6150 
6151     if (m_videoFullscreenStandby || m_videoFullscreenMode != VideoFullscreenModeNone)
6152         document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6153     else
6154         document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6155 }
6156 
6157 void HTMLMediaElement::willBecomeFullscreenElement()
6158 {
6159 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6160     HTMLMediaElementEnums::VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6161 #endif
6162 
6163     fullscreenModeChanged(VideoFullscreenModeStandard);
6164 
6165 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6166     switch (oldVideoFullscreenMode) {
6167     case VideoFullscreenModeNone:
6168     case VideoFullscreenModeStandard:
6169         // Don&#39;t need to do anything if we are not in any special fullscreen mode or it&#39;s already
6170         // in standard fullscreen mode.
6171         break;
6172     case VideoFullscreenModePictureInPicture:
6173         if (is&lt;HTMLVideoElement&gt;(*this))
6174             downcast&lt;HTMLVideoElement&gt;(this)-&gt;exitToFullscreenModeWithoutAnimationIfPossible(oldVideoFullscreenMode, VideoFullscreenModeStandard);
6175         break;
6176     }
6177 #endif
6178 
6179     Element::willBecomeFullscreenElement();
6180 }
6181 
6182 void HTMLMediaElement::didBecomeFullscreenElement()
6183 {
6184     m_waitingToEnterFullscreen = false;
6185     if (hasMediaControls())
6186         mediaControls()-&gt;enteredFullscreen();
6187     scheduleUpdatePlayState();
6188 }
6189 
6190 void HTMLMediaElement::willStopBeingFullscreenElement()
6191 {
6192     if (hasMediaControls())
6193         mediaControls()-&gt;exitedFullscreen();
6194 
6195     if (fullscreenMode() == VideoFullscreenModeStandard)
6196         fullscreenModeChanged(VideoFullscreenModeNone);
6197 }
6198 
6199 PlatformLayer* HTMLMediaElement::platformLayer() const
6200 {
6201     return m_player ? m_player-&gt;platformLayer() : nullptr;
6202 }
6203 
6204 void HTMLMediaElement::setPreparedToReturnVideoLayerToInline(bool value)
6205 {
6206     m_preparedForInline = value;
6207     if (m_preparedForInline &amp;&amp; m_preparedForInlineCompletionHandler) {
6208         m_preparedForInlineCompletionHandler();
6209         m_preparedForInlineCompletionHandler = nullptr;
6210     }
6211 }
6212 
6213 void HTMLMediaElement::waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6214 {
6215     ASSERT(!m_preparedForInlineCompletionHandler);
6216     if (m_preparedForInline)  {
6217         completionHandler();
6218         return;
6219     }
6220 
6221     m_preparedForInlineCompletionHandler = WTFMove(completionHandler);
6222 }
6223 
6224 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6225 
6226 void HTMLMediaElement::willExitFullscreen()
6227 {
6228     if (m_player)
6229         m_player-&gt;updateVideoFullscreenInlineImage();
6230 }
6231 
6232 bool HTMLMediaElement::isVideoLayerInline()
6233 {
6234     return !m_videoFullscreenLayer;
6235 };
6236 
6237 void HTMLMediaElement::setVideoFullscreenLayer(PlatformLayer* platformLayer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6238 {
6239     m_videoFullscreenLayer = platformLayer;
6240     if (!m_player) {
6241         completionHandler();
6242         return;
6243     }
6244 
6245     m_player-&gt;setVideoFullscreenLayer(platformLayer, WTFMove(completionHandler));
6246     invalidateStyleAndLayerComposition();
6247 #if ENABLE(VIDEO_TRACK)
6248     updateTextTrackDisplay();
6249 #endif
6250 }
6251 
6252 void HTMLMediaElement::setVideoFullscreenFrame(FloatRect frame)
6253 {
6254     m_videoFullscreenFrame = frame;
6255     if (m_player)
6256         m_player-&gt;setVideoFullscreenFrame(frame);
6257 }
6258 
6259 void HTMLMediaElement::setVideoFullscreenGravity(MediaPlayer::VideoGravity gravity)
6260 {
6261     m_videoFullscreenGravity = gravity;
6262     if (m_player)
6263         m_player-&gt;setVideoFullscreenGravity(gravity);
6264 }
6265 
6266 #else
6267 
6268 bool HTMLMediaElement::isVideoLayerInline()
6269 {
6270     return true;
6271 };
6272 
6273 #endif
6274 
6275 bool HTMLMediaElement::hasClosedCaptions() const
6276 {
6277     if (m_player &amp;&amp; m_player-&gt;hasClosedCaptions())
6278         return true;
6279 
6280 #if ENABLE(VIDEO_TRACK)
6281     if (!m_textTracks)
6282         return false;
6283 
6284     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6285         auto&amp; track = *m_textTracks-&gt;item(i);
6286         if (track.readinessState() == TextTrack::FailedToLoad)
6287             continue;
6288         if (track.kind() == TextTrack::Kind::Captions || track.kind() == TextTrack::Kind::Subtitles)
6289             return true;
6290     }
6291 #endif
6292 
6293     return false;
6294 }
6295 
6296 bool HTMLMediaElement::closedCaptionsVisible() const
6297 {
6298     return m_closedCaptionsVisible;
6299 }
6300 
6301 #if ENABLE(VIDEO_TRACK)
6302 
6303 void HTMLMediaElement::updateTextTrackDisplay()
6304 {
6305 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6306     ensureMediaControlsShadowRoot();
6307     if (!m_mediaControlsHost)
6308         m_mediaControlsHost = MediaControlsHost::create(this);
6309     m_mediaControlsHost-&gt;updateTextTrackContainer();
6310 #else
6311     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6312         return;
6313 
6314     mediaControls()-&gt;updateTextTrackDisplay();
6315 #endif
6316 }
6317 
6318 #endif
6319 
6320 void HTMLMediaElement::setClosedCaptionsVisible(bool closedCaptionVisible)
6321 {
6322     INFO_LOG(LOGIDENTIFIER, closedCaptionVisible);
6323 
6324     m_closedCaptionsVisible = false;
6325 
6326     if (!m_player || !hasClosedCaptions())
6327         return;
6328 
6329     m_closedCaptionsVisible = closedCaptionVisible;
6330     m_player-&gt;setClosedCaptionsVisible(closedCaptionVisible);
6331 
6332 #if ENABLE(VIDEO_TRACK)
6333     markCaptionAndSubtitleTracksAsUnconfigured(Immediately);
6334     updateTextTrackDisplay();
6335 #else
6336     if (hasMediaControls())
6337         mediaControls()-&gt;changedClosedCaptionsVisibility();
6338 #endif
6339 }
6340 
6341 void HTMLMediaElement::setWebkitClosedCaptionsVisible(bool visible)
6342 {
6343     m_webkitLegacyClosedCaptionOverride = visible;
6344     setClosedCaptionsVisible(visible);
6345 }
6346 
6347 bool HTMLMediaElement::webkitClosedCaptionsVisible() const
6348 {
6349     return m_webkitLegacyClosedCaptionOverride &amp;&amp; m_closedCaptionsVisible;
6350 }
6351 
6352 
6353 bool HTMLMediaElement::webkitHasClosedCaptions() const
6354 {
6355     return hasClosedCaptions();
6356 }
6357 
6358 #if ENABLE(MEDIA_STATISTICS)
6359 unsigned HTMLMediaElement::webkitAudioDecodedByteCount() const
6360 {
6361     if (!m_player)
6362         return 0;
6363     return m_player-&gt;audioDecodedByteCount();
6364 }
6365 
6366 unsigned HTMLMediaElement::webkitVideoDecodedByteCount() const
6367 {
6368     if (!m_player)
6369         return 0;
6370     return m_player-&gt;videoDecodedByteCount();
6371 }
6372 #endif
6373 
6374 void HTMLMediaElement::mediaCanStart(Document&amp; document)
6375 {
6376     ASSERT_UNUSED(document, &amp;document == &amp;this-&gt;document());
6377     INFO_LOG(LOGIDENTIFIER, &quot;m_isWaitingUntilMediaCanStart = &quot;, m_isWaitingUntilMediaCanStart, &quot;, m_pausedInternal = &quot;, m_pausedInternal);
6378 
6379     ASSERT(m_isWaitingUntilMediaCanStart || m_pausedInternal);
6380     if (m_isWaitingUntilMediaCanStart) {
6381         m_isWaitingUntilMediaCanStart = false;
6382         selectMediaResource();
6383     }
6384     if (m_pausedInternal)
6385         setPausedInternal(false);
6386 }
6387 
6388 bool HTMLMediaElement::isURLAttribute(const Attribute&amp; attribute) const
6389 {
6390     return attribute.name() == srcAttr || HTMLElement::isURLAttribute(attribute);
6391 }
6392 
6393 void HTMLMediaElement::setShouldDelayLoadEvent(bool shouldDelay)
6394 {
6395     if (m_shouldDelayLoadEvent == shouldDelay)
6396         return;
6397 
6398     INFO_LOG(LOGIDENTIFIER, shouldDelay);
6399 
6400     m_shouldDelayLoadEvent = shouldDelay;
6401     if (shouldDelay)
6402         document().incrementLoadEventDelayCount();
6403     else
6404         document().decrementLoadEventDelayCount();
6405 }
6406 
6407 static String&amp; sharedMediaCacheDirectory()
6408 {
6409     static NeverDestroyed&lt;String&gt; sharedMediaCacheDirectory;
6410     return sharedMediaCacheDirectory;
6411 }
6412 
6413 void HTMLMediaElement::setMediaCacheDirectory(const String&amp; path)
6414 {
6415     sharedMediaCacheDirectory() = path;
6416 }
6417 
6418 const String&amp; HTMLMediaElement::mediaCacheDirectory()
6419 {
6420     return sharedMediaCacheDirectory();
6421 }
6422 
6423 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; HTMLMediaElement::originsInMediaCache(const String&amp; path)
6424 {
6425     return MediaPlayer::originsInMediaCache(path);
6426 }
6427 
6428 void HTMLMediaElement::clearMediaCache(const String&amp; path, WallTime modifiedSince)
6429 {
6430     MediaPlayer::clearMediaCache(path, modifiedSince);
6431 }
6432 
6433 void HTMLMediaElement::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
6434 {
6435     MediaPlayer::clearMediaCacheForOrigins(path, origins);
6436 }
6437 
6438 void HTMLMediaElement::resetMediaEngines()
6439 {
6440     MediaPlayer::resetMediaEngines();
6441 }
6442 
<a name="95" id="anc95"></a><span class="line-modified">6443 void HTMLMediaElement::privateBrowsingStateDidChange(PAL::SessionID sessionID)</span>
6444 {
6445     if (!m_player)
6446         return;
6447 
<a name="96" id="anc96"></a><span class="line-modified">6448     m_player-&gt;setPrivateBrowsingMode(sessionID.isEphemeral());</span>

6449 }
6450 
6451 MediaControls* HTMLMediaElement::mediaControls() const
6452 {
6453 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6454     return nullptr;
6455 #else
6456     auto root = userAgentShadowRoot();
6457     if (!root)
6458         return nullptr;
6459 
6460     return childrenOfType&lt;MediaControls&gt;(*root).first();
6461 #endif
6462 }
6463 
6464 bool HTMLMediaElement::hasMediaControls() const
6465 {
6466 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6467     return false;
6468 #else
6469 
6470     if (auto userAgent = userAgentShadowRoot()) {
6471         RefPtr&lt;Node&gt; node = childrenOfType&lt;MediaControls&gt;(*root).first();
6472         ASSERT_WITH_SECURITY_IMPLICATION(!node || node-&gt;isMediaControls());
6473         return node;
6474     }
6475 
6476     return false;
6477 #endif
6478 }
6479 
6480 bool HTMLMediaElement::createMediaControls()
6481 {
6482 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6483     ensureMediaControlsShadowRoot();
6484     return false;
6485 #else
6486     if (hasMediaControls())
6487         return true;
6488 
6489     auto mediaControls = MediaControls::create(document());
6490     if (!mediaControls)
6491         return false;
6492 
6493     mediaControls-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6494     mediaControls-&gt;reset();
6495     if (isFullscreen())
6496         mediaControls-&gt;enteredFullscreen();
6497 
6498     ensureUserAgentShadowRoot().appendChild(mediaControls);
6499 
6500     if (!controls() || !isConnected())
6501         mediaControls-&gt;hide();
6502 
6503     return true;
6504 #endif
6505 }
6506 
6507 bool HTMLMediaElement::shouldForceControlsDisplay() const
6508 {
6509     // Always create controls for autoplay video that requires user gesture due to being in low power mode.
6510     return isVideo() &amp;&amp; autoplay() &amp;&amp; m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
6511 }
6512 
6513 void HTMLMediaElement::configureMediaControls()
6514 {
6515     bool requireControls = controls();
6516 
6517     // Always create controls for video when fullscreen playback is required.
6518     if (isVideo() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback())
6519         requireControls = true;
6520 
6521     if (shouldForceControlsDisplay())
6522         requireControls = true;
6523 
6524     // Always create controls when in full screen mode.
6525     if (isFullscreen())
6526         requireControls = true;
6527 
6528 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6529     if (m_isPlayingToWirelessTarget)
6530         requireControls = true;
6531 #endif
6532 
6533 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6534     if (!requireControls || !isConnected() || !inActiveDocument())
6535         return;
6536 
6537     ensureMediaControlsShadowRoot();
6538 #else
6539     if (!requireControls || !isConnected() || !inActiveDocument()) {
6540         if (hasMediaControls())
6541             mediaControls()-&gt;hide();
6542         return;
6543     }
6544 
6545     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6546         return;
6547 
6548     mediaControls()-&gt;show();
6549 #endif
6550 }
6551 
6552 #if ENABLE(VIDEO_TRACK)
6553 void HTMLMediaElement::configureTextTrackDisplay(TextTrackVisibilityCheckType checkType)
6554 {
6555     ALWAYS_LOG(LOGIDENTIFIER);
6556     ASSERT(m_textTracks);
6557 
6558     if (m_processingPreferenceChange)
6559         return;
6560 
6561     if (document().activeDOMObjectsAreStopped())
6562         return;
6563 
6564     bool haveVisibleTextTrack = false;
6565     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6566         if (m_textTracks-&gt;item(i)-&gt;mode() == TextTrack::Mode::Showing) {
6567             haveVisibleTextTrack = true;
6568             break;
6569         }
6570     }
6571 
6572     if (checkType == CheckTextTrackVisibility &amp;&amp; m_haveVisibleTextTrack == haveVisibleTextTrack) {
6573         updateActiveTextTrackCues(currentMediaTime());
6574         return;
6575     }
6576 
6577     m_haveVisibleTextTrack = haveVisibleTextTrack;
6578     m_closedCaptionsVisible = m_haveVisibleTextTrack;
6579 
6580 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6581     if (!m_haveVisibleTextTrack)
6582         return;
6583 
6584     ensureMediaControlsShadowRoot();
6585 #else
6586     if (!m_haveVisibleTextTrack &amp;&amp; !hasMediaControls())
6587         return;
6588     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6589         return;
6590 
6591     mediaControls()-&gt;changedClosedCaptionsVisibility();
6592 
6593     updateTextTrackDisplay();
6594     updateActiveTextTrackCues(currentMediaTime());
6595 #endif
6596 }
6597 
6598 void HTMLMediaElement::captionPreferencesChanged()
6599 {
6600     if (!isVideo())
6601         return;
6602 
6603     if (hasMediaControls())
6604         mediaControls()-&gt;textTrackPreferencesChanged();
6605 
6606 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6607     if (m_mediaControlsHost)
6608         m_mediaControlsHost-&gt;updateCaptionDisplaySizes();
6609 #endif
6610 
6611     if (m_player)
6612         m_player-&gt;tracksChanged();
6613 
6614     if (!document().page())
6615         return;
6616 
6617     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6618     if (captionDisplayMode() == displayMode)
6619         return;
6620 
6621     m_captionDisplayMode = displayMode;
6622     setWebkitClosedCaptionsVisible(captionDisplayMode() == CaptionUserPreferences::AlwaysOn);
6623 }
6624 
6625 CaptionUserPreferences::CaptionDisplayMode HTMLMediaElement::captionDisplayMode()
6626 {
6627     if (!m_captionDisplayMode.hasValue()) {
6628         if (document().page())
6629             m_captionDisplayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6630         else
6631             m_captionDisplayMode = CaptionUserPreferences::Automatic;
6632     }
6633 
6634     return m_captionDisplayMode.value();
6635 }
6636 
6637 void HTMLMediaElement::markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode mode)
6638 {
6639     if (!m_textTracks)
6640         return;
6641 
6642     INFO_LOG(LOGIDENTIFIER);
6643 
6644     // Mark all tracks as not &quot;configured&quot; so that configureTextTracks()
6645     // will reconsider which tracks to display in light of new user preferences
6646     // (e.g. default tracks should not be displayed if the user has turned off
6647     // captions and non-default tracks should be displayed based on language
6648     // preferences if the user has turned captions on).
6649     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6650         auto&amp; track = *m_textTracks-&gt;item(i);
6651         auto kind = track.kind();
6652         if (kind == TextTrack::Kind::Subtitles || kind == TextTrack::Kind::Captions)
6653             track.setHasBeenConfigured(false);
6654     }
6655 
6656     m_processingPreferenceChange = true;
6657     m_configureTextTracksTask.cancelTask();
6658     if (mode == Immediately) {
6659         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // configureTextTracks calls methods that can trigger arbitrary DOM mutations.
6660         configureTextTracks();
6661     }
6662     else
6663         scheduleConfigureTextTracks();
6664 }
6665 
6666 #endif
6667 
6668 void HTMLMediaElement::createMediaPlayer()
6669 {
6670     INFO_LOG(LOGIDENTIFIER);
6671 
6672 #if ENABLE(WEB_AUDIO)
6673     if (m_audioSourceNode)
6674         m_audioSourceNode-&gt;lock();
6675 #endif
6676 
6677 #if ENABLE(MEDIA_SOURCE)
6678     detachMediaSource();
6679 #endif
6680 
6681 #if ENABLE(VIDEO_TRACK)
6682     forgetResourceSpecificTracks();
6683 #endif
6684 
6685 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6686     if (m_isPlayingToWirelessTarget)
6687         setIsPlayingToWirelessTarget(false);
6688 #endif
6689 
6690     m_player = MediaPlayer::create(*this);
<a name="97" id="anc97"></a><span class="line-modified">6691     m_player-&gt;setBufferingPolicy(m_bufferingPolicy);</span>
6692     schedulePlaybackControlsManagerUpdate();
6693 
6694 #if ENABLE(WEB_AUDIO)
6695     if (m_audioSourceNode) {
6696         // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
6697         if (audioSourceProvider())
6698             audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6699 
6700         m_audioSourceNode-&gt;unlock();
6701     }
6702 #endif
6703 
6704 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6705     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
6706         m_hasPlaybackTargetAvailabilityListeners = true;
6707         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
6708         enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
6709     }
6710 #endif
6711 
6712     updateSleepDisabling();
6713 }
6714 
6715 #if ENABLE(WEB_AUDIO)
6716 void HTMLMediaElement::setAudioSourceNode(MediaElementAudioSourceNode* sourceNode)
6717 {
6718     m_audioSourceNode = sourceNode;
6719 
6720     if (audioSourceProvider())
6721         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6722 }
6723 
6724 AudioSourceProvider* HTMLMediaElement::audioSourceProvider()
6725 {
6726     if (m_player)
6727         return m_player-&gt;audioSourceProvider();
6728 
6729     return 0;
6730 }
6731 #endif
6732 
6733 const String&amp; HTMLMediaElement::mediaGroup() const
6734 {
6735     return m_mediaGroup;
6736 }
6737 
6738 void HTMLMediaElement::setMediaGroup(const String&amp; group)
6739 {
6740     if (m_mediaGroup == group)
6741         return;
6742     m_mediaGroup = group;
6743 
6744     // When a media element is created with a mediagroup attribute, and when a media element&#39;s mediagroup
6745     // attribute is set, changed, or removed, the user agent must run the following steps:
6746     // 1. Let m [this] be the media element in question.
6747     // 2. Let m have no current media controller, if it currently has one.
6748     setController(nullptr);
6749 
6750     // 3. If m&#39;s mediagroup attribute is being removed, then abort these steps.
6751     if (group.isEmpty())
6752         return;
6753 
6754     // 4. If there is another media element whose Document is the same as m&#39;s Document (even if one or both
6755     // of these elements are not actually in the Document),
6756     HashSet&lt;HTMLMediaElement*&gt; elements = documentToElementSetMap().get(&amp;document());
6757     for (auto&amp; element : elements) {
6758         if (element == this)
6759             continue;
6760 
6761         // and which also has a mediagroup attribute, and whose mediagroup attribute has the same value as
6762         // the new value of m&#39;s mediagroup attribute,
6763         if (element-&gt;mediaGroup() == group) {
6764             //  then let controller be that media element&#39;s current media controller.
6765             setController(element-&gt;controller());
6766             return;
6767         }
6768     }
6769 
6770     // Otherwise, let controller be a newly created MediaController.
6771     setController(MediaController::create(document()));
6772 }
6773 
6774 MediaController* HTMLMediaElement::controller() const
6775 {
6776     return m_mediaController.get();
6777 }
6778 
6779 void HTMLMediaElement::setController(RefPtr&lt;MediaController&gt;&amp;&amp; controller)
6780 {
6781     if (m_mediaController)
6782         m_mediaController-&gt;removeMediaElement(*this);
6783 
6784     m_mediaController = WTFMove(controller);
6785 
6786     if (m_mediaController)
6787         m_mediaController-&gt;addMediaElement(*this);
6788 
6789     if (hasMediaControls())
6790         mediaControls()-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6791 }
6792 
6793 void HTMLMediaElement::setControllerForBindings(MediaController* controller)
6794 {
6795     // 4.8.10.11.2 Media controllers: controller attribute.
6796     // On setting, it must first remove the element&#39;s mediagroup attribute, if any,
6797     setMediaGroup({ });
6798     // and then set the current media controller to the given value.
6799     setController(controller);
6800 }
6801 
6802 void HTMLMediaElement::updateMediaController()
6803 {
6804     if (m_mediaController)
6805         m_mediaController-&gt;reportControllerState();
6806 }
6807 
6808 bool HTMLMediaElement::isBlocked() const
6809 {
6810     // A media element is a blocked media element if its readyState attribute is in the
6811     // HAVE_NOTHING state, the HAVE_METADATA state, or the HAVE_CURRENT_DATA state,
6812     if (m_readyState &lt;= HAVE_CURRENT_DATA)
6813         return true;
6814 
6815     // or if the element has paused for user interaction.
6816     return pausedForUserInteraction();
6817 }
6818 
6819 bool HTMLMediaElement::isBlockedOnMediaController() const
6820 {
6821     if (!m_mediaController)
6822         return false;
6823 
6824     // A media element is blocked on its media controller if the MediaController is a blocked
6825     // media controller,
6826     if (m_mediaController-&gt;isBlocked())
6827         return true;
6828 
6829     // or if its media controller position is either before the media resource&#39;s earliest possible
6830     // position relative to the MediaController&#39;s timeline or after the end of the media resource
6831     // relative to the MediaController&#39;s timeline.
6832     double mediaControllerPosition = m_mediaController-&gt;currentTime();
6833     if (mediaControllerPosition &lt; 0 || mediaControllerPosition &gt; duration())
6834         return true;
6835 
6836     return false;
6837 }
6838 
6839 void HTMLMediaElement::prepareMediaFragmentURI()
6840 {
6841     MediaFragmentURIParser fragmentParser(m_currentSrc);
6842     MediaTime dur = durationMediaTime();
6843 
6844     MediaTime start = fragmentParser.startTime();
6845     if (start.isValid() &amp;&amp; start &gt; MediaTime::zeroTime()) {
6846         m_fragmentStartTime = start;
6847         if (m_fragmentStartTime &gt; dur)
6848             m_fragmentStartTime = dur;
6849     } else
6850         m_fragmentStartTime = MediaTime::invalidTime();
6851 
6852     MediaTime end = fragmentParser.endTime();
6853     if (end.isValid() &amp;&amp; end &gt; MediaTime::zeroTime() &amp;&amp; (!m_fragmentStartTime.isValid() || end &gt; m_fragmentStartTime)) {
6854         m_fragmentEndTime = end;
6855         if (m_fragmentEndTime &gt; dur)
6856             m_fragmentEndTime = dur;
6857     } else
6858         m_fragmentEndTime = MediaTime::invalidTime();
6859 
6860     if (m_fragmentStartTime.isValid() &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
6861         prepareToPlay();
6862 }
6863 
6864 void HTMLMediaElement::applyMediaFragmentURI()
6865 {
6866     if (m_fragmentStartTime.isValid()) {
6867         m_sentEndEvent = false;
6868         seek(m_fragmentStartTime);
6869     }
6870 }
6871 
6872 void HTMLMediaElement::updateSleepDisabling()
6873 {
6874     SleepType shouldDisableSleep = this-&gt;shouldDisableSleep();
6875     if (shouldDisableSleep == SleepType::None &amp;&amp; m_sleepDisabler)
6876         m_sleepDisabler = nullptr;
6877     else if (shouldDisableSleep != SleepType::None) {
6878         auto type = shouldDisableSleep == SleepType::Display ? PAL::SleepDisabler::Type::Display : PAL::SleepDisabler::Type::System;
6879         if (!m_sleepDisabler || m_sleepDisabler-&gt;type() != type)
6880             m_sleepDisabler = PAL::SleepDisabler::create(&quot;com.apple.WebCore: HTMLMediaElement playback&quot;, type);
6881     }
6882 
6883     if (m_player)
6884         m_player-&gt;setShouldDisableSleep(shouldDisableSleep == SleepType::Display);
6885 }
6886 
6887 #if ENABLE(MEDIA_STREAM)
6888 static inline bool isRemoteMediaStreamVideoTrack(RefPtr&lt;MediaStreamTrack&gt;&amp; item)
6889 {
6890     auto* track = item.get();
6891     return track-&gt;privateTrack().type() == RealtimeMediaSource::Type::Video &amp;&amp; !track-&gt;isCaptureTrack() &amp;&amp; !track-&gt;isCanvas();
6892 }
6893 #endif
6894 
6895 HTMLMediaElement::SleepType HTMLMediaElement::shouldDisableSleep() const
6896 {
6897 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(GTK) &amp;&amp; !PLATFORM(WPE)
6898     return SleepType::None;
6899 #endif
6900     if (!m_player || m_player-&gt;paused() || loop())
6901         return SleepType::None;
6902 
6903 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6904     // If the media is playing remotely, we can&#39;t know definitively whether it has audio or video tracks.
6905     if (m_isPlayingToWirelessTarget)
6906         return SleepType::System;
6907 #endif
6908 
<a name="98" id="anc98"></a><span class="line-modified">6909     if (PlatformMediaSessionManager::sharedManager().processIsSuspended())</span>
<span class="line-added">6910         return SleepType::None;</span>
<span class="line-added">6911 </span>
<span class="line-added">6912     bool shouldBeAbleToSleep = mediaType() != PlatformMediaSession::VideoAudio;</span>
6913 #if ENABLE(MEDIA_STREAM)
6914     // Remote media stream video tracks may have their corresponding audio tracks being played outside of the media element. Let&#39;s ensure to not IDLE the screen in that case.
6915     // FIXME: We should check that audio is being/to be played. Ideally, we would come up with a media stream agnostic heuristisc.
6916     shouldBeAbleToSleep = shouldBeAbleToSleep &amp;&amp; !(m_mediaStreamSrcObject &amp;&amp; WTF::anyOf(m_mediaStreamSrcObject-&gt;getTracks(), isRemoteMediaStreamVideoTrack));
6917 #endif
6918 
6919     if (shouldBeAbleToSleep)
6920         return SleepType::None;
6921 
6922     if (m_elementIsHidden)
6923         return SleepType::System;
6924 
6925     return SleepType::Display;
6926 }
6927 
6928 String HTMLMediaElement::mediaPlayerReferrer() const
6929 {
6930     RefPtr&lt;Frame&gt; frame = document().frame();
6931     if (!frame)
6932         return String();
6933 
6934     return SecurityPolicy::generateReferrerHeader(document().referrerPolicy(), m_currentSrc, frame-&gt;loader().outgoingReferrer());
6935 }
6936 
6937 String HTMLMediaElement::mediaPlayerUserAgent() const
6938 {
6939     RefPtr&lt;Frame&gt; frame = document().frame();
6940     if (!frame)
6941         return String();
6942 
6943     return frame-&gt;loader().userAgent(m_currentSrc);
6944 }
6945 
6946 #if ENABLE(AVF_CAPTIONS)
6947 
6948 static inline PlatformTextTrack::TrackKind toPlatform(TextTrack::Kind kind)
6949 {
6950     switch (kind) {
6951     case TextTrack::Kind::Captions:
6952         return PlatformTextTrack::Caption;
6953     case TextTrack::Kind::Chapters:
6954         return PlatformTextTrack::Chapter;
6955     case TextTrack::Kind::Descriptions:
6956         return PlatformTextTrack::Description;
6957     case TextTrack::Kind::Forced:
6958         return PlatformTextTrack::Forced;
6959     case TextTrack::Kind::Metadata:
6960         return PlatformTextTrack::MetaData;
6961     case TextTrack::Kind::Subtitles:
6962         return PlatformTextTrack::Subtitle;
6963     }
6964     ASSERT_NOT_REACHED();
6965     return PlatformTextTrack::Caption;
6966 }
6967 
6968 static inline PlatformTextTrack::TrackMode toPlatform(TextTrack::Mode mode)
6969 {
6970     switch (mode) {
6971     case TextTrack::Mode::Disabled:
6972         return PlatformTextTrack::Disabled;
6973     case TextTrack::Mode::Hidden:
6974         return PlatformTextTrack::Hidden;
6975     case TextTrack::Mode::Showing:
6976         return PlatformTextTrack::Showing;
6977     }
6978     ASSERT_NOT_REACHED();
6979     return PlatformTextTrack::Disabled;
6980 }
6981 
6982 Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; HTMLMediaElement::outOfBandTrackSources()
6983 {
6984     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources;
6985     for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
6986         URL url = trackElement.getNonEmptyURLAttribute(srcAttr);
6987         if (url.isEmpty())
6988             continue;
6989 
6990         if (!isAllowedToLoadMediaURL(*this, url, trackElement.isInUserAgentShadowTree()))
6991             continue;
6992 
6993         auto&amp; track = trackElement.track();
6994         auto kind = track.kind();
6995 
6996         // FIXME: The switch statement below preserves existing behavior where we ignore chapters and metadata tracks.
6997         // If we confirm this behavior is valuable, we should remove this comment. Otherwise, remove both comment and switch.
6998         switch (kind) {
6999         case TextTrack::Kind::Captions:
7000         case TextTrack::Kind::Descriptions:
7001         case TextTrack::Kind::Forced:
7002         case TextTrack::Kind::Subtitles:
7003             break;
7004         case TextTrack::Kind::Chapters:
7005         case TextTrack::Kind::Metadata:
7006             continue;
7007         }
7008 
7009         outOfBandTrackSources.append(PlatformTextTrack::createOutOfBand(trackElement.label(), trackElement.srclang(), url.string(), toPlatform(track.mode()), toPlatform(kind), track.uniqueId(), trackElement.isDefault()));
7010     }
7011 
7012     return outOfBandTrackSources;
7013 }
7014 
7015 #endif
7016 
7017 void HTMLMediaElement::mediaPlayerEnterFullscreen()
7018 {
7019     enterFullscreen();
7020 }
7021 
7022 void HTMLMediaElement::mediaPlayerExitFullscreen()
7023 {
7024     exitFullscreen();
7025 }
7026 
7027 bool HTMLMediaElement::mediaPlayerIsFullscreen() const
7028 {
7029     return isFullscreen();
7030 }
7031 
7032 bool HTMLMediaElement::mediaPlayerIsFullscreenPermitted() const
7033 {
7034     return m_mediaSession-&gt;fullscreenPermitted();
7035 }
7036 
7037 bool HTMLMediaElement::mediaPlayerIsVideo() const
7038 {
7039     return isVideo();
7040 }
7041 
7042 LayoutRect HTMLMediaElement::mediaPlayerContentBoxRect() const
7043 {
7044     auto* renderer = this-&gt;renderer();
7045     if (!renderer)
7046         return { };
7047     return renderer-&gt;enclosingBox().contentBoxRect();
7048 }
7049 
7050 float HTMLMediaElement::mediaPlayerContentsScale() const
7051 {
7052     if (auto page = document().page())
7053         return page-&gt;pageScaleFactor() * page-&gt;deviceScaleFactor();
7054     return 1;
7055 }
7056 
7057 void HTMLMediaElement::mediaPlayerSetSize(const IntSize&amp; size)
7058 {
7059     setIntegralAttribute(widthAttr, size.width());
7060     setIntegralAttribute(heightAttr, size.height());
7061 }
7062 
7063 void HTMLMediaElement::mediaPlayerPause()
7064 {
7065     pause();
7066 }
7067 
7068 void HTMLMediaElement::mediaPlayerPlay()
7069 {
7070     play();
7071 }
7072 
7073 bool HTMLMediaElement::mediaPlayerPlatformVolumeConfigurationRequired() const
7074 {
7075     return !m_volumeInitialized;
7076 }
7077 
7078 bool HTMLMediaElement::mediaPlayerIsPaused() const
7079 {
7080     return paused();
7081 }
7082 
7083 bool HTMLMediaElement::mediaPlayerIsLooping() const
7084 {
7085     return loop();
7086 }
7087 
7088 CachedResourceLoader* HTMLMediaElement::mediaPlayerCachedResourceLoader()
7089 {
7090     return &amp;document().cachedResourceLoader();
7091 }
7092 
7093 RefPtr&lt;PlatformMediaResourceLoader&gt; HTMLMediaElement::mediaPlayerCreateResourceLoader()
7094 {
7095     auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
7096 
7097     m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
7098 
<a name="99" id="anc99"></a><span class="line-modified">7099     return mediaResourceLoader;</span>
7100 }
7101 
7102 const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
7103 {
7104     return m_lastMediaResourceLoaderForTesting.get();
7105 }
7106 
7107 bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
7108 {
7109     if (Page* page = document().page())
7110         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabled();
7111 
7112     return false;
7113 }
7114 
7115 const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
7116 {
7117     return mediaCacheDirectory();
7118 }
7119 
7120 String HTMLMediaElement::sourceApplicationIdentifier() const
7121 {
7122     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
7123         if (NetworkingContext* networkingContext = frame-&gt;loader().networkingContext())
7124             return networkingContext-&gt;sourceApplicationIdentifier();
7125     }
7126     return emptyString();
7127 }
7128 
7129 Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
7130 {
<a name="100" id="anc100"></a>
7131     if (Page* page = document().page())
7132         return page-&gt;group().captionPreferences().preferredAudioCharacteristics();
<a name="101" id="anc101"></a>
7133     return Vector&lt;String&gt;();
7134 }
7135 
7136 #if PLATFORM(IOS_FAMILY)
7137 String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
7138 {
7139     return DeprecatedGlobalSettings::networkInterfaceName();
7140 }
7141 
7142 bool HTMLMediaElement::mediaPlayerGetRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
7143 {
7144     if (auto* page = document().page())
7145         return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
7146     return false;
7147 }
7148 #endif
7149 
7150 bool HTMLMediaElement::mediaPlayerIsInMediaDocument() const
7151 {
7152     return document().isMediaDocument();
7153 }
7154 
7155 void HTMLMediaElement::mediaPlayerEngineFailedToLoad() const
7156 {
7157     if (!m_player)
7158         return;
7159 
7160     if (auto* page = document().page())
7161         page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValue(DiagnosticLoggingKeys::engineFailedToLoadKey(), m_player-&gt;engineDescription(), m_player-&gt;platformErrorCode(), 4, ShouldSample::No);
7162 }
7163 
7164 double HTMLMediaElement::mediaPlayerRequestedPlaybackRate() const
7165 {
7166     return potentiallyPlaying() ? requestedPlaybackRate() : 0;
7167 }
7168 
7169 const Vector&lt;ContentType&gt;&amp; HTMLMediaElement::mediaContentTypesRequiringHardwareSupport() const
7170 {
7171     return document().settings().mediaContentTypesRequiringHardwareSupport();
7172 }
7173 
7174 bool HTMLMediaElement::mediaPlayerShouldCheckHardwareSupport() const
7175 {
7176     if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback())
7177         return true;
7178 
7179     if (m_loadState == LoadingFromSourceElement &amp;&amp; m_currentSourceNode &amp;&amp; !m_nextChildNodeToConsider)
7180         return false;
7181 
7182     if (m_loadState == LoadingFromSrcAttr)
7183         return false;
7184 
7185     return true;
7186 }
7187 
7188 #if USE(GSTREAMER)
7189 void HTMLMediaElement::requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback)
7190 {
7191     if (!document().page())
7192         return;
7193 
7194     document().page()-&gt;chrome().client().requestInstallMissingMediaPlugins(details, description, callback);
7195 }
7196 #endif
7197 
<a name="102" id="anc102"></a><span class="line-modified">7198 void HTMLMediaElement::removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask)</span>
7199 {
7200     MediaElementSession::BehaviorRestrictions restrictionsToRemove = mask &amp;
7201         (MediaElementSession::RequireUserGestureForLoad
7202 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7203         | MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker
7204         | MediaElementSession::RequireUserGestureToAutoplayToExternalDevice
7205 #endif
7206         | MediaElementSession::RequireUserGestureForVideoRateChange
7207         | MediaElementSession::RequireUserGestureForAudioRateChange
7208         | MediaElementSession::RequireUserGestureForFullscreen
7209         | MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode
7210         | MediaElementSession::InvisibleAutoplayNotPermitted
7211         | MediaElementSession::RequireUserGestureToControlControlsManager);
7212 
<a name="103" id="anc103"></a><span class="line-added">7213     m_removedBehaviorRestrictionsAfterFirstUserGesture = true;</span>
<span class="line-added">7214 </span>
7215     m_mediaSession-&gt;removeBehaviorRestriction(restrictionsToRemove);
7216     document().topDocument().noteUserInteractionWithMediaElement();
7217 }
7218 
7219 void HTMLMediaElement::updateRateChangeRestrictions()
7220 {
7221     const auto&amp; document = this-&gt;document();
7222     if (!document.ownerElement() &amp;&amp; document.isMediaDocument())
7223         return;
7224 
7225     const auto&amp; topDocument = document.topDocument();
7226     if (topDocument.videoPlaybackRequiresUserGesture())
7227         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7228     else
7229         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7230 
7231     if (topDocument.audioPlaybackRequiresUserGesture())
7232         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7233     else
7234         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7235 }
7236 
7237 RefPtr&lt;VideoPlaybackQuality&gt; HTMLMediaElement::getVideoPlaybackQuality()
7238 {
7239     RefPtr&lt;DOMWindow&gt; domWindow = document().domWindow();
7240     double timestamp = domWindow ? 1000 * domWindow-&gt;nowTimestamp() : 0;
7241 
7242     auto metrics = m_player ? m_player-&gt;videoPlaybackQualityMetrics() : WTF::nullopt;
7243     if (!metrics)
7244         return VideoPlaybackQuality::create(timestamp, { });
7245 
7246 #if ENABLE(MEDIA_SOURCE)
7247     metrics.value().totalVideoFrames += m_droppedVideoFrames;
7248     metrics.value().droppedVideoFrames += m_droppedVideoFrames;
7249 #endif
7250 
7251     return VideoPlaybackQuality::create(timestamp, metrics.value());
7252 }
7253 
7254 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
7255 DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
7256 {
7257     if (!m_isolatedWorld)
7258         m_isolatedWorld = DOMWrapperWorld::create(commonVM());
7259     return *m_isolatedWorld;
7260 }
7261 
7262 bool HTMLMediaElement::ensureMediaControlsInjectedScript()
7263 {
<a name="104" id="anc104"></a><span class="line-modified">7264     INFO_LOG(LOGIDENTIFIER);</span>
7265 
7266     Page* page = document().page();
7267     if (!page)
7268         return false;
7269 
7270     String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
7271     if (!mediaControlsScript.length())
7272         return false;
7273 
7274     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {
7275         auto&amp; vm = globalObject.vm();
7276         auto scope = DECLARE_CATCH_SCOPE(vm);
7277 
<a name="105" id="anc105"></a><span class="line-modified">7278         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7279         if (functionValue.isFunction(vm))
7280             return true;
7281 
7282 #ifndef NDEBUG
7283         // Setting a scriptURL allows the source to be debuggable in the inspector.
7284         URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
7285 #else
7286         URL scriptURL;
7287 #endif
7288         scriptController.evaluateInWorld(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);
7289         if (UNLIKELY(scope.exception())) {
7290             scope.clearException();
7291             return false;
7292         }
7293 
7294         return true;
7295     });
7296 }
7297 
7298 void HTMLMediaElement::updatePageScaleFactorJSProperty()
7299 {
7300     Page* page = document().page();
7301     if (!page)
7302         return;
7303 
7304     setControllerJSProperty(&quot;pageScaleFactor&quot;, JSC::jsNumber(page-&gt;pageScaleFactor()));
7305 }
7306 
7307 void HTMLMediaElement::updateUsesLTRUserInterfaceLayoutDirectionJSProperty()
7308 {
7309     Page* page = document().page();
7310     if (!page)
7311         return;
7312 
7313     bool usesLTRUserInterfaceLayoutDirectionProperty = page-&gt;userInterfaceLayoutDirection() == UserInterfaceLayoutDirection::LTR;
7314     setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
7315 }
7316 
7317 void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
7318 {
7319     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7320         auto&amp; vm = globalObject.vm();
7321         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7322         if (controllerValue.isNull())
7323             return false;
7324 
7325         JSC::PutPropertySlot propertySlot(controllerValue);
7326         auto* controllerObject = controllerValue.toObject(&amp;exec);
7327         if (!controllerObject)
7328             return false;
7329 
<a name="106" id="anc106"></a><span class="line-modified">7330         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
7331 
7332         return true;
7333     });
7334 }
7335 
7336 void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
7337 {
<a name="107" id="anc107"></a><span class="line-modified">7338     INFO_LOG(LOGIDENTIFIER);</span>
7339 
7340     if (!ensureMediaControlsInjectedScript())
7341         return;
7342 
7343     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7344         auto&amp; vm = globalObject.vm();
7345         auto scope = DECLARE_CATCH_SCOPE(vm);
7346 
7347         // The media controls script must provide a method with the following details.
7348         // Name: createControls
7349         // Parameters:
7350         //     1. The ShadowRoot element that will hold the controls.
7351         //     2. This object (and HTMLMediaElement).
7352         //     3. The MediaControlsHost object.
7353         // Return value:
7354         //     A reference to the created media controller instance.
7355 
<a name="108" id="anc108"></a><span class="line-modified">7356         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7357         if (functionValue.isUndefinedOrNull())
7358             return false;
7359 
7360         if (!m_mediaControlsHost)
7361             m_mediaControlsHost = MediaControlsHost::create(this);
7362 
7363         auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, *this);
7364         auto mediaControlsHostJSWrapper = toJS(&amp;exec, &amp;globalObject, *m_mediaControlsHost);
7365 
7366         JSC::MarkedArgumentBuffer argList;
7367         argList.append(toJS(&amp;exec, &amp;globalObject, root));
7368         argList.append(mediaJSWrapper);
7369         argList.append(mediaControlsHostJSWrapper);
7370         ASSERT(!argList.hasOverflowed());
7371 
7372         auto* function = functionValue.toObject(&amp;exec);
7373         scope.assertNoException();
7374         JSC::CallData callData;
7375         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7376         if (callType == JSC::CallType::None)
7377             return false;
7378 
7379         auto controllerValue = JSC::call(&amp;exec, function, callType, callData, &amp;globalObject, argList);
7380         scope.clearException();
7381         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
7382         if (!controllerObject)
7383             return false;
7384 
7385         // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
7386         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);
7387         scope.assertNoException();
<a name="109" id="anc109"></a><span class="line-modified">7388         auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);</span>
7389 
7390         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));
7391 
<a name="110" id="anc110"></a><span class="line-modified">7392         mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7393 
7394         auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
7395         if (!mediaControlsHostJSWrapperObject)
7396             return false;
7397 
<a name="111" id="anc111"></a><span class="line-modified">7398         auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);</span>
7399 
7400         ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));
7401 
<a name="112" id="anc112"></a><span class="line-modified">7402         mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7403 
7404         updatePageScaleFactorJSProperty();
7405         updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7406 
7407         if (UNLIKELY(scope.exception()))
7408             scope.clearException();
7409 
7410         return true;
7411     });
7412 }
7413 
7414 void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
7415 {
<a name="113" id="anc113"></a><span class="line-modified">7416     INFO_LOG(LOGIDENTIFIER, dependsOnPageScale);</span>
7417 
7418     if (document().settings().mediaControlsScaleWithPageZoom()) {
<a name="114" id="anc114"></a><span class="line-modified">7419         INFO_LOG(LOGIDENTIFIER, &quot;forced to false by Settings value&quot;);</span>
7420         m_mediaControlsDependOnPageScaleFactor = false;
7421         return;
7422     }
7423 
7424     if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)
7425         return;
7426 
7427     m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;
7428 
7429     if (m_mediaControlsDependOnPageScaleFactor)
7430         document().registerForPageScaleFactorChangedCallbacks(*this);
7431     else
7432         document().unregisterForPageScaleFactorChangedCallbacks(*this);
7433 }
7434 
7435 void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
7436 {
7437     // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
7438     // stopped/suspended the object.
7439     if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
7440         return;
7441 
<a name="115" id="anc115"></a><span class="line-added">7442     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())</span>
<span class="line-added">7443         return;</span>
<span class="line-added">7444 </span>
7445     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7446         auto&amp; vm = globalObject.vm();
7447         auto scope = DECLARE_THROW_SCOPE(vm);
7448 
7449         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7450         auto* controllerObject = controllerValue.toObject(&amp;exec);
7451 
7452         RETURN_IF_EXCEPTION(scope, false);
7453 
<a name="116" id="anc116"></a><span class="line-modified">7454         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
7455         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7456             return false;
7457 
7458         auto* function = functionValue.toObject(&amp;exec);
7459         scope.assertNoException();
7460         JSC::CallData callData;
7461         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7462         if (callType == JSC::CallType::None)
7463             return false;
7464 
7465         JSC::MarkedArgumentBuffer argList;
7466         ASSERT(!argList.hasOverflowed());
7467         JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7468 
7469         return true;
7470     });
7471 }
7472 
7473 void HTMLMediaElement::pageScaleFactorChanged()
7474 {
7475     updatePageScaleFactorJSProperty();
7476 }
7477 
7478 void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
7479 {
7480     updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7481 }
7482 
7483 String HTMLMediaElement::getCurrentMediaControlsStatus()
7484 {
7485     ensureMediaControlsShadowRoot();
7486 
7487     String status;
7488     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7489         auto&amp; vm = globalObject.vm();
7490         auto scope = DECLARE_THROW_SCOPE(vm);
7491 
7492         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7493         auto* controllerObject = controllerValue.toObject(&amp;exec);
7494 
7495         RETURN_IF_EXCEPTION(scope, false);
7496 
<a name="117" id="anc117"></a><span class="line-modified">7497         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
7498         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7499             return false;
7500 
7501         auto* function = functionValue.toObject(&amp;exec);
7502         scope.assertNoException();
7503         JSC::CallData callData;
7504         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7505         JSC::MarkedArgumentBuffer argList;
7506         ASSERT(!argList.hasOverflowed());
7507         if (callType == JSC::CallType::None)
7508             return false;
7509 
7510         auto outputValue = JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7511 
7512         RETURN_IF_EXCEPTION(scope, false);
7513 
7514         status = outputValue.getString(&amp;exec);
7515         return true;
7516     });
7517 
7518     return status;
7519 }
7520 #endif // ENABLE(MEDIA_CONTROLS_SCRIPT)
7521 
7522 unsigned long long HTMLMediaElement::fileSize() const
7523 {
7524     if (m_player)
7525         return m_player-&gt;fileSize();
7526 
7527     return 0;
7528 }
7529 
7530 PlatformMediaSession::MediaType HTMLMediaElement::mediaType() const
7531 {
7532     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA) {
7533         if (hasVideo() &amp;&amp; hasAudio() &amp;&amp; !muted())
7534             return PlatformMediaSession::VideoAudio;
7535         return hasVideo() ? PlatformMediaSession::Video : PlatformMediaSession::Audio;
7536     }
7537 
7538     return presentationType();
7539 }
7540 
7541 PlatformMediaSession::MediaType HTMLMediaElement::presentationType() const
7542 {
7543     if (hasTagName(HTMLNames::videoTag))
7544         return muted() ? PlatformMediaSession::Video : PlatformMediaSession::VideoAudio;
7545 
7546     return PlatformMediaSession::Audio;
7547 }
7548 
7549 PlatformMediaSession::DisplayType HTMLMediaElement::displayType() const
7550 {
7551     if (m_videoFullscreenMode == VideoFullscreenModeStandard)
7552         return PlatformMediaSession::Fullscreen;
7553     if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7554         return PlatformMediaSession::Optimized;
7555     if (m_videoFullscreenMode == VideoFullscreenModeNone)
7556         return PlatformMediaSession::Normal;
7557 
7558     ASSERT_NOT_REACHED();
7559     return PlatformMediaSession::Normal;
7560 }
7561 
7562 PlatformMediaSession::CharacteristicsFlags HTMLMediaElement::characteristics() const
7563 {
7564     if (m_readyState &lt; HAVE_METADATA)
7565         return PlatformMediaSession::HasNothing;
7566 
7567     PlatformMediaSession::CharacteristicsFlags state = PlatformMediaSession::HasNothing;
7568     if (isVideo() &amp;&amp; hasVideo())
7569         state |= PlatformMediaSession::HasVideo;
7570     if (this-&gt;hasAudio())
7571         state |= PlatformMediaSession::HasAudio;
7572 
7573     return state;
7574 }
7575 
7576 bool HTMLMediaElement::canProduceAudio() const
7577 {
7578 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7579     // Because the remote target could unmute playback without notifying us, we must assume
7580     // that we may be playing audio.
7581     if (m_isPlayingToWirelessTarget)
7582         return true;
7583 #endif
7584 
7585     if (muted())
7586         return false;
7587 
7588     return m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA &amp;&amp; hasAudio();
7589 }
7590 
7591 bool HTMLMediaElement::isSuspended() const
7592 {
7593     return document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped();
7594 }
7595 
7596 #if ENABLE(MEDIA_SOURCE)
7597 size_t HTMLMediaElement::maximumSourceBufferSize(const SourceBuffer&amp; buffer) const
7598 {
7599     return m_mediaSession-&gt;maximumMediaSourceBufferSize(buffer);
7600 }
7601 #endif
7602 
7603 void HTMLMediaElement::suspendPlayback()
7604 {
7605     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7606     if (!paused())
7607         pause();
7608 }
7609 
7610 void HTMLMediaElement::resumeAutoplaying()
7611 {
7612     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7613     m_autoplaying = true;
7614 
7615     if (canTransitionFromAutoplayToPlay())
7616         play();
7617 }
7618 
7619 void HTMLMediaElement::mayResumePlayback(bool shouldResume)
7620 {
7621     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7622     if (paused() &amp;&amp; shouldResume)
7623         play();
7624 }
7625 
7626 String HTMLMediaElement::mediaSessionTitle() const
7627 {
7628     if (!document().page() || document().page()-&gt;usesEphemeralSession())
7629         return emptyString();
7630 
7631     auto title = String(attributeWithoutSynchronization(titleAttr)).stripWhiteSpace().simplifyWhiteSpace();
7632     if (!title.isEmpty())
7633         return title;
7634 
7635     title = document().title().stripWhiteSpace().simplifyWhiteSpace();
7636     if (!title.isEmpty())
7637         return title;
7638 
7639     title = m_currentSrc.host().toString();
7640 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
7641     if (!title.isEmpty())
7642         title = decodeHostName(title);
7643 #endif
<a name="118" id="anc118"></a>
7644     if (!title.isEmpty()) {
<a name="119" id="anc119"></a><span class="line-modified">7645         auto domain = RegistrableDomain { m_currentSrc };</span>
7646         if (!domain.isEmpty())
<a name="120" id="anc120"></a><span class="line-modified">7647             title = domain.string();</span>
7648     }
<a name="121" id="anc121"></a>
7649 
7650     return title;
7651 }
7652 
7653 uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
7654 {
7655     auto&amp; url = m_currentSrc.string();
7656     return url.impl() ? url.impl()-&gt;hash() : 0;
7657 }
7658 
7659 void HTMLMediaElement::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
7660 {
7661     INFO_LOG(LOGIDENTIFIER, command);
7662 
7663     UserGestureIndicator remoteControlUserGesture(ProcessingUserGesture, &amp;document());
7664     switch (command) {
7665     case PlatformMediaSession::PlayCommand:
7666         play();
7667         break;
7668     case PlatformMediaSession::StopCommand:
7669     case PlatformMediaSession::PauseCommand:
7670         pause();
7671         break;
7672     case PlatformMediaSession::TogglePlayPauseCommand:
7673         canPlay() ? play() : pause();
7674         break;
7675     case PlatformMediaSession::BeginSeekingBackwardCommand:
7676         beginScanning(Backward);
7677         break;
7678     case PlatformMediaSession::BeginSeekingForwardCommand:
7679         beginScanning(Forward);
7680         break;
7681     case PlatformMediaSession::EndSeekingBackwardCommand:
7682     case PlatformMediaSession::EndSeekingForwardCommand:
7683         endScanning();
7684         break;
7685     case PlatformMediaSession::SeekToPlaybackPositionCommand:
7686         ASSERT(argument);
7687         if (argument)
7688             handleSeekToPlaybackPosition(argument-&gt;asDouble);
7689         break;
7690     default:
7691         { } // Do nothing
7692     }
7693 }
7694 
<a name="122" id="anc122"></a>








7695 bool HTMLMediaElement::supportsSeeking() const
7696 {
<a name="123" id="anc123"></a><span class="line-modified">7697     return !document().quirks().needsSeekingSupportDisabled() &amp;&amp; !isLiveStream();</span>
7698 }
7699 
7700 bool HTMLMediaElement::shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType type) const
7701 {
7702     if (type == PlatformMediaSession::EnteringBackground) {
7703         if (isPlayingToExternalTarget()) {
7704             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7705             return true;
7706         }
<a name="124" id="anc124"></a><span class="line-added">7707         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {</span>
<span class="line-added">7708             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);</span>
<span class="line-added">7709             return true;</span>
<span class="line-added">7710         }</span>
7711         if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7712             return true;
7713 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
7714         if (((m_videoFullscreenMode == VideoFullscreenModeStandard) || m_videoFullscreenStandby) &amp;&amp; supportsPictureInPicture() &amp;&amp; isPlaying())
7715             return true;
7716 #endif
7717     } else if (type == PlatformMediaSession::SuspendedUnderLock) {
7718         if (isPlayingToExternalTarget()) {
7719             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7720             return true;
7721         }
<a name="125" id="anc125"></a><span class="line-added">7722         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {</span>
<span class="line-added">7723             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);</span>
<span class="line-added">7724             return true;</span>
<span class="line-added">7725         }</span>
7726     }
7727     return false;
7728 }
7729 
7730 bool HTMLMediaElement::processingUserGestureForMedia() const
7731 {
7732     return document().processingUserGestureForMedia();
7733 }
<a name="126" id="anc126"></a><span class="line-added">7734 </span>
<span class="line-added">7735 void HTMLMediaElement::processIsSuspendedChanged()</span>
<span class="line-added">7736 {</span>
<span class="line-added">7737     updateSleepDisabling();</span>
<span class="line-added">7738 }</span>
<span class="line-added">7739 </span>
7740 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7741 
7742 void HTMLMediaElement::scheduleUpdateMediaState()
7743 {
7744     if (m_updateMediaStateTask.hasPendingTask())
7745         return;
7746 
7747     auto logSiteIdentifier = LOGIDENTIFIER;
7748     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
7749     m_updateMediaStateTask.scheduleTask([this, logSiteIdentifier] {
7750         UNUSED_PARAM(logSiteIdentifier);
7751         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
7752         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaState calls methods that can trigger arbitrary DOM mutations.
7753         updateMediaState();
7754     });
7755 }
7756 
7757 void HTMLMediaElement::updateMediaState()
7758 {
7759     MediaProducer::MediaStateFlags state = mediaState();
7760     if (m_mediaState == state)
7761         return;
7762 
7763     m_mediaState = state;
7764     m_mediaSession-&gt;mediaStateDidChange(m_mediaState);
7765 #if ENABLE(MEDIA_SESSION)
7766     document().updateIsPlayingMedia(m_elementID);
7767 #else
7768     document().updateIsPlayingMedia();
7769 #endif
7770 }
7771 #endif
7772 
7773 MediaProducer::MediaStateFlags HTMLMediaElement::mediaState() const
7774 {
7775     MediaStateFlags state = IsNotPlaying;
7776 
7777     bool hasActiveVideo = isVideo() &amp;&amp; hasVideo();
7778     bool hasAudio = this-&gt;hasAudio();
7779     if (isPlayingToExternalTarget())
7780         state |= IsPlayingToExternalDevice;
7781 
7782 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7783     if (m_hasPlaybackTargetAvailabilityListeners) {
7784         state |= HasPlaybackTargetAvailabilityListener;
7785         if (!m_mediaSession-&gt;wirelessVideoPlaybackDisabled())
7786             state |= RequiresPlaybackTargetMonitoring;
7787     }
7788 
7789     bool requireUserGesture = m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
7790     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; !requireUserGesture &amp;&amp; !m_failedToPlayToWirelessTarget)
7791         state |= ExternalDeviceAutoPlayCandidate;
7792 
7793     if (hasActiveVideo || hasAudio)
7794         state |= HasAudioOrVideo;
7795 
7796     if (hasActiveVideo &amp;&amp; endedPlayback())
7797         state |= DidPlayToEnd;
7798 #endif
7799 
7800     if (!isPlaying())
7801         return state;
7802 
7803     if (hasAudio &amp;&amp; !muted() &amp;&amp; volume())
7804         state |= IsPlayingAudio;
7805 
7806     if (hasActiveVideo)
7807         state |= IsPlayingVideo;
7808 
7809     return state;
7810 }
7811 
7812 void HTMLMediaElement::handleAutoplayEvent(AutoplayEvent event)
7813 {
7814     if (Page* page = document().page()) {
7815         bool hasAudio = this-&gt;hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
7816         bool wasPlaybackPrevented = m_autoplayEventPlaybackState == AutoplayEventPlaybackState::PreventedAutoplay;
7817         bool hasMainContent = m_mediaSession &amp;&amp; m_mediaSession-&gt;isMainContentForPurposesOfAutoplayEvents();
7818         ALWAYS_LOG(LOGIDENTIFIER, &quot;hasAudio = &quot;, hasAudio, &quot; wasPlaybackPrevented = &quot;, wasPlaybackPrevented, &quot; hasMainContent = &quot;, hasMainContent);
7819 
7820         OptionSet&lt;AutoplayEventFlags&gt; flags;
7821         if (hasAudio)
7822             flags.add(AutoplayEventFlags::HasAudio);
7823         if (wasPlaybackPrevented)
7824             flags.add(AutoplayEventFlags::PlaybackWasPrevented);
7825         if (hasMainContent)
7826             flags.add(AutoplayEventFlags::MediaIsMainContent);
7827 
7828         page-&gt;chrome().client().handleAutoplayEvent(event, flags);
7829     }
7830 }
7831 
7832 void HTMLMediaElement::userDidInterfereWithAutoplay()
7833 {
7834     if (m_autoplayEventPlaybackState != AutoplayEventPlaybackState::StartedWithoutUserGesture)
7835         return;
7836 
7837     // Only consider interference in the first 10 seconds of automatic playback.
7838     if (currentTime() - playbackStartedTime() &gt; AutoplayInterferenceTimeThreshold)
7839         return;
7840 
7841     ALWAYS_LOG(LOGIDENTIFIER);
7842     handleAutoplayEvent(AutoplayEvent::UserDidInterfereWithPlayback);
7843     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
7844 }
7845 
7846 void HTMLMediaElement::setAutoplayEventPlaybackState(AutoplayEventPlaybackState reason)
7847 {
7848     ALWAYS_LOG(LOGIDENTIFIER, reason);
7849 
7850     m_autoplayEventPlaybackState = reason;
7851 
7852     if (reason == AutoplayEventPlaybackState::PreventedAutoplay) {
7853         dispatchPlayPauseEventsIfNeedsQuirks();
7854         handleAutoplayEvent(AutoplayEvent::DidPreventMediaFromPlaying);
7855     }
7856 }
7857 
7858 void HTMLMediaElement::pageMutedStateDidChange()
7859 {
7860     updateVolume();
7861 
7862     if (Page* page = document().page()) {
7863         if (hasAudio() &amp;&amp; !muted() &amp;&amp; page-&gt;isAudioMuted())
7864             userDidInterfereWithAutoplay();
7865     }
7866 }
7867 
<a name="127" id="anc127"></a><span class="line-added">7868 double HTMLMediaElement::effectiveVolume() const</span>
<span class="line-added">7869 {</span>
<span class="line-added">7870     auto* page = document().page();</span>
<span class="line-added">7871     double volumeMultiplier = page ? page-&gt;mediaVolume() : 1;</span>
<span class="line-added">7872     if (m_mediaController)</span>
<span class="line-added">7873         volumeMultiplier *= m_mediaController-&gt;volume();</span>
<span class="line-added">7874 #if ENABLE(MEDIA_SESSION)</span>
<span class="line-added">7875     if (m_shouldDuck)</span>
<span class="line-added">7876         volumeMultiplier *= 0.25;</span>
<span class="line-added">7877 #endif</span>
<span class="line-added">7878 </span>
<span class="line-added">7879     return m_volume * volumeMultiplier;</span>
<span class="line-added">7880 }</span>
<span class="line-added">7881 </span>
7882 bool HTMLMediaElement::effectiveMuted() const
7883 {
<a name="128" id="anc128"></a><span class="line-modified">7884     return muted() || (m_mediaController &amp;&amp; m_mediaController-&gt;muted()) || (document().page() &amp;&amp; document().page()-&gt;isAudioMuted());</span>
7885 }
7886 
<a name="129" id="anc129"></a><span class="line-modified">7887 bool HTMLMediaElement::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const</span>
7888 {
7889     QualifiedName attributeName(nullAtom(), attribute, nullAtom());
7890 
7891     auto&amp; elementValue = attributeWithoutSynchronization(attributeName);
7892     if (elementValue.isNull())
7893         return false;
7894 
7895     if (attributeName == HTMLNames::x_itunes_inherit_uri_query_componentAttr &amp;&amp; !document().settings().enableInheritURIQueryComponent())
7896         return false;
7897 
7898     if (value)
7899         *value = elementValue;
7900 
7901     return true;
7902 }
7903 
<a name="130" id="anc130"></a><span class="line-modified">7904 void HTMLMediaElement::setBufferingPolicy(BufferingPolicy policy)</span>
7905 {
<a name="131" id="anc131"></a><span class="line-modified">7906     if (policy == m_bufferingPolicy)</span>
7907         return;
7908 
<a name="132" id="anc132"></a><span class="line-modified">7909     INFO_LOG(LOGIDENTIFIER, policy);</span>
<span class="line-added">7910 </span>
<span class="line-added">7911     m_bufferingPolicy = policy;</span>
7912     if (m_player)
<a name="133" id="anc133"></a><span class="line-modified">7913         m_player-&gt;setBufferingPolicy(policy);</span>
7914 }
7915 
7916 void HTMLMediaElement::purgeBufferedDataIfPossible()
7917 {
<a name="134" id="anc134"></a><span class="line-modified">7918     INFO_LOG(LOGIDENTIFIER);</span>
<span class="line-modified">7919 </span>
<span class="line-added">7920     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;preferredBufferingPolicy() == BufferingPolicy::Default)</span>
7921         return;
7922 
7923     if (isPlayingToExternalTarget()) {
7924         INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
7925         return;
7926     }
7927 
<a name="135" id="anc135"></a><span class="line-modified">7928     setBufferingPolicy(BufferingPolicy::PurgeResources);</span>






7929 }
7930 
7931 bool HTMLMediaElement::canSaveMediaData() const
7932 {
7933     if (m_player)
7934         return m_player-&gt;canSaveMediaData();
7935 
7936     return false;
7937 }
7938 
7939 #if ENABLE(MEDIA_SESSION)
7940 double HTMLMediaElement::playerVolume() const
7941 {
7942     return m_player ? m_player-&gt;volume() : 0;
7943 }
7944 
7945 MediaSession* HTMLMediaElement::session() const
7946 {
7947     RefPtr&lt;MediaSession&gt; session = m_session.get();
7948     if (session &amp;&amp; session == &amp;document().defaultMediaSession())
7949         return nullptr;
7950 
7951     return session.get();
7952 }
7953 
7954 void HTMLMediaElement::setSession(MediaSession* session)
7955 {
7956     // 6.1. Extensions to the HTMLMediaElement interface
7957     // 1. Let m be the media element in question.
7958     // 2. Let old media session be m’s current media session, if it has one, and null otherwise.
7959     // 3. Let m’s current media session be the new value or the top-level browsing context’s media session if the new value is null.
7960     // 4. Let new media session be m’s current media session.
7961 
7962     // 5. Update media sessions: If old media session and new media session are the same (whether both null or both the same media session), then terminate these steps.
7963     if (m_session.get() == session)
7964         return;
7965 
7966     if (m_session) {
7967         // 6. If m is an audio-producing participant of old media session, then pause m and remove m from old media session’s list of audio-producing participants.
7968         if (m_session-&gt;isMediaElementActive(*this))
7969             pause();
7970 
7971         m_session-&gt;removeMediaElement(*this);
7972 
7973         // 7. If old media session is not null and no longer has one or more audio-producing participants, then run the media session deactivation algorithm for old media session.
7974         if (!m_session-&gt;hasActiveMediaElements())
7975             m_session-&gt;deactivate();
7976     }
7977 
7978     if (session)
7979         setSessionInternal(*session);
7980     else
7981         setSessionInternal(document().defaultMediaSession());
7982 }
7983 
7984 void HTMLMediaElement::setSessionInternal(MediaSession&amp; session)
7985 {
7986     m_session = &amp;session;
7987     session.addMediaElement(*this);
7988     m_kind = session.kind();
7989 }
7990 
7991 void HTMLMediaElement::setShouldDuck(bool duck)
7992 {
7993     if (m_shouldDuck == duck)
7994         return;
7995 
7996     m_shouldDuck = duck;
7997     updateVolume();
7998 }
7999 
8000 #endif
8001 
8002 void HTMLMediaElement::allowsMediaDocumentInlinePlaybackChanged()
8003 {
8004     if (potentiallyPlaying() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; !isFullscreen())
8005         enterFullscreen();
8006 }
8007 
8008 bool HTMLMediaElement::isVideoTooSmallForInlinePlayback()
8009 {
8010     auto* renderer = this-&gt;renderer();
8011 
8012     if (!renderer || !is&lt;RenderVideo&gt;(*renderer))
8013         return true;
8014 
8015     IntRect videoBox = downcast&lt;RenderVideo&gt;(*renderer).videoBox();
8016     return (videoBox.width() &lt;= 1 || videoBox.height() &lt;= 1);
8017 }
8018 
8019 void HTMLMediaElement::isVisibleInViewportChanged()
8020 {
8021     m_visibilityChangeTaskQueue.enqueueTask([this] {
8022         m_mediaSession-&gt;isVisibleInViewportChanged();
8023         updateShouldAutoplay();
8024         schedulePlaybackControlsManagerUpdate();
8025     });
8026 }
8027 
8028 void HTMLMediaElement::updateShouldAutoplay()
8029 {
8030     if (!autoplay())
8031         return;
8032 
8033     if (!m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
8034         return;
8035 
8036     bool canAutoplay = mediaSession().autoplayPermitted();
8037     if (canAutoplay
8038         &amp;&amp; m_mediaSession-&gt;state() == PlatformMediaSession::Interrupted
8039         &amp;&amp; m_mediaSession-&gt;interruptionType() == PlatformMediaSession::InvisibleAutoplay)
8040         m_mediaSession-&gt;endInterruption(PlatformMediaSession::MayResumePlaying);
8041     else if (!canAutoplay
8042         &amp;&amp; m_mediaSession-&gt;state() != PlatformMediaSession::Interrupted)
8043         m_mediaSession-&gt;beginInterruption(PlatformMediaSession::InvisibleAutoplay);
8044 }
8045 
8046 void HTMLMediaElement::updateShouldPlay()
8047 {
8048     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
8049         pauseInternal();
8050         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
8051     } else if (canTransitionFromAutoplayToPlay())
8052         play();
8053 }
8054 
8055 void HTMLMediaElement::resetPlaybackSessionState()
8056 {
8057     if (m_mediaSession)
8058         m_mediaSession-&gt;resetPlaybackSessionState();
8059 }
8060 
8061 bool HTMLMediaElement::isVisibleInViewport() const
8062 {
8063     auto renderer = this-&gt;renderer();
8064     return renderer &amp;&amp; renderer-&gt;visibleInViewportState() == VisibleInViewportState::Yes;
8065 }
8066 
8067 void HTMLMediaElement::schedulePlaybackControlsManagerUpdate()
8068 {
8069     Page* page = document().page();
8070     if (!page)
8071         return;
8072     page-&gt;schedulePlaybackControlsManagerUpdate();
8073 }
8074 
8075 void HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired()
8076 {
8077     if (m_playbackControlsManagerBehaviorRestrictionsQueue.hasPendingTask())
8078         return;
8079 
8080     if (!m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager))
8081         return;
8082 
8083     RefPtr&lt;HTMLMediaElement&gt; protectedThis(this);
8084     m_playbackControlsManagerBehaviorRestrictionsQueue.scheduleTask([protectedThis] () {
8085         MediaElementSession* mediaElementSession = protectedThis-&gt;m_mediaSession.get();
8086         if (protectedThis-&gt;isPlaying() || mediaElementSession-&gt;state() == PlatformMediaSession::Autoplaying || mediaElementSession-&gt;state() == PlatformMediaSession::Playing)
8087             return;
8088 
8089         mediaElementSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
8090         protectedThis-&gt;schedulePlaybackControlsManagerUpdate();
8091     });
8092 }
8093 
8094 bool HTMLMediaElement::shouldOverrideBackgroundLoadingRestriction() const
8095 {
8096     if (isPlayingToExternalTarget())
8097         return true;
8098 
8099     return m_videoFullscreenMode == VideoFullscreenModePictureInPicture;
8100 }
8101 
8102 void HTMLMediaElement::fullscreenModeChanged(VideoFullscreenMode mode)
8103 {
8104     if (m_videoFullscreenMode == mode)
8105         return;
8106 
8107     m_videoFullscreenMode = mode;
8108     visibilityStateChanged();
8109     schedulePlaybackControlsManagerUpdate();
8110 }
8111 
8112 #if !RELEASE_LOG_DISABLED
8113 WTFLogChannel&amp; HTMLMediaElement::logChannel() const
8114 {
8115     return LogMedia;
8116 }
8117 #endif
8118 
8119 bool HTMLMediaElement::willLog(WTFLogLevel level) const
8120 {
8121 #if !RELEASE_LOG_DISABLED
8122     return m_logger-&gt;willLog(logChannel(), level);
8123 #else
8124     UNUSED_PARAM(level);
8125     return false;
8126 #endif
8127 }
8128 
8129 void HTMLMediaElement::applicationWillResignActive()
8130 {
8131     if (m_player)
8132         m_player-&gt;applicationWillResignActive();
8133 }
8134 
8135 void HTMLMediaElement::applicationDidBecomeActive()
8136 {
8137     if (m_player)
8138         m_player-&gt;applicationDidBecomeActive();
8139 }
8140 
8141 void HTMLMediaElement::setInActiveDocument(bool inActiveDocument)
8142 {
8143     if (inActiveDocument == m_inActiveDocument)
8144         return;
8145 
8146     m_inActiveDocument = inActiveDocument;
8147     m_mediaSession-&gt;inActiveDocumentChanged();
8148 }
8149 
<a name="136" id="anc136"></a><span class="line-added">8150 HTMLMediaElementEnums::BufferingPolicy HTMLMediaElement::bufferingPolicy() const</span>
<span class="line-added">8151 {</span>
<span class="line-added">8152     return m_bufferingPolicy;</span>
<span class="line-added">8153 }</span>
<span class="line-added">8154 </span>
<span class="line-added">8155 bool HTMLMediaElement::hasMediaStreamSource() const</span>
<span class="line-added">8156 {</span>
<span class="line-added">8157 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">8158     return hasMediaStreamSrcObject();</span>
<span class="line-added">8159 #else</span>
<span class="line-added">8160     return false;</span>
<span class="line-added">8161 #endif</span>
<span class="line-added">8162 }</span>
<span class="line-added">8163 </span>
8164 }
8165 
8166 #endif
<a name="137" id="anc137"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="137" type="hidden" />
</body>
</html>