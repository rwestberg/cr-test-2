<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RoundedRect.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShadowBlur.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
167 }
168 #endif
169 
170 static const int templateSideLength = 1;
171 
172 ShadowBlur::ShadowBlur() = default;
173 
174 ShadowBlur::ShadowBlur(const FloatSize&amp; radius, const FloatSize&amp; offset, const Color&amp; color, bool shadowsIgnoreTransforms)
175     : m_color(color)
176     , m_blurRadius(radius)
177     , m_offset(offset)
178     , m_shadowsIgnoreTransforms(shadowsIgnoreTransforms)
179 {
180     updateShadowBlurValues();
181 }
182 
183 ShadowBlur::ShadowBlur(const GraphicsContextState&amp; state)
184     : m_color(state.shadowColor)
185     , m_blurRadius(state.shadowBlur, state.shadowBlur)
186     , m_offset(state.shadowOffset)
<span class="line-removed">187     , m_layerImage(0)</span>
188     , m_shadowsIgnoreTransforms(state.shadowsIgnoreTransforms)
189 {
190 #if USE(CG)
191     if (state.shadowsUseLegacyRadius) {
192         float shadowBlur = radiusToLegacyRadius(state.shadowBlur);
193         m_blurRadius = FloatSize(shadowBlur, shadowBlur);
194     }
195 #endif
196     updateShadowBlurValues();
197 }
198 
199 void ShadowBlur::setShadowValues(const FloatSize&amp; radius, const FloatSize&amp; offset, const Color&amp; color, bool ignoreTransforms)
200 {
201     m_blurRadius = radius;
202     m_offset = offset;
203     m_color = color;
204     m_shadowsIgnoreTransforms = ignoreTransforms;
205 
206     updateShadowBlurValues();
207 }
</pre>
<hr />
<pre>
362 void ShadowBlur::adjustBlurRadius(const AffineTransform&amp; transform)
363 {
364     if (m_shadowsIgnoreTransforms)
365         m_blurRadius.scale(1 / static_cast&lt;float&gt;(transform.xScale()), 1 / static_cast&lt;float&gt;(transform.yScale()));
366 }
367 
368 IntSize ShadowBlur::blurredEdgeSize() const
369 {
370     IntSize edgeSize = expandedIntSize(m_blurRadius);
371 
372     // To avoid slowing down blurLayerImage() for radius == 1, we give it two empty pixels on each side.
373     if (edgeSize.width() == 1)
374         edgeSize.setWidth(2);
375 
376     if (edgeSize.height() == 1)
377         edgeSize.setHeight(2);
378 
379     return edgeSize;
380 }
381 
<span class="line-modified">382 IntSize ShadowBlur::calculateLayerBoundingRect(const AffineTransform&amp; transform, const FloatRect&amp; shadowedRect, const IntRect&amp; clipRect)</span>
383 {


384     IntSize edgeSize = blurredEdgeSize();
385 
386     // Calculate the destination of the blurred and/or transformed layer.
387     FloatRect layerRect;
388     IntSize inflation;
389 
390     if (m_shadowsIgnoreTransforms &amp;&amp; !transform.isIdentity()) {
391         FloatQuad transformedPolygon = transform.mapQuad(FloatQuad(shadowedRect));
392         transformedPolygon.move(m_offset);
393         layerRect = transform.inverse().valueOr(AffineTransform()).mapQuad(transformedPolygon).boundingBox();
394     } else {
395         layerRect = shadowedRect;
396         layerRect.move(m_offset);
397     }
398 
399     // We expand the area by the blur radius to give extra space for the blur transition.
400     if (m_type == BlurShadow) {
401         layerRect.inflateX(edgeSize.width());
402         layerRect.inflateY(edgeSize.height());
403         inflation = edgeSize;
404     }
405 
406     FloatRect unclippedLayerRect = layerRect;
407 
408     if (!clipRect.contains(enclosingIntRect(layerRect))) {
409         // If we are totally outside the clip region, we aren&#39;t painting at all.
410         if (intersection(layerRect, clipRect).isEmpty())
<span class="line-modified">411             return IntSize();</span>
412 
413         IntRect inflatedClip = clipRect;
414         // Pixels at the edges can be affected by pixels outside the buffer,
415         // so intersect with the clip inflated by the blur.
416         if (m_type == BlurShadow) {
417             inflatedClip.inflateX(edgeSize.width());
418             inflatedClip.inflateY(edgeSize.height());
419         } else {
420             // Enlarge the clipping area 1 pixel so that the fill does not
421             // bleed (due to antialiasing) even if the unaligned clip rect occurred
422             inflatedClip.inflateX(1);
423             inflatedClip.inflateY(1);
424         }
425 
426         layerRect.intersect(inflatedClip);
427     }
428 
429     IntSize frameSize = inflation;
430     frameSize.scale(2);
<span class="line-modified">431     m_shadowedResultSize = FloatSize(shadowedRect.width() + frameSize.width(), shadowedRect.height() + frameSize.height());</span>
<span class="line-modified">432     m_layerOrigin = FloatPoint(layerRect.x(), layerRect.y());</span>
<span class="line-modified">433     m_layerSize = layerRect.size();</span>
434 
435     const FloatPoint unclippedLayerOrigin = FloatPoint(unclippedLayerRect.x(), unclippedLayerRect.y());
<span class="line-modified">436     const FloatSize clippedOut = unclippedLayerOrigin - m_layerOrigin;</span>
437 
438     // Set the origin as the top left corner of the scratch image, or, in case there&#39;s a clipped
439     // out region, set the origin accordingly to the full bounding rect&#39;s top-left corner.
440     float translationX = -shadowedRect.x() + inflation.width() - fabsf(clippedOut.width());
441     float translationY = -shadowedRect.y() + inflation.height() - fabsf(clippedOut.height());
<span class="line-modified">442     m_layerContextTranslation = FloatSize(translationX, translationY);</span>
443 
<span class="line-modified">444     return expandedIntSize(layerRect.size());</span>
445 }
446 
<span class="line-modified">447 void ShadowBlur::drawShadowBuffer(GraphicsContext&amp; graphicsContext)</span>
448 {
<span class="line-removed">449     if (!m_layerImage)</span>
<span class="line-removed">450         return;</span>
<span class="line-removed">451 </span>
452     GraphicsContextStateSaver stateSaver(graphicsContext);
453 
<span class="line-modified">454     IntSize bufferSize = m_layerImage-&gt;internalSize();</span>
<span class="line-modified">455     if (bufferSize != m_layerSize) {</span>
456         // The rect passed to clipToImageBuffer() has to be the size of the entire buffer,
457         // but we may not have cleared it all, so clip to the filled part first.
<span class="line-modified">458         graphicsContext.clip(FloatRect(m_layerOrigin, m_layerSize));</span>
459     }
<span class="line-modified">460     graphicsContext.clipToImageBuffer(*m_layerImage, FloatRect(m_layerOrigin, bufferSize));</span>
461     graphicsContext.setFillColor(m_color);
462 
463     graphicsContext.clearShadow();
<span class="line-modified">464     graphicsContext.fillRect(FloatRect(m_layerOrigin, m_layerSize));</span>
465 }
466 
467 static void computeSliceSizesFromRadii(const IntSize&amp; twiceRadius, const FloatRoundedRect::Radii&amp; radii, int&amp; leftSlice, int&amp; rightSlice, int&amp; topSlice, int&amp; bottomSlice)
468 {
469     leftSlice = twiceRadius.width() + std::max(radii.topLeft().width(), radii.bottomLeft().width());
470     rightSlice = twiceRadius.width() + std::max(radii.topRight().width(), radii.bottomRight().width());
471 
472     topSlice = twiceRadius.height() + std::max(radii.topLeft().height(), radii.topRight().height());
473     bottomSlice = twiceRadius.height() + std::max(radii.bottomLeft().height(), radii.bottomRight().height());
474 }
475 
476 IntSize ShadowBlur::templateSize(const IntSize&amp; radiusPadding, const FloatRoundedRect::Radii&amp; radii) const
477 {
478     const int templateSideLength = 1;
479 
480     int leftSlice;
481     int rightSlice;
482     int topSlice;
483     int bottomSlice;
484 
485     IntSize blurExpansion = radiusPadding;
486     blurExpansion.scale(2);
487 
488     computeSliceSizesFromRadii(blurExpansion, radii, leftSlice, rightSlice, topSlice, bottomSlice);
489 
490     return IntSize(templateSideLength + leftSlice + rightSlice, templateSideLength + topSlice + bottomSlice);
491 }
492 
493 void ShadowBlur::drawRectShadow(GraphicsContext&amp; graphicsContext, const FloatRoundedRect&amp; shadowedRect)
494 {
495     drawRectShadow(graphicsContext.getCTM(), graphicsContext.clipBounds(), shadowedRect,
<span class="line-modified">496         [this, &amp;graphicsContext](ImageBuffer&amp;, const FloatPoint&amp;, const FloatSize&amp;) {</span>
<span class="line-modified">497             // FIXME: Use parameters instead of implicit parameters defined as class variables.</span>
<span class="line-removed">498             drawShadowBuffer(graphicsContext);</span>
499         },
500         [&amp;graphicsContext](ImageBuffer&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; srcRect) {
501             GraphicsContextStateSaver stateSaver(graphicsContext);
502             graphicsContext.clearShadow();
503             graphicsContext.drawImageBuffer(image, destRect, srcRect);
504         },
505         [&amp;graphicsContext](const FloatRect&amp; rect, const Color&amp; color) {
506             GraphicsContextStateSaver stateSaver(graphicsContext);
507             graphicsContext.setFillColor(color);
508             graphicsContext.clearShadow();
509             graphicsContext.fillRect(rect);
510         });
511 }
512 
513 void ShadowBlur::drawInsetShadow(GraphicsContext&amp; graphicsContext, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect)
514 {
515     drawInsetShadow(graphicsContext.getCTM(), graphicsContext.clipBounds(), fullRect, holeRect,
<span class="line-modified">516         [this, &amp;graphicsContext](ImageBuffer&amp;, const FloatPoint&amp;, const FloatSize&amp;) {</span>
<span class="line-modified">517             // FIXME: Use parameters instead of implicit parameters defined as class variables.</span>
<span class="line-removed">518             drawShadowBuffer(graphicsContext);</span>
519         },
520         [&amp;graphicsContext](ImageBuffer&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; srcRect) {
521             // Note that drawing the ImageBuffer is faster than creating a Image and drawing that,
522             // because ImageBuffer::draw() knows that it doesn&#39;t have to copy the image bits.
523             GraphicsContextStateSaver stateSaver(graphicsContext);
524             graphicsContext.clearShadow();
525             graphicsContext.drawImageBuffer(image, destRect, srcRect);
526         },
527         [&amp;graphicsContext](const FloatRect&amp; rect, const FloatRect&amp; holeRect, const Color&amp; color) {
528             Path exteriorPath;
529             exteriorPath.addRect(rect);
530             exteriorPath.addRect(holeRect);
531 
532             GraphicsContextStateSaver fillStateSaver(graphicsContext);
533             graphicsContext.setFillRule(WindRule::EvenOdd);
534             graphicsContext.setFillColor(color);
535             graphicsContext.clearShadow();
536             graphicsContext.fillPath(exteriorPath);
537         });
538 }
539 
540 void ShadowBlur::drawRectShadow(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRoundedRect&amp; shadowedRect, const DrawBufferCallback&amp; drawBuffer, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect)
541 {
<span class="line-modified">542     IntSize layerSize = calculateLayerBoundingRect(transform, shadowedRect.rect(), clipBounds);</span>
<span class="line-modified">543     if (layerSize.isEmpty())</span>
544         return;
545 
546     adjustBlurRadius(transform);
547 
548     bool canUseTilingTechnique = true;
549 
550     // drawRectShadowWithTiling does not work with rotations.
551     // https://bugs.webkit.org/show_bug.cgi?id=45042
552     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
553         canUseTilingTechnique = false;
554 
555     IntSize edgeSize = blurredEdgeSize();
556     IntSize templateSize = this-&gt;templateSize(edgeSize, shadowedRect.radii());
557     const FloatRect&amp; rect = shadowedRect.rect();
558 
559     if (templateSize.width() &gt; rect.width() || templateSize.height() &gt; rect.height()
<span class="line-modified">560         || (templateSize.width() * templateSize.height() &gt; m_shadowedResultSize.width() * m_shadowedResultSize.height()))</span>
561         canUseTilingTechnique = false;
562 
563     if (canUseTilingTechnique)
<span class="line-modified">564         drawRectShadowWithTiling(transform, shadowedRect, templateSize, edgeSize, drawImage, fillRect);</span>
565     else
<span class="line-modified">566         drawRectShadowWithoutTiling(transform, shadowedRect, layerSize, drawBuffer);</span>
567 }
568 
569 void ShadowBlur::drawInsetShadow(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const DrawBufferCallback&amp; drawBuffer, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
570 {
<span class="line-modified">571     IntSize layerSize = calculateLayerBoundingRect(transform, fullRect, clipBounds);</span>
<span class="line-modified">572     if (layerSize.isEmpty())</span>
573         return;
574 
575     adjustBlurRadius(transform);
576 
577     bool canUseTilingTechnique = true;
578 
579     // drawRectShadowWithTiling does not work with rotations.
580     // https://bugs.webkit.org/show_bug.cgi?id=45042
581     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
582         canUseTilingTechnique = false;
583 
584     IntSize edgeSize = blurredEdgeSize();
585     IntSize templateSize = this-&gt;templateSize(edgeSize, holeRect.radii());
586     const FloatRect&amp; hRect = holeRect.rect();
587 
588     if (templateSize.width() &gt; hRect.width() || templateSize.height() &gt; hRect.height()
589         || (templateSize.width() * templateSize.height() &gt; hRect.width() * hRect.height()))
590         canUseTilingTechnique = false;
591 
592     if (canUseTilingTechnique)
593         drawInsetShadowWithTiling(transform, fullRect, holeRect, templateSize, edgeSize, drawImage, fillRectWithHole);
594     else
<span class="line-modified">595         drawInsetShadowWithoutTiling(transform, fullRect, holeRect, layerSize, drawBuffer);</span>
596 }
597 
<span class="line-modified">598 void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&amp;, const FloatRoundedRect&amp; shadowedRect, const IntSize&amp; layerSize, const DrawBufferCallback&amp; drawBuffer)</span>
599 {
<span class="line-modified">600     auto layerImage = ImageBuffer::create(layerSize, Unaccelerated, 1);</span>
601     if (!layerImage)
602         return;
<span class="line-removed">603     m_layerImage = layerImage.get();</span>
604 
605     GraphicsContext&amp; shadowContext = layerImage-&gt;context();
606     GraphicsContextStateSaver stateSaver(shadowContext);
607     shadowContext.setFillColor(Color::black);
608 
609     {
610         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
611         GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">612         shadowContext.translate(m_layerContextTranslation);</span>
613         shadowContext.setFillColor(Color::black);
614         if (shadowedRect.radii().isZero())
615             shadowContext.fillRect(shadowedRect.rect());
616         else {
617             Path path;
618             path.addRoundedRect(shadowedRect);
619             shadowContext.fillPath(path);
620         }
621 
<span class="line-modified">622         blurShadowBuffer(layerSize);</span>
623     }
<span class="line-modified">624     drawBuffer(*layerImage, m_layerOrigin, m_layerSize);</span>
625 }
626 
<span class="line-modified">627 void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&amp;, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; layerSize, const DrawBufferCallback&amp; drawBuffer)</span>
628 {
<span class="line-modified">629     auto layerImage = ImageBuffer::create(layerSize, Unaccelerated, 1);</span>
630     if (!layerImage)
631         return;
<span class="line-removed">632     m_layerImage = layerImage.get();</span>
633 
634     {
635         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
636         GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">637         shadowContext.translate(m_layerContextTranslation);</span>
638 
639         Path path;
640         path.addRect(fullRect);
641         if (holeRect.radii().isZero())
642             path.addRect(holeRect.rect());
643         else
644             path.addRoundedRect(holeRect);
645 
646         shadowContext.setFillRule(WindRule::EvenOdd);
647         shadowContext.setFillColor(Color::black);
648         shadowContext.fillPath(path);
649 
<span class="line-modified">650         blurShadowBuffer(layerSize);</span>
651     }
652 
<span class="line-modified">653     drawBuffer(*layerImage, m_layerOrigin, m_layerSize);</span>
654 }
655 
656 /*
657   These functions use tiling to improve the performance of the shadow
658   drawing of rounded rectangles. The code basically does the following
659   steps:
660 
661      1. Calculate the size of the shadow template, a rectangle that
662      contains all the necessary tiles to draw the complete shadow.
663 
664      2. If that size is smaller than the real rectangle render the new
665      template rectangle and its shadow in a new surface, in other case
666      render the shadow of the real rectangle in the destination
667      surface.
668 
669      3. Calculate the sizes and positions of the tiles and their
670      destinations and use drawPattern to render the final shadow. The
671      code divides the rendering in 8 tiles:
672 
673         1 | 2 | 3
674        -----------
675         4 |   | 5
676        -----------
677         6 | 7 | 8
678 
679      The corners are directly copied from the template rectangle to the
680      real one and the side tiles are 1 pixel width, we use them as
681      tiles to cover the destination side. The corner tiles are bigger
682      than just the side of the rounded corner, we need to increase it
683      because the modifications caused by the corner over the blur
684      effect. We fill the central or outer part with solid color to complete
685      the shadow.
686  */
687 
<span class="line-modified">688 void ShadowBlur::drawRectShadowWithTiling(const AffineTransform&amp; transform, const FloatRoundedRect&amp; shadowedRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect)</span>
689 {
690 #if USE(CG)
<span class="line-modified">691     m_layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);</span>
692 #else
<span class="line-modified">693     auto layerImage = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
<span class="line-modified">694     m_layerImage = layerImage.get();</span>

695 #endif
696 
<span class="line-modified">697     if (!m_layerImage)</span>
698         return;
699 
700     FloatRect templateShadow = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
701 
702     bool redrawNeeded = true;
703 #if USE(CG)
704     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
<span class="line-modified">705     redrawNeeded = ScratchBuffer::singleton().setCachedShadowValues(m_blurRadius, m_color, templateShadow, shadowedRect.radii(), m_layerSize);</span>
706 #endif
707 
708     if (redrawNeeded) {
709         // Draw shadow into the ImageBuffer.
<span class="line-modified">710         GraphicsContext&amp; shadowContext = m_layerImage-&gt;context();</span>
711         GraphicsContextStateSaver shadowStateSaver(shadowContext);
712 
713         shadowContext.clearRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
714         shadowContext.setFillColor(Color::black);
715 
716         if (shadowedRect.radii().isZero())
717             shadowContext.fillRect(templateShadow);
718         else {
<span class="line-modified">719         Path path;</span>
720             path.addRoundedRect(FloatRoundedRect(templateShadow, shadowedRect.radii()));
<span class="line-modified">721         shadowContext.fillPath(path);</span>
722         }
<span class="line-modified">723         blurAndColorShadowBuffer(templateSize);</span>
724     }
725 
726     FloatSize offset = m_offset;
727     if (shadowsIgnoreTransforms())
728         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
729 
730     FloatRect shadowBounds = shadowedRect.rect();
731     shadowBounds.move(offset);
732     shadowBounds.inflateX(edgeSize.width());
733     shadowBounds.inflateY(edgeSize.height());
734 
<span class="line-modified">735     drawLayerPiecesAndFillCenter(shadowBounds, shadowedRect.radii(), edgeSize, templateSize, drawImage, fillRect);</span>
<span class="line-removed">736 </span>
<span class="line-removed">737     m_layerImage = nullptr;</span>
738 
739 #if USE(CG)
740     ScratchBuffer::singleton().scheduleScratchBufferPurge();
741 #endif
742 }
743 
744 void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform&amp; transform, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
745 {
746 #if USE(CG)
<span class="line-modified">747     m_layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);</span>
748 #else
<span class="line-modified">749     auto layerImage = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
<span class="line-modified">750     m_layerImage = layerImage.get();</span>
751 #endif
752 
<span class="line-modified">753     if (!m_layerImage)</span>
754         return;
755 
756     // Draw the rectangle with hole.
757     FloatRect templateBounds(0, 0, templateSize.width(), templateSize.height());
758     FloatRect templateHole = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
759 
760     bool redrawNeeded = true;
761 #if USE(CG)
762     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
763     redrawNeeded = ScratchBuffer::singleton().setCachedInsetShadowValues(m_blurRadius, m_color, templateBounds, templateHole, holeRect.radii());
764 #endif
765 
766     if (redrawNeeded) {
767         // Draw shadow into a new ImageBuffer.
<span class="line-modified">768         GraphicsContext&amp; shadowContext = m_layerImage-&gt;context();</span>
769         GraphicsContextStateSaver shadowStateSaver(shadowContext);
770         shadowContext.clearRect(templateBounds);
771         shadowContext.setFillRule(WindRule::EvenOdd);
772         shadowContext.setFillColor(Color::black);
773 
<span class="line-modified">774             Path path;</span>
775         path.addRect(templateBounds);
776         if (holeRect.radii().isZero())
777             path.addRect(templateHole);
778         else
779             path.addRoundedRect(FloatRoundedRect(templateHole, holeRect.radii()));
780 
<span class="line-modified">781             shadowContext.fillPath(path);</span>
782 
<span class="line-modified">783         blurAndColorShadowBuffer(templateSize);</span>
784     }
785     FloatSize offset = m_offset;
786     if (shadowsIgnoreTransforms())
787         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
788 
789     FloatRect boundingRect = fullRect;
790     boundingRect.move(offset);
791 
792     FloatRect destHoleRect = holeRect.rect();
793     destHoleRect.move(offset);
794     FloatRect destHoleBounds = destHoleRect;
795     destHoleBounds.inflateX(edgeSize.width());
796     destHoleBounds.inflateY(edgeSize.height());
797 
798     // Fill the external part of the shadow (which may be visible because of offset).
799     fillRectWithHole(boundingRect, destHoleBounds, m_color);
800 
<span class="line-modified">801     drawLayerPieces(destHoleBounds, holeRect.radii(), edgeSize, templateSize, drawImage);</span>
<span class="line-removed">802 </span>
<span class="line-removed">803     m_layerImage = nullptr;</span>
804 
805 #if USE(CG)
806     ScratchBuffer::singleton().scheduleScratchBufferPurge();
807 #endif
808 }
809 
<span class="line-modified">810 void ShadowBlur::drawLayerPieces(const FloatRect&amp; shadowBounds, const FloatRoundedRect::Radii&amp; radii, const IntSize&amp; bufferPadding, const IntSize&amp; templateSize, const DrawImageCallback&amp; drawImage)</span>
811 {
812     const IntSize twiceRadius = IntSize(bufferPadding.width() * 2, bufferPadding.height() * 2);
813 
814     int leftSlice;
815     int rightSlice;
816     int topSlice;
817     int bottomSlice;
818     computeSliceSizesFromRadii(twiceRadius, radii, leftSlice, rightSlice, topSlice, bottomSlice);
819 
820     int centerWidth = shadowBounds.width() - leftSlice - rightSlice;
821     int centerHeight = shadowBounds.height() - topSlice - bottomSlice;
822     FloatRect centerRect(shadowBounds.x() + leftSlice, shadowBounds.y() + topSlice, centerWidth, centerHeight);
823 
824     // Top side.
825     FloatRect tileRect = FloatRect(leftSlice, 0, templateSideLength, topSlice);
826     FloatRect destRect = FloatRect(centerRect.x(), centerRect.y() - topSlice, centerRect.width(), topSlice);
<span class="line-modified">827     drawImage(*m_layerImage, destRect, tileRect);</span>
828 
829     // Draw the bottom side.
830     tileRect.setY(templateSize.height() - bottomSlice);
831     tileRect.setHeight(bottomSlice);
832     destRect.setY(centerRect.maxY());
833     destRect.setHeight(bottomSlice);
<span class="line-modified">834     drawImage(*m_layerImage, destRect, tileRect);</span>
835 
836     // Left side.
837     tileRect = FloatRect(0, topSlice, leftSlice, templateSideLength);
838     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.y(), leftSlice, centerRect.height());
<span class="line-modified">839     drawImage(*m_layerImage, destRect, tileRect);</span>
840 
841     // Right side.
842     tileRect.setX(templateSize.width() - rightSlice);
843     tileRect.setWidth(rightSlice);
844     destRect.setX(centerRect.maxX());
845     destRect.setWidth(rightSlice);
<span class="line-modified">846     drawImage(*m_layerImage, destRect, tileRect);</span>
847 
848     // Top left corner.
849     tileRect = FloatRect(0, 0, leftSlice, topSlice);
850     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.y() - topSlice, leftSlice, topSlice);
<span class="line-modified">851     drawImage(*m_layerImage, destRect, tileRect);</span>
852 
853     // Top right corner.
854     tileRect = FloatRect(templateSize.width() - rightSlice, 0, rightSlice, topSlice);
855     destRect = FloatRect(centerRect.maxX(), centerRect.y() - topSlice, rightSlice, topSlice);
<span class="line-modified">856     drawImage(*m_layerImage, destRect, tileRect);</span>
857 
858     // Bottom right corner.
859     tileRect = FloatRect(templateSize.width() - rightSlice, templateSize.height() - bottomSlice, rightSlice, bottomSlice);
860     destRect = FloatRect(centerRect.maxX(), centerRect.maxY(), rightSlice, bottomSlice);
<span class="line-modified">861     drawImage(*m_layerImage, destRect, tileRect);</span>
862 
863     // Bottom left corner.
864     tileRect = FloatRect(0, templateSize.height() - bottomSlice, leftSlice, bottomSlice);
865     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.maxY(), leftSlice, bottomSlice);
<span class="line-modified">866     drawImage(*m_layerImage, destRect, tileRect);</span>
867 }
868 
<span class="line-modified">869 void ShadowBlur::drawLayerPiecesAndFillCenter(const FloatRect&amp; shadowBounds, const FloatRoundedRect::Radii&amp; radii, const IntSize&amp; bufferPadding, const IntSize&amp; templateSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect)</span>
870 {
871     const IntSize twiceRadius = IntSize(bufferPadding.width() * 2, bufferPadding.height() * 2);
872 
873     int leftSlice;
874     int rightSlice;
875     int topSlice;
876     int bottomSlice;
877     computeSliceSizesFromRadii(twiceRadius, radii, leftSlice, rightSlice, topSlice, bottomSlice);
878 
879     int centerWidth = shadowBounds.width() - leftSlice - rightSlice;
880     int centerHeight = shadowBounds.height() - topSlice - bottomSlice;
881     FloatRect centerRect(shadowBounds.x() + leftSlice, shadowBounds.y() + topSlice, centerWidth, centerHeight);
882 
883     // Fill center
884     if (!centerRect.isEmpty())
885         fillRect(centerRect, m_color);
886 
<span class="line-modified">887     drawLayerPieces(shadowBounds, radii, bufferPadding, templateSize, drawImage);</span>
888 }
889 
<span class="line-modified">890 void ShadowBlur::blurShadowBuffer(const IntSize&amp; templateSize)</span>
891 {
892     if (m_type != BlurShadow)
893         return;
894 
895     IntRect blurRect(IntPoint(), templateSize);
<span class="line-modified">896     auto layerData = m_layerImage-&gt;getUnmultipliedImageData(blurRect);</span>
897     if (!layerData)
898         return;
899 
900     blurLayerImage(layerData-&gt;data(), blurRect.size(), blurRect.width() * 4);
<span class="line-modified">901     m_layerImage-&gt;putByteArray(*layerData, AlphaPremultiplication::Unpremultiplied, blurRect.size(), blurRect, { });</span>
902 }
903 
<span class="line-modified">904 void ShadowBlur::blurAndColorShadowBuffer(const IntSize&amp; templateSize)</span>
905 {
<span class="line-modified">906     blurShadowBuffer(templateSize);</span>
907 
908     // Mask the image with the shadow color.
<span class="line-modified">909     GraphicsContext&amp; shadowContext = m_layerImage-&gt;context();</span>
910     GraphicsContextStateSaver stateSaver(shadowContext);
911     shadowContext.setCompositeOperation(CompositeSourceIn);
912     shadowContext.setFillColor(m_color);
913     shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
914 }
915 
916 void ShadowBlur::drawShadowLayer(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; layerArea, const DrawShadowCallback&amp; drawShadow, const DrawBufferCallback&amp; drawBuffer)
917 {
<span class="line-modified">918     IntSize layerSize = calculateLayerBoundingRect(transform, layerArea, clipBounds);</span>
<span class="line-modified">919     if (layerSize.isEmpty())</span>
920         return;
921 
922     adjustBlurRadius(transform);
923 
<span class="line-modified">924     auto layerImage = ImageBuffer::create(layerSize, Unaccelerated, 1);</span>
925     if (!layerImage)
926         return;
<span class="line-removed">927     m_layerImage = layerImage.get();</span>
928 
929     {
930         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
931         GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">932         shadowContext.translate(m_layerContextTranslation);</span>
933         drawShadow(shadowContext);
934     }
935 
<span class="line-modified">936     blurAndColorShadowBuffer(expandedIntSize(m_layerSize));</span>
<span class="line-modified">937     drawBuffer(*layerImage, m_layerOrigin, m_layerSize);</span>
938 }
939 
940 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
167 }
168 #endif
169 
170 static const int templateSideLength = 1;
171 
172 ShadowBlur::ShadowBlur() = default;
173 
174 ShadowBlur::ShadowBlur(const FloatSize&amp; radius, const FloatSize&amp; offset, const Color&amp; color, bool shadowsIgnoreTransforms)
175     : m_color(color)
176     , m_blurRadius(radius)
177     , m_offset(offset)
178     , m_shadowsIgnoreTransforms(shadowsIgnoreTransforms)
179 {
180     updateShadowBlurValues();
181 }
182 
183 ShadowBlur::ShadowBlur(const GraphicsContextState&amp; state)
184     : m_color(state.shadowColor)
185     , m_blurRadius(state.shadowBlur, state.shadowBlur)
186     , m_offset(state.shadowOffset)

187     , m_shadowsIgnoreTransforms(state.shadowsIgnoreTransforms)
188 {
189 #if USE(CG)
190     if (state.shadowsUseLegacyRadius) {
191         float shadowBlur = radiusToLegacyRadius(state.shadowBlur);
192         m_blurRadius = FloatSize(shadowBlur, shadowBlur);
193     }
194 #endif
195     updateShadowBlurValues();
196 }
197 
198 void ShadowBlur::setShadowValues(const FloatSize&amp; radius, const FloatSize&amp; offset, const Color&amp; color, bool ignoreTransforms)
199 {
200     m_blurRadius = radius;
201     m_offset = offset;
202     m_color = color;
203     m_shadowsIgnoreTransforms = ignoreTransforms;
204 
205     updateShadowBlurValues();
206 }
</pre>
<hr />
<pre>
361 void ShadowBlur::adjustBlurRadius(const AffineTransform&amp; transform)
362 {
363     if (m_shadowsIgnoreTransforms)
364         m_blurRadius.scale(1 / static_cast&lt;float&gt;(transform.xScale()), 1 / static_cast&lt;float&gt;(transform.yScale()));
365 }
366 
367 IntSize ShadowBlur::blurredEdgeSize() const
368 {
369     IntSize edgeSize = expandedIntSize(m_blurRadius);
370 
371     // To avoid slowing down blurLayerImage() for radius == 1, we give it two empty pixels on each side.
372     if (edgeSize.width() == 1)
373         edgeSize.setWidth(2);
374 
375     if (edgeSize.height() == 1)
376         edgeSize.setHeight(2);
377 
378     return edgeSize;
379 }
380 
<span class="line-modified">381 Optional&lt;ShadowBlur::LayerImageProperties&gt; ShadowBlur::calculateLayerBoundingRect(const AffineTransform&amp; transform, const FloatRect&amp; shadowedRect, const IntRect&amp; clipRect)</span>
382 {
<span class="line-added">383     LayerImageProperties calculatedLayerImageProperties;</span>
<span class="line-added">384 </span>
385     IntSize edgeSize = blurredEdgeSize();
386 
387     // Calculate the destination of the blurred and/or transformed layer.
388     FloatRect layerRect;
389     IntSize inflation;
390 
391     if (m_shadowsIgnoreTransforms &amp;&amp; !transform.isIdentity()) {
392         FloatQuad transformedPolygon = transform.mapQuad(FloatQuad(shadowedRect));
393         transformedPolygon.move(m_offset);
394         layerRect = transform.inverse().valueOr(AffineTransform()).mapQuad(transformedPolygon).boundingBox();
395     } else {
396         layerRect = shadowedRect;
397         layerRect.move(m_offset);
398     }
399 
400     // We expand the area by the blur radius to give extra space for the blur transition.
401     if (m_type == BlurShadow) {
402         layerRect.inflateX(edgeSize.width());
403         layerRect.inflateY(edgeSize.height());
404         inflation = edgeSize;
405     }
406 
407     FloatRect unclippedLayerRect = layerRect;
408 
409     if (!clipRect.contains(enclosingIntRect(layerRect))) {
410         // If we are totally outside the clip region, we aren&#39;t painting at all.
411         if (intersection(layerRect, clipRect).isEmpty())
<span class="line-modified">412             return WTF::nullopt;</span>
413 
414         IntRect inflatedClip = clipRect;
415         // Pixels at the edges can be affected by pixels outside the buffer,
416         // so intersect with the clip inflated by the blur.
417         if (m_type == BlurShadow) {
418             inflatedClip.inflateX(edgeSize.width());
419             inflatedClip.inflateY(edgeSize.height());
420         } else {
421             // Enlarge the clipping area 1 pixel so that the fill does not
422             // bleed (due to antialiasing) even if the unaligned clip rect occurred
423             inflatedClip.inflateX(1);
424             inflatedClip.inflateY(1);
425         }
426 
427         layerRect.intersect(inflatedClip);
428     }
429 
430     IntSize frameSize = inflation;
431     frameSize.scale(2);
<span class="line-modified">432     calculatedLayerImageProperties.shadowedResultSize = FloatSize(shadowedRect.width() + frameSize.width(), shadowedRect.height() + frameSize.height());</span>
<span class="line-modified">433     calculatedLayerImageProperties.layerOrigin = FloatPoint(layerRect.x(), layerRect.y());</span>
<span class="line-modified">434     calculatedLayerImageProperties.layerSize = layerRect.size();</span>
435 
436     const FloatPoint unclippedLayerOrigin = FloatPoint(unclippedLayerRect.x(), unclippedLayerRect.y());
<span class="line-modified">437     const FloatSize clippedOut = unclippedLayerOrigin - calculatedLayerImageProperties.layerOrigin;</span>
438 
439     // Set the origin as the top left corner of the scratch image, or, in case there&#39;s a clipped
440     // out region, set the origin accordingly to the full bounding rect&#39;s top-left corner.
441     float translationX = -shadowedRect.x() + inflation.width() - fabsf(clippedOut.width());
442     float translationY = -shadowedRect.y() + inflation.height() - fabsf(clippedOut.height());
<span class="line-modified">443     calculatedLayerImageProperties.layerContextTranslation = FloatSize(translationX, translationY);</span>
444 
<span class="line-modified">445     return calculatedLayerImageProperties;</span>
446 }
447 
<span class="line-modified">448 void ShadowBlur::drawShadowBuffer(GraphicsContext&amp; graphicsContext, ImageBuffer&amp; layerImage, const FloatPoint&amp; layerOrigin, const FloatSize&amp; layerSize)</span>
449 {



450     GraphicsContextStateSaver stateSaver(graphicsContext);
451 
<span class="line-modified">452     IntSize bufferSize = layerImage.internalSize();</span>
<span class="line-modified">453     if (bufferSize != layerSize) {</span>
454         // The rect passed to clipToImageBuffer() has to be the size of the entire buffer,
455         // but we may not have cleared it all, so clip to the filled part first.
<span class="line-modified">456         graphicsContext.clip(FloatRect(layerOrigin, layerSize));</span>
457     }
<span class="line-modified">458     graphicsContext.clipToImageBuffer(layerImage, FloatRect(layerOrigin, bufferSize));</span>
459     graphicsContext.setFillColor(m_color);
460 
461     graphicsContext.clearShadow();
<span class="line-modified">462     graphicsContext.fillRect(FloatRect(layerOrigin, layerSize));</span>
463 }
464 
465 static void computeSliceSizesFromRadii(const IntSize&amp; twiceRadius, const FloatRoundedRect::Radii&amp; radii, int&amp; leftSlice, int&amp; rightSlice, int&amp; topSlice, int&amp; bottomSlice)
466 {
467     leftSlice = twiceRadius.width() + std::max(radii.topLeft().width(), radii.bottomLeft().width());
468     rightSlice = twiceRadius.width() + std::max(radii.topRight().width(), radii.bottomRight().width());
469 
470     topSlice = twiceRadius.height() + std::max(radii.topLeft().height(), radii.topRight().height());
471     bottomSlice = twiceRadius.height() + std::max(radii.bottomLeft().height(), radii.bottomRight().height());
472 }
473 
474 IntSize ShadowBlur::templateSize(const IntSize&amp; radiusPadding, const FloatRoundedRect::Radii&amp; radii) const
475 {
476     const int templateSideLength = 1;
477 
478     int leftSlice;
479     int rightSlice;
480     int topSlice;
481     int bottomSlice;
482 
483     IntSize blurExpansion = radiusPadding;
484     blurExpansion.scale(2);
485 
486     computeSliceSizesFromRadii(blurExpansion, radii, leftSlice, rightSlice, topSlice, bottomSlice);
487 
488     return IntSize(templateSideLength + leftSlice + rightSlice, templateSideLength + topSlice + bottomSlice);
489 }
490 
491 void ShadowBlur::drawRectShadow(GraphicsContext&amp; graphicsContext, const FloatRoundedRect&amp; shadowedRect)
492 {
493     drawRectShadow(graphicsContext.getCTM(), graphicsContext.clipBounds(), shadowedRect,
<span class="line-modified">494         [this, &amp;graphicsContext](ImageBuffer&amp; layerImage, const FloatPoint&amp; layerOrigin, const FloatSize&amp; layerSize) {</span>
<span class="line-modified">495             drawShadowBuffer(graphicsContext, layerImage, layerOrigin, layerSize);</span>

496         },
497         [&amp;graphicsContext](ImageBuffer&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; srcRect) {
498             GraphicsContextStateSaver stateSaver(graphicsContext);
499             graphicsContext.clearShadow();
500             graphicsContext.drawImageBuffer(image, destRect, srcRect);
501         },
502         [&amp;graphicsContext](const FloatRect&amp; rect, const Color&amp; color) {
503             GraphicsContextStateSaver stateSaver(graphicsContext);
504             graphicsContext.setFillColor(color);
505             graphicsContext.clearShadow();
506             graphicsContext.fillRect(rect);
507         });
508 }
509 
510 void ShadowBlur::drawInsetShadow(GraphicsContext&amp; graphicsContext, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect)
511 {
512     drawInsetShadow(graphicsContext.getCTM(), graphicsContext.clipBounds(), fullRect, holeRect,
<span class="line-modified">513         [this, &amp;graphicsContext](ImageBuffer&amp; layerImage, const FloatPoint&amp; layerOrigin, const FloatSize&amp; layerSize) {</span>
<span class="line-modified">514             drawShadowBuffer(graphicsContext, layerImage, layerOrigin, layerSize);</span>

515         },
516         [&amp;graphicsContext](ImageBuffer&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; srcRect) {
517             // Note that drawing the ImageBuffer is faster than creating a Image and drawing that,
518             // because ImageBuffer::draw() knows that it doesn&#39;t have to copy the image bits.
519             GraphicsContextStateSaver stateSaver(graphicsContext);
520             graphicsContext.clearShadow();
521             graphicsContext.drawImageBuffer(image, destRect, srcRect);
522         },
523         [&amp;graphicsContext](const FloatRect&amp; rect, const FloatRect&amp; holeRect, const Color&amp; color) {
524             Path exteriorPath;
525             exteriorPath.addRect(rect);
526             exteriorPath.addRect(holeRect);
527 
528             GraphicsContextStateSaver fillStateSaver(graphicsContext);
529             graphicsContext.setFillRule(WindRule::EvenOdd);
530             graphicsContext.setFillColor(color);
531             graphicsContext.clearShadow();
532             graphicsContext.fillPath(exteriorPath);
533         });
534 }
535 
536 void ShadowBlur::drawRectShadow(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRoundedRect&amp; shadowedRect, const DrawBufferCallback&amp; drawBuffer, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect)
537 {
<span class="line-modified">538     auto layerImageProperties = calculateLayerBoundingRect(transform, shadowedRect.rect(), clipBounds);</span>
<span class="line-modified">539     if (!layerImageProperties)</span>
540         return;
541 
542     adjustBlurRadius(transform);
543 
544     bool canUseTilingTechnique = true;
545 
546     // drawRectShadowWithTiling does not work with rotations.
547     // https://bugs.webkit.org/show_bug.cgi?id=45042
548     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
549         canUseTilingTechnique = false;
550 
551     IntSize edgeSize = blurredEdgeSize();
552     IntSize templateSize = this-&gt;templateSize(edgeSize, shadowedRect.radii());
553     const FloatRect&amp; rect = shadowedRect.rect();
554 
555     if (templateSize.width() &gt; rect.width() || templateSize.height() &gt; rect.height()
<span class="line-modified">556         || (templateSize.area() &gt; layerImageProperties-&gt;shadowedResultSize.area()))</span>
557         canUseTilingTechnique = false;
558 
559     if (canUseTilingTechnique)
<span class="line-modified">560         drawRectShadowWithTiling(transform, shadowedRect, templateSize, edgeSize, drawImage, fillRect, *layerImageProperties);</span>
561     else
<span class="line-modified">562         drawRectShadowWithoutTiling(transform, shadowedRect, *layerImageProperties, drawBuffer);</span>
563 }
564 
565 void ShadowBlur::drawInsetShadow(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const DrawBufferCallback&amp; drawBuffer, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
566 {
<span class="line-modified">567     auto layerImageProperties = calculateLayerBoundingRect(transform, fullRect, clipBounds);</span>
<span class="line-modified">568     if (!layerImageProperties)</span>
569         return;
570 
571     adjustBlurRadius(transform);
572 
573     bool canUseTilingTechnique = true;
574 
575     // drawRectShadowWithTiling does not work with rotations.
576     // https://bugs.webkit.org/show_bug.cgi?id=45042
577     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
578         canUseTilingTechnique = false;
579 
580     IntSize edgeSize = blurredEdgeSize();
581     IntSize templateSize = this-&gt;templateSize(edgeSize, holeRect.radii());
582     const FloatRect&amp; hRect = holeRect.rect();
583 
584     if (templateSize.width() &gt; hRect.width() || templateSize.height() &gt; hRect.height()
585         || (templateSize.width() * templateSize.height() &gt; hRect.width() * hRect.height()))
586         canUseTilingTechnique = false;
587 
588     if (canUseTilingTechnique)
589         drawInsetShadowWithTiling(transform, fullRect, holeRect, templateSize, edgeSize, drawImage, fillRectWithHole);
590     else
<span class="line-modified">591         drawInsetShadowWithoutTiling(transform, fullRect, holeRect, *layerImageProperties, drawBuffer);</span>
592 }
593 
<span class="line-modified">594 void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&amp;, const FloatRoundedRect&amp; shadowedRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)</span>
595 {
<span class="line-modified">596     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
597     if (!layerImage)
598         return;

599 
600     GraphicsContext&amp; shadowContext = layerImage-&gt;context();
601     GraphicsContextStateSaver stateSaver(shadowContext);
602     shadowContext.setFillColor(Color::black);
603 
604     {
605         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
606         GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">607         shadowContext.translate(layerImageProperties.layerContextTranslation);</span>
608         shadowContext.setFillColor(Color::black);
609         if (shadowedRect.radii().isZero())
610             shadowContext.fillRect(shadowedRect.rect());
611         else {
612             Path path;
613             path.addRoundedRect(shadowedRect);
614             shadowContext.fillPath(path);
615         }
616 
<span class="line-modified">617         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));</span>
618     }
<span class="line-modified">619     drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);</span>
620 }
621 
<span class="line-modified">622 void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&amp;, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)</span>
623 {
<span class="line-modified">624     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
625     if (!layerImage)
626         return;

627 
628     {
629         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
630         GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">631         shadowContext.translate(layerImageProperties.layerContextTranslation);</span>
632 
633         Path path;
634         path.addRect(fullRect);
635         if (holeRect.radii().isZero())
636             path.addRect(holeRect.rect());
637         else
638             path.addRoundedRect(holeRect);
639 
640         shadowContext.setFillRule(WindRule::EvenOdd);
641         shadowContext.setFillColor(Color::black);
642         shadowContext.fillPath(path);
643 
<span class="line-modified">644         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));</span>
645     }
646 
<span class="line-modified">647     drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);</span>
648 }
649 
650 /*
651   These functions use tiling to improve the performance of the shadow
652   drawing of rounded rectangles. The code basically does the following
653   steps:
654 
655      1. Calculate the size of the shadow template, a rectangle that
656      contains all the necessary tiles to draw the complete shadow.
657 
658      2. If that size is smaller than the real rectangle render the new
659      template rectangle and its shadow in a new surface, in other case
660      render the shadow of the real rectangle in the destination
661      surface.
662 
663      3. Calculate the sizes and positions of the tiles and their
664      destinations and use drawPattern to render the final shadow. The
665      code divides the rendering in 8 tiles:
666 
667         1 | 2 | 3
668        -----------
669         4 |   | 5
670        -----------
671         6 | 7 | 8
672 
673      The corners are directly copied from the template rectangle to the
674      real one and the side tiles are 1 pixel width, we use them as
675      tiles to cover the destination side. The corner tiles are bigger
676      than just the side of the rounded corner, we need to increase it
677      because the modifications caused by the corner over the blur
678      effect. We fill the central or outer part with solid color to complete
679      the shadow.
680  */
681 
<span class="line-modified">682 void ShadowBlur::drawRectShadowWithTiling(const AffineTransform&amp; transform, const FloatRoundedRect&amp; shadowedRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect, const LayerImageProperties&amp; layerImageProperties)</span>
683 {
684 #if USE(CG)
<span class="line-modified">685     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);</span>
686 #else
<span class="line-modified">687     UNUSED_PARAM(layerImageProperties);</span>
<span class="line-modified">688     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
<span class="line-added">689     auto* layerImage = layerImageBuffer.get();</span>
690 #endif
691 
<span class="line-modified">692     if (!layerImage)</span>
693         return;
694 
695     FloatRect templateShadow = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
696 
697     bool redrawNeeded = true;
698 #if USE(CG)
699     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
<span class="line-modified">700     redrawNeeded = ScratchBuffer::singleton().setCachedShadowValues(m_blurRadius, m_color, templateShadow, shadowedRect.radii(), layerImageProperties.layerSize);</span>
701 #endif
702 
703     if (redrawNeeded) {
704         // Draw shadow into the ImageBuffer.
<span class="line-modified">705         GraphicsContext&amp; shadowContext = layerImage-&gt;context();</span>
706         GraphicsContextStateSaver shadowStateSaver(shadowContext);
707 
708         shadowContext.clearRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
709         shadowContext.setFillColor(Color::black);
710 
711         if (shadowedRect.radii().isZero())
712             shadowContext.fillRect(templateShadow);
713         else {
<span class="line-modified">714             Path path;</span>
715             path.addRoundedRect(FloatRoundedRect(templateShadow, shadowedRect.radii()));
<span class="line-modified">716             shadowContext.fillPath(path);</span>
717         }
<span class="line-modified">718         blurAndColorShadowBuffer(*layerImage, templateSize);</span>
719     }
720 
721     FloatSize offset = m_offset;
722     if (shadowsIgnoreTransforms())
723         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
724 
725     FloatRect shadowBounds = shadowedRect.rect();
726     shadowBounds.move(offset);
727     shadowBounds.inflateX(edgeSize.width());
728     shadowBounds.inflateY(edgeSize.height());
729 
<span class="line-modified">730     drawLayerPiecesAndFillCenter(*layerImage, shadowBounds, shadowedRect.radii(), edgeSize, templateSize, drawImage, fillRect);</span>


731 
732 #if USE(CG)
733     ScratchBuffer::singleton().scheduleScratchBufferPurge();
734 #endif
735 }
736 
737 void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform&amp; transform, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
738 {
739 #if USE(CG)
<span class="line-modified">740     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);</span>
741 #else
<span class="line-modified">742     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
<span class="line-modified">743     auto* layerImage = layerImageBuffer.get();</span>
744 #endif
745 
<span class="line-modified">746     if (!layerImage)</span>
747         return;
748 
749     // Draw the rectangle with hole.
750     FloatRect templateBounds(0, 0, templateSize.width(), templateSize.height());
751     FloatRect templateHole = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
752 
753     bool redrawNeeded = true;
754 #if USE(CG)
755     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
756     redrawNeeded = ScratchBuffer::singleton().setCachedInsetShadowValues(m_blurRadius, m_color, templateBounds, templateHole, holeRect.radii());
757 #endif
758 
759     if (redrawNeeded) {
760         // Draw shadow into a new ImageBuffer.
<span class="line-modified">761         GraphicsContext&amp; shadowContext = layerImage-&gt;context();</span>
762         GraphicsContextStateSaver shadowStateSaver(shadowContext);
763         shadowContext.clearRect(templateBounds);
764         shadowContext.setFillRule(WindRule::EvenOdd);
765         shadowContext.setFillColor(Color::black);
766 
<span class="line-modified">767         Path path;</span>
768         path.addRect(templateBounds);
769         if (holeRect.radii().isZero())
770             path.addRect(templateHole);
771         else
772             path.addRoundedRect(FloatRoundedRect(templateHole, holeRect.radii()));
773 
<span class="line-modified">774         shadowContext.fillPath(path);</span>
775 
<span class="line-modified">776         blurAndColorShadowBuffer(*layerImage, templateSize);</span>
777     }
778     FloatSize offset = m_offset;
779     if (shadowsIgnoreTransforms())
780         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
781 
782     FloatRect boundingRect = fullRect;
783     boundingRect.move(offset);
784 
785     FloatRect destHoleRect = holeRect.rect();
786     destHoleRect.move(offset);
787     FloatRect destHoleBounds = destHoleRect;
788     destHoleBounds.inflateX(edgeSize.width());
789     destHoleBounds.inflateY(edgeSize.height());
790 
791     // Fill the external part of the shadow (which may be visible because of offset).
792     fillRectWithHole(boundingRect, destHoleBounds, m_color);
793 
<span class="line-modified">794     drawLayerPieces(*layerImage, destHoleBounds, holeRect.radii(), edgeSize, templateSize, drawImage);</span>


795 
796 #if USE(CG)
797     ScratchBuffer::singleton().scheduleScratchBufferPurge();
798 #endif
799 }
800 
<span class="line-modified">801 void ShadowBlur::drawLayerPieces(ImageBuffer&amp; layerImage, const FloatRect&amp; shadowBounds, const FloatRoundedRect::Radii&amp; radii, const IntSize&amp; bufferPadding, const IntSize&amp; templateSize, const DrawImageCallback&amp; drawImage)</span>
802 {
803     const IntSize twiceRadius = IntSize(bufferPadding.width() * 2, bufferPadding.height() * 2);
804 
805     int leftSlice;
806     int rightSlice;
807     int topSlice;
808     int bottomSlice;
809     computeSliceSizesFromRadii(twiceRadius, radii, leftSlice, rightSlice, topSlice, bottomSlice);
810 
811     int centerWidth = shadowBounds.width() - leftSlice - rightSlice;
812     int centerHeight = shadowBounds.height() - topSlice - bottomSlice;
813     FloatRect centerRect(shadowBounds.x() + leftSlice, shadowBounds.y() + topSlice, centerWidth, centerHeight);
814 
815     // Top side.
816     FloatRect tileRect = FloatRect(leftSlice, 0, templateSideLength, topSlice);
817     FloatRect destRect = FloatRect(centerRect.x(), centerRect.y() - topSlice, centerRect.width(), topSlice);
<span class="line-modified">818     drawImage(layerImage, destRect, tileRect);</span>
819 
820     // Draw the bottom side.
821     tileRect.setY(templateSize.height() - bottomSlice);
822     tileRect.setHeight(bottomSlice);
823     destRect.setY(centerRect.maxY());
824     destRect.setHeight(bottomSlice);
<span class="line-modified">825     drawImage(layerImage, destRect, tileRect);</span>
826 
827     // Left side.
828     tileRect = FloatRect(0, topSlice, leftSlice, templateSideLength);
829     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.y(), leftSlice, centerRect.height());
<span class="line-modified">830     drawImage(layerImage, destRect, tileRect);</span>
831 
832     // Right side.
833     tileRect.setX(templateSize.width() - rightSlice);
834     tileRect.setWidth(rightSlice);
835     destRect.setX(centerRect.maxX());
836     destRect.setWidth(rightSlice);
<span class="line-modified">837     drawImage(layerImage, destRect, tileRect);</span>
838 
839     // Top left corner.
840     tileRect = FloatRect(0, 0, leftSlice, topSlice);
841     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.y() - topSlice, leftSlice, topSlice);
<span class="line-modified">842     drawImage(layerImage, destRect, tileRect);</span>
843 
844     // Top right corner.
845     tileRect = FloatRect(templateSize.width() - rightSlice, 0, rightSlice, topSlice);
846     destRect = FloatRect(centerRect.maxX(), centerRect.y() - topSlice, rightSlice, topSlice);
<span class="line-modified">847     drawImage(layerImage, destRect, tileRect);</span>
848 
849     // Bottom right corner.
850     tileRect = FloatRect(templateSize.width() - rightSlice, templateSize.height() - bottomSlice, rightSlice, bottomSlice);
851     destRect = FloatRect(centerRect.maxX(), centerRect.maxY(), rightSlice, bottomSlice);
<span class="line-modified">852     drawImage(layerImage, destRect, tileRect);</span>
853 
854     // Bottom left corner.
855     tileRect = FloatRect(0, templateSize.height() - bottomSlice, leftSlice, bottomSlice);
856     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.maxY(), leftSlice, bottomSlice);
<span class="line-modified">857     drawImage(layerImage, destRect, tileRect);</span>
858 }
859 
<span class="line-modified">860 void ShadowBlur::drawLayerPiecesAndFillCenter(ImageBuffer&amp; layerImage, const FloatRect&amp; shadowBounds, const FloatRoundedRect::Radii&amp; radii, const IntSize&amp; bufferPadding, const IntSize&amp; templateSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect)</span>
861 {
862     const IntSize twiceRadius = IntSize(bufferPadding.width() * 2, bufferPadding.height() * 2);
863 
864     int leftSlice;
865     int rightSlice;
866     int topSlice;
867     int bottomSlice;
868     computeSliceSizesFromRadii(twiceRadius, radii, leftSlice, rightSlice, topSlice, bottomSlice);
869 
870     int centerWidth = shadowBounds.width() - leftSlice - rightSlice;
871     int centerHeight = shadowBounds.height() - topSlice - bottomSlice;
872     FloatRect centerRect(shadowBounds.x() + leftSlice, shadowBounds.y() + topSlice, centerWidth, centerHeight);
873 
874     // Fill center
875     if (!centerRect.isEmpty())
876         fillRect(centerRect, m_color);
877 
<span class="line-modified">878     drawLayerPieces(layerImage, shadowBounds, radii, bufferPadding, templateSize, drawImage);</span>
879 }
880 
<span class="line-modified">881 void ShadowBlur::blurShadowBuffer(ImageBuffer&amp; layerImage, const IntSize&amp; templateSize)</span>
882 {
883     if (m_type != BlurShadow)
884         return;
885 
886     IntRect blurRect(IntPoint(), templateSize);
<span class="line-modified">887     auto layerData = layerImage.getUnmultipliedImageData(blurRect);</span>
888     if (!layerData)
889         return;
890 
891     blurLayerImage(layerData-&gt;data(), blurRect.size(), blurRect.width() * 4);
<span class="line-modified">892     layerImage.putByteArray(*layerData, AlphaPremultiplication::Unpremultiplied, blurRect.size(), blurRect, { });</span>
893 }
894 
<span class="line-modified">895 void ShadowBlur::blurAndColorShadowBuffer(ImageBuffer&amp; layerImage, const IntSize&amp; templateSize)</span>
896 {
<span class="line-modified">897     blurShadowBuffer(layerImage, templateSize);</span>
898 
899     // Mask the image with the shadow color.
<span class="line-modified">900     GraphicsContext&amp; shadowContext = layerImage.context();</span>
901     GraphicsContextStateSaver stateSaver(shadowContext);
902     shadowContext.setCompositeOperation(CompositeSourceIn);
903     shadowContext.setFillColor(m_color);
904     shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
905 }
906 
907 void ShadowBlur::drawShadowLayer(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; layerArea, const DrawShadowCallback&amp; drawShadow, const DrawBufferCallback&amp; drawBuffer)
908 {
<span class="line-modified">909     auto layerImageProperties = calculateLayerBoundingRect(transform, layerArea, clipBounds);</span>
<span class="line-modified">910     if (!layerImageProperties)</span>
911         return;
912 
913     adjustBlurRadius(transform);
914 
<span class="line-modified">915     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties-&gt;layerSize), Unaccelerated, 1);</span>
916     if (!layerImage)
917         return;

918 
919     {
920         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
921         GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">922         shadowContext.translate(layerImageProperties-&gt;layerContextTranslation);</span>
923         drawShadow(shadowContext);
924     }
925 
<span class="line-modified">926     blurAndColorShadowBuffer(*layerImage, expandedIntSize(layerImageProperties-&gt;layerSize));</span>
<span class="line-modified">927     drawBuffer(*layerImage, layerImageProperties-&gt;layerOrigin, layerImageProperties-&gt;layerSize);</span>
928 }
929 
930 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="RoundedRect.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShadowBlur.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>