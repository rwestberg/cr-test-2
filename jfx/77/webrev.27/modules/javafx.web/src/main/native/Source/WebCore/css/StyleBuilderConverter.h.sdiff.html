<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleBuilderConverter.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectorPseudoTypeMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleBuilderCustom.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleBuilderConverter.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;BasicShapeFunctions.h&quot;
  30 #include &quot;CSSCalculationValue.h&quot;
  31 #include &quot;CSSContentDistributionValue.h&quot;
  32 #include &quot;CSSFontFeatureValue.h&quot;
  33 #include &quot;CSSFontStyleValue.h&quot;
  34 #include &quot;CSSFontVariationValue.h&quot;
  35 #include &quot;CSSFunctionValue.h&quot;
  36 #include &quot;CSSGridAutoRepeatValue.h&quot;

  37 #include &quot;CSSGridLineNamesValue.h&quot;
  38 #include &quot;CSSImageGeneratorValue.h&quot;
  39 #include &quot;CSSImageSetValue.h&quot;
  40 #include &quot;CSSImageValue.h&quot;
  41 #include &quot;CSSPrimitiveValue.h&quot;
  42 #include &quot;CSSPrimitiveValueMappings.h&quot;
  43 #include &quot;CSSReflectValue.h&quot;
  44 #include &quot;FontSelectionValueInlines.h&quot;
  45 #include &quot;Frame.h&quot;
  46 #include &quot;GridPositionsResolver.h&quot;
  47 #include &quot;Length.h&quot;
  48 #include &quot;Pair.h&quot;
  49 #include &quot;QuotesData.h&quot;
  50 #include &quot;RuntimeEnabledFeatures.h&quot;
  51 #include &quot;SVGURIReference.h&quot;
  52 #include &quot;Settings.h&quot;
  53 #include &quot;StyleResolver.h&quot;
  54 #include &quot;StyleScrollSnapPoints.h&quot;

  55 #include &quot;TouchAction.h&quot;
  56 #include &quot;TransformFunctions.h&quot;
  57 #include &lt;wtf/Optional.h&gt;
  58 
  59 namespace WebCore {
  60 
  61 // Note that we assume the CSS parser only allows valid CSSValue types.
  62 class StyleBuilderConverter {
  63 public:
  64     static Length convertLength(const StyleResolver&amp;, const CSSValue&amp;);
  65     static Length convertLengthOrAuto(const StyleResolver&amp;, const CSSValue&amp;);
  66     static Length convertLengthSizing(const StyleResolver&amp;, const CSSValue&amp;);
  67     static Length convertLengthMaxSizing(const StyleResolver&amp;, const CSSValue&amp;);

  68     template&lt;typename T&gt; static T convertComputedLength(StyleResolver&amp;, const CSSValue&amp;);
  69     template&lt;typename T&gt; static T convertLineWidth(StyleResolver&amp;, const CSSValue&amp;);
  70     static float convertSpacing(StyleResolver&amp;, const CSSValue&amp;);
  71     static LengthSize convertRadius(StyleResolver&amp;, const CSSValue&amp;);
  72     static LengthPoint convertObjectPosition(StyleResolver&amp;, const CSSValue&amp;);
  73     static OptionSet&lt;TextDecoration&gt; convertTextDecoration(StyleResolver&amp;, const CSSValue&amp;);
  74     template&lt;typename T&gt; static T convertNumber(StyleResolver&amp;, const CSSValue&amp;);
  75     template&lt;typename T&gt; static T convertNumberOrAuto(StyleResolver&amp;, const CSSValue&amp;);
  76     static short convertWebkitHyphenateLimitLines(StyleResolver&amp;, const CSSValue&amp;);
  77     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderImage(StyleResolver&amp;, CSSValue&amp;);
  78     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderMask(StyleResolver&amp;, CSSValue&amp;);
  79     template&lt;CSSPropertyID&gt; static RefPtr&lt;StyleImage&gt; convertStyleImage(StyleResolver&amp;, CSSValue&amp;);
  80     static TransformOperations convertTransform(StyleResolver&amp;, const CSSValue&amp;);
  81 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">  82     static StyleSupportedColorSchemes convertSupportedColorSchemes(StyleResolver&amp;, const CSSValue&amp;);</span>
  83 #endif
  84     static String convertString(StyleResolver&amp;, const CSSValue&amp;);
  85     static String convertStringOrAuto(StyleResolver&amp;, const CSSValue&amp;);
  86     static String convertStringOrNone(StyleResolver&amp;, const CSSValue&amp;);
  87     static OptionSet&lt;TextEmphasisPosition&gt; convertTextEmphasisPosition(StyleResolver&amp;, const CSSValue&amp;);
  88     static TextAlignMode convertTextAlign(StyleResolver&amp;, const CSSValue&amp;);
  89     static RefPtr&lt;ClipPathOperation&gt; convertClipPath(StyleResolver&amp;, const CSSValue&amp;);
  90     static Resize convertResize(StyleResolver&amp;, const CSSValue&amp;);
  91     static int convertMarqueeRepetition(StyleResolver&amp;, const CSSValue&amp;);
  92     static int convertMarqueeSpeed(StyleResolver&amp;, const CSSValue&amp;);
  93     static Ref&lt;QuotesData&gt; convertQuotes(StyleResolver&amp;, const CSSValue&amp;);
  94     static TextUnderlinePosition convertTextUnderlinePosition(StyleResolver&amp;, const CSSValue&amp;);
  95     static TextUnderlineOffset convertTextUnderlineOffset(StyleResolver&amp;, const CSSValue&amp;);
  96     static TextDecorationThickness convertTextDecorationThickness(StyleResolver&amp;, const CSSValue&amp;);
  97     static RefPtr&lt;StyleReflection&gt; convertReflection(StyleResolver&amp;, const CSSValue&amp;);
  98     static IntSize convertInitialLetter(StyleResolver&amp;, const CSSValue&amp;);
  99     static float convertTextStrokeWidth(StyleResolver&amp;, const CSSValue&amp;);
 100     static LineBoxContain convertLineBoxContain(StyleResolver&amp;, const CSSValue&amp;);
 101     static OptionSet&lt;TextDecorationSkip&gt; convertTextDecorationSkip(StyleResolver&amp;, const CSSValue&amp;);
 102     static RefPtr&lt;ShapeValue&gt; convertShapeValue(StyleResolver&amp;, CSSValue&amp;);
</pre>
<hr />
<pre>
 104     static ScrollSnapType convertScrollSnapType(StyleResolver&amp;, const CSSValue&amp;);
 105     static ScrollSnapAlign convertScrollSnapAlign(StyleResolver&amp;, const CSSValue&amp;);
 106 #endif
 107     static GridTrackSize convertGridTrackSize(StyleResolver&amp;, const CSSValue&amp;);
 108     static Vector&lt;GridTrackSize&gt; convertGridTrackSizeList(StyleResolver&amp;, const CSSValue&amp;);
 109     static Optional&lt;GridPosition&gt; convertGridPosition(StyleResolver&amp;, const CSSValue&amp;);
 110     static GridAutoFlow convertGridAutoFlow(StyleResolver&amp;, const CSSValue&amp;);
 111     static Optional&lt;Length&gt; convertWordSpacing(StyleResolver&amp;, const CSSValue&amp;);
 112     static Optional&lt;float&gt; convertPerspective(StyleResolver&amp;, const CSSValue&amp;);
 113     static Optional&lt;Length&gt; convertMarqueeIncrement(StyleResolver&amp;, const CSSValue&amp;);
 114     static Optional&lt;FilterOperations&gt; convertFilterOperations(StyleResolver&amp;, const CSSValue&amp;);
 115 #if PLATFORM(IOS_FAMILY)
 116     static bool convertTouchCallout(StyleResolver&amp;, const CSSValue&amp;);
 117 #endif
 118 #if ENABLE(TOUCH_EVENTS)
 119     static Color convertTapHighlightColor(StyleResolver&amp;, const CSSValue&amp;);
 120 #endif
 121 #if ENABLE(POINTER_EVENTS)
 122     static OptionSet&lt;TouchAction&gt; convertTouchAction(StyleResolver&amp;, const CSSValue&amp;);
 123 #endif
<span class="line-modified"> 124 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 125     static bool convertOverflowScrolling(StyleResolver&amp;, const CSSValue&amp;);
 126 #endif
 127     static FontFeatureSettings convertFontFeatureSettings(StyleResolver&amp;, const CSSValue&amp;);
 128     static FontSelectionValue convertFontWeightFromValue(const CSSValue&amp;);
 129     static FontSelectionValue convertFontStretchFromValue(const CSSValue&amp;);
 130     static Optional&lt;FontSelectionValue&gt; convertFontStyleFromValue(const CSSValue&amp;);
 131     static FontSelectionValue convertFontWeight(StyleResolver&amp;, const CSSValue&amp;);
 132     static FontSelectionValue convertFontStretch(StyleResolver&amp;, const CSSValue&amp;);
 133     static FontSelectionValue convertFontStyle(StyleResolver&amp;, const CSSValue&amp;);
 134 #if ENABLE(VARIATION_FONTS)
 135     static FontVariationSettings convertFontVariationSettings(StyleResolver&amp;, const CSSValue&amp;);
 136 #endif
 137     static SVGLengthValue convertSVGLengthValue(StyleResolver&amp;, const CSSValue&amp;);
 138     static Vector&lt;SVGLengthValue&gt; convertSVGLengthVector(StyleResolver&amp;, const CSSValue&amp;);
 139     static Vector&lt;SVGLengthValue&gt; convertStrokeDashArray(StyleResolver&amp;, const CSSValue&amp;);
 140     static PaintOrder convertPaintOrder(StyleResolver&amp;, const CSSValue&amp;);
 141     static float convertOpacity(StyleResolver&amp;, const CSSValue&amp;);
 142     static String convertSVGURIReference(StyleResolver&amp;, const CSSValue&amp;);
 143     static Color convertSVGColor(StyleResolver&amp;, const CSSValue&amp;);
 144     static StyleSelfAlignmentData convertSelfOrDefaultAlignmentData(StyleResolver&amp;, const CSSValue&amp;);
</pre>
<hr />
<pre>
 156     static OptionSet&lt;HangingPunctuation&gt; convertHangingPunctuation(StyleResolver&amp;, const CSSValue&amp;);
 157 
 158     static OptionSet&lt;SpeakAs&gt; convertSpeakAs(StyleResolver&amp;, const CSSValue&amp;);
 159 
 160     static Length convertPositionComponentX(StyleResolver&amp;, const CSSValue&amp;);
 161     static Length convertPositionComponentY(StyleResolver&amp;, const CSSValue&amp;);
 162 
 163     static GapLength convertGapLength(StyleResolver&amp;, const CSSValue&amp;);
 164 
 165 private:
 166     friend class StyleBuilderCustom;
 167 
 168     static Length convertToRadiusLength(CSSToLengthConversionData&amp;, const CSSPrimitiveValue&amp;);
 169     static OptionSet&lt;TextEmphasisPosition&gt; valueToEmphasisPosition(const CSSPrimitiveValue&amp;);
 170     static OptionSet&lt;TextDecorationSkip&gt; valueToDecorationSkip(const CSSPrimitiveValue&amp;);
 171 #if ENABLE(CSS_SCROLL_SNAP)
 172     static Length parseSnapCoordinate(StyleResolver&amp;, const CSSValue&amp;);
 173 #endif
 174 
 175 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 176     static void updateSupportedColorSchemes(const CSSPrimitiveValue&amp;, StyleSupportedColorSchemes&amp;);</span>
 177 #endif
 178 
 179     static Length convertTo100PercentMinusLength(const Length&amp;);
 180     template&lt;CSSValueID, CSSValueID&gt; static Length convertPositionComponent(StyleResolver&amp;, const CSSPrimitiveValue&amp;);
 181 
 182     static GridLength createGridTrackBreadth(const CSSPrimitiveValue&amp;, StyleResolver&amp;);
 183     static GridTrackSize createGridTrackSize(const CSSValue&amp;, StyleResolver&amp;);
 184     struct TracksData;
 185     static bool createGridTrackList(const CSSValue&amp;, TracksData&amp;, StyleResolver&amp;);
 186     static bool createGridPosition(const CSSValue&amp;, GridPosition&amp;);
 187     static void createImplicitNamedGridLinesFromGridArea(const NamedGridAreaMap&amp;, NamedGridLinesMap&amp;, GridTrackSizingDirection);
 188     static CSSToLengthConversionData csstoLengthConversionDataWithTextZoomFactor(StyleResolver&amp;);
 189 };
 190 
 191 inline Length StyleBuilderConverter::convertLength(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 192 {
 193     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 194     CSSToLengthConversionData conversionData = styleResolver.useSVGZoomRulesForLength() ?
 195         styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f)
 196         : styleResolver.state().cssToLengthConversionData();
</pre>
<hr />
<pre>
 237     case CSSValueWebkitFillAvailable:
 238         return Length(FillAvailable);
 239     case CSSValueFitContent:
 240     case CSSValueWebkitFitContent:
 241         return Length(FitContent);
 242     case CSSValueAuto:
 243         return Length(Auto);
 244     default:
 245         ASSERT_NOT_REACHED();
 246         return Length();
 247     }
 248 }
 249 
 250 inline Length StyleBuilderConverter::convertLengthMaxSizing(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 251 {
 252     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 253         return Length(Undefined);
 254     return convertLengthSizing(styleResolver, value);
 255 }
 256 








 257 template&lt;typename T&gt;
 258 inline T StyleBuilderConverter::convertComputedLength(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 259 {
 260     return downcast&lt;CSSPrimitiveValue&gt;(value).computeLength&lt;T&gt;(styleResolver.state().cssToLengthConversionData());
 261 }
 262 
 263 template&lt;typename T&gt;
 264 inline T StyleBuilderConverter::convertLineWidth(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 265 {
 266     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 267     switch (primitiveValue.valueID()) {
 268     case CSSValueThin:
 269         return 1;
 270     case CSSValueMedium:
 271         return 3;
 272     case CSSValueThick:
 273         return 5;
 274     case CSSValueInvalid: {
 275         // Any original result that was &gt;= 1 should not be allowed to fall below 1.
 276         // This keeps border lines from vanishing.
</pre>
<hr />
<pre>
 320 
 321     CSSToLengthConversionData conversionData = styleResolver.state().cssToLengthConversionData();
 322     LengthSize radius { convertToRadiusLength(conversionData, *pair-&gt;first()), convertToRadiusLength(conversionData, *pair-&gt;second()) };
 323 
 324     ASSERT(!radius.width.isNegative());
 325     ASSERT(!radius.height.isNegative());
 326     if (radius.width.isZero() || radius.height.isZero())
 327         return { { 0, Fixed }, { 0, Fixed } };
 328 
 329     return radius;
 330 }
 331 
 332 inline Length StyleBuilderConverter::convertTo100PercentMinusLength(const Length&amp; length)
 333 {
 334     if (length.isPercent())
 335         return Length(100 - length.value(), Percent);
 336 
 337     // Turn this into a calc expression: calc(100% - length)
 338     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; lengths;
 339     lengths.reserveInitialCapacity(2);
<span class="line-modified"> 340     lengths.uncheckedAppend(std::make_unique&lt;CalcExpressionLength&gt;(Length(100, Percent)));</span>
<span class="line-modified"> 341     lengths.uncheckedAppend(std::make_unique&lt;CalcExpressionLength&gt;(length));</span>
<span class="line-modified"> 342     auto op = std::make_unique&lt;CalcExpressionOperation&gt;(WTFMove(lengths), CalcOperator::Subtract);</span>
 343     return Length(CalculationValue::create(WTFMove(op), ValueRangeAll));
 344 }
 345 
 346 inline Length StyleBuilderConverter::convertPositionComponentX(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 347 {
 348     return convertPositionComponent&lt;CSSValueLeft, CSSValueRight&gt;(styleResolver, downcast&lt;CSSPrimitiveValue&gt;(value));
 349 }
 350 
 351 inline Length StyleBuilderConverter::convertPositionComponentY(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 352 {
 353     return convertPositionComponent&lt;CSSValueTop, CSSValueBottom&gt;(styleResolver, downcast&lt;CSSPrimitiveValue&gt;(value));
 354 }
 355 
 356 template&lt;CSSValueID cssValueFor0, CSSValueID cssValueFor100&gt;
 357 inline Length StyleBuilderConverter::convertPositionComponent(StyleResolver&amp; styleResolver, const CSSPrimitiveValue&amp; value)
 358 {
 359     Length length;
 360 
 361     auto* lengthValue = &amp;value;
 362     bool relativeToTrailingEdge = false;
</pre>
<hr />
<pre>
 448     NinePieceImage image;
 449     image.setMaskDefaults();
 450     styleResolver.styleMap()-&gt;mapNinePieceImage(property, &amp;value, image);
 451     return image;
 452 }
 453 
 454 template&lt;CSSPropertyID&gt;
 455 inline RefPtr&lt;StyleImage&gt; StyleBuilderConverter::convertStyleImage(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 456 {
 457     return styleResolver.styleImage(value);
 458 }
 459 
 460 inline TransformOperations StyleBuilderConverter::convertTransform(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 461 {
 462     TransformOperations operations;
 463     transformsForValue(value, styleResolver.state().cssToLengthConversionData(), operations);
 464     return operations;
 465 }
 466 
 467 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 468 inline void StyleBuilderConverter::updateSupportedColorSchemes(const CSSPrimitiveValue&amp; primitiveValue, StyleSupportedColorSchemes&amp; supportedColorSchemes)</span>
 469 {
 470     ASSERT(primitiveValue.isValueID());
 471 
 472     switch (primitiveValue.valueID()) {
 473     case CSSValueAuto:
<span class="line-modified"> 474         supportedColorSchemes = StyleSupportedColorSchemes();</span>
 475         break;
 476     case CSSValueOnly:
<span class="line-modified"> 477         supportedColorSchemes.setAllowsTransformations(false);</span>
 478         break;
 479     case CSSValueLight:
<span class="line-modified"> 480         supportedColorSchemes.add(ColorSchemes::Light);</span>
 481         break;
 482     case CSSValueDark:
<span class="line-modified"> 483         supportedColorSchemes.add(ColorSchemes::Dark);</span>
 484         break;
 485     default:
 486         // Unknown identifiers are allowed and ignored.
 487         break;
 488     }
 489 }
 490 
<span class="line-modified"> 491 inline StyleSupportedColorSchemes StyleBuilderConverter::convertSupportedColorSchemes(StyleResolver&amp;, const CSSValue&amp; value)</span>
 492 {
<span class="line-modified"> 493     StyleSupportedColorSchemes supportedColorSchemes;</span>
 494 
 495     if (is&lt;CSSValueList&gt;(value)) {
 496         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
<span class="line-modified"> 497             updateSupportedColorSchemes(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()), supportedColorSchemes);</span>
 498     } else if (is&lt;CSSPrimitiveValue&gt;(value))
<span class="line-modified"> 499         updateSupportedColorSchemes(downcast&lt;CSSPrimitiveValue&gt;(value), supportedColorSchemes);</span>
 500 
 501     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
<span class="line-modified"> 502     if (supportedColorSchemes.isOnly())</span>
<span class="line-modified"> 503         supportedColorSchemes.add(ColorSchemes::Light);</span>
 504 
<span class="line-modified"> 505     return supportedColorSchemes;</span>
 506 }
 507 #endif
 508 
 509 inline String StyleBuilderConverter::convertString(StyleResolver&amp;, const CSSValue&amp; value)
 510 {
 511     return downcast&lt;CSSPrimitiveValue&gt;(value).stringValue();
 512 }
 513 
 514 inline String StyleBuilderConverter::convertStringOrAuto(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 515 {
 516     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 517         return nullAtom();
 518     return convertString(styleResolver, value);
 519 }
 520 
 521 inline String StyleBuilderConverter::convertStringOrNone(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 522 {
 523     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 524         return nullAtom();
 525     return convertString(styleResolver, value);
</pre>
<hr />
<pre>
 562     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 563     ASSERT(primitiveValue.isValueID());
 564 
 565     if (primitiveValue.valueID() != CSSValueWebkitMatchParent)
 566         return primitiveValue;
 567 
 568     auto* parentStyle = styleResolver.parentStyle();
 569     if (parentStyle-&gt;textAlign() == TextAlignMode::Start)
 570         return parentStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Left : TextAlignMode::Right;
 571     if (parentStyle-&gt;textAlign() == TextAlignMode::End)
 572         return parentStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Right : TextAlignMode::Left;
 573     return parentStyle-&gt;textAlign();
 574 }
 575 
 576 inline RefPtr&lt;ClipPathOperation&gt; StyleBuilderConverter::convertClipPath(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 577 {
 578     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 579         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 580         if (primitiveValue.primitiveType() == CSSPrimitiveValue::CSS_URI) {
 581             String cssURLValue = primitiveValue.stringValue();
<span class="line-modified"> 582             URL url = styleResolver.document().completeURL(cssURLValue);</span>
 583             // FIXME: It doesn&#39;t work with external SVG references (see https://bugs.webkit.org/show_bug.cgi?id=126133)
<span class="line-modified"> 584             return ReferenceClipPathOperation::create(cssURLValue, url.fragmentIdentifier());</span>
 585         }
 586         ASSERT(primitiveValue.valueID() == CSSValueNone);
 587         return nullptr;
 588     }
 589 
 590     CSSBoxType referenceBox = CSSBoxType::BoxMissing;
 591     RefPtr&lt;ClipPathOperation&gt; operation;
 592 
 593     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
 594         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
 595         if (primitiveValue.isShape()) {
 596             ASSERT(!operation);
 597             operation = ShapeClipPathOperation::create(basicShapeForValue(styleResolver.state().cssToLengthConversionData(), *primitiveValue.shapeValue()));
 598         } else {
 599             ASSERT(primitiveValue.valueID() == CSSValueContentBox
 600                 || primitiveValue.valueID() == CSSValueBorderBox
 601                 || primitiveValue.valueID() == CSSValuePaddingBox
 602                 || primitiveValue.valueID() == CSSValueMarginBox
 603                 || primitiveValue.valueID() == CSSValueFillBox
 604                 || primitiveValue.valueID() == CSSValueStrokeBox
</pre>
<hr />
<pre>
 729 }
 730 
 731 inline RefPtr&lt;StyleReflection&gt; StyleBuilderConverter::convertReflection(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 732 {
 733     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 734         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 735         return nullptr;
 736     }
 737 
 738     auto&amp; reflectValue = downcast&lt;CSSReflectValue&gt;(value);
 739 
 740     auto reflection = StyleReflection::create();
 741     reflection-&gt;setDirection(reflectValue.direction());
 742     reflection-&gt;setOffset(reflectValue.offset().convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData()));
 743 
 744     NinePieceImage mask;
 745     mask.setMaskDefaults();
 746     styleResolver.styleMap()-&gt;mapNinePieceImage(CSSPropertyWebkitBoxReflect, reflectValue.mask(), mask);
 747     reflection-&gt;setMask(mask);
 748 
<span class="line-modified"> 749     return WTFMove(reflection);</span>
 750 }
 751 
 752 inline IntSize StyleBuilderConverter::convertInitialLetter(StyleResolver&amp;, const CSSValue&amp; value)
 753 {
 754     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 755 
 756     if (primitiveValue.valueID() == CSSValueNormal)
 757         return IntSize();
 758 
 759     Pair* pair = primitiveValue.pairValue();
 760     ASSERT(pair);
 761     ASSERT(pair-&gt;first());
 762     ASSERT(pair-&gt;second());
 763 
 764     return IntSize(pair-&gt;first()-&gt;intValue(), pair-&gt;second()-&gt;intValue());
 765 }
 766 
 767 inline float StyleBuilderConverter::convertTextStrokeWidth(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 768 {
 769     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
</pre>
<hr />
<pre>
 972     Vector&lt;GridTrackSize&gt; m_trackSizes;
 973     NamedGridLinesMap m_namedGridLines;
 974     OrderedNamedGridLinesMap m_orderedNamedGridLines;
 975     Vector&lt;GridTrackSize&gt; m_autoRepeatTrackSizes;
 976     NamedGridLinesMap m_autoRepeatNamedGridLines;
 977     OrderedNamedGridLinesMap m_autoRepeatOrderedNamedGridLines;
 978     unsigned m_autoRepeatInsertionPoint { RenderStyle::initialGridAutoRepeatInsertionPoint() };
 979     AutoRepeatType m_autoRepeatType { RenderStyle::initialGridAutoRepeatType() };
 980 };
 981 
 982 inline bool StyleBuilderConverter::createGridTrackList(const CSSValue&amp; value, TracksData&amp; tracksData, StyleResolver&amp; styleResolver)
 983 {
 984     // Handle &#39;none&#39;.
 985     if (is&lt;CSSPrimitiveValue&gt;(value))
 986         return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
 987 
 988     if (!is&lt;CSSValueList&gt;(value))
 989         return false;
 990 
 991     unsigned currentNamedGridLine = 0;
<span class="line-modified"> 992     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {</span>
<span class="line-modified"> 993         if (is&lt;CSSGridLineNamesValue&gt;(currentValue)) {</span>
<span class="line-modified"> 994             createGridLineNamesList(currentValue.get(), currentNamedGridLine, tracksData.m_namedGridLines, tracksData.m_orderedNamedGridLines);</span>
<span class="line-modified"> 995             continue;</span>


 996         }

 997 

 998         if (is&lt;CSSGridAutoRepeatValue&gt;(currentValue)) {
 999             ASSERT(tracksData.m_autoRepeatTrackSizes.isEmpty());
1000             unsigned autoRepeatIndex = 0;
1001             CSSValueID autoRepeatID = downcast&lt;CSSGridAutoRepeatValue&gt;(currentValue.get()).autoRepeatID();
1002             ASSERT(autoRepeatID == CSSValueAutoFill || autoRepeatID == CSSValueAutoFit);
1003             tracksData.m_autoRepeatType = autoRepeatID == CSSValueAutoFill ? AutoRepeatType::Fill : AutoRepeatType::Fit;
1004             for (auto&amp; autoRepeatValue : downcast&lt;CSSValueList&gt;(currentValue.get())) {
1005                 if (is&lt;CSSGridLineNamesValue&gt;(autoRepeatValue)) {
1006                     createGridLineNamesList(autoRepeatValue.get(), autoRepeatIndex, tracksData.m_autoRepeatNamedGridLines, tracksData.m_autoRepeatOrderedNamedGridLines);
1007                     continue;
1008                 }
1009                 ++autoRepeatIndex;
1010                 tracksData.m_autoRepeatTrackSizes.append(createGridTrackSize(autoRepeatValue.get(), styleResolver));
1011             }
1012             tracksData.m_autoRepeatInsertionPoint = currentNamedGridLine++;
1013             continue;
1014         }
1015 
<span class="line-modified">1016         ++currentNamedGridLine;</span>
<span class="line-modified">1017         tracksData.m_trackSizes.append(createGridTrackSize(currentValue, styleResolver));</span>








1018     }
1019 
1020     // The parser should have rejected any &lt;track-list&gt; without any &lt;track-size&gt; as
1021     // this is not conformant to the syntax.
1022     ASSERT(!tracksData.m_trackSizes.isEmpty() || !tracksData.m_autoRepeatTrackSizes.isEmpty());
1023     return true;
1024 }
1025 
1026 inline bool StyleBuilderConverter::createGridPosition(const CSSValue&amp; value, GridPosition&amp; position)
1027 {
1028     // We accept the specification&#39;s grammar:
1029     // auto | &lt;custom-ident&gt; | [ &lt;integer&gt; &amp;&amp; &lt;custom-ident&gt;? ] | [ span &amp;&amp; [ &lt;integer&gt; || &lt;custom-ident&gt; ] ]
1030     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1031         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1032         // We translate &lt;ident&gt; to &lt;string&gt; during parsing as it makes handling it simpler.
1033         if (primitiveValue.isString()) {
1034             position.setNamedGridArea(primitiveValue.stringValue());
1035             return true;
1036         }
1037 
</pre>
<hr />
<pre>
1082             startVector.append(areaSpan.startLine());
1083             std::sort(startVector.begin(), startVector.end());
1084         }
1085         {
1086             auto&amp; endVector = namedGridLines.add(area.key + &quot;-end&quot;, Vector&lt;unsigned&gt;()).iterator-&gt;value;
1087             endVector.append(areaSpan.endLine());
1088             std::sort(endVector.begin(), endVector.end());
1089         }
1090     }
1091 }
1092 
1093 inline Vector&lt;GridTrackSize&gt; StyleBuilderConverter::convertGridTrackSizeList(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1094 {
1095     ASSERT(value.isValueList());
1096     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1097     Vector&lt;GridTrackSize&gt; trackSizes;
1098     trackSizes.reserveInitialCapacity(valueList.length());
1099     for (auto&amp; currValue : valueList) {
1100         ASSERT(!currValue-&gt;isGridLineNamesValue());
1101         ASSERT(!currValue-&gt;isGridAutoRepeatValue());

1102         trackSizes.uncheckedAppend(convertGridTrackSize(styleResolver, currValue));
1103     }
1104     return trackSizes;
1105 }
1106 
1107 inline GridTrackSize StyleBuilderConverter::convertGridTrackSize(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1108 {
1109     return createGridTrackSize(value, styleResolver);
1110 }
1111 
1112 inline Optional&lt;GridPosition&gt; StyleBuilderConverter::convertGridPosition(StyleResolver&amp;, const CSSValue&amp; value)
1113 {
1114     GridPosition gridPosition;
1115     if (createGridPosition(value, gridPosition))
1116         return gridPosition;
1117     return WTF::nullopt;
1118 }
1119 
1120 inline GridAutoFlow StyleBuilderConverter::convertGridAutoFlow(StyleResolver&amp;, const CSSValue&amp; value)
1121 {
</pre>
<hr />
<pre>
1356 {
1357     if (is&lt;CSSPrimitiveValue&gt;(value))
1358         return downcast&lt;CSSPrimitiveValue&gt;(value);
1359 
1360     if (is&lt;CSSValueList&gt;(value)) {
1361         OptionSet&lt;TouchAction&gt; touchActions;
1362         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
1363             auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
1364             auto primitiveValueID = primitiveValue.valueID();
1365             if (primitiveValueID != CSSValuePanX &amp;&amp; primitiveValueID != CSSValuePanY &amp;&amp; primitiveValueID != CSSValuePinchZoom)
1366                 return RenderStyle::initialTouchActions();
1367             touchActions.add(primitiveValue);
1368         }
1369         return touchActions;
1370     }
1371 
1372     return RenderStyle::initialTouchActions();
1373 }
1374 #endif
1375 
<span class="line-modified">1376 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
1377 inline bool StyleBuilderConverter::convertOverflowScrolling(StyleResolver&amp;, const CSSValue&amp; value)
1378 {
1379     return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueTouch;
1380 }
1381 #endif
1382 
1383 inline SVGLengthValue StyleBuilderConverter::convertSVGLengthValue(StyleResolver&amp;, const CSSValue&amp; value)
1384 {
1385     return SVGLengthValue::fromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1386 }
1387 
1388 inline Vector&lt;SVGLengthValue&gt; StyleBuilderConverter::convertSVGLengthVector(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1389 {
1390     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1391 
1392     Vector&lt;SVGLengthValue&gt; svgLengths;
1393     svgLengths.reserveInitialCapacity(valueList.length());
1394     for (auto&amp; item : valueList)
1395         svgLengths.uncheckedAppend(convertSVGLengthValue(styleResolver, item));
1396 
</pre>
<hr />
<pre>
1549     ASSERT(is&lt;CSSValueList&gt;(value));
1550     for (const CSSValue&amp; v : downcast&lt;CSSValueList&gt;(value)) {
1551         switch (downcast&lt;CSSPrimitiveValue&gt;(v).valueID()) {
1552         case CSSValueWeight:
1553             result |= FontSynthesisWeight;
1554             break;
1555         case CSSValueStyle:
1556             result |= FontSynthesisStyle;
1557             break;
1558         case CSSValueSmallCaps:
1559             result |= FontSynthesisSmallCaps;
1560             break;
1561         default:
1562             ASSERT_NOT_REACHED();
1563             break;
1564         }
1565     }
1566 
1567     return result;
1568 }
<span class="line-removed">1569 </span>
<span class="line-removed">1570 inline BreakBetween StyleBuilderConverter::convertPageBreakBetween(StyleResolver&amp;, const CSSValue&amp; value)</span>
<span class="line-removed">1571 {</span>
<span class="line-removed">1572     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);</span>
<span class="line-removed">1573     if (primitiveValue.valueID() == CSSValueAlways)</span>
<span class="line-removed">1574         return BreakBetween::Page;</span>
<span class="line-removed">1575     if (primitiveValue.valueID() == CSSValueAvoid)</span>
<span class="line-removed">1576         return BreakBetween::AvoidPage;</span>
<span class="line-removed">1577     return primitiveValue;</span>
<span class="line-removed">1578 }</span>
<span class="line-removed">1579 </span>
<span class="line-removed">1580 inline BreakInside StyleBuilderConverter::convertPageBreakInside(StyleResolver&amp;, const CSSValue&amp; value)</span>
<span class="line-removed">1581 {</span>
<span class="line-removed">1582     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);</span>
<span class="line-removed">1583     if (primitiveValue.valueID() == CSSValueAvoid)</span>
<span class="line-removed">1584         return BreakInside::AvoidPage;</span>
<span class="line-removed">1585     return primitiveValue;</span>
<span class="line-removed">1586 }</span>
<span class="line-removed">1587 </span>
<span class="line-removed">1588 inline BreakBetween StyleBuilderConverter::convertColumnBreakBetween(StyleResolver&amp;, const CSSValue&amp; value)</span>
<span class="line-removed">1589 {</span>
<span class="line-removed">1590     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);</span>
<span class="line-removed">1591     if (primitiveValue.valueID() == CSSValueAlways)</span>
<span class="line-removed">1592         return BreakBetween::Column;</span>
<span class="line-removed">1593     if (primitiveValue.valueID() == CSSValueAvoid)</span>
<span class="line-removed">1594         return BreakBetween::AvoidColumn;</span>
<span class="line-removed">1595     return primitiveValue;</span>
<span class="line-removed">1596 }</span>
<span class="line-removed">1597 </span>
<span class="line-removed">1598 inline BreakInside StyleBuilderConverter::convertColumnBreakInside(StyleResolver&amp;, const CSSValue&amp; value)</span>
<span class="line-removed">1599 {</span>
<span class="line-removed">1600     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);</span>
<span class="line-removed">1601     if (primitiveValue.valueID() == CSSValueAvoid)</span>
<span class="line-removed">1602         return BreakInside::AvoidColumn;</span>
<span class="line-removed">1603     return primitiveValue;</span>
<span class="line-removed">1604 }</span>
1605 
1606 inline OptionSet&lt;SpeakAs&gt; StyleBuilderConverter::convertSpeakAs(StyleResolver&amp;, const CSSValue&amp; value)
1607 {
1608     auto result = RenderStyle::initialSpeakAs();
1609     if (is&lt;CSSValueList&gt;(value)) {
1610         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1611             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1612     }
1613     return result;
1614 }
1615 
1616 inline OptionSet&lt;HangingPunctuation&gt; StyleBuilderConverter::convertHangingPunctuation(StyleResolver&amp;, const CSSValue&amp; value)
1617 {
1618     auto result = RenderStyle::initialHangingPunctuation();
1619     if (is&lt;CSSValueList&gt;(value)) {
1620         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1621             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1622     }
1623     return result;
1624 }
</pre>
</td>
<td>
<hr />
<pre>
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;BasicShapeFunctions.h&quot;
  30 #include &quot;CSSCalculationValue.h&quot;
  31 #include &quot;CSSContentDistributionValue.h&quot;
  32 #include &quot;CSSFontFeatureValue.h&quot;
  33 #include &quot;CSSFontStyleValue.h&quot;
  34 #include &quot;CSSFontVariationValue.h&quot;
  35 #include &quot;CSSFunctionValue.h&quot;
  36 #include &quot;CSSGridAutoRepeatValue.h&quot;
<span class="line-added">  37 #include &quot;CSSGridIntegerRepeatValue.h&quot;</span>
  38 #include &quot;CSSGridLineNamesValue.h&quot;
  39 #include &quot;CSSImageGeneratorValue.h&quot;
  40 #include &quot;CSSImageSetValue.h&quot;
  41 #include &quot;CSSImageValue.h&quot;
  42 #include &quot;CSSPrimitiveValue.h&quot;
  43 #include &quot;CSSPrimitiveValueMappings.h&quot;
  44 #include &quot;CSSReflectValue.h&quot;
  45 #include &quot;FontSelectionValueInlines.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;GridPositionsResolver.h&quot;
  48 #include &quot;Length.h&quot;
  49 #include &quot;Pair.h&quot;
  50 #include &quot;QuotesData.h&quot;
  51 #include &quot;RuntimeEnabledFeatures.h&quot;
  52 #include &quot;SVGURIReference.h&quot;
  53 #include &quot;Settings.h&quot;
  54 #include &quot;StyleResolver.h&quot;
  55 #include &quot;StyleScrollSnapPoints.h&quot;
<span class="line-added">  56 #include &quot;TabSize.h&quot;</span>
  57 #include &quot;TouchAction.h&quot;
  58 #include &quot;TransformFunctions.h&quot;
  59 #include &lt;wtf/Optional.h&gt;
  60 
  61 namespace WebCore {
  62 
  63 // Note that we assume the CSS parser only allows valid CSSValue types.
  64 class StyleBuilderConverter {
  65 public:
  66     static Length convertLength(const StyleResolver&amp;, const CSSValue&amp;);
  67     static Length convertLengthOrAuto(const StyleResolver&amp;, const CSSValue&amp;);
  68     static Length convertLengthSizing(const StyleResolver&amp;, const CSSValue&amp;);
  69     static Length convertLengthMaxSizing(const StyleResolver&amp;, const CSSValue&amp;);
<span class="line-added">  70     static TabSize convertTabSize(const StyleResolver&amp;, const CSSValue&amp;);</span>
  71     template&lt;typename T&gt; static T convertComputedLength(StyleResolver&amp;, const CSSValue&amp;);
  72     template&lt;typename T&gt; static T convertLineWidth(StyleResolver&amp;, const CSSValue&amp;);
  73     static float convertSpacing(StyleResolver&amp;, const CSSValue&amp;);
  74     static LengthSize convertRadius(StyleResolver&amp;, const CSSValue&amp;);
  75     static LengthPoint convertObjectPosition(StyleResolver&amp;, const CSSValue&amp;);
  76     static OptionSet&lt;TextDecoration&gt; convertTextDecoration(StyleResolver&amp;, const CSSValue&amp;);
  77     template&lt;typename T&gt; static T convertNumber(StyleResolver&amp;, const CSSValue&amp;);
  78     template&lt;typename T&gt; static T convertNumberOrAuto(StyleResolver&amp;, const CSSValue&amp;);
  79     static short convertWebkitHyphenateLimitLines(StyleResolver&amp;, const CSSValue&amp;);
  80     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderImage(StyleResolver&amp;, CSSValue&amp;);
  81     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderMask(StyleResolver&amp;, CSSValue&amp;);
  82     template&lt;CSSPropertyID&gt; static RefPtr&lt;StyleImage&gt; convertStyleImage(StyleResolver&amp;, CSSValue&amp;);
  83     static TransformOperations convertTransform(StyleResolver&amp;, const CSSValue&amp;);
  84 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">  85     static StyleColorScheme convertColorScheme(StyleResolver&amp;, const CSSValue&amp;);</span>
  86 #endif
  87     static String convertString(StyleResolver&amp;, const CSSValue&amp;);
  88     static String convertStringOrAuto(StyleResolver&amp;, const CSSValue&amp;);
  89     static String convertStringOrNone(StyleResolver&amp;, const CSSValue&amp;);
  90     static OptionSet&lt;TextEmphasisPosition&gt; convertTextEmphasisPosition(StyleResolver&amp;, const CSSValue&amp;);
  91     static TextAlignMode convertTextAlign(StyleResolver&amp;, const CSSValue&amp;);
  92     static RefPtr&lt;ClipPathOperation&gt; convertClipPath(StyleResolver&amp;, const CSSValue&amp;);
  93     static Resize convertResize(StyleResolver&amp;, const CSSValue&amp;);
  94     static int convertMarqueeRepetition(StyleResolver&amp;, const CSSValue&amp;);
  95     static int convertMarqueeSpeed(StyleResolver&amp;, const CSSValue&amp;);
  96     static Ref&lt;QuotesData&gt; convertQuotes(StyleResolver&amp;, const CSSValue&amp;);
  97     static TextUnderlinePosition convertTextUnderlinePosition(StyleResolver&amp;, const CSSValue&amp;);
  98     static TextUnderlineOffset convertTextUnderlineOffset(StyleResolver&amp;, const CSSValue&amp;);
  99     static TextDecorationThickness convertTextDecorationThickness(StyleResolver&amp;, const CSSValue&amp;);
 100     static RefPtr&lt;StyleReflection&gt; convertReflection(StyleResolver&amp;, const CSSValue&amp;);
 101     static IntSize convertInitialLetter(StyleResolver&amp;, const CSSValue&amp;);
 102     static float convertTextStrokeWidth(StyleResolver&amp;, const CSSValue&amp;);
 103     static LineBoxContain convertLineBoxContain(StyleResolver&amp;, const CSSValue&amp;);
 104     static OptionSet&lt;TextDecorationSkip&gt; convertTextDecorationSkip(StyleResolver&amp;, const CSSValue&amp;);
 105     static RefPtr&lt;ShapeValue&gt; convertShapeValue(StyleResolver&amp;, CSSValue&amp;);
</pre>
<hr />
<pre>
 107     static ScrollSnapType convertScrollSnapType(StyleResolver&amp;, const CSSValue&amp;);
 108     static ScrollSnapAlign convertScrollSnapAlign(StyleResolver&amp;, const CSSValue&amp;);
 109 #endif
 110     static GridTrackSize convertGridTrackSize(StyleResolver&amp;, const CSSValue&amp;);
 111     static Vector&lt;GridTrackSize&gt; convertGridTrackSizeList(StyleResolver&amp;, const CSSValue&amp;);
 112     static Optional&lt;GridPosition&gt; convertGridPosition(StyleResolver&amp;, const CSSValue&amp;);
 113     static GridAutoFlow convertGridAutoFlow(StyleResolver&amp;, const CSSValue&amp;);
 114     static Optional&lt;Length&gt; convertWordSpacing(StyleResolver&amp;, const CSSValue&amp;);
 115     static Optional&lt;float&gt; convertPerspective(StyleResolver&amp;, const CSSValue&amp;);
 116     static Optional&lt;Length&gt; convertMarqueeIncrement(StyleResolver&amp;, const CSSValue&amp;);
 117     static Optional&lt;FilterOperations&gt; convertFilterOperations(StyleResolver&amp;, const CSSValue&amp;);
 118 #if PLATFORM(IOS_FAMILY)
 119     static bool convertTouchCallout(StyleResolver&amp;, const CSSValue&amp;);
 120 #endif
 121 #if ENABLE(TOUCH_EVENTS)
 122     static Color convertTapHighlightColor(StyleResolver&amp;, const CSSValue&amp;);
 123 #endif
 124 #if ENABLE(POINTER_EVENTS)
 125     static OptionSet&lt;TouchAction&gt; convertTouchAction(StyleResolver&amp;, const CSSValue&amp;);
 126 #endif
<span class="line-modified"> 127 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
 128     static bool convertOverflowScrolling(StyleResolver&amp;, const CSSValue&amp;);
 129 #endif
 130     static FontFeatureSettings convertFontFeatureSettings(StyleResolver&amp;, const CSSValue&amp;);
 131     static FontSelectionValue convertFontWeightFromValue(const CSSValue&amp;);
 132     static FontSelectionValue convertFontStretchFromValue(const CSSValue&amp;);
 133     static Optional&lt;FontSelectionValue&gt; convertFontStyleFromValue(const CSSValue&amp;);
 134     static FontSelectionValue convertFontWeight(StyleResolver&amp;, const CSSValue&amp;);
 135     static FontSelectionValue convertFontStretch(StyleResolver&amp;, const CSSValue&amp;);
 136     static FontSelectionValue convertFontStyle(StyleResolver&amp;, const CSSValue&amp;);
 137 #if ENABLE(VARIATION_FONTS)
 138     static FontVariationSettings convertFontVariationSettings(StyleResolver&amp;, const CSSValue&amp;);
 139 #endif
 140     static SVGLengthValue convertSVGLengthValue(StyleResolver&amp;, const CSSValue&amp;);
 141     static Vector&lt;SVGLengthValue&gt; convertSVGLengthVector(StyleResolver&amp;, const CSSValue&amp;);
 142     static Vector&lt;SVGLengthValue&gt; convertStrokeDashArray(StyleResolver&amp;, const CSSValue&amp;);
 143     static PaintOrder convertPaintOrder(StyleResolver&amp;, const CSSValue&amp;);
 144     static float convertOpacity(StyleResolver&amp;, const CSSValue&amp;);
 145     static String convertSVGURIReference(StyleResolver&amp;, const CSSValue&amp;);
 146     static Color convertSVGColor(StyleResolver&amp;, const CSSValue&amp;);
 147     static StyleSelfAlignmentData convertSelfOrDefaultAlignmentData(StyleResolver&amp;, const CSSValue&amp;);
</pre>
<hr />
<pre>
 159     static OptionSet&lt;HangingPunctuation&gt; convertHangingPunctuation(StyleResolver&amp;, const CSSValue&amp;);
 160 
 161     static OptionSet&lt;SpeakAs&gt; convertSpeakAs(StyleResolver&amp;, const CSSValue&amp;);
 162 
 163     static Length convertPositionComponentX(StyleResolver&amp;, const CSSValue&amp;);
 164     static Length convertPositionComponentY(StyleResolver&amp;, const CSSValue&amp;);
 165 
 166     static GapLength convertGapLength(StyleResolver&amp;, const CSSValue&amp;);
 167 
 168 private:
 169     friend class StyleBuilderCustom;
 170 
 171     static Length convertToRadiusLength(CSSToLengthConversionData&amp;, const CSSPrimitiveValue&amp;);
 172     static OptionSet&lt;TextEmphasisPosition&gt; valueToEmphasisPosition(const CSSPrimitiveValue&amp;);
 173     static OptionSet&lt;TextDecorationSkip&gt; valueToDecorationSkip(const CSSPrimitiveValue&amp;);
 174 #if ENABLE(CSS_SCROLL_SNAP)
 175     static Length parseSnapCoordinate(StyleResolver&amp;, const CSSValue&amp;);
 176 #endif
 177 
 178 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 179     static void updateColorScheme(const CSSPrimitiveValue&amp;, StyleColorScheme&amp;);</span>
 180 #endif
 181 
 182     static Length convertTo100PercentMinusLength(const Length&amp;);
 183     template&lt;CSSValueID, CSSValueID&gt; static Length convertPositionComponent(StyleResolver&amp;, const CSSPrimitiveValue&amp;);
 184 
 185     static GridLength createGridTrackBreadth(const CSSPrimitiveValue&amp;, StyleResolver&amp;);
 186     static GridTrackSize createGridTrackSize(const CSSValue&amp;, StyleResolver&amp;);
 187     struct TracksData;
 188     static bool createGridTrackList(const CSSValue&amp;, TracksData&amp;, StyleResolver&amp;);
 189     static bool createGridPosition(const CSSValue&amp;, GridPosition&amp;);
 190     static void createImplicitNamedGridLinesFromGridArea(const NamedGridAreaMap&amp;, NamedGridLinesMap&amp;, GridTrackSizingDirection);
 191     static CSSToLengthConversionData csstoLengthConversionDataWithTextZoomFactor(StyleResolver&amp;);
 192 };
 193 
 194 inline Length StyleBuilderConverter::convertLength(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 195 {
 196     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 197     CSSToLengthConversionData conversionData = styleResolver.useSVGZoomRulesForLength() ?
 198         styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f)
 199         : styleResolver.state().cssToLengthConversionData();
</pre>
<hr />
<pre>
 240     case CSSValueWebkitFillAvailable:
 241         return Length(FillAvailable);
 242     case CSSValueFitContent:
 243     case CSSValueWebkitFitContent:
 244         return Length(FitContent);
 245     case CSSValueAuto:
 246         return Length(Auto);
 247     default:
 248         ASSERT_NOT_REACHED();
 249         return Length();
 250     }
 251 }
 252 
 253 inline Length StyleBuilderConverter::convertLengthMaxSizing(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 254 {
 255     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 256         return Length(Undefined);
 257     return convertLengthSizing(styleResolver, value);
 258 }
 259 
<span class="line-added"> 260 inline TabSize StyleBuilderConverter::convertTabSize(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)</span>
<span class="line-added"> 261 {</span>
<span class="line-added"> 262     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);</span>
<span class="line-added"> 263     if (primitiveValue.isNumber())</span>
<span class="line-added"> 264         return TabSize(primitiveValue.floatValue(), SpaceValueType);</span>
<span class="line-added"> 265     return TabSize(primitiveValue.computeLength&lt;float&gt;(styleResolver.state().cssToLengthConversionData()), LengthValueType);</span>
<span class="line-added"> 266 }</span>
<span class="line-added"> 267 </span>
 268 template&lt;typename T&gt;
 269 inline T StyleBuilderConverter::convertComputedLength(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 270 {
 271     return downcast&lt;CSSPrimitiveValue&gt;(value).computeLength&lt;T&gt;(styleResolver.state().cssToLengthConversionData());
 272 }
 273 
 274 template&lt;typename T&gt;
 275 inline T StyleBuilderConverter::convertLineWidth(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 276 {
 277     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 278     switch (primitiveValue.valueID()) {
 279     case CSSValueThin:
 280         return 1;
 281     case CSSValueMedium:
 282         return 3;
 283     case CSSValueThick:
 284         return 5;
 285     case CSSValueInvalid: {
 286         // Any original result that was &gt;= 1 should not be allowed to fall below 1.
 287         // This keeps border lines from vanishing.
</pre>
<hr />
<pre>
 331 
 332     CSSToLengthConversionData conversionData = styleResolver.state().cssToLengthConversionData();
 333     LengthSize radius { convertToRadiusLength(conversionData, *pair-&gt;first()), convertToRadiusLength(conversionData, *pair-&gt;second()) };
 334 
 335     ASSERT(!radius.width.isNegative());
 336     ASSERT(!radius.height.isNegative());
 337     if (radius.width.isZero() || radius.height.isZero())
 338         return { { 0, Fixed }, { 0, Fixed } };
 339 
 340     return radius;
 341 }
 342 
 343 inline Length StyleBuilderConverter::convertTo100PercentMinusLength(const Length&amp; length)
 344 {
 345     if (length.isPercent())
 346         return Length(100 - length.value(), Percent);
 347 
 348     // Turn this into a calc expression: calc(100% - length)
 349     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; lengths;
 350     lengths.reserveInitialCapacity(2);
<span class="line-modified"> 351     lengths.uncheckedAppend(makeUnique&lt;CalcExpressionLength&gt;(Length(100, Percent)));</span>
<span class="line-modified"> 352     lengths.uncheckedAppend(makeUnique&lt;CalcExpressionLength&gt;(length));</span>
<span class="line-modified"> 353     auto op = makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(lengths), CalcOperator::Subtract);</span>
 354     return Length(CalculationValue::create(WTFMove(op), ValueRangeAll));
 355 }
 356 
 357 inline Length StyleBuilderConverter::convertPositionComponentX(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 358 {
 359     return convertPositionComponent&lt;CSSValueLeft, CSSValueRight&gt;(styleResolver, downcast&lt;CSSPrimitiveValue&gt;(value));
 360 }
 361 
 362 inline Length StyleBuilderConverter::convertPositionComponentY(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 363 {
 364     return convertPositionComponent&lt;CSSValueTop, CSSValueBottom&gt;(styleResolver, downcast&lt;CSSPrimitiveValue&gt;(value));
 365 }
 366 
 367 template&lt;CSSValueID cssValueFor0, CSSValueID cssValueFor100&gt;
 368 inline Length StyleBuilderConverter::convertPositionComponent(StyleResolver&amp; styleResolver, const CSSPrimitiveValue&amp; value)
 369 {
 370     Length length;
 371 
 372     auto* lengthValue = &amp;value;
 373     bool relativeToTrailingEdge = false;
</pre>
<hr />
<pre>
 459     NinePieceImage image;
 460     image.setMaskDefaults();
 461     styleResolver.styleMap()-&gt;mapNinePieceImage(property, &amp;value, image);
 462     return image;
 463 }
 464 
 465 template&lt;CSSPropertyID&gt;
 466 inline RefPtr&lt;StyleImage&gt; StyleBuilderConverter::convertStyleImage(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 467 {
 468     return styleResolver.styleImage(value);
 469 }
 470 
 471 inline TransformOperations StyleBuilderConverter::convertTransform(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 472 {
 473     TransformOperations operations;
 474     transformsForValue(value, styleResolver.state().cssToLengthConversionData(), operations);
 475     return operations;
 476 }
 477 
 478 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 479 inline void StyleBuilderConverter::updateColorScheme(const CSSPrimitiveValue&amp; primitiveValue, StyleColorScheme&amp; colorScheme)</span>
 480 {
 481     ASSERT(primitiveValue.isValueID());
 482 
 483     switch (primitiveValue.valueID()) {
 484     case CSSValueAuto:
<span class="line-modified"> 485         colorScheme = StyleColorScheme();</span>
 486         break;
 487     case CSSValueOnly:
<span class="line-modified"> 488         colorScheme.setAllowsTransformations(false);</span>
 489         break;
 490     case CSSValueLight:
<span class="line-modified"> 491         colorScheme.add(ColorScheme::Light);</span>
 492         break;
 493     case CSSValueDark:
<span class="line-modified"> 494         colorScheme.add(ColorScheme::Dark);</span>
 495         break;
 496     default:
 497         // Unknown identifiers are allowed and ignored.
 498         break;
 499     }
 500 }
 501 
<span class="line-modified"> 502 inline StyleColorScheme StyleBuilderConverter::convertColorScheme(StyleResolver&amp;, const CSSValue&amp; value)</span>
 503 {
<span class="line-modified"> 504     StyleColorScheme colorScheme;</span>
 505 
 506     if (is&lt;CSSValueList&gt;(value)) {
 507         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
<span class="line-modified"> 508             updateColorScheme(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()), colorScheme);</span>
 509     } else if (is&lt;CSSPrimitiveValue&gt;(value))
<span class="line-modified"> 510         updateColorScheme(downcast&lt;CSSPrimitiveValue&gt;(value), colorScheme);</span>
 511 
 512     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
<span class="line-modified"> 513     if (colorScheme.isOnly())</span>
<span class="line-modified"> 514         colorScheme.add(ColorScheme::Light);</span>
 515 
<span class="line-modified"> 516     return colorScheme;</span>
 517 }
 518 #endif
 519 
 520 inline String StyleBuilderConverter::convertString(StyleResolver&amp;, const CSSValue&amp; value)
 521 {
 522     return downcast&lt;CSSPrimitiveValue&gt;(value).stringValue();
 523 }
 524 
 525 inline String StyleBuilderConverter::convertStringOrAuto(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 526 {
 527     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 528         return nullAtom();
 529     return convertString(styleResolver, value);
 530 }
 531 
 532 inline String StyleBuilderConverter::convertStringOrNone(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 533 {
 534     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 535         return nullAtom();
 536     return convertString(styleResolver, value);
</pre>
<hr />
<pre>
 573     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 574     ASSERT(primitiveValue.isValueID());
 575 
 576     if (primitiveValue.valueID() != CSSValueWebkitMatchParent)
 577         return primitiveValue;
 578 
 579     auto* parentStyle = styleResolver.parentStyle();
 580     if (parentStyle-&gt;textAlign() == TextAlignMode::Start)
 581         return parentStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Left : TextAlignMode::Right;
 582     if (parentStyle-&gt;textAlign() == TextAlignMode::End)
 583         return parentStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Right : TextAlignMode::Left;
 584     return parentStyle-&gt;textAlign();
 585 }
 586 
 587 inline RefPtr&lt;ClipPathOperation&gt; StyleBuilderConverter::convertClipPath(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 588 {
 589     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 590         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 591         if (primitiveValue.primitiveType() == CSSPrimitiveValue::CSS_URI) {
 592             String cssURLValue = primitiveValue.stringValue();
<span class="line-modified"> 593             String fragment = SVGURIReference::fragmentIdentifierFromIRIString(cssURLValue, styleResolver.document());</span>
 594             // FIXME: It doesn&#39;t work with external SVG references (see https://bugs.webkit.org/show_bug.cgi?id=126133)
<span class="line-modified"> 595             return ReferenceClipPathOperation::create(cssURLValue, fragment);</span>
 596         }
 597         ASSERT(primitiveValue.valueID() == CSSValueNone);
 598         return nullptr;
 599     }
 600 
 601     CSSBoxType referenceBox = CSSBoxType::BoxMissing;
 602     RefPtr&lt;ClipPathOperation&gt; operation;
 603 
 604     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
 605         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
 606         if (primitiveValue.isShape()) {
 607             ASSERT(!operation);
 608             operation = ShapeClipPathOperation::create(basicShapeForValue(styleResolver.state().cssToLengthConversionData(), *primitiveValue.shapeValue()));
 609         } else {
 610             ASSERT(primitiveValue.valueID() == CSSValueContentBox
 611                 || primitiveValue.valueID() == CSSValueBorderBox
 612                 || primitiveValue.valueID() == CSSValuePaddingBox
 613                 || primitiveValue.valueID() == CSSValueMarginBox
 614                 || primitiveValue.valueID() == CSSValueFillBox
 615                 || primitiveValue.valueID() == CSSValueStrokeBox
</pre>
<hr />
<pre>
 740 }
 741 
 742 inline RefPtr&lt;StyleReflection&gt; StyleBuilderConverter::convertReflection(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 743 {
 744     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 745         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 746         return nullptr;
 747     }
 748 
 749     auto&amp; reflectValue = downcast&lt;CSSReflectValue&gt;(value);
 750 
 751     auto reflection = StyleReflection::create();
 752     reflection-&gt;setDirection(reflectValue.direction());
 753     reflection-&gt;setOffset(reflectValue.offset().convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData()));
 754 
 755     NinePieceImage mask;
 756     mask.setMaskDefaults();
 757     styleResolver.styleMap()-&gt;mapNinePieceImage(CSSPropertyWebkitBoxReflect, reflectValue.mask(), mask);
 758     reflection-&gt;setMask(mask);
 759 
<span class="line-modified"> 760     return reflection;</span>
 761 }
 762 
 763 inline IntSize StyleBuilderConverter::convertInitialLetter(StyleResolver&amp;, const CSSValue&amp; value)
 764 {
 765     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 766 
 767     if (primitiveValue.valueID() == CSSValueNormal)
 768         return IntSize();
 769 
 770     Pair* pair = primitiveValue.pairValue();
 771     ASSERT(pair);
 772     ASSERT(pair-&gt;first());
 773     ASSERT(pair-&gt;second());
 774 
 775     return IntSize(pair-&gt;first()-&gt;intValue(), pair-&gt;second()-&gt;intValue());
 776 }
 777 
 778 inline float StyleBuilderConverter::convertTextStrokeWidth(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 779 {
 780     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
</pre>
<hr />
<pre>
 983     Vector&lt;GridTrackSize&gt; m_trackSizes;
 984     NamedGridLinesMap m_namedGridLines;
 985     OrderedNamedGridLinesMap m_orderedNamedGridLines;
 986     Vector&lt;GridTrackSize&gt; m_autoRepeatTrackSizes;
 987     NamedGridLinesMap m_autoRepeatNamedGridLines;
 988     OrderedNamedGridLinesMap m_autoRepeatOrderedNamedGridLines;
 989     unsigned m_autoRepeatInsertionPoint { RenderStyle::initialGridAutoRepeatInsertionPoint() };
 990     AutoRepeatType m_autoRepeatType { RenderStyle::initialGridAutoRepeatType() };
 991 };
 992 
 993 inline bool StyleBuilderConverter::createGridTrackList(const CSSValue&amp; value, TracksData&amp; tracksData, StyleResolver&amp; styleResolver)
 994 {
 995     // Handle &#39;none&#39;.
 996     if (is&lt;CSSPrimitiveValue&gt;(value))
 997         return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
 998 
 999     if (!is&lt;CSSValueList&gt;(value))
1000         return false;
1001 
1002     unsigned currentNamedGridLine = 0;
<span class="line-modified">1003     auto handleLineNameOrTrackSize = [&amp;](const CSSValue&amp; currentValue) {</span>
<span class="line-modified">1004         if (is&lt;CSSGridLineNamesValue&gt;(currentValue))</span>
<span class="line-modified">1005             createGridLineNamesList(currentValue, currentNamedGridLine, tracksData.m_namedGridLines, tracksData.m_orderedNamedGridLines);</span>
<span class="line-modified">1006         else {</span>
<span class="line-added">1007             ++currentNamedGridLine;</span>
<span class="line-added">1008             tracksData.m_trackSizes.append(createGridTrackSize(currentValue, styleResolver));</span>
1009         }
<span class="line-added">1010     };</span>
1011 
<span class="line-added">1012     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {</span>
1013         if (is&lt;CSSGridAutoRepeatValue&gt;(currentValue)) {
1014             ASSERT(tracksData.m_autoRepeatTrackSizes.isEmpty());
1015             unsigned autoRepeatIndex = 0;
1016             CSSValueID autoRepeatID = downcast&lt;CSSGridAutoRepeatValue&gt;(currentValue.get()).autoRepeatID();
1017             ASSERT(autoRepeatID == CSSValueAutoFill || autoRepeatID == CSSValueAutoFit);
1018             tracksData.m_autoRepeatType = autoRepeatID == CSSValueAutoFill ? AutoRepeatType::Fill : AutoRepeatType::Fit;
1019             for (auto&amp; autoRepeatValue : downcast&lt;CSSValueList&gt;(currentValue.get())) {
1020                 if (is&lt;CSSGridLineNamesValue&gt;(autoRepeatValue)) {
1021                     createGridLineNamesList(autoRepeatValue.get(), autoRepeatIndex, tracksData.m_autoRepeatNamedGridLines, tracksData.m_autoRepeatOrderedNamedGridLines);
1022                     continue;
1023                 }
1024                 ++autoRepeatIndex;
1025                 tracksData.m_autoRepeatTrackSizes.append(createGridTrackSize(autoRepeatValue.get(), styleResolver));
1026             }
1027             tracksData.m_autoRepeatInsertionPoint = currentNamedGridLine++;
1028             continue;
1029         }
1030 
<span class="line-modified">1031         if (is&lt;CSSGridIntegerRepeatValue&gt;(currentValue)) {</span>
<span class="line-modified">1032             size_t repetitions = downcast&lt;CSSGridIntegerRepeatValue&gt;(currentValue.get()).repetitions();</span>
<span class="line-added">1033             for (size_t i = 0; i &lt; repetitions; ++i) {</span>
<span class="line-added">1034                 for (auto&amp; integerRepeatValue : downcast&lt;CSSValueList&gt;(currentValue.get()))</span>
<span class="line-added">1035                     handleLineNameOrTrackSize(integerRepeatValue);</span>
<span class="line-added">1036             }</span>
<span class="line-added">1037             continue;</span>
<span class="line-added">1038         }</span>
<span class="line-added">1039 </span>
<span class="line-added">1040         handleLineNameOrTrackSize(currentValue);</span>
1041     }
1042 
1043     // The parser should have rejected any &lt;track-list&gt; without any &lt;track-size&gt; as
1044     // this is not conformant to the syntax.
1045     ASSERT(!tracksData.m_trackSizes.isEmpty() || !tracksData.m_autoRepeatTrackSizes.isEmpty());
1046     return true;
1047 }
1048 
1049 inline bool StyleBuilderConverter::createGridPosition(const CSSValue&amp; value, GridPosition&amp; position)
1050 {
1051     // We accept the specification&#39;s grammar:
1052     // auto | &lt;custom-ident&gt; | [ &lt;integer&gt; &amp;&amp; &lt;custom-ident&gt;? ] | [ span &amp;&amp; [ &lt;integer&gt; || &lt;custom-ident&gt; ] ]
1053     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1054         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1055         // We translate &lt;ident&gt; to &lt;string&gt; during parsing as it makes handling it simpler.
1056         if (primitiveValue.isString()) {
1057             position.setNamedGridArea(primitiveValue.stringValue());
1058             return true;
1059         }
1060 
</pre>
<hr />
<pre>
1105             startVector.append(areaSpan.startLine());
1106             std::sort(startVector.begin(), startVector.end());
1107         }
1108         {
1109             auto&amp; endVector = namedGridLines.add(area.key + &quot;-end&quot;, Vector&lt;unsigned&gt;()).iterator-&gt;value;
1110             endVector.append(areaSpan.endLine());
1111             std::sort(endVector.begin(), endVector.end());
1112         }
1113     }
1114 }
1115 
1116 inline Vector&lt;GridTrackSize&gt; StyleBuilderConverter::convertGridTrackSizeList(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1117 {
1118     ASSERT(value.isValueList());
1119     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1120     Vector&lt;GridTrackSize&gt; trackSizes;
1121     trackSizes.reserveInitialCapacity(valueList.length());
1122     for (auto&amp; currValue : valueList) {
1123         ASSERT(!currValue-&gt;isGridLineNamesValue());
1124         ASSERT(!currValue-&gt;isGridAutoRepeatValue());
<span class="line-added">1125         ASSERT(!currValue-&gt;isGridIntegerRepeatValue());</span>
1126         trackSizes.uncheckedAppend(convertGridTrackSize(styleResolver, currValue));
1127     }
1128     return trackSizes;
1129 }
1130 
1131 inline GridTrackSize StyleBuilderConverter::convertGridTrackSize(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1132 {
1133     return createGridTrackSize(value, styleResolver);
1134 }
1135 
1136 inline Optional&lt;GridPosition&gt; StyleBuilderConverter::convertGridPosition(StyleResolver&amp;, const CSSValue&amp; value)
1137 {
1138     GridPosition gridPosition;
1139     if (createGridPosition(value, gridPosition))
1140         return gridPosition;
1141     return WTF::nullopt;
1142 }
1143 
1144 inline GridAutoFlow StyleBuilderConverter::convertGridAutoFlow(StyleResolver&amp;, const CSSValue&amp; value)
1145 {
</pre>
<hr />
<pre>
1380 {
1381     if (is&lt;CSSPrimitiveValue&gt;(value))
1382         return downcast&lt;CSSPrimitiveValue&gt;(value);
1383 
1384     if (is&lt;CSSValueList&gt;(value)) {
1385         OptionSet&lt;TouchAction&gt; touchActions;
1386         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
1387             auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
1388             auto primitiveValueID = primitiveValue.valueID();
1389             if (primitiveValueID != CSSValuePanX &amp;&amp; primitiveValueID != CSSValuePanY &amp;&amp; primitiveValueID != CSSValuePinchZoom)
1390                 return RenderStyle::initialTouchActions();
1391             touchActions.add(primitiveValue);
1392         }
1393         return touchActions;
1394     }
1395 
1396     return RenderStyle::initialTouchActions();
1397 }
1398 #endif
1399 
<span class="line-modified">1400 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
1401 inline bool StyleBuilderConverter::convertOverflowScrolling(StyleResolver&amp;, const CSSValue&amp; value)
1402 {
1403     return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueTouch;
1404 }
1405 #endif
1406 
1407 inline SVGLengthValue StyleBuilderConverter::convertSVGLengthValue(StyleResolver&amp;, const CSSValue&amp; value)
1408 {
1409     return SVGLengthValue::fromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1410 }
1411 
1412 inline Vector&lt;SVGLengthValue&gt; StyleBuilderConverter::convertSVGLengthVector(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1413 {
1414     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1415 
1416     Vector&lt;SVGLengthValue&gt; svgLengths;
1417     svgLengths.reserveInitialCapacity(valueList.length());
1418     for (auto&amp; item : valueList)
1419         svgLengths.uncheckedAppend(convertSVGLengthValue(styleResolver, item));
1420 
</pre>
<hr />
<pre>
1573     ASSERT(is&lt;CSSValueList&gt;(value));
1574     for (const CSSValue&amp; v : downcast&lt;CSSValueList&gt;(value)) {
1575         switch (downcast&lt;CSSPrimitiveValue&gt;(v).valueID()) {
1576         case CSSValueWeight:
1577             result |= FontSynthesisWeight;
1578             break;
1579         case CSSValueStyle:
1580             result |= FontSynthesisStyle;
1581             break;
1582         case CSSValueSmallCaps:
1583             result |= FontSynthesisSmallCaps;
1584             break;
1585         default:
1586             ASSERT_NOT_REACHED();
1587             break;
1588         }
1589     }
1590 
1591     return result;
1592 }




































1593 
1594 inline OptionSet&lt;SpeakAs&gt; StyleBuilderConverter::convertSpeakAs(StyleResolver&amp;, const CSSValue&amp; value)
1595 {
1596     auto result = RenderStyle::initialSpeakAs();
1597     if (is&lt;CSSValueList&gt;(value)) {
1598         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1599             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1600     }
1601     return result;
1602 }
1603 
1604 inline OptionSet&lt;HangingPunctuation&gt; StyleBuilderConverter::convertHangingPunctuation(StyleResolver&amp;, const CSSValue&amp; value)
1605 {
1606     auto result = RenderStyle::initialHangingPunctuation();
1607     if (is&lt;CSSValueList&gt;(value)) {
1608         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1609             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1610     }
1611     return result;
1612 }
</pre>
</td>
</tr>
</table>
<center><a href="SelectorPseudoTypeMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleBuilderCustom.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>