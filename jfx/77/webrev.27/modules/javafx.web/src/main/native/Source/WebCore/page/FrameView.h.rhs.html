<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2    Copyright (C) 1997 Martin Jones (mjones@kde.org)
  3              (C) 1998 Waldo Bastian (bastian@kde.org)
  4              (C) 1998, 1999 Torben Weis (weis@kde.org)
  5              (C) 1999 Lars Knoll (knoll@kde.org)
  6              (C) 1999 Antti Koivisto (koivisto@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">  7    Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
  8 
  9    This library is free software; you can redistribute it and/or
 10    modify it under the terms of the GNU Library General Public
 11    License as published by the Free Software Foundation; either
 12    version 2 of the License, or (at your option) any later version.
 13 
 14    This library is distributed in the hope that it will be useful,
 15    but WITHOUT ANY WARRANTY; without even the implied warranty of
 16    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17    Library General Public License for more details.
 18 
 19    You should have received a copy of the GNU Library General Public License
 20    along with this library; see the file COPYING.LIB.  If not, write to
 21    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22    Boston, MA 02110-1301, USA.
 23 */
 24 
 25 #pragma once
 26 
 27 #include &quot;AdjustViewSizeOrNot.h&quot;
 28 #include &quot;Color.h&quot;
 29 #include &quot;ContainerNode.h&quot;
 30 #include &quot;FrameViewLayoutContext.h&quot;
 31 #include &quot;GraphicsContext.h&quot;
 32 #include &quot;LayoutMilestone.h&quot;
 33 #include &quot;LayoutRect.h&quot;
 34 #include &quot;Pagination.h&quot;
 35 #include &quot;PaintPhase.h&quot;
 36 #include &quot;RenderPtr.h&quot;
 37 #include &quot;ScrollView.h&quot;
 38 #include &quot;StyleColor.h&quot;
 39 #include &quot;TiledBacking.h&quot;
 40 #include &lt;memory&gt;
 41 #include &lt;wtf/Forward.h&gt;
 42 #include &lt;wtf/Function.h&gt;
 43 #include &lt;wtf/HashSet.h&gt;
 44 #include &lt;wtf/IsoMalloc.h&gt;
 45 #include &lt;wtf/ListHashSet.h&gt;
 46 #include &lt;wtf/OptionSet.h&gt;
 47 #include &lt;wtf/text/WTFString.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 class AXObjectCache;
 52 class Element;
 53 class FloatSize;
 54 class Frame;
 55 class HTMLFrameOwnerElement;
 56 class Page;
 57 class RenderBox;
 58 class RenderElement;
 59 class RenderEmbeddedObject;
 60 class RenderLayer;
 61 class RenderLayerModelObject;
 62 class RenderObject;
 63 class RenderScrollbarPart;
 64 class RenderStyle;
 65 class RenderView;
 66 class RenderWidget;
 67 
 68 enum class FrameFlattening;
 69 
 70 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp;);
 71 
 72 class FrameView final : public ScrollView {
 73     WTF_MAKE_ISO_ALLOCATED(FrameView);
 74 public:
 75     friend class RenderView;
 76     friend class Internals;
 77     friend class FrameViewLayoutContext;
 78 
 79     WEBCORE_EXPORT static Ref&lt;FrameView&gt; create(Frame&amp;);
 80     static Ref&lt;FrameView&gt; create(Frame&amp;, const IntSize&amp; initialSize);
 81 
 82     virtual ~FrameView();
 83 
 84     HostWindow* hostWindow() const final;
 85 
 86     WEBCORE_EXPORT void invalidateRect(const IntRect&amp;) final;
 87     void setFrameRect(const IntRect&amp;) final;
 88 
 89     bool scheduleAnimation() final;
 90 
 91     Frame&amp; frame() const { return m_frame; }
 92 
 93     WEBCORE_EXPORT RenderView* renderView() const;
 94 
 95     int mapFromLayoutToCSSUnits(LayoutUnit) const;
 96     LayoutUnit mapFromCSSToLayoutUnits(int) const;
 97 
<a name="2" id="anc2"></a>




 98     WEBCORE_EXPORT void setCanHaveScrollbars(bool) final;
 99     WEBCORE_EXPORT void updateCanHaveScrollbars();
100 
101     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation) final;
102 
103     bool avoidScrollbarCreation() const final;
104 
105     void setContentsSize(const IntSize&amp;) final;
106     void updateContentsSize() final;
107 
108     const FrameViewLayoutContext&amp; layoutContext() const { return m_layoutContext; }
109     FrameViewLayoutContext&amp; layoutContext() { return m_layoutContext; }
110 
111     WEBCORE_EXPORT bool didFirstLayout() const;
112     void queuePostLayoutCallback(WTF::Function&lt;void ()&gt;&amp;&amp;);
113 
114     WEBCORE_EXPORT bool needsLayout() const;
115     WEBCORE_EXPORT void setNeedsLayoutAfterViewConfigurationChange();
116 
117     void setNeedsCompositingConfigurationUpdate();
118     void setNeedsCompositingGeometryUpdate();
119 
120     void setViewportConstrainedObjectsNeedLayout();
121 
122     WEBCORE_EXPORT bool renderedCharactersExceed(unsigned threshold);
123 
124     void scheduleSelectionUpdate();
125 
126 #if PLATFORM(IOS_FAMILY)
127     bool useCustomFixedPositionLayoutRect() const;
128     IntRect customFixedPositionLayoutRect() const { return m_customFixedPositionLayoutRect; }
129     WEBCORE_EXPORT void setCustomFixedPositionLayoutRect(const IntRect&amp;);
130     bool updateFixedPositionLayoutRect();
131 
132     IntSize customSizeForResizeEvent() const { return m_customSizeForResizeEvent; }
133     WEBCORE_EXPORT void setCustomSizeForResizeEvent(IntSize);
134 
<a name="3" id="anc3"></a><span class="line-modified">135     WEBCORE_EXPORT void setScrollVelocity(const VelocityData&amp;);</span>
136 #else
137     bool useCustomFixedPositionLayoutRect() const { return false; }
138 #endif
139 
140     void willRecalcStyle();
141     bool updateCompositingLayersAfterStyleChange();
142     void updateCompositingLayersAfterLayout();
143 
144     // Called when changes to the GraphicsLayer hierarchy have to be synchronized with
145     // content rendered via the normal painting path.
146     void setNeedsOneShotDrawingSynchronization();
147 
148     WEBCORE_EXPORT GraphicsLayer* graphicsLayerForPlatformWidget(PlatformWidget);
149     WEBCORE_EXPORT void scheduleLayerFlushAllowingThrottling();
150 
<a name="4" id="anc4"></a><span class="line-modified">151     WEBCORE_EXPORT TiledBacking* tiledBacking() const;</span>
152 
153     ScrollingNodeID scrollingNodeID() const override;
154     ScrollableArea* scrollableAreaForScrollLayerID(uint64_t) const;
155     bool usesAsyncScrolling() const final;
156 
157     WEBCORE_EXPORT void enterCompositingMode();
158     WEBCORE_EXPORT bool isEnclosedInCompositingLayer() const;
159 
160     // Only used with accelerated compositing, but outside the #ifdef to make linkage easier.
161     // Returns true if the flush was completed.
162     WEBCORE_EXPORT bool flushCompositingStateIncludingSubframes();
163 
164     // Returns true when a paint with the PaintBehavior::FlattenCompositingLayers flag set gives
165     // a faithful representation of the content.
166     WEBCORE_EXPORT bool isSoftwareRenderable() const;
167 
168     void setIsInWindow(bool);
169 
170     void resetScrollbars();
171     void resetScrollbarsAndClearContentsSize();
172     void prepareForDetach();
173     void detachCustomScrollbars();
174     WEBCORE_EXPORT void recalculateScrollbarOverlayStyle();
175 #if ENABLE(DARK_MODE_CSS)
176     void recalculateBaseBackgroundColor();
177 #endif
178 
179     void clear();
180     void resetLayoutMilestones();
181 
182     WEBCORE_EXPORT bool isTransparent() const;
183     WEBCORE_EXPORT void setTransparent(bool isTransparent);
184 
185     // True if the FrameView is not transparent, and the base background color is opaque.
186     bool hasOpaqueBackground() const;
187 
188     WEBCORE_EXPORT Color baseBackgroundColor() const;
189     WEBCORE_EXPORT void setBaseBackgroundColor(const Color&amp;);
190     WEBCORE_EXPORT void updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor);
191 
192     enum ExtendedBackgroundModeFlags {
193         ExtendedBackgroundModeNone          = 0,
194         ExtendedBackgroundModeVertical      = 1 &lt;&lt; 0,
195         ExtendedBackgroundModeHorizontal    = 1 &lt;&lt; 1,
196         ExtendedBackgroundModeAll           = ExtendedBackgroundModeVertical | ExtendedBackgroundModeHorizontal,
197     };
198     typedef unsigned ExtendedBackgroundMode;
199 
200     void updateExtendBackgroundIfNecessary();
201     void updateTilesForExtendedBackgroundMode(ExtendedBackgroundMode);
202     ExtendedBackgroundMode calculateExtendedBackgroundMode() const;
203 
204     bool hasExtendedBackgroundRectForPainting() const;
205     IntRect extendedBackgroundRectForPainting() const;
206 
207     bool shouldUpdateWhileOffscreen() const;
208     WEBCORE_EXPORT void setShouldUpdateWhileOffscreen(bool);
209     bool shouldUpdate() const;
210 
211     WEBCORE_EXPORT void adjustViewSize();
212 
213     WEBCORE_EXPORT void setViewportSizeForCSSViewportUnits(IntSize);
214     void clearViewportSizeOverrideForCSSViewportUnits();
215     IntSize viewportSizeForCSSViewportUnits() const;
216 
217     IntRect windowClipRect() const final;
218     WEBCORE_EXPORT IntRect windowClipRectForFrameOwner(const HTMLFrameOwnerElement*, bool clipToLayerContents) const;
219 
220     float visibleContentScaleFactor() const final;
221 
222 #if USE(COORDINATED_GRAPHICS)
223     WEBCORE_EXPORT void setFixedVisibleContentRect(const IntRect&amp;) final;
224 #endif
225     WEBCORE_EXPORT void setScrollPosition(const ScrollPosition&amp;) final;
226     void restoreScrollbar();
227     void scheduleScrollToFocusedElement(SelectionRevealMode);
228     void scrollToFocusedElementImmediatelyIfNeeded();
229     void updateLayerPositionsAfterScrolling() final;
230     void updateCompositingLayersAfterScrolling() final;
231     bool requestScrollPositionUpdate(const ScrollPosition&amp;) final;
232     bool isRubberBandInProgress() const final;
233     WEBCORE_EXPORT ScrollPosition minimumScrollPosition() const final;
234     WEBCORE_EXPORT ScrollPosition maximumScrollPosition() const final;
235 
236     // The scrollOrigin, scrollPosition, minimumScrollPosition and maximumScrollPosition are all affected by frame scale,
237     // but layoutViewport computations require unscaled scroll positions.
238     ScrollPosition unscaledMinimumScrollPosition() const;
239     ScrollPosition unscaledMaximumScrollPosition() const;
240 
241     IntPoint unscaledScrollOrigin() const;
242 
243     WEBCORE_EXPORT LayoutPoint minStableLayoutViewportOrigin() const;
244     WEBCORE_EXPORT LayoutPoint maxStableLayoutViewportOrigin() const;
245 
246     enum class TriggerLayoutOrNot {
247         No,
248         Yes
249     };
250     // This origin can be overridden by setLayoutViewportOverrideRect.
251     void setBaseLayoutViewportOrigin(LayoutPoint, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
252     // This size can be overridden by setLayoutViewportOverrideRect.
253     WEBCORE_EXPORT LayoutSize baseLayoutViewportSize() const;
254 
255     // If set, overrides the default &quot;m_layoutViewportOrigin, size of initial containing block&quot; rect.
256     // Used with delegated scrolling (i.e. iOS).
257     WEBCORE_EXPORT void setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt;, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
<a name="5" id="anc5"></a><span class="line-added">258     Optional&lt;LayoutRect&gt; layoutViewportOverrideRect() const { return m_layoutViewportOverrideRect; }</span>
259 
260     WEBCORE_EXPORT void setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt;);
<a name="6" id="anc6"></a><span class="line-added">261     Optional&lt;LayoutRect&gt; visualViewportOverrideRect() const { return m_visualViewportOverrideRect; }</span>
262 
263     // These are in document coordinates, unaffected by page scale (but affected by zooming).
264     WEBCORE_EXPORT LayoutRect layoutViewportRect() const;
265     WEBCORE_EXPORT LayoutRect visualViewportRect() const;
266 
267     static LayoutRect visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor);
268 
269     // This is different than visibleContentRect() in that it ignores negative (or overly positive)
270     // offsets from rubber-banding, and it takes zooming into account.
271     LayoutRect viewportConstrainedVisibleContentRect() const;
272 
<a name="7" id="anc7"></a><span class="line-added">273     WEBCORE_EXPORT void layoutOrVisualViewportChanged();</span>
<span class="line-added">274 </span>
275     LayoutRect rectForFixedPositionLayout() const;
276 
277     void viewportContentsChanged();
278     WEBCORE_EXPORT void resumeVisibleImageAnimationsIncludingSubframes();
279 
280     String mediaType() const;
281     WEBCORE_EXPORT void setMediaType(const String&amp;);
282     void adjustMediaTypeForPrinting(bool printing);
283 
284     void setCannotBlitToWindow();
285     void setIsOverlapped(bool);
286     void setContentIsOpaque(bool);
287 
288     void addSlowRepaintObject(RenderElement&amp;);
289     void removeSlowRepaintObject(RenderElement&amp;);
290     bool hasSlowRepaintObject(const RenderElement&amp; renderer) const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;contains(&amp;renderer); }
291     bool hasSlowRepaintObjects() const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;size(); }
292 
293     // Includes fixed- and sticky-position objects.
294     typedef HashSet&lt;RenderLayerModelObject*&gt; ViewportConstrainedObjectSet;
295     void addViewportConstrainedObject(RenderLayerModelObject*);
296     void removeViewportConstrainedObject(RenderLayerModelObject*);
297     const ViewportConstrainedObjectSet* viewportConstrainedObjects() const { return m_viewportConstrainedObjects.get(); }
298     bool hasViewportConstrainedObjects() const { return m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;size() &gt; 0; }
299 
300     float frameScaleFactor() const;
301 
302     // Functions for querying the current scrolled position, negating the effects of overhang
303     // and adjusting for page scale.
304     LayoutPoint scrollPositionForFixedPosition() const;
305 
306     // Static function can be called from another thread.
<a name="8" id="anc8"></a><span class="line-modified">307     WEBCORE_EXPORT static LayoutPoint scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements, int headerHeight, int footerHeight);</span>
308 
309     WEBCORE_EXPORT static LayoutSize expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor);
310 
311     enum class LayoutViewportConstraint { ConstrainedToDocumentRect, Unconstrained };
312     WEBCORE_EXPORT static LayoutRect computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint);
313 
314     WEBCORE_EXPORT static LayoutPoint computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements);
315 
316     // These layers are positioned differently when there is a topContentInset, a header, or a footer. These value need to be computed
317     // on both the main thread and the scrolling thread.
318     static float yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
319     WEBCORE_EXPORT static FloatPoint positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight);
320     WEBCORE_EXPORT FloatPoint positionForRootContentLayer() const;
321 
322     static float yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
323     static float yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight);
324 
325 #if PLATFORM(IOS_FAMILY)
326     WEBCORE_EXPORT LayoutRect viewportConstrainedObjectsRect() const;
327     // Static function can be called from another thread.
328     WEBCORE_EXPORT static LayoutRect rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements);
329 #endif
330 
<a name="9" id="anc9"></a><span class="line-modified">331     IntRect viewRectExpandedByContentInsets() const;</span>
332 
333     bool fixedElementsLayoutRelativeToFrame() const;
334 
335     WEBCORE_EXPORT void disableLayerFlushThrottlingTemporarilyForInteraction();
336     bool speculativeTilingEnabled() const { return m_speculativeTilingEnabled; }
337     void loadProgressingStatusChanged();
338 
339     WEBCORE_EXPORT void updateControlTints();
340 
341     WEBCORE_EXPORT bool wasScrolledByUser() const;
342     WEBCORE_EXPORT void setWasScrolledByUser(bool);
343 
344     bool safeToPropagateScrollToParent() const;
345 
346     void addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
347     void removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
348 
349     WEBCORE_EXPORT void paintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin) final;
350 
351     struct PaintingState {
352         OptionSet&lt;PaintBehavior&gt; paintBehavior;
353         bool isTopLevelPainter;
354         bool isFlatteningPaintOfRootFrame;
355         PaintingState()
356             : paintBehavior()
357             , isTopLevelPainter(false)
358             , isFlatteningPaintOfRootFrame(false)
359         {
360         }
361     };
362 
363     void willPaintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, PaintingState&amp;);
364     void didPaintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, PaintingState&amp;);
365 
366 #if PLATFORM(IOS_FAMILY)
367     WEBCORE_EXPORT void didReplaceMultipartContent();
368 #endif
369 
370     WEBCORE_EXPORT void setPaintBehavior(OptionSet&lt;PaintBehavior&gt;);
371     WEBCORE_EXPORT OptionSet&lt;PaintBehavior&gt; paintBehavior() const;
372     bool isPainting() const;
373     bool hasEverPainted() const { return !!m_lastPaintTime; }
374     void setLastPaintTime(MonotonicTime lastPaintTime) { m_lastPaintTime = lastPaintTime; }
375     WEBCORE_EXPORT void setNodeToDraw(Node*);
376 
377     enum SelectionInSnapshot { IncludeSelection, ExcludeSelection };
378     enum CoordinateSpaceForSnapshot { DocumentCoordinates, ViewCoordinates };
379     WEBCORE_EXPORT void paintContentsForSnapshot(GraphicsContext&amp;, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot);
380 
381     void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect) final;
382     void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect) final;
383     void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;) final;
384 
385     WEBCORE_EXPORT Color documentBackgroundColor() const;
386 
387     bool isInChildFrameWithFrameFlattening() const;
388 
389     void startDisallowingLayout() { layoutContext().startDisallowingLayout(); }
390     void endDisallowingLayout() { layoutContext().endDisallowingLayout(); }
391 
392     static MonotonicTime currentPaintTimeStamp() { return sCurrentPaintTimeStamp; } // returns 0 if not painting
393 
394     WEBCORE_EXPORT void updateLayoutAndStyleIfNeededRecursive();
395 
396     void incrementVisuallyNonEmptyCharacterCount(const String&amp;);
397     void incrementVisuallyNonEmptyPixelCount(const IntSize&amp;);
398     void updateIsVisuallyNonEmpty();
399     void updateSignificantRenderedTextMilestoneIfNeeded();
400     bool isVisuallyNonEmpty() const { return m_isVisuallyNonEmpty; }
<a name="10" id="anc10"></a><span class="line-modified">401     WEBCORE_EXPORT bool qualifiesAsVisuallyNonEmpty() const;</span>
<span class="line-added">402 </span>
<span class="line-added">403     WEBCORE_EXPORT void enableAutoSizeMode(bool enable, const IntSize&amp; minSize);</span>
404     WEBCORE_EXPORT void setAutoSizeFixedMinimumHeight(int);
<a name="11" id="anc11"></a><span class="line-added">405     bool isAutoSizeEnabled() const { return m_shouldAutoSize; }</span>
406     IntSize autoSizingIntrinsicContentSize() const { return m_autoSizeContentSize; }
407 
408     WEBCORE_EXPORT void forceLayout(bool allowSubtreeLayout = false);
409     WEBCORE_EXPORT void forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot);
410 
411     // FIXME: This method is retained because of embedded WebViews in AppKit.  When a WebView is embedded inside
412     // some enclosing view with auto-pagination, no call happens to resize the view.  The new pagination model
413     // needs the view to resize as a result of the breaks, but that means that the enclosing view has to potentially
414     // resize around that view.  Auto-pagination uses the bounds of the actual view that&#39;s being printed to determine
415     // the edges of the print operation, so the resize is necessary if the enclosing view&#39;s bounds depend on the
416     // web document&#39;s bounds.
417     //
418     // This is already a problem if the view needs to be a different size because of printer fonts or because of print stylesheets.
419     // Mail/Dictionary work around this problem by using the _layoutForPrinting SPI
420     // to at least get print stylesheets and printer fonts into play, but since WebKit doesn&#39;t know about the page offset or
421     // page size, it can&#39;t actually paginate correctly during _layoutForPrinting.
422     //
423     // We can eventually move Mail to a newer SPI that would let them opt in to the layout-time pagination model,
424     // but that doesn&#39;t solve the general problem of how other AppKit views could opt in to the better model.
425     //
426     // NO OTHER PLATFORM BESIDES MAC SHOULD USE THIS METHOD.
427     WEBCORE_EXPORT void adjustPageHeightDeprecated(float* newBottom, float oldTop, float oldBottom, float bottomLimit);
428 
429     bool scrollToFragment(const URL&amp;);
430     bool scrollToAnchor(const String&amp;);
431     void maintainScrollPositionAtAnchor(ContainerNode*);
432     WEBCORE_EXPORT void scrollElementToRect(const Element&amp;, const IntRect&amp;);
433 
434     // Coordinate systems:
435     //
436     // &quot;View&quot;
437     //     Top left is top left of the FrameView/ScrollView/Widget. Size is Widget::boundsRect().size().
438     //
439     // &quot;TotalContents&quot;
440     //    Relative to ScrollView&#39;s scrolled contents, including headers and footers. Size is totalContentsSize().
441     //
442     // &quot;Contents&quot;
443     //    Relative to ScrollView&#39;s scrolled contents, excluding headers and footers, so top left is top left of the scroll view&#39;s
444     //    document, and size is contentsSize().
445     //
446     // &quot;Absolute&quot;
447     //    Relative to the document&#39;s scroll origin (non-zero for RTL documents), but affected by page zoom and page scale. Mostly used
448     //    in rendering code.
449     //
450     // &quot;Document&quot;
451     //    Relative to the document&#39;s scroll origin, but not affected by page zoom or page scale. Size is equivalent to CSS pixel dimensions.
452     //    FIXME: some uses are affected by page zoom (e.g. layout and visual viewports).
453     //
454     // &quot;Client&quot;
455     //    Relative to the visible part of the document (or, more strictly, the layout viewport rect), and with the same scaling
456     //    as Document coordinates, i.e. matching CSS pixels. Affected by scroll origin.
457     //
458     // &quot;LayoutViewport&quot;
459     //    Similar to client coordinates, but affected by page zoom (but not page scale).
460     //
461 
462     // Methods to convert points and rects between the coordinate space of the renderer, and this view.
463     WEBCORE_EXPORT IntRect convertFromRendererToContainingView(const RenderElement*, const IntRect&amp;) const;
464     WEBCORE_EXPORT IntRect convertFromContainingViewToRenderer(const RenderElement*, const IntRect&amp;) const;
465     WEBCORE_EXPORT FloatRect convertFromContainingViewToRenderer(const RenderElement*, const FloatRect&amp;) const;
466     WEBCORE_EXPORT IntPoint convertFromRendererToContainingView(const RenderElement*, const IntPoint&amp;) const;
467     WEBCORE_EXPORT IntPoint convertFromContainingViewToRenderer(const RenderElement*, const IntPoint&amp;) const;
468 
469     // Override ScrollView methods to do point conversion via renderers, in order to take transforms into account.
470     IntRect convertToContainingView(const IntRect&amp;) const final;
471     IntRect convertFromContainingView(const IntRect&amp;) const final;
472     FloatRect convertFromContainingView(const FloatRect&amp;) const final;
473     IntPoint convertToContainingView(const IntPoint&amp;) const final;
474     IntPoint convertFromContainingView(const IntPoint&amp;) const final;
475 
476     float documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
477     float absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
478 
<a name="12" id="anc12"></a><span class="line-modified">479     WEBCORE_EXPORT FloatRect absoluteToDocumentRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
<span class="line-modified">480     WEBCORE_EXPORT FloatPoint absoluteToDocumentPoint(FloatPoint, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
481 
482     FloatRect absoluteToClientRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
483 
484     FloatSize documentToClientOffset() const;
<a name="13" id="anc13"></a><span class="line-modified">485     WEBCORE_EXPORT FloatRect documentToClientRect(FloatRect) const;</span>
486     FloatPoint documentToClientPoint(FloatPoint) const;
487     WEBCORE_EXPORT FloatRect clientToDocumentRect(FloatRect) const;
488     WEBCORE_EXPORT FloatPoint clientToDocumentPoint(FloatPoint) const;
489 
<a name="14" id="anc14"></a><span class="line-added">490     WEBCORE_EXPORT FloatPoint absoluteToLayoutViewportPoint(FloatPoint) const;</span>
491     FloatPoint layoutViewportToAbsolutePoint(FloatPoint) const;
492 
<a name="15" id="anc15"></a><span class="line-added">493     WEBCORE_EXPORT FloatRect absoluteToLayoutViewportRect(FloatRect) const;</span>
<span class="line-added">494     FloatRect layoutViewportToAbsoluteRect(FloatRect) const;</span>
<span class="line-added">495 </span>
496     // Unlike client coordinates, layout viewport coordinates are affected by page zoom.
497     WEBCORE_EXPORT FloatRect clientToLayoutViewportRect(FloatRect) const;
498     WEBCORE_EXPORT FloatPoint clientToLayoutViewportPoint(FloatPoint) const;
499 
500     bool isFrameViewScrollCorner(const RenderScrollbarPart&amp; scrollCorner) const { return m_scrollCorner.get() == &amp;scrollCorner; }
501 
502     // isScrollable() takes an optional Scrollability parameter that allows the caller to define what they mean by &#39;scrollable.&#39;
503     // Most callers are interested in the default value, Scrollability::Scrollable, which means that there is actually content
504     // to scroll to, and a scrollbar that will allow you to access it. In some cases, callers want to know if the FrameView is allowed
505     // to rubber-band, which the main frame might be allowed to do even if there is no content to scroll to. In that case,
506     // callers use Scrollability::ScrollableOrRubberbandable.
507     enum class Scrollability { Scrollable, ScrollableOrRubberbandable };
508     WEBCORE_EXPORT bool isScrollable(Scrollability definitionOfScrollable = Scrollability::Scrollable);
509 
510     bool isScrollableOrRubberbandable() final;
511     bool hasScrollableOrRubberbandableAncestor() final;
512 
513     enum ScrollbarModesCalculationStrategy { RulesFromWebContentOnly, AnyRule };
514     void calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy = AnyRule);
515 
516     IntPoint lastKnownMousePosition() const final;
517     bool isHandlingWheelEvent() const final;
518     bool shouldSetCursor() const;
519 
520     WEBCORE_EXPORT bool useDarkAppearance() const final;
521     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
522 
523     // FIXME: Remove this method once plugin loading is decoupled from layout.
524     void flushAnyPendingPostLayoutTasks();
525 
526     bool shouldSuspendScrollAnimations() const final;
527     void scrollbarStyleChanged(ScrollbarStyle, bool forceUpdate) override;
528 
529     RenderBox* embeddedContentBox() const;
530 
531     WEBCORE_EXPORT void setTracksRepaints(bool);
532     bool isTrackingRepaints() const { return m_isTrackingRepaints; }
533     WEBCORE_EXPORT void resetTrackedRepaints();
534     const Vector&lt;FloatRect&gt;&amp; trackedRepaintRects() const { return m_trackedRepaintRects; }
535     String trackedRepaintRectsAsText() const;
536 
537     typedef HashSet&lt;ScrollableArea*&gt; ScrollableAreaSet;
538     // Returns whether the scrollable area has just been newly added.
539     WEBCORE_EXPORT bool addScrollableArea(ScrollableArea*);
540     // Returns whether the scrollable area has just been removed.
541     WEBCORE_EXPORT bool removeScrollableArea(ScrollableArea*);
542     bool containsScrollableArea(ScrollableArea*) const;
543     const ScrollableAreaSet* scrollableAreas() const { return m_scrollableAreas.get(); }
544 
545     WEBCORE_EXPORT void addChild(Widget&amp;) final;
546     WEBCORE_EXPORT void removeChild(Widget&amp;) final;
547 
548     // This function exists for ports that need to handle wheel events manually.
549     // On Mac WebKit1 the underlying NSScrollView just does the scrolling, but on most other platforms
550     // we need this function in order to do the scroll ourselves.
551     bool wheelEvent(const PlatformWheelEvent&amp;);
552 
553     WEBCORE_EXPORT void setScrollingPerformanceLoggingEnabled(bool);
554 
555     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
556     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
557     // FrameViews in the page cache, but FrameView::pagination() only affects the current
558     // FrameView. FrameView::pagination() will return m_pagination if it has been set. Otherwise,
559     // it will return Page::pagination() since currently there are no callers that need to
560     // distinguish between the two.
561     const Pagination&amp; pagination() const;
562     void setPagination(const Pagination&amp;);
563 
<a name="16" id="anc16"></a>


564 #if ENABLE(CSS_DEVICE_ADAPTATION)
565     IntSize initialViewportSize() const { return m_initialViewportSize; }
566     void setInitialViewportSize(const IntSize&amp; size) { m_initialViewportSize = size; }
567 #endif
568 
569     bool isActive() const final;
570     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const final;
571 
572 #if ENABLE(RUBBER_BANDING)
573     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForTopOverHangArea(bool) const;
574     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForBottomOverHangArea(bool) const;
575 #endif
576 
577     // This function &quot;smears&quot; the &quot;position:fixed&quot; uninflatedBounds for scrolling, returning a rect that is the union of
578     // all possible locations of the given rect under page scrolling.
579     LayoutRect fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const;
580 
581     LayoutPoint scrollPositionRespectingCustomFixedPosition() const;
582 
583     WEBCORE_EXPORT int headerHeight() const final;
584     WEBCORE_EXPORT int footerHeight() const final;
585 
586     WEBCORE_EXPORT float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const final;
587     void topContentInsetDidChange(float newTopContentInset);
588 
589     void topContentDirectionDidChange();
590 
591     WEBCORE_EXPORT void willStartLiveResize() final;
592     WEBCORE_EXPORT void willEndLiveResize() final;
593 
594     WEBCORE_EXPORT void availableContentSizeChanged(AvailableSizeChangeReason) final;
595 
596     void updateTiledBackingAdaptiveSizing();
597     TiledBacking::Scrollability computeScrollability() const;
598 
<a name="17" id="anc17"></a>



599     void addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt;);
600     void firePaintRelatedMilestonesIfNeeded();
601     void fireLayoutRelatedMilestonesIfNeeded();
602     OptionSet&lt;LayoutMilestone&gt; milestonesPendingPaint() const { return m_milestonesPendingPaint; }
603 
604     bool visualUpdatesAllowedByClient() const { return m_visualUpdatesAllowedByClient; }
605     WEBCORE_EXPORT void setVisualUpdatesAllowedByClient(bool);
606 
607     WEBCORE_EXPORT void setScrollPinningBehavior(ScrollPinningBehavior);
608 
609     ScrollBehaviorForFixedElements scrollBehaviorForFixedElements() const;
610 
611     bool hasFlippedBlockRenderers() const { return m_hasFlippedBlockRenderers; }
612     void setHasFlippedBlockRenderers(bool b) { m_hasFlippedBlockRenderers = b; }
613 
614     void updateWidgetPositions();
615     void scheduleUpdateWidgetPositions();
616 
617     void didAddWidgetToRenderTree(Widget&amp;);
618     void willRemoveWidgetFromRenderTree(Widget&amp;);
619 
620     const HashSet&lt;Widget*&gt;&amp; widgetsInRenderTree() const { return m_widgetsInRenderTree; }
621 
622     void addTrackedRepaintRect(const FloatRect&amp;);
623 
624     // exposedRect represents WebKit&#39;s understanding of what part
625     // of the view is actually exposed on screen (taking into account
626     // clipping by other UI elements), whereas visibleContentRect is
627     // internal to WebCore and doesn&#39;t respect those things.
628     WEBCORE_EXPORT void setViewExposedRect(Optional&lt;FloatRect&gt;);
629     Optional&lt;FloatRect&gt; viewExposedRect() const { return m_viewExposedRect; }
630 
631 #if ENABLE(CSS_SCROLL_SNAP)
632     void updateSnapOffsets() final;
633     bool isScrollSnapInProgress() const final;
634     void updateScrollingCoordinatorScrollSnapProperties() const;
635 #endif
636 
637     float adjustScrollStepForFixedContent(float step, ScrollbarOrientation, ScrollGranularity) final;
638 
639     void didChangeScrollOffset();
640 
641     void show() final;
642     void hide() final;
643 
644     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final;
645 
646     void didRestoreFromPageCache();
647 
648     void willDestroyRenderTree();
649     void didDestroyRenderTree();
650 
651     void setSpeculativeTilingDelayDisabledForTesting(bool disabled) { m_speculativeTilingDelayDisabledForTesting = disabled; }
652 
653     WEBCORE_EXPORT FrameFlattening effectiveFrameFlattening() const;
654 
655     WEBCORE_EXPORT void traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons);
656     void invalidateControlTints() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingControlTints); }
657     void invalidateImagesWithAsyncDecodes() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes); }
658 
659     GraphicsLayer* layerForHorizontalScrollbar() const final;
660     GraphicsLayer* layerForVerticalScrollbar() const final;
661 
662 protected:
663     bool scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect) final;
664     void scrollContentsSlowPath(const IntRect&amp; updateRect) final;
665 
666     void repaintSlowRepaintObjects();
667 
668     bool isVerticalDocument() const final;
669     bool isFlippedDocument() const final;
670 
671 private:
672     explicit FrameView(Frame&amp;);
673 
674     void reset();
675     void init();
676 
677     enum LayoutPhase {
678         OutsideLayout,
679         InPreLayout,
680         InRenderTreeLayout,
681         InViewSizeAdjust,
682         InPostLayout
683     };
684 
685     bool isFrameView() const final { return true; }
686 
687     friend class RenderWidget;
688     bool useSlowRepaints(bool considerOverlap = true) const;
689     bool useSlowRepaintsIfNotOverlapped() const;
690     void updateCanBlitOnScrollRecursively();
691     bool shouldLayoutAfterContentsResized() const;
692 
693     bool shouldUpdateCompositingLayersAfterScrolling() const;
694     bool flushCompositingStateForThisFrame(const Frame&amp; rootFrameForFlush);
695 
696     bool shouldDeferScrollUpdateAfterContentSizeChange() final;
697 
698     void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset) final;
699 
700     void applyOverflowToViewport(const RenderElement&amp;, ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode);
701     void applyPaginationToViewport();
702 
703     void updateOverflowStatus(bool horizontalOverflow, bool verticalOverflow);
704 
705     void forceLayoutParentViewIfNeeded();
706     void flushPostLayoutTasksQueue();
707     void performPostLayoutTasks();
708     void autoSizeIfEnabled();
709 
710     void applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp;);
711     void resumeVisibleImageAnimations(const IntRect&amp; visibleRect);
712     void updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect);
713 
714     void updateLayerFlushThrottling();
715     WEBCORE_EXPORT void adjustTiledBackingCoverage();
716 
717     void repaintContentRectangle(const IntRect&amp;) final;
718     void addedOrRemovedScrollbar() final;
719 
720     void scrollToFocusedElementTimerFired();
721     void scrollToFocusedElementInternal();
722 
723     void delegatesScrollingDidChange() final;
724 
725     // ScrollableArea interface
726     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) final;
727     void scrollTo(const ScrollPosition&amp;) final;
728     void setVisibleScrollerThumbRect(const IntRect&amp;) final;
729     ScrollableArea* enclosingScrollableArea() const final;
730     IntRect scrollableAreaBoundingBox(bool* = nullptr) const final;
731     bool scrollAnimatorEnabled() const final;
732     GraphicsLayer* layerForScrollCorner() const final;
733 #if ENABLE(RUBBER_BANDING)
734     GraphicsLayer* layerForOverhangAreas() const final;
735 #endif
736     void contentsResized() final;
737 
738 #if PLATFORM(IOS_FAMILY)
739     void unobscuredContentSizeChanged() final;
740 #endif
741 
742 #if ENABLE(DARK_MODE_CSS)
<a name="18" id="anc18"></a><span class="line-modified">743     RenderObject* rendererForColorScheme() const;</span>
744 #endif
745 
746     bool usesCompositedScrolling() const final;
747     bool usesMockScrollAnimator() const final;
748     void logMockScrollAnimatorMessage(const String&amp;) const final;
749 
750     // Override scrollbar notifications to update the AXObject cache.
751     void didAddScrollbar(Scrollbar*, ScrollbarOrientation) final;
752     void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation) final;
753 
754     IntSize sizeForResizeEvent() const;
755     void sendResizeEventIfNeeded();
756 
757     void adjustScrollbarsForLayout(bool firstLayout);
758 
759     void handleDeferredScrollbarsUpdateAfterDirectionChange();
760 
761     void updateScrollableAreaSet();
762     void updateLayoutViewport();
763 
764     void notifyPageThatContentAreaWillPaint() const final;
765 
766     void enableSpeculativeTilingIfNeeded();
767     void speculativeTilingEnableTimerFired();
768 
769     void updateEmbeddedObjectsTimerFired();
770     bool updateEmbeddedObjects();
771     void updateEmbeddedObject(RenderEmbeddedObject&amp;);
772 
773     void updateWidgetPositionsTimerFired();
774 
775     void scrollToAnchor();
776     void scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition);
777     void scrollableAreaSetChanged();
778     void sendScrollEvent();
779     void resetScrollAnchor();
780 
781     bool hasCustomScrollbars() const;
782 
783     void updateScrollCorner() final;
784 
785     FrameView* parentFrameView() const;
786 
787     bool frameFlatteningEnabled() const;
788     bool isFrameFlatteningValidForThisFrame() const;
789 
790     void markRootOrBodyRendererDirty() const;
791 
<a name="19" id="anc19"></a>
792     bool qualifiesAsSignificantRenderedText() const;
793     void updateHasReachedSignificantRenderedTextThreshold();
794 
795     bool isViewForDocumentInFrame() const;
796 
797     AXObjectCache* axObjectCache() const;
798     void notifyWidgetsInAllFrames(WidgetNotification);
799     void removeFromAXObjectCache();
800     void notifyWidgets(WidgetNotification);
801 
802     RenderElement* viewportRenderer() const;
803 
804     void willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
805     void didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
806 
807     struct OverrideViewportSize {
808         Optional&lt;int&gt; width;
809         Optional&lt;int&gt; height;
810 
811         bool operator==(const OverrideViewportSize&amp; rhs) const { return rhs.width == width &amp;&amp; rhs.height == height; }
812     };
813     void overrideViewportSizeForCSSViewportUnits(OverrideViewportSize);
814 
815     static MonotonicTime sCurrentPaintTimeStamp; // used for detecting decoded resource thrash in the cache
816 
817     const Ref&lt;Frame&gt; m_frame;
818     FrameViewLayoutContext m_layoutContext;
819 
820     HashSet&lt;Widget*&gt; m_widgetsInRenderTree;
821     std::unique_ptr&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt; m_embeddedObjectsToUpdate;
822     std::unique_ptr&lt;HashSet&lt;const RenderElement*&gt;&gt; m_slowRepaintObjects;
823 
824     RefPtr&lt;ContainerNode&gt; m_maintainScrollPositionAnchor;
825     RefPtr&lt;Node&gt; m_nodeToDraw;
826 
827     // Renderer to hold our custom scroll corner.
828     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
829 
830     Timer m_updateEmbeddedObjectsTimer;
831     Timer m_updateWidgetPositionsTimer;
832     Timer m_delayedScrollEventTimer;
833     Timer m_delayedScrollToFocusedElementTimer;
834     Timer m_speculativeTilingEnableTimer;
835 
836     MonotonicTime m_lastPaintTime;
837 
838     LayoutSize m_size;
<a name="20" id="anc20"></a>
839 
840     Color m_baseBackgroundColor { Color::white };
841     IntSize m_lastViewportSize;
842 
843     String m_mediaType { &quot;screen&quot;_s };
844     String m_mediaTypeWhenNotPrinting;
845 
846     Vector&lt;FloatRect&gt; m_trackedRepaintRects;
847 
848     IntRect* m_cachedWindowClipRect { nullptr };
849     Vector&lt;WTF::Function&lt;void ()&gt;&gt; m_postLayoutCallbackQueue;
850 
851     LayoutPoint m_layoutViewportOrigin;
852     Optional&lt;LayoutRect&gt; m_layoutViewportOverrideRect;
853     Optional&lt;LayoutRect&gt; m_visualViewportOverrideRect; // Used when the iOS keyboard is showing.
854 
855     Optional&lt;FloatRect&gt; m_viewExposedRect;
856 
857     OptionSet&lt;PaintBehavior&gt; m_paintBehavior;
858 
859     float m_lastZoomFactor { 1 };
860     unsigned m_visuallyNonEmptyCharacterCount { 0 };
861     unsigned m_visuallyNonEmptyPixelCount { 0 };
862     unsigned m_textRendererCountForVisuallyNonEmptyCharacters { 0 };
863     int m_headerHeight { 0 };
864     int m_footerHeight { 0 };
865 
866 #if PLATFORM(IOS_FAMILY)
867     bool m_useCustomFixedPositionLayoutRect { false };
868     bool m_useCustomSizeForResizeEvent { false };
869 
870     IntRect m_customFixedPositionLayoutRect;
871     IntSize m_customSizeForResizeEvent;
872 #endif
873 
874     Optional&lt;OverrideViewportSize&gt; m_overrideViewportSize;
875 
<a name="21" id="anc21"></a><span class="line-modified">876     // The view size when autosizing.</span>
<span class="line-modified">877     IntSize m_autoSizeConstraint;</span>


878     // The fixed height to resize the view to after autosizing is complete.
879     int m_autoSizeFixedMinimumHeight { 0 };
880     // The intrinsic content size decided by autosizing.
881     IntSize m_autoSizeContentSize;
882 
883     std::unique_ptr&lt;ScrollableAreaSet&gt; m_scrollableAreas;
884     std::unique_ptr&lt;ViewportConstrainedObjectSet&gt; m_viewportConstrainedObjects;
885 
886     OptionSet&lt;LayoutMilestone&gt; m_milestonesPendingPaint;
887 
888     static const unsigned visualCharacterThreshold = 200;
889     static const unsigned visualPixelThreshold = 32 * 32;
890 
891 #if ENABLE(CSS_DEVICE_ADAPTATION)
892     // Size of viewport before any UA or author styles have overridden
893     // the viewport given by the window or viewing area of the UA.
894     IntSize m_initialViewportSize;
895 #endif
896 
897     Pagination m_pagination;
898 
899     enum class ViewportRendererType : uint8_t { None, Document, Body };
900     ViewportRendererType m_viewportRendererType { ViewportRendererType::None };
901     ScrollPinningBehavior m_scrollPinningBehavior { DoNotPin };
902     SelectionRevealMode m_selectionRevealModeForFocusedElement { SelectionRevealMode::DoNotReveal };
903 
904     bool m_shouldUpdateWhileOffscreen { true };
905     bool m_overflowStatusDirty { true };
906     bool m_horizontalOverflow { false };
907     bool m_verticalOverflow { false };
908     bool m_canHaveScrollbars { true };
909     bool m_cannotBlitToWindow { false };
910     bool m_isOverlapped { false };
911     bool m_contentIsOpaque { false };
912     bool m_firstLayoutCallbackPending { false };
913 
914     bool m_isTransparent { false };
915 #if ENABLE(DARK_MODE_CSS)
916     bool m_usesDarkAppearance { false };
917 #endif
918 
919     bool m_isTrackingRepaints { false }; // Used for testing.
920     bool m_wasScrolledByUser { false };
<a name="22" id="anc22"></a>
921     bool m_shouldScrollToFocusedElement { false };
922 
923     bool m_isPainting { false };
924 
925     bool m_isVisuallyNonEmpty { false };
926 
927     bool m_renderedSignificantAmountOfText { false };
928     bool m_hasReachedSignificantRenderedTextThreshold { false };
929 
930     bool m_needsDeferredScrollbarsUpdate { false };
931     bool m_speculativeTilingEnabled { false };
932     bool m_visualUpdatesAllowedByClient { true };
933     bool m_hasFlippedBlockRenderers { false };
934     bool m_speculativeTilingDelayDisabledForTesting { false };
935 
936     // If true, automatically resize the frame view around its content.
937     bool m_shouldAutoSize { false };
938     bool m_inAutoSize { false };
939     // True if autosize has been run since m_shouldAutoSize was set.
940     bool m_didRunAutosize { false };
941 };
942 
943 inline void FrameView::incrementVisuallyNonEmptyPixelCount(const IntSize&amp; size)
944 {
945     if (m_visuallyNonEmptyPixelCount &gt; visualPixelThreshold)
946         return;
947     m_visuallyNonEmptyPixelCount += size.width() * size.height();
948 }
949 
950 } // namespace WebCore
951 
952 SPECIALIZE_TYPE_TRAITS_WIDGET(FrameView, isFrameView())
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>