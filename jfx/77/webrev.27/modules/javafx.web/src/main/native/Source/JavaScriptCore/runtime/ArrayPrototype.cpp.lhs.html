<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   5  *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;ArrayPrototype.h&quot;
  26 
  27 #include &quot;AdaptiveInferredPropertyValueWatchpointBase.h&quot;
  28 #include &quot;ArrayConstructor.h&quot;
  29 #include &quot;BuiltinNames.h&quot;
  30 #include &quot;ButterflyInlines.h&quot;
  31 #include &quot;CodeBlock.h&quot;
  32 #include &quot;Error.h&quot;
  33 #include &quot;GetterSetter.h&quot;
  34 #include &quot;Interpreter.h&quot;
  35 #include &quot;JIT.h&quot;
  36 #include &quot;JSArrayInlines.h&quot;
  37 #include &quot;JSCBuiltins.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 #include &quot;JSStringJoiner.h&quot;
  41 #include &quot;Lookup.h&quot;
  42 #include &quot;ObjectConstructor.h&quot;
  43 #include &quot;ObjectPrototype.h&quot;
  44 #include &quot;Operations.h&quot;
  45 #include &quot;StringRecursionChecker.h&quot;
  46 #include &lt;algorithm&gt;
  47 #include &lt;wtf/Assertions.h&gt;
  48 
  49 namespace JSC {
  50 
  51 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState*);
  52 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState*);
  53 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState*);
  54 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState*);
  55 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState*);
  56 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState*);
  57 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState*);
  58 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState*);
  59 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState*);
  60 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState*);
  61 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState*);
  62 
  63 // ------------------------------ ArrayPrototype ----------------------------
  64 
  65 const ClassInfo ArrayPrototype::s_info = {&quot;Array&quot;, &amp;JSArray::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ArrayPrototype)};
  66 
  67 ArrayPrototype* ArrayPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
  68 {
  69     ArrayPrototype* prototype = new (NotNull, allocateCell&lt;ArrayPrototype&gt;(vm.heap)) ArrayPrototype(vm, structure);
  70     prototype-&gt;finishCreation(vm, globalObject);
<a name="2" id="anc2"></a><span class="line-removed">  71     vm.heap.addFinalizer(prototype, destroy);</span>
  72     return prototype;
  73 }
  74 
  75 // ECMA 15.4.4
  76 ArrayPrototype::ArrayPrototype(VM&amp; vm, Structure* structure)
  77     : JSArray(vm, structure, 0)
  78 {
  79 }
  80 
  81 void ArrayPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  82 {
  83     Base::finishCreation(vm);
  84     ASSERT(inherits(vm, info()));
<a name="3" id="anc3"></a><span class="line-removed">  85     didBecomePrototype();</span>
  86 
  87     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toString, globalObject-&gt;arrayProtoToStringFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  88     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPublicName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  89     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  90 
  91     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toLocaleString, arrayProtoFuncToLocaleString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
<a name="4" id="anc4"></a><span class="line-modified">  92     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;concat&quot;, arrayPrototypeConcatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">  93     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;fill&quot;, arrayPrototypeFillCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  94     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;join, arrayProtoFuncJoin, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
  95     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;pop&quot;, arrayProtoFuncPop, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayPopIntrinsic);
  96     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPublicName(), arrayProtoFuncPush, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayPushIntrinsic);
  97     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPrivateName(), arrayProtoFuncPush, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 1, ArrayPushIntrinsic);
  98     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;reverse&quot;, arrayProtoFuncReverse, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
  99     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPublicName(), arrayProtoFuncShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 100     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPrivateName(), arrayProtoFuncShift, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 0);
 101     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;slice, arrayProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, ArraySliceIntrinsic);
<a name="5" id="anc5"></a><span class="line-modified"> 102     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;sort&quot;, arrayPrototypeSortCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 103     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;splice&quot;, arrayProtoFuncSplice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 104     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;unshift&quot;, arrayProtoFuncUnShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<a name="6" id="anc6"></a><span class="line-modified"> 105     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;every&quot;, arrayPrototypeEveryCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 106     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;forEach&quot;, arrayPrototypeForEachCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 107     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;some&quot;, arrayPrototypeSomeCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 108     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, arrayProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayIndexOfIntrinsic);
 109     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, arrayProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<a name="7" id="anc7"></a><span class="line-modified"> 110     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;filter&quot;, arrayPrototypeFilterCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 111     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;flat&quot;, arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 112     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;flatMap&quot;, arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 113     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;reduce&quot;, arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 114     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;reduceRight&quot;, arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 115     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;map&quot;, arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 116     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayPrototypeEntriesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 117     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayPrototypeKeysCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<a name="8" id="anc8"></a><span class="line-modified"> 118     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;find&quot;, arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 119     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;findIndex&quot;, arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 120     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 121     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;copyWithin&quot;, arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 122 
 123     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 124     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 125     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 126     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 127 
 128     JSObject* unscopables = constructEmptyObject(globalObject-&gt;globalExec(), globalObject-&gt;nullPrototypeObjectStructure());
<a name="9" id="anc9"></a><span class="line-modified"> 129     const char* unscopableNames[] = {</span>
<span class="line-modified"> 130         &quot;copyWithin&quot;,</span>
<span class="line-modified"> 131         &quot;entries&quot;,</span>
<span class="line-modified"> 132         &quot;fill&quot;,</span>
<span class="line-modified"> 133         &quot;find&quot;,</span>
<span class="line-modified"> 134         &quot;findIndex&quot;,</span>
<span class="line-modified"> 135         &quot;includes&quot;,</span>
<span class="line-modified"> 136         &quot;keys&quot;,</span>
<span class="line-modified"> 137         &quot;values&quot;</span>



 138     };
<a name="10" id="anc10"></a><span class="line-modified"> 139     for (const char* unscopableName : unscopableNames)</span>
<span class="line-modified"> 140         unscopables-&gt;putDirect(vm, Identifier::fromString(&amp;vm, unscopableName), jsBoolean(true));</span>
 141     putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 142 }
 143 
<a name="11" id="anc11"></a><span class="line-removed"> 144 void ArrayPrototype::destroy(JSC::JSCell* cell)</span>
<span class="line-removed"> 145 {</span>
<span class="line-removed"> 146     ArrayPrototype* thisObject = static_cast&lt;ArrayPrototype*&gt;(cell);</span>
<span class="line-removed"> 147     thisObject-&gt;ArrayPrototype::~ArrayPrototype();</span>
<span class="line-removed"> 148 }</span>
<span class="line-removed"> 149 </span>
 150 // ------------------------------ Array Functions ----------------------------
 151 
 152 static ALWAYS_INLINE JSValue getProperty(ExecState* exec, JSObject* object, unsigned index)
 153 {
 154     VM&amp; vm = exec-&gt;vm();
 155     auto scope = DECLARE_THROW_SCOPE(vm);
 156 
 157     if (JSValue result = object-&gt;tryGetIndexQuickly(index))
 158         return result;
 159     // We want to perform get and has in the same operation.
 160     // We can only do so when this behavior is not observable. The
 161     // only time it is observable is when we encounter an opaque objects (ProxyObject and JSModuleNamespaceObject)
 162     // somewhere in the prototype chain.
 163     PropertySlot slot(object, PropertySlot::InternalMethodType::HasProperty);
 164     bool hasProperty = object-&gt;getPropertySlot(exec, index, slot);
 165     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 166     if (!hasProperty)
 167         return { };
 168     if (UNLIKELY(slot.isTaintedByOpaqueObject()))
 169         RELEASE_AND_RETURN(scope, object-&gt;get(exec, index));
 170 
 171     RELEASE_AND_RETURN(scope, slot.getValue(exec, index));
 172 }
 173 
 174 static ALWAYS_INLINE bool putLength(ExecState* exec, VM&amp; vm, JSObject* obj, JSValue value)
 175 {
 176     PutPropertySlot slot(obj);
 177     return obj-&gt;methodTable(vm)-&gt;put(obj, exec, vm.propertyNames-&gt;length, value, slot);
 178 }
 179 
 180 static ALWAYS_INLINE void setLength(ExecState* exec, VM&amp; vm, JSObject* obj, unsigned value)
 181 {
 182     auto scope = DECLARE_THROW_SCOPE(vm);
 183     static const bool throwException = true;
 184     if (isJSArray(obj)) {
 185         jsCast&lt;JSArray*&gt;(obj)-&gt;setLength(exec, value, throwException);
 186         RETURN_IF_EXCEPTION(scope, void());
 187     }
 188     bool success = putLength(exec, vm, obj, jsNumber(value));
 189     RETURN_IF_EXCEPTION(scope, void());
 190     if (UNLIKELY(!success))
 191         throwTypeError(exec, scope, ReadonlyPropertyWriteError);
 192 }
 193 
<a name="12" id="anc12"></a>



 194 ALWAYS_INLINE bool speciesWatchpointIsValid(ExecState* exec, JSObject* thisObject)
 195 {
 196     VM&amp; vm = exec-&gt;vm();
 197     JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
 198     ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
 199 
<a name="13" id="anc13"></a><span class="line-modified"> 200     if (globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() == ClearWatchpoint) {</span>
<span class="line-modified"> 201         arrayPrototype-&gt;tryInitializeSpeciesWatchpoint(exec);</span>
<span class="line-modified"> 202         ASSERT(globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() != ClearWatchpoint);</span>

 203     }
 204 
 205     return !thisObject-&gt;hasCustomProperties(vm)
 206         &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
<a name="14" id="anc14"></a><span class="line-modified"> 207         &amp;&amp; globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() == IsWatched;</span>
 208 }
 209 
 210 enum class SpeciesConstructResult {
 211     FastPath,
 212     Exception,
 213     CreatedObject
 214 };
 215 
<a name="15" id="anc15"></a><span class="line-modified"> 216 static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(ExecState* exec, JSObject* thisObject, unsigned length)</span>
 217 {
 218     VM&amp; vm = exec-&gt;vm();
 219     auto scope = DECLARE_THROW_SCOPE(vm);
 220 
 221     auto exceptionResult = [] () {
 222         return std::make_pair(SpeciesConstructResult::Exception, nullptr);
 223     };
 224 
 225     // ECMA 9.4.2.3: https://tc39.github.io/ecma262/#sec-arrayspeciescreate
 226     JSValue constructor = jsUndefined();
 227     bool thisIsArray = isArray(exec, thisObject);
 228     RETURN_IF_EXCEPTION(scope, exceptionResult());
 229     if (LIKELY(thisIsArray)) {
 230         // Fast path in the normal case where the user has not set an own constructor and the Array.prototype.constructor is normal.
 231         // We need prototype check for subclasses of Array, which are Array objects but have a different prototype by default.
 232         bool isValid = speciesWatchpointIsValid(exec, thisObject);
 233         scope.assertNoException();
 234         if (LIKELY(isValid))
 235             return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 236 
 237         constructor = thisObject-&gt;get(exec, vm.propertyNames-&gt;constructor);
 238         RETURN_IF_EXCEPTION(scope, exceptionResult());
 239         if (constructor.isConstructor(vm)) {
 240             JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<a name="16" id="anc16"></a><span class="line-modified"> 241             if (exec-&gt;lexicalGlobalObject() != constructorObject-&gt;globalObject(vm))</span>
<span class="line-modified"> 242                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);;</span>


 243         }
 244         if (constructor.isObject()) {
 245             constructor = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);
 246             RETURN_IF_EXCEPTION(scope, exceptionResult());
 247             if (constructor.isNull())
<a name="17" id="anc17"></a><span class="line-modified"> 248                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);;</span>
 249         }
 250     } else {
 251         // If isArray is false, return ? ArrayCreate(length).
 252         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 253     }
 254 
 255     if (constructor.isUndefined())
 256         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 257 
 258     MarkedArgumentBuffer args;
 259     args.append(jsNumber(length));
 260     ASSERT(!args.hasOverflowed());
 261     JSObject* newObject = construct(exec, constructor, args, &quot;Species construction did not get a valid constructor&quot;);
 262     RETURN_IF_EXCEPTION(scope, exceptionResult());
 263     return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
 264 }
 265 
<a name="18" id="anc18"></a>





















 266 static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)
 267 {
 268     JSValue value = exec-&gt;argument(argument);
 269     if (value.isUndefined())
 270         return undefinedValue;
 271 
 272     double indexDouble = value.toInteger(exec);
 273     if (indexDouble &lt; 0) {
 274         indexDouble += length;
 275         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 276     }
 277     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
 278 }
 279 
 280 // The shift/unshift function implement the shift/unshift behaviour required
 281 // by the corresponding array prototype methods, and by splice. In both cases,
 282 // the methods are operating an an array or array like object.
 283 //
 284 //  header  currentCount  (remainder)
 285 // [------][------------][-----------]
 286 //  header  resultCount  (remainder)
 287 // [------][-----------][-----------]
 288 //
 289 // The set of properties in the range &#39;header&#39; must be unchanged. The set of
 290 // properties in the range &#39;remainder&#39; (where remainder = length - header -
 291 // currentCount) will be shifted to the left or right as appropriate; in the
 292 // case of shift this must be removing values, in the case of unshift this
 293 // must be introducing new values.
 294 
 295 template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
 296 void shift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)
 297 {
 298     VM&amp; vm = exec-&gt;vm();
 299     auto scope = DECLARE_THROW_SCOPE(vm);
 300 
 301     RELEASE_ASSERT(currentCount &gt; resultCount);
 302     unsigned count = currentCount - resultCount;
 303 
 304     RELEASE_ASSERT(header &lt;= length);
 305     RELEASE_ASSERT(currentCount &lt;= (length - header));
 306 
 307     if (isJSArray(thisObj)) {
 308         JSArray* array = asArray(thisObj);
 309         if (array-&gt;length() == length &amp;&amp; array-&gt;shiftCount&lt;shiftCountMode&gt;(exec, header, count))
 310             return;
 311     }
 312 
 313     for (unsigned k = header; k &lt; length - currentCount; ++k) {
 314         unsigned from = k + currentCount;
 315         unsigned to = k + resultCount;
 316         JSValue value = getProperty(exec, thisObj, from);
 317         RETURN_IF_EXCEPTION(scope, void());
 318         if (value) {
 319             thisObj-&gt;putByIndexInline(exec, to, value, true);
 320             RETURN_IF_EXCEPTION(scope, void());
 321         } else {
 322             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);
 323             RETURN_IF_EXCEPTION(scope, void());
 324             if (!success) {
 325                 throwTypeError(exec, scope, UnableToDeletePropertyError);
 326                 return;
 327             }
 328         }
 329     }
 330     for (unsigned k = length; k &gt; length - count; --k) {
 331         bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, k - 1);
 332         RETURN_IF_EXCEPTION(scope, void());
 333         if (!success) {
 334             throwTypeError(exec, scope, UnableToDeletePropertyError);
 335             return;
 336         }
 337     }
 338 }
 339 
 340 template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
 341 void unshift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)
 342 {
 343     VM&amp; vm = exec-&gt;vm();
 344     auto scope = DECLARE_THROW_SCOPE(vm);
 345 
 346     RELEASE_ASSERT(resultCount &gt; currentCount);
 347     unsigned count = resultCount - currentCount;
 348 
 349     RELEASE_ASSERT(header &lt;= length);
 350     RELEASE_ASSERT(currentCount &lt;= (length - header));
 351 
 352     // Guard against overflow.
 353     if (count &gt; UINT_MAX - length) {
 354         throwOutOfMemoryError(exec, scope);
 355         return;
 356     }
 357 
 358     if (isJSArray(thisObj)) {
 359         JSArray* array = asArray(thisObj);
 360         if (array-&gt;length() == length) {
 361             bool handled = array-&gt;unshiftCount&lt;shiftCountMode&gt;(exec, header, count);
 362             EXCEPTION_ASSERT(!scope.exception() || handled);
 363             if (handled)
 364                 return;
 365         }
 366     }
 367 
 368     for (unsigned k = length - currentCount; k &gt; header; --k) {
 369         unsigned from = k + currentCount - 1;
 370         unsigned to = k + resultCount - 1;
 371         JSValue value = getProperty(exec, thisObj, from);
 372         RETURN_IF_EXCEPTION(scope, void());
 373         if (value) {
 374             thisObj-&gt;putByIndexInline(exec, to, value, true);
 375             RETURN_IF_EXCEPTION(scope, void());
 376         } else {
 377             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);
 378             RETURN_IF_EXCEPTION(scope, void());
 379             if (UNLIKELY(!success)) {
 380                 throwTypeError(exec, scope, UnableToDeletePropertyError);
 381                 return;
 382             }
 383         }
 384     }
 385 }
 386 
 387 inline bool canUseFastJoin(const JSObject* thisObject)
 388 {
 389     switch (thisObject-&gt;indexingType()) {
 390     case ALL_CONTIGUOUS_INDEXING_TYPES:
 391     case ALL_INT32_INDEXING_TYPES:
 392     case ALL_DOUBLE_INDEXING_TYPES:
 393     case ALL_UNDECIDED_INDEXING_TYPES:
 394         return true;
 395     default:
 396         break;
 397     }
 398     return false;
 399 }
 400 
 401 inline bool holesMustForwardToPrototype(VM&amp; vm, JSObject* object)
 402 {
 403     return object-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, object);
 404 }
 405 
 406 inline bool isHole(double value)
 407 {
 408     return std::isnan(value);
 409 }
 410 
 411 inline bool isHole(const WriteBarrier&lt;Unknown&gt;&amp; value)
 412 {
 413     return !value;
 414 }
 415 
 416 template&lt;typename T&gt;
 417 inline bool containsHole(T* data, unsigned length)
 418 {
 419     for (unsigned i = 0; i &lt; length; ++i) {
 420         if (isHole(data[i]))
 421             return true;
 422     }
 423     return false;
 424 }
 425 
 426 inline JSValue fastJoin(ExecState&amp; state, JSObject* thisObject, StringView separator, unsigned length, bool* sawHoles = nullptr)
 427 {
 428     VM&amp; vm = state.vm();
 429     auto scope = DECLARE_THROW_SCOPE(vm);
 430 
 431     switch (thisObject-&gt;indexingType()) {
 432     case ALL_INT32_INDEXING_TYPES: {
 433         auto&amp; butterfly = *thisObject-&gt;butterfly();
 434         if (UNLIKELY(length &gt; butterfly.publicLength()))
 435             break;
 436         JSStringJoiner joiner(state, separator, length);
 437         RETURN_IF_EXCEPTION(scope, { });
 438         auto data = butterfly.contiguous().data();
 439         bool holesKnownToBeOK = false;
 440         for (unsigned i = 0; i &lt; length; ++i) {
 441             JSValue value = data[i].get();
 442             if (LIKELY(value))
 443                 joiner.appendNumber(vm, value.asInt32());
 444             else {
 445                 if (sawHoles)
 446                     *sawHoles = true;
 447                 if (!holesKnownToBeOK) {
 448                     if (holesMustForwardToPrototype(vm, thisObject))
 449                         goto generalCase;
 450                     holesKnownToBeOK = true;
 451                 }
 452                 joiner.appendEmptyString();
 453             }
 454         }
 455         RELEASE_AND_RETURN(scope, joiner.join(state));
 456     }
 457     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 458         auto&amp; butterfly = *thisObject-&gt;butterfly();
 459         if (UNLIKELY(length &gt; butterfly.publicLength()))
 460             break;
 461         JSStringJoiner joiner(state, separator, length);
 462         RETURN_IF_EXCEPTION(scope, { });
 463         auto data = butterfly.contiguous().data();
 464         bool holesKnownToBeOK = false;
 465         for (unsigned i = 0; i &lt; length; ++i) {
 466             if (JSValue value = data[i].get()) {
 467                 if (!joiner.appendWithoutSideEffects(state, value))
 468                     goto generalCase;
 469             } else {
 470                 if (sawHoles)
 471                     *sawHoles = true;
 472                 if (!holesKnownToBeOK) {
 473                     if (holesMustForwardToPrototype(vm, thisObject))
 474                         goto generalCase;
 475                     holesKnownToBeOK = true;
 476                 }
 477                 joiner.appendEmptyString();
 478             }
 479         }
 480         RELEASE_AND_RETURN(scope, joiner.join(state));
 481     }
 482     case ALL_DOUBLE_INDEXING_TYPES: {
 483         auto&amp; butterfly = *thisObject-&gt;butterfly();
 484         if (UNLIKELY(length &gt; butterfly.publicLength()))
 485             break;
 486         JSStringJoiner joiner(state, separator, length);
 487         RETURN_IF_EXCEPTION(scope, { });
 488         auto data = butterfly.contiguousDouble().data();
 489         bool holesKnownToBeOK = false;
 490         for (unsigned i = 0; i &lt; length; ++i) {
 491             double value = data[i];
 492             if (LIKELY(!isHole(value)))
 493                 joiner.appendNumber(vm, value);
 494             else {
 495                 if (sawHoles)
 496                     *sawHoles = true;
 497                 if (!holesKnownToBeOK) {
 498                     if (holesMustForwardToPrototype(vm, thisObject))
 499                         goto generalCase;
 500                     holesKnownToBeOK = true;
 501                 }
 502                 joiner.appendEmptyString();
 503             }
 504         }
 505         RELEASE_AND_RETURN(scope, joiner.join(state));
 506     }
 507     case ALL_UNDECIDED_INDEXING_TYPES: {
 508         if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 509             goto generalCase;
 510         switch (separator.length()) {
 511         case 0:
<a name="19" id="anc19"></a><span class="line-modified"> 512             RELEASE_AND_RETURN(scope, jsEmptyString(&amp;state));</span>
 513         case 1: {
 514             if (length &lt;= 1)
<a name="20" id="anc20"></a><span class="line-modified"> 515                 RELEASE_AND_RETURN(scope, jsEmptyString(&amp;state));</span>
 516             if (separator.is8Bit())
 517                 RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters8()[0], length - 1));
 518             RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters16()[0], length - 1));
<a name="21" id="anc21"></a>


















 519         }
 520         }
 521     }
 522     }
 523 
 524 generalCase:
 525     JSStringJoiner joiner(state, separator, length);
 526     RETURN_IF_EXCEPTION(scope, { });
 527     for (unsigned i = 0; i &lt; length; ++i) {
 528         JSValue element = thisObject-&gt;getIndex(&amp;state, i);
 529         RETURN_IF_EXCEPTION(scope, { });
 530         joiner.append(state, element);
 531         RETURN_IF_EXCEPTION(scope, { });
 532     }
 533     RELEASE_AND_RETURN(scope, joiner.join(state));
 534 }
 535 
<a name="22" id="anc22"></a>














 536 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(ExecState* exec)
 537 {
 538     VM&amp; vm = exec-&gt;vm();
 539     auto scope = DECLARE_THROW_SCOPE(vm);
 540     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
 541 
 542     // 1. Let array be the result of calling ToObject on the this value.
 543     JSObject* thisObject = thisValue.toObject(exec);
 544     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 545 
<a name="23" id="anc23"></a><span class="line-modified"> 546     // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.</span>
<span class="line-modified"> 547     JSValue function = JSValue(thisObject).get(exec, vm.propertyNames-&gt;join);</span>
<span class="line-modified"> 548     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>

 549 
<a name="24" id="anc24"></a><span class="line-modified"> 550     // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).</span>
<span class="line-modified"> 551     bool customJoinCase = false;</span>
<span class="line-modified"> 552     if (!function.isCell())</span>
<span class="line-modified"> 553         customJoinCase = true;</span>
<span class="line-modified"> 554     CallData callData;</span>
<span class="line-modified"> 555     CallType callType = getCallData(vm, function, callData);</span>
<span class="line-modified"> 556     if (callType == CallType::None)</span>
<span class="line-modified"> 557         customJoinCase = true;</span>
 558 
<a name="25" id="anc25"></a><span class="line-modified"> 559     if (UNLIKELY(customJoinCase))</span>
<span class="line-modified"> 560         RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
 561 
<a name="26" id="anc26"></a><span class="line-modified"> 562     // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.</span>
<span class="line-modified"> 563     if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)</span>
<span class="line-modified"> 564         RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, function, callType, callData, thisObject, *vm.emptyList)));</span>

 565 
 566     ASSERT(isJSArray(thisValue));
 567     JSArray* thisArray = asArray(thisValue);
 568 
 569     unsigned length = thisArray-&gt;length();
 570 
 571     StringRecursionChecker checker(exec, thisArray);
 572     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 573     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 574         return JSValue::encode(earlyReturnValue);
 575 
 576     if (LIKELY(canUseFastJoin(thisArray))) {
 577         const LChar comma = &#39;,&#39;;
 578         scope.release();
 579 
 580         bool isCoW = isCopyOnWrite(thisArray-&gt;indexingMode());
 581         JSImmutableButterfly* immutableButterfly = nullptr;
 582         if (isCoW) {
 583             immutableButterfly = JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly());
 584             auto iter = vm.heap.immutableButterflyToStringCache.find(immutableButterfly);
 585             if (iter != vm.heap.immutableButterflyToStringCache.end())
 586                 return JSValue::encode(iter-&gt;value);
 587         }
 588 
 589         bool sawHoles = false;
 590         JSValue result = fastJoin(*exec, thisArray, { &amp;comma, 1 }, length, &amp;sawHoles);
 591 
 592         if (!sawHoles &amp;&amp; result &amp;&amp; isJSString(result) &amp;&amp; isCoW) {
 593             ASSERT(JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly()) == immutableButterfly);
 594             vm.heap.immutableButterflyToStringCache.add(immutableButterfly, jsCast&lt;JSString*&gt;(result));
 595         }
 596 
 597         return JSValue::encode(result);
 598     }
 599 
 600     JSStringJoiner joiner(*exec, &#39;,&#39;, length);
 601     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 602 
 603     for (unsigned i = 0; i &lt; length; ++i) {
 604         JSValue element = thisArray-&gt;tryGetIndexQuickly(i);
 605         if (!element) {
 606             element = thisArray-&gt;get(exec, i);
 607             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 608         }
 609         joiner.append(*exec, element);
 610         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 611     }
 612 
 613     RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(*exec)));
 614 }
 615 
 616 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState* exec)
 617 {
 618     VM&amp; vm = exec-&gt;vm();
 619     auto scope = DECLARE_THROW_SCOPE(vm);
 620     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
 621 
 622     JSObject* thisObject = thisValue.toObject(exec);
 623     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 624     unsigned length = toLength(exec, thisObject);
 625     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 626 
 627     StringRecursionChecker checker(exec, thisObject);
 628     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 629     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 630         return JSValue::encode(earlyReturnValue);
 631 
 632     JSStringJoiner stringJoiner(*exec, &#39;,&#39;, length);
 633     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 634 
 635 #if ENABLE(INTL)
 636     ArgList arguments(exec);
 637 #endif
 638     for (unsigned i = 0; i &lt; length; ++i) {
 639         JSValue element = thisObject-&gt;getIndex(exec, i);
 640         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 641         if (element.isUndefinedOrNull())
<a name="27" id="anc27"></a><span class="line-modified"> 642             element = jsEmptyString(exec);</span>
 643         else {
 644             JSValue conversionFunction = element.get(exec, vm.propertyNames-&gt;toLocaleString);
 645             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 646             CallData callData;
 647             CallType callType = getCallData(vm, conversionFunction, callData);
 648             if (callType != CallType::None) {
 649 #if ENABLE(INTL)
 650                 element = call(exec, conversionFunction, callType, callData, element, arguments);
 651 #else
 652                 element = call(exec, conversionFunction, callType, callData, element, *vm.emptyList);
 653 #endif
 654                 RETURN_IF_EXCEPTION(scope, encodedJSValue());
 655             }
 656         }
 657         stringJoiner.append(*exec, element);
 658         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 659     }
 660 
 661     RELEASE_AND_RETURN(scope, JSValue::encode(stringJoiner.join(*exec)));
 662 }
 663 
 664 static JSValue slowJoin(ExecState&amp; exec, JSObject* thisObject, JSString* separator, uint64_t length)
 665 {
 666     VM&amp; vm = exec.vm();
 667     auto scope = DECLARE_THROW_SCOPE(vm);
 668 
 669     // 5. If len is zero, return the empty String.
 670     if (!length)
<a name="28" id="anc28"></a><span class="line-modified"> 671         return jsEmptyString(&amp;exec);</span>
 672 
 673     // 6. Let element0 be Get(O, &quot;0&quot;).
 674     JSValue element0 = thisObject-&gt;getIndex(&amp;exec, 0);
 675     RETURN_IF_EXCEPTION(scope, { });
 676 
 677     // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
 678     JSString* r = nullptr;
 679     if (element0.isUndefinedOrNull())
<a name="29" id="anc29"></a><span class="line-modified"> 680         r = jsEmptyString(&amp;exec);</span>
 681     else
 682         r = element0.toString(&amp;exec);
 683     RETURN_IF_EXCEPTION(scope, { });
 684 
 685     // 8. Let k be 1.
 686     // 9. Repeat, while k &lt; len
 687     // 9.e Increase k by 1..
 688     for (uint64_t k = 1; k &lt; length; ++k) {
 689         // b. Let element be ? Get(O, ! ToString(k)).
<a name="30" id="anc30"></a><span class="line-modified"> 690         JSValue element = thisObject-&gt;get(&amp;exec, Identifier::fromString(&amp;exec, AtomicString::number(k)));</span>
 691         RETURN_IF_EXCEPTION(scope, { });
 692 
 693         // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
 694         JSString* next = nullptr;
 695         if (element.isUndefinedOrNull()) {
 696             if (!separator-&gt;length())
 697                 continue;
<a name="31" id="anc31"></a><span class="line-modified"> 698             next = jsEmptyString(&amp;exec);</span>
 699         } else
 700             next = element.toString(&amp;exec);
 701         RETURN_IF_EXCEPTION(scope, { });
 702 
 703         // a. Let S be the String value produced by concatenating R and sep.
 704         // d. Let R be a String value produced by concatenating S and next.
 705         r = jsString(&amp;exec, r, separator, next);
 706         RETURN_IF_EXCEPTION(scope, { });
 707     }
 708     // 10. Return R.
 709     return r;
 710 }
 711 
 712 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState* exec)
 713 {
 714     VM&amp; vm = exec-&gt;vm();
 715     auto scope = DECLARE_THROW_SCOPE(vm);
 716 
 717     // 1. Let O be ? ToObject(this value).
 718     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
 719     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 720     if (UNLIKELY(!thisObject))
 721         return encodedJSValue();
 722 
 723     StringRecursionChecker checker(exec, thisObject);
 724     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 725     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 726         return JSValue::encode(earlyReturnValue);
 727 
 728     // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).
 729     double length = toLength(exec, thisObject);
 730     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 731 
 732     // 3. If separator is undefined, let separator be the single-element String &quot;,&quot;.
 733     JSValue separatorValue = exec-&gt;argument(0);
 734     if (separatorValue.isUndefined()) {
 735         const LChar comma = &#39;,&#39;;
 736 
 737         if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 738             uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 739             ASSERT(static_cast&lt;double&gt;(length64) == length);
<a name="32" id="anc32"></a><span class="line-modified"> 740             JSString* jsSeparator = jsSingleCharacterString(exec, comma);</span>
 741             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 742 
 743             RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
 744         }
 745 
 746         unsigned unsignedLength = static_cast&lt;unsigned&gt;(length);
 747         ASSERT(static_cast&lt;double&gt;(unsignedLength) == length);
 748 
 749         RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, { &amp;comma, 1 }, unsignedLength)));
 750     }
 751 
 752     // 4. Let sep be ? ToString(separator).
 753     JSString* jsSeparator = separatorValue.toString(exec);
 754     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 755 
 756     if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 757         uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 758         ASSERT(static_cast&lt;double&gt;(length64) == length);
 759 
 760         RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
 761     }
 762 
 763     auto viewWithString = jsSeparator-&gt;viewWithUnderlyingString(exec);
 764     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 765 
 766     RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, viewWithString.view, length)));
 767 }
 768 
 769 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState* exec)
 770 {
 771     VM&amp; vm = exec-&gt;vm();
 772     auto scope = DECLARE_THROW_SCOPE(vm);
 773 
 774     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
 775 
 776     if (isJSArray(thisValue))
 777         RELEASE_AND_RETURN(scope, JSValue::encode(asArray(thisValue)-&gt;pop(exec)));
 778 
 779     JSObject* thisObj = thisValue.toObject(exec);
 780     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 781     if (UNLIKELY(!thisObj))
 782         return encodedJSValue();
 783     unsigned length = toLength(exec, thisObj);
 784     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 785 
 786     if (length == 0) {
 787         scope.release();
 788         putLength(exec, vm, thisObj, jsNumber(length));
 789         return JSValue::encode(jsUndefined());
 790     }
 791 
 792     JSValue result = thisObj-&gt;get(exec, length - 1);
 793     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 794     bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, length - 1);
 795     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 796     if (UNLIKELY(!success)) {
 797         throwTypeError(exec, scope, UnableToDeletePropertyError);
 798         return encodedJSValue();
 799     }
 800     scope.release();
 801     putLength(exec, vm, thisObj, jsNumber(length - 1));
 802     return JSValue::encode(result);
 803 }
 804 
 805 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState* exec)
 806 {
 807     VM&amp; vm = exec-&gt;vm();
 808     auto scope = DECLARE_THROW_SCOPE(vm);
 809     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
 810 
 811     if (LIKELY(isJSArray(thisValue) &amp;&amp; exec-&gt;argumentCount() == 1)) {
 812         JSArray* array = asArray(thisValue);
 813         scope.release();
 814         array-&gt;pushInline(exec, exec-&gt;uncheckedArgument(0));
 815         return JSValue::encode(jsNumber(array-&gt;length()));
 816     }
 817 
 818     JSObject* thisObj = thisValue.toObject(exec);
 819     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 820     if (UNLIKELY(!thisObj))
 821         return encodedJSValue();
 822     unsigned length = toLength(exec, thisObj);
 823     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 824 
 825     for (unsigned n = 0; n &lt; exec-&gt;argumentCount(); n++) {
 826         // Check for integer overflow; where safe we can do a fast put by index.
 827         if (length + n &gt;= length)
 828             thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, exec, length + n, exec-&gt;uncheckedArgument(n), true);
 829         else {
 830             PutPropertySlot slot(thisObj);
<a name="33" id="anc33"></a><span class="line-modified"> 831             Identifier propertyName = Identifier::fromString(exec, JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(exec));</span>
 832             thisObj-&gt;methodTable(vm)-&gt;put(thisObj, exec, propertyName, exec-&gt;uncheckedArgument(n), slot);
 833         }
 834         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 835     }
 836 
 837     JSValue newLength(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(exec-&gt;argumentCount()));
 838     scope.release();
 839     putLength(exec, vm, thisObj, newLength);
 840     return JSValue::encode(newLength);
 841 }
 842 
 843 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState* exec)
 844 {
 845     VM&amp; vm = exec-&gt;vm();
 846     auto scope = DECLARE_THROW_SCOPE(vm);
 847 
 848     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
 849     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 850     if (UNLIKELY(!thisObject))
 851         return encodedJSValue();
 852 
 853     unsigned length = toLength(exec, thisObject);
 854     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 855 
 856     thisObject-&gt;ensureWritable(vm);
 857 
 858     switch (thisObject-&gt;indexingType()) {
 859     case ALL_CONTIGUOUS_INDEXING_TYPES:
 860     case ALL_INT32_INDEXING_TYPES: {
 861         auto&amp; butterfly = *thisObject-&gt;butterfly();
 862         if (length &gt; butterfly.publicLength())
 863             break;
 864         auto data = butterfly.contiguous().data();
 865         if (containsHole(data, length) &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 866             break;
 867         std::reverse(data, data + length);
 868         if (!hasInt32(thisObject-&gt;indexingType()))
 869             vm.heap.writeBarrier(thisObject);
 870         return JSValue::encode(thisObject);
 871     }
 872     case ALL_DOUBLE_INDEXING_TYPES: {
 873         auto&amp; butterfly = *thisObject-&gt;butterfly();
 874         if (length &gt; butterfly.publicLength())
 875             break;
 876         auto data = butterfly.contiguousDouble().data();
 877         if (containsHole(data, length) &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 878             break;
 879         std::reverse(data, data + length);
 880         return JSValue::encode(thisObject);
 881     }
 882     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 883         auto&amp; storage = *thisObject-&gt;butterfly()-&gt;arrayStorage();
 884         if (length &gt; storage.vectorLength())
 885             break;
 886         if (storage.hasHoles() &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 887             break;
 888         auto data = storage.vector().data();
 889         std::reverse(data, data + length);
 890         vm.heap.writeBarrier(thisObject);
 891         return JSValue::encode(thisObject);
 892     }
 893     }
 894 
 895     unsigned middle = length / 2;
 896     for (unsigned lower = 0; lower &lt; middle; lower++) {
 897         unsigned upper = length - lower - 1;
 898         bool lowerExists = thisObject-&gt;hasProperty(exec, lower);
 899         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 900         JSValue lowerValue;
 901         if (lowerExists) {
 902             lowerValue = thisObject-&gt;get(exec, lower);
 903             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 904         }
 905 
 906         bool upperExists = thisObject-&gt;hasProperty(exec, upper);
 907         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 908         JSValue upperValue;
 909         if (upperExists) {
 910             upperValue = thisObject-&gt;get(exec, upper);
 911             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 912         }
 913 
 914         if (upperExists) {
 915             thisObject-&gt;putByIndexInline(exec, lower, upperValue, true);
 916             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 917         } else {
 918             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, lower);
 919             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 920             if (UNLIKELY(!success)) {
 921                 throwTypeError(exec, scope, UnableToDeletePropertyError);
 922                 return encodedJSValue();
 923             }
 924         }
 925 
 926         if (lowerExists) {
 927             thisObject-&gt;putByIndexInline(exec, upper, lowerValue, true);
 928             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 929         } else {
 930             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, upper);
 931             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 932             if (UNLIKELY(!success)) {
 933                 throwTypeError(exec, scope, UnableToDeletePropertyError);
 934                 return encodedJSValue();
 935             }
 936         }
 937     }
 938     return JSValue::encode(thisObject);
 939 }
 940 
 941 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState* exec)
 942 {
 943     VM&amp; vm = exec-&gt;vm();
 944     auto scope = DECLARE_THROW_SCOPE(vm);
 945     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
 946     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 947     if (UNLIKELY(!thisObj))
 948         return encodedJSValue();
 949     unsigned length = toLength(exec, thisObj);
 950     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 951 
 952     if (length == 0) {
 953         scope.release();
 954         putLength(exec, vm, thisObj, jsNumber(length));
 955         return JSValue::encode(jsUndefined());
 956     }
 957 
 958     JSValue result = thisObj-&gt;getIndex(exec, 0);
 959     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 960     shift&lt;JSArray::ShiftCountForShift&gt;(exec, thisObj, 0, 1, 0, length);
 961     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 962     scope.release();
 963     putLength(exec, vm, thisObj, jsNumber(length - 1));
 964     return JSValue::encode(result);
 965 }
 966 
 967 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)
 968 {
 969     // https://tc39.github.io/ecma262/#sec-array.prototype.slice
 970     VM&amp; vm = exec-&gt;vm();
 971     auto scope = DECLARE_THROW_SCOPE(vm);
 972     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
 973     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 974     if (UNLIKELY(!thisObj))
 975         return { };
 976     unsigned length = toLength(exec, thisObj);
 977     RETURN_IF_EXCEPTION(scope, { });
 978 
 979     unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);
 980     RETURN_IF_EXCEPTION(scope, { });
 981     unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length);
 982     RETURN_IF_EXCEPTION(scope, { });
 983     if (end &lt; begin)
 984         end = begin;
 985 
 986     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, end - begin);
 987     // We can only get an exception if we call some user function.
 988     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
 989     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
 990         return { };
 991 
 992     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj);
 993     RETURN_IF_EXCEPTION(scope, { });
 994     if (LIKELY(okToDoFastPath)) {
 995         if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))
 996             return JSValue::encode(result);
 997     }
 998 
 999     JSObject* result;
1000     if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1001         result = speciesResult.second;
1002     else {
1003         result = constructEmptyArray(exec, nullptr, end - begin);
1004         RETURN_IF_EXCEPTION(scope, { });
1005     }
1006 
1007     // Document that we need to keep the source array alive until after anything
1008     // that can GC (e.g. allocating the result array).
1009     thisObj-&gt;use();
1010 
1011     unsigned n = 0;
1012     for (unsigned k = begin; k &lt; end; k++, n++) {
1013         JSValue v = getProperty(exec, thisObj, k);
1014         RETURN_IF_EXCEPTION(scope, { });
1015         if (v) {
1016             result-&gt;putDirectIndex(exec, n, v, 0, PutDirectIndexShouldThrow);
1017             RETURN_IF_EXCEPTION(scope, { });
1018         }
1019     }
1020     scope.release();
1021     setLength(exec, vm, result, n);
1022     return JSValue::encode(result);
1023 }
1024 
1025 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec)
1026 {
1027     // 15.4.4.12
1028 
1029     VM&amp; vm = exec-&gt;vm();
1030     auto scope = DECLARE_THROW_SCOPE(vm);
1031 
1032     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
1033     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1034     if (UNLIKELY(!thisObj))
1035         return encodedJSValue();
1036     unsigned length = toLength(exec, thisObj);
1037     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1038 
1039     if (!exec-&gt;argumentCount()) {
1040         std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, 0);
1041         EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1042         if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
1043             return encodedJSValue();
1044 
1045         JSObject* result;
1046         if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1047             result = speciesResult.second;
1048         else {
1049             result = constructEmptyArray(exec, nullptr);
1050             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1051         }
1052 
1053         setLength(exec, vm, result, 0);
1054         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1055         scope.release();
1056         setLength(exec, vm, thisObj, length);
1057         return JSValue::encode(result);
1058     }
1059 
1060     unsigned actualStart = argumentClampedIndexFromStartOrEnd(exec, 0, length);
1061     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1062 
1063     unsigned actualDeleteCount = length - actualStart;
1064     if (exec-&gt;argumentCount() &gt; 1) {
1065         double deleteCount = exec-&gt;uncheckedArgument(1).toInteger(exec);
1066         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1067         if (deleteCount &lt; 0)
1068             actualDeleteCount = 0;
1069         else if (deleteCount &gt; length - actualStart)
1070             actualDeleteCount = length - actualStart;
1071         else
1072             actualDeleteCount = static_cast&lt;unsigned&gt;(deleteCount);
1073     }
1074 
1075     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, actualDeleteCount);
1076     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1077     if (speciesResult.first == SpeciesConstructResult::Exception)
1078         return JSValue::encode(jsUndefined());
1079 
1080     JSObject* result = nullptr;
1081     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj);
1082     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1083     if (LIKELY(okToDoFastPath))
1084         result = asArray(thisObj)-&gt;fastSlice(*exec, actualStart, actualDeleteCount);
1085 
1086     if (!result) {
1087         if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1088             result = speciesResult.second;
1089         else {
1090             result = JSArray::tryCreate(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), actualDeleteCount);
1091             if (UNLIKELY(!result)) {
1092                 throwOutOfMemoryError(exec, scope);
1093                 return encodedJSValue();
1094             }
1095         }
1096         for (unsigned k = 0; k &lt; actualDeleteCount; ++k) {
1097             JSValue v = getProperty(exec, thisObj, k + actualStart);
1098             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1099             if (UNLIKELY(!v))
1100                 continue;
1101             result-&gt;putDirectIndex(exec, k, v, 0, PutDirectIndexShouldThrow);
1102             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1103         }
1104     }
1105 
1106     unsigned itemCount = std::max&lt;int&gt;(exec-&gt;argumentCount() - 2, 0);
1107     if (itemCount &lt; actualDeleteCount) {
1108         shift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);
1109         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1110     } else if (itemCount &gt; actualDeleteCount) {
1111         unshift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);
1112         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1113     }
1114     for (unsigned k = 0; k &lt; itemCount; ++k) {
1115         thisObj-&gt;putByIndexInline(exec, k + actualStart, exec-&gt;uncheckedArgument(k + 2), true);
1116         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1117     }
1118 
1119     scope.release();
1120     setLength(exec, vm, thisObj, length - actualDeleteCount + itemCount);
1121     return JSValue::encode(result);
1122 }
1123 
1124 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState* exec)
1125 {
1126     VM&amp; vm = exec-&gt;vm();
1127     auto scope = DECLARE_THROW_SCOPE(vm);
1128     // 15.4.4.13
1129 
1130     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
1131     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1132     if (UNLIKELY(!thisObj))
1133         return encodedJSValue();
1134     double doubleLength = toLength(exec, thisObj);
1135     unsigned length = doubleLength;
1136     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1137 
1138     unsigned nrArgs = exec-&gt;argumentCount();
1139     if (nrArgs) {
1140         if (UNLIKELY(doubleLength + static_cast&lt;double&gt;(nrArgs) &gt; maxSafeInteger()))
1141             return throwVMTypeError(exec, scope, &quot;Cannot shift to offset greater than (2 ** 53) - 1&quot;_s);
1142         unshift&lt;JSArray::ShiftCountForShift&gt;(exec, thisObj, 0, 0, nrArgs, length);
1143         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1144     }
1145     for (unsigned k = 0; k &lt; nrArgs; ++k) {
1146         thisObj-&gt;putByIndexInline(exec, k, exec-&gt;uncheckedArgument(k), true);
1147         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1148     }
1149     JSValue result = jsNumber(length + nrArgs);
1150     scope.release();
1151     putLength(exec, vm, thisObj, result);
1152     return JSValue::encode(result);
1153 }
1154 
1155 enum class IndexOfDirection { Forward, Backward };
1156 template&lt;IndexOfDirection direction&gt;
1157 ALWAYS_INLINE JSValue fastIndexOf(ExecState* exec, VM&amp; vm, JSArray* array, unsigned length, JSValue searchElement, unsigned index)
1158 {
1159     auto scope = DECLARE_THROW_SCOPE(vm);
1160 
1161     bool canDoFastPath = array-&gt;canDoFastIndexedAccess(vm)
1162         &amp;&amp; array-&gt;getArrayLength() == length; // The effects in getting `index` could have changed the length of this array.
1163     if (!canDoFastPath)
1164         return JSValue();
1165 
1166     switch (array-&gt;indexingType()) {
1167     case ALL_INT32_INDEXING_TYPES: {
1168         if (!searchElement.isNumber())
1169             return jsNumber(-1);
1170         JSValue searchInt32;
1171         if (searchElement.isInt32())
1172             searchInt32 = searchElement;
1173         else {
1174             double searchNumber = searchElement.asNumber();
1175             if (!canBeInt32(searchNumber))
1176                 return jsNumber(-1);
1177             searchInt32 = jsNumber(static_cast&lt;int32_t&gt;(searchNumber));
1178         }
1179         auto&amp; butterfly = *array-&gt;butterfly();
1180         auto data = butterfly.contiguous().data();
1181         if (direction == IndexOfDirection::Forward) {
1182             for (; index &lt; length; ++index) {
1183                 // Array#indexOf uses `===` semantics (not HashMap isEqual semantics).
1184                 // And the hole never matches against Int32 value.
1185                 if (searchInt32 == data[index].get())
1186                     return jsNumber(index);
1187             }
1188         } else {
1189             do {
1190                 ASSERT(index &lt; length);
1191                 // Array#lastIndexOf uses `===` semantics (not HashMap isEqual semantics).
1192                 // And the hole never matches against Int32 value.
1193                 if (searchInt32 == data[index].get())
1194                     return jsNumber(index);
1195             } while (index--);
1196         }
1197         return jsNumber(-1);
1198     }
1199     case ALL_CONTIGUOUS_INDEXING_TYPES: {
1200         auto&amp; butterfly = *array-&gt;butterfly();
1201         auto data = butterfly.contiguous().data();
1202 
1203         if (direction == IndexOfDirection::Forward) {
1204             for (; index &lt; length; ++index) {
1205                 JSValue value = data[index].get();
1206                 if (!value)
1207                     continue;
1208                 bool isEqual = JSValue::strictEqual(exec, searchElement, value);
1209                 RETURN_IF_EXCEPTION(scope, { });
1210                 if (isEqual)
1211                     return jsNumber(index);
1212             }
1213         } else {
1214             do {
1215                 ASSERT(index &lt; length);
1216                 JSValue value = data[index].get();
1217                 if (!value)
1218                     continue;
1219                 bool isEqual = JSValue::strictEqual(exec, searchElement, value);
1220                 RETURN_IF_EXCEPTION(scope, { });
1221                 if (isEqual)
1222                     return jsNumber(index);
1223             } while (index--);
1224         }
1225         return jsNumber(-1);
1226     }
1227     case ALL_DOUBLE_INDEXING_TYPES: {
1228         if (!searchElement.isNumber())
1229             return jsNumber(-1);
1230         double searchNumber = searchElement.asNumber();
1231         auto&amp; butterfly = *array-&gt;butterfly();
1232         auto data = butterfly.contiguousDouble().data();
1233         if (direction == IndexOfDirection::Forward) {
1234             for (; index &lt; length; ++index) {
1235                 // Array#indexOf uses `===` semantics (not HashMap isEqual semantics).
1236                 // And the hole never matches since it is NaN.
1237                 if (data[index] == searchNumber)
1238                     return jsNumber(index);
1239             }
1240         } else {
1241             do {
1242                 ASSERT(index &lt; length);
1243                 // Array#lastIndexOf uses `===` semantics (not HashMap isEqual semantics).
1244                 // And the hole never matches since it is NaN.
1245                 if (data[index] == searchNumber)
1246                     return jsNumber(index);
1247             } while (index--);
1248         }
1249         return jsNumber(-1);
1250     }
1251     default:
1252         return JSValue();
1253     }
1254 }
1255 
1256 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState* exec)
1257 {
1258     VM&amp; vm = exec-&gt;vm();
1259     auto scope = DECLARE_THROW_SCOPE(vm);
1260 
1261     // 15.4.4.14
1262     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
1263     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
1264     if (UNLIKELY(!thisObject))
1265         return { };
1266     unsigned length = toLength(exec, thisObject);
1267     RETURN_IF_EXCEPTION(scope, { });
1268 
1269     unsigned index = argumentClampedIndexFromStartOrEnd(exec, 1, length);
1270     RETURN_IF_EXCEPTION(scope, { });
1271     JSValue searchElement = exec-&gt;argument(0);
1272 
1273     if (isJSArray(thisObject)) {
1274         JSValue result = fastIndexOf&lt;IndexOfDirection::Forward&gt;(exec, vm, asArray(thisObject), length, searchElement, index);
1275         RETURN_IF_EXCEPTION(scope, { });
1276         if (result)
1277             return JSValue::encode(result);
1278     }
1279 
1280     for (; index &lt; length; ++index) {
1281         JSValue e = getProperty(exec, thisObject, index);
1282         RETURN_IF_EXCEPTION(scope, { });
1283         if (!e)
1284             continue;
1285         bool isEqual = JSValue::strictEqual(exec, searchElement, e);
1286         RETURN_IF_EXCEPTION(scope, { });
1287         if (isEqual)
1288             return JSValue::encode(jsNumber(index));
1289     }
1290 
1291     return JSValue::encode(jsNumber(-1));
1292 }
1293 
1294 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState* exec)
1295 {
1296     VM&amp; vm = exec-&gt;vm();
1297     auto scope = DECLARE_THROW_SCOPE(vm);
1298 
1299     // 15.4.4.15
1300     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
1301     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
1302     if (UNLIKELY(!thisObject))
1303         return { };
1304     unsigned length = toLength(exec, thisObject);
1305     if (UNLIKELY(scope.exception()) || !length)
1306         return JSValue::encode(jsNumber(-1));
1307 
1308     unsigned index = length - 1;
1309     if (exec-&gt;argumentCount() &gt;= 2) {
1310         JSValue fromValue = exec-&gt;uncheckedArgument(1);
1311         double fromDouble = fromValue.toInteger(exec);
1312         RETURN_IF_EXCEPTION(scope, { });
1313         if (fromDouble &lt; 0) {
1314             fromDouble += length;
1315             if (fromDouble &lt; 0)
1316                 return JSValue::encode(jsNumber(-1));
1317         }
1318         if (fromDouble &lt; length)
1319             index = static_cast&lt;unsigned&gt;(fromDouble);
1320     }
1321 
1322     JSValue searchElement = exec-&gt;argument(0);
1323 
1324     if (isJSArray(thisObject)) {
1325         JSValue result = fastIndexOf&lt;IndexOfDirection::Backward&gt;(exec, vm, asArray(thisObject), length, searchElement, index);
1326         RETURN_IF_EXCEPTION(scope, { });
1327         if (result)
1328             return JSValue::encode(result);
1329     }
1330 
1331     do {
1332         ASSERT(index &lt; length);
1333         JSValue e = getProperty(exec, thisObject, index);
1334         RETURN_IF_EXCEPTION(scope, { });
1335         if (!e)
1336             continue;
1337         bool isEqual = JSValue::strictEqual(exec, searchElement, e);
1338         RETURN_IF_EXCEPTION(scope, { });
1339         if (isEqual)
1340             return JSValue::encode(jsNumber(index));
1341     } while (index--);
1342 
1343     return JSValue::encode(jsNumber(-1));
1344 }
1345 
1346 static bool moveElements(ExecState* exec, VM&amp; vm, JSArray* target, unsigned targetOffset, JSArray* source, unsigned sourceLength)
1347 {
1348     auto scope = DECLARE_THROW_SCOPE(vm);
1349 
1350     if (LIKELY(!hasAnyArrayStorage(source-&gt;indexingType()) &amp;&amp; !holesMustForwardToPrototype(vm, source))) {
1351         for (unsigned i = 0; i &lt; sourceLength; ++i) {
1352             JSValue value = source-&gt;tryGetIndexQuickly(i);
1353             if (value) {
1354                 target-&gt;putDirectIndex(exec, targetOffset + i, value, 0, PutDirectIndexShouldThrow);
1355                 RETURN_IF_EXCEPTION(scope, false);
1356             }
1357         }
1358     } else {
1359         for (unsigned i = 0; i &lt; sourceLength; ++i) {
1360             JSValue value = getProperty(exec, source, i);
1361             RETURN_IF_EXCEPTION(scope, false);
1362             if (value) {
1363                 target-&gt;putDirectIndex(exec, targetOffset + i, value, 0, PutDirectIndexShouldThrow);
1364                 RETURN_IF_EXCEPTION(scope, false);
1365             }
1366         }
1367     }
1368     return true;
1369 }
1370 
1371 static EncodedJSValue concatAppendOne(ExecState* exec, VM&amp; vm, JSArray* first, JSValue second)
1372 {
1373     auto scope = DECLARE_THROW_SCOPE(vm);
1374 
1375     ASSERT(!isJSArray(second));
1376     ASSERT(!shouldUseSlowPut(first-&gt;indexingType()));
1377     Butterfly* firstButterfly = first-&gt;butterfly();
1378     unsigned firstArraySize = firstButterfly-&gt;publicLength();
1379 
1380     Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
1381     checkedResultSize += 1;
1382     if (UNLIKELY(checkedResultSize.hasOverflowed())) {
1383         throwOutOfMemoryError(exec, scope);
1384         return encodedJSValue();
1385     }
1386 
1387     unsigned resultSize = checkedResultSize.unsafeGet();
1388     IndexingType type = first-&gt;mergeIndexingTypeForCopying(indexingTypeForValue(second) | IsArray);
1389 
1390     if (type == NonArray)
1391         type = first-&gt;indexingType();
1392 
1393     Structure* resultStructure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(type);
1394     JSArray* result = JSArray::tryCreate(vm, resultStructure, resultSize);
1395     if (UNLIKELY(!result)) {
1396         throwOutOfMemoryError(exec, scope);
1397         return encodedJSValue();
1398     }
1399 
1400     bool success = result-&gt;appendMemcpy(exec, vm, 0, first);
1401     EXCEPTION_ASSERT(!scope.exception() || !success);
1402     if (!success) {
1403         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1404 
1405         bool success = moveElements(exec, vm, result, 0, first, firstArraySize);
1406         EXCEPTION_ASSERT(!scope.exception() == success);
1407         if (UNLIKELY(!success))
1408             return encodedJSValue();
1409     }
1410 
1411     scope.release();
1412     result-&gt;putDirectIndex(exec, firstArraySize, second);
1413     return JSValue::encode(result);
1414 
1415 }
1416 
1417 template&lt;typename T&gt;
1418 void clearElement(T&amp; element)
1419 {
1420     element.clear();
1421 }
1422 
1423 template&lt;&gt;
1424 void clearElement(double&amp; element)
1425 {
1426     element = PNaN;
1427 }
1428 
1429 template&lt;typename T&gt;
1430 ALWAYS_INLINE void copyElements(T* buffer, unsigned offset, void* source, unsigned sourceSize, IndexingType sourceType)
1431 {
1432     if (sourceType != ArrayWithUndecided) {
1433         memcpy(buffer + offset, source, sizeof(JSValue) * sourceSize);
1434         return;
1435     }
1436 
1437     for (unsigned i = sourceSize; i--;)
1438         clearElement&lt;T&gt;(buffer[i + offset]);
1439 };
1440 
1441 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncConcatMemcpy(ExecState* exec)
1442 {
1443     ASSERT(exec-&gt;argumentCount() == 2);
1444     VM&amp; vm = exec-&gt;vm();
1445     auto scope = DECLARE_THROW_SCOPE(vm);
1446 
1447     JSArray* firstArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));
1448 
1449     // This code assumes that neither array has set Symbol.isConcatSpreadable. If the first array
1450     // has indexed accessors then one of those accessors might change the value of Symbol.isConcatSpreadable
1451     // on the second argument.
1452     if (UNLIKELY(shouldUseSlowPut(firstArray-&gt;indexingType())))
1453         return JSValue::encode(jsNull());
1454 
1455     // We need to check the species constructor here since checking it in the JS wrapper is too expensive for the non-optimizing tiers.
1456     bool isValid = speciesWatchpointIsValid(exec, firstArray);
1457     scope.assertNoException();
1458     if (UNLIKELY(!isValid))
1459         return JSValue::encode(jsNull());
1460 
1461     JSValue second = exec-&gt;uncheckedArgument(1);
1462     if (!isJSArray(second))
1463         RELEASE_AND_RETURN(scope, concatAppendOne(exec, vm, firstArray, second));
1464 
1465     JSArray* secondArray = jsCast&lt;JSArray*&gt;(second);
1466 
1467     Butterfly* firstButterfly = firstArray-&gt;butterfly();
1468     Butterfly* secondButterfly = secondArray-&gt;butterfly();
1469 
1470     unsigned firstArraySize = firstButterfly-&gt;publicLength();
1471     unsigned secondArraySize = secondButterfly-&gt;publicLength();
1472 
1473     Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
1474     checkedResultSize += secondArraySize;
1475 
1476     if (UNLIKELY(checkedResultSize.hasOverflowed())) {
1477         throwOutOfMemoryError(exec, scope);
1478         return encodedJSValue();
1479     }
1480 
1481     unsigned resultSize = checkedResultSize.unsafeGet();
1482     IndexingType firstType = firstArray-&gt;indexingType();
1483     IndexingType secondType = secondArray-&gt;indexingType();
1484     IndexingType type = firstArray-&gt;mergeIndexingTypeForCopying(secondType);
1485     if (type == NonArray || !firstArray-&gt;canFastCopy(vm, secondArray) || resultSize &gt;= MIN_SPARSE_ARRAY_INDEX) {
1486         JSArray* result = constructEmptyArray(exec, nullptr, resultSize);
1487         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1488 
1489         bool success = moveElements(exec, vm, result, 0, firstArray, firstArraySize);
1490         EXCEPTION_ASSERT(!scope.exception() == success);
1491         if (UNLIKELY(!success))
1492             return encodedJSValue();
1493         success = moveElements(exec, vm, result, firstArraySize, secondArray, secondArraySize);
1494         EXCEPTION_ASSERT(!scope.exception() == success);
1495         if (UNLIKELY(!success))
1496             return encodedJSValue();
1497 
1498         return JSValue::encode(result);
1499     }
1500 
1501     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();
1502     Structure* resultStructure = lexicalGlobalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(type);
1503     if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
1504         return JSValue::encode(jsNull());
1505 
1506     ASSERT(!lexicalGlobalObject-&gt;isHavingABadTime());
1507     ObjectInitializationScope initializationScope(vm);
1508     JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, resultStructure, resultSize);
1509     if (UNLIKELY(!result)) {
1510         throwOutOfMemoryError(exec, scope);
1511         return encodedJSValue();
1512     }
1513 
1514     if (type == ArrayWithDouble) {
1515         double* buffer = result-&gt;butterfly()-&gt;contiguousDouble().data();
1516         copyElements(buffer, 0, firstButterfly-&gt;contiguousDouble().data(), firstArraySize, firstType);
1517         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguousDouble().data(), secondArraySize, secondType);
1518 
1519     } else if (type != ArrayWithUndecided) {
1520         WriteBarrier&lt;Unknown&gt;* buffer = result-&gt;butterfly()-&gt;contiguous().data();
1521         copyElements(buffer, 0, firstButterfly-&gt;contiguous().data(), firstArraySize, firstType);
1522         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguous().data(), secondArraySize, secondType);
1523     }
1524 
1525     result-&gt;butterfly()-&gt;setPublicLength(resultSize);
1526     return JSValue::encode(result);
1527 }
1528 
1529 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(ExecState* exec)
1530 {
1531     ASSERT(exec-&gt;argumentCount() == 3);
1532 
1533     VM&amp; vm = exec-&gt;vm();
1534     auto scope = DECLARE_THROW_SCOPE(vm);
1535     JSArray* resultArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));
1536     JSArray* otherArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(1));
1537     JSValue startValue = exec-&gt;uncheckedArgument(2);
<a name="34" id="anc34"></a><span class="line-modified">1538     ASSERT(startValue.isAnyInt() &amp;&amp; startValue.asAnyInt() &gt;= 0 &amp;&amp; startValue.asAnyInt() &lt;= std::numeric_limits&lt;unsigned&gt;::max());</span>
<span class="line-modified">1539     unsigned startIndex = static_cast&lt;unsigned&gt;(startValue.asAnyInt());</span>
1540     bool success = resultArray-&gt;appendMemcpy(exec, vm, startIndex, otherArray);
1541     EXCEPTION_ASSERT(!scope.exception() || !success);
1542     if (success)
1543         return JSValue::encode(jsUndefined());
1544     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1545     scope.release();
1546     moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());
1547     return JSValue::encode(jsUndefined());
1548 }
1549 
<a name="35" id="anc35"></a><span class="line-removed">1550 </span>
<span class="line-removed">1551 // -------------------- ArrayPrototype.constructor Watchpoint ------------------</span>
<span class="line-removed">1552 </span>
<span class="line-removed">1553 namespace ArrayPrototypeInternal {</span>
<span class="line-removed">1554 static bool verbose = false;</span>
<span class="line-removed">1555 }</span>
<span class="line-removed">1556 </span>
<span class="line-removed">1557 class ArrayPrototypeAdaptiveInferredPropertyWatchpoint : public AdaptiveInferredPropertyValueWatchpointBase {</span>
<span class="line-removed">1558 public:</span>
<span class="line-removed">1559     typedef AdaptiveInferredPropertyValueWatchpointBase Base;</span>
<span class="line-removed">1560     ArrayPrototypeAdaptiveInferredPropertyWatchpoint(const ObjectPropertyCondition&amp;, ArrayPrototype*);</span>
<span class="line-removed">1561 </span>
<span class="line-removed">1562 private:</span>
<span class="line-removed">1563     void handleFire(VM&amp;, const FireDetail&amp;) override;</span>
<span class="line-removed">1564 </span>
<span class="line-removed">1565     ArrayPrototype* m_arrayPrototype;</span>
<span class="line-removed">1566 };</span>
<span class="line-removed">1567 </span>
<span class="line-removed">1568 void ArrayPrototype::tryInitializeSpeciesWatchpoint(ExecState* exec)</span>
<span class="line-removed">1569 {</span>
<span class="line-removed">1570     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">1571 </span>
<span class="line-removed">1572     RELEASE_ASSERT(!m_constructorWatchpoint);</span>
<span class="line-removed">1573     RELEASE_ASSERT(!m_constructorSpeciesWatchpoint);</span>
<span class="line-removed">1574 </span>
<span class="line-removed">1575     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">1576 </span>
<span class="line-removed">1577     if (ArrayPrototypeInternal::verbose)</span>
<span class="line-removed">1578         dataLog(&quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(this), &quot; with structure: &quot;, pointerDump(this-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(this-&gt;globalObject(vm)-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(this-&gt;globalObject(vm)-&gt;arrayConstructor()-&gt;structure(vm)), &quot;\n&quot;);</span>
<span class="line-removed">1579     // First we need to make sure that the Array.prototype.constructor property points to Array</span>
<span class="line-removed">1580     // and that Array[Symbol.species] is the primordial GetterSetter.</span>
<span class="line-removed">1581 </span>
<span class="line-removed">1582     // We only initialize once so flattening the structures does not have any real cost.</span>
<span class="line-removed">1583     Structure* prototypeStructure = this-&gt;structure(vm);</span>
<span class="line-removed">1584     if (prototypeStructure-&gt;isDictionary())</span>
<span class="line-removed">1585         prototypeStructure = prototypeStructure-&gt;flattenDictionaryStructure(vm, this);</span>
<span class="line-removed">1586     RELEASE_ASSERT(!prototypeStructure-&gt;isDictionary());</span>
<span class="line-removed">1587 </span>
<span class="line-removed">1588     JSGlobalObject* globalObject = this-&gt;globalObject(vm);</span>
<span class="line-removed">1589     ArrayConstructor* arrayConstructor = globalObject-&gt;arrayConstructor();</span>
<span class="line-removed">1590 </span>
<span class="line-removed">1591     auto invalidateWatchpoint = [&amp;] {</span>
<span class="line-removed">1592         globalObject-&gt;arraySpeciesWatchpoint().invalidate(vm, StringFireDetail(&quot;Was not able to set up array species watchpoint.&quot;));</span>
<span class="line-removed">1593     };</span>
<span class="line-removed">1594 </span>
<span class="line-removed">1595     PropertySlot constructorSlot(this, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-removed">1596     this-&gt;getOwnPropertySlot(this, exec, vm.propertyNames-&gt;constructor, constructorSlot);</span>
<span class="line-removed">1597     scope.assertNoException();</span>
<span class="line-removed">1598     if (constructorSlot.slotBase() != this</span>
<span class="line-removed">1599         || !constructorSlot.isCacheableValue()</span>
<span class="line-removed">1600         || constructorSlot.getValue(exec, vm.propertyNames-&gt;constructor) != arrayConstructor) {</span>
<span class="line-removed">1601         invalidateWatchpoint();</span>
<span class="line-removed">1602         return;</span>
<span class="line-removed">1603     }</span>
<span class="line-removed">1604 </span>
<span class="line-removed">1605     Structure* constructorStructure = arrayConstructor-&gt;structure(vm);</span>
<span class="line-removed">1606     if (constructorStructure-&gt;isDictionary())</span>
<span class="line-removed">1607         constructorStructure = constructorStructure-&gt;flattenDictionaryStructure(vm, arrayConstructor);</span>
<span class="line-removed">1608 </span>
<span class="line-removed">1609     PropertySlot speciesSlot(arrayConstructor, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-removed">1610     arrayConstructor-&gt;getOwnPropertySlot(arrayConstructor, exec, vm.propertyNames-&gt;speciesSymbol, speciesSlot);</span>
<span class="line-removed">1611     scope.assertNoException();</span>
<span class="line-removed">1612     if (speciesSlot.slotBase() != arrayConstructor</span>
<span class="line-removed">1613         || !speciesSlot.isCacheableGetter()</span>
<span class="line-removed">1614         || speciesSlot.getterSetter() != globalObject-&gt;speciesGetterSetter()) {</span>
<span class="line-removed">1615         invalidateWatchpoint();</span>
<span class="line-removed">1616         return;</span>
<span class="line-removed">1617     }</span>
<span class="line-removed">1618 </span>
<span class="line-removed">1619     // Now we need to setup the watchpoints to make sure these conditions remain valid.</span>
<span class="line-removed">1620     prototypeStructure-&gt;startWatchingPropertyForReplacements(vm, constructorSlot.cachedOffset());</span>
<span class="line-removed">1621     constructorStructure-&gt;startWatchingPropertyForReplacements(vm, speciesSlot.cachedOffset());</span>
<span class="line-removed">1622 </span>
<span class="line-removed">1623     ObjectPropertyCondition constructorCondition = ObjectPropertyCondition::equivalence(vm, this, this, vm.propertyNames-&gt;constructor.impl(), arrayConstructor);</span>
<span class="line-removed">1624     ObjectPropertyCondition speciesCondition = ObjectPropertyCondition::equivalence(vm, this, arrayConstructor, vm.propertyNames-&gt;speciesSymbol.impl(), globalObject-&gt;speciesGetterSetter());</span>
<span class="line-removed">1625 </span>
<span class="line-removed">1626     if (!constructorCondition.isWatchable() || !speciesCondition.isWatchable()) {</span>
<span class="line-removed">1627         invalidateWatchpoint();</span>
<span class="line-removed">1628         return;</span>
<span class="line-removed">1629     }</span>
<span class="line-removed">1630 </span>
<span class="line-removed">1631     m_constructorWatchpoint = std::make_unique&lt;ArrayPrototypeAdaptiveInferredPropertyWatchpoint&gt;(constructorCondition, this);</span>
<span class="line-removed">1632     m_constructorWatchpoint-&gt;install(vm);</span>
<span class="line-removed">1633 </span>
<span class="line-removed">1634     m_constructorSpeciesWatchpoint = std::make_unique&lt;ArrayPrototypeAdaptiveInferredPropertyWatchpoint&gt;(speciesCondition, this);</span>
<span class="line-removed">1635     m_constructorSpeciesWatchpoint-&gt;install(vm);</span>
<span class="line-removed">1636 </span>
<span class="line-removed">1637     // We only watch this from the DFG, and the DFG makes sure to only start watching if the watchpoint is in the IsWatched state.</span>
<span class="line-removed">1638     RELEASE_ASSERT(!globalObject-&gt;arraySpeciesWatchpoint().isBeingWatched());</span>
<span class="line-removed">1639     globalObject-&gt;arraySpeciesWatchpoint().touch(vm, &quot;Set up array species watchpoint.&quot;);</span>
<span class="line-removed">1640 }</span>
<span class="line-removed">1641 </span>
<span class="line-removed">1642 ArrayPrototypeAdaptiveInferredPropertyWatchpoint::ArrayPrototypeAdaptiveInferredPropertyWatchpoint(const ObjectPropertyCondition&amp; key, ArrayPrototype* prototype)</span>
<span class="line-removed">1643     : Base(key)</span>
<span class="line-removed">1644     , m_arrayPrototype(prototype)</span>
<span class="line-removed">1645 {</span>
<span class="line-removed">1646 }</span>
<span class="line-removed">1647 </span>
<span class="line-removed">1648 void ArrayPrototypeAdaptiveInferredPropertyWatchpoint::handleFire(VM&amp; vm, const FireDetail&amp; detail)</span>
<span class="line-removed">1649 {</span>
<span class="line-removed">1650     auto lazyDetail = createLazyFireDetail(&quot;ArrayPrototype adaption of &quot;, key(), &quot; failed: &quot;, detail);</span>
<span class="line-removed">1651 </span>
<span class="line-removed">1652     if (ArrayPrototypeInternal::verbose)</span>
<span class="line-removed">1653         WTF::dataLog(lazyDetail, &quot;\n&quot;);</span>
<span class="line-removed">1654 </span>
<span class="line-removed">1655     JSGlobalObject* globalObject = m_arrayPrototype-&gt;globalObject(vm);</span>
<span class="line-removed">1656     globalObject-&gt;arraySpeciesWatchpoint().fireAll(vm, lazyDetail);</span>
<span class="line-removed">1657 }</span>
<span class="line-removed">1658 </span>
1659 } // namespace JSC
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>