<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fast-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="double-conversion.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fast-dtoa.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fast-dtoa.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,21 ***</span>
  #include &lt;wtf/dtoa/diy-fp.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">!     </span>
  // The minimal and maximal target exponent define the range of w&#39;s binary
  // exponent, where &#39;w&#39; is the result of multiplying the input by a cached power
  // of ten.
  //
  // A different range might be chosen on a different platform, to optimize digit
  // generation, but a smaller range requires more powers of ten to be cached.
  static const int kMinimalTargetExponent = -60;
  static const int kMaximalTargetExponent = -32;
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Adjusts the last digit of the generated number, and screens out generated
  // solutions that may be inaccurate. A solution may be inaccurate if it is
  // outside the safe interval, or if we cannot prove that it is closer to the
  // input than a neighboring representation of the same length.
  //
<span class="line-new-header">--- 33,21 ---</span>
  #include &lt;wtf/dtoa/diy-fp.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">! </span>
  // The minimal and maximal target exponent define the range of w&#39;s binary
  // exponent, where &#39;w&#39; is the result of multiplying the input by a cached power
  // of ten.
  //
  // A different range might be chosen on a different platform, to optimize digit
  // generation, but a smaller range requires more powers of ten to be cached.
  static const int kMinimalTargetExponent = -60;
  static const int kMaximalTargetExponent = -32;
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Adjusts the last digit of the generated number, and screens out generated
  // solutions that may be inaccurate. A solution may be inaccurate if it is
  // outside the safe interval, or if we cannot prove that it is closer to the
  // input than a neighboring representation of the same length.
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,117 ***</span>
  //        * unit = the common multiplier
  // Output: returns true if the buffer is guaranteed to contain the closest
  //    representable number to the input.
  //  Modifies the generated digits in the buffer to approach (round towards) w.
  static bool RoundWeed(BufferReference&lt;char&gt; buffer,
<span class="line-modified">!                           int length,</span>
<span class="line-modified">!                           uint64_t distance_too_high_w,</span>
<span class="line-modified">!                           uint64_t unsafe_interval,</span>
<span class="line-modified">!                           uint64_t rest,</span>
<span class="line-modified">!                           uint64_t ten_kappa,</span>
<span class="line-modified">!                           uint64_t unit) {</span>
<span class="line-modified">!         uint64_t small_distance = distance_too_high_w - unit;</span>
<span class="line-modified">!         uint64_t big_distance = distance_too_high_w + unit;</span>
<span class="line-modified">!         // Let w_low  = too_high - big_distance, and</span>
<span class="line-modified">!         //     w_high = too_high - small_distance.</span>
<span class="line-modified">!         // Note: w_low &lt; w &lt; w_high</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // The real w (* unit) must lie somewhere inside the interval</span>
<span class="line-modified">!         // ]w_low; w_high[ (often written as &quot;(w_low; w_high)&quot;)</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Basically the buffer currently contains a number in the unsafe interval</span>
<span class="line-modified">!         // ]too_low; too_high[ with too_low &lt; w &lt; too_high</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         //  too_high - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="line-modified">!         //                     ^v 1 unit            ^      ^                 ^      ^</span>
<span class="line-modified">!         //  boundary_high ---------------------     .      .                 .      .</span>
<span class="line-modified">!         //                     ^v 1 unit            .      .                 .      .</span>
<span class="line-modified">!         //   - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .</span>
<span class="line-modified">!         //                                          .      .         ^       .      .</span>
<span class="line-modified">!         //                                          .  big_distance  .       .      .</span>
<span class="line-modified">!         //                                          .      .         .       .    rest</span>
<span class="line-modified">!         //                              small_distance     .         .       .      .</span>
<span class="line-modified">!         //                                          v      .         .       .      .</span>
<span class="line-modified">!         //  w_high - - - - - - - - - - - - - - - - - -     .         .       .      .</span>
<span class="line-modified">!         //                     ^v 1 unit                   .         .       .      .</span>
<span class="line-modified">!         //  w ----------------------------------------     .         .       .      .</span>
<span class="line-modified">!         //                     ^v 1 unit                   v         .       .      .</span>
<span class="line-modified">!         //  w_low  - - - - - - - - - - - - - - - - - - - - -         .       .      .</span>
<span class="line-modified">!         //                                                           .       .      v</span>
<span class="line-modified">!         //  buffer --------------------------------------------------+-------+--------</span>
<span class="line-modified">!         //                                                           .       .</span>
<span class="line-modified">!         //                                                  safe_interval    .</span>
<span class="line-modified">!         //                                                           v       .</span>
<span class="line-modified">!         //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .</span>
<span class="line-modified">!         //                     ^v 1 unit                                     .</span>
<span class="line-modified">!         //  boundary_low -------------------------                     unsafe_interval</span>
<span class="line-modified">!         //                     ^v 1 unit                                     v</span>
<span class="line-modified">!         //  too_low  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Note that the value of buffer could lie anywhere inside the range too_low</span>
<span class="line-modified">!         // to too_high.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // boundary_low, boundary_high and w are approximations of the real boundaries</span>
<span class="line-modified">!         // and v (the input number). They are guaranteed to be precise up to one unit.</span>
<span class="line-modified">!         // In fact the error is guaranteed to be strictly less than one unit.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Anything that lies outside the unsafe interval is guaranteed not to round</span>
<span class="line-modified">!         // to v when read again.</span>
<span class="line-modified">!         // Anything that lies inside the safe interval is guaranteed to round to v</span>
<span class="line-modified">!         // when read again.</span>
<span class="line-modified">!         // If the number inside the buffer lies inside the unsafe interval but not</span>
<span class="line-modified">!         // inside the safe interval then we simply do not know and bail out (returning</span>
<span class="line-modified">!         // false).</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Similarly we have to take into account the imprecision of &#39;w&#39; when finding</span>
<span class="line-modified">!         // the closest representation of &#39;w&#39;. If we have two potential</span>
<span class="line-modified">!         // representations, and one is closer to both w_low and w_high, then we know</span>
<span class="line-modified">!         // it is closer to the actual value v.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // By generating the digits of too_high we got the largest (closest to</span>
<span class="line-modified">!         // too_high) buffer that is still in the unsafe interval. In the case where</span>
<span class="line-modified">!         // w_high &lt; buffer &lt; too_high we try to decrement the buffer.</span>
<span class="line-modified">!         // This way the buffer approaches (rounds towards) w.</span>
<span class="line-modified">!         // There are 3 conditions that stop the decrementation process:</span>
<span class="line-modified">!         //   1) the buffer is already below w_high</span>
<span class="line-modified">!         //   2) decrementing the buffer would make it leave the unsafe interval</span>
<span class="line-modified">!         //   3) decrementing the buffer would yield a number below w_high and farther</span>
<span class="line-modified">!         //      away than the current number. In other words:</span>
<span class="line-modified">!         //              (buffer{-1} &lt; w_high) &amp;&amp; w_high - buffer{-1} &gt; buffer - w_high</span>
<span class="line-modified">!         // Instead of using the buffer directly we use its distance to too_high.</span>
<span class="line-modified">!         // Conceptually rest ~= too_high - buffer</span>
<span class="line-modified">!         // We need to do the following tests in this order to avoid over- and</span>
<span class="line-modified">!         // underflows.</span>
<span class="line-modified">!         ASSERT(rest &lt;= unsafe_interval);</span>
<span class="line-modified">!         while (rest &lt; small_distance &amp;&amp;  // Negated condition 1</span>
<span class="line-modified">!                unsafe_interval - rest &gt;= ten_kappa &amp;&amp;  // Negated condition 2</span>
<span class="line-modified">!                (rest + ten_kappa &lt; small_distance ||  // buffer{-1} &gt; w_high</span>
<span class="line-modified">!                 small_distance - rest &gt;= rest + ten_kappa - small_distance)) {</span>
<span class="line-modified">!                    buffer[length - 1]--;</span>
<span class="line-modified">!                    rest += ten_kappa;</span>
<span class="line-modified">!                }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // We have approached w+ as much as possible. We now test if approaching w-</span>
<span class="line-modified">!         // would require changing the buffer. If yes, then we have two possible</span>
<span class="line-modified">!         // representations close to w, but we cannot decide which one is closer.</span>
<span class="line-modified">!         if (rest &lt; big_distance &amp;&amp;</span>
<span class="line-modified">!             unsafe_interval - rest &gt;= ten_kappa &amp;&amp;</span>
<span class="line-modified">!             (rest + ten_kappa &lt; big_distance ||</span>
<span class="line-modified">!              big_distance - rest &gt; rest + ten_kappa - big_distance)) {</span>
<span class="line-modified">!                 return false;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Weeding test.</span>
<span class="line-modified">!         //   The safe interval is [too_low + 2 ulp; too_high - 2 ulp]</span>
<span class="line-modified">!         //   Since too_low = too_high - unsafe_interval this is equivalent to</span>
<span class="line-modified">!         //      [too_high - unsafe_interval + 4 ulp; too_high - 2 ulp]</span>
<span class="line-modified">!         //   Conceptually we have: rest ~= too_high - buffer</span>
<span class="line-modified">!         return (2 * unit &lt;= rest) &amp;&amp; (rest &lt;= unsafe_interval - 4 * unit);</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Rounds the buffer upwards if the result is closer to v by possibly adding
  // 1 to the buffer. If the precision of the calculation is not sufficient to
  // round correctly, return false.
  // The rounding might shift the whole buffer in which case the kappa is
  // adjusted. For example &quot;99&quot;, kappa = 3 might become &quot;10&quot;, kappa = 4.
<span class="line-new-header">--- 60,117 ---</span>
  //        * unit = the common multiplier
  // Output: returns true if the buffer is guaranteed to contain the closest
  //    representable number to the input.
  //  Modifies the generated digits in the buffer to approach (round towards) w.
  static bool RoundWeed(BufferReference&lt;char&gt; buffer,
<span class="line-modified">!                       int length,</span>
<span class="line-modified">!                       uint64_t distance_too_high_w,</span>
<span class="line-modified">!                       uint64_t unsafe_interval,</span>
<span class="line-modified">!                       uint64_t rest,</span>
<span class="line-modified">!                       uint64_t ten_kappa,</span>
<span class="line-modified">!                       uint64_t unit) {</span>
<span class="line-modified">!   uint64_t small_distance = distance_too_high_w - unit;</span>
<span class="line-modified">!   uint64_t big_distance = distance_too_high_w + unit;</span>
<span class="line-modified">!   // Let w_low  = too_high - big_distance, and</span>
<span class="line-modified">!   //     w_high = too_high - small_distance.</span>
<span class="line-modified">!   // Note: w_low &lt; w &lt; w_high</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // The real w (* unit) must lie somewhere inside the interval</span>
<span class="line-modified">!   // ]w_low; w_high[ (often written as &quot;(w_low; w_high)&quot;)</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Basically the buffer currently contains a number in the unsafe interval</span>
<span class="line-modified">!   // ]too_low; too_high[ with too_low &lt; w &lt; too_high</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   //  too_high - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="line-modified">!   //                     ^v 1 unit            ^      ^                 ^      ^</span>
<span class="line-modified">!   //  boundary_high ---------------------     .      .                 .      .</span>
<span class="line-modified">!   //                     ^v 1 unit            .      .                 .      .</span>
<span class="line-modified">!   //   - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .</span>
<span class="line-modified">!   //                                          .      .         ^       .      .</span>
<span class="line-modified">!   //                                          .  big_distance  .       .      .</span>
<span class="line-modified">!   //                                          .      .         .       .    rest</span>
<span class="line-modified">!   //                              small_distance     .         .       .      .</span>
<span class="line-modified">!   //                                          v      .         .       .      .</span>
<span class="line-modified">!   //  w_high - - - - - - - - - - - - - - - - - -     .         .       .      .</span>
<span class="line-modified">!   //                     ^v 1 unit                   .         .       .      .</span>
<span class="line-modified">!   //  w ----------------------------------------     .         .       .      .</span>
<span class="line-modified">!   //                     ^v 1 unit                   v         .       .      .</span>
<span class="line-modified">!   //  w_low  - - - - - - - - - - - - - - - - - - - - -         .       .      .</span>
<span class="line-modified">!   //                                                           .       .      v</span>
<span class="line-modified">!   //  buffer --------------------------------------------------+-------+--------</span>
<span class="line-modified">!   //                                                           .       .</span>
<span class="line-modified">!   //                                                  safe_interval    .</span>
<span class="line-modified">!   //                                                           v       .</span>
<span class="line-modified">!   //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .</span>
<span class="line-modified">!   //                     ^v 1 unit                                     .</span>
<span class="line-modified">!   //  boundary_low -------------------------                     unsafe_interval</span>
<span class="line-modified">!   //                     ^v 1 unit                                     v</span>
<span class="line-modified">!   //  too_low  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Note that the value of buffer could lie anywhere inside the range too_low</span>
<span class="line-modified">!   // to too_high.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // boundary_low, boundary_high and w are approximations of the real boundaries</span>
<span class="line-modified">!   // and v (the input number). They are guaranteed to be precise up to one unit.</span>
<span class="line-modified">!   // In fact the error is guaranteed to be strictly less than one unit.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Anything that lies outside the unsafe interval is guaranteed not to round</span>
<span class="line-modified">!   // to v when read again.</span>
<span class="line-modified">!   // Anything that lies inside the safe interval is guaranteed to round to v</span>
<span class="line-modified">!   // when read again.</span>
<span class="line-modified">!   // If the number inside the buffer lies inside the unsafe interval but not</span>
<span class="line-modified">!   // inside the safe interval then we simply do not know and bail out (returning</span>
<span class="line-modified">!   // false).</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Similarly we have to take into account the imprecision of &#39;w&#39; when finding</span>
<span class="line-modified">!   // the closest representation of &#39;w&#39;. If we have two potential</span>
<span class="line-modified">!   // representations, and one is closer to both w_low and w_high, then we know</span>
<span class="line-modified">!   // it is closer to the actual value v.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // By generating the digits of too_high we got the largest (closest to</span>
<span class="line-modified">!   // too_high) buffer that is still in the unsafe interval. In the case where</span>
<span class="line-modified">!   // w_high &lt; buffer &lt; too_high we try to decrement the buffer.</span>
<span class="line-modified">!   // This way the buffer approaches (rounds towards) w.</span>
<span class="line-modified">!   // There are 3 conditions that stop the decrementation process:</span>
<span class="line-modified">!   //   1) the buffer is already below w_high</span>
<span class="line-modified">!   //   2) decrementing the buffer would make it leave the unsafe interval</span>
<span class="line-modified">!   //   3) decrementing the buffer would yield a number below w_high and farther</span>
<span class="line-modified">!   //      away than the current number. In other words:</span>
<span class="line-modified">!   //              (buffer{-1} &lt; w_high) &amp;&amp; w_high - buffer{-1} &gt; buffer - w_high</span>
<span class="line-modified">!   // Instead of using the buffer directly we use its distance to too_high.</span>
<span class="line-modified">!   // Conceptually rest ~= too_high - buffer</span>
<span class="line-modified">!   // We need to do the following tests in this order to avoid over- and</span>
<span class="line-modified">!   // underflows.</span>
<span class="line-modified">!   ASSERT(rest &lt;= unsafe_interval);</span>
<span class="line-modified">!   while (rest &lt; small_distance &amp;&amp;  // Negated condition 1</span>
<span class="line-modified">!          unsafe_interval - rest &gt;= ten_kappa &amp;&amp;  // Negated condition 2</span>
<span class="line-modified">!          (rest + ten_kappa &lt; small_distance ||  // buffer{-1} &gt; w_high</span>
<span class="line-modified">!           small_distance - rest &gt;= rest + ten_kappa - small_distance)) {</span>
<span class="line-modified">!     buffer[length - 1]--;</span>
<span class="line-modified">!     rest += ten_kappa;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // We have approached w+ as much as possible. We now test if approaching w-</span>
<span class="line-modified">!   // would require changing the buffer. If yes, then we have two possible</span>
<span class="line-modified">!   // representations close to w, but we cannot decide which one is closer.</span>
<span class="line-modified">!   if (rest &lt; big_distance &amp;&amp;</span>
<span class="line-modified">!       unsafe_interval - rest &gt;= ten_kappa &amp;&amp;</span>
<span class="line-modified">!       (rest + ten_kappa &lt; big_distance ||</span>
<span class="line-modified">!        big_distance - rest &gt; rest + ten_kappa - big_distance)) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Weeding test.</span>
<span class="line-modified">!   //   The safe interval is [too_low + 2 ulp; too_high - 2 ulp]</span>
<span class="line-modified">!   //   Since too_low = too_high - unsafe_interval this is equivalent to</span>
<span class="line-modified">!   //      [too_high - unsafe_interval + 4 ulp; too_high - 2 ulp]</span>
<span class="line-modified">!   //   Conceptually we have: rest ~= too_high - buffer</span>
<span class="line-modified">!   return (2 * unit &lt;= rest) &amp;&amp; (rest &lt;= unsafe_interval - 4 * unit);</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Rounds the buffer upwards if the result is closer to v by possibly adding
  // 1 to the buffer. If the precision of the calculation is not sufficient to
  // round correctly, return false.
  // The rounding might shift the whole buffer in which case the kappa is
  // adjusted. For example &quot;99&quot;, kappa = 3 might become &quot;10&quot;, kappa = 4.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,53 ***</span>
  // imprecision and returns false, if the rounding direction cannot be
  // unambiguously determined.
  //
  // Precondition: rest &lt; ten_kappa.
  static bool RoundWeedCounted(BufferReference&lt;char&gt; buffer,
<span class="line-modified">!                                  int length,</span>
<span class="line-modified">!                                  uint64_t rest,</span>
<span class="line-modified">!                                  uint64_t ten_kappa,</span>
<span class="line-modified">!                                  uint64_t unit,</span>
<span class="line-modified">!                                  int* kappa) {</span>
<span class="line-modified">!         ASSERT(rest &lt; ten_kappa);</span>
<span class="line-modified">!         // The following tests are done in a specific order to avoid overflows. They</span>
<span class="line-modified">!         // will work correctly with any uint64 values of rest &lt; ten_kappa and unit.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // If the unit is too big, then we don&#39;t know which way to round. For example</span>
<span class="line-modified">!         // a unit of 50 means that the real number lies within rest +/- 50. If</span>
<span class="line-modified">!         // 10^kappa == 40 then there is no way to tell which way to round.</span>
<span class="line-modified">!         if (unit &gt;= ten_kappa) return false;</span>
<span class="line-modified">!         // Even if unit is just half the size of 10^kappa we are already completely</span>
<span class="line-modified">!         // lost. (And after the previous test we know that the expression will not</span>
<span class="line-modified">!         // over/underflow.)</span>
<span class="line-modified">!         if (ten_kappa - unit &lt;= unit) return false;</span>
<span class="line-modified">!         // If 2 * (rest + unit) &lt;= 10^kappa we can safely round down.</span>
<span class="line-modified">!         if ((ten_kappa - rest &gt; rest) &amp;&amp; (ten_kappa - 2 * rest &gt;= 2 * unit)) {</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // If 2 * (rest - unit) &gt;= 10^kappa, then we can safely round up.</span>
<span class="line-modified">!         if ((rest &gt; unit) &amp;&amp; (ten_kappa - (rest - unit) &lt;= (rest - unit))) {</span>
<span class="line-modified">!             // Increment the last digit recursively until we find a non &#39;9&#39; digit.</span>
<span class="line-modified">!             buffer[length - 1]++;</span>
<span class="line-modified">!             for (int i = length - 1; i &gt; 0; --i) {</span>
<span class="line-modified">!                 if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="line-modified">!                 buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">!                 buffer[i - 1]++;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             // If the first digit is now &#39;0&#39;+ 10 we had a buffer with all &#39;9&#39;s. With the</span>
<span class="line-modified">!             // exception of the first digit all digits are now &#39;0&#39;. Simply switch the</span>
<span class="line-modified">!             // first digit to &#39;1&#39; and adjust the kappa. Example: &quot;99&quot; becomes &quot;10&quot; and</span>
<span class="line-modified">!             // the power (the kappa) is increased.</span>
<span class="line-modified">!             if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">!                 buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!                 (*kappa) += 1;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return false;</span>
  }
<span class="line-modified">!     </span>
  // Returns the biggest power of ten that is less than or equal to the given
  // number. We furthermore receive the maximum number of bits &#39;number&#39; has.
  //
  // Returns power == 10^(exponent_plus_one-1) such that
  //    power &lt;= number &lt; power * 10.
<span class="line-new-header">--- 180,53 ---</span>
  // imprecision and returns false, if the rounding direction cannot be
  // unambiguously determined.
  //
  // Precondition: rest &lt; ten_kappa.
  static bool RoundWeedCounted(BufferReference&lt;char&gt; buffer,
<span class="line-modified">!                              int length,</span>
<span class="line-modified">!                              uint64_t rest,</span>
<span class="line-modified">!                              uint64_t ten_kappa,</span>
<span class="line-modified">!                              uint64_t unit,</span>
<span class="line-modified">!                              int* kappa) {</span>
<span class="line-modified">!   ASSERT(rest &lt; ten_kappa);</span>
<span class="line-modified">!   // The following tests are done in a specific order to avoid overflows. They</span>
<span class="line-modified">!   // will work correctly with any uint64 values of rest &lt; ten_kappa and unit.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // If the unit is too big, then we don&#39;t know which way to round. For example</span>
<span class="line-modified">!   // a unit of 50 means that the real number lies within rest +/- 50. If</span>
<span class="line-modified">!   // 10^kappa == 40 then there is no way to tell which way to round.</span>
<span class="line-modified">!   if (unit &gt;= ten_kappa) return false;</span>
<span class="line-modified">!   // Even if unit is just half the size of 10^kappa we are already completely</span>
<span class="line-modified">!   // lost. (And after the previous test we know that the expression will not</span>
<span class="line-modified">!   // over/underflow.)</span>
<span class="line-modified">!   if (ten_kappa - unit &lt;= unit) return false;</span>
<span class="line-modified">!   // If 2 * (rest + unit) &lt;= 10^kappa we can safely round down.</span>
<span class="line-modified">!   if ((ten_kappa - rest &gt; rest) &amp;&amp; (ten_kappa - 2 * rest &gt;= 2 * unit)) {</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // If 2 * (rest - unit) &gt;= 10^kappa, then we can safely round up.</span>
<span class="line-modified">!   if ((rest &gt; unit) &amp;&amp; (ten_kappa - (rest - unit) &lt;= (rest - unit))) {</span>
<span class="line-modified">!     // Increment the last digit recursively until we find a non &#39;9&#39; digit.</span>
<span class="line-modified">!     buffer[length - 1]++;</span>
<span class="line-modified">!     for (int i = length - 1; i &gt; 0; --i) {</span>
<span class="line-modified">!       if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="line-modified">!       buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">!       buffer[i - 1]++;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     // If the first digit is now &#39;0&#39;+ 10 we had a buffer with all &#39;9&#39;s. With the</span>
<span class="line-modified">!     // exception of the first digit all digits are now &#39;0&#39;. Simply switch the</span>
<span class="line-modified">!     // first digit to &#39;1&#39; and adjust the kappa. Example: &quot;99&quot; becomes &quot;10&quot; and</span>
<span class="line-modified">!     // the power (the kappa) is increased.</span>
<span class="line-modified">!     if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">!       buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!       (*kappa) += 1;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return false;</span>
  }
<span class="line-modified">! </span>
  // Returns the biggest power of ten that is less than or equal to the given
  // number. We furthermore receive the maximum number of bits &#39;number&#39; has.
  //
  // Returns power == 10^(exponent_plus_one-1) such that
  //    power &lt;= number &lt; power * 10.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,14 ***</span>
  // Inspired by the method for finding an integer log base 10 from here:
  // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
  static unsigned int const kSmallPowersOfTen[] =
      {0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,
       1000000000};
<span class="line-modified">!     </span>
  static void BiggestPowerTen(uint32_t number,
<span class="line-modified">!                                 int number_bits,</span>
<span class="line-modified">!                                 uint32_t* power,</span>
                              int* exponent_plus_one) {
    ASSERT(number &lt; (1u &lt;&lt; (number_bits + 1)));
    // 1233/4096 is approximately 1/lg(10).
    int exponent_plus_one_guess = ((number_bits + 1) * 1233 &gt;&gt; 12);
    // We increment to skip over the first entry in the kPowersOf10 table.
<span class="line-new-header">--- 237,14 ---</span>
  // Inspired by the method for finding an integer log base 10 from here:
  // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
  static unsigned int const kSmallPowersOfTen[] =
      {0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,
       1000000000};
<span class="line-modified">! </span>
  static void BiggestPowerTen(uint32_t number,
<span class="line-modified">!                             int number_bits,</span>
<span class="line-modified">!                             uint32_t* power,</span>
                              int* exponent_plus_one) {
    ASSERT(number &lt; (1u &lt;&lt; (number_bits + 1)));
    // 1233/4096 is approximately 1/lg(10).
    int exponent_plus_one_guess = ((number_bits + 1) * 1233 &gt;&gt; 12);
    // We increment to skip over the first entry in the kPowersOf10 table.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,109 ***</span>
  // once we have enough digits. That is, once the digits inside the buffer
  // represent &#39;w&#39; we can stop. Everything inside the interval low - high
  // represents w. However we have to pay attention to low, high and w&#39;s
  // imprecision.
  static bool DigitGen(DiyFp low,
<span class="line-modified">!                          DiyFp w,</span>
<span class="line-modified">!                          DiyFp high,</span>
<span class="line-modified">!                          BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                          int* length,</span>
<span class="line-modified">!                          int* kappa) {</span>
<span class="line-modified">!         ASSERT(low.e() == w.e() &amp;&amp; w.e() == high.e());</span>
<span class="line-modified">!         ASSERT(low.f() + 1 &lt;= high.f() - 1);</span>
<span class="line-modified">!         ASSERT(kMinimalTargetExponent &lt;= w.e() &amp;&amp; w.e() &lt;= kMaximalTargetExponent);</span>
<span class="line-modified">!         // low, w and high are imprecise, but by less than one ulp (unit in the last</span>
<span class="line-modified">!         // place).</span>
<span class="line-modified">!         // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that</span>
<span class="line-modified">!         // the new numbers are outside of the interval we want the final</span>
<span class="line-modified">!         // representation to lie in.</span>
<span class="line-modified">!         // Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield</span>
<span class="line-modified">!         // numbers that are certain to lie in the interval. We will use this fact</span>
<span class="line-modified">!         // later on.</span>
<span class="line-modified">!         // We will now start by generating the digits within the uncertain</span>
<span class="line-modified">!         // interval. Later we will weed out representations that lie outside the safe</span>
<span class="line-modified">!         // interval and thus _might_ lie outside the correct interval.</span>
<span class="line-modified">!         uint64_t unit = 1;</span>
<span class="line-modified">!         DiyFp too_low = DiyFp(low.f() - unit, low.e());</span>
<span class="line-modified">!         DiyFp too_high = DiyFp(high.f() + unit, high.e());</span>
<span class="line-modified">!         // too_low and too_high are guaranteed to lie outside the interval we want the</span>
<span class="line-modified">!         // generated number in.</span>
<span class="line-modified">!         DiyFp unsafe_interval = DiyFp::Minus(too_high, too_low);</span>
<span class="line-modified">!         // We now cut the input number into two parts: the integral digits and the</span>
<span class="line-modified">!         // fractionals. We will not write any decimal separator though, but adapt</span>
<span class="line-modified">!         // kappa instead.</span>
<span class="line-modified">!         // Reminder: we are currently computing the digits (stored inside the buffer)</span>
<span class="line-modified">!         // such that:   too_low &lt; buffer * 10^kappa &lt; too_high</span>
<span class="line-modified">!         // We use too_high for the digit_generation and stop as soon as possible.</span>
<span class="line-modified">!         // If we stop early we effectively round down.</span>
<span class="line-modified">!         DiyFp one = DiyFp(static_cast&lt;uint64_t&gt;(1) &lt;&lt; -w.e(), w.e());</span>
<span class="line-modified">!         // Division by one is a shift.</span>
<span class="line-modified">!         uint32_t integrals = static_cast&lt;uint32_t&gt;(too_high.f() &gt;&gt; -one.e());</span>
<span class="line-modified">!         // Modulo by one is an and.</span>
<span class="line-modified">!         uint64_t fractionals = too_high.f() &amp; (one.f() - 1);</span>
<span class="line-modified">!         uint32_t divisor;</span>
    int divisor_exponent_plus_one;
<span class="line-modified">!         BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),</span>
                    &amp;divisor, &amp;divisor_exponent_plus_one);
    *kappa = divisor_exponent_plus_one;
<span class="line-modified">!         *length = 0;</span>
<span class="line-modified">!         // Loop invariant: buffer = too_high / 10^kappa  (integer division)</span>
<span class="line-modified">!         // The invariant holds for the first iteration: kappa has been initialized</span>
<span class="line-modified">!         // with the divisor exponent + 1. And the divisor is the biggest power of ten</span>
<span class="line-modified">!         // that is smaller than integrals.</span>
<span class="line-modified">!         while (*kappa &gt; 0) {</span>
<span class="line-modified">!             int digit = integrals / divisor;</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!             (*length)++;</span>
<span class="line-modified">!             integrals %= divisor;</span>
<span class="line-modified">!             (*kappa)--;</span>
<span class="line-modified">!             // Note that kappa now equals the exponent of the divisor and that the</span>
<span class="line-modified">!             // invariant thus holds again.</span>
<span class="line-modified">!             uint64_t rest =</span>
<span class="line-modified">!             (static_cast&lt;uint64_t&gt;(integrals) &lt;&lt; -one.e()) + fractionals;</span>
<span class="line-modified">!             // Invariant: too_high = buffer * 10^kappa + DiyFp(rest, one.e())</span>
<span class="line-modified">!             // Reminder: unsafe_interval.e() == one.e()</span>
<span class="line-modified">!             if (rest &lt; unsafe_interval.f()) {</span>
<span class="line-modified">!                 // Rounding down (by not emitting the remaining digits) yields a number</span>
<span class="line-modified">!                 // that lies within the unsafe interval.</span>
<span class="line-modified">!                 return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f(),</span>
<span class="line-modified">!                                  unsafe_interval.f(), rest,</span>
<span class="line-modified">!                                  static_cast&lt;uint64_t&gt;(divisor) &lt;&lt; -one.e(), unit);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             divisor /= 10;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // The integrals have been generated. We are at the point of the decimal</span>
<span class="line-modified">!         // separator. In the following loop we simply multiply the remaining digits by</span>
<span class="line-modified">!         // 10 and divide by one. We just need to pay attention to multiply associated</span>
<span class="line-modified">!         // data (like the interval or &#39;unit&#39;), too.</span>
<span class="line-modified">!         // Note that the multiplication by 10 does not overflow, because w.e &gt;= -60</span>
<span class="line-modified">!         // and thus one.e &gt;= -60.</span>
<span class="line-modified">!         ASSERT(one.e() &gt;= -60);</span>
<span class="line-modified">!         ASSERT(fractionals &lt; one.f());</span>
<span class="line-modified">!         ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 &gt;= one.f());</span>
    for (;;) {
<span class="line-modified">!             fractionals *= 10;</span>
<span class="line-modified">!             unit *= 10;</span>
<span class="line-modified">!             unsafe_interval.set_f(unsafe_interval.f() * 10);</span>
<span class="line-modified">!             // Integer division by one.</span>
<span class="line-modified">!             int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; -one.e());</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!             (*length)++;</span>
<span class="line-modified">!             fractionals &amp;= one.f() - 1;  // Modulo by one.</span>
<span class="line-modified">!             (*kappa)--;</span>
<span class="line-modified">!             if (fractionals &lt; unsafe_interval.f()) {</span>
<span class="line-modified">!                 return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f() * unit,</span>
<span class="line-modified">!                                  unsafe_interval.f(), fractionals, one.f(), unit);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Generates (at most) requested_digits digits of input number w.
  // w is a floating-point number (DiyFp), consisting of a significand and an
  // exponent. Its exponent is bounded by kMinimalTargetExponent and
  // kMaximalTargetExponent.
  //       Hence -60 &lt;= w.e() &lt;= -32.
<span class="line-new-header">--- 299,109 ---</span>
  // once we have enough digits. That is, once the digits inside the buffer
  // represent &#39;w&#39; we can stop. Everything inside the interval low - high
  // represents w. However we have to pay attention to low, high and w&#39;s
  // imprecision.
  static bool DigitGen(DiyFp low,
<span class="line-modified">!                      DiyFp w,</span>
<span class="line-modified">!                      DiyFp high,</span>
<span class="line-modified">!                      BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                      int* length,</span>
<span class="line-modified">!                      int* kappa) {</span>
<span class="line-modified">!   ASSERT(low.e() == w.e() &amp;&amp; w.e() == high.e());</span>
<span class="line-modified">!   ASSERT(low.f() + 1 &lt;= high.f() - 1);</span>
<span class="line-modified">!   ASSERT(kMinimalTargetExponent &lt;= w.e() &amp;&amp; w.e() &lt;= kMaximalTargetExponent);</span>
<span class="line-modified">!   // low, w and high are imprecise, but by less than one ulp (unit in the last</span>
<span class="line-modified">!   // place).</span>
<span class="line-modified">!   // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that</span>
<span class="line-modified">!   // the new numbers are outside of the interval we want the final</span>
<span class="line-modified">!   // representation to lie in.</span>
<span class="line-modified">!   // Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield</span>
<span class="line-modified">!   // numbers that are certain to lie in the interval. We will use this fact</span>
<span class="line-modified">!   // later on.</span>
<span class="line-modified">!   // We will now start by generating the digits within the uncertain</span>
<span class="line-modified">!   // interval. Later we will weed out representations that lie outside the safe</span>
<span class="line-modified">!   // interval and thus _might_ lie outside the correct interval.</span>
<span class="line-modified">!   uint64_t unit = 1;</span>
<span class="line-modified">!   DiyFp too_low = DiyFp(low.f() - unit, low.e());</span>
<span class="line-modified">!   DiyFp too_high = DiyFp(high.f() + unit, high.e());</span>
<span class="line-modified">!   // too_low and too_high are guaranteed to lie outside the interval we want the</span>
<span class="line-modified">!   // generated number in.</span>
<span class="line-modified">!   DiyFp unsafe_interval = DiyFp::Minus(too_high, too_low);</span>
<span class="line-modified">!   // We now cut the input number into two parts: the integral digits and the</span>
<span class="line-modified">!   // fractionals. We will not write any decimal separator though, but adapt</span>
<span class="line-modified">!   // kappa instead.</span>
<span class="line-modified">!   // Reminder: we are currently computing the digits (stored inside the buffer)</span>
<span class="line-modified">!   // such that:   too_low &lt; buffer * 10^kappa &lt; too_high</span>
<span class="line-modified">!   // We use too_high for the digit_generation and stop as soon as possible.</span>
<span class="line-modified">!   // If we stop early we effectively round down.</span>
<span class="line-modified">!   DiyFp one = DiyFp(static_cast&lt;uint64_t&gt;(1) &lt;&lt; -w.e(), w.e());</span>
<span class="line-modified">!   // Division by one is a shift.</span>
<span class="line-modified">!   uint32_t integrals = static_cast&lt;uint32_t&gt;(too_high.f() &gt;&gt; -one.e());</span>
<span class="line-modified">!   // Modulo by one is an and.</span>
<span class="line-modified">!   uint64_t fractionals = too_high.f() &amp; (one.f() - 1);</span>
<span class="line-modified">!   uint32_t divisor;</span>
    int divisor_exponent_plus_one;
<span class="line-modified">!   BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),</span>
                    &amp;divisor, &amp;divisor_exponent_plus_one);
    *kappa = divisor_exponent_plus_one;
<span class="line-modified">!   *length = 0;</span>
<span class="line-modified">!   // Loop invariant: buffer = too_high / 10^kappa  (integer division)</span>
<span class="line-modified">!   // The invariant holds for the first iteration: kappa has been initialized</span>
<span class="line-modified">!   // with the divisor exponent + 1. And the divisor is the biggest power of ten</span>
<span class="line-modified">!   // that is smaller than integrals.</span>
<span class="line-modified">!   while (*kappa &gt; 0) {</span>
<span class="line-modified">!     int digit = integrals / divisor;</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!     (*length)++;</span>
<span class="line-modified">!     integrals %= divisor;</span>
<span class="line-modified">!     (*kappa)--;</span>
<span class="line-modified">!     // Note that kappa now equals the exponent of the divisor and that the</span>
<span class="line-modified">!     // invariant thus holds again.</span>
<span class="line-modified">!     uint64_t rest =</span>
<span class="line-modified">!         (static_cast&lt;uint64_t&gt;(integrals) &lt;&lt; -one.e()) + fractionals;</span>
<span class="line-modified">!     // Invariant: too_high = buffer * 10^kappa + DiyFp(rest, one.e())</span>
<span class="line-modified">!     // Reminder: unsafe_interval.e() == one.e()</span>
<span class="line-modified">!     if (rest &lt; unsafe_interval.f()) {</span>
<span class="line-modified">!       // Rounding down (by not emitting the remaining digits) yields a number</span>
<span class="line-modified">!       // that lies within the unsafe interval.</span>
<span class="line-modified">!       return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f(),</span>
<span class="line-modified">!                        unsafe_interval.f(), rest,</span>
<span class="line-modified">!                        static_cast&lt;uint64_t&gt;(divisor) &lt;&lt; -one.e(), unit);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     divisor /= 10;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The integrals have been generated. We are at the point of the decimal</span>
<span class="line-modified">!   // separator. In the following loop we simply multiply the remaining digits by</span>
<span class="line-modified">!   // 10 and divide by one. We just need to pay attention to multiply associated</span>
<span class="line-modified">!   // data (like the interval or &#39;unit&#39;), too.</span>
<span class="line-modified">!   // Note that the multiplication by 10 does not overflow, because w.e &gt;= -60</span>
<span class="line-modified">!   // and thus one.e &gt;= -60.</span>
<span class="line-modified">!   ASSERT(one.e() &gt;= -60);</span>
<span class="line-modified">!   ASSERT(fractionals &lt; one.f());</span>
<span class="line-modified">!   ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 &gt;= one.f());</span>
    for (;;) {
<span class="line-modified">!     fractionals *= 10;</span>
<span class="line-modified">!     unit *= 10;</span>
<span class="line-modified">!     unsafe_interval.set_f(unsafe_interval.f() * 10);</span>
<span class="line-modified">!     // Integer division by one.</span>
<span class="line-modified">!     int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; -one.e());</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!     (*length)++;</span>
<span class="line-modified">!     fractionals &amp;= one.f() - 1;  // Modulo by one.</span>
<span class="line-modified">!     (*kappa)--;</span>
<span class="line-modified">!     if (fractionals &lt; unsafe_interval.f()) {</span>
<span class="line-modified">!       return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f() * unit,</span>
<span class="line-modified">!                        unsafe_interval.f(), fractionals, one.f(), unit);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Generates (at most) requested_digits digits of input number w.
  // w is a floating-point number (DiyFp), consisting of a significand and an
  // exponent. Its exponent is bounded by kMinimalTargetExponent and
  // kMaximalTargetExponent.
  //       Hence -60 &lt;= w.e() &lt;= -32.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,89 ***</span>
  // Remark: This procedure takes into account the imprecision of its input
  //   numbers. If the precision is not enough to guarantee all the postconditions
  //   then false is returned. This usually happens rarely, but the failure-rate
  //   increases with higher requested_digits.
  static bool DigitGenCounted(DiyFp w,
<span class="line-modified">!                                 int requested_digits,</span>
<span class="line-modified">!                                 BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                                 int* length,</span>
<span class="line-modified">!                                 int* kappa) {</span>
<span class="line-modified">!         ASSERT(kMinimalTargetExponent &lt;= w.e() &amp;&amp; w.e() &lt;= kMaximalTargetExponent);</span>
<span class="line-modified">!         ASSERT(kMinimalTargetExponent &gt;= -60);</span>
<span class="line-modified">!         ASSERT(kMaximalTargetExponent &lt;= -32);</span>
<span class="line-modified">!         // w is assumed to have an error less than 1 unit. Whenever w is scaled we</span>
<span class="line-modified">!         // also scale its error.</span>
<span class="line-modified">!         uint64_t w_error = 1;</span>
<span class="line-modified">!         // We cut the input number into two parts: the integral digits and the</span>
<span class="line-modified">!         // fractional digits. We don&#39;t emit any decimal separator, but adapt kappa</span>
<span class="line-modified">!         // instead. Example: instead of writing &quot;1.2&quot; we put &quot;12&quot; into the buffer and</span>
<span class="line-modified">!         // increase kappa by 1.</span>
<span class="line-modified">!         DiyFp one = DiyFp(static_cast&lt;uint64_t&gt;(1) &lt;&lt; -w.e(), w.e());</span>
<span class="line-modified">!         // Division by one is a shift.</span>
<span class="line-modified">!         uint32_t integrals = static_cast&lt;uint32_t&gt;(w.f() &gt;&gt; -one.e());</span>
<span class="line-modified">!         // Modulo by one is an and.</span>
<span class="line-modified">!         uint64_t fractionals = w.f() &amp; (one.f() - 1);</span>
<span class="line-modified">!         uint32_t divisor;</span>
    int divisor_exponent_plus_one;
<span class="line-modified">!         BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),</span>
                    &amp;divisor, &amp;divisor_exponent_plus_one);
    *kappa = divisor_exponent_plus_one;
<span class="line-modified">!         *length = 0;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Loop invariant: buffer = w / 10^kappa  (integer division)</span>
<span class="line-modified">!         // The invariant holds for the first iteration: kappa has been initialized</span>
<span class="line-modified">!         // with the divisor exponent + 1. And the divisor is the biggest power of ten</span>
<span class="line-modified">!         // that is smaller than &#39;integrals&#39;.</span>
<span class="line-modified">!         while (*kappa &gt; 0) {</span>
<span class="line-modified">!             int digit = integrals / divisor;</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!             (*length)++;</span>
<span class="line-modified">!             requested_digits--;</span>
<span class="line-modified">!             integrals %= divisor;</span>
<span class="line-modified">!             (*kappa)--;</span>
<span class="line-modified">!             // Note that kappa now equals the exponent of the divisor and that the</span>
<span class="line-modified">!             // invariant thus holds again.</span>
<span class="line-modified">!             if (requested_digits == 0) break;</span>
<span class="line-modified">!             divisor /= 10;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (requested_digits == 0) {</span>
<span class="line-modified">!             uint64_t rest =</span>
<span class="line-modified">!             (static_cast&lt;uint64_t&gt;(integrals) &lt;&lt; -one.e()) + fractionals;</span>
<span class="line-modified">!             return RoundWeedCounted(buffer, *length, rest,</span>
<span class="line-modified">!                                     static_cast&lt;uint64_t&gt;(divisor) &lt;&lt; -one.e(), w_error,</span>
<span class="line-modified">!                                     kappa);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // The integrals have been generated. We are at the point of the decimal</span>
<span class="line-modified">!         // separator. In the following loop we simply multiply the remaining digits by</span>
<span class="line-modified">!         // 10 and divide by one. We just need to pay attention to multiply associated</span>
<span class="line-modified">!         // data (the &#39;unit&#39;), too.</span>
<span class="line-modified">!         // Note that the multiplication by 10 does not overflow, because w.e &gt;= -60</span>
<span class="line-modified">!         // and thus one.e &gt;= -60.</span>
<span class="line-modified">!         ASSERT(one.e() &gt;= -60);</span>
<span class="line-modified">!         ASSERT(fractionals &lt; one.f());</span>
<span class="line-modified">!         ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 &gt;= one.f());</span>
<span class="line-modified">!         while (requested_digits &gt; 0 &amp;&amp; fractionals &gt; w_error) {</span>
<span class="line-modified">!             fractionals *= 10;</span>
<span class="line-modified">!             w_error *= 10;</span>
<span class="line-modified">!             // Integer division by one.</span>
<span class="line-modified">!             int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; -one.e());</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!             (*length)++;</span>
<span class="line-modified">!             requested_digits--;</span>
<span class="line-modified">!             fractionals &amp;= one.f() - 1;  // Modulo by one.</span>
<span class="line-modified">!             (*kappa)--;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (requested_digits != 0) return false;</span>
<span class="line-modified">!         return RoundWeedCounted(buffer, *length, fractionals, one.f(), w_error,</span>
<span class="line-modified">!                                 kappa);</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Provides a decimal representation of v.
  // Returns true if it succeeds, otherwise the result cannot be trusted.
  // There will be *length digits inside the buffer (not null-terminated).
  // If the function returns true then
  //        v == (double) (buffer * 10^decimal_exponent).
<span class="line-new-header">--- 427,89 ---</span>
  // Remark: This procedure takes into account the imprecision of its input
  //   numbers. If the precision is not enough to guarantee all the postconditions
  //   then false is returned. This usually happens rarely, but the failure-rate
  //   increases with higher requested_digits.
  static bool DigitGenCounted(DiyFp w,
<span class="line-modified">!                             int requested_digits,</span>
<span class="line-modified">!                             BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                             int* length,</span>
<span class="line-modified">!                             int* kappa) {</span>
<span class="line-modified">!   ASSERT(kMinimalTargetExponent &lt;= w.e() &amp;&amp; w.e() &lt;= kMaximalTargetExponent);</span>
<span class="line-modified">!   ASSERT(kMinimalTargetExponent &gt;= -60);</span>
<span class="line-modified">!   ASSERT(kMaximalTargetExponent &lt;= -32);</span>
<span class="line-modified">!   // w is assumed to have an error less than 1 unit. Whenever w is scaled we</span>
<span class="line-modified">!   // also scale its error.</span>
<span class="line-modified">!   uint64_t w_error = 1;</span>
<span class="line-modified">!   // We cut the input number into two parts: the integral digits and the</span>
<span class="line-modified">!   // fractional digits. We don&#39;t emit any decimal separator, but adapt kappa</span>
<span class="line-modified">!   // instead. Example: instead of writing &quot;1.2&quot; we put &quot;12&quot; into the buffer and</span>
<span class="line-modified">!   // increase kappa by 1.</span>
<span class="line-modified">!   DiyFp one = DiyFp(static_cast&lt;uint64_t&gt;(1) &lt;&lt; -w.e(), w.e());</span>
<span class="line-modified">!   // Division by one is a shift.</span>
<span class="line-modified">!   uint32_t integrals = static_cast&lt;uint32_t&gt;(w.f() &gt;&gt; -one.e());</span>
<span class="line-modified">!   // Modulo by one is an and.</span>
<span class="line-modified">!   uint64_t fractionals = w.f() &amp; (one.f() - 1);</span>
<span class="line-modified">!   uint32_t divisor;</span>
    int divisor_exponent_plus_one;
<span class="line-modified">!   BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),</span>
                    &amp;divisor, &amp;divisor_exponent_plus_one);
    *kappa = divisor_exponent_plus_one;
<span class="line-modified">!   *length = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Loop invariant: buffer = w / 10^kappa  (integer division)</span>
<span class="line-modified">!   // The invariant holds for the first iteration: kappa has been initialized</span>
<span class="line-modified">!   // with the divisor exponent + 1. And the divisor is the biggest power of ten</span>
<span class="line-modified">!   // that is smaller than &#39;integrals&#39;.</span>
<span class="line-modified">!   while (*kappa &gt; 0) {</span>
<span class="line-modified">!     int digit = integrals / divisor;</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!     (*length)++;</span>
<span class="line-modified">!     requested_digits--;</span>
<span class="line-modified">!     integrals %= divisor;</span>
<span class="line-modified">!     (*kappa)--;</span>
<span class="line-modified">!     // Note that kappa now equals the exponent of the divisor and that the</span>
<span class="line-modified">!     // invariant thus holds again.</span>
<span class="line-modified">!     if (requested_digits == 0) break;</span>
<span class="line-modified">!     divisor /= 10;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (requested_digits == 0) {</span>
<span class="line-modified">!     uint64_t rest =</span>
<span class="line-modified">!         (static_cast&lt;uint64_t&gt;(integrals) &lt;&lt; -one.e()) + fractionals;</span>
<span class="line-modified">!     return RoundWeedCounted(buffer, *length, rest,</span>
<span class="line-modified">!                             static_cast&lt;uint64_t&gt;(divisor) &lt;&lt; -one.e(), w_error,</span>
<span class="line-modified">!                             kappa);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The integrals have been generated. We are at the point of the decimal</span>
<span class="line-modified">!   // separator. In the following loop we simply multiply the remaining digits by</span>
<span class="line-modified">!   // 10 and divide by one. We just need to pay attention to multiply associated</span>
<span class="line-modified">!   // data (the &#39;unit&#39;), too.</span>
<span class="line-modified">!   // Note that the multiplication by 10 does not overflow, because w.e &gt;= -60</span>
<span class="line-modified">!   // and thus one.e &gt;= -60.</span>
<span class="line-modified">!   ASSERT(one.e() &gt;= -60);</span>
<span class="line-modified">!   ASSERT(fractionals &lt; one.f());</span>
<span class="line-modified">!   ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 &gt;= one.f());</span>
<span class="line-modified">!   while (requested_digits &gt; 0 &amp;&amp; fractionals &gt; w_error) {</span>
<span class="line-modified">!     fractionals *= 10;</span>
<span class="line-modified">!     w_error *= 10;</span>
<span class="line-modified">!     // Integer division by one.</span>
<span class="line-modified">!     int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; -one.e());</span>
      ASSERT(digit &lt;= 9);
      buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!     (*length)++;</span>
<span class="line-modified">!     requested_digits--;</span>
<span class="line-modified">!     fractionals &amp;= one.f() - 1;  // Modulo by one.</span>
<span class="line-modified">!     (*kappa)--;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (requested_digits != 0) return false;</span>
<span class="line-modified">!   return RoundWeedCounted(buffer, *length, fractionals, one.f(), w_error,</span>
<span class="line-modified">!                           kappa);</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Provides a decimal representation of v.
  // Returns true if it succeeds, otherwise the result cannot be trusted.
  // There will be *length digits inside the buffer (not null-terminated).
  // If the function returns true then
  //        v == (double) (buffer * 10^decimal_exponent).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,151 ***</span>
  // The last digit will be closest to the actual v. That is, even if several
  // digits might correctly yield &#39;v&#39; when read again, the closest will be
  // computed.
  static bool Grisu3(double v,
                     FastDtoaMode mode,
<span class="line-modified">!                        BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                        int* length,</span>
<span class="line-modified">!                        int* decimal_exponent) {</span>
<span class="line-modified">!         DiyFp w = Double(v).AsNormalizedDiyFp();</span>
<span class="line-modified">!         // boundary_minus and boundary_plus are the boundaries between v and its</span>
<span class="line-modified">!         // closest floating-point neighbors. Any number strictly between</span>
<span class="line-modified">!         // boundary_minus and boundary_plus will round to v when convert to a double.</span>
<span class="line-modified">!         // Grisu3 will never output representations that lie exactly on a boundary.</span>
<span class="line-modified">!         DiyFp boundary_minus, boundary_plus;</span>
    if (mode == FAST_DTOA_SHORTEST) {
<span class="line-modified">!         Double(v).NormalizedBoundaries(&amp;boundary_minus, &amp;boundary_plus);</span>
    } else {
      ASSERT(mode == FAST_DTOA_SHORTEST_SINGLE);
      float single_v = static_cast&lt;float&gt;(v);
      Single(single_v).NormalizedBoundaries(&amp;boundary_minus, &amp;boundary_plus);
    }
<span class="line-modified">!         ASSERT(boundary_plus.e() == w.e());</span>
<span class="line-modified">!         DiyFp ten_mk;  // Cached power of ten: 10^-k</span>
<span class="line-modified">!         int mk;        // -k</span>
<span class="line-modified">!         int ten_mk_minimal_binary_exponent =</span>
<span class="line-modified">!         kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!         int ten_mk_maximal_binary_exponent =</span>
<span class="line-modified">!         kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!         PowersOfTenCache::GetCachedPowerForBinaryExponentRange(</span>
<span class="line-modified">!                                                                ten_mk_minimal_binary_exponent,</span>
<span class="line-modified">!                                                                ten_mk_maximal_binary_exponent,</span>
<span class="line-modified">!                                                                &amp;ten_mk, &amp;mk);</span>
<span class="line-modified">!         ASSERT((kMinimalTargetExponent &lt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!                 DiyFp::kSignificandSize) &amp;&amp;</span>
<span class="line-modified">!                (kMaximalTargetExponent &gt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!                 DiyFp::kSignificandSize));</span>
<span class="line-modified">!         // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a</span>
<span class="line-modified">!         // 64 bit significand and ten_mk is thus only precise up to 64 bits.</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // The DiyFp::Times procedure rounds its result, and ten_mk is approximated</span>
<span class="line-modified">!         // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now</span>
<span class="line-modified">!         // off by a small amount.</span>
<span class="line-modified">!         // In fact: scaled_w - w*10^k &lt; 1ulp (unit in the last place) of scaled_w.</span>
<span class="line-modified">!         // In other words: let f = scaled_w.f() and e = scaled_w.e(), then</span>
<span class="line-modified">!         //           (f-1) * 2^e &lt; w*10^k &lt; (f+1) * 2^e</span>
<span class="line-modified">!         DiyFp scaled_w = DiyFp::Times(w, ten_mk);</span>
<span class="line-modified">!         ASSERT(scaled_w.e() ==</span>
<span class="line-modified">!                boundary_plus.e() + ten_mk.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!         // In theory it would be possible to avoid some recomputations by computing</span>
<span class="line-modified">!         // the difference between w and boundary_minus/plus (a power of 2) and to</span>
<span class="line-modified">!         // compute scaled_boundary_minus/plus by subtracting/adding from</span>
<span class="line-modified">!         // scaled_w. However the code becomes much less readable and the speed</span>
<span class="line-modified">!         // enhancements are not terriffic.</span>
<span class="line-modified">!         DiyFp scaled_boundary_minus = DiyFp::Times(boundary_minus, ten_mk);</span>
<span class="line-modified">!         DiyFp scaled_boundary_plus  = DiyFp::Times(boundary_plus,  ten_mk);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // DigitGen will generate the digits of scaled_w. Therefore we have</span>
<span class="line-modified">!         // v == (double) (scaled_w * 10^-mk).</span>
<span class="line-modified">!         // Set decimal_exponent == -mk and pass it to DigitGen. If scaled_w is not an</span>
<span class="line-modified">!         // integer than it will be updated. For instance if scaled_w == 1.23 then</span>
<span class="line-modified">!         // the buffer will be filled with &quot;123&quot; und the decimal_exponent will be</span>
<span class="line-modified">!         // decreased by 2.</span>
<span class="line-modified">!         int kappa;</span>
<span class="line-modified">!         bool result = DigitGen(scaled_boundary_minus, scaled_w, scaled_boundary_plus,</span>
<span class="line-modified">!                                buffer, length, &amp;kappa);</span>
<span class="line-modified">!         *decimal_exponent = -mk + kappa;</span>
<span class="line-modified">!         return result;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // The &quot;counted&quot; version of grisu3 (see above) only generates requested_digits
  // number of digits. This version does not generate the shortest representation,
  // and with enough requested digits 0.1 will at some point print as 0.9999999...
  // Grisu3 is too imprecise for real halfway cases (1.5 will not work) and
  // therefore the rounding strategy for halfway cases is irrelevant.
  static bool Grisu3Counted(double v,
<span class="line-modified">!                               int requested_digits,</span>
<span class="line-modified">!                               BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                               int* length,</span>
<span class="line-modified">!                               int* decimal_exponent) {</span>
<span class="line-modified">!         DiyFp w = Double(v).AsNormalizedDiyFp();</span>
<span class="line-modified">!         DiyFp ten_mk;  // Cached power of ten: 10^-k</span>
<span class="line-modified">!         int mk;        // -k</span>
<span class="line-modified">!         int ten_mk_minimal_binary_exponent =</span>
<span class="line-modified">!         kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!         int ten_mk_maximal_binary_exponent =</span>
<span class="line-modified">!         kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!         PowersOfTenCache::GetCachedPowerForBinaryExponentRange(</span>
<span class="line-modified">!                                                                ten_mk_minimal_binary_exponent,</span>
<span class="line-modified">!                                                                ten_mk_maximal_binary_exponent,</span>
<span class="line-modified">!                                                                &amp;ten_mk, &amp;mk);</span>
<span class="line-modified">!         ASSERT((kMinimalTargetExponent &lt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!                 DiyFp::kSignificandSize) &amp;&amp;</span>
<span class="line-modified">!                (kMaximalTargetExponent &gt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!                 DiyFp::kSignificandSize));</span>
<span class="line-modified">!         // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a</span>
<span class="line-modified">!         // 64 bit significand and ten_mk is thus only precise up to 64 bits.</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // The DiyFp::Times procedure rounds its result, and ten_mk is approximated</span>
<span class="line-modified">!         // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now</span>
<span class="line-modified">!         // off by a small amount.</span>
<span class="line-modified">!         // In fact: scaled_w - w*10^k &lt; 1ulp (unit in the last place) of scaled_w.</span>
<span class="line-modified">!         // In other words: let f = scaled_w.f() and e = scaled_w.e(), then</span>
<span class="line-modified">!         //           (f-1) * 2^e &lt; w*10^k &lt; (f+1) * 2^e</span>
<span class="line-modified">!         DiyFp scaled_w = DiyFp::Times(w, ten_mk);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // We now have (double) (scaled_w * 10^-mk).</span>
<span class="line-modified">!         // DigitGen will generate the first requested_digits digits of scaled_w and</span>
<span class="line-modified">!         // return together with a kappa such that scaled_w ~= buffer * 10^kappa. (It</span>
<span class="line-modified">!         // will not always be exactly the same since DigitGenCounted only produces a</span>
<span class="line-modified">!         // limited number of digits.)</span>
<span class="line-modified">!         int kappa;</span>
<span class="line-modified">!         bool result = DigitGenCounted(scaled_w, requested_digits,</span>
<span class="line-modified">!                                       buffer, length, &amp;kappa);</span>
<span class="line-modified">!         *decimal_exponent = -mk + kappa;</span>
<span class="line-modified">!         return result;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  bool FastDtoa(double v,
<span class="line-modified">!                   FastDtoaMode mode,</span>
<span class="line-modified">!                   int requested_digits,</span>
<span class="line-modified">!                   BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                   int* length,</span>
<span class="line-modified">!                   int* decimal_point) {</span>
<span class="line-modified">!         ASSERT(v &gt; 0);</span>
<span class="line-modified">!         ASSERT(!Double(v).IsSpecial());</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool result = false;</span>
<span class="line-modified">!         int decimal_exponent = 0;</span>
<span class="line-modified">!         switch (mode) {</span>
<span class="line-modified">!             case FAST_DTOA_SHORTEST:</span>
      case FAST_DTOA_SHORTEST_SINGLE:
        result = Grisu3(v, mode, buffer, length, &amp;decimal_exponent);
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case FAST_DTOA_PRECISION:</span>
<span class="line-modified">!                 result = Grisu3Counted(v, requested_digits,</span>
<span class="line-modified">!                                        buffer, length, &amp;decimal_exponent);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 UNREACHABLE();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (result) {</span>
<span class="line-modified">!             *decimal_point = *length + decimal_exponent;</span>
<span class="line-modified">!             buffer[*length] = &#39;\0&#39;;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return result;</span>
  }
<span class="line-modified">!     </span>
  }  // namespace double_conversion
<span class="line-modified">! } // namespace WTF</span>
<span class="line-new-header">--- 519,151 ---</span>
  // The last digit will be closest to the actual v. That is, even if several
  // digits might correctly yield &#39;v&#39; when read again, the closest will be
  // computed.
  static bool Grisu3(double v,
                     FastDtoaMode mode,
<span class="line-modified">!                    BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                    int* length,</span>
<span class="line-modified">!                    int* decimal_exponent) {</span>
<span class="line-modified">!   DiyFp w = Double(v).AsNormalizedDiyFp();</span>
<span class="line-modified">!   // boundary_minus and boundary_plus are the boundaries between v and its</span>
<span class="line-modified">!   // closest floating-point neighbors. Any number strictly between</span>
<span class="line-modified">!   // boundary_minus and boundary_plus will round to v when convert to a double.</span>
<span class="line-modified">!   // Grisu3 will never output representations that lie exactly on a boundary.</span>
<span class="line-modified">!   DiyFp boundary_minus, boundary_plus;</span>
    if (mode == FAST_DTOA_SHORTEST) {
<span class="line-modified">!     Double(v).NormalizedBoundaries(&amp;boundary_minus, &amp;boundary_plus);</span>
    } else {
      ASSERT(mode == FAST_DTOA_SHORTEST_SINGLE);
      float single_v = static_cast&lt;float&gt;(v);
      Single(single_v).NormalizedBoundaries(&amp;boundary_minus, &amp;boundary_plus);
    }
<span class="line-modified">!   ASSERT(boundary_plus.e() == w.e());</span>
<span class="line-modified">!   DiyFp ten_mk;  // Cached power of ten: 10^-k</span>
<span class="line-modified">!   int mk;        // -k</span>
<span class="line-modified">!   int ten_mk_minimal_binary_exponent =</span>
<span class="line-modified">!      kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!   int ten_mk_maximal_binary_exponent =</span>
<span class="line-modified">!      kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!   PowersOfTenCache::GetCachedPowerForBinaryExponentRange(</span>
<span class="line-modified">!       ten_mk_minimal_binary_exponent,</span>
<span class="line-modified">!       ten_mk_maximal_binary_exponent,</span>
<span class="line-modified">!       &amp;ten_mk, &amp;mk);</span>
<span class="line-modified">!   ASSERT((kMinimalTargetExponent &lt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!           DiyFp::kSignificandSize) &amp;&amp;</span>
<span class="line-modified">!          (kMaximalTargetExponent &gt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!           DiyFp::kSignificandSize));</span>
<span class="line-modified">!   // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a</span>
<span class="line-modified">!   // 64 bit significand and ten_mk is thus only precise up to 64 bits.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The DiyFp::Times procedure rounds its result, and ten_mk is approximated</span>
<span class="line-modified">!   // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now</span>
<span class="line-modified">!   // off by a small amount.</span>
<span class="line-modified">!   // In fact: scaled_w - w*10^k &lt; 1ulp (unit in the last place) of scaled_w.</span>
<span class="line-modified">!   // In other words: let f = scaled_w.f() and e = scaled_w.e(), then</span>
<span class="line-modified">!   //           (f-1) * 2^e &lt; w*10^k &lt; (f+1) * 2^e</span>
<span class="line-modified">!   DiyFp scaled_w = DiyFp::Times(w, ten_mk);</span>
<span class="line-modified">!   ASSERT(scaled_w.e() ==</span>
<span class="line-modified">!          boundary_plus.e() + ten_mk.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!   // In theory it would be possible to avoid some recomputations by computing</span>
<span class="line-modified">!   // the difference between w and boundary_minus/plus (a power of 2) and to</span>
<span class="line-modified">!   // compute scaled_boundary_minus/plus by subtracting/adding from</span>
<span class="line-modified">!   // scaled_w. However the code becomes much less readable and the speed</span>
<span class="line-modified">!   // enhancements are not terriffic.</span>
<span class="line-modified">!   DiyFp scaled_boundary_minus = DiyFp::Times(boundary_minus, ten_mk);</span>
<span class="line-modified">!   DiyFp scaled_boundary_plus  = DiyFp::Times(boundary_plus,  ten_mk);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // DigitGen will generate the digits of scaled_w. Therefore we have</span>
<span class="line-modified">!   // v == (double) (scaled_w * 10^-mk).</span>
<span class="line-modified">!   // Set decimal_exponent == -mk and pass it to DigitGen. If scaled_w is not an</span>
<span class="line-modified">!   // integer than it will be updated. For instance if scaled_w == 1.23 then</span>
<span class="line-modified">!   // the buffer will be filled with &quot;123&quot; und the decimal_exponent will be</span>
<span class="line-modified">!   // decreased by 2.</span>
<span class="line-modified">!   int kappa;</span>
<span class="line-modified">!   bool result = DigitGen(scaled_boundary_minus, scaled_w, scaled_boundary_plus,</span>
<span class="line-modified">!                          buffer, length, &amp;kappa);</span>
<span class="line-modified">!   *decimal_exponent = -mk + kappa;</span>
<span class="line-modified">!   return result;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // The &quot;counted&quot; version of grisu3 (see above) only generates requested_digits
  // number of digits. This version does not generate the shortest representation,
  // and with enough requested digits 0.1 will at some point print as 0.9999999...
  // Grisu3 is too imprecise for real halfway cases (1.5 will not work) and
  // therefore the rounding strategy for halfway cases is irrelevant.
  static bool Grisu3Counted(double v,
<span class="line-modified">!                           int requested_digits,</span>
<span class="line-modified">!                           BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                           int* length,</span>
<span class="line-modified">!                           int* decimal_exponent) {</span>
<span class="line-modified">!   DiyFp w = Double(v).AsNormalizedDiyFp();</span>
<span class="line-modified">!   DiyFp ten_mk;  // Cached power of ten: 10^-k</span>
<span class="line-modified">!   int mk;        // -k</span>
<span class="line-modified">!   int ten_mk_minimal_binary_exponent =</span>
<span class="line-modified">!      kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!   int ten_mk_maximal_binary_exponent =</span>
<span class="line-modified">!      kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);</span>
<span class="line-modified">!   PowersOfTenCache::GetCachedPowerForBinaryExponentRange(</span>
<span class="line-modified">!       ten_mk_minimal_binary_exponent,</span>
<span class="line-modified">!       ten_mk_maximal_binary_exponent,</span>
<span class="line-modified">!       &amp;ten_mk, &amp;mk);</span>
<span class="line-modified">!   ASSERT((kMinimalTargetExponent &lt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!           DiyFp::kSignificandSize) &amp;&amp;</span>
<span class="line-modified">!          (kMaximalTargetExponent &gt;= w.e() + ten_mk.e() +</span>
<span class="line-modified">!           DiyFp::kSignificandSize));</span>
<span class="line-modified">!   // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a</span>
<span class="line-modified">!   // 64 bit significand and ten_mk is thus only precise up to 64 bits.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The DiyFp::Times procedure rounds its result, and ten_mk is approximated</span>
<span class="line-modified">!   // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now</span>
<span class="line-modified">!   // off by a small amount.</span>
<span class="line-modified">!   // In fact: scaled_w - w*10^k &lt; 1ulp (unit in the last place) of scaled_w.</span>
<span class="line-modified">!   // In other words: let f = scaled_w.f() and e = scaled_w.e(), then</span>
<span class="line-modified">!   //           (f-1) * 2^e &lt; w*10^k &lt; (f+1) * 2^e</span>
<span class="line-modified">!   DiyFp scaled_w = DiyFp::Times(w, ten_mk);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // We now have (double) (scaled_w * 10^-mk).</span>
<span class="line-modified">!   // DigitGen will generate the first requested_digits digits of scaled_w and</span>
<span class="line-modified">!   // return together with a kappa such that scaled_w ~= buffer * 10^kappa. (It</span>
<span class="line-modified">!   // will not always be exactly the same since DigitGenCounted only produces a</span>
<span class="line-modified">!   // limited number of digits.)</span>
<span class="line-modified">!   int kappa;</span>
<span class="line-modified">!   bool result = DigitGenCounted(scaled_w, requested_digits,</span>
<span class="line-modified">!                                 buffer, length, &amp;kappa);</span>
<span class="line-modified">!   *decimal_exponent = -mk + kappa;</span>
<span class="line-modified">!   return result;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  bool FastDtoa(double v,
<span class="line-modified">!               FastDtoaMode mode,</span>
<span class="line-modified">!               int requested_digits,</span>
<span class="line-modified">!               BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!               int* length,</span>
<span class="line-modified">!               int* decimal_point) {</span>
<span class="line-modified">!   ASSERT(v &gt; 0);</span>
<span class="line-modified">!   ASSERT(!Double(v).IsSpecial());</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool result = false;</span>
<span class="line-modified">!   int decimal_exponent = 0;</span>
<span class="line-modified">!   switch (mode) {</span>
<span class="line-modified">!     case FAST_DTOA_SHORTEST:</span>
      case FAST_DTOA_SHORTEST_SINGLE:
        result = Grisu3(v, mode, buffer, length, &amp;decimal_exponent);
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case FAST_DTOA_PRECISION:</span>
<span class="line-modified">!       result = Grisu3Counted(v, requested_digits,</span>
<span class="line-modified">!                              buffer, length, &amp;decimal_exponent);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!       UNREACHABLE();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (result) {</span>
<span class="line-modified">!     *decimal_point = *length + decimal_exponent;</span>
<span class="line-modified">!     buffer[*length] = &#39;\0&#39;;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return result;</span>
  }
<span class="line-modified">! </span>
  }  // namespace double_conversion
<span class="line-modified">! }  // namespace WTF</span>
</pre>
<center><a href="double-conversion.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fast-dtoa.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>