<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityNodeObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityRenderObject.h&quot;
  34 #include &quot;AccessibilityScrollView.h&quot;
  35 #include &quot;AccessibilityTable.h&quot;
<span class="line-modified">  36 #include &quot;AccessibleSetValueEvent.h&quot;</span>

  37 #include &quot;DOMTokenList.h&quot;
  38 #include &quot;Editing.h&quot;
  39 #include &quot;Editor.h&quot;
  40 #include &quot;ElementIterator.h&quot;
  41 #include &quot;Event.h&quot;
  42 #include &quot;EventDispatcher.h&quot;
  43 #include &quot;EventHandler.h&quot;

  44 #include &quot;FloatRect.h&quot;
  45 #include &quot;FocusController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;FrameSelection.h&quot;

  49 #include &quot;HTMLDetailsElement.h&quot;
  50 #include &quot;HTMLFormControlElement.h&quot;
  51 #include &quot;HTMLInputElement.h&quot;
  52 #include &quot;HTMLMediaElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLParserIdioms.h&quot;

  55 #include &quot;HitTestResult.h&quot;
  56 #include &quot;LocalizedStrings.h&quot;
  57 #include &quot;MathMLNames.h&quot;
  58 #include &quot;NodeList.h&quot;
  59 #include &quot;NodeTraversal.h&quot;
  60 #include &quot;Page.h&quot;
  61 #include &quot;RenderImage.h&quot;
  62 #include &quot;RenderLayer.h&quot;
  63 #include &quot;RenderListItem.h&quot;
  64 #include &quot;RenderListMarker.h&quot;
  65 #include &quot;RenderMenuList.h&quot;
  66 #include &quot;RenderText.h&quot;
  67 #include &quot;RenderTextControl.h&quot;
  68 #include &quot;RenderTheme.h&quot;
  69 #include &quot;RenderView.h&quot;
  70 #include &quot;RenderWidget.h&quot;
  71 #include &quot;RenderedPosition.h&quot;
  72 #include &quot;RuntimeEnabledFeatures.h&quot;
  73 #include &quot;Settings.h&quot;
  74 #include &quot;TextCheckerClient.h&quot;
</pre>
<hr />
<pre>
  85 
  86 namespace WebCore {
  87 
  88 using namespace HTMLNames;
  89 
  90 AccessibilityObject::~AccessibilityObject()
  91 {
  92     ASSERT(isDetached());
  93 }
  94 
  95 void AccessibilityObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
  96 {
  97     // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
  98     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu &amp;&amp; cache)
  99         cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);
 100 
 101     // Clear any children and call detachFromParent on them so that
 102     // no children are left with dangling pointers to their parent.
 103     clearChildren();
 104 
<span class="line-modified"> 105 #if HAVE(ACCESSIBILITY)</span>
 106     setWrapper(nullptr);
 107 #endif
 108 }
 109 
 110 bool AccessibilityObject::isDetached() const
 111 {
<span class="line-modified"> 112 #if HAVE(ACCESSIBILITY)</span>
 113     return !wrapper();
 114 #else
 115     return true;
 116 #endif
 117 }
 118 
 119 bool AccessibilityObject::isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria, size_t index)
 120 {
 121     switch (criteria-&gt;searchKeys[index]) {
 122     // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.
 123     case AccessibilitySearchKey::AnyType:
 124         return true;
 125 
 126     case AccessibilitySearchKey::Article:
 127         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;
 128 
 129     case AccessibilitySearchKey::BlockquoteSameLevel:
 130         return criteria-&gt;startObject
 131             &amp;&amp; axObject-&gt;isBlockquote()
 132             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria-&gt;startObject-&gt;blockquoteLevel();
</pre>
<hr />
<pre>
 176     case AccessibilitySearchKey::HeadingLevel4:
 177         return axObject-&gt;headingLevel() == 4;
 178 
 179     case AccessibilitySearchKey::HeadingLevel5:
 180         return axObject-&gt;headingLevel() == 5;
 181 
 182     case AccessibilitySearchKey::HeadingLevel6:
 183         return axObject-&gt;headingLevel() == 6;
 184 
 185     case AccessibilitySearchKey::HeadingSameLevel:
 186         return criteria-&gt;startObject
 187             &amp;&amp; axObject-&gt;isHeading()
 188             &amp;&amp; axObject-&gt;headingLevel() == criteria-&gt;startObject-&gt;headingLevel();
 189 
 190     case AccessibilitySearchKey::Heading:
 191         return axObject-&gt;isHeading();
 192 
 193     case AccessibilitySearchKey::Highlighted:
 194         return axObject-&gt;hasHighlighting();
 195 



 196     case AccessibilitySearchKey::ItalicFont:
 197         return axObject-&gt;hasItalicFont();
 198 
 199     case AccessibilitySearchKey::Landmark:
 200         return axObject-&gt;isLandmark();
 201 
 202     case AccessibilitySearchKey::Link: {
 203         bool isLink = axObject-&gt;isLink();
 204 #if PLATFORM(IOS_FAMILY)
 205         if (!isLink)
 206             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);
 207 #endif
 208         return isLink;
 209     }
 210 
 211     case AccessibilitySearchKey::List:
 212         return axObject-&gt;isList();
 213 
 214     case AccessibilitySearchKey::LiveRegion:
 215         return axObject-&gt;supportsLiveRegion();
</pre>
<hr />
<pre>
 315     case AccessibilityRole::DocumentArticle:
 316     case AccessibilityRole::DocumentMath:
 317     case AccessibilityRole::DocumentNote:
 318     case AccessibilityRole::LandmarkRegion:
 319     case AccessibilityRole::LandmarkDocRegion:
 320     case AccessibilityRole::Form:
 321     case AccessibilityRole::Grid:
 322     case AccessibilityRole::Group:
 323     case AccessibilityRole::Image:
 324     case AccessibilityRole::List:
 325     case AccessibilityRole::ListBox:
 326     case AccessibilityRole::LandmarkBanner:
 327     case AccessibilityRole::LandmarkComplementary:
 328     case AccessibilityRole::LandmarkContentInfo:
 329     case AccessibilityRole::LandmarkNavigation:
 330     case AccessibilityRole::LandmarkMain:
 331     case AccessibilityRole::LandmarkSearch:
 332     case AccessibilityRole::Menu:
 333     case AccessibilityRole::MenuBar:
 334     case AccessibilityRole::ProgressIndicator:

 335     case AccessibilityRole::RadioGroup:
 336     case AccessibilityRole::ScrollBar:
 337     case AccessibilityRole::Slider:
 338     case AccessibilityRole::SpinButton:
 339     case AccessibilityRole::Splitter:
 340     case AccessibilityRole::Table:
 341     case AccessibilityRole::TabList:
 342     case AccessibilityRole::TabPanel:
 343     case AccessibilityRole::TextArea:
 344     case AccessibilityRole::TextField:
 345     case AccessibilityRole::Toolbar:
 346     case AccessibilityRole::TreeGrid:
 347     case AccessibilityRole::Tree:
 348     case AccessibilityRole::WebApplication:
 349         return false;
 350     default:
 351         break;
 352     }
 353 
 354     // Now check for generically derived elements now that we know the element does not match a specific ARIA role.
</pre>
<hr />
<pre>
 389     case AccessibilityRole::TextArea:
 390     case AccessibilityRole::TextField:
 391         return true;
 392     default:
 393         return false;
 394     }
 395 }
 396 
 397 bool AccessibilityObject::isARIATextControl() const
 398 {
 399     return ariaRoleAttribute() == AccessibilityRole::TextArea || ariaRoleAttribute() == AccessibilityRole::TextField || ariaRoleAttribute() == AccessibilityRole::SearchField;
 400 }
 401 
 402 bool AccessibilityObject::isNonNativeTextControl() const
 403 {
 404     return (isARIATextControl() || hasContentEditableAttributeSet()) &amp;&amp; !isNativeTextControl();
 405 }
 406 
 407 bool AccessibilityObject::isLandmark() const
 408 {
<span class="line-modified"> 409     AccessibilityRole role = roleValue();</span>
<span class="line-modified"> 410 </span>
<span class="line-modified"> 411     return role == AccessibilityRole::LandmarkBanner</span>
<span class="line-modified"> 412         || role == AccessibilityRole::LandmarkComplementary</span>
<span class="line-modified"> 413         || role == AccessibilityRole::LandmarkContentInfo</span>
<span class="line-modified"> 414         || role == AccessibilityRole::LandmarkDocRegion</span>
<span class="line-modified"> 415         || role == AccessibilityRole::LandmarkMain</span>
<span class="line-modified"> 416         || role == AccessibilityRole::LandmarkNavigation</span>
<span class="line-modified"> 417         || role == AccessibilityRole::LandmarkRegion</span>
<span class="line-modified"> 418         || role == AccessibilityRole::LandmarkSearch;</span>



 419 }
 420 
 421 bool AccessibilityObject::hasMisspelling() const
 422 {
 423     if (!node())
 424         return false;
 425 
 426     Frame* frame = node()-&gt;document().frame();
 427     if (!frame)
 428         return false;
 429 
 430     Editor&amp; editor = frame-&gt;editor();
 431 
 432     TextCheckerClient* textChecker = editor.textChecker();
 433     if (!textChecker)
 434         return false;
 435 
 436     bool isMisspelled = false;
 437 
 438     if (unifiedTextCheckerEnabled(frame)) {
</pre>
<hr />
<pre>
 465 
 466 AccessibilityObject* AccessibilityObject::parentObjectUnignored() const
 467 {
 468     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
 469         return !object.accessibilityIsIgnored();
 470     }));
 471 }
 472 
 473 AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
 474 {
 475     AccessibilityObject* previous;
 476     ASSERT(limit &gt;= 0);
 477     for (previous = previousSibling(); previous &amp;&amp; previous-&gt;accessibilityIsIgnored(); previous = previous-&gt;previousSibling()) {
 478         limit--;
 479         if (limit &lt;= 0)
 480             break;
 481     }
 482     return previous;
 483 }
 484 

































 485 AccessibilityObject* AccessibilityObject::nextSiblingUnignored(int limit) const
 486 {
 487     AccessibilityObject* next;
 488     ASSERT(limit &gt;= 0);
 489     for (next = nextSibling(); next &amp;&amp; next-&gt;accessibilityIsIgnored(); next = next-&gt;nextSibling()) {
 490         limit--;
 491         if (limit &lt;= 0)
 492             break;
 493     }
 494     return next;
 495 }
 496 
 497 AccessibilityObject* AccessibilityObject::firstAccessibleObjectFromNode(const Node* node)







 498 {
 499     if (!node)
 500         return nullptr;
 501 
 502     AXObjectCache* cache = node-&gt;document().axObjectCache();
 503     if (!cache)
 504         return nullptr;
 505 
 506     AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
<span class="line-modified"> 507     while (accessibleObject &amp;&amp; accessibleObject-&gt;accessibilityIsIgnored()) {</span>
 508         node = NodeTraversal::next(*node);
 509 
 510         while (node &amp;&amp; !node-&gt;renderer())
 511             node = NodeTraversal::nextSkippingChildren(*node);
 512 
 513         if (!node)
 514             return nullptr;
 515 
 516         accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 517     }
 518 
 519     return accessibleObject;
 520 }
 521 
 522 bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
 523 {
 524     return AccessibilityObject::matchedParent(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {
 525         return object.roleValue() == role;
 526     }) != nullptr;
 527 }
</pre>
<hr />
<pre>
 696                 break;
 697 
 698             if (!criteria-&gt;immediateDescendantsOnly)
 699                 appendChildrenToArray(searchObject, isForward, 0, searchStack);
 700         }
 701 
 702         if (results.size() &gt;= criteria-&gt;resultsLimit)
 703             break;
 704 
 705         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.
 706         if (!isForward &amp;&amp; startObject != this &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))
 707             break;
 708 
 709         previousObject = startObject;
 710     }
 711 }
 712 
 713 // Returns the range that is fewer positions away from the reference range.
 714 // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
 715 // range is expected to ACTUALLY be before. These are not checked for performance reasons.
<span class="line-modified"> 716 static RefPtr&lt;Range&gt; rangeClosestToRange(Range* referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)</span>
 717 {
 718     if (!referenceRange)
 719         return nullptr;
 720 
 721     // The treeScope for shadow nodes may not be the same scope as another element in a document.
 722     // Comparisons may fail in that case, which are expected behavior and should not assert.
 723     if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 724         return nullptr;
<span class="line-modified"> 725     ASSERT(!afterRange || afterRange-&gt;startPosition() &gt;= referenceRange-&gt;endPosition());</span>
 726 
 727     if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 728         return nullptr;
<span class="line-modified"> 729     ASSERT(!beforeRange || beforeRange-&gt;endPosition() &lt;= referenceRange-&gt;startPosition());</span>
 730 
 731     if (!afterRange &amp;&amp; !beforeRange)
 732         return nullptr;
 733     if (afterRange &amp;&amp; !beforeRange)
 734         return WTFMove(afterRange);
 735     if (!afterRange &amp;&amp; beforeRange)
 736         return WTFMove(beforeRange);
 737 
 738     unsigned positionsToAfterRange = Position::positionCountBetweenPositions(afterRange-&gt;startPosition(), referenceRange-&gt;endPosition());
 739     unsigned positionsToBeforeRange = Position::positionCountBetweenPositions(beforeRange-&gt;endPosition(), referenceRange-&gt;startPosition());
 740 
 741     return positionsToAfterRange &lt; positionsToBeforeRange ? afterRange : beforeRange;
 742 }
 743 
<span class="line-modified"> 744 RefPtr&lt;Range&gt; AccessibilityObject::rangeOfStringClosestToRangeInDirection(Range* referenceRange, AccessibilitySearchDirection searchDirection, Vector&lt;String&gt;&amp; searchStrings) const</span>
 745 {
 746     Frame* frame = this-&gt;frame();
 747     if (!frame)
 748         return nullptr;
 749 
 750     if (!referenceRange)
 751         return nullptr;
 752 
 753     bool isBackwardSearch = searchDirection == AccessibilitySearchDirection::Previous;
 754     FindOptions findOptions { AtWordStarts, AtWordEnds, CaseInsensitive, StartInSelection };
 755     if (isBackwardSearch)
<span class="line-modified"> 756         findOptions.add(Backwards);</span>
 757 
 758     RefPtr&lt;Range&gt; closestStringRange = nullptr;
 759     for (const auto&amp; searchString : searchStrings) {
 760         if (RefPtr&lt;Range&gt; searchStringRange = frame-&gt;editor().rangeOfString(searchString, referenceRange, findOptions)) {
 761             if (!closestStringRange)
 762                 closestStringRange = searchStringRange;
 763             else {
 764                 // If searching backward, use the trailing range edges to correctly determine which
 765                 // range is closest. Similarly, if searching forward, use the leading range edges.
 766                 Position closestStringPosition = isBackwardSearch ? closestStringRange-&gt;endPosition() : closestStringRange-&gt;startPosition();
 767                 Position searchStringPosition = isBackwardSearch ? searchStringRange-&gt;endPosition() : searchStringRange-&gt;startPosition();
 768 
 769                 int closestPositionOffset = closestStringPosition.computeOffsetInContainerNode();
 770                 int searchPositionOffset = searchStringPosition.computeOffsetInContainerNode();
 771                 Node* closestContainerNode = closestStringPosition.containerNode();
 772                 Node* searchContainerNode = searchStringPosition.containerNode();
 773 
 774                 short result = Range::compareBoundaryPoints(closestContainerNode, closestPositionOffset, searchContainerNode, searchPositionOffset).releaseReturnValue();
 775                 if ((!isBackwardSearch &amp;&amp; result &gt; 0) || (isBackwardSearch &amp;&amp; result &lt; 0))
 776                     closestStringRange = searchStringRange;
</pre>
<hr />
<pre>
 782 
 783 // Returns the range of the entire document if there is no selection.
 784 RefPtr&lt;Range&gt; AccessibilityObject::selectionRange() const
 785 {
 786     Frame* frame = this-&gt;frame();
 787     if (!frame)
 788         return nullptr;
 789 
 790     const VisibleSelection&amp; selection = frame-&gt;selection().selection();
 791     if (!selection.isNone())
 792         return selection.firstRange();
 793 
 794     return Range::create(*frame-&gt;document());
 795 }
 796 
 797 RefPtr&lt;Range&gt; AccessibilityObject::elementRange() const
 798 {
 799     return AXObjectCache::rangeForNodeContents(node());
 800 }
 801 
<span class="line-modified"> 802 String AccessibilityObject::selectText(AccessibilitySelectTextCriteria* criteria)</span>
 803 {
<span class="line-modified"> 804     ASSERT(criteria);</span>
<span class="line-modified"> 805 </span>
<span class="line-modified"> 806     if (!criteria)</span>
<span class="line-modified"> 807         return String();</span>
<span class="line-modified"> 808 </span>
<span class="line-modified"> 809     Frame* frame = this-&gt;frame();</span>
<span class="line-modified"> 810     if (!frame)</span>
<span class="line-modified"> 811         return String();</span>


 812 
<span class="line-modified"> 813     AccessibilitySelectTextActivity&amp; activity = criteria-&gt;activity;</span>
<span class="line-removed"> 814     AccessibilitySelectTextAmbiguityResolution&amp; ambiguityResolution = criteria-&gt;ambiguityResolution;</span>
<span class="line-removed"> 815     String&amp; replacementString = criteria-&gt;replacementString;</span>
<span class="line-removed"> 816     Vector&lt;String&gt;&amp; searchStrings = criteria-&gt;searchStrings;</span>
<span class="line-removed"> 817 </span>
<span class="line-removed"> 818     RefPtr&lt;Range&gt; selectedStringRange = selectionRange();</span>
<span class="line-removed"> 819     // When starting our search again, make this a zero length range so that search forwards will find this selected range if its appropriate.</span>
<span class="line-removed"> 820     selectedStringRange-&gt;setEnd(selectedStringRange-&gt;startContainer(), selectedStringRange-&gt;startOffset());</span>
<span class="line-removed"> 821 </span>
<span class="line-removed"> 822     RefPtr&lt;Range&gt; closestAfterStringRange = nullptr;</span>
<span class="line-removed"> 823     RefPtr&lt;Range&gt; closestBeforeStringRange = nullptr;</span>
<span class="line-removed"> 824     // Search forward if necessary.</span>
<span class="line-removed"> 825     if (ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestAfter || ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestTo)</span>
<span class="line-removed"> 826         closestAfterStringRange = rangeOfStringClosestToRangeInDirection(selectedStringRange.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-removed"> 827     // Search backward if necessary.</span>
<span class="line-removed"> 828     if (ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestBefore || ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestTo)</span>
<span class="line-removed"> 829         closestBeforeStringRange = rangeOfStringClosestToRangeInDirection(selectedStringRange.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-removed"> 830 </span>
<span class="line-removed"> 831     // Determine which candidate is closest to the selection and perform the activity.</span>
<span class="line-removed"> 832     if (RefPtr&lt;Range&gt; closestStringRange = rangeClosestToRange(selectedStringRange.get(), WTFMove(closestAfterStringRange), WTFMove(closestBeforeStringRange))) {</span>
 833         // If the search started within a text control, ensure that the result is inside that element.
 834         if (element() &amp;&amp; element()-&gt;isTextField()) {
<span class="line-modified"> 835             if (!closestStringRange-&gt;startContainer().isDescendantOrShadowDescendantOf(element()) || !closestStringRange-&gt;endContainer().isDescendantOrShadowDescendantOf(element()))</span>
<span class="line-modified"> 836                 return String();</span>

 837         }



 838 
<span class="line-modified"> 839         String closestString = closestStringRange-&gt;text();</span>
<span class="line-modified"> 840         bool replaceSelection = false;</span>
<span class="line-modified"> 841         if (frame-&gt;selection().setSelectedRange(closestStringRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes)) {</span>
<span class="line-removed"> 842             switch (activity) {</span>
<span class="line-removed"> 843             case AccessibilitySelectTextActivity::FindAndCapitalize:</span>
<span class="line-removed"> 844                 replacementString = capitalize(closestString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-removed"> 845                 replaceSelection = true;</span>
<span class="line-removed"> 846                 break;</span>
<span class="line-removed"> 847             case AccessibilitySelectTextActivity::FindAndUppercase:</span>
<span class="line-removed"> 848                 replacementString = closestString.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-removed"> 849                 replaceSelection = true;</span>
<span class="line-removed"> 850                 break;</span>
<span class="line-removed"> 851             case AccessibilitySelectTextActivity::FindAndLowercase:</span>
<span class="line-removed"> 852                 replacementString = closestString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-removed"> 853                 replaceSelection = true;</span>
<span class="line-removed"> 854                 break;</span>
<span class="line-removed"> 855             case AccessibilitySelectTextActivity::FindAndReplace: {</span>
<span class="line-removed"> 856                 replaceSelection = true;</span>
<span class="line-removed"> 857                 // When applying find and replace activities, we want to match the capitalization of the replaced text,</span>
<span class="line-removed"> 858                 // (unless we&#39;re replacing with an abbreviation.)</span>
<span class="line-removed"> 859                 if (closestString.length() &gt; 0 &amp;&amp; replacementString.length() &gt; 2 &amp;&amp; replacementString != replacementString.convertToUppercaseWithoutLocale()) {</span>
<span class="line-removed"> 860                     if (closestString[0] == u_toupper(closestString[0]))</span>
<span class="line-removed"> 861                         replacementString = capitalize(replacementString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-removed"> 862                     else</span>
<span class="line-removed"> 863                         replacementString = replacementString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-removed"> 864                 }</span>
<span class="line-removed"> 865                 break;</span>
<span class="line-removed"> 866             }</span>
<span class="line-removed"> 867             case AccessibilitySelectTextActivity::FindAndSelect:</span>
<span class="line-removed"> 868                 break;</span>
<span class="line-removed"> 869             }</span>
 870 
<span class="line-modified"> 871             // A bit obvious, but worth noting the API contract for this method is that we should</span>
<span class="line-modified"> 872             // return the replacement string when replacing, but the selected string if not.</span>
<span class="line-modified"> 873             if (replaceSelection) {</span>
<span class="line-modified"> 874                 frame-&gt;editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::Yes, Editor::SmartReplace::Yes);</span>
<span class="line-modified"> 875                 return replacementString;</span>




























 876             }




















 877 
<span class="line-modified"> 878             return closestString;</span>
































 879         }











 880     }
 881 
<span class="line-modified"> 882     return String();</span>
 883 }
 884 
 885 bool AccessibilityObject::hasAttributesRequiredForInclusion() const
 886 {
 887     // These checks are simplified in the interest of execution speed.
 888     if (!getAttribute(aria_helpAttr).isEmpty()
 889         || !getAttribute(aria_describedbyAttr).isEmpty()
 890         || !getAttribute(altAttr).isEmpty()
 891         || !getAttribute(titleAttr).isEmpty())
 892         return true;
 893 
 894 #if ENABLE(MATHML)
 895     if (!getAttribute(MathMLNames::alttextAttr).isEmpty())
 896         return true;
 897 #endif
 898 
 899     return false;
 900 }
 901 
 902 bool AccessibilityObject::isARIAInput(AccessibilityRole ariaRole)
 903 {
 904     return ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::CheckBox || ariaRole == AccessibilityRole::TextField || ariaRole == AccessibilityRole::Switch || ariaRole == AccessibilityRole::SearchField;
 905 }
 906 
 907 bool AccessibilityObject::isARIAControl(AccessibilityRole ariaRole)
 908 {
 909     return isARIAInput(ariaRole) || ariaRole == AccessibilityRole::TextArea || ariaRole == AccessibilityRole::Button || ariaRole == AccessibilityRole::ComboBox || ariaRole == AccessibilityRole::Slider || ariaRole == AccessibilityRole::ListBox;
 910 }
 911 
 912 bool AccessibilityObject::isRangeControl() const
 913 {
 914     switch (roleValue()) {

 915     case AccessibilityRole::ProgressIndicator:
 916     case AccessibilityRole::Slider:
 917     case AccessibilityRole::ScrollBar:
 918     case AccessibilityRole::SpinButton:
 919         return true;
 920     case AccessibilityRole::Splitter:
 921         return canSetFocusAttribute();
 922     default:
 923         return false;
 924     }
 925 }
 926 
 927 bool AccessibilityObject::isMeter() const
 928 {



 929 #if ENABLE(METER_ELEMENT)
 930     RenderObject* renderer = this-&gt;renderer();
 931     return renderer &amp;&amp; renderer-&gt;isMeter();
 932 #else
 933     return false;
 934 #endif
 935 }
 936 
 937 IntPoint AccessibilityObject::clickPoint()
 938 {
 939     LayoutRect rect = elementRect();
 940     return roundedIntPoint(LayoutPoint(rect.x() + rect.width() / 2, rect.y() + rect.height() / 2));
 941 }
 942 
 943 IntRect AccessibilityObject::boundingBoxForQuads(RenderObject* obj, const Vector&lt;FloatQuad&gt;&amp; quads)
 944 {
 945     ASSERT(obj);
 946     if (!obj)
 947         return IntRect();
 948 
</pre>
<hr />
<pre>
 978         if (auto* innerNode = hitTestResult.innerNode()) {
 979             if (auto* shadowHost = innerNode-&gt;shadowHost())
 980                 hitTestElement = shadowHost;
 981             else if (is&lt;Element&gt;(*innerNode))
 982                 hitTestElement = &amp;downcast&lt;Element&gt;(*innerNode);
 983             else
 984                 hitTestElement = innerNode-&gt;parentElement();
 985         }
 986     }
 987 
 988     // Prefer the actionElement instead of this node, if the actionElement is inside this node.
 989     Element* pressElement = this-&gt;element();
 990     if (!pressElement || actionElem-&gt;isDescendantOf(*pressElement))
 991         pressElement = actionElem;
 992 
 993     ASSERT(pressElement);
 994     // Prefer the hit test element, if it is inside the target element.
 995     if (hitTestElement &amp;&amp; hitTestElement-&gt;isDescendantOf(*pressElement))
 996         pressElement = hitTestElement;
 997 
<span class="line-removed"> 998     // dispatch accessibleclick event</span>
<span class="line-removed"> 999     if (auto* cache = axObjectCache()) {</span>
<span class="line-removed">1000         if (auto* pressObject = cache-&gt;getOrCreate(pressElement)) {</span>
<span class="line-removed">1001             if (pressObject-&gt;dispatchAccessibilityEventWithType(AccessibilityEventType::Click))</span>
<span class="line-removed">1002                 return true;</span>
<span class="line-removed">1003         }</span>
<span class="line-removed">1004     }</span>
<span class="line-removed">1005 </span>
1006     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document);
1007 
1008     bool dispatchedTouchEvent = false;
1009 #if PLATFORM(IOS_FAMILY)
1010     if (hasTouchEventListener())
1011         dispatchedTouchEvent = dispatchTouchEvent();
1012 #endif
1013     if (!dispatchedTouchEvent)
1014         pressElement-&gt;accessKeyAction(true);
1015 
1016     return true;
1017 }
1018 
1019 bool AccessibilityObject::dispatchTouchEvent()
1020 {
1021 #if ENABLE(IOS_TOUCH_EVENTS)
1022     if (auto* frame = mainFrame())
1023         return frame-&gt;eventHandler().dispatchSimulatedTouchEvent(clickPoint());
1024 #endif
1025     return false;
1026 }
1027 
1028 Frame* AccessibilityObject::frame() const
1029 {
1030     Node* node = this-&gt;node();
<span class="line-modified">1031     if (!node)</span>
<span class="line-removed">1032         return nullptr;</span>
<span class="line-removed">1033 </span>
<span class="line-removed">1034     return node-&gt;document().frame();</span>
1035 }
1036 
1037 Frame* AccessibilityObject::mainFrame() const
1038 {
1039     Document* document = topDocument();
1040     if (!document)
1041         return nullptr;
1042 
1043     Frame* frame = document-&gt;frame();
1044     if (!frame)
1045         return nullptr;
1046 
1047     return &amp;frame-&gt;mainFrame();
1048 }
1049 
1050 Document* AccessibilityObject::topDocument() const
1051 {
1052     if (!document())
1053         return nullptr;
1054     return &amp;document()-&gt;topDocument();
1055 }
1056 
1057 String AccessibilityObject::language() const
1058 {
<span class="line-modified">1059     const AtomicString&amp; lang = getAttribute(langAttr);</span>
1060     if (!lang.isEmpty())
1061         return lang;
1062 
1063     AccessibilityObject* parent = parentObject();
1064 
1065     // as a last resort, fall back to the content language specified in the meta tag
1066     if (!parent) {
1067         Document* doc = document();
1068         if (doc)
1069             return doc-&gt;contentLanguage();
1070         return nullAtom();
1071     }
1072 
1073     return parent-&gt;language();
1074 }
1075 
1076 VisiblePositionRange AccessibilityObject::visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp; visiblePos1, const VisiblePosition&amp; visiblePos2) const
1077 {
1078     if (visiblePos1.isNull() || visiblePos2.isNull())
1079         return VisiblePositionRange();
</pre>
<hr />
<pre>
1665         || role == AccessibilityRole::TextField
1666         || role == AccessibilityRole::TreeGrid
1667         || isPasswordField();
1668 }
1669 
1670 String AccessibilityObject::readOnlyValue() const
1671 {
1672     if (!hasAttribute(aria_readonlyAttr))
1673         return ariaRoleAttribute() != AccessibilityRole::Unknown &amp;&amp; supportsReadOnly() ? &quot;false&quot; : String();
1674 
1675     return getAttribute(aria_readonlyAttr).string().convertToASCIILowercase();
1676 }
1677 
1678 bool AccessibilityObject::supportsAutoComplete() const
1679 {
1680     return (isComboBox() || isARIATextControl()) &amp;&amp; hasAttribute(aria_autocompleteAttr);
1681 }
1682 
1683 String AccessibilityObject::autoCompleteValue() const
1684 {
<span class="line-modified">1685     const AtomicString&amp; autoComplete = getAttribute(aria_autocompleteAttr);</span>
1686     if (equalLettersIgnoringASCIICase(autoComplete, &quot;inline&quot;)
1687         || equalLettersIgnoringASCIICase(autoComplete, &quot;list&quot;)
1688         || equalLettersIgnoringASCIICase(autoComplete, &quot;both&quot;))
1689         return autoComplete;
1690 
1691     return &quot;none&quot;;
1692 }
1693 
1694 bool AccessibilityObject::contentEditableAttributeIsEnabled(Element* element)
1695 {
1696     if (!element)
1697         return false;
1698 
<span class="line-modified">1699     const AtomicString&amp; contentEditableValue = element-&gt;attributeWithoutSynchronization(contenteditableAttr);</span>
1700     if (contentEditableValue.isNull())
1701         return false;
1702 
1703     // Both &quot;true&quot; (case-insensitive) and the empty string count as true.
1704     return contentEditableValue.isEmpty() || equalLettersIgnoringASCIICase(contentEditableValue, &quot;true&quot;);
1705 }
1706 
<span class="line-modified">1707 #if HAVE(ACCESSIBILITY)</span>
1708 int AccessibilityObject::lineForPosition(const VisiblePosition&amp; visiblePos) const
1709 {
1710     if (visiblePos.isNull() || !node())
1711         return -1;
1712 
1713     // If the position is not in the same editable region as this AX object, return -1.
1714     Node* containerNode = visiblePos.deepEquivalent().containerNode();
1715     if (!containerNode-&gt;containsIncludingShadowDOM(node()) &amp;&amp; !node()-&gt;containsIncludingShadowDOM(containerNode))
1716         return -1;
1717 
1718     int lineCount = -1;
1719     VisiblePosition currentVisiblePos = visiblePos;
1720     VisiblePosition savedVisiblePos;
1721 
1722     // move up until we get to the top
1723     // FIXME: This only takes us to the top of the rootEditableElement, not the top of the
1724     // top document.
1725     do {
1726         savedVisiblePos = currentVisiblePos;
1727         VisiblePosition prevVisiblePos = previousLinePosition(currentVisiblePos, 0, HasEditableAXRole);
</pre>
<hr />
<pre>
1757         return PlainTextRange();
1758 
1759     return PlainTextRange(i, 1);
1760 }
1761 
1762 // Given a character index, the range of text associated with this accessibility object
1763 // over which the style in effect at that character index applies.
1764 PlainTextRange AccessibilityObject::doAXStyleRangeForIndex(unsigned index) const
1765 {
1766     VisiblePositionRange range = styleRangeForPosition(visiblePositionForIndex(index, false));
1767     return plainTextRangeForVisiblePositionRange(range);
1768 }
1769 
1770 // Given an indexed character, the line number of the text associated with this accessibility
1771 // object that contains the character.
1772 unsigned AccessibilityObject::doAXLineForIndex(unsigned index)
1773 {
1774     return lineForPosition(visiblePositionForIndex(index, false));
1775 }
1776 
<span class="line-modified">1777 #if HAVE(ACCESSIBILITY)</span>
1778 void AccessibilityObject::updateBackingStore()
1779 {
1780     if (!axObjectCache())
1781         return;
1782 
1783     // Updating the layout may delete this object.
1784     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1785     if (auto* document = this-&gt;document()) {
1786         if (!document-&gt;view()-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !document-&gt;inRenderTreeUpdate() &amp;&amp; !document-&gt;inStyleRecalc())
1787             document-&gt;updateLayoutIgnorePendingStylesheets();
1788     }
1789 
1790     if (auto cache = axObjectCache())
1791         cache-&gt;performDeferredCacheUpdate();
1792 
1793     updateChildrenIfNecessary();
1794 }
1795 #endif
1796 
<span class="line-modified">1797 ScrollView* AccessibilityObject::scrollViewAncestor() const</span>
1798 {
<span class="line-modified">1799     if (const AccessibilityObject* scrollParent = AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
1800         return is&lt;AccessibilityScrollView&gt;(object);
<span class="line-modified">1801     }))</span>
<span class="line-modified">1802         return downcast&lt;AccessibilityScrollView&gt;(*scrollParent).scrollView();</span>





1803 
1804     return nullptr;
1805 }
1806 
1807 Document* AccessibilityObject::document() const
1808 {
1809     FrameView* frameView = documentFrameView();
1810     if (!frameView)
1811         return nullptr;
1812 
1813     return frameView-&gt;frame().document();
1814 }
1815 
1816 Page* AccessibilityObject::page() const
1817 {
1818     Document* document = this-&gt;document();
1819     if (!document)
1820         return nullptr;
1821     return document-&gt;page();
1822 }
1823 
1824 FrameView* AccessibilityObject::documentFrameView() const
1825 {
1826     const AccessibilityObject* object = this;
1827     while (object &amp;&amp; !object-&gt;isAccessibilityRenderObject())
1828         object = object-&gt;parentObject();
1829 
1830     if (!object)
1831         return nullptr;
1832 
1833     return object-&gt;documentFrameView();
1834 }
1835 
<span class="line-modified">1836 #if HAVE(ACCESSIBILITY)</span>
1837 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
1838 {
1839     if (updateChildrenIfNeeded)
1840         updateChildrenIfNecessary();
1841 
1842     return m_children;
1843 }
1844 #endif
1845 
1846 void AccessibilityObject::updateChildrenIfNecessary()
1847 {
1848     if (!hasChildren()) {
<span class="line-removed">1849 #if HAVE(ACCESSIBILITY)</span>
1850         // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
1851         AXAttributeCacheEnabler enableCache(axObjectCache());
<span class="line-removed">1852 #endif</span>
1853         addChildren();
1854     }
1855 }
1856 
1857 void AccessibilityObject::clearChildren()
1858 {
1859     // Some objects have weak pointers to their parents and those associations need to be detached.
1860     for (const auto&amp; child : m_children)
1861         child-&gt;detachFromParent();
1862 
1863     m_children.clear();
1864     m_haveChildren = false;
1865 }
1866 
1867 AccessibilityObject* AccessibilityObject::anchorElementForNode(Node* node)
1868 {
1869     RenderObject* obj = node-&gt;renderer();
1870     if (!obj)
1871         return nullptr;
1872 
</pre>
<hr />
<pre>
1941     }
1942 }
1943 
1944 const String AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityRole role)
1945 {
1946     switch (role) {
1947     case AccessibilityRole::ApplicationAlertDialog:
1948     case AccessibilityRole::ApplicationAlert:
1949         return &quot;assertive&quot;_s;
1950     case AccessibilityRole::ApplicationLog:
1951     case AccessibilityRole::ApplicationStatus:
1952         return &quot;polite&quot;_s;
1953     case AccessibilityRole::ApplicationTimer:
1954     case AccessibilityRole::ApplicationMarquee:
1955         return &quot;off&quot;_s;
1956     default:
1957         return nullAtom();
1958     }
1959 }
1960 
<span class="line-modified">1961 #if HAVE(ACCESSIBILITY)</span>
1962 const String&amp; AccessibilityObject::actionVerb() const
1963 {
1964 #if !PLATFORM(IOS_FAMILY)
1965     // FIXME: Need to add verbs for select elements.
1966     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
1967     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
1968     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
1969     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXCheckedCheckBoxActionVerb());
1970     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
1971     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
1972     static NeverDestroyed&lt;const String&gt; menuListAction(AXMenuListActionVerb());
1973     static NeverDestroyed&lt;const String&gt; menuListPopupAction(AXMenuListPopupActionVerb());
1974     static NeverDestroyed&lt;const String&gt; listItemAction(AXListItemActionVerb());
1975 
1976     switch (roleValue()) {
1977     case AccessibilityRole::Button:
1978     case AccessibilityRole::ToggleButton:
1979         return buttonAction;
1980     case AccessibilityRole::TextField:
1981     case AccessibilityRole::TextArea:
</pre>
<hr />
<pre>
2135         return false;
2136 
2137     return !isModalDescendant(modalNode);
2138 }
2139 
2140 bool AccessibilityObject::hasTagName(const QualifiedName&amp; tagName) const
2141 {
2142     Node* node = this-&gt;node();
2143     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hasTagName(tagName);
2144 }
2145 
2146 bool AccessibilityObject::hasAttribute(const QualifiedName&amp; attribute) const
2147 {
2148     Node* node = this-&gt;node();
2149     if (!is&lt;Element&gt;(node))
2150         return false;
2151 
2152     return downcast&lt;Element&gt;(*node).hasAttributeWithoutSynchronization(attribute);
2153 }
2154 
<span class="line-modified">2155 const AtomicString&amp; AccessibilityObject::getAttribute(const QualifiedName&amp; attribute) const</span>
2156 {
2157     if (auto* element = this-&gt;element())
2158         return element-&gt;attributeWithoutSynchronization(attribute);
2159     return nullAtom();
2160 }
2161 
<span class="line-modified">2162 bool AccessibilityObject::shouldDispatchAccessibilityEvent() const</span>
2163 {
<span class="line-modified">2164     bool shouldDispatch = RuntimeEnabledFeatures::sharedFeatures().accessibilityObjectModelEnabled();</span>
<span class="line-removed">2165 #if ENABLE(ACCESSIBILITY_EVENTS)</span>
<span class="line-removed">2166     return shouldDispatch &amp;= this-&gt;page()-&gt;settings().accessibilityEventsEnabled();</span>
<span class="line-removed">2167 #endif</span>
<span class="line-removed">2168     return shouldDispatch;</span>
<span class="line-removed">2169 }</span>
<span class="line-removed">2170 </span>
<span class="line-removed">2171 bool AccessibilityObject::dispatchAccessibilityEvent(Event&amp; event) const</span>
<span class="line-removed">2172 {</span>
<span class="line-removed">2173     if (!shouldDispatchAccessibilityEvent())</span>
2174         return false;
2175 
<span class="line-modified">2176     Vector&lt;Element*&gt; eventPath;</span>
<span class="line-removed">2177     for (auto* parentObject = this; parentObject; parentObject = parentObject-&gt;parentObject()) {</span>
<span class="line-removed">2178         if (parentObject-&gt;isWebArea())</span>
<span class="line-removed">2179             break;</span>
<span class="line-removed">2180         if (auto* parentElement = parentObject-&gt;element())</span>
<span class="line-removed">2181             eventPath.append(parentElement);</span>
<span class="line-removed">2182     }</span>
2183 
<span class="line-modified">2184     if (!eventPath.size())</span>
<span class="line-modified">2185         return false;</span>






2186 
<span class="line-modified">2187     EventDispatcher::dispatchEvent(eventPath, event);</span>







2188 
<span class="line-modified">2189     // return true if preventDefault() was called, so that we don&#39;t execute the fallback behavior.</span>
<span class="line-removed">2190     return event.defaultPrevented();</span>
2191 }
2192 
<span class="line-modified">2193 bool AccessibilityObject::dispatchAccessibilityEventWithType(AccessibilityEventType type) const</span>
2194 {
<span class="line-modified">2195     AtomicString eventName;</span>
<span class="line-removed">2196     switch (type) {</span>
<span class="line-removed">2197     case AccessibilityEventType::ContextMenu:</span>
<span class="line-removed">2198         eventName = eventNames().accessiblecontextmenuEvent;</span>
<span class="line-removed">2199         break;</span>
<span class="line-removed">2200     case AccessibilityEventType::Click:</span>
<span class="line-removed">2201         eventName = eventNames().accessibleclickEvent;</span>
<span class="line-removed">2202         break;</span>
<span class="line-removed">2203     case AccessibilityEventType::Decrement:</span>
<span class="line-removed">2204         eventName = eventNames().accessibledecrementEvent;</span>
<span class="line-removed">2205         break;</span>
<span class="line-removed">2206     case AccessibilityEventType::Dismiss:</span>
<span class="line-removed">2207         eventName = eventNames().accessibledismissEvent;</span>
<span class="line-removed">2208         break;</span>
<span class="line-removed">2209     case AccessibilityEventType::Focus:</span>
<span class="line-removed">2210         eventName = eventNames().accessiblefocusEvent;</span>
<span class="line-removed">2211         break;</span>
<span class="line-removed">2212     case AccessibilityEventType::Increment:</span>
<span class="line-removed">2213         eventName = eventNames().accessibleincrementEvent;</span>
<span class="line-removed">2214         break;</span>
<span class="line-removed">2215     case AccessibilityEventType::ScrollIntoView:</span>
<span class="line-removed">2216         eventName = eventNames().accessiblescrollintoviewEvent;</span>
<span class="line-removed">2217         break;</span>
<span class="line-removed">2218     case AccessibilityEventType::Select:</span>
<span class="line-removed">2219         eventName = eventNames().accessibleselectEvent;</span>
<span class="line-removed">2220         break;</span>
<span class="line-removed">2221     default:</span>
2222         return false;
<span class="line-removed">2223     }</span>
2224 
<span class="line-modified">2225     auto event = Event::create(eventName, Event::CanBubble::Yes, Event::IsCancelable::Yes);</span>
<span class="line-removed">2226     return dispatchAccessibilityEvent(event);</span>
<span class="line-removed">2227 }</span>
2228 
<span class="line-modified">2229 bool AccessibilityObject::dispatchAccessibleSetValueEvent(const String&amp; value) const</span>
<span class="line-modified">2230 {</span>
<span class="line-removed">2231     if (!canSetValueAttribute())</span>
2232         return false;
<span class="line-modified">2233     auto event = AccessibleSetValueEvent::create(eventNames().accessiblesetvalueEvent, value);</span>
<span class="line-modified">2234     return dispatchAccessibilityEvent(event);</span>


2235 }
2236 
2237 // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
2238 AccessibilityOrientation AccessibilityObject::orientation() const
2239 {
2240     LayoutRect bounds = elementRect();
2241     if (bounds.size().width() &gt; bounds.size().height())
2242         return AccessibilityOrientation::Horizontal;
2243     if (bounds.size().height() &gt; bounds.size().width())
2244         return AccessibilityOrientation::Vertical;
2245 
2246     return AccessibilityOrientation::Undefined;
2247 }
2248 
2249 bool AccessibilityObject::isDescendantOfObject(const AccessibilityObject* axObject) const
2250 {
2251     if (!axObject || !axObject-&gt;hasChildren())
2252         return false;
2253 
2254     return AccessibilityObject::matchedParent(*this, false, [axObject] (const AccessibilityObject&amp; object) {
</pre>
<hr />
<pre>
2285 };
2286 
2287 static void initializeRoleMap()
2288 {
2289     if (gAriaRoleMap)
2290         return;
2291     ASSERT(!gAriaReverseRoleMap);
2292 
2293     const RoleEntry roles[] = {
2294         { &quot;alert&quot;, AccessibilityRole::ApplicationAlert },
2295         { &quot;alertdialog&quot;, AccessibilityRole::ApplicationAlertDialog },
2296         { &quot;application&quot;, AccessibilityRole::WebApplication },
2297         { &quot;article&quot;, AccessibilityRole::DocumentArticle },
2298         { &quot;banner&quot;, AccessibilityRole::LandmarkBanner },
2299         { &quot;blockquote&quot;, AccessibilityRole::Blockquote },
2300         { &quot;button&quot;, AccessibilityRole::Button },
2301         { &quot;caption&quot;, AccessibilityRole::Caption },
2302         { &quot;checkbox&quot;, AccessibilityRole::CheckBox },
2303         { &quot;complementary&quot;, AccessibilityRole::LandmarkComplementary },
2304         { &quot;contentinfo&quot;, AccessibilityRole::LandmarkContentInfo },

2305         { &quot;dialog&quot;, AccessibilityRole::ApplicationDialog },
2306         { &quot;directory&quot;, AccessibilityRole::Directory },
2307         // The &#39;doc-*&#39; roles are defined the ARIA DPUB mobile: https://www.w3.org/TR/dpub-aam-1.0/
2308         // Editor&#39;s draft is currently at https://rawgit.com/w3c/aria/master/dpub-aam/dpub-aam.html
2309         { &quot;doc-abstract&quot;, AccessibilityRole::ApplicationTextGroup },
2310         { &quot;doc-acknowledgments&quot;, AccessibilityRole::LandmarkDocRegion },
2311         { &quot;doc-afterword&quot;, AccessibilityRole::LandmarkDocRegion },
2312         { &quot;doc-appendix&quot;, AccessibilityRole::LandmarkDocRegion },
2313         { &quot;doc-backlink&quot;, AccessibilityRole::WebCoreLink },
2314         { &quot;doc-biblioentry&quot;, AccessibilityRole::ListItem },
2315         { &quot;doc-bibliography&quot;, AccessibilityRole::LandmarkDocRegion },
2316         { &quot;doc-biblioref&quot;, AccessibilityRole::WebCoreLink },
2317         { &quot;doc-chapter&quot;, AccessibilityRole::LandmarkDocRegion },
2318         { &quot;doc-colophon&quot;, AccessibilityRole::ApplicationTextGroup },
2319         { &quot;doc-conclusion&quot;, AccessibilityRole::LandmarkDocRegion },
2320         { &quot;doc-cover&quot;, AccessibilityRole::Image },
2321         { &quot;doc-credit&quot;, AccessibilityRole::ApplicationTextGroup },
2322         { &quot;doc-credits&quot;, AccessibilityRole::LandmarkDocRegion },
2323         { &quot;doc-dedication&quot;, AccessibilityRole::ApplicationTextGroup },
2324         { &quot;doc-endnote&quot;, AccessibilityRole::ListItem },
</pre>
<hr />
<pre>
2347         { &quot;doc-toc&quot;, AccessibilityRole::LandmarkNavigation },
2348         { &quot;figure&quot;, AccessibilityRole::Figure },
2349         // The mappings for &#39;graphics-*&#39; roles are defined in this spec: https://w3c.github.io/graphics-aam/
2350         { &quot;graphics-document&quot;, AccessibilityRole::GraphicsDocument },
2351         { &quot;graphics-object&quot;, AccessibilityRole::GraphicsObject },
2352         { &quot;graphics-symbol&quot;, AccessibilityRole::GraphicsSymbol },
2353         { &quot;grid&quot;, AccessibilityRole::Grid },
2354         { &quot;gridcell&quot;, AccessibilityRole::GridCell },
2355         { &quot;table&quot;, AccessibilityRole::Table },
2356         { &quot;cell&quot;, AccessibilityRole::Cell },
2357         { &quot;columnheader&quot;, AccessibilityRole::ColumnHeader },
2358         { &quot;combobox&quot;, AccessibilityRole::ComboBox },
2359         { &quot;definition&quot;, AccessibilityRole::Definition },
2360         { &quot;document&quot;, AccessibilityRole::Document },
2361         { &quot;feed&quot;, AccessibilityRole::Feed },
2362         { &quot;form&quot;, AccessibilityRole::Form },
2363         { &quot;rowheader&quot;, AccessibilityRole::RowHeader },
2364         { &quot;group&quot;, AccessibilityRole::ApplicationGroup },
2365         { &quot;heading&quot;, AccessibilityRole::Heading },
2366         { &quot;img&quot;, AccessibilityRole::Image },

2367         { &quot;link&quot;, AccessibilityRole::WebCoreLink },
2368         { &quot;list&quot;, AccessibilityRole::List },
2369         { &quot;listitem&quot;, AccessibilityRole::ListItem },
2370         { &quot;listbox&quot;, AccessibilityRole::ListBox },
2371         { &quot;log&quot;, AccessibilityRole::ApplicationLog },
2372         { &quot;main&quot;, AccessibilityRole::LandmarkMain },
2373         { &quot;marquee&quot;, AccessibilityRole::ApplicationMarquee },
2374         { &quot;math&quot;, AccessibilityRole::DocumentMath },
2375         { &quot;menu&quot;, AccessibilityRole::Menu },
2376         { &quot;menubar&quot;, AccessibilityRole::MenuBar },
2377         { &quot;menuitem&quot;, AccessibilityRole::MenuItem },
2378         { &quot;menuitemcheckbox&quot;, AccessibilityRole::MenuItemCheckbox },
2379         { &quot;menuitemradio&quot;, AccessibilityRole::MenuItemRadio },

2380         { &quot;none&quot;, AccessibilityRole::Presentational },
2381         { &quot;note&quot;, AccessibilityRole::DocumentNote },
2382         { &quot;navigation&quot;, AccessibilityRole::LandmarkNavigation },
2383         { &quot;option&quot;, AccessibilityRole::ListBoxOption },
2384         { &quot;paragraph&quot;, AccessibilityRole::Paragraph },
2385         { &quot;presentation&quot;, AccessibilityRole::Presentational },
2386         { &quot;progressbar&quot;, AccessibilityRole::ProgressIndicator },
2387         { &quot;radio&quot;, AccessibilityRole::RadioButton },
2388         { &quot;radiogroup&quot;, AccessibilityRole::RadioGroup },
2389         { &quot;region&quot;, AccessibilityRole::LandmarkRegion },
2390         { &quot;row&quot;, AccessibilityRole::Row },
2391         { &quot;rowgroup&quot;, AccessibilityRole::RowGroup },
2392         { &quot;scrollbar&quot;, AccessibilityRole::ScrollBar },
2393         { &quot;search&quot;, AccessibilityRole::LandmarkSearch },
2394         { &quot;searchbox&quot;, AccessibilityRole::SearchField },
2395         { &quot;separator&quot;, AccessibilityRole::Splitter },
2396         { &quot;slider&quot;, AccessibilityRole::Slider },
2397         { &quot;spinbutton&quot;, AccessibilityRole::SpinButton },
2398         { &quot;status&quot;, AccessibilityRole::ApplicationStatus },


2399         { &quot;switch&quot;, AccessibilityRole::Switch },
2400         { &quot;tab&quot;, AccessibilityRole::Tab },
2401         { &quot;tablist&quot;, AccessibilityRole::TabList },
2402         { &quot;tabpanel&quot;, AccessibilityRole::TabPanel },
2403         { &quot;text&quot;, AccessibilityRole::StaticText },
2404         { &quot;textbox&quot;, AccessibilityRole::TextArea },
2405         { &quot;term&quot;, AccessibilityRole::Term },

2406         { &quot;timer&quot;, AccessibilityRole::ApplicationTimer },
2407         { &quot;toolbar&quot;, AccessibilityRole::Toolbar },
2408         { &quot;tooltip&quot;, AccessibilityRole::UserInterfaceTooltip },
2409         { &quot;tree&quot;, AccessibilityRole::Tree },
2410         { &quot;treegrid&quot;, AccessibilityRole::TreeGrid },
2411         { &quot;treeitem&quot;, AccessibilityRole::TreeItem }
2412     };
2413 
2414     gAriaRoleMap = new ARIARoleMap;
2415     gAriaReverseRoleMap = new ARIAReverseRoleMap;
2416     size_t roleLength = WTF_ARRAY_LENGTH(roles);
2417     for (size_t i = 0; i &lt; roleLength; ++i) {
2418         gAriaRoleMap-&gt;set(roles[i].ariaRole, roles[i].webcoreRole);
2419         gAriaReverseRoleMap-&gt;set(static_cast&lt;int&gt;(roles[i].webcoreRole), roles[i].ariaRole);
2420     }
2421 }
2422 
2423 static ARIARoleMap&amp; ariaRoleMap()
2424 {
2425     initializeRoleMap();
2426     return *gAriaRoleMap;
2427 }
2428 
2429 static ARIAReverseRoleMap&amp; reverseAriaRoleMap()
2430 {
2431     initializeRoleMap();
2432     return *gAriaReverseRoleMap;
2433 }
2434 
2435 AccessibilityRole AccessibilityObject::ariaRoleToWebCoreRole(const String&amp; value)
2436 {
<span class="line-modified">2437     ASSERT(!value.isEmpty());</span>


2438     for (auto roleName : StringView(value).split(&#39; &#39;)) {
2439         AccessibilityRole role = ariaRoleMap().get&lt;ASCIICaseInsensitiveStringViewHashTranslator&gt;(roleName);
2440         if (static_cast&lt;int&gt;(role))
2441             return role;
2442     }
2443     return AccessibilityRole::Unknown;
2444 }
2445 
2446 String AccessibilityObject::computedRoleString() const
2447 {
2448     // FIXME: Need a few special cases that aren&#39;t in the RoleMap: option, etc. http://webkit.org/b/128296
2449     AccessibilityRole role = roleValue();
2450 



2451     // We do not compute a role string for generic block elements with user-agent assigned roles.
2452     if (role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup)
2453         return &quot;&quot;;
2454 
2455     // We do compute a role string for block elements with author-provided roles.
2456     if (role == AccessibilityRole::ApplicationTextGroup
2457         || role == AccessibilityRole::Footnote
2458         || role == AccessibilityRole::GraphicsObject)
2459         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::ApplicationGroup));
2460 
2461     if (role == AccessibilityRole::GraphicsDocument)
2462         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Document));
2463 
2464     if (role == AccessibilityRole::GraphicsSymbol)
2465         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Image));
2466 
2467     if (role == AccessibilityRole::HorizontalRule)
2468         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Splitter));
2469 
2470     if (role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton)
</pre>
<hr />
<pre>
2514             // Search within for immediate descendants that are static text. If we find more than one
2515             // then this is an event delegator actionElement and we should expose the press action.
2516             Vector&lt;AccessibilitySearchKey&gt; keys({ AccessibilitySearchKey::StaticText, AccessibilitySearchKey::Control, AccessibilitySearchKey::Graphic, AccessibilitySearchKey::Heading, AccessibilitySearchKey::Link });
2517             AccessibilitySearchCriteria criteria(axObj, AccessibilitySearchDirection::Next, emptyString(), 2, false, false);
2518             criteria.searchKeys = keys;
2519             axObj-&gt;findMatchingObjects(&amp;criteria, results);
2520             if (results.size() &gt; 1)
2521                 return false;
2522         }
2523     }
2524 
2525     // [Bug: 133613] Heuristic: If the action element is presentational, we shouldn&#39;t expose press as a supported action.
2526     return !nodeHasPresentationRole(actionElement);
2527 }
2528 
2529 bool AccessibilityObject::supportsDatetimeAttribute() const
2530 {
2531     return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
2532 }
2533 
<span class="line-modified">2534 const AtomicString&amp; AccessibilityObject::datetimeAttributeValue() const</span>
2535 {
2536     return getAttribute(datetimeAttr);
2537 }
2538 
<span class="line-modified">2539 const AtomicString&amp; AccessibilityObject::linkRelValue() const</span>
2540 {
2541     return getAttribute(relAttr);
2542 }
2543 
2544 const String AccessibilityObject::keyShortcutsValue() const
2545 {
2546     return getAttribute(aria_keyshortcutsAttr);
2547 }
2548 
2549 Element* AccessibilityObject::element() const
2550 {
2551     Node* node = this-&gt;node();
2552     if (is&lt;Element&gt;(node))
2553         return downcast&lt;Element&gt;(node);
2554     return nullptr;
2555 }
2556 
2557 bool AccessibilityObject::isValueAutofillAvailable() const
2558 {
2559     if (!isNativeTextControl())
</pre>
<hr />
<pre>
2571     if (!isValueAutofillAvailable())
2572         return AutoFillButtonType::None;
2573 
2574     return downcast&lt;HTMLInputElement&gt;(*this-&gt;node()).autoFillButtonType();
2575 }
2576 
2577 bool AccessibilityObject::isValueAutofilled() const
2578 {
2579     if (!isNativeTextControl())
2580         return false;
2581 
2582     Node* node = this-&gt;node();
2583     if (!is&lt;HTMLInputElement&gt;(node))
2584         return false;
2585 
2586     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFilled();
2587 }
2588 
2589 const String AccessibilityObject::placeholderValue() const
2590 {
<span class="line-modified">2591     const AtomicString&amp; placeholder = getAttribute(placeholderAttr);</span>
2592     if (!placeholder.isEmpty())
2593         return placeholder;
2594 
<span class="line-modified">2595     const AtomicString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);</span>
2596     if (!ariaPlaceholder.isEmpty())
2597         return ariaPlaceholder;
2598 
2599     return nullAtom();
2600 }
2601 
2602 bool AccessibilityObject::isInsideLiveRegion(bool excludeIfOff) const
2603 {
2604     return liveRegionAncestor(excludeIfOff);
2605 }
2606 
2607 AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
2608 {
2609     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {
2610         return object.supportsLiveRegion(excludeIfOff);
2611     }));
2612 }
2613 
2614 bool AccessibilityObject::supportsARIAAttributes() const
2615 {
</pre>
<hr />
<pre>
2617     return supportsLiveRegion()
2618         || supportsARIADragging()
2619         || supportsARIADropping()
2620         || supportsARIAOwns()
2621         || hasAttribute(aria_atomicAttr)
2622         || hasAttribute(aria_busyAttr)
2623         || hasAttribute(aria_controlsAttr)
2624         || hasAttribute(aria_currentAttr)
2625         || hasAttribute(aria_describedbyAttr)
2626         || hasAttribute(aria_detailsAttr)
2627         || hasAttribute(aria_disabledAttr)
2628         || hasAttribute(aria_errormessageAttr)
2629         || hasAttribute(aria_flowtoAttr)
2630         || hasAttribute(aria_haspopupAttr)
2631         || hasAttribute(aria_invalidAttr)
2632         || hasAttribute(aria_labelAttr)
2633         || hasAttribute(aria_labelledbyAttr)
2634         || hasAttribute(aria_relevantAttr);
2635 }
2636 
<span class="line-modified">2637 bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomicString&amp; liveRegionStatus)</span>
2638 {
2639     return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
2640 }
2641 
2642 bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
2643 {
<span class="line-modified">2644     const AtomicString&amp; liveRegionStatusValue = liveRegionStatus();</span>
2645     return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
2646 }
2647 
<span class="line-modified">2648 AccessibilityObject* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2649 {
2650     // Send the hit test back into the sub-frame if necessary.
2651     if (isAttachment()) {
2652         Widget* widget = widgetForAttachmentView();
2653         // Normalize the point for the widget&#39;s bounds.
2654         if (widget &amp;&amp; widget-&gt;isFrameView()) {
2655             if (AXObjectCache* cache = axObjectCache())
2656                 return cache-&gt;getOrCreate(widget)-&gt;accessibilityHitTest(IntPoint(point - widget-&gt;frameRect().location()));
2657         }
2658     }
2659 
2660     // Check if there are any mock elements that need to be handled.
2661     for (const auto&amp; child : m_children) {
2662         if (child-&gt;isMockObject() &amp;&amp; child-&gt;elementRect().contains(point))
2663             return child-&gt;elementAccessibilityHitTest(point);
2664     }
2665 
2666     return const_cast&lt;AccessibilityObject*&gt;(this);
2667 }
2668 
2669 AXObjectCache* AccessibilityObject::axObjectCache() const
2670 {
2671     auto* document = this-&gt;document();
2672     return document ? document-&gt;axObjectCache() : nullptr;
2673 }
2674 
<span class="line-modified">2675 AccessibilityObject* AccessibilityObject::focusedUIElement() const</span>
2676 {
2677     auto* page = this-&gt;page();
2678     return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;
2679 }
2680 
2681 AccessibilitySortDirection AccessibilityObject::sortDirection() const
2682 {
2683     AccessibilityRole role = roleValue();
2684     if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
2685         return AccessibilitySortDirection::Invalid;
2686 
<span class="line-modified">2687     const AtomicString&amp; sortAttribute = getAttribute(aria_sortAttr);</span>
2688     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
2689         return AccessibilitySortDirection::Ascending;
2690     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
2691         return AccessibilitySortDirection::Descending;
2692     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
2693         return AccessibilitySortDirection::Other;
2694 
2695     return AccessibilitySortDirection::None;
2696 }
2697 
2698 bool AccessibilityObject::supportsRangeValue() const
2699 {
2700     return isProgressIndicator()
2701         || isSlider()
2702         || isScrollbar()
2703         || isSpinButton()
2704         || (isSplitter() &amp;&amp; canSetFocusAttribute())
2705         || isAttachmentElement();
2706 }
2707 
2708 bool AccessibilityObject::supportsHasPopup() const
2709 {
2710     return hasAttribute(aria_haspopupAttr) || isComboBox();
2711 }
2712 
<span class="line-modified">2713 String AccessibilityObject::hasPopupValue() const</span>
2714 {
<span class="line-modified">2715     const AtomicString&amp; hasPopup = getAttribute(aria_haspopupAttr);</span>
<span class="line-modified">2716     if (equalLettersIgnoringASCIICase(hasPopup, &quot;true&quot;)</span>
<span class="line-modified">2717         || equalLettersIgnoringASCIICase(hasPopup, &quot;dialog&quot;)</span>
<span class="line-modified">2718         || equalLettersIgnoringASCIICase(hasPopup, &quot;grid&quot;)</span>
<span class="line-modified">2719         || equalLettersIgnoringASCIICase(hasPopup, &quot;listbox&quot;)</span>
<span class="line-modified">2720         || equalLettersIgnoringASCIICase(hasPopup, &quot;menu&quot;)</span>
<span class="line-modified">2721         || equalLettersIgnoringASCIICase(hasPopup, &quot;tree&quot;))</span>






2722         return hasPopup;
2723 
<span class="line-modified">2724     // In ARIA 1.1, the implicit value for combobox became &quot;listbox.&quot;</span>
<span class="line-modified">2725     if (isComboBox() &amp;&amp; hasPopup.isEmpty())</span>
<span class="line-modified">2726         return &quot;listbox&quot;;</span>
2727 
2728     // The spec states that &quot;User agents must treat any value of aria-haspopup that is not
2729     // included in the list of allowed values, including an empty string, as if the value
2730     // false had been provided.&quot;
2731     return &quot;false&quot;;
2732 }
2733 


















2734 bool AccessibilityObject::supportsSetSize() const
2735 {
2736     return hasAttribute(aria_setsizeAttr);
2737 }
2738 
2739 bool AccessibilityObject::supportsPosInSet() const
2740 {
2741     return hasAttribute(aria_posinsetAttr);
2742 }
2743 
2744 int AccessibilityObject::setSize() const
2745 {
2746     return getAttribute(aria_setsizeAttr).toInt();
2747 }
2748 
2749 int AccessibilityObject::posInSet() const
2750 {
2751     return getAttribute(aria_posinsetAttr).toInt();
2752 }
2753 
<span class="line-modified">2754 const AtomicString&amp; AccessibilityObject::identifierAttribute() const</span>
2755 {
2756     return getAttribute(idAttr);
2757 }
2758 
2759 void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
2760 {
2761     Node* node = this-&gt;node();
2762     if (!is&lt;Element&gt;(node))
2763         return;
2764 
2765     Element* element = downcast&lt;Element&gt;(node);
2766     DOMTokenList&amp; list = element-&gt;classList();
2767     unsigned length = list.length();
2768     for (unsigned k = 0; k &lt; length; k++)
2769         classList.append(list.item(k).string());
2770 }
2771 
2772 bool AccessibilityObject::supportsPressed() const
2773 {
<span class="line-modified">2774     const AtomicString&amp; expanded = getAttribute(aria_pressedAttr);</span>
2775     return equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;);
2776 }
2777 
2778 bool AccessibilityObject::supportsExpanded() const
2779 {
2780     // Undefined values should not result in this attribute being exposed to ATs according to ARIA.
<span class="line-modified">2781     const AtomicString&amp; expanded = getAttribute(aria_expandedAttr);</span>
2782     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
2783         return true;
2784     switch (roleValue()) {
2785     case AccessibilityRole::ComboBox:
2786     case AccessibilityRole::DisclosureTriangle:
2787     case AccessibilityRole::Details:
2788         return true;
2789     default:
2790         return false;
2791     }
2792 }
2793 
2794 bool AccessibilityObject::isExpanded() const
2795 {
2796     if (equalLettersIgnoringASCIICase(getAttribute(aria_expandedAttr), &quot;true&quot;))
2797         return true;
2798 
2799     if (is&lt;HTMLDetailsElement&gt;(node()))
2800         return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
2801 
</pre>
<hr />
<pre>
2814 {
2815     switch (roleValue()) {
2816     case AccessibilityRole::CheckBox:
2817     case AccessibilityRole::MenuItemCheckbox:
2818     case AccessibilityRole::MenuItemRadio:
2819     case AccessibilityRole::RadioButton:
2820     case AccessibilityRole::Switch:
2821         return true;
2822     default:
2823         return false;
2824     }
2825 }
2826 
2827 AccessibilityButtonState AccessibilityObject::checkboxOrRadioValue() const
2828 {
2829     // If this is a real checkbox or radio button, AccessibilityRenderObject will handle.
2830     // If it&#39;s an ARIA checkbox, radio, or switch the aria-checked attribute should be used.
2831     // If it&#39;s a toggle button, the aria-pressed attribute is consulted.
2832 
2833     if (isToggleButton()) {
<span class="line-modified">2834         const AtomicString&amp; ariaPressed = getAttribute(aria_pressedAttr);</span>
2835         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;true&quot;))
2836             return AccessibilityButtonState::On;
2837         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;mixed&quot;))
2838             return AccessibilityButtonState::Mixed;
2839         return AccessibilityButtonState::Off;
2840     }
2841 
<span class="line-modified">2842     const AtomicString&amp; result = getAttribute(aria_checkedAttr);</span>
2843     if (equalLettersIgnoringASCIICase(result, &quot;true&quot;))
2844         return AccessibilityButtonState::On;
2845     if (equalLettersIgnoringASCIICase(result, &quot;mixed&quot;)) {
2846         // ARIA says that radio, menuitemradio, and switch elements must NOT expose button state mixed.
2847         AccessibilityRole ariaRole = ariaRoleAttribute();
2848         if (ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::MenuItemRadio || ariaRole == AccessibilityRole::Switch)
2849             return AccessibilityButtonState::Off;
2850         return AccessibilityButtonState::Mixed;
2851     }
2852 
2853     if (isIndeterminate())
2854         return AccessibilityButtonState::Mixed;
2855 
2856     return AccessibilityButtonState::Off;
2857 }
2858 
2859 // This is a 1-dimensional scroll offset helper function that&#39;s applied
2860 // separately in the horizontal and vertical directions, because the
2861 // logic is the same. The goal is to compute the best scroll offset
2862 // in order to make an object visible within a viewport.
</pre>
<hr />
<pre>
2965     size_t levels = objects.size() - 1;
2966 
2967     for (size_t i = levels; i &gt;= 1; i--) {
2968         const AccessibilityObject* outer = objects[i];
2969         const AccessibilityObject* inner = objects[i - 1];
2970         // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
2971         const IntRect outerRect = i &lt; levels ? snappedIntRect(outer-&gt;boundingBoxRect()) : outer-&gt;getScrollableAreaIfScrollable()-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
2972         const IntRect innerRect = snappedIntRect(inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect());
2973 
2974         if (!outerRect.intersects(innerRect)) {
2975             isOnscreen = false;
2976             break;
2977         }
2978     }
2979 
2980     return isOnscreen;
2981 }
2982 
2983 void AccessibilityObject::scrollToMakeVisible() const
2984 {
<span class="line-modified">2985     if (dispatchAccessibilityEventWithType(AccessibilityEventType::ScrollIntoView))</span>
<span class="line-modified">2986         return;</span>
2987 


2988     if (isScrollView() &amp;&amp; parentObject())
2989         parentObject()-&gt;scrollToMakeVisible();
2990 
2991     if (auto* renderer = this-&gt;renderer())
<span class="line-modified">2992         renderer-&gt;scrollRectToVisible(boundingBoxRect(), false, { SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::Yes });</span>
2993 }
2994 
2995 void AccessibilityObject::scrollToMakeVisibleWithSubFocus(const IntRect&amp; subfocus) const
2996 {
2997     // Search up the parent chain until we find the first one that&#39;s scrollable.
2998     AccessibilityObject* scrollParent = parentObject();
2999     ScrollableArea* scrollableArea;
3000     for (scrollableArea = nullptr;
3001          scrollParent &amp;&amp; !(scrollableArea = scrollParent-&gt;getScrollableAreaIfScrollable());
3002          scrollParent = scrollParent-&gt;parentObject()) { }
3003     if (!scrollableArea)
3004         return;
3005 
3006     LayoutRect objectRect = boundingBoxRect();
3007     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3008     // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
3009     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3010 
3011     if (!scrollParent-&gt;isScrollView()) {
3012         objectRect.moveBy(scrollPosition);
</pre>
<hr />
<pre>
3210 
3211 void AccessibilityObject::notifyIfIgnoredValueChanged()
3212 {
3213     bool isIgnored = accessibilityIsIgnored();
3214     if (lastKnownIsIgnoredValue() != isIgnored) {
3215         if (AXObjectCache* cache = axObjectCache())
3216             cache-&gt;childrenChanged(parentObject());
3217         setLastKnownIsIgnoredValue(isIgnored);
3218     }
3219 }
3220 
3221 bool AccessibilityObject::pressedIsPresent() const
3222 {
3223     return !getAttribute(aria_pressedAttr).isEmpty();
3224 }
3225 
3226 TextIteratorBehavior AccessibilityObject::textIteratorBehaviorForTextRange() const
3227 {
3228     TextIteratorBehavior behavior = TextIteratorIgnoresStyleVisibility;
3229 
<span class="line-modified">3230 #if PLATFORM(GTK)</span>
3231     // We need to emit replaced elements for GTK, and present
3232     // them with the &#39;object replacement character&#39; (0xFFFC).
3233     behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsObjectReplacementCharacters);
3234 #endif
3235 
3236     return behavior;
3237 }
3238 
3239 AccessibilityRole AccessibilityObject::buttonRoleType() const
3240 {
3241     // If aria-pressed is present, then it should be exposed as a toggle button.
3242     // http://www.w3.org/TR/wai-aria/states_and_properties#aria-pressed
3243     if (pressedIsPresent())
3244         return AccessibilityRole::ToggleButton;
3245     if (hasPopup())
3246         return AccessibilityRole::PopUpButton;
3247     // We don&#39;t contemplate AccessibilityRole::RadioButton, as it depends on the input
3248     // type.
3249 
3250     return AccessibilityRole::Button;
</pre>
<hr />
<pre>
3332         }
3333     }
3334 
3335     bool result = computeAccessibilityIsIgnored();
3336 
3337     // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
3338     if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
3339         attributeCache-&gt;setIgnored(axObjectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);
3340 
3341     return result;
3342 }
3343 
3344 void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
3345 {
3346     Node* node = this-&gt;node();
3347     if (!node || !node-&gt;isElementNode())
3348         return;
3349 
3350     TreeScope&amp; treeScope = node-&gt;treeScope();
3351 
<span class="line-modified">3352     const AtomicString&amp; idList = getAttribute(attribute);</span>
3353     if (idList.isEmpty())
3354         return;
3355 
3356     auto spaceSplitString = SpaceSplitString(idList, false);
3357     size_t length = spaceSplitString.size();
3358     for (size_t i = 0; i &lt; length; ++i) {
3359         if (auto* idElement = treeScope.getElementById(spaceSplitString[i]))
3360             elements.append(idElement);
3361     }
3362 }
3363 
3364 #if PLATFORM(COCOA)
3365 bool AccessibilityObject::preventKeyboardDOMEventDispatch() const
3366 {
3367     Frame* frame = this-&gt;frame();
3368     return frame &amp;&amp; frame-&gt;settings().preventKeyboardDOMEventDispatch();
3369 }
3370 
3371 void AccessibilityObject::setPreventKeyboardDOMEventDispatch(bool on)
3372 {
</pre>
<hr />
<pre>
3412 AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
3413 {
3414     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
3415         return object.isRadioGroup();
3416     }));
3417 }
3418 
3419 bool AccessibilityObject::isStyleFormatGroup() const
3420 {
3421     Node* node = this-&gt;node();
3422     if (!node)
3423         return false;
3424 
3425     return node-&gt;hasTagName(kbdTag) || node-&gt;hasTagName(codeTag)
3426     || node-&gt;hasTagName(preTag) || node-&gt;hasTagName(sampTag)
3427     || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
3428     || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
3429     || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
3430 }
3431 
<span class="line-modified">3432 bool AccessibilityObject::isSubscriptStyleGroup() const</span>
<span class="line-removed">3433 {</span>
<span class="line-removed">3434     Node* node = this-&gt;node();</span>
<span class="line-removed">3435     return node &amp;&amp; node-&gt;hasTagName(subTag);</span>
<span class="line-removed">3436 }</span>
<span class="line-removed">3437 </span>
<span class="line-removed">3438 bool AccessibilityObject::isSuperscriptStyleGroup() const</span>
3439 {
3440     Node* node = this-&gt;node();
<span class="line-modified">3441     return node &amp;&amp; node-&gt;hasTagName(supTag);</span>
3442 }
3443 
<span class="line-modified">3444 bool AccessibilityObject::isFigureElement() const</span>
3445 {
<span class="line-modified">3446     Node* node = this-&gt;node();</span>
<span class="line-modified">3447     return node &amp;&amp; node-&gt;hasTagName(figureTag);</span>

3448 }
3449 
3450 bool AccessibilityObject::isOutput() const
3451 {
3452     Node* node = this-&gt;node();
3453     return node &amp;&amp; node-&gt;hasTagName(outputTag);
3454 }
3455 
3456 bool AccessibilityObject::isContainedByPasswordField() const
3457 {
3458     Node* node = this-&gt;node();
3459     if (!node)
3460         return false;
3461 
3462     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
3463         return false;
3464 
3465     Element* element = node-&gt;shadowHost();
3466     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
3467 }
</pre>
<hr />
<pre>
3481     Vector&lt;Element*&gt; elements;
3482     elementsFromAttribute(elements, attributeName);
3483     AXObjectCache* cache = axObjectCache();
3484     for (const auto&amp; element : elements) {
3485         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(element))
3486             children.append(axObject);
3487     }
3488 }
3489 
3490 void AccessibilityObject::ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp; elements, const QualifiedName&amp; attribute) const
3491 {
3492     auto id = identifierAttribute();
3493     if (id.isEmpty())
3494         return;
3495 
3496     AXObjectCache* cache = axObjectCache();
3497     if (!cache)
3498         return;
3499 
3500     for (auto&amp; element : descendantsOfType&lt;Element&gt;(node()-&gt;treeScope().rootNode())) {
<span class="line-modified">3501         const AtomicString&amp; idList = element.attributeWithoutSynchronization(attribute);</span>
3502         if (!SpaceSplitString(idList, false).contains(id))
3503             continue;
3504 
3505         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(&amp;element))
3506             elements.append(axObject);
3507     }
3508 }
3509 
3510 bool AccessibilityObject::isActiveDescendantOfFocusedContainer() const
3511 {
3512     AccessibilityChildrenVector containers;
3513     ariaActiveDescendantReferencingElements(containers);
3514     for (auto&amp; container : containers) {
3515         if (container-&gt;isFocused())
3516             return true;
3517     }
3518 
3519     return false;
3520 }
3521 
</pre>
</td>
<td>
<hr />
<pre>
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityRenderObject.h&quot;
  34 #include &quot;AccessibilityScrollView.h&quot;
  35 #include &quot;AccessibilityTable.h&quot;
<span class="line-modified">  36 #include &quot;Chrome.h&quot;</span>
<span class="line-added">  37 #include &quot;ChromeClient.h&quot;</span>
  38 #include &quot;DOMTokenList.h&quot;
  39 #include &quot;Editing.h&quot;
  40 #include &quot;Editor.h&quot;
  41 #include &quot;ElementIterator.h&quot;
  42 #include &quot;Event.h&quot;
  43 #include &quot;EventDispatcher.h&quot;
  44 #include &quot;EventHandler.h&quot;
<span class="line-added">  45 #include &quot;EventNames.h&quot;</span>
  46 #include &quot;FloatRect.h&quot;
  47 #include &quot;FocusController.h&quot;
  48 #include &quot;Frame.h&quot;
  49 #include &quot;FrameLoader.h&quot;
  50 #include &quot;FrameSelection.h&quot;
<span class="line-added">  51 #include &quot;HTMLDataListElement.h&quot;</span>
  52 #include &quot;HTMLDetailsElement.h&quot;
  53 #include &quot;HTMLFormControlElement.h&quot;
  54 #include &quot;HTMLInputElement.h&quot;
  55 #include &quot;HTMLMediaElement.h&quot;
  56 #include &quot;HTMLNames.h&quot;
  57 #include &quot;HTMLParserIdioms.h&quot;
<span class="line-added">  58 #include &quot;HTMLTextAreaElement.h&quot;</span>
  59 #include &quot;HitTestResult.h&quot;
  60 #include &quot;LocalizedStrings.h&quot;
  61 #include &quot;MathMLNames.h&quot;
  62 #include &quot;NodeList.h&quot;
  63 #include &quot;NodeTraversal.h&quot;
  64 #include &quot;Page.h&quot;
  65 #include &quot;RenderImage.h&quot;
  66 #include &quot;RenderLayer.h&quot;
  67 #include &quot;RenderListItem.h&quot;
  68 #include &quot;RenderListMarker.h&quot;
  69 #include &quot;RenderMenuList.h&quot;
  70 #include &quot;RenderText.h&quot;
  71 #include &quot;RenderTextControl.h&quot;
  72 #include &quot;RenderTheme.h&quot;
  73 #include &quot;RenderView.h&quot;
  74 #include &quot;RenderWidget.h&quot;
  75 #include &quot;RenderedPosition.h&quot;
  76 #include &quot;RuntimeEnabledFeatures.h&quot;
  77 #include &quot;Settings.h&quot;
  78 #include &quot;TextCheckerClient.h&quot;
</pre>
<hr />
<pre>
  89 
  90 namespace WebCore {
  91 
  92 using namespace HTMLNames;
  93 
  94 AccessibilityObject::~AccessibilityObject()
  95 {
  96     ASSERT(isDetached());
  97 }
  98 
  99 void AccessibilityObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
 100 {
 101     // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
 102     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu &amp;&amp; cache)
 103         cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);
 104 
 105     // Clear any children and call detachFromParent on them so that
 106     // no children are left with dangling pointers to their parent.
 107     clearChildren();
 108 
<span class="line-modified"> 109 #if ENABLE(ACCESSIBILITY)</span>
 110     setWrapper(nullptr);
 111 #endif
 112 }
 113 
 114 bool AccessibilityObject::isDetached() const
 115 {
<span class="line-modified"> 116 #if ENABLE(ACCESSIBILITY)</span>
 117     return !wrapper();
 118 #else
 119     return true;
 120 #endif
 121 }
 122 
 123 bool AccessibilityObject::isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria, size_t index)
 124 {
 125     switch (criteria-&gt;searchKeys[index]) {
 126     // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.
 127     case AccessibilitySearchKey::AnyType:
 128         return true;
 129 
 130     case AccessibilitySearchKey::Article:
 131         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;
 132 
 133     case AccessibilitySearchKey::BlockquoteSameLevel:
 134         return criteria-&gt;startObject
 135             &amp;&amp; axObject-&gt;isBlockquote()
 136             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria-&gt;startObject-&gt;blockquoteLevel();
</pre>
<hr />
<pre>
 180     case AccessibilitySearchKey::HeadingLevel4:
 181         return axObject-&gt;headingLevel() == 4;
 182 
 183     case AccessibilitySearchKey::HeadingLevel5:
 184         return axObject-&gt;headingLevel() == 5;
 185 
 186     case AccessibilitySearchKey::HeadingLevel6:
 187         return axObject-&gt;headingLevel() == 6;
 188 
 189     case AccessibilitySearchKey::HeadingSameLevel:
 190         return criteria-&gt;startObject
 191             &amp;&amp; axObject-&gt;isHeading()
 192             &amp;&amp; axObject-&gt;headingLevel() == criteria-&gt;startObject-&gt;headingLevel();
 193 
 194     case AccessibilitySearchKey::Heading:
 195         return axObject-&gt;isHeading();
 196 
 197     case AccessibilitySearchKey::Highlighted:
 198         return axObject-&gt;hasHighlighting();
 199 
<span class="line-added"> 200     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-added"> 201         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-added"> 202 </span>
 203     case AccessibilitySearchKey::ItalicFont:
 204         return axObject-&gt;hasItalicFont();
 205 
 206     case AccessibilitySearchKey::Landmark:
 207         return axObject-&gt;isLandmark();
 208 
 209     case AccessibilitySearchKey::Link: {
 210         bool isLink = axObject-&gt;isLink();
 211 #if PLATFORM(IOS_FAMILY)
 212         if (!isLink)
 213             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);
 214 #endif
 215         return isLink;
 216     }
 217 
 218     case AccessibilitySearchKey::List:
 219         return axObject-&gt;isList();
 220 
 221     case AccessibilitySearchKey::LiveRegion:
 222         return axObject-&gt;supportsLiveRegion();
</pre>
<hr />
<pre>
 322     case AccessibilityRole::DocumentArticle:
 323     case AccessibilityRole::DocumentMath:
 324     case AccessibilityRole::DocumentNote:
 325     case AccessibilityRole::LandmarkRegion:
 326     case AccessibilityRole::LandmarkDocRegion:
 327     case AccessibilityRole::Form:
 328     case AccessibilityRole::Grid:
 329     case AccessibilityRole::Group:
 330     case AccessibilityRole::Image:
 331     case AccessibilityRole::List:
 332     case AccessibilityRole::ListBox:
 333     case AccessibilityRole::LandmarkBanner:
 334     case AccessibilityRole::LandmarkComplementary:
 335     case AccessibilityRole::LandmarkContentInfo:
 336     case AccessibilityRole::LandmarkNavigation:
 337     case AccessibilityRole::LandmarkMain:
 338     case AccessibilityRole::LandmarkSearch:
 339     case AccessibilityRole::Menu:
 340     case AccessibilityRole::MenuBar:
 341     case AccessibilityRole::ProgressIndicator:
<span class="line-added"> 342     case AccessibilityRole::Meter:</span>
 343     case AccessibilityRole::RadioGroup:
 344     case AccessibilityRole::ScrollBar:
 345     case AccessibilityRole::Slider:
 346     case AccessibilityRole::SpinButton:
 347     case AccessibilityRole::Splitter:
 348     case AccessibilityRole::Table:
 349     case AccessibilityRole::TabList:
 350     case AccessibilityRole::TabPanel:
 351     case AccessibilityRole::TextArea:
 352     case AccessibilityRole::TextField:
 353     case AccessibilityRole::Toolbar:
 354     case AccessibilityRole::TreeGrid:
 355     case AccessibilityRole::Tree:
 356     case AccessibilityRole::WebApplication:
 357         return false;
 358     default:
 359         break;
 360     }
 361 
 362     // Now check for generically derived elements now that we know the element does not match a specific ARIA role.
</pre>
<hr />
<pre>
 397     case AccessibilityRole::TextArea:
 398     case AccessibilityRole::TextField:
 399         return true;
 400     default:
 401         return false;
 402     }
 403 }
 404 
 405 bool AccessibilityObject::isARIATextControl() const
 406 {
 407     return ariaRoleAttribute() == AccessibilityRole::TextArea || ariaRoleAttribute() == AccessibilityRole::TextField || ariaRoleAttribute() == AccessibilityRole::SearchField;
 408 }
 409 
 410 bool AccessibilityObject::isNonNativeTextControl() const
 411 {
 412     return (isARIATextControl() || hasContentEditableAttributeSet()) &amp;&amp; !isNativeTextControl();
 413 }
 414 
 415 bool AccessibilityObject::isLandmark() const
 416 {
<span class="line-modified"> 417     switch (roleValue()) {</span>
<span class="line-modified"> 418     case AccessibilityRole::LandmarkBanner:</span>
<span class="line-modified"> 419     case AccessibilityRole::LandmarkComplementary:</span>
<span class="line-modified"> 420     case AccessibilityRole::LandmarkContentInfo:</span>
<span class="line-modified"> 421     case AccessibilityRole::LandmarkDocRegion:</span>
<span class="line-modified"> 422     case AccessibilityRole::LandmarkMain:</span>
<span class="line-modified"> 423     case AccessibilityRole::LandmarkNavigation:</span>
<span class="line-modified"> 424     case AccessibilityRole::LandmarkRegion:</span>
<span class="line-modified"> 425     case AccessibilityRole::LandmarkSearch:</span>
<span class="line-modified"> 426         return true;</span>
<span class="line-added"> 427     default:</span>
<span class="line-added"> 428         return false;</span>
<span class="line-added"> 429     }</span>
 430 }
 431 
 432 bool AccessibilityObject::hasMisspelling() const
 433 {
 434     if (!node())
 435         return false;
 436 
 437     Frame* frame = node()-&gt;document().frame();
 438     if (!frame)
 439         return false;
 440 
 441     Editor&amp; editor = frame-&gt;editor();
 442 
 443     TextCheckerClient* textChecker = editor.textChecker();
 444     if (!textChecker)
 445         return false;
 446 
 447     bool isMisspelled = false;
 448 
 449     if (unifiedTextCheckerEnabled(frame)) {
</pre>
<hr />
<pre>
 476 
 477 AccessibilityObject* AccessibilityObject::parentObjectUnignored() const
 478 {
 479     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
 480         return !object.accessibilityIsIgnored();
 481     }));
 482 }
 483 
 484 AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
 485 {
 486     AccessibilityObject* previous;
 487     ASSERT(limit &gt;= 0);
 488     for (previous = previousSibling(); previous &amp;&amp; previous-&gt;accessibilityIsIgnored(); previous = previous-&gt;previousSibling()) {
 489         limit--;
 490         if (limit &lt;= 0)
 491             break;
 492     }
 493     return previous;
 494 }
 495 
<span class="line-added"> 496 FloatRect AccessibilityObject::convertFrameToSpace(const FloatRect&amp; frameRect, AccessibilityConversionSpace conversionSpace) const</span>
<span class="line-added"> 497 {</span>
<span class="line-added"> 498     ASSERT(isMainThread());</span>
<span class="line-added"> 499 </span>
<span class="line-added"> 500     // Find the appropriate scroll view to use to convert the contents to the window.</span>
<span class="line-added"> 501     const auto parentAccessibilityScrollView = ancestorAccessibilityScrollView(false /* includeSelf */);</span>
<span class="line-added"> 502     auto* parentScrollView = parentAccessibilityScrollView ? parentAccessibilityScrollView-&gt;scrollView() : nullptr;</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504     auto snappedFrameRect = snappedIntRect(IntRect(frameRect));</span>
<span class="line-added"> 505     if (parentScrollView)</span>
<span class="line-added"> 506         snappedFrameRect = parentScrollView-&gt;contentsToRootView(snappedFrameRect);</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508     if (conversionSpace == AccessibilityConversionSpace::Screen) {</span>
<span class="line-added"> 509         auto page = this-&gt;page();</span>
<span class="line-added"> 510         if (!page)</span>
<span class="line-added"> 511             return snappedFrameRect;</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513         // If we have an empty chrome client (like SVG) then we should use the page</span>
<span class="line-added"> 514         // of the scroll view parent to help us get to the screen rect.</span>
<span class="line-added"> 515         if (parentAccessibilityScrollView &amp;&amp; page-&gt;chrome().client().isEmptyChromeClient())</span>
<span class="line-added"> 516             page = parentAccessibilityScrollView-&gt;page();</span>
<span class="line-added"> 517 </span>
<span class="line-added"> 518         snappedFrameRect = page-&gt;chrome().rootViewToAccessibilityScreen(snappedFrameRect);</span>
<span class="line-added"> 519     }</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521     return snappedFrameRect;</span>
<span class="line-added"> 522 }</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524 FloatRect AccessibilityObject::relativeFrame() const</span>
<span class="line-added"> 525 {</span>
<span class="line-added"> 526     return convertFrameToSpace(elementRect(), AccessibilityConversionSpace::Page);</span>
<span class="line-added"> 527 }</span>
<span class="line-added"> 528 </span>
 529 AccessibilityObject* AccessibilityObject::nextSiblingUnignored(int limit) const
 530 {
 531     AccessibilityObject* next;
 532     ASSERT(limit &gt;= 0);
 533     for (next = nextSibling(); next &amp;&amp; next-&gt;accessibilityIsIgnored(); next = next-&gt;nextSibling()) {
 534         limit--;
 535         if (limit &lt;= 0)
 536             break;
 537     }
 538     return next;
 539 }
 540 
 541 AccessibilityObject* AccessibilityObject::firstAccessibleObjectFromNode(const Node* node)
<span class="line-added"> 542 {</span>
<span class="line-added"> 543     return WebCore::firstAccessibleObjectFromNode(node, [] (const AccessibilityObject&amp; accessible) {</span>
<span class="line-added"> 544         return !accessible.accessibilityIsIgnored();</span>
<span class="line-added"> 545     });</span>
<span class="line-added"> 546 }</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548 AccessibilityObject* firstAccessibleObjectFromNode(const Node* node, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; isAccessible)</span>
 549 {
 550     if (!node)
 551         return nullptr;
 552 
 553     AXObjectCache* cache = node-&gt;document().axObjectCache();
 554     if (!cache)
 555         return nullptr;
 556 
 557     AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
<span class="line-modified"> 558     while (accessibleObject &amp;&amp; !isAccessible(*accessibleObject)) {</span>
 559         node = NodeTraversal::next(*node);
 560 
 561         while (node &amp;&amp; !node-&gt;renderer())
 562             node = NodeTraversal::nextSkippingChildren(*node);
 563 
 564         if (!node)
 565             return nullptr;
 566 
 567         accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 568     }
 569 
 570     return accessibleObject;
 571 }
 572 
 573 bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
 574 {
 575     return AccessibilityObject::matchedParent(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {
 576         return object.roleValue() == role;
 577     }) != nullptr;
 578 }
</pre>
<hr />
<pre>
 747                 break;
 748 
 749             if (!criteria-&gt;immediateDescendantsOnly)
 750                 appendChildrenToArray(searchObject, isForward, 0, searchStack);
 751         }
 752 
 753         if (results.size() &gt;= criteria-&gt;resultsLimit)
 754             break;
 755 
 756         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.
 757         if (!isForward &amp;&amp; startObject != this &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))
 758             break;
 759 
 760         previousObject = startObject;
 761     }
 762 }
 763 
 764 // Returns the range that is fewer positions away from the reference range.
 765 // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
 766 // range is expected to ACTUALLY be before. These are not checked for performance reasons.
<span class="line-modified"> 767 static RefPtr&lt;Range&gt; rangeClosestToRange(RefPtr&lt;Range&gt; const&amp; referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)</span>
 768 {
 769     if (!referenceRange)
 770         return nullptr;
 771 
 772     // The treeScope for shadow nodes may not be the same scope as another element in a document.
 773     // Comparisons may fail in that case, which are expected behavior and should not assert.
 774     if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 775         return nullptr;
<span class="line-modified"> 776     ASSERT(!afterRange || afterRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &gt;= 0);</span>
 777 
 778     if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 779         return nullptr;
<span class="line-modified"> 780     ASSERT(!beforeRange || beforeRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &lt;= 0);</span>
 781 
 782     if (!afterRange &amp;&amp; !beforeRange)
 783         return nullptr;
 784     if (afterRange &amp;&amp; !beforeRange)
 785         return WTFMove(afterRange);
 786     if (!afterRange &amp;&amp; beforeRange)
 787         return WTFMove(beforeRange);
 788 
 789     unsigned positionsToAfterRange = Position::positionCountBetweenPositions(afterRange-&gt;startPosition(), referenceRange-&gt;endPosition());
 790     unsigned positionsToBeforeRange = Position::positionCountBetweenPositions(beforeRange-&gt;endPosition(), referenceRange-&gt;startPosition());
 791 
 792     return positionsToAfterRange &lt; positionsToBeforeRange ? afterRange : beforeRange;
 793 }
 794 
<span class="line-modified"> 795 RefPtr&lt;Range&gt; AccessibilityObject::rangeOfStringClosestToRangeInDirection(Range* referenceRange, AccessibilitySearchDirection searchDirection, Vector&lt;String&gt; const&amp; searchStrings) const</span>
 796 {
 797     Frame* frame = this-&gt;frame();
 798     if (!frame)
 799         return nullptr;
 800 
 801     if (!referenceRange)
 802         return nullptr;
 803 
 804     bool isBackwardSearch = searchDirection == AccessibilitySearchDirection::Previous;
 805     FindOptions findOptions { AtWordStarts, AtWordEnds, CaseInsensitive, StartInSelection };
 806     if (isBackwardSearch)
<span class="line-modified"> 807         findOptions.add(FindOptionFlag::Backwards);</span>
 808 
 809     RefPtr&lt;Range&gt; closestStringRange = nullptr;
 810     for (const auto&amp; searchString : searchStrings) {
 811         if (RefPtr&lt;Range&gt; searchStringRange = frame-&gt;editor().rangeOfString(searchString, referenceRange, findOptions)) {
 812             if (!closestStringRange)
 813                 closestStringRange = searchStringRange;
 814             else {
 815                 // If searching backward, use the trailing range edges to correctly determine which
 816                 // range is closest. Similarly, if searching forward, use the leading range edges.
 817                 Position closestStringPosition = isBackwardSearch ? closestStringRange-&gt;endPosition() : closestStringRange-&gt;startPosition();
 818                 Position searchStringPosition = isBackwardSearch ? searchStringRange-&gt;endPosition() : searchStringRange-&gt;startPosition();
 819 
 820                 int closestPositionOffset = closestStringPosition.computeOffsetInContainerNode();
 821                 int searchPositionOffset = searchStringPosition.computeOffsetInContainerNode();
 822                 Node* closestContainerNode = closestStringPosition.containerNode();
 823                 Node* searchContainerNode = searchStringPosition.containerNode();
 824 
 825                 short result = Range::compareBoundaryPoints(closestContainerNode, closestPositionOffset, searchContainerNode, searchPositionOffset).releaseReturnValue();
 826                 if ((!isBackwardSearch &amp;&amp; result &gt; 0) || (isBackwardSearch &amp;&amp; result &lt; 0))
 827                     closestStringRange = searchStringRange;
</pre>
<hr />
<pre>
 833 
 834 // Returns the range of the entire document if there is no selection.
 835 RefPtr&lt;Range&gt; AccessibilityObject::selectionRange() const
 836 {
 837     Frame* frame = this-&gt;frame();
 838     if (!frame)
 839         return nullptr;
 840 
 841     const VisibleSelection&amp; selection = frame-&gt;selection().selection();
 842     if (!selection.isNone())
 843         return selection.firstRange();
 844 
 845     return Range::create(*frame-&gt;document());
 846 }
 847 
 848 RefPtr&lt;Range&gt; AccessibilityObject::elementRange() const
 849 {
 850     return AXObjectCache::rangeForNodeContents(node());
 851 }
 852 
<span class="line-modified"> 853 RefPtr&lt;Range&gt; AccessibilityObject::findTextRange(Vector&lt;String&gt; const&amp; searchStrings, RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchTextDirection direction) const</span>
 854 {
<span class="line-modified"> 855     RefPtr&lt;Range&gt; found;</span>
<span class="line-modified"> 856     if (direction == AccessibilitySearchTextDirection::Forward)</span>
<span class="line-modified"> 857         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-modified"> 858     else if (direction == AccessibilitySearchTextDirection::Backward)</span>
<span class="line-modified"> 859         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-modified"> 860     else if (direction == AccessibilitySearchTextDirection::Closest) {</span>
<span class="line-modified"> 861         auto foundAfter = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-modified"> 862         auto foundBefore = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-added"> 863         found = rangeClosestToRange(start.get(), WTFMove(foundAfter), WTFMove(foundBefore));</span>
<span class="line-added"> 864     }</span>
 865 
<span class="line-modified"> 866     if (found) {</span>



















 867         // If the search started within a text control, ensure that the result is inside that element.
 868         if (element() &amp;&amp; element()-&gt;isTextField()) {
<span class="line-modified"> 869             if (!found-&gt;startContainer().isDescendantOrShadowDescendantOf(element())</span>
<span class="line-modified"> 870                 || !found-&gt;endContainer().isDescendantOrShadowDescendantOf(element()))</span>
<span class="line-added"> 871                 return nullptr;</span>
 872         }
<span class="line-added"> 873     }</span>
<span class="line-added"> 874     return found;</span>
<span class="line-added"> 875 }</span>
 876 
<span class="line-modified"> 877 Vector&lt;RefPtr&lt;Range&gt;&gt; AccessibilityObject::findTextRanges(AccessibilitySearchTextCriteria const&amp; criteria) const</span>
<span class="line-modified"> 878 {</span>
<span class="line-modified"> 879     Vector&lt;RefPtr&lt;Range&gt;&gt; result;</span>




























 880 
<span class="line-modified"> 881     // Determine start range.</span>
<span class="line-modified"> 882     RefPtr&lt;Range&gt; startRange;</span>
<span class="line-modified"> 883     if (criteria.start == AccessibilitySearchTextStartFrom::Selection)</span>
<span class="line-modified"> 884         startRange = selectionRange();</span>
<span class="line-modified"> 885     else</span>
<span class="line-added"> 886         startRange = elementRange();</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888     if (startRange) {</span>
<span class="line-added"> 889         // Collapse the range to the start unless searching from the end of the doc or searching backwards.</span>
<span class="line-added"> 890         if (criteria.start == AccessibilitySearchTextStartFrom::Begin)</span>
<span class="line-added"> 891             startRange-&gt;collapse(true);</span>
<span class="line-added"> 892         else if (criteria.start == AccessibilitySearchTextStartFrom::End)</span>
<span class="line-added"> 893             startRange-&gt;collapse(false);</span>
<span class="line-added"> 894         else</span>
<span class="line-added"> 895             startRange-&gt;collapse(criteria.direction != AccessibilitySearchTextDirection::Backward);</span>
<span class="line-added"> 896     } else</span>
<span class="line-added"> 897         return result;</span>
<span class="line-added"> 898 </span>
<span class="line-added"> 899     RefPtr&lt;Range&gt; found;</span>
<span class="line-added"> 900     switch (criteria.direction) {</span>
<span class="line-added"> 901     case AccessibilitySearchTextDirection::Forward:</span>
<span class="line-added"> 902     case AccessibilitySearchTextDirection::Backward:</span>
<span class="line-added"> 903     case AccessibilitySearchTextDirection::Closest:</span>
<span class="line-added"> 904         found = findTextRange(criteria.searchStrings, startRange, criteria.direction);</span>
<span class="line-added"> 905         if (found)</span>
<span class="line-added"> 906             result.append(found);</span>
<span class="line-added"> 907         break;</span>
<span class="line-added"> 908     case AccessibilitySearchTextDirection::All: {</span>
<span class="line-added"> 909         auto findAll = [&amp;](AccessibilitySearchTextDirection dir) {</span>
<span class="line-added"> 910             found = findTextRange(criteria.searchStrings, startRange, dir);</span>
<span class="line-added"> 911             while (found) {</span>
<span class="line-added"> 912                 result.append(found);</span>
<span class="line-added"> 913                 found = findTextRange(criteria.searchStrings, found, dir);</span>
 914             }
<span class="line-added"> 915         };</span>
<span class="line-added"> 916         findAll(AccessibilitySearchTextDirection::Forward);</span>
<span class="line-added"> 917         findAll(AccessibilitySearchTextDirection::Backward);</span>
<span class="line-added"> 918         break;</span>
<span class="line-added"> 919     }</span>
<span class="line-added"> 920     }</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922     return result;</span>
<span class="line-added"> 923 }</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925 Vector&lt;String&gt; AccessibilityObject::performTextOperation(AccessibilityTextOperation const&amp; operation)</span>
<span class="line-added"> 926 {</span>
<span class="line-added"> 927     Vector&lt;String&gt; result;</span>
<span class="line-added"> 928 </span>
<span class="line-added"> 929     if (operation.textRanges.isEmpty())</span>
<span class="line-added"> 930         return result;</span>
<span class="line-added"> 931 </span>
<span class="line-added"> 932     Frame* frame = this-&gt;frame();</span>
<span class="line-added"> 933     if (!frame)</span>
<span class="line-added"> 934         return result;</span>
 935 
<span class="line-modified"> 936     for (auto textRange : operation.textRanges) {</span>
<span class="line-added"> 937         if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))</span>
<span class="line-added"> 938             continue;</span>
<span class="line-added"> 939 </span>
<span class="line-added"> 940         String text = textRange-&gt;text();</span>
<span class="line-added"> 941         String replacementString = operation.replacementText;</span>
<span class="line-added"> 942         bool replaceSelection = false;</span>
<span class="line-added"> 943         switch (operation.type) {</span>
<span class="line-added"> 944         case AccessibilityTextOperationType::Capitalize:</span>
<span class="line-added"> 945             replacementString = capitalize(text, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-added"> 946             replaceSelection = true;</span>
<span class="line-added"> 947             break;</span>
<span class="line-added"> 948         case AccessibilityTextOperationType::Uppercase:</span>
<span class="line-added"> 949             replacementString = text.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added"> 950             replaceSelection = true;</span>
<span class="line-added"> 951             break;</span>
<span class="line-added"> 952         case AccessibilityTextOperationType::Lowercase:</span>
<span class="line-added"> 953             replacementString = text.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added"> 954             replaceSelection = true;</span>
<span class="line-added"> 955             break;</span>
<span class="line-added"> 956         case AccessibilityTextOperationType::Replace: {</span>
<span class="line-added"> 957             replaceSelection = true;</span>
<span class="line-added"> 958             // When applying find and replace activities, we want to match the capitalization of the replaced text,</span>
<span class="line-added"> 959             // (unless we&#39;re replacing with an abbreviation.)</span>
<span class="line-added"> 960             if (text.length() &gt; 0</span>
<span class="line-added"> 961                 &amp;&amp; replacementString.length() &gt; 2</span>
<span class="line-added"> 962                 &amp;&amp; replacementString != replacementString.convertToUppercaseWithoutLocale()) {</span>
<span class="line-added"> 963                 if (text[0] == u_toupper(text[0]))</span>
<span class="line-added"> 964                     replacementString = capitalize(replacementString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-added"> 965                 else</span>
<span class="line-added"> 966                     replacementString = replacementString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added"> 967             }</span>
<span class="line-added"> 968             break;</span>
 969         }
<span class="line-added"> 970         case AccessibilityTextOperationType::Select:</span>
<span class="line-added"> 971             break;</span>
<span class="line-added"> 972         }</span>
<span class="line-added"> 973 </span>
<span class="line-added"> 974         // A bit obvious, but worth noting the API contract for this method is that we should</span>
<span class="line-added"> 975         // return the replacement string when replacing, but the selected string if not.</span>
<span class="line-added"> 976         if (replaceSelection) {</span>
<span class="line-added"> 977             frame-&gt;editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::Yes, Editor::SmartReplace::Yes);</span>
<span class="line-added"> 978             result.append(replacementString);</span>
<span class="line-added"> 979         } else</span>
<span class="line-added"> 980             result.append(text);</span>
 981     }
 982 
<span class="line-modified"> 983     return result;</span>
 984 }
 985 
 986 bool AccessibilityObject::hasAttributesRequiredForInclusion() const
 987 {
 988     // These checks are simplified in the interest of execution speed.
 989     if (!getAttribute(aria_helpAttr).isEmpty()
 990         || !getAttribute(aria_describedbyAttr).isEmpty()
 991         || !getAttribute(altAttr).isEmpty()
 992         || !getAttribute(titleAttr).isEmpty())
 993         return true;
 994 
 995 #if ENABLE(MATHML)
 996     if (!getAttribute(MathMLNames::alttextAttr).isEmpty())
 997         return true;
 998 #endif
 999 
1000     return false;
1001 }
1002 
1003 bool AccessibilityObject::isARIAInput(AccessibilityRole ariaRole)
1004 {
1005     return ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::CheckBox || ariaRole == AccessibilityRole::TextField || ariaRole == AccessibilityRole::Switch || ariaRole == AccessibilityRole::SearchField;
1006 }
1007 
1008 bool AccessibilityObject::isARIAControl(AccessibilityRole ariaRole)
1009 {
1010     return isARIAInput(ariaRole) || ariaRole == AccessibilityRole::TextArea || ariaRole == AccessibilityRole::Button || ariaRole == AccessibilityRole::ComboBox || ariaRole == AccessibilityRole::Slider || ariaRole == AccessibilityRole::ListBox;
1011 }
1012 
1013 bool AccessibilityObject::isRangeControl() const
1014 {
1015     switch (roleValue()) {
<span class="line-added">1016     case AccessibilityRole::Meter:</span>
1017     case AccessibilityRole::ProgressIndicator:
1018     case AccessibilityRole::Slider:
1019     case AccessibilityRole::ScrollBar:
1020     case AccessibilityRole::SpinButton:
1021         return true;
1022     case AccessibilityRole::Splitter:
1023         return canSetFocusAttribute();
1024     default:
1025         return false;
1026     }
1027 }
1028 
1029 bool AccessibilityObject::isMeter() const
1030 {
<span class="line-added">1031     if (ariaRoleAttribute() == AccessibilityRole::Meter)</span>
<span class="line-added">1032         return true;</span>
<span class="line-added">1033 </span>
1034 #if ENABLE(METER_ELEMENT)
1035     RenderObject* renderer = this-&gt;renderer();
1036     return renderer &amp;&amp; renderer-&gt;isMeter();
1037 #else
1038     return false;
1039 #endif
1040 }
1041 
1042 IntPoint AccessibilityObject::clickPoint()
1043 {
1044     LayoutRect rect = elementRect();
1045     return roundedIntPoint(LayoutPoint(rect.x() + rect.width() / 2, rect.y() + rect.height() / 2));
1046 }
1047 
1048 IntRect AccessibilityObject::boundingBoxForQuads(RenderObject* obj, const Vector&lt;FloatQuad&gt;&amp; quads)
1049 {
1050     ASSERT(obj);
1051     if (!obj)
1052         return IntRect();
1053 
</pre>
<hr />
<pre>
1083         if (auto* innerNode = hitTestResult.innerNode()) {
1084             if (auto* shadowHost = innerNode-&gt;shadowHost())
1085                 hitTestElement = shadowHost;
1086             else if (is&lt;Element&gt;(*innerNode))
1087                 hitTestElement = &amp;downcast&lt;Element&gt;(*innerNode);
1088             else
1089                 hitTestElement = innerNode-&gt;parentElement();
1090         }
1091     }
1092 
1093     // Prefer the actionElement instead of this node, if the actionElement is inside this node.
1094     Element* pressElement = this-&gt;element();
1095     if (!pressElement || actionElem-&gt;isDescendantOf(*pressElement))
1096         pressElement = actionElem;
1097 
1098     ASSERT(pressElement);
1099     // Prefer the hit test element, if it is inside the target element.
1100     if (hitTestElement &amp;&amp; hitTestElement-&gt;isDescendantOf(*pressElement))
1101         pressElement = hitTestElement;
1102 








1103     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document);
1104 
1105     bool dispatchedTouchEvent = false;
1106 #if PLATFORM(IOS_FAMILY)
1107     if (hasTouchEventListener())
1108         dispatchedTouchEvent = dispatchTouchEvent();
1109 #endif
1110     if (!dispatchedTouchEvent)
1111         pressElement-&gt;accessKeyAction(true);
1112 
1113     return true;
1114 }
1115 
1116 bool AccessibilityObject::dispatchTouchEvent()
1117 {
1118 #if ENABLE(IOS_TOUCH_EVENTS)
1119     if (auto* frame = mainFrame())
1120         return frame-&gt;eventHandler().dispatchSimulatedTouchEvent(clickPoint());
1121 #endif
1122     return false;
1123 }
1124 
1125 Frame* AccessibilityObject::frame() const
1126 {
1127     Node* node = this-&gt;node();
<span class="line-modified">1128     return node ? node-&gt;document().frame() : nullptr;</span>



1129 }
1130 
1131 Frame* AccessibilityObject::mainFrame() const
1132 {
1133     Document* document = topDocument();
1134     if (!document)
1135         return nullptr;
1136 
1137     Frame* frame = document-&gt;frame();
1138     if (!frame)
1139         return nullptr;
1140 
1141     return &amp;frame-&gt;mainFrame();
1142 }
1143 
1144 Document* AccessibilityObject::topDocument() const
1145 {
1146     if (!document())
1147         return nullptr;
1148     return &amp;document()-&gt;topDocument();
1149 }
1150 
1151 String AccessibilityObject::language() const
1152 {
<span class="line-modified">1153     const AtomString&amp; lang = getAttribute(langAttr);</span>
1154     if (!lang.isEmpty())
1155         return lang;
1156 
1157     AccessibilityObject* parent = parentObject();
1158 
1159     // as a last resort, fall back to the content language specified in the meta tag
1160     if (!parent) {
1161         Document* doc = document();
1162         if (doc)
1163             return doc-&gt;contentLanguage();
1164         return nullAtom();
1165     }
1166 
1167     return parent-&gt;language();
1168 }
1169 
1170 VisiblePositionRange AccessibilityObject::visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp; visiblePos1, const VisiblePosition&amp; visiblePos2) const
1171 {
1172     if (visiblePos1.isNull() || visiblePos2.isNull())
1173         return VisiblePositionRange();
</pre>
<hr />
<pre>
1759         || role == AccessibilityRole::TextField
1760         || role == AccessibilityRole::TreeGrid
1761         || isPasswordField();
1762 }
1763 
1764 String AccessibilityObject::readOnlyValue() const
1765 {
1766     if (!hasAttribute(aria_readonlyAttr))
1767         return ariaRoleAttribute() != AccessibilityRole::Unknown &amp;&amp; supportsReadOnly() ? &quot;false&quot; : String();
1768 
1769     return getAttribute(aria_readonlyAttr).string().convertToASCIILowercase();
1770 }
1771 
1772 bool AccessibilityObject::supportsAutoComplete() const
1773 {
1774     return (isComboBox() || isARIATextControl()) &amp;&amp; hasAttribute(aria_autocompleteAttr);
1775 }
1776 
1777 String AccessibilityObject::autoCompleteValue() const
1778 {
<span class="line-modified">1779     const AtomString&amp; autoComplete = getAttribute(aria_autocompleteAttr);</span>
1780     if (equalLettersIgnoringASCIICase(autoComplete, &quot;inline&quot;)
1781         || equalLettersIgnoringASCIICase(autoComplete, &quot;list&quot;)
1782         || equalLettersIgnoringASCIICase(autoComplete, &quot;both&quot;))
1783         return autoComplete;
1784 
1785     return &quot;none&quot;;
1786 }
1787 
1788 bool AccessibilityObject::contentEditableAttributeIsEnabled(Element* element)
1789 {
1790     if (!element)
1791         return false;
1792 
<span class="line-modified">1793     const AtomString&amp; contentEditableValue = element-&gt;attributeWithoutSynchronization(contenteditableAttr);</span>
1794     if (contentEditableValue.isNull())
1795         return false;
1796 
1797     // Both &quot;true&quot; (case-insensitive) and the empty string count as true.
1798     return contentEditableValue.isEmpty() || equalLettersIgnoringASCIICase(contentEditableValue, &quot;true&quot;);
1799 }
1800 
<span class="line-modified">1801 #if ENABLE(ACCESSIBILITY)</span>
1802 int AccessibilityObject::lineForPosition(const VisiblePosition&amp; visiblePos) const
1803 {
1804     if (visiblePos.isNull() || !node())
1805         return -1;
1806 
1807     // If the position is not in the same editable region as this AX object, return -1.
1808     Node* containerNode = visiblePos.deepEquivalent().containerNode();
1809     if (!containerNode-&gt;containsIncludingShadowDOM(node()) &amp;&amp; !node()-&gt;containsIncludingShadowDOM(containerNode))
1810         return -1;
1811 
1812     int lineCount = -1;
1813     VisiblePosition currentVisiblePos = visiblePos;
1814     VisiblePosition savedVisiblePos;
1815 
1816     // move up until we get to the top
1817     // FIXME: This only takes us to the top of the rootEditableElement, not the top of the
1818     // top document.
1819     do {
1820         savedVisiblePos = currentVisiblePos;
1821         VisiblePosition prevVisiblePos = previousLinePosition(currentVisiblePos, 0, HasEditableAXRole);
</pre>
<hr />
<pre>
1851         return PlainTextRange();
1852 
1853     return PlainTextRange(i, 1);
1854 }
1855 
1856 // Given a character index, the range of text associated with this accessibility object
1857 // over which the style in effect at that character index applies.
1858 PlainTextRange AccessibilityObject::doAXStyleRangeForIndex(unsigned index) const
1859 {
1860     VisiblePositionRange range = styleRangeForPosition(visiblePositionForIndex(index, false));
1861     return plainTextRangeForVisiblePositionRange(range);
1862 }
1863 
1864 // Given an indexed character, the line number of the text associated with this accessibility
1865 // object that contains the character.
1866 unsigned AccessibilityObject::doAXLineForIndex(unsigned index)
1867 {
1868     return lineForPosition(visiblePositionForIndex(index, false));
1869 }
1870 
<span class="line-modified">1871 #if ENABLE(ACCESSIBILITY)</span>
1872 void AccessibilityObject::updateBackingStore()
1873 {
1874     if (!axObjectCache())
1875         return;
1876 
1877     // Updating the layout may delete this object.
1878     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1879     if (auto* document = this-&gt;document()) {
1880         if (!document-&gt;view()-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !document-&gt;inRenderTreeUpdate() &amp;&amp; !document-&gt;inStyleRecalc())
1881             document-&gt;updateLayoutIgnorePendingStylesheets();
1882     }
1883 
1884     if (auto cache = axObjectCache())
1885         cache-&gt;performDeferredCacheUpdate();
1886 
1887     updateChildrenIfNecessary();
1888 }
1889 #endif
1890 
<span class="line-modified">1891 const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const</span>
1892 {
<span class="line-modified">1893     return downcast&lt;AccessibilityScrollView&gt;(AccessibilityObject::matchedParent(*this, includeSelf, [] (const auto&amp; object) {</span>
1894         return is&lt;AccessibilityScrollView&gt;(object);
<span class="line-modified">1895     }));</span>
<span class="line-modified">1896 }</span>
<span class="line-added">1897 </span>
<span class="line-added">1898 ScrollView* AccessibilityObject::scrollViewAncestor() const</span>
<span class="line-added">1899 {</span>
<span class="line-added">1900     if (auto parentScrollView = ancestorAccessibilityScrollView(true/* includeSelf */))</span>
<span class="line-added">1901         return parentScrollView-&gt;scrollView();</span>
1902 
1903     return nullptr;
1904 }
1905 
1906 Document* AccessibilityObject::document() const
1907 {
1908     FrameView* frameView = documentFrameView();
1909     if (!frameView)
1910         return nullptr;
1911 
1912     return frameView-&gt;frame().document();
1913 }
1914 
1915 Page* AccessibilityObject::page() const
1916 {
1917     Document* document = this-&gt;document();
1918     if (!document)
1919         return nullptr;
1920     return document-&gt;page();
1921 }
1922 
1923 FrameView* AccessibilityObject::documentFrameView() const
1924 {
1925     const AccessibilityObject* object = this;
1926     while (object &amp;&amp; !object-&gt;isAccessibilityRenderObject())
1927         object = object-&gt;parentObject();
1928 
1929     if (!object)
1930         return nullptr;
1931 
1932     return object-&gt;documentFrameView();
1933 }
1934 
<span class="line-modified">1935 #if ENABLE(ACCESSIBILITY)</span>
1936 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
1937 {
1938     if (updateChildrenIfNeeded)
1939         updateChildrenIfNecessary();
1940 
1941     return m_children;
1942 }
1943 #endif
1944 
1945 void AccessibilityObject::updateChildrenIfNecessary()
1946 {
1947     if (!hasChildren()) {

1948         // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
1949         AXAttributeCacheEnabler enableCache(axObjectCache());

1950         addChildren();
1951     }
1952 }
1953 
1954 void AccessibilityObject::clearChildren()
1955 {
1956     // Some objects have weak pointers to their parents and those associations need to be detached.
1957     for (const auto&amp; child : m_children)
1958         child-&gt;detachFromParent();
1959 
1960     m_children.clear();
1961     m_haveChildren = false;
1962 }
1963 
1964 AccessibilityObject* AccessibilityObject::anchorElementForNode(Node* node)
1965 {
1966     RenderObject* obj = node-&gt;renderer();
1967     if (!obj)
1968         return nullptr;
1969 
</pre>
<hr />
<pre>
2038     }
2039 }
2040 
2041 const String AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityRole role)
2042 {
2043     switch (role) {
2044     case AccessibilityRole::ApplicationAlertDialog:
2045     case AccessibilityRole::ApplicationAlert:
2046         return &quot;assertive&quot;_s;
2047     case AccessibilityRole::ApplicationLog:
2048     case AccessibilityRole::ApplicationStatus:
2049         return &quot;polite&quot;_s;
2050     case AccessibilityRole::ApplicationTimer:
2051     case AccessibilityRole::ApplicationMarquee:
2052         return &quot;off&quot;_s;
2053     default:
2054         return nullAtom();
2055     }
2056 }
2057 
<span class="line-modified">2058 #if ENABLE(ACCESSIBILITY)</span>
2059 const String&amp; AccessibilityObject::actionVerb() const
2060 {
2061 #if !PLATFORM(IOS_FAMILY)
2062     // FIXME: Need to add verbs for select elements.
2063     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
2064     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
2065     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
2066     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXCheckedCheckBoxActionVerb());
2067     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
2068     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
2069     static NeverDestroyed&lt;const String&gt; menuListAction(AXMenuListActionVerb());
2070     static NeverDestroyed&lt;const String&gt; menuListPopupAction(AXMenuListPopupActionVerb());
2071     static NeverDestroyed&lt;const String&gt; listItemAction(AXListItemActionVerb());
2072 
2073     switch (roleValue()) {
2074     case AccessibilityRole::Button:
2075     case AccessibilityRole::ToggleButton:
2076         return buttonAction;
2077     case AccessibilityRole::TextField:
2078     case AccessibilityRole::TextArea:
</pre>
<hr />
<pre>
2232         return false;
2233 
2234     return !isModalDescendant(modalNode);
2235 }
2236 
2237 bool AccessibilityObject::hasTagName(const QualifiedName&amp; tagName) const
2238 {
2239     Node* node = this-&gt;node();
2240     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hasTagName(tagName);
2241 }
2242 
2243 bool AccessibilityObject::hasAttribute(const QualifiedName&amp; attribute) const
2244 {
2245     Node* node = this-&gt;node();
2246     if (!is&lt;Element&gt;(node))
2247         return false;
2248 
2249     return downcast&lt;Element&gt;(*node).hasAttributeWithoutSynchronization(attribute);
2250 }
2251 
<span class="line-modified">2252 const AtomString&amp; AccessibilityObject::getAttribute(const QualifiedName&amp; attribute) const</span>
2253 {
2254     if (auto* element = this-&gt;element())
2255         return element-&gt;attributeWithoutSynchronization(attribute);
2256     return nullAtom();
2257 }
2258 
<span class="line-modified">2259 bool AccessibilityObject::replaceTextInRange(const String&amp; replacementString, const PlainTextRange&amp; range)</span>
2260 {
<span class="line-modified">2261     if (!renderer() || !is&lt;Element&gt;(node()))</span>









2262         return false;
2263 
<span class="line-modified">2264     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());</span>






2265 
<span class="line-modified">2266     // We should use the editor&#39;s insertText to mimic typing into the field.</span>
<span class="line-modified">2267     // Also only do this when the field is in editing mode.</span>
<span class="line-added">2268     auto&amp; frame = renderer()-&gt;frame();</span>
<span class="line-added">2269     if (element.shouldUseInputMethod()) {</span>
<span class="line-added">2270         frame.selection().setSelectedRange(rangeForPlainTextRange(range).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);</span>
<span class="line-added">2271         frame.editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::No, Editor::SmartReplace::No);</span>
<span class="line-added">2272         return true;</span>
<span class="line-added">2273     }</span>
2274 
<span class="line-modified">2275     if (is&lt;HTMLInputElement&gt;(element)) {</span>
<span class="line-added">2276         downcast&lt;HTMLInputElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);</span>
<span class="line-added">2277         return true;</span>
<span class="line-added">2278     }</span>
<span class="line-added">2279     if (is&lt;HTMLTextAreaElement&gt;(element)) {</span>
<span class="line-added">2280         downcast&lt;HTMLTextAreaElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);</span>
<span class="line-added">2281         return true;</span>
<span class="line-added">2282     }</span>
2283 
<span class="line-modified">2284     return false;</span>

2285 }
2286 
<span class="line-modified">2287 bool AccessibilityObject::insertText(const String&amp; text)</span>
2288 {
<span class="line-modified">2289     if (!renderer() || !is&lt;Element&gt;(node()))</span>


























2290         return false;

2291 
<span class="line-modified">2292     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());</span>


2293 
<span class="line-modified">2294     // Only try to insert text if the field is in editing mode.</span>
<span class="line-modified">2295     if (!element.shouldUseInputMethod())</span>

2296         return false;
<span class="line-modified">2297 </span>
<span class="line-modified">2298     // Use Editor::insertText to mimic typing into the field.</span>
<span class="line-added">2299     auto&amp; editor = renderer()-&gt;frame().editor();</span>
<span class="line-added">2300     return editor.insertText(text, nullptr);</span>
2301 }
2302 
2303 // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
2304 AccessibilityOrientation AccessibilityObject::orientation() const
2305 {
2306     LayoutRect bounds = elementRect();
2307     if (bounds.size().width() &gt; bounds.size().height())
2308         return AccessibilityOrientation::Horizontal;
2309     if (bounds.size().height() &gt; bounds.size().width())
2310         return AccessibilityOrientation::Vertical;
2311 
2312     return AccessibilityOrientation::Undefined;
2313 }
2314 
2315 bool AccessibilityObject::isDescendantOfObject(const AccessibilityObject* axObject) const
2316 {
2317     if (!axObject || !axObject-&gt;hasChildren())
2318         return false;
2319 
2320     return AccessibilityObject::matchedParent(*this, false, [axObject] (const AccessibilityObject&amp; object) {
</pre>
<hr />
<pre>
2351 };
2352 
2353 static void initializeRoleMap()
2354 {
2355     if (gAriaRoleMap)
2356         return;
2357     ASSERT(!gAriaReverseRoleMap);
2358 
2359     const RoleEntry roles[] = {
2360         { &quot;alert&quot;, AccessibilityRole::ApplicationAlert },
2361         { &quot;alertdialog&quot;, AccessibilityRole::ApplicationAlertDialog },
2362         { &quot;application&quot;, AccessibilityRole::WebApplication },
2363         { &quot;article&quot;, AccessibilityRole::DocumentArticle },
2364         { &quot;banner&quot;, AccessibilityRole::LandmarkBanner },
2365         { &quot;blockquote&quot;, AccessibilityRole::Blockquote },
2366         { &quot;button&quot;, AccessibilityRole::Button },
2367         { &quot;caption&quot;, AccessibilityRole::Caption },
2368         { &quot;checkbox&quot;, AccessibilityRole::CheckBox },
2369         { &quot;complementary&quot;, AccessibilityRole::LandmarkComplementary },
2370         { &quot;contentinfo&quot;, AccessibilityRole::LandmarkContentInfo },
<span class="line-added">2371         { &quot;deletion&quot;, AccessibilityRole::Deletion },</span>
2372         { &quot;dialog&quot;, AccessibilityRole::ApplicationDialog },
2373         { &quot;directory&quot;, AccessibilityRole::Directory },
2374         // The &#39;doc-*&#39; roles are defined the ARIA DPUB mobile: https://www.w3.org/TR/dpub-aam-1.0/
2375         // Editor&#39;s draft is currently at https://rawgit.com/w3c/aria/master/dpub-aam/dpub-aam.html
2376         { &quot;doc-abstract&quot;, AccessibilityRole::ApplicationTextGroup },
2377         { &quot;doc-acknowledgments&quot;, AccessibilityRole::LandmarkDocRegion },
2378         { &quot;doc-afterword&quot;, AccessibilityRole::LandmarkDocRegion },
2379         { &quot;doc-appendix&quot;, AccessibilityRole::LandmarkDocRegion },
2380         { &quot;doc-backlink&quot;, AccessibilityRole::WebCoreLink },
2381         { &quot;doc-biblioentry&quot;, AccessibilityRole::ListItem },
2382         { &quot;doc-bibliography&quot;, AccessibilityRole::LandmarkDocRegion },
2383         { &quot;doc-biblioref&quot;, AccessibilityRole::WebCoreLink },
2384         { &quot;doc-chapter&quot;, AccessibilityRole::LandmarkDocRegion },
2385         { &quot;doc-colophon&quot;, AccessibilityRole::ApplicationTextGroup },
2386         { &quot;doc-conclusion&quot;, AccessibilityRole::LandmarkDocRegion },
2387         { &quot;doc-cover&quot;, AccessibilityRole::Image },
2388         { &quot;doc-credit&quot;, AccessibilityRole::ApplicationTextGroup },
2389         { &quot;doc-credits&quot;, AccessibilityRole::LandmarkDocRegion },
2390         { &quot;doc-dedication&quot;, AccessibilityRole::ApplicationTextGroup },
2391         { &quot;doc-endnote&quot;, AccessibilityRole::ListItem },
</pre>
<hr />
<pre>
2414         { &quot;doc-toc&quot;, AccessibilityRole::LandmarkNavigation },
2415         { &quot;figure&quot;, AccessibilityRole::Figure },
2416         // The mappings for &#39;graphics-*&#39; roles are defined in this spec: https://w3c.github.io/graphics-aam/
2417         { &quot;graphics-document&quot;, AccessibilityRole::GraphicsDocument },
2418         { &quot;graphics-object&quot;, AccessibilityRole::GraphicsObject },
2419         { &quot;graphics-symbol&quot;, AccessibilityRole::GraphicsSymbol },
2420         { &quot;grid&quot;, AccessibilityRole::Grid },
2421         { &quot;gridcell&quot;, AccessibilityRole::GridCell },
2422         { &quot;table&quot;, AccessibilityRole::Table },
2423         { &quot;cell&quot;, AccessibilityRole::Cell },
2424         { &quot;columnheader&quot;, AccessibilityRole::ColumnHeader },
2425         { &quot;combobox&quot;, AccessibilityRole::ComboBox },
2426         { &quot;definition&quot;, AccessibilityRole::Definition },
2427         { &quot;document&quot;, AccessibilityRole::Document },
2428         { &quot;feed&quot;, AccessibilityRole::Feed },
2429         { &quot;form&quot;, AccessibilityRole::Form },
2430         { &quot;rowheader&quot;, AccessibilityRole::RowHeader },
2431         { &quot;group&quot;, AccessibilityRole::ApplicationGroup },
2432         { &quot;heading&quot;, AccessibilityRole::Heading },
2433         { &quot;img&quot;, AccessibilityRole::Image },
<span class="line-added">2434         { &quot;insertion&quot;, AccessibilityRole::Insertion },</span>
2435         { &quot;link&quot;, AccessibilityRole::WebCoreLink },
2436         { &quot;list&quot;, AccessibilityRole::List },
2437         { &quot;listitem&quot;, AccessibilityRole::ListItem },
2438         { &quot;listbox&quot;, AccessibilityRole::ListBox },
2439         { &quot;log&quot;, AccessibilityRole::ApplicationLog },
2440         { &quot;main&quot;, AccessibilityRole::LandmarkMain },
2441         { &quot;marquee&quot;, AccessibilityRole::ApplicationMarquee },
2442         { &quot;math&quot;, AccessibilityRole::DocumentMath },
2443         { &quot;menu&quot;, AccessibilityRole::Menu },
2444         { &quot;menubar&quot;, AccessibilityRole::MenuBar },
2445         { &quot;menuitem&quot;, AccessibilityRole::MenuItem },
2446         { &quot;menuitemcheckbox&quot;, AccessibilityRole::MenuItemCheckbox },
2447         { &quot;menuitemradio&quot;, AccessibilityRole::MenuItemRadio },
<span class="line-added">2448         { &quot;meter&quot;, AccessibilityRole::Meter },</span>
2449         { &quot;none&quot;, AccessibilityRole::Presentational },
2450         { &quot;note&quot;, AccessibilityRole::DocumentNote },
2451         { &quot;navigation&quot;, AccessibilityRole::LandmarkNavigation },
2452         { &quot;option&quot;, AccessibilityRole::ListBoxOption },
2453         { &quot;paragraph&quot;, AccessibilityRole::Paragraph },
2454         { &quot;presentation&quot;, AccessibilityRole::Presentational },
2455         { &quot;progressbar&quot;, AccessibilityRole::ProgressIndicator },
2456         { &quot;radio&quot;, AccessibilityRole::RadioButton },
2457         { &quot;radiogroup&quot;, AccessibilityRole::RadioGroup },
2458         { &quot;region&quot;, AccessibilityRole::LandmarkRegion },
2459         { &quot;row&quot;, AccessibilityRole::Row },
2460         { &quot;rowgroup&quot;, AccessibilityRole::RowGroup },
2461         { &quot;scrollbar&quot;, AccessibilityRole::ScrollBar },
2462         { &quot;search&quot;, AccessibilityRole::LandmarkSearch },
2463         { &quot;searchbox&quot;, AccessibilityRole::SearchField },
2464         { &quot;separator&quot;, AccessibilityRole::Splitter },
2465         { &quot;slider&quot;, AccessibilityRole::Slider },
2466         { &quot;spinbutton&quot;, AccessibilityRole::SpinButton },
2467         { &quot;status&quot;, AccessibilityRole::ApplicationStatus },
<span class="line-added">2468         { &quot;subscript&quot;, AccessibilityRole::Subscript },</span>
<span class="line-added">2469         { &quot;superscript&quot;, AccessibilityRole::Superscript },</span>
2470         { &quot;switch&quot;, AccessibilityRole::Switch },
2471         { &quot;tab&quot;, AccessibilityRole::Tab },
2472         { &quot;tablist&quot;, AccessibilityRole::TabList },
2473         { &quot;tabpanel&quot;, AccessibilityRole::TabPanel },
2474         { &quot;text&quot;, AccessibilityRole::StaticText },
2475         { &quot;textbox&quot;, AccessibilityRole::TextArea },
2476         { &quot;term&quot;, AccessibilityRole::Term },
<span class="line-added">2477         { &quot;time&quot;, AccessibilityRole::Time },</span>
2478         { &quot;timer&quot;, AccessibilityRole::ApplicationTimer },
2479         { &quot;toolbar&quot;, AccessibilityRole::Toolbar },
2480         { &quot;tooltip&quot;, AccessibilityRole::UserInterfaceTooltip },
2481         { &quot;tree&quot;, AccessibilityRole::Tree },
2482         { &quot;treegrid&quot;, AccessibilityRole::TreeGrid },
2483         { &quot;treeitem&quot;, AccessibilityRole::TreeItem }
2484     };
2485 
2486     gAriaRoleMap = new ARIARoleMap;
2487     gAriaReverseRoleMap = new ARIAReverseRoleMap;
2488     size_t roleLength = WTF_ARRAY_LENGTH(roles);
2489     for (size_t i = 0; i &lt; roleLength; ++i) {
2490         gAriaRoleMap-&gt;set(roles[i].ariaRole, roles[i].webcoreRole);
2491         gAriaReverseRoleMap-&gt;set(static_cast&lt;int&gt;(roles[i].webcoreRole), roles[i].ariaRole);
2492     }
2493 }
2494 
2495 static ARIARoleMap&amp; ariaRoleMap()
2496 {
2497     initializeRoleMap();
2498     return *gAriaRoleMap;
2499 }
2500 
2501 static ARIAReverseRoleMap&amp; reverseAriaRoleMap()
2502 {
2503     initializeRoleMap();
2504     return *gAriaReverseRoleMap;
2505 }
2506 
2507 AccessibilityRole AccessibilityObject::ariaRoleToWebCoreRole(const String&amp; value)
2508 {
<span class="line-modified">2509     if (value.isNull() || value.isEmpty())</span>
<span class="line-added">2510         return AccessibilityRole::Unknown;</span>
<span class="line-added">2511 </span>
2512     for (auto roleName : StringView(value).split(&#39; &#39;)) {
2513         AccessibilityRole role = ariaRoleMap().get&lt;ASCIICaseInsensitiveStringViewHashTranslator&gt;(roleName);
2514         if (static_cast&lt;int&gt;(role))
2515             return role;
2516     }
2517     return AccessibilityRole::Unknown;
2518 }
2519 
2520 String AccessibilityObject::computedRoleString() const
2521 {
2522     // FIXME: Need a few special cases that aren&#39;t in the RoleMap: option, etc. http://webkit.org/b/128296
2523     AccessibilityRole role = roleValue();
2524 
<span class="line-added">2525     if (role == AccessibilityRole::Image &amp;&amp; accessibilityIsIgnored())</span>
<span class="line-added">2526         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Presentational));</span>
<span class="line-added">2527 </span>
2528     // We do not compute a role string for generic block elements with user-agent assigned roles.
2529     if (role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup)
2530         return &quot;&quot;;
2531 
2532     // We do compute a role string for block elements with author-provided roles.
2533     if (role == AccessibilityRole::ApplicationTextGroup
2534         || role == AccessibilityRole::Footnote
2535         || role == AccessibilityRole::GraphicsObject)
2536         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::ApplicationGroup));
2537 
2538     if (role == AccessibilityRole::GraphicsDocument)
2539         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Document));
2540 
2541     if (role == AccessibilityRole::GraphicsSymbol)
2542         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Image));
2543 
2544     if (role == AccessibilityRole::HorizontalRule)
2545         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Splitter));
2546 
2547     if (role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton)
</pre>
<hr />
<pre>
2591             // Search within for immediate descendants that are static text. If we find more than one
2592             // then this is an event delegator actionElement and we should expose the press action.
2593             Vector&lt;AccessibilitySearchKey&gt; keys({ AccessibilitySearchKey::StaticText, AccessibilitySearchKey::Control, AccessibilitySearchKey::Graphic, AccessibilitySearchKey::Heading, AccessibilitySearchKey::Link });
2594             AccessibilitySearchCriteria criteria(axObj, AccessibilitySearchDirection::Next, emptyString(), 2, false, false);
2595             criteria.searchKeys = keys;
2596             axObj-&gt;findMatchingObjects(&amp;criteria, results);
2597             if (results.size() &gt; 1)
2598                 return false;
2599         }
2600     }
2601 
2602     // [Bug: 133613] Heuristic: If the action element is presentational, we shouldn&#39;t expose press as a supported action.
2603     return !nodeHasPresentationRole(actionElement);
2604 }
2605 
2606 bool AccessibilityObject::supportsDatetimeAttribute() const
2607 {
2608     return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
2609 }
2610 
<span class="line-modified">2611 const AtomString&amp; AccessibilityObject::datetimeAttributeValue() const</span>
2612 {
2613     return getAttribute(datetimeAttr);
2614 }
2615 
<span class="line-modified">2616 const AtomString&amp; AccessibilityObject::linkRelValue() const</span>
2617 {
2618     return getAttribute(relAttr);
2619 }
2620 
2621 const String AccessibilityObject::keyShortcutsValue() const
2622 {
2623     return getAttribute(aria_keyshortcutsAttr);
2624 }
2625 
2626 Element* AccessibilityObject::element() const
2627 {
2628     Node* node = this-&gt;node();
2629     if (is&lt;Element&gt;(node))
2630         return downcast&lt;Element&gt;(node);
2631     return nullptr;
2632 }
2633 
2634 bool AccessibilityObject::isValueAutofillAvailable() const
2635 {
2636     if (!isNativeTextControl())
</pre>
<hr />
<pre>
2648     if (!isValueAutofillAvailable())
2649         return AutoFillButtonType::None;
2650 
2651     return downcast&lt;HTMLInputElement&gt;(*this-&gt;node()).autoFillButtonType();
2652 }
2653 
2654 bool AccessibilityObject::isValueAutofilled() const
2655 {
2656     if (!isNativeTextControl())
2657         return false;
2658 
2659     Node* node = this-&gt;node();
2660     if (!is&lt;HTMLInputElement&gt;(node))
2661         return false;
2662 
2663     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFilled();
2664 }
2665 
2666 const String AccessibilityObject::placeholderValue() const
2667 {
<span class="line-modified">2668     const AtomString&amp; placeholder = getAttribute(placeholderAttr);</span>
2669     if (!placeholder.isEmpty())
2670         return placeholder;
2671 
<span class="line-modified">2672     const AtomString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);</span>
2673     if (!ariaPlaceholder.isEmpty())
2674         return ariaPlaceholder;
2675 
2676     return nullAtom();
2677 }
2678 
2679 bool AccessibilityObject::isInsideLiveRegion(bool excludeIfOff) const
2680 {
2681     return liveRegionAncestor(excludeIfOff);
2682 }
2683 
2684 AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
2685 {
2686     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {
2687         return object.supportsLiveRegion(excludeIfOff);
2688     }));
2689 }
2690 
2691 bool AccessibilityObject::supportsARIAAttributes() const
2692 {
</pre>
<hr />
<pre>
2694     return supportsLiveRegion()
2695         || supportsARIADragging()
2696         || supportsARIADropping()
2697         || supportsARIAOwns()
2698         || hasAttribute(aria_atomicAttr)
2699         || hasAttribute(aria_busyAttr)
2700         || hasAttribute(aria_controlsAttr)
2701         || hasAttribute(aria_currentAttr)
2702         || hasAttribute(aria_describedbyAttr)
2703         || hasAttribute(aria_detailsAttr)
2704         || hasAttribute(aria_disabledAttr)
2705         || hasAttribute(aria_errormessageAttr)
2706         || hasAttribute(aria_flowtoAttr)
2707         || hasAttribute(aria_haspopupAttr)
2708         || hasAttribute(aria_invalidAttr)
2709         || hasAttribute(aria_labelAttr)
2710         || hasAttribute(aria_labelledbyAttr)
2711         || hasAttribute(aria_relevantAttr);
2712 }
2713 
<span class="line-modified">2714 bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomString&amp; liveRegionStatus)</span>
2715 {
2716     return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
2717 }
2718 
2719 bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
2720 {
<span class="line-modified">2721     const AtomString&amp; liveRegionStatusValue = liveRegionStatus();</span>
2722     return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
2723 }
2724 
<span class="line-modified">2725 AccessibilityObjectInterface* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2726 {
2727     // Send the hit test back into the sub-frame if necessary.
2728     if (isAttachment()) {
2729         Widget* widget = widgetForAttachmentView();
2730         // Normalize the point for the widget&#39;s bounds.
2731         if (widget &amp;&amp; widget-&gt;isFrameView()) {
2732             if (AXObjectCache* cache = axObjectCache())
2733                 return cache-&gt;getOrCreate(widget)-&gt;accessibilityHitTest(IntPoint(point - widget-&gt;frameRect().location()));
2734         }
2735     }
2736 
2737     // Check if there are any mock elements that need to be handled.
2738     for (const auto&amp; child : m_children) {
2739         if (child-&gt;isMockObject() &amp;&amp; child-&gt;elementRect().contains(point))
2740             return child-&gt;elementAccessibilityHitTest(point);
2741     }
2742 
2743     return const_cast&lt;AccessibilityObject*&gt;(this);
2744 }
2745 
2746 AXObjectCache* AccessibilityObject::axObjectCache() const
2747 {
2748     auto* document = this-&gt;document();
2749     return document ? document-&gt;axObjectCache() : nullptr;
2750 }
2751 
<span class="line-modified">2752 AccessibilityObjectInterface* AccessibilityObject::focusedUIElement() const</span>
2753 {
2754     auto* page = this-&gt;page();
2755     return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;
2756 }
2757 
2758 AccessibilitySortDirection AccessibilityObject::sortDirection() const
2759 {
2760     AccessibilityRole role = roleValue();
2761     if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
2762         return AccessibilitySortDirection::Invalid;
2763 
<span class="line-modified">2764     const AtomString&amp; sortAttribute = getAttribute(aria_sortAttr);</span>
2765     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
2766         return AccessibilitySortDirection::Ascending;
2767     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
2768         return AccessibilitySortDirection::Descending;
2769     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
2770         return AccessibilitySortDirection::Other;
2771 
2772     return AccessibilitySortDirection::None;
2773 }
2774 
2775 bool AccessibilityObject::supportsRangeValue() const
2776 {
2777     return isProgressIndicator()
2778         || isSlider()
2779         || isScrollbar()
2780         || isSpinButton()
2781         || (isSplitter() &amp;&amp; canSetFocusAttribute())
2782         || isAttachmentElement();
2783 }
2784 
2785 bool AccessibilityObject::supportsHasPopup() const
2786 {
2787     return hasAttribute(aria_haspopupAttr) || isComboBox();
2788 }
2789 
<span class="line-modified">2790 String AccessibilityObject::popupValue() const</span>
2791 {
<span class="line-modified">2792     static const NeverDestroyed&lt;HashSet&lt;String&gt;&gt; allowedPopupValues(std::initializer_list&lt;String&gt; {</span>
<span class="line-modified">2793         &quot;menu&quot;, &quot;listbox&quot;, &quot;tree&quot;, &quot;grid&quot;, &quot;dialog&quot;</span>
<span class="line-modified">2794     });</span>
<span class="line-modified">2795 </span>
<span class="line-modified">2796     auto hasPopup = getAttribute(aria_haspopupAttr).convertToASCIILowercase();</span>
<span class="line-modified">2797     if (hasPopup.isNull() || hasPopup.isEmpty()) {</span>
<span class="line-modified">2798         // In ARIA 1.1, the implicit value for combobox became &quot;listbox.&quot;</span>
<span class="line-added">2799         if (isComboBox() || hasDatalist())</span>
<span class="line-added">2800             return &quot;listbox&quot;;</span>
<span class="line-added">2801         return &quot;false&quot;;</span>
<span class="line-added">2802     }</span>
<span class="line-added">2803 </span>
<span class="line-added">2804     if (allowedPopupValues-&gt;contains(hasPopup))</span>
2805         return hasPopup;
2806 
<span class="line-modified">2807     // aria-haspopup specification states that true must be treated as menu.</span>
<span class="line-modified">2808     if (hasPopup == &quot;true&quot;)</span>
<span class="line-modified">2809         return &quot;menu&quot;;</span>
2810 
2811     // The spec states that &quot;User agents must treat any value of aria-haspopup that is not
2812     // included in the list of allowed values, including an empty string, as if the value
2813     // false had been provided.&quot;
2814     return &quot;false&quot;;
2815 }
2816 
<span class="line-added">2817 bool AccessibilityObject::hasDatalist() const</span>
<span class="line-added">2818 {</span>
<span class="line-added">2819 #if ENABLE(DATALIST_ELEMENT)</span>
<span class="line-added">2820     auto datalistId = getAttribute(listAttr);</span>
<span class="line-added">2821     if (datalistId.isNull() || datalistId.isEmpty())</span>
<span class="line-added">2822         return false;</span>
<span class="line-added">2823 </span>
<span class="line-added">2824     auto element = this-&gt;element();</span>
<span class="line-added">2825     if (!element)</span>
<span class="line-added">2826         return false;</span>
<span class="line-added">2827 </span>
<span class="line-added">2828     auto datalist = element-&gt;treeScope().getElementById(datalistId);</span>
<span class="line-added">2829     return is&lt;HTMLDataListElement&gt;(datalist);</span>
<span class="line-added">2830 #else</span>
<span class="line-added">2831     return false;</span>
<span class="line-added">2832 #endif</span>
<span class="line-added">2833 }</span>
<span class="line-added">2834 </span>
2835 bool AccessibilityObject::supportsSetSize() const
2836 {
2837     return hasAttribute(aria_setsizeAttr);
2838 }
2839 
2840 bool AccessibilityObject::supportsPosInSet() const
2841 {
2842     return hasAttribute(aria_posinsetAttr);
2843 }
2844 
2845 int AccessibilityObject::setSize() const
2846 {
2847     return getAttribute(aria_setsizeAttr).toInt();
2848 }
2849 
2850 int AccessibilityObject::posInSet() const
2851 {
2852     return getAttribute(aria_posinsetAttr).toInt();
2853 }
2854 
<span class="line-modified">2855 const AtomString&amp; AccessibilityObject::identifierAttribute() const</span>
2856 {
2857     return getAttribute(idAttr);
2858 }
2859 
2860 void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
2861 {
2862     Node* node = this-&gt;node();
2863     if (!is&lt;Element&gt;(node))
2864         return;
2865 
2866     Element* element = downcast&lt;Element&gt;(node);
2867     DOMTokenList&amp; list = element-&gt;classList();
2868     unsigned length = list.length();
2869     for (unsigned k = 0; k &lt; length; k++)
2870         classList.append(list.item(k).string());
2871 }
2872 
2873 bool AccessibilityObject::supportsPressed() const
2874 {
<span class="line-modified">2875     const AtomString&amp; expanded = getAttribute(aria_pressedAttr);</span>
2876     return equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;);
2877 }
2878 
2879 bool AccessibilityObject::supportsExpanded() const
2880 {
2881     // Undefined values should not result in this attribute being exposed to ATs according to ARIA.
<span class="line-modified">2882     const AtomString&amp; expanded = getAttribute(aria_expandedAttr);</span>
2883     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
2884         return true;
2885     switch (roleValue()) {
2886     case AccessibilityRole::ComboBox:
2887     case AccessibilityRole::DisclosureTriangle:
2888     case AccessibilityRole::Details:
2889         return true;
2890     default:
2891         return false;
2892     }
2893 }
2894 
2895 bool AccessibilityObject::isExpanded() const
2896 {
2897     if (equalLettersIgnoringASCIICase(getAttribute(aria_expandedAttr), &quot;true&quot;))
2898         return true;
2899 
2900     if (is&lt;HTMLDetailsElement&gt;(node()))
2901         return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
2902 
</pre>
<hr />
<pre>
2915 {
2916     switch (roleValue()) {
2917     case AccessibilityRole::CheckBox:
2918     case AccessibilityRole::MenuItemCheckbox:
2919     case AccessibilityRole::MenuItemRadio:
2920     case AccessibilityRole::RadioButton:
2921     case AccessibilityRole::Switch:
2922         return true;
2923     default:
2924         return false;
2925     }
2926 }
2927 
2928 AccessibilityButtonState AccessibilityObject::checkboxOrRadioValue() const
2929 {
2930     // If this is a real checkbox or radio button, AccessibilityRenderObject will handle.
2931     // If it&#39;s an ARIA checkbox, radio, or switch the aria-checked attribute should be used.
2932     // If it&#39;s a toggle button, the aria-pressed attribute is consulted.
2933 
2934     if (isToggleButton()) {
<span class="line-modified">2935         const AtomString&amp; ariaPressed = getAttribute(aria_pressedAttr);</span>
2936         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;true&quot;))
2937             return AccessibilityButtonState::On;
2938         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;mixed&quot;))
2939             return AccessibilityButtonState::Mixed;
2940         return AccessibilityButtonState::Off;
2941     }
2942 
<span class="line-modified">2943     const AtomString&amp; result = getAttribute(aria_checkedAttr);</span>
2944     if (equalLettersIgnoringASCIICase(result, &quot;true&quot;))
2945         return AccessibilityButtonState::On;
2946     if (equalLettersIgnoringASCIICase(result, &quot;mixed&quot;)) {
2947         // ARIA says that radio, menuitemradio, and switch elements must NOT expose button state mixed.
2948         AccessibilityRole ariaRole = ariaRoleAttribute();
2949         if (ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::MenuItemRadio || ariaRole == AccessibilityRole::Switch)
2950             return AccessibilityButtonState::Off;
2951         return AccessibilityButtonState::Mixed;
2952     }
2953 
2954     if (isIndeterminate())
2955         return AccessibilityButtonState::Mixed;
2956 
2957     return AccessibilityButtonState::Off;
2958 }
2959 
2960 // This is a 1-dimensional scroll offset helper function that&#39;s applied
2961 // separately in the horizontal and vertical directions, because the
2962 // logic is the same. The goal is to compute the best scroll offset
2963 // in order to make an object visible within a viewport.
</pre>
<hr />
<pre>
3066     size_t levels = objects.size() - 1;
3067 
3068     for (size_t i = levels; i &gt;= 1; i--) {
3069         const AccessibilityObject* outer = objects[i];
3070         const AccessibilityObject* inner = objects[i - 1];
3071         // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
3072         const IntRect outerRect = i &lt; levels ? snappedIntRect(outer-&gt;boundingBoxRect()) : outer-&gt;getScrollableAreaIfScrollable()-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3073         const IntRect innerRect = snappedIntRect(inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect());
3074 
3075         if (!outerRect.intersects(innerRect)) {
3076             isOnscreen = false;
3077             break;
3078         }
3079     }
3080 
3081     return isOnscreen;
3082 }
3083 
3084 void AccessibilityObject::scrollToMakeVisible() const
3085 {
<span class="line-modified">3086     scrollToMakeVisible({ SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::Yes });</span>
<span class="line-modified">3087 }</span>
3088 
<span class="line-added">3089 void AccessibilityObject::scrollToMakeVisible(const ScrollRectToVisibleOptions&amp; options) const</span>
<span class="line-added">3090 {</span>
3091     if (isScrollView() &amp;&amp; parentObject())
3092         parentObject()-&gt;scrollToMakeVisible();
3093 
3094     if (auto* renderer = this-&gt;renderer())
<span class="line-modified">3095         renderer-&gt;scrollRectToVisible(boundingBoxRect(), false, options);</span>
3096 }
3097 
3098 void AccessibilityObject::scrollToMakeVisibleWithSubFocus(const IntRect&amp; subfocus) const
3099 {
3100     // Search up the parent chain until we find the first one that&#39;s scrollable.
3101     AccessibilityObject* scrollParent = parentObject();
3102     ScrollableArea* scrollableArea;
3103     for (scrollableArea = nullptr;
3104          scrollParent &amp;&amp; !(scrollableArea = scrollParent-&gt;getScrollableAreaIfScrollable());
3105          scrollParent = scrollParent-&gt;parentObject()) { }
3106     if (!scrollableArea)
3107         return;
3108 
3109     LayoutRect objectRect = boundingBoxRect();
3110     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3111     // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
3112     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3113 
3114     if (!scrollParent-&gt;isScrollView()) {
3115         objectRect.moveBy(scrollPosition);
</pre>
<hr />
<pre>
3313 
3314 void AccessibilityObject::notifyIfIgnoredValueChanged()
3315 {
3316     bool isIgnored = accessibilityIsIgnored();
3317     if (lastKnownIsIgnoredValue() != isIgnored) {
3318         if (AXObjectCache* cache = axObjectCache())
3319             cache-&gt;childrenChanged(parentObject());
3320         setLastKnownIsIgnoredValue(isIgnored);
3321     }
3322 }
3323 
3324 bool AccessibilityObject::pressedIsPresent() const
3325 {
3326     return !getAttribute(aria_pressedAttr).isEmpty();
3327 }
3328 
3329 TextIteratorBehavior AccessibilityObject::textIteratorBehaviorForTextRange() const
3330 {
3331     TextIteratorBehavior behavior = TextIteratorIgnoresStyleVisibility;
3332 
<span class="line-modified">3333 #if USE(ATK)</span>
3334     // We need to emit replaced elements for GTK, and present
3335     // them with the &#39;object replacement character&#39; (0xFFFC).
3336     behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsObjectReplacementCharacters);
3337 #endif
3338 
3339     return behavior;
3340 }
3341 
3342 AccessibilityRole AccessibilityObject::buttonRoleType() const
3343 {
3344     // If aria-pressed is present, then it should be exposed as a toggle button.
3345     // http://www.w3.org/TR/wai-aria/states_and_properties#aria-pressed
3346     if (pressedIsPresent())
3347         return AccessibilityRole::ToggleButton;
3348     if (hasPopup())
3349         return AccessibilityRole::PopUpButton;
3350     // We don&#39;t contemplate AccessibilityRole::RadioButton, as it depends on the input
3351     // type.
3352 
3353     return AccessibilityRole::Button;
</pre>
<hr />
<pre>
3435         }
3436     }
3437 
3438     bool result = computeAccessibilityIsIgnored();
3439 
3440     // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
3441     if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
3442         attributeCache-&gt;setIgnored(axObjectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);
3443 
3444     return result;
3445 }
3446 
3447 void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
3448 {
3449     Node* node = this-&gt;node();
3450     if (!node || !node-&gt;isElementNode())
3451         return;
3452 
3453     TreeScope&amp; treeScope = node-&gt;treeScope();
3454 
<span class="line-modified">3455     const AtomString&amp; idList = getAttribute(attribute);</span>
3456     if (idList.isEmpty())
3457         return;
3458 
3459     auto spaceSplitString = SpaceSplitString(idList, false);
3460     size_t length = spaceSplitString.size();
3461     for (size_t i = 0; i &lt; length; ++i) {
3462         if (auto* idElement = treeScope.getElementById(spaceSplitString[i]))
3463             elements.append(idElement);
3464     }
3465 }
3466 
3467 #if PLATFORM(COCOA)
3468 bool AccessibilityObject::preventKeyboardDOMEventDispatch() const
3469 {
3470     Frame* frame = this-&gt;frame();
3471     return frame &amp;&amp; frame-&gt;settings().preventKeyboardDOMEventDispatch();
3472 }
3473 
3474 void AccessibilityObject::setPreventKeyboardDOMEventDispatch(bool on)
3475 {
</pre>
<hr />
<pre>
3515 AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
3516 {
3517     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
3518         return object.isRadioGroup();
3519     }));
3520 }
3521 
3522 bool AccessibilityObject::isStyleFormatGroup() const
3523 {
3524     Node* node = this-&gt;node();
3525     if (!node)
3526         return false;
3527 
3528     return node-&gt;hasTagName(kbdTag) || node-&gt;hasTagName(codeTag)
3529     || node-&gt;hasTagName(preTag) || node-&gt;hasTagName(sampTag)
3530     || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
3531     || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
3532     || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
3533 }
3534 
<span class="line-modified">3535 bool AccessibilityObject::isFigureElement() const</span>






3536 {
3537     Node* node = this-&gt;node();
<span class="line-modified">3538     return node &amp;&amp; node-&gt;hasTagName(figureTag);</span>
3539 }
3540 
<span class="line-modified">3541 bool AccessibilityObject::isKeyboardFocusable() const</span>
3542 {
<span class="line-modified">3543     if (auto element = this-&gt;element())</span>
<span class="line-modified">3544         return element-&gt;isFocusable();</span>
<span class="line-added">3545     return false;</span>
3546 }
3547 
3548 bool AccessibilityObject::isOutput() const
3549 {
3550     Node* node = this-&gt;node();
3551     return node &amp;&amp; node-&gt;hasTagName(outputTag);
3552 }
3553 
3554 bool AccessibilityObject::isContainedByPasswordField() const
3555 {
3556     Node* node = this-&gt;node();
3557     if (!node)
3558         return false;
3559 
3560     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
3561         return false;
3562 
3563     Element* element = node-&gt;shadowHost();
3564     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
3565 }
</pre>
<hr />
<pre>
3579     Vector&lt;Element*&gt; elements;
3580     elementsFromAttribute(elements, attributeName);
3581     AXObjectCache* cache = axObjectCache();
3582     for (const auto&amp; element : elements) {
3583         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(element))
3584             children.append(axObject);
3585     }
3586 }
3587 
3588 void AccessibilityObject::ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp; elements, const QualifiedName&amp; attribute) const
3589 {
3590     auto id = identifierAttribute();
3591     if (id.isEmpty())
3592         return;
3593 
3594     AXObjectCache* cache = axObjectCache();
3595     if (!cache)
3596         return;
3597 
3598     for (auto&amp; element : descendantsOfType&lt;Element&gt;(node()-&gt;treeScope().rootNode())) {
<span class="line-modified">3599         const AtomString&amp; idList = element.attributeWithoutSynchronization(attribute);</span>
3600         if (!SpaceSplitString(idList, false).contains(id))
3601             continue;
3602 
3603         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(&amp;element))
3604             elements.append(axObject);
3605     }
3606 }
3607 
3608 bool AccessibilityObject::isActiveDescendantOfFocusedContainer() const
3609 {
3610     AccessibilityChildrenVector containers;
3611     ariaActiveDescendantReferencingElements(containers);
3612     for (auto&amp; container : containers) {
3613         if (container-&gt;isFocused())
3614             return true;
3615     }
3616 
3617     return false;
3618 }
3619 
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityNodeObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>