<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphicsContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext3D.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;DashArray.h&quot;
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;FontCascade.h&quot;
 32 #include &quot;Gradient.h&quot;
 33 #include &quot;GraphicsTypes.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;ImageOrientation.h&quot;

 36 #include &quot;Pattern.h&quot;
 37 #include &lt;wtf/Function.h&gt;
 38 #include &lt;wtf/Noncopyable.h&gt;
 39 
 40 #if USE(CG)
 41 typedef struct CGContext PlatformGraphicsContext;
 42 #elif USE(DIRECT2D)
 43 interface ID2D1DCRenderTarget;
 44 interface ID2D1RenderTarget;
 45 interface ID2D1Factory;
 46 interface ID2D1SolidColorBrush;
<span class="line-modified"> 47 typedef ID2D1RenderTarget PlatformGraphicsContext;</span>



 48 #elif USE(CAIRO)
 49 namespace WebCore {
 50 class PlatformContextCairo;
 51 }
 52 typedef WebCore::PlatformContextCairo PlatformGraphicsContext;
 53 #elif USE(WINGDI)
 54 typedef struct HDC__ PlatformGraphicsContext;
 55 #elif PLATFORM(JAVA)
 56 namespace WebCore {
 57 class PlatformContextJava;
 58 }
 59 typedef WebCore::PlatformContextJava PlatformGraphicsContext;
 60 #else
 61 typedef void PlatformGraphicsContext;
 62 #endif
 63 
 64 #if PLATFORM(WIN)
 65 #include &quot;DIBPixelData.h&quot;
 66 typedef struct HDC__* HDC;
 67 #if !USE(CG)
</pre>
<hr />
<pre>
154         StrokePatternChange                     = 1 &lt;&lt; 2,
155         FillGradientChange                      = 1 &lt;&lt; 3,
156         FillPatternChange                       = 1 &lt;&lt; 4,
157         StrokeThicknessChange                   = 1 &lt;&lt; 5,
158         StrokeColorChange                       = 1 &lt;&lt; 6,
159         StrokeStyleChange                       = 1 &lt;&lt; 7,
160         FillColorChange                         = 1 &lt;&lt; 8,
161         FillRuleChange                          = 1 &lt;&lt; 9,
162         ShadowChange                            = 1 &lt;&lt; 10,
163         ShadowColorChange                       = 1 &lt;&lt; 11,
164         ShadowsIgnoreTransformsChange           = 1 &lt;&lt; 12,
165         AlphaChange                             = 1 &lt;&lt; 13,
166         CompositeOperationChange                = 1 &lt;&lt; 14,
167         BlendModeChange                         = 1 &lt;&lt; 15,
168         TextDrawingModeChange                   = 1 &lt;&lt; 16,
169         ShouldAntialiasChange                   = 1 &lt;&lt; 17,
170         ShouldSmoothFontsChange                 = 1 &lt;&lt; 18,
171         ShouldSubpixelQuantizeFontsChange       = 1 &lt;&lt; 19,
172         DrawLuminanceMaskChange                 = 1 &lt;&lt; 20,
173         ImageInterpolationQualityChange         = 1 &lt;&lt; 21,



174     };
175     typedef uint32_t StateChangeFlags;
176 
177     RefPtr&lt;Gradient&gt; strokeGradient;
178     RefPtr&lt;Pattern&gt; strokePattern;
179 
180     RefPtr&lt;Gradient&gt; fillGradient;
181     RefPtr&lt;Pattern&gt; fillPattern;
182 
183     FloatSize shadowOffset;
184 
185     float strokeThickness { 0 };
186     float shadowBlur { 0 };
187 
188     TextDrawingModeFlags textDrawingMode { TextModeFill };
189 
190     Color strokeColor { Color::black };
191     Color fillColor { Color::black };
192     Color shadowColor;
193 
194     StrokeStyle strokeStyle { SolidStroke };
195     WindRule fillRule { WindRule::NonZero };
196 
197     float alpha { 1 };
198     CompositeOperator compositeOperator { CompositeSourceOver };
199     BlendMode blendMode { BlendMode::Normal };
200     InterpolationQuality imageInterpolationQuality { InterpolationDefault };
201 
202     bool shouldAntialias : 1;
203     bool shouldSmoothFonts : 1;
204     bool shouldSubpixelQuantizeFonts : 1;
205     bool shadowsIgnoreTransforms : 1;
206 #if USE(CG)
207     bool shadowsUseLegacyRadius : 1;
208 #endif
209 #if PLATFORM(JAVA)
210     AffineTransform transform;
211     FloatRect clipBounds;
212 #endif
213     bool drawLuminanceMask : 1;
<span class="line-modified">214 };</span>
<span class="line-modified">215 </span>
<span class="line-modified">216 struct ImagePaintingOptions {</span>
<span class="line-removed">217     ImagePaintingOptions(CompositeOperator compositeOperator = CompositeSourceOver, BlendMode blendMode = BlendMode::Normal, DecodingMode decodingMode = DecodingMode::Synchronous, ImageOrientationDescription orientationDescription = ImageOrientationDescription(), InterpolationQuality interpolationQuality = InterpolationDefault)</span>
<span class="line-removed">218         : m_compositeOperator(compositeOperator)</span>
<span class="line-removed">219         , m_blendMode(blendMode)</span>
<span class="line-removed">220         , m_decodingMode(decodingMode)</span>
<span class="line-removed">221         , m_orientationDescription(orientationDescription)</span>
<span class="line-removed">222         , m_interpolationQuality(interpolationQuality)</span>
<span class="line-removed">223     {</span>
<span class="line-removed">224     }</span>
<span class="line-removed">225 </span>
<span class="line-removed">226     ImagePaintingOptions(ImageOrientationDescription orientationDescription, InterpolationQuality interpolationQuality = InterpolationDefault, CompositeOperator compositeOperator = CompositeSourceOver, BlendMode blendMode = BlendMode::Normal, DecodingMode decodingMode = DecodingMode::Synchronous)</span>
<span class="line-removed">227         : m_compositeOperator(compositeOperator)</span>
<span class="line-removed">228         , m_blendMode(blendMode)</span>
<span class="line-removed">229         , m_decodingMode(decodingMode)</span>
<span class="line-removed">230         , m_orientationDescription(orientationDescription)</span>
<span class="line-removed">231         , m_interpolationQuality(interpolationQuality)</span>
<span class="line-removed">232     {</span>
<span class="line-removed">233     }</span>
<span class="line-removed">234 </span>
<span class="line-removed">235     ImagePaintingOptions(InterpolationQuality interpolationQuality, ImageOrientationDescription orientationDescription = ImageOrientationDescription(), CompositeOperator compositeOperator = CompositeSourceOver, BlendMode blendMode = BlendMode::Normal, DecodingMode decodingMode = DecodingMode::Synchronous)</span>
<span class="line-removed">236         : m_compositeOperator(compositeOperator)</span>
<span class="line-removed">237         , m_blendMode(blendMode)</span>
<span class="line-removed">238         , m_decodingMode(decodingMode)</span>
<span class="line-removed">239         , m_orientationDescription(orientationDescription)</span>
<span class="line-removed">240         , m_interpolationQuality(interpolationQuality)</span>
<span class="line-removed">241     {</span>
<span class="line-removed">242     }</span>
<span class="line-removed">243 </span>
<span class="line-removed">244     bool usesDefaultInterpolation() const { return m_interpolationQuality == InterpolationDefault; }</span>
<span class="line-removed">245 </span>
<span class="line-removed">246     CompositeOperator m_compositeOperator;</span>
<span class="line-removed">247     BlendMode m_blendMode;</span>
<span class="line-removed">248     DecodingMode m_decodingMode;</span>
<span class="line-removed">249     ImageOrientationDescription m_orientationDescription;</span>
<span class="line-removed">250     InterpolationQuality m_interpolationQuality;</span>
251 };
252 
253 struct GraphicsContextStateChange {
254     GraphicsContextStateChange() = default;
255     GraphicsContextStateChange(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
256         : m_state(state)
257         , m_changeFlags(flags)
258     {
259     }
260 
261     GraphicsContextState::StateChangeFlags changesFromState(const GraphicsContextState&amp;) const;
262 
263     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
264     void apply(GraphicsContext&amp;) const;
265 
266     void dump(WTF::TextStream&amp;) const;
267 
268     GraphicsContextState m_state;
269     GraphicsContextState::StateChangeFlags m_changeFlags { GraphicsContextState::NoChange };
270 };
</pre>
<hr />
<pre>
273 
274 
275 class GraphicsContext {
276     WTF_MAKE_NONCOPYABLE(GraphicsContext); WTF_MAKE_FAST_ALLOCATED;
277 public:
278     WEBCORE_EXPORT GraphicsContext(PlatformGraphicsContext*);
279 
280     using GraphicsContextImplFactory = WTF::Function&lt;std::unique_ptr&lt;GraphicsContextImpl&gt;(GraphicsContext&amp;)&gt;;
281     WEBCORE_EXPORT GraphicsContext(const GraphicsContextImplFactory&amp;);
282 
283     GraphicsContext() = default;
284     WEBCORE_EXPORT ~GraphicsContext();
285 
286     enum class PaintInvalidationReasons : uint8_t {
287         None,
288         InvalidatingControlTints,
289         InvalidatingImagesWithAsyncDecodes
290     };
291     GraphicsContext(PaintInvalidationReasons);
292 








293     WEBCORE_EXPORT bool hasPlatformContext() const;
294     WEBCORE_EXPORT PlatformGraphicsContext* platformContext() const;
295 
296     bool paintingDisabled() const { return !m_data &amp;&amp; !m_impl; }
297     bool performingPaintInvalidation() const { return m_paintInvalidationReasons != PaintInvalidationReasons::None; }
298     bool invalidatingControlTints() const { return m_paintInvalidationReasons == PaintInvalidationReasons::InvalidatingControlTints; }
299     bool invalidatingImagesWithAsyncDecodes() const { return m_paintInvalidationReasons == PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes; }
300 
301     WEBCORE_EXPORT void setStrokeThickness(float);
302     float strokeThickness() const { return m_state.strokeThickness; }
303 
304     void setStrokeStyle(StrokeStyle);
305     StrokeStyle strokeStyle() const { return m_state.strokeStyle; }
306 
307     WEBCORE_EXPORT void setStrokeColor(const Color&amp;);
308     const Color&amp; strokeColor() const { return m_state.strokeColor; }
309 
310     void setStrokePattern(Ref&lt;Pattern&gt;&amp;&amp;);
311     Pattern* strokePattern() const { return m_state.strokePattern.get(); }
312 
</pre>
<hr />
<pre>
325     WEBCORE_EXPORT void setFillGradient(Ref&lt;Gradient&gt;&amp;&amp;);
326     RefPtr&lt;Gradient&gt; fillGradient() const { return m_state.fillGradient; }
327 
328     void setShadowsIgnoreTransforms(bool);
329     bool shadowsIgnoreTransforms() const { return m_state.shadowsIgnoreTransforms; }
330 
331     WEBCORE_EXPORT void setShouldAntialias(bool);
332     bool shouldAntialias() const { return m_state.shouldAntialias; }
333 
334     WEBCORE_EXPORT void setShouldSmoothFonts(bool);
335     bool shouldSmoothFonts() const { return m_state.shouldSmoothFonts; }
336 
337     // Normally CG enables subpixel-quantization because it improves the performance of aligning glyphs.
338     // In some cases we have to disable to to ensure a high-quality output of the glyphs.
339     void setShouldSubpixelQuantizeFonts(bool);
340     bool shouldSubpixelQuantizeFonts() const { return m_state.shouldSubpixelQuantizeFonts; }
341 
342     const GraphicsContextState&amp; state() const { return m_state; }
343 
344 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
<span class="line-modified">345     WEBCORE_EXPORT void drawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, CompositeOperator = CompositeSourceOver, BlendMode = BlendMode::Normal, ImageOrientation = ImageOrientation());</span>
346 #endif
347 
348 #if USE(CG) || USE(DIRECT2D)
349     void applyStrokePattern();
350     void applyFillPattern();
351     void drawPath(const Path&amp;);
352 
353     WEBCORE_EXPORT void setIsCALayerContext(bool);
354     bool isCALayerContext() const;
355 
356     WEBCORE_EXPORT void setIsAcceleratedContext(bool);
357 #endif
358     bool isAcceleratedContext() const;
359     RenderingMode renderingMode() const { return isAcceleratedContext() ? Accelerated : Unaccelerated; }
360 
361     WEBCORE_EXPORT void save();
362     WEBCORE_EXPORT void restore();
363 


364     // These draw methods will do both stroking and filling.
365     // FIXME: ...except drawRect(), which fills properly but always strokes
366     // using a 1-pixel stroke inset from the rect borders (of the correct
367     // stroke color).
368     void drawRect(const FloatRect&amp;, float borderThickness = 1);
369     void drawLine(const FloatPoint&amp;, const FloatPoint&amp;);
370 
371     void drawEllipse(const FloatRect&amp;);
372     void drawRaisedEllipse(const FloatRect&amp;, const Color&amp; ellipseColor, const Color&amp; shadowColor);
373 
374     WEBCORE_EXPORT void fillPath(const Path&amp;);
375     WEBCORE_EXPORT void strokePath(const Path&amp;);
376 
377     void fillEllipse(const FloatRect&amp;);
378     void strokeEllipse(const FloatRect&amp;);
379 
380     WEBCORE_EXPORT void fillRect(const FloatRect&amp;);
381     WEBCORE_EXPORT void fillRect(const FloatRect&amp;, const Color&amp;);
382     void fillRect(const FloatRect&amp;, Gradient&amp;);
383     void fillRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode = BlendMode::Normal);
384     void fillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode = BlendMode::Normal);
385     void fillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp;);
386 
387     WEBCORE_EXPORT void clearRect(const FloatRect&amp;);
388 
389     WEBCORE_EXPORT void strokeRect(const FloatRect&amp;, float lineWidth);
390 
<span class="line-modified">391     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
<span class="line-modified">392     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
<span class="line-modified">393     ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
394 
<span class="line-modified">395     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
<span class="line-modified">396     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor,</span>
<span class="line-removed">397         Image::TileRule, Image::TileRule, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
398 
<span class="line-modified">399     WEBCORE_EXPORT void drawImageBuffer(ImageBuffer&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
<span class="line-modified">400     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
<span class="line-modified">401     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
402 
<span class="line-modified">403     void drawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, CompositeOperator, BlendMode = BlendMode::Normal);</span>
404 
<span class="line-modified">405     WEBCORE_EXPORT void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
<span class="line-modified">406     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
<span class="line-modified">407     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = ImagePaintingOptions());</span>
408 
409     WEBCORE_EXPORT void setImageInterpolationQuality(InterpolationQuality);
410     InterpolationQuality imageInterpolationQuality() const { return m_state.imageInterpolationQuality; }
411 
412     WEBCORE_EXPORT void clip(const FloatRect&amp;);
413     void clipRoundedRect(const FloatRoundedRect&amp;);
414 
415     void clipOut(const FloatRect&amp;);
416     void clipOutRoundedRect(const FloatRoundedRect&amp;);
417     void clipPath(const Path&amp;, WindRule = WindRule::EvenOdd);
418     void clipToImageBuffer(ImageBuffer&amp;, const FloatRect&amp;);
419 
420     IntRect clipBounds() const;
421 
422     void setTextDrawingMode(TextDrawingModeFlags);
423     TextDrawingModeFlags textDrawingMode() const { return m_state.textDrawingMode; }
424 





425     float drawText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
426     void drawGlyphs(const Font&amp;, const GlyphBuffer&amp;, unsigned from, unsigned numGlyphs, const FloatPoint&amp;, FontSmoothingMode);
<span class="line-modified">427     void drawEmphasisMarks(const FontCascade&amp;, const TextRun&amp;, const AtomicString&amp; mark, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);</span>
428     void drawBidiText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, FontCascade::CustomFontNotReadyAction = FontCascade::DoNotPaintIfFontNotReady);
429 
430     void applyState(const GraphicsContextState&amp;);
431 
432     enum RoundingMode {
433         RoundAllSides,
434         RoundOriginAndDimensions
435     };
436     FloatRect roundToDevicePixels(const FloatRect&amp;, RoundingMode = RoundAllSides);
437 
438     FloatRect computeUnderlineBoundsForText(const FloatRect&amp;, bool printing);
439     WEBCORE_EXPORT void drawLineForText(const FloatRect&amp;, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
440     void drawLinesForText(const FloatPoint&amp;, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
441     void drawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);
442 
443     WEBCORE_EXPORT void beginTransparencyLayer(float opacity);
444     WEBCORE_EXPORT void endTransparencyLayer();
445     bool isInTransparencyLayer() const { return (m_transparencyCount &gt; 0) &amp;&amp; supportsTransparencyLayers(); }
446 
447     WEBCORE_EXPORT void setShadow(const FloatSize&amp;, float blur, const Color&amp;);
</pre>
<hr />
<pre>
529     void paintTextField(const IntRect&amp; rect, unsigned state);
530     void drawBitmap(SharedBitmap*, const IntRect&amp; dstRect, const IntRect&amp; srcRect, CompositeOperator, BlendMode);
531     void drawBitmapPattern(SharedBitmap*, const FloatRect&amp; tileRectIn, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, CompositeOperator, const FloatRect&amp; destRect, const IntSize&amp; origSourceSize);
532     void drawIcon(HICON icon, const IntRect&amp; dstRect, UINT flags);
533     void drawRoundCorner(bool newClip, RECT clipRect, RECT rectWin, HDC dc, int width, int height);
534 #else
535     GraphicsContext(HDC, bool hasAlpha = false); // FIXME: To be removed.
536 
537     // When set to true, child windows should be rendered into this context
538     // rather than allowing them just to render to the screen. Defaults to
539     // false.
540     // FIXME: This is a layering violation. GraphicsContext shouldn&#39;t know
541     // what a &quot;window&quot; is. It would be much more appropriate for this flag
542     // to be passed as a parameter alongside the GraphicsContext, but doing
543     // that would require lots of changes in cross-platform code that we
544     // aren&#39;t sure we want to make.
545     void setShouldIncludeChildWindows(bool);
546     bool shouldIncludeChildWindows() const;
547 
548     class WindowsBitmap {

549         WTF_MAKE_NONCOPYABLE(WindowsBitmap);
550     public:
551         WindowsBitmap(HDC, const IntSize&amp;);
552         ~WindowsBitmap();
553 
554         HDC hdc() const { return m_hdc; }
555         UInt8* buffer() const { return m_pixelData.buffer(); }
556         unsigned bufferLength() const { return m_pixelData.bufferLength(); }
557         const IntSize&amp; size() const { return m_pixelData.size(); }
558         unsigned bytesPerRow() const { return m_pixelData.bytesPerRow(); }
559         unsigned short bitsPerPixel() const { return m_pixelData.bitsPerPixel(); }
560         const DIBPixelData&amp; windowsDIB() const { return m_pixelData; }
561 
562     private:
563         HDC m_hdc;
564         HBITMAP m_bitmap;
565         DIBPixelData m_pixelData;
566     };
567 
568     std::unique_ptr&lt;WindowsBitmap&gt; createWindowsBitmap(const IntSize&amp;);
</pre>
<hr />
<pre>
589     ID2D1SolidColorBrush* brushWithColor(const Color&amp;);
590 #endif
591 #else // PLATFORM(WIN)
592     bool shouldIncludeChildWindows() const { return false; }
593 #endif // PLATFORM(WIN)
594 
595     static void adjustLineToPixelBoundaries(FloatPoint&amp; p1, FloatPoint&amp; p2, float strokeWidth, StrokeStyle);
596 
597     bool supportsInternalLinks() const;
598 
599 private:
600     void platformInit(PlatformGraphicsContext*);
601     void platformDestroy();
602 
603 #if PLATFORM(WIN) &amp;&amp; !USE(WINGDI)
604     void platformInit(HDC, bool hasAlpha = false);
605 #endif
606 
607 #if USE(DIRECT2D)
608     void platformInit(HDC, ID2D1RenderTarget**, RECT, bool hasAlpha = false);
<span class="line-modified">609     void drawWithoutShadow(const FloatRect&amp; boundingRect, const WTF::Function&lt;void(ID2D1RenderTarget*)&gt;&amp;);</span>
<span class="line-removed">610     void drawWithShadow(const FloatRect&amp; boundingRect, const WTF::Function&lt;void(ID2D1RenderTarget*)&gt;&amp;);</span>
611 #endif
612 
613     void savePlatformState();
614     void restorePlatformState();
615 
616     void setPlatformTextDrawingMode(TextDrawingModeFlags);
617 
618     void setPlatformStrokeColor(const Color&amp;);
619     void setPlatformStrokeStyle(StrokeStyle);
620     void setPlatformStrokeThickness(float);
621 
622     void setPlatformFillColor(const Color&amp;);
623 
624     void setPlatformShouldAntialias(bool);
625     void setPlatformShouldSmoothFonts(bool);
626     void setPlatformImageInterpolationQuality(InterpolationQuality);
627 
628     void setPlatformShadow(const FloatSize&amp;, float blur, const Color&amp;);
629     void clearPlatformShadow();
630 
</pre>
<hr />
<pre>
681     {
682         ASSERT(!m_saveAndRestore);
683         m_context.save();
684         m_saveAndRestore = true;
685     }
686 
687     void restore()
688     {
689         ASSERT(m_saveAndRestore);
690         m_context.restore();
691         m_saveAndRestore = false;
692     }
693 
694     GraphicsContext* context() const { return &amp;m_context; }
695 
696 private:
697     GraphicsContext&amp; m_context;
698     bool m_saveAndRestore;
699 };
700 





















701 class InterpolationQualityMaintainer {
702 public:
703     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, InterpolationQuality interpolationQualityToUse)
704         : m_graphicsContext(graphicsContext)
705         , m_currentInterpolationQuality(graphicsContext.imageInterpolationQuality())
706         , m_interpolationQualityChanged(interpolationQualityToUse != InterpolationDefault &amp;&amp; m_currentInterpolationQuality != interpolationQualityToUse)
707     {
708         if (m_interpolationQualityChanged)
709             m_graphicsContext.setImageInterpolationQuality(interpolationQualityToUse);
710     }
711 
712     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, Optional&lt;InterpolationQuality&gt; interpolationQuality)
713         : InterpolationQualityMaintainer(graphicsContext, interpolationQuality ? interpolationQuality.value() : graphicsContext.imageInterpolationQuality())
714     {
715     }
716 
717     ~InterpolationQualityMaintainer()
718     {
719         if (m_interpolationQualityChanged)
720             m_graphicsContext.setImageInterpolationQuality(m_currentInterpolationQuality);
</pre>
</td>
<td>
<hr />
<pre>
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;DashArray.h&quot;
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;FontCascade.h&quot;
 32 #include &quot;Gradient.h&quot;
 33 #include &quot;GraphicsTypes.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;ImageOrientation.h&quot;
<span class="line-added"> 36 #include &quot;ImagePaintingOptions.h&quot;</span>
 37 #include &quot;Pattern.h&quot;
 38 #include &lt;wtf/Function.h&gt;
 39 #include &lt;wtf/Noncopyable.h&gt;
 40 
 41 #if USE(CG)
 42 typedef struct CGContext PlatformGraphicsContext;
 43 #elif USE(DIRECT2D)
 44 interface ID2D1DCRenderTarget;
 45 interface ID2D1RenderTarget;
 46 interface ID2D1Factory;
 47 interface ID2D1SolidColorBrush;
<span class="line-modified"> 48 namespace WebCore {</span>
<span class="line-added"> 49 class PlatformContextDirect2D;</span>
<span class="line-added"> 50 }</span>
<span class="line-added"> 51 typedef WebCore::PlatformContextDirect2D PlatformGraphicsContext;</span>
 52 #elif USE(CAIRO)
 53 namespace WebCore {
 54 class PlatformContextCairo;
 55 }
 56 typedef WebCore::PlatformContextCairo PlatformGraphicsContext;
 57 #elif USE(WINGDI)
 58 typedef struct HDC__ PlatformGraphicsContext;
 59 #elif PLATFORM(JAVA)
 60 namespace WebCore {
 61 class PlatformContextJava;
 62 }
 63 typedef WebCore::PlatformContextJava PlatformGraphicsContext;
 64 #else
 65 typedef void PlatformGraphicsContext;
 66 #endif
 67 
 68 #if PLATFORM(WIN)
 69 #include &quot;DIBPixelData.h&quot;
 70 typedef struct HDC__* HDC;
 71 #if !USE(CG)
</pre>
<hr />
<pre>
158         StrokePatternChange                     = 1 &lt;&lt; 2,
159         FillGradientChange                      = 1 &lt;&lt; 3,
160         FillPatternChange                       = 1 &lt;&lt; 4,
161         StrokeThicknessChange                   = 1 &lt;&lt; 5,
162         StrokeColorChange                       = 1 &lt;&lt; 6,
163         StrokeStyleChange                       = 1 &lt;&lt; 7,
164         FillColorChange                         = 1 &lt;&lt; 8,
165         FillRuleChange                          = 1 &lt;&lt; 9,
166         ShadowChange                            = 1 &lt;&lt; 10,
167         ShadowColorChange                       = 1 &lt;&lt; 11,
168         ShadowsIgnoreTransformsChange           = 1 &lt;&lt; 12,
169         AlphaChange                             = 1 &lt;&lt; 13,
170         CompositeOperationChange                = 1 &lt;&lt; 14,
171         BlendModeChange                         = 1 &lt;&lt; 15,
172         TextDrawingModeChange                   = 1 &lt;&lt; 16,
173         ShouldAntialiasChange                   = 1 &lt;&lt; 17,
174         ShouldSmoothFontsChange                 = 1 &lt;&lt; 18,
175         ShouldSubpixelQuantizeFontsChange       = 1 &lt;&lt; 19,
176         DrawLuminanceMaskChange                 = 1 &lt;&lt; 20,
177         ImageInterpolationQualityChange         = 1 &lt;&lt; 21,
<span class="line-added">178 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added">179         UseDarkAppearanceChange                 = 1 &lt;&lt; 22,</span>
<span class="line-added">180 #endif</span>
181     };
182     typedef uint32_t StateChangeFlags;
183 
184     RefPtr&lt;Gradient&gt; strokeGradient;
185     RefPtr&lt;Pattern&gt; strokePattern;
186 
187     RefPtr&lt;Gradient&gt; fillGradient;
188     RefPtr&lt;Pattern&gt; fillPattern;
189 
190     FloatSize shadowOffset;
191 
192     float strokeThickness { 0 };
193     float shadowBlur { 0 };
194 
195     TextDrawingModeFlags textDrawingMode { TextModeFill };
196 
197     Color strokeColor { Color::black };
198     Color fillColor { Color::black };
199     Color shadowColor;
200 
201     StrokeStyle strokeStyle { SolidStroke };
202     WindRule fillRule { WindRule::NonZero };
203 
204     float alpha { 1 };
205     CompositeOperator compositeOperator { CompositeSourceOver };
206     BlendMode blendMode { BlendMode::Normal };
207     InterpolationQuality imageInterpolationQuality { InterpolationDefault };
208 
209     bool shouldAntialias : 1;
210     bool shouldSmoothFonts : 1;
211     bool shouldSubpixelQuantizeFonts : 1;
212     bool shadowsIgnoreTransforms : 1;
213 #if USE(CG)
214     bool shadowsUseLegacyRadius : 1;
215 #endif
216 #if PLATFORM(JAVA)
217     AffineTransform transform;
218     FloatRect clipBounds;
219 #endif
220     bool drawLuminanceMask : 1;
<span class="line-modified">221 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-modified">222     bool useDarkAppearance : 1;</span>
<span class="line-modified">223 #endif</span>


































224 };
225 
226 struct GraphicsContextStateChange {
227     GraphicsContextStateChange() = default;
228     GraphicsContextStateChange(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
229         : m_state(state)
230         , m_changeFlags(flags)
231     {
232     }
233 
234     GraphicsContextState::StateChangeFlags changesFromState(const GraphicsContextState&amp;) const;
235 
236     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
237     void apply(GraphicsContext&amp;) const;
238 
239     void dump(WTF::TextStream&amp;) const;
240 
241     GraphicsContextState m_state;
242     GraphicsContextState::StateChangeFlags m_changeFlags { GraphicsContextState::NoChange };
243 };
</pre>
<hr />
<pre>
246 
247 
248 class GraphicsContext {
249     WTF_MAKE_NONCOPYABLE(GraphicsContext); WTF_MAKE_FAST_ALLOCATED;
250 public:
251     WEBCORE_EXPORT GraphicsContext(PlatformGraphicsContext*);
252 
253     using GraphicsContextImplFactory = WTF::Function&lt;std::unique_ptr&lt;GraphicsContextImpl&gt;(GraphicsContext&amp;)&gt;;
254     WEBCORE_EXPORT GraphicsContext(const GraphicsContextImplFactory&amp;);
255 
256     GraphicsContext() = default;
257     WEBCORE_EXPORT ~GraphicsContext();
258 
259     enum class PaintInvalidationReasons : uint8_t {
260         None,
261         InvalidatingControlTints,
262         InvalidatingImagesWithAsyncDecodes
263     };
264     GraphicsContext(PaintInvalidationReasons);
265 
<span class="line-added">266 #if USE(DIRECT2D)</span>
<span class="line-added">267     enum class BitmapRenderingContextType : uint8_t {</span>
<span class="line-added">268         CPUMemory,</span>
<span class="line-added">269         GPUMemory</span>
<span class="line-added">270     };</span>
<span class="line-added">271     WEBCORE_EXPORT GraphicsContext(PlatformGraphicsContext*, BitmapRenderingContextType);</span>
<span class="line-added">272 #endif</span>
<span class="line-added">273 </span>
274     WEBCORE_EXPORT bool hasPlatformContext() const;
275     WEBCORE_EXPORT PlatformGraphicsContext* platformContext() const;
276 
277     bool paintingDisabled() const { return !m_data &amp;&amp; !m_impl; }
278     bool performingPaintInvalidation() const { return m_paintInvalidationReasons != PaintInvalidationReasons::None; }
279     bool invalidatingControlTints() const { return m_paintInvalidationReasons == PaintInvalidationReasons::InvalidatingControlTints; }
280     bool invalidatingImagesWithAsyncDecodes() const { return m_paintInvalidationReasons == PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes; }
281 
282     WEBCORE_EXPORT void setStrokeThickness(float);
283     float strokeThickness() const { return m_state.strokeThickness; }
284 
285     void setStrokeStyle(StrokeStyle);
286     StrokeStyle strokeStyle() const { return m_state.strokeStyle; }
287 
288     WEBCORE_EXPORT void setStrokeColor(const Color&amp;);
289     const Color&amp; strokeColor() const { return m_state.strokeColor; }
290 
291     void setStrokePattern(Ref&lt;Pattern&gt;&amp;&amp;);
292     Pattern* strokePattern() const { return m_state.strokePattern.get(); }
293 
</pre>
<hr />
<pre>
306     WEBCORE_EXPORT void setFillGradient(Ref&lt;Gradient&gt;&amp;&amp;);
307     RefPtr&lt;Gradient&gt; fillGradient() const { return m_state.fillGradient; }
308 
309     void setShadowsIgnoreTransforms(bool);
310     bool shadowsIgnoreTransforms() const { return m_state.shadowsIgnoreTransforms; }
311 
312     WEBCORE_EXPORT void setShouldAntialias(bool);
313     bool shouldAntialias() const { return m_state.shouldAntialias; }
314 
315     WEBCORE_EXPORT void setShouldSmoothFonts(bool);
316     bool shouldSmoothFonts() const { return m_state.shouldSmoothFonts; }
317 
318     // Normally CG enables subpixel-quantization because it improves the performance of aligning glyphs.
319     // In some cases we have to disable to to ensure a high-quality output of the glyphs.
320     void setShouldSubpixelQuantizeFonts(bool);
321     bool shouldSubpixelQuantizeFonts() const { return m_state.shouldSubpixelQuantizeFonts; }
322 
323     const GraphicsContextState&amp; state() const { return m_state; }
324 
325 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
<span class="line-modified">326     WEBCORE_EXPORT void drawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; = { });</span>
327 #endif
328 
329 #if USE(CG) || USE(DIRECT2D)
330     void applyStrokePattern();
331     void applyFillPattern();
332     void drawPath(const Path&amp;);
333 
334     WEBCORE_EXPORT void setIsCALayerContext(bool);
335     bool isCALayerContext() const;
336 
337     WEBCORE_EXPORT void setIsAcceleratedContext(bool);
338 #endif
339     bool isAcceleratedContext() const;
340     RenderingMode renderingMode() const { return isAcceleratedContext() ? Accelerated : Unaccelerated; }
341 
342     WEBCORE_EXPORT void save();
343     WEBCORE_EXPORT void restore();
344 
<span class="line-added">345     unsigned stackSize() const { return m_stack.size(); }</span>
<span class="line-added">346 </span>
347     // These draw methods will do both stroking and filling.
348     // FIXME: ...except drawRect(), which fills properly but always strokes
349     // using a 1-pixel stroke inset from the rect borders (of the correct
350     // stroke color).
351     void drawRect(const FloatRect&amp;, float borderThickness = 1);
352     void drawLine(const FloatPoint&amp;, const FloatPoint&amp;);
353 
354     void drawEllipse(const FloatRect&amp;);
355     void drawRaisedEllipse(const FloatRect&amp;, const Color&amp; ellipseColor, const Color&amp; shadowColor);
356 
357     WEBCORE_EXPORT void fillPath(const Path&amp;);
358     WEBCORE_EXPORT void strokePath(const Path&amp;);
359 
360     void fillEllipse(const FloatRect&amp;);
361     void strokeEllipse(const FloatRect&amp;);
362 
363     WEBCORE_EXPORT void fillRect(const FloatRect&amp;);
364     WEBCORE_EXPORT void fillRect(const FloatRect&amp;, const Color&amp;);
365     void fillRect(const FloatRect&amp;, Gradient&amp;);
366     void fillRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode = BlendMode::Normal);
367     void fillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode = BlendMode::Normal);
368     void fillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp;);
369 
370     WEBCORE_EXPORT void clearRect(const FloatRect&amp;);
371 
372     WEBCORE_EXPORT void strokeRect(const FloatRect&amp;, float lineWidth);
373 
<span class="line-modified">374     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">375     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">376     ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });</span>
377 
<span class="line-modified">378     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">379     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule, Image::TileRule, const ImagePaintingOptions&amp; = { });</span>

380 
<span class="line-modified">381     WEBCORE_EXPORT void drawImageBuffer(ImageBuffer&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">382     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">383     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });</span>
384 
<span class="line-modified">385     void drawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });</span>
386 
<span class="line-modified">387     WEBCORE_EXPORT void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">388     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">389     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });</span>
390 
391     WEBCORE_EXPORT void setImageInterpolationQuality(InterpolationQuality);
392     InterpolationQuality imageInterpolationQuality() const { return m_state.imageInterpolationQuality; }
393 
394     WEBCORE_EXPORT void clip(const FloatRect&amp;);
395     void clipRoundedRect(const FloatRoundedRect&amp;);
396 
397     void clipOut(const FloatRect&amp;);
398     void clipOutRoundedRect(const FloatRoundedRect&amp;);
399     void clipPath(const Path&amp;, WindRule = WindRule::EvenOdd);
400     void clipToImageBuffer(ImageBuffer&amp;, const FloatRect&amp;);
401 
402     IntRect clipBounds() const;
403 
404     void setTextDrawingMode(TextDrawingModeFlags);
405     TextDrawingModeFlags textDrawingMode() const { return m_state.textDrawingMode; }
406 
<span class="line-added">407 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added">408     void setUseDarkAppearance(bool);</span>
<span class="line-added">409     bool useDarkAppearance() const { return m_state.useDarkAppearance; }</span>
<span class="line-added">410 #endif</span>
<span class="line-added">411 </span>
412     float drawText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
413     void drawGlyphs(const Font&amp;, const GlyphBuffer&amp;, unsigned from, unsigned numGlyphs, const FloatPoint&amp;, FontSmoothingMode);
<span class="line-modified">414     void drawEmphasisMarks(const FontCascade&amp;, const TextRun&amp;, const AtomString&amp; mark, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);</span>
415     void drawBidiText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, FontCascade::CustomFontNotReadyAction = FontCascade::DoNotPaintIfFontNotReady);
416 
417     void applyState(const GraphicsContextState&amp;);
418 
419     enum RoundingMode {
420         RoundAllSides,
421         RoundOriginAndDimensions
422     };
423     FloatRect roundToDevicePixels(const FloatRect&amp;, RoundingMode = RoundAllSides);
424 
425     FloatRect computeUnderlineBoundsForText(const FloatRect&amp;, bool printing);
426     WEBCORE_EXPORT void drawLineForText(const FloatRect&amp;, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
427     void drawLinesForText(const FloatPoint&amp;, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
428     void drawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);
429 
430     WEBCORE_EXPORT void beginTransparencyLayer(float opacity);
431     WEBCORE_EXPORT void endTransparencyLayer();
432     bool isInTransparencyLayer() const { return (m_transparencyCount &gt; 0) &amp;&amp; supportsTransparencyLayers(); }
433 
434     WEBCORE_EXPORT void setShadow(const FloatSize&amp;, float blur, const Color&amp;);
</pre>
<hr />
<pre>
516     void paintTextField(const IntRect&amp; rect, unsigned state);
517     void drawBitmap(SharedBitmap*, const IntRect&amp; dstRect, const IntRect&amp; srcRect, CompositeOperator, BlendMode);
518     void drawBitmapPattern(SharedBitmap*, const FloatRect&amp; tileRectIn, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, CompositeOperator, const FloatRect&amp; destRect, const IntSize&amp; origSourceSize);
519     void drawIcon(HICON icon, const IntRect&amp; dstRect, UINT flags);
520     void drawRoundCorner(bool newClip, RECT clipRect, RECT rectWin, HDC dc, int width, int height);
521 #else
522     GraphicsContext(HDC, bool hasAlpha = false); // FIXME: To be removed.
523 
524     // When set to true, child windows should be rendered into this context
525     // rather than allowing them just to render to the screen. Defaults to
526     // false.
527     // FIXME: This is a layering violation. GraphicsContext shouldn&#39;t know
528     // what a &quot;window&quot; is. It would be much more appropriate for this flag
529     // to be passed as a parameter alongside the GraphicsContext, but doing
530     // that would require lots of changes in cross-platform code that we
531     // aren&#39;t sure we want to make.
532     void setShouldIncludeChildWindows(bool);
533     bool shouldIncludeChildWindows() const;
534 
535     class WindowsBitmap {
<span class="line-added">536         WTF_MAKE_FAST_ALLOCATED;</span>
537         WTF_MAKE_NONCOPYABLE(WindowsBitmap);
538     public:
539         WindowsBitmap(HDC, const IntSize&amp;);
540         ~WindowsBitmap();
541 
542         HDC hdc() const { return m_hdc; }
543         UInt8* buffer() const { return m_pixelData.buffer(); }
544         unsigned bufferLength() const { return m_pixelData.bufferLength(); }
545         const IntSize&amp; size() const { return m_pixelData.size(); }
546         unsigned bytesPerRow() const { return m_pixelData.bytesPerRow(); }
547         unsigned short bitsPerPixel() const { return m_pixelData.bitsPerPixel(); }
548         const DIBPixelData&amp; windowsDIB() const { return m_pixelData; }
549 
550     private:
551         HDC m_hdc;
552         HBITMAP m_bitmap;
553         DIBPixelData m_pixelData;
554     };
555 
556     std::unique_ptr&lt;WindowsBitmap&gt; createWindowsBitmap(const IntSize&amp;);
</pre>
<hr />
<pre>
577     ID2D1SolidColorBrush* brushWithColor(const Color&amp;);
578 #endif
579 #else // PLATFORM(WIN)
580     bool shouldIncludeChildWindows() const { return false; }
581 #endif // PLATFORM(WIN)
582 
583     static void adjustLineToPixelBoundaries(FloatPoint&amp; p1, FloatPoint&amp; p2, float strokeWidth, StrokeStyle);
584 
585     bool supportsInternalLinks() const;
586 
587 private:
588     void platformInit(PlatformGraphicsContext*);
589     void platformDestroy();
590 
591 #if PLATFORM(WIN) &amp;&amp; !USE(WINGDI)
592     void platformInit(HDC, bool hasAlpha = false);
593 #endif
594 
595 #if USE(DIRECT2D)
596     void platformInit(HDC, ID2D1RenderTarget**, RECT, bool hasAlpha = false);
<span class="line-modified">597     void platformInit(PlatformContextDirect2D*, BitmapRenderingContextType);</span>

598 #endif
599 
600     void savePlatformState();
601     void restorePlatformState();
602 
603     void setPlatformTextDrawingMode(TextDrawingModeFlags);
604 
605     void setPlatformStrokeColor(const Color&amp;);
606     void setPlatformStrokeStyle(StrokeStyle);
607     void setPlatformStrokeThickness(float);
608 
609     void setPlatformFillColor(const Color&amp;);
610 
611     void setPlatformShouldAntialias(bool);
612     void setPlatformShouldSmoothFonts(bool);
613     void setPlatformImageInterpolationQuality(InterpolationQuality);
614 
615     void setPlatformShadow(const FloatSize&amp;, float blur, const Color&amp;);
616     void clearPlatformShadow();
617 
</pre>
<hr />
<pre>
668     {
669         ASSERT(!m_saveAndRestore);
670         m_context.save();
671         m_saveAndRestore = true;
672     }
673 
674     void restore()
675     {
676         ASSERT(m_saveAndRestore);
677         m_context.restore();
678         m_saveAndRestore = false;
679     }
680 
681     GraphicsContext* context() const { return &amp;m_context; }
682 
683 private:
684     GraphicsContext&amp; m_context;
685     bool m_saveAndRestore;
686 };
687 
<span class="line-added">688 </span>
<span class="line-added">689 class GraphicsContextStateStackChecker {</span>
<span class="line-added">690 public:</span>
<span class="line-added">691     GraphicsContextStateStackChecker(GraphicsContext&amp; context)</span>
<span class="line-added">692         : m_context(context)</span>
<span class="line-added">693         , m_stackSize(context.stackSize())</span>
<span class="line-added">694     { }</span>
<span class="line-added">695 </span>
<span class="line-added">696     ~GraphicsContextStateStackChecker()</span>
<span class="line-added">697     {</span>
<span class="line-added">698         if (m_context.stackSize() != m_stackSize)</span>
<span class="line-added">699             WTFLogAlways(&quot;GraphicsContext %p stack changed by %d&quot;, this, (int)m_context.stackSize() - (int)m_stackSize);</span>
<span class="line-added">700     }</span>
<span class="line-added">701 </span>
<span class="line-added">702 private:</span>
<span class="line-added">703     GraphicsContext&amp; m_context;</span>
<span class="line-added">704     unsigned m_stackSize;</span>
<span class="line-added">705 };</span>
<span class="line-added">706 </span>
<span class="line-added">707 </span>
<span class="line-added">708 </span>
709 class InterpolationQualityMaintainer {
710 public:
711     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, InterpolationQuality interpolationQualityToUse)
712         : m_graphicsContext(graphicsContext)
713         , m_currentInterpolationQuality(graphicsContext.imageInterpolationQuality())
714         , m_interpolationQualityChanged(interpolationQualityToUse != InterpolationDefault &amp;&amp; m_currentInterpolationQuality != interpolationQualityToUse)
715     {
716         if (m_interpolationQualityChanged)
717             m_graphicsContext.setImageInterpolationQuality(interpolationQualityToUse);
718     }
719 
720     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, Optional&lt;InterpolationQuality&gt; interpolationQuality)
721         : InterpolationQualityMaintainer(graphicsContext, interpolationQuality ? interpolationQuality.value() : graphicsContext.imageInterpolationQuality())
722     {
723     }
724 
725     ~InterpolationQualityMaintainer()
726     {
727         if (m_interpolationQualityChanged)
728             m_graphicsContext.setImageInterpolationQuality(m_currentInterpolationQuality);
</pre>
</td>
</tr>
</table>
<center><a href="GraphicsContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext3D.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>