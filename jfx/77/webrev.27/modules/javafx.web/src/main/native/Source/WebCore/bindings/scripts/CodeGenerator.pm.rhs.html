<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGenerator.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 #
   2 # WebKit IDL parser
   3 #
   4 # Copyright (C) 2005 Nikolas Zimmermann &lt;wildfox@kde.org&gt;
   5 # Copyright (C) 2006 Samuel Weinig &lt;sam.weinig@gmail.com&gt;
   6 # Copyright (C) 2007, 2008, 2009, 2010 Apple Inc. All rights reserved.
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  10 #
  11 # This library is free software; you can redistribute it and/or
  12 # modify it under the terms of the GNU Library General Public
  13 # License as published by the Free Software Foundation; either
  14 # version 2 of the License, or (at your option) any later version.
  15 #
  16 # This library is distributed in the hope that it will be useful,
  17 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  18 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19 # Library General Public License for more details.
  20 #
  21 # You should have received a copy of the GNU Library General Public License
  22 # along with this library; see the file COPYING.LIB.  If not, write to
  23 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24 # Boston, MA 02110-1301, USA.
  25 #
  26 
  27 package CodeGenerator;
  28 
  29 use strict;
  30 
  31 use File::Basename;
  32 use File::Find;
  33 use Carp qw&lt;longmess&gt;;
  34 use Data::Dumper;
  35 
  36 my $useDocument = &quot;&quot;;
  37 my $useGenerator = &quot;&quot;;
  38 my $useOutputDir = &quot;&quot;;
  39 my $useOutputHeadersDir = &quot;&quot;;
  40 my $useDirectories = &quot;&quot;;
  41 my $preprocessor;
  42 my $idlAttributes;
  43 my $writeDependencies = 0;
  44 my $defines = &quot;&quot;;
  45 my $targetIdlFilePath = &quot;&quot;;
  46 
  47 my $codeGenerator = 0;
  48 
  49 my $verbose = 0;
  50 
  51 my %integerTypeHash = (
  52     &quot;byte&quot; =&gt; 1,
  53     &quot;long long&quot; =&gt; 1,
  54     &quot;long&quot; =&gt; 1,
  55     &quot;octet&quot; =&gt; 1,
  56     &quot;short&quot; =&gt; 1,
  57     &quot;unsigned long long&quot; =&gt; 1,
  58     &quot;unsigned long&quot; =&gt; 1,
  59     &quot;unsigned short&quot; =&gt; 1,
  60 );
  61 
  62 my %floatingPointTypeHash = (
  63     &quot;float&quot; =&gt; 1,
  64     &quot;unrestricted float&quot; =&gt; 1,
  65     &quot;double&quot; =&gt; 1,
  66     &quot;unrestricted double&quot; =&gt; 1,
  67 );
  68 
  69 my %stringTypeHash = (
  70     &quot;ByteString&quot; =&gt; 1,
  71     &quot;DOMString&quot; =&gt; 1,
  72     &quot;USVString&quot; =&gt; 1,
  73 );
  74 
  75 my %bufferSourceTypes = (
  76     &quot;ArrayBuffer&quot; =&gt; 1,
  77     &quot;ArrayBufferView&quot; =&gt; 1,
  78     &quot;DataView&quot; =&gt; 1,
  79     &quot;Float32Array&quot; =&gt; 1,
  80     &quot;Float64Array&quot; =&gt; 1,
  81     &quot;Int16Array&quot; =&gt; 1,
  82     &quot;Int32Array&quot; =&gt; 1,
  83     &quot;Int8Array&quot; =&gt; 1,
  84     &quot;Uint16Array&quot; =&gt; 1,
  85     &quot;Uint32Array&quot; =&gt; 1,
  86     &quot;Uint8Array&quot; =&gt; 1,
  87     &quot;Uint8ClampedArray&quot; =&gt; 1,
  88 );
  89 
  90 my %primitiveTypeHash = ( 
  91     &quot;boolean&quot; =&gt; 1, 
  92     &quot;void&quot; =&gt; 1,
  93     &quot;Date&quot; =&gt; 1
  94 );
  95 
  96 my %dictionaryTypeImplementationNameOverrides = ();
  97 my %enumTypeImplementationNameOverrides = ();
  98 
  99 my %svgAttributesInHTMLHash = (
 100     &quot;class&quot; =&gt; 1,
 101     &quot;id&quot; =&gt; 1,
 102     &quot;onabort&quot; =&gt; 1,
 103     &quot;onclick&quot; =&gt; 1,
 104     &quot;onerror&quot; =&gt; 1,
 105     &quot;onload&quot; =&gt; 1,
 106     &quot;onmousedown&quot; =&gt; 1,
 107     &quot;onmouseenter&quot; =&gt; 1,
 108     &quot;onmouseleave&quot; =&gt; 1,
 109     &quot;onmousemove&quot; =&gt; 1,
 110     &quot;onmouseout&quot; =&gt; 1,
 111     &quot;onmouseover&quot; =&gt; 1,
 112     &quot;onmouseup&quot; =&gt; 1,
 113     &quot;onresize&quot; =&gt; 1,
 114     &quot;onscroll&quot; =&gt; 1,
 115     &quot;onunload&quot; =&gt; 1,
 116 );
 117 
 118 # Cache of IDL file pathnames.
 119 my $idlFiles;
 120 my $cachedInterfaces = {};
 121 my $cachedExternalDictionaries = {};
 122 my $cachedExternalEnumerations = {};
 123 my $cachedTypes = {};
 124 
 125 sub assert
 126 {
 127     my $message = shift;
 128     
 129     my $mess = longmess();
 130     print Dumper($mess);
 131 
 132     die $message;
 133 }
 134 
 135 # Default constructor
 136 sub new
 137 {
 138     my $object = shift;
 139     my $reference = { };
 140 
 141     $useDirectories = shift;
 142     $useGenerator = shift;
 143     $useOutputDir = shift;
 144     $useOutputHeadersDir = shift;
 145     $preprocessor = shift;
 146     $writeDependencies = shift;
 147     $verbose = shift;
 148     $targetIdlFilePath = shift;
 149     $idlAttributes = shift;
 150 
 151     bless($reference, $object);
 152     return $reference;
 153 }
 154 
 155 sub ProcessDocument
 156 {
 157     my $object = shift;
 158     $useDocument = shift;
 159     $defines = shift;
 160 
 161     my $ifaceName = &quot;CodeGenerator&quot; . $useGenerator;
 162     require $ifaceName . &quot;.pm&quot;;
 163 
 164     foreach my $dictionary (@{$useDocument-&gt;dictionaries}) {
 165         if ($dictionary-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 166             $dictionaryTypeImplementationNameOverrides{$dictionary-&gt;type-&gt;name} = $dictionary-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 167         }
 168     }
 169 
 170     foreach my $enumeration (@{$useDocument-&gt;enumerations}) {
 171         if ($enumeration-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 172             $enumTypeImplementationNameOverrides{$enumeration-&gt;type-&gt;name} = $enumeration-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 173         }
 174     }
 175 
 176     # Dynamically load external code generation perl module
 177     $codeGenerator = $ifaceName-&gt;new($object, $writeDependencies, $verbose, $targetIdlFilePath);
 178     unless (defined($codeGenerator)) {
 179         my $interfaces = $useDocument-&gt;interfaces;
 180         foreach my $interface (@$interfaces) {
 181             print &quot;Skipping $useGenerator code generation for IDL interface \&quot;&quot; . $interface-&gt;type-&gt;name . &quot;\&quot;.\n&quot; if $verbose;
 182         }
 183         return;
 184     }
 185 
 186     my $interfaces = $useDocument-&gt;interfaces;
 187     if (@$interfaces) {
 188         die &quot;Multiple interfaces per document are not supported&quot; if @$interfaces &gt; 1;
 189 
 190         my $interface = @$interfaces[0];
 191         print &quot;Generating $useGenerator bindings code for IDL interface \&quot;&quot; . $interface-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 192         $codeGenerator-&gt;GenerateInterface($interface, $defines, $useDocument-&gt;enumerations, $useDocument-&gt;dictionaries);
 193         $codeGenerator-&gt;WriteData($interface, $useOutputDir, $useOutputHeadersDir);
 194         return;
 195     }
 196 
 197     my $callbackFunctions = $useDocument-&gt;callbackFunctions;
 198     if (@$callbackFunctions) {
 199         die &quot;Multiple standalone callback functions per document are not supported&quot; if @$callbackFunctions &gt; 1;
 200 
 201         my $callbackFunction = @$callbackFunctions[0];
 202         print &quot;Generating $useGenerator bindings code for IDL callback function \&quot;&quot; . $callbackFunction-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 203         $codeGenerator-&gt;GenerateCallbackFunction($callbackFunction, $useDocument-&gt;enumerations, $useDocument-&gt;dictionaries);
 204         $codeGenerator-&gt;WriteData($callbackFunction, $useOutputDir, $useOutputHeadersDir);
 205         return;
 206     }
 207 
 208     my $dictionaries = $useDocument-&gt;dictionaries;
 209     if (@$dictionaries) {
 210         my $dictionary;
 211         my $otherDictionaries;
 212         if (@$dictionaries == 1) {
 213             $dictionary = @$dictionaries[0];
 214         } else {
 215             my $primaryDictionaryName = fileparse($targetIdlFilePath, &quot;.idl&quot;);
 216             for my $candidate (@$dictionaries) {
 217                 if ($candidate-&gt;type-&gt;name eq $primaryDictionaryName) {
 218                     $dictionary = $candidate;
 219                 } else {
 220                     push @$otherDictionaries, $candidate;
 221                 }
 222             }
 223             die &quot;Multiple dictionaries per document are only supported if one matches the filename&quot; unless $dictionary;
 224         }
 225 
 226         print &quot;Generating $useGenerator bindings code for IDL dictionary \&quot;&quot; . $dictionary-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 227         $codeGenerator-&gt;GenerateDictionary($dictionary, $useDocument-&gt;enumerations, $otherDictionaries);
 228         $codeGenerator-&gt;WriteData($dictionary, $useOutputDir, $useOutputHeadersDir);
 229         return;
 230     }
 231     
 232     my $enumerations = $useDocument-&gt;enumerations;
 233     if (@$enumerations) {
 234         die &quot;Multiple standalone enumerations per document are not supported&quot; if @$enumerations &gt; 1;
 235 
 236         my $enumeration = @$enumerations[0];
 237         print &quot;Generating $useGenerator bindings code for IDL enumeration \&quot;&quot; . $enumeration-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 238         $codeGenerator-&gt;GenerateEnumeration($enumeration);
 239         $codeGenerator-&gt;WriteData($enumeration, $useOutputDir, $useOutputHeadersDir);
 240         return;
 241     }
 242 
 243     die &quot;Processing document &quot; . $useDocument-&gt;fileName . &quot; did not generate anything&quot;
 244 }
 245 
 246 sub FileNamePrefix
 247 {
 248     my $object = shift;
 249 
 250     my $ifaceName = &quot;CodeGenerator&quot; . $useGenerator;
 251     require $ifaceName . &quot;.pm&quot;;
 252 
 253     # Dynamically load external code generation perl module
 254     $codeGenerator = $ifaceName-&gt;new($object, $writeDependencies, $verbose);
 255     return $codeGenerator-&gt;FileNamePrefix();
 256 }
 257 
 258 sub UpdateFile
 259 {
 260     my $object = shift;
 261     my $fileName = shift;
 262     my $contents = shift;
 263 
 264     # FIXME: We should only write content if it is different from what is in the file.
 265     # But that would mean running more often the binding generator, see https://bugs.webkit.org/show_bug.cgi?id=131756
 266     open FH, &quot;&gt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
 267     print FH $contents;
 268     close FH;
 269 }
 270 
 271 sub ForAllParents
 272 {
 273     my $object = shift;
 274     my $interface = shift;
 275     my $beforeRecursion = shift;
 276     my $afterRecursion = shift;
 277 
 278     my $recurse;
 279     $recurse = sub {
 280         my $outerInterface = shift;
 281         my $currentInterface = shift;
 282 
 283         if  ($currentInterface-&gt;parentType) {
 284             my $interfaceName = $currentInterface-&gt;parentType-&gt;name;
 285             my $parentInterface = $object-&gt;ParseInterface($outerInterface, $interfaceName);
 286 
 287             if ($beforeRecursion) {
 288                 &amp;$beforeRecursion($parentInterface) eq &#39;prune&#39; and next;
 289             }
 290             &amp;$recurse($outerInterface, $parentInterface);
 291             &amp;$afterRecursion($parentInterface) if $afterRecursion;
 292         }
 293     };
 294 
 295     &amp;$recurse($interface, $interface);
 296 }
 297 
 298 sub IDLFileForInterface
 299 {
 300     my $object = shift;
 301     my $interfaceName = shift;
 302 
 303     unless ($idlFiles) {
 304         my $sourceRoot = $ENV{SOURCE_ROOT};
 305         my @directories = map { $_ = &quot;$sourceRoot/$_&quot; if $sourceRoot &amp;&amp; -d &quot;$sourceRoot/$_&quot;; $_ } @$useDirectories;
 306         push(@directories, &quot;.&quot;);
 307 
 308         $idlFiles = { };
 309 
 310         my $wanted = sub {
 311             $idlFiles-&gt;{$1} = $File::Find::name if /^([A-Z].*)\.idl$/;
 312             $File::Find::prune = 1 if /^\../;
 313         };
 314         find($wanted, @directories);
 315     }
 316 
 317     return $idlFiles-&gt;{$interfaceName};
 318 }
 319 
 320 sub GetInterfaceForType
 321 {
 322     my ($object, $currentInterface, $type) = @_;
 323 
 324     return undef unless $object-&gt;IsInterfaceType($type);
 325 
 326     return $object-&gt;ParseInterface($currentInterface, $type-&gt;name);
 327 }
 328 
 329 sub GetAttributeFromInterface
 330 {
 331     my ($object, $outerInterface, $interfaceName, $attributeName) = @_;
 332 
 333     my $interface = $object-&gt;ParseInterface($outerInterface, $interfaceName);
 334     for my $attribute (@{$interface-&gt;attributes}) {
 335         return $attribute if $attribute-&gt;name eq $attributeName;
 336     }
 337     die(&quot;Could not find attribute &#39;$attributeName&#39; on interface &#39;$interfaceName&#39;.&quot;);
 338 }
 339 
 340 sub ParseInterface
 341 {
 342     my $object = shift;
 343     my $outerInterface = shift;
 344     my $interfaceName = shift;
 345 
 346     return undef if $interfaceName eq &#39;Object&#39;;
 347     return undef if $interfaceName eq &#39;UNION&#39;;
 348 
 349     if (exists $cachedInterfaces-&gt;{$interfaceName}) {
 350         return $cachedInterfaces-&gt;{$interfaceName};
 351     }
 352 
 353     # Step #1: Find the IDL file associated with &#39;interface&#39;
 354     my $filename = $object-&gt;IDLFileForInterface($interfaceName)
 355         or assert(&quot;Could NOT find IDL file for interface \&quot;$interfaceName\&quot;, reachable from \&quot;&quot; . $outerInterface-&gt;type-&gt;name . &quot;\&quot;!\n&quot;);
 356 
 357     print &quot;  |  |&gt;  Parsing parent IDL \&quot;$filename\&quot; for interface \&quot;$interfaceName\&quot;\n&quot; if $verbose;
 358 
 359     # Step #2: Parse the found IDL file (in quiet mode).
 360     my $parser = IDLParser-&gt;new(1);
 361     my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 362 
 363     foreach my $interface (@{$document-&gt;interfaces}) {
 364         if ($interface-&gt;type-&gt;name eq $interfaceName) {
 365             $cachedInterfaces-&gt;{$interfaceName} = $interface;
 366             return $interface;
 367         }
 368     }
 369 
 370     die(&quot;Could NOT find interface definition for $interfaceName in $filename&quot;);
 371 }
 372 
 373 sub ParseType
 374 {
 375     my ($object, $typeString) = @_;
 376 
 377     return $cachedTypes-&gt;{$typeString} if exists($cachedTypes-&gt;{$typeString});
 378 
 379     my $parser = IDLParser-&gt;new(1);
 380     my $type = $parser-&gt;ParseType($typeString, $idlAttributes);
 381 
 382     $cachedTypes-&gt;{$typeString} = $type;
 383 
 384     return $type;
 385 }
 386 
 387 # Helpers for all CodeGenerator***.pm modules
 388 
 389 sub IsNumericType
 390 {
 391     my ($object, $type) = @_;
 392 
 393     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 394 
 395     return 1 if $integerTypeHash{$type-&gt;name};
 396     return 1 if $floatingPointTypeHash{$type-&gt;name};
 397     return 0;
 398 }
 399 
 400 sub IsStringOrEnumType
 401 {
 402     my ($object, $type) = @_;
 403     
 404     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 405 
 406     return 1 if $object-&gt;IsStringType($type);
 407     return 1 if $object-&gt;IsEnumType($type);
 408     return 0;
 409 }
 410 
 411 sub IsIntegerType
 412 {
 413     my ($object, $type) = @_;
 414 
 415     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 416 
 417     return 1 if $integerTypeHash{$type-&gt;name};
 418     return 0;
 419 }
 420 
 421 sub IsFloatingPointType
 422 {
 423     my ($object, $type) = @_;
 424 
 425     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 426 
 427     return 1 if $floatingPointTypeHash{$type-&gt;name};
 428     return 0;
 429 }
 430 
 431 sub IsPrimitiveType
 432 {
 433     my ($object, $type) = @_;
 434 
 435     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 436 
 437     return 1 if $primitiveTypeHash{$type-&gt;name};
 438     return 1 if $object-&gt;IsNumericType($type);
 439     return 0;
 440 }
 441 
 442 sub IsStringType
 443 {
 444     my ($object, $type) = @_;
 445 
 446     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 447 
 448     return 1 if $stringTypeHash{$type-&gt;name};
 449     return 0;
 450 }
 451 
 452 sub IsEnumType
 453 {
 454     my ($object, $type) = @_;
 455 
 456     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 457 
 458     return defined($object-&gt;GetEnumByType($type));
 459 }
 460 
 461 sub GetEnumByType
 462 {
 463     my ($object, $type) = @_;
 464 
 465     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 466 
 467     my $name = $type-&gt;name;
 468 
 469     die &quot;GetEnumByType() was called with an undefined enumeration name&quot; unless defined($name);
 470 
 471     for my $enumeration (@{$useDocument-&gt;enumerations}) {
 472         return $enumeration if $enumeration-&gt;type-&gt;name eq $name;
 473     }
 474 
 475     return $cachedExternalEnumerations-&gt;{$name} if exists($cachedExternalEnumerations-&gt;{$name});
 476 
 477     # Find the IDL file associated with the dictionary.
 478     my $filename = $object-&gt;IDLFileForInterface($name) or return;
 479 
 480     # Do a fast check to see if it seems to contain a dictionary.
 481     my $fileContents = slurp($filename);
 482 
 483     if ($fileContents =~ /\benum\s+$name/gs) {
 484         # Parse the IDL.
 485         my $parser = IDLParser-&gt;new(1);
 486         my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 487 
 488         foreach my $enumeration (@{$document-&gt;enumerations}) {
 489             next unless $enumeration-&gt;type-&gt;name eq $name;
 490 
 491             $cachedExternalEnumerations-&gt;{$name} = $enumeration;
 492             my $implementedAs = $enumeration-&gt;extendedAttributes-&gt;{ImplementedAs};
 493             $enumTypeImplementationNameOverrides{$enumeration-&gt;type-&gt;name} = $implementedAs if $implementedAs;
 494             return $enumeration;
 495         }
 496     }
 497     $cachedExternalEnumerations-&gt;{$name} = undef;
 498 }
 499 
 500 # An enumeration defined in its own IDL file.
 501 sub IsExternalEnumType
 502 {
 503     my ($object, $type) = @_;
 504 
 505     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 506 
 507     return $object-&gt;IsEnumType($type) &amp;&amp; defined($cachedExternalEnumerations-&gt;{$type-&gt;name});
 508 }
 509 
 510 sub HasEnumImplementationNameOverride
 511 {
 512     my ($object, $type) = @_;
 513 
 514     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 515 
 516     return 1 if exists $enumTypeImplementationNameOverrides{$type-&gt;name};
 517     return 0;
 518 }
 519 
 520 sub GetEnumImplementationNameOverride
 521 {
 522     my ($object, $type) = @_;
 523 
 524     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 525 
 526     return $enumTypeImplementationNameOverrides{$type-&gt;name};
 527 }
 528 
 529 sub GetDictionaryByType
 530 {
 531     my ($object, $type) = @_;
 532 
 533     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 534 
 535     my $name = $type-&gt;name;
 536 
 537     die &quot;GetDictionaryByType() was called with an undefined dictionary name&quot; unless defined($name);
 538 
 539     for my $dictionary (@{$useDocument-&gt;dictionaries}) {
 540         return $dictionary if $dictionary-&gt;type-&gt;name eq $name;
 541     }
 542 
 543     return $cachedExternalDictionaries-&gt;{$name} if exists($cachedExternalDictionaries-&gt;{$name});
 544 
 545     # Find the IDL file associated with the dictionary.
 546     my $filename = $object-&gt;IDLFileForInterface($name) or return;
 547 
 548     # Do a fast check to see if it seems to contain a dictionary.
 549     my $fileContents = slurp($filename);
 550 
 551     if ($fileContents =~ /\bdictionary\s+$name/gs) {
 552         # Parse the IDL.
 553         my $parser = IDLParser-&gt;new(1);
 554         my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 555 
 556         foreach my $dictionary (@{$document-&gt;dictionaries}) {
 557             next unless $dictionary-&gt;type-&gt;name eq $name;
 558 
 559             $cachedExternalDictionaries-&gt;{$name} = $dictionary;
 560             my $implementedAs = $dictionary-&gt;extendedAttributes-&gt;{ImplementedAs};
 561             $dictionaryTypeImplementationNameOverrides{$dictionary-&gt;type-&gt;name} = $implementedAs if $implementedAs;
 562             return $dictionary;
 563         }
 564     }
 565     $cachedExternalDictionaries-&gt;{$name} = undef;
 566 }
 567 
 568 sub IsDictionaryType
 569 {
 570     my ($object, $type) = @_;
 571 
 572     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 573 
 574     return $type-&gt;name =~ /^[A-Z]/ &amp;&amp; defined($object-&gt;GetDictionaryByType($type));
 575 }
 576 
 577 # A dictionary defined in its own IDL file.
 578 sub IsExternalDictionaryType
 579 {
 580     my ($object, $type) = @_;
 581 
 582     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 583 
 584     return $object-&gt;IsDictionaryType($type) &amp;&amp; defined($cachedExternalDictionaries-&gt;{$type-&gt;name});
 585 }
 586 
 587 sub HasDictionaryImplementationNameOverride
 588 {
 589     my ($object, $type) = @_;
 590 
 591     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 592 
 593     return 1 if exists $dictionaryTypeImplementationNameOverrides{$type-&gt;name};
 594     return 0;
 595 }
 596 
 597 sub GetDictionaryImplementationNameOverride
 598 {
 599     my ($object, $type) = @_;
 600 
 601     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 602 
 603     return $dictionaryTypeImplementationNameOverrides{$type-&gt;name};
 604 }
 605 
 606 sub IsSVGAnimatedTypeName
 607 {
 608     my ($object, $typeName) = @_;
 609 
 610     return $typeName =~ /^SVGAnimated/;
 611 }
 612 
 613 sub IsSVGAnimatedType
 614 {
 615     my ($object, $type) = @_;
 616 
 617     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 618 
 619     return $object-&gt;IsSVGAnimatedTypeName($type-&gt;name);
 620 }
 621 
<a name="1" id="anc1"></a><span class="line-added"> 622 sub IsSVGPathSegTypeName</span>
<span class="line-added"> 623 {</span>
<span class="line-added"> 624     my ($object, $typeName) = @_;</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626     return $typeName =~ /^SVGPathSeg/;</span>
<span class="line-added"> 627 }</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629 sub IsSVGPathSegType</span>
<span class="line-added"> 630 {</span>
<span class="line-added"> 631     my ($object, $type) = @_;</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635     return $object-&gt;IsSVGPathSegTypeName($type-&gt;name);</span>
<span class="line-added"> 636 }</span>
<span class="line-added"> 637 </span>
 638 sub IsConstructorType
 639 {
 640     my ($object, $type) = @_;
 641 
 642     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 643 
 644     return $type-&gt;name =~ /Constructor$/;
 645 }
 646 
 647 sub IsSequenceType
 648 {
 649     my ($object, $type) = @_;
 650 
 651     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 652 
 653     return $type-&gt;name eq &quot;sequence&quot;;
 654 }
 655 
 656 sub IsFrozenArrayType
 657 {
 658     my ($object, $type) = @_;
 659 
 660     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 661 
 662     return $type-&gt;name eq &quot;FrozenArray&quot;;
 663 }
 664 
 665 sub IsSequenceOrFrozenArrayType
 666 {
 667     my ($object, $type) = @_;
 668 
 669     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 670 
 671     return $object-&gt;IsSequenceType($type) || $object-&gt;IsFrozenArrayType($type);
 672 }
 673 
 674 sub IsRecordType
 675 {
 676     my ($object, $type) = @_;
 677 
 678     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 679 
 680     return $type-&gt;name eq &quot;record&quot;;
 681 }
 682 
 683 sub IsBufferSourceType
 684 {
 685     my ($object, $type) = @_;
 686 
 687     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 688 
 689     return 1 if $bufferSourceTypes{$type-&gt;name};
 690     return 0;
 691 }
 692 
 693 sub IsPromiseType
 694 {
 695     my ($object, $type) = @_;
 696 
 697     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 698 
 699     return $type-&gt;name eq &quot;Promise&quot;;
 700 }
 701 
 702 # These match WK_lcfirst and WK_ucfirst defined in builtins_generator.py.
 703 # Uppercase the first letter while respecting WebKit style guidelines.
 704 # E.g., xmlEncoding becomes XMLEncoding, but xmlllang becomes Xmllang.
 705 sub WK_ucfirst
 706 {
 707     my ($object, $param) = @_;
 708 
 709     my $ret = ucfirst($param);
 710     $ret =~ s/Xml/XML/ if $ret =~ /^Xml[^a-z]/;
 711     $ret =~ s/Svg/SVG/ if $ret =~ /^Svg/;
 712     $ret =~ s/Srgb/SRGB/ if $ret =~ /^Srgb/;
 713     $ret =~ s/Cenc/cenc/ if $ret =~ /^Cenc/;
 714     $ret =~ s/Cbcs/cbcs/ if $ret =~ /^Cbcs/;
 715 
 716     return $ret;
 717 }
 718 
 719 # Lowercase the first letter while respecting WebKit style guidelines.
 720 # URL becomes url, but SetURL becomes setURL.
 721 sub WK_lcfirst
 722 {
 723     my ($object, $param) = @_;
 724 
 725     my $ret = lcfirst($param);
 726     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
 727     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
 728     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
 729     $ret =~ s/jS/js/ if $ret =~ /^jS/;
 730     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
 731     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
 732     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
 733     $ret =~ s/rTC/rtc/ if $ret =~ /^rTC/;
 734 
 735     # For HTML5 FileSystem API Flags attributes.
 736     # (create is widely used to instantiate an object and must be avoided.)
 737     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
 738     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
 739 
 740     return $ret;
 741 }
 742 
 743 sub slurp
 744 {
 745     my $file = shift;
 746 
 747     open my $fh, &#39;&lt;&#39;, $file or die;
 748     local $/ = undef;
 749     my $content = &lt;$fh&gt;;
 750     close $fh;
 751     return $content;
 752 }
 753 
 754 sub trim
 755 {
 756     my $string = shift;
 757 
 758     $string =~ s/^\s+|\s+$//g;
 759     return $string;
 760 }
 761 
 762 # Return the C++ namespace that a given attribute name string is defined in.
 763 sub NamespaceForAttributeName
 764 {
 765     my ($object, $interfaceName, $attributeName) = @_;
 766 
 767     return &quot;SVGNames&quot; if $interfaceName =~ /^SVG/ &amp;&amp; !$svgAttributesInHTMLHash{$attributeName};
 768     return &quot;HTMLNames&quot;;
 769 }
 770 
 771 # Identifies overloaded functions and for each function adds an array with
 772 # links to its respective overloads (including itself).
 773 sub LinkOverloadedOperations
 774 {
 775     my ($object, $interface) = @_;
 776 
 777     my %nameToOperationsMap = ();
 778     foreach my $operation (@{$interface-&gt;operations}) {
 779         my $name = $operation-&gt;name;
 780         $nameToOperationsMap{$name} = [] if !exists $nameToOperationsMap{$name};
 781         push(@{$nameToOperationsMap{$name}}, $operation);
 782         $operation-&gt;{overloads} = $nameToOperationsMap{$name};
 783         $operation-&gt;{overloadIndex} = @{$nameToOperationsMap{$name}};
 784     }
 785 
 786     my $index = 1;
 787     foreach my $constructor (@{$interface-&gt;constructors}) {
 788         $constructor-&gt;{overloads} = $interface-&gt;constructors;
 789         $constructor-&gt;{overloadIndex} = $index;
 790         $index++;
 791     }
 792 }
 793 
 794 sub AttributeNameForGetterAndSetter
 795 {
 796     my ($generator, $attribute) = @_;
 797 
 798     my $attributeName = $attribute-&gt;name;
 799     if ($attribute-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 800         $attributeName = $attribute-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 801     }
 802     my $attributeType = $attribute-&gt;type;
 803 
 804     # SVG animated types need to use a special attribute name.
 805     # The rest of the special casing for SVG animated types is handled in the language-specific code generators.
 806     $attributeName .= &quot;Animated&quot; if $generator-&gt;IsSVGAnimatedType($attributeType);
 807 
 808     return $attributeName;
 809 }
 810 
 811 sub ContentAttributeName
 812 {
 813     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 814 
 815     my $contentAttributeName = $attribute-&gt;extendedAttributes-&gt;{&quot;Reflect&quot;};
 816     return undef if !$contentAttributeName;
 817 
 818     $contentAttributeName = lc $generator-&gt;AttributeNameForGetterAndSetter($attribute) if $contentAttributeName eq &quot;VALUE_IS_MISSING&quot;;
 819 
 820     my $namespace = $generator-&gt;NamespaceForAttributeName($interfaceName, $contentAttributeName);
 821 
 822     $implIncludes-&gt;{&quot;${namespace}.h&quot;} = 1;
 823     return &quot;WebCore::${namespace}::${contentAttributeName}Attr&quot;;
 824 }
 825 
 826 sub GetterExpression
 827 {
 828     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 829 
 830     my $contentAttributeName = $generator-&gt;ContentAttributeName($implIncludes, $interfaceName, $attribute);
 831 
 832     if (!$contentAttributeName) {
 833         return ($generator-&gt;WK_lcfirst($generator-&gt;AttributeNameForGetterAndSetter($attribute)));
 834     }
 835 
 836     my $attributeType = $attribute-&gt;type;
 837 
 838     my $functionName;
 839     if ($attribute-&gt;extendedAttributes-&gt;{&quot;URL&quot;}) {
 840         $functionName = &quot;getURLAttribute&quot;;
 841     } elsif ($attributeType-&gt;name eq &quot;boolean&quot;) {
 842         $functionName = &quot;hasAttributeWithoutSynchronization&quot;;
 843     } elsif ($attributeType-&gt;name eq &quot;long&quot;) {
 844         $functionName = &quot;getIntegralAttribute&quot;;
 845     } elsif ($attributeType-&gt;name eq &quot;unsigned long&quot;) {
 846         $functionName = &quot;getUnsignedIntegralAttribute&quot;;
 847     } else {
 848         if ($contentAttributeName eq &quot;WebCore::HTMLNames::idAttr&quot;) {
 849             $functionName = &quot;getIdAttribute&quot;;
 850             $contentAttributeName = &quot;&quot;;
 851         } elsif ($contentAttributeName eq &quot;WebCore::HTMLNames::nameAttr&quot;) {
 852             $functionName = &quot;getNameAttribute&quot;;
 853             $contentAttributeName = &quot;&quot;;
 854         } elsif ($generator-&gt;IsSVGAnimatedType($attributeType)) {
 855             $functionName = &quot;getAttribute&quot;;
 856         } else {
 857             $functionName = &quot;attributeWithoutSynchronization&quot;;
 858         }
 859     }
 860 
 861     return ($functionName, $contentAttributeName);
 862 }
 863 
 864 sub SetterExpression
 865 {
 866     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 867 
 868     my $contentAttributeName = $generator-&gt;ContentAttributeName($implIncludes, $interfaceName, $attribute);
 869 
 870     if (!$contentAttributeName) {
 871         return (&quot;set&quot; . $generator-&gt;WK_ucfirst($generator-&gt;AttributeNameForGetterAndSetter($attribute)));
 872     }
 873 
 874     my $attributeType = $attribute-&gt;type;
 875 
 876     my $functionName;
 877     if ($attributeType-&gt;name eq &quot;boolean&quot;) {
 878         $functionName = &quot;setBooleanAttribute&quot;;
 879     } elsif ($attributeType-&gt;name eq &quot;long&quot;) {
 880         $functionName = &quot;setIntegralAttribute&quot;;
 881     } elsif ($attributeType-&gt;name eq &quot;unsigned long&quot;) {
 882         $functionName = &quot;setUnsignedIntegralAttribute&quot;;
 883     } elsif ($generator-&gt;IsSVGAnimatedType($attributeType)) {
 884         $functionName = &quot;setAttribute&quot;;
 885     } else {
 886         $functionName = &quot;setAttributeWithoutSynchronization&quot;;
 887     }
 888 
 889     return ($functionName, $contentAttributeName);
 890 }
 891 
 892 sub IsBuiltinType
 893 {
 894     my ($object, $type) = @_;
 895 
 896     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 897 
 898     return 1 if $object-&gt;IsPrimitiveType($type);
 899     return 1 if $object-&gt;IsSequenceOrFrozenArrayType($type);
 900     return 1 if $object-&gt;IsRecordType($type);
 901     return 1 if $object-&gt;IsStringType($type);
 902     return 1 if $object-&gt;IsBufferSourceType($type);
 903     return 1 if $type-&gt;isUnion;
 904     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
 905     return 1 if $type-&gt;name eq &quot;JSON&quot;;
 906     return 1 if $type-&gt;name eq &quot;Promise&quot;;
 907     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
 908     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
 909     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
 910     return 1 if $type-&gt;name eq &quot;any&quot;;
 911     return 1 if $type-&gt;name eq &quot;object&quot;;
 912 
 913     return 0;
 914 }
 915 
 916 sub IsInterfaceType
 917 {
 918     my ($object, $type) = @_;
 919 
 920     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 921 
 922     return 0 if $object-&gt;IsBuiltinType($type);
 923     return 0 if $object-&gt;IsDictionaryType($type);
 924     return 0 if $object-&gt;IsEnumType($type);
 925 
 926     return 1;
 927 }
 928 
 929 sub IsWrapperType
 930 {
 931     my ($object, $type) = @_;
 932 
 933     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 934 
 935     return 1 if $object-&gt;IsInterfaceType($type);
 936     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
 937 
 938     return 0;
 939 }
 940 
 941 sub InheritsSerializable
 942 {
 943     my ($object, $interface) = @_;
 944 
 945     my $anyParentIsSerializable = 0;
 946     $object-&gt;ForAllParents($interface, sub {
 947         my $parentInterface = shift;
 948         $anyParentIsSerializable = 1 if $parentInterface-&gt;serializable;
 949     }, 0);
 950 
 951     return $anyParentIsSerializable;
 952 }
 953 
 954 sub IsSerializableType
 955 {
 956     my ($object, $interface, $type) = @_;
 957 
 958     # https://heycam.github.io/webidl/#dfn-serializable-type
 959 
 960     return 1 if $type-&gt;name eq &quot;boolean&quot;;
 961     return 1 if $object-&gt;IsNumericType($type);
 962     return 1 if $object-&gt;IsEnumType($type);
 963     return 1 if $object-&gt;IsStringType($type);
 964     return 0 if $type-&gt;name eq &quot;EventHandler&quot;;
 965 
 966     if ($type-&gt;isUnion || $object-&gt;IsDictionaryType($type)) {
 967         die &quot;Serializers for union and dictionary types are not currently supported.\n&quot;;
 968     }
 969 
 970     if ($object-&gt;IsSequenceOrFrozenArrayType($type)) {
 971         my $subtype = @{$type-&gt;subtypes}[0];
 972 
 973         # FIXME: webkit.org/b/194439 [WebIDL] Support serializing sequences and FrozenArrays of interfaces
 974         return 0 if $object-&gt;IsInterfaceType($subtype);
 975 
 976         return $object-&gt;IsSerializableType($interface, $subtype);
 977     }
 978 
 979     return 0 if !$object-&gt;IsInterfaceType($type);
 980 
 981     my $interfaceForType = $object-&gt;GetInterfaceForType($interface, $type);
 982     if ($interfaceForType) {
 983         return 1 if $interfaceForType-&gt;serializable;
 984         return $object-&gt;InheritsSerializable($interfaceForType);
 985     }
 986 
 987     return 0;
 988 }
 989 
 990 sub hasCachedAttributeOrCustomGetterExtendedAttribute
 991 {
 992     my ($attribute) = @_;
 993     return $attribute-&gt;extendedAttributes-&gt;{CachedAttribute} || $attribute-&gt;extendedAttributes-&gt;{CustomGetter};
 994 }
 995 
 996 sub IsSerializableAttribute
 997 {
 998     my ($object, $interface, $attribute) = @_;
 999 
1000     if ($object-&gt;IsSequenceType($attribute-&gt;type) &amp;&amp; hasCachedAttributeOrCustomGetterExtendedAttribute($attribute)) {
1001         die &quot;Serializers for sequence types with CachedAttribute or CustomGetter extended attributes are not currently supported.\n&quot;;
1002     }
1003 
1004     return $object-&gt;IsSerializableType($interface, $attribute-&gt;type);
1005 }
1006 
1007 sub GetInterfaceExtendedAttributesFromName
1008 {
1009     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1010     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1011 
1012     my ($object, $interfaceName) = @_;
1013 
1014     my $idlFile = $object-&gt;IDLFileForInterface($interfaceName) or assert(&quot;Could NOT find IDL file for interface \&quot;$interfaceName\&quot;!\n&quot;);
1015 
1016     open FILE, &quot;&lt;&quot;, $idlFile or die;
1017     my @lines = &lt;FILE&gt;;
1018     close FILE;
1019 
1020     my $fileContents = join(&#39;&#39;, @lines);
1021 
1022     my $extendedAttributes = {};
1023 
1024     if ($fileContents =~ /\[(.*)\]\s+(callback interface|interface|exception)\s+(\w+)/gs) {
1025         my @parts = split(&#39;,&#39;, $1);
1026         foreach my $part (@parts) {
1027             my @keyValue = split(&#39;=&#39;, $part);
1028             my $key = trim($keyValue[0]);
1029             next unless length($key);
1030             my $value = &quot;VALUE_IS_MISSING&quot;;
1031             $value = trim($keyValue[1]) if @keyValue &gt; 1;
1032             $extendedAttributes-&gt;{$key} = $value;
1033         }
1034     }
1035 
1036     return $extendedAttributes;
1037 }
1038 
1039 sub ComputeIsCallbackInterface
1040 {
1041     my ($object, $type) = @_;
1042 
1043     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1044 
1045     return 0 unless $object-&gt;IsInterfaceType($type);
1046     return 0 if $type-&gt;name eq &quot;WindowProxy&quot;;
1047 
1048     my $typeName = $type-&gt;name;
1049     my $idlFile = $object-&gt;IDLFileForInterface($typeName) or assert(&quot;Could NOT find IDL file for interface \&quot;$typeName\&quot;!\n&quot;);
1050 
1051     open FILE, &quot;&lt;&quot;, $idlFile or die;
1052     my @lines = &lt;FILE&gt;;
1053     close FILE;
1054 
1055     my $fileContents = join(&#39;&#39;, @lines);
1056     return ($fileContents =~ /callback\s+interface\s+(\w+)/gs);
1057 }
1058 
1059 my %isCallbackInterface = ();
1060 
1061 sub IsCallbackInterface
1062 {
1063     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1064     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1065     # To mitigate that, lets cache what we learn in a hash so we don&#39;t open the same file over and over.
1066 
1067     my ($object, $type) = @_;
1068 
1069     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1070 
1071     return $isCallbackInterface{$type-&gt;name} if exists $isCallbackInterface{$type-&gt;name};
1072     my $result = $object-&gt;ComputeIsCallbackInterface($type);
1073     $isCallbackInterface{$type-&gt;name} = $result;
1074     return $result;
1075 }
1076 
1077 sub ComputeIsCallbackFunction
1078 {
1079     my ($object, $type) = @_;
1080 
1081     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1082 
1083     return 0 unless $object-&gt;IsInterfaceType($type);
1084     return 0 if $type-&gt;name eq &quot;WindowProxy&quot;;
1085 
1086     my $typeName = $type-&gt;name;
1087     my $idlFile = $object-&gt;IDLFileForInterface($typeName) or assert(&quot;Could NOT find IDL file for interface \&quot;$typeName\&quot;!\n&quot;);
1088 
1089     open FILE, &quot;&lt;&quot;, $idlFile or die;
1090     my @lines = &lt;FILE&gt;;
1091     close FILE;
1092 
1093     my $fileContents = join(&#39;&#39;, @lines);
1094     return ($fileContents =~ /(.*)callback\s+(\w+)\s+=/gs);
1095 }
1096 
1097 my %isCallbackFunction = ();
1098 
1099 sub IsCallbackFunction
1100 {
1101     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1102     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1103     # To mitigate that, lets cache what we learn in a hash so we don&#39;t open the same file over and over.
1104 
1105     my ($object, $type) = @_;
1106 
1107     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1108 
1109     return $isCallbackFunction{$type-&gt;name} if exists $isCallbackFunction{$type-&gt;name};
1110     my $result = $object-&gt;ComputeIsCallbackFunction($type);
1111     $isCallbackFunction{$type-&gt;name} = $result;
1112     return $result;
1113 }
1114 
1115 sub GenerateConditionalString
1116 {
1117     my ($generator, $node) = @_;
1118 
1119     my $conditional = $node-&gt;extendedAttributes-&gt;{&quot;Conditional&quot;};
1120     if ($conditional) {
1121         return $generator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1122     } else {
1123         return &quot;&quot;;
1124     }
1125 }
1126 
1127 sub GenerateConditionalStringFromAttributeValue
1128 {
1129     my ($generator, $conditional) = @_;
1130 
1131     my %disjunction;
1132     map {
1133         my $expression = $_;
1134         my %conjunction;
1135         map { $conjunction{$_} = 1; } split(/&amp;/, $expression);
1136         $expression = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, sort keys %conjunction) . &quot;)&quot;;
1137         $disjunction{$expression} = 1
1138     } split(/\|/, $conditional);
1139 
1140     return &quot;1&quot; if keys %disjunction == 0;
1141     return (%disjunction)[0] if keys %disjunction == 1;
1142 
1143     my @parenthesized;
1144     map {
1145         my $expression = $_;
1146         $expression = &quot;($expression)&quot; if $expression =~ / /;
1147         push @parenthesized, $expression;
1148     } sort keys %disjunction;
1149 
1150     return join(&quot; || &quot;, @parenthesized);
1151 }
1152 
1153 sub GenerateCompileTimeCheckForEnumsIfNeeded
1154 {
1155     my ($generator, $interface) = @_;
1156 
1157     return () if $interface-&gt;extendedAttributes-&gt;{&quot;DoNotCheckConstants&quot;} || !@{$interface-&gt;constants};
1158 
1159     my $baseScope = $interface-&gt;extendedAttributes-&gt;{&quot;ConstantsScope&quot;} || $interface-&gt;type-&gt;name;
1160 
1161     my @checks = ();
1162     foreach my $constant (@{$interface-&gt;constants}) {
1163         my $scope = $constant-&gt;extendedAttributes-&gt;{&quot;ImplementedBy&quot;} || $baseScope;
1164         my $name = $constant-&gt;extendedAttributes-&gt;{&quot;Reflect&quot;} || $constant-&gt;name;
1165         my $value = $constant-&gt;value;
1166         my $conditional = $constant-&gt;extendedAttributes-&gt;{&quot;Conditional&quot;};
1167         push(@checks, &quot;#if &quot; . $generator-&gt;GenerateConditionalStringFromAttributeValue($conditional) . &quot;\n&quot;) if $conditional;
1168         push(@checks, &quot;static_assert(${scope}::${name} == ${value}, \&quot;${name} in ${scope} does not match value from IDL\&quot;);\n&quot;);
1169         push(@checks, &quot;#endif\n&quot;) if $conditional;
1170     }
1171     push(@checks, &quot;\n&quot;);
1172     return @checks;
1173 }
1174 
1175 sub ExtendedAttributeContains
1176 {
1177     my $object = shift;
1178     my $callWith = shift;
1179     return 0 unless $callWith;
1180     my $keyword = shift;
1181 
1182     my @callWithKeywords = split /\s*\&amp;\s*/, $callWith;
1183     return grep { $_ eq $keyword } @callWithKeywords;
1184 }
1185 
1186 # FIXME: This is backwards. We currently name the interface and the IDL files with the implementation name. We
1187 # should use the real interface name in the IDL files and then use ImplementedAs to map this to the implementation name.
1188 sub GetVisibleInterfaceName
1189 {
1190     my ($object, $interface) = @_;
1191 
1192     my $interfaceName = $interface-&gt;extendedAttributes-&gt;{&quot;InterfaceName&quot;};
1193     return $interfaceName ? $interfaceName : $interface-&gt;type-&gt;name;
1194 }
1195 
1196 sub InheritsInterface
1197 {
1198     my ($object, $interface, $interfaceName) = @_;
1199 
1200     return 1 if $interfaceName eq $interface-&gt;type-&gt;name;
1201 
1202     my $found = 0;
1203     $object-&gt;ForAllParents($interface, sub {
1204         my $currentInterface = shift;
1205         if ($currentInterface-&gt;type-&gt;name eq $interfaceName) {
1206             $found = 1;
1207         }
1208         return 1 if $found;
1209     }, 0);
1210 
1211     return $found;
1212 }
1213 
1214 sub InheritsExtendedAttribute
1215 {
1216     my ($object, $interface, $extendedAttribute) = @_;
1217 
1218     return 1 if $interface-&gt;extendedAttributes-&gt;{$extendedAttribute};
1219 
1220     my $found = 0;
1221     $object-&gt;ForAllParents($interface, sub {
1222         my $currentInterface = shift;
1223         if ($currentInterface-&gt;extendedAttributes-&gt;{$extendedAttribute}) {
1224             $found = 1;
1225         }
1226         return 1 if $found;
1227     }, 0);
1228 
1229     return $found;
1230 }
1231 
1232 
1233 1;
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>