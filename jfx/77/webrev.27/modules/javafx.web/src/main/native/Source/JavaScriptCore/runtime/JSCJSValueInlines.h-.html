<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValueInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;ExceptionHelpers.h&quot;
  31 #include &quot;Identifier.h&quot;
  32 #include &quot;InternalFunction.h&quot;
  33 #include &quot;JSBigInt.h&quot;
  34 #include &quot;JSCJSValue.h&quot;
  35 #include &quot;JSCellInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSObject.h&quot;
  38 #include &quot;JSProxy.h&quot;
  39 #include &quot;JSStringInlines.h&quot;
  40 #include &quot;MathCommon.h&quot;
  41 #include &lt;wtf/Variant.h&gt;
  42 #include &lt;wtf/text/StringImpl.h&gt;
  43 
  44 namespace JSC {
  45 
  46 ALWAYS_INLINE int32_t JSValue::toInt32(ExecState* exec) const
  47 {
  48     if (isInt32())
  49         return asInt32();
  50     return JSC::toInt32(toNumber(exec));
  51 }
  52 
  53 inline uint32_t JSValue::toUInt32(ExecState* exec) const
  54 {
  55     // See comment on JSC::toUInt32, in JSCJSValue.h.
  56     return toInt32(exec);
  57 }
  58 
  59 inline uint32_t JSValue::toIndex(ExecState* exec, const char* errorName) const
  60 {
  61     VM&amp; vm = exec-&gt;vm();
  62     auto scope = DECLARE_THROW_SCOPE(vm);
  63 
  64     double d = toNumber(exec);
  65     RETURN_IF_EXCEPTION(scope, 0);
  66     if (d &lt;= -1) {
  67         throwException(exec, scope, createRangeError(exec, makeString(errorName, &quot; cannot be negative&quot;)));
  68         return 0;
  69     }
  70     if (d &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
  71         throwException(exec, scope, createRangeError(exec, makeString(errorName, &quot; too large&quot;)));
  72         return 0;
  73     }
  74 
  75     if (isInt32())
  76         return asInt32();
  77     RELEASE_AND_RETURN(scope, JSC::toInt32(d));
  78 }
  79 
  80 inline bool JSValue::isUInt32() const
  81 {
  82     return isInt32() &amp;&amp; asInt32() &gt;= 0;
  83 }
  84 
  85 inline uint32_t JSValue::asUInt32() const
  86 {
  87     ASSERT(isUInt32());
  88     return asInt32();
  89 }
  90 
  91 inline double JSValue::asNumber() const
  92 {
  93     ASSERT(isNumber());
  94     return isInt32() ? asInt32() : asDouble();
  95 }
  96 
  97 inline JSValue jsNaN()
  98 {
  99     return JSValue(JSValue::EncodeAsDouble, PNaN);
 100 }
 101 
 102 inline JSValue::JSValue(char i)
 103 {
 104     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 105 }
 106 
 107 inline JSValue::JSValue(unsigned char i)
 108 {
 109     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 110 }
 111 
 112 inline JSValue::JSValue(short i)
 113 {
 114     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 115 }
 116 
 117 inline JSValue::JSValue(unsigned short i)
 118 {
 119     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 120 }
 121 
 122 inline JSValue::JSValue(unsigned i)
 123 {
 124     if (static_cast&lt;int32_t&gt;(i) &lt; 0) {
 125         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 126         return;
 127     }
 128     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 129 }
 130 
 131 inline JSValue::JSValue(long i)
 132 {
 133     if (static_cast&lt;int32_t&gt;(i) != i) {
 134         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 135         return;
 136     }
 137     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 138 }
 139 
 140 inline JSValue::JSValue(unsigned long i)
 141 {
 142     if (static_cast&lt;uint32_t&gt;(i) != i) {
 143         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 144         return;
 145     }
 146     *this = JSValue(static_cast&lt;uint32_t&gt;(i));
 147 }
 148 
 149 inline JSValue::JSValue(long long i)
 150 {
 151     if (static_cast&lt;int32_t&gt;(i) != i) {
 152         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 153         return;
 154     }
 155     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 156 }
 157 
 158 inline JSValue::JSValue(unsigned long long i)
 159 {
 160     if (static_cast&lt;uint32_t&gt;(i) != i) {
 161         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 162         return;
 163     }
 164     *this = JSValue(static_cast&lt;uint32_t&gt;(i));
 165 }
 166 
 167 inline JSValue::JSValue(double d)
 168 {
 169     if (canBeStrictInt32(d)) {
 170         *this = JSValue(static_cast&lt;int32_t&gt;(d));
 171         return;
 172     }
 173     *this = JSValue(EncodeAsDouble, d);
 174 }
 175 
 176 inline EncodedJSValue JSValue::encode(JSValue value)
 177 {
 178     return value.u.asInt64;
 179 }
 180 
 181 inline JSValue JSValue::decode(EncodedJSValue encodedJSValue)
 182 {
 183     JSValue v;
 184     v.u.asInt64 = encodedJSValue;
 185     return v;
 186 }
 187 
 188 #if USE(JSVALUE32_64)
 189 inline JSValue::JSValue()
 190 {
 191     u.asBits.tag = EmptyValueTag;
 192     u.asBits.payload = 0;
 193 }
 194 
 195 inline JSValue::JSValue(JSNullTag)
 196 {
 197     u.asBits.tag = NullTag;
 198     u.asBits.payload = 0;
 199 }
 200 
 201 inline JSValue::JSValue(JSUndefinedTag)
 202 {
 203     u.asBits.tag = UndefinedTag;
 204     u.asBits.payload = 0;
 205 }
 206 
 207 inline JSValue::JSValue(JSTrueTag)
 208 {
 209     u.asBits.tag = BooleanTag;
 210     u.asBits.payload = 1;
 211 }
 212 
 213 inline JSValue::JSValue(JSFalseTag)
 214 {
 215     u.asBits.tag = BooleanTag;
 216     u.asBits.payload = 0;
 217 }
 218 
 219 inline JSValue::JSValue(HashTableDeletedValueTag)
 220 {
 221     u.asBits.tag = DeletedValueTag;
 222     u.asBits.payload = 0;
 223 }
 224 
 225 inline JSValue::JSValue(JSCell* ptr)
 226 {
 227     if (ptr)
 228         u.asBits.tag = CellTag;
 229     else
 230         u.asBits.tag = EmptyValueTag;
 231     u.asBits.payload = reinterpret_cast&lt;int32_t&gt;(ptr);
 232 }
 233 
 234 inline JSValue::JSValue(const JSCell* ptr)
 235 {
 236     if (ptr)
 237         u.asBits.tag = CellTag;
 238     else
 239         u.asBits.tag = EmptyValueTag;
 240     u.asBits.payload = reinterpret_cast&lt;int32_t&gt;(const_cast&lt;JSCell*&gt;(ptr));
 241 }
 242 
 243 inline JSValue::operator bool() const
 244 {
 245     ASSERT(tag() != DeletedValueTag);
 246     return tag() != EmptyValueTag;
 247 }
 248 
 249 inline bool JSValue::operator==(const JSValue&amp; other) const
 250 {
 251     return u.asInt64 == other.u.asInt64;
 252 }
 253 
 254 inline bool JSValue::operator!=(const JSValue&amp; other) const
 255 {
 256     return u.asInt64 != other.u.asInt64;
 257 }
 258 
 259 inline bool JSValue::isEmpty() const
 260 {
 261     return tag() == EmptyValueTag;
 262 }
 263 
 264 inline bool JSValue::isUndefined() const
 265 {
 266     return tag() == UndefinedTag;
 267 }
 268 
 269 inline bool JSValue::isNull() const
 270 {
 271     return tag() == NullTag;
 272 }
 273 
 274 inline bool JSValue::isUndefinedOrNull() const
 275 {
 276     return isUndefined() || isNull();
 277 }
 278 
 279 inline bool JSValue::isCell() const
 280 {
 281     return tag() == CellTag;
 282 }
 283 
 284 inline bool JSValue::isInt32() const
 285 {
 286     return tag() == Int32Tag;
 287 }
 288 
 289 inline bool JSValue::isDouble() const
 290 {
 291     return tag() &lt; LowestTag;
 292 }
 293 
 294 inline bool JSValue::isTrue() const
 295 {
 296     return tag() == BooleanTag &amp;&amp; payload();
 297 }
 298 
 299 inline bool JSValue::isFalse() const
 300 {
 301     return tag() == BooleanTag &amp;&amp; !payload();
 302 }
 303 
 304 inline uint32_t JSValue::tag() const
 305 {
 306     return u.asBits.tag;
 307 }
 308 
 309 inline int32_t JSValue::payload() const
 310 {
 311     return u.asBits.payload;
 312 }
 313 
 314 inline int32_t JSValue::asInt32() const
 315 {
 316     ASSERT(isInt32());
 317     return u.asBits.payload;
 318 }
 319 
 320 inline double JSValue::asDouble() const
 321 {
 322     ASSERT(isDouble());
 323     return u.asDouble;
 324 }
 325 
 326 ALWAYS_INLINE JSCell* JSValue::asCell() const
 327 {
 328     ASSERT(isCell());
 329     return reinterpret_cast&lt;JSCell*&gt;(u.asBits.payload);
 330 }
 331 
 332 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 333 {
 334     ASSERT(!isImpureNaN(d));
 335     u.asDouble = d;
 336 }
 337 
 338 inline JSValue::JSValue(int i)
 339 {
 340     u.asBits.tag = Int32Tag;
 341     u.asBits.payload = i;
 342 }
 343 
 344 inline JSValue::JSValue(int32_t tag, int32_t payload)
 345 {
 346     u.asBits.tag = tag;
 347     u.asBits.payload = payload;
 348 }
 349 
 350 inline bool JSValue::isNumber() const
 351 {
 352     return isInt32() || isDouble();
 353 }
 354 
 355 inline bool JSValue::isBoolean() const
 356 {
 357     return tag() == BooleanTag;
 358 }
 359 
 360 inline bool JSValue::asBoolean() const
 361 {
 362     ASSERT(isBoolean());
 363     return payload();
 364 }
 365 
 366 #else // !USE(JSVALUE32_64) i.e. USE(JSVALUE64)
 367 
 368 // 0x0 can never occur naturally because it has a tag of 00, indicating a pointer value, but a payload of 0x0, which is in the (invalid) zero page.
 369 inline JSValue::JSValue()
 370 {
 371     u.asInt64 = ValueEmpty;
 372 }
 373 
 374 // 0x4 can never occur naturally because it has a tag of 00, indicating a pointer value, but a payload of 0x4, which is in the (invalid) zero page.
 375 inline JSValue::JSValue(HashTableDeletedValueTag)
 376 {
 377     u.asInt64 = ValueDeleted;
 378 }
 379 
 380 inline JSValue::JSValue(JSCell* ptr)
 381 {
 382     u.asInt64 = reinterpret_cast&lt;uintptr_t&gt;(ptr);
 383 }
 384 
 385 inline JSValue::JSValue(const JSCell* ptr)
 386 {
 387     u.asInt64 = reinterpret_cast&lt;uintptr_t&gt;(const_cast&lt;JSCell*&gt;(ptr));
 388 }
 389 
 390 inline JSValue::operator bool() const
 391 {
 392     return u.asInt64;
 393 }
 394 
 395 inline bool JSValue::operator==(const JSValue&amp; other) const
 396 {
 397     return u.asInt64 == other.u.asInt64;
 398 }
 399 
 400 inline bool JSValue::operator!=(const JSValue&amp; other) const
 401 {
 402     return u.asInt64 != other.u.asInt64;
 403 }
 404 
 405 inline bool JSValue::isEmpty() const
 406 {
 407     return u.asInt64 == ValueEmpty;
 408 }
 409 
 410 inline bool JSValue::isUndefined() const
 411 {
 412     return asValue() == JSValue(JSUndefined);
 413 }
 414 
 415 inline bool JSValue::isNull() const
 416 {
 417     return asValue() == JSValue(JSNull);
 418 }
 419 
 420 inline bool JSValue::isTrue() const
 421 {
 422     return asValue() == JSValue(JSTrue);
 423 }
 424 
 425 inline bool JSValue::isFalse() const
 426 {
 427     return asValue() == JSValue(JSFalse);
 428 }
 429 
 430 inline bool JSValue::asBoolean() const
 431 {
 432     ASSERT(isBoolean());
 433     return asValue() == JSValue(JSTrue);
 434 }
 435 
 436 inline int32_t JSValue::asInt32() const
 437 {
 438     ASSERT(isInt32());
 439     return static_cast&lt;int32_t&gt;(u.asInt64);
 440 }
 441 
 442 inline bool JSValue::isDouble() const
 443 {
 444     return isNumber() &amp;&amp; !isInt32();
 445 }
 446 
 447 inline JSValue::JSValue(JSNullTag)
 448 {
 449     u.asInt64 = ValueNull;
 450 }
 451 
 452 inline JSValue::JSValue(JSUndefinedTag)
 453 {
 454     u.asInt64 = ValueUndefined;
 455 }
 456 
 457 inline JSValue::JSValue(JSTrueTag)
 458 {
 459     u.asInt64 = ValueTrue;
 460 }
 461 
 462 inline JSValue::JSValue(JSFalseTag)
 463 {
 464     u.asInt64 = ValueFalse;
 465 }
 466 
 467 inline bool JSValue::isUndefinedOrNull() const
 468 {
 469     // Undefined and null share the same value, bar the &#39;undefined&#39; bit in the extended tag.
 470     return (u.asInt64 &amp; ~TagBitUndefined) == ValueNull;
 471 }
 472 
 473 inline bool JSValue::isBoolean() const
 474 {
 475     return (u.asInt64 &amp; ~1) == ValueFalse;
 476 }
 477 
 478 inline bool JSValue::isCell() const
 479 {
 480     return !(u.asInt64 &amp; TagMask);
 481 }
 482 
 483 inline bool JSValue::isInt32() const
 484 {
 485     return (u.asInt64 &amp; TagTypeNumber) == TagTypeNumber;
 486 }
 487 
 488 inline int64_t reinterpretDoubleToInt64(double value)
 489 {
 490     return bitwise_cast&lt;int64_t&gt;(value);
 491 }
 492 inline double reinterpretInt64ToDouble(int64_t value)
 493 {
 494     return bitwise_cast&lt;double&gt;(value);
 495 }
 496 
 497 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 498 {
 499     ASSERT(!isImpureNaN(d));
 500     u.asInt64 = reinterpretDoubleToInt64(d) + DoubleEncodeOffset;
 501 }
 502 
 503 inline JSValue::JSValue(int i)
 504 {
 505     u.asInt64 = TagTypeNumber | static_cast&lt;uint32_t&gt;(i);
 506 }
 507 
 508 inline double JSValue::asDouble() const
 509 {
 510     ASSERT(isDouble());
 511     return reinterpretInt64ToDouble(u.asInt64 - DoubleEncodeOffset);
 512 }
 513 
 514 inline bool JSValue::isNumber() const
 515 {
 516     return u.asInt64 &amp; TagTypeNumber;
 517 }
 518 
 519 ALWAYS_INLINE JSCell* JSValue::asCell() const
 520 {
 521     ASSERT(isCell());
 522     return u.ptr;
 523 }
 524 
 525 #endif // USE(JSVALUE64)
 526 
 527 inline int64_t tryConvertToInt52(double number)
 528 {
 529     if (number != number)
 530         return JSValue::notInt52;
 531 #if OS(WINDOWS) &amp;&amp; CPU(X86)
 532     // The VS Compiler for 32-bit builds generates a floating point error when attempting to cast
 533     // from an infinity to a 64-bit integer. We leave this routine with the floating point error
 534     // left in a register, causing undefined behavior in later floating point operations.
 535     //
 536     // To avoid this issue, we check for infinity here, and return false in that case.
 537     if (std::isinf(number))
 538         return JSValue::notInt52;
 539 #endif
 540     int64_t asInt64 = static_cast&lt;int64_t&gt;(number);
 541     if (asInt64 != number)
 542         return JSValue::notInt52;
 543     if (!asInt64 &amp;&amp; std::signbit(number))
 544         return JSValue::notInt52;
 545     if (asInt64 &gt;= (static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))
 546         return JSValue::notInt52;
 547     if (asInt64 &lt; -(static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))
 548         return JSValue::notInt52;
 549     return asInt64;
 550 }
 551 
 552 inline bool isInt52(double number)
 553 {
 554     return tryConvertToInt52(number) != JSValue::notInt52;
 555 }
 556 
 557 inline bool JSValue::isAnyInt() const
 558 {
 559     if (isInt32())
 560         return true;
 561     if (!isNumber())
 562         return false;
 563     return isInt52(asDouble());
 564 }
 565 
 566 inline int64_t JSValue::asAnyInt() const
 567 {
 568     ASSERT(isAnyInt());
 569     if (isInt32())
 570         return asInt32();
 571     return static_cast&lt;int64_t&gt;(asDouble());
 572 }
 573 
 574 inline bool JSValue::isString() const
 575 {
 576     return isCell() &amp;&amp; asCell()-&gt;isString();
 577 }
 578 
 579 inline bool JSValue::isBigInt() const
 580 {
 581     return isCell() &amp;&amp; asCell()-&gt;isBigInt();
 582 }
 583 
 584 inline bool JSValue::isSymbol() const
 585 {
 586     return isCell() &amp;&amp; asCell()-&gt;isSymbol();
 587 }
 588 
 589 inline bool JSValue::isPrimitive() const
 590 {
 591     return !isCell() || asCell()-&gt;isString() || asCell()-&gt;isSymbol() || asCell()-&gt;isBigInt();
 592 }
 593 
 594 inline bool JSValue::isGetterSetter() const
 595 {
 596     return isCell() &amp;&amp; asCell()-&gt;isGetterSetter();
 597 }
 598 
 599 inline bool JSValue::isCustomGetterSetter() const
 600 {
 601     return isCell() &amp;&amp; asCell()-&gt;isCustomGetterSetter();
 602 }
 603 
 604 inline bool JSValue::isObject() const
 605 {
 606     return isCell() &amp;&amp; asCell()-&gt;isObject();
 607 }
 608 
 609 inline bool JSValue::getString(ExecState* exec, String&amp; s) const
 610 {
 611     return isCell() &amp;&amp; asCell()-&gt;getString(exec, s);
 612 }
 613 
 614 inline String JSValue::getString(ExecState* exec) const
 615 {
 616     return isCell() ? asCell()-&gt;getString(exec) : String();
 617 }
 618 
 619 template &lt;typename Base&gt; String HandleConverter&lt;Base, Unknown&gt;::getString(ExecState* exec) const
 620 {
 621     return jsValue().getString(exec);
 622 }
 623 
 624 inline JSObject* JSValue::getObject() const
 625 {
 626     return isCell() ? asCell()-&gt;getObject() : 0;
 627 }
 628 
 629 ALWAYS_INLINE bool JSValue::getUInt32(uint32_t&amp; v) const
 630 {
 631     if (isInt32()) {
 632         int32_t i = asInt32();
 633         v = static_cast&lt;uint32_t&gt;(i);
 634         return i &gt;= 0;
 635     }
 636     if (isDouble()) {
 637         double d = asDouble();
 638         v = static_cast&lt;uint32_t&gt;(d);
 639         return v == d;
 640     }
 641     return false;
 642 }
 643 
 644 ALWAYS_INLINE Identifier JSValue::toPropertyKey(ExecState* exec) const
 645 {
 646     VM&amp; vm = exec-&gt;vm();
 647     auto scope = DECLARE_THROW_SCOPE(vm);
 648 
 649     if (isString())
 650         RELEASE_AND_RETURN(scope, asString(*this)-&gt;toIdentifier(exec));
 651 
 652     JSValue primitive = toPrimitive(exec, PreferString);
 653     RETURN_IF_EXCEPTION(scope, vm.propertyNames-&gt;emptyIdentifier);
 654     if (primitive.isSymbol())
 655         RELEASE_AND_RETURN(scope, Identifier::fromUid(asSymbol(primitive)-&gt;privateName()));
 656 
 657     RELEASE_AND_RETURN(scope, primitive.toString(exec)-&gt;toIdentifier(exec));
 658 }
 659 
 660 inline JSValue JSValue::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const
 661 {
 662     return isCell() ? asCell()-&gt;toPrimitive(exec, preferredType) : asValue();
 663 }
 664 
 665 inline PreferredPrimitiveType toPreferredPrimitiveType(ExecState* exec, JSValue value)
 666 {
 667     VM&amp; vm = exec-&gt;vm();
 668     auto scope = DECLARE_THROW_SCOPE(vm);
 669 
 670     if (!value.isString()) {
 671         throwTypeError(exec, scope, &quot;Primitive hint is not a string.&quot;_s);
 672         return NoPreference;
 673     }
 674 
 675     StringImpl* hintString = asString(value)-&gt;value(exec).impl();
 676     RETURN_IF_EXCEPTION(scope, NoPreference);
 677 
 678     if (WTF::equal(hintString, &quot;default&quot;))
 679         return NoPreference;
 680     if (WTF::equal(hintString, &quot;number&quot;))
 681         return PreferNumber;
 682     if (WTF::equal(hintString, &quot;string&quot;))
 683         return PreferString;
 684 
 685     throwTypeError(exec, scope, &quot;Expected primitive hint to match one of &#39;default&#39;, &#39;number&#39;, &#39;string&#39;.&quot;_s);
 686     return NoPreference;
 687 }
 688 
 689 inline bool JSValue::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; value)
 690 {
 691     if (isInt32()) {
 692         number = asInt32();
 693         value = *this;
 694         return true;
 695     }
 696     if (isDouble()) {
 697         number = asDouble();
 698         value = *this;
 699         return true;
 700     }
 701     if (isCell())
 702         return asCell()-&gt;getPrimitiveNumber(exec, number, value);
 703     if (isTrue()) {
 704         number = 1.0;
 705         value = *this;
 706         return true;
 707     }
 708     if (isFalse() || isNull()) {
 709         number = 0.0;
 710         value = *this;
 711         return true;
 712     }
 713     ASSERT(isUndefined());
 714     number = PNaN;
 715     value = *this;
 716     return true;
 717 }
 718 
 719 ALWAYS_INLINE double JSValue::toNumber(ExecState* exec) const
 720 {
 721     if (isInt32())
 722         return asInt32();
 723     if (isDouble())
 724         return asDouble();
 725     return toNumberSlowCase(exec);
 726 }
 727 
 728 ALWAYS_INLINE Variant&lt;JSBigInt*, double&gt; JSValue::toNumeric(ExecState* exec) const
 729 {
 730     if (isInt32())
 731         return asInt32();
 732     if (isDouble())
 733         return asDouble();
 734     if (isBigInt())
 735         return asBigInt(*this);
 736 
 737     VM&amp; vm = exec-&gt;vm();
 738     auto scope = DECLARE_THROW_SCOPE(vm);
 739     JSValue primValue = this-&gt;toPrimitive(exec, PreferNumber);
 740     RETURN_IF_EXCEPTION(scope, 0);
 741     if (primValue.isBigInt())
 742         return asBigInt(primValue);
 743     double value = primValue.toNumber(exec);
 744     RETURN_IF_EXCEPTION(scope, 0);
 745     return value;
 746 }
 747 
 748 ALWAYS_INLINE Variant&lt;JSBigInt*, int32_t&gt; JSValue::toBigIntOrInt32(ExecState* exec) const
 749 {
 750     if (isInt32())
 751         return asInt32();
 752     if (isDouble() &amp;&amp; canBeInt32(asDouble()))
 753         return static_cast&lt;int32_t&gt;(asDouble());
 754     if (isBigInt())
 755         return asBigInt(*this);
 756 
 757     VM&amp; vm = exec-&gt;vm();
 758     auto scope = DECLARE_THROW_SCOPE(vm);
 759     JSValue primValue = this-&gt;toPrimitive(exec, PreferNumber);
 760     RETURN_IF_EXCEPTION(scope, 0);
 761     if (primValue.isBigInt())
 762         return asBigInt(primValue);
 763     int32_t value = primValue.toInt32(exec);
 764     RETURN_IF_EXCEPTION(scope, 0);
 765     return value;
 766 }
 767 
 768 inline JSObject* JSValue::toObject(ExecState* exec) const
 769 {
 770     return isCell() ? asCell()-&gt;toObject(exec, exec-&gt;lexicalGlobalObject()) : toObjectSlowCase(exec, exec-&gt;lexicalGlobalObject());
 771 }
 772 
 773 inline JSObject* JSValue::toObject(ExecState* exec, JSGlobalObject* globalObject) const
 774 {
 775     return isCell() ? asCell()-&gt;toObject(exec, globalObject) : toObjectSlowCase(exec, globalObject);
 776 }
 777 
 778 inline bool JSValue::isFunction(VM&amp; vm) const
 779 {
 780     if (!isCell())
 781         return false;
 782     return asCell()-&gt;isFunction(vm);
 783 }
 784 
 785 inline bool JSValue::isCallable(VM&amp; vm, CallType&amp; callType, CallData&amp; callData) const
 786 {
 787     if (!isCell())
 788         return false;
 789     return asCell()-&gt;isCallable(vm, callType, callData);
 790 }
 791 
 792 inline bool JSValue::isConstructor(VM&amp; vm) const
 793 {
 794     if (!isCell())
 795         return false;
 796     return asCell()-&gt;isConstructor(vm);
 797 }
 798 
 799 inline bool JSValue::isConstructor(VM&amp; vm, ConstructType&amp; constructType, ConstructData&amp; constructData) const
 800 {
 801     if (!isCell())
 802         return false;
 803     return asCell()-&gt;isConstructor(vm, constructType, constructData);
 804 }
 805 
 806 // this method is here to be after the inline declaration of JSCell::inherits
 807 inline bool JSValue::inherits(VM&amp; vm, const ClassInfo* classInfo) const
 808 {
 809     return isCell() &amp;&amp; asCell()-&gt;inherits(vm, classInfo);
 810 }
 811 
 812 template&lt;typename Target&gt;
 813 inline bool JSValue::inherits(VM&amp; vm) const
 814 {
 815     return isCell() &amp;&amp; asCell()-&gt;inherits&lt;Target&gt;(vm);
 816 }
 817 
 818 inline const ClassInfo* JSValue::classInfoOrNull(VM&amp; vm) const
 819 {
 820     return isCell() ? asCell()-&gt;classInfo(vm) : nullptr;
 821 }
 822 
 823 inline JSValue JSValue::toThis(ExecState* exec, ECMAMode ecmaMode) const
 824 {
 825     return isCell() ? asCell()-&gt;methodTable(exec-&gt;vm())-&gt;toThis(asCell(), exec, ecmaMode) : toThisSlowCase(exec, ecmaMode);
 826 }
 827 
 828 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, PropertyName propertyName) const
 829 {
 830     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 831     return get(exec, propertyName, slot);
 832 }
 833 
 834 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const
 835 {
 836     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 837     bool hasSlot = getPropertySlot(exec, propertyName, slot);
 838     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 839     if (!hasSlot)
 840         return jsUndefined();
 841     RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 842 }
 843 
 844 template&lt;typename CallbackWhenNoException&gt;
 845 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, CallbackWhenNoException callback) const
 846 {
 847     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 848     return getPropertySlot(exec, propertyName, slot, callback);
 849 }
 850 
 851 template&lt;typename CallbackWhenNoException&gt;
 852 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const
 853 {
 854     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 855     bool found = getPropertySlot(exec, propertyName, slot);
 856     RETURN_IF_EXCEPTION(scope, { });
 857     RELEASE_AND_RETURN(scope, callback(found, slot));
 858 }
 859 
 860 ALWAYS_INLINE bool JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const
 861 {
 862     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 863     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 864     // and if it&#39;s a string there are special properties to check first.
 865     JSObject* object;
 866     if (UNLIKELY(!isObject())) {
 867         if (isString()) {
 868             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot);
 869             RETURN_IF_EXCEPTION(scope, false);
 870             if (hasProperty)
 871                 return true;
 872         }
 873         object = synthesizePrototype(exec);
 874         EXCEPTION_ASSERT(!!scope.exception() == !object);
 875         if (UNLIKELY(!object))
 876             return false;
 877     } else
 878         object = asObject(asCell());
 879 
 880     RELEASE_AND_RETURN(scope, object-&gt;getPropertySlot(exec, propertyName, slot));
 881 }
 882 
 883 ALWAYS_INLINE bool JSValue::getOwnPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const
 884 {
 885     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 886     // and if it&#39;s a string there are special properties to check first.
 887     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 888     if (UNLIKELY(!isObject())) {
 889         if (isString())
 890             RELEASE_AND_RETURN(scope, asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot));
 891 
 892         if (isUndefinedOrNull())
 893             throwException(exec, scope, createNotAnObjectError(exec, *this));
 894         return false;
 895     }
 896     RELEASE_AND_RETURN(scope, asObject(asCell())-&gt;getOwnPropertySlotInline(exec, propertyName, slot));
 897 }
 898 
 899 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, unsigned propertyName) const
 900 {
 901     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 902     return get(exec, propertyName, slot);
 903 }
 904 
 905 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot) const
 906 {
 907     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 908     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 909     // and if it&#39;s a string there are special properties to check first.
 910     JSObject* object;
 911     if (UNLIKELY(!isObject())) {
 912         if (isString()) {
 913             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot);
 914             RETURN_IF_EXCEPTION(scope, { });
 915             if (hasProperty)
 916                 RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 917         }
 918         object = synthesizePrototype(exec);
 919         EXCEPTION_ASSERT(!!scope.exception() == !object);
 920         if (UNLIKELY(!object))
 921             return JSValue();
 922     } else
 923         object = asObject(asCell());
 924 
 925     bool hasSlot = object-&gt;getPropertySlot(exec, propertyName, slot);
 926     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 927     if (!hasSlot)
 928         return jsUndefined();
 929     RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 930 }
 931 
 932 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, uint64_t propertyName) const
 933 {
 934     if (LIKELY(propertyName &lt;= std::numeric_limits&lt;unsigned&gt;::max()))
 935         return get(exec, static_cast&lt;unsigned&gt;(propertyName));
 936     return get(exec, Identifier::from(exec, static_cast&lt;double&gt;(propertyName)));
 937 }
 938 
 939 inline bool JSValue::put(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 940 {
 941     if (UNLIKELY(!isCell()))
 942         return putToPrimitive(exec, propertyName, value, slot);
 943 
 944     return asCell()-&gt;methodTable(exec-&gt;vm())-&gt;put(asCell(), exec, propertyName, value, slot);
 945 }
 946 
 947 ALWAYS_INLINE bool JSValue::putInline(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 948 {
 949     if (UNLIKELY(!isCell()))
 950         return putToPrimitive(exec, propertyName, value, slot);
 951     return asCell()-&gt;putInline(exec, propertyName, value, slot);
 952 }
 953 
 954 inline bool JSValue::putByIndex(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 955 {
 956     if (UNLIKELY(!isCell()))
 957         return putToPrimitiveByIndex(exec, propertyName, value, shouldThrow);
 958 
 959     return asCell()-&gt;methodTable(exec-&gt;vm())-&gt;putByIndex(asCell(), exec, propertyName, value, shouldThrow);
 960 }
 961 
 962 inline Structure* JSValue::structureOrNull() const
 963 {
 964     if (isCell())
 965         return asCell()-&gt;structure();
 966     return nullptr;
 967 }
 968 
 969 inline JSValue JSValue::structureOrUndefined() const
 970 {
 971     if (isCell())
 972         return JSValue(asCell()-&gt;structure());
 973     return jsUndefined();
 974 }
 975 
 976 // ECMA 11.9.3
 977 inline bool JSValue::equal(ExecState* exec, JSValue v1, JSValue v2)
 978 {
 979     if (v1.isInt32() &amp;&amp; v2.isInt32())
 980         return v1 == v2;
 981 
 982     return equalSlowCase(exec, v1, v2);
 983 }
 984 
 985 ALWAYS_INLINE bool JSValue::equalSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)
 986 {
 987     VM&amp; vm = exec-&gt;vm();
 988     auto scope = DECLARE_THROW_SCOPE(vm);
 989     do {
 990         if (v1.isNumber() &amp;&amp; v2.isNumber())
 991             return v1.asNumber() == v2.asNumber();
 992 
 993         bool s1 = v1.isString();
 994         bool s2 = v2.isString();
 995         if (s1 &amp;&amp; s2)
 996             RELEASE_AND_RETURN(scope, asString(v1)-&gt;equal(exec, asString(v2)));
 997 
 998         if (v1.isBigInt() &amp;&amp; s2) {
 999             JSBigInt* n = JSBigInt::stringToBigInt(exec, asString(v2)-&gt;value(exec));
1000             RETURN_IF_EXCEPTION(scope, false);
1001             if (!n)
1002                 return false;
1003 
1004             v2 = JSValue(n);
1005             continue;
1006         }
1007 
1008         if (s1 &amp;&amp; v2.isBigInt()) {
1009             JSBigInt* n = JSBigInt::stringToBigInt(exec, asString(v1)-&gt;value(exec));
1010             RETURN_IF_EXCEPTION(scope, false);
1011             if (!n)
1012                 return false;
1013 
1014             v1 = JSValue(n);
1015             continue;
1016         }
1017 
1018         if (v1.isUndefinedOrNull()) {
1019             if (v2.isUndefinedOrNull())
1020                 return true;
1021             if (!v2.isCell())
1022                 return false;
1023             return v2.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());
1024         }
1025 
1026         if (v2.isUndefinedOrNull()) {
1027             if (!v1.isCell())
1028                 return false;
1029             return v1.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());
1030         }
1031 
1032         if (v1.isObject()) {
1033             if (v2.isObject())
1034                 return v1 == v2;
1035             JSValue p1 = v1.toPrimitive(exec);
1036             RETURN_IF_EXCEPTION(scope, false);
1037             v1 = p1;
1038             if (v1.isInt32() &amp;&amp; v2.isInt32())
1039                 return v1 == v2;
1040             continue;
1041         }
1042 
1043         if (v2.isObject()) {
1044             JSValue p2 = v2.toPrimitive(exec);
1045             RETURN_IF_EXCEPTION(scope, false);
1046             v2 = p2;
1047             if (v1.isInt32() &amp;&amp; v2.isInt32())
1048                 return v1 == v2;
1049             continue;
1050         }
1051 
1052         bool sym1 = v1.isSymbol();
1053         bool sym2 = v2.isSymbol();
1054         if (sym1 || sym2) {
1055             if (sym1 &amp;&amp; sym2)
1056                 return asSymbol(v1) == asSymbol(v2);
1057             return false;
1058         }
1059 
1060         if (s1 || s2) {
1061             double d1 = v1.toNumber(exec);
1062             RETURN_IF_EXCEPTION(scope, false);
1063             double d2 = v2.toNumber(exec);
1064             RETURN_IF_EXCEPTION(scope, false);
1065             return d1 == d2;
1066         }
1067 
1068         if (v1.isBoolean()) {
1069             if (v2.isNumber())
1070                 return static_cast&lt;double&gt;(v1.asBoolean()) == v2.asNumber();
1071             else if (v2.isBigInt()) {
1072                 v1 = JSValue(v1.toNumber(exec));
1073                 continue;
1074             }
1075         } else if (v2.isBoolean()) {
1076             if (v1.isNumber())
1077                 return v1.asNumber() == static_cast&lt;double&gt;(v2.asBoolean());
1078             else if (v1.isBigInt()) {
1079                 v2 = JSValue(v2.toNumber(exec));
1080                 continue;
1081             }
1082         }
1083 
1084         if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1085             return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1086 
1087         if (v1.isBigInt() &amp;&amp; v2.isNumber())
1088             return asBigInt(v1)-&gt;equalsToNumber(v2);
1089 
1090         if (v2.isBigInt() &amp;&amp; v1.isNumber())
1091             return asBigInt(v2)-&gt;equalsToNumber(v1);
1092 
1093         return v1 == v2;
1094     } while (true);
1095 }
1096 
1097 // ECMA 11.9.3
1098 ALWAYS_INLINE bool JSValue::strictEqualSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)
1099 {
1100     ASSERT(v1.isCell() &amp;&amp; v2.isCell());
1101 
1102     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString())
1103         return asString(v1)-&gt;equal(exec, asString(v2));
1104     if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1105         return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1106     return v1 == v2;
1107 }
1108 
1109 inline bool JSValue::strictEqual(ExecState* exec, JSValue v1, JSValue v2)
1110 {
1111     if (v1.isInt32() &amp;&amp; v2.isInt32())
1112         return v1 == v2;
1113 
1114     if (v1.isNumber() &amp;&amp; v2.isNumber())
1115         return v1.asNumber() == v2.asNumber();
1116 
1117     if (!v1.isCell() || !v2.isCell())
1118         return v1 == v2;
1119 
1120     return strictEqualSlowCaseInline(exec, v1, v2);
1121 }
1122 
1123 inline int32_t JSValue::asInt32ForArithmetic() const
1124 {
1125     if (isBoolean())
1126         return asBoolean();
1127     return asInt32();
1128 }
1129 
1130 inline TriState JSValue::pureStrictEqual(JSValue v1, JSValue v2)
1131 {
1132     if (v1.isInt32() &amp;&amp; v2.isInt32())
1133         return triState(v1 == v2);
1134 
1135     if (v1.isNumber() &amp;&amp; v2.isNumber())
1136         return triState(v1.asNumber() == v2.asNumber());
1137 
1138     if (!v1.isCell() || !v2.isCell())
1139         return triState(v1 == v2);
1140 
1141     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString()) {
1142         const StringImpl* v1String = asString(v1)-&gt;tryGetValueImpl();
1143         const StringImpl* v2String = asString(v2)-&gt;tryGetValueImpl();
1144         if (!v1String || !v2String)
1145             return MixedTriState;
1146         return triState(WTF::equal(*v1String, *v2String));
1147     }
1148 
1149     return triState(v1 == v2);
1150 }
1151 
1152 inline TriState JSValue::pureToBoolean() const
1153 {
1154     if (isInt32())
1155         return asInt32() ? TrueTriState : FalseTriState;
1156     if (isDouble())
1157         return isNotZeroAndOrdered(asDouble()) ? TrueTriState : FalseTriState; // false for NaN
1158     if (isCell())
1159         return asCell()-&gt;pureToBoolean();
1160     return isTrue() ? TrueTriState : FalseTriState;
1161 }
1162 
1163 ALWAYS_INLINE bool JSValue::requireObjectCoercible(ExecState* exec) const
1164 {
1165     VM&amp; vm = exec-&gt;vm();
1166     auto scope = DECLARE_THROW_SCOPE(vm);
1167 
1168     if (!isUndefinedOrNull())
1169         return true;
1170     throwException(exec, scope, createNotAnObjectError(exec, *this));
1171     return false;
1172 }
1173 
1174 ALWAYS_INLINE bool isThisValueAltered(const PutPropertySlot&amp; slot, JSObject* baseObject)
1175 {
1176     JSValue thisValue = slot.thisValue();
1177     if (LIKELY(thisValue == baseObject))
1178         return false;
1179 
1180     if (!thisValue.isObject())
1181         return true;
1182     JSObject* thisObject = asObject(thisValue);
1183     // Only PureForwardingProxyType can be seen as the same to the original target object.
1184     if (thisObject-&gt;type() == PureForwardingProxyType &amp;&amp; jsCast&lt;JSProxy*&gt;(thisObject)-&gt;target() == baseObject)
1185         return false;
1186     return true;
1187 }
1188 
1189 // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
1190 ALWAYS_INLINE bool sameValue(ExecState* exec, JSValue a, JSValue b)
1191 {
1192     if (!a.isNumber())
1193         return JSValue::strictEqual(exec, a, b);
1194     if (!b.isNumber())
1195         return false;
1196     double x = a.asNumber();
1197     double y = b.asNumber();
1198     bool xIsNaN = std::isnan(x);
1199     bool yIsNaN = std::isnan(y);
1200     if (xIsNaN || yIsNaN)
1201         return xIsNaN &amp;&amp; yIsNaN;
1202     return bitwise_cast&lt;uint64_t&gt;(x) == bitwise_cast&lt;uint64_t&gt;(y);
1203 }
1204 
1205 } // namespace JSC
    </pre>
  </body>
</html>