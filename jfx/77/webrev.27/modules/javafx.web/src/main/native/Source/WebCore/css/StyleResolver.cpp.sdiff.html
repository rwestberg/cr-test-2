<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleProperties.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleResolver.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59 #include &quot;Frame.h&quot;
  60 #include &quot;FrameSelection.h&quot;
  61 #include &quot;FrameView.h&quot;
  62 #include &quot;HTMLInputElement.h&quot;
  63 #include &quot;HTMLMarqueeElement.h&quot;
  64 #include &quot;HTMLNames.h&quot;
  65 #include &quot;HTMLSlotElement.h&quot;
  66 #include &quot;HTMLTableElement.h&quot;
  67 #include &quot;HTMLTextAreaElement.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;KeyframeList.h&quot;
  70 #include &quot;Logging.h&quot;
  71 #include &quot;MathMLElement.h&quot;
  72 #include &quot;MathMLNames.h&quot;
  73 #include &quot;MediaList.h&quot;
  74 #include &quot;MediaQueryEvaluator.h&quot;
  75 #include &quot;NodeRenderStyle.h&quot;
  76 #include &quot;PageRuleCollector.h&quot;
  77 #include &quot;PaintWorkletGlobalScope.h&quot;
  78 #include &quot;Pair.h&quot;

  79 #include &quot;RenderScrollbar.h&quot;
  80 #include &quot;RenderStyleConstants.h&quot;
  81 #include &quot;RenderTheme.h&quot;
  82 #include &quot;RenderView.h&quot;
  83 #include &quot;RuleSet.h&quot;
  84 #include &quot;RuntimeEnabledFeatures.h&quot;
  85 #include &quot;SVGDocument.h&quot;
  86 #include &quot;SVGDocumentExtensions.h&quot;
  87 #include &quot;SVGFontFaceElement.h&quot;
  88 #include &quot;SVGNames.h&quot;
  89 #include &quot;SVGSVGElement.h&quot;
  90 #include &quot;SVGURIReference.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;ShadowRoot.h&quot;
  93 #include &quot;SharedStringHash.h&quot;
  94 #include &quot;StyleBuilder.h&quot;
  95 #include &quot;StyleColor.h&quot;
  96 #include &quot;StyleCachedImage.h&quot;
  97 #include &quot;StyleFontSizeFunctions.h&quot;
  98 #include &quot;StyleGeneratedImage.h&quot;
  99 #include &quot;StyleProperties.h&quot;
 100 #include &quot;StylePropertyShorthand.h&quot;
 101 #include &quot;StyleRule.h&quot;
 102 #include &quot;StyleSheetContents.h&quot;
 103 #include &quot;TransformFunctions.h&quot;
 104 #include &quot;TransformOperations.h&quot;
 105 #include &quot;UserAgentStyleSheets.h&quot;
 106 #include &quot;ViewportStyleResolver.h&quot;
 107 #include &quot;VisitedLinkState.h&quot;
 108 #include &quot;WebKitFontFamilyNames.h&quot;
 109 #include &lt;bitset&gt;
 110 #include &lt;wtf/Seconds.h&gt;
 111 #include &lt;wtf/StdLibExtras.h&gt;
 112 #include &lt;wtf/Vector.h&gt;
<span class="line-modified"> 113 #include &lt;wtf/text/AtomicStringHash.h&gt;</span>
<span class="line-removed"> 114 </span>
<span class="line-removed"> 115 </span>
<span class="line-removed"> 116 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 117 #endif</span>
<span class="line-removed"> 118 </span>
<span class="line-removed"> 119 #if ENABLE(VIDEO_TRACK)</span>
<span class="line-removed"> 120 #endif</span>
 121 
 122 namespace WebCore {
 123 
 124 using namespace HTMLNames;
 125 
 126 static const CSSPropertyID firstLowPriorityProperty = static_cast&lt;CSSPropertyID&gt;(lastHighPriorityProperty + 1);
 127 
 128 static void extractDirectionAndWritingMode(const RenderStyle&amp;, const StyleResolver::MatchResult&amp;, TextDirection&amp;, WritingMode&amp;);
 129 
 130 inline void StyleResolver::State::cacheBorderAndBackground()
 131 {
 132     m_hasUAAppearance = m_style-&gt;hasAppearance();
 133     if (m_hasUAAppearance) {
 134         m_borderData = m_style-&gt;border();
 135         m_backgroundData = m_style-&gt;backgroundLayers();
 136         m_backgroundColor = m_style-&gt;backgroundColor();
 137     }
 138 }
 139 
 140 inline void StyleResolver::State::clear()
</pre>
<hr />
<pre>
 244             m_document.fontSelector().addFontFaceRule(svgFontFaceElement-&gt;fontFaceRule(), svgFontFaceElement-&gt;isInUserAgentShadowTree());
 245     }
 246 #endif
 247 }
 248 
 249 void StyleResolver::appendAuthorStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; styleSheets)
 250 {
 251     m_ruleSets.appendAuthorStyleSheets(styleSheets, &amp;m_mediaQueryEvaluator, m_inspectorCSSOMWrappers, this);
 252 
 253     if (auto renderView = document().renderView())
 254         renderView-&gt;style().fontCascade().update(&amp;document().fontSelector());
 255 
 256 #if ENABLE(CSS_DEVICE_ADAPTATION)
 257     viewportStyleResolver()-&gt;resolve();
 258 #endif
 259 }
 260 
 261 // This is a simplified style setting function for keyframe styles
 262 void StyleResolver::addKeyframeStyle(Ref&lt;StyleRuleKeyframes&gt;&amp;&amp; rule)
 263 {
<span class="line-modified"> 264     AtomicString s(rule-&gt;name());</span>
 265     m_keyframesRuleMap.set(s.impl(), WTFMove(rule));
 266 }
 267 
 268 StyleResolver::~StyleResolver()
 269 {
 270     RELEASE_ASSERT(!m_document.isResolvingTreeStyle());
 271     RELEASE_ASSERT(!m_isDeleted);
 272     m_isDeleted = true;
 273 
 274 #if ENABLE(CSS_DEVICE_ADAPTATION)
 275     m_viewportStyleResolver-&gt;clearDocument();
 276 #endif
 277 }
 278 
 279 void StyleResolver::sweepMatchedPropertiesCache()
 280 {
 281     // Look for cache entries containing a style declaration with a single ref and remove them.
 282     // This may happen when an element attribute mutation causes it to generate a new inlineStyle()
 283     // or presentationAttributeStyle(), potentially leaving this cache with the last ref on the old one.
 284     Vector&lt;unsigned, 16&gt; toRemove;
</pre>
<hr />
<pre>
 448 
 449     cascade.applyDeferredProperties(*this, applyState);
 450 
 451     adjustRenderStyle(*state.style(), *state.parentStyle(), nullptr, nullptr);
 452 
 453     // Add all the animating properties to the keyframe.
 454     unsigned propertyCount = keyframe-&gt;properties().propertyCount();
 455     for (unsigned i = 0; i &lt; propertyCount; ++i) {
 456         CSSPropertyID property = keyframe-&gt;properties().propertyAt(i).id();
 457         // Timing-function within keyframes is special, because it is not animated; it just
 458         // describes the timing function between this keyframe and the next.
 459         if (property != CSSPropertyAnimationTimingFunction)
 460             keyframeValue.addProperty(property);
 461     }
 462 
 463     return state.takeStyle();
 464 }
 465 
 466 bool StyleResolver::isAnimationNameValid(const String&amp; name)
 467 {
<span class="line-modified"> 468     return m_keyframesRuleMap.find(AtomicString(name).impl()) != m_keyframesRuleMap.end();</span>
 469 }
 470 
 471 void StyleResolver::keyframeStylesForAnimation(const Element&amp; element, const RenderStyle* elementStyle, KeyframeList&amp; list)
 472 {
 473     list.clear();
 474 
 475     // Get the keyframesRule for this name.
 476     if (list.animationName().isEmpty())
 477         return;
 478 
 479     m_keyframesRuleMap.checkConsistency();
 480 
 481     KeyframesRuleMap::iterator it = m_keyframesRuleMap.find(list.animationName().impl());
 482     if (it == m_keyframesRuleMap.end())
 483         return;
 484 
 485     const StyleRuleKeyframes* keyframesRule = it-&gt;value.get();
 486 
 487     auto* keyframes = &amp;keyframesRule-&gt;keyframes();
 488     Vector&lt;Ref&lt;StyleRuleKeyframe&gt;&gt; newKeyframesIfNecessary;
</pre>
<hr />
<pre>
 678             style.setMarginRight(Length(intrinsicMargin, Fixed));
 679     }
 680 
 681     if (style.height().isAuto()) {
 682         if (style.marginTop().hasQuirk())
 683             style.setMarginTop(Length(intrinsicMargin, Fixed));
 684         if (style.marginBottom().hasQuirk())
 685             style.setMarginBottom(Length(intrinsicMargin, Fixed));
 686     }
 687 }
 688 
 689 static DisplayType equivalentBlockDisplay(const RenderStyle&amp; style, const Document&amp; document)
 690 {
 691     switch (auto display = style.display()) {
 692     case DisplayType::Block:
 693     case DisplayType::Table:
 694     case DisplayType::Box:
 695     case DisplayType::Flex:
 696     case DisplayType::WebKitFlex:
 697     case DisplayType::Grid:

 698         return display;
 699 
 700     case DisplayType::ListItem:
 701         // It is a WinIE bug that floated list items lose their bullets, so we&#39;ll emulate the quirk, but only in quirks mode.
 702         if (document.inQuirksMode() &amp;&amp; style.isFloating())
 703             return DisplayType::Block;
 704         return display;
 705     case DisplayType::InlineTable:
 706         return DisplayType::Table;
 707     case DisplayType::InlineBox:
 708         return DisplayType::Box;
 709     case DisplayType::InlineFlex:
 710     case DisplayType::WebKitInlineFlex:
 711         return DisplayType::Flex;
 712     case DisplayType::InlineGrid:
 713         return DisplayType::Grid;
 714 
 715     case DisplayType::Inline:
 716     case DisplayType::Compact:
 717     case DisplayType::InlineBlock:
</pre>
<hr />
<pre>
 728         ASSERT_NOT_REACHED();
 729         return DisplayType::Contents;
 730     case DisplayType::None:
 731         ASSERT_NOT_REACHED();
 732         return DisplayType::None;
 733     }
 734     ASSERT_NOT_REACHED();
 735     return DisplayType::Block;
 736 }
 737 
 738 // CSS requires text-decoration to be reset at each DOM element for tables,
 739 // inline blocks, inline tables, shadow DOM crossings, floating elements,
 740 // and absolute or relatively positioned elements.
 741 static bool doesNotInheritTextDecoration(const RenderStyle&amp; style, const Element* element)
 742 {
 743     return style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
 744         || style.display() == DisplayType::InlineBlock || style.display() == DisplayType::InlineBox || (element &amp;&amp; isAtShadowBoundary(*element))
 745         || style.isFloating() || style.hasOutOfFlowPosition();
 746 }
 747 
<span class="line-modified"> 748 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 749 static bool isScrollableOverflow(Overflow overflow)
 750 {
 751     return overflow == Overflow::Scroll || overflow == Overflow::Auto;
 752 }
 753 #endif
 754 
 755 void StyleResolver::adjustStyleForInterCharacterRuby()
 756 {
 757     RenderStyle* style = m_state.style();
 758     if (style-&gt;rubyPosition() != RubyPosition::InterCharacter || !m_state.element() || !m_state.element()-&gt;hasTagName(rtTag))
 759         return;
 760     style-&gt;setTextAlign(TextAlignMode::Center);
 761     if (style-&gt;isHorizontalWritingMode())
 762         style-&gt;setWritingMode(LeftToRightWritingMode);
 763 }
 764 
 765 static bool hasEffectiveDisplayNoneForDisplayContents(const Element&amp; element)
 766 {
 767     // https://drafts.csswg.org/css-display-3/#unbox-html
<span class="line-modified"> 768     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; tagNames = [] {</span>
 769         static const HTMLQualifiedName* const tagList[] = {
 770             &amp;brTag.get(),
 771             &amp;wbrTag.get(),
 772             &amp;meterTag.get(),
 773             &amp;appletTag.get(),
 774             &amp;progressTag.get(),
 775             &amp;canvasTag.get(),
 776             &amp;embedTag.get(),
 777             &amp;objectTag.get(),
 778             &amp;audioTag.get(),
 779             &amp;iframeTag.get(),
 780             &amp;imgTag.get(),
 781             &amp;videoTag.get(),
 782             &amp;frameTag.get(),
 783             &amp;framesetTag.get(),
 784             &amp;inputTag.get(),
 785             &amp;textareaTag.get(),
 786             &amp;selectTag.get(),
 787         };
<span class="line-modified"> 788         HashSet&lt;AtomicString&gt; set;</span>
 789         for (auto&amp; name : tagList)
 790             set.add(name-&gt;localName());
 791         return set;
 792     }();
 793 
 794     // https://drafts.csswg.org/css-display-3/#unbox-svg
 795     // FIXME: &lt;g&gt;, &lt;use&gt; and &lt;tspan&gt; have special (?) behavior for display:contents in the current draft spec.
 796     if (is&lt;SVGElement&gt;(element))
 797         return true;
 798 #if ENABLE(MATHML)
 799     // Not sure MathML code can handle it.
 800     if (is&lt;MathMLElement&gt;(element))
 801         return true;
 802 #endif // ENABLE(MATHML)
 803     if (!is&lt;HTMLElement&gt;(element))
 804         return false;
 805     return tagNames.get().contains(element.localName());
 806 }
 807 
 808 static void adjustDisplayContentsStyle(RenderStyle&amp; style, const Element* element)
</pre>
<hr />
<pre>
 825         style.setDisplay(DisplayType::None);
 826 }
 827 
 828 void StyleResolver::adjustSVGElementStyle(const SVGElement&amp; svgElement, RenderStyle&amp; style)
 829 {
 830     // Only the root &lt;svg&gt; element in an SVG document fragment tree honors css position
 831     auto isPositioningAllowed = svgElement.hasTagName(SVGNames::svgTag) &amp;&amp; svgElement.parentNode() &amp;&amp; !svgElement.parentNode()-&gt;isSVGElement() &amp;&amp; !svgElement.correspondingElement();
 832     if (!isPositioningAllowed)
 833         style.setPosition(RenderStyle::initialPosition());
 834 
 835     // RenderSVGRoot handles zooming for the whole SVG subtree, so foreignObject content should
 836     // not be scaled again.
 837     if (svgElement.hasTagName(SVGNames::foreignObjectTag))
 838         style.setEffectiveZoom(RenderStyle::initialZoom());
 839 
 840     // SVG text layout code expects us to be a block-level style element.
 841     if ((svgElement.hasTagName(SVGNames::foreignObjectTag) || svgElement.hasTagName(SVGNames::textTag)) &amp;&amp; style.isDisplayInlineType())
 842         style.setDisplay(DisplayType::Block);
 843 }
 844 


































































































 845 void StyleResolver::adjustRenderStyle(RenderStyle&amp; style, const RenderStyle&amp; parentStyle, const RenderStyle* parentBoxStyle, const Element* element)
 846 {
 847     // If the composed tree parent has display:contents, the parent box style will be different from the parent style.
 848     // We don&#39;t have it when resolving computed style for display:none subtree. Use parent style for adjustments in that case.
 849     if (!parentBoxStyle)
 850         parentBoxStyle = &amp;parentStyle;
 851 
 852     // Cache our original display.
 853     style.setOriginalDisplay(style.display());
 854 
 855     if (style.display() == DisplayType::Contents)
 856         adjustDisplayContentsStyle(style, element);
 857 
 858     if (style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents) {
 859         if (element) {
 860             // If we have a &lt;td&gt; that specifies a float property, in quirks mode we just drop the float
 861             // property.
 862             // Sites also commonly use display:inline/block on &lt;td&gt;s and &lt;table&gt;s. In quirks mode we force
 863             // these tags to retain their display types.
 864             if (document().inQuirksMode()) {
</pre>
<hr />
<pre>
1020     // Style::createForDocument().
1021     if ((style.overflowY() == Overflow::PagedX || style.overflowY() == Overflow::PagedY) &amp;&amp; !(element &amp;&amp; (element-&gt;hasTagName(htmlTag) || element-&gt;hasTagName(bodyTag))))
1022         style.setColumnStylesFromPaginationMode(WebCore::paginationModeForRenderStyle(style));
1023 
1024     // Table rows, sections and the table itself will support overflow:hidden and will ignore scroll/auto.
1025     // FIXME: Eventually table sections will support auto and scroll.
1026     if (style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
1027         || style.display() == DisplayType::TableRowGroup || style.display() == DisplayType::TableRow) {
1028         if (style.overflowX() != Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Hidden)
1029             style.setOverflowX(Overflow::Visible);
1030         if (style.overflowY() != Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Hidden)
1031             style.setOverflowY(Overflow::Visible);
1032     }
1033 
1034     // Menulists should have visible overflow
1035     if (style.appearance() == MenulistPart) {
1036         style.setOverflowX(Overflow::Visible);
1037         style.setOverflowY(Overflow::Visible);
1038     }
1039 
<span class="line-modified">1040 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
1041     // Touch overflow scrolling creates a stacking context.
1042     if (style.hasAutoZIndex() &amp;&amp; style.useTouchOverflowScrolling() &amp;&amp; (isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY())))
1043         style.setZIndex(0);
1044 #endif
1045 
1046     // Cull out any useless layers and also repeat patterns into additional layers.
1047     style.adjustBackgroundLayers();
1048     style.adjustMaskLayers();
1049 
1050     // Do the same for animations and transitions.
1051     style.adjustAnimations();
1052     style.adjustTransitions();
1053 
1054     // Important: Intrinsic margins get added to controls before the theme has adjusted the style, since the theme will
1055     // alter fonts and heights/widths.
1056     if (is&lt;HTMLFormControlElement&gt;(element) &amp;&amp; style.computedFontPixelSize() &gt;= 11) {
1057         // Don&#39;t apply intrinsic margins to image buttons. The designer knows how big the images are,
1058         // so we have to treat all image buttons as though they were explicitly sized.
1059         if (!is&lt;HTMLInputElement&gt;(*element) || !downcast&lt;HTMLInputElement&gt;(*element).isImageButton())
1060             addIntrinsicMargins(style);
</pre>
<hr />
<pre>
1070 
1071     // FIXME: when dropping the -webkit prefix on transform-style, we should also have opacity &lt; 1 cause flattening.
1072     if (style.preserves3D() &amp;&amp; (style.overflowX() != Overflow::Visible
1073         || style.overflowY() != Overflow::Visible
1074         || style.hasClip()
1075         || style.clipPath()
1076         || style.hasFilter()
1077 #if ENABLE(FILTERS_LEVEL_2)
1078         || style.hasBackdropFilter()
1079 #endif
1080         || style.hasBlendMode()))
1081         style.setTransformStyle3D(TransformStyle3D::Flat);
1082 
1083     if (is&lt;SVGElement&gt;(element))
1084         adjustSVGElementStyle(downcast&lt;SVGElement&gt;(*element), style);
1085 
1086     // If the inherited value of justify-items includes the &#39;legacy&#39; keyword (plus &#39;left&#39;, &#39;right&#39; or
1087     // &#39;center&#39;), &#39;legacy&#39; computes to the the inherited value. Otherwise, &#39;auto&#39; computes to &#39;normal&#39;.
1088     if (parentBoxStyle-&gt;justifyItems().positionType() == ItemPositionType::Legacy &amp;&amp; style.justifyItems().position() == ItemPosition::Legacy)
1089         style.setJustifyItems(parentBoxStyle-&gt;justifyItems());











1090 }
1091 
<span class="line-modified">1092 static void checkForOrientationChange(RenderStyle* style)</span>
1093 {
<span class="line-modified">1094     FontOrientation fontOrientation;</span>
<span class="line-modified">1095     NonCJKGlyphOrientation glyphOrientation;</span>
<span class="line-modified">1096     std::tie(fontOrientation, glyphOrientation) = style-&gt;fontAndGlyphOrientation();</span>










1097 
<span class="line-modified">1098     const auto&amp; fontDescription = style-&gt;fontDescription();</span>




1099     if (fontDescription.orientation() == fontOrientation &amp;&amp; fontDescription.nonCJKGlyphOrientation() == glyphOrientation)
1100         return;
1101 
1102     auto newFontDescription = fontDescription;
1103     newFontDescription.setNonCJKGlyphOrientation(glyphOrientation);
1104     newFontDescription.setOrientation(fontOrientation);
<span class="line-modified">1105     style-&gt;setFontDescription(WTFMove(newFontDescription));</span>
1106 }
1107 
1108 void StyleResolver::updateFont()
1109 {
1110     if (!m_state.fontDirty())
1111         return;
1112 
<span class="line-modified">1113     RenderStyle* style = m_state.style();</span>
1114 #if ENABLE(TEXT_AUTOSIZING)
1115     checkForTextSizeAdjust(style);
1116 #endif
1117     checkForGenericFamilyChange(style, m_state.parentStyle());
1118     checkForZoomChange(style, m_state.parentStyle());
1119     checkForOrientationChange(style);
<span class="line-modified">1120     style-&gt;fontCascade().update(&amp;document().fontSelector());</span>
1121     if (m_state.fontSizeHasViewportUnits())
<span class="line-modified">1122         style-&gt;setHasViewportUnits(true);</span>
1123     m_state.setFontDirty(false);
1124 }
1125 
1126 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::styleRulesForElement(const Element* element, unsigned rulesToInclude)
1127 {
1128     return pseudoStyleRulesForElement(element, PseudoId::None, rulesToInclude);
1129 }
1130 
1131 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::pseudoStyleRulesForElement(const Element* element, PseudoId pseudoId, unsigned rulesToInclude)
1132 {
1133     if (!element)
1134         return { };
1135 
1136     m_state = State(*element, nullptr);
1137 
1138     ElementRuleCollector collector(*element, m_ruleSets, m_state.selectorFilter());
1139     collector.setMode(SelectorChecker::Mode::CollectingRules);
1140     collector.setPseudoStyleRequest(PseudoStyleRequest(pseudoId));
1141     collector.setMedium(&amp;m_mediaQueryEvaluator);
1142 
</pre>
<hr />
<pre>
1367     TextDirection direction;
1368     WritingMode writingMode;
1369     extractDirectionAndWritingMode(*state.style(), matchResult, direction, writingMode);
1370 
1371     if (elementTypeHasAppearanceFromUAStyle(*state.element())) {
1372         // FIXME: This is such a hack.
1373         // Find out if there&#39;s a -webkit-appearance property in effect from the UA sheet.
1374         // If so, we cache the border and background styles so that RenderTheme::adjustStyle()
1375         // can look at them later to figure out if this is a styled form control or not.
1376         CascadedProperties cascade(direction, writingMode);
1377         cascade.addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1378         cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1379 
1380         ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1381 
1382         applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1383         adjustStyleForInterCharacterRuby();
1384 
1385 #if ENABLE(DARK_MODE_CSS)
1386         // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
<span class="line-modified">1387         applyCascadedProperties(CSSPropertySupportedColorSchemes, CSSPropertySupportedColorSchemes, applyState);</span>
1388 #endif
1389 
1390         applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1391 
1392         // If our font got dirtied, update it now.
1393         updateFont();
1394 
1395         // Now resolve remaining custom properties and the rest, in any order
1396         for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1397             applyCascadedCustomProperty(it-&gt;key, applyState);
1398         applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1399 
1400         state.cacheBorderAndBackground();
1401     }
1402 
1403     CascadedProperties cascade(direction, writingMode);
1404     cascade.addNormalMatches(matchResult, 0, matchResult.matchedProperties().size() - 1, applyInheritedOnly);
1405     cascade.addImportantMatches(matchResult, matchResult.ranges.firstAuthorRule, matchResult.ranges.lastAuthorRule, applyInheritedOnly);
1406     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, applyInheritedOnly);
1407     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1408 
1409     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1410 
1411     applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1412     adjustStyleForInterCharacterRuby();
1413 
1414 #if ENABLE(DARK_MODE_CSS)
1415     // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
<span class="line-modified">1416     applyCascadedProperties(CSSPropertySupportedColorSchemes, CSSPropertySupportedColorSchemes, applyState);</span>
1417 #endif
1418 
1419     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1420 
1421     // If the effective zoom value changes, we can&#39;t use the matched properties cache. Start over.
1422     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;effectiveZoom() != state.style()-&gt;effectiveZoom())
1423         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1424 
1425     // If our font got dirtied, update it now.
1426     updateFont();
1427 
1428     // If the font changed, we can&#39;t use the matched properties cache. Start over.
1429     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;fontDescription() != state.style()-&gt;fontDescription())
1430         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1431 
1432     // Now resolve remaining custom properties and the rest, in any order
1433     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1434         applyCascadedCustomProperty(it-&gt;key, applyState);
1435     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1436 
</pre>
<hr />
<pre>
1580 
1581 // Scale with/height properties on inline SVG root.
1582 bool StyleResolver::useSVGZoomRulesForLength() const
1583 {
1584     return is&lt;SVGElement&gt;(m_state.element()) &amp;&amp; !(is&lt;SVGSVGElement&gt;(*m_state.element()) &amp;&amp; m_state.element()-&gt;parentNode());
1585 }
1586 
1587 StyleResolver::CascadedProperties* StyleResolver::cascadedPropertiesForRollback(const MatchResult&amp; matchResult)
1588 {
1589     ASSERT(cascadeLevel() != CascadeLevel::UserAgentLevel);
1590 
1591     TextDirection direction;
1592     WritingMode writingMode;
1593     extractDirectionAndWritingMode(*state().style(), matchResult, direction, writingMode);
1594 
1595     if (cascadeLevel() == CascadeLevel::AuthorLevel) {
1596         CascadedProperties* authorRollback = state().authorRollback();
1597         if (authorRollback)
1598             return authorRollback;
1599 
<span class="line-modified">1600         auto newAuthorRollback(std::make_unique&lt;CascadedProperties&gt;(direction, writingMode));</span>
1601 
1602         // This special rollback cascade contains UA rules and user rules but no author rules.
1603         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1604         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1605         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1606         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1607 
1608         state().setAuthorRollback(newAuthorRollback);
1609         return state().authorRollback();
1610     }
1611 
1612     if (cascadeLevel() == CascadeLevel::UserLevel) {
1613         CascadedProperties* userRollback = state().userRollback();
1614         if (userRollback)
1615             return userRollback;
1616 
<span class="line-modified">1617         auto newUserRollback(std::make_unique&lt;CascadedProperties&gt;(direction, writingMode));</span>
1618 
1619         // This special rollback cascade contains only UA rules.
1620         newUserRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1621         newUserRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1622 
1623         state().setUserRollback(newUserRollback);
1624         return state().userRollback();
1625     }
1626 
1627     return nullptr;
1628 }
1629 
1630 void StyleResolver::applyProperty(CSSPropertyID id, CSSValue* value, ApplyCascadedPropertyState&amp; applyState, SelectorChecker::LinkMatchMask linkMatchMask)
1631 {
1632     auto* matchResult = applyState.matchResult;
1633     ASSERT_WITH_MESSAGE(!isShorthandCSSProperty(id), &quot;Shorthand property id = %d wasn&#39;t expanded at parsing time&quot;, id);
1634 
1635     State&amp; state = m_state;
1636 
1637     RefPtr&lt;CSSValue&gt; valueToApply = value;
</pre>
<hr />
<pre>
1746 RefPtr&lt;StyleImage&gt; StyleResolver::styleImage(CSSValue&amp; value)
1747 {
1748     if (is&lt;CSSImageGeneratorValue&gt;(value)) {
1749         if (is&lt;CSSGradientValue&gt;(value))
1750             return StyleGeneratedImage::create(downcast&lt;CSSGradientValue&gt;(value).gradientWithStylesResolved(*this));
1751 
1752         if (is&lt;CSSFilterImageValue&gt;(value)) {
1753             // FilterImage needs to calculate FilterOperations.
1754             downcast&lt;CSSFilterImageValue&gt;(value).createFilterOperations(this);
1755         }
1756         return StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(value));
1757     }
1758 
1759     if (is&lt;CSSImageValue&gt;(value) || is&lt;CSSImageSetValue&gt;(value) || is&lt;CSSCursorImageValue&gt;(value))
1760         return StyleCachedImage::create(value);
1761 
1762     return nullptr;
1763 }
1764 
1765 #if ENABLE(TEXT_AUTOSIZING)
<span class="line-modified">1766 void StyleResolver::checkForTextSizeAdjust(RenderStyle* style)</span>
1767 {
<span class="line-modified">1768     if (style-&gt;textSizeAdjust().isAuto())</span>


1769         return;
1770 
<span class="line-modified">1771     auto newFontDescription = style-&gt;fontDescription();</span>
<span class="line-modified">1772     if (!style-&gt;textSizeAdjust().isNone())</span>
<span class="line-modified">1773         newFontDescription.setComputedSize(newFontDescription.specifiedSize() * style-&gt;textSizeAdjust().multiplier());</span>
1774     else
1775         newFontDescription.setComputedSize(newFontDescription.specifiedSize());
<span class="line-modified">1776     style-&gt;setFontDescription(WTFMove(newFontDescription));</span>
1777 }
1778 #endif
1779 
<span class="line-modified">1780 void StyleResolver::checkForZoomChange(RenderStyle* style, const RenderStyle* parentStyle)</span>
1781 {
1782     if (!parentStyle)
1783         return;
1784 
<span class="line-modified">1785     if (style-&gt;effectiveZoom() == parentStyle-&gt;effectiveZoom() &amp;&amp; style-&gt;textZoom() == parentStyle-&gt;textZoom())</span>
1786         return;
1787 
<span class="line-modified">1788     const auto&amp; childFont = style-&gt;fontDescription();</span>
1789     auto newFontDescription = childFont;
1790     setFontSize(newFontDescription, childFont.specifiedSize());
<span class="line-modified">1791     style-&gt;setFontDescription(WTFMove(newFontDescription));</span>
1792 }
1793 
<span class="line-modified">1794 void StyleResolver::checkForGenericFamilyChange(RenderStyle* style, const RenderStyle* parentStyle)</span>
1795 {
<span class="line-modified">1796     const auto&amp; childFont = style-&gt;fontDescription();</span>
1797 
1798     if (childFont.isAbsoluteSize() || !parentStyle)
1799         return;
1800 
1801     const auto&amp; parentFont = parentStyle-&gt;fontDescription();
1802     if (childFont.useFixedDefaultSize() == parentFont.useFixedDefaultSize())
1803         return;
1804     // We know the parent is monospace or the child is monospace, and that font
1805     // size was unspecified. We want to scale our font size as appropriate.
1806     // If the font uses a keyword size, then we refetch from the table rather than
1807     // multiplying by our scale factor.
1808     float size;
1809     if (CSSValueID sizeIdentifier = childFont.keywordSizeAsIdentifier())
1810         size = Style::fontSizeForKeyword(sizeIdentifier, childFont.useFixedDefaultSize(), document());
1811     else {
1812         float fixedScaleFactor = (settings().defaultFixedFontSize() &amp;&amp; settings().defaultFontSize())
1813             ? static_cast&lt;float&gt;(settings().defaultFixedFontSize()) / settings().defaultFontSize()
1814             : 1;
1815         size = parentFont.useFixedDefaultSize() ?
1816                 childFont.specifiedSize() / fixedScaleFactor :
1817                 childFont.specifiedSize() * fixedScaleFactor;
1818     }
1819 
1820     auto newFontDescription = childFont;
1821     setFontSize(newFontDescription, size);
<span class="line-modified">1822     style-&gt;setFontDescription(WTFMove(newFontDescription));</span>
1823 }
1824 
1825 void StyleResolver::initializeFontStyle()
1826 {
1827     FontCascadeDescription fontDescription;
1828     fontDescription.setRenderingMode(settings().fontRenderingMode());
1829     fontDescription.setOneFamily(standardFamily);
1830     fontDescription.setKeywordSizeFromIdentifier(CSSValueMedium);
1831     setFontSize(fontDescription, Style::fontSizeForKeyword(CSSValueMedium, false, document()));
1832     fontDescription.setShouldAllowUserInstalledFonts(settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No);

1833     setFontDescription(WTFMove(fontDescription));
1834 }
1835 
1836 void StyleResolver::setFontSize(FontCascadeDescription&amp; fontDescription, float size)
1837 {
1838     fontDescription.setSpecifiedSize(size);
1839     fontDescription.setComputedSize(Style::computedFontSizeFromSpecifiedSize(size, fontDescription.isAbsoluteSize(), useSVGZoomRules(), m_state.style(), document()));
1840 }
1841 
1842 bool StyleResolver::colorFromPrimitiveValueIsDerivedFromElement(const CSSPrimitiveValue&amp; value)
1843 {
1844     switch (value.valueID()) {
1845     case CSSValueWebkitText:
1846     case CSSValueWebkitLink:
1847     case CSSValueWebkitActivelink:
1848     case CSSValueCurrentcolor:
1849         return true;
1850     default:
1851         return false;
1852     }
</pre>
</td>
<td>
<hr />
<pre>
  59 #include &quot;Frame.h&quot;
  60 #include &quot;FrameSelection.h&quot;
  61 #include &quot;FrameView.h&quot;
  62 #include &quot;HTMLInputElement.h&quot;
  63 #include &quot;HTMLMarqueeElement.h&quot;
  64 #include &quot;HTMLNames.h&quot;
  65 #include &quot;HTMLSlotElement.h&quot;
  66 #include &quot;HTMLTableElement.h&quot;
  67 #include &quot;HTMLTextAreaElement.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;KeyframeList.h&quot;
  70 #include &quot;Logging.h&quot;
  71 #include &quot;MathMLElement.h&quot;
  72 #include &quot;MathMLNames.h&quot;
  73 #include &quot;MediaList.h&quot;
  74 #include &quot;MediaQueryEvaluator.h&quot;
  75 #include &quot;NodeRenderStyle.h&quot;
  76 #include &quot;PageRuleCollector.h&quot;
  77 #include &quot;PaintWorkletGlobalScope.h&quot;
  78 #include &quot;Pair.h&quot;
<span class="line-added">  79 #include &quot;Quirks.h&quot;</span>
  80 #include &quot;RenderScrollbar.h&quot;
  81 #include &quot;RenderStyleConstants.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RuleSet.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;SVGFontFaceElement.h&quot;
  89 #include &quot;SVGNames.h&quot;
  90 #include &quot;SVGSVGElement.h&quot;
  91 #include &quot;SVGURIReference.h&quot;
  92 #include &quot;Settings.h&quot;
  93 #include &quot;ShadowRoot.h&quot;
  94 #include &quot;SharedStringHash.h&quot;
  95 #include &quot;StyleBuilder.h&quot;
  96 #include &quot;StyleColor.h&quot;
  97 #include &quot;StyleCachedImage.h&quot;
  98 #include &quot;StyleFontSizeFunctions.h&quot;
  99 #include &quot;StyleGeneratedImage.h&quot;
 100 #include &quot;StyleProperties.h&quot;
 101 #include &quot;StylePropertyShorthand.h&quot;
 102 #include &quot;StyleRule.h&quot;
 103 #include &quot;StyleSheetContents.h&quot;
 104 #include &quot;TransformFunctions.h&quot;
 105 #include &quot;TransformOperations.h&quot;
 106 #include &quot;UserAgentStyleSheets.h&quot;
 107 #include &quot;ViewportStyleResolver.h&quot;
 108 #include &quot;VisitedLinkState.h&quot;
 109 #include &quot;WebKitFontFamilyNames.h&quot;
 110 #include &lt;bitset&gt;
 111 #include &lt;wtf/Seconds.h&gt;
 112 #include &lt;wtf/StdLibExtras.h&gt;
 113 #include &lt;wtf/Vector.h&gt;
<span class="line-modified"> 114 #include &lt;wtf/text/AtomStringHash.h&gt;</span>







 115 
 116 namespace WebCore {
 117 
 118 using namespace HTMLNames;
 119 
 120 static const CSSPropertyID firstLowPriorityProperty = static_cast&lt;CSSPropertyID&gt;(lastHighPriorityProperty + 1);
 121 
 122 static void extractDirectionAndWritingMode(const RenderStyle&amp;, const StyleResolver::MatchResult&amp;, TextDirection&amp;, WritingMode&amp;);
 123 
 124 inline void StyleResolver::State::cacheBorderAndBackground()
 125 {
 126     m_hasUAAppearance = m_style-&gt;hasAppearance();
 127     if (m_hasUAAppearance) {
 128         m_borderData = m_style-&gt;border();
 129         m_backgroundData = m_style-&gt;backgroundLayers();
 130         m_backgroundColor = m_style-&gt;backgroundColor();
 131     }
 132 }
 133 
 134 inline void StyleResolver::State::clear()
</pre>
<hr />
<pre>
 238             m_document.fontSelector().addFontFaceRule(svgFontFaceElement-&gt;fontFaceRule(), svgFontFaceElement-&gt;isInUserAgentShadowTree());
 239     }
 240 #endif
 241 }
 242 
 243 void StyleResolver::appendAuthorStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; styleSheets)
 244 {
 245     m_ruleSets.appendAuthorStyleSheets(styleSheets, &amp;m_mediaQueryEvaluator, m_inspectorCSSOMWrappers, this);
 246 
 247     if (auto renderView = document().renderView())
 248         renderView-&gt;style().fontCascade().update(&amp;document().fontSelector());
 249 
 250 #if ENABLE(CSS_DEVICE_ADAPTATION)
 251     viewportStyleResolver()-&gt;resolve();
 252 #endif
 253 }
 254 
 255 // This is a simplified style setting function for keyframe styles
 256 void StyleResolver::addKeyframeStyle(Ref&lt;StyleRuleKeyframes&gt;&amp;&amp; rule)
 257 {
<span class="line-modified"> 258     AtomString s(rule-&gt;name());</span>
 259     m_keyframesRuleMap.set(s.impl(), WTFMove(rule));
 260 }
 261 
 262 StyleResolver::~StyleResolver()
 263 {
 264     RELEASE_ASSERT(!m_document.isResolvingTreeStyle());
 265     RELEASE_ASSERT(!m_isDeleted);
 266     m_isDeleted = true;
 267 
 268 #if ENABLE(CSS_DEVICE_ADAPTATION)
 269     m_viewportStyleResolver-&gt;clearDocument();
 270 #endif
 271 }
 272 
 273 void StyleResolver::sweepMatchedPropertiesCache()
 274 {
 275     // Look for cache entries containing a style declaration with a single ref and remove them.
 276     // This may happen when an element attribute mutation causes it to generate a new inlineStyle()
 277     // or presentationAttributeStyle(), potentially leaving this cache with the last ref on the old one.
 278     Vector&lt;unsigned, 16&gt; toRemove;
</pre>
<hr />
<pre>
 442 
 443     cascade.applyDeferredProperties(*this, applyState);
 444 
 445     adjustRenderStyle(*state.style(), *state.parentStyle(), nullptr, nullptr);
 446 
 447     // Add all the animating properties to the keyframe.
 448     unsigned propertyCount = keyframe-&gt;properties().propertyCount();
 449     for (unsigned i = 0; i &lt; propertyCount; ++i) {
 450         CSSPropertyID property = keyframe-&gt;properties().propertyAt(i).id();
 451         // Timing-function within keyframes is special, because it is not animated; it just
 452         // describes the timing function between this keyframe and the next.
 453         if (property != CSSPropertyAnimationTimingFunction)
 454             keyframeValue.addProperty(property);
 455     }
 456 
 457     return state.takeStyle();
 458 }
 459 
 460 bool StyleResolver::isAnimationNameValid(const String&amp; name)
 461 {
<span class="line-modified"> 462     return m_keyframesRuleMap.find(AtomString(name).impl()) != m_keyframesRuleMap.end();</span>
 463 }
 464 
 465 void StyleResolver::keyframeStylesForAnimation(const Element&amp; element, const RenderStyle* elementStyle, KeyframeList&amp; list)
 466 {
 467     list.clear();
 468 
 469     // Get the keyframesRule for this name.
 470     if (list.animationName().isEmpty())
 471         return;
 472 
 473     m_keyframesRuleMap.checkConsistency();
 474 
 475     KeyframesRuleMap::iterator it = m_keyframesRuleMap.find(list.animationName().impl());
 476     if (it == m_keyframesRuleMap.end())
 477         return;
 478 
 479     const StyleRuleKeyframes* keyframesRule = it-&gt;value.get();
 480 
 481     auto* keyframes = &amp;keyframesRule-&gt;keyframes();
 482     Vector&lt;Ref&lt;StyleRuleKeyframe&gt;&gt; newKeyframesIfNecessary;
</pre>
<hr />
<pre>
 672             style.setMarginRight(Length(intrinsicMargin, Fixed));
 673     }
 674 
 675     if (style.height().isAuto()) {
 676         if (style.marginTop().hasQuirk())
 677             style.setMarginTop(Length(intrinsicMargin, Fixed));
 678         if (style.marginBottom().hasQuirk())
 679             style.setMarginBottom(Length(intrinsicMargin, Fixed));
 680     }
 681 }
 682 
 683 static DisplayType equivalentBlockDisplay(const RenderStyle&amp; style, const Document&amp; document)
 684 {
 685     switch (auto display = style.display()) {
 686     case DisplayType::Block:
 687     case DisplayType::Table:
 688     case DisplayType::Box:
 689     case DisplayType::Flex:
 690     case DisplayType::WebKitFlex:
 691     case DisplayType::Grid:
<span class="line-added"> 692     case DisplayType::FlowRoot:</span>
 693         return display;
 694 
 695     case DisplayType::ListItem:
 696         // It is a WinIE bug that floated list items lose their bullets, so we&#39;ll emulate the quirk, but only in quirks mode.
 697         if (document.inQuirksMode() &amp;&amp; style.isFloating())
 698             return DisplayType::Block;
 699         return display;
 700     case DisplayType::InlineTable:
 701         return DisplayType::Table;
 702     case DisplayType::InlineBox:
 703         return DisplayType::Box;
 704     case DisplayType::InlineFlex:
 705     case DisplayType::WebKitInlineFlex:
 706         return DisplayType::Flex;
 707     case DisplayType::InlineGrid:
 708         return DisplayType::Grid;
 709 
 710     case DisplayType::Inline:
 711     case DisplayType::Compact:
 712     case DisplayType::InlineBlock:
</pre>
<hr />
<pre>
 723         ASSERT_NOT_REACHED();
 724         return DisplayType::Contents;
 725     case DisplayType::None:
 726         ASSERT_NOT_REACHED();
 727         return DisplayType::None;
 728     }
 729     ASSERT_NOT_REACHED();
 730     return DisplayType::Block;
 731 }
 732 
 733 // CSS requires text-decoration to be reset at each DOM element for tables,
 734 // inline blocks, inline tables, shadow DOM crossings, floating elements,
 735 // and absolute or relatively positioned elements.
 736 static bool doesNotInheritTextDecoration(const RenderStyle&amp; style, const Element* element)
 737 {
 738     return style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
 739         || style.display() == DisplayType::InlineBlock || style.display() == DisplayType::InlineBox || (element &amp;&amp; isAtShadowBoundary(*element))
 740         || style.isFloating() || style.hasOutOfFlowPosition();
 741 }
 742 
<span class="line-modified"> 743 #if ENABLE(OVERFLOW_SCROLLING_TOUCH) || ENABLE(POINTER_EVENTS)</span>
 744 static bool isScrollableOverflow(Overflow overflow)
 745 {
 746     return overflow == Overflow::Scroll || overflow == Overflow::Auto;
 747 }
 748 #endif
 749 
 750 void StyleResolver::adjustStyleForInterCharacterRuby()
 751 {
 752     RenderStyle* style = m_state.style();
 753     if (style-&gt;rubyPosition() != RubyPosition::InterCharacter || !m_state.element() || !m_state.element()-&gt;hasTagName(rtTag))
 754         return;
 755     style-&gt;setTextAlign(TextAlignMode::Center);
 756     if (style-&gt;isHorizontalWritingMode())
 757         style-&gt;setWritingMode(LeftToRightWritingMode);
 758 }
 759 
 760 static bool hasEffectiveDisplayNoneForDisplayContents(const Element&amp; element)
 761 {
 762     // https://drafts.csswg.org/css-display-3/#unbox-html
<span class="line-modified"> 763     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {</span>
 764         static const HTMLQualifiedName* const tagList[] = {
 765             &amp;brTag.get(),
 766             &amp;wbrTag.get(),
 767             &amp;meterTag.get(),
 768             &amp;appletTag.get(),
 769             &amp;progressTag.get(),
 770             &amp;canvasTag.get(),
 771             &amp;embedTag.get(),
 772             &amp;objectTag.get(),
 773             &amp;audioTag.get(),
 774             &amp;iframeTag.get(),
 775             &amp;imgTag.get(),
 776             &amp;videoTag.get(),
 777             &amp;frameTag.get(),
 778             &amp;framesetTag.get(),
 779             &amp;inputTag.get(),
 780             &amp;textareaTag.get(),
 781             &amp;selectTag.get(),
 782         };
<span class="line-modified"> 783         HashSet&lt;AtomString&gt; set;</span>
 784         for (auto&amp; name : tagList)
 785             set.add(name-&gt;localName());
 786         return set;
 787     }();
 788 
 789     // https://drafts.csswg.org/css-display-3/#unbox-svg
 790     // FIXME: &lt;g&gt;, &lt;use&gt; and &lt;tspan&gt; have special (?) behavior for display:contents in the current draft spec.
 791     if (is&lt;SVGElement&gt;(element))
 792         return true;
 793 #if ENABLE(MATHML)
 794     // Not sure MathML code can handle it.
 795     if (is&lt;MathMLElement&gt;(element))
 796         return true;
 797 #endif // ENABLE(MATHML)
 798     if (!is&lt;HTMLElement&gt;(element))
 799         return false;
 800     return tagNames.get().contains(element.localName());
 801 }
 802 
 803 static void adjustDisplayContentsStyle(RenderStyle&amp; style, const Element* element)
</pre>
<hr />
<pre>
 820         style.setDisplay(DisplayType::None);
 821 }
 822 
 823 void StyleResolver::adjustSVGElementStyle(const SVGElement&amp; svgElement, RenderStyle&amp; style)
 824 {
 825     // Only the root &lt;svg&gt; element in an SVG document fragment tree honors css position
 826     auto isPositioningAllowed = svgElement.hasTagName(SVGNames::svgTag) &amp;&amp; svgElement.parentNode() &amp;&amp; !svgElement.parentNode()-&gt;isSVGElement() &amp;&amp; !svgElement.correspondingElement();
 827     if (!isPositioningAllowed)
 828         style.setPosition(RenderStyle::initialPosition());
 829 
 830     // RenderSVGRoot handles zooming for the whole SVG subtree, so foreignObject content should
 831     // not be scaled again.
 832     if (svgElement.hasTagName(SVGNames::foreignObjectTag))
 833         style.setEffectiveZoom(RenderStyle::initialZoom());
 834 
 835     // SVG text layout code expects us to be a block-level style element.
 836     if ((svgElement.hasTagName(SVGNames::foreignObjectTag) || svgElement.hasTagName(SVGNames::textTag)) &amp;&amp; style.isDisplayInlineType())
 837         style.setDisplay(DisplayType::Block);
 838 }
 839 
<span class="line-added"> 840 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 841 static OptionSet&lt;TouchAction&gt; computeEffectiveTouchActions(const RenderStyle&amp; style, OptionSet&lt;TouchAction&gt; effectiveTouchActions)</span>
<span class="line-added"> 842 {</span>
<span class="line-added"> 843     // https://w3c.github.io/pointerevents/#determining-supported-touch-behavior</span>
<span class="line-added"> 844     // &quot;A touch behavior is supported if it conforms to the touch-action property of each element between</span>
<span class="line-added"> 845     // the hit tested element and its nearest ancestor with the default touch behavior (including both the</span>
<span class="line-added"> 846     // hit tested element and the element with the default touch behavior).&quot;</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848     bool hasDefaultTouchBehavior = isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY());</span>
<span class="line-added"> 849     if (hasDefaultTouchBehavior)</span>
<span class="line-added"> 850         effectiveTouchActions = RenderStyle::initialTouchActions();</span>
<span class="line-added"> 851 </span>
<span class="line-added"> 852     auto touchActions = style.touchActions();</span>
<span class="line-added"> 853     if (touchActions == RenderStyle::initialTouchActions())</span>
<span class="line-added"> 854         return effectiveTouchActions;</span>
<span class="line-added"> 855 </span>
<span class="line-added"> 856     if (effectiveTouchActions.contains(TouchAction::None))</span>
<span class="line-added"> 857         return { TouchAction::None };</span>
<span class="line-added"> 858 </span>
<span class="line-added"> 859     if (effectiveTouchActions.containsAny({ TouchAction::Auto, TouchAction::Manipulation }))</span>
<span class="line-added"> 860         return touchActions;</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862     if (touchActions.containsAny({ TouchAction::Auto, TouchAction::Manipulation }))</span>
<span class="line-added"> 863         return effectiveTouchActions;</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865     auto sharedTouchActions = effectiveTouchActions &amp; touchActions;</span>
<span class="line-added"> 866     if (sharedTouchActions.isEmpty())</span>
<span class="line-added"> 867         return { TouchAction::None };</span>
<span class="line-added"> 868 </span>
<span class="line-added"> 869     return sharedTouchActions;</span>
<span class="line-added"> 870 }</span>
<span class="line-added"> 871 #endif</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-added"> 874 static bool hasTextChild(const Element&amp; element)</span>
<span class="line-added"> 875 {</span>
<span class="line-added"> 876     for (auto* child = element.firstChild(); child; child = child-&gt;nextSibling()) {</span>
<span class="line-added"> 877         if (is&lt;Text&gt;(child))</span>
<span class="line-added"> 878             return true;</span>
<span class="line-added"> 879     }</span>
<span class="line-added"> 880     return false;</span>
<span class="line-added"> 881 }</span>
<span class="line-added"> 882 </span>
<span class="line-added"> 883 bool StyleResolver::adjustRenderStyleForTextAutosizing(RenderStyle&amp; style, const Element&amp; element)</span>
<span class="line-added"> 884 {</span>
<span class="line-added"> 885     if (!settings().textAutosizingEnabled() || !settings().textAutosizingUsesIdempotentMode())</span>
<span class="line-added"> 886         return false;</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888     AutosizeStatus::updateStatus(style);</span>
<span class="line-added"> 889     if (style.textSizeAdjust().isNone())</span>
<span class="line-added"> 890         return false;</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892     float initialScale = document().page() ? document().page()-&gt;initialScale() : 1;</span>
<span class="line-added"> 893     auto adjustLineHeightIfNeeded = [&amp;](auto computedFontSize) {</span>
<span class="line-added"> 894         auto lineHeight = style.specifiedLineHeight();</span>
<span class="line-added"> 895         constexpr static unsigned eligibleFontSize = 12;</span>
<span class="line-added"> 896         if (computedFontSize * initialScale &gt;= eligibleFontSize)</span>
<span class="line-added"> 897             return;</span>
<span class="line-added"> 898 </span>
<span class="line-added"> 899         constexpr static float boostFactor = 1.25;</span>
<span class="line-added"> 900         auto minimumLineHeight = boostFactor * computedFontSize;</span>
<span class="line-added"> 901         if (!lineHeight.isFixed() || lineHeight.value() &gt;= minimumLineHeight)</span>
<span class="line-added"> 902             return;</span>
<span class="line-added"> 903 </span>
<span class="line-added"> 904         if (AutosizeStatus::probablyContainsASmallFixedNumberOfLines(style))</span>
<span class="line-added"> 905             return;</span>
<span class="line-added"> 906 </span>
<span class="line-added"> 907         style.setLineHeight({ minimumLineHeight, Fixed });</span>
<span class="line-added"> 908     };</span>
<span class="line-added"> 909 </span>
<span class="line-added"> 910     auto fontDescription = style.fontDescription();</span>
<span class="line-added"> 911     auto initialComputedFontSize = fontDescription.computedSize();</span>
<span class="line-added"> 912     auto specifiedFontSize = fontDescription.specifiedSize();</span>
<span class="line-added"> 913     bool isCandidate = style.isIdempotentTextAutosizingCandidate();</span>
<span class="line-added"> 914     if (!isCandidate &amp;&amp; WTF::areEssentiallyEqual(initialComputedFontSize, specifiedFontSize))</span>
<span class="line-added"> 915         return false;</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917     auto adjustedFontSize = AutosizeStatus::idempotentTextSize(fontDescription.specifiedSize(), initialScale);</span>
<span class="line-added"> 918     if (isCandidate &amp;&amp; WTF::areEssentiallyEqual(initialComputedFontSize, adjustedFontSize))</span>
<span class="line-added"> 919         return false;</span>
<span class="line-added"> 920 </span>
<span class="line-added"> 921     if (!hasTextChild(element))</span>
<span class="line-added"> 922         return false;</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924     fontDescription.setComputedSize(isCandidate ? adjustedFontSize : specifiedFontSize);</span>
<span class="line-added"> 925     style.setFontDescription(WTFMove(fontDescription));</span>
<span class="line-added"> 926     style.fontCascade().update(&amp;document().fontSelector());</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928     // FIXME: We should restore computed line height to its original value in the case where the element is not</span>
<span class="line-added"> 929     // an idempotent text autosizing candidate; otherwise, if an element that is a text autosizing candidate contains</span>
<span class="line-added"> 930     // children which are not autosized, the non-autosized content will end up with a boosted line height.</span>
<span class="line-added"> 931     if (isCandidate)</span>
<span class="line-added"> 932         adjustLineHeightIfNeeded(adjustedFontSize);</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934     return true;</span>
<span class="line-added"> 935 }</span>
<span class="line-added"> 936 #endif</span>
<span class="line-added"> 937 </span>
 938 void StyleResolver::adjustRenderStyle(RenderStyle&amp; style, const RenderStyle&amp; parentStyle, const RenderStyle* parentBoxStyle, const Element* element)
 939 {
 940     // If the composed tree parent has display:contents, the parent box style will be different from the parent style.
 941     // We don&#39;t have it when resolving computed style for display:none subtree. Use parent style for adjustments in that case.
 942     if (!parentBoxStyle)
 943         parentBoxStyle = &amp;parentStyle;
 944 
 945     // Cache our original display.
 946     style.setOriginalDisplay(style.display());
 947 
 948     if (style.display() == DisplayType::Contents)
 949         adjustDisplayContentsStyle(style, element);
 950 
 951     if (style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents) {
 952         if (element) {
 953             // If we have a &lt;td&gt; that specifies a float property, in quirks mode we just drop the float
 954             // property.
 955             // Sites also commonly use display:inline/block on &lt;td&gt;s and &lt;table&gt;s. In quirks mode we force
 956             // these tags to retain their display types.
 957             if (document().inQuirksMode()) {
</pre>
<hr />
<pre>
1113     // Style::createForDocument().
1114     if ((style.overflowY() == Overflow::PagedX || style.overflowY() == Overflow::PagedY) &amp;&amp; !(element &amp;&amp; (element-&gt;hasTagName(htmlTag) || element-&gt;hasTagName(bodyTag))))
1115         style.setColumnStylesFromPaginationMode(WebCore::paginationModeForRenderStyle(style));
1116 
1117     // Table rows, sections and the table itself will support overflow:hidden and will ignore scroll/auto.
1118     // FIXME: Eventually table sections will support auto and scroll.
1119     if (style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
1120         || style.display() == DisplayType::TableRowGroup || style.display() == DisplayType::TableRow) {
1121         if (style.overflowX() != Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Hidden)
1122             style.setOverflowX(Overflow::Visible);
1123         if (style.overflowY() != Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Hidden)
1124             style.setOverflowY(Overflow::Visible);
1125     }
1126 
1127     // Menulists should have visible overflow
1128     if (style.appearance() == MenulistPart) {
1129         style.setOverflowX(Overflow::Visible);
1130         style.setOverflowY(Overflow::Visible);
1131     }
1132 
<span class="line-modified">1133 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
1134     // Touch overflow scrolling creates a stacking context.
1135     if (style.hasAutoZIndex() &amp;&amp; style.useTouchOverflowScrolling() &amp;&amp; (isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY())))
1136         style.setZIndex(0);
1137 #endif
1138 
1139     // Cull out any useless layers and also repeat patterns into additional layers.
1140     style.adjustBackgroundLayers();
1141     style.adjustMaskLayers();
1142 
1143     // Do the same for animations and transitions.
1144     style.adjustAnimations();
1145     style.adjustTransitions();
1146 
1147     // Important: Intrinsic margins get added to controls before the theme has adjusted the style, since the theme will
1148     // alter fonts and heights/widths.
1149     if (is&lt;HTMLFormControlElement&gt;(element) &amp;&amp; style.computedFontPixelSize() &gt;= 11) {
1150         // Don&#39;t apply intrinsic margins to image buttons. The designer knows how big the images are,
1151         // so we have to treat all image buttons as though they were explicitly sized.
1152         if (!is&lt;HTMLInputElement&gt;(*element) || !downcast&lt;HTMLInputElement&gt;(*element).isImageButton())
1153             addIntrinsicMargins(style);
</pre>
<hr />
<pre>
1163 
1164     // FIXME: when dropping the -webkit prefix on transform-style, we should also have opacity &lt; 1 cause flattening.
1165     if (style.preserves3D() &amp;&amp; (style.overflowX() != Overflow::Visible
1166         || style.overflowY() != Overflow::Visible
1167         || style.hasClip()
1168         || style.clipPath()
1169         || style.hasFilter()
1170 #if ENABLE(FILTERS_LEVEL_2)
1171         || style.hasBackdropFilter()
1172 #endif
1173         || style.hasBlendMode()))
1174         style.setTransformStyle3D(TransformStyle3D::Flat);
1175 
1176     if (is&lt;SVGElement&gt;(element))
1177         adjustSVGElementStyle(downcast&lt;SVGElement&gt;(*element), style);
1178 
1179     // If the inherited value of justify-items includes the &#39;legacy&#39; keyword (plus &#39;left&#39;, &#39;right&#39; or
1180     // &#39;center&#39;), &#39;legacy&#39; computes to the the inherited value. Otherwise, &#39;auto&#39; computes to &#39;normal&#39;.
1181     if (parentBoxStyle-&gt;justifyItems().positionType() == ItemPositionType::Legacy &amp;&amp; style.justifyItems().position() == ItemPosition::Legacy)
1182         style.setJustifyItems(parentBoxStyle-&gt;justifyItems());
<span class="line-added">1183 </span>
<span class="line-added">1184 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">1185     style.setEffectiveTouchActions(computeEffectiveTouchActions(style, parentStyle.effectiveTouchActions()));</span>
<span class="line-added">1186 #endif</span>
<span class="line-added">1187 </span>
<span class="line-added">1188     if (element) {</span>
<span class="line-added">1189 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-added">1190         adjustRenderStyleForTextAutosizing(style, *element);</span>
<span class="line-added">1191 #endif</span>
<span class="line-added">1192         adjustRenderStyleForSiteSpecificQuirks(style, *element);</span>
<span class="line-added">1193     }</span>
1194 }
1195 
<span class="line-modified">1196 void StyleResolver::adjustRenderStyleForSiteSpecificQuirks(RenderStyle&amp; style, const Element&amp; element)</span>
1197 {
<span class="line-modified">1198     if (document().quirks().needsGMailOverflowScrollQuirk()) {</span>
<span class="line-modified">1199         // This turns sidebar scrollable without mouse move event.</span>
<span class="line-modified">1200         static NeverDestroyed&lt;AtomString&gt; roleValue(&quot;navigation&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-added">1201         if (style.overflowY() == Overflow::Hidden &amp;&amp; element.attributeWithoutSynchronization(roleAttr) == roleValue)</span>
<span class="line-added">1202             style.setOverflowY(Overflow::Auto);</span>
<span class="line-added">1203     }</span>
<span class="line-added">1204     if (document().quirks().needsYouTubeOverflowScrollQuirk()) {</span>
<span class="line-added">1205         // This turns sidebar scrollable without hover.</span>
<span class="line-added">1206         static NeverDestroyed&lt;AtomString&gt; idValue(&quot;guide-inner-content&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-added">1207         if (style.overflowY() == Overflow::Hidden &amp;&amp; element.idForStyleResolution() == idValue)</span>
<span class="line-added">1208             style.setOverflowY(Overflow::Auto);</span>
<span class="line-added">1209     }</span>
<span class="line-added">1210 }</span>
1211 
<span class="line-modified">1212 static void checkForOrientationChange(RenderStyle&amp; style)</span>
<span class="line-added">1213 {</span>
<span class="line-added">1214     auto [fontOrientation, glyphOrientation] = style.fontAndGlyphOrientation();</span>
<span class="line-added">1215 </span>
<span class="line-added">1216     const auto&amp; fontDescription = style.fontDescription();</span>
1217     if (fontDescription.orientation() == fontOrientation &amp;&amp; fontDescription.nonCJKGlyphOrientation() == glyphOrientation)
1218         return;
1219 
1220     auto newFontDescription = fontDescription;
1221     newFontDescription.setNonCJKGlyphOrientation(glyphOrientation);
1222     newFontDescription.setOrientation(fontOrientation);
<span class="line-modified">1223     style.setFontDescription(WTFMove(newFontDescription));</span>
1224 }
1225 
1226 void StyleResolver::updateFont()
1227 {
1228     if (!m_state.fontDirty())
1229         return;
1230 
<span class="line-modified">1231     auto&amp; style = *m_state.style();</span>
1232 #if ENABLE(TEXT_AUTOSIZING)
1233     checkForTextSizeAdjust(style);
1234 #endif
1235     checkForGenericFamilyChange(style, m_state.parentStyle());
1236     checkForZoomChange(style, m_state.parentStyle());
1237     checkForOrientationChange(style);
<span class="line-modified">1238     style.fontCascade().update(&amp;document().fontSelector());</span>
1239     if (m_state.fontSizeHasViewportUnits())
<span class="line-modified">1240         style.setHasViewportUnits(true);</span>
1241     m_state.setFontDirty(false);
1242 }
1243 
1244 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::styleRulesForElement(const Element* element, unsigned rulesToInclude)
1245 {
1246     return pseudoStyleRulesForElement(element, PseudoId::None, rulesToInclude);
1247 }
1248 
1249 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::pseudoStyleRulesForElement(const Element* element, PseudoId pseudoId, unsigned rulesToInclude)
1250 {
1251     if (!element)
1252         return { };
1253 
1254     m_state = State(*element, nullptr);
1255 
1256     ElementRuleCollector collector(*element, m_ruleSets, m_state.selectorFilter());
1257     collector.setMode(SelectorChecker::Mode::CollectingRules);
1258     collector.setPseudoStyleRequest(PseudoStyleRequest(pseudoId));
1259     collector.setMedium(&amp;m_mediaQueryEvaluator);
1260 
</pre>
<hr />
<pre>
1485     TextDirection direction;
1486     WritingMode writingMode;
1487     extractDirectionAndWritingMode(*state.style(), matchResult, direction, writingMode);
1488 
1489     if (elementTypeHasAppearanceFromUAStyle(*state.element())) {
1490         // FIXME: This is such a hack.
1491         // Find out if there&#39;s a -webkit-appearance property in effect from the UA sheet.
1492         // If so, we cache the border and background styles so that RenderTheme::adjustStyle()
1493         // can look at them later to figure out if this is a styled form control or not.
1494         CascadedProperties cascade(direction, writingMode);
1495         cascade.addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1496         cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1497 
1498         ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1499 
1500         applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1501         adjustStyleForInterCharacterRuby();
1502 
1503 #if ENABLE(DARK_MODE_CSS)
1504         // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
<span class="line-modified">1505         applyCascadedProperties(CSSPropertyColorScheme, CSSPropertyColorScheme, applyState);</span>
1506 #endif
1507 
1508         applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1509 
1510         // If our font got dirtied, update it now.
1511         updateFont();
1512 
1513         // Now resolve remaining custom properties and the rest, in any order
1514         for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1515             applyCascadedCustomProperty(it-&gt;key, applyState);
1516         applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1517 
1518         state.cacheBorderAndBackground();
1519     }
1520 
1521     CascadedProperties cascade(direction, writingMode);
1522     cascade.addNormalMatches(matchResult, 0, matchResult.matchedProperties().size() - 1, applyInheritedOnly);
1523     cascade.addImportantMatches(matchResult, matchResult.ranges.firstAuthorRule, matchResult.ranges.lastAuthorRule, applyInheritedOnly);
1524     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, applyInheritedOnly);
1525     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1526 
1527     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1528 
1529     applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1530     adjustStyleForInterCharacterRuby();
1531 
1532 #if ENABLE(DARK_MODE_CSS)
1533     // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
<span class="line-modified">1534     applyCascadedProperties(CSSPropertyColorScheme, CSSPropertyColorScheme, applyState);</span>
1535 #endif
1536 
1537     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1538 
1539     // If the effective zoom value changes, we can&#39;t use the matched properties cache. Start over.
1540     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;effectiveZoom() != state.style()-&gt;effectiveZoom())
1541         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1542 
1543     // If our font got dirtied, update it now.
1544     updateFont();
1545 
1546     // If the font changed, we can&#39;t use the matched properties cache. Start over.
1547     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;fontDescription() != state.style()-&gt;fontDescription())
1548         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1549 
1550     // Now resolve remaining custom properties and the rest, in any order
1551     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1552         applyCascadedCustomProperty(it-&gt;key, applyState);
1553     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1554 
</pre>
<hr />
<pre>
1698 
1699 // Scale with/height properties on inline SVG root.
1700 bool StyleResolver::useSVGZoomRulesForLength() const
1701 {
1702     return is&lt;SVGElement&gt;(m_state.element()) &amp;&amp; !(is&lt;SVGSVGElement&gt;(*m_state.element()) &amp;&amp; m_state.element()-&gt;parentNode());
1703 }
1704 
1705 StyleResolver::CascadedProperties* StyleResolver::cascadedPropertiesForRollback(const MatchResult&amp; matchResult)
1706 {
1707     ASSERT(cascadeLevel() != CascadeLevel::UserAgentLevel);
1708 
1709     TextDirection direction;
1710     WritingMode writingMode;
1711     extractDirectionAndWritingMode(*state().style(), matchResult, direction, writingMode);
1712 
1713     if (cascadeLevel() == CascadeLevel::AuthorLevel) {
1714         CascadedProperties* authorRollback = state().authorRollback();
1715         if (authorRollback)
1716             return authorRollback;
1717 
<span class="line-modified">1718         auto newAuthorRollback(makeUnique&lt;CascadedProperties&gt;(direction, writingMode));</span>
1719 
1720         // This special rollback cascade contains UA rules and user rules but no author rules.
1721         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1722         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1723         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1724         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1725 
1726         state().setAuthorRollback(newAuthorRollback);
1727         return state().authorRollback();
1728     }
1729 
1730     if (cascadeLevel() == CascadeLevel::UserLevel) {
1731         CascadedProperties* userRollback = state().userRollback();
1732         if (userRollback)
1733             return userRollback;
1734 
<span class="line-modified">1735         auto newUserRollback(makeUnique&lt;CascadedProperties&gt;(direction, writingMode));</span>
1736 
1737         // This special rollback cascade contains only UA rules.
1738         newUserRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1739         newUserRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1740 
1741         state().setUserRollback(newUserRollback);
1742         return state().userRollback();
1743     }
1744 
1745     return nullptr;
1746 }
1747 
1748 void StyleResolver::applyProperty(CSSPropertyID id, CSSValue* value, ApplyCascadedPropertyState&amp; applyState, SelectorChecker::LinkMatchMask linkMatchMask)
1749 {
1750     auto* matchResult = applyState.matchResult;
1751     ASSERT_WITH_MESSAGE(!isShorthandCSSProperty(id), &quot;Shorthand property id = %d wasn&#39;t expanded at parsing time&quot;, id);
1752 
1753     State&amp; state = m_state;
1754 
1755     RefPtr&lt;CSSValue&gt; valueToApply = value;
</pre>
<hr />
<pre>
1864 RefPtr&lt;StyleImage&gt; StyleResolver::styleImage(CSSValue&amp; value)
1865 {
1866     if (is&lt;CSSImageGeneratorValue&gt;(value)) {
1867         if (is&lt;CSSGradientValue&gt;(value))
1868             return StyleGeneratedImage::create(downcast&lt;CSSGradientValue&gt;(value).gradientWithStylesResolved(*this));
1869 
1870         if (is&lt;CSSFilterImageValue&gt;(value)) {
1871             // FilterImage needs to calculate FilterOperations.
1872             downcast&lt;CSSFilterImageValue&gt;(value).createFilterOperations(this);
1873         }
1874         return StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(value));
1875     }
1876 
1877     if (is&lt;CSSImageValue&gt;(value) || is&lt;CSSImageSetValue&gt;(value) || is&lt;CSSCursorImageValue&gt;(value))
1878         return StyleCachedImage::create(value);
1879 
1880     return nullptr;
1881 }
1882 
1883 #if ENABLE(TEXT_AUTOSIZING)
<span class="line-modified">1884 void StyleResolver::checkForTextSizeAdjust(RenderStyle&amp; style)</span>
1885 {
<span class="line-modified">1886     if (style.textSizeAdjust().isAuto()</span>
<span class="line-added">1887         || !settings().textAutosizingEnabled()</span>
<span class="line-added">1888         || (settings().textAutosizingUsesIdempotentMode() &amp;&amp; !style.textSizeAdjust().isNone()))</span>
1889         return;
1890 
<span class="line-modified">1891     auto newFontDescription = style.fontDescription();</span>
<span class="line-modified">1892     if (!style.textSizeAdjust().isNone())</span>
<span class="line-modified">1893         newFontDescription.setComputedSize(newFontDescription.specifiedSize() * style.textSizeAdjust().multiplier());</span>
1894     else
1895         newFontDescription.setComputedSize(newFontDescription.specifiedSize());
<span class="line-modified">1896     style.setFontDescription(WTFMove(newFontDescription));</span>
1897 }
1898 #endif
1899 
<span class="line-modified">1900 void StyleResolver::checkForZoomChange(RenderStyle&amp; style, const RenderStyle* parentStyle)</span>
1901 {
1902     if (!parentStyle)
1903         return;
1904 
<span class="line-modified">1905     if (style.effectiveZoom() == parentStyle-&gt;effectiveZoom() &amp;&amp; style.textZoom() == parentStyle-&gt;textZoom())</span>
1906         return;
1907 
<span class="line-modified">1908     const auto&amp; childFont = style.fontDescription();</span>
1909     auto newFontDescription = childFont;
1910     setFontSize(newFontDescription, childFont.specifiedSize());
<span class="line-modified">1911     style.setFontDescription(WTFMove(newFontDescription));</span>
1912 }
1913 
<span class="line-modified">1914 void StyleResolver::checkForGenericFamilyChange(RenderStyle&amp; style, const RenderStyle* parentStyle)</span>
1915 {
<span class="line-modified">1916     const auto&amp; childFont = style.fontDescription();</span>
1917 
1918     if (childFont.isAbsoluteSize() || !parentStyle)
1919         return;
1920 
1921     const auto&amp; parentFont = parentStyle-&gt;fontDescription();
1922     if (childFont.useFixedDefaultSize() == parentFont.useFixedDefaultSize())
1923         return;
1924     // We know the parent is monospace or the child is monospace, and that font
1925     // size was unspecified. We want to scale our font size as appropriate.
1926     // If the font uses a keyword size, then we refetch from the table rather than
1927     // multiplying by our scale factor.
1928     float size;
1929     if (CSSValueID sizeIdentifier = childFont.keywordSizeAsIdentifier())
1930         size = Style::fontSizeForKeyword(sizeIdentifier, childFont.useFixedDefaultSize(), document());
1931     else {
1932         float fixedScaleFactor = (settings().defaultFixedFontSize() &amp;&amp; settings().defaultFontSize())
1933             ? static_cast&lt;float&gt;(settings().defaultFixedFontSize()) / settings().defaultFontSize()
1934             : 1;
1935         size = parentFont.useFixedDefaultSize() ?
1936                 childFont.specifiedSize() / fixedScaleFactor :
1937                 childFont.specifiedSize() * fixedScaleFactor;
1938     }
1939 
1940     auto newFontDescription = childFont;
1941     setFontSize(newFontDescription, size);
<span class="line-modified">1942     style.setFontDescription(WTFMove(newFontDescription));</span>
1943 }
1944 
1945 void StyleResolver::initializeFontStyle()
1946 {
1947     FontCascadeDescription fontDescription;
1948     fontDescription.setRenderingMode(settings().fontRenderingMode());
1949     fontDescription.setOneFamily(standardFamily);
1950     fontDescription.setKeywordSizeFromIdentifier(CSSValueMedium);
1951     setFontSize(fontDescription, Style::fontSizeForKeyword(CSSValueMedium, false, document()));
1952     fontDescription.setShouldAllowUserInstalledFonts(settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No);
<span class="line-added">1953     fontDescription.setShouldAllowDesignSystemUIFonts(settings().shouldAllowDesignSystemUIFonts());</span>
1954     setFontDescription(WTFMove(fontDescription));
1955 }
1956 
1957 void StyleResolver::setFontSize(FontCascadeDescription&amp; fontDescription, float size)
1958 {
1959     fontDescription.setSpecifiedSize(size);
1960     fontDescription.setComputedSize(Style::computedFontSizeFromSpecifiedSize(size, fontDescription.isAbsoluteSize(), useSVGZoomRules(), m_state.style(), document()));
1961 }
1962 
1963 bool StyleResolver::colorFromPrimitiveValueIsDerivedFromElement(const CSSPrimitiveValue&amp; value)
1964 {
1965     switch (value.valueID()) {
1966     case CSSValueWebkitText:
1967     case CSSValueWebkitLink:
1968     case CSSValueWebkitActivelink:
1969     case CSSValueCurrentcolor:
1970         return true;
1971     default:
1972         return false;
1973     }
</pre>
</td>
</tr>
</table>
<center><a href="StyleProperties.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleResolver.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>