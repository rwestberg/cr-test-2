<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004 Zack Rusin &lt;zack@kde.org&gt;
   3  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   5  * Copyright (C) 2007 Nicholas Shanks &lt;webkit@nickshanks.com&gt;
   6  * Copyright (C) 2011 Sencha, Inc. All rights reserved.
   7  * Copyright (C) 2013 Adobe Systems Incorporated. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Lesser General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Lesser General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public
  20  * License along with this library; if not, write to the Free Software
  21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  22  * 02110-1301  USA
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 
  28 #include &quot;BasicShapeFunctions.h&quot;
  29 #include &quot;CSSAnimationController.h&quot;
  30 #include &quot;CSSAspectRatioValue.h&quot;
  31 #include &quot;CSSBasicShapes.h&quot;
  32 #include &quot;CSSBorderImage.h&quot;
  33 #include &quot;CSSBorderImageSliceValue.h&quot;
  34 #include &quot;CSSFontFeatureValue.h&quot;
  35 #include &quot;CSSFontStyleValue.h&quot;
  36 #include &quot;CSSFontValue.h&quot;
  37 #include &quot;CSSFontVariationValue.h&quot;
  38 #include &quot;CSSFunctionValue.h&quot;
  39 #include &quot;CSSLineBoxContainValue.h&quot;
  40 #include &quot;CSSPrimitiveValue.h&quot;
  41 #include &quot;CSSPrimitiveValueMappings.h&quot;
  42 #include &quot;CSSPropertyNames.h&quot;
  43 #include &quot;CSSPropertyParser.h&quot;
  44 #include &quot;CSSReflectValue.h&quot;
  45 #include &quot;CSSSelector.h&quot;
  46 #include &quot;CSSShadowValue.h&quot;
  47 #include &quot;CSSTimingFunctionValue.h&quot;
  48 #include &quot;CSSValueList.h&quot;
  49 #include &quot;CSSValuePool.h&quot;
  50 #include &quot;ComposedTreeAncestorIterator.h&quot;
  51 #include &quot;ContentData.h&quot;
  52 #include &quot;CursorList.h&quot;
  53 #include &quot;DeprecatedCSSOMValue.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentTimeline.h&quot;
  56 #include &quot;FontCascade.h&quot;
  57 #include &quot;FontSelectionValueInlines.h&quot;
  58 #include &quot;FontTaggedSettings.h&quot;
  59 #include &quot;NodeRenderStyle.h&quot;
  60 #include &quot;Pair.h&quot;
  61 #include &quot;Rect.h&quot;
  62 #include &quot;RenderBlock.h&quot;
  63 #include &quot;RenderBox.h&quot;
  64 #include &quot;RenderInline.h&quot;
  65 #include &quot;RenderStyle.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;SVGElement.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;ShapeValue.h&quot;
  70 #include &quot;StyleProperties.h&quot;
  71 #include &quot;StylePropertyShorthand.h&quot;
  72 #include &quot;StylePropertyShorthandFunctions.h&quot;
  73 #include &quot;StyleResolver.h&quot;
  74 #include &quot;StyleScope.h&quot;
  75 #include &quot;StyleScrollSnapPoints.h&quot;
  76 #include &quot;TouchAction.h&quot;
  77 #include &quot;WebKitFontFamilyNames.h&quot;
  78 #include &quot;WillChangeData.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  79 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  80 #include &lt;wtf/NeverDestroyed.h&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 #include &quot;CSSGridLineNamesValue.h&quot;
  84 #include &quot;CSSGridTemplateAreasValue.h&quot;
  85 #include &quot;RenderGrid.h&quot;
  86 
<a name="2" id="anc2"></a>



  87 namespace WebCore {
  88 
<a name="3" id="anc3"></a><span class="line-added">  89 WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);</span>
<span class="line-added">  90 </span>
  91 // List of all properties we know how to compute, omitting shorthands.
  92 static const CSSPropertyID computedProperties[] = {
<a name="4" id="anc4"></a><span class="line-added">  93     CSSPropertyAlignContent,</span>
<span class="line-added">  94     CSSPropertyAlignItems,</span>
<span class="line-added">  95     CSSPropertyAlignSelf,</span>
<span class="line-added">  96     CSSPropertyAlignmentBaseline,</span>
  97     CSSPropertyAlt,
  98     CSSPropertyAnimationDelay,
  99     CSSPropertyAnimationDirection,
 100     CSSPropertyAnimationDuration,
 101     CSSPropertyAnimationFillMode,
 102     CSSPropertyAnimationIterationCount,
 103     CSSPropertyAnimationName,
 104     CSSPropertyAnimationPlayState,
 105     CSSPropertyAnimationTimingFunction,
 106     CSSPropertyBackgroundAttachment,
 107     CSSPropertyBackgroundBlendMode,
 108     CSSPropertyBackgroundClip,
 109     CSSPropertyBackgroundColor,
 110     CSSPropertyBackgroundImage,
 111     CSSPropertyBackgroundOrigin,
 112     CSSPropertyBackgroundPosition, // more-specific background-position-x/y are non-standard
 113     CSSPropertyBackgroundRepeat,
 114     CSSPropertyBackgroundSize,
<a name="5" id="anc5"></a><span class="line-added"> 115     CSSPropertyBaselineShift,</span>
 116     CSSPropertyBorderBottomColor,
 117     CSSPropertyBorderBottomLeftRadius,
 118     CSSPropertyBorderBottomRightRadius,
 119     CSSPropertyBorderBottomStyle,
 120     CSSPropertyBorderBottomWidth,
 121     CSSPropertyBorderCollapse,
 122     CSSPropertyBorderImageOutset,
 123     CSSPropertyBorderImageRepeat,
 124     CSSPropertyBorderImageSlice,
 125     CSSPropertyBorderImageSource,
 126     CSSPropertyBorderImageWidth,
 127     CSSPropertyBorderLeftColor,
 128     CSSPropertyBorderLeftStyle,
 129     CSSPropertyBorderLeftWidth,
 130     CSSPropertyBorderRightColor,
 131     CSSPropertyBorderRightStyle,
 132     CSSPropertyBorderRightWidth,
 133     CSSPropertyBorderTopColor,
 134     CSSPropertyBorderTopLeftRadius,
 135     CSSPropertyBorderTopRightRadius,
 136     CSSPropertyBorderTopStyle,
 137     CSSPropertyBorderTopWidth,
 138     CSSPropertyBottom,
 139     CSSPropertyBoxShadow,
 140     CSSPropertyBoxSizing,
<a name="6" id="anc6"></a><span class="line-added"> 141     CSSPropertyBufferedRendering,</span>
 142     CSSPropertyCaptionSide,
 143     CSSPropertyCaretColor,
 144     CSSPropertyClear,
 145     CSSPropertyClip,
<a name="7" id="anc7"></a><span class="line-added"> 146     CSSPropertyClipPath,</span>
<span class="line-added"> 147     CSSPropertyClipRule,</span>
 148     CSSPropertyColor,
<a name="8" id="anc8"></a><span class="line-modified"> 149     CSSPropertyColorInterpolation,</span>
<span class="line-added"> 150     CSSPropertyColorInterpolationFilters,</span>
<span class="line-added"> 151     CSSPropertyColorRendering,</span>
<span class="line-added"> 152 #if ENABLE(DARK_MODE_CSS)</span>
<span class="line-added"> 153     CSSPropertyColorScheme,</span>
<span class="line-added"> 154 #endif</span>
<span class="line-added"> 155     CSSPropertyColumnCount,</span>
<span class="line-added"> 156     CSSPropertyColumnFill,</span>
<span class="line-added"> 157     CSSPropertyColumnGap,</span>
<span class="line-added"> 158     CSSPropertyColumnRuleColor,</span>
<span class="line-added"> 159     CSSPropertyColumnRuleStyle,</span>
<span class="line-added"> 160     CSSPropertyColumnRuleWidth,</span>
<span class="line-added"> 161     CSSPropertyColumnSpan,</span>
<span class="line-added"> 162     CSSPropertyColumnWidth,</span>
<span class="line-added"> 163     CSSPropertyContent,</span>
 164     CSSPropertyCounterIncrement,
 165     CSSPropertyCounterReset,
<a name="9" id="anc9"></a>
 166     CSSPropertyCursor,
<a name="10" id="anc10"></a><span class="line-added"> 167     CSSPropertyCx,</span>
<span class="line-added"> 168     CSSPropertyCy,</span>
 169     CSSPropertyDirection,
 170     CSSPropertyDisplay,
<a name="11" id="anc11"></a><span class="line-added"> 171     CSSPropertyDominantBaseline,</span>
 172     CSSPropertyEmptyCells,
<a name="12" id="anc12"></a><span class="line-added"> 173     CSSPropertyFill,</span>
<span class="line-added"> 174     CSSPropertyFillOpacity,</span>
<span class="line-added"> 175     CSSPropertyFillRule,</span>
<span class="line-added"> 176     CSSPropertyFilter,</span>
<span class="line-added"> 177     CSSPropertyFlexBasis,</span>
<span class="line-added"> 178     CSSPropertyFlexDirection,</span>
<span class="line-added"> 179     CSSPropertyFlexFlow,</span>
<span class="line-added"> 180     CSSPropertyFlexGrow,</span>
<span class="line-added"> 181     CSSPropertyFlexShrink,</span>
<span class="line-added"> 182     CSSPropertyFlexWrap,</span>
 183     CSSPropertyFloat,
<a name="13" id="anc13"></a><span class="line-added"> 184     CSSPropertyFloodColor,</span>
<span class="line-added"> 185     CSSPropertyFloodOpacity,</span>
 186     CSSPropertyFontFamily,
<a name="14" id="anc14"></a><span class="line-added"> 187 #if ENABLE(VARIATION_FONTS)</span>
<span class="line-added"> 188     CSSPropertyFontOpticalSizing,</span>
<span class="line-added"> 189 #endif</span>
 190     CSSPropertyFontSize,
 191     CSSPropertyFontStretch,
 192     CSSPropertyFontStyle,
 193     CSSPropertyFontSynthesis,
 194     CSSPropertyFontVariant,
<a name="15" id="anc15"></a><span class="line-modified"> 195     CSSPropertyFontVariantAlternates,</span>
<span class="line-added"> 196     CSSPropertyFontVariantCaps,</span>
<span class="line-added"> 197     CSSPropertyFontVariantEastAsian,</span>
<span class="line-added"> 198     CSSPropertyFontVariantLigatures,</span>
<span class="line-added"> 199     CSSPropertyFontVariantNumeric,</span>
<span class="line-added"> 200     CSSPropertyFontVariantPosition,</span>
 201 #if ENABLE(VARIATION_FONTS)
<a name="16" id="anc16"></a><span class="line-modified"> 202     CSSPropertyFontVariationSettings,</span>
 203 #endif
<a name="17" id="anc17"></a><span class="line-added"> 204     CSSPropertyFontWeight,</span>
<span class="line-added"> 205     CSSPropertyGlyphOrientationHorizontal,</span>
<span class="line-added"> 206     CSSPropertyGlyphOrientationVertical,</span>
<span class="line-added"> 207     CSSPropertyGridAutoColumns,</span>
<span class="line-added"> 208     CSSPropertyGridAutoFlow,</span>
<span class="line-added"> 209     CSSPropertyGridAutoRows,</span>
<span class="line-added"> 210     CSSPropertyGridColumnEnd,</span>
<span class="line-added"> 211     CSSPropertyGridColumnStart,</span>
<span class="line-added"> 212     CSSPropertyGridRowEnd,</span>
<span class="line-added"> 213     CSSPropertyGridRowStart,</span>
<span class="line-added"> 214     CSSPropertyGridTemplateAreas,</span>
<span class="line-added"> 215     CSSPropertyGridTemplateColumns,</span>
<span class="line-added"> 216     CSSPropertyGridTemplateRows,</span>
 217     CSSPropertyHangingPunctuation,
 218     CSSPropertyHeight,
 219 #if ENABLE(CSS_IMAGE_ORIENTATION)
 220     CSSPropertyImageOrientation,
 221 #endif
 222     CSSPropertyImageRendering,
 223 #if ENABLE(CSS_IMAGE_RESOLUTION)
 224     CSSPropertyImageResolution,
 225 #endif
<a name="18" id="anc18"></a><span class="line-added"> 226 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added"> 227     CSSPropertyIsolation,</span>
<span class="line-added"> 228 #endif</span>
<span class="line-added"> 229     CSSPropertyJustifyContent,</span>
<span class="line-added"> 230     CSSPropertyJustifyItems,</span>
<span class="line-added"> 231     CSSPropertyJustifySelf,</span>
<span class="line-added"> 232     CSSPropertyKerning,</span>
 233     CSSPropertyLeft,
 234     CSSPropertyLetterSpacing,
<a name="19" id="anc19"></a><span class="line-added"> 235     CSSPropertyLightingColor,</span>
<span class="line-added"> 236     CSSPropertyLineBreak,</span>
 237     CSSPropertyLineHeight,
 238     CSSPropertyListStyleImage,
 239     CSSPropertyListStylePosition,
 240     CSSPropertyListStyleType,
 241     CSSPropertyMarginBottom,
 242     CSSPropertyMarginLeft,
 243     CSSPropertyMarginRight,
 244     CSSPropertyMarginTop,
<a name="20" id="anc20"></a><span class="line-added"> 245     CSSPropertyMarkerEnd,</span>
<span class="line-added"> 246     CSSPropertyMarkerMid,</span>
<span class="line-added"> 247     CSSPropertyMarkerStart,</span>
<span class="line-added"> 248     CSSPropertyMask,</span>
<span class="line-added"> 249     CSSPropertyMaskType,</span>
 250     CSSPropertyMaxHeight,
 251     CSSPropertyMaxWidth,
 252     CSSPropertyMinHeight,
 253     CSSPropertyMinWidth,
<a name="21" id="anc21"></a><span class="line-added"> 254 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added"> 255     CSSPropertyMixBlendMode,</span>
<span class="line-added"> 256 #endif</span>
 257     CSSPropertyObjectFit,
 258     CSSPropertyObjectPosition,
 259     CSSPropertyOpacity,
<a name="22" id="anc22"></a><span class="line-added"> 260     CSSPropertyOrder,</span>
 261     CSSPropertyOrphans,
 262     CSSPropertyOutlineColor,
 263     CSSPropertyOutlineOffset,
 264     CSSPropertyOutlineStyle,
 265     CSSPropertyOutlineWidth,
 266     CSSPropertyOverflowWrap,
 267     CSSPropertyOverflowX,
 268     CSSPropertyOverflowY,
 269     CSSPropertyPaddingBottom,
 270     CSSPropertyPaddingLeft,
 271     CSSPropertyPaddingRight,
 272     CSSPropertyPaddingTop,
 273     CSSPropertyPageBreakAfter,
 274     CSSPropertyPageBreakBefore,
 275     CSSPropertyPageBreakInside,
<a name="23" id="anc23"></a><span class="line-added"> 276     CSSPropertyPaintOrder,</span>
<span class="line-added"> 277     CSSPropertyPerspective,</span>
<span class="line-added"> 278     CSSPropertyPerspectiveOrigin,</span>
<span class="line-added"> 279     CSSPropertyPlaceContent,</span>
<span class="line-added"> 280     CSSPropertyPlaceItems,</span>
<span class="line-added"> 281     CSSPropertyPlaceSelf,</span>
 282     CSSPropertyPointerEvents,
 283     CSSPropertyPosition,
<a name="24" id="anc24"></a><span class="line-added"> 284     CSSPropertyR,</span>
 285     CSSPropertyResize,
 286     CSSPropertyRight,
<a name="25" id="anc25"></a><span class="line-added"> 287     CSSPropertyRowGap,</span>
<span class="line-added"> 288     CSSPropertyRx,</span>
<span class="line-added"> 289     CSSPropertyRy,</span>
<span class="line-added"> 290 #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-added"> 291     CSSPropertyScrollPadding,</span>
<span class="line-added"> 292     CSSPropertyScrollPaddingBottom,</span>
<span class="line-added"> 293     CSSPropertyScrollPaddingLeft,</span>
<span class="line-added"> 294     CSSPropertyScrollPaddingRight,</span>
<span class="line-added"> 295     CSSPropertyScrollPaddingTop,</span>
<span class="line-added"> 296     CSSPropertyScrollSnapAlign,</span>
<span class="line-added"> 297     CSSPropertyScrollSnapMargin,</span>
<span class="line-added"> 298     CSSPropertyScrollSnapMarginBottom,</span>
<span class="line-added"> 299     CSSPropertyScrollSnapMarginLeft,</span>
<span class="line-added"> 300     CSSPropertyScrollSnapMarginRight,</span>
<span class="line-added"> 301     CSSPropertyScrollSnapMarginTop,</span>
<span class="line-added"> 302     CSSPropertyScrollSnapType,</span>
<span class="line-added"> 303 #endif</span>
<span class="line-added"> 304     CSSPropertyShapeImageThreshold,</span>
<span class="line-added"> 305     CSSPropertyShapeMargin,</span>
<span class="line-added"> 306     CSSPropertyShapeOutside,</span>
<span class="line-added"> 307     CSSPropertyShapeRendering,</span>
 308     CSSPropertySpeakAs,
<a name="26" id="anc26"></a><span class="line-modified"> 309     CSSPropertyStopColor,</span>
<span class="line-added"> 310     CSSPropertyStopOpacity,</span>
<span class="line-added"> 311     CSSPropertyStroke,</span>
<span class="line-added"> 312     CSSPropertyStrokeColor,</span>
<span class="line-added"> 313     CSSPropertyStrokeDasharray,</span>
<span class="line-added"> 314     CSSPropertyStrokeDashoffset,</span>
<span class="line-added"> 315     CSSPropertyStrokeLinecap,</span>
<span class="line-added"> 316     CSSPropertyStrokeLinejoin,</span>
<span class="line-added"> 317     CSSPropertyStrokeMiterlimit,</span>
<span class="line-added"> 318     CSSPropertyStrokeOpacity,</span>
<span class="line-added"> 319     CSSPropertyStrokeWidth,</span>
 320     CSSPropertyTabSize,
<a name="27" id="anc27"></a><span class="line-added"> 321     CSSPropertyTableLayout,</span>
 322     CSSPropertyTextAlign,
<a name="28" id="anc28"></a><span class="line-added"> 323     CSSPropertyTextAnchor,</span>
 324     CSSPropertyTextDecoration,
<a name="29" id="anc29"></a>





 325     CSSPropertyTextDecorationColor,
<a name="30" id="anc30"></a><span class="line-added"> 326     CSSPropertyTextDecorationLine,</span>
 327     CSSPropertyTextDecorationSkip,
<a name="31" id="anc31"></a><span class="line-modified"> 328     CSSPropertyTextDecorationStyle,</span>
 329     CSSPropertyTextIndent,
<a name="32" id="anc32"></a><span class="line-added"> 330     CSSPropertyTextOverflow,</span>
 331     CSSPropertyTextRendering,
 332     CSSPropertyTextShadow,
<a name="33" id="anc33"></a>
 333     CSSPropertyTextTransform,
<a name="34" id="anc34"></a><span class="line-added"> 334     CSSPropertyTextUnderlinePosition,</span>
 335     CSSPropertyTop,
<a name="35" id="anc35"></a><span class="line-added"> 336 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 337     CSSPropertyTouchAction,</span>
<span class="line-added"> 338 #endif</span>
 339     CSSPropertyTransform,
 340     CSSPropertyTransformBox,
 341     CSSPropertyTransformOrigin,
 342     CSSPropertyTransformStyle,
 343     CSSPropertyTransitionDelay,
 344     CSSPropertyTransitionDuration,
 345     CSSPropertyTransitionProperty,
 346     CSSPropertyTransitionTimingFunction,
 347     CSSPropertyUnicodeBidi,
<a name="36" id="anc36"></a><span class="line-added"> 348     CSSPropertyVectorEffect,</span>
 349     CSSPropertyVerticalAlign,
 350     CSSPropertyVisibility,
 351     CSSPropertyWhiteSpace,
 352     CSSPropertyWidows,
 353     CSSPropertyWidth,
 354     CSSPropertyWillChange,
 355     CSSPropertyWordBreak,
 356     CSSPropertyWordSpacing,
 357     CSSPropertyWordWrap,
<a name="37" id="anc37"></a><span class="line-modified"> 358     CSSPropertyWritingMode,</span>
<span class="line-modified"> 359     CSSPropertyX,</span>
<span class="line-modified"> 360     CSSPropertyY,</span>











 361     CSSPropertyZIndex,
 362     CSSPropertyZoom,
<a name="38" id="anc38"></a><span class="line-added"> 363     CSSPropertyAppleColorFilter,</span>
 364     CSSPropertyWebkitAppearance,
<a name="39" id="anc39"></a><span class="line-added"> 365 #if ENABLE(FILTERS_LEVEL_2)</span>
<span class="line-added"> 366     CSSPropertyWebkitBackdropFilter,</span>
<span class="line-added"> 367 #endif</span>
 368     CSSPropertyWebkitBackfaceVisibility,
 369     CSSPropertyWebkitBackgroundClip,
 370     CSSPropertyWebkitBackgroundComposite,
 371     CSSPropertyWebkitBackgroundOrigin,
 372     CSSPropertyWebkitBackgroundSize,
<a name="40" id="anc40"></a>



 373     CSSPropertyWebkitBorderFit,
 374     CSSPropertyWebkitBorderHorizontalSpacing,
 375     CSSPropertyWebkitBorderImage,
 376     CSSPropertyWebkitBorderVerticalSpacing,
 377     CSSPropertyWebkitBoxAlign,
 378 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 379     CSSPropertyWebkitBoxDecorationBreak,
 380 #endif
 381     CSSPropertyWebkitBoxDirection,
 382     CSSPropertyWebkitBoxFlex,
 383     CSSPropertyWebkitBoxFlexGroup,
 384     CSSPropertyWebkitBoxLines,
 385     CSSPropertyWebkitBoxOrdinalGroup,
 386     CSSPropertyWebkitBoxOrient,
 387     CSSPropertyWebkitBoxPack,
 388     CSSPropertyWebkitBoxReflect,
 389     CSSPropertyWebkitBoxShadow,
 390     CSSPropertyWebkitClipPath,
<a name="41" id="anc41"></a><span class="line-added"> 391     CSSPropertyWebkitColumnAxis,</span>
 392     CSSPropertyWebkitColumnBreakAfter,
 393     CSSPropertyWebkitColumnBreakBefore,
 394     CSSPropertyWebkitColumnBreakInside,
<a name="42" id="anc42"></a>




 395     CSSPropertyWebkitColumnProgression,
<a name="43" id="anc43"></a>




 396 #if ENABLE(CURSOR_VISIBILITY)
 397     CSSPropertyWebkitCursorVisibility,
<a name="44" id="anc44"></a>





















 398 #endif
 399     CSSPropertyWebkitFontKerning,
 400     CSSPropertyWebkitFontSmoothing,
<a name="45" id="anc45"></a>


















 401     CSSPropertyWebkitHyphenateCharacter,
 402     CSSPropertyWebkitHyphenateLimitAfter,
 403     CSSPropertyWebkitHyphenateLimitBefore,
 404     CSSPropertyWebkitHyphenateLimitLines,
 405     CSSPropertyWebkitHyphens,
 406     CSSPropertyWebkitInitialLetter,
 407     CSSPropertyWebkitLineAlign,
 408     CSSPropertyWebkitLineBoxContain,
<a name="46" id="anc46"></a>
 409     CSSPropertyWebkitLineClamp,
 410     CSSPropertyWebkitLineGrid,
 411     CSSPropertyWebkitLineSnap,
 412     CSSPropertyWebkitLocale,
<a name="47" id="anc47"></a>
 413     CSSPropertyWebkitMarginAfterCollapse,
<a name="48" id="anc48"></a><span class="line-added"> 414     CSSPropertyWebkitMarginBeforeCollapse,</span>
 415     CSSPropertyWebkitMarqueeDirection,
 416     CSSPropertyWebkitMarqueeIncrement,
 417     CSSPropertyWebkitMarqueeRepetition,
 418     CSSPropertyWebkitMarqueeStyle,
 419     CSSPropertyWebkitMaskBoxImage,
 420     CSSPropertyWebkitMaskBoxImageOutset,
 421     CSSPropertyWebkitMaskBoxImageRepeat,
 422     CSSPropertyWebkitMaskBoxImageSlice,
 423     CSSPropertyWebkitMaskBoxImageSource,
 424     CSSPropertyWebkitMaskBoxImageWidth,
 425     CSSPropertyWebkitMaskClip,
 426     CSSPropertyWebkitMaskComposite,
 427     CSSPropertyWebkitMaskImage,
 428     CSSPropertyWebkitMaskOrigin,
 429     CSSPropertyWebkitMaskPosition,
 430     CSSPropertyWebkitMaskRepeat,
 431     CSSPropertyWebkitMaskSize,
 432     CSSPropertyWebkitMaskSourceType,
 433     CSSPropertyWebkitNbspMode,
<a name="49" id="anc49"></a><span class="line-modified"> 434 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>

 435     CSSPropertyWebkitOverflowScrolling,
 436 #endif
<a name="50" id="anc50"></a>

 437     CSSPropertyWebkitPrintColorAdjust,
 438     CSSPropertyWebkitRtlOrdering,
<a name="51" id="anc51"></a>


 439 #if ENABLE(TOUCH_EVENTS)
 440     CSSPropertyWebkitTapHighlightColor,
<a name="52" id="anc52"></a><span class="line-added"> 441 #endif</span>
<span class="line-added"> 442 #if ENABLE(CSS3_TEXT)</span>
<span class="line-added"> 443     CSSPropertyWebkitTextAlignLast,</span>
 444 #endif
 445     CSSPropertyWebkitTextCombine,
 446     CSSPropertyWebkitTextDecorationsInEffect,
 447     CSSPropertyWebkitTextEmphasisColor,
 448     CSSPropertyWebkitTextEmphasisPosition,
 449     CSSPropertyWebkitTextEmphasisStyle,
 450     CSSPropertyWebkitTextFillColor,
<a name="53" id="anc53"></a><span class="line-added"> 451 #if ENABLE(CSS3_TEXT)</span>
<span class="line-added"> 452     CSSPropertyWebkitTextJustify,</span>
<span class="line-added"> 453 #endif</span>
 454     CSSPropertyWebkitTextOrientation,
 455     CSSPropertyWebkitTextSecurity,
 456 #if ENABLE(TEXT_AUTOSIZING)
 457     CSSPropertyWebkitTextSizeAdjust,
 458 #endif
 459     CSSPropertyWebkitTextStrokeColor,
 460     CSSPropertyWebkitTextStrokeWidth,
 461     CSSPropertyWebkitTextZoom,
<a name="54" id="anc54"></a><span class="line-added"> 462 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 463     CSSPropertyWebkitTouchCallout,</span>
<span class="line-added"> 464 #endif</span>
 465     CSSPropertyWebkitTransformStyle,
 466     CSSPropertyWebkitUserDrag,
 467     CSSPropertyWebkitUserModify,
 468     CSSPropertyWebkitUserSelect,
<a name="55" id="anc55"></a>



















































 469 };
 470 
 471 const unsigned numComputedProperties = WTF_ARRAY_LENGTH(computedProperties);
 472 
 473 static CSSValueID valueForRepeatRule(int rule)
 474 {
 475     switch (rule) {
 476         case RepeatImageRule:
 477             return CSSValueRepeat;
 478         case RoundImageRule:
 479             return CSSValueRound;
 480         case SpaceImageRule:
 481             return CSSValueSpace;
 482         default:
 483             return CSSValueStretch;
 484     }
 485 }
 486 
 487 static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
 488 {
 489     // These values can be percentages, numbers, or while an animation of mixed types is in progress,
 490     // a calculation that combines a percentage and a number.
 491     if (length.isPercent())
 492         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
 493     if (length.isFixed())
 494         return CSSValuePool::singleton().createValue(length.value(), CSSPrimitiveValue::CSS_NUMBER);
 495 
 496     // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
 497     // And even if we could do that, it&#39;s not clear if that&#39;s exactly what we&#39;d want during animation.
 498     // FIXME: For now, just return 0.
 499     ASSERT(length.isCalculated());
 500     return CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::CSS_NUMBER);
 501 }
 502 
 503 static Ref&lt;CSSBorderImageSliceValue&gt; valueForNinePieceImageSlice(const NinePieceImage&amp; image)
 504 {
 505     auto&amp; slices = image.imageSlices();
 506 
 507     RefPtr&lt;CSSPrimitiveValue&gt; top = valueForImageSliceSide(slices.top());
 508 
 509     RefPtr&lt;CSSPrimitiveValue&gt; right;
 510     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 511     RefPtr&lt;CSSPrimitiveValue&gt; left;
 512 
 513     if (slices.right() == slices.top() &amp;&amp; slices.bottom() == slices.top() &amp;&amp; slices.left() == slices.top()) {
 514         right = top;
 515         bottom = top;
 516         left = top;
 517     } else {
 518         right = valueForImageSliceSide(slices.right());
 519 
 520         if (slices.bottom() == slices.top() &amp;&amp; slices.right() == slices.left()) {
 521             bottom = top;
 522             left = right;
 523         } else {
 524             bottom = valueForImageSliceSide(slices.bottom());
 525 
 526             if (slices.left() == slices.right())
 527                 left = right;
 528             else
 529                 left = valueForImageSliceSide(slices.left());
 530         }
 531     }
 532 
 533     auto quad = Quad::create();
 534     quad-&gt;setTop(WTFMove(top));
 535     quad-&gt;setRight(WTFMove(right));
 536     quad-&gt;setBottom(WTFMove(bottom));
 537     quad-&gt;setLeft(WTFMove(left));
 538 
 539     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), image.fill());
 540 }
 541 
 542 static Ref&lt;CSSPrimitiveValue&gt; valueForNinePieceImageQuad(const LengthBox&amp; box)
 543 {
 544     RefPtr&lt;CSSPrimitiveValue&gt; top;
 545     RefPtr&lt;CSSPrimitiveValue&gt; right;
 546     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 547     RefPtr&lt;CSSPrimitiveValue&gt; left;
 548 
 549     auto&amp; cssValuePool = CSSValuePool::singleton();
 550 
 551     if (box.top().isRelative())
 552         top = cssValuePool.createValue(box.top().value(), CSSPrimitiveValue::CSS_NUMBER);
 553     else
 554         top = cssValuePool.createValue(box.top());
 555 
 556     if (box.right() == box.top() &amp;&amp; box.bottom() == box.top() &amp;&amp; box.left() == box.top()) {
 557         right = top;
 558         bottom = top;
 559         left = top;
 560     } else {
 561         if (box.right().isRelative())
 562             right = cssValuePool.createValue(box.right().value(), CSSPrimitiveValue::CSS_NUMBER);
 563         else
 564             right = cssValuePool.createValue(box.right());
 565 
 566         if (box.bottom() == box.top() &amp;&amp; box.right() == box.left()) {
 567             bottom = top;
 568             left = right;
 569         } else {
 570             if (box.bottom().isRelative())
 571                 bottom = cssValuePool.createValue(box.bottom().value(), CSSPrimitiveValue::CSS_NUMBER);
 572             else
 573                 bottom = cssValuePool.createValue(box.bottom());
 574 
 575             if (box.left() == box.right())
 576                 left = right;
 577             else {
 578                 if (box.left().isRelative())
 579                     left = cssValuePool.createValue(box.left().value(), CSSPrimitiveValue::CSS_NUMBER);
 580                 else
 581                     left = cssValuePool.createValue(box.left());
 582             }
 583         }
 584     }
 585 
 586     auto quad = Quad::create();
 587     quad-&gt;setTop(WTFMove(top));
 588     quad-&gt;setRight(WTFMove(right));
 589     quad-&gt;setBottom(WTFMove(bottom));
 590     quad-&gt;setLeft(WTFMove(left));
 591 
 592     return cssValuePool.createValue(WTFMove(quad));
 593 }
 594 
 595 static Ref&lt;CSSValue&gt; valueForNinePieceImageRepeat(const NinePieceImage&amp; image)
 596 {
 597     auto&amp; cssValuePool = CSSValuePool::singleton();
 598     auto horizontalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.horizontalRule()));
 599     RefPtr&lt;CSSPrimitiveValue&gt; verticalRepeat;
 600     if (image.horizontalRule() == image.verticalRule())
 601         verticalRepeat = horizontalRepeat.copyRef();
 602     else
 603         verticalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.verticalRule()));
 604     return cssValuePool.createValue(Pair::create(WTFMove(horizontalRepeat), WTFMove(verticalRepeat)));
 605 }
 606 
 607 static Ref&lt;CSSValue&gt; valueForNinePieceImage(const NinePieceImage&amp; image)
 608 {
 609     if (!image.hasImage())
 610         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 611 
 612     // Image first.
 613     RefPtr&lt;CSSValue&gt; imageValue;
 614     if (image.image())
 615         imageValue = image.image()-&gt;cssValue();
 616 
 617     // Create the image slice.
 618     RefPtr&lt;CSSBorderImageSliceValue&gt; imageSlices = valueForNinePieceImageSlice(image);
 619 
 620     // Create the border area slices.
 621     RefPtr&lt;CSSValue&gt; borderSlices = valueForNinePieceImageQuad(image.borderSlices());
 622 
 623     // Create the border outset.
 624     RefPtr&lt;CSSValue&gt; outset = valueForNinePieceImageQuad(image.outset());
 625 
 626     // Create the repeat rules.
 627     RefPtr&lt;CSSValue&gt; repeat = valueForNinePieceImageRepeat(image);
 628 
 629     return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
 630 }
 631 
 632 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValue(double value, const RenderStyle&amp; style)
 633 {
 634     return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSPrimitiveValue::CSS_PX);
 635 }
 636 
 637 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedNumberValue(double value, const RenderStyle&amp; style)
 638 {
 639     return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSPrimitiveValue::CSS_NUMBER);
 640 }
 641 
 642 static Ref&lt;CSSValue&gt; zoomAdjustedPixelValueForLength(const Length&amp; length, const RenderStyle&amp; style)
 643 {
 644     if (length.isFixed())
 645         return zoomAdjustedPixelValue(length.value(), style);
 646     return CSSValuePool::singleton().createValue(length, style);
 647 }
 648 
 649 static Ref&lt;CSSValue&gt; valueForReflection(const StyleReflection* reflection, const RenderStyle&amp; style)
 650 {
 651     if (!reflection)
 652         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 653 
 654     RefPtr&lt;CSSPrimitiveValue&gt; offset;
 655     if (reflection-&gt;offset().isPercentOrCalculated())
 656         offset = CSSValuePool::singleton().createValue(reflection-&gt;offset().percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
 657     else
 658         offset = zoomAdjustedPixelValue(reflection-&gt;offset().value(), style);
 659 
 660     RefPtr&lt;CSSPrimitiveValue&gt; direction;
 661     switch (reflection-&gt;direction()) {
 662     case ReflectionBelow:
 663         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
 664         break;
 665     case ReflectionAbove:
 666         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
 667         break;
 668     case ReflectionLeft:
 669         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
 670         break;
 671     case ReflectionRight:
 672         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
 673         break;
 674     }
 675 
 676     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection-&gt;mask()));
 677 }
 678 
 679 static Ref&lt;CSSValueList&gt; createPositionListForLayer(CSSPropertyID propertyID, const FillLayer&amp; layer, const RenderStyle&amp; style)
 680 {
 681     auto list = CSSValueList::createSpaceSeparated();
 682     if (layer.isBackgroundXOriginSet()) {
 683         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 684         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundXOrigin()));
 685     }
 686     list-&gt;append(zoomAdjustedPixelValueForLength(layer.xPosition(), style));
 687     if (layer.isBackgroundYOriginSet()) {
 688         ASSERT(propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 689         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundYOrigin()));
 690     }
 691     list-&gt;append(zoomAdjustedPixelValueForLength(layer.yPosition(), style));
 692     return list;
 693 }
 694 
 695 static Length getOffsetComputedLength(const RenderStyle&amp; style, CSSPropertyID propertyID)
 696 {
 697     // If specified as a length, the corresponding absolute length; if specified as
 698     // a percentage, the specified value; otherwise, &#39;auto&#39;. Hence, we can just
 699     // return the value in the style.
 700     //
 701     // See http://www.w3.org/TR/CSS21/cascade.html#computed-value
 702     switch (propertyID) {
 703     case CSSPropertyLeft:
 704         return style.left();
 705     case CSSPropertyRight:
 706         return style.right();
 707     case CSSPropertyTop:
 708         return style.top();
 709     case CSSPropertyBottom:
 710         return style.bottom();
 711     default:
 712         ASSERT_NOT_REACHED();
 713     }
 714 
 715     return { };
 716 }
 717 
 718 static LayoutUnit getOffsetUsedStyleRelative(RenderBox&amp; box, CSSPropertyID propertyID)
 719 {
 720     // For relatively positioned boxes, the offset is with respect to the top edges
 721     // of the box itself. This ties together top/bottom and left/right to be
 722     // opposites of each other.
 723     //
 724     // See http://www.w3.org/TR/CSS2/visuren.html#relative-positioning
 725     //
 726     // Specifically;
 727     //   Since boxes are not split or stretched as a result of &#39;left&#39; or
 728     //   &#39;right&#39;, the used values are always: left = -right.
 729     // and
 730     //   Since boxes are not split or stretched as a result of &#39;top&#39; or
 731     //   &#39;bottom&#39;, the used values are always: top = -bottom.
 732     switch (propertyID) {
 733     case CSSPropertyTop:
 734         return box.relativePositionOffset().height();
 735     case CSSPropertyBottom:
 736         return -(box.relativePositionOffset().height());
 737     case CSSPropertyLeft:
 738         return box.relativePositionOffset().width();
 739     case CSSPropertyRight:
 740         return -(box.relativePositionOffset().width());
 741     default:
 742         ASSERT_NOT_REACHED();
 743     }
 744 
 745     return 0;
 746 }
 747 
 748 static LayoutUnit getOffsetUsedStyleOutOfFlowPositioned(RenderBlock&amp; container, RenderBox&amp; box, CSSPropertyID propertyID)
 749 {
 750     // For out-of-flow positioned boxes, the offset is how far an box&#39;s margin
 751     // edge is offset below the edge of the box&#39;s containing block.
 752     // See http://www.w3.org/TR/CSS2/visuren.html#position-props
 753 
 754     // Margins are included in offsetTop/offsetLeft so we need to remove them here.
 755     switch (propertyID) {
 756     case CSSPropertyTop:
 757         return box.offsetTop() - box.marginTop();
 758     case CSSPropertyBottom:
 759         return container.clientHeight() - (box.offsetTop() + box.offsetHeight()) - box.marginBottom();
 760     case CSSPropertyLeft:
 761         return box.offsetLeft() - box.marginLeft();
 762     case CSSPropertyRight:
 763         return container.clientWidth() - (box.offsetLeft() + box.offsetWidth()) - box.marginRight();
 764     default:
 765         ASSERT_NOT_REACHED();
 766     }
 767 
 768     return 0;
 769 }
 770 
 771 static RefPtr&lt;CSSValue&gt; positionOffsetValue(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderObject* renderer)
 772 {
 773     auto offset = getOffsetComputedLength(style, propertyID);
 774 
 775     // If the element is not displayed; return the &quot;computed value&quot;.
 776     if (!renderer || !renderer-&gt;isBox())
 777         return zoomAdjustedPixelValueForLength(offset, style);
 778 
 779     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
 780     auto* containingBlock = box.containingBlock();
 781 
 782     // Resolve a &quot;computed value&quot; percentage if the element is positioned.
<a name="56" id="anc56"></a><span class="line-modified"> 783     if (containingBlock &amp;&amp; offset.isPercentOrCalculated() &amp;&amp; box.isPositioned()) {</span>

 784         bool isVerticalProperty;
 785         if (propertyID == CSSPropertyTop || propertyID == CSSPropertyBottom)
 786             isVerticalProperty = true;
 787         else {
 788             ASSERT(propertyID == CSSPropertyLeft || propertyID == CSSPropertyRight);
 789             isVerticalProperty = false;
 790         }
 791         LayoutUnit containingBlockSize;
<a name="57" id="anc57"></a><span class="line-modified"> 792         if (box.isStickilyPositioned()) {</span>
<span class="line-modified"> 793             auto&amp; enclosingClippingBox = box.enclosingClippingBoxForStickyPosition();</span>
<span class="line-modified"> 794             if (isVerticalProperty == enclosingClippingBox.isHorizontalWritingMode())</span>
<span class="line-modified"> 795                 containingBlockSize = enclosingClippingBox.contentLogicalHeight();</span>
<span class="line-added"> 796             else</span>
<span class="line-added"> 797                 containingBlockSize = enclosingClippingBox.contentLogicalWidth();</span>
 798         } else {
<a name="58" id="anc58"></a><span class="line-modified"> 799             if (isVerticalProperty == containingBlock-&gt;isHorizontalWritingMode()) {</span>
<span class="line-modified"> 800                 containingBlockSize = box.isOutOfFlowPositioned()</span>
<span class="line-modified"> 801                     ? box.containingBlockLogicalHeightForPositioned(*containingBlock, false)</span>
<span class="line-added"> 802                     : box.containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);</span>
<span class="line-added"> 803             } else {</span>
<span class="line-added"> 804                 containingBlockSize = box.isOutOfFlowPositioned()</span>
<span class="line-added"> 805                     ? box.containingBlockLogicalWidthForPositioned(*containingBlock, nullptr, false)</span>
<span class="line-added"> 806                     : box.containingBlockLogicalWidthForContent();</span>
<span class="line-added"> 807             }</span>
 808         }
 809         return zoomAdjustedPixelValue(floatValueForLength(offset, containingBlockSize), style);
 810     }
 811 
 812     // Return a &quot;computed value&quot; length.
 813     if (!offset.isAuto())
 814         return zoomAdjustedPixelValueForLength(offset, style);
 815 
 816     // The property won&#39;t be overconstrained if its computed value is &quot;auto&quot;, so the &quot;used value&quot; can be returned.
 817     if (box.isRelativelyPositioned())
 818         return zoomAdjustedPixelValue(getOffsetUsedStyleRelative(box, propertyID), style);
 819 
 820     if (containingBlock &amp;&amp; box.isOutOfFlowPositioned())
 821         return zoomAdjustedPixelValue(getOffsetUsedStyleOutOfFlowPositioned(*containingBlock, box, propertyID), style);
 822 
 823     return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 824 }
 825 
 826 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::currentColorOrValidColor(const RenderStyle* style, const Color&amp; color) const
 827 {
 828     // This function does NOT look at visited information, so that computed style doesn&#39;t expose that.
 829     if (!color.isValid())
 830         return CSSValuePool::singleton().createColorValue(style-&gt;color());
 831     return CSSValuePool::singleton().createColorValue(color);
 832 }
 833 
 834 static Ref&lt;CSSPrimitiveValue&gt; percentageOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 835 {
 836     if (length.isPercent())
 837         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
 838 
 839     return zoomAdjustedPixelValue(valueForLength(length, 0), style);
 840 }
 841 
 842 static Ref&lt;CSSPrimitiveValue&gt; autoOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 843 {
 844     if (length.isAuto())
 845         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 846 
 847     return zoomAdjustedPixelValue(valueForLength(length, 0), style);
 848 }
 849 
 850 static Ref&lt;CSSValueList&gt; borderRadiusCornerValues(const LengthSize&amp; radius, const RenderStyle&amp; style)
 851 {
 852     auto list = CSSValueList::createSpaceSeparated();
 853     list-&gt;append(percentageOrZoomAdjustedValue(radius.width, style));
 854     list-&gt;append(percentageOrZoomAdjustedValue(radius.height, style));
 855     return list;
 856 }
 857 
 858 static Ref&lt;CSSValue&gt; borderRadiusCornerValue(const LengthSize&amp; radius, const RenderStyle&amp; style)
 859 {
 860     if (radius.width == radius.height)
 861         return percentageOrZoomAdjustedValue(radius.width, style);
 862     return borderRadiusCornerValues(radius, style);
 863 }
 864 
 865 static Ref&lt;CSSValueList&gt; borderRadiusShorthandValue(const RenderStyle&amp; style)
 866 {
 867     auto list = CSSValueList::createSlashSeparated();
 868     bool showHorizontalBottomLeft = style.borderTopRightRadius().width != style.borderBottomLeftRadius().width;
 869     bool showHorizontalBottomRight = showHorizontalBottomLeft || (style.borderBottomRightRadius().width != style.borderTopLeftRadius().width);
 870     bool showHorizontalTopRight = showHorizontalBottomRight || (style.borderTopRightRadius().width != style.borderTopLeftRadius().width);
 871 
 872     bool showVerticalBottomLeft = style.borderTopRightRadius().height != style.borderBottomLeftRadius().height;
 873     bool showVerticalBottomRight = showVerticalBottomLeft || (style.borderBottomRightRadius().height != style.borderTopLeftRadius().height);
 874     bool showVerticalTopRight = showVerticalBottomRight || (style.borderTopRightRadius().height != style.borderTopLeftRadius().height);
 875 
 876     auto topLeftRadius = borderRadiusCornerValues(style.borderTopLeftRadius(), style);
 877     auto topRightRadius = borderRadiusCornerValues(style.borderTopRightRadius(), style);
 878     auto bottomRightRadius = borderRadiusCornerValues(style.borderBottomRightRadius(), style);
 879     auto bottomLeftRadius = borderRadiusCornerValues(style.borderBottomLeftRadius(), style);
 880 
 881     auto horizontalRadii = CSSValueList::createSpaceSeparated();
 882     horizontalRadii-&gt;append(*topLeftRadius-&gt;item(0));
 883     if (showHorizontalTopRight)
 884         horizontalRadii-&gt;append(*topRightRadius-&gt;item(0));
 885     if (showHorizontalBottomRight)
 886         horizontalRadii-&gt;append(*bottomRightRadius-&gt;item(0));
 887     if (showHorizontalBottomLeft)
 888         horizontalRadii-&gt;append(*bottomLeftRadius-&gt;item(0));
 889 
 890     list-&gt;append(WTFMove(horizontalRadii));
 891 
 892     auto verticalRadiiList = CSSValueList::createSpaceSeparated();
 893     verticalRadiiList-&gt;append(*topLeftRadius-&gt;item(1));
 894     if (showVerticalTopRight)
 895         verticalRadiiList-&gt;append(*topRightRadius-&gt;item(1));
 896     if (showVerticalBottomRight)
 897         verticalRadiiList-&gt;append(*bottomRightRadius-&gt;item(1));
 898     if (showVerticalBottomLeft)
 899         verticalRadiiList-&gt;append(*bottomLeftRadius-&gt;item(1));
 900 
 901     if (!verticalRadiiList-&gt;equals(downcast&lt;CSSValueList&gt;(*list-&gt;item(0))))
 902         list-&gt;append(WTFMove(verticalRadiiList));
 903 
 904     return list;
 905 }
 906 
 907 static LayoutRect sizingBox(RenderObject&amp; renderer)
 908 {
 909     if (!is&lt;RenderBox&gt;(renderer))
 910         return LayoutRect();
 911 
 912     auto&amp; box = downcast&lt;RenderBox&gt;(renderer);
 913     return box.style().boxSizing() == BoxSizing::BorderBox ? box.borderBoxRect() : box.computedCSSContentBoxRect();
 914 }
 915 
 916 static Ref&lt;CSSFunctionValue&gt; matrixTransformValue(const TransformationMatrix&amp; transform, const RenderStyle&amp; style)
 917 {
 918     RefPtr&lt;CSSFunctionValue&gt; transformValue;
 919     auto&amp; cssValuePool = CSSValuePool::singleton();
 920     if (transform.isAffine()) {
 921         transformValue = CSSFunctionValue::create(CSSValueMatrix);
 922 
 923         transformValue-&gt;append(cssValuePool.createValue(transform.a(), CSSPrimitiveValue::CSS_NUMBER));
 924         transformValue-&gt;append(cssValuePool.createValue(transform.b(), CSSPrimitiveValue::CSS_NUMBER));
 925         transformValue-&gt;append(cssValuePool.createValue(transform.c(), CSSPrimitiveValue::CSS_NUMBER));
 926         transformValue-&gt;append(cssValuePool.createValue(transform.d(), CSSPrimitiveValue::CSS_NUMBER));
 927         transformValue-&gt;append(zoomAdjustedNumberValue(transform.e(), style));
 928         transformValue-&gt;append(zoomAdjustedNumberValue(transform.f(), style));
 929     } else {
 930         transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
 931 
 932         transformValue-&gt;append(cssValuePool.createValue(transform.m11(), CSSPrimitiveValue::CSS_NUMBER));
 933         transformValue-&gt;append(cssValuePool.createValue(transform.m12(), CSSPrimitiveValue::CSS_NUMBER));
 934         transformValue-&gt;append(cssValuePool.createValue(transform.m13(), CSSPrimitiveValue::CSS_NUMBER));
 935         transformValue-&gt;append(cssValuePool.createValue(transform.m14(), CSSPrimitiveValue::CSS_NUMBER));
 936 
 937         transformValue-&gt;append(cssValuePool.createValue(transform.m21(), CSSPrimitiveValue::CSS_NUMBER));
 938         transformValue-&gt;append(cssValuePool.createValue(transform.m22(), CSSPrimitiveValue::CSS_NUMBER));
 939         transformValue-&gt;append(cssValuePool.createValue(transform.m23(), CSSPrimitiveValue::CSS_NUMBER));
 940         transformValue-&gt;append(cssValuePool.createValue(transform.m24(), CSSPrimitiveValue::CSS_NUMBER));
 941 
 942         transformValue-&gt;append(cssValuePool.createValue(transform.m31(), CSSPrimitiveValue::CSS_NUMBER));
 943         transformValue-&gt;append(cssValuePool.createValue(transform.m32(), CSSPrimitiveValue::CSS_NUMBER));
 944         transformValue-&gt;append(cssValuePool.createValue(transform.m33(), CSSPrimitiveValue::CSS_NUMBER));
 945         transformValue-&gt;append(cssValuePool.createValue(transform.m34(), CSSPrimitiveValue::CSS_NUMBER));
 946 
 947         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m41(), style));
 948         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m42(), style));
 949         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m43(), style));
 950         transformValue-&gt;append(cssValuePool.createValue(transform.m44(), CSSPrimitiveValue::CSS_NUMBER));
 951     }
 952 
 953     return transformValue.releaseNonNull();
 954 }
 955 
 956 static Ref&lt;CSSValue&gt; computedTransform(RenderObject* renderer, const RenderStyle&amp; style)
 957 {
 958     // Inline renderers do not support transforms.
 959     if (!renderer || is&lt;RenderInline&gt;(*renderer) || !style.hasTransform())
 960         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 961 
 962     FloatRect pixelSnappedRect;
 963     if (is&lt;RenderBox&gt;(*renderer))
 964         pixelSnappedRect = snapRectToDevicePixels(downcast&lt;RenderBox&gt;(*renderer).borderBoxRect(), renderer-&gt;document().deviceScaleFactor());
 965 
 966     TransformationMatrix transform;
 967     style.applyTransform(transform, pixelSnappedRect, RenderStyle::ExcludeTransformOrigin);
 968     // Note that this does not flatten to an affine transform if ENABLE(3D_TRANSFORMS) is off, by design.
 969 
 970     // FIXME: Need to print out individual functions (https://bugs.webkit.org/show_bug.cgi?id=23924)
 971     auto list = CSSValueList::createSpaceSeparated();
 972     list-&gt;append(matrixTransformValue(transform, style));
<a name="59" id="anc59"></a><span class="line-modified"> 973     return list;</span>
 974 }
 975 
 976 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 977 {
 978     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSPrimitiveValue::CSS_PX);
 979 }
 980 
 981 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 982 {
 983     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
 984 }
 985 
 986 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForShadow(const ShadowData* shadow, CSSPropertyID propertyID, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 987 {
 988     auto&amp; cssValuePool = CSSValuePool::singleton();
 989     if (!shadow)
 990         return cssValuePool.createIdentifierValue(CSSValueNone);
 991 
 992     auto list = CSSValueList::createCommaSeparated();
 993     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
 994         auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
 995         auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
 996         auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
 997         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
 998         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);
 999         auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
1000         list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
1001     }
<a name="60" id="anc60"></a><span class="line-modified">1002     return list;</span>
1003 }
1004 
1005 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForFilter(const RenderStyle&amp; style, const FilterOperations&amp; filterOperations, AdjustPixelValuesForComputedStyle adjust)
1006 {
1007     auto&amp; cssValuePool = CSSValuePool::singleton();
1008     if (filterOperations.operations().isEmpty())
1009         return cssValuePool.createIdentifierValue(CSSValueNone);
1010 
1011     auto list = CSSValueList::createSpaceSeparated();
1012 
1013     Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator end = filterOperations.operations().end();
1014     for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
1015         FilterOperation&amp; filterOperation = **it;
1016 
1017         if (filterOperation.type() == FilterOperation::REFERENCE) {
1018             ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
1019             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSPrimitiveValue::CSS_URI));
1020         } else {
1021             RefPtr&lt;CSSFunctionValue&gt; filterValue;
1022             switch (filterOperation.type()) {
1023             case FilterOperation::GRAYSCALE: {
1024                 filterValue = CSSFunctionValue::create(CSSValueGrayscale);
1025                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1026                 break;
1027             }
1028             case FilterOperation::SEPIA: {
1029                 filterValue = CSSFunctionValue::create(CSSValueSepia);
1030                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1031                 break;
1032             }
1033             case FilterOperation::SATURATE: {
1034                 filterValue = CSSFunctionValue::create(CSSValueSaturate);
1035                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1036                 break;
1037             }
1038             case FilterOperation::HUE_ROTATE: {
1039                 filterValue = CSSFunctionValue::create(CSSValueHueRotate);
1040                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_DEG));
1041                 break;
1042             }
1043             case FilterOperation::INVERT: {
1044                 filterValue = CSSFunctionValue::create(CSSValueInvert);
1045                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1046                 break;
1047             }
1048             case FilterOperation::APPLE_INVERT_LIGHTNESS: {
1049                 filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
1050                 break;
1051             }
1052             case FilterOperation::OPACITY: {
1053                 filterValue = CSSFunctionValue::create(CSSValueOpacity);
1054                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1055                 break;
1056             }
1057             case FilterOperation::BRIGHTNESS: {
1058                 filterValue = CSSFunctionValue::create(CSSValueBrightness);
1059                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1060                 break;
1061             }
1062             case FilterOperation::CONTRAST: {
1063                 filterValue = CSSFunctionValue::create(CSSValueContrast);
1064                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1065                 break;
1066             }
1067             case FilterOperation::BLUR: {
1068                 filterValue = CSSFunctionValue::create(CSSValueBlur);
1069                 filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
1070                 break;
1071             }
1072             case FilterOperation::DROP_SHADOW: {
1073                 DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
1074                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
1075                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
1076                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, Normal, false, dropShadowOperation.color());
1077                 filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
1078                 break;
1079             }
1080             default:
1081                 ASSERT_NOT_REACHED();
1082                 filterValue = CSSFunctionValue::create(CSSValueInvalid);
1083                 break;
1084             }
1085             list-&gt;append(filterValue.releaseNonNull());
1086         }
1087     }
<a name="61" id="anc61"></a><span class="line-modified">1088     return list;</span>
1089 }
1090 
1091 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
1092 {
1093     if (!trackBreadth.isLength())
1094         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSPrimitiveValue::CSS_FR);
1095 
1096     const Length&amp; trackBreadthLength = trackBreadth.length();
1097     if (trackBreadthLength.isAuto())
1098         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1099     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
1100 }
1101 
1102 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackSize(const GridTrackSize&amp; trackSize, const RenderStyle&amp; style)
1103 {
1104     switch (trackSize.type()) {
1105     case LengthTrackSizing:
1106         return specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style);
1107     case FitContentTrackSizing: {
1108         auto fitContentTrackSize = CSSFunctionValue::create(CSSValueFitContent);
1109         fitContentTrackSize-&gt;append(zoomAdjustedPixelValueForLength(trackSize.fitContentTrackBreadth().length(), style));
<a name="62" id="anc62"></a><span class="line-modified">1110         return fitContentTrackSize;</span>
1111     }
1112     default:
1113         ASSERT(trackSize.type() == MinMaxTrackSizing);
1114         if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
1115             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSPrimitiveValue::CSS_FR);
1116 
1117         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
1118         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
1119         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
<a name="63" id="anc63"></a><span class="line-modified">1120         return minMaxTrackBreadths;</span>
1121     }
1122 }
1123 
1124 class OrderedNamedLinesCollector {
1125     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
1126 public:
1127     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount)
1128         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
1129         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
1130         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())
1131         , m_autoRepeatTotalTracks(autoRepeatTracksCount)
1132         , m_autoRepeatTrackListLength(isRowAxis ? style.gridAutoRepeatColumns().size() : style.gridAutoRepeatRows().size())
1133     {
1134     }
1135 
1136     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
1137     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;
1138 
1139 private:
1140 
1141     enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
1142     void appendLines(CSSGridLineNamesValue&amp;, unsigned index, NamedLinesType) const;
1143 
1144     const OrderedNamedGridLinesMap&amp; m_orderedNamedGridLines;
1145     const OrderedNamedGridLinesMap&amp; m_orderedNamedAutoRepeatGridLines;
1146     unsigned m_insertionPoint;
1147     unsigned m_autoRepeatTotalTracks;
1148     unsigned m_autoRepeatTrackListLength;
1149 };
1150 
1151 void OrderedNamedLinesCollector::appendLines(CSSGridLineNamesValue&amp; lineNamesValue, unsigned index, NamedLinesType type) const
1152 {
1153     auto iter = type == NamedLines ? m_orderedNamedGridLines.find(index) : m_orderedNamedAutoRepeatGridLines.find(index);
1154     auto endIter = type == NamedLines ? m_orderedNamedGridLines.end() : m_orderedNamedAutoRepeatGridLines.end();
1155     if (iter == endIter)
1156         return;
1157 
1158     auto&amp; cssValuePool = CSSValuePool::singleton();
1159     for (const auto&amp; lineName : iter-&gt;value)
1160         lineNamesValue.append(cssValuePool.createValue(lineName, CSSPrimitiveValue::CSS_STRING));
1161 }
1162 
1163 void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
1164 {
1165     ASSERT(!isEmpty());
1166     if (m_orderedNamedAutoRepeatGridLines.isEmpty() || i &lt; m_insertionPoint) {
1167         appendLines(lineNamesValue, i, NamedLines);
1168         return;
1169     }
1170 
1171     ASSERT(m_autoRepeatTotalTracks);
1172 
1173     if (i &gt; m_insertionPoint + m_autoRepeatTotalTracks) {
1174         appendLines(lineNamesValue, i - (m_autoRepeatTotalTracks - 1), NamedLines);
1175         return;
1176     }
1177 
1178     if (i == m_insertionPoint) {
1179         appendLines(lineNamesValue, i, NamedLines);
1180         appendLines(lineNamesValue, 0, AutoRepeatNamedLines);
1181         return;
1182     }
1183 
1184     if (i == m_insertionPoint + m_autoRepeatTotalTracks) {
1185         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
1186         appendLines(lineNamesValue, m_insertionPoint + 1, NamedLines);
1187         return;
1188     }
1189 
1190     unsigned autoRepeatIndexInFirstRepetition = (i - m_insertionPoint) % m_autoRepeatTrackListLength;
1191     if (!autoRepeatIndexInFirstRepetition &amp;&amp; i &gt; m_insertionPoint)
1192         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
1193     appendLines(lineNamesValue, autoRepeatIndexInFirstRepetition, AutoRepeatNamedLines);
1194 }
1195 
1196 static void addValuesForNamedGridLinesAtIndex(OrderedNamedLinesCollector&amp; collector, unsigned i, CSSValueList&amp; list)
1197 {
1198     if (collector.isEmpty())
1199         return;
1200 
1201     auto lineNames = CSSGridLineNamesValue::create();
1202     collector.collectLineNamesForIndex(lineNames.get(), i);
1203     if (lineNames-&gt;length())
1204         list.append(WTFMove(lineNames));
1205 }
1206 
1207 static Ref&lt;CSSValueList&gt; valueForGridTrackSizeList(GridTrackSizingDirection direction, const RenderStyle&amp; style)
1208 {
1209     auto&amp; autoTrackSizes = direction == ForColumns ? style.gridAutoColumns() : style.gridAutoRows();
1210 
1211     auto list = CSSValueList::createSpaceSeparated();
1212     for (auto&amp; trackSize : autoTrackSizes)
1213         list-&gt;append(specifiedValueForGridTrackSize(trackSize, style));
1214     return list;
1215 }
1216 
1217 static Ref&lt;CSSValue&gt; valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle&amp; style)
1218 {
1219     bool isRowAxis = direction == ForColumns;
1220     bool isRenderGrid = is&lt;RenderGrid&gt;(renderer);
1221     auto&amp; trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
1222     auto&amp; autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
1223 
1224     // Handle the &#39;none&#39; case.
1225     bool trackListIsEmpty = trackSizes.isEmpty() &amp;&amp; autoRepeatTrackSizes.isEmpty();
1226     if (isRenderGrid &amp;&amp; trackListIsEmpty) {
1227         // For grids we should consider every listed track, whether implicitly or explicitly
1228         // created. Empty grids have a sole grid line per axis.
1229         auto&amp; grid = downcast&lt;RenderGrid&gt;(*renderer);
1230         auto&amp; positions = isRowAxis ? grid.columnPositions() : grid.rowPositions();
1231         trackListIsEmpty = positions.size() == 1;
1232     }
1233 
1234     if (trackListIsEmpty)
1235         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1236 
1237     unsigned autoRepeatTotalTracks = isRenderGrid ? downcast&lt;RenderGrid&gt;(renderer)-&gt;autoRepeatCountForDirection(direction) : 0;
1238     OrderedNamedLinesCollector collector(style, isRowAxis, autoRepeatTotalTracks);
1239     auto list = CSSValueList::createSpaceSeparated();
1240     unsigned insertionIndex;
1241     if (isRenderGrid) {
1242         auto computedTrackSizes = downcast&lt;RenderGrid&gt;(*renderer).trackSizesForComputedStyle(direction);
1243         unsigned numTracks = computedTrackSizes.size();
1244 
1245         for (unsigned i = 0; i &lt; numTracks; ++i) {
1246             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1247             list-&gt;append(zoomAdjustedPixelValue(computedTrackSizes[i], style));
1248         }
1249         addValuesForNamedGridLinesAtIndex(collector, numTracks + 1, list.get());
1250         insertionIndex = numTracks;
1251     } else {
1252         for (unsigned i = 0; i &lt; trackSizes.size(); ++i) {
1253             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1254             list-&gt;append(specifiedValueForGridTrackSize(trackSizes[i], style));
1255         }
1256         insertionIndex = trackSizes.size();
1257     }
1258 
1259     // Those are the trailing &lt;ident&gt;* allowed in the syntax.
1260     addValuesForNamedGridLinesAtIndex(collector, insertionIndex, list.get());
<a name="64" id="anc64"></a><span class="line-modified">1261     return list;</span>
1262 }
1263 
1264 static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
1265 {
1266     auto&amp; cssValuePool = CSSValuePool::singleton();
1267     if (position.isAuto())
1268         return cssValuePool.createIdentifierValue(CSSValueAuto);
1269 
1270     if (position.isNamedGridArea())
1271         return cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING);
1272 
1273     auto list = CSSValueList::createSpaceSeparated();
1274     if (position.isSpan()) {
1275         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
1276         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSPrimitiveValue::CSS_NUMBER));
1277     } else
1278         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSPrimitiveValue::CSS_NUMBER));
1279 
1280     if (!position.namedGridLine().isNull())
1281         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING));
<a name="65" id="anc65"></a><span class="line-modified">1282     return list;</span>
1283 }
1284 
1285 static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
1286 {
1287     switch (animation.animationMode()) {
1288     case Animation::AnimateNone:
1289         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1290     case Animation::AnimateAll:
1291         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1292     case Animation::AnimateSingleProperty:
1293         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSPrimitiveValue::CSS_STRING);
1294     case Animation::AnimateUnknownProperty:
1295         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSPrimitiveValue::CSS_STRING);
1296     }
1297     ASSERT_NOT_REACHED();
1298     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1299 }
1300 
1301 static Ref&lt;CSSValueList&gt; transitionPropertyValue(const AnimationList* animationList)
1302 {
1303     auto list = CSSValueList::createCommaSeparated();
1304     if (animationList) {
1305         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1306             list-&gt;append(createTransitionPropertyValue(animationList-&gt;animation(i)));
1307     } else
1308         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAll));
1309     return list;
1310 }
1311 
1312 #if ENABLE(CSS_SCROLL_SNAP)
1313 
1314 static Ref&lt;CSSValueList&gt; valueForScrollSnapType(const ScrollSnapType&amp; type)
1315 {
1316     auto value = CSSValueList::createSpaceSeparated();
1317     if (type.strictness == ScrollSnapStrictness::None)
1318         value-&gt;append(CSSValuePool::singleton().createValue(CSSValueNone));
1319     else {
1320         value-&gt;append(CSSPrimitiveValue::create(type.axis));
1321         value-&gt;append(CSSPrimitiveValue::create(type.strictness));
1322     }
1323     return value;
1324 }
1325 
1326 static Ref&lt;CSSValueList&gt; valueForScrollSnapAlignment(const ScrollSnapAlign&amp; alignment)
1327 {
1328     auto value = CSSValueList::createSpaceSeparated();
1329     value-&gt;append(CSSPrimitiveValue::create(alignment.x));
1330     value-&gt;append(CSSPrimitiveValue::create(alignment.y));
1331     return value;
1332 }
1333 
1334 #endif
1335 
1336 static Ref&lt;CSSValue&gt; willChangePropertyValue(const WillChangeData* willChangeData)
1337 {
1338     auto&amp; cssValuePool = CSSValuePool::singleton();
1339     if (!willChangeData || !willChangeData-&gt;numFeatures())
1340         return cssValuePool.createIdentifierValue(CSSValueAuto);
1341 
1342     auto list = CSSValueList::createCommaSeparated();
1343     for (size_t i = 0; i &lt; willChangeData-&gt;numFeatures(); ++i) {
1344         WillChangeData::FeaturePropertyPair feature = willChangeData-&gt;featureAt(i);
1345         switch (feature.first) {
1346         case WillChangeData::ScrollPosition:
1347             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueScrollPosition));
1348             break;
1349         case WillChangeData::Contents:
1350             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueContents));
1351             break;
1352         case WillChangeData::Property:
1353             list-&gt;append(cssValuePool.createIdentifierValue(feature.second));
1354             break;
1355         case WillChangeData::Invalid:
1356             ASSERT_NOT_REACHED();
1357             break;
1358         }
1359     }
1360 
<a name="66" id="anc66"></a><span class="line-modified">1361     return list;</span>
1362 }
1363 
1364 static inline void appendLigaturesValue(CSSValueList&amp; list, FontVariantLigatures value, CSSValueID yesValue, CSSValueID noValue)
1365 {
1366     switch (value) {
1367     case FontVariantLigatures::Normal:
1368         return;
1369     case FontVariantLigatures::No:
1370         list.append(CSSValuePool::singleton().createIdentifierValue(noValue));
1371         return;
1372     case FontVariantLigatures::Yes:
1373         list.append(CSSValuePool::singleton().createIdentifierValue(yesValue));
1374         return;
1375     }
1376     ASSERT_NOT_REACHED();
1377 }
1378 
1379 static Ref&lt;CSSValue&gt; fontVariantLigaturesPropertyValue(FontVariantLigatures common, FontVariantLigatures discretionary, FontVariantLigatures historical, FontVariantLigatures contextualAlternates)
1380 {
1381     auto&amp; cssValuePool = CSSValuePool::singleton();
1382     if (common == FontVariantLigatures::No &amp;&amp; discretionary == FontVariantLigatures::No &amp;&amp; historical == FontVariantLigatures::No &amp;&amp; contextualAlternates == FontVariantLigatures::No)
1383         return cssValuePool.createIdentifierValue(CSSValueNone);
1384     if (common == FontVariantLigatures::Normal &amp;&amp; discretionary == FontVariantLigatures::Normal &amp;&amp; historical == FontVariantLigatures::Normal &amp;&amp; contextualAlternates == FontVariantLigatures::Normal)
1385         return cssValuePool.createIdentifierValue(CSSValueNormal);
1386 
1387     auto valueList = CSSValueList::createSpaceSeparated();
1388     appendLigaturesValue(valueList, common, CSSValueCommonLigatures, CSSValueNoCommonLigatures);
1389     appendLigaturesValue(valueList, discretionary, CSSValueDiscretionaryLigatures, CSSValueNoDiscretionaryLigatures);
1390     appendLigaturesValue(valueList, historical, CSSValueHistoricalLigatures, CSSValueNoHistoricalLigatures);
1391     appendLigaturesValue(valueList, contextualAlternates, CSSValueContextual, CSSValueNoContextual);
<a name="67" id="anc67"></a><span class="line-modified">1392     return valueList;</span>
1393 }
1394 
1395 static Ref&lt;CSSValue&gt; fontVariantPositionPropertyValue(FontVariantPosition position)
1396 {
1397     auto&amp; cssValuePool = CSSValuePool::singleton();
1398     CSSValueID valueID = CSSValueNormal;
1399     switch (position) {
1400     case FontVariantPosition::Normal:
1401         break;
1402     case FontVariantPosition::Subscript:
1403         valueID = CSSValueSub;
1404         break;
1405     case FontVariantPosition::Superscript:
1406         valueID = CSSValueSuper;
1407         break;
1408     }
1409     return cssValuePool.createIdentifierValue(valueID);
1410 }
1411 
1412 static Ref&lt;CSSValue&gt; fontVariantCapsPropertyValue(FontVariantCaps caps)
1413 {
1414     auto&amp; cssValuePool = CSSValuePool::singleton();
1415     CSSValueID valueID = CSSValueNormal;
1416     switch (caps) {
1417     case FontVariantCaps::Normal:
1418         break;
1419     case FontVariantCaps::Small:
1420         valueID = CSSValueSmallCaps;
1421         break;
1422     case FontVariantCaps::AllSmall:
1423         valueID = CSSValueAllSmallCaps;
1424         break;
1425     case FontVariantCaps::Petite:
1426         valueID = CSSValuePetiteCaps;
1427         break;
1428     case FontVariantCaps::AllPetite:
1429         valueID = CSSValueAllPetiteCaps;
1430         break;
1431     case FontVariantCaps::Unicase:
1432         valueID = CSSValueUnicase;
1433         break;
1434     case FontVariantCaps::Titling:
1435         valueID = CSSValueTitlingCaps;
1436         break;
1437     }
1438     return cssValuePool.createIdentifierValue(valueID);
1439 }
1440 
1441 static Ref&lt;CSSValue&gt; fontVariantNumericPropertyValue(FontVariantNumericFigure figure, FontVariantNumericSpacing spacing, FontVariantNumericFraction fraction, FontVariantNumericOrdinal ordinal, FontVariantNumericSlashedZero slashedZero)
1442 {
1443     auto&amp; cssValuePool = CSSValuePool::singleton();
1444     if (figure == FontVariantNumericFigure::Normal &amp;&amp; spacing == FontVariantNumericSpacing::Normal &amp;&amp; fraction == FontVariantNumericFraction::Normal &amp;&amp; ordinal == FontVariantNumericOrdinal::Normal &amp;&amp; slashedZero == FontVariantNumericSlashedZero::Normal)
1445         return cssValuePool.createIdentifierValue(CSSValueNormal);
1446 
1447     auto valueList = CSSValueList::createSpaceSeparated();
1448     switch (figure) {
1449     case FontVariantNumericFigure::Normal:
1450         break;
1451     case FontVariantNumericFigure::LiningNumbers:
1452         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiningNums));
1453         break;
1454     case FontVariantNumericFigure::OldStyleNumbers:
1455         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOldstyleNums));
1456         break;
1457     }
1458 
1459     switch (spacing) {
1460     case FontVariantNumericSpacing::Normal:
1461         break;
1462     case FontVariantNumericSpacing::ProportionalNumbers:
1463         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalNums));
1464         break;
1465     case FontVariantNumericSpacing::TabularNumbers:
1466         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTabularNums));
1467         break;
1468     }
1469 
1470     switch (fraction) {
1471     case FontVariantNumericFraction::Normal:
1472         break;
1473     case FontVariantNumericFraction::DiagonalFractions:
1474         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueDiagonalFractions));
1475         break;
1476     case FontVariantNumericFraction::StackedFractions:
1477         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueStackedFractions));
1478         break;
1479     }
1480 
1481     if (ordinal == FontVariantNumericOrdinal::Yes)
1482         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOrdinal));
1483     if (slashedZero == FontVariantNumericSlashedZero::Yes)
1484         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSlashedZero));
1485 
<a name="68" id="anc68"></a><span class="line-modified">1486     return valueList;</span>
1487 }
1488 
1489 static Ref&lt;CSSValue&gt; fontVariantAlternatesPropertyValue(FontVariantAlternates alternates)
1490 {
1491     auto&amp; cssValuePool = CSSValuePool::singleton();
1492     CSSValueID valueID = CSSValueNormal;
1493     switch (alternates) {
1494     case FontVariantAlternates::Normal:
1495         break;
1496     case FontVariantAlternates::HistoricalForms:
1497         valueID = CSSValueHistoricalForms;
1498         break;
1499     }
1500     return cssValuePool.createIdentifierValue(valueID);
1501 }
1502 
1503 static Ref&lt;CSSValue&gt; fontVariantEastAsianPropertyValue(FontVariantEastAsianVariant variant, FontVariantEastAsianWidth width, FontVariantEastAsianRuby ruby)
1504 {
1505     auto&amp; cssValuePool = CSSValuePool::singleton();
1506     if (variant == FontVariantEastAsianVariant::Normal &amp;&amp; width == FontVariantEastAsianWidth::Normal &amp;&amp; ruby == FontVariantEastAsianRuby::Normal)
1507         return cssValuePool.createIdentifierValue(CSSValueNormal);
1508 
1509     auto valueList = CSSValueList::createSpaceSeparated();
1510     switch (variant) {
1511     case FontVariantEastAsianVariant::Normal:
1512         break;
1513     case FontVariantEastAsianVariant::Jis78:
1514         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis78));
1515         break;
1516     case FontVariantEastAsianVariant::Jis83:
1517         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis83));
1518         break;
1519     case FontVariantEastAsianVariant::Jis90:
1520         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis90));
1521         break;
1522     case FontVariantEastAsianVariant::Jis04:
1523         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis04));
1524         break;
1525     case FontVariantEastAsianVariant::Simplified:
1526         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSimplified));
1527         break;
1528     case FontVariantEastAsianVariant::Traditional:
1529         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTraditional));
1530         break;
1531     }
1532 
1533     switch (width) {
1534     case FontVariantEastAsianWidth::Normal:
1535         break;
1536     case FontVariantEastAsianWidth::Full:
1537         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueFullWidth));
1538         break;
1539     case FontVariantEastAsianWidth::Proportional:
1540         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalWidth));
1541         break;
1542     }
1543 
1544     if (ruby == FontVariantEastAsianRuby::Yes)
1545         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueRuby));
1546 
<a name="69" id="anc69"></a><span class="line-modified">1547     return valueList;</span>
1548 }
1549 
1550 static Ref&lt;CSSValueList&gt; delayValue(const AnimationList* animationList)
1551 {
1552     auto&amp; cssValuePool = CSSValuePool::singleton();
1553     auto list = CSSValueList::createCommaSeparated();
1554     if (animationList) {
1555         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1556             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSPrimitiveValue::CSS_S));
1557     } else {
1558         // Note that initialAnimationDelay() is used for both transitions and animations
1559         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
1560     }
1561     return list;
1562 }
1563 
1564 static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
1565 {
1566     auto&amp; cssValuePool = CSSValuePool::singleton();
1567     auto list = CSSValueList::createCommaSeparated();
1568     if (animationList) {
1569         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1570             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).duration(), CSSPrimitiveValue::CSS_S));
1571     } else {
1572         // Note that initialAnimationDuration() is used for both transitions and animations
1573         list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
1574     }
1575     return list;
1576 }
1577 
1578 static Ref&lt;CSSValue&gt; createTimingFunctionValue(const TimingFunction&amp; timingFunction)
1579 {
1580     switch (timingFunction.type()) {
1581     case TimingFunction::CubicBezierFunction: {
1582         auto&amp; function = downcast&lt;CubicBezierTimingFunction&gt;(timingFunction);
1583         if (function.timingFunctionPreset() != CubicBezierTimingFunction::Custom) {
1584             CSSValueID valueId = CSSValueInvalid;
1585             switch (function.timingFunctionPreset()) {
1586             case CubicBezierTimingFunction::Ease:
1587                 valueId = CSSValueEase;
1588                 break;
1589             case CubicBezierTimingFunction::EaseIn:
1590                 valueId = CSSValueEaseIn;
1591                 break;
1592             case CubicBezierTimingFunction::EaseOut:
1593                 valueId = CSSValueEaseOut;
1594                 break;
1595             default:
1596                 ASSERT(function.timingFunctionPreset() == CubicBezierTimingFunction::EaseInOut);
1597                 valueId = CSSValueEaseInOut;
1598                 break;
1599             }
1600             return CSSValuePool::singleton().createIdentifierValue(valueId);
1601         }
1602         return CSSCubicBezierTimingFunctionValue::create(function.x1(), function.y1(), function.x2(), function.y2());
1603     }
1604     case TimingFunction::StepsFunction: {
1605         auto&amp; function = downcast&lt;StepsTimingFunction&gt;(timingFunction);
1606         return CSSStepsTimingFunctionValue::create(function.numberOfSteps(), function.stepAtStart());
1607     }
1608     case TimingFunction::SpringFunction: {
1609         auto&amp; function = downcast&lt;SpringTimingFunction&gt;(timingFunction);
1610         return CSSSpringTimingFunctionValue::create(function.mass(), function.stiffness(), function.damping(), function.initialVelocity());
1611     }
1612     default:
1613         ASSERT(timingFunction.type() == TimingFunction::LinearFunction);
1614         return CSSValuePool::singleton().createIdentifierValue(CSSValueLinear);
1615     }
1616 }
1617 
1618 static Ref&lt;CSSValueList&gt; timingFunctionValue(const AnimationList* animationList)
1619 {
1620     auto list = CSSValueList::createCommaSeparated();
1621     if (animationList) {
1622         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1623             list-&gt;append(createTimingFunctionValue(*animationList-&gt;animation(i).timingFunction()));
1624     } else
1625         // Note that initialAnimationTimingFunction() is used for both transitions and animations
1626         list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
1627     return list;
1628 }
1629 
1630 static Ref&lt;CSSValue&gt; createLineBoxContainValue(unsigned lineBoxContain)
1631 {
1632     if (!lineBoxContain)
1633         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1634     return CSSLineBoxContainValue::create(lineBoxContain);
1635 }
1636 
1637 static Element* styleElementForNode(Node* node)
1638 {
1639     if (!node)
1640         return nullptr;
1641     if (is&lt;Element&gt;(*node))
1642         return downcast&lt;Element&gt;(node);
1643     return composedTreeAncestors(*node).first();
1644 }
1645 
1646 ComputedStyleExtractor::ComputedStyleExtractor(Node* node, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1647     : m_element(styleElementForNode(node))
1648     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1649     , m_allowVisitedStyle(allowVisitedStyle)
1650 {
1651 }
1652 
1653 ComputedStyleExtractor::ComputedStyleExtractor(Element* element, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1654     : m_element(element)
1655     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1656     , m_allowVisitedStyle(allowVisitedStyle)
1657 {
1658 }
1659 
<a name="70" id="anc70"></a><span class="line-modified">1660 CSSComputedStyleDeclaration::CSSComputedStyleDeclaration(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)</span>
1661     : m_element(element)
1662     , m_allowVisitedStyle(allowVisitedStyle)
<a name="71" id="anc71"></a>
1663 {
<a name="72" id="anc72"></a><span class="line-modified">1664     StringView name = pseudoElementName;</span>
<span class="line-modified">1665     if (name.startsWith(&#39;:&#39;))</span>
<span class="line-modified">1666         name = name.substring(1);</span>
<span class="line-added">1667     if (name.startsWith(&#39;:&#39;))</span>
<span class="line-added">1668         name = name.substring(1);</span>
<span class="line-added">1669     m_pseudoElementSpecifier = CSSSelector::pseudoId(CSSSelector::parsePseudoElementType(name));</span>
1670 }
1671 
1672 CSSComputedStyleDeclaration::~CSSComputedStyleDeclaration() = default;
1673 
<a name="73" id="anc73"></a><span class="line-added">1674 Ref&lt;CSSComputedStyleDeclaration&gt; CSSComputedStyleDeclaration::create(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)</span>
<span class="line-added">1675 {</span>
<span class="line-added">1676     return adoptRef(*new CSSComputedStyleDeclaration(element, allowVisitedStyle, pseudoElementName));</span>
<span class="line-added">1677 }</span>
<span class="line-added">1678 </span>
1679 void CSSComputedStyleDeclaration::ref()
1680 {
1681     ++m_refCount;
1682 }
1683 
1684 void CSSComputedStyleDeclaration::deref()
1685 {
1686     ASSERT(m_refCount);
1687     if (!--m_refCount)
1688         delete this;
1689 }
1690 
1691 String CSSComputedStyleDeclaration::cssText() const
1692 {
1693     StringBuilder result;
<a name="74" id="anc74"></a>
1694     for (unsigned i = 0; i &lt; numComputedProperties; i++) {
1695         if (i)
1696             result.append(&#39; &#39;);
<a name="75" id="anc75"></a><span class="line-modified">1697         result.append(getPropertyName(computedProperties[i]), &quot;: &quot;, getPropertyValue(computedProperties[i]), &#39;;&#39;);</span>



1698     }
<a name="76" id="anc76"></a>
1699     return result.toString();
1700 }
1701 
1702 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
1703 {
1704     return Exception { NoModificationAllowedError };
1705 }
1706 
1707 RefPtr&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::getFontSizeCSSValuePreferringKeyword()
1708 {
1709     if (!m_element)
1710         return nullptr;
1711 
1712     m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
1713 
1714     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1715     if (!style)
1716         return nullptr;
1717 
1718     if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier())
1719         return CSSValuePool::singleton().createIdentifierValue(sizeIdentifier);
1720 
1721     return zoomAdjustedPixelValue(style-&gt;fontDescription().computedSize(), *style);
1722 }
1723 
1724 bool ComputedStyleExtractor::useFixedFontDefaultSize()
1725 {
1726     if (!m_element)
1727         return false;
1728     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1729     if (!style)
1730         return false;
1731 
1732     return style-&gt;fontDescription().useFixedDefaultSize();
1733 }
1734 
<a name="77" id="anc77"></a><span class="line-modified">1735 static CSSValueID identifierForFamily(const AtomString&amp; family)</span>
1736 {
1737     if (family == cursiveFamily)
1738         return CSSValueCursive;
1739     if (family == fantasyFamily)
1740         return CSSValueFantasy;
1741     if (family == monospaceFamily)
1742         return CSSValueMonospace;
1743     if (family == pictographFamily)
1744         return CSSValueWebkitPictograph;
1745     if (family == sansSerifFamily)
1746         return CSSValueSansSerif;
1747     if (family == serifFamily)
1748         return CSSValueSerif;
1749     if (family == systemUiFamily)
1750         return CSSValueSystemUi;
1751     return CSSValueInvalid;
1752 }
1753 
<a name="78" id="anc78"></a><span class="line-modified">1754 static Ref&lt;CSSPrimitiveValue&gt; valueForFamily(const AtomString&amp; family)</span>
1755 {
1756     if (CSSValueID familyIdentifier = identifierForFamily(family))
1757         return CSSValuePool::singleton().createIdentifierValue(familyIdentifier);
1758     return CSSValuePool::singleton().createFontFamilyValue(family);
1759 }
1760 
1761 #if ENABLE(POINTER_EVENTS)
1762 static Ref&lt;CSSValue&gt; touchActionFlagsToCSSValue(OptionSet&lt;TouchAction&gt; touchActions)
1763 {
1764     auto&amp; cssValuePool = CSSValuePool::singleton();
1765 
1766     if (touchActions &amp; TouchAction::Auto)
1767         return cssValuePool.createIdentifierValue(CSSValueAuto);
1768     if (touchActions &amp; TouchAction::None)
1769         return cssValuePool.createIdentifierValue(CSSValueNone);
1770     if (touchActions &amp; TouchAction::Manipulation)
1771         return cssValuePool.createIdentifierValue(CSSValueManipulation);
1772 
1773     auto list = CSSValueList::createSpaceSeparated();
1774     if (touchActions &amp; TouchAction::PanX)
1775         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanX));
1776     if (touchActions &amp; TouchAction::PanY)
1777         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanY));
1778     if (touchActions &amp; TouchAction::PinchZoom)
1779         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePinchZoom));
1780 
1781     if (!list-&gt;length())
1782         return cssValuePool.createIdentifierValue(CSSValueAuto);
<a name="79" id="anc79"></a><span class="line-modified">1783     return list;</span>
1784 }
1785 #endif
1786 
1787 static Ref&lt;CSSValue&gt; renderTextDecorationFlagsToCSSValue(OptionSet&lt;TextDecoration&gt; textDecoration)
1788 {
1789     auto&amp; cssValuePool = CSSValuePool::singleton();
1790     // Blink value is ignored.
1791     auto list = CSSValueList::createSpaceSeparated();
1792     if (textDecoration &amp; TextDecoration::Underline)
1793         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnderline));
1794     if (textDecoration &amp; TextDecoration::Overline)
1795         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOverline));
1796     if (textDecoration &amp; TextDecoration::LineThrough)
1797         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLineThrough));
1798 #if ENABLE(LETTERPRESS)
1799     if (textDecoration &amp; TextDecoration::Letterpress)
1800         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitLetterpress));
1801 #endif
1802 
1803     if (!list-&gt;length())
1804         return cssValuePool.createIdentifierValue(CSSValueNone);
<a name="80" id="anc80"></a><span class="line-modified">1805     return list;</span>
1806 }
1807 
1808 static Ref&lt;CSSValue&gt; renderTextDecorationStyleFlagsToCSSValue(TextDecorationStyle textDecorationStyle)
1809 {
1810     switch (textDecorationStyle) {
1811     case TextDecorationStyle::Solid:
1812         return CSSValuePool::singleton().createIdentifierValue(CSSValueSolid);
1813     case TextDecorationStyle::Double:
1814         return CSSValuePool::singleton().createIdentifierValue(CSSValueDouble);
1815     case TextDecorationStyle::Dotted:
1816         return CSSValuePool::singleton().createIdentifierValue(CSSValueDotted);
1817     case TextDecorationStyle::Dashed:
1818         return CSSValuePool::singleton().createIdentifierValue(CSSValueDashed);
1819     case TextDecorationStyle::Wavy:
1820         return CSSValuePool::singleton().createIdentifierValue(CSSValueWavy);
1821     }
1822 
1823     ASSERT_NOT_REACHED();
1824     return CSSValuePool::singleton().createExplicitInitialValue();
1825 }
1826 
1827 static Ref&lt;CSSValue&gt; renderTextDecorationSkipFlagsToCSSValue(OptionSet&lt;TextDecorationSkip&gt; textDecorationSkip)
1828 {
1829     // FIXME: This should probably return a CSSValueList with the set of all TextDecorationSkips.
1830     switch (static_cast&lt;TextDecorationSkip&gt;(textDecorationSkip.toRaw())) {
1831     case TextDecorationSkip::Auto:
1832         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1833     case TextDecorationSkip::None:
1834         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1835     case TextDecorationSkip::Ink:
1836         return CSSValuePool::singleton().createIdentifierValue(CSSValueInk);
1837     case TextDecorationSkip::Objects:
1838         return CSSValuePool::singleton().createIdentifierValue(CSSValueObjects);
1839     }
1840 
1841     ASSERT_NOT_REACHED();
1842     return CSSValuePool::singleton().createExplicitInitialValue();
1843 }
1844 
1845 static Ref&lt;CSSValue&gt; textUnderlineOffsetToCSSValue(const TextUnderlineOffset&amp; textUnderlineOffset)
1846 {
1847     if (textUnderlineOffset.isAuto())
1848         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1849     ASSERT(textUnderlineOffset.isLength());
1850     return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSPrimitiveValue::CSS_PX);
1851 }
1852 
1853 static Ref&lt;CSSValue&gt; textDecorationThicknessToCSSValue(const TextDecorationThickness&amp; textDecorationThickness)
1854 {
1855     if (textDecorationThickness.isAuto())
1856         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1857     if (textDecorationThickness.isFromFont())
1858         return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
1859     ASSERT(textDecorationThickness.isLength());
1860     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSPrimitiveValue::CSS_PX);
1861 }
1862 
1863 static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
1864 {
1865     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
1866     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Left) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Right)));
1867     auto&amp; cssValuePool = CSSValuePool::singleton();
1868     auto list = CSSValueList::createSpaceSeparated();
1869     if (textEmphasisPosition &amp; TextEmphasisPosition::Over)
1870         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOver));
1871     if (textEmphasisPosition &amp; TextEmphasisPosition::Under)
1872         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnder));
1873     if (textEmphasisPosition &amp; TextEmphasisPosition::Left)
1874         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLeft));
1875     if (textEmphasisPosition &amp; TextEmphasisPosition::Right)
1876         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRight));
1877     if (!list-&gt;length())
1878         return cssValuePool.createIdentifierValue(CSSValueNone);
<a name="81" id="anc81"></a><span class="line-modified">1879     return list;</span>
1880 }
1881 
1882 static Ref&lt;CSSValue&gt; speakAsToCSSValue(OptionSet&lt;SpeakAs&gt; speakAs)
1883 {
1884     auto&amp; cssValuePool = CSSValuePool::singleton();
1885     auto list = CSSValueList::createSpaceSeparated();
1886     if (speakAs &amp; SpeakAs::SpellOut)
1887         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpellOut));
1888     if (speakAs &amp; SpeakAs::Digits)
1889         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDigits));
1890     if (speakAs &amp; SpeakAs::LiteralPunctuation)
1891         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiteralPunctuation));
1892     if (speakAs &amp; SpeakAs::NoPunctuation)
1893         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNoPunctuation));
1894     if (!list-&gt;length())
1895         return cssValuePool.createIdentifierValue(CSSValueNormal);
<a name="82" id="anc82"></a><span class="line-modified">1896     return list;</span>
1897 }
1898 
1899 static Ref&lt;CSSValue&gt; hangingPunctuationToCSSValue(OptionSet&lt;HangingPunctuation&gt; hangingPunctuation)
1900 {
1901     auto&amp; cssValuePool = CSSValuePool::singleton();
1902     auto list = CSSValueList::createSpaceSeparated();
1903     if (hangingPunctuation &amp; HangingPunctuation::First)
1904         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueFirst));
1905     if (hangingPunctuation &amp; HangingPunctuation::AllowEnd)
1906         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAllowEnd));
1907     if (hangingPunctuation &amp; HangingPunctuation::ForceEnd)
1908         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForceEnd));
1909     if (hangingPunctuation &amp; HangingPunctuation::Last)
1910         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
1911     if (!list-&gt;length())
1912         return cssValuePool.createIdentifierValue(CSSValueNone);
<a name="83" id="anc83"></a><span class="line-modified">1913     return list;</span>
1914 }
1915 
1916 static Ref&lt;CSSValue&gt; fillRepeatToCSSValue(FillRepeat xRepeat, FillRepeat yRepeat)
1917 {
1918     // For backwards compatibility, if both values are equal, just return one of them. And
1919     // if the two values are equivalent to repeat-x or repeat-y, just return the shorthand.
1920     auto&amp; cssValuePool = CSSValuePool::singleton();
1921     if (xRepeat == yRepeat)
1922         return cssValuePool.createValue(xRepeat);
1923     if (xRepeat == FillRepeat::Repeat &amp;&amp; yRepeat == FillRepeat::NoRepeat)
1924         return cssValuePool.createIdentifierValue(CSSValueRepeatX);
1925     if (xRepeat == FillRepeat::NoRepeat &amp;&amp; yRepeat == FillRepeat::Repeat)
1926         return cssValuePool.createIdentifierValue(CSSValueRepeatY);
1927 
1928     auto list = CSSValueList::createSpaceSeparated();
1929     list-&gt;append(cssValuePool.createValue(xRepeat));
1930     list-&gt;append(cssValuePool.createValue(yRepeat));
<a name="84" id="anc84"></a><span class="line-modified">1931     return list;</span>
1932 }
1933 
1934 static Ref&lt;CSSValue&gt; fillSourceTypeToCSSValue(MaskSourceType type)
1935 {
1936     switch (type) {
1937     case MaskSourceType::Alpha:
1938         return CSSValuePool::singleton().createValue(CSSValueAlpha);
1939     default:
1940         ASSERT(type == MaskSourceType::Luminance);
1941         return CSSValuePool::singleton().createValue(CSSValueLuminance);
1942     }
1943 }
1944 
1945 static Ref&lt;CSSValue&gt; fillSizeToCSSValue(const FillSize&amp; fillSize, const RenderStyle&amp; style)
1946 {
1947     if (fillSize.type == FillSizeType::Contain)
1948         return CSSValuePool::singleton().createIdentifierValue(CSSValueContain);
1949 
1950     if (fillSize.type == FillSizeType::Cover)
1951         return CSSValuePool::singleton().createIdentifierValue(CSSValueCover);
1952 
1953     if (fillSize.size.height.isAuto())
1954         return zoomAdjustedPixelValueForLength(fillSize.size.width, style);
1955 
1956     auto list = CSSValueList::createSpaceSeparated();
1957     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.width, style));
1958     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.height, style));
<a name="85" id="anc85"></a><span class="line-modified">1959     return list;</span>
1960 }
1961 
1962 static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
1963 {
1964     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSPrimitiveValue::CSS_STRING);
1965 }
1966 
1967 static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
1968 {
1969     auto&amp; cssValuePool = CSSValuePool::singleton();
1970     auto list = CSSValueList::createSpaceSeparated();
1971     for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
1972         if (is&lt;CounterContentData&gt;(*contentData))
1973             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSPrimitiveValue::CSS_COUNTER_NAME));
1974         else if (is&lt;ImageContentData&gt;(*contentData))
1975             list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
1976         else if (is&lt;TextContentData&gt;(*contentData))
1977             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSPrimitiveValue::CSS_STRING));
1978     }
1979     return list;
1980 }
1981 
1982 static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
1983 {
1984     auto* map = style.counterDirectives();
1985     if (!map)
1986         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1987 
1988     auto&amp; cssValuePool = CSSValuePool::singleton();
1989     auto list = CSSValueList::createSpaceSeparated();
1990     for (auto&amp; keyValue : *map) {
1991         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSPrimitiveValue::CSS_STRING));
1992         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
1993         list-&gt;append(cssValuePool.createValue(number, CSSPrimitiveValue::CSS_NUMBER));
1994     }
<a name="86" id="anc86"></a><span class="line-modified">1995     return list;</span>
1996 }
1997 
1998 static void logUnimplementedPropertyID(CSSPropertyID propertyID)
1999 {
2000     static NeverDestroyed&lt;HashSet&lt;CSSPropertyID&gt;&gt; propertyIDSet;
2001     if (!propertyIDSet.get().add(propertyID).isNewEntry)
2002         return;
2003 
2004     LOG_ERROR(&quot;WebKit does not yet implement getComputedStyle for &#39;%s&#39;.&quot;, getPropertyName(propertyID));
2005 }
2006 
2007 static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
2008 {
2009     auto list = CSSValueList::createCommaSeparated();
2010     for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
2011         list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
2012     return list;
2013 }
2014 
2015 static Ref&lt;CSSValue&gt; fontFamilyFromStyle(const RenderStyle&amp; style)
2016 {
2017     if (style.fontCascade().familyCount() == 1)
2018         return valueForFamily(style.fontCascade().familyAt(0));
2019     return fontFamilyListFromStyle(style);
2020 }
2021 
2022 static Ref&lt;CSSPrimitiveValue&gt; lineHeightFromStyle(const RenderStyle&amp; style)
2023 {
2024     Length length = style.lineHeight();
2025     if (length.isNegative()) // If true, line-height not set; use the font&#39;s line spacing.
2026         return zoomAdjustedPixelValue(style.fontMetrics().floatLineSpacing(), style);
2027     if (length.isPercent()) {
2028         // This is imperfect, because it doesn&#39;t include the zoom factor and the real computation
2029         // for how high to be in pixels does include things like minimum font size and the zoom factor.
2030         // On the other hand, since font-size doesn&#39;t include the zoom factor, we really can&#39;t do
2031         // that here either.
2032         return zoomAdjustedPixelValue(static_cast&lt;int&gt;(length.percent() * style.fontDescription().computedSize()) / 100, style);
2033     }
2034     return zoomAdjustedPixelValue(floatValueForLength(length, 0), style);
2035 }
2036 
2037 static Ref&lt;CSSPrimitiveValue&gt; fontSizeFromStyle(const RenderStyle&amp; style)
2038 {
2039     return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
2040 }
2041 
2042 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
2043 {
2044     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);
2045 }
2046 
2047 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
2048 {
2049     if (auto value = fontWeightKeyword(weight))
2050         return CSSValuePool::singleton().createIdentifierValue(value.value());
2051     return fontNonKeywordWeightFromStyleValue(weight);
2052 }
2053 
2054 static Ref&lt;CSSPrimitiveValue&gt; fontWeightFromStyle(const RenderStyle&amp; style)
2055 {
2056     return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
2057 }
2058 
2059 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
2060 {
2061     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(stretch), CSSPrimitiveValue::CSS_PERCENTAGE);
2062 }
2063 
2064 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
2065 {
2066     if (auto keyword = fontStretchKeyword(stretch))
2067         return CSSValuePool::singleton().createIdentifierValue(keyword.value());
2068     return fontNonKeywordStretchFromStyleValue(stretch);
2069 }
2070 
2071 static Ref&lt;CSSPrimitiveValue&gt; fontStretchFromStyle(const RenderStyle&amp; style)
2072 {
2073     return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
2074 }
2075 
2076 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
2077 {
2078     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(italic), CSSPrimitiveValue::CSS_DEG));
2079 }
2080 
2081 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontStyleFromStyleValue(Optional&lt;FontSelectionValue&gt; italic, FontStyleAxis fontStyleAxis)
2082 {
2083     if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
2084         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(keyword.value()));
2085     return fontNonKeywordStyleFromStyleValue(italic.value());
2086 }
2087 
2088 static Ref&lt;CSSFontStyleValue&gt; fontStyleFromStyle(const RenderStyle&amp; style)
2089 {
2090     return ComputedStyleExtractor::fontStyleFromStyleValue(style.fontDescription().italic(), style.fontDescription().fontStyleAxis());
2091 }
2092 
2093 static Ref&lt;CSSValue&gt; fontVariantFromStyle(const RenderStyle&amp; style)
2094 {
2095     if (style.fontDescription().variantSettings().isAllNormal())
2096         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2097 
2098     auto list = CSSValueList::createSpaceSeparated();
2099 
2100     switch (style.fontDescription().variantCommonLigatures()) {
2101     case FontVariantLigatures::Normal:
2102         break;
2103     case FontVariantLigatures::Yes:
2104         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueCommonLigatures));
2105         break;
2106     case FontVariantLigatures::No:
2107         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoCommonLigatures));
2108         break;
2109     }
2110 
2111     switch (style.fontDescription().variantDiscretionaryLigatures()) {
2112     case FontVariantLigatures::Normal:
2113         break;
2114     case FontVariantLigatures::Yes:
2115         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDiscretionaryLigatures));
2116         break;
2117     case FontVariantLigatures::No:
2118         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoDiscretionaryLigatures));
2119         break;
2120     }
2121 
2122     switch (style.fontDescription().variantHistoricalLigatures()) {
2123     case FontVariantLigatures::Normal:
2124         break;
2125     case FontVariantLigatures::Yes:
2126         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueHistoricalLigatures));
2127         break;
2128     case FontVariantLigatures::No:
2129         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoHistoricalLigatures));
2130         break;
2131     }
2132 
2133     switch (style.fontDescription().variantContextualAlternates()) {
2134     case FontVariantLigatures::Normal:
2135         break;
2136     case FontVariantLigatures::Yes:
2137         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueContextual));
2138         break;
2139     case FontVariantLigatures::No:
2140         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoContextual));
2141         break;
2142     }
2143 
2144     switch (style.fontDescription().variantPosition()) {
2145     case FontVariantPosition::Normal:
2146         break;
2147     case FontVariantPosition::Subscript:
2148         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSub));
2149         break;
2150     case FontVariantPosition::Superscript:
2151         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSuper));
2152         break;
2153     }
2154 
2155     switch (style.fontDescription().variantCaps()) {
2156     case FontVariantCaps::Normal:
2157         break;
2158     case FontVariantCaps::Small:
2159         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
2160         break;
2161     case FontVariantCaps::AllSmall:
2162         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAllSmallCaps));
2163         break;
2164     case FontVariantCaps::Petite:
2165         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValuePetiteCaps));
2166         break;
2167     case FontVariantCaps::AllPetite:
2168         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAllPetiteCaps));
2169         break;
2170     case FontVariantCaps::Unicase:
2171         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueUnicase));
2172         break;
2173     case FontVariantCaps::Titling:
2174         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTitlingCaps));
2175         break;
2176     }
2177 
2178     switch (style.fontDescription().variantNumericFigure()) {
2179     case FontVariantNumericFigure::Normal:
2180         break;
2181     case FontVariantNumericFigure::LiningNumbers:
2182         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueLiningNums));
2183         break;
2184     case FontVariantNumericFigure::OldStyleNumbers:
2185         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueOldstyleNums));
2186         break;
2187     }
2188 
2189     switch (style.fontDescription().variantNumericSpacing()) {
2190     case FontVariantNumericSpacing::Normal:
2191         break;
2192     case FontVariantNumericSpacing::ProportionalNumbers:
2193         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalNums));
2194         break;
2195     case FontVariantNumericSpacing::TabularNumbers:
2196         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTabularNums));
2197         break;
2198     }
2199 
2200     switch (style.fontDescription().variantNumericFraction()) {
2201     case FontVariantNumericFraction::Normal:
2202         break;
2203     case FontVariantNumericFraction::DiagonalFractions:
2204         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDiagonalFractions));
2205         break;
2206     case FontVariantNumericFraction::StackedFractions:
2207         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStackedFractions));
2208         break;
2209     }
2210 
2211     switch (style.fontDescription().variantNumericOrdinal()) {
2212     case FontVariantNumericOrdinal::Normal:
2213         break;
2214     case FontVariantNumericOrdinal::Yes:
2215         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueOrdinal));
2216         break;
2217     }
2218 
2219     switch (style.fontDescription().variantNumericSlashedZero()) {
2220     case FontVariantNumericSlashedZero::Normal:
2221         break;
2222     case FontVariantNumericSlashedZero::Yes:
2223         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSlashedZero));
2224         break;
2225     }
2226 
2227     switch (style.fontDescription().variantAlternates()) {
2228     case FontVariantAlternates::Normal:
2229         break;
2230     case FontVariantAlternates::HistoricalForms:
2231         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueHistoricalForms));
2232         break;
2233     }
2234 
2235     switch (style.fontDescription().variantEastAsianVariant()) {
2236     case FontVariantEastAsianVariant::Normal:
2237         break;
2238     case FontVariantEastAsianVariant::Jis78:
2239         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis78));
2240         break;
2241     case FontVariantEastAsianVariant::Jis83:
2242         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis83));
2243         break;
2244     case FontVariantEastAsianVariant::Jis90:
2245         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis90));
2246         break;
2247     case FontVariantEastAsianVariant::Jis04:
2248         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis04));
2249         break;
2250     case FontVariantEastAsianVariant::Simplified:
2251         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSimplified));
2252         break;
2253     case FontVariantEastAsianVariant::Traditional:
2254         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTraditional));
2255         break;
2256     }
2257 
2258     switch (style.fontDescription().variantEastAsianWidth()) {
2259     case FontVariantEastAsianWidth::Normal:
2260         break;
2261     case FontVariantEastAsianWidth::Full:
2262         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
2263         break;
2264     case FontVariantEastAsianWidth::Proportional:
2265         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
2266         break;
2267     }
2268 
2269     switch (style.fontDescription().variantEastAsianRuby()) {
2270     case FontVariantEastAsianRuby::Normal:
2271         break;
2272     case FontVariantEastAsianRuby::Yes:
2273         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
2274         break;
2275     }
2276 
<a name="87" id="anc87"></a><span class="line-modified">2277     return list;</span>
2278 }
2279 
2280 static Ref&lt;CSSValue&gt; fontSynthesisFromStyle(const RenderStyle&amp; style)
2281 {
2282     if (style.fontDescription().fontSynthesis() == FontSynthesisNone)
2283         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2284 
2285     auto list = CSSValueList::createSpaceSeparated();
2286     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisStyle)
2287         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStyle));
2288     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisWeight)
2289         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueWeight));
2290     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisSmallCaps)
2291         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
<a name="88" id="anc88"></a><span class="line-modified">2292     return list;</span>
2293 }
2294 
2295 typedef const Length&amp; (RenderStyle::*RenderStyleLengthGetter)() const;
2296 typedef LayoutUnit (RenderBoxModelObject::*RenderBoxComputedCSSValueGetter)() const;
2297 
2298 template&lt;RenderStyleLengthGetter lengthGetter, RenderBoxComputedCSSValueGetter computedCSSValueGetter&gt;
2299 static RefPtr&lt;CSSValue&gt; zoomAdjustedPaddingOrMarginPixelValue(const RenderStyle&amp; style, RenderObject* renderer)
2300 {
2301     Length unzoomzedLength = (style.*lengthGetter)();
2302     if (!is&lt;RenderBox&gt;(renderer) || unzoomzedLength.isFixed())
2303         return zoomAdjustedPixelValueForLength(unzoomzedLength, style);
2304     return zoomAdjustedPixelValue((downcast&lt;RenderBox&gt;(*renderer).*computedCSSValueGetter)(), style);
2305 }
2306 
2307 template&lt;RenderStyleLengthGetter lengthGetter&gt;
2308 static bool paddingOrMarginIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
2309 {
2310     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox() &amp;&amp; !(style-&gt;*lengthGetter)().isFixed();
2311 }
2312 
2313 static bool positionOffsetValueIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
2314 {
2315     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox();
2316 }
2317 
2318 static CSSValueID convertToPageBreak(BreakBetween value)
2319 {
2320     if (value == BreakBetween::Page || value == BreakBetween::LeftPage || value == BreakBetween::RightPage
2321         || value == BreakBetween::RectoPage || value == BreakBetween::VersoPage)
2322         return CSSValueAlways; // CSS 2.1 allows us to map these to always.
2323     if (value == BreakBetween::Avoid || value == BreakBetween::AvoidPage)
2324         return CSSValueAvoid;
2325     return CSSValueAuto;
2326 }
2327 
2328 static CSSValueID convertToColumnBreak(BreakBetween value)
2329 {
2330     if (value == BreakBetween::Column)
2331         return CSSValueAlways;
2332     if (value == BreakBetween::Avoid || value == BreakBetween::AvoidColumn)
2333         return CSSValueAvoid;
2334     return CSSValueAuto;
2335 }
2336 
2337 static CSSValueID convertToPageBreak(BreakInside value)
2338 {
2339     if (value == BreakInside::Avoid || value == BreakInside::AvoidPage)
2340         return CSSValueAvoid;
2341     return CSSValueAuto;
2342 }
2343 
2344 static CSSValueID convertToColumnBreak(BreakInside value)
2345 {
2346     if (value == BreakInside::Avoid || value == BreakInside::AvoidColumn)
2347         return CSSValueAvoid;
2348     return CSSValueAuto;
2349 }
2350 
2351 static inline bool isNonReplacedInline(RenderObject&amp; renderer)
2352 {
2353     return renderer.isInline() &amp;&amp; !renderer.isReplaced();
2354 }
2355 
2356 static bool isLayoutDependent(CSSPropertyID propertyID, const RenderStyle* style, RenderObject* renderer)
2357 {
2358     switch (propertyID) {
2359     case CSSPropertyTop:
2360     case CSSPropertyBottom:
2361     case CSSPropertyLeft:
2362     case CSSPropertyRight:
2363     case CSSPropertyInsetBlockStart:
2364     case CSSPropertyInsetBlockEnd:
2365     case CSSPropertyInsetInlineStart:
2366     case CSSPropertyInsetInlineEnd:
2367         return positionOffsetValueIsRendererDependent(style, renderer);
2368     case CSSPropertyWidth:
2369     case CSSPropertyHeight:
2370     case CSSPropertyInlineSize:
2371     case CSSPropertyBlockSize:
2372         return renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject() &amp;&amp; !isNonReplacedInline(*renderer);
2373     case CSSPropertyPerspectiveOrigin:
2374     case CSSPropertyTransformOrigin:
2375     case CSSPropertyTransform:
2376     case CSSPropertyFilter: // Why are filters layout-dependent?
2377 #if ENABLE(FILTERS_LEVEL_2)
2378     case CSSPropertyWebkitBackdropFilter: // Ditto for backdrop-filter.
2379 #endif
2380         return true;
2381     case CSSPropertyMargin: {
2382         if (!renderer || !renderer-&gt;isBox())
2383             return false;
2384         return !(style &amp;&amp; style-&gt;marginTop().isFixed() &amp;&amp; style-&gt;marginRight().isFixed()
2385             &amp;&amp; style-&gt;marginBottom().isFixed() &amp;&amp; style-&gt;marginLeft().isFixed());
2386     }
2387     case CSSPropertyMarginTop:
2388         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginTop&gt;(style, renderer);
2389     case CSSPropertyMarginRight:
2390         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginRight&gt;(style, renderer);
2391     case CSSPropertyMarginBottom:
2392         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginBottom&gt;(style, renderer);
2393     case CSSPropertyMarginLeft:
2394         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginLeft&gt;(style, renderer);
2395     case CSSPropertyPadding: {
2396         if (!renderer || !renderer-&gt;isBox())
2397             return false;
2398         return !(style &amp;&amp; style-&gt;paddingTop().isFixed() &amp;&amp; style-&gt;paddingRight().isFixed()
2399             &amp;&amp; style-&gt;paddingBottom().isFixed() &amp;&amp; style-&gt;paddingLeft().isFixed());
2400     }
2401     case CSSPropertyPaddingTop:
2402         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingTop&gt;(style, renderer);
2403     case CSSPropertyPaddingRight:
2404         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingRight&gt;(style, renderer);
2405     case CSSPropertyPaddingBottom:
2406         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingBottom&gt;(style, renderer);
2407     case CSSPropertyPaddingLeft:
2408         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingLeft&gt;(style, renderer);
2409     case CSSPropertyGridTemplateColumns:
2410     case CSSPropertyGridTemplateRows:
2411     case CSSPropertyGridTemplate:
2412     case CSSPropertyGrid:
2413         return renderer &amp;&amp; renderer-&gt;isRenderGrid();
2414     default:
2415         return false;
2416     }
2417 }
2418 
2419 Element* ComputedStyleExtractor::styledElement() const
2420 {
2421     if (!m_element)
2422         return nullptr;
2423     PseudoElement* pseudoElement;
2424     if (m_pseudoElementSpecifier == PseudoId::Before &amp;&amp; (pseudoElement = m_element-&gt;beforePseudoElement()))
2425         return pseudoElement;
2426     if (m_pseudoElementSpecifier == PseudoId::After &amp;&amp; (pseudoElement = m_element-&gt;afterPseudoElement()))
2427         return pseudoElement;
2428     return m_element.get();
2429 }
2430 
2431 RenderElement* ComputedStyleExtractor::styledRenderer() const
2432 {
2433     auto* element = styledElement();
2434     if (!element)
2435         return nullptr;
2436     if (m_pseudoElementSpecifier != PseudoId::None &amp;&amp; element == m_element.get())
2437         return nullptr;
2438     if (element-&gt;hasDisplayContents())
2439         return nullptr;
2440     return element-&gt;renderer();
2441 }
2442 
2443 static bool isImplicitlyInheritedGridOrFlexProperty(CSSPropertyID propertyID)
2444 {
2445     // It would be nice if grid and flex worked within normal CSS mechanisms and not invented their own inheritance system.
2446     switch (propertyID) {
2447     case CSSPropertyAlignSelf:
2448     case CSSPropertyJustifySelf:
2449     case CSSPropertyJustifyItems:
2450     // FIXME: In StyleResolver::adjustRenderStyle z-index is adjusted based on the parent display property for grid/flex.
2451     case CSSPropertyZIndex:
2452         return true;
2453     default:
2454         return false;
2455     }
2456 }
2457 
2458 // In CSS 2.1 the returned object should actually contain the &quot;used values&quot;
2459 // rather then the &quot;computed values&quot; (despite the name saying otherwise).
2460 //
2461 // See;
2462 // http://www.w3.org/TR/CSS21/cascade.html#used-value
2463 // http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration
2464 // https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle#Notes
2465 RefPtr&lt;CSSValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(CSSPropertyID propertyID, EUpdateLayout updateLayout) const
2466 {
2467     return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).propertyValue(propertyID, updateLayout);
2468 }
2469 
2470 Ref&lt;MutableStyleProperties&gt; CSSComputedStyleDeclaration::copyProperties() const
2471 {
2472     return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).copyProperties();
2473 }
2474 
2475 static inline bool hasValidStyleForProperty(Element&amp; element, CSSPropertyID propertyID)
2476 {
2477     if (element.styleValidity() != Style::Validity::Valid)
2478         return false;
2479     if (element.document().hasPendingFullStyleRebuild())
2480         return false;
2481     if (!element.document().childNeedsStyleRecalc())
2482         return true;
2483 
2484     bool isInherited = CSSProperty::isInheritedProperty(propertyID) || isImplicitlyInheritedGridOrFlexProperty(propertyID);
2485     bool maybeExplicitlyInherited = !isInherited;
2486 
2487     const auto* currentElement = &amp;element;
2488     for (auto&amp; ancestor : composedTreeAncestors(element)) {
2489         if (ancestor.styleValidity() &gt;= Style::Validity::SubtreeInvalid)
2490             return false;
2491 
2492         if (maybeExplicitlyInherited) {
2493             auto* style = currentElement-&gt;renderStyle();
2494             maybeExplicitlyInherited = !style || style-&gt;hasExplicitlyInheritedProperties();
2495         }
2496 
2497         if ((isInherited || maybeExplicitlyInherited) &amp;&amp; ancestor.styleValidity() == Style::Validity::ElementInvalid)
2498             return false;
2499 
2500         if (ancestor.directChildNeedsStyleRecalc() &amp;&amp; currentElement-&gt;styleIsAffectedByPreviousSibling())
2501             return false;
2502 
2503         currentElement = &amp;ancestor;
2504     }
2505 
2506     return true;
2507 }
2508 
2509 static bool updateStyleIfNeededForProperty(Element&amp; element, CSSPropertyID propertyID)
2510 {
2511     auto&amp; document = element.document();
2512 
2513     document.styleScope().flushPendingUpdate();
2514 
2515     if (hasValidStyleForProperty(element, propertyID))
2516         return false;
2517 
2518     document.updateStyleIfNeeded();
2519     return true;
2520 }
2521 
2522 static inline const RenderStyle* computeRenderStyleForProperty(Element&amp; element, PseudoId pseudoElementSpecifier, CSSPropertyID propertyID, std::unique_ptr&lt;RenderStyle&gt;&amp; ownedStyle)
2523 {
2524     auto* renderer = element.renderer();
2525 
2526     if (renderer &amp;&amp; renderer-&gt;isComposited() &amp;&amp; CSSAnimationController::supportsAcceleratedAnimationOfProperty(propertyID)) {
2527         if (auto timeline = element.document().existingTimeline())
2528             ownedStyle = timeline-&gt;animatedStyleForRenderer(*renderer);
2529         else
2530             ownedStyle = renderer-&gt;animation().animatedStyleForRenderer(*renderer);
2531         if (pseudoElementSpecifier != PseudoId::None &amp;&amp; !element.isPseudoElement()) {
2532             // FIXME: This cached pseudo style will only exist if the animation has been run at least once.
2533             return ownedStyle-&gt;getCachedPseudoStyle(pseudoElementSpecifier);
2534         }
2535         return ownedStyle.get();
2536     }
2537 
2538     return element.computedStyle(element.isPseudoElement() ? PseudoId::None : pseudoElementSpecifier);
2539 }
2540 
2541 static Ref&lt;CSSValue&gt; shapePropertyValue(const RenderStyle&amp; style, const ShapeValue* shapeValue)
2542 {
2543     if (!shapeValue)
2544         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2545 
2546     if (shapeValue-&gt;type() == ShapeValue::Type::Box)
2547         return CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox());
2548 
2549     if (shapeValue-&gt;type() == ShapeValue::Type::Image) {
2550         if (shapeValue-&gt;image())
2551             return shapeValue-&gt;image()-&gt;cssValue();
2552         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2553     }
2554 
2555     ASSERT(shapeValue-&gt;type() == ShapeValue::Type::Shape);
2556 
2557     auto list = CSSValueList::createSpaceSeparated();
2558     list-&gt;append(valueForBasicShape(style, *shapeValue-&gt;shape()));
2559     if (shapeValue-&gt;cssBox() != CSSBoxType::BoxMissing)
2560         list-&gt;append(CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox()));
<a name="89" id="anc89"></a><span class="line-modified">2561     return list;</span>
2562 }
2563 
2564 static Ref&lt;CSSValueList&gt; valueForItemPositionWithOverflowAlignment(const StyleSelfAlignmentData&amp; data)
2565 {
2566     auto&amp; cssValuePool = CSSValuePool::singleton();
2567     auto result = CSSValueList::createSpaceSeparated();
2568     if (data.positionType() == ItemPositionType::Legacy)
2569         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLegacy));
2570     if (data.position() == ItemPosition::Baseline)
2571         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2572     else if (data.position() == ItemPosition::LastBaseline) {
2573         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2574         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2575     } else {
2576         if (data.position() &gt;= ItemPosition::Center &amp;&amp; data.overflow() != OverflowAlignment::Default)
2577             result-&gt;append(cssValuePool.createValue(data.overflow()));
2578         if (data.position() == ItemPosition::Legacy)
2579             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2580         else
2581             result-&gt;append(cssValuePool.createValue(data.position()));
2582     }
2583     ASSERT(result-&gt;length() &lt;= 2);
2584     return result;
2585 }
2586 
2587 static Ref&lt;CSSValueList&gt; valueForContentPositionAndDistributionWithOverflowAlignment(const StyleContentAlignmentData&amp; data)
2588 {
2589     auto&amp; cssValuePool = CSSValuePool::singleton();
2590     auto result = CSSValueList::createSpaceSeparated();
2591     // Handle content-distribution values
2592     if (data.distribution() != ContentDistribution::Default)
2593         result-&gt;append(cssValuePool.createValue(data.distribution()));
2594 
2595     // Handle content-position values (either as fallback or actual value)
2596     switch (data.position()) {
2597     case ContentPosition::Normal:
2598         // Handle &#39;normal&#39; value, not valid as content-distribution fallback.
2599         if (data.distribution() == ContentDistribution::Default)
2600             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2601         break;
2602     case ContentPosition::LastBaseline:
2603         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2604         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2605         break;
2606     default:
2607         // Handle overflow-alignment (only allowed for content-position values)
2608         if ((data.position() &gt;= ContentPosition::Center || data.distribution() != ContentDistribution::Default) &amp;&amp; data.overflow() != OverflowAlignment::Default)
2609             result-&gt;append(cssValuePool.createValue(data.overflow()));
2610         result-&gt;append(cssValuePool.createValue(data.position()));
2611     }
2612 
2613     ASSERT(result-&gt;length() &gt; 0);
2614     ASSERT(result-&gt;length() &lt;= 3);
2615     return result;
2616 }
2617 
2618 static Ref&lt;CSSValue&gt; paintOrder(PaintOrder paintOrder)
2619 {
2620     if (paintOrder == PaintOrder::Normal)
2621         return CSSPrimitiveValue::createIdentifier(CSSValueNormal);
2622 
2623     auto paintOrderList = CSSValueList::createSpaceSeparated();
2624     switch (paintOrder) {
2625     case PaintOrder::Normal:
2626         ASSERT_NOT_REACHED();
2627         break;
2628     case PaintOrder::Fill:
2629         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2630         break;
2631     case PaintOrder::FillMarkers:
2632         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2633         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2634         break;
2635     case PaintOrder::Stroke:
2636         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2637         break;
2638     case PaintOrder::StrokeMarkers:
2639         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2640         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2641         break;
2642     case PaintOrder::Markers:
2643         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2644         break;
2645     case PaintOrder::MarkersStroke:
2646         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2647         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2648         break;
2649     }
<a name="90" id="anc90"></a><span class="line-modified">2650     return paintOrderList;</span>
2651 }
2652 
2653 inline static bool isFlexOrGrid(ContainerNode* element)
2654 {
2655     return element &amp;&amp; element-&gt;computedStyle() &amp;&amp; element-&gt;computedStyle()-&gt;isDisplayFlexibleOrGridBox();
2656 }
2657 
2658 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::customPropertyValue(const String&amp; propertyName)
2659 {
2660     Element* styledElement = this-&gt;styledElement();
2661     if (!styledElement)
2662         return nullptr;
2663 
2664     if (updateStyleIfNeededForProperty(*styledElement, CSSPropertyCustom)) {
2665         // Style update may change styledElement() to PseudoElement or back.
2666         styledElement = this-&gt;styledElement();
2667     }
2668 
2669     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2670     auto* style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, CSSPropertyCustom, ownedStyle);
2671     if (!style)
2672         return nullptr;
2673 
2674     auto* registered = styledElement-&gt;document().getCSSRegisteredCustomPropertySet().get(propertyName);
2675     auto* value = style-&gt;getCustomProperty(propertyName);
2676 
2677     if (registered &amp;&amp; !value)
2678         return registered-&gt;initialValueCopy();
2679 
2680     if (!value)
2681         return nullptr;
2682 
2683     return WTF::switchOn(value-&gt;value(), [&amp;](const Ref&lt;CSSVariableReferenceValue&gt;&amp;) {
2684         ASSERT_NOT_REACHED();
2685         return RefPtr&lt;CSSValue&gt;();
2686     }, [&amp;](const CSSValueID&amp;) {
2687         return CSSCustomPropertyValue::create(*value);
2688     }, [&amp;](const Ref&lt;CSSVariableData&gt;&amp;) {
2689         return CSSCustomPropertyValue::create(*value);
2690     }, [&amp;](const Length&amp; value) {
2691         return zoomAdjustedPixelValueForLength(value, *style);
2692     }, [&amp;](const Ref&lt;StyleImage&gt;&amp;) {
2693         return CSSCustomPropertyValue::create(*value);
2694     });
2695 }
2696 
2697 String ComputedStyleExtractor::customPropertyText(const String&amp; propertyName)
2698 {
2699     RefPtr&lt;CSSValue&gt; propertyValue = customPropertyValue(propertyName);
2700     return propertyValue ? propertyValue-&gt;cssText() : emptyString();
2701 }
2702 
2703 static Ref&lt;CSSFontValue&gt; fontShorthandValueForSelectionProperties(const FontDescription&amp; fontDescription)
2704 {
2705     auto computedFont = CSSFontValue::create();
2706 
2707     auto variantCaps = fontDescription.variantCaps();
2708     if (variantCaps == FontVariantCaps::Small)
2709         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps);
2710     else if (variantCaps == FontVariantCaps::Normal)
2711         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2712     else
2713         return CSSFontValue::create();
2714 
2715     auto weight = fontDescription.weight();
2716     if (auto value = fontWeightKeyword(weight))
2717         computedFont-&gt;weight = CSSValuePool::singleton().createIdentifierValue(value.value());
2718     else if (isCSS21Weight(weight))
2719         computedFont-&gt;weight = CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);
2720     else
2721         return CSSFontValue::create();
2722 
2723     if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
2724         computedFont-&gt;stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
2725     else
2726         return CSSFontValue::create();
2727 
2728     if (auto italic = fontStyleKeyword(fontDescription.italic(), fontDescription.fontStyleAxis()))
2729         computedFont-&gt;style = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(italic.value()));
2730     else
2731         return CSSFontValue::create();
2732 
2733     return computedFont;
2734 }
2735 
2736 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::propertyValue(CSSPropertyID propertyID, EUpdateLayout updateLayout)
2737 {
2738     auto* styledElement = this-&gt;styledElement();
2739     if (!styledElement)
2740         return nullptr;
2741 
2742     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2743     const RenderStyle* style = nullptr;
2744     RenderElement* renderer = nullptr;
2745     bool forceFullLayout = false;
2746     if (updateLayout) {
2747         Document&amp; document = m_element-&gt;document();
2748 
2749         if (updateStyleIfNeededForProperty(*styledElement, propertyID)) {
2750             // Style update may change styledElement() to PseudoElement or back.
2751             styledElement = this-&gt;styledElement();
2752         }
2753         renderer = styledRenderer();
2754 
2755         if (propertyID == CSSPropertyDisplay &amp;&amp; !renderer &amp;&amp; is&lt;SVGElement&gt;(*styledElement) &amp;&amp; !downcast&lt;SVGElement&gt;(*styledElement).isValid())
2756             return nullptr;
2757 
2758         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2759 
2760         // FIXME: Some of these cases could be narrowed down or optimized better.
2761         forceFullLayout = isLayoutDependent(propertyID, style, renderer)
2762             || styledElement-&gt;isInShadowTree()
2763             || (document.styleScope().resolverIfExists() &amp;&amp; document.styleScope().resolverIfExists()-&gt;hasViewportDependentMediaQueries() &amp;&amp; document.ownerElement());
2764 
2765         if (forceFullLayout) {
2766             document.updateLayoutIgnorePendingStylesheets();
2767             styledElement = this-&gt;styledElement();
2768         }
2769     }
2770 
2771     if (!updateLayout || forceFullLayout) {
2772         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2773         renderer = styledRenderer();
2774     }
2775 
2776     if (!style)
2777         return nullptr;
2778 
<a name="91" id="anc91"></a><span class="line-modified">2779     return valueForPropertyInStyle(*style, propertyID, renderer);</span>
2780 }
2781 
<a name="92" id="anc92"></a><span class="line-modified">2782 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::valueForPropertyInStyle(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderElement* renderer)</span>
2783 {
2784     auto&amp; cssValuePool = CSSValuePool::singleton();
2785     propertyID = CSSProperty::resolveDirectionAwareProperty(propertyID, style.direction(), style.writingMode());
2786 
2787     switch (propertyID) {
2788         case CSSPropertyInvalid:
<a name="93" id="anc93"></a><span class="line-added">2789 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-added">2790         case CSSPropertyInternalTextAutosizingStatus:</span>
<span class="line-added">2791 #endif</span>
2792             break;
2793 
2794         case CSSPropertyBackgroundColor:
2795             return cssValuePool.createColorValue(m_allowVisitedStyle? style.visitedDependentColor(CSSPropertyBackgroundColor) : style.backgroundColor());
2796         case CSSPropertyBackgroundImage:
2797         case CSSPropertyWebkitMaskImage: {
2798             auto&amp; layers = propertyID == CSSPropertyWebkitMaskImage ? style.maskLayers() : style.backgroundLayers();
2799             if (!layers.next()) {
2800                 if (layers.image())
2801                     return layers.image()-&gt;cssValue();
2802                 return cssValuePool.createIdentifierValue(CSSValueNone);
2803             }
2804             auto list = CSSValueList::createCommaSeparated();
2805             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next()) {
2806                 if (currLayer-&gt;image())
2807                     list-&gt;append(currLayer-&gt;image()-&gt;cssValue());
2808                 else
2809                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
2810             }
<a name="94" id="anc94"></a><span class="line-modified">2811             return list;</span>
2812         }
2813         case CSSPropertyBackgroundSize:
2814         case CSSPropertyWebkitBackgroundSize:
2815         case CSSPropertyWebkitMaskSize: {
2816             auto&amp; layers = propertyID == CSSPropertyWebkitMaskSize ? style.maskLayers() : style.backgroundLayers();
2817             if (!layers.next())
2818                 return fillSizeToCSSValue(layers.size(), style);
2819             auto list = CSSValueList::createCommaSeparated();
2820             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2821                 list-&gt;append(fillSizeToCSSValue(currLayer-&gt;size(), style));
<a name="95" id="anc95"></a><span class="line-modified">2822             return list;</span>
2823         }
2824         case CSSPropertyBackgroundRepeat:
2825         case CSSPropertyWebkitMaskRepeat: {
2826             auto&amp; layers = propertyID == CSSPropertyWebkitMaskRepeat ? style.maskLayers() : style.backgroundLayers();
2827             if (!layers.next())
2828                 return fillRepeatToCSSValue(layers.repeatX(), layers.repeatY());
2829             auto list = CSSValueList::createCommaSeparated();
2830             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2831                 list-&gt;append(fillRepeatToCSSValue(currLayer-&gt;repeatX(), currLayer-&gt;repeatY()));
<a name="96" id="anc96"></a><span class="line-modified">2832             return list;</span>
2833         }
2834         case CSSPropertyWebkitMaskSourceType: {
2835             auto&amp; layers = style.maskLayers();
2836             if (!layers.next())
2837                 return fillSourceTypeToCSSValue(layers.maskSourceType());
2838             auto list = CSSValueList::createCommaSeparated();
2839             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2840                 list-&gt;append(fillSourceTypeToCSSValue(currLayer-&gt;maskSourceType()));
<a name="97" id="anc97"></a><span class="line-modified">2841             return list;</span>
2842         }
2843         case CSSPropertyWebkitBackgroundComposite:
2844         case CSSPropertyWebkitMaskComposite: {
2845             auto&amp; layers = propertyID == CSSPropertyWebkitMaskComposite ? style.maskLayers() : style.backgroundLayers();
2846             if (!layers.next())
2847                 return cssValuePool.createValue(layers.composite());
2848             auto list = CSSValueList::createCommaSeparated();
2849             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2850                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;composite()));
<a name="98" id="anc98"></a><span class="line-modified">2851             return list;</span>
2852         }
2853         case CSSPropertyBackgroundAttachment: {
2854             auto&amp; layers = style.backgroundLayers();
2855             if (!layers.next())
2856                 return cssValuePool.createValue(layers.attachment());
2857             auto list = CSSValueList::createCommaSeparated();
2858             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2859                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;attachment()));
<a name="99" id="anc99"></a><span class="line-modified">2860             return list;</span>
2861         }
2862         case CSSPropertyBackgroundClip:
2863         case CSSPropertyBackgroundOrigin:
2864         case CSSPropertyWebkitBackgroundClip:
2865         case CSSPropertyWebkitBackgroundOrigin:
2866         case CSSPropertyWebkitMaskClip:
2867         case CSSPropertyWebkitMaskOrigin: {
2868             auto&amp; layers = (propertyID == CSSPropertyWebkitMaskClip || propertyID == CSSPropertyWebkitMaskOrigin) ? style.maskLayers() : style.backgroundLayers();
2869             bool isClip = propertyID == CSSPropertyBackgroundClip || propertyID == CSSPropertyWebkitBackgroundClip || propertyID == CSSPropertyWebkitMaskClip;
2870             if (!layers.next())
2871                 return cssValuePool.createValue(isClip ? layers.clip() : layers.origin());
2872             auto list = CSSValueList::createCommaSeparated();
2873             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2874                 list-&gt;append(cssValuePool.createValue(isClip ? currLayer-&gt;clip() : currLayer-&gt;origin()));
<a name="100" id="anc100"></a><span class="line-modified">2875             return list;</span>
2876         }
2877         case CSSPropertyBackgroundPosition:
2878         case CSSPropertyWebkitMaskPosition: {
2879             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPosition ? style.maskLayers() : style.backgroundLayers();
2880             if (!layers.next())
2881                 return createPositionListForLayer(propertyID, layers, style);
2882 
2883             auto list = CSSValueList::createCommaSeparated();
2884             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2885                 list-&gt;append(createPositionListForLayer(propertyID, *currLayer, style));
<a name="101" id="anc101"></a><span class="line-modified">2886             return list;</span>
2887         }
2888         case CSSPropertyBackgroundPositionX:
2889         case CSSPropertyWebkitMaskPositionX: {
2890             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionX ? style.maskLayers() : style.backgroundLayers();
2891             if (!layers.next())
2892                 return cssValuePool.createValue(layers.xPosition());
2893 
2894             auto list = CSSValueList::createCommaSeparated();
2895             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2896                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;xPosition()));
2897 
<a name="102" id="anc102"></a><span class="line-modified">2898             return list;</span>
2899         }
2900         case CSSPropertyBackgroundPositionY:
2901         case CSSPropertyWebkitMaskPositionY: {
2902             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionY ? style.maskLayers() : style.backgroundLayers();
2903             if (!layers.next())
2904                 return cssValuePool.createValue(layers.yPosition());
2905 
2906             auto list = CSSValueList::createCommaSeparated();
2907             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2908                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;yPosition()));
2909 
<a name="103" id="anc103"></a><span class="line-modified">2910             return list;</span>
2911         }
2912         case CSSPropertyBorderCollapse:
2913             if (style.borderCollapse() == BorderCollapse::Collapse)
2914                 return cssValuePool.createIdentifierValue(CSSValueCollapse);
2915             return cssValuePool.createIdentifierValue(CSSValueSeparate);
2916         case CSSPropertyBorderSpacing: {
2917             auto list = CSSValueList::createSpaceSeparated();
2918             list-&gt;append(zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style));
2919             list-&gt;append(zoomAdjustedPixelValue(style.verticalBorderSpacing(), style));
<a name="104" id="anc104"></a><span class="line-modified">2920             return list;</span>
2921         }
2922         case CSSPropertyWebkitBorderHorizontalSpacing:
2923             return zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style);
2924         case CSSPropertyWebkitBorderVerticalSpacing:
2925             return zoomAdjustedPixelValue(style.verticalBorderSpacing(), style);
2926         case CSSPropertyBorderImageSource:
2927             if (style.borderImageSource())
2928                 return style.borderImageSource()-&gt;cssValue();
2929             return cssValuePool.createIdentifierValue(CSSValueNone);
2930         case CSSPropertyBorderTopColor:
2931             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderTopColor)) : currentColorOrValidColor(&amp;style, style.borderTopColor());
2932         case CSSPropertyBorderRightColor:
2933             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderRightColor)) : currentColorOrValidColor(&amp;style, style.borderRightColor());
2934         case CSSPropertyBorderBottomColor:
2935             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderBottomColor)) : currentColorOrValidColor(&amp;style, style.borderBottomColor());
2936         case CSSPropertyBorderLeftColor:
2937             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderLeftColor)) : currentColorOrValidColor(&amp;style, style.borderLeftColor());
2938         case CSSPropertyBorderTopStyle:
2939             return cssValuePool.createValue(style.borderTopStyle());
2940         case CSSPropertyBorderRightStyle:
2941             return cssValuePool.createValue(style.borderRightStyle());
2942         case CSSPropertyBorderBottomStyle:
2943             return cssValuePool.createValue(style.borderBottomStyle());
2944         case CSSPropertyBorderLeftStyle:
2945             return cssValuePool.createValue(style.borderLeftStyle());
2946         case CSSPropertyBorderTopWidth:
2947             return zoomAdjustedPixelValue(style.borderTopWidth(), style);
2948         case CSSPropertyBorderRightWidth:
2949             return zoomAdjustedPixelValue(style.borderRightWidth(), style);
2950         case CSSPropertyBorderBottomWidth:
2951             return zoomAdjustedPixelValue(style.borderBottomWidth(), style);
2952         case CSSPropertyBorderLeftWidth:
2953             return zoomAdjustedPixelValue(style.borderLeftWidth(), style);
2954         case CSSPropertyBottom:
2955             return positionOffsetValue(style, CSSPropertyBottom, renderer);
2956         case CSSPropertyWebkitBoxAlign:
2957             return cssValuePool.createValue(style.boxAlign());
2958 #if ENABLE(CSS_BOX_DECORATION_BREAK)
2959         case CSSPropertyWebkitBoxDecorationBreak:
2960             if (style.boxDecorationBreak() == BoxDecorationBreak::Slice)
2961                 return cssValuePool.createIdentifierValue(CSSValueSlice);
2962         return cssValuePool.createIdentifierValue(CSSValueClone);
2963 #endif
2964         case CSSPropertyWebkitBoxDirection:
2965             return cssValuePool.createValue(style.boxDirection());
2966         case CSSPropertyWebkitBoxFlex:
2967             return cssValuePool.createValue(style.boxFlex(), CSSPrimitiveValue::CSS_NUMBER);
2968         case CSSPropertyWebkitBoxFlexGroup:
2969             return cssValuePool.createValue(style.boxFlexGroup(), CSSPrimitiveValue::CSS_NUMBER);
2970         case CSSPropertyWebkitBoxLines:
2971             return cssValuePool.createValue(style.boxLines());
2972         case CSSPropertyWebkitBoxOrdinalGroup:
2973             return cssValuePool.createValue(style.boxOrdinalGroup(), CSSPrimitiveValue::CSS_NUMBER);
2974         case CSSPropertyWebkitBoxOrient:
2975             return cssValuePool.createValue(style.boxOrient());
2976         case CSSPropertyWebkitBoxPack:
2977             return cssValuePool.createValue(style.boxPack());
2978         case CSSPropertyWebkitBoxReflect:
2979             return valueForReflection(style.boxReflect(), style);
2980         case CSSPropertyBoxShadow:
2981         case CSSPropertyWebkitBoxShadow:
2982             return valueForShadow(style.boxShadow(), propertyID, style);
2983         case CSSPropertyCaptionSide:
2984             return cssValuePool.createValue(style.captionSide());
2985         case CSSPropertyCaretColor:
2986             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyCaretColor)) : currentColorOrValidColor(&amp;style, style.caretColor());
2987         case CSSPropertyClear:
2988             return cssValuePool.createValue(style.clear());
2989         case CSSPropertyColor:
2990             return cssValuePool.createColorValue(m_allowVisitedStyle ? style.visitedDependentColor(CSSPropertyColor) : style.color());
2991         case CSSPropertyWebkitPrintColorAdjust:
2992             return cssValuePool.createValue(style.printColorAdjust());
2993         case CSSPropertyWebkitColumnAxis:
2994             return cssValuePool.createValue(style.columnAxis());
2995         case CSSPropertyColumnCount:
2996             if (style.hasAutoColumnCount())
2997                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2998             return cssValuePool.createValue(style.columnCount(), CSSPrimitiveValue::CSS_NUMBER);
2999         case CSSPropertyColumnFill:
3000             return cssValuePool.createValue(style.columnFill());
3001         case CSSPropertyColumnGap:
3002             if (style.columnGap().isNormal())
3003                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3004             return zoomAdjustedPixelValueForLength(style.columnGap().length(), style);
3005         case CSSPropertyRowGap:
3006             if (style.rowGap().isNormal())
3007                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3008             return zoomAdjustedPixelValueForLength(style.rowGap().length(), style);
3009         case CSSPropertyWebkitColumnProgression:
3010             return cssValuePool.createValue(style.columnProgression());
3011         case CSSPropertyColumnRuleColor:
3012             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.columnRuleColor());
3013         case CSSPropertyColumnRuleStyle:
3014             return cssValuePool.createValue(style.columnRuleStyle());
3015         case CSSPropertyColumnRuleWidth:
3016             return zoomAdjustedPixelValue(style.columnRuleWidth(), style);
3017         case CSSPropertyColumnSpan:
3018             return cssValuePool.createIdentifierValue(style.columnSpan() == ColumnSpan::All ? CSSValueAll : CSSValueNone);
3019         case CSSPropertyWebkitColumnBreakAfter:
3020             return cssValuePool.createValue(convertToColumnBreak(style.breakAfter()));
3021         case CSSPropertyWebkitColumnBreakBefore:
3022             return cssValuePool.createValue(convertToColumnBreak(style.breakBefore()));
3023         case CSSPropertyWebkitColumnBreakInside:
3024             return cssValuePool.createValue(convertToColumnBreak(style.breakInside()));
3025         case CSSPropertyColumnWidth:
3026             if (style.hasAutoColumnWidth())
3027                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3028             return zoomAdjustedPixelValue(style.columnWidth(), style);
3029         case CSSPropertyTabSize:
<a name="105" id="anc105"></a><span class="line-modified">3030             return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSPrimitiveValue::CSS_NUMBER : CSSPrimitiveValue::CSS_PX);</span>
3031         case CSSPropertyCursor: {
3032             RefPtr&lt;CSSValueList&gt; list;
3033             auto* cursors = style.cursors();
3034             if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
3035                 list = CSSValueList::createCommaSeparated();
3036                 for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i)
3037                     if (StyleImage* image = cursors-&gt;at(i).image())
3038                         list-&gt;append(image-&gt;cssValue());
3039             }
3040             auto value = cssValuePool.createValue(style.cursor());
3041             if (list) {
3042                 list-&gt;append(WTFMove(value));
3043                 return list;
3044             }
<a name="106" id="anc106"></a><span class="line-modified">3045             return value;</span>
3046         }
3047 #if ENABLE(CURSOR_VISIBILITY)
3048         case CSSPropertyWebkitCursorVisibility:
3049             return cssValuePool.createValue(style.cursorVisibility());
3050 #endif
3051         case CSSPropertyDirection:
3052             return cssValuePool.createValue(style.direction());
3053         case CSSPropertyDisplay:
3054             return cssValuePool.createValue(style.display());
3055         case CSSPropertyEmptyCells:
3056             return cssValuePool.createValue(style.emptyCells());
3057         case CSSPropertyAlignContent:
3058             return valueForContentPositionAndDistributionWithOverflowAlignment(style.alignContent());
3059         case CSSPropertyAlignItems:
3060             return valueForItemPositionWithOverflowAlignment(style.alignItems());
3061         case CSSPropertyAlignSelf:
3062             return valueForItemPositionWithOverflowAlignment(style.alignSelf());
3063         case CSSPropertyFlex:
3064             return getCSSPropertyValuesForShorthandProperties(flexShorthand());
3065         case CSSPropertyFlexBasis:
3066             return cssValuePool.createValue(style.flexBasis(), style);
3067         case CSSPropertyFlexDirection:
3068             return cssValuePool.createValue(style.flexDirection());
3069         case CSSPropertyFlexFlow:
3070             return getCSSPropertyValuesForShorthandProperties(flexFlowShorthand());
3071         case CSSPropertyFlexGrow:
3072             return cssValuePool.createValue(style.flexGrow());
3073         case CSSPropertyFlexShrink:
3074             return cssValuePool.createValue(style.flexShrink());
3075         case CSSPropertyFlexWrap:
3076             return cssValuePool.createValue(style.flexWrap());
3077         case CSSPropertyJustifyContent:
3078             return valueForContentPositionAndDistributionWithOverflowAlignment(style.justifyContent());
3079         case CSSPropertyJustifyItems:
3080             return valueForItemPositionWithOverflowAlignment(style.justifyItems());
3081         case CSSPropertyJustifySelf:
3082             return valueForItemPositionWithOverflowAlignment(style.justifySelf());
3083         case CSSPropertyPlaceContent:
3084             return getCSSPropertyValuesForShorthandProperties(placeContentShorthand());
3085         case CSSPropertyPlaceItems:
3086             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
3087         case CSSPropertyPlaceSelf:
3088             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
3089         case CSSPropertyOrder:
3090             return cssValuePool.createValue(style.order(), CSSPrimitiveValue::CSS_NUMBER);
3091         case CSSPropertyFloat:
3092             if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
3093                 return cssValuePool.createIdentifierValue(CSSValueNone);
3094             return cssValuePool.createValue(style.floating());
3095         case CSSPropertyFont: {
3096             auto computedFont = fontShorthandValueForSelectionProperties(style.fontDescription());
3097             computedFont-&gt;size = fontSizeFromStyle(style);
3098             computedFont-&gt;lineHeight = lineHeightFromStyle(style);
3099             computedFont-&gt;family = fontFamilyListFromStyle(style);
<a name="107" id="anc107"></a><span class="line-modified">3100             return computedFont;</span>
3101         }
3102         case CSSPropertyFontFamily:
3103             return fontFamilyFromStyle(style);
3104         case CSSPropertyFontSize:
3105             return fontSizeFromStyle(style);
3106         case CSSPropertyFontStyle:
3107             return fontStyleFromStyle(style);
3108         case CSSPropertyFontStretch:
3109             return fontStretchFromStyle(style);
3110         case CSSPropertyFontVariant:
3111             return fontVariantFromStyle(style);
3112         case CSSPropertyFontWeight:
3113             return fontWeightFromStyle(style);
3114         case CSSPropertyFontSynthesis:
3115             return fontSynthesisFromStyle(style);
3116         case CSSPropertyFontFeatureSettings: {
3117             const FontFeatureSettings&amp; featureSettings = style.fontDescription().featureSettings();
3118             if (!featureSettings.size())
3119                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3120             auto list = CSSValueList::createCommaSeparated();
3121             for (auto&amp; feature : featureSettings)
3122                 list-&gt;append(CSSFontFeatureValue::create(FontTag(feature.tag()), feature.value()));
<a name="108" id="anc108"></a><span class="line-modified">3123             return list;</span>
3124         }
3125 #if ENABLE(VARIATION_FONTS)
3126         case CSSPropertyFontVariationSettings: {
3127             const FontVariationSettings&amp; variationSettings = style.fontDescription().variationSettings();
3128             if (variationSettings.isEmpty())
3129                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3130             auto list = CSSValueList::createCommaSeparated();
3131             for (auto&amp; feature : variationSettings)
3132                 list-&gt;append(CSSFontVariationValue::create(feature.tag(), feature.value()));
<a name="109" id="anc109"></a><span class="line-modified">3133             return list;</span>
3134         }
3135         case CSSPropertyFontOpticalSizing:
3136             return cssValuePool.createValue(style.fontDescription().opticalSizing());
3137 #endif
3138         case CSSPropertyGridAutoFlow: {
3139             auto list = CSSValueList::createSpaceSeparated();
3140             ASSERT(style.isGridAutoFlowDirectionRow() || style.isGridAutoFlowDirectionColumn());
3141             if (style.isGridAutoFlowDirectionRow())
3142                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRow));
3143             else
3144                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueColumn));
3145 
3146             if (style.isGridAutoFlowAlgorithmDense())
3147                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDense));
3148 
<a name="110" id="anc110"></a><span class="line-modified">3149             return list;</span>
3150         }
3151 
3152         // Specs mention that getComputedStyle() should return the used value of the property instead of the computed
3153         // one for grid-template-{rows|columns} but not for the grid-auto-{rows|columns} as things like
3154         // grid-auto-columns: 2fr; cannot be resolved to a value in pixels as the &#39;2fr&#39; means very different things
3155         // depending on the size of the explicit grid or the number of implicit tracks added to the grid. See
3156         // http://lists.w3.org/Archives/Public/www-style/2013Nov/0014.html
3157         case CSSPropertyGridAutoColumns:
3158             return valueForGridTrackSizeList(ForColumns, style);
3159         case CSSPropertyGridAutoRows:
3160             return valueForGridTrackSizeList(ForRows, style);
3161 
3162         case CSSPropertyGridTemplateColumns:
3163             return valueForGridTrackList(ForColumns, renderer, style);
3164         case CSSPropertyGridTemplateRows:
3165             return valueForGridTrackList(ForRows, renderer, style);
3166 
3167         case CSSPropertyGridColumnStart:
3168             return valueForGridPosition(style.gridItemColumnStart());
3169         case CSSPropertyGridColumnEnd:
3170             return valueForGridPosition(style.gridItemColumnEnd());
3171         case CSSPropertyGridRowStart:
3172             return valueForGridPosition(style.gridItemRowStart());
3173         case CSSPropertyGridRowEnd:
3174             return valueForGridPosition(style.gridItemRowEnd());
3175         case CSSPropertyGridArea:
3176             return getCSSPropertyValuesForGridShorthand(gridAreaShorthand());
3177         case CSSPropertyGridTemplate:
3178             return getCSSPropertyValuesForGridShorthand(gridTemplateShorthand());
3179         case CSSPropertyGrid:
3180             return getCSSPropertyValuesForGridShorthand(gridShorthand());
3181         case CSSPropertyGridColumn:
3182             return getCSSPropertyValuesForGridShorthand(gridColumnShorthand());
3183         case CSSPropertyGridRow:
3184             return getCSSPropertyValuesForGridShorthand(gridRowShorthand());
3185         case CSSPropertyGridTemplateAreas:
3186             if (!style.namedGridAreaRowCount()) {
3187                 ASSERT(!style.namedGridAreaColumnCount());
3188                 return cssValuePool.createIdentifierValue(CSSValueNone);
3189             }
3190             return CSSGridTemplateAreasValue::create(style.namedGridArea(), style.namedGridAreaRowCount(), style.namedGridAreaColumnCount());
3191         case CSSPropertyGap:
3192             return getCSSPropertyValuesForShorthandProperties(gapShorthand());
3193         case CSSPropertyHeight:
3194             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3195                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-height-property,
3196                 // the &quot;height&quot; property does not apply for non-replaced inline elements.
<a name="111" id="anc111"></a><span class="line-modified">3197                 if (!isNonReplacedInline(*renderer))</span>
<span class="line-modified">3198                     return zoomAdjustedPixelValue(sizingBox(*renderer).height(), style);</span>

3199             }
3200             return zoomAdjustedPixelValueForLength(style.height(), style);
3201         case CSSPropertyWebkitHyphens:
3202             return cssValuePool.createValue(style.hyphens());
3203         case CSSPropertyWebkitHyphenateCharacter:
3204             if (style.hyphenationString().isNull())
3205                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3206             return cssValuePool.createValue(style.hyphenationString(), CSSPrimitiveValue::CSS_STRING);
3207         case CSSPropertyWebkitHyphenateLimitAfter:
3208             if (style.hyphenationLimitAfter() &lt; 0)
3209                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3210             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSPrimitiveValue::CSS_NUMBER);
3211         case CSSPropertyWebkitHyphenateLimitBefore:
3212             if (style.hyphenationLimitBefore() &lt; 0)
3213                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3214             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSPrimitiveValue::CSS_NUMBER);
3215         case CSSPropertyWebkitHyphenateLimitLines:
3216             if (style.hyphenationLimitLines() &lt; 0)
3217                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
3218             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSPrimitiveValue::CSS_NUMBER);
3219         case CSSPropertyWebkitBorderFit:
3220             if (style.borderFit() == BorderFit::Border)
3221                 return cssValuePool.createIdentifierValue(CSSValueBorder);
3222             return cssValuePool.createIdentifierValue(CSSValueLines);
3223 #if ENABLE(CSS_IMAGE_ORIENTATION)
3224         case CSSPropertyImageOrientation:
3225             return cssValuePool.createValue(style.imageOrientation());
3226 #endif
3227         case CSSPropertyImageRendering:
3228             return CSSPrimitiveValue::create(style.imageRendering());
3229 #if ENABLE(CSS_IMAGE_RESOLUTION)
3230         case CSSPropertyImageResolution:
3231             return cssValuePool.createValue(style.imageResolution(), CSSPrimitiveValue::CSS_DPPX);
3232 #endif
3233         case CSSPropertyLeft:
3234             return positionOffsetValue(style, CSSPropertyLeft, renderer);
3235         case CSSPropertyLetterSpacing:
3236             if (!style.letterSpacing())
3237                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3238             return zoomAdjustedPixelValue(style.letterSpacing(), style);
3239         case CSSPropertyWebkitLineClamp:
3240             if (style.lineClamp().isNone())
3241                 return cssValuePool.createIdentifierValue(CSSValueNone);
3242             return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSPrimitiveValue::CSS_PERCENTAGE : CSSPrimitiveValue::CSS_NUMBER);
3243         case CSSPropertyLineHeight:
3244             return lineHeightFromStyle(style);
3245         case CSSPropertyListStyleImage:
3246             if (style.listStyleImage())
3247                 return style.listStyleImage()-&gt;cssValue();
3248             return cssValuePool.createIdentifierValue(CSSValueNone);
3249         case CSSPropertyListStylePosition:
3250             return cssValuePool.createValue(style.listStylePosition());
3251         case CSSPropertyListStyleType:
3252             return cssValuePool.createValue(style.listStyleType());
3253         case CSSPropertyWebkitLocale:
3254             if (style.locale().isNull())
3255                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3256             return cssValuePool.createValue(style.locale(), CSSPrimitiveValue::CSS_STRING);
3257         case CSSPropertyMarginTop:
3258             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginTop, &amp;RenderBoxModelObject::marginTop&gt;(style, renderer);
3259         case CSSPropertyMarginRight: {
3260             Length marginRight = style.marginRight();
3261             if (marginRight.isFixed() || !is&lt;RenderBox&gt;(renderer))
3262                 return zoomAdjustedPixelValueForLength(marginRight, style);
3263             float value;
3264             if (marginRight.isPercentOrCalculated()) {
3265                 // RenderBox gives a marginRight() that is the distance between the right-edge of the child box
3266                 // and the right-edge of the containing box, when display == DisplayType::Block. Let&#39;s calculate the absolute
3267                 // value of the specified margin-right % instead of relying on RenderBox&#39;s marginRight() value.
3268                 value = minimumValueForLength(marginRight, downcast&lt;RenderBox&gt;(*renderer).containingBlockLogicalWidthForContent());
3269             } else
3270                 value = downcast&lt;RenderBox&gt;(*renderer).marginRight();
3271             return zoomAdjustedPixelValue(value, style);
3272         }
3273         case CSSPropertyMarginBottom:
3274             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginBottom, &amp;RenderBoxModelObject::marginBottom&gt;(style, renderer);
3275         case CSSPropertyMarginLeft:
3276             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginLeft, &amp;RenderBoxModelObject::marginLeft&gt;(style, renderer);
3277         case CSSPropertyWebkitMarqueeDirection:
3278             return cssValuePool.createValue(style.marqueeDirection());
3279         case CSSPropertyWebkitMarqueeIncrement:
3280             return cssValuePool.createValue(style.marqueeIncrement());
3281         case CSSPropertyWebkitMarqueeRepetition:
3282             if (style.marqueeLoopCount() &lt; 0)
3283                 return cssValuePool.createIdentifierValue(CSSValueInfinite);
3284             return cssValuePool.createValue(style.marqueeLoopCount(), CSSPrimitiveValue::CSS_NUMBER);
3285         case CSSPropertyWebkitMarqueeStyle:
3286             return cssValuePool.createValue(style.marqueeBehavior());
3287         case CSSPropertyWebkitUserModify:
3288             return cssValuePool.createValue(style.userModify());
3289         case CSSPropertyMaxHeight: {
3290             const Length&amp; maxHeight = style.maxHeight();
3291             if (maxHeight.isUndefined())
3292                 return cssValuePool.createIdentifierValue(CSSValueNone);
3293             return zoomAdjustedPixelValueForLength(maxHeight, style);
3294         }
3295         case CSSPropertyMaxWidth: {
3296             const Length&amp; maxWidth = style.maxWidth();
3297             if (maxWidth.isUndefined())
3298                 return cssValuePool.createIdentifierValue(CSSValueNone);
3299             return zoomAdjustedPixelValueForLength(maxWidth, style);
3300         }
3301         case CSSPropertyMinHeight:
3302             if (style.minHeight().isAuto()) {
3303                 auto* styledElement = this-&gt;styledElement();
3304                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3305                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3306                 return zoomAdjustedPixelValue(0, style);
3307             }
3308             return zoomAdjustedPixelValueForLength(style.minHeight(), style);
3309         case CSSPropertyMinWidth:
3310             if (style.minWidth().isAuto()) {
3311                 auto* styledElement = this-&gt;styledElement();
3312                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3313                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3314                 return zoomAdjustedPixelValue(0, style);
3315             }
3316             return zoomAdjustedPixelValueForLength(style.minWidth(), style);
3317         case CSSPropertyObjectFit:
3318             return cssValuePool.createValue(style.objectFit());
3319         case CSSPropertyObjectPosition: {
3320             auto list = CSSValueList::createSpaceSeparated();
3321             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
3322             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
<a name="112" id="anc112"></a><span class="line-modified">3323             return list;</span>
3324         }
3325         case CSSPropertyOpacity:
3326             return cssValuePool.createValue(style.opacity(), CSSPrimitiveValue::CSS_NUMBER);
3327         case CSSPropertyOrphans:
3328             if (style.hasAutoOrphans())
3329                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3330             return cssValuePool.createValue(style.orphans(), CSSPrimitiveValue::CSS_NUMBER);
3331         case CSSPropertyOutlineColor:
3332             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
3333         case CSSPropertyOutlineOffset:
3334             return zoomAdjustedPixelValue(style.outlineOffset(), style);
3335         case CSSPropertyOutlineStyle:
3336             if (style.outlineStyleIsAuto() == OutlineIsAuto::On)
3337                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3338             return cssValuePool.createValue(style.outlineStyle());
3339         case CSSPropertyOutlineWidth:
3340             return zoomAdjustedPixelValue(style.outlineWidth(), style);
3341         case CSSPropertyOverflow:
3342             return cssValuePool.createValue(std::max(style.overflowX(), style.overflowY()));
3343         case CSSPropertyOverflowWrap:
3344             return cssValuePool.createValue(style.overflowWrap());
3345         case CSSPropertyOverflowX:
3346             return cssValuePool.createValue(style.overflowX());
3347         case CSSPropertyOverflowY:
3348             return cssValuePool.createValue(style.overflowY());
3349         case CSSPropertyPaddingTop:
3350             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingTop, &amp;RenderBoxModelObject::computedCSSPaddingTop&gt;(style, renderer);
3351         case CSSPropertyPaddingRight:
3352             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingRight, &amp;RenderBoxModelObject::computedCSSPaddingRight&gt;(style, renderer);
3353         case CSSPropertyPaddingBottom:
3354             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingBottom, &amp;RenderBoxModelObject::computedCSSPaddingBottom&gt;(style, renderer);
3355         case CSSPropertyPaddingLeft:
3356             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingLeft, &amp;RenderBoxModelObject::computedCSSPaddingLeft&gt;(style, renderer);
3357         case CSSPropertyPageBreakAfter:
3358             return cssValuePool.createValue(convertToPageBreak(style.breakAfter()));
3359         case CSSPropertyPageBreakBefore:
3360             return cssValuePool.createValue(convertToPageBreak(style.breakBefore()));
3361         case CSSPropertyPageBreakInside:
3362             return cssValuePool.createValue(convertToPageBreak(style.breakInside()));
3363         case CSSPropertyBreakAfter:
3364             return cssValuePool.createValue(style.breakAfter());
3365         case CSSPropertyBreakBefore:
3366             return cssValuePool.createValue(style.breakBefore());
3367         case CSSPropertyBreakInside:
3368             return cssValuePool.createValue(style.breakInside());
3369         case CSSPropertyHangingPunctuation:
3370             return hangingPunctuationToCSSValue(style.hangingPunctuation());
3371         case CSSPropertyPosition:
3372             return cssValuePool.createValue(style.position());
3373         case CSSPropertyRight:
3374             return positionOffsetValue(style, CSSPropertyRight, renderer);
3375         case CSSPropertyWebkitRubyPosition:
3376             return cssValuePool.createValue(style.rubyPosition());
3377         case CSSPropertyTableLayout:
3378             return cssValuePool.createValue(style.tableLayout());
3379         case CSSPropertyTextAlign:
3380             return cssValuePool.createValue(style.textAlign());
3381         case CSSPropertyTextDecoration:
3382             return renderTextDecorationFlagsToCSSValue(style.textDecoration());
3383 #if ENABLE(CSS3_TEXT)
3384         case CSSPropertyWebkitTextAlignLast:
3385             return cssValuePool.createValue(style.textAlignLast());
3386         case CSSPropertyWebkitTextJustify:
3387             return cssValuePool.createValue(style.textJustify());
3388 #endif // CSS3_TEXT
3389         case CSSPropertyWebkitTextDecoration:
3390             return getCSSPropertyValuesForShorthandProperties(webkitTextDecorationShorthand());
3391         case CSSPropertyTextDecorationLine:
3392             return renderTextDecorationFlagsToCSSValue(style.textDecoration());
3393         case CSSPropertyTextDecorationStyle:
3394             return renderTextDecorationStyleFlagsToCSSValue(style.textDecorationStyle());
3395         case CSSPropertyTextDecorationColor:
3396             return currentColorOrValidColor(&amp;style, style.textDecorationColor());
3397         case CSSPropertyTextDecorationSkip:
3398             return renderTextDecorationSkipFlagsToCSSValue(style.textDecorationSkip());
3399         case CSSPropertyTextUnderlinePosition:
3400             return cssValuePool.createValue(style.textUnderlinePosition());
3401         case CSSPropertyTextUnderlineOffset:
3402             return textUnderlineOffsetToCSSValue(style.textUnderlineOffset());
3403         case CSSPropertyTextDecorationThickness:
3404             return textDecorationThicknessToCSSValue(style.textDecorationThickness());
3405         case CSSPropertyWebkitTextDecorationsInEffect:
3406             return renderTextDecorationFlagsToCSSValue(style.textDecorationsInEffect());
3407         case CSSPropertyWebkitTextFillColor:
3408             return currentColorOrValidColor(&amp;style, style.textFillColor());
3409         case CSSPropertyWebkitTextEmphasisColor:
3410             return currentColorOrValidColor(&amp;style, style.textEmphasisColor());
3411         case CSSPropertyWebkitTextEmphasisPosition:
3412             return renderEmphasisPositionFlagsToCSSValue(style.textEmphasisPosition());
3413         case CSSPropertyWebkitTextEmphasisStyle:
3414             switch (style.textEmphasisMark()) {
3415             case TextEmphasisMark::None:
3416                 return cssValuePool.createIdentifierValue(CSSValueNone);
3417             case TextEmphasisMark::Custom:
3418                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSPrimitiveValue::CSS_STRING);
3419             case TextEmphasisMark::Auto:
3420                 ASSERT_NOT_REACHED();
3421 #if ASSERT_DISABLED
3422                 FALLTHROUGH;
3423 #endif
3424             case TextEmphasisMark::Dot:
3425             case TextEmphasisMark::Circle:
3426             case TextEmphasisMark::DoubleCircle:
3427             case TextEmphasisMark::Triangle:
3428             case TextEmphasisMark::Sesame:
3429                 auto list = CSSValueList::createSpaceSeparated();
3430                 list-&gt;append(cssValuePool.createValue(style.textEmphasisFill()));
3431                 list-&gt;append(cssValuePool.createValue(style.textEmphasisMark()));
<a name="113" id="anc113"></a><span class="line-modified">3432                 return list;</span>
3433             }
3434             RELEASE_ASSERT_NOT_REACHED();
3435         case CSSPropertyTextIndent: {
3436             // If CSS3_TEXT is disabled or text-indent has only one value(&lt;length&gt; | &lt;percentage&gt;),
3437             // getPropertyCSSValue() returns CSSValue.
3438             auto textIndent = zoomAdjustedPixelValueForLength(style.textIndent(), style);
3439 #if ENABLE(CSS3_TEXT)
3440             // If CSS3_TEXT is enabled and text-indent has -webkit-each-line or -webkit-hanging,
3441             // getPropertyCSSValue() returns CSSValueList.
3442             if (style.textIndentLine() == TextIndentLine::EachLine || style.textIndentType() == TextIndentType::Hanging) {
3443                 auto list = CSSValueList::createSpaceSeparated();
3444                 list-&gt;append(WTFMove(textIndent));
3445                 if (style.textIndentLine() == TextIndentLine::EachLine)
3446                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitEachLine));
3447                 if (style.textIndentType() == TextIndentType::Hanging)
3448                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitHanging));
<a name="114" id="anc114"></a><span class="line-modified">3449                 return list;</span>
3450             }
3451 #endif
<a name="115" id="anc115"></a><span class="line-modified">3452             return textIndent;</span>
3453         }
3454         case CSSPropertyTextShadow:
3455             return valueForShadow(style.textShadow(), propertyID, style);
3456         case CSSPropertyTextRendering:
3457             return cssValuePool.createValue(style.fontDescription().textRenderingMode());
3458         case CSSPropertyTextOverflow:
3459             if (style.textOverflow() == TextOverflow::Ellipsis)
3460                 return cssValuePool.createIdentifierValue(CSSValueEllipsis);
3461             return cssValuePool.createIdentifierValue(CSSValueClip);
3462         case CSSPropertyWebkitTextSecurity:
3463             return cssValuePool.createValue(style.textSecurity());
3464 #if ENABLE(TEXT_AUTOSIZING)
3465         case CSSPropertyWebkitTextSizeAdjust:
3466             if (style.textSizeAdjust().isAuto())
3467                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3468             if (style.textSizeAdjust().isNone())
3469                 return cssValuePool.createIdentifierValue(CSSValueNone);
3470             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSPrimitiveValue::CSS_PERCENTAGE);
3471 #endif
3472         case CSSPropertyWebkitTextStrokeColor:
3473             return currentColorOrValidColor(&amp;style, style.textStrokeColor());
3474         case CSSPropertyWebkitTextStrokeWidth:
3475             return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
3476         case CSSPropertyTextTransform:
3477             return cssValuePool.createValue(style.textTransform());
3478         case CSSPropertyTop:
3479             return positionOffsetValue(style, CSSPropertyTop, renderer);
3480         case CSSPropertyUnicodeBidi:
3481             return cssValuePool.createValue(style.unicodeBidi());
3482         case CSSPropertyVerticalAlign:
3483             switch (style.verticalAlign()) {
3484             case VerticalAlign::Baseline:
3485                 return cssValuePool.createIdentifierValue(CSSValueBaseline);
3486             case VerticalAlign::Middle:
3487                 return cssValuePool.createIdentifierValue(CSSValueMiddle);
3488             case VerticalAlign::Sub:
3489                 return cssValuePool.createIdentifierValue(CSSValueSub);
3490             case VerticalAlign::Super:
3491                 return cssValuePool.createIdentifierValue(CSSValueSuper);
3492             case VerticalAlign::TextTop:
3493                 return cssValuePool.createIdentifierValue(CSSValueTextTop);
3494             case VerticalAlign::TextBottom:
3495                 return cssValuePool.createIdentifierValue(CSSValueTextBottom);
3496             case VerticalAlign::Top:
3497                 return cssValuePool.createIdentifierValue(CSSValueTop);
3498             case VerticalAlign::Bottom:
3499                 return cssValuePool.createIdentifierValue(CSSValueBottom);
3500             case VerticalAlign::BaselineMiddle:
3501                 return cssValuePool.createIdentifierValue(CSSValueWebkitBaselineMiddle);
3502             case VerticalAlign::Length:
3503                 return cssValuePool.createValue(style.verticalAlignLength());
3504             }
3505             ASSERT_NOT_REACHED();
3506             return nullptr;
3507         case CSSPropertyVisibility:
3508             return cssValuePool.createValue(style.visibility());
3509         case CSSPropertyWhiteSpace:
3510             return cssValuePool.createValue(style.whiteSpace());
3511         case CSSPropertyWidows:
3512             if (style.hasAutoWidows())
3513                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3514             return cssValuePool.createValue(style.widows(), CSSPrimitiveValue::CSS_NUMBER);
3515         case CSSPropertyWidth:
3516             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3517                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
3518                 // the &quot;width&quot; property does not apply for non-replaced inline elements.
<a name="116" id="anc116"></a><span class="line-modified">3519                 if (!isNonReplacedInline(*renderer))</span>
<span class="line-modified">3520                     return zoomAdjustedPixelValue(sizingBox(*renderer).width(), style);</span>

3521             }
3522             return zoomAdjustedPixelValueForLength(style.width(), style);
3523         case CSSPropertyWillChange:
3524             return willChangePropertyValue(style.willChange());
3525         case CSSPropertyWordBreak:
3526             return cssValuePool.createValue(style.wordBreak());
3527         case CSSPropertyWordSpacing:
3528             return zoomAdjustedPixelValue(style.fontCascade().wordSpacing(), style);
3529         case CSSPropertyWordWrap:
3530             return cssValuePool.createValue(style.overflowWrap());
3531         case CSSPropertyLineBreak:
3532             return cssValuePool.createValue(style.lineBreak());
3533         case CSSPropertyWebkitNbspMode:
3534             return cssValuePool.createValue(style.nbspMode());
3535         case CSSPropertyResize:
3536             return cssValuePool.createValue(style.resize());
3537         case CSSPropertyWebkitFontKerning:
3538             return cssValuePool.createValue(style.fontDescription().kerning());
3539         case CSSPropertyWebkitFontSmoothing:
3540             return cssValuePool.createValue(style.fontDescription().fontSmoothing());
3541         case CSSPropertyFontVariantLigatures:
3542             return fontVariantLigaturesPropertyValue(style.fontDescription().variantCommonLigatures(), style.fontDescription().variantDiscretionaryLigatures(), style.fontDescription().variantHistoricalLigatures(), style.fontDescription().variantContextualAlternates());
3543         case CSSPropertyFontVariantPosition:
3544             return fontVariantPositionPropertyValue(style.fontDescription().variantPosition());
3545         case CSSPropertyFontVariantCaps:
3546             return fontVariantCapsPropertyValue(style.fontDescription().variantCaps());
3547         case CSSPropertyFontVariantNumeric:
3548             return fontVariantNumericPropertyValue(style.fontDescription().variantNumericFigure(), style.fontDescription().variantNumericSpacing(), style.fontDescription().variantNumericFraction(), style.fontDescription().variantNumericOrdinal(), style.fontDescription().variantNumericSlashedZero());
3549         case CSSPropertyFontVariantAlternates:
3550             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
3551         case CSSPropertyFontVariantEastAsian:
3552             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
3553         case CSSPropertyZIndex:
3554             if (style.hasAutoZIndex())
3555                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3556             return cssValuePool.createValue(style.zIndex(), CSSPrimitiveValue::CSS_NUMBER);
3557         case CSSPropertyZoom:
3558             return cssValuePool.createValue(style.zoom(), CSSPrimitiveValue::CSS_NUMBER);
3559         case CSSPropertyBoxSizing:
3560             if (style.boxSizing() == BoxSizing::ContentBox)
3561                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
3562             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
<a name="117" id="anc117"></a>































3563         case CSSPropertyAnimationDelay:
3564             return delayValue(style.animations());
3565         case CSSPropertyAnimationDirection: {
3566             auto list = CSSValueList::createCommaSeparated();
3567             const AnimationList* t = style.animations();
3568             if (t) {
3569                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3570                     switch (t-&gt;animation(i).direction()) {
3571                     case Animation::AnimationDirectionNormal:
3572                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3573                         break;
3574                     case Animation::AnimationDirectionAlternate:
3575                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternate));
3576                         break;
3577                     case Animation::AnimationDirectionReverse:
3578                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueReverse));
3579                         break;
3580                     case Animation::AnimationDirectionAlternateReverse:
3581                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternateReverse));
3582                         break;
3583                     }
3584                 }
3585             } else
3586                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
<a name="118" id="anc118"></a><span class="line-modified">3587             return list;</span>
3588         }
3589         case CSSPropertyAnimationDuration:
3590             return durationValue(style.animations());
3591         case CSSPropertyAnimationFillMode: {
3592             auto list = CSSValueList::createCommaSeparated();
3593             const AnimationList* t = style.animations();
3594             if (t) {
3595                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3596                     switch (t-&gt;animation(i).fillMode()) {
3597                     case AnimationFillMode::None:
3598                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3599                         break;
3600                     case AnimationFillMode::Forwards:
3601                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForwards));
3602                         break;
3603                     case AnimationFillMode::Backwards:
3604                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBackwards));
3605                         break;
3606                     case AnimationFillMode::Both:
3607                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBoth));
3608                         break;
3609                     }
3610                 }
3611             } else
3612                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
<a name="119" id="anc119"></a><span class="line-modified">3613             return list;</span>
3614         }
3615         case CSSPropertyAnimationIterationCount: {
3616             auto list = CSSValueList::createCommaSeparated();
3617             const AnimationList* t = style.animations();
3618             if (t) {
3619                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3620                     double iterationCount = t-&gt;animation(i).iterationCount();
3621                     if (iterationCount == Animation::IterationCountInfinite)
3622                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
3623                     else
3624                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSPrimitiveValue::CSS_NUMBER));
3625                 }
3626             } else
3627                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSPrimitiveValue::CSS_NUMBER));
<a name="120" id="anc120"></a><span class="line-modified">3628             return list;</span>
3629         }
3630         case CSSPropertyAnimationName: {
3631             auto list = CSSValueList::createCommaSeparated();
3632             const AnimationList* t = style.animations();
3633             if (t) {
3634                 for (size_t i = 0; i &lt; t-&gt;size(); ++i)
3635                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSPrimitiveValue::CSS_STRING));
3636             } else
3637                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
<a name="121" id="anc121"></a><span class="line-modified">3638             return list;</span>
3639         }
3640         case CSSPropertyAnimationPlayState: {
3641             auto list = CSSValueList::createCommaSeparated();
3642             const AnimationList* t = style.animations();
3643             if (t) {
3644                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3645                     switch (t-&gt;animation(i).playState()) {
3646                     case AnimationPlayState::Playing:
3647                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3648                         break;
3649                     case AnimationPlayState::Paused:
3650                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePaused));
3651                         break;
3652                     }
3653                 }
3654             } else
3655                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
<a name="122" id="anc122"></a><span class="line-modified">3656             return list;</span>
3657         }
3658         case CSSPropertyAnimationTimingFunction:
3659             return timingFunctionValue(style.animations());
3660         case CSSPropertyWebkitAppearance:
3661             return cssValuePool.createValue(style.appearance());
3662         case CSSPropertyWebkitAspectRatio:
3663             switch (style.aspectRatioType()) {
3664             case AspectRatioType::Auto:
3665                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3666             case AspectRatioType::FromDimensions:
3667                 return cssValuePool.createIdentifierValue(CSSValueFromDimensions);
3668             case AspectRatioType::FromIntrinsic:
3669                 return cssValuePool.createIdentifierValue(CSSValueFromIntrinsic);
3670             case AspectRatioType::Specified:
3671                 return CSSAspectRatioValue::create(style.aspectRatioNumerator(), style.aspectRatioDenominator());
3672             }
3673             ASSERT_NOT_REACHED();
3674             return nullptr;
3675         case CSSPropertyWebkitBackfaceVisibility:
3676             return cssValuePool.createIdentifierValue((style.backfaceVisibility() == BackfaceVisibility::Hidden) ? CSSValueHidden : CSSValueVisible);
3677         case CSSPropertyWebkitBorderImage:
3678             return valueForNinePieceImage(style.borderImage());
3679         case CSSPropertyBorderImageOutset:
3680             return valueForNinePieceImageQuad(style.borderImage().outset());
3681         case CSSPropertyBorderImageRepeat:
3682             return valueForNinePieceImageRepeat(style.borderImage());
3683         case CSSPropertyBorderImageSlice:
3684             return valueForNinePieceImageSlice(style.borderImage());
3685         case CSSPropertyBorderImageWidth:
3686             return valueForNinePieceImageQuad(style.borderImage().borderSlices());
3687         case CSSPropertyWebkitMaskBoxImage:
3688             return valueForNinePieceImage(style.maskBoxImage());
3689         case CSSPropertyWebkitMaskBoxImageOutset:
3690             return valueForNinePieceImageQuad(style.maskBoxImage().outset());
3691         case CSSPropertyWebkitMaskBoxImageRepeat:
3692             return valueForNinePieceImageRepeat(style.maskBoxImage());
3693         case CSSPropertyWebkitMaskBoxImageSlice:
3694             return valueForNinePieceImageSlice(style.maskBoxImage());
3695         case CSSPropertyWebkitMaskBoxImageWidth:
3696             return valueForNinePieceImageQuad(style.maskBoxImage().borderSlices());
3697         case CSSPropertyWebkitMaskBoxImageSource:
3698             if (style.maskBoxImageSource())
3699                 return style.maskBoxImageSource()-&gt;cssValue();
3700             return cssValuePool.createIdentifierValue(CSSValueNone);
3701         case CSSPropertyWebkitFontSizeDelta:
3702             // Not a real style property -- used by the editing engine -- so has no computed value.
3703             break;
3704         case CSSPropertyWebkitInitialLetter: {
3705             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSPrimitiveValue::CSS_NUMBER);
3706             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSPrimitiveValue::CSS_NUMBER);
3707             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
3708         }
3709         case CSSPropertyWebkitMarginBottomCollapse:
3710         case CSSPropertyWebkitMarginAfterCollapse:
3711             return cssValuePool.createValue(style.marginAfterCollapse());
3712         case CSSPropertyWebkitMarginTopCollapse:
3713         case CSSPropertyWebkitMarginBeforeCollapse:
3714             return cssValuePool.createValue(style.marginBeforeCollapse());
<a name="123" id="anc123"></a><span class="line-modified">3715 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
3716         case CSSPropertyWebkitOverflowScrolling:
3717             if (!style.useTouchOverflowScrolling())
3718                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3719             return cssValuePool.createIdentifierValue(CSSValueTouch);
3720 #endif
3721         case CSSPropertyPerspective:
3722             if (!style.hasPerspective())
3723                 return cssValuePool.createIdentifierValue(CSSValueNone);
3724             return zoomAdjustedPixelValue(style.perspective(), style);
3725         case CSSPropertyPerspectiveOrigin: {
3726             auto list = CSSValueList::createSpaceSeparated();
3727             if (renderer) {
3728                 LayoutRect box;
3729                 if (is&lt;RenderBox&gt;(*renderer))
3730                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3731 
3732                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginX(), box.width()), style));
3733                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginY(), box.height()), style));
3734             } else {
3735                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginX(), style));
3736                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginY(), style));
3737             }
<a name="124" id="anc124"></a><span class="line-modified">3738             return list;</span>
3739         }
3740         case CSSPropertyWebkitRtlOrdering:
3741             return cssValuePool.createIdentifierValue(style.rtlOrdering() == Order::Visual ? CSSValueVisual : CSSValueLogical);
3742 #if ENABLE(TOUCH_EVENTS)
3743         case CSSPropertyWebkitTapHighlightColor:
3744             return currentColorOrValidColor(&amp;style, style.tapHighlightColor());
3745 #endif
3746 #if ENABLE(POINTER_EVENTS)
3747         case CSSPropertyTouchAction:
3748             return touchActionFlagsToCSSValue(style.touchActions());
3749 #endif
3750 #if PLATFORM(IOS_FAMILY)
3751         case CSSPropertyWebkitTouchCallout:
3752             return cssValuePool.createIdentifierValue(style.touchCalloutEnabled() ? CSSValueDefault : CSSValueNone);
3753 #endif
3754         case CSSPropertyWebkitUserDrag:
3755             return cssValuePool.createValue(style.userDrag());
3756         case CSSPropertyWebkitUserSelect:
3757             return cssValuePool.createValue(style.userSelect());
3758         case CSSPropertyBorderBottomLeftRadius:
3759             return borderRadiusCornerValue(style.borderBottomLeftRadius(), style);
3760         case CSSPropertyBorderBottomRightRadius:
3761             return borderRadiusCornerValue(style.borderBottomRightRadius(), style);
3762         case CSSPropertyBorderTopLeftRadius:
3763             return borderRadiusCornerValue(style.borderTopLeftRadius(), style);
3764         case CSSPropertyBorderTopRightRadius:
3765             return borderRadiusCornerValue(style.borderTopRightRadius(), style);
3766         case CSSPropertyClip: {
3767             if (!style.hasClip())
3768                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3769             auto rect = Rect::create();
3770             rect-&gt;setTop(autoOrZoomAdjustedValue(style.clip().top(), style));
3771             rect-&gt;setRight(autoOrZoomAdjustedValue(style.clip().right(), style));
3772             rect-&gt;setBottom(autoOrZoomAdjustedValue(style.clip().bottom(), style));
3773             rect-&gt;setLeft(autoOrZoomAdjustedValue(style.clip().left(), style));
3774             return cssValuePool.createValue(WTFMove(rect));
3775         }
3776         case CSSPropertySpeakAs:
3777             return speakAsToCSSValue(style.speakAs());
3778         case CSSPropertyTransform:
3779             return computedTransform(renderer, style);
3780         case CSSPropertyTransformBox:
3781             return CSSPrimitiveValue::create(style.transformBox());
3782         case CSSPropertyTransformOrigin: {
3783             auto list = CSSValueList::createSpaceSeparated();
3784             if (renderer) {
3785                 LayoutRect box;
3786                 if (is&lt;RenderBox&gt;(*renderer))
3787                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3788 
3789                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginX(), box.width()), style));
3790                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginY(), box.height()), style));
3791                 if (style.transformOriginZ())
3792                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3793             } else {
3794                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginX(), style));
3795                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginY(), style));
3796                 if (style.transformOriginZ())
3797                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3798             }
<a name="125" id="anc125"></a><span class="line-modified">3799             return list;</span>
3800         }
3801         case CSSPropertyTransformStyle:
3802         case CSSPropertyWebkitTransformStyle:
3803             return cssValuePool.createIdentifierValue((style.transformStyle3D() == TransformStyle3D::Preserve3D) ? CSSValuePreserve3d : CSSValueFlat);
3804         case CSSPropertyTransitionDelay:
3805             return delayValue(style.transitions());
3806         case CSSPropertyTransitionDuration:
3807             return durationValue(style.transitions());
3808         case CSSPropertyTransitionProperty:
3809             return transitionPropertyValue(style.transitions());
3810         case CSSPropertyTransitionTimingFunction:
3811             return timingFunctionValue(style.transitions());
3812         case CSSPropertyTransition: {
3813             if (auto* animationList = style.transitions()) {
3814                 auto transitionsList = CSSValueList::createCommaSeparated();
3815                 for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
3816                     auto list = CSSValueList::createSpaceSeparated();
3817                     auto&amp; animation = animationList-&gt;animation(i);
3818                     list-&gt;append(createTransitionPropertyValue(animation));
3819                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSPrimitiveValue::CSS_S));
3820                     list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
3821                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSPrimitiveValue::CSS_S));
3822                     transitionsList-&gt;append(WTFMove(list));
3823                 }
<a name="126" id="anc126"></a><span class="line-modified">3824                 return transitionsList;</span>
3825             }
3826 
3827             auto list = CSSValueList::createSpaceSeparated();
3828             // transition-property default value.
3829             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
3830             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
3831             list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
3832             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
<a name="127" id="anc127"></a><span class="line-modified">3833             return list;</span>
3834         }
3835         case CSSPropertyPointerEvents:
3836             return cssValuePool.createValue(style.pointerEvents());
3837         case CSSPropertyWebkitLineGrid:
3838             if (style.lineGrid().isNull())
3839                 return cssValuePool.createIdentifierValue(CSSValueNone);
3840             return cssValuePool.createValue(style.lineGrid(), CSSPrimitiveValue::CSS_STRING);
3841         case CSSPropertyWebkitLineSnap:
3842             return CSSPrimitiveValue::create(style.lineSnap());
3843         case CSSPropertyWebkitLineAlign:
3844             return CSSPrimitiveValue::create(style.lineAlign());
3845         case CSSPropertyWritingMode:
3846             return cssValuePool.createValue(style.writingMode());
3847         case CSSPropertyWebkitTextCombine:
3848             return cssValuePool.createValue(style.textCombine());
3849         case CSSPropertyWebkitTextOrientation:
3850             return CSSPrimitiveValue::create(style.textOrientation());
3851         case CSSPropertyWebkitLineBoxContain:
3852             return createLineBoxContainValue(style.lineBoxContain());
3853         case CSSPropertyAlt:
3854             return altTextToCSSValue(style);
3855         case CSSPropertyContent:
3856             return contentToCSSValue(style);
3857         case CSSPropertyCounterIncrement:
3858             return counterToCSSValue(style, propertyID);
3859         case CSSPropertyCounterReset:
3860             return counterToCSSValue(style, propertyID);
3861         case CSSPropertyWebkitClipPath: {
3862             auto* operation = style.clipPath();
3863             if (!operation)
3864                 return cssValuePool.createIdentifierValue(CSSValueNone);
3865             if (is&lt;ReferenceClipPathOperation&gt;(*operation))
3866                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSPrimitiveValue::CSS_URI);
3867             auto list = CSSValueList::createSpaceSeparated();
3868             if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
3869                 auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
3870                 list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
3871                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
3872                     list-&gt;append(cssValuePool.createValue(shapeOperation.referenceBox()));
3873             }
3874             if (is&lt;BoxClipPathOperation&gt;(*operation))
3875                 list-&gt;append(cssValuePool.createValue(downcast&lt;BoxClipPathOperation&gt;(*operation).referenceBox()));
<a name="128" id="anc128"></a><span class="line-modified">3876             return list;</span>
3877         }
3878         case CSSPropertyShapeMargin:
3879             return cssValuePool.createValue(style.shapeMargin(), style);
3880         case CSSPropertyShapeImageThreshold:
3881             return cssValuePool.createValue(style.shapeImageThreshold(), CSSPrimitiveValue::CSS_NUMBER);
3882         case CSSPropertyShapeOutside:
3883             return shapePropertyValue(style, style.shapeOutside());
3884         case CSSPropertyFilter:
3885             return valueForFilter(style, style.filter());
3886         case CSSPropertyAppleColorFilter:
3887             return valueForFilter(style, style.appleColorFilter());
3888 #if ENABLE(FILTERS_LEVEL_2)
3889         case CSSPropertyWebkitBackdropFilter:
3890             return valueForFilter(style, style.backdropFilter());
3891 #endif
3892 #if ENABLE(CSS_COMPOSITING)
3893         case CSSPropertyMixBlendMode:
3894             return cssValuePool.createValue(style.blendMode());
3895         case CSSPropertyIsolation:
3896             return cssValuePool.createValue(style.isolation());
3897 #endif
3898         case CSSPropertyBackgroundBlendMode: {
3899             auto&amp; layers = style.backgroundLayers();
3900             if (!layers.next())
3901                 return cssValuePool.createValue(layers.blendMode());
3902             auto list = CSSValueList::createCommaSeparated();
3903             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
3904                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;blendMode()));
<a name="129" id="anc129"></a><span class="line-modified">3905             return list;</span>
3906         }
3907         case CSSPropertyBackground:
3908             return getBackgroundShorthandValue();
3909         case CSSPropertyBorder: {
3910             auto value = propertyValue(CSSPropertyBorderTop, DoNotUpdateLayout);
3911             const CSSPropertyID properties[3] = { CSSPropertyBorderRight, CSSPropertyBorderBottom, CSSPropertyBorderLeft };
3912             for (auto&amp; property : properties) {
3913                 if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(property, DoNotUpdateLayout)))
3914                     return nullptr;
3915             }
3916             return value;
3917         }
3918         case CSSPropertyBorderBlock: {
3919             auto value = propertyValue(CSSPropertyBorderBlockStart, DoNotUpdateLayout);
3920             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderBlockEnd, DoNotUpdateLayout)))
3921                 return nullptr;
3922             return value;
3923         }
3924         case CSSPropertyBorderBlockColor:
3925             return getCSSPropertyValuesFor2SidesShorthand(borderBlockColorShorthand());
3926         case CSSPropertyBorderBlockStyle:
3927             return getCSSPropertyValuesFor2SidesShorthand(borderBlockStyleShorthand());
3928         case CSSPropertyBorderBlockWidth:
3929             return getCSSPropertyValuesFor2SidesShorthand(borderBlockWidthShorthand());
3930         case CSSPropertyBorderBottom:
3931             return getCSSPropertyValuesForShorthandProperties(borderBottomShorthand());
3932         case CSSPropertyBorderColor:
3933             return getCSSPropertyValuesFor4SidesShorthand(borderColorShorthand());
3934         case CSSPropertyBorderLeft:
3935             return getCSSPropertyValuesForShorthandProperties(borderLeftShorthand());
3936         case CSSPropertyBorderImage:
3937             return valueForNinePieceImage(style.borderImage());
3938         case CSSPropertyBorderInline: {
3939             auto value = propertyValue(CSSPropertyBorderInlineStart, DoNotUpdateLayout);
3940             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderInlineEnd, DoNotUpdateLayout)))
3941                 return nullptr;
3942             return value;
3943         }
3944         case CSSPropertyBorderInlineColor:
3945             return getCSSPropertyValuesFor2SidesShorthand(borderInlineColorShorthand());
3946         case CSSPropertyBorderInlineStyle:
3947             return getCSSPropertyValuesFor2SidesShorthand(borderInlineStyleShorthand());
3948         case CSSPropertyBorderInlineWidth:
3949             return getCSSPropertyValuesFor2SidesShorthand(borderInlineWidthShorthand());
3950         case CSSPropertyBorderRadius:
3951             return borderRadiusShorthandValue(style);
3952         case CSSPropertyBorderRight:
3953             return getCSSPropertyValuesForShorthandProperties(borderRightShorthand());
3954         case CSSPropertyBorderStyle:
3955             return getCSSPropertyValuesFor4SidesShorthand(borderStyleShorthand());
3956         case CSSPropertyBorderTop:
3957             return getCSSPropertyValuesForShorthandProperties(borderTopShorthand());
3958         case CSSPropertyBorderWidth:
3959             return getCSSPropertyValuesFor4SidesShorthand(borderWidthShorthand());
3960         case CSSPropertyColumnRule:
3961             return getCSSPropertyValuesForShorthandProperties(columnRuleShorthand());
3962         case CSSPropertyColumns:
3963             return getCSSPropertyValuesForShorthandProperties(columnsShorthand());
3964         case CSSPropertyInset:
3965             return getCSSPropertyValuesFor4SidesShorthand(insetShorthand());
3966         case CSSPropertyInsetBlock:
3967             return getCSSPropertyValuesFor2SidesShorthand(insetBlockShorthand());
3968         case CSSPropertyInsetInline:
3969             return getCSSPropertyValuesFor2SidesShorthand(insetInlineShorthand());
3970         case CSSPropertyListStyle:
3971             return getCSSPropertyValuesForShorthandProperties(listStyleShorthand());
3972         case CSSPropertyMargin:
3973             return getCSSPropertyValuesFor4SidesShorthand(marginShorthand());
3974         case CSSPropertyMarginBlock:
3975             return getCSSPropertyValuesFor2SidesShorthand(marginBlockShorthand());
3976         case CSSPropertyMarginInline:
3977             return getCSSPropertyValuesFor2SidesShorthand(marginInlineShorthand());
3978         case CSSPropertyOutline:
3979             return getCSSPropertyValuesForShorthandProperties(outlineShorthand());
3980         case CSSPropertyPadding:
3981             return getCSSPropertyValuesFor4SidesShorthand(paddingShorthand());
3982         case CSSPropertyPaddingBlock:
3983             return getCSSPropertyValuesFor2SidesShorthand(paddingBlockShorthand());
3984         case CSSPropertyPaddingInline:
3985             return getCSSPropertyValuesFor2SidesShorthand(paddingInlineShorthand());
3986 #if ENABLE(CSS_SCROLL_SNAP)
3987         case CSSPropertyScrollSnapMargin:
3988             return getCSSPropertyValuesFor4SidesShorthand(scrollSnapMarginShorthand());
3989         case CSSPropertyScrollSnapMarginBottom:
3990             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginBottom(), style);
3991         case CSSPropertyScrollSnapMarginTop:
3992             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginTop(), style);
3993         case CSSPropertyScrollSnapMarginRight:
3994             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginRight(), style);
3995         case CSSPropertyScrollSnapMarginLeft:
3996             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginLeft(), style);
3997         case CSSPropertyScrollPadding:
3998             return getCSSPropertyValuesFor4SidesShorthand(scrollPaddingShorthand());
3999         case CSSPropertyScrollPaddingBottom:
4000             return zoomAdjustedPixelValueForLength(style.scrollPaddingBottom(), style);
4001         case CSSPropertyScrollPaddingTop:
4002             return zoomAdjustedPixelValueForLength(style.scrollPaddingTop(), style);
4003         case CSSPropertyScrollPaddingRight:
4004             return zoomAdjustedPixelValueForLength(style.scrollPaddingRight(), style);
4005         case CSSPropertyScrollPaddingLeft:
4006             return zoomAdjustedPixelValueForLength(style.scrollPaddingLeft(), style);
4007         case CSSPropertyScrollSnapType:
4008             return valueForScrollSnapType(style.scrollSnapType());
4009         case CSSPropertyScrollSnapAlign:
4010             return valueForScrollSnapAlignment(style.scrollSnapAlign());
4011 #endif
4012 
4013 #if ENABLE(CSS_TRAILING_WORD)
4014         case CSSPropertyAppleTrailingWord:
4015             return cssValuePool.createValue(style.trailingWord());
4016 #endif
4017 
4018 #if ENABLE(APPLE_PAY)
4019         case CSSPropertyApplePayButtonStyle:
4020             return cssValuePool.createValue(style.applePayButtonStyle());
4021         case CSSPropertyApplePayButtonType:
4022             return cssValuePool.createValue(style.applePayButtonType());
4023 #endif
4024 
4025 #if ENABLE(DARK_MODE_CSS)
<a name="130" id="anc130"></a><span class="line-modified">4026         case CSSPropertyColorScheme: {</span>
<span class="line-modified">4027             auto colorScheme = style.colorScheme();</span>
<span class="line-modified">4028             if (colorScheme.isAuto())</span>



4029                 return cssValuePool.createIdentifierValue(CSSValueAuto);
4030 
4031             auto list = CSSValueList::createSpaceSeparated();
<a name="131" id="anc131"></a><span class="line-modified">4032             if (colorScheme.contains(ColorScheme::Light))</span>
4033                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLight));
<a name="132" id="anc132"></a><span class="line-modified">4034             if (colorScheme.contains(ColorScheme::Dark))</span>
4035                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDark));
<a name="133" id="anc133"></a><span class="line-modified">4036             if (!colorScheme.allowsTransformations())</span>
4037                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOnly));
4038             ASSERT(list-&gt;length());
<a name="134" id="anc134"></a><span class="line-modified">4039             return list;</span>
4040         }
4041 #endif
4042 
4043         /* Individual properties not part of the spec */
4044         case CSSPropertyBackgroundRepeatX:
4045         case CSSPropertyBackgroundRepeatY:
4046             break;
4047 
4048         // Length properties for SVG.
4049         case CSSPropertyCx:
4050             return zoomAdjustedPixelValueForLength(style.svgStyle().cx(), style);
4051         case CSSPropertyCy:
4052             return zoomAdjustedPixelValueForLength(style.svgStyle().cy(), style);
4053         case CSSPropertyR:
4054             return zoomAdjustedPixelValueForLength(style.svgStyle().r(), style);
4055         case CSSPropertyRx:
4056             return zoomAdjustedPixelValueForLength(style.svgStyle().rx(), style);
4057         case CSSPropertyRy:
4058             return zoomAdjustedPixelValueForLength(style.svgStyle().ry(), style);
4059         case CSSPropertyStrokeDashoffset:
4060             return zoomAdjustedPixelValueForLength(style.svgStyle().strokeDashOffset(), style);
4061         case CSSPropertyX:
4062             return zoomAdjustedPixelValueForLength(style.svgStyle().x(), style);
4063         case CSSPropertyY:
4064             return zoomAdjustedPixelValueForLength(style.svgStyle().y(), style);
4065         case CSSPropertyWebkitTextZoom:
4066             return cssValuePool.createValue(style.textZoom());
4067 
4068         case CSSPropertyPaintOrder:
4069             return paintOrder(style.paintOrder());
4070         case CSSPropertyStrokeLinecap:
4071             return CSSPrimitiveValue::create(style.capStyle());
4072         case CSSPropertyStrokeLinejoin:
4073             return CSSPrimitiveValue::create(style.joinStyle());
4074         case CSSPropertyStrokeWidth:
4075             return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
4076         case CSSPropertyStrokeColor:
4077             return currentColorOrValidColor(&amp;style, style.strokeColor());
4078         case CSSPropertyStrokeMiterlimit:
4079             return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSPrimitiveValue::CSS_NUMBER);
4080 
4081         /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
4082         case CSSPropertyAll:
4083         case CSSPropertyAnimation:
4084         case CSSPropertyWebkitTextEmphasis:
4085             break;
4086 
4087         /* Directional properties are resolved by resolveDirectionAwareProperty() before the switch. */
4088         case CSSPropertyBorderBlockEnd:
4089         case CSSPropertyBorderBlockEndColor:
4090         case CSSPropertyBorderBlockEndStyle:
4091         case CSSPropertyBorderBlockEndWidth:
4092         case CSSPropertyBorderBlockStart:
4093         case CSSPropertyBorderBlockStartColor:
4094         case CSSPropertyBorderBlockStartStyle:
4095         case CSSPropertyBorderBlockStartWidth:
4096         case CSSPropertyBorderInlineEnd:
4097         case CSSPropertyBorderInlineEndColor:
4098         case CSSPropertyBorderInlineEndStyle:
4099         case CSSPropertyBorderInlineEndWidth:
4100         case CSSPropertyBorderInlineStart:
4101         case CSSPropertyBorderInlineStartColor:
4102         case CSSPropertyBorderInlineStartStyle:
4103         case CSSPropertyBorderInlineStartWidth:
4104         case CSSPropertyInsetBlockEnd:
4105         case CSSPropertyInsetBlockStart:
4106         case CSSPropertyInsetInlineEnd:
4107         case CSSPropertyInsetInlineStart:
4108         case CSSPropertyMarginBlockEnd:
4109         case CSSPropertyMarginBlockStart:
4110         case CSSPropertyMarginInlineEnd:
4111         case CSSPropertyMarginInlineStart:
4112         case CSSPropertyPaddingBlockEnd:
4113         case CSSPropertyPaddingBlockStart:
4114         case CSSPropertyPaddingInlineEnd:
4115         case CSSPropertyPaddingInlineStart:
4116         case CSSPropertyBlockSize:
4117         case CSSPropertyInlineSize:
4118         case CSSPropertyMaxBlockSize:
4119         case CSSPropertyMaxInlineSize:
4120         case CSSPropertyMinBlockSize:
4121         case CSSPropertyMinInlineSize:
4122             ASSERT_NOT_REACHED();
4123             break;
4124 
4125         /* Unimplemented @font-face properties */
4126         case CSSPropertySrc:
4127         case CSSPropertyUnicodeRange:
4128         case CSSPropertyFontDisplay:
4129             break;
4130 
4131         /* Other unimplemented properties */
4132         case CSSPropertyPage: // for @page
4133         case CSSPropertyQuotes: // FIXME: needs implementation
4134         case CSSPropertySize: // for @page
4135             break;
4136 
4137         /* Unimplemented -webkit- properties */
4138         case CSSPropertyWebkitBorderRadius:
4139         case CSSPropertyWebkitMarginCollapse:
4140         case CSSPropertyWebkitMarquee:
4141         case CSSPropertyWebkitMarqueeSpeed:
4142         case CSSPropertyWebkitMask:
4143         case CSSPropertyWebkitMaskRepeatX:
4144         case CSSPropertyWebkitMaskRepeatY:
4145         case CSSPropertyPerspectiveOriginX:
4146         case CSSPropertyPerspectiveOriginY:
4147         case CSSPropertyWebkitTextStroke:
4148         case CSSPropertyTransformOriginX:
4149         case CSSPropertyTransformOriginY:
4150         case CSSPropertyTransformOriginZ:
4151             break;
4152 
4153 #if ENABLE(CSS_DEVICE_ADAPTATION)
4154         case CSSPropertyMaxZoom:
4155         case CSSPropertyMinZoom:
4156         case CSSPropertyOrientation:
4157         case CSSPropertyUserZoom:
4158             break;
4159 #endif
4160 
4161         case CSSPropertyBufferedRendering:
4162         case CSSPropertyClipPath:
4163         case CSSPropertyClipRule:
4164         case CSSPropertyMask:
4165         case CSSPropertyEnableBackground:
4166         case CSSPropertyFloodColor:
4167         case CSSPropertyFloodOpacity:
4168         case CSSPropertyLightingColor:
4169         case CSSPropertyStopColor:
4170         case CSSPropertyStopOpacity:
4171         case CSSPropertyColorInterpolation:
4172         case CSSPropertyColorInterpolationFilters:
4173         case CSSPropertyColorProfile:
4174         case CSSPropertyColorRendering:
4175         case CSSPropertyFill:
4176         case CSSPropertyFillOpacity:
4177         case CSSPropertyFillRule:
4178         case CSSPropertyMarker:
4179         case CSSPropertyMarkerEnd:
4180         case CSSPropertyMarkerMid:
4181         case CSSPropertyMarkerStart:
4182         case CSSPropertyMaskType:
4183         case CSSPropertyShapeRendering:
4184         case CSSPropertyStroke:
4185         case CSSPropertyStrokeDasharray:
4186         case CSSPropertyStrokeOpacity:
4187         case CSSPropertyAlignmentBaseline:
4188         case CSSPropertyBaselineShift:
4189         case CSSPropertyDominantBaseline:
4190         case CSSPropertyGlyphOrientationHorizontal:
4191         case CSSPropertyGlyphOrientationVertical:
4192         case CSSPropertyKerning:
4193         case CSSPropertyTextAnchor:
4194         case CSSPropertyVectorEffect:
4195             return svgPropertyValue(propertyID);
4196         case CSSPropertyCustom:
4197             ASSERT_NOT_REACHED();
4198             return nullptr;
4199     }
4200 
4201     logUnimplementedPropertyID(propertyID);
4202     return nullptr;
4203 }
4204 
4205 String CSSComputedStyleDeclaration::getPropertyValue(CSSPropertyID propertyID) const
4206 {
4207     auto value = getPropertyCSSValue(propertyID);
4208     if (!value)
4209         return emptyString(); // FIXME: Should this be null instead, as it is in StyleProperties::getPropertyValue?
4210     return value-&gt;cssText();
4211 }
4212 
4213 unsigned CSSComputedStyleDeclaration::length() const
4214 {
4215     updateStyleIfNeededForProperty(m_element.get(), CSSPropertyCustom);
4216 
4217     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
4218     if (!style)
4219         return 0;
4220 
4221     return numComputedProperties + style-&gt;inheritedCustomProperties().size() + style-&gt;nonInheritedCustomProperties().size();
4222 }
4223 
4224 String CSSComputedStyleDeclaration::item(unsigned i) const
4225 {
4226     if (i &gt;= length())
4227         return String();
4228 
4229     if (i &lt; numComputedProperties)
4230         return getPropertyNameString(computedProperties[i]);
4231 
4232     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
4233     if (!style)
4234         return String();
4235 
4236     const auto&amp; inheritedCustomProperties = style-&gt;inheritedCustomProperties();
4237 
4238     if (i &lt; numComputedProperties + inheritedCustomProperties.size()) {
4239         auto results = copyToVector(inheritedCustomProperties.keys());
4240         return results.at(i - numComputedProperties);
4241     }
4242 
4243     const auto&amp; nonInheritedCustomProperties = style-&gt;nonInheritedCustomProperties();
4244     auto results = copyToVector(nonInheritedCustomProperties.keys());
4245     return results.at(i - inheritedCustomProperties.size() - numComputedProperties);
4246 }
4247 
4248 bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
4249 {
4250     if (!m_element)
4251         return false;
4252     if (propertyID == CSSPropertyFontSize &amp;&amp; is&lt;CSSPrimitiveValue&gt;(*value)) {
4253         m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
4254         if (auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier)) {
4255             if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier()) {
4256                 auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
4257                 if (primitiveValue.isValueID() &amp;&amp; primitiveValue.valueID() == sizeIdentifier)
4258                     return true;
4259             }
4260         }
4261     }
4262     RefPtr&lt;CSSValue&gt; computedValue = propertyValue(propertyID);
4263     return computedValue &amp;&amp; value &amp;&amp; computedValue-&gt;equals(*value);
4264 }
4265 
4266 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyProperties()
4267 {
4268     return copyPropertiesInSet(computedProperties, numComputedProperties);
4269 }
4270 
4271 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForShorthandProperties(const StylePropertyShorthand&amp; shorthand)
4272 {
4273     auto list = CSSValueList::createSpaceSeparated();
4274     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4275         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4276     return list;
4277 }
4278 
4279 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor2SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4280 {
4281     auto list = CSSValueList::createSpaceSeparated();
4282 
4283     // Assume the properties are in the usual order start, end.
4284     auto startValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4285     auto endValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4286 
4287     // All 2 properties must be specified.
4288     if (!startValue || !endValue)
4289         return nullptr;
4290 
4291     bool showEnd = !compareCSSValuePtr(startValue, endValue);
4292 
4293     list-&gt;append(startValue.releaseNonNull());
4294     if (showEnd)
4295         list-&gt;append(endValue.releaseNonNull());
4296 
<a name="135" id="anc135"></a><span class="line-modified">4297     return list;</span>
4298 }
4299 
4300 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor4SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4301 {
4302     auto list = CSSValueList::createSpaceSeparated();
4303 
4304     // Assume the properties are in the usual order top, right, bottom, left.
4305     auto topValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4306     auto rightValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4307     auto bottomValue = propertyValue(shorthand.properties()[2], DoNotUpdateLayout);
4308     auto leftValue = propertyValue(shorthand.properties()[3], DoNotUpdateLayout);
4309 
4310     // All 4 properties must be specified.
4311     if (!topValue || !rightValue || !bottomValue || !leftValue)
4312         return nullptr;
4313 
4314     bool showLeft = !compareCSSValuePtr(rightValue, leftValue);
4315     bool showBottom = !compareCSSValuePtr(topValue, bottomValue) || showLeft;
4316     bool showRight = !compareCSSValuePtr(topValue, rightValue) || showBottom;
4317 
4318     list-&gt;append(topValue.releaseNonNull());
4319     if (showRight)
4320         list-&gt;append(rightValue.releaseNonNull());
4321     if (showBottom)
4322         list-&gt;append(bottomValue.releaseNonNull());
4323     if (showLeft)
4324         list-&gt;append(leftValue.releaseNonNull());
4325 
<a name="136" id="anc136"></a><span class="line-modified">4326     return list;</span>
4327 }
4328 
4329 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&amp; shorthand)
4330 {
4331     auto list = CSSValueList::createSlashSeparated();
4332     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4333         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4334     return list;
4335 }
4336 
4337 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
4338 {
4339     Vector&lt;CSSProperty, 256&gt; list;
4340     list.reserveInitialCapacity(length);
4341     for (unsigned i = 0; i &lt; length; ++i) {
4342         if (auto value = propertyValue(set[i]))
4343             list.append(CSSProperty(set[i], WTFMove(value), false));
4344     }
4345     return MutableStyleProperties::create(list.data(), list.size());
4346 }
4347 
4348 CSSRule* CSSComputedStyleDeclaration::parentRule() const
4349 {
4350     return nullptr;
4351 }
4352 
4353 RefPtr&lt;DeprecatedCSSOMValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(const String&amp; propertyName)
4354 {
4355     if (isCustomPropertyName(propertyName)) {
4356         auto value = ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyValue(propertyName);
4357         if (!value)
4358             return nullptr;
4359         return value-&gt;createDeprecatedCSSOMWrapper(*this);
4360     }
4361 
4362     CSSPropertyID propertyID = cssPropertyID(propertyName);
4363     if (!propertyID)
4364         return nullptr;
4365     auto value = getPropertyCSSValue(propertyID);
4366     if (!value)
4367         return nullptr;
4368     return value-&gt;createDeprecatedCSSOMWrapper(*this);
4369 }
4370 
4371 String CSSComputedStyleDeclaration::getPropertyValue(const String &amp;propertyName)
4372 {
4373     if (isCustomPropertyName(propertyName))
4374         return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyText(propertyName);
4375 
4376     CSSPropertyID propertyID = cssPropertyID(propertyName);
4377     if (!propertyID)
4378         return String();
4379     return getPropertyValue(propertyID);
4380 }
4381 
4382 String CSSComputedStyleDeclaration::getPropertyPriority(const String&amp;)
4383 {
4384     // All computed styles have a priority of not &quot;important&quot;.
4385     return emptyString(); // FIXME: Should this sometimes be null instead of empty, to match a normal style declaration?
4386 }
4387 
4388 String CSSComputedStyleDeclaration::getPropertyShorthand(const String&amp;)
4389 {
4390     return emptyString(); // FIXME: Should this sometimes be null instead of empty, to match a normal style declaration?
4391 }
4392 
4393 bool CSSComputedStyleDeclaration::isPropertyImplicit(const String&amp;)
4394 {
4395     return false;
4396 }
4397 
4398 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setProperty(const String&amp;, const String&amp;, const String&amp;)
4399 {
4400     return Exception { NoModificationAllowedError };
4401 }
4402 
4403 ExceptionOr&lt;String&gt; CSSComputedStyleDeclaration::removeProperty(const String&amp;)
4404 {
4405     return Exception { NoModificationAllowedError };
4406 }
4407 
4408 RefPtr&lt;CSSValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValueInternal(CSSPropertyID propertyID)
4409 {
4410     return getPropertyCSSValue(propertyID);
4411 }
4412 
4413 String CSSComputedStyleDeclaration::getPropertyValueInternal(CSSPropertyID propertyID)
4414 {
4415     return getPropertyValue(propertyID);
4416 }
4417 
4418 ExceptionOr&lt;bool&gt; CSSComputedStyleDeclaration::setPropertyInternal(CSSPropertyID, const String&amp;, bool)
4419 {
4420     return Exception { NoModificationAllowedError };
4421 }
4422 
4423 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getBackgroundShorthandValue()
4424 {
4425     static const CSSPropertyID propertiesBeforeSlashSeperator[5] = { CSSPropertyBackgroundColor, CSSPropertyBackgroundImage, CSSPropertyBackgroundRepeat, CSSPropertyBackgroundAttachment, CSSPropertyBackgroundPosition };
4426     static const CSSPropertyID propertiesAfterSlashSeperator[3] = { CSSPropertyBackgroundSize, CSSPropertyBackgroundOrigin, CSSPropertyBackgroundClip };
4427 
4428     auto list = CSSValueList::createSlashSeparated();
4429     list-&gt;append(getCSSPropertyValuesForShorthandProperties(StylePropertyShorthand(CSSPropertyBackground, propertiesBeforeSlashSeperator)));
4430     list-&gt;append(getCSSPropertyValuesForShorthandProperties(StylePropertyShorthand(CSSPropertyBackground, propertiesAfterSlashSeperator)));
4431     return list;
4432 }
4433 
4434 } // namespace WebCore
<a name="137" id="anc137"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="137" type="hidden" />
</body>
</html>