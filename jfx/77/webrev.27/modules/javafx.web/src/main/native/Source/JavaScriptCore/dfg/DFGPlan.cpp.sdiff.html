<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPhase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPlan.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPlan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 34 #include &quot;DFGCFAPhase.h&quot;
 35 #include &quot;DFGCFGSimplificationPhase.h&quot;
 36 #include &quot;DFGCPSRethreadingPhase.h&quot;
 37 #include &quot;DFGCSEPhase.h&quot;
 38 #include &quot;DFGCleanUpPhase.h&quot;
 39 #include &quot;DFGConstantFoldingPhase.h&quot;
 40 #include &quot;DFGConstantHoistingPhase.h&quot;
 41 #include &quot;DFGCriticalEdgeBreakingPhase.h&quot;
 42 #include &quot;DFGDCEPhase.h&quot;
 43 #include &quot;DFGFailedFinalizer.h&quot;
 44 #include &quot;DFGFixupPhase.h&quot;
 45 #include &quot;DFGGraphSafepoint.h&quot;
 46 #include &quot;DFGIntegerCheckCombiningPhase.h&quot;
 47 #include &quot;DFGIntegerRangeOptimizationPhase.h&quot;
 48 #include &quot;DFGInvalidationPointInjectionPhase.h&quot;
 49 #include &quot;DFGJITCompiler.h&quot;
 50 #include &quot;DFGLICMPhase.h&quot;
 51 #include &quot;DFGLiveCatchVariablePreservationPhase.h&quot;
 52 #include &quot;DFGLivenessAnalysisPhase.h&quot;
 53 #include &quot;DFGLoopPreHeaderCreationPhase.h&quot;
<span class="line-removed"> 54 #include &quot;DFGMaximalFlushInsertionPhase.h&quot;</span>
 55 #include &quot;DFGMovHintRemovalPhase.h&quot;
 56 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
 57 #include &quot;DFGOSREntrypointCreationPhase.h&quot;
 58 #include &quot;DFGObjectAllocationSinkingPhase.h&quot;
 59 #include &quot;DFGPhantomInsertionPhase.h&quot;
 60 #include &quot;DFGPredictionInjectionPhase.h&quot;
 61 #include &quot;DFGPredictionPropagationPhase.h&quot;
 62 #include &quot;DFGPutStackSinkingPhase.h&quot;
 63 #include &quot;DFGSSAConversionPhase.h&quot;
 64 #include &quot;DFGSSALoweringPhase.h&quot;
 65 #include &quot;DFGStackLayoutPhase.h&quot;
 66 #include &quot;DFGStaticExecutionCountEstimationPhase.h&quot;
 67 #include &quot;DFGStoreBarrierClusteringPhase.h&quot;
 68 #include &quot;DFGStoreBarrierInsertionPhase.h&quot;
 69 #include &quot;DFGStrengthReductionPhase.h&quot;
 70 #include &quot;DFGTierUpCheckInjectionPhase.h&quot;
 71 #include &quot;DFGTypeCheckHoistingPhase.h&quot;
 72 #include &quot;DFGUnificationPhase.h&quot;
 73 #include &quot;DFGValidate.h&quot;

 74 #include &quot;DFGVarargsForwardingPhase.h&quot;
 75 #include &quot;DFGVirtualRegisterAllocationPhase.h&quot;
 76 #include &quot;DFGWatchpointCollectionPhase.h&quot;
 77 #include &quot;JSCInlines.h&quot;
 78 #include &quot;OperandsInlines.h&quot;
 79 #include &quot;ProfilerDatabase.h&quot;
 80 #include &quot;TrackedReferences.h&quot;
 81 #include &quot;VMInlines.h&quot;
 82 
 83 #if ENABLE(FTL_JIT)
 84 #include &quot;FTLCapabilities.h&quot;
 85 #include &quot;FTLCompile.h&quot;
 86 #include &quot;FTLFail.h&quot;
 87 #include &quot;FTLLink.h&quot;
 88 #include &quot;FTLLowerDFGToB3.h&quot;
 89 #include &quot;FTLState.h&quot;
 90 #endif
 91 
 92 namespace JSC {
 93 
</pre>
<hr />
<pre>
119     switch (mode) {
120     case InvalidCompilationMode:
121         RELEASE_ASSERT_NOT_REACHED();
122         return Profiler::DFG;
123     case DFGMode:
124         return Profiler::DFG;
125     case FTLMode:
126         return Profiler::FTL;
127     case FTLForOSREntryMode:
128         return Profiler::FTLForOSREntry;
129     }
130     RELEASE_ASSERT_NOT_REACHED();
131     return Profiler::DFG;
132 }
133 
134 } // anonymous namespace
135 
136 Plan::Plan(CodeBlock* passedCodeBlock, CodeBlock* profiledDFGCodeBlock,
137     CompilationMode mode, unsigned osrEntryBytecodeIndex,
138     const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues)
<span class="line-modified">139     : m_vm(passedCodeBlock-&gt;vm())</span>

140     , m_codeBlock(passedCodeBlock)
141     , m_profiledDFGCodeBlock(profiledDFGCodeBlock)
<span class="line-removed">142     , m_mode(mode)</span>
<span class="line-removed">143     , m_osrEntryBytecodeIndex(osrEntryBytecodeIndex)</span>
144     , m_mustHandleValues(mustHandleValues)

145     , m_compilation(UNLIKELY(m_vm-&gt;m_perBytecodeProfiler) ? adoptRef(new Profiler::Compilation(m_vm-&gt;m_perBytecodeProfiler-&gt;ensureBytecodesFor(m_codeBlock), profilerCompilationKindForMode(mode))) : nullptr)
146     , m_inlineCallFrames(adoptRef(new InlineCallFrameSet()))
147     , m_identifiers(m_codeBlock)
148     , m_weakReferences(m_codeBlock)
149     , m_stage(Preparing)
150 {
151     RELEASE_ASSERT(m_codeBlock-&gt;alternative()-&gt;jitCode());

152 }
153 
154 Plan::~Plan()
155 {
156 }
157 
158 bool Plan::computeCompileTimes() const
159 {
160     return reportCompileTimes()
161         || Options::reportTotalCompileTimes()
162         || (m_vm &amp;&amp; m_vm-&gt;m_perBytecodeProfiler);
163 }
164 
165 bool Plan::reportCompileTimes() const
166 {
167     return Options::reportCompileTimes()
168         || Options::reportDFGCompileTimes()
169         || (Options::reportFTLCompileTimes() &amp;&amp; isFTL());
170 }
171 
172 void Plan::compileInThread(ThreadData* threadData)
173 {
174     m_threadData = threadData;
175 
176     MonotonicTime before { };
177     CString codeBlockName;
178     if (UNLIKELY(computeCompileTimes()))
179         before = MonotonicTime::now();
180     if (UNLIKELY(reportCompileTimes()))
181         codeBlockName = toCString(*m_codeBlock);
182 
183     CompilationScope compilationScope;
184 
185     if (logCompilationChanges(m_mode) || Options::logPhaseTimes())
<span class="line-modified">186         dataLog(&quot;DFG(Plan) compiling &quot;, *m_codeBlock, &quot; with &quot;, m_mode, &quot;, number of instructions = &quot;, m_codeBlock-&gt;instructionCount(), &quot;\n&quot;);</span>
187 
188     CompilationPath path = compileInThreadImpl();
189 
190     RELEASE_ASSERT(path == CancelPath || m_finalizer);
191     RELEASE_ASSERT((path == CancelPath) == (m_stage == Cancelled));
192 
193     MonotonicTime after { };
194     if (UNLIKELY(computeCompileTimes())) {
195         after = MonotonicTime::now();
196 
197         if (Options::reportTotalCompileTimes()) {
198             if (isFTL()) {
199                 totalFTLCompileTime += after - before;
200                 totalFTLDFGCompileTime += m_timeBeforeFTL - before;
201                 totalFTLB3CompileTime += after - m_timeBeforeFTL;
202             } else
203                 totalDFGCompileTime += after - before;
204         }
205     }
206     const char* pathName = nullptr;
</pre>
<hr />
<pre>
245         dataLog(&quot;\n&quot;);
246     }
247 
248     Graph dfg(*m_vm, *this);
249     parse(dfg);
250 
251     m_codeBlock-&gt;setCalleeSaveRegisters(RegisterSet::dfgCalleeSaveRegisters());
252 
253     bool changed = false;
254 
255 #define RUN_PHASE(phase)                                         \
256     do {                                                         \
257         if (Options::safepointBeforeEachPhase()) {               \
258             Safepoint::Result safepointResult;                   \
259             {                                                    \
260                 GraphSafepoint safepoint(dfg, safepointResult);  \
261             }                                                    \
262             if (safepointResult.didGetCancelled())               \
263                 return CancelPath;                               \
264         }                                                        \

265         changed |= phase(dfg);                                   \
266     } while (false);                                             \
267 
268 
269     // By this point the DFG bytecode parser will have potentially mutated various tables
270     // in the CodeBlock. This is a good time to perform an early shrink, which is more
271     // powerful than a late one. It&#39;s safe to do so because we haven&#39;t generated any code
272     // that references any of the tables directly, yet.
273     m_codeBlock-&gt;shrinkToFit(CodeBlock::EarlyShrink);
274 
275     if (validationEnabled())
276         validate(dfg);
277 
278     if (Options::dumpGraphAfterParsing()) {
279         dataLog(&quot;Graph after parsing:\n&quot;);
280         dfg.dump();
281     }
282 
283     RUN_PHASE(performLiveCatchVariablePreservationPhase);
284 
<span class="line-removed">285     if (Options::useMaximalFlushInsertionPhase())</span>
<span class="line-removed">286         RUN_PHASE(performMaximalFlushInsertion);</span>
<span class="line-removed">287 </span>
288     RUN_PHASE(performCPSRethreading);
289     RUN_PHASE(performUnification);
290     RUN_PHASE(performPredictionInjection);
291 
292     RUN_PHASE(performStaticExecutionCountEstimation);
293 
294     if (m_mode == FTLForOSREntryMode) {
295         bool result = performOSREntrypointCreation(dfg);
296         if (!result) {
<span class="line-modified">297             m_finalizer = std::make_unique&lt;FailedFinalizer&gt;(*this);</span>
298             return FailPath;
299         }
300         RUN_PHASE(performCPSRethreading);
301     }
302 
303     if (validationEnabled())
304         validate(dfg);
305 
306     RUN_PHASE(performBackwardsPropagation);
307     RUN_PHASE(performPredictionPropagation);
308     RUN_PHASE(performFixup);
309     RUN_PHASE(performInvalidationPointInjection);
310     RUN_PHASE(performTypeCheckHoisting);
311 
312     dfg.m_fixpointState = FixpointNotConverged;
313 
314     // For now we&#39;re back to avoiding a fixpoint. Note that we&#39;ve ping-ponged on this decision
315     // many times. For maximum throughput, it&#39;s best to fixpoint. But the throughput benefit is
316     // small and not likely to show up in FTL anyway. On the other hand, not fixpointing means
317     // that the compiler compiles more quickly. We want the third tier to compile quickly, which
</pre>
<hr />
<pre>
378         RUN_PHASE(performDCE);
379         RUN_PHASE(performPhantomInsertion);
380         RUN_PHASE(performStackLayout);
381         RUN_PHASE(performVirtualRegisterAllocation);
382         RUN_PHASE(performWatchpointCollection);
383         dumpAndVerifyGraph(dfg, &quot;Graph after optimization:&quot;);
384 
385         JITCompiler dataFlowJIT(dfg);
386         if (m_codeBlock-&gt;codeType() == FunctionCode)
387             dataFlowJIT.compileFunction();
388         else
389             dataFlowJIT.compile();
390 
391         return DFGPath;
392     }
393 
394     case FTLMode:
395     case FTLForOSREntryMode: {
396 #if ENABLE(FTL_JIT)
397         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
<span class="line-modified">398             m_finalizer = std::make_unique&lt;FailedFinalizer&gt;(*this);</span>
399             return FailPath;
400         }
401 
402         RUN_PHASE(performCleanUp); // Reduce the graph size a bit.
403         RUN_PHASE(performCriticalEdgeBreaking);
404         if (Options::createPreHeaders())
405             RUN_PHASE(performLoopPreHeaderCreation);
406         RUN_PHASE(performCPSRethreading);
407         RUN_PHASE(performSSAConversion);
408         RUN_PHASE(performSSALowering);
409 
410         // Ideally, these would be run to fixpoint with the object allocation sinking phase.
411         RUN_PHASE(performArgumentsElimination);
412         if (Options::usePutStackSinking())
413             RUN_PHASE(performPutStackSinking);
414 
415         RUN_PHASE(performConstantHoisting);
416         RUN_PHASE(performGlobalCSE);
417         RUN_PHASE(performLivenessAnalysis);
418         RUN_PHASE(performCFA);
419         RUN_PHASE(performConstantFolding);
420         RUN_PHASE(performCleanUp); // Reduce the graph size a lot.
421         changed = false;
422         RUN_PHASE(performStrengthReduction);
423         if (Options::useObjectAllocationSinking()) {
424             RUN_PHASE(performCriticalEdgeBreaking);
425             RUN_PHASE(performObjectAllocationSinking);
426         }


427         if (changed) {
428             // State-at-tail and state-at-head will be invalid if we did strength reduction since
429             // it might increase live ranges.
430             RUN_PHASE(performLivenessAnalysis);
431             RUN_PHASE(performCFA);
432             RUN_PHASE(performConstantFolding);
433         }
434 
435         // Currently, this relies on pre-headers still being valid. That precludes running CFG
436         // simplification before it, unless we re-created the pre-headers. There wouldn&#39;t be anything
437         // wrong with running LICM earlier, if we wanted to put other CFG transforms above this point.
438         // Alternatively, we could run loop pre-header creation after SSA conversion - but if we did that
439         // then we&#39;d need to do some simple SSA fix-up.
440         RUN_PHASE(performLivenessAnalysis);
441         RUN_PHASE(performCFA);
442         RUN_PHASE(performLICM);
443 
444         // FIXME: Currently: IntegerRangeOptimization *must* be run after LICM.
445         //
446         // IntegerRangeOptimization makes changes on nodes based on preceding blocks
</pre>
<hr />
<pre>
456         RUN_PHASE(performGlobalCSE);
457 
458         // At this point we&#39;re not allowed to do any further code motion because our reasoning
459         // about code motion assumes that it&#39;s OK to insert GC points in random places.
460         dfg.m_fixpointState = FixpointConverged;
461 
462         RUN_PHASE(performLivenessAnalysis);
463         RUN_PHASE(performCFA);
464         RUN_PHASE(performGlobalStoreBarrierInsertion);
465         RUN_PHASE(performStoreBarrierClustering);
466         if (Options::useMovHintRemoval())
467             RUN_PHASE(performMovHintRemoval);
468         RUN_PHASE(performCleanUp);
469         RUN_PHASE(performDCE); // We rely on this to kill dead code that won&#39;t be recognized as dead by B3.
470         RUN_PHASE(performStackLayout);
471         RUN_PHASE(performLivenessAnalysis);
472         RUN_PHASE(performOSRAvailabilityAnalysis);
473         RUN_PHASE(performWatchpointCollection);
474 
475         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
<span class="line-modified">476             m_finalizer = std::make_unique&lt;FailedFinalizer&gt;(*this);</span>
477             return FailPath;
478         }
479 

480         dumpAndVerifyGraph(dfg, &quot;Graph just before FTL lowering:&quot;, shouldDumpDisassembly(m_mode));
481 
482         // Flash a safepoint in case the GC wants some action.
483         Safepoint::Result safepointResult;
484         {
485             GraphSafepoint safepoint(dfg, safepointResult);
486         }
487         if (safepointResult.didGetCancelled())
488             return CancelPath;
489 

490         FTL::State state(dfg);
491         FTL::lowerDFGToB3(state);
492 
493         if (UNLIKELY(computeCompileTimes()))
494             m_timeBeforeFTL = MonotonicTime::now();
495 
496         if (Options::b3AlwaysFailsBeforeCompile()) {
497             FTL::fail(state);
498             return FTLPath;
499         }
500 
501         FTL::compile(state, safepointResult);
502         if (safepointResult.didGetCancelled())
503             return CancelPath;
504 
505         if (Options::b3AlwaysFailsBeforeLink()) {
506             FTL::fail(state);
507             return FTLPath;
508         }
509 
</pre>
<hr />
<pre>
561 }
562 
563 void Plan::notifyCompiling()
564 {
565     m_stage = Compiling;
566 }
567 
568 void Plan::notifyReady()
569 {
570     m_callback-&gt;compilationDidBecomeReadyAsynchronously(m_codeBlock, m_profiledDFGCodeBlock);
571     m_stage = Ready;
572 }
573 
574 bool Plan::isStillValidOnMainThread()
575 {
576     return m_globalProperties.isStillValidOnMainThread(*m_vm, m_identifiers);
577 }
578 
579 CompilationResult Plan::finalizeWithoutNotifyingCallback()
580 {
<span class="line-modified">581     // We will establish new references from the code block to things. So, we need a barrier.</span>
<span class="line-modified">582     m_vm-&gt;heap.writeBarrier(m_codeBlock);</span>







583 
<span class="line-modified">584     if (!isStillValidOnMainThread() || !isStillValid()) {</span>
<span class="line-modified">585         CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;invalidated&quot;));</span>
<span class="line-modified">586         return CompilationInvalidated;</span>
<span class="line-modified">587     }</span>

588 
<span class="line-modified">589     bool result;</span>
<span class="line-modified">590     if (m_codeBlock-&gt;codeType() == FunctionCode)</span>
<span class="line-modified">591         result = m_finalizer-&gt;finalizeFunction();</span>
<span class="line-modified">592     else</span>
<span class="line-removed">593         result = m_finalizer-&gt;finalize();</span>
594 
<span class="line-modified">595     if (!result) {</span>
<span class="line-removed">596         CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;failed&quot;));</span>
<span class="line-removed">597         return CompilationFailed;</span>
<span class="line-removed">598     }</span>
599 
<span class="line-modified">600     reallyAdd(m_codeBlock-&gt;jitCode()-&gt;dfgCommon());</span>

601 
<span class="line-modified">602     if (validationEnabled()) {</span>
<span class="line-modified">603         TrackedReferences trackedReferences;</span>




604 
<span class="line-modified">605         for (WriteBarrier&lt;JSCell&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakReferences)</span>
<span class="line-modified">606             trackedReferences.add(reference.get());</span>
<span class="line-modified">607         for (WriteBarrier&lt;Structure&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakStructureReferences)</span>
<span class="line-modified">608             trackedReferences.add(reference.get());</span>
<span class="line-removed">609         for (WriteBarrier&lt;Unknown&gt;&amp; constant : m_codeBlock-&gt;constants())</span>
<span class="line-removed">610             trackedReferences.add(constant.get());</span>
611 
<span class="line-modified">612         for (auto* inlineCallFrame : *m_inlineCallFrames) {</span>
<span class="line-modified">613             ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());</span>
<span class="line-modified">614             trackedReferences.add(inlineCallFrame-&gt;baselineCodeBlock.get());</span>
615         }
616 
<span class="line-modified">617         // Check that any other references that we have anywhere in the JITCode are also</span>
<span class="line-modified">618         // tracked either strongly or weakly.</span>
<span class="line-modified">619         m_codeBlock-&gt;jitCode()-&gt;validateReferences(trackedReferences);</span>
<span class="line-removed">620     }</span>
621 
<span class="line-modified">622     CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;succeeded&quot;));</span>
<span class="line-modified">623     return CompilationSuccessful;</span>

624 }
625 
626 void Plan::finalizeAndNotifyCallback()
627 {
628     m_callback-&gt;compilationDidComplete(m_codeBlock, m_profiledDFGCodeBlock, finalizeWithoutNotifyingCallback());
629 }
630 
631 CompilationKey Plan::key()
632 {
633     return CompilationKey(m_codeBlock-&gt;alternative(), m_mode);
634 }
635 
636 void Plan::checkLivenessAndVisitChildren(SlotVisitor&amp; visitor)
637 {
638     if (!isKnownToBeLiveDuringGC())
639         return;
640 
641     cleanMustHandleValuesIfNecessary();
642     for (unsigned i = m_mustHandleValues.size(); i--;) {
643         Optional&lt;JSValue&gt; value = m_mustHandleValues[i];
</pre>
<hr />
<pre>
647 
648     m_recordedStatuses.markIfCheap(visitor);
649 
650     visitor.appendUnbarriered(m_codeBlock);
651     visitor.appendUnbarriered(m_codeBlock-&gt;alternative());
652     visitor.appendUnbarriered(m_profiledDFGCodeBlock);
653 
654     if (m_inlineCallFrames) {
655         for (auto* inlineCallFrame : *m_inlineCallFrames) {
656             ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
657             visitor.appendUnbarriered(inlineCallFrame-&gt;baselineCodeBlock.get());
658         }
659     }
660 
661     m_weakReferences.visitChildren(visitor);
662     m_transitions.visitChildren(visitor);
663 }
664 
665 void Plan::finalizeInGC()
666 {
<span class="line-modified">667     m_recordedStatuses.finalizeWithoutDeleting();</span>

668 }
669 
670 bool Plan::isKnownToBeLiveDuringGC()
671 {
672     if (m_stage == Cancelled)
673         return false;
<span class="line-modified">674     if (!Heap::isMarked(m_codeBlock-&gt;ownerExecutable()))</span>
675         return false;
<span class="line-modified">676     if (!Heap::isMarked(m_codeBlock-&gt;alternative()))</span>
677         return false;
<span class="line-modified">678     if (!!m_profiledDFGCodeBlock &amp;&amp; !Heap::isMarked(m_profiledDFGCodeBlock))</span>
679         return false;
680     return true;
681 }
682 
683 void Plan::cancel()
684 {
685     m_vm = nullptr;
686     m_codeBlock = nullptr;
687     m_profiledDFGCodeBlock = nullptr;
688     m_mustHandleValues.clear();
689     m_compilation = nullptr;
690     m_finalizer = nullptr;
691     m_inlineCallFrames = nullptr;
692     m_watchpoints = DesiredWatchpoints();
693     m_identifiers = DesiredIdentifiers();
694     m_globalProperties = DesiredGlobalProperties();
695     m_weakReferences = DesiredWeakReferences();
696     m_transitions = DesiredTransitions();
697     m_callback = nullptr;
698     m_stage = Cancelled;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 34 #include &quot;DFGCFAPhase.h&quot;
 35 #include &quot;DFGCFGSimplificationPhase.h&quot;
 36 #include &quot;DFGCPSRethreadingPhase.h&quot;
 37 #include &quot;DFGCSEPhase.h&quot;
 38 #include &quot;DFGCleanUpPhase.h&quot;
 39 #include &quot;DFGConstantFoldingPhase.h&quot;
 40 #include &quot;DFGConstantHoistingPhase.h&quot;
 41 #include &quot;DFGCriticalEdgeBreakingPhase.h&quot;
 42 #include &quot;DFGDCEPhase.h&quot;
 43 #include &quot;DFGFailedFinalizer.h&quot;
 44 #include &quot;DFGFixupPhase.h&quot;
 45 #include &quot;DFGGraphSafepoint.h&quot;
 46 #include &quot;DFGIntegerCheckCombiningPhase.h&quot;
 47 #include &quot;DFGIntegerRangeOptimizationPhase.h&quot;
 48 #include &quot;DFGInvalidationPointInjectionPhase.h&quot;
 49 #include &quot;DFGJITCompiler.h&quot;
 50 #include &quot;DFGLICMPhase.h&quot;
 51 #include &quot;DFGLiveCatchVariablePreservationPhase.h&quot;
 52 #include &quot;DFGLivenessAnalysisPhase.h&quot;
 53 #include &quot;DFGLoopPreHeaderCreationPhase.h&quot;

 54 #include &quot;DFGMovHintRemovalPhase.h&quot;
 55 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
 56 #include &quot;DFGOSREntrypointCreationPhase.h&quot;
 57 #include &quot;DFGObjectAllocationSinkingPhase.h&quot;
 58 #include &quot;DFGPhantomInsertionPhase.h&quot;
 59 #include &quot;DFGPredictionInjectionPhase.h&quot;
 60 #include &quot;DFGPredictionPropagationPhase.h&quot;
 61 #include &quot;DFGPutStackSinkingPhase.h&quot;
 62 #include &quot;DFGSSAConversionPhase.h&quot;
 63 #include &quot;DFGSSALoweringPhase.h&quot;
 64 #include &quot;DFGStackLayoutPhase.h&quot;
 65 #include &quot;DFGStaticExecutionCountEstimationPhase.h&quot;
 66 #include &quot;DFGStoreBarrierClusteringPhase.h&quot;
 67 #include &quot;DFGStoreBarrierInsertionPhase.h&quot;
 68 #include &quot;DFGStrengthReductionPhase.h&quot;
 69 #include &quot;DFGTierUpCheckInjectionPhase.h&quot;
 70 #include &quot;DFGTypeCheckHoistingPhase.h&quot;
 71 #include &quot;DFGUnificationPhase.h&quot;
 72 #include &quot;DFGValidate.h&quot;
<span class="line-added"> 73 #include &quot;DFGValueRepReductionPhase.h&quot;</span>
 74 #include &quot;DFGVarargsForwardingPhase.h&quot;
 75 #include &quot;DFGVirtualRegisterAllocationPhase.h&quot;
 76 #include &quot;DFGWatchpointCollectionPhase.h&quot;
 77 #include &quot;JSCInlines.h&quot;
 78 #include &quot;OperandsInlines.h&quot;
 79 #include &quot;ProfilerDatabase.h&quot;
 80 #include &quot;TrackedReferences.h&quot;
 81 #include &quot;VMInlines.h&quot;
 82 
 83 #if ENABLE(FTL_JIT)
 84 #include &quot;FTLCapabilities.h&quot;
 85 #include &quot;FTLCompile.h&quot;
 86 #include &quot;FTLFail.h&quot;
 87 #include &quot;FTLLink.h&quot;
 88 #include &quot;FTLLowerDFGToB3.h&quot;
 89 #include &quot;FTLState.h&quot;
 90 #endif
 91 
 92 namespace JSC {
 93 
</pre>
<hr />
<pre>
119     switch (mode) {
120     case InvalidCompilationMode:
121         RELEASE_ASSERT_NOT_REACHED();
122         return Profiler::DFG;
123     case DFGMode:
124         return Profiler::DFG;
125     case FTLMode:
126         return Profiler::FTL;
127     case FTLForOSREntryMode:
128         return Profiler::FTLForOSREntry;
129     }
130     RELEASE_ASSERT_NOT_REACHED();
131     return Profiler::DFG;
132 }
133 
134 } // anonymous namespace
135 
136 Plan::Plan(CodeBlock* passedCodeBlock, CodeBlock* profiledDFGCodeBlock,
137     CompilationMode mode, unsigned osrEntryBytecodeIndex,
138     const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues)
<span class="line-modified">139     : m_mode(mode)</span>
<span class="line-added">140     , m_vm(&amp;passedCodeBlock-&gt;vm())</span>
141     , m_codeBlock(passedCodeBlock)
142     , m_profiledDFGCodeBlock(profiledDFGCodeBlock)


143     , m_mustHandleValues(mustHandleValues)
<span class="line-added">144     , m_osrEntryBytecodeIndex(osrEntryBytecodeIndex)</span>
145     , m_compilation(UNLIKELY(m_vm-&gt;m_perBytecodeProfiler) ? adoptRef(new Profiler::Compilation(m_vm-&gt;m_perBytecodeProfiler-&gt;ensureBytecodesFor(m_codeBlock), profilerCompilationKindForMode(mode))) : nullptr)
146     , m_inlineCallFrames(adoptRef(new InlineCallFrameSet()))
147     , m_identifiers(m_codeBlock)
148     , m_weakReferences(m_codeBlock)
149     , m_stage(Preparing)
150 {
151     RELEASE_ASSERT(m_codeBlock-&gt;alternative()-&gt;jitCode());
<span class="line-added">152     m_inlineCallFrames-&gt;disableThreadingChecks();</span>
153 }
154 
155 Plan::~Plan()
156 {
157 }
158 
159 bool Plan::computeCompileTimes() const
160 {
161     return reportCompileTimes()
162         || Options::reportTotalCompileTimes()
163         || (m_vm &amp;&amp; m_vm-&gt;m_perBytecodeProfiler);
164 }
165 
166 bool Plan::reportCompileTimes() const
167 {
168     return Options::reportCompileTimes()
169         || Options::reportDFGCompileTimes()
170         || (Options::reportFTLCompileTimes() &amp;&amp; isFTL());
171 }
172 
173 void Plan::compileInThread(ThreadData* threadData)
174 {
175     m_threadData = threadData;
176 
177     MonotonicTime before { };
178     CString codeBlockName;
179     if (UNLIKELY(computeCompileTimes()))
180         before = MonotonicTime::now();
181     if (UNLIKELY(reportCompileTimes()))
182         codeBlockName = toCString(*m_codeBlock);
183 
184     CompilationScope compilationScope;
185 
186     if (logCompilationChanges(m_mode) || Options::logPhaseTimes())
<span class="line-modified">187         dataLog(&quot;DFG(Plan) compiling &quot;, *m_codeBlock, &quot; with &quot;, m_mode, &quot;, instructions size = &quot;, m_codeBlock-&gt;instructionsSize(), &quot;\n&quot;);</span>
188 
189     CompilationPath path = compileInThreadImpl();
190 
191     RELEASE_ASSERT(path == CancelPath || m_finalizer);
192     RELEASE_ASSERT((path == CancelPath) == (m_stage == Cancelled));
193 
194     MonotonicTime after { };
195     if (UNLIKELY(computeCompileTimes())) {
196         after = MonotonicTime::now();
197 
198         if (Options::reportTotalCompileTimes()) {
199             if (isFTL()) {
200                 totalFTLCompileTime += after - before;
201                 totalFTLDFGCompileTime += m_timeBeforeFTL - before;
202                 totalFTLB3CompileTime += after - m_timeBeforeFTL;
203             } else
204                 totalDFGCompileTime += after - before;
205         }
206     }
207     const char* pathName = nullptr;
</pre>
<hr />
<pre>
246         dataLog(&quot;\n&quot;);
247     }
248 
249     Graph dfg(*m_vm, *this);
250     parse(dfg);
251 
252     m_codeBlock-&gt;setCalleeSaveRegisters(RegisterSet::dfgCalleeSaveRegisters());
253 
254     bool changed = false;
255 
256 #define RUN_PHASE(phase)                                         \
257     do {                                                         \
258         if (Options::safepointBeforeEachPhase()) {               \
259             Safepoint::Result safepointResult;                   \
260             {                                                    \
261                 GraphSafepoint safepoint(dfg, safepointResult);  \
262             }                                                    \
263             if (safepointResult.didGetCancelled())               \
264                 return CancelPath;                               \
265         }                                                        \
<span class="line-added">266         dfg.nextPhase();                                         \</span>
267         changed |= phase(dfg);                                   \
268     } while (false);                                             \
269 
270 
271     // By this point the DFG bytecode parser will have potentially mutated various tables
272     // in the CodeBlock. This is a good time to perform an early shrink, which is more
273     // powerful than a late one. It&#39;s safe to do so because we haven&#39;t generated any code
274     // that references any of the tables directly, yet.
275     m_codeBlock-&gt;shrinkToFit(CodeBlock::EarlyShrink);
276 
277     if (validationEnabled())
278         validate(dfg);
279 
280     if (Options::dumpGraphAfterParsing()) {
281         dataLog(&quot;Graph after parsing:\n&quot;);
282         dfg.dump();
283     }
284 
285     RUN_PHASE(performLiveCatchVariablePreservationPhase);
286 



287     RUN_PHASE(performCPSRethreading);
288     RUN_PHASE(performUnification);
289     RUN_PHASE(performPredictionInjection);
290 
291     RUN_PHASE(performStaticExecutionCountEstimation);
292 
293     if (m_mode == FTLForOSREntryMode) {
294         bool result = performOSREntrypointCreation(dfg);
295         if (!result) {
<span class="line-modified">296             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);</span>
297             return FailPath;
298         }
299         RUN_PHASE(performCPSRethreading);
300     }
301 
302     if (validationEnabled())
303         validate(dfg);
304 
305     RUN_PHASE(performBackwardsPropagation);
306     RUN_PHASE(performPredictionPropagation);
307     RUN_PHASE(performFixup);
308     RUN_PHASE(performInvalidationPointInjection);
309     RUN_PHASE(performTypeCheckHoisting);
310 
311     dfg.m_fixpointState = FixpointNotConverged;
312 
313     // For now we&#39;re back to avoiding a fixpoint. Note that we&#39;ve ping-ponged on this decision
314     // many times. For maximum throughput, it&#39;s best to fixpoint. But the throughput benefit is
315     // small and not likely to show up in FTL anyway. On the other hand, not fixpointing means
316     // that the compiler compiles more quickly. We want the third tier to compile quickly, which
</pre>
<hr />
<pre>
377         RUN_PHASE(performDCE);
378         RUN_PHASE(performPhantomInsertion);
379         RUN_PHASE(performStackLayout);
380         RUN_PHASE(performVirtualRegisterAllocation);
381         RUN_PHASE(performWatchpointCollection);
382         dumpAndVerifyGraph(dfg, &quot;Graph after optimization:&quot;);
383 
384         JITCompiler dataFlowJIT(dfg);
385         if (m_codeBlock-&gt;codeType() == FunctionCode)
386             dataFlowJIT.compileFunction();
387         else
388             dataFlowJIT.compile();
389 
390         return DFGPath;
391     }
392 
393     case FTLMode:
394     case FTLForOSREntryMode: {
395 #if ENABLE(FTL_JIT)
396         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
<span class="line-modified">397             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);</span>
398             return FailPath;
399         }
400 
401         RUN_PHASE(performCleanUp); // Reduce the graph size a bit.
402         RUN_PHASE(performCriticalEdgeBreaking);
403         if (Options::createPreHeaders())
404             RUN_PHASE(performLoopPreHeaderCreation);
405         RUN_PHASE(performCPSRethreading);
406         RUN_PHASE(performSSAConversion);
407         RUN_PHASE(performSSALowering);
408 
409         // Ideally, these would be run to fixpoint with the object allocation sinking phase.
410         RUN_PHASE(performArgumentsElimination);
411         if (Options::usePutStackSinking())
412             RUN_PHASE(performPutStackSinking);
413 
414         RUN_PHASE(performConstantHoisting);
415         RUN_PHASE(performGlobalCSE);
416         RUN_PHASE(performLivenessAnalysis);
417         RUN_PHASE(performCFA);
418         RUN_PHASE(performConstantFolding);
419         RUN_PHASE(performCleanUp); // Reduce the graph size a lot.
420         changed = false;
421         RUN_PHASE(performStrengthReduction);
422         if (Options::useObjectAllocationSinking()) {
423             RUN_PHASE(performCriticalEdgeBreaking);
424             RUN_PHASE(performObjectAllocationSinking);
425         }
<span class="line-added">426         if (Options::useValueRepElimination())</span>
<span class="line-added">427             RUN_PHASE(performValueRepReduction);</span>
428         if (changed) {
429             // State-at-tail and state-at-head will be invalid if we did strength reduction since
430             // it might increase live ranges.
431             RUN_PHASE(performLivenessAnalysis);
432             RUN_PHASE(performCFA);
433             RUN_PHASE(performConstantFolding);
434         }
435 
436         // Currently, this relies on pre-headers still being valid. That precludes running CFG
437         // simplification before it, unless we re-created the pre-headers. There wouldn&#39;t be anything
438         // wrong with running LICM earlier, if we wanted to put other CFG transforms above this point.
439         // Alternatively, we could run loop pre-header creation after SSA conversion - but if we did that
440         // then we&#39;d need to do some simple SSA fix-up.
441         RUN_PHASE(performLivenessAnalysis);
442         RUN_PHASE(performCFA);
443         RUN_PHASE(performLICM);
444 
445         // FIXME: Currently: IntegerRangeOptimization *must* be run after LICM.
446         //
447         // IntegerRangeOptimization makes changes on nodes based on preceding blocks
</pre>
<hr />
<pre>
457         RUN_PHASE(performGlobalCSE);
458 
459         // At this point we&#39;re not allowed to do any further code motion because our reasoning
460         // about code motion assumes that it&#39;s OK to insert GC points in random places.
461         dfg.m_fixpointState = FixpointConverged;
462 
463         RUN_PHASE(performLivenessAnalysis);
464         RUN_PHASE(performCFA);
465         RUN_PHASE(performGlobalStoreBarrierInsertion);
466         RUN_PHASE(performStoreBarrierClustering);
467         if (Options::useMovHintRemoval())
468             RUN_PHASE(performMovHintRemoval);
469         RUN_PHASE(performCleanUp);
470         RUN_PHASE(performDCE); // We rely on this to kill dead code that won&#39;t be recognized as dead by B3.
471         RUN_PHASE(performStackLayout);
472         RUN_PHASE(performLivenessAnalysis);
473         RUN_PHASE(performOSRAvailabilityAnalysis);
474         RUN_PHASE(performWatchpointCollection);
475 
476         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
<span class="line-modified">477             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);</span>
478             return FailPath;
479         }
480 
<span class="line-added">481         dfg.nextPhase();</span>
482         dumpAndVerifyGraph(dfg, &quot;Graph just before FTL lowering:&quot;, shouldDumpDisassembly(m_mode));
483 
484         // Flash a safepoint in case the GC wants some action.
485         Safepoint::Result safepointResult;
486         {
487             GraphSafepoint safepoint(dfg, safepointResult);
488         }
489         if (safepointResult.didGetCancelled())
490             return CancelPath;
491 
<span class="line-added">492         dfg.nextPhase();</span>
493         FTL::State state(dfg);
494         FTL::lowerDFGToB3(state);
495 
496         if (UNLIKELY(computeCompileTimes()))
497             m_timeBeforeFTL = MonotonicTime::now();
498 
499         if (Options::b3AlwaysFailsBeforeCompile()) {
500             FTL::fail(state);
501             return FTLPath;
502         }
503 
504         FTL::compile(state, safepointResult);
505         if (safepointResult.didGetCancelled())
506             return CancelPath;
507 
508         if (Options::b3AlwaysFailsBeforeLink()) {
509             FTL::fail(state);
510             return FTLPath;
511         }
512 
</pre>
<hr />
<pre>
564 }
565 
566 void Plan::notifyCompiling()
567 {
568     m_stage = Compiling;
569 }
570 
571 void Plan::notifyReady()
572 {
573     m_callback-&gt;compilationDidBecomeReadyAsynchronously(m_codeBlock, m_profiledDFGCodeBlock);
574     m_stage = Ready;
575 }
576 
577 bool Plan::isStillValidOnMainThread()
578 {
579     return m_globalProperties.isStillValidOnMainThread(*m_vm, m_identifiers);
580 }
581 
582 CompilationResult Plan::finalizeWithoutNotifyingCallback()
583 {
<span class="line-modified">584     // We perform multiple stores before emitting a write-barrier. To ensure that no GC happens between store and write-barrier, we should ensure that</span>
<span class="line-modified">585     // GC is deferred when this function is called.</span>
<span class="line-added">586     ASSERT(m_vm-&gt;heap.isDeferred());</span>
<span class="line-added">587 </span>
<span class="line-added">588     CompilationResult result = [&amp;] {</span>
<span class="line-added">589         if (!isStillValidOnMainThread() || !isStillValid()) {</span>
<span class="line-added">590             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;invalidated&quot;));</span>
<span class="line-added">591             return CompilationInvalidated;</span>
<span class="line-added">592         }</span>
593 
<span class="line-modified">594         bool result;</span>
<span class="line-modified">595         if (m_codeBlock-&gt;codeType() == FunctionCode)</span>
<span class="line-modified">596             result = m_finalizer-&gt;finalizeFunction();</span>
<span class="line-modified">597         else</span>
<span class="line-added">598             result = m_finalizer-&gt;finalize();</span>
599 
<span class="line-modified">600         if (!result) {</span>
<span class="line-modified">601             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;failed&quot;));</span>
<span class="line-modified">602             return CompilationFailed;</span>
<span class="line-modified">603         }</span>

604 
<span class="line-modified">605         reallyAdd(m_codeBlock-&gt;jitCode()-&gt;dfgCommon());</span>



606 
<span class="line-modified">607         if (validationEnabled()) {</span>
<span class="line-added">608             TrackedReferences trackedReferences;</span>
609 
<span class="line-modified">610             for (WriteBarrier&lt;JSCell&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakReferences)</span>
<span class="line-modified">611                 trackedReferences.add(reference.get());</span>
<span class="line-added">612             for (WriteBarrier&lt;Structure&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakStructureReferences)</span>
<span class="line-added">613                 trackedReferences.add(reference.get());</span>
<span class="line-added">614             for (WriteBarrier&lt;Unknown&gt;&amp; constant : m_codeBlock-&gt;constants())</span>
<span class="line-added">615                 trackedReferences.add(constant.get());</span>
616 
<span class="line-modified">617             for (auto* inlineCallFrame : *m_inlineCallFrames) {</span>
<span class="line-modified">618                 ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());</span>
<span class="line-modified">619                 trackedReferences.add(inlineCallFrame-&gt;baselineCodeBlock.get());</span>
<span class="line-modified">620             }</span>


621 
<span class="line-modified">622             // Check that any other references that we have anywhere in the JITCode are also</span>
<span class="line-modified">623             // tracked either strongly or weakly.</span>
<span class="line-modified">624             m_codeBlock-&gt;jitCode()-&gt;validateReferences(trackedReferences);</span>
625         }
626 
<span class="line-modified">627         CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;succeeded&quot;));</span>
<span class="line-modified">628         return CompilationSuccessful;</span>
<span class="line-modified">629     }();</span>

630 
<span class="line-modified">631     // We will establish new references from the code block to things. So, we need a barrier.</span>
<span class="line-modified">632     m_vm-&gt;heap.writeBarrier(m_codeBlock);</span>
<span class="line-added">633     return result;</span>
634 }
635 
636 void Plan::finalizeAndNotifyCallback()
637 {
638     m_callback-&gt;compilationDidComplete(m_codeBlock, m_profiledDFGCodeBlock, finalizeWithoutNotifyingCallback());
639 }
640 
641 CompilationKey Plan::key()
642 {
643     return CompilationKey(m_codeBlock-&gt;alternative(), m_mode);
644 }
645 
646 void Plan::checkLivenessAndVisitChildren(SlotVisitor&amp; visitor)
647 {
648     if (!isKnownToBeLiveDuringGC())
649         return;
650 
651     cleanMustHandleValuesIfNecessary();
652     for (unsigned i = m_mustHandleValues.size(); i--;) {
653         Optional&lt;JSValue&gt; value = m_mustHandleValues[i];
</pre>
<hr />
<pre>
657 
658     m_recordedStatuses.markIfCheap(visitor);
659 
660     visitor.appendUnbarriered(m_codeBlock);
661     visitor.appendUnbarriered(m_codeBlock-&gt;alternative());
662     visitor.appendUnbarriered(m_profiledDFGCodeBlock);
663 
664     if (m_inlineCallFrames) {
665         for (auto* inlineCallFrame : *m_inlineCallFrames) {
666             ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
667             visitor.appendUnbarriered(inlineCallFrame-&gt;baselineCodeBlock.get());
668         }
669     }
670 
671     m_weakReferences.visitChildren(visitor);
672     m_transitions.visitChildren(visitor);
673 }
674 
675 void Plan::finalizeInGC()
676 {
<span class="line-modified">677     ASSERT(m_vm);</span>
<span class="line-added">678     m_recordedStatuses.finalizeWithoutDeleting(*m_vm);</span>
679 }
680 
681 bool Plan::isKnownToBeLiveDuringGC()
682 {
683     if (m_stage == Cancelled)
684         return false;
<span class="line-modified">685     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;ownerExecutable()))</span>
686         return false;
<span class="line-modified">687     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;alternative()))</span>
688         return false;
<span class="line-modified">689     if (!!m_profiledDFGCodeBlock &amp;&amp; !m_vm-&gt;heap.isMarked(m_profiledDFGCodeBlock))</span>
690         return false;
691     return true;
692 }
693 
694 void Plan::cancel()
695 {
696     m_vm = nullptr;
697     m_codeBlock = nullptr;
698     m_profiledDFGCodeBlock = nullptr;
699     m_mustHandleValues.clear();
700     m_compilation = nullptr;
701     m_finalizer = nullptr;
702     m_inlineCallFrames = nullptr;
703     m_watchpoints = DesiredWatchpoints();
704     m_identifiers = DesiredIdentifiers();
705     m_globalProperties = DesiredGlobalProperties();
706     m_weakReferences = DesiredWeakReferences();
707     m_transitions = DesiredTransitions();
708     m_callback = nullptr;
709     m_stage = Cancelled;
</pre>
</td>
</tr>
</table>
<center><a href="DFGPhase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPlan.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>