<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public License
  15  * along with this library; see the file COPYING.LIB.  If not, write to
  16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 #include &quot;Page.h&quot;
  22 
  23 #include &quot;ActivityStateChangeObserver.h&quot;
  24 #include &quot;AlternativeTextClient.h&quot;
  25 #include &quot;ApplicationCacheStorage.h&quot;
  26 #include &quot;ApplicationStateChangeListener.h&quot;
  27 #include &quot;AuthenticatorCoordinator.h&quot;
  28 #include &quot;BackForwardClient.h&quot;
  29 #include &quot;BackForwardController.h&quot;
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CacheStorageProvider.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;ConstantPropertyMap.h&quot;
  35 #include &quot;ContextMenuClient.h&quot;
  36 #include &quot;ContextMenuController.h&quot;
  37 #include &quot;CookieJar.h&quot;
  38 #include &quot;DOMRect.h&quot;
  39 #include &quot;DOMRectList.h&quot;
  40 #include &quot;DatabaseProvider.h&quot;
  41 #include &quot;DiagnosticLoggingClient.h&quot;
  42 #include &quot;DiagnosticLoggingKeys.h&quot;
  43 #include &quot;DocumentLoader.h&quot;
  44 #include &quot;DocumentMarkerController.h&quot;
  45 #include &quot;DocumentTimeline.h&quot;
  46 #include &quot;DragController.h&quot;
  47 #include &quot;Editing.h&quot;
  48 #include &quot;Editor.h&quot;
  49 #include &quot;EditorClient.h&quot;
  50 #include &quot;EmptyClients.h&quot;
  51 #include &quot;Event.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;ExtensionStyleSheets.h&quot;
  54 #include &quot;FocusController.h&quot;
  55 #include &quot;FrameLoader.h&quot;
  56 #include &quot;FrameLoaderClient.h&quot;
  57 #include &quot;FrameSelection.h&quot;
  58 #include &quot;FrameTree.h&quot;
  59 #include &quot;FrameView.h&quot;
  60 #include &quot;HTMLElement.h&quot;
  61 #include &quot;HTMLMediaElement.h&quot;
  62 #include &quot;HistoryController.h&quot;
  63 #include &quot;HistoryItem.h&quot;
  64 #include &quot;InspectorClient.h&quot;
  65 #include &quot;InspectorController.h&quot;
  66 #include &quot;InspectorInstrumentation.h&quot;
  67 #include &quot;LibWebRTCProvider.h&quot;
  68 #include &quot;LoaderStrategy.h&quot;
  69 #include &quot;Logging.h&quot;
  70 #include &quot;LowPowerModeNotifier.h&quot;
  71 #include &quot;MediaCanStartListener.h&quot;
  72 #include &quot;Navigator.h&quot;
  73 #include &quot;PageCache.h&quot;
  74 #include &quot;PageConfiguration.h&quot;
  75 #include &quot;PageConsoleClient.h&quot;
  76 #include &quot;PageDebuggable.h&quot;
  77 #include &quot;PageGroup.h&quot;
  78 #include &quot;PageOverlayController.h&quot;
  79 #include &quot;PaymentCoordinator.h&quot;
  80 #include &quot;PerformanceLogging.h&quot;
  81 #include &quot;PerformanceLoggingClient.h&quot;
  82 #include &quot;PerformanceMonitor.h&quot;
  83 #include &quot;PlatformMediaSessionManager.h&quot;
  84 #include &quot;PlatformStrategies.h&quot;
  85 #include &quot;PlugInClient.h&quot;
  86 #include &quot;PluginData.h&quot;
  87 #include &quot;PluginInfoProvider.h&quot;
  88 #include &quot;PluginViewBase.h&quot;
  89 #include &quot;PointerCaptureController.h&quot;
  90 #include &quot;PointerLockController.h&quot;
  91 #include &quot;ProgressTracker.h&quot;
  92 #include &quot;PublicSuffix.h&quot;
  93 #include &quot;RenderLayerCompositor.h&quot;
  94 #include &quot;RenderTheme.h&quot;
  95 #include &quot;RenderView.h&quot;
  96 #include &quot;RenderWidget.h&quot;
  97 #include &quot;ResourceUsageOverlay.h&quot;
  98 #include &quot;RuntimeEnabledFeatures.h&quot;
  99 #include &quot;SVGDocumentExtensions.h&quot;
 100 #include &quot;SchemeRegistry.h&quot;
 101 #include &quot;ScriptController.h&quot;
 102 #include &quot;ScriptedAnimationController.h&quot;
 103 #include &quot;ScrollLatchingState.h&quot;
 104 #include &quot;ScrollingCoordinator.h&quot;
 105 #include &quot;Settings.h&quot;
 106 #include &quot;SharedBuffer.h&quot;
 107 #include &quot;SocketProvider.h&quot;
 108 #include &quot;StorageArea.h&quot;
 109 #include &quot;StorageNamespace.h&quot;
 110 #include &quot;StorageNamespaceProvider.h&quot;
 111 #include &quot;StyleResolver.h&quot;
 112 #include &quot;StyleScope.h&quot;
 113 #include &quot;SubframeLoader.h&quot;
 114 #include &quot;TextIterator.h&quot;
 115 #include &quot;TextResourceDecoder.h&quot;
 116 #include &quot;UserContentProvider.h&quot;
 117 #include &quot;UserInputBridge.h&quot;
 118 #include &quot;ValidationMessageClient.h&quot;
 119 #include &quot;VisitedLinkState.h&quot;
 120 #include &quot;VisitedLinkStore.h&quot;
 121 #include &quot;VoidCallback.h&quot;
 122 #include &quot;WebGLStateTracker.h&quot;
 123 #include &quot;WheelEventDeltaFilter.h&quot;
 124 #include &quot;Widget.h&quot;
 125 #include &lt;wtf/FileSystem.h&gt;
 126 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 127 #include &lt;wtf/StdLibExtras.h&gt;
 128 #include &lt;wtf/text/Base64.h&gt;
 129 #include &lt;wtf/text/StringHash.h&gt;
 130 
 131 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 132 #include &quot;HTMLVideoElement.h&quot;
 133 #include &quot;MediaPlaybackTarget.h&quot;
 134 #endif
 135 
 136 #if PLATFORM(MAC)
 137 #include &quot;ServicesOverlayController.h&quot;
 138 #endif
 139 
 140 #if ENABLE(MEDIA_SESSION)
 141 #include &quot;MediaSessionManager.h&quot;
 142 #endif
 143 
 144 #if ENABLE(INDEXED_DATABASE)
 145 #include &quot;IDBConnectionToServer.h&quot;
 146 #include &quot;InProcessIDBServer.h&quot;
 147 #endif
 148 
 149 #if ENABLE(DATA_INTERACTION)
 150 #include &quot;SelectionRect.h&quot;
 151 #endif
 152 
 153 namespace WebCore {
 154 
 155 static HashSet&lt;Page*&gt;&amp; allPages()
 156 {
 157     static NeverDestroyed&lt;HashSet&lt;Page*&gt;&gt; set;
 158     return set;
 159 }
 160 
 161 static unsigned nonUtilityPageCount { 0 };
 162 
 163 static inline bool isUtilityPageChromeClient(ChromeClient&amp; chromeClient)
 164 {
 165     return chromeClient.isEmptyChromeClient() || chromeClient.isSVGImageChromeClient();
 166 }
 167 
 168 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, pageCounter, (&quot;Page&quot;));
 169 
 170 void Page::forEachPage(const WTF::Function&lt;void(Page&amp;)&gt;&amp; function)
 171 {
 172     for (auto* page : allPages())
 173         function(*page);
 174 }
 175 
 176 void Page::updateValidationBubbleStateIfNeeded()
 177 {
 178     if (auto* client = validationMessageClient())
 179         client-&gt;updateValidationBubbleStateIfNeeded();
 180 }
 181 
 182 static void networkStateChanged(bool isOnLine)
 183 {
 184     Vector&lt;Ref&lt;Frame&gt;&gt; frames;
 185 
 186     // Get all the frames of all the pages in all the page groups
 187     for (auto* page : allPages()) {
 188         for (Frame* frame = &amp;page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 189             frames.append(*frame);
 190         InspectorInstrumentation::networkStateChanged(*page);
 191     }
 192 
 193     auto&amp; eventName = isOnLine ? eventNames().onlineEvent : eventNames().offlineEvent;
 194     for (auto&amp; frame : frames) {
 195         if (!frame-&gt;document())
 196             continue;
 197         frame-&gt;document()-&gt;dispatchWindowEvent(Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No));
 198     }
 199 }
 200 
 201 static constexpr OptionSet&lt;ActivityState::Flag&gt; pageInitialActivityState()
 202 {
 203     return { ActivityState::IsVisible, ActivityState::IsInWindow };
 204 }
 205 
 206 Page::Page(PageConfiguration&amp;&amp; pageConfiguration)
 207     : m_chrome(std::make_unique&lt;Chrome&gt;(*this, *pageConfiguration.chromeClient))
 208     , m_dragCaretController(std::make_unique&lt;DragCaretController&gt;())
 209 #if ENABLE(DRAG_SUPPORT)
 210     , m_dragController(std::make_unique&lt;DragController&gt;(*this, *pageConfiguration.dragClient))
 211 #endif
 212     , m_focusController(std::make_unique&lt;FocusController&gt;(*this, pageInitialActivityState()))
 213 #if ENABLE(CONTEXT_MENUS)
 214     , m_contextMenuController(std::make_unique&lt;ContextMenuController&gt;(*this, *pageConfiguration.contextMenuClient))
 215 #endif
 216     , m_userInputBridge(std::make_unique&lt;UserInputBridge&gt;(*this))
 217     , m_inspectorController(std::make_unique&lt;InspectorController&gt;(*this, pageConfiguration.inspectorClient))
 218 #if ENABLE(POINTER_EVENTS)
 219     , m_pointerCaptureController(std::make_unique&lt;PointerCaptureController&gt;(*this))
 220 #endif
 221 #if ENABLE(POINTER_LOCK)
 222     , m_pointerLockController(std::make_unique&lt;PointerLockController&gt;(*this))
 223 #endif
 224     , m_settings(Settings::create(this))
 225     , m_progress(std::make_unique&lt;ProgressTracker&gt;(*pageConfiguration.progressTrackerClient))
 226     , m_backForwardController(std::make_unique&lt;BackForwardController&gt;(*this, WTFMove(pageConfiguration.backForwardClient)))
 227     , m_mainFrame(Frame::create(this, nullptr, pageConfiguration.loaderClientForMainFrame))
 228     , m_editorClient(WTFMove(pageConfiguration.editorClient))
 229     , m_plugInClient(pageConfiguration.plugInClient)
 230     , m_validationMessageClient(WTFMove(pageConfiguration.validationMessageClient))
 231     , m_diagnosticLoggingClient(WTFMove(pageConfiguration.diagnosticLoggingClient))
 232     , m_performanceLoggingClient(WTFMove(pageConfiguration.performanceLoggingClient))
 233     , m_webGLStateTracker(WTFMove(pageConfiguration.webGLStateTracker))
 234     , m_libWebRTCProvider(WTFMove(pageConfiguration.libWebRTCProvider))
 235     , m_verticalScrollElasticity(ScrollElasticityAllowed)
 236     , m_horizontalScrollElasticity(ScrollElasticityAllowed)
 237     , m_domTimerAlignmentInterval(DOMTimer::defaultAlignmentInterval())
 238     , m_domTimerAlignmentIntervalIncreaseTimer(*this, &amp;Page::domTimerAlignmentIntervalIncreaseTimerFired)
 239     , m_activityState(pageInitialActivityState())
 240     , m_alternativeTextClient(pageConfiguration.alternativeTextClient)
 241     , m_consoleClient(std::make_unique&lt;PageConsoleClient&gt;(*this))
 242 #if ENABLE(REMOTE_INSPECTOR)
 243     , m_inspectorDebuggable(std::make_unique&lt;PageDebuggable&gt;(*this))
 244 #endif
 245     , m_socketProvider(WTFMove(pageConfiguration.socketProvider))
 246     , m_cookieJar(WTFMove(pageConfiguration.cookieJar))
 247     , m_applicationCacheStorage(*WTFMove(pageConfiguration.applicationCacheStorage))
 248     , m_cacheStorageProvider(WTFMove(pageConfiguration.cacheStorageProvider))
 249     , m_databaseProvider(*WTFMove(pageConfiguration.databaseProvider))
 250     , m_pluginInfoProvider(*WTFMove(pageConfiguration.pluginInfoProvider))
 251     , m_storageNamespaceProvider(*WTFMove(pageConfiguration.storageNamespaceProvider))
 252     , m_userContentProvider(*WTFMove(pageConfiguration.userContentProvider))
 253     , m_visitedLinkStore(*WTFMove(pageConfiguration.visitedLinkStore))
 254 #if ENABLE(INTERSECTION_OBSERVER)
 255     , m_intersectionObservationUpdateTimer(*this, &amp;Page::updateIntersectionObservations)
 256 #endif
 257     , m_sessionID(PAL::SessionID::defaultSessionID())
 258 #if ENABLE(VIDEO)
 259     , m_playbackControlsManagerUpdateTimer(*this, &amp;Page::playbackControlsManagerUpdateTimerFired)
 260 #endif
 261     , m_isUtilityPage(isUtilityPageChromeClient(chrome().client()))
 262     , m_performanceMonitor(isUtilityPage() ? nullptr : std::make_unique&lt;PerformanceMonitor&gt;(*this))
 263     , m_lowPowerModeNotifier(std::make_unique&lt;LowPowerModeNotifier&gt;([this](bool isLowPowerModeEnabled) { handleLowModePowerChange(isLowPowerModeEnabled); }))
 264     , m_performanceLogging(std::make_unique&lt;PerformanceLogging&gt;(*this))
 265 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
 266     , m_servicesOverlayController(std::make_unique&lt;ServicesOverlayController&gt;(*this))
 267 #endif
 268     , m_recentWheelEventDeltaFilter(WheelEventDeltaFilter::create())
 269     , m_pageOverlayController(std::make_unique&lt;PageOverlayController&gt;(*this))
 270 #if ENABLE(APPLE_PAY)
 271     , m_paymentCoordinator(std::make_unique&lt;PaymentCoordinator&gt;(*pageConfiguration.paymentCoordinatorClient))
 272 #endif
 273 #if ENABLE(WEB_AUTHN)
 274     , m_authenticatorCoordinator(makeUniqueRef&lt;AuthenticatorCoordinator&gt;(WTFMove(pageConfiguration.authenticatorCoordinatorClient)))
 275 #endif
 276 #if ENABLE(APPLICATION_MANIFEST)
 277     , m_applicationManifest(pageConfiguration.applicationManifest)
 278 #endif
 279 {
 280     updateTimerThrottlingState();
 281 
 282     m_pluginInfoProvider-&gt;addPage(*this);
 283     m_storageNamespaceProvider-&gt;addPage(*this);
 284     m_userContentProvider-&gt;addPage(*this);
 285     m_visitedLinkStore-&gt;addPage(*this);
 286 
 287     static bool addedListener;
 288     if (!addedListener) {
 289         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
 290         addedListener = true;
 291     }
 292 
 293     ASSERT(!allPages().contains(this));
 294     allPages().add(this);
 295 
 296     if (!isUtilityPage()) {
 297         ++nonUtilityPageCount;
 298         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 299     }
 300 
 301 #ifndef NDEBUG
 302     pageCounter.increment();
 303 #endif
 304 
 305 #if ENABLE(REMOTE_INSPECTOR)
 306     if (m_inspectorController-&gt;inspectorClient() &amp;&amp; m_inspectorController-&gt;inspectorClient()-&gt;allowRemoteInspectionToPageDirectly())
 307         m_inspectorDebuggable-&gt;init();
 308 #endif
 309 
 310 #if PLATFORM(COCOA)
 311     platformInitialize();
 312 #endif
 313 
 314 #if USE(LIBWEBRTC)
 315     m_libWebRTCProvider-&gt;supportsVP8(RuntimeEnabledFeatures::sharedFeatures().webRTCVP8CodecEnabled());
 316 #endif
 317 }
 318 
 319 Page::~Page()
 320 {
 321     ASSERT(!m_nestedRunLoopCount);
 322     ASSERT(!m_unnestCallback);
 323 
 324     m_validationMessageClient = nullptr;
 325     m_diagnosticLoggingClient = nullptr;
 326     m_performanceLoggingClient = nullptr;
 327     m_mainFrame-&gt;setView(nullptr);
 328     setGroupName(String());
 329     allPages().remove(this);
 330     if (!isUtilityPage()) {
 331         --nonUtilityPageCount;
 332         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 333     }
 334 
 335     m_settings-&gt;pageDestroyed();
 336 
 337     m_inspectorController-&gt;inspectedPageDestroyed();
 338 
 339     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 340         frame-&gt;willDetachPage();
 341         frame-&gt;detachFromPage();
 342     }
 343 
 344     if (m_plugInClient)
 345         m_plugInClient-&gt;pageDestroyed();
 346     if (m_alternativeTextClient)
 347         m_alternativeTextClient-&gt;pageDestroyed();
 348 
 349     if (m_scrollingCoordinator)
 350         m_scrollingCoordinator-&gt;pageDestroyed();
 351 
 352     backForward().close();
 353     if (!isUtilityPage())
 354         PageCache::singleton().removeAllItemsForPage(*this);
 355 
 356 #ifndef NDEBUG
 357     pageCounter.decrement();
 358 #endif
 359 
 360     m_pluginInfoProvider-&gt;removePage(*this);
 361     m_storageNamespaceProvider-&gt;removePage(*this);
 362     m_userContentProvider-&gt;removePage(*this);
 363     m_visitedLinkStore-&gt;removePage(*this);
 364 }
 365 
 366 void Page::clearPreviousItemFromAllPages(HistoryItem* item)
 367 {
 368     for (auto* page : allPages()) {
 369         auto&amp; controller = page-&gt;mainFrame().loader().history();
 370         if (item == controller.previousItem()) {
 371             controller.clearPreviousItem();
 372             return;
 373         }
 374     }
 375 }
 376 
 377 uint64_t Page::renderTreeSize() const
 378 {
 379     uint64_t total = 0;
 380     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 381         if (!frame-&gt;document() || !frame-&gt;document()-&gt;renderView())
 382             continue;
 383         total += frame-&gt;document()-&gt;renderView()-&gt;rendererCount();
 384     }
 385     return total;
 386 }
 387 
 388 OptionSet&lt;DisabledAdaptations&gt; Page::disabledAdaptations() const
 389 {
 390     if (mainFrame().document())
 391         return mainFrame().document()-&gt;disabledAdaptations();
 392 
 393     return { };
 394 }
 395 
 396 ViewportArguments Page::viewportArguments() const
 397 {
 398     return mainFrame().document() ? mainFrame().document()-&gt;viewportArguments() : ViewportArguments();
 399 }
 400 
 401 ScrollingCoordinator* Page::scrollingCoordinator()
 402 {
 403     if (!m_scrollingCoordinator &amp;&amp; m_settings-&gt;scrollingCoordinatorEnabled()) {
 404         m_scrollingCoordinator = chrome().client().createScrollingCoordinator(*this);
 405         if (!m_scrollingCoordinator)
 406             m_scrollingCoordinator = ScrollingCoordinator::create(this);
 407     }
 408 
 409     return m_scrollingCoordinator.get();
 410 }
 411 
 412 String Page::scrollingStateTreeAsText()
 413 {
 414     if (Document* document = m_mainFrame-&gt;document())
 415         document-&gt;updateLayout();
 416 
 417     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 418         return scrollingCoordinator-&gt;scrollingStateTreeAsText();
 419 
 420     return String();
 421 }
 422 
 423 String Page::synchronousScrollingReasonsAsText()
 424 {
 425     if (Document* document = m_mainFrame-&gt;document())
 426         document-&gt;updateLayout();
 427 
 428     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 429         return scrollingCoordinator-&gt;synchronousScrollingReasonsAsText();
 430 
 431     return String();
 432 }
 433 
 434 Ref&lt;DOMRectList&gt; Page::nonFastScrollableRects()
 435 {
 436     if (Document* document = m_mainFrame-&gt;document())
 437         document-&gt;updateLayout();
 438 
 439     Vector&lt;IntRect&gt; rects;
 440     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator()) {
 441         const EventTrackingRegions&amp; eventTrackingRegions = scrollingCoordinator-&gt;absoluteEventTrackingRegions();
 442         for (const auto&amp; synchronousEventRegion : eventTrackingRegions.eventSpecificSynchronousDispatchRegions)
 443             rects.appendVector(synchronousEventRegion.value.rects());
 444     }
 445 
 446     Vector&lt;FloatQuad&gt; quads(rects.size());
 447     for (size_t i = 0; i &lt; rects.size(); ++i)
 448         quads[i] = FloatRect(rects[i]);
 449 
 450     return DOMRectList::create(quads);
 451 }
 452 
 453 Ref&lt;DOMRectList&gt; Page::touchEventRectsForEvent(const String&amp; eventName)
 454 {
 455     if (Document* document = m_mainFrame-&gt;document()) {
 456         document-&gt;updateLayout();
 457 #if ENABLE(IOS_TOUCH_EVENTS)
 458         document-&gt;updateTouchEventRegions();
 459 #endif
 460     }
 461 
 462     Vector&lt;IntRect&gt; rects;
 463     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator()) {
 464         const EventTrackingRegions&amp; eventTrackingRegions = scrollingCoordinator-&gt;absoluteEventTrackingRegions();
 465         const auto&amp; region = eventTrackingRegions.eventSpecificSynchronousDispatchRegions.get(eventName);
 466         rects.appendVector(region.rects());
 467     }
 468 
 469     Vector&lt;FloatQuad&gt; quads(rects.size());
 470     for (size_t i = 0; i &lt; rects.size(); ++i)
 471         quads[i] = FloatRect(rects[i]);
 472 
 473     return DOMRectList::create(quads);
 474 }
 475 
 476 Ref&lt;DOMRectList&gt; Page::passiveTouchEventListenerRects()
 477 {
 478     if (Document* document = m_mainFrame-&gt;document()) {
 479         document-&gt;updateLayout();
 480 #if ENABLE(IOS_TOUCH_EVENTS)
 481         document-&gt;updateTouchEventRegions();
 482 #endif
 483     }
 484 
 485     Vector&lt;IntRect&gt; rects;
 486     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 487         rects.appendVector(scrollingCoordinator-&gt;absoluteEventTrackingRegions().asynchronousDispatchRegion.rects());
 488 
 489     Vector&lt;FloatQuad&gt; quads(rects.size());
 490     for (size_t i = 0; i &lt; rects.size(); ++i)
 491         quads[i] = FloatRect(rects[i]);
 492 
 493     return DOMRectList::create(quads);
 494 }
 495 
 496 bool Page::openedByDOM() const
 497 {
 498     return m_openedByDOM;
 499 }
 500 
 501 void Page::setOpenedByDOM()
 502 {
 503     m_openedByDOM = true;
 504 }
 505 
 506 void Page::goToItem(HistoryItem&amp; item, FrameLoadType type, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
 507 {
 508     // stopAllLoaders may end up running onload handlers, which could cause further history traversals that may lead to the passed in HistoryItem
 509     // being deref()-ed. Make sure we can still use it with HistoryController::goToItem later.
 510     Ref&lt;HistoryItem&gt; protector(item);
 511 
 512     auto&amp; frameLoader = m_mainFrame-&gt;loader();
 513     if (frameLoader.history().shouldStopLoadingForHistoryItem(item))
 514         m_mainFrame-&gt;loader().stopAllLoadersAndCheckCompleteness();
 515 
 516     m_mainFrame-&gt;loader().history().goToItem(item, type, shouldTreatAsContinuingLoad);
 517 }
 518 
 519 void Page::setGroupName(const String&amp; name)
 520 {
 521     if (m_group &amp;&amp; !m_group-&gt;name().isEmpty()) {
 522         ASSERT(m_group != m_singlePageGroup.get());
 523         ASSERT(!m_singlePageGroup);
 524         m_group-&gt;removePage(*this);
 525     }
 526 
 527     if (name.isEmpty())
 528         m_group = m_singlePageGroup.get();
 529     else {
 530         m_singlePageGroup = nullptr;
 531         m_group = PageGroup::pageGroup(name);
 532         m_group-&gt;addPage(*this);
 533     }
 534 }
 535 
 536 const String&amp; Page::groupName() const
 537 {
 538     return m_group ? m_group-&gt;name() : nullAtom().string();
 539 }
 540 
 541 void Page::initGroup()
 542 {
 543     ASSERT(!m_singlePageGroup);
 544     ASSERT(!m_group);
 545     m_singlePageGroup = std::make_unique&lt;PageGroup&gt;(*this);
 546     m_group = m_singlePageGroup.get();
 547 }
 548 
 549 void Page::updateStyleAfterChangeInEnvironment()
 550 {
 551     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 552         // If a change in the global environment has occurred, we need to
 553         // make sure all the properties a recomputed, therefore we invalidate
 554         // the properties cache.
 555         auto* document = frame-&gt;document();
 556         if (!document)
 557             continue;
 558 
 559         if (StyleResolver* styleResolver = document-&gt;styleScope().resolverIfExists())
 560             styleResolver-&gt;invalidateMatchedPropertiesCache();
 561         document-&gt;scheduleFullStyleRebuild();
 562         document-&gt;styleScope().didChangeStyleSheetEnvironment();
 563     }
 564 }
 565 
 566 void Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment()
 567 {
 568     for (auto* page : allPages())
 569         page-&gt;updateStyleAfterChangeInEnvironment();
 570 }
 571 
 572 void Page::setNeedsRecalcStyleInAllFrames()
 573 {
 574     // FIXME: Figure out what this function is actually trying to add in different call sites.
 575     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 576         if (Document* document = frame-&gt;document())
 577             document-&gt;styleScope().didChangeStyleSheetEnvironment();
 578     }
 579 }
 580 
 581 void Page::refreshPlugins(bool reload)
 582 {
 583     HashSet&lt;PluginInfoProvider*&gt; pluginInfoProviders;
 584 
 585     for (auto* page : allPages())
 586         pluginInfoProviders.add(&amp;page-&gt;pluginInfoProvider());
 587 
 588     for (auto&amp; pluginInfoProvider : pluginInfoProviders)
 589         pluginInfoProvider-&gt;refresh(reload);
 590 }
 591 
 592 PluginData&amp; Page::pluginData()
 593 {
 594     if (!m_pluginData)
 595         m_pluginData = PluginData::create(*this);
 596     return *m_pluginData;
 597 }
 598 
 599 void Page::clearPluginData()
 600 {
 601     m_pluginData = nullptr;
 602 }
 603 
 604 bool Page::showAllPlugins() const
 605 {
 606     if (m_showAllPlugins)
 607         return true;
 608 
 609     if (Document* document = mainFrame().document())
 610         return document-&gt;securityOrigin().isLocal();
 611 
 612     return false;
 613 }
 614 
 615 inline Optional&lt;std::pair&lt;MediaCanStartListener&amp;, Document&amp;&gt;&gt;  Page::takeAnyMediaCanStartListener()
 616 {
 617     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 618         if (!frame-&gt;document())
 619             continue;
 620         if (MediaCanStartListener* listener = frame-&gt;document()-&gt;takeAnyMediaCanStartListener())
 621             return { { *listener, *frame-&gt;document() } };
 622     }
 623     return WTF::nullopt;
 624 }
 625 
 626 void Page::setCanStartMedia(bool canStartMedia)
 627 {
 628     if (m_canStartMedia == canStartMedia)
 629         return;
 630 
 631     m_canStartMedia = canStartMedia;
 632 
 633     while (m_canStartMedia) {
 634         auto listener = takeAnyMediaCanStartListener();
 635         if (!listener)
 636             break;
 637         listener-&gt;first.mediaCanStart(listener-&gt;second);
 638     }
 639 }
 640 
 641 static Frame* incrementFrame(Frame* curr, bool forward, CanWrap canWrap, DidWrap* didWrap = nullptr)
 642 {
 643     return forward
 644         ? curr-&gt;tree().traverseNext(canWrap, didWrap)
 645         : curr-&gt;tree().traversePrevious(canWrap, didWrap);
 646 }
 647 
 648 bool Page::findString(const String&amp; target, FindOptions options, DidWrap* didWrap)
 649 {
 650     if (target.isEmpty())
 651         return false;
 652 
 653     CanWrap canWrap = options.contains(WrapAround) ? CanWrap::Yes : CanWrap::No;
 654     Frame* frame = &amp;focusController().focusedOrMainFrame();
 655     Frame* startFrame = frame;
 656     do {
 657         if (frame-&gt;editor().findString(target, (options - WrapAround) | StartInSelection)) {
 658             if (frame != startFrame)
 659                 startFrame-&gt;selection().clear();
 660             focusController().setFocusedFrame(frame);
 661             return true;
 662         }
 663         frame = incrementFrame(frame, !options.contains(Backwards), canWrap, didWrap);
 664     } while (frame &amp;&amp; frame != startFrame);
 665 
 666     // Search contents of startFrame, on the other side of the selection that we did earlier.
 667     // We cheat a bit and just research with wrap on
 668     if (canWrap == CanWrap::Yes &amp;&amp; !startFrame-&gt;selection().isNone()) {
 669         if (didWrap)
 670             *didWrap = DidWrap::Yes;
 671         bool found = startFrame-&gt;editor().findString(target, options | WrapAround | StartInSelection);
 672         focusController().setFocusedFrame(frame);
 673         return found;
 674     }
 675 
 676     return false;
 677 }
 678 
 679 void Page::findStringMatchingRanges(const String&amp; target, FindOptions options, int limit, Vector&lt;RefPtr&lt;Range&gt;&gt;&amp; matchRanges, int&amp; indexForSelection)
 680 {
 681     indexForSelection = 0;
 682 
 683     Frame* frame = &amp;mainFrame();
 684     Frame* frameWithSelection = nullptr;
 685     do {
 686         frame-&gt;editor().countMatchesForText(target, 0, options, limit ? (limit - matchRanges.size()) : 0, true, &amp;matchRanges);
 687         if (frame-&gt;selection().isRange())
 688             frameWithSelection = frame;
 689         frame = incrementFrame(frame, true, CanWrap::No);
 690     } while (frame);
 691 
 692     if (matchRanges.isEmpty())
 693         return;
 694 
 695     if (frameWithSelection) {
 696         indexForSelection = NoMatchAfterUserSelection;
 697         RefPtr&lt;Range&gt; selectedRange = frameWithSelection-&gt;selection().selection().firstRange();
 698         if (options.contains(Backwards)) {
 699             for (size_t i = matchRanges.size(); i &gt; 0; --i) {
 700                 auto result = selectedRange-&gt;compareBoundaryPoints(Range::END_TO_START, *matchRanges[i - 1]);
 701                 if (!result.hasException() &amp;&amp; result.releaseReturnValue() &gt; 0) {
 702                     indexForSelection = i - 1;
 703                     break;
 704                 }
 705             }
 706         } else {
 707             for (size_t i = 0, size = matchRanges.size(); i &lt; size; ++i) {
 708                 auto result = selectedRange-&gt;compareBoundaryPoints(Range::START_TO_END, *matchRanges[i]);
 709                 if (!result.hasException() &amp;&amp; result.releaseReturnValue() &lt; 0) {
 710                     indexForSelection = i;
 711                     break;
 712                 }
 713             }
 714         }
 715     } else {
 716         if (options.contains(Backwards))
 717             indexForSelection = matchRanges.size() - 1;
 718         else
 719             indexForSelection = 0;
 720     }
 721 }
 722 
 723 RefPtr&lt;Range&gt; Page::rangeOfString(const String&amp; target, Range* referenceRange, FindOptions options)
 724 {
 725     if (target.isEmpty())
 726         return nullptr;
 727 
 728     if (referenceRange &amp;&amp; referenceRange-&gt;ownerDocument().page() != this)
 729         return nullptr;
 730 
 731     CanWrap canWrap = options.contains(WrapAround) ? CanWrap::Yes : CanWrap::No;
 732     Frame* frame = referenceRange ? referenceRange-&gt;ownerDocument().frame() : &amp;mainFrame();
 733     Frame* startFrame = frame;
 734     do {
 735         if (RefPtr&lt;Range&gt; resultRange = frame-&gt;editor().rangeOfString(target, frame == startFrame ? referenceRange : 0, options - WrapAround))
 736             return resultRange;
 737 
 738         frame = incrementFrame(frame, !options.contains(Backwards), canWrap);
 739     } while (frame &amp;&amp; frame != startFrame);
 740 
 741     // Search contents of startFrame, on the other side of the reference range that we did earlier.
 742     // We cheat a bit and just search again with wrap on.
 743     if (canWrap == CanWrap::Yes &amp;&amp; referenceRange) {
 744         if (RefPtr&lt;Range&gt; resultRange = startFrame-&gt;editor().rangeOfString(target, referenceRange, options | WrapAround | StartInSelection))
 745             return resultRange;
 746     }
 747 
 748     return nullptr;
 749 }
 750 
 751 unsigned Page::findMatchesForText(const String&amp; target, FindOptions options, unsigned maxMatchCount, ShouldHighlightMatches shouldHighlightMatches, ShouldMarkMatches shouldMarkMatches)
 752 {
 753     if (target.isEmpty())
 754         return 0;
 755 
 756     unsigned matchCount = 0;
 757 
 758     Frame* frame = &amp;mainFrame();
 759     do {
 760         if (shouldMarkMatches == MarkMatches)
 761             frame-&gt;editor().setMarkedTextMatchesAreHighlighted(shouldHighlightMatches == HighlightMatches);
 762         matchCount += frame-&gt;editor().countMatchesForText(target, 0, options, maxMatchCount ? (maxMatchCount - matchCount) : 0, shouldMarkMatches == MarkMatches, 0);
 763         frame = incrementFrame(frame, true, CanWrap::No);
 764     } while (frame);
 765 
 766     return matchCount;
 767 }
 768 
 769 unsigned Page::markAllMatchesForText(const String&amp; target, FindOptions options, bool shouldHighlight, unsigned maxMatchCount)
 770 {
 771     return findMatchesForText(target, options, maxMatchCount, shouldHighlight ? HighlightMatches : DoNotHighlightMatches, MarkMatches);
 772 }
 773 
 774 unsigned Page::countFindMatches(const String&amp; target, FindOptions options, unsigned maxMatchCount)
 775 {
 776     return findMatchesForText(target, options, maxMatchCount, DoNotHighlightMatches, DoNotMarkMatches);
 777 }
 778 
 779 struct FindReplacementRange {
 780     RefPtr&lt;ContainerNode&gt; root;
 781     size_t location { notFound };
 782     size_t length { 0 };
 783 };
 784 
 785 static void replaceRanges(Page&amp; page, const Vector&lt;FindReplacementRange&gt;&amp; ranges, const String&amp; replacementText)
 786 {
 787     HashMap&lt;RefPtr&lt;ContainerNode&gt;, Vector&lt;FindReplacementRange&gt;&gt; rangesByContainerNode;
 788     for (auto&amp; range : ranges) {
 789         auto&amp; rangeList = rangesByContainerNode.ensure(range.root, [] {
 790             return Vector&lt;FindReplacementRange&gt; { };
 791         }).iterator-&gt;value;
 792 
 793         // Ensure that ranges are sorted by their end offsets, per editing container.
 794         auto endOffsetForRange = range.location + range.length;
 795         auto insertionIndex = rangeList.size();
 796         for (auto iterator = rangeList.rbegin(); iterator != rangeList.rend(); ++iterator) {
 797             auto endOffsetBeforeInsertionIndex = iterator-&gt;location + iterator-&gt;length;
 798             if (endOffsetForRange &gt;= endOffsetBeforeInsertionIndex)
 799                 break;
 800             insertionIndex--;
 801         }
 802         rangeList.insert(insertionIndex, range);
 803     }
 804 
 805     HashMap&lt;RefPtr&lt;Frame&gt;, unsigned&gt; frameToTraversalIndexMap;
 806     unsigned currentFrameTraversalIndex = 0;
 807     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 808         frameToTraversalIndexMap.set(frame, currentFrameTraversalIndex++);
 809 
 810     // Likewise, iterate backwards (in document and frame order) through editing containers that contain text matches,
 811     // so that we&#39;re consistent with our backwards iteration behavior per editing container when replacing text.
 812     auto containerNodesInOrderOfReplacement = copyToVector(rangesByContainerNode.keys());
 813     std::sort(containerNodesInOrderOfReplacement.begin(), containerNodesInOrderOfReplacement.end(), [frameToTraversalIndexMap] (auto&amp; firstNode, auto&amp; secondNode) {
 814         if (firstNode == secondNode)
 815             return false;
 816 
 817         auto firstFrame = makeRefPtr(firstNode-&gt;document().frame());
 818         if (!firstFrame)
 819             return true;
 820 
 821         auto secondFrame = makeRefPtr(secondNode-&gt;document().frame());
 822         if (!secondFrame)
 823             return false;
 824 
 825         if (firstFrame == secondFrame) {
 826             // comparePositions is used here instead of Node::compareDocumentPosition because some editing roots may exist inside shadow roots.
 827             return comparePositions({ firstNode.get(), Position::PositionIsBeforeChildren }, { secondNode.get(), Position::PositionIsBeforeChildren }) &gt; 0;
 828         }
 829         return frameToTraversalIndexMap.get(firstFrame) &gt; frameToTraversalIndexMap.get(secondFrame);
 830     });
 831 
 832     for (auto&amp; container : containerNodesInOrderOfReplacement) {
 833         auto frame = makeRefPtr(container-&gt;document().frame());
 834         if (!frame)
 835             continue;
 836 
 837         // Iterate backwards through ranges when replacing text, such that earlier text replacements don&#39;t clobber replacement ranges later on.
 838         auto&amp; ranges = rangesByContainerNode.find(container)-&gt;value;
 839         for (auto iterator = ranges.rbegin(); iterator != ranges.rend(); ++iterator) {
 840             auto range = TextIterator::rangeFromLocationAndLength(container.get(), iterator-&gt;location, iterator-&gt;length);
 841             if (!range || range-&gt;collapsed())
 842                 continue;
 843 
 844             frame-&gt;selection().setSelectedRange(range.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
 845             frame-&gt;editor().replaceSelectionWithText(replacementText, Editor::SelectReplacement::Yes, Editor::SmartReplace::No, EditAction::InsertReplacement);
 846         }
 847     }
 848 }
 849 
 850 uint32_t Page::replaceRangesWithText(const Vector&lt;Ref&lt;Range&gt;&gt;&amp; rangesToReplace, const String&amp; replacementText, bool selectionOnly)
 851 {
 852     // FIXME: In the future, we should respect the `selectionOnly` flag by checking whether each range being replaced is
 853     // contained within its frame&#39;s selection.
 854     UNUSED_PARAM(selectionOnly);
 855 
 856     Vector&lt;FindReplacementRange&gt; replacementRanges;
 857     replacementRanges.reserveInitialCapacity(rangesToReplace.size());
 858 
 859     for (auto&amp; range : rangesToReplace) {
 860         auto highestRoot = makeRefPtr(highestEditableRoot(range-&gt;startPosition()));
 861         if (!highestRoot || highestRoot != highestEditableRoot(range-&gt;endPosition()))
 862             continue;
 863 
 864         auto frame = makeRefPtr(highestRoot-&gt;document().frame());
 865         if (!frame)
 866             continue;
 867 
 868         size_t replacementLocation = notFound;
 869         size_t replacementLength = 0;
 870         if (!TextIterator::getLocationAndLengthFromRange(highestRoot.get(), range.ptr(), replacementLocation, replacementLength))
 871             continue;
 872 
 873         if (replacementLocation == notFound || !replacementLength)
 874             continue;
 875 
 876         replacementRanges.append({ WTFMove(highestRoot), replacementLocation, replacementLength });
 877     }
 878 
 879     replaceRanges(*this, replacementRanges, replacementText);
 880     return rangesToReplace.size();
 881 }
 882 
 883 uint32_t Page::replaceSelectionWithText(const String&amp; replacementText)
 884 {
 885     auto frame = makeRef(focusController().focusedOrMainFrame());
 886     auto selection = frame-&gt;selection().selection();
 887     if (!selection.isContentEditable())
 888         return 0;
 889 
 890     auto editAction = selection.isRange() ? EditAction::InsertReplacement : EditAction::Insert;
 891     frame-&gt;editor().replaceSelectionWithText(replacementText, Editor::SelectReplacement::Yes, Editor::SmartReplace::No, editAction);
 892     return 1;
 893 }
 894 
 895 void Page::unmarkAllTextMatches()
 896 {
 897     Frame* frame = &amp;mainFrame();
 898     do {
 899         frame-&gt;document()-&gt;markers().removeMarkers(DocumentMarker::TextMatch);
 900         frame = incrementFrame(frame, true, CanWrap::No);
 901     } while (frame);
 902 }
 903 
 904 const VisibleSelection&amp; Page::selection() const
 905 {
 906     return focusController().focusedOrMainFrame().selection().selection();
 907 }
 908 
 909 void Page::setDefersLoading(bool defers)
 910 {
 911     if (!m_settings-&gt;loadDeferringEnabled())
 912         return;
 913 
 914     if (m_settings-&gt;wantsBalancedSetDefersLoadingBehavior()) {
 915         ASSERT(defers || m_defersLoadingCallCount);
 916         if (defers &amp;&amp; ++m_defersLoadingCallCount &gt; 1)
 917             return;
 918         if (!defers &amp;&amp; --m_defersLoadingCallCount)
 919             return;
 920     } else {
 921         ASSERT(!m_defersLoadingCallCount);
 922         if (defers == m_defersLoading)
 923             return;
 924     }
 925 
 926     m_defersLoading = defers;
 927     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 928         frame-&gt;loader().setDefersLoading(defers);
 929 }
 930 
 931 void Page::clearUndoRedoOperations()
 932 {
 933     m_editorClient-&gt;clearUndoRedoOperations();
 934 }
 935 
 936 bool Page::inLowQualityImageInterpolationMode() const
 937 {
 938     return m_inLowQualityInterpolationMode;
 939 }
 940 
 941 void Page::setInLowQualityImageInterpolationMode(bool mode)
 942 {
 943     m_inLowQualityInterpolationMode = mode;
 944 }
 945 
 946 DiagnosticLoggingClient&amp; Page::diagnosticLoggingClient() const
 947 {
 948     if (!settings().diagnosticLoggingEnabled() || !m_diagnosticLoggingClient)
 949         return emptyDiagnosticLoggingClient();
 950     return *m_diagnosticLoggingClient;
 951 }
 952 
 953 void Page::setMediaVolume(float volume)
 954 {
 955     if (volume &lt; 0 || volume &gt; 1)
 956         return;
 957 
 958     if (m_mediaVolume == volume)
 959         return;
 960 
 961     m_mediaVolume = volume;
 962     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 963         if (!frame-&gt;document())
 964             continue;
 965         frame-&gt;document()-&gt;mediaVolumeDidChange();
 966     }
 967 }
 968 
 969 void Page::setZoomedOutPageScaleFactor(float scale)
 970 {
 971     if (m_zoomedOutPageScaleFactor == scale)
 972         return;
 973     m_zoomedOutPageScaleFactor = scale;
 974 
 975     mainFrame().deviceOrPageScaleFactorChanged();
 976 }
 977 
 978 void Page::setPageScaleFactor(float scale, const IntPoint&amp; origin, bool inStableState)
 979 {
 980     LOG(Viewports, &quot;Page::setPageScaleFactor %.2f - inStableState %d&quot;, scale, inStableState);
 981 
 982     Document* document = mainFrame().document();
 983     FrameView* view = document-&gt;view();
 984 
 985     if (scale == m_pageScaleFactor) {
 986         if (view &amp;&amp; view-&gt;scrollPosition() != origin) {
 987             if (!m_settings-&gt;delegatesPageScaling())
 988                 document-&gt;updateLayoutIgnorePendingStylesheets();
 989 
 990             if (!view-&gt;delegatesScrolling())
 991                 view-&gt;setScrollPosition(origin);
 992 #if USE(COORDINATED_GRAPHICS)
 993             else
 994                 view-&gt;requestScrollPositionUpdate(origin);
 995 #endif
 996         }
 997 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 998         if (inStableState) {
 999             for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1000                 if (!frame-&gt;document())
1001                     continue;
1002                 frame-&gt;document()-&gt;pageScaleFactorChangedAndStable();
1003             }
1004         }
1005 #endif
1006         return;
1007     }
1008 
1009     m_pageScaleFactor = scale;
1010 
1011     if (!m_settings-&gt;delegatesPageScaling()) {
1012         view-&gt;setNeedsLayoutAfterViewConfigurationChange();
1013         view-&gt;setNeedsCompositingGeometryUpdate();
1014 
1015         document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);
1016 
1017         // Transform change on RenderView doesn&#39;t trigger repaint on non-composited contents.
1018         mainFrame().view()-&gt;invalidateRect(IntRect(LayoutRect::infiniteRect()));
1019     }
1020 
1021     mainFrame().deviceOrPageScaleFactorChanged();
1022 
1023     if (view &amp;&amp; view-&gt;fixedElementsLayoutRelativeToFrame())
1024         view-&gt;setViewportConstrainedObjectsNeedLayout();
1025 
1026     if (view &amp;&amp; view-&gt;scrollPosition() != origin) {
1027         if (!m_settings-&gt;delegatesPageScaling() &amp;&amp; document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())
1028             view-&gt;layoutContext().layout();
1029 
1030         if (!view-&gt;delegatesScrolling())
1031             view-&gt;setScrollPosition(origin);
1032 #if USE(COORDINATED_GRAPHICS)
1033         else
1034             view-&gt;requestScrollPositionUpdate(origin);
1035 #endif
1036     }
1037 
1038 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1039     if (inStableState) {
1040         for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1041             if (!frame-&gt;document())
1042                 continue;
1043             frame-&gt;document()-&gt;pageScaleFactorChangedAndStable();
1044         }
1045     }
1046 #else
1047     UNUSED_PARAM(inStableState);
1048 #endif
1049 }
1050 
1051 void Page::setViewScaleFactor(float scale)
1052 {
1053     if (m_viewScaleFactor == scale)
1054         return;
1055 
1056     m_viewScaleFactor = scale;
1057     PageCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);
1058 }
1059 
1060 void Page::setDeviceScaleFactor(float scaleFactor)
1061 {
1062     ASSERT(scaleFactor &gt; 0);
1063     if (scaleFactor &lt;= 0)
1064         return;
1065 
1066     if (m_deviceScaleFactor == scaleFactor)
1067         return;
1068 
1069     m_deviceScaleFactor = scaleFactor;
1070     setNeedsRecalcStyleInAllFrames();
1071 
1072     mainFrame().deviceOrPageScaleFactorChanged();
1073     PageCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);
1074 
1075     pageOverlayController().didChangeDeviceScaleFactor();
1076 }
1077 
1078 void Page::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
1079 {
1080     if (m_userInterfaceLayoutDirection == userInterfaceLayoutDirection)
1081         return;
1082 
1083     m_userInterfaceLayoutDirection = userInterfaceLayoutDirection;
1084 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1085     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1086         if (!frame-&gt;document())
1087             continue;
1088         frame-&gt;document()-&gt;userInterfaceLayoutDirectionChanged();
1089     }
1090 #endif
1091 }
1092 
1093 #if ENABLE(VIDEO)
1094 void Page::updateMediaElementRateChangeRestrictions()
1095 {
1096     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
1097         mediaElement-&gt;updateRateChangeRestrictions();
1098 }
1099 #endif
1100 
1101 void Page::didStartProvisionalLoad()
1102 {
1103     if (m_performanceMonitor)
1104         m_performanceMonitor-&gt;didStartProvisionalLoad();
1105 }
1106 
1107 void Page::didFinishLoad()
1108 {
1109     resetRelevantPaintedObjectCounter();
1110 
1111     if (m_performanceMonitor)
1112         m_performanceMonitor-&gt;didFinishLoad();
1113 }
1114 
1115 void Page::willDisplayPage()
1116 {
1117 #if ENABLE(INTERSECTION_OBSERVER)
1118     updateIntersectionObservations();
1119 #endif
1120 }
1121 
1122 bool Page::isOnlyNonUtilityPage() const
1123 {
1124     return !isUtilityPage() &amp;&amp; nonUtilityPageCount == 1;
1125 }
1126 
1127 bool Page::isLowPowerModeEnabled() const
1128 {
1129     if (m_lowPowerModeEnabledOverrideForTesting)
1130         return m_lowPowerModeEnabledOverrideForTesting.value();
1131 
1132     return m_lowPowerModeNotifier-&gt;isLowPowerModeEnabled();
1133 }
1134 
1135 void Page::setLowPowerModeEnabledOverrideForTesting(Optional&lt;bool&gt; isEnabled)
1136 {
1137     m_lowPowerModeEnabledOverrideForTesting = isEnabled;
1138     handleLowModePowerChange(m_lowPowerModeEnabledOverrideForTesting.valueOr(false));
1139 }
1140 
1141 void Page::setTopContentInset(float contentInset)
1142 {
1143     if (m_topContentInset == contentInset)
1144         return;
1145 
1146     m_topContentInset = contentInset;
1147 
1148     if (FrameView* view = mainFrame().view())
1149         view-&gt;topContentInsetDidChange(m_topContentInset);
1150 }
1151 
1152 void Page::setShouldSuppressScrollbarAnimations(bool suppressAnimations)
1153 {
1154     if (suppressAnimations == m_suppressScrollbarAnimations)
1155         return;
1156 
1157     lockAllOverlayScrollbarsToHidden(suppressAnimations);
1158     m_suppressScrollbarAnimations = suppressAnimations;
1159 }
1160 
1161 void Page::lockAllOverlayScrollbarsToHidden(bool lockOverlayScrollbars)
1162 {
1163     FrameView* view = mainFrame().view();
1164     if (!view)
1165         return;
1166 
1167     view-&gt;lockOverlayScrollbarStateToHidden(lockOverlayScrollbars);
1168 
1169     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1170         FrameView* frameView = frame-&gt;view();
1171         if (!frameView)
1172             continue;
1173 
1174         const HashSet&lt;ScrollableArea*&gt;* scrollableAreas = frameView-&gt;scrollableAreas();
1175         if (!scrollableAreas)
1176             continue;
1177 
1178         for (auto&amp; scrollableArea : *scrollableAreas)
1179             scrollableArea-&gt;lockOverlayScrollbarStateToHidden(lockOverlayScrollbars);
1180     }
1181 }
1182 
1183 void Page::setVerticalScrollElasticity(ScrollElasticity elasticity)
1184 {
1185     if (m_verticalScrollElasticity == elasticity)
1186         return;
1187 
1188     m_verticalScrollElasticity = elasticity;
1189 
1190     if (FrameView* view = mainFrame().view())
1191         view-&gt;setVerticalScrollElasticity(elasticity);
1192 }
1193 
1194 void Page::setHorizontalScrollElasticity(ScrollElasticity elasticity)
1195 {
1196     if (m_horizontalScrollElasticity == elasticity)
1197         return;
1198 
1199     m_horizontalScrollElasticity = elasticity;
1200 
1201     if (FrameView* view = mainFrame().view())
1202         view-&gt;setHorizontalScrollElasticity(elasticity);
1203 }
1204 
1205 void Page::setPagination(const Pagination&amp; pagination)
1206 {
1207     if (m_pagination == pagination)
1208         return;
1209 
1210     m_pagination = pagination;
1211 
1212     setNeedsRecalcStyleInAllFrames();
1213 }
1214 
1215 void Page::setPaginationLineGridEnabled(bool enabled)
1216 {
1217     if (m_paginationLineGridEnabled == enabled)
1218         return;
1219 
1220     m_paginationLineGridEnabled = enabled;
1221 
1222     setNeedsRecalcStyleInAllFrames();
1223 }
1224 
1225 unsigned Page::pageCount() const
1226 {
1227     if (m_pagination.mode == Pagination::Unpaginated)
1228         return 0;
1229 
1230     if (Document* document = mainFrame().document())
1231         document-&gt;updateLayoutIgnorePendingStylesheets();
1232 
1233     RenderView* contentRenderer = mainFrame().contentRenderer();
1234     return contentRenderer ? contentRenderer-&gt;pageCount() : 0;
1235 }
1236 
1237 void Page::setIsInWindow(bool isInWindow)
1238 {
1239     setActivityState(isInWindow ? m_activityState | ActivityState::IsInWindow : m_activityState - ActivityState::IsInWindow);
1240 }
1241 
1242 void Page::setIsInWindowInternal(bool isInWindow)
1243 {
1244     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1245         if (FrameView* frameView = frame-&gt;view())
1246             frameView-&gt;setIsInWindow(isInWindow);
1247     }
1248 
1249     if (isInWindow)
1250         resumeAnimatingImages();
1251 }
1252 
1253 void Page::addActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1254 {
1255     m_activityStateChangeObservers.add(&amp;observer);
1256 }
1257 
1258 void Page::removeActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1259 {
1260     m_activityStateChangeObservers.remove(&amp;observer);
1261 }
1262 
1263 #if ENABLE(INTERSECTION_OBSERVER)
1264 void Page::addDocumentNeedingIntersectionObservationUpdate(Document&amp; document)
1265 {
1266     if (m_documentsNeedingIntersectionObservationUpdate.find(&amp;document) == notFound)
1267         m_documentsNeedingIntersectionObservationUpdate.append(makeWeakPtr(document));
1268 }
1269 
1270 void Page::updateIntersectionObservations()
1271 {
1272     m_intersectionObservationUpdateTimer.stop();
1273     for (const auto&amp; document : m_documentsNeedingIntersectionObservationUpdate) {
1274         if (document)
1275             document-&gt;updateIntersectionObservations();
1276     }
1277     m_documentsNeedingIntersectionObservationUpdate.clear();
1278 }
1279 
1280 void Page::scheduleForcedIntersectionObservationUpdate(Document&amp; document)
1281 {
1282     addDocumentNeedingIntersectionObservationUpdate(document);
1283     if (m_intersectionObservationUpdateTimer.isActive())
1284         return;
1285     m_intersectionObservationUpdateTimer.startOneShot(0_s);
1286 }
1287 #endif
1288 
1289 void Page::suspendScriptedAnimations()
1290 {
1291     m_scriptedAnimationsSuspended = true;
1292     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1293         if (frame-&gt;document())
1294             frame-&gt;document()-&gt;suspendScriptedAnimationControllerCallbacks();
1295     }
1296 }
1297 
1298 void Page::resumeScriptedAnimations()
1299 {
1300     m_scriptedAnimationsSuspended = false;
1301     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1302         if (frame-&gt;document())
1303             frame-&gt;document()-&gt;resumeScriptedAnimationControllerCallbacks();
1304     }
1305 }
1306 
1307 enum class ThrottlingReasonOperation { Add, Remove };
1308 static void updateScriptedAnimationsThrottlingReason(Page&amp; page, ThrottlingReasonOperation operation, ScriptedAnimationController::ThrottlingReason reason)
1309 {
1310     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1311         auto* document = frame-&gt;document();
1312         if (!document)
1313             continue;
1314         auto* scriptedAnimationController = document-&gt;scriptedAnimationController();
1315         if (!scriptedAnimationController)
1316             continue;
1317 
1318         if (operation == ThrottlingReasonOperation::Add)
1319             scriptedAnimationController-&gt;addThrottlingReason(reason);
1320         else
1321             scriptedAnimationController-&gt;removeThrottlingReason(reason);
1322     }
1323 }
1324 
1325 void Page::setIsVisuallyIdleInternal(bool isVisuallyIdle)
1326 {
1327     updateScriptedAnimationsThrottlingReason(*this, isVisuallyIdle ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::VisuallyIdle);
1328 }
1329 
1330 void Page::handleLowModePowerChange(bool isLowPowerModeEnabled)
1331 {
1332     updateScriptedAnimationsThrottlingReason(*this, isLowPowerModeEnabled ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::LowPowerMode);
1333     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1334         forEachDocument([&amp;] (Document&amp; document) {
1335             if (auto timeline = document.existingTimeline())
1336                 timeline-&gt;updateThrottlingState();
1337         });
1338     } else
1339         mainFrame().animation().updateThrottlingState();
1340     updateDOMTimerAlignmentInterval();
1341 }
1342 
1343 void Page::userStyleSheetLocationChanged()
1344 {
1345     // FIXME: Eventually we will move to a model of just being handed the sheet
1346     // text instead of loading the URL ourselves.
1347     URL url = m_settings-&gt;userStyleSheetLocation();
1348 
1349     // Allow any local file URL scheme to be loaded.
1350     if (SchemeRegistry::shouldTreatURLSchemeAsLocal(url.protocol().toStringWithoutCopying()))
1351         m_userStyleSheetPath = url.fileSystemPath();
1352     else
1353         m_userStyleSheetPath = String();
1354 
1355     m_didLoadUserStyleSheet = false;
1356     m_userStyleSheet = String();
1357     m_userStyleSheetModificationTime = WTF::nullopt;
1358 
1359     // Data URLs with base64-encoded UTF-8 style sheets are common. We can process them
1360     // synchronously and avoid using a loader.
1361     if (url.protocolIsData() &amp;&amp; url.string().startsWith(&quot;data:text/css;charset=utf-8;base64,&quot;)) {
1362         m_didLoadUserStyleSheet = true;
1363 
1364         Vector&lt;char&gt; styleSheetAsUTF8;
1365         if (base64Decode(decodeURLEscapeSequences(url.string().substring(35)), styleSheetAsUTF8, Base64IgnoreSpacesAndNewLines))
1366             m_userStyleSheet = String::fromUTF8(styleSheetAsUTF8.data(), styleSheetAsUTF8.size());
1367     }
1368 
1369     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1370         if (frame-&gt;document())
1371             frame-&gt;document()-&gt;extensionStyleSheets().updatePageUserSheet();
1372     }
1373 }
1374 
1375 const String&amp; Page::userStyleSheet() const
1376 {
1377     if (m_userStyleSheetPath.isEmpty())
1378         return m_userStyleSheet;
1379 
1380     auto modificationTime = FileSystem::getFileModificationTime(m_userStyleSheetPath);
1381     if (!modificationTime) {
1382         // The stylesheet either doesn&#39;t exist, was just deleted, or is
1383         // otherwise unreadable. If we&#39;ve read the stylesheet before, we should
1384         // throw away that data now as it no longer represents what&#39;s on disk.
1385         m_userStyleSheet = String();
1386         return m_userStyleSheet;
1387     }
1388 
1389     // If the stylesheet hasn&#39;t changed since the last time we read it, we can
1390     // just return the old data.
1391     if (m_didLoadUserStyleSheet &amp;&amp; (m_userStyleSheetModificationTime &amp;&amp; modificationTime.value() &lt;= m_userStyleSheetModificationTime.value()))
1392         return m_userStyleSheet;
1393 
1394     m_didLoadUserStyleSheet = true;
1395     m_userStyleSheet = String();
1396     m_userStyleSheetModificationTime = modificationTime;
1397 
1398     // FIXME: It would be better to load this asynchronously to avoid blocking
1399     // the process, but we will first need to create an asynchronous loading
1400     // mechanism that is not tied to a particular Frame. We will also have to
1401     // determine what our behavior should be before the stylesheet is loaded
1402     // and what should happen when it finishes loading, especially with respect
1403     // to when the load event fires, when Document::close is called, and when
1404     // layout/paint are allowed to happen.
1405     auto data = SharedBuffer::createWithContentsOfFile(m_userStyleSheetPath);
1406     if (!data)
1407         return m_userStyleSheet;
1408 
1409     m_userStyleSheet = TextResourceDecoder::create(&quot;text/css&quot;)-&gt;decodeAndFlush(data-&gt;data(), data-&gt;size());
1410 
1411     return m_userStyleSheet;
1412 }
1413 
1414 void Page::userAgentChanged()
1415 {
1416     for (auto* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {
1417         auto* window = frame-&gt;window();
1418         if (!window)
1419             continue;
1420         if (auto* navigator = window-&gt;optionalNavigator())
1421             navigator-&gt;userAgentChanged();
1422     }
1423 }
1424 
1425 void Page::invalidateStylesForAllLinks()
1426 {
1427     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {
1428         if (!frame-&gt;document())
1429             continue;
1430         frame-&gt;document()-&gt;visitedLinkState().invalidateStyleForAllLinks();
1431     }
1432 }
1433 
1434 void Page::invalidateStylesForLink(SharedStringHash linkHash)
1435 {
1436     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {
1437         if (!frame-&gt;document())
1438             continue;
1439         frame-&gt;document()-&gt;visitedLinkState().invalidateStyleForLink(linkHash);
1440     }
1441 }
1442 
1443 void Page::invalidateInjectedStyleSheetCacheInAllFrames()
1444 {
1445     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {
1446         Document* document = frame-&gt;document();
1447         if (!document)
1448             continue;
1449         document-&gt;extensionStyleSheets().invalidateInjectedStyleSheetCache();
1450     }
1451 }
1452 
1453 void Page::setDebugger(JSC::Debugger* debugger)
1454 {
1455     if (m_debugger == debugger)
1456         return;
1457 
1458     m_debugger = debugger;
1459 
1460     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
1461         frame-&gt;windowProxy().attachDebugger(m_debugger);
1462 }
1463 
1464 StorageNamespace* Page::sessionStorage(bool optionalCreate)
1465 {
1466     if (!m_sessionStorage &amp;&amp; optionalCreate)
1467         m_sessionStorage = m_storageNamespaceProvider-&gt;createSessionStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());
1468 
1469     return m_sessionStorage.get();
1470 }
1471 
1472 void Page::setSessionStorage(RefPtr&lt;StorageNamespace&gt;&amp;&amp; newStorage)
1473 {
1474     m_sessionStorage = WTFMove(newStorage);
1475 }
1476 
1477 StorageNamespace* Page::ephemeralLocalStorage(bool optionalCreate)
1478 {
1479     if (!m_ephemeralLocalStorage &amp;&amp; optionalCreate)
1480         m_ephemeralLocalStorage = m_storageNamespaceProvider-&gt;createEphemeralLocalStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());
1481 
1482     return m_ephemeralLocalStorage.get();
1483 }
1484 
1485 void Page::setEphemeralLocalStorage(RefPtr&lt;StorageNamespace&gt;&amp;&amp; newStorage)
1486 {
1487     m_ephemeralLocalStorage = WTFMove(newStorage);
1488 }
1489 
1490 bool Page::hasCustomHTMLTokenizerTimeDelay() const
1491 {
1492     return m_settings-&gt;maxParseDuration() != -1;
1493 }
1494 
1495 double Page::customHTMLTokenizerTimeDelay() const
1496 {
1497     ASSERT(m_settings-&gt;maxParseDuration() != -1);
1498     return m_settings-&gt;maxParseDuration();
1499 }
1500 
1501 void Page::setMemoryCacheClientCallsEnabled(bool enabled)
1502 {
1503     if (m_areMemoryCacheClientCallsEnabled == enabled)
1504         return;
1505 
1506     m_areMemoryCacheClientCallsEnabled = enabled;
1507     if (!enabled)
1508         return;
1509 
1510     for (RefPtr&lt;Frame&gt; frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
1511         frame-&gt;loader().tellClientAboutPastMemoryCacheLoads();
1512 }
1513 
1514 void Page::hiddenPageDOMTimerThrottlingStateChanged()
1515 {
1516     // Disable &amp; reengage to ensure state is updated.
1517     setTimerThrottlingState(TimerThrottlingState::Disabled);
1518     updateTimerThrottlingState();
1519 }
1520 
1521 void Page::updateTimerThrottlingState()
1522 {
1523     // Timer throttling disabled if page is visually active, or disabled by setting.
1524     if (!m_settings-&gt;hiddenPageDOMTimerThrottlingEnabled() || !(m_activityState &amp; ActivityState::IsVisuallyIdle)) {
1525         setTimerThrottlingState(TimerThrottlingState::Disabled);
1526         return;
1527     }
1528 
1529     // If the page is visible (but idle), there is any activity (loading, media playing, etc), or per setting,
1530     // we allow timer throttling, but not increasing timer throttling.
1531     if (!m_settings-&gt;hiddenPageDOMTimerThrottlingAutoIncreases()
1532         || m_activityState.containsAny({ActivityState::IsVisible, ActivityState::IsAudible, ActivityState::IsLoading, ActivityState::IsCapturingMedia })) {
1533         setTimerThrottlingState(TimerThrottlingState::Enabled);
1534         return;
1535     }
1536 
1537     // If we get here increasing timer throttling is enabled.
1538     setTimerThrottlingState(TimerThrottlingState::EnabledIncreasing);
1539 }
1540 
1541 void Page::setTimerThrottlingState(TimerThrottlingState state)
1542 {
1543     if (state == m_timerThrottlingState)
1544         return;
1545 
1546     m_timerThrottlingState = state;
1547     m_timerThrottlingStateLastChangedTime = MonotonicTime::now();
1548 
1549     updateDOMTimerAlignmentInterval();
1550 
1551     // When throttling is disabled, release all throttled timers.
1552     if (state == TimerThrottlingState::Disabled) {
1553         for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1554             if (auto* document = frame-&gt;document())
1555                 document-&gt;didChangeTimerAlignmentInterval();
1556         }
1557     }
1558 }
1559 
1560 void Page::setDOMTimerAlignmentIntervalIncreaseLimit(Seconds limit)
1561 {
1562     m_domTimerAlignmentIntervalIncreaseLimit = limit;
1563 
1564     // If (m_domTimerAlignmentIntervalIncreaseLimit &lt; m_domTimerAlignmentInterval) then we need
1565     // to update m_domTimerAlignmentInterval, if greater then need to restart the increase timer.
1566     if (m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing)
1567         updateDOMTimerAlignmentInterval();
1568 }
1569 
1570 void Page::updateDOMTimerAlignmentInterval()
1571 {
1572     bool needsIncreaseTimer = false;
1573 
1574     switch (m_timerThrottlingState) {
1575     case TimerThrottlingState::Disabled:
1576         m_domTimerAlignmentInterval = isLowPowerModeEnabled() ? DOMTimer::defaultAlignmentIntervalInLowPowerMode() : DOMTimer::defaultAlignmentInterval();
1577         break;
1578 
1579     case TimerThrottlingState::Enabled:
1580         m_domTimerAlignmentInterval = DOMTimer::hiddenPageAlignmentInterval();
1581         break;
1582 
1583     case TimerThrottlingState::EnabledIncreasing:
1584         // For pages in prerender state maximum throttling kicks in immediately.
1585         if (m_isPrerender)
1586             m_domTimerAlignmentInterval = m_domTimerAlignmentIntervalIncreaseLimit;
1587         else {
1588             ASSERT(!!m_timerThrottlingStateLastChangedTime);
1589             m_domTimerAlignmentInterval = MonotonicTime::now() - m_timerThrottlingStateLastChangedTime;
1590             // If we&#39;re below the limit, set the timer. If above, clamp to limit.
1591             if (m_domTimerAlignmentInterval &lt; m_domTimerAlignmentIntervalIncreaseLimit)
1592                 needsIncreaseTimer = true;
1593             else
1594                 m_domTimerAlignmentInterval = m_domTimerAlignmentIntervalIncreaseLimit;
1595         }
1596         // Alignment interval should not be less than DOMTimer::hiddenPageAlignmentInterval().
1597         m_domTimerAlignmentInterval = std::max(m_domTimerAlignmentInterval, DOMTimer::hiddenPageAlignmentInterval());
1598     }
1599 
1600     // If throttling is enabled, auto-increasing of throttling is enabled, and the auto-increase
1601     // limit has not yet been reached, and then arm the timer to consider an increase. Time to wait
1602     // between increases is equal to the current throttle time. Since alinment interval increases
1603     // exponentially, time between steps is exponential too.
1604     if (!needsIncreaseTimer)
1605         m_domTimerAlignmentIntervalIncreaseTimer.stop();
1606     else if (!m_domTimerAlignmentIntervalIncreaseTimer.isActive())
1607         m_domTimerAlignmentIntervalIncreaseTimer.startOneShot(m_domTimerAlignmentInterval);
1608 }
1609 
1610 void Page::domTimerAlignmentIntervalIncreaseTimerFired()
1611 {
1612     ASSERT(m_settings-&gt;hiddenPageDOMTimerThrottlingAutoIncreases());
1613     ASSERT(m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing);
1614     ASSERT(m_domTimerAlignmentInterval &lt; m_domTimerAlignmentIntervalIncreaseLimit);
1615 
1616     // Alignment interval is increased to equal the time the page has been throttled, to a limit.
1617     updateDOMTimerAlignmentInterval();
1618 }
1619 
1620 void Page::dnsPrefetchingStateChanged()
1621 {
1622     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1623         if (!frame-&gt;document())
1624             continue;
1625         frame-&gt;document()-&gt;initDNSPrefetch();
1626     }
1627 }
1628 
1629 Vector&lt;Ref&lt;PluginViewBase&gt;&gt; Page::pluginViews()
1630 {
1631     Vector&lt;Ref&lt;PluginViewBase&gt;&gt; views;
1632     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1633         auto* view = frame-&gt;view();
1634         if (!view)
1635             break;
1636         for (auto&amp; widget : view-&gt;children()) {
1637             if (is&lt;PluginViewBase&gt;(widget))
1638                 views.append(downcast&lt;PluginViewBase&gt;(widget.get()));
1639         }
1640     }
1641     return views;
1642 }
1643 
1644 void Page::storageBlockingStateChanged()
1645 {
1646     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1647         if (!frame-&gt;document())
1648             continue;
1649         frame-&gt;document()-&gt;storageBlockingStateDidChange();
1650     }
1651 
1652     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
1653     // from below storageBlockingStateChanged does not affect their lifetime.
1654     for (auto&amp; view : pluginViews())
1655         view-&gt;storageBlockingStateChanged();
1656 }
1657 
1658 void Page::enableLegacyPrivateBrowsing(bool privateBrowsingEnabled)
1659 {
1660     // Don&#39;t allow changing the legacy private browsing state if we have set a session ID.
1661     ASSERT(m_sessionID == PAL::SessionID::defaultSessionID() || m_sessionID == PAL::SessionID::legacyPrivateSessionID());
1662 
1663     setSessionID(privateBrowsingEnabled ? PAL::SessionID::legacyPrivateSessionID() : PAL::SessionID::defaultSessionID());
1664 }
1665 
1666 void Page::updateIsPlayingMedia(uint64_t sourceElementID)
1667 {
1668     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
1669     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1670         if (Document* document = frame-&gt;document())
1671             state |= document-&gt;mediaState();
1672     }
1673 
1674     if (state == m_mediaState)
1675         return;
1676 
1677     m_mediaState = state;
1678 
1679     chrome().client().isPlayingMediaDidChange(state, sourceElementID);
1680 }
1681 
1682 void Page::schedulePlaybackControlsManagerUpdate()
1683 {
1684 #if ENABLE(VIDEO)
1685     if (!m_playbackControlsManagerUpdateTimer.isActive())
1686         m_playbackControlsManagerUpdateTimer.startOneShot(0_s);
1687 #endif
1688 }
1689 
1690 #if ENABLE(VIDEO)
1691 void Page::playbackControlsManagerUpdateTimerFired()
1692 {
1693     if (auto bestMediaElement = HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose::ControlsManager))
1694         chrome().client().setUpPlaybackControlsManager(*bestMediaElement);
1695     else
1696         chrome().client().clearPlaybackControlsManager();
1697 }
1698 #endif
1699 
1700 void Page::setMuted(MediaProducer::MutedStateFlags muted)
1701 {
1702     if (m_mutedState == muted)
1703         return;
1704 
1705     m_mutedState = muted;
1706 
1707     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1708         if (!frame-&gt;document())
1709             continue;
1710         frame-&gt;document()-&gt;pageMutedStateDidChange();
1711     }
1712 }
1713 
1714 void Page::stopMediaCapture()
1715 {
1716 #if ENABLE(MEDIA_STREAM)
1717     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1718         if (!frame-&gt;document())
1719             continue;
1720 
1721         frame-&gt;document()-&gt;stopMediaCapture();
1722     }
1723 #endif
1724 }
1725 
1726 void Page::stopAllMediaPlayback()
1727 {
1728 #if ENABLE(VIDEO)
1729     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1730         if (auto* document = frame-&gt;document())
1731             document-&gt;stopAllMediaPlayback();
1732     }
1733 #endif
1734 }
1735 
1736 void Page::suspendAllMediaPlayback()
1737 {
1738 #if ENABLE(VIDEO)
1739     ASSERT(!m_mediaPlaybackIsSuspended);
1740     if (m_mediaPlaybackIsSuspended)
1741         return;
1742 
1743     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1744         if (auto* document = frame-&gt;document())
1745             document-&gt;suspendAllMediaPlayback();
1746     }
1747 
1748     m_mediaPlaybackIsSuspended = true;
1749 #endif
1750 }
1751 
1752 void Page::resumeAllMediaPlayback()
1753 {
1754 #if ENABLE(VIDEO)
1755     ASSERT(m_mediaPlaybackIsSuspended);
1756     if (!m_mediaPlaybackIsSuspended)
1757         return;
1758     m_mediaPlaybackIsSuspended = false;
1759 
1760     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1761         if (auto* document = frame-&gt;document())
1762             document-&gt;resumeAllMediaPlayback();
1763     }
1764 #endif
1765 }
1766 
1767 #if ENABLE(MEDIA_SESSION)
1768 void Page::handleMediaEvent(MediaEventType eventType)
1769 {
1770     switch (eventType) {
1771     case MediaEventType::PlayPause:
1772         MediaSessionManager::singleton().togglePlayback();
1773         break;
1774     case MediaEventType::TrackNext:
1775         MediaSessionManager::singleton().skipToNextTrack();
1776         break;
1777     case MediaEventType::TrackPrevious:
1778         MediaSessionManager::singleton().skipToPreviousTrack();
1779         break;
1780     }
1781 }
1782 
1783 void Page::setVolumeOfMediaElement(double volume, uint64_t elementID)
1784 {
1785     if (HTMLMediaElement* element = HTMLMediaElement::elementWithID(elementID))
1786         element-&gt;setVolume(volume, ASSERT_NO_EXCEPTION);
1787 }
1788 #endif
1789 
1790 #if !ASSERT_DISABLED
1791 void Page::checkSubframeCountConsistency() const
1792 {
1793     ASSERT(m_subframeCount &gt;= 0);
1794 
1795     int subframeCount = 0;
1796     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
1797         ++subframeCount;
1798 
1799     ASSERT(m_subframeCount + 1 == subframeCount);
1800 }
1801 #endif
1802 
1803 void Page::resumeAnimatingImages()
1804 {
1805     // Drawing models which cache painted content while out-of-window (WebKit2&#39;s composited drawing areas, etc.)
1806     // require that we repaint animated images to kickstart the animation loop.
1807     if (FrameView* view = mainFrame().view())
1808         view-&gt;resumeVisibleImageAnimationsIncludingSubframes();
1809 }
1810 
1811 void Page::setActivityState(OptionSet&lt;ActivityState::Flag&gt; activityState)
1812 {
1813     auto changed = m_activityState ^ activityState;
1814     if (!changed)
1815         return;
1816 
1817     auto oldActivityState = m_activityState;
1818 
1819     bool wasVisibleAndActive = isVisibleAndActive();
1820     m_activityState = activityState;
1821 
1822     m_focusController-&gt;setActivityState(activityState);
1823 
1824     if (changed &amp; ActivityState::IsVisible)
1825         setIsVisibleInternal(activityState.contains(ActivityState::IsVisible));
1826     if (changed &amp; ActivityState::IsInWindow)
1827         setIsInWindowInternal(activityState.contains(ActivityState::IsInWindow));
1828     if (changed &amp; ActivityState::IsVisuallyIdle)
1829         setIsVisuallyIdleInternal(activityState.contains(ActivityState::IsVisuallyIdle));
1830     if (changed &amp; ActivityState::WindowIsActive) {
1831         if (auto* view = m_mainFrame-&gt;view())
1832             view-&gt;updateTiledBackingAdaptiveSizing();
1833     }
1834 
1835     if (changed.containsAny({ActivityState::IsVisible, ActivityState::IsVisuallyIdle, ActivityState::IsAudible, ActivityState::IsLoading, ActivityState::IsCapturingMedia }))
1836         updateTimerThrottlingState();
1837 
1838     for (auto* observer : m_activityStateChangeObservers)
1839         observer-&gt;activityStateDidChange(oldActivityState, m_activityState);
1840 
1841     if (wasVisibleAndActive != isVisibleAndActive())
1842         PlatformMediaSessionManager::updateNowPlayingInfoIfNecessary();
1843 
1844     if (m_performanceMonitor)
1845         m_performanceMonitor-&gt;activityStateChanged(oldActivityState, activityState);
1846 }
1847 
1848 bool Page::isVisibleAndActive() const
1849 {
1850     return m_activityState.contains(ActivityState::IsVisible) &amp;&amp; m_activityState.contains(ActivityState::WindowIsActive);
1851 }
1852 
1853 bool Page::isWindowActive() const
1854 {
1855     return m_activityState.contains(ActivityState::WindowIsActive);
1856 }
1857 
1858 void Page::setIsVisible(bool isVisible)
1859 {
1860     auto state = m_activityState;
1861 
1862     if (isVisible) {
1863         state.remove(ActivityState::IsVisuallyIdle);
1864         state.add({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1865     } else {
1866         state.add(ActivityState::IsVisuallyIdle);
1867         state.remove({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1868     }
1869     setActivityState(state);
1870 }
1871 
1872 enum class SVGAnimationsState { Paused, Resumed };
1873 static inline void setSVGAnimationsState(Page&amp; page, SVGAnimationsState state)
1874 {
1875     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1876         auto* document = frame-&gt;document();
1877         if (!document)
1878             continue;
1879 
1880         if (!document-&gt;svgExtensions())
1881             continue;
1882 
1883         if (state == SVGAnimationsState::Paused)
1884             document-&gt;accessSVGExtensions().pauseAnimations();
1885         else
1886             document-&gt;accessSVGExtensions().unpauseAnimations();
1887     }
1888 }
1889 
1890 void Page::setIsVisibleInternal(bool isVisible)
1891 {
1892     // FIXME: The visibility state should be stored on the top-level document.
1893     // https://bugs.webkit.org/show_bug.cgi?id=116769
1894 
1895     if (isVisible) {
1896         m_isPrerender = false;
1897 
1898         resumeScriptedAnimations();
1899 #if PLATFORM(IOS_FAMILY)
1900         resumeDeviceMotionAndOrientationUpdates();
1901 #endif
1902 
1903         if (FrameView* view = mainFrame().view())
1904             view-&gt;show();
1905 
1906         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1907             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1908                 forEachDocument([&amp;] (Document&amp; document) {
1909                     if (auto* timeline = document.existingTimeline())
1910                         timeline-&gt;resumeAnimations();
1911                 });
1912             } else
1913                 mainFrame().animation().resumeAnimations();
1914         }
1915 
1916         setSVGAnimationsState(*this, SVGAnimationsState::Resumed);
1917 
1918         resumeAnimatingImages();
1919 
1920         if (m_navigationToLogWhenVisible) {
1921             logNavigation(m_navigationToLogWhenVisible.value());
1922             m_navigationToLogWhenVisible = WTF::nullopt;
1923         }
1924     }
1925 
1926     if (!isVisible) {
1927         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1928             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1929                 forEachDocument([&amp;] (Document&amp; document) {
1930                     if (auto* timeline = document.existingTimeline())
1931                         timeline-&gt;suspendAnimations();
1932                 });
1933             } else
1934                 mainFrame().animation().suspendAnimations();
1935         }
1936 
1937         setSVGAnimationsState(*this, SVGAnimationsState::Paused);
1938 
1939 #if PLATFORM(IOS_FAMILY)
1940         suspendDeviceMotionAndOrientationUpdates();
1941 #endif
1942 
1943         suspendScriptedAnimations();
1944 
1945         if (FrameView* view = mainFrame().view())
1946             view-&gt;hide();
1947     }
1948 
1949     Vector&lt;Ref&lt;Document&gt;&gt; documents;
1950     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
1951         documents.append(*frame-&gt;document());
1952 
1953     for (auto&amp; document : documents)
1954         document-&gt;visibilityStateChanged();
1955 }
1956 
1957 void Page::setIsPrerender()
1958 {
1959     m_isPrerender = true;
1960     updateDOMTimerAlignmentInterval();
1961 }
1962 
1963 VisibilityState Page::visibilityState() const
1964 {
1965     if (isVisible())
1966         return VisibilityState::Visible;
1967     if (m_isPrerender)
1968         return VisibilityState::Prerender;
1969     return VisibilityState::Hidden;
1970 }
1971 
1972 void Page::setHeaderHeight(int headerHeight)
1973 {
1974     if (headerHeight == m_headerHeight)
1975         return;
1976 
1977     m_headerHeight = headerHeight;
1978 
1979     FrameView* frameView = mainFrame().view();
1980     if (!frameView)
1981         return;
1982 
1983     RenderView* renderView = frameView-&gt;renderView();
1984     if (!renderView)
1985         return;
1986 
1987     frameView-&gt;setNeedsLayoutAfterViewConfigurationChange();
1988     frameView-&gt;setNeedsCompositingGeometryUpdate();
1989 }
1990 
1991 void Page::setFooterHeight(int footerHeight)
1992 {
1993     if (footerHeight == m_footerHeight)
1994         return;
1995 
1996     m_footerHeight = footerHeight;
1997 
1998     FrameView* frameView = mainFrame().view();
1999     if (!frameView)
2000         return;
2001 
2002     RenderView* renderView = frameView-&gt;renderView();
2003     if (!renderView)
2004         return;
2005 
2006     frameView-&gt;setNeedsLayoutAfterViewConfigurationChange();
2007     frameView-&gt;setNeedsCompositingGeometryUpdate();
2008 }
2009 
2010 void Page::incrementNestedRunLoopCount()
2011 {
2012     m_nestedRunLoopCount++;
2013 }
2014 
2015 void Page::decrementNestedRunLoopCount()
2016 {
2017     ASSERT(m_nestedRunLoopCount);
2018     if (m_nestedRunLoopCount &lt;= 0)
2019         return;
2020 
2021     m_nestedRunLoopCount--;
2022 
2023     if (!m_nestedRunLoopCount &amp;&amp; m_unnestCallback) {
2024         callOnMainThread([this] {
2025             if (insideNestedRunLoop())
2026                 return;
2027 
2028             // This callback may destruct the Page.
2029             if (m_unnestCallback) {
2030                 auto callback = WTFMove(m_unnestCallback);
2031                 callback();
2032             }
2033         });
2034     }
2035 }
2036 
2037 void Page::whenUnnested(WTF::Function&lt;void()&gt;&amp;&amp; callback)
2038 {
2039     ASSERT(!m_unnestCallback);
2040 
2041     m_unnestCallback = WTFMove(callback);
2042 }
2043 
2044 #if ENABLE(REMOTE_INSPECTOR)
2045 bool Page::remoteInspectionAllowed() const
2046 {
2047     return m_inspectorDebuggable-&gt;remoteDebuggingAllowed();
2048 }
2049 
2050 void Page::setRemoteInspectionAllowed(bool allowed)
2051 {
2052     m_inspectorDebuggable-&gt;setRemoteDebuggingAllowed(allowed);
2053 }
2054 
2055 String Page::remoteInspectionNameOverride() const
2056 {
2057     return m_inspectorDebuggable-&gt;nameOverride();
2058 }
2059 
2060 void Page::setRemoteInspectionNameOverride(const String&amp; name)
2061 {
2062     m_inspectorDebuggable-&gt;setNameOverride(name);
2063 }
2064 
2065 void Page::remoteInspectorInformationDidChange() const
2066 {
2067     m_inspectorDebuggable-&gt;update();
2068 }
2069 #endif
2070 
2071 void Page::addLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2072 {
2073     // In the future, we may want a function that replaces m_layoutMilestones instead of just adding to it.
2074     m_requestedLayoutMilestones.add(milestones);
2075 }
2076 
2077 void Page::removeLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2078 {
2079     m_requestedLayoutMilestones.remove(milestones);
2080 }
2081 
2082 Color Page::pageExtendedBackgroundColor() const
2083 {
2084     FrameView* frameView = mainFrame().view();
2085     if (!frameView)
2086         return Color();
2087 
2088     RenderView* renderView = frameView-&gt;renderView();
2089     if (!renderView)
2090         return Color();
2091 
2092     return renderView-&gt;compositor().rootExtendedBackgroundColor();
2093 }
2094 
2095 // These are magical constants that might be tweaked over time.
2096 static const double gMinimumPaintedAreaRatio = 0.1;
2097 static const double gMaximumUnpaintedAreaRatio = 0.04;
2098 
2099 bool Page::isCountingRelevantRepaintedObjects() const
2100 {
2101     return m_isCountingRelevantRepaintedObjects &amp;&amp; m_requestedLayoutMilestones.contains(DidHitRelevantRepaintedObjectsAreaThreshold);
2102 }
2103 
2104 void Page::startCountingRelevantRepaintedObjects()
2105 {
2106     // Reset everything in case we didn&#39;t hit the threshold last time.
2107     resetRelevantPaintedObjectCounter();
2108 
2109     m_isCountingRelevantRepaintedObjects = true;
2110 }
2111 
2112 void Page::resetRelevantPaintedObjectCounter()
2113 {
2114     m_isCountingRelevantRepaintedObjects = false;
2115     m_relevantUnpaintedRenderObjects.clear();
2116     m_topRelevantPaintedRegion = Region();
2117     m_bottomRelevantPaintedRegion = Region();
2118     m_relevantUnpaintedRegion = Region();
2119 }
2120 
2121 static LayoutRect relevantViewRect(RenderView* view)
2122 {
2123     LayoutRect viewRect = view-&gt;viewRect();
2124 
2125     float relevantViewRectWidth = 980;
2126 #if PLATFORM(WATCHOS)
2127     // FIXME(186051): Consider limiting the relevant rect width to the view width everywhere.
2128     relevantViewRectWidth = std::min&lt;float&gt;(viewRect.width().toFloat(), relevantViewRectWidth);
2129 #endif
2130 
2131     // DidHitRelevantRepaintedObjectsAreaThreshold is a LayoutMilestone intended to indicate that
2132     // a certain relevant amount of content has been drawn to the screen. This is the rect that
2133     // has been determined to be relevant in the context of this goal. We may choose to tweak
2134     // the rect over time, much like we may choose to tweak gMinimumPaintedAreaRatio and
2135     // gMaximumUnpaintedAreaRatio. But this seems to work well right now.
2136     LayoutRect relevantViewRect { 0, 0, relevantViewRectWidth, 1300 };
2137     // If the viewRect is wider than the relevantViewRect, center the relevantViewRect.
2138     if (viewRect.width() &gt; relevantViewRect.width())
2139         relevantViewRect.setX((viewRect.width() - relevantViewRect.width()) / 2);
2140 
2141     return relevantViewRect;
2142 }
2143 
2144 void Page::addRelevantRepaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2145 {
2146     if (!isCountingRelevantRepaintedObjects())
2147         return;
2148 
2149     // Objects inside sub-frames are not considered to be relevant.
2150     if (&amp;object-&gt;frame() != &amp;mainFrame())
2151         return;
2152 
2153     LayoutRect relevantRect = relevantViewRect(&amp;object-&gt;view());
2154 
2155     // The objects are only relevant if they are being painted within the viewRect().
2156     if (!objectPaintRect.intersects(snappedIntRect(relevantRect)))
2157         return;
2158 
2159     IntRect snappedPaintRect = snappedIntRect(objectPaintRect);
2160 
2161     // If this object was previously counted as an unpainted object, remove it from that HashSet
2162     // and corresponding Region. FIXME: This doesn&#39;t do the right thing if the objects overlap.
2163     if (m_relevantUnpaintedRenderObjects.remove(object))
2164         m_relevantUnpaintedRegion.subtract(snappedPaintRect);
2165 
2166     // Split the relevantRect into a top half and a bottom half. Making sure we have coverage in
2167     // both halves helps to prevent cases where we have a fully loaded menu bar or masthead with
2168     // no content beneath that.
2169     LayoutRect topRelevantRect = relevantRect;
2170     topRelevantRect.contract(LayoutSize(0_lu, relevantRect.height() / 2));
2171     LayoutRect bottomRelevantRect = topRelevantRect;
2172     bottomRelevantRect.setY(relevantRect.height() / 2);
2173 
2174     // If the rect straddles both Regions, split it appropriately.
2175     if (topRelevantRect.intersects(snappedPaintRect) &amp;&amp; bottomRelevantRect.intersects(snappedPaintRect)) {
2176         IntRect topIntersection = snappedPaintRect;
2177         topIntersection.intersect(snappedIntRect(topRelevantRect));
2178         m_topRelevantPaintedRegion.unite(topIntersection);
2179 
2180         IntRect bottomIntersection = snappedPaintRect;
2181         bottomIntersection.intersect(snappedIntRect(bottomRelevantRect));
2182         m_bottomRelevantPaintedRegion.unite(bottomIntersection);
2183     } else if (topRelevantRect.intersects(snappedPaintRect))
2184         m_topRelevantPaintedRegion.unite(snappedPaintRect);
2185     else
2186         m_bottomRelevantPaintedRegion.unite(snappedPaintRect);
2187 
2188     float topPaintedArea = m_topRelevantPaintedRegion.totalArea();
2189     float bottomPaintedArea = m_bottomRelevantPaintedRegion.totalArea();
2190     float viewArea = relevantRect.width() * relevantRect.height();
2191 
2192     float ratioThatIsPaintedOnTop = topPaintedArea / viewArea;
2193     float ratioThatIsPaintedOnBottom = bottomPaintedArea / viewArea;
2194     float ratioOfViewThatIsUnpainted = m_relevantUnpaintedRegion.totalArea() / viewArea;
2195 
2196     if (ratioThatIsPaintedOnTop &gt; (gMinimumPaintedAreaRatio / 2) &amp;&amp; ratioThatIsPaintedOnBottom &gt; (gMinimumPaintedAreaRatio / 2)
2197         &amp;&amp; ratioOfViewThatIsUnpainted &lt; gMaximumUnpaintedAreaRatio) {
2198         m_isCountingRelevantRepaintedObjects = false;
2199         resetRelevantPaintedObjectCounter();
2200         if (Frame* frame = &amp;mainFrame())
2201             frame-&gt;loader().didReachLayoutMilestone(DidHitRelevantRepaintedObjectsAreaThreshold);
2202     }
2203 }
2204 
2205 void Page::addRelevantUnpaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2206 {
2207     if (!isCountingRelevantRepaintedObjects())
2208         return;
2209 
2210     // The objects are only relevant if they are being painted within the relevantViewRect().
2211     if (!objectPaintRect.intersects(snappedIntRect(relevantViewRect(&amp;object-&gt;view()))))
2212         return;
2213 
2214     m_relevantUnpaintedRenderObjects.add(object);
2215     m_relevantUnpaintedRegion.unite(snappedIntRect(objectPaintRect));
2216 }
2217 
2218 void Page::suspendDeviceMotionAndOrientationUpdates()
2219 {
2220     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2221         if (Document* document = frame-&gt;document())
2222             document-&gt;suspendDeviceMotionAndOrientationUpdates();
2223     }
2224 }
2225 
2226 void Page::resumeDeviceMotionAndOrientationUpdates()
2227 {
2228     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2229         if (Document* document = frame-&gt;document())
2230             document-&gt;resumeDeviceMotionAndOrientationUpdates();
2231     }
2232 }
2233 
2234 void Page::suspendActiveDOMObjectsAndAnimations()
2235 {
2236     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2237         frame-&gt;suspendActiveDOMObjectsAndAnimations();
2238 }
2239 
2240 void Page::resumeActiveDOMObjectsAndAnimations()
2241 {
2242     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2243         frame-&gt;resumeActiveDOMObjectsAndAnimations();
2244 
2245     resumeAnimatingImages();
2246 }
2247 
2248 bool Page::hasSeenAnyPlugin() const
2249 {
2250     return !m_seenPlugins.isEmpty();
2251 }
2252 
2253 bool Page::hasSeenPlugin(const String&amp; serviceType) const
2254 {
2255     return m_seenPlugins.contains(serviceType);
2256 }
2257 
2258 void Page::sawPlugin(const String&amp; serviceType)
2259 {
2260     m_seenPlugins.add(serviceType);
2261 }
2262 
2263 void Page::resetSeenPlugins()
2264 {
2265     m_seenPlugins.clear();
2266 }
2267 
2268 bool Page::hasSeenAnyMediaEngine() const
2269 {
2270     return !m_seenMediaEngines.isEmpty();
2271 }
2272 
2273 bool Page::hasSeenMediaEngine(const String&amp; engineDescription) const
2274 {
2275     return m_seenMediaEngines.contains(engineDescription);
2276 }
2277 
2278 void Page::sawMediaEngine(const String&amp; engineDescription)
2279 {
2280     m_seenMediaEngines.add(engineDescription);
2281 }
2282 
2283 void Page::resetSeenMediaEngines()
2284 {
2285     m_seenMediaEngines.clear();
2286 }
2287 
2288 void Page::hiddenPageCSSAnimationSuspensionStateChanged()
2289 {
2290     if (!isVisible()) {
2291         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2292             forEachDocument([&amp;] (Document&amp; document) {
2293                 if (auto* timeline = document.existingTimeline()) {
2294                     if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2295                         timeline-&gt;suspendAnimations();
2296                     else
2297                         timeline-&gt;resumeAnimations();
2298                 }
2299             });
2300         } else {
2301             if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2302                 mainFrame().animation().suspendAnimations();
2303             else
2304                 mainFrame().animation().resumeAnimations();
2305         }
2306     }
2307 }
2308 
2309 #if ENABLE(VIDEO_TRACK)
2310 void Page::captionPreferencesChanged()
2311 {
2312     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2313         if (!frame-&gt;document())
2314             continue;
2315         frame-&gt;document()-&gt;captionPreferencesChanged();
2316     }
2317 }
2318 #endif
2319 
2320 void Page::forbidPrompts()
2321 {
2322     ++m_forbidPromptsDepth;
2323 }
2324 
2325 void Page::allowPrompts()
2326 {
2327     ASSERT(m_forbidPromptsDepth);
2328     --m_forbidPromptsDepth;
2329 }
2330 
2331 bool Page::arePromptsAllowed()
2332 {
2333     return !m_forbidPromptsDepth;
2334 }
2335 
2336 void Page::logNavigation(const Navigation&amp; navigation)
2337 {
2338     String navigationDescription;
2339     switch (navigation.type) {
2340     case FrameLoadType::Standard:
2341         navigationDescription = &quot;standard&quot;_s;
2342         break;
2343     case FrameLoadType::Back:
2344         navigationDescription = &quot;back&quot;_s;
2345         break;
2346     case FrameLoadType::Forward:
2347         navigationDescription = &quot;forward&quot;_s;
2348         break;
2349     case FrameLoadType::IndexedBackForward:
2350         navigationDescription = &quot;indexedBackForward&quot;_s;
2351         break;
2352     case FrameLoadType::Reload:
2353         navigationDescription = &quot;reload&quot;_s;
2354         break;
2355     case FrameLoadType::Same:
2356         navigationDescription = &quot;same&quot;_s;
2357         break;
2358     case FrameLoadType::ReloadFromOrigin:
2359         navigationDescription = &quot;reloadFromOrigin&quot;_s;
2360         break;
2361     case FrameLoadType::ReloadExpiredOnly:
2362         navigationDescription = &quot;reloadRevalidatingExpired&quot;_s;
2363         break;
2364     case FrameLoadType::Replace:
2365     case FrameLoadType::RedirectWithLockedBackForwardList:
2366         // Not logging those for now.
2367         return;
2368     }
2369     diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::navigationKey(), navigationDescription, ShouldSample::No);
2370 
2371     if (!navigation.domain.isEmpty())
2372         diagnosticLoggingClient().logDiagnosticMessageWithEnhancedPrivacy(DiagnosticLoggingKeys::domainVisitedKey(), navigation.domain, ShouldSample::Yes);
2373 }
2374 
2375 void Page::mainFrameLoadStarted(const URL&amp; destinationURL, FrameLoadType type)
2376 {
2377     String domain;
2378 #if ENABLE(PUBLIC_SUFFIX_LIST)
2379     domain = topPrivatelyControlledDomain(destinationURL.host().toString());
2380 #else
2381     UNUSED_PARAM(destinationURL);
2382 #endif
2383 
2384     Navigation navigation = { domain, type };
2385 
2386     // To avoid being too verbose, we only log navigations if the page is or becomes visible. This avoids logging non-user observable loads.
2387     if (!isVisible()) {
2388         m_navigationToLogWhenVisible = navigation;
2389         return;
2390     }
2391 
2392     m_navigationToLogWhenVisible = WTF::nullopt;
2393     logNavigation(navigation);
2394 }
2395 
2396 PluginInfoProvider&amp; Page::pluginInfoProvider()
2397 {
2398     return m_pluginInfoProvider;
2399 }
2400 
2401 UserContentProvider&amp; Page::userContentProvider()
2402 {
2403     return m_userContentProvider;
2404 }
2405 
2406 void Page::setUserContentProvider(Ref&lt;UserContentProvider&gt;&amp;&amp; userContentProvider)
2407 {
2408     m_userContentProvider-&gt;removePage(*this);
2409     m_userContentProvider = WTFMove(userContentProvider);
2410     m_userContentProvider-&gt;addPage(*this);
2411 
2412     invalidateInjectedStyleSheetCacheInAllFrames();
2413 }
2414 
2415 void Page::setStorageNamespaceProvider(Ref&lt;StorageNamespaceProvider&gt;&amp;&amp; storageNamespaceProvider)
2416 {
2417     m_storageNamespaceProvider-&gt;removePage(*this);
2418     m_storageNamespaceProvider = WTFMove(storageNamespaceProvider);
2419     m_storageNamespaceProvider-&gt;addPage(*this);
2420 
2421     // This needs to reset all the local storage namespaces of all the pages.
2422 }
2423 
2424 VisitedLinkStore&amp; Page::visitedLinkStore()
2425 {
2426     return m_visitedLinkStore;
2427 }
2428 
2429 void Page::setVisitedLinkStore(Ref&lt;VisitedLinkStore&gt;&amp;&amp; visitedLinkStore)
2430 {
2431     m_visitedLinkStore-&gt;removePage(*this);
2432     m_visitedLinkStore = WTFMove(visitedLinkStore);
2433     m_visitedLinkStore-&gt;addPage(*this);
2434 
2435     invalidateStylesForAllLinks();
2436 }
2437 
2438 PAL::SessionID Page::sessionID() const
2439 {
2440     return m_sessionID;
2441 }
2442 
2443 void Page::setSessionID(PAL::SessionID sessionID)
2444 {
2445     ASSERT(sessionID.isValid());
2446 
2447 #if ENABLE(INDEXED_DATABASE)
2448     if (sessionID != m_sessionID)
2449         m_idbConnectionToServer = nullptr;
2450 #endif
2451 
2452     bool privateBrowsingStateChanged = (sessionID.isEphemeral() != m_sessionID.isEphemeral());
2453 
2454     m_sessionID = sessionID;
2455 
2456     if (!privateBrowsingStateChanged)
2457         return;
2458 
2459     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2460         if (!frame-&gt;document())
2461             continue;
2462         frame-&gt;document()-&gt;privateBrowsingStateDidChange();
2463     }
2464 
2465     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
2466     // from below privateBrowsingStateChanged does not affect their lifetime.
2467 
2468     for (auto&amp; view : pluginViews())
2469         view-&gt;privateBrowsingStateChanged(sessionID.isEphemeral());
2470 }
2471 
2472 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2473 void Page::addPlaybackTargetPickerClient(uint64_t contextId)
2474 {
2475     chrome().client().addPlaybackTargetPickerClient(contextId);
2476 }
2477 
2478 void Page::removePlaybackTargetPickerClient(uint64_t contextId)
2479 {
2480     chrome().client().removePlaybackTargetPickerClient(contextId);
2481 }
2482 
2483 void Page::showPlaybackTargetPicker(uint64_t contextId, const WebCore::IntPoint&amp; location, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
2484 {
2485 #if PLATFORM(IOS_FAMILY)
2486     // FIXME: refactor iOS implementation.
2487     UNUSED_PARAM(contextId);
2488     UNUSED_PARAM(location);
2489     chrome().client().showPlaybackTargetPicker(isVideo, routeSharingPolicy, routingContextUID);
2490 #else
2491     UNUSED_PARAM(routeSharingPolicy);
2492     UNUSED_PARAM(routingContextUID);
2493     chrome().client().showPlaybackTargetPicker(contextId, location, isVideo);
2494 #endif
2495 }
2496 
2497 void Page::playbackTargetPickerClientStateDidChange(uint64_t contextId, MediaProducer::MediaStateFlags state)
2498 {
2499     chrome().client().playbackTargetPickerClientStateDidChange(contextId, state);
2500 }
2501 
2502 void Page::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
2503 {
2504     chrome().client().setMockMediaPlaybackTargetPickerEnabled(enabled);
2505 }
2506 
2507 void Page::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
2508 {
2509     chrome().client().setMockMediaPlaybackTargetPickerState(name, state);
2510 }
2511 
2512 void Page::setPlaybackTarget(uint64_t contextId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
2513 {
2514     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2515         if (!frame-&gt;document())
2516             continue;
2517         frame-&gt;document()-&gt;setPlaybackTarget(contextId, target.copyRef());
2518     }
2519 }
2520 
2521 void Page::playbackTargetAvailabilityDidChange(uint64_t contextId, bool available)
2522 {
2523     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2524         if (!frame-&gt;document())
2525             continue;
2526         frame-&gt;document()-&gt;playbackTargetAvailabilityDidChange(contextId, available);
2527     }
2528 }
2529 
2530 void Page::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
2531 {
2532     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2533         if (!frame-&gt;document())
2534             continue;
2535         frame-&gt;document()-&gt;setShouldPlayToPlaybackTarget(clientId, shouldPlay);
2536     }
2537 }
2538 #endif
2539 
2540 WheelEventTestTrigger&amp; Page::ensureTestTrigger()
2541 {
2542     if (!m_testTrigger) {
2543         m_testTrigger = adoptRef(new WheelEventTestTrigger());
2544         // We need to update the scrolling coordinator so that the mainframe scrolling node can expect wheel event test triggers.
2545         if (auto* frameView = mainFrame().view()) {
2546             if (m_scrollingCoordinator)
2547                 m_scrollingCoordinator-&gt;updateExpectsWheelEventTestTriggerWithFrameView(*frameView);
2548         }
2549     }
2550 
2551     return *m_testTrigger;
2552 }
2553 
2554 #if ENABLE(VIDEO)
2555 void Page::setAllowsMediaDocumentInlinePlayback(bool flag)
2556 {
2557     if (m_allowsMediaDocumentInlinePlayback == flag)
2558         return;
2559     m_allowsMediaDocumentInlinePlayback = flag;
2560 
2561     Vector&lt;Ref&lt;Document&gt;&gt; documents;
2562     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
2563         documents.append(*frame-&gt;document());
2564 
2565     for (auto&amp; document : documents)
2566         document-&gt;allowsMediaDocumentInlinePlaybackChanged();
2567 }
2568 #endif
2569 
2570 #if ENABLE(INDEXED_DATABASE)
2571 IDBClient::IDBConnectionToServer&amp; Page::idbConnection()
2572 {
2573     if (!m_idbConnectionToServer)
2574         m_idbConnectionToServer = &amp;databaseProvider().idbConnectionToServerForSession(m_sessionID);
2575 
2576     return *m_idbConnectionToServer;
2577 }
2578 
2579 IDBClient::IDBConnectionToServer* Page::optionalIDBConnection()
2580 {
2581     return m_idbConnectionToServer.get();
2582 }
2583 
2584 void Page::clearIDBConnection()
2585 {
2586     m_idbConnectionToServer = nullptr;
2587 }
2588 #endif
2589 
2590 #if ENABLE(RESOURCE_USAGE)
2591 void Page::setResourceUsageOverlayVisible(bool visible)
2592 {
2593     if (!visible) {
2594         m_resourceUsageOverlay = nullptr;
2595         return;
2596     }
2597 
2598     if (!m_resourceUsageOverlay &amp;&amp; m_settings-&gt;acceleratedCompositingEnabled())
2599         m_resourceUsageOverlay = std::make_unique&lt;ResourceUsageOverlay&gt;(*this);
2600 }
2601 #endif
2602 
2603 bool Page::isAlwaysOnLoggingAllowed() const
2604 {
2605     return m_sessionID.isAlwaysOnLoggingAllowed();
2606 }
2607 
2608 String Page::captionUserPreferencesStyleSheet()
2609 {
2610     return m_captionUserPreferencesStyleSheet;
2611 }
2612 
2613 void Page::setCaptionUserPreferencesStyleSheet(const String&amp; styleSheet)
2614 {
2615     if (m_captionUserPreferencesStyleSheet == styleSheet)
2616         return;
2617 
2618     m_captionUserPreferencesStyleSheet = styleSheet;
2619 }
2620 
2621 void Page::accessibilitySettingsDidChange()
2622 {
2623     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2624         if (auto* document = frame-&gt;document()) {
2625             document-&gt;styleScope().evaluateMediaQueriesForAccessibilitySettingsChange();
2626             document-&gt;evaluateMediaQueryList();
2627         }
2628     }
2629 }
2630 
2631 void Page::appearanceDidChange()
2632 {
2633     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2634         auto* document = frame-&gt;document();
2635         if (!document)
2636             continue;
2637 
2638         document-&gt;styleScope().didChangeStyleSheetEnvironment();
2639         document-&gt;styleScope().evaluateMediaQueriesForAppearanceChange();
2640         document-&gt;evaluateMediaQueryList();
2641     }
2642 }
2643 
2644 void Page::installedPageOverlaysChanged()
2645 {
2646     if (isInWindow()) {
2647         if (pageOverlayController().hasViewOverlays())
2648             chrome().client().attachViewOverlayGraphicsLayer(&amp;pageOverlayController().layerWithViewOverlays());
2649         else
2650             chrome().client().attachViewOverlayGraphicsLayer(nullptr);
2651     }
2652 
2653     if (auto* frameView = mainFrame().view())
2654         frameView-&gt;setNeedsCompositingConfigurationUpdate();
2655 }
2656 
2657 void Page::setUnobscuredSafeAreaInsets(const FloatBoxExtent&amp; insets)
2658 {
2659     if (m_unobscuredSafeAreaInsets == insets)
2660         return;
2661 
2662     m_unobscuredSafeAreaInsets = insets;
2663 
2664     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2665         if (!frame-&gt;document())
2666             continue;
2667         frame-&gt;document()-&gt;constantProperties().didChangeSafeAreaInsets();
2668     }
2669 }
2670 
2671 void Page::setUseSystemAppearance(bool value)
2672 {
2673     if (m_useSystemAppearance == value)
2674         return;
2675 
2676     m_useSystemAppearance = value;
2677 
2678     appearanceDidChange();
2679 
2680     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2681         auto* document = frame-&gt;document();
2682         if (!document)
2683             continue;
2684 
2685         // System apperance change may affect stylesheet parsing. We need to reparse.
2686         document-&gt;extensionStyleSheets().clearPageUserSheet();
2687         document-&gt;extensionStyleSheets().invalidateInjectedStyleSheetCache();
2688     }
2689 }
2690 
2691 void Page::setUseDarkAppearance(bool value)
2692 {
2693 #if HAVE(OS_DARK_MODE_SUPPORT)
2694     if (m_useDarkAppearance == value)
2695         return;
2696 
2697     m_useDarkAppearance = value;
2698 
2699     InspectorInstrumentation::defaultAppearanceDidChange(*this, value);
2700 
2701     appearanceDidChange();
2702 #else
2703     UNUSED_PARAM(value);
2704 #endif
2705 }
2706 
2707 bool Page::useDarkAppearance() const
2708 {
2709 #if HAVE(OS_DARK_MODE_SUPPORT)
2710     FrameView* view = mainFrame().view();
2711     if (!view || !equalLettersIgnoringASCIICase(view-&gt;mediaType(), &quot;screen&quot;))
2712         return false;
2713     if (m_useDarkAppearanceOverride)
2714         return m_useDarkAppearanceOverride.value();
2715     return m_useDarkAppearance;
2716 #else
2717     return false;
2718 #endif
2719 }
2720 
2721 void Page::setUseDarkAppearanceOverride(Optional&lt;bool&gt; valueOverride)
2722 {
2723 #if HAVE(OS_DARK_MODE_SUPPORT)
2724     if (valueOverride == m_useDarkAppearanceOverride)
2725         return;
2726 
2727     m_useDarkAppearanceOverride = valueOverride;
2728 
2729     appearanceDidChange();
2730 #else
2731     UNUSED_PARAM(valueOverride);
2732 #endif
2733 }
2734 
2735 void Page::setFullscreenInsets(const FloatBoxExtent&amp; insets)
2736 {
2737     if (insets == m_fullscreenInsets)
2738         return;
2739     m_fullscreenInsets = insets;
2740 
2741     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2742         if (!frame-&gt;document())
2743             continue;
2744         frame-&gt;document()-&gt;constantProperties().didChangeFullscreenInsets();
2745     }
2746 }
2747 
2748 void Page::setFullscreenAutoHideDuration(Seconds duration)
2749 {
2750     if (duration == m_fullscreenAutoHideDuration)
2751         return;
2752     m_fullscreenAutoHideDuration = duration;
2753     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2754         if (!frame-&gt;document())
2755             continue;
2756         frame-&gt;document()-&gt;constantProperties().setFullscreenAutoHideDuration(duration);
2757     }
2758 }
2759 
2760 void Page::setFullscreenControlsHidden(bool hidden)
2761 {
2762 #if ENABLE(FULLSCREEN_API)
2763     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2764         if (!frame-&gt;document())
2765             continue;
2766         frame-&gt;document()-&gt;setFullscreenControlsHidden(hidden);
2767     }
2768 #else
2769     UNUSED_PARAM(hidden);
2770 #endif
2771 }
2772 
2773 #if ENABLE(DATA_INTERACTION)
2774 
2775 bool Page::hasSelectionAtPosition(const FloatPoint&amp; position) const
2776 {
2777     auto currentSelection = m_mainFrame-&gt;selection().selection();
2778     if (!currentSelection.isRange())
2779         return false;
2780 
2781     if (auto selectedRange = currentSelection.toNormalizedRange()) {
2782         Vector&lt;SelectionRect&gt; selectionRects;
2783         selectedRange-&gt;collectSelectionRects(selectionRects);
2784         for (auto selectionRect : selectionRects) {
2785             if (FloatRect(selectionRect.rect()).contains(position))
2786                 return true;
2787         }
2788     }
2789 
2790     return false;
2791 }
2792 
2793 #endif
2794 
2795 void Page::disableICECandidateFiltering()
2796 {
2797     m_shouldEnableICECandidateFilteringByDefault = false;
2798 #if ENABLE(WEB_RTC)
2799     m_rtcController.disableICECandidateFilteringForAllOrigins();
2800 #endif
2801 }
2802 
2803 void Page::enableICECandidateFiltering()
2804 {
2805     m_shouldEnableICECandidateFilteringByDefault = true;
2806 #if ENABLE(WEB_RTC)
2807     m_rtcController.enableICECandidateFiltering();
2808 #endif
2809 }
2810 
2811 void Page::didChangeMainDocument()
2812 {
2813 #if ENABLE(WEB_RTC)
2814     m_rtcController.reset(m_shouldEnableICECandidateFilteringByDefault);
2815 #endif
2816 }
2817 
2818 void Page::forEachDocument(const Function&lt;void(Document&amp;)&gt;&amp; functor)
2819 {
2820     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2821         if (!frame-&gt;document())
2822             continue;
2823 
2824         functor(*frame-&gt;document());
2825     }
2826 }
2827 
2828 void Page::applicationWillResignActive()
2829 {
2830     forEachDocument([&amp;] (Document&amp; document) {
2831         document.forEachApplicationStateChangeListener([&amp;] (ApplicationStateChangeListener&amp; listener) {
2832             listener.applicationWillResignActive();
2833         });
2834     });
2835 }
2836 
2837 void Page::applicationDidEnterBackground()
2838 {
2839     m_libWebRTCProvider-&gt;setActive(false);
2840 }
2841 
2842 void Page::applicationWillEnterForeground()
2843 {
2844     m_libWebRTCProvider-&gt;setActive(true);
2845 }
2846 
2847 void Page::applicationDidBecomeActive()
2848 {
2849     forEachDocument([&amp;] (Document&amp; document) {
2850         document.forEachApplicationStateChangeListener([&amp;] (ApplicationStateChangeListener&amp; listener) {
2851             listener.applicationDidBecomeActive();
2852         });
2853     });
2854 }
2855 
2856 #if PLATFORM(MAC)
2857 ScrollLatchingState* Page::latchingState()
2858 {
2859     if (m_latchingState.isEmpty())
2860         return nullptr;
2861 
2862     return &amp;m_latchingState.last();
2863 }
2864 
2865 void Page::pushNewLatchingState()
2866 {
2867     m_latchingState.append(ScrollLatchingState());
2868 }
2869 
2870 void Page::resetLatchingState()
2871 {
2872     m_latchingState.clear();
2873 }
2874 
2875 void Page::popLatchingState()
2876 {
2877     m_latchingState.removeLast();
2878 }
2879 
2880 void Page::removeLatchingStateForTarget(Element&amp; targetNode)
2881 {
2882     if (m_latchingState.isEmpty())
2883         return;
2884 
2885     m_latchingState.removeAllMatching([&amp;targetNode] (ScrollLatchingState&amp; state) {
2886         auto* wheelElement = state.wheelEventElement();
2887         if (!wheelElement)
2888             return false;
2889 
2890         return targetNode.isEqualNode(wheelElement);
2891     });
2892 }
2893 #endif // PLATFORM(MAC)
2894 
2895 #if ENABLE(APPLE_PAY)
2896 void Page::setPaymentCoordinator(std::unique_ptr&lt;PaymentCoordinator&gt;&amp;&amp; paymentCoordinator)
2897 {
2898     m_paymentCoordinator = WTFMove(paymentCoordinator);
2899 }
2900 #endif
2901 
2902 } // namespace WebCore
    </pre>
  </body>
</html>