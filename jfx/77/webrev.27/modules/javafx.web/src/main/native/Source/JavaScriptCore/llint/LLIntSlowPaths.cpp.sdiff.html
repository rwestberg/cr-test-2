<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LLIntOfflineAsmConfig.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 #include &quot;LLIntPrototypeLoadAdaptiveStructureWatchpoint.h&quot;
  61 #include &quot;LowLevelInterpreter.h&quot;
  62 #include &quot;ModuleProgramCodeBlock.h&quot;
  63 #include &quot;ObjectConstructor.h&quot;
  64 #include &quot;ObjectPropertyConditionSet.h&quot;
  65 #include &quot;OpcodeInlines.h&quot;
  66 #include &quot;ProgramCodeBlock.h&quot;
  67 #include &quot;ProtoCallFrame.h&quot;
  68 #include &quot;RegExpObject.h&quot;
  69 #include &quot;ShadowChicken.h&quot;
  70 #include &quot;StructureRareDataInlines.h&quot;
  71 #include &quot;SuperSampler.h&quot;
  72 #include &quot;VMInlines.h&quot;
  73 #include &lt;wtf/NeverDestroyed.h&gt;
  74 #include &lt;wtf/StringPrintStream.h&gt;
  75 
  76 namespace JSC { namespace LLInt {
  77 
  78 #define LLINT_BEGIN_NO_SET_PC() \
  79     VM&amp; vm = exec-&gt;vm();      \
<span class="line-modified">  80     NativeCallFrameTracer tracer(&amp;vm, exec); \</span>
  81     auto throwScope = DECLARE_THROW_SCOPE(vm)
  82 
  83 #ifndef NDEBUG
  84 #define LLINT_SET_PC_FOR_STUBS() do { \
  85         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \
  86         exec-&gt;setCurrentVPC(pc); \
  87     } while (false)
  88 #else
  89 #define LLINT_SET_PC_FOR_STUBS() do { \
  90         exec-&gt;setCurrentVPC(pc); \
  91     } while (false)
  92 #endif
  93 
  94 #define LLINT_BEGIN()                           \
  95     LLINT_BEGIN_NO_SET_PC();                    \
  96     LLINT_SET_PC_FOR_STUBS()
  97 
  98 inline JSValue getNonConstantOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;uncheckedR(operand.offset()).jsValue(); }
  99 inline JSValue getOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;r(operand.offset()).jsValue(); }
 100 
</pre>
<hr />
<pre>
 340     }
 341     LLINT_END_IMPL();
 342 }
 343 
 344 enum EntryKind { Prologue, ArityCheck };
 345 
 346 #if ENABLE(JIT)
 347 static FunctionWhitelist&amp; ensureGlobalJITWhitelist()
 348 {
 349     static LazyNeverDestroyed&lt;FunctionWhitelist&gt; baselineWhitelist;
 350     static std::once_flag initializeWhitelistFlag;
 351     std::call_once(initializeWhitelistFlag, [] {
 352         const char* functionWhitelistFile = Options::jitWhitelist();
 353         baselineWhitelist.construct(functionWhitelistFile);
 354     });
 355     return baselineWhitelist;
 356 }
 357 
 358 inline bool shouldJIT(CodeBlock* codeBlock)
 359 {
<span class="line-modified"> 360     if (!Options::bytecodeRangeToJITCompile().isInRange(codeBlock-&gt;instructionCount())</span>
 361         || !ensureGlobalJITWhitelist().contains(codeBlock))
 362         return false;
 363 
 364     return VM::canUseJIT() &amp;&amp; Options::useBaselineJIT();
 365 }
 366 
 367 // Returns true if we should try to OSR.
 368 inline bool jitCompileAndSetHeuristics(CodeBlock* codeBlock, ExecState* exec, unsigned loopOSREntryBytecodeOffset = 0)
 369 {
 370     VM&amp; vm = exec-&gt;vm();
 371     DeferGCForAWhile deferGC(vm.heap); // My callers don&#39;t set top callframe, so we don&#39;t want to GC here at all.
 372     ASSERT(VM::canUseJIT());
 373 
 374     codeBlock-&gt;updateAllValueProfilePredictions();
 375 
 376     if (!codeBlock-&gt;checkIfJITThresholdReached()) {
 377         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayJITCompile&quot;, (&quot;threshold not reached, counter = &quot;, codeBlock-&gt;llintExecuteCounter()));
 378         if (Options::verboseOSR())
 379             dataLogF(&quot;    JIT threshold should be lifted.\n&quot;);
 380         return false;
 381     }
 382 
 383     JITWorklist::ensureGlobalWorklist().poll(vm);
 384 
 385     switch (codeBlock-&gt;jitType()) {
<span class="line-modified"> 386     case JITCode::BaselineJIT: {</span>
 387         if (Options::verboseOSR())
 388             dataLogF(&quot;    Code was already compiled.\n&quot;);
 389         codeBlock-&gt;jitSoon();
 390         return true;
 391     }
<span class="line-modified"> 392     case JITCode::InterpreterThunk: {</span>
 393         JITWorklist::ensureGlobalWorklist().compileLater(codeBlock, loopOSREntryBytecodeOffset);
<span class="line-modified"> 394         return codeBlock-&gt;jitType() == JITCode::BaselineJIT;</span>
 395     }
 396     default:
 397         dataLog(&quot;Unexpected code block in LLInt: &quot;, *codeBlock, &quot;\n&quot;);
 398         RELEASE_ASSERT_NOT_REACHED();
 399         return false;
 400     }
 401 }
 402 
 403 static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char *name, EntryKind kind)
 404 {
 405     if (Options::verboseOSR()) {
 406         dataLog(
 407             *codeBlock, &quot;: Entered &quot;, name, &quot; with executeCounter = &quot;,
 408             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);
 409     }
 410 
 411     if (!shouldJIT(codeBlock)) {
 412         codeBlock-&gt;dontJITAnytimeSoon();
 413         LLINT_RETURN_TWO(0, 0);
 414     }
</pre>
<hr />
<pre>
 463 
 464 #if ENABLE(JIT)
 465     if (Options::verboseOSR()) {
 466         dataLog(
 467             *codeBlock, &quot;: Entered loop_osr with executeCounter = &quot;,
 468             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);
 469     }
 470 
 471     unsigned loopOSREntryBytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);
 472 
 473     if (!shouldJIT(codeBlock)) {
 474         codeBlock-&gt;dontJITAnytimeSoon();
 475         LLINT_RETURN_TWO(0, 0);
 476     }
 477 
 478     if (!jitCompileAndSetHeuristics(codeBlock, exec, loopOSREntryBytecodeOffset))
 479         LLINT_RETURN_TWO(0, 0);
 480 
 481     CODEBLOCK_LOG_EVENT(codeBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, loopOSREntryBytecodeOffset));
 482 
<span class="line-modified"> 483     ASSERT(codeBlock-&gt;jitType() == JITCode::BaselineJIT);</span>
 484 
 485     const JITCodeMap&amp; codeMap = codeBlock-&gt;jitCodeMap();
 486     CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(loopOSREntryBytecodeOffset);
 487     ASSERT(codeLocation);
 488 
 489     void* jumpTarget = codeLocation.executableAddress();
 490     ASSERT(jumpTarget);
 491 
 492     LLINT_RETURN_TWO(jumpTarget, exec-&gt;topOfFrame());
 493 #else // ENABLE(JIT)
 494     UNUSED_PARAM(pc);
 495     codeBlock-&gt;dontJITAnytimeSoon();
 496     LLINT_RETURN_TWO(0, 0);
 497 #endif // ENABLE(JIT)
 498 }
 499 
 500 LLINT_SLOW_PATH_DECL(replace)
 501 {
 502     LLINT_BEGIN_NO_SET_PC();
 503     UNUSED_PARAM(throwScope);
</pre>
<hr />
<pre>
 512 
 513     if (shouldJIT(codeBlock))
 514         jitCompileAndSetHeuristics(codeBlock, exec);
 515     else
 516         codeBlock-&gt;dontJITAnytimeSoon();
 517     LLINT_END_IMPL();
 518 #else // ENABLE(JIT)
 519     codeBlock-&gt;dontJITAnytimeSoon();
 520     LLINT_END_IMPL();
 521 #endif // ENABLE(JIT)
 522 }
 523 
 524 LLINT_SLOW_PATH_DECL(stack_check)
 525 {
 526     VM&amp; vm = exec-&gt;vm();
 527     auto throwScope = DECLARE_THROW_SCOPE(vm);
 528 
 529     // It&#39;s ok to create the NativeCallFrameTracer here before we
 530     // convertToStackOverflowFrame() because this function is always called
 531     // after the frame has been propulated with a proper CodeBlock and callee.
<span class="line-modified"> 532     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 533 
 534     LLINT_SET_PC_FOR_STUBS();
 535 
 536     CodeBlock* codeBlock = exec-&gt;codeBlock();
 537     slowPathLogF(&quot;Checking stack height with exec = %p.\n&quot;, exec);
 538     slowPathLog(&quot;CodeBlock = &quot;, codeBlock, &quot;\n&quot;);
 539     if (codeBlock) {
 540         slowPathLogF(&quot;Num callee registers = %u.\n&quot;, codeBlock-&gt;numCalleeLocals());
 541         slowPathLogF(&quot;Num vars = %u.\n&quot;, codeBlock-&gt;numVars());
 542     }
 543     slowPathLogF(&quot;Current OS stack end is at %p.\n&quot;, vm.softStackLimit());
 544 #if ENABLE(C_LOOP)
 545     slowPathLogF(&quot;Current C Loop stack end is at %p.\n&quot;, vm.cloopStackLimit());
 546 #endif
 547 
 548     // If the stack check succeeds and we don&#39;t need to throw the error, then
 549     // we&#39;ll return 0 instead. The prologue will check for a non-zero value
 550     // when determining whether to set the callFrame or not.
 551 
 552     // For JIT enabled builds which uses the C stack, the stack is not growable.
</pre>
<hr />
<pre>
 660         {
 661             StructureID oldStructureID = metadata.m_structureID;
 662             if (oldStructureID) {
 663                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 664                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 665 
 666                 if (Structure::shouldConvertToPolyProto(a, b)) {
 667                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 668                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 669                 }
 670             }
 671         }
 672 
 673         JSCell* baseCell = baseValue.asCell();
 674         Structure* structure = baseCell-&gt;structure(vm);
 675         if (slot.isValue()) {
 676             // Start out by clearing out the old cache.
 677             metadata.m_structureID = 0;
 678             metadata.m_offset = 0;
 679 
<span class="line-modified"> 680             if (structure-&gt;propertyAccessesAreCacheable()</span>
<span class="line-modified"> 681                 &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>




 682                 vm.heap.writeBarrier(codeBlock);
<span class="line-removed"> 683 </span>
<span class="line-removed"> 684                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed"> 685 </span>
<span class="line-removed"> 686                 metadata.m_structureID = structure-&gt;id();</span>
<span class="line-removed"> 687                 metadata.m_offset = slot.cachedOffset();</span>
 688             }
 689         }
 690     }
 691 
 692     LLINT_RETURN_PROFILED(result);
 693 }
 694 
 695 
 696 static void setupGetByIdPrototypeCache(ExecState* exec, VM&amp; vm, const Instruction* pc, OpGetById::Metadata&amp; metadata, JSCell* baseCell, PropertySlot&amp; slot, const Identifier&amp; ident)
 697 {
 698     CodeBlock* codeBlock = exec-&gt;codeBlock();
 699     Structure* structure = baseCell-&gt;structure(vm);
 700 
 701     if (structure-&gt;typeInfo().prohibitsPropertyCaching())
 702         return;
 703 
 704     if (structure-&gt;needImpurePropertyWatchpoint())
 705         return;
 706 
 707     if (structure-&gt;isDictionary()) {
 708         if (structure-&gt;hasBeenFlattenedBefore())
 709             return;
 710         structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
 711     }
 712 
 713     ObjectPropertyConditionSet conditions;
 714     if (slot.isUnset())
 715         conditions = generateConditionsForPropertyMiss(vm, codeBlock, exec, structure, ident.impl());
 716     else
 717         conditions = generateConditionsForPrototypePropertyHit(vm, codeBlock, exec, structure, slot.slotBase(), ident.impl());
 718 
 719     if (!conditions.isValid())
 720         return;
 721 

 722     PropertyOffset offset = invalidOffset;
 723     CodeBlock::StructureWatchpointMap&amp; watchpointMap = codeBlock-&gt;llintGetByIdWatchpointMap();
<span class="line-modified"> 724     Bag&lt;LLIntPrototypeLoadAdaptiveStructureWatchpoint&gt; watchpoints;</span>

 725     for (ObjectPropertyCondition condition : conditions) {
 726         if (!condition.isWatchable())
 727             return;
 728         if (condition.condition().kind() == PropertyCondition::Presence)
 729             offset = condition.condition().offset();
<span class="line-modified"> 730         watchpoints.add(condition, metadata)-&gt;install(vm);</span>

 731     }
 732 
 733     ASSERT((offset == invalidOffset) == slot.isUnset());
<span class="line-modified"> 734     auto result = watchpointMap.add(std::make_tuple(structure, pc), WTFMove(watchpoints));</span>
 735     ASSERT_UNUSED(result, result.isNewEntry);
 736 
<span class="line-modified"> 737     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-modified"> 738 </span>
<span class="line-modified"> 739     if (slot.isUnset()) {</span>
<span class="line-modified"> 740         metadata.m_mode = GetByIdMode::Unset;</span>
<span class="line-modified"> 741         metadata.m_modeMetadata.unsetMode.structureID = structure-&gt;id();</span>
<span class="line-modified"> 742         return;</span>


 743     }
<span class="line-modified"> 744     ASSERT(slot.isValue());</span>
<span class="line-removed"> 745 </span>
<span class="line-removed"> 746     metadata.m_mode = GetByIdMode::ProtoLoad;</span>
<span class="line-removed"> 747     metadata.m_modeMetadata.protoLoadMode.structureID = structure-&gt;id();</span>
<span class="line-removed"> 748     metadata.m_modeMetadata.protoLoadMode.cachedOffset = offset;</span>
<span class="line-removed"> 749     metadata.m_modeMetadata.protoLoadMode.cachedSlot = slot.slotBase();</span>
<span class="line-removed"> 750     // We know that this pointer will remain valid because it will be cleared by either a watchpoint fire or</span>
<span class="line-removed"> 751     // during GC when we clear the LLInt caches.</span>
<span class="line-removed"> 752     metadata.m_modeMetadata.protoLoadMode.cachedSlot = slot.slotBase();</span>
 753 }
 754 
 755 
 756 LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
 757 {
 758     LLINT_BEGIN();
 759     auto bytecode = pc-&gt;as&lt;OpGetById&gt;();
 760     auto&amp; metadata = bytecode.metadata(exec);
 761     CodeBlock* codeBlock = exec-&gt;codeBlock();
 762     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 763     JSValue baseValue = getOperand(exec, bytecode.m_base);
 764     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::Get);
 765 
 766     JSValue result = baseValue.get(exec, ident, slot);
 767     LLINT_CHECK_EXCEPTION();
 768     exec-&gt;uncheckedR(bytecode.m_dst) = result;
 769 
 770     if (!LLINT_ALWAYS_ACCESS_SLOW
 771         &amp;&amp; baseValue.isCell()
 772         &amp;&amp; slot.isCacheable()) {
 773         {
 774             StructureID oldStructureID;
<span class="line-modified"> 775             auto mode = metadata.m_mode;</span>
<span class="line-removed"> 776             switch (mode) {</span>
 777             case GetByIdMode::Default:
 778                 oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
 779                 break;
 780             case GetByIdMode::Unset:
 781                 oldStructureID = metadata.m_modeMetadata.unsetMode.structureID;
 782                 break;
 783             case GetByIdMode::ProtoLoad:
 784                 oldStructureID = metadata.m_modeMetadata.protoLoadMode.structureID;
 785                 break;
 786             default:
 787                 oldStructureID = 0;
 788             }
 789             if (oldStructureID) {
 790                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 791                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 792 
 793                 if (Structure::shouldConvertToPolyProto(a, b)) {
 794                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 795                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 796                 }
 797             }
 798         }
 799 
 800         JSCell* baseCell = baseValue.asCell();
 801         Structure* structure = baseCell-&gt;structure(vm);
 802         if (slot.isValue() &amp;&amp; slot.slotBase() == baseValue) {

 803             // Start out by clearing out the old cache.
<span class="line-modified"> 804             metadata.m_mode = GetByIdMode::Default;</span>
<span class="line-removed"> 805             metadata.m_modeMetadata.defaultMode.structureID = 0;</span>
<span class="line-removed"> 806             metadata.m_modeMetadata.defaultMode.cachedOffset = 0;</span>
 807 
 808             // Prevent the prototype cache from ever happening.
<span class="line-modified"> 809             metadata.m_hitCountForLLIntCaching = 0;</span>
<span class="line-removed"> 810 </span>
<span class="line-removed"> 811             if (structure-&gt;propertyAccessesAreCacheable()</span>
<span class="line-removed"> 812                 &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>
<span class="line-removed"> 813                 vm.heap.writeBarrier(codeBlock);</span>
<span class="line-removed"> 814 </span>
<span class="line-removed"> 815                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
 816 

 817                 metadata.m_modeMetadata.defaultMode.structureID = structure-&gt;id();
 818                 metadata.m_modeMetadata.defaultMode.cachedOffset = slot.cachedOffset();

 819             }
<span class="line-modified"> 820         } else if (UNLIKELY(metadata.m_hitCountForLLIntCaching &amp;&amp; (slot.isValue() || slot.isUnset()))) {</span>
 821             ASSERT(slot.slotBase() != baseValue);
 822 
<span class="line-modified"> 823             if (!(--metadata.m_hitCountForLLIntCaching))</span>
 824                 setupGetByIdPrototypeCache(exec, vm, pc, metadata, baseCell, slot, ident);
 825         }
<span class="line-modified"> 826     } else if (!LLINT_ALWAYS_ACCESS_SLOW</span>
<span class="line-modified"> 827         &amp;&amp; isJSArray(baseValue)</span>
<span class="line-modified"> 828         &amp;&amp; ident == vm.propertyNames-&gt;length) {</span>
<span class="line-modified"> 829         metadata.m_mode = GetByIdMode::ArrayLength;</span>
<span class="line-modified"> 830         new (&amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile) ArrayProfile(codeBlock-&gt;bytecodeOffset(pc));</span>
<span class="line-modified"> 831         metadata.m_modeMetadata.arrayLengthMode.arrayProfile.observeStructure(baseValue.asCell()-&gt;structure(vm));</span>
<span class="line-modified"> 832 </span>
<span class="line-removed"> 833         // Prevent the prototype cache from ever happening.</span>
<span class="line-removed"> 834         metadata.m_hitCountForLLIntCaching = 0;</span>
 835     }
 836 
 837     LLINT_PROFILE_VALUE(result);
 838     LLINT_END();
 839 }
 840 
 841 LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
 842 {
 843     LLINT_BEGIN();
 844     auto bytecode = pc-&gt;as&lt;OpPutById&gt;();
 845     auto&amp; metadata = bytecode.metadata(exec);
 846     CodeBlock* codeBlock = exec-&gt;codeBlock();
 847     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 848 
 849     JSValue baseValue = getOperand(exec, bytecode.m_base);
 850     PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
 851     if (bytecode.m_flags &amp; PutByIdIsDirect)
 852         CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, getOperand(exec, bytecode.m_value), slot);
 853     else
 854         baseValue.putInline(exec, ident, getOperand(exec, bytecode.m_value), slot);
</pre>
<hr />
<pre>
 865                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 866                 if (slot.type() == PutPropertySlot::NewProperty)
 867                     b = b-&gt;previousID();
 868 
 869                 if (Structure::shouldConvertToPolyProto(a, b)) {
 870                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 871                     b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 872                 }
 873             }
 874         }
 875 
 876         // Start out by clearing out the old cache.
 877         metadata.m_oldStructureID = 0;
 878         metadata.m_offset = 0;
 879         metadata.m_newStructureID = 0;
 880         metadata.m_structureChain.clear();
 881 
 882         JSCell* baseCell = baseValue.asCell();
 883         Structure* structure = baseCell-&gt;structure(vm);
 884 
<span class="line-modified"> 885         if (!structure-&gt;isUncacheableDictionary()</span>
<span class="line-removed"> 886             &amp;&amp; !structure-&gt;typeInfo().prohibitsPropertyCaching()</span>
<span class="line-removed"> 887             &amp;&amp; baseCell == slot.base()) {</span>
<span class="line-removed"> 888 </span>
<span class="line-removed"> 889             vm.heap.writeBarrier(codeBlock);</span>
<span class="line-removed"> 890 </span>
 891             if (slot.type() == PutPropertySlot::NewProperty) {
 892                 GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
<span class="line-removed"> 893 </span>
 894                 if (!structure-&gt;isDictionary() &amp;&amp; structure-&gt;previousID()-&gt;outOfLineCapacity() == structure-&gt;outOfLineCapacity()) {
 895                     ASSERT(structure-&gt;previousID()-&gt;transitionWatchpointSetHasBeenInvalidated());
 896 
 897                     bool sawPolyProto = false;
 898                     auto result = normalizePrototypeChain(exec, baseCell, sawPolyProto);
 899                     if (result != InvalidPrototypeChain &amp;&amp; !sawPolyProto) {
 900                         ASSERT(structure-&gt;previousID()-&gt;isObject());
 901                         metadata.m_oldStructureID = structure-&gt;previousID()-&gt;id();
 902                         metadata.m_offset = slot.cachedOffset();
 903                         metadata.m_newStructureID = structure-&gt;id();
 904                         if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {
 905                             StructureChain* chain = structure-&gt;prototypeChain(exec, asObject(baseCell));
 906                             ASSERT(chain);
 907                             metadata.m_structureChain.set(vm, codeBlock, chain);
 908                         }

 909                     }
 910                 }
 911             } else {
 912                 structure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());
<span class="line-modified"> 913                 metadata.m_oldStructureID = structure-&gt;id();</span>
<span class="line-modified"> 914                 metadata.m_offset = slot.cachedOffset();</span>




 915             }
 916         }
 917     }
 918 
 919     LLINT_END();
 920 }
 921 
 922 LLINT_SLOW_PATH_DECL(slow_path_del_by_id)
 923 {
 924     LLINT_BEGIN();
 925     auto bytecode = pc-&gt;as&lt;OpDelById&gt;();
 926     CodeBlock* codeBlock = exec-&gt;codeBlock();
 927     JSObject* baseObject = getOperand(exec, bytecode.m_base).toObject(exec);
 928     LLINT_CHECK_EXCEPTION();
 929     bool couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, codeBlock-&gt;identifier(bytecode.m_property));
 930     LLINT_CHECK_EXCEPTION();
 931     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
 932         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));
 933     LLINT_RETURN(jsBoolean(couldDelete));
 934 }
 935 
 936 static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, ExecState* exec, OpGetByVal bytecode)
 937 {
 938     JSValue baseValue = getOperand(exec, bytecode.m_base);
 939     JSValue subscript = getOperand(exec, bytecode.m_property);
 940     auto scope = DECLARE_THROW_SCOPE(vm);
 941 
 942     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
 943         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
 944         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 945             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified"> 946                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>


 947                     return result;
 948             }
 949         }
 950     }
 951 
 952     if (subscript.isUInt32()) {
 953         uint32_t i = subscript.asUInt32();
 954         auto&amp; metadata = bytecode.metadata(exec);
 955         ArrayProfile* arrayProfile = &amp;metadata.m_arrayProfile;
 956 
 957         if (isJSString(baseValue)) {
 958             if (asString(baseValue)-&gt;canGetIndex(i)) {
 959                 scope.release();
 960                 return asString(baseValue)-&gt;getIndex(exec, i);
 961             }
 962             arrayProfile-&gt;setOutOfBounds();
 963         } else if (baseValue.isObject()) {
 964             JSObject* object = asObject(baseValue);
 965             if (object-&gt;canGetIndexQuickly(i))
 966                 return object-&gt;getIndexQuickly(i);
</pre>
<hr />
<pre>
 994 {
 995     LLINT_BEGIN();
 996     auto bytecode = pc-&gt;as&lt;OpGetByVal&gt;();
 997     LLINT_RETURN_PROFILED(getByVal(vm, exec, bytecode));
 998 }
 999 
1000 LLINT_SLOW_PATH_DECL(slow_path_put_by_val)
1001 {
1002     LLINT_BEGIN();
1003 
1004     auto bytecode = pc-&gt;as&lt;OpPutByVal&gt;();
1005     JSValue baseValue = getOperand(exec, bytecode.m_base);
1006     JSValue subscript = getOperand(exec, bytecode.m_property);
1007     JSValue value = getOperand(exec, bytecode.m_value);
1008     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();
1009 
1010     if (LIKELY(subscript.isUInt32())) {
1011         uint32_t i = subscript.asUInt32();
1012         if (baseValue.isObject()) {
1013             JSObject* object = asObject(baseValue);
<span class="line-modified">1014             if (object-&gt;canSetIndexQuickly(i))</span>
1015                 object-&gt;setIndexQuickly(vm, i, value);
1016             else
1017                 object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, i, value, isStrictMode);
1018             LLINT_END();
1019         }
1020         baseValue.putByIndex(exec, i, value, isStrictMode);
1021         LLINT_END();
1022     }
1023 
1024     auto property = subscript.toPropertyKey(exec);
1025     LLINT_CHECK_EXCEPTION();
1026     PutPropertySlot slot(baseValue, isStrictMode);
1027     baseValue.put(exec, property, value, slot);
1028     LLINT_END();
1029 }
1030 
1031 LLINT_SLOW_PATH_DECL(slow_path_put_by_val_direct)
1032 {
1033     LLINT_BEGIN();
1034 
</pre>
<hr />
<pre>
1308     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);
1309     ASSERT(scrutinee.isString());
1310     JSString* string = asString(scrutinee);
1311     ASSERT(string-&gt;length() == 1);
1312     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1313     StringImpl* impl = string-&gt;value(exec).impl();
1314     CodeBlock* codeBlock = exec-&gt;codeBlock();
1315     JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue((*impl)[0], defaultOffset));
1316     LLINT_END();
1317 }
1318 
1319 LLINT_SLOW_PATH_DECL(slow_path_switch_string)
1320 {
1321     LLINT_BEGIN();
1322     auto bytecode = pc-&gt;as&lt;OpSwitchString&gt;();
1323     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);
1324     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1325     if (!scrutinee.isString())
1326         JUMP_TO(defaultOffset);
1327     else {




1328         CodeBlock* codeBlock = exec-&gt;codeBlock();
<span class="line-modified">1329         JUMP_TO(codeBlock-&gt;stringSwitchJumpTable(bytecode.m_tableIndex).offsetForValue(asString(scrutinee)-&gt;value(exec).impl(), defaultOffset));</span>

1330     }
1331     LLINT_END();
1332 }
1333 
1334 LLINT_SLOW_PATH_DECL(slow_path_new_func)
1335 {
1336     LLINT_BEGIN();
1337     auto bytecode = pc-&gt;as&lt;OpNewFunc&gt;();
1338     CodeBlock* codeBlock = exec-&gt;codeBlock();
1339     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1340     slowPathLogF(&quot;Creating function!\n&quot;);
1341     LLINT_RETURN(JSFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1342 }
1343 
1344 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func)
1345 {
1346     LLINT_BEGIN();
1347     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFunc&gt;();
1348     CodeBlock* codeBlock = exec-&gt;codeBlock();
1349     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
</pre>
<hr />
<pre>
1430 }
1431 
1432 static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CodeSpecializationKind kind)
1433 {
1434     slowPathLog(&quot;Performing host call.\n&quot;);
1435 
1436     ExecState* exec = execCallee-&gt;callerFrame();
1437     VM&amp; vm = exec-&gt;vm();
1438     auto throwScope = DECLARE_THROW_SCOPE(vm);
1439 
1440     execCallee-&gt;setCodeBlock(0);
1441     execCallee-&gt;clearReturnPC();
1442 
1443     if (kind == CodeForCall) {
1444         CallData callData;
1445         CallType callType = getCallData(vm, callee, callData);
1446 
1447         ASSERT(callType != CallType::JS);
1448 
1449         if (callType == CallType::Host) {
<span class="line-modified">1450             NativeCallFrameTracer tracer(&amp;vm, execCallee);</span>
1451             execCallee-&gt;setCallee(asObject(callee));
1452             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));
1453             LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1454         }
1455 
1456         slowPathLog(&quot;Call callee is not a function: &quot;, callee, &quot;\n&quot;);
1457 
1458         ASSERT(callType == CallType::None);
1459         LLINT_CALL_THROW(exec, createNotAFunctionError(exec, callee));
1460     }
1461 
1462     ASSERT(kind == CodeForConstruct);
1463 
1464     ConstructData constructData;
1465     ConstructType constructType = getConstructData(vm, callee, constructData);
1466 
1467     ASSERT(constructType != ConstructType::JS);
1468 
1469     if (constructType == ConstructType::Host) {
<span class="line-modified">1470         NativeCallFrameTracer tracer(&amp;vm, execCallee);</span>
1471         execCallee-&gt;setCallee(asObject(callee));
1472         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));
1473         LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1474     }
1475 
1476     slowPathLog(&quot;Constructor callee is not a function: &quot;, callee, &quot;\n&quot;);
1477 
1478     ASSERT(constructType == ConstructType::None);
1479     LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));
1480 }
1481 
1482 inline SlowPathReturnType setUpCall(ExecState* execCallee, CodeSpecializationKind kind, JSValue calleeAsValue, LLIntCallLinkInfo* callLinkInfo = nullptr)
1483 {
1484     ExecState* exec = execCallee-&gt;callerFrame();
1485     VM&amp; vm = exec-&gt;vm();
1486     auto throwScope = DECLARE_THROW_SCOPE(vm);
1487 
1488     slowPathLogF(&quot;Performing call with recorded PC = %p\n&quot;, exec-&gt;currentVPC());
1489 
1490     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1491     if (!calleeAsFunctionCell) {
1492         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1493             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1494             ASSERT(!!codePtr);
1495 
1496             if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
1497                 CodeBlock* callerCodeBlock = exec-&gt;codeBlock();
1498 
1499                 ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
<span class="line-modified">1500 </span>
<span class="line-removed">1501                 if (callLinkInfo-&gt;isOnList())</span>
<span class="line-removed">1502                     callLinkInfo-&gt;remove();</span>
<span class="line-removed">1503                 callLinkInfo-&gt;callee.set(vm, callerCodeBlock, internalFunction);</span>
<span class="line-removed">1504                 callLinkInfo-&gt;lastSeenCallee.set(vm, callerCodeBlock, internalFunction);</span>
<span class="line-removed">1505                 callLinkInfo-&gt;machineCodeTarget = codePtr;</span>
1506             }
1507 
1508             assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
1509             LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);
1510         }
1511         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, kind));
1512     }
1513     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1514     JSScope* scope = callee-&gt;scopeUnchecked();
1515     ExecutableBase* executable = callee-&gt;executable();
1516 
1517     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1518     CodeBlock* codeBlock = 0;
1519     if (executable-&gt;isHostFunction())
1520         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1521     else {
1522         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1523 
1524         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
1525             LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));
1526 
1527         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="line-modified">1528         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);</span>
1529         EXCEPTION_ASSERT(throwScope.exception() == error);
1530         if (UNLIKELY(error))
1531             LLINT_CALL_THROW(exec, error);
1532         codeBlock = *codeBlockSlot;
1533         ASSERT(codeBlock);
1534         ArityCheckMode arity;
1535         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))
1536             arity = MustCheckArity;
1537         else
1538             arity = ArityCheckNotRequired;
1539         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1540     }
1541 
1542     ASSERT(!!codePtr);
1543 
1544     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
1545         CodeBlock* callerCodeBlock = exec-&gt;codeBlock();
1546 
1547         ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
<span class="line-modified">1548 </span>
<span class="line-removed">1549         if (callLinkInfo-&gt;isOnList())</span>
<span class="line-removed">1550             callLinkInfo-&gt;remove();</span>
<span class="line-removed">1551         callLinkInfo-&gt;callee.set(vm, callerCodeBlock, callee);</span>
<span class="line-removed">1552         callLinkInfo-&gt;lastSeenCallee.set(vm, callerCodeBlock, callee);</span>
<span class="line-removed">1553         callLinkInfo-&gt;machineCodeTarget = codePtr;</span>
1554         if (codeBlock)
1555             codeBlock-&gt;linkIncomingCall(exec, callLinkInfo);
1556     }
1557 
1558     assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
1559     LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);
1560 }
1561 
1562 template&lt;typename Op&gt;
1563 inline SlowPathReturnType genericCall(ExecState* exec, Op&amp;&amp; bytecode, CodeSpecializationKind kind)
1564 {
1565     // This needs to:
1566     // - Set up a call frame.
1567     // - Figure out what to call and compile it if necessary.
1568     // - If possible, link the call&#39;s inline cache.
1569     // - Return a tuple of machine code address to call and the new call frame.
1570 
1571     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);
1572 
1573     ExecState* execCallee = exec - bytecode.m_argv;
</pre>
<hr />
<pre>
1723 
1724     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);
1725     execCallee-&gt;setCallerFrame(exec);
1726     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;
1727     execCallee-&gt;setReturnPC(returnPoint.executableAddress());
1728     execCallee-&gt;setCodeBlock(0);
1729     exec-&gt;setCurrentVPC(pc);
1730 
1731     if (!isHostFunction(calleeAsValue, globalFuncEval))
1732         RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, CodeForCall, calleeAsValue));
1733 
1734     vm.hostCallReturnValue = eval(execCallee);
1735     LLINT_CALL_RETURN(exec, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1736 }
1737 
1738 LLINT_SLOW_PATH_DECL(slow_path_call_eval)
1739 {
1740     return commonCallEval(exec, pc, LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));
1741 }
1742 
<span class="line-modified">1743 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide)</span>





1744 {
<span class="line-modified">1745     return commonCallEval(exec, pc, LLInt::getWideCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1746 }
1747 
1748 LLINT_SLOW_PATH_DECL(slow_path_strcat)
1749 {
1750     LLINT_BEGIN();
1751     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
1752     LLINT_RETURN(jsStringFromRegisterArray(exec, &amp;exec-&gt;uncheckedR(bytecode.m_src), bytecode.m_count));
1753 }
1754 
1755 LLINT_SLOW_PATH_DECL(slow_path_to_primitive)
1756 {
1757     LLINT_BEGIN();
1758     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
1759     LLINT_RETURN(getOperand(exec, bytecode.m_src).toPrimitive(exec));
1760 }
1761 
1762 LLINT_SLOW_PATH_DECL(slow_path_throw)
1763 {
1764     LLINT_BEGIN();
1765     auto bytecode = pc-&gt;as&lt;OpThrow&gt;();
</pre>
<hr />
<pre>
1771     LLINT_BEGIN_NO_SET_PC();
1772     ASSERT(vm.needTrapHandling());
1773     vm.handleTraps(exec);
1774     UNUSED_PARAM(pc);
1775     LLINT_RETURN_TWO(throwScope.exception(), exec);
1776 }
1777 
1778 LLINT_SLOW_PATH_DECL(slow_path_debug)
1779 {
1780     LLINT_BEGIN();
1781     auto bytecode = pc-&gt;as&lt;OpDebug&gt;();
1782     vm.interpreter-&gt;debug(exec, bytecode.m_debugHookType);
1783 
1784     LLINT_END();
1785 }
1786 
1787 LLINT_SLOW_PATH_DECL(slow_path_handle_exception)
1788 {
1789     LLINT_BEGIN_NO_SET_PC();
1790     UNUSED_PARAM(throwScope);
<span class="line-modified">1791     genericUnwind(&amp;vm, exec);</span>
1792     LLINT_END_IMPL();
1793 }
1794 
1795 LLINT_SLOW_PATH_DECL(slow_path_get_from_scope)
1796 {
1797     LLINT_BEGIN();
1798     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
1799     auto&amp; metadata = bytecode.metadata(exec);
1800     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_var);
1801     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));
1802 
1803     // ModuleVar is always converted to ClosureVar for get_from_scope.
1804     ASSERT(metadata.m_getPutInfo.resolveType() != ModuleVar);
1805 
1806     LLINT_RETURN(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
1807         if (!found) {
1808             if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound)
1809                 return throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
1810             return jsUndefined();
1811         }
</pre>
<hr />
<pre>
1906     CallSiteIndex callSiteIndex(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc));
1907 #else
1908     CallSiteIndex callSiteIndex(pc);
1909 #endif
1910     ShadowChicken* shadowChicken = vm.shadowChicken();
1911     RELEASE_ASSERT(shadowChicken);
1912     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::tail(exec, thisValue, scope, exec-&gt;codeBlock(), callSiteIndex));
1913 
1914     LLINT_END();
1915 }
1916 
1917 LLINT_SLOW_PATH_DECL(slow_path_profile_catch)
1918 {
1919     LLINT_BEGIN();
1920 
1921     exec-&gt;codeBlock()-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(exec-&gt;bytecodeOffset());
1922 
1923     auto bytecode = pc-&gt;as&lt;OpCatch&gt;();
1924     auto&amp; metadata = bytecode.metadata(exec);
1925     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
<span class="line-modified">1926         profile.m_profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1927     });
1928 
1929     LLINT_END();
1930 }
1931 
1932 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_begin)
1933 {
1934     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1935     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
1936     UNUSED_PARAM(exec);
1937     g_superSamplerCount++;
1938     LLINT_END_IMPL();
1939 }
1940 
1941 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_end)
1942 {
1943     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1944     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
1945     UNUSED_PARAM(exec);
1946     g_superSamplerCount--;
</pre>
</td>
<td>
<hr />
<pre>
  60 #include &quot;LLIntPrototypeLoadAdaptiveStructureWatchpoint.h&quot;
  61 #include &quot;LowLevelInterpreter.h&quot;
  62 #include &quot;ModuleProgramCodeBlock.h&quot;
  63 #include &quot;ObjectConstructor.h&quot;
  64 #include &quot;ObjectPropertyConditionSet.h&quot;
  65 #include &quot;OpcodeInlines.h&quot;
  66 #include &quot;ProgramCodeBlock.h&quot;
  67 #include &quot;ProtoCallFrame.h&quot;
  68 #include &quot;RegExpObject.h&quot;
  69 #include &quot;ShadowChicken.h&quot;
  70 #include &quot;StructureRareDataInlines.h&quot;
  71 #include &quot;SuperSampler.h&quot;
  72 #include &quot;VMInlines.h&quot;
  73 #include &lt;wtf/NeverDestroyed.h&gt;
  74 #include &lt;wtf/StringPrintStream.h&gt;
  75 
  76 namespace JSC { namespace LLInt {
  77 
  78 #define LLINT_BEGIN_NO_SET_PC() \
  79     VM&amp; vm = exec-&gt;vm();      \
<span class="line-modified">  80     NativeCallFrameTracer tracer(vm, exec); \</span>
  81     auto throwScope = DECLARE_THROW_SCOPE(vm)
  82 
  83 #ifndef NDEBUG
  84 #define LLINT_SET_PC_FOR_STUBS() do { \
  85         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \
  86         exec-&gt;setCurrentVPC(pc); \
  87     } while (false)
  88 #else
  89 #define LLINT_SET_PC_FOR_STUBS() do { \
  90         exec-&gt;setCurrentVPC(pc); \
  91     } while (false)
  92 #endif
  93 
  94 #define LLINT_BEGIN()                           \
  95     LLINT_BEGIN_NO_SET_PC();                    \
  96     LLINT_SET_PC_FOR_STUBS()
  97 
  98 inline JSValue getNonConstantOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;uncheckedR(operand.offset()).jsValue(); }
  99 inline JSValue getOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;r(operand.offset()).jsValue(); }
 100 
</pre>
<hr />
<pre>
 340     }
 341     LLINT_END_IMPL();
 342 }
 343 
 344 enum EntryKind { Prologue, ArityCheck };
 345 
 346 #if ENABLE(JIT)
 347 static FunctionWhitelist&amp; ensureGlobalJITWhitelist()
 348 {
 349     static LazyNeverDestroyed&lt;FunctionWhitelist&gt; baselineWhitelist;
 350     static std::once_flag initializeWhitelistFlag;
 351     std::call_once(initializeWhitelistFlag, [] {
 352         const char* functionWhitelistFile = Options::jitWhitelist();
 353         baselineWhitelist.construct(functionWhitelistFile);
 354     });
 355     return baselineWhitelist;
 356 }
 357 
 358 inline bool shouldJIT(CodeBlock* codeBlock)
 359 {
<span class="line-modified"> 360     if (!Options::bytecodeRangeToJITCompile().isInRange(codeBlock-&gt;instructionsSize())</span>
 361         || !ensureGlobalJITWhitelist().contains(codeBlock))
 362         return false;
 363 
 364     return VM::canUseJIT() &amp;&amp; Options::useBaselineJIT();
 365 }
 366 
 367 // Returns true if we should try to OSR.
 368 inline bool jitCompileAndSetHeuristics(CodeBlock* codeBlock, ExecState* exec, unsigned loopOSREntryBytecodeOffset = 0)
 369 {
 370     VM&amp; vm = exec-&gt;vm();
 371     DeferGCForAWhile deferGC(vm.heap); // My callers don&#39;t set top callframe, so we don&#39;t want to GC here at all.
 372     ASSERT(VM::canUseJIT());
 373 
 374     codeBlock-&gt;updateAllValueProfilePredictions();
 375 
 376     if (!codeBlock-&gt;checkIfJITThresholdReached()) {
 377         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayJITCompile&quot;, (&quot;threshold not reached, counter = &quot;, codeBlock-&gt;llintExecuteCounter()));
 378         if (Options::verboseOSR())
 379             dataLogF(&quot;    JIT threshold should be lifted.\n&quot;);
 380         return false;
 381     }
 382 
 383     JITWorklist::ensureGlobalWorklist().poll(vm);
 384 
 385     switch (codeBlock-&gt;jitType()) {
<span class="line-modified"> 386     case JITType::BaselineJIT: {</span>
 387         if (Options::verboseOSR())
 388             dataLogF(&quot;    Code was already compiled.\n&quot;);
 389         codeBlock-&gt;jitSoon();
 390         return true;
 391     }
<span class="line-modified"> 392     case JITType::InterpreterThunk: {</span>
 393         JITWorklist::ensureGlobalWorklist().compileLater(codeBlock, loopOSREntryBytecodeOffset);
<span class="line-modified"> 394         return codeBlock-&gt;jitType() == JITType::BaselineJIT;</span>
 395     }
 396     default:
 397         dataLog(&quot;Unexpected code block in LLInt: &quot;, *codeBlock, &quot;\n&quot;);
 398         RELEASE_ASSERT_NOT_REACHED();
 399         return false;
 400     }
 401 }
 402 
 403 static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char *name, EntryKind kind)
 404 {
 405     if (Options::verboseOSR()) {
 406         dataLog(
 407             *codeBlock, &quot;: Entered &quot;, name, &quot; with executeCounter = &quot;,
 408             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);
 409     }
 410 
 411     if (!shouldJIT(codeBlock)) {
 412         codeBlock-&gt;dontJITAnytimeSoon();
 413         LLINT_RETURN_TWO(0, 0);
 414     }
</pre>
<hr />
<pre>
 463 
 464 #if ENABLE(JIT)
 465     if (Options::verboseOSR()) {
 466         dataLog(
 467             *codeBlock, &quot;: Entered loop_osr with executeCounter = &quot;,
 468             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);
 469     }
 470 
 471     unsigned loopOSREntryBytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);
 472 
 473     if (!shouldJIT(codeBlock)) {
 474         codeBlock-&gt;dontJITAnytimeSoon();
 475         LLINT_RETURN_TWO(0, 0);
 476     }
 477 
 478     if (!jitCompileAndSetHeuristics(codeBlock, exec, loopOSREntryBytecodeOffset))
 479         LLINT_RETURN_TWO(0, 0);
 480 
 481     CODEBLOCK_LOG_EVENT(codeBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, loopOSREntryBytecodeOffset));
 482 
<span class="line-modified"> 483     ASSERT(codeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
 484 
 485     const JITCodeMap&amp; codeMap = codeBlock-&gt;jitCodeMap();
 486     CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(loopOSREntryBytecodeOffset);
 487     ASSERT(codeLocation);
 488 
 489     void* jumpTarget = codeLocation.executableAddress();
 490     ASSERT(jumpTarget);
 491 
 492     LLINT_RETURN_TWO(jumpTarget, exec-&gt;topOfFrame());
 493 #else // ENABLE(JIT)
 494     UNUSED_PARAM(pc);
 495     codeBlock-&gt;dontJITAnytimeSoon();
 496     LLINT_RETURN_TWO(0, 0);
 497 #endif // ENABLE(JIT)
 498 }
 499 
 500 LLINT_SLOW_PATH_DECL(replace)
 501 {
 502     LLINT_BEGIN_NO_SET_PC();
 503     UNUSED_PARAM(throwScope);
</pre>
<hr />
<pre>
 512 
 513     if (shouldJIT(codeBlock))
 514         jitCompileAndSetHeuristics(codeBlock, exec);
 515     else
 516         codeBlock-&gt;dontJITAnytimeSoon();
 517     LLINT_END_IMPL();
 518 #else // ENABLE(JIT)
 519     codeBlock-&gt;dontJITAnytimeSoon();
 520     LLINT_END_IMPL();
 521 #endif // ENABLE(JIT)
 522 }
 523 
 524 LLINT_SLOW_PATH_DECL(stack_check)
 525 {
 526     VM&amp; vm = exec-&gt;vm();
 527     auto throwScope = DECLARE_THROW_SCOPE(vm);
 528 
 529     // It&#39;s ok to create the NativeCallFrameTracer here before we
 530     // convertToStackOverflowFrame() because this function is always called
 531     // after the frame has been propulated with a proper CodeBlock and callee.
<span class="line-modified"> 532     NativeCallFrameTracer tracer(vm, exec);</span>
 533 
 534     LLINT_SET_PC_FOR_STUBS();
 535 
 536     CodeBlock* codeBlock = exec-&gt;codeBlock();
 537     slowPathLogF(&quot;Checking stack height with exec = %p.\n&quot;, exec);
 538     slowPathLog(&quot;CodeBlock = &quot;, codeBlock, &quot;\n&quot;);
 539     if (codeBlock) {
 540         slowPathLogF(&quot;Num callee registers = %u.\n&quot;, codeBlock-&gt;numCalleeLocals());
 541         slowPathLogF(&quot;Num vars = %u.\n&quot;, codeBlock-&gt;numVars());
 542     }
 543     slowPathLogF(&quot;Current OS stack end is at %p.\n&quot;, vm.softStackLimit());
 544 #if ENABLE(C_LOOP)
 545     slowPathLogF(&quot;Current C Loop stack end is at %p.\n&quot;, vm.cloopStackLimit());
 546 #endif
 547 
 548     // If the stack check succeeds and we don&#39;t need to throw the error, then
 549     // we&#39;ll return 0 instead. The prologue will check for a non-zero value
 550     // when determining whether to set the callFrame or not.
 551 
 552     // For JIT enabled builds which uses the C stack, the stack is not growable.
</pre>
<hr />
<pre>
 660         {
 661             StructureID oldStructureID = metadata.m_structureID;
 662             if (oldStructureID) {
 663                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 664                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 665 
 666                 if (Structure::shouldConvertToPolyProto(a, b)) {
 667                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 668                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 669                 }
 670             }
 671         }
 672 
 673         JSCell* baseCell = baseValue.asCell();
 674         Structure* structure = baseCell-&gt;structure(vm);
 675         if (slot.isValue()) {
 676             // Start out by clearing out the old cache.
 677             metadata.m_structureID = 0;
 678             metadata.m_offset = 0;
 679 
<span class="line-modified"> 680             if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>
<span class="line-modified"> 681                 {</span>
<span class="line-added"> 682                     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-added"> 683                     metadata.m_structureID = structure-&gt;id();</span>
<span class="line-added"> 684                     metadata.m_offset = slot.cachedOffset();</span>
<span class="line-added"> 685                 }</span>
 686                 vm.heap.writeBarrier(codeBlock);





 687             }
 688         }
 689     }
 690 
 691     LLINT_RETURN_PROFILED(result);
 692 }
 693 
 694 
 695 static void setupGetByIdPrototypeCache(ExecState* exec, VM&amp; vm, const Instruction* pc, OpGetById::Metadata&amp; metadata, JSCell* baseCell, PropertySlot&amp; slot, const Identifier&amp; ident)
 696 {
 697     CodeBlock* codeBlock = exec-&gt;codeBlock();
 698     Structure* structure = baseCell-&gt;structure(vm);
 699 
 700     if (structure-&gt;typeInfo().prohibitsPropertyCaching())
 701         return;
 702 
 703     if (structure-&gt;needImpurePropertyWatchpoint())
 704         return;
 705 
 706     if (structure-&gt;isDictionary()) {
 707         if (structure-&gt;hasBeenFlattenedBefore())
 708             return;
 709         structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
 710     }
 711 
 712     ObjectPropertyConditionSet conditions;
 713     if (slot.isUnset())
 714         conditions = generateConditionsForPropertyMiss(vm, codeBlock, exec, structure, ident.impl());
 715     else
 716         conditions = generateConditionsForPrototypePropertyHit(vm, codeBlock, exec, structure, slot.slotBase(), ident.impl());
 717 
 718     if (!conditions.isValid())
 719         return;
 720 
<span class="line-added"> 721     unsigned bytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);</span>
 722     PropertyOffset offset = invalidOffset;
 723     CodeBlock::StructureWatchpointMap&amp; watchpointMap = codeBlock-&gt;llintGetByIdWatchpointMap();
<span class="line-modified"> 724     Vector&lt;LLIntPrototypeLoadAdaptiveStructureWatchpoint&gt; watchpoints;</span>
<span class="line-added"> 725     watchpoints.reserveInitialCapacity(conditions.size());</span>
 726     for (ObjectPropertyCondition condition : conditions) {
 727         if (!condition.isWatchable())
 728             return;
 729         if (condition.condition().kind() == PropertyCondition::Presence)
 730             offset = condition.condition().offset();
<span class="line-modified"> 731         watchpoints.uncheckedConstructAndAppend(codeBlock, condition, bytecodeOffset);</span>
<span class="line-added"> 732         watchpoints.last().install(vm);</span>
 733     }
 734 
 735     ASSERT((offset == invalidOffset) == slot.isUnset());
<span class="line-modified"> 736     auto result = watchpointMap.add(std::make_tuple(structure-&gt;id(), bytecodeOffset), WTFMove(watchpoints));</span>
 737     ASSERT_UNUSED(result, result.isNewEntry);
 738 
<span class="line-modified"> 739     {</span>
<span class="line-modified"> 740         ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-modified"> 741         if (slot.isUnset())</span>
<span class="line-modified"> 742             metadata.m_modeMetadata.setUnsetMode(structure);</span>
<span class="line-modified"> 743         else {</span>
<span class="line-modified"> 744             ASSERT(slot.isValue());</span>
<span class="line-added"> 745             metadata.m_modeMetadata.setProtoLoadMode(structure, offset, slot.slotBase());</span>
<span class="line-added"> 746         }</span>
 747     }
<span class="line-modified"> 748     vm.heap.writeBarrier(codeBlock);</span>








 749 }
 750 
 751 
 752 LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
 753 {
 754     LLINT_BEGIN();
 755     auto bytecode = pc-&gt;as&lt;OpGetById&gt;();
 756     auto&amp; metadata = bytecode.metadata(exec);
 757     CodeBlock* codeBlock = exec-&gt;codeBlock();
 758     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 759     JSValue baseValue = getOperand(exec, bytecode.m_base);
 760     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::Get);
 761 
 762     JSValue result = baseValue.get(exec, ident, slot);
 763     LLINT_CHECK_EXCEPTION();
 764     exec-&gt;uncheckedR(bytecode.m_dst) = result;
 765 
 766     if (!LLINT_ALWAYS_ACCESS_SLOW
 767         &amp;&amp; baseValue.isCell()
 768         &amp;&amp; slot.isCacheable()) {
 769         {
 770             StructureID oldStructureID;
<span class="line-modified"> 771             switch (metadata.m_modeMetadata.mode) {</span>

 772             case GetByIdMode::Default:
 773                 oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
 774                 break;
 775             case GetByIdMode::Unset:
 776                 oldStructureID = metadata.m_modeMetadata.unsetMode.structureID;
 777                 break;
 778             case GetByIdMode::ProtoLoad:
 779                 oldStructureID = metadata.m_modeMetadata.protoLoadMode.structureID;
 780                 break;
 781             default:
 782                 oldStructureID = 0;
 783             }
 784             if (oldStructureID) {
 785                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 786                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 787 
 788                 if (Structure::shouldConvertToPolyProto(a, b)) {
 789                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 790                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 791                 }
 792             }
 793         }
 794 
 795         JSCell* baseCell = baseValue.asCell();
 796         Structure* structure = baseCell-&gt;structure(vm);
 797         if (slot.isValue() &amp;&amp; slot.slotBase() == baseValue) {
<span class="line-added"> 798             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
 799             // Start out by clearing out the old cache.
<span class="line-modified"> 800             metadata.m_modeMetadata.clearToDefaultModeWithoutCache();</span>


 801 
 802             // Prevent the prototype cache from ever happening.
<span class="line-modified"> 803             metadata.m_modeMetadata.hitCountForLLIntCaching = 0;</span>






 804 
<span class="line-added"> 805             if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>
 806                 metadata.m_modeMetadata.defaultMode.structureID = structure-&gt;id();
 807                 metadata.m_modeMetadata.defaultMode.cachedOffset = slot.cachedOffset();
<span class="line-added"> 808                 vm.heap.writeBarrier(codeBlock);</span>
 809             }
<span class="line-modified"> 810         } else if (UNLIKELY(metadata.m_modeMetadata.hitCountForLLIntCaching &amp;&amp; (slot.isValue() || slot.isUnset()))) {</span>
 811             ASSERT(slot.slotBase() != baseValue);
 812 
<span class="line-modified"> 813             if (!(--metadata.m_modeMetadata.hitCountForLLIntCaching))</span>
 814                 setupGetByIdPrototypeCache(exec, vm, pc, metadata, baseCell, slot, ident);
 815         }
<span class="line-modified"> 816     } else if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; isJSArray(baseValue) &amp;&amp; ident == vm.propertyNames-&gt;length) {</span>
<span class="line-modified"> 817         {</span>
<span class="line-modified"> 818             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-modified"> 819             metadata.m_modeMetadata.setArrayLengthMode();</span>
<span class="line-modified"> 820             metadata.m_modeMetadata.arrayLengthMode.arrayProfile.observeStructure(baseValue.asCell()-&gt;structure(vm));</span>
<span class="line-modified"> 821         }</span>
<span class="line-modified"> 822         vm.heap.writeBarrier(codeBlock);</span>


 823     }
 824 
 825     LLINT_PROFILE_VALUE(result);
 826     LLINT_END();
 827 }
 828 
 829 LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
 830 {
 831     LLINT_BEGIN();
 832     auto bytecode = pc-&gt;as&lt;OpPutById&gt;();
 833     auto&amp; metadata = bytecode.metadata(exec);
 834     CodeBlock* codeBlock = exec-&gt;codeBlock();
 835     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 836 
 837     JSValue baseValue = getOperand(exec, bytecode.m_base);
 838     PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
 839     if (bytecode.m_flags &amp; PutByIdIsDirect)
 840         CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, getOperand(exec, bytecode.m_value), slot);
 841     else
 842         baseValue.putInline(exec, ident, getOperand(exec, bytecode.m_value), slot);
</pre>
<hr />
<pre>
 853                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 854                 if (slot.type() == PutPropertySlot::NewProperty)
 855                     b = b-&gt;previousID();
 856 
 857                 if (Structure::shouldConvertToPolyProto(a, b)) {
 858                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 859                     b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 860                 }
 861             }
 862         }
 863 
 864         // Start out by clearing out the old cache.
 865         metadata.m_oldStructureID = 0;
 866         metadata.m_offset = 0;
 867         metadata.m_newStructureID = 0;
 868         metadata.m_structureChain.clear();
 869 
 870         JSCell* baseCell = baseValue.asCell();
 871         Structure* structure = baseCell-&gt;structure(vm);
 872 
<span class="line-modified"> 873         if (!structure-&gt;isUncacheableDictionary() &amp;&amp; !structure-&gt;typeInfo().prohibitsPropertyCaching() &amp;&amp; baseCell == slot.base()) {</span>





 874             if (slot.type() == PutPropertySlot::NewProperty) {
 875                 GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);

 876                 if (!structure-&gt;isDictionary() &amp;&amp; structure-&gt;previousID()-&gt;outOfLineCapacity() == structure-&gt;outOfLineCapacity()) {
 877                     ASSERT(structure-&gt;previousID()-&gt;transitionWatchpointSetHasBeenInvalidated());
 878 
 879                     bool sawPolyProto = false;
 880                     auto result = normalizePrototypeChain(exec, baseCell, sawPolyProto);
 881                     if (result != InvalidPrototypeChain &amp;&amp; !sawPolyProto) {
 882                         ASSERT(structure-&gt;previousID()-&gt;isObject());
 883                         metadata.m_oldStructureID = structure-&gt;previousID()-&gt;id();
 884                         metadata.m_offset = slot.cachedOffset();
 885                         metadata.m_newStructureID = structure-&gt;id();
 886                         if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {
 887                             StructureChain* chain = structure-&gt;prototypeChain(exec, asObject(baseCell));
 888                             ASSERT(chain);
 889                             metadata.m_structureChain.set(vm, codeBlock, chain);
 890                         }
<span class="line-added"> 891                         vm.heap.writeBarrier(codeBlock);</span>
 892                     }
 893                 }
 894             } else {
 895                 structure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());
<span class="line-modified"> 896                 {</span>
<span class="line-modified"> 897                     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-added"> 898                     metadata.m_oldStructureID = structure-&gt;id();</span>
<span class="line-added"> 899                     metadata.m_offset = slot.cachedOffset();</span>
<span class="line-added"> 900                 }</span>
<span class="line-added"> 901                 vm.heap.writeBarrier(codeBlock);</span>
 902             }
 903         }
 904     }
 905 
 906     LLINT_END();
 907 }
 908 
 909 LLINT_SLOW_PATH_DECL(slow_path_del_by_id)
 910 {
 911     LLINT_BEGIN();
 912     auto bytecode = pc-&gt;as&lt;OpDelById&gt;();
 913     CodeBlock* codeBlock = exec-&gt;codeBlock();
 914     JSObject* baseObject = getOperand(exec, bytecode.m_base).toObject(exec);
 915     LLINT_CHECK_EXCEPTION();
 916     bool couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, codeBlock-&gt;identifier(bytecode.m_property));
 917     LLINT_CHECK_EXCEPTION();
 918     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
 919         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));
 920     LLINT_RETURN(jsBoolean(couldDelete));
 921 }
 922 
 923 static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, ExecState* exec, OpGetByVal bytecode)
 924 {
 925     JSValue baseValue = getOperand(exec, bytecode.m_base);
 926     JSValue subscript = getOperand(exec, bytecode.m_property);
 927     auto scope = DECLARE_THROW_SCOPE(vm);
 928 
 929     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
 930         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
 931         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 932             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified"> 933             RETURN_IF_EXCEPTION(scope, JSValue());</span>
<span class="line-added"> 934             if (existingAtomString) {</span>
<span class="line-added"> 935                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
 936                     return result;
 937             }
 938         }
 939     }
 940 
 941     if (subscript.isUInt32()) {
 942         uint32_t i = subscript.asUInt32();
 943         auto&amp; metadata = bytecode.metadata(exec);
 944         ArrayProfile* arrayProfile = &amp;metadata.m_arrayProfile;
 945 
 946         if (isJSString(baseValue)) {
 947             if (asString(baseValue)-&gt;canGetIndex(i)) {
 948                 scope.release();
 949                 return asString(baseValue)-&gt;getIndex(exec, i);
 950             }
 951             arrayProfile-&gt;setOutOfBounds();
 952         } else if (baseValue.isObject()) {
 953             JSObject* object = asObject(baseValue);
 954             if (object-&gt;canGetIndexQuickly(i))
 955                 return object-&gt;getIndexQuickly(i);
</pre>
<hr />
<pre>
 983 {
 984     LLINT_BEGIN();
 985     auto bytecode = pc-&gt;as&lt;OpGetByVal&gt;();
 986     LLINT_RETURN_PROFILED(getByVal(vm, exec, bytecode));
 987 }
 988 
 989 LLINT_SLOW_PATH_DECL(slow_path_put_by_val)
 990 {
 991     LLINT_BEGIN();
 992 
 993     auto bytecode = pc-&gt;as&lt;OpPutByVal&gt;();
 994     JSValue baseValue = getOperand(exec, bytecode.m_base);
 995     JSValue subscript = getOperand(exec, bytecode.m_property);
 996     JSValue value = getOperand(exec, bytecode.m_value);
 997     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();
 998 
 999     if (LIKELY(subscript.isUInt32())) {
1000         uint32_t i = subscript.asUInt32();
1001         if (baseValue.isObject()) {
1002             JSObject* object = asObject(baseValue);
<span class="line-modified">1003             if (object-&gt;canSetIndexQuickly(i, value))</span>
1004                 object-&gt;setIndexQuickly(vm, i, value);
1005             else
1006                 object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, i, value, isStrictMode);
1007             LLINT_END();
1008         }
1009         baseValue.putByIndex(exec, i, value, isStrictMode);
1010         LLINT_END();
1011     }
1012 
1013     auto property = subscript.toPropertyKey(exec);
1014     LLINT_CHECK_EXCEPTION();
1015     PutPropertySlot slot(baseValue, isStrictMode);
1016     baseValue.put(exec, property, value, slot);
1017     LLINT_END();
1018 }
1019 
1020 LLINT_SLOW_PATH_DECL(slow_path_put_by_val_direct)
1021 {
1022     LLINT_BEGIN();
1023 
</pre>
<hr />
<pre>
1297     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);
1298     ASSERT(scrutinee.isString());
1299     JSString* string = asString(scrutinee);
1300     ASSERT(string-&gt;length() == 1);
1301     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1302     StringImpl* impl = string-&gt;value(exec).impl();
1303     CodeBlock* codeBlock = exec-&gt;codeBlock();
1304     JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue((*impl)[0], defaultOffset));
1305     LLINT_END();
1306 }
1307 
1308 LLINT_SLOW_PATH_DECL(slow_path_switch_string)
1309 {
1310     LLINT_BEGIN();
1311     auto bytecode = pc-&gt;as&lt;OpSwitchString&gt;();
1312     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);
1313     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1314     if (!scrutinee.isString())
1315         JUMP_TO(defaultOffset);
1316     else {
<span class="line-added">1317         StringImpl* scrutineeStringImpl = asString(scrutinee)-&gt;value(exec).impl();</span>
<span class="line-added">1318 </span>
<span class="line-added">1319         LLINT_CHECK_EXCEPTION();</span>
<span class="line-added">1320 </span>
1321         CodeBlock* codeBlock = exec-&gt;codeBlock();
<span class="line-modified">1322 </span>
<span class="line-added">1323         JUMP_TO(codeBlock-&gt;stringSwitchJumpTable(bytecode.m_tableIndex).offsetForValue(scrutineeStringImpl, defaultOffset));</span>
1324     }
1325     LLINT_END();
1326 }
1327 
1328 LLINT_SLOW_PATH_DECL(slow_path_new_func)
1329 {
1330     LLINT_BEGIN();
1331     auto bytecode = pc-&gt;as&lt;OpNewFunc&gt;();
1332     CodeBlock* codeBlock = exec-&gt;codeBlock();
1333     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1334     slowPathLogF(&quot;Creating function!\n&quot;);
1335     LLINT_RETURN(JSFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1336 }
1337 
1338 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func)
1339 {
1340     LLINT_BEGIN();
1341     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFunc&gt;();
1342     CodeBlock* codeBlock = exec-&gt;codeBlock();
1343     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();
</pre>
<hr />
<pre>
1424 }
1425 
1426 static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CodeSpecializationKind kind)
1427 {
1428     slowPathLog(&quot;Performing host call.\n&quot;);
1429 
1430     ExecState* exec = execCallee-&gt;callerFrame();
1431     VM&amp; vm = exec-&gt;vm();
1432     auto throwScope = DECLARE_THROW_SCOPE(vm);
1433 
1434     execCallee-&gt;setCodeBlock(0);
1435     execCallee-&gt;clearReturnPC();
1436 
1437     if (kind == CodeForCall) {
1438         CallData callData;
1439         CallType callType = getCallData(vm, callee, callData);
1440 
1441         ASSERT(callType != CallType::JS);
1442 
1443         if (callType == CallType::Host) {
<span class="line-modified">1444             NativeCallFrameTracer tracer(vm, execCallee);</span>
1445             execCallee-&gt;setCallee(asObject(callee));
1446             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));
1447             LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1448         }
1449 
1450         slowPathLog(&quot;Call callee is not a function: &quot;, callee, &quot;\n&quot;);
1451 
1452         ASSERT(callType == CallType::None);
1453         LLINT_CALL_THROW(exec, createNotAFunctionError(exec, callee));
1454     }
1455 
1456     ASSERT(kind == CodeForConstruct);
1457 
1458     ConstructData constructData;
1459     ConstructType constructType = getConstructData(vm, callee, constructData);
1460 
1461     ASSERT(constructType != ConstructType::JS);
1462 
1463     if (constructType == ConstructType::Host) {
<span class="line-modified">1464         NativeCallFrameTracer tracer(vm, execCallee);</span>
1465         execCallee-&gt;setCallee(asObject(callee));
1466         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));
1467         LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1468     }
1469 
1470     slowPathLog(&quot;Constructor callee is not a function: &quot;, callee, &quot;\n&quot;);
1471 
1472     ASSERT(constructType == ConstructType::None);
1473     LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));
1474 }
1475 
1476 inline SlowPathReturnType setUpCall(ExecState* execCallee, CodeSpecializationKind kind, JSValue calleeAsValue, LLIntCallLinkInfo* callLinkInfo = nullptr)
1477 {
1478     ExecState* exec = execCallee-&gt;callerFrame();
1479     VM&amp; vm = exec-&gt;vm();
1480     auto throwScope = DECLARE_THROW_SCOPE(vm);
1481 
1482     slowPathLogF(&quot;Performing call with recorded PC = %p\n&quot;, exec-&gt;currentVPC());
1483 
1484     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1485     if (!calleeAsFunctionCell) {
1486         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1487             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1488             ASSERT(!!codePtr);
1489 
1490             if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
1491                 CodeBlock* callerCodeBlock = exec-&gt;codeBlock();
1492 
1493                 ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
<span class="line-modified">1494                 callLinkInfo-&gt;link(vm, callerCodeBlock, internalFunction, codePtr);</span>





1495             }
1496 
1497             assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
1498             LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);
1499         }
1500         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, kind));
1501     }
1502     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1503     JSScope* scope = callee-&gt;scopeUnchecked();
1504     ExecutableBase* executable = callee-&gt;executable();
1505 
1506     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1507     CodeBlock* codeBlock = 0;
1508     if (executable-&gt;isHostFunction())
1509         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1510     else {
1511         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1512 
1513         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
1514             LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));
1515 
1516         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="line-modified">1517         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);</span>
1518         EXCEPTION_ASSERT(throwScope.exception() == error);
1519         if (UNLIKELY(error))
1520             LLINT_CALL_THROW(exec, error);
1521         codeBlock = *codeBlockSlot;
1522         ASSERT(codeBlock);
1523         ArityCheckMode arity;
1524         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))
1525             arity = MustCheckArity;
1526         else
1527             arity = ArityCheckNotRequired;
1528         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1529     }
1530 
1531     ASSERT(!!codePtr);
1532 
1533     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
1534         CodeBlock* callerCodeBlock = exec-&gt;codeBlock();
1535 
1536         ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
<span class="line-modified">1537         callLinkInfo-&gt;link(vm, callerCodeBlock, callee, codePtr);</span>





1538         if (codeBlock)
1539             codeBlock-&gt;linkIncomingCall(exec, callLinkInfo);
1540     }
1541 
1542     assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
1543     LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);
1544 }
1545 
1546 template&lt;typename Op&gt;
1547 inline SlowPathReturnType genericCall(ExecState* exec, Op&amp;&amp; bytecode, CodeSpecializationKind kind)
1548 {
1549     // This needs to:
1550     // - Set up a call frame.
1551     // - Figure out what to call and compile it if necessary.
1552     // - If possible, link the call&#39;s inline cache.
1553     // - Return a tuple of machine code address to call and the new call frame.
1554 
1555     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);
1556 
1557     ExecState* execCallee = exec - bytecode.m_argv;
</pre>
<hr />
<pre>
1707 
1708     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);
1709     execCallee-&gt;setCallerFrame(exec);
1710     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;
1711     execCallee-&gt;setReturnPC(returnPoint.executableAddress());
1712     execCallee-&gt;setCodeBlock(0);
1713     exec-&gt;setCurrentVPC(pc);
1714 
1715     if (!isHostFunction(calleeAsValue, globalFuncEval))
1716         RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, CodeForCall, calleeAsValue));
1717 
1718     vm.hostCallReturnValue = eval(execCallee);
1719     LLINT_CALL_RETURN(exec, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);
1720 }
1721 
1722 LLINT_SLOW_PATH_DECL(slow_path_call_eval)
1723 {
1724     return commonCallEval(exec, pc, LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));
1725 }
1726 
<span class="line-modified">1727 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide16)</span>
<span class="line-added">1728 {</span>
<span class="line-added">1729     return commonCallEval(exec, pc, LLInt::getWide16CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
<span class="line-added">1730 }</span>
<span class="line-added">1731 </span>
<span class="line-added">1732 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide32)</span>
1733 {
<span class="line-modified">1734     return commonCallEval(exec, pc, LLInt::getWide32CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1735 }
1736 
1737 LLINT_SLOW_PATH_DECL(slow_path_strcat)
1738 {
1739     LLINT_BEGIN();
1740     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
1741     LLINT_RETURN(jsStringFromRegisterArray(exec, &amp;exec-&gt;uncheckedR(bytecode.m_src), bytecode.m_count));
1742 }
1743 
1744 LLINT_SLOW_PATH_DECL(slow_path_to_primitive)
1745 {
1746     LLINT_BEGIN();
1747     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
1748     LLINT_RETURN(getOperand(exec, bytecode.m_src).toPrimitive(exec));
1749 }
1750 
1751 LLINT_SLOW_PATH_DECL(slow_path_throw)
1752 {
1753     LLINT_BEGIN();
1754     auto bytecode = pc-&gt;as&lt;OpThrow&gt;();
</pre>
<hr />
<pre>
1760     LLINT_BEGIN_NO_SET_PC();
1761     ASSERT(vm.needTrapHandling());
1762     vm.handleTraps(exec);
1763     UNUSED_PARAM(pc);
1764     LLINT_RETURN_TWO(throwScope.exception(), exec);
1765 }
1766 
1767 LLINT_SLOW_PATH_DECL(slow_path_debug)
1768 {
1769     LLINT_BEGIN();
1770     auto bytecode = pc-&gt;as&lt;OpDebug&gt;();
1771     vm.interpreter-&gt;debug(exec, bytecode.m_debugHookType);
1772 
1773     LLINT_END();
1774 }
1775 
1776 LLINT_SLOW_PATH_DECL(slow_path_handle_exception)
1777 {
1778     LLINT_BEGIN_NO_SET_PC();
1779     UNUSED_PARAM(throwScope);
<span class="line-modified">1780     genericUnwind(vm, exec);</span>
1781     LLINT_END_IMPL();
1782 }
1783 
1784 LLINT_SLOW_PATH_DECL(slow_path_get_from_scope)
1785 {
1786     LLINT_BEGIN();
1787     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
1788     auto&amp; metadata = bytecode.metadata(exec);
1789     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_var);
1790     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));
1791 
1792     // ModuleVar is always converted to ClosureVar for get_from_scope.
1793     ASSERT(metadata.m_getPutInfo.resolveType() != ModuleVar);
1794 
1795     LLINT_RETURN(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
1796         if (!found) {
1797             if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound)
1798                 return throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
1799             return jsUndefined();
1800         }
</pre>
<hr />
<pre>
1895     CallSiteIndex callSiteIndex(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc));
1896 #else
1897     CallSiteIndex callSiteIndex(pc);
1898 #endif
1899     ShadowChicken* shadowChicken = vm.shadowChicken();
1900     RELEASE_ASSERT(shadowChicken);
1901     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::tail(exec, thisValue, scope, exec-&gt;codeBlock(), callSiteIndex));
1902 
1903     LLINT_END();
1904 }
1905 
1906 LLINT_SLOW_PATH_DECL(slow_path_profile_catch)
1907 {
1908     LLINT_BEGIN();
1909 
1910     exec-&gt;codeBlock()-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(exec-&gt;bytecodeOffset());
1911 
1912     auto bytecode = pc-&gt;as&lt;OpCatch&gt;();
1913     auto&amp; metadata = bytecode.metadata(exec);
1914     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
<span class="line-modified">1915         profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1916     });
1917 
1918     LLINT_END();
1919 }
1920 
1921 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_begin)
1922 {
1923     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1924     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
1925     UNUSED_PARAM(exec);
1926     g_superSamplerCount++;
1927     LLINT_END_IMPL();
1928 }
1929 
1930 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_end)
1931 {
1932     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1933     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
1934     UNUSED_PARAM(exec);
1935     g_superSamplerCount--;
</pre>
</td>
</tr>
</table>
<center><a href="LLIntOfflineAsmConfig.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>