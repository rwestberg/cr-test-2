<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Dirk Mueller &lt;mueller@kde.org&gt;
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  *           (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   8  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   9  * Copyright (C) 2009 Google Inc. All rights reserved.
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;BackForwardController.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  37 #include &quot;CustomHeaderFields.h&quot;</span>
  38 #include &quot;DOMWindow.h&quot;
  39 #include &quot;DebugPageOverlays.h&quot;
  40 #include &quot;DeprecatedGlobalSettings.h&quot;
  41 #include &quot;DocumentLoader.h&quot;
  42 #include &quot;DocumentMarkerController.h&quot;
  43 #include &quot;EventHandler.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FloatRect.h&quot;
  46 #include &quot;FocusController.h&quot;
  47 #include &quot;Frame.h&quot;
  48 #include &quot;FrameLoader.h&quot;
  49 #include &quot;FrameLoaderClient.h&quot;
  50 #include &quot;FrameSelection.h&quot;
  51 #include &quot;FrameTree.h&quot;
  52 #include &quot;GraphicsContext.h&quot;
  53 #include &quot;HTMLBodyElement.h&quot;
  54 #include &quot;HTMLEmbedElement.h&quot;
  55 #include &quot;HTMLFrameElement.h&quot;
  56 #include &quot;HTMLFrameSetElement.h&quot;
  57 #include &quot;HTMLHtmlElement.h&quot;
  58 #include &quot;HTMLIFrameElement.h&quot;
  59 #include &quot;HTMLNames.h&quot;
  60 #include &quot;HTMLObjectElement.h&quot;
  61 #include &quot;HTMLParserIdioms.h&quot;
  62 #include &quot;HTMLPlugInImageElement.h&quot;
  63 #include &quot;ImageDocument.h&quot;
  64 #include &quot;InspectorClient.h&quot;
  65 #include &quot;InspectorController.h&quot;
  66 #include &quot;InspectorInstrumentation.h&quot;
  67 #include &quot;Logging.h&quot;
  68 #include &quot;MemoryCache.h&quot;
  69 #include &quot;OverflowEvent.h&quot;
  70 #include &quot;Page.h&quot;
  71 #include &quot;PageCache.h&quot;
  72 #include &quot;PageOverlayController.h&quot;
  73 #include &quot;ProgressTracker.h&quot;
  74 #include &quot;RenderEmbeddedObject.h&quot;
  75 #include &quot;RenderFullScreen.h&quot;
  76 #include &quot;RenderIFrame.h&quot;
  77 #include &quot;RenderInline.h&quot;
  78 #include &quot;RenderLayer.h&quot;
  79 #include &quot;RenderLayerBacking.h&quot;
  80 #include &quot;RenderLayerCompositor.h&quot;
  81 #include &quot;RenderSVGRoot.h&quot;
  82 #include &quot;RenderScrollbar.h&quot;
  83 #include &quot;RenderScrollbarPart.h&quot;
  84 #include &quot;RenderStyle.h&quot;
  85 #include &quot;RenderText.h&quot;
  86 #include &quot;RenderTheme.h&quot;
  87 #include &quot;RenderView.h&quot;
  88 #include &quot;RenderWidget.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  89 #include &quot;ResizeObserver.h&quot;</span>
  90 #include &quot;RuntimeEnabledFeatures.h&quot;
  91 #include &quot;SVGDocument.h&quot;
  92 #include &quot;SVGSVGElement.h&quot;
  93 #include &quot;ScriptRunner.h&quot;
  94 #include &quot;ScriptedAnimationController.h&quot;
  95 #include &quot;ScrollAnimator.h&quot;
  96 #include &quot;ScrollingCoordinator.h&quot;
  97 #include &quot;Settings.h&quot;
  98 #include &quot;StyleResolver.h&quot;
  99 #include &quot;StyleScope.h&quot;
 100 #include &quot;TextResourceDecoder.h&quot;
 101 #include &quot;TiledBacking.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 102 #include &quot;VelocityData.h&quot;</span>
 103 #include &quot;VisualViewport.h&quot;
 104 #include &quot;WheelEventTestTrigger.h&quot;
 105 #include &lt;wtf/text/TextStream.h&gt;
 106 
 107 #include &lt;wtf/IsoMallocInlines.h&gt;
 108 #include &lt;wtf/MemoryPressureHandler.h&gt;
 109 #include &lt;wtf/Ref.h&gt;
 110 #include &lt;wtf/SetForScope.h&gt;
 111 #include &lt;wtf/SystemTracing.h&gt;
 112 
 113 #if USE(COORDINATED_GRAPHICS)
 114 #include &quot;TiledBackingStore.h&quot;
 115 #endif
 116 
 117 #if ENABLE(CSS_SCROLL_SNAP)
 118 #include &quot;AxisScrollSnapOffsets.h&quot;
 119 #endif
 120 
 121 #if PLATFORM(IOS_FAMILY)
 122 #include &quot;DocumentLoader.h&quot;
 123 #include &quot;LegacyTileCache.h&quot;
 124 #endif
 125 
 126 #if PLATFORM(MAC)
 127 #include &quot;LocalDefaultSystemAppearance.h&quot;
 128 #endif
 129 
 130 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), Layout, &quot;%p - FrameView::&quot; fmt, this, ##__VA_ARGS__)
 131 
 132 namespace WebCore {
 133 
 134 using namespace HTMLNames;
 135 
 136 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 137 
 138 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 139 
 140 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 141 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 142 
 143 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 144 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 145 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 146 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 147 
<a name="4" id="anc4"></a>











 148 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 149 {
 150     Overflow overflow = style.overflowY();
 151     if (overflow != Overflow::PagedX &amp;&amp; overflow != Overflow::PagedY)
 152         return Pagination::Unpaginated;
 153 
 154     bool isHorizontalWritingMode = style.isHorizontalWritingMode();
 155     TextDirection textDirection = style.direction();
 156     WritingMode writingMode = style.writingMode();
 157 
 158     // paged-x always corresponds to LeftToRightPaginated or RightToLeftPaginated. If the WritingMode
 159     // is horizontal, then we use TextDirection to choose between those options. If the WritingMode
 160     // is vertical, then the direction of the verticality dictates the choice.
 161     if (overflow == Overflow::PagedX) {
 162         if ((isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::LTR) || writingMode == LeftToRightWritingMode)
 163             return Pagination::LeftToRightPaginated;
 164         return Pagination::RightToLeftPaginated;
 165     }
 166 
 167     // paged-y always corresponds to TopToBottomPaginated or BottomToTopPaginated. If the WritingMode
 168     // is horizontal, then the direction of the horizontality dictates the choice. If the WritingMode
 169     // is vertical, then we use TextDirection to choose between those options.
 170     if (writingMode == TopToBottomWritingMode || (!isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::RTL))
 171         return Pagination::TopToBottomPaginated;
 172     return Pagination::BottomToTopPaginated;
 173 }
 174 
 175 FrameView::FrameView(Frame&amp; frame)
 176     : m_frame(frame)
 177     , m_layoutContext(*this)
 178     , m_updateEmbeddedObjectsTimer(*this, &amp;FrameView::updateEmbeddedObjectsTimerFired)
 179     , m_updateWidgetPositionsTimer(*this, &amp;FrameView::updateWidgetPositionsTimerFired)
 180     , m_delayedScrollEventTimer(*this, &amp;FrameView::sendScrollEvent)
 181     , m_delayedScrollToFocusedElementTimer(*this, &amp;FrameView::scrollToFocusedElementTimerFired)
 182     , m_speculativeTilingEnableTimer(*this, &amp;FrameView::speculativeTilingEnableTimerFired)
 183 {
 184     init();
 185 
 186 #if ENABLE(RUBBER_BANDING)
 187     ScrollElasticity verticalElasticity = ScrollElasticityNone;
 188     ScrollElasticity horizontalElasticity = ScrollElasticityNone;
 189     if (m_frame-&gt;isMainFrame()) {
 190         verticalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;verticalScrollElasticity() : ScrollElasticityAllowed;
 191         horizontalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;horizontalScrollElasticity() : ScrollElasticityAllowed;
 192     } else if (m_frame-&gt;settings().rubberBandingForSubScrollableRegionsEnabled()) {
 193         verticalElasticity = ScrollElasticityAutomatic;
 194         horizontalElasticity = ScrollElasticityAutomatic;
 195     }
 196 
 197     ScrollableArea::setVerticalScrollElasticity(verticalElasticity);
 198     ScrollableArea::setHorizontalScrollElasticity(horizontalElasticity);
 199 #endif
 200 }
 201 
 202 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame)
 203 {
 204     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 205     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 206         view-&gt;show();
 207     return view;
 208 }
 209 
 210 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame, const IntSize&amp; initialSize)
 211 {
 212     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 213     view-&gt;Widget::setFrameRect(IntRect(view-&gt;location(), initialSize));
 214     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 215         view-&gt;show();
 216     return view;
 217 }
 218 
 219 FrameView::~FrameView()
 220 {
 221     removeFromAXObjectCache();
 222     resetScrollbars();
 223 
 224     // Custom scrollbars should already be destroyed at this point
 225     ASSERT(!horizontalScrollbar() || !horizontalScrollbar()-&gt;isCustomScrollbar());
 226     ASSERT(!verticalScrollbar() || !verticalScrollbar()-&gt;isCustomScrollbar());
 227 
 228     setHasHorizontalScrollbar(false); // Remove native scrollbars now before we lose the connection to the HostWindow.
 229     setHasVerticalScrollbar(false);
 230 
 231     ASSERT(!m_scrollCorner);
 232 
 233     ASSERT(frame().view() != this || !frame().contentRenderer());
 234 }
 235 
 236 void FrameView::reset()
 237 {
 238     m_cannotBlitToWindow = false;
 239     m_isOverlapped = false;
 240     m_contentIsOpaque = false;
 241     m_updateEmbeddedObjectsTimer.stop();
 242     m_wasScrolledByUser = false;
 243     m_delayedScrollEventTimer.stop();
 244     m_shouldScrollToFocusedElement = false;
 245     m_delayedScrollToFocusedElementTimer.stop();
 246     m_lastViewportSize = IntSize();
 247     m_lastZoomFactor = 1.0f;
 248     m_isTrackingRepaints = false;
 249     m_trackedRepaintRects.clear();
 250     m_lastPaintTime = MonotonicTime();
 251     m_paintBehavior = PaintBehavior::Normal;
 252     m_isPainting = false;
 253     m_needsDeferredScrollbarsUpdate = false;
 254     m_maintainScrollPositionAnchor = nullptr;
 255     resetLayoutMilestones();
 256     layoutContext().reset();
 257 }
 258 
 259 void FrameView::resetLayoutMilestones()
 260 {
 261     m_firstLayoutCallbackPending = false;
 262     m_isVisuallyNonEmpty = false;
 263     m_hasReachedSignificantRenderedTextThreshold = false;
 264     m_renderedSignificantAmountOfText = false;
 265     m_visuallyNonEmptyCharacterCount = 0;
 266     m_visuallyNonEmptyPixelCount = 0;
 267     m_textRendererCountForVisuallyNonEmptyCharacters = 0;
 268 }
 269 
 270 void FrameView::removeFromAXObjectCache()
 271 {
 272     if (AXObjectCache* cache = axObjectCache()) {
 273         if (HTMLFrameOwnerElement* owner = frame().ownerElement())
 274             cache-&gt;childrenChanged(owner-&gt;renderer());
 275         cache-&gt;remove(this);
 276     }
 277 }
 278 
 279 void FrameView::resetScrollbars()
 280 {
 281     // FIXME: Do we really need this?
 282     layoutContext().resetFirstLayoutFlag();
 283     // Reset the document&#39;s scrollbars back to our defaults before we yield the floor.
 284     setScrollbarsSuppressed(true);
 285     if (m_canHaveScrollbars)
 286         setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
 287     else
 288         setScrollbarModes(ScrollbarAlwaysOff, ScrollbarAlwaysOff);
 289     setScrollbarsSuppressed(false);
 290 }
 291 
 292 void FrameView::resetScrollbarsAndClearContentsSize()
 293 {
 294     resetScrollbars();
 295 
 296     LOG(Layout, &quot;FrameView %p resetScrollbarsAndClearContentsSize&quot;, this);
 297 
 298     setScrollbarsSuppressed(true);
 299     setContentsSize(IntSize());
 300     setScrollbarsSuppressed(false);
 301 }
 302 
 303 void FrameView::init()
 304 {
 305     reset();
 306 
<a name="5" id="anc5"></a>
 307     m_size = LayoutSize();
 308 
<a name="6" id="anc6"></a><span class="line-modified"> 309     // Propagate the scrolling mode to the view.</span>
<span class="line-modified"> 310     auto* ownerElement = frame().ownerElement();</span>
<span class="line-modified"> 311     if (is&lt;HTMLFrameElementBase&gt;(ownerElement) &amp;&amp; downcast&lt;HTMLFrameElementBase&gt;(*ownerElement).scrollingMode() == ScrollbarAlwaysOff)</span>
<span class="line-modified"> 312         setCanHaveScrollbars(false);</span>









 313 
 314     Page* page = frame().page();
 315     if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
 316         setPaintsEntireContents(true);
 317 }
 318 
 319 void FrameView::prepareForDetach()
 320 {
 321     detachCustomScrollbars();
 322     // When the view is no longer associated with a frame, it needs to be removed from the ax object cache
 323     // right now, otherwise it won&#39;t be able to reach the topDocument()&#39;s axObject cache later.
 324     removeFromAXObjectCache();
 325 
 326     if (frame().page()) {
 327         if (ScrollingCoordinator* scrollingCoordinator = frame().page()-&gt;scrollingCoordinator())
 328             scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 329     }
 330 }
 331 
 332 void FrameView::detachCustomScrollbars()
 333 {
 334     Scrollbar* horizontalBar = horizontalScrollbar();
 335     if (horizontalBar &amp;&amp; horizontalBar-&gt;isCustomScrollbar())
 336         setHasHorizontalScrollbar(false);
 337 
 338     Scrollbar* verticalBar = verticalScrollbar();
 339     if (verticalBar &amp;&amp; verticalBar-&gt;isCustomScrollbar())
 340         setHasVerticalScrollbar(false);
 341 
 342     m_scrollCorner = nullptr;
 343 }
 344 
 345 void FrameView::recalculateScrollbarOverlayStyle()
 346 {
 347     ScrollbarOverlayStyle oldOverlayStyle = scrollbarOverlayStyle();
 348     Optional&lt;ScrollbarOverlayStyle&gt; clientOverlayStyle = frame().page() ? frame().page()-&gt;chrome().client().preferredScrollbarOverlayStyle() : WTF::nullopt;
 349     if (clientOverlayStyle) {
 350         if (clientOverlayStyle.value() != oldOverlayStyle)
 351             setScrollbarOverlayStyle(clientOverlayStyle.value());
 352         return;
 353     }
 354 
 355     ScrollbarOverlayStyle computedOverlayStyle = ScrollbarOverlayStyleDefault;
 356 
 357     Color backgroundColor = documentBackgroundColor();
 358     if (backgroundColor.isValid()) {
 359         // Reduce the background color from RGB to a lightness value
 360         // and determine which scrollbar style to use based on a lightness
 361         // heuristic.
 362         double hue, saturation, lightness;
 363         backgroundColor.getHSL(hue, saturation, lightness);
 364         if (lightness &lt;= .5 &amp;&amp; backgroundColor.isVisible())
 365             computedOverlayStyle = ScrollbarOverlayStyleLight;
 366         else if (!backgroundColor.isVisible() &amp;&amp; useDarkAppearance())
 367             computedOverlayStyle = ScrollbarOverlayStyleLight;
 368     }
 369 
 370     if (oldOverlayStyle != computedOverlayStyle)
 371         setScrollbarOverlayStyle(computedOverlayStyle);
 372 }
 373 
 374 #if ENABLE(DARK_MODE_CSS)
 375 void FrameView::recalculateBaseBackgroundColor()
 376 {
 377     bool usingDarkAppearance = useDarkAppearance();
 378     if (m_usesDarkAppearance == usingDarkAppearance)
 379         return;
 380 
 381     m_usesDarkAppearance = usingDarkAppearance;
 382     Optional&lt;Color&gt; backgroundColor;
 383     if (m_isTransparent)
 384         backgroundColor = Color(Color::transparent);
 385     updateBackgroundRecursively(backgroundColor);
 386 }
 387 #endif
 388 
 389 void FrameView::clear()
 390 {
 391     setCanBlitOnScroll(true);
 392 
 393     reset();
 394 
 395     setScrollbarsSuppressed(true);
 396 
 397 #if PLATFORM(IOS_FAMILY)
 398     // To avoid flashes of white, disable tile updates immediately when view is cleared at the beginning of a page load.
 399     // Tiling will be re-enabled from UIKit via [WAKWindow setTilingMode:] when we have content to draw.
 400     if (LegacyTileCache* tileCache = legacyTileCache())
 401         tileCache-&gt;setTilingMode(LegacyTileCache::Disabled);
 402 #endif
 403 }
 404 
 405 #if PLATFORM(IOS_FAMILY)
 406 void FrameView::didReplaceMultipartContent()
 407 {
 408     // Re-enable tile updates that were disabled in clear().
 409     if (LegacyTileCache* tileCache = legacyTileCache())
 410         tileCache-&gt;setTilingMode(LegacyTileCache::Normal);
 411 }
 412 #endif
 413 
 414 bool FrameView::didFirstLayout() const
 415 {
 416     return layoutContext().didFirstLayout();
 417 }
 418 
 419 void FrameView::invalidateRect(const IntRect&amp; rect)
 420 {
 421     if (!parent()) {
 422         if (auto* page = frame().page())
 423             page-&gt;chrome().invalidateContentsAndRootView(rect);
 424         return;
 425     }
 426 
 427     auto* renderer = frame().ownerRenderer();
 428     if (!renderer)
 429         return;
 430 
 431     IntRect repaintRect = rect;
 432     repaintRect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
 433     renderer-&gt;repaintRectangle(repaintRect);
 434 }
 435 
 436 void FrameView::setFrameRect(const IntRect&amp; newRect)
 437 {
 438     Ref&lt;FrameView&gt; protectedThis(*this);
 439     IntRect oldRect = frameRect();
 440     if (newRect == oldRect)
 441         return;
<a name="7" id="anc7"></a><span class="line-added"> 442 </span>
 443     // Every scroll that happens as the result of frame size change is programmatic.
<a name="8" id="anc8"></a><span class="line-modified"> 444     auto oldScrollType = currentScrollType();</span>
<span class="line-added"> 445     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added"> 446 </span>
 447     ScrollView::setFrameRect(newRect);
 448 
 449     updateScrollableAreaSet();
 450 
 451     if (RenderView* renderView = this-&gt;renderView()) {
 452         if (renderView-&gt;usesCompositing())
 453             renderView-&gt;compositor().frameViewDidChangeSize();
 454     }
 455 
 456     if (frame().isMainFrame() &amp;&amp; frame().page())
 457         frame().page()-&gt;pageOverlayController().didChangeViewSize();
 458 
 459     viewportContentsChanged();
<a name="9" id="anc9"></a><span class="line-added"> 460     setCurrentScrollType(oldScrollType);</span>
 461 }
 462 
 463 bool FrameView::scheduleAnimation()
 464 {
 465     auto* page = frame().page();
 466     if (!page)
 467         return false;
 468     page-&gt;chrome().scheduleAnimation();
 469     return true;
 470 }
 471 
<a name="10" id="anc10"></a>











 472 FrameFlattening FrameView::effectiveFrameFlattening() const
 473 {
 474 #if PLATFORM(IOS_FAMILY)
 475     // On iOS when async frame scrolling is enabled, it does not make sense to use full frame flattening.
 476     // In that case, we just consider that frame flattening is disabled. This allows people to test
 477     // frame scrolling on iOS by enabling &quot;Async Frame Scrolling&quot; via the Safari menu.
 478     if (frame().settings().asyncFrameScrollingEnabled() &amp;&amp; frame().settings().frameFlattening() == FrameFlattening::FullyEnabled)
 479         return FrameFlattening::Disabled;
 480 #endif
 481     return frame().settings().frameFlattening();
 482 }
 483 
 484 bool FrameView::frameFlatteningEnabled() const
 485 {
 486     return effectiveFrameFlattening() != FrameFlattening::Disabled;
 487 }
 488 
 489 bool FrameView::isFrameFlatteningValidForThisFrame() const
 490 {
 491     if (!frameFlatteningEnabled())
 492         return false;
 493 
 494     HTMLFrameOwnerElement* owner = frame().ownerElement();
 495     if (!owner)
 496         return false;
 497 
 498     // Frame flattening is valid only for &lt;frame&gt; and &lt;iframe&gt;.
 499     return owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag);
 500 }
 501 
 502 bool FrameView::avoidScrollbarCreation() const
 503 {
 504     // with frame flattening no subframe can have scrollbars
 505     // but we also cannot turn scrollbars off as we determine
 506     // our flattening policy using that.
 507     return isFrameFlatteningValidForThisFrame();
 508 }
 509 
 510 void FrameView::setCanHaveScrollbars(bool canHaveScrollbars)
 511 {
 512     m_canHaveScrollbars = canHaveScrollbars;
 513     ScrollView::setCanHaveScrollbars(canHaveScrollbars);
 514 }
 515 
 516 void FrameView::updateCanHaveScrollbars()
 517 {
 518     ScrollbarMode hMode;
 519     ScrollbarMode vMode;
 520     scrollbarModes(hMode, vMode);
 521     if (hMode == ScrollbarAlwaysOff &amp;&amp; vMode == ScrollbarAlwaysOff)
 522         setCanHaveScrollbars(false);
 523     else
 524         setCanHaveScrollbars(true);
 525 }
 526 
 527 Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)
 528 {
 529     // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
 530     Document* doc = frame().document();
 531 
 532     // Try the &lt;body&gt; element first as a scrollbar source.
 533     HTMLElement* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
 534     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 535         return RenderScrollbar::createCustomScrollbar(*this, orientation, body);
 536 
 537     // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
 538     Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
 539     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 540         return RenderScrollbar::createCustomScrollbar(*this, orientation, docElement);
 541 
 542     // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
 543     RenderWidget* frameRenderer = frame().ownerRenderer();
 544     if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 545         return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
 546 
 547     // Nobody set a custom style, so we just use a native scrollbar.
 548     return ScrollView::createScrollbar(orientation);
 549 }
 550 
 551 void FrameView::didRestoreFromPageCache()
 552 {
 553     // When restoring from page cache, the main frame stays in place while subframes get swapped in.
 554     // We update the scrollable area set to ensure that scrolling data structures get invalidated.
 555     updateScrollableAreaSet();
 556 }
 557 
 558 void FrameView::willDestroyRenderTree()
 559 {
 560     detachCustomScrollbars();
 561     layoutContext().clearSubtreeLayoutRoot();
 562 }
 563 
 564 void FrameView::didDestroyRenderTree()
 565 {
 566     ASSERT(!layoutContext().subtreeLayoutRoot());
 567     ASSERT(m_widgetsInRenderTree.isEmpty());
 568 
 569     // If the render tree is destroyed below FrameView::updateEmbeddedObjects(), there will still be a null sentinel in the set.
 570     // Everything else should have removed itself as the tree was felled.
 571     ASSERT(!m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty() || (m_embeddedObjectsToUpdate-&gt;size() == 1 &amp;&amp; m_embeddedObjectsToUpdate-&gt;first() == nullptr));
 572 
 573     ASSERT(!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty());
 574     ASSERT(!m_slowRepaintObjects || m_slowRepaintObjects-&gt;isEmpty());
 575 
 576     ASSERT(!frame().animation().hasAnimations());
 577 }
 578 
 579 void FrameView::setContentsSize(const IntSize&amp; size)
 580 {
 581     if (size == contentsSize())
 582         return;
 583 
 584     layoutContext().disableSetNeedsLayout();
 585 
 586     ScrollView::setContentsSize(size);
 587     contentsResized();
 588 
 589     Page* page = frame().page();
 590     if (!page)
 591         return;
 592 
 593     updateScrollableAreaSet();
 594 
 595     page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
 596 
 597     if (frame().isMainFrame()) {
 598         page-&gt;pageOverlayController().didChangeDocumentSize();
 599         PageCache::singleton().markPagesForContentsSizeChanged(*page);
 600     }
 601     layoutContext().enableSetNeedsLayout();
 602 }
 603 
 604 void FrameView::adjustViewSize()
 605 {
 606     RenderView* renderView = this-&gt;renderView();
 607     if (!renderView)
 608         return;
 609 
 610     ASSERT(frame().view() == this);
 611 
 612     const IntRect rect = renderView-&gt;documentRect();
 613     const IntSize&amp; size = rect.size();
 614     ScrollView::setScrollOrigin(IntPoint(-rect.x(), -rect.y()), !frame().document()-&gt;printing(), size == contentsSize());
 615 
 616     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; adjustViewSize: unscaled document rect changed to &quot; &lt;&lt; renderView-&gt;unscaledDocumentRect() &lt;&lt; &quot; (scaled to &quot; &lt;&lt; size &lt;&lt; &quot;)&quot;);
 617 
 618     setContentsSize(size);
 619 }
 620 
 621 void FrameView::applyOverflowToViewport(const RenderElement&amp; renderer, ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode)
 622 {
 623     // Handle the overflow:hidden/scroll case for the body/html elements.  WinIE treats
 624     // overflow:hidden and overflow:scroll on &lt;body&gt; as applying to the document&#39;s
 625     // scrollbars.  The CSS2.1 draft states that HTML UAs should use the &lt;html&gt; or &lt;body&gt; element and XML/XHTML UAs should
 626     // use the root element.
 627 
 628     // To combat the inability to scroll on a page with overflow:hidden on the root when scaled, disregard hidden when
 629     // there is a frameScaleFactor that is greater than one on the main frame. Also disregard hidden if there is a
 630     // header or footer.
 631 
 632     bool overrideHidden = frame().isMainFrame() &amp;&amp; ((frame().frameScaleFactor() &gt; 1) || headerHeight() || footerHeight());
 633 
 634     Overflow overflowX = renderer.style().overflowX();
 635     Overflow overflowY = renderer.style().overflowY();
 636 
 637     if (is&lt;RenderSVGRoot&gt;(renderer)) {
 638         // FIXME: evaluate if we can allow overflow for these cases too.
 639         // Overflow is always hidden when stand-alone SVG documents are embedded.
 640         if (downcast&lt;RenderSVGRoot&gt;(renderer).isEmbeddedThroughFrameContainingSVGDocument()) {
 641             overflowX = Overflow::Hidden;
 642             overflowY = Overflow::Hidden;
 643         }
 644     }
 645 
 646     switch (overflowX) {
 647     case Overflow::Hidden:
 648         if (overrideHidden)
 649             hMode = ScrollbarAuto;
 650         else
 651             hMode = ScrollbarAlwaysOff;
 652         break;
 653     case Overflow::Scroll:
 654         hMode = ScrollbarAlwaysOn;
 655         break;
 656     case Overflow::Auto:
 657         hMode = ScrollbarAuto;
 658         break;
 659     default:
 660         // Don&#39;t set it at all.
 661         ;
 662     }
 663 
 664     switch (overflowY) {
 665     case Overflow::Hidden:
 666         if (overrideHidden)
 667             vMode = ScrollbarAuto;
 668         else
 669             vMode = ScrollbarAlwaysOff;
 670         break;
 671     case Overflow::Scroll:
 672         vMode = ScrollbarAlwaysOn;
 673         break;
 674     case Overflow::Auto:
 675         vMode = ScrollbarAuto;
 676         break;
 677     default:
 678         // Don&#39;t set it at all. Values of Overflow::PagedX and Overflow::PagedY are handled by applyPaginationToViewPort().
 679         ;
 680     }
 681 }
 682 
 683 void FrameView::applyPaginationToViewport()
 684 {
 685     auto* document = frame().document();
 686     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
 687     if (!documentElement || !documentElement-&gt;renderer()) {
 688         setPagination(Pagination());
 689         return;
 690     }
 691 
 692     auto&amp; documentRenderer = *documentElement-&gt;renderer();
 693     auto* documentOrBodyRenderer = &amp;documentRenderer;
 694 
 695     auto* body = document-&gt;body();
 696     if (body &amp;&amp; body-&gt;renderer()) {
 697         documentOrBodyRenderer = documentRenderer.style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(*documentElement) ?
 698             body-&gt;renderer() : &amp;documentRenderer;
 699     }
 700 
 701     Pagination pagination;
 702     Overflow overflowY = documentOrBodyRenderer-&gt;style().overflowY();
 703     if (overflowY == Overflow::PagedX || overflowY == Overflow::PagedY) {
 704         pagination.mode = WebCore::paginationModeForRenderStyle(documentOrBodyRenderer-&gt;style());
 705         GapLength columnGapLength = documentOrBodyRenderer-&gt;style().columnGap();
 706         pagination.gap = 0;
 707         if (!columnGapLength.isNormal()) {
 708             if (auto* containerForPaginationGap = is&lt;RenderBox&gt;(documentOrBodyRenderer) ? downcast&lt;RenderBox&gt;(documentOrBodyRenderer) : documentOrBodyRenderer-&gt;containingBlock())
 709                 pagination.gap = valueForLength(columnGapLength.length(), containerForPaginationGap-&gt;availableLogicalWidth()).toUnsigned();
 710         }
 711     }
 712     setPagination(pagination);
 713 }
 714 
 715 void FrameView::calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy strategy)
 716 {
 717     m_viewportRendererType = ViewportRendererType::None;
 718 
 719     const HTMLFrameOwnerElement* owner = frame().ownerElement();
 720     if (owner &amp;&amp; (owner-&gt;scrollingMode() == ScrollbarAlwaysOff)) {
 721         hMode = ScrollbarAlwaysOff;
 722         vMode = ScrollbarAlwaysOff;
 723         return;
 724     }
 725 
 726     if (m_canHaveScrollbars || strategy == RulesFromWebContentOnly) {
 727         hMode = ScrollbarAuto;
 728         vMode = ScrollbarAuto;
 729     } else {
 730         hMode = ScrollbarAlwaysOff;
 731         vMode = ScrollbarAlwaysOff;
 732     }
 733 
 734     if (layoutContext().subtreeLayoutRoot())
 735         return;
 736 
 737     auto* document = frame().document();
 738     if (!document)
 739         return;
 740 
 741     auto* documentElement = document-&gt;documentElement();
 742     if (!documentElement)
 743         return;
 744 
 745     auto* bodyOrFrameset = document-&gt;bodyOrFrameset();
 746     auto* rootRenderer = documentElement-&gt;renderer();
 747     if (!bodyOrFrameset || !bodyOrFrameset-&gt;renderer()) {
 748         if (rootRenderer) {
 749             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 750             m_viewportRendererType = ViewportRendererType::Document;
 751         }
 752         return;
 753     }
 754 
 755     if (is&lt;HTMLFrameSetElement&gt;(*bodyOrFrameset) &amp;&amp; !frameFlatteningEnabled()) {
 756         vMode = ScrollbarAlwaysOff;
 757         hMode = ScrollbarAlwaysOff;
 758         return;
 759     }
 760 
 761     if (is&lt;HTMLBodyElement&gt;(*bodyOrFrameset) &amp;&amp; rootRenderer) {
 762         // It&#39;s sufficient to just check the X overflow,
 763         // since it&#39;s illegal to have visible in only one direction.
 764         if (rootRenderer-&gt;style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(documentElement)) {
 765             auto* bodyRenderer = bodyOrFrameset-&gt;renderer();
 766             if (bodyRenderer) {
 767                 applyOverflowToViewport(*bodyRenderer, hMode, vMode);
 768                 m_viewportRendererType = ViewportRendererType::Body;
 769             }
 770         } else {
 771             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 772             m_viewportRendererType = ViewportRendererType::Document;
 773         }
 774     }
 775 }
 776 
 777 void FrameView::willRecalcStyle()
 778 {
 779     RenderView* renderView = this-&gt;renderView();
 780     if (!renderView)
 781         return;
 782 
 783     renderView-&gt;compositor().willRecalcStyle();
 784 }
 785 
 786 bool FrameView::updateCompositingLayersAfterStyleChange()
 787 {
 788     // If we expect to update compositing after an incipient layout, don&#39;t do so here.
 789     if (!renderView() || needsLayout() || layoutContext().isInLayout())
 790         return false;
 791     return renderView()-&gt;compositor().didRecalcStyleWithNoPendingLayout();
 792 }
 793 
 794 void FrameView::updateCompositingLayersAfterLayout()
 795 {
 796     RenderView* renderView = this-&gt;renderView();
 797     if (!renderView)
 798         return;
 799 
 800     renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::AfterLayout);
 801 }
 802 
 803 GraphicsLayer* FrameView::layerForHorizontalScrollbar() const
 804 {
 805     RenderView* renderView = this-&gt;renderView();
 806     if (!renderView)
 807         return nullptr;
 808     return renderView-&gt;compositor().layerForHorizontalScrollbar();
 809 }
 810 
 811 GraphicsLayer* FrameView::layerForVerticalScrollbar() const
 812 {
 813     RenderView* renderView = this-&gt;renderView();
 814     if (!renderView)
 815         return nullptr;
 816     return renderView-&gt;compositor().layerForVerticalScrollbar();
 817 }
 818 
 819 GraphicsLayer* FrameView::layerForScrollCorner() const
 820 {
 821     RenderView* renderView = this-&gt;renderView();
 822     if (!renderView)
 823         return nullptr;
 824     return renderView-&gt;compositor().layerForScrollCorner();
 825 }
 826 
 827 TiledBacking* FrameView::tiledBacking() const
 828 {
 829     RenderView* renderView = this-&gt;renderView();
 830     if (!renderView)
 831         return nullptr;
 832 
 833     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 834     if (!backing)
 835         return nullptr;
 836 
 837     return backing-&gt;tiledBacking();
 838 }
 839 
 840 ScrollingNodeID FrameView::scrollingNodeID() const
 841 {
 842     RenderView* renderView = this-&gt;renderView();
 843     if (!renderView)
 844         return 0;
 845 
 846     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 847     if (!backing)
 848         return 0;
 849 
 850     return backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
 851 }
 852 
 853 ScrollableArea* FrameView::scrollableAreaForScrollLayerID(uint64_t nodeID) const
 854 {
 855     RenderView* renderView = this-&gt;renderView();
 856     if (!renderView)
 857         return nullptr;
 858 
 859     return renderView-&gt;compositor().scrollableAreaForScrollLayerID(nodeID);
 860 }
 861 
 862 #if ENABLE(RUBBER_BANDING)
 863 GraphicsLayer* FrameView::layerForOverhangAreas() const
 864 {
 865     RenderView* renderView = this-&gt;renderView();
 866     if (!renderView)
 867         return nullptr;
 868     return renderView-&gt;compositor().layerForOverhangAreas();
 869 }
 870 
 871 GraphicsLayer* FrameView::setWantsLayerForTopOverHangArea(bool wantsLayer) const
 872 {
 873     RenderView* renderView = this-&gt;renderView();
 874     if (!renderView)
 875         return nullptr;
 876 
 877     return renderView-&gt;compositor().updateLayerForTopOverhangArea(wantsLayer);
 878 }
 879 
 880 GraphicsLayer* FrameView::setWantsLayerForBottomOverHangArea(bool wantsLayer) const
 881 {
 882     RenderView* renderView = this-&gt;renderView();
 883     if (!renderView)
 884         return nullptr;
 885 
 886     return renderView-&gt;compositor().updateLayerForBottomOverhangArea(wantsLayer);
 887 }
 888 
 889 #endif // ENABLE(RUBBER_BANDING)
 890 
 891 #if ENABLE(CSS_SCROLL_SNAP)
 892 void FrameView::updateSnapOffsets()
 893 {
 894     if (!frame().document())
 895         return;
 896 
 897     // FIXME: Should we allow specifying snap points through &lt;html&gt; tags too?
 898     HTMLElement* body = frame().document()-&gt;bodyOrFrameset();
 899     if (!renderView() || !body || !body-&gt;renderer())
 900         return;
 901 
 902     updateSnapOffsetsForScrollableArea(*this, *body, *renderView(), body-&gt;renderer()-&gt;style());
 903 }
 904 
 905 bool FrameView::isScrollSnapInProgress() const
 906 {
 907     if (scrollbarsSuppressed())
 908         return false;
 909 
 910     // If the scrolling thread updates the scroll position for this FrameView, then we should return
 911     // ScrollingCoordinator::isScrollSnapInProgress().
 912     if (Page* page = frame().page()) {
 913         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
 914             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
 915                 return scrollingCoordinator-&gt;isScrollSnapInProgress();
 916         }
 917     }
 918 
 919     // If the main thread updates the scroll position for this FrameView, we should return
 920     // ScrollAnimator::isScrollSnapInProgress().
 921     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
 922         return scrollAnimator-&gt;isScrollSnapInProgress();
 923 
 924     return false;
 925 }
 926 
 927 void FrameView::updateScrollingCoordinatorScrollSnapProperties() const
 928 {
 929     renderView()-&gt;compositor().updateScrollSnapPropertiesWithFrameView(*this);
 930 }
 931 #endif
 932 
 933 bool FrameView::flushCompositingStateForThisFrame(const Frame&amp; rootFrameForFlush)
 934 {
 935     RenderView* renderView = this-&gt;renderView();
 936     if (!renderView)
 937         return true; // We don&#39;t want to keep trying to update layers if we have no renderer.
 938 
 939     ASSERT(frame().view() == this);
 940 
 941     // If we sync compositing layers when a layout is pending, we may cause painting of compositing
 942     // layer content to occur before layout has happened, which will cause paintContents() to bail.
 943     if (needsLayout())
 944         return false;
 945 
 946 #if PLATFORM(IOS_FAMILY)
 947     if (LegacyTileCache* tileCache = legacyTileCache())
 948         tileCache-&gt;doPendingRepaints();
 949 #endif
 950 
 951     renderView-&gt;compositor().flushPendingLayerChanges(&amp;rootFrameForFlush == m_frame.ptr());
 952 
 953     return true;
 954 }
 955 
 956 void FrameView::setNeedsOneShotDrawingSynchronization()
 957 {
 958     if (Page* page = frame().page())
 959         page-&gt;chrome().client().setNeedsOneShotDrawingSynchronization();
 960 }
 961 
 962 GraphicsLayer* FrameView::graphicsLayerForPlatformWidget(PlatformWidget platformWidget)
 963 {
 964     // To find the Widget that corresponds with platformWidget we have to do a linear
 965     // search of our child widgets.
 966     const Widget* foundWidget = nullptr;
 967     for (auto&amp; widget : children()) {
 968         if (widget-&gt;platformWidget() != platformWidget)
 969             continue;
 970         foundWidget = widget.ptr();
 971         break;
 972     }
 973 
 974     if (!foundWidget)
 975         return nullptr;
 976 
 977     auto* renderWidget = RenderWidget::find(*foundWidget);
 978     if (!renderWidget)
 979         return nullptr;
 980 
 981     auto* widgetLayer = renderWidget-&gt;layer();
 982     if (!widgetLayer || !widgetLayer-&gt;isComposited())
 983         return nullptr;
 984 
 985     return widgetLayer-&gt;backing()-&gt;parentForSublayers();
 986 }
 987 
 988 void FrameView::scheduleLayerFlushAllowingThrottling()
 989 {
 990     RenderView* view = this-&gt;renderView();
 991     if (!view)
 992         return;
 993     view-&gt;compositor().scheduleLayerFlush(true /* canThrottle */);
 994 }
 995 
 996 LayoutRect FrameView::fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const
 997 {
 998     LayoutPoint scrollPosition;
 999     LayoutSize topLeftExpansion;
1000     LayoutSize bottomRightExpansion;
1001 
1002     if (frame().settings().visualViewportEnabled()) {
1003         // FIXME: this is wrong under zooming; uninflatedBounds is scaled but the scroll positions are not.
1004         scrollPosition = layoutViewportRect().location();
1005         topLeftExpansion = scrollPosition - unscaledMinimumScrollPosition();
1006         bottomRightExpansion = unscaledMaximumScrollPosition() - scrollPosition;
1007     } else {
1008         scrollPosition = scrollPositionRespectingCustomFixedPosition();
1009         topLeftExpansion = scrollPosition - minimumScrollPosition();
1010         bottomRightExpansion = maximumScrollPosition() - scrollPosition;
1011     }
1012 
1013     return LayoutRect(uninflatedBounds.location() - topLeftExpansion, uninflatedBounds.size() + topLeftExpansion + bottomRightExpansion);
1014 }
1015 
1016 LayoutPoint FrameView::scrollPositionRespectingCustomFixedPosition() const
1017 {
1018 #if PLATFORM(IOS_FAMILY)
1019     if (!frame().settings().visualViewportEnabled())
1020         return useCustomFixedPositionLayoutRect() ? customFixedPositionLayoutRect().location() : scrollPosition();
1021 #endif
1022 
1023     return scrollPositionForFixedPosition();
1024 }
1025 
1026 int FrameView::headerHeight() const
1027 {
1028     if (!frame().isMainFrame())
1029         return 0;
1030     Page* page = frame().page();
1031     return page ? page-&gt;headerHeight() : 0;
1032 }
1033 
1034 int FrameView::footerHeight() const
1035 {
1036     if (!frame().isMainFrame())
1037         return 0;
1038     Page* page = frame().page();
1039     return page ? page-&gt;footerHeight() : 0;
1040 }
1041 
1042 float FrameView::topContentInset(TopContentInsetType contentInsetTypeToReturn) const
1043 {
1044     if (platformWidget() &amp;&amp; contentInsetTypeToReturn == TopContentInsetType::WebCoreOrPlatformContentInset)
1045         return platformTopContentInset();
1046 
1047     if (!frame().isMainFrame())
1048         return 0;
1049 
1050     Page* page = frame().page();
1051     return page ? page-&gt;topContentInset() : 0;
1052 }
1053 
1054 void FrameView::topContentInsetDidChange(float newTopContentInset)
1055 {
1056     RenderView* renderView = this-&gt;renderView();
1057     if (!renderView)
1058         return;
1059 
1060     if (platformWidget())
1061         platformSetTopContentInset(newTopContentInset);
1062 
1063     layoutContext().layout();
1064     // Every scroll that happens as the result of content inset change is programmatic.
<a name="11" id="anc11"></a><span class="line-modified">1065     auto oldScrollType = currentScrollType();</span>
<span class="line-added">1066     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added">1067 </span>
1068     updateScrollbars(scrollPosition());
1069     if (renderView-&gt;usesCompositing())
1070         renderView-&gt;compositor().frameViewDidChangeSize();
1071 
1072     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
1073         tiledBacking-&gt;setTopContentInset(newTopContentInset);
<a name="12" id="anc12"></a><span class="line-added">1074 </span>
<span class="line-added">1075     setCurrentScrollType(oldScrollType);</span>
1076 }
1077 
1078 void FrameView::topContentDirectionDidChange()
1079 {
1080     m_needsDeferredScrollbarsUpdate = true;
1081 }
1082 
1083 void FrameView::handleDeferredScrollbarsUpdateAfterDirectionChange()
1084 {
1085     if (!m_needsDeferredScrollbarsUpdate)
1086         return;
1087 
1088     m_needsDeferredScrollbarsUpdate = false;
1089 
1090     updateScrollbars(scrollPosition());
1091     positionScrollbarLayers();
1092 }
1093 
1094 // Sometimes (for plug-ins) we need to eagerly go into compositing mode.
1095 void FrameView::enterCompositingMode()
1096 {
1097     if (RenderView* renderView = this-&gt;renderView()) {
1098         renderView-&gt;compositor().enableCompositingMode();
1099         if (!needsLayout())
1100             renderView-&gt;compositor().scheduleCompositingLayerUpdate();
1101     }
1102 }
1103 
1104 bool FrameView::isEnclosedInCompositingLayer() const
1105 {
1106     auto frameOwnerRenderer = frame().ownerRenderer();
1107     if (frameOwnerRenderer &amp;&amp; frameOwnerRenderer-&gt;containerForRepaint())
1108         return true;
1109 
1110     if (FrameView* parentView = parentFrameView())
1111         return parentView-&gt;isEnclosedInCompositingLayer();
1112     return false;
1113 }
1114 
1115 bool FrameView::flushCompositingStateIncludingSubframes()
1116 {
<a name="13" id="anc13"></a>



1117     bool allFramesFlushed = flushCompositingStateForThisFrame(frame());
1118 
1119     for (Frame* child = frame().tree().firstRenderedChild(); child; child = child-&gt;tree().traverseNextRendered(m_frame.ptr())) {
1120         if (!child-&gt;view())
1121             continue;
1122         bool flushed = child-&gt;view()-&gt;flushCompositingStateForThisFrame(frame());
1123         allFramesFlushed &amp;= flushed;
1124     }
1125     return allFramesFlushed;
1126 }
1127 
1128 bool FrameView::isSoftwareRenderable() const
1129 {
1130     RenderView* renderView = this-&gt;renderView();
1131     return !renderView || !renderView-&gt;compositor().has3DContent();
1132 }
1133 
1134 void FrameView::setIsInWindow(bool isInWindow)
1135 {
1136     if (RenderView* renderView = this-&gt;renderView())
1137         renderView-&gt;setIsInWindow(isInWindow);
1138 }
1139 
1140 void FrameView::forceLayoutParentViewIfNeeded()
1141 {
1142     RenderWidget* ownerRenderer = frame().ownerRenderer();
1143     if (!ownerRenderer)
1144         return;
1145 
1146     RenderBox* contentBox = embeddedContentBox();
1147     if (!contentBox)
1148         return;
1149 
1150     auto&amp; svgRoot = downcast&lt;RenderSVGRoot&gt;(*contentBox);
1151     if (svgRoot.everHadLayout() &amp;&amp; !svgRoot.needsLayout())
1152         return;
1153 
1154     LOG(Layout, &quot;FrameView %p forceLayoutParentViewIfNeeded scheduling layout on parent FrameView %p&quot;, this, &amp;ownerRenderer-&gt;view().frameView());
1155 
1156     // If the embedded SVG document appears the first time, the ownerRenderer has already finished
1157     // layout without knowing about the existence of the embedded SVG document, because RenderReplaced
1158     // embeddedContentBox() returns nullptr, as long as the embedded document isn&#39;t loaded yet. Before
1159     // bothering to lay out the SVG document, mark the ownerRenderer needing layout and ask its
1160     // FrameView for a layout. After that the RenderEmbeddedObject (ownerRenderer) carries the
1161     // correct size, which RenderSVGRoot::computeReplacedLogicalWidth/Height rely on, when laying
1162     // out for the first time, or when the RenderSVGRoot size has changed dynamically (eg. via &lt;script&gt;).
1163 
1164     ownerRenderer-&gt;setNeedsLayoutAndPrefWidthsRecalc();
1165     ownerRenderer-&gt;view().frameView().layoutContext().scheduleLayout();
1166 }
1167 
1168 void FrameView::markRootOrBodyRendererDirty() const
1169 {
1170     auto&amp; document = *frame().document();
1171     RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;
1172     auto* body = document.bodyOrFrameset();
1173     RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;
1174     if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())
1175         bodyRenderer-&gt;setChildNeedsLayout();
1176     else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())
1177         rootRenderer-&gt;setChildNeedsLayout();
1178 }
1179 
1180 void FrameView::adjustScrollbarsForLayout(bool isFirstLayout)
1181 {
1182     ScrollbarMode hMode;
1183     ScrollbarMode vMode;
1184     calculateScrollbarModesForLayout(hMode, vMode);
1185     if (isFirstLayout &amp;&amp; !layoutContext().isLayoutNested()) {
1186         setScrollbarsSuppressed(true);
1187         // Set the initial vMode to AlwaysOn if we&#39;re auto.
1188         if (vMode == ScrollbarAuto)
1189             setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
1190         // Set the initial hMode to AlwaysOff if we&#39;re auto.
1191         if (hMode == ScrollbarAuto)
1192             setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
1193         ASSERT(frame().page());
1194         if (frame().page()-&gt;expectsWheelEventTriggers())
1195             scrollAnimator().setWheelEventTestTrigger(frame().page()-&gt;testTrigger());
1196         setScrollbarModes(hMode, vMode);
1197         setScrollbarsSuppressed(false, true);
1198     } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
1199         setScrollbarModes(hMode, vMode);
1200 }
1201 
1202 void FrameView::willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1203 {
1204     bool subtreeLayout = !is&lt;RenderView&gt;(*layoutRoot);
1205     if (subtreeLayout)
1206         return;
1207 
1208     if (auto* body = frame().document()-&gt;bodyOrFrameset()) {
1209         if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled() &amp;&amp; body-&gt;renderer())
1210             body-&gt;renderer()-&gt;setChildNeedsLayout();
1211     }
1212     auto firstLayout = !layoutContext().didFirstLayout();
1213     if (firstLayout) {
1214         m_lastViewportSize = sizeForResizeEvent();
1215         m_lastZoomFactor = layoutRoot-&gt;style().zoom();
1216         m_firstLayoutCallbackPending = true;
1217     }
1218     adjustScrollbarsForLayout(firstLayout);
1219 
1220     auto oldSize = m_size;
1221     LayoutSize newSize = layoutSize();
1222     if (oldSize != newSize) {
1223         m_size = newSize;
1224         LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(),     newSize.width().toFloat(), newSize.height().toFloat());
1225         layoutContext().setNeedsFullRepaint();
1226         if (!firstLayout)
1227             markRootOrBodyRendererDirty();
1228     }
1229     forceLayoutParentViewIfNeeded();
1230 }
1231 
1232 void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1233 {
1234     renderView()-&gt;releaseProtectedRenderWidgets();
1235     auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
<a name="14" id="anc14"></a><span class="line-modified">1236     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(!is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint());</span>
1237 
1238     updateCompositingLayersAfterLayout();
1239 
1240 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
1241     if (auto* cache = frame().document()-&gt;existingAXObjectCache())
1242         cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
1243 #endif
1244 
<a name="15" id="anc15"></a><span class="line-modified">1245     frame().document()-&gt;invalidateRenderingDependentRegions();</span>
1246 
1247     updateCanBlitOnScrollRecursively();
1248 
1249     handleDeferredScrollUpdateAfterContentSizeChange();
1250 
1251     handleDeferredScrollbarsUpdateAfterDirectionChange();
1252 
1253     if (frame().document()-&gt;hasListenerType(Document::OVERFLOWCHANGED_LISTENER))
1254         updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());
1255 
1256     frame().document()-&gt;markers().invalidateRectsForAllMarkers();
1257 }
1258 
1259 bool FrameView::shouldDeferScrollUpdateAfterContentSizeChange()
1260 {
1261     return (layoutContext().layoutPhase() &lt; FrameViewLayoutContext::LayoutPhase::InPostLayout) &amp;&amp; (layoutContext().layoutPhase() != FrameViewLayoutContext::LayoutPhase::OutsideLayout);
1262 }
1263 
1264 RenderBox* FrameView::embeddedContentBox() const
1265 {
1266     RenderView* renderView = this-&gt;renderView();
1267     if (!renderView)
1268         return nullptr;
1269 
1270     RenderObject* firstChild = renderView-&gt;firstChild();
1271 
1272     // Curently only embedded SVG documents participate in the size-negotiation logic.
1273     if (is&lt;RenderSVGRoot&gt;(firstChild))
1274         return downcast&lt;RenderSVGRoot&gt;(firstChild);
1275 
1276     return nullptr;
1277 }
1278 
1279 void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1280 {
1281     if (!m_embeddedObjectsToUpdate)
<a name="16" id="anc16"></a><span class="line-modified">1282         m_embeddedObjectsToUpdate = makeUnique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();</span>
1283 
1284     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
1285     if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
1286         // Tell the DOM element that it needs a widget update.
1287         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
1288         if (!pluginElement.needsCheckForSizeChange())
1289             pluginElement.setNeedsWidgetUpdate(true);
1290     }
1291 
1292     m_embeddedObjectsToUpdate-&gt;add(&amp;embeddedObject);
1293 }
1294 
1295 void FrameView::removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1296 {
1297     if (!m_embeddedObjectsToUpdate)
1298         return;
1299 
1300     m_embeddedObjectsToUpdate-&gt;remove(&amp;embeddedObject);
1301 }
1302 
1303 void FrameView::setMediaType(const String&amp; mediaType)
1304 {
1305     m_mediaType = mediaType;
1306 }
1307 
1308 String FrameView::mediaType() const
1309 {
1310     // See if we have an override type.
1311     String overrideType = frame().loader().client().overrideMediaType();
1312     InspectorInstrumentation::applyEmulatedMedia(frame(), overrideType);
1313     if (!overrideType.isNull())
1314         return overrideType;
1315     return m_mediaType;
1316 }
1317 
1318 void FrameView::adjustMediaTypeForPrinting(bool printing)
1319 {
1320     if (printing) {
1321         if (m_mediaTypeWhenNotPrinting.isNull())
1322             m_mediaTypeWhenNotPrinting = mediaType();
1323         setMediaType(&quot;print&quot;);
1324     } else {
1325         if (!m_mediaTypeWhenNotPrinting.isNull())
1326             setMediaType(m_mediaTypeWhenNotPrinting);
1327         m_mediaTypeWhenNotPrinting = String();
1328     }
1329 }
1330 
1331 bool FrameView::useSlowRepaints(bool considerOverlap) const
1332 {
1333     bool mustBeSlow = hasSlowRepaintObjects() || (platformWidget() &amp;&amp; hasViewportConstrainedObjects());
1334 
1335     // FIXME: WidgetMac.mm makes the assumption that useSlowRepaints ==
1336     // m_contentIsOpaque, so don&#39;t take the fast path for composited layers
1337     // if they are a platform widget in order to get painting correctness
1338     // for transparent layers. See the comment in WidgetMac::paint.
1339     if (usesCompositedScrolling() &amp;&amp; !platformWidget())
1340         return mustBeSlow;
1341 
1342     bool isOverlapped = m_isOverlapped &amp;&amp; considerOverlap;
1343 
1344     if (mustBeSlow || m_cannotBlitToWindow || isOverlapped || !m_contentIsOpaque)
1345         return true;
1346 
1347     if (FrameView* parentView = parentFrameView())
1348         return parentView-&gt;useSlowRepaints(considerOverlap);
1349 
1350     return false;
1351 }
1352 
1353 bool FrameView::useSlowRepaintsIfNotOverlapped() const
1354 {
1355     return useSlowRepaints(false);
1356 }
1357 
1358 void FrameView::updateCanBlitOnScrollRecursively()
1359 {
1360     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
1361         if (FrameView* view = frame-&gt;view())
1362             view-&gt;setCanBlitOnScroll(!view-&gt;useSlowRepaints());
1363     }
1364 }
1365 
1366 bool FrameView::usesCompositedScrolling() const
1367 {
1368     RenderView* renderView = this-&gt;renderView();
1369     if (renderView &amp;&amp; renderView-&gt;isComposited()) {
1370         GraphicsLayer* layer = renderView-&gt;layer()-&gt;backing()-&gt;graphicsLayer();
1371         if (layer &amp;&amp; layer-&gt;drawsContent())
1372             return true;
1373     }
1374 
1375     return false;
1376 }
1377 
1378 bool FrameView::usesAsyncScrolling() const
1379 {
1380 #if ENABLE(ASYNC_SCROLLING)
1381     if (Page* page = frame().page()) {
1382         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1383             return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this);
1384     }
1385 #endif
1386     return false;
1387 }
1388 
1389 bool FrameView::usesMockScrollAnimator() const
1390 {
1391     return DeprecatedGlobalSettings::usesMockScrollAnimator();
1392 }
1393 
1394 void FrameView::logMockScrollAnimatorMessage(const String&amp; message) const
1395 {
1396     Document* document = frame().document();
1397     if (!document)
1398         return;
1399     StringBuilder builder;
1400     if (frame().isMainFrame())
1401         builder.appendLiteral(&quot;Main&quot;);
1402     builder.appendLiteral(&quot;FrameView: &quot;);
1403     builder.append(message);
1404     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1405 }
1406 
1407 void FrameView::setCannotBlitToWindow()
1408 {
1409     m_cannotBlitToWindow = true;
1410     updateCanBlitOnScrollRecursively();
1411 }
1412 
1413 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1414 {
1415     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1416 
1417     if (!m_slowRepaintObjects)
<a name="17" id="anc17"></a><span class="line-modified">1418         m_slowRepaintObjects = makeUnique&lt;HashSet&lt;const RenderElement*&gt;&gt;();</span>
1419 
1420     m_slowRepaintObjects-&gt;add(&amp;renderer);
1421     if (hadSlowRepaintObjects)
1422         return;
1423 
1424     updateCanBlitOnScrollRecursively();
1425 
1426     if (auto* page = frame().page()) {
1427         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1428             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1429     }
1430 }
1431 
1432 void FrameView::removeSlowRepaintObject(RenderElement&amp; renderer)
1433 {
1434     if (!m_slowRepaintObjects)
1435         return;
1436 
1437     m_slowRepaintObjects-&gt;remove(&amp;renderer);
1438     if (!m_slowRepaintObjects-&gt;isEmpty())
1439         return;
1440 
1441     m_slowRepaintObjects = nullptr;
1442     updateCanBlitOnScrollRecursively();
1443 
1444     if (auto* page = frame().page()) {
1445         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1446             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1447     }
1448 }
1449 
1450 void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
1451 {
1452     if (!m_viewportConstrainedObjects)
<a name="18" id="anc18"></a><span class="line-modified">1453         m_viewportConstrainedObjects = makeUnique&lt;ViewportConstrainedObjectSet&gt;();</span>
1454 
1455     if (!m_viewportConstrainedObjects-&gt;contains(object)) {
1456         m_viewportConstrainedObjects-&gt;add(object);
1457         if (platformWidget())
1458             updateCanBlitOnScrollRecursively();
1459 
1460         if (Page* page = frame().page()) {
1461             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1462                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1463         }
1464     }
1465 }
1466 
1467 void FrameView::removeViewportConstrainedObject(RenderLayerModelObject* object)
1468 {
1469     if (m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;remove(object)) {
1470         if (Page* page = frame().page()) {
1471             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1472                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1473         }
1474 
1475         // FIXME: In addFixedObject() we only call this if there&#39;s a platform widget,
1476         // why isn&#39;t the same check being made here?
1477         updateCanBlitOnScrollRecursively();
1478     }
1479 }
1480 
1481 LayoutSize FrameView::expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor)
1482 {
1483     if (!heightExpansionFactor)
1484         return baseLayoutViewportSize;
1485 
1486     auto documentHeight = documentSize.height();
1487     auto layoutViewportHeight = baseLayoutViewportSize.height();
1488     if (layoutViewportHeight &gt; documentHeight)
1489         return baseLayoutViewportSize;
1490 
<a name="19" id="anc19"></a><span class="line-modified">1491     return { baseLayoutViewportSize.width(), std::min(documentHeight, LayoutUnit((1 + heightExpansionFactor) * layoutViewportHeight)) };</span>
1492 }
1493 
1494 LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
1495 {
1496     LayoutRect layoutViewportRect = layoutViewport;
1497 
1498     // The layout viewport is never smaller than baseLayoutViewportSize, and never be smaller than the unobscuredContentRect.
1499     LayoutSize constrainedSize = baseLayoutViewportSize;
1500     layoutViewportRect.setSize(constrainedSize.expandedTo(unobscuredContentSize));
1501 
1502     LayoutPoint layoutViewportOrigin = computeLayoutViewportOrigin(unobscuredContentRect, stableLayoutViewportOriginMin, stableLayoutViewportOriginMax, layoutViewportRect, StickToViewportBounds);
1503 
1504     // FIXME: Is this equivalent to calling computeLayoutViewportOrigin() with StickToDocumentBounds?
1505     if (constraint == LayoutViewportConstraint::ConstrainedToDocumentRect) {
1506         // The max stable layout viewport origin really depends on the size of the layout viewport itself, so we need to adjust the location of the layout viewport one final time to make sure it does not end up out of bounds of the document.
1507         // Without this adjustment (and with using the non-constrained unobscuredContentRect&#39;s size as the size of the layout viewport) the layout viewport can be pushed past the bounds of the document during rubber-banding, and cannot be pushed
1508         // back in until the user scrolls back in the other direction.
1509         layoutViewportOrigin.setX(clampTo&lt;float&gt;(layoutViewportOrigin.x().toFloat(), 0, documentRect.width() - layoutViewportRect.width()));
1510         layoutViewportOrigin.setY(clampTo&lt;float&gt;(layoutViewportOrigin.y().toFloat(), 0, documentRect.height() - layoutViewportRect.height()));
1511     }
1512     layoutViewportRect.setLocation(layoutViewportOrigin);
1513 
1514     return layoutViewportRect;
1515 }
1516 
1517 // visualViewport and layoutViewport are both in content coordinates (unzoomed).
1518 LayoutPoint FrameView::computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements fixedBehavior)
1519 {
1520     LayoutPoint layoutViewportOrigin = layoutViewport.location();
1521     bool allowRubberBanding = fixedBehavior == StickToViewportBounds;
1522 
1523     if (visualViewport.width() &gt; layoutViewport.width()) {
1524         layoutViewportOrigin.setX(visualViewport.x());
1525         if (!allowRubberBanding) {
1526             if (layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1527                 layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1528             else if (layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1529                 layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1530         }
1531     } else {
1532         bool rubberbandingAtLeft = allowRubberBanding &amp;&amp; visualViewport.x() &lt; stableLayoutViewportOriginMin.x();
1533         bool rubberbandingAtRight = allowRubberBanding &amp;&amp; (visualViewport.maxX() - layoutViewport.width()) &gt; stableLayoutViewportOriginMax.x();
1534 
1535         if (visualViewport.x() &lt; layoutViewport.x() || rubberbandingAtLeft)
1536             layoutViewportOrigin.setX(visualViewport.x());
1537 
1538         if (visualViewport.maxX() &gt; layoutViewport.maxX() || rubberbandingAtRight)
1539             layoutViewportOrigin.setX(visualViewport.maxX() - layoutViewport.width());
1540 
1541         if (!rubberbandingAtLeft &amp;&amp; layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1542             layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1543 
1544         if (!rubberbandingAtRight &amp;&amp; layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1545             layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1546     }
1547 
1548     if (visualViewport.height() &gt; layoutViewport.height()) {
1549         layoutViewportOrigin.setY(visualViewport.y());
1550         if (!allowRubberBanding) {
1551             if (layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1552                 layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1553             else if (layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1554                 layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1555         }
1556     } else {
1557         bool rubberbandingAtTop = allowRubberBanding &amp;&amp; visualViewport.y() &lt; stableLayoutViewportOriginMin.y();
1558         bool rubberbandingAtBottom = allowRubberBanding &amp;&amp; (visualViewport.maxY() - layoutViewport.height()) &gt; stableLayoutViewportOriginMax.y();
1559 
1560         if (visualViewport.y() &lt; layoutViewport.y() || rubberbandingAtTop)
1561             layoutViewportOrigin.setY(visualViewport.y());
1562 
1563         if (visualViewport.maxY() &gt; layoutViewport.maxY() || rubberbandingAtBottom)
1564             layoutViewportOrigin.setY(visualViewport.maxY() - layoutViewport.height());
1565 
1566         if (!rubberbandingAtTop &amp;&amp; layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1567             layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1568 
1569         if (!rubberbandingAtBottom &amp;&amp; layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1570             layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1571     }
1572 
1573     return layoutViewportOrigin;
1574 }
1575 
1576 void FrameView::setBaseLayoutViewportOrigin(LayoutPoint origin, TriggerLayoutOrNot layoutTriggering)
1577 {
1578     ASSERT(frame().settings().visualViewportEnabled());
1579 
1580     if (origin == m_layoutViewportOrigin)
1581         return;
1582 
1583     m_layoutViewportOrigin = origin;
1584     if (layoutTriggering == TriggerLayoutOrNot::Yes)
1585         setViewportConstrainedObjectsNeedLayout();
1586 
1587     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
1588         FloatRect layoutViewport = layoutViewportRect();
1589         layoutViewport.moveBy(unscaledScrollOrigin()); // tiledBacking deals in top-left relative coordinates.
1590         tiledBacking-&gt;setLayoutViewportRect(layoutViewport);
1591     }
1592 }
1593 
1594 void FrameView::setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt; rect, TriggerLayoutOrNot layoutTriggering)
1595 {
1596     if (rect == m_layoutViewportOverrideRect)
1597         return;
1598 
1599     LayoutRect oldRect = layoutViewportRect();
1600     m_layoutViewportOverrideRect = rect;
1601 
1602     // Triggering layout on height changes is necessary to make bottom-fixed elements behave correctly.
1603     if (oldRect.height() != layoutViewportRect().height())
1604         layoutTriggering = TriggerLayoutOrNot::Yes;
1605 
1606     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; setLayoutViewportOverrideRect() - changing override layout viewport from &quot; &lt;&lt; oldRect &lt;&lt; &quot; to &quot; &lt;&lt; m_layoutViewportOverrideRect.valueOr(LayoutRect()) &lt;&lt; &quot; layoutTriggering &quot; &lt;&lt; (layoutTriggering == TriggerLayoutOrNot::Yes ? &quot;yes&quot; : &quot;no&quot;));
1607 
1608     if (oldRect != layoutViewportRect() &amp;&amp; layoutTriggering == TriggerLayoutOrNot::Yes)
1609         setViewportConstrainedObjectsNeedLayout();
1610 }
1611 
1612 void FrameView::setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt; rect)
1613 {
1614     m_visualViewportOverrideRect = rect;
1615 }
1616 
1617 LayoutSize FrameView::baseLayoutViewportSize() const
1618 {
1619     return renderView() ? renderView()-&gt;size() : size();
1620 }
1621 
1622 void FrameView::updateLayoutViewport()
1623 {
1624     if (!frame().settings().visualViewportEnabled())
1625         return;
1626 
1627     // Don&#39;t update the layout viewport if we&#39;re in the middle of adjusting scrollbars. We&#39;ll get another call
1628     // as a post-layout task.
1629     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
1630         return;
1631 
1632     LayoutRect layoutViewport = layoutViewportRect();
1633 
1634     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; updateLayoutViewport() totalContentSize &quot; &lt;&lt; totalContentsSize() &lt;&lt; &quot; unscaledDocumentRect &quot; &lt;&lt; (renderView() ? renderView()-&gt;unscaledDocumentRect() : IntRect()) &lt;&lt; &quot; header height &quot; &lt;&lt; headerHeight() &lt;&lt; &quot; footer height &quot; &lt;&lt; footerHeight() &lt;&lt; &quot; fixed behavior &quot; &lt;&lt; scrollBehaviorForFixedElements());
1635     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
1636     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
1637     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
1638 
1639     if (m_layoutViewportOverrideRect) {
<a name="20" id="anc20"></a><span class="line-modified">1640         if (currentScrollType() == ScrollType::Programmatic) {</span>
1641             LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
1642             LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
1643             setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
1644         }
<a name="21" id="anc21"></a><span class="line-modified">1645         layoutOrVisualViewportChanged();</span>



1646         return;
1647     }
1648 
1649     LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
1650     if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
1651         setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
1652         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
1653     }
<a name="22" id="anc22"></a><span class="line-modified">1654     layoutOrVisualViewportChanged();</span>



1655 }
1656 
1657 LayoutPoint FrameView::minStableLayoutViewportOrigin() const
1658 {
1659     return unscaledMinimumScrollPosition();
1660 }
1661 
1662 LayoutPoint FrameView::maxStableLayoutViewportOrigin() const
1663 {
1664     LayoutPoint maxPosition = unscaledMaximumScrollPosition();
1665     maxPosition = (maxPosition - LayoutSize(0, headerHeight() + footerHeight())).expandedTo({ });
1666     return maxPosition;
1667 }
1668 
1669 IntPoint FrameView::unscaledScrollOrigin() const
1670 {
1671     if (RenderView* renderView = this-&gt;renderView())
1672         return -renderView-&gt;unscaledDocumentRect().location(); // Akin to code in adjustViewSize().
1673 
1674     return { };
1675 }
1676 
1677 LayoutRect FrameView::layoutViewportRect() const
1678 {
1679     if (m_layoutViewportOverrideRect)
1680         return m_layoutViewportOverrideRect.value();
1681 
1682     // Size of initial containing block, anchored at scroll position, in document coordinates (unchanged by scale factor).
1683     return LayoutRect(m_layoutViewportOrigin, baseLayoutViewportSize());
1684 }
1685 
1686 // visibleContentRect is in the bounds of the scroll view content. That consists of an
1687 // optional header, the document, and an optional footer. Only the document is scaled,
1688 // so we have to compute the visible part of the document in unscaled document coordinates.
1689 // On iOS, pageScaleFactor is always 1 here, and we never have headers and footers.
1690 LayoutRect FrameView::visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor)
1691 {
1692     float contentsHeight = totalContentsSize.height() - headerHeight - footerHeight;
1693 
1694     float rubberBandTop = std::min&lt;float&gt;(visibleContentRect.y(), 0);
1695     float visibleScaledDocumentTop = std::max&lt;float&gt;(visibleContentRect.y() - headerHeight, 0) + rubberBandTop;
1696 
1697     float rubberBandBottom = std::min&lt;float&gt;((totalContentsSize.height() - visibleContentRect.y()) - visibleContentRect.height(), 0);
1698     float visibleScaledDocumentBottom = std::min&lt;float&gt;(visibleContentRect.maxY() - headerHeight, contentsHeight) - rubberBandBottom;
1699 
1700     FloatRect visibleDocumentRect = visibleContentRect;
1701     visibleDocumentRect.setY(visibleScaledDocumentTop);
1702     visibleDocumentRect.setHeight(std::max&lt;float&gt;(visibleScaledDocumentBottom - visibleScaledDocumentTop, 0));
1703     visibleDocumentRect.scale(1 / pageScaleFactor);
1704 
1705     return LayoutRect(visibleDocumentRect);
1706 }
1707 
1708 LayoutRect FrameView::visualViewportRect() const
1709 {
1710     if (m_visualViewportOverrideRect)
1711         return m_visualViewportOverrideRect.value();
1712 
1713     FloatRect visibleContentRect = this-&gt;visibleContentRect(LegacyIOSDocumentVisibleRect);
1714     return visibleDocumentRect(visibleContentRect, headerHeight(), footerHeight(), totalContentsSize(), frameScaleFactor());
1715 }
1716 
1717 LayoutRect FrameView::viewportConstrainedVisibleContentRect() const
1718 {
1719     ASSERT(!frame().settings().visualViewportEnabled());
1720 
1721 #if PLATFORM(IOS_FAMILY)
1722     if (useCustomFixedPositionLayoutRect())
1723         return customFixedPositionLayoutRect();
1724 #endif
1725     LayoutRect viewportRect = visibleContentRect();
1726 
1727     viewportRect.setLocation(scrollPositionForFixedPosition());
1728     return viewportRect;
1729 }
1730 
1731 LayoutRect FrameView::rectForFixedPositionLayout() const
1732 {
1733     if (frame().settings().visualViewportEnabled())
1734         return layoutViewportRect();
1735 
1736     return viewportConstrainedVisibleContentRect();
1737 }
1738 
1739 float FrameView::frameScaleFactor() const
1740 {
1741     return frame().frameScaleFactor();
1742 }
1743 
1744 LayoutPoint FrameView::scrollPositionForFixedPosition() const
1745 {
1746     if (frame().settings().visualViewportEnabled())
1747         return layoutViewportRect().location();
1748 
1749     return scrollPositionForFixedPosition(visibleContentRect(), totalContentsSize(), scrollPosition(), scrollOrigin(), frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements(), headerHeight(), footerHeight());
1750 }
1751 
1752 LayoutPoint FrameView::scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements behaviorForFixed, int headerHeight, int footerHeight)
1753 {
1754     LayoutPoint position;
1755     if (behaviorForFixed == StickToDocumentBounds)
1756         position = ScrollableArea::constrainScrollPositionForOverhang(visibleContentRect, totalContentsSize, scrollPosition, scrollOrigin, headerHeight, footerHeight);
1757     else {
1758         position = scrollPosition;
1759         position.setY(position.y() - headerHeight);
1760     }
1761 
1762     LayoutSize maxSize = totalContentsSize - visibleContentRect.size();
1763 
1764     float dragFactorX = (fixedElementsLayoutRelativeToFrame || !maxSize.width()) ? 1 : (totalContentsSize.width() - visibleContentRect.width() * frameScaleFactor) / maxSize.width();
1765     float dragFactorY = (fixedElementsLayoutRelativeToFrame || !maxSize.height()) ? 1 : (totalContentsSize.height() - visibleContentRect.height() * frameScaleFactor) / maxSize.height();
1766 
1767     return LayoutPoint(position.x() * dragFactorX / frameScaleFactor, position.y() * dragFactorY / frameScaleFactor);
1768 }
1769 
1770 float FrameView::yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1771 {
1772     if (!topContentInset)
1773         return 0;
1774 
1775     // The insetClipLayer should not move for negative scroll values.
1776     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1777 
1778     if (scrollY &gt;= topContentInset)
1779         return 0;
1780 
1781     return topContentInset - scrollY;
1782 }
1783 
1784 float FrameView::yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1785 {
1786     if (!topContentInset)
1787         return 0;
1788 
1789     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1790 
1791     if (scrollY &gt;= topContentInset)
1792         return topContentInset;
1793 
1794     return scrollY;
1795 }
1796 
1797 float FrameView::yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight)
1798 {
1799     return yPositionForHeaderLayer(scrollPosition, topContentInset) + totalContentsHeight - footerHeight;
1800 }
1801 
1802 FloatPoint FrameView::positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight)
1803 {
1804     return FloatPoint(0, yPositionForHeaderLayer(scrollPosition, topContentInset) + headerHeight) - toFloatSize(scrollOrigin);
1805 }
1806 
1807 FloatPoint FrameView::positionForRootContentLayer() const
1808 {
1809     return positionForRootContentLayer(scrollPosition(), scrollOrigin(), topContentInset(), headerHeight());
1810 }
1811 
1812 #if PLATFORM(IOS_FAMILY)
1813 LayoutRect FrameView::rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements scrollBehavior)
1814 {
1815     if (fixedElementsLayoutRelativeToFrame)
1816         return visibleContentRect;
1817 
1818     if (totalContentsSize.isEmpty())
1819         return visibleContentRect;
1820 
1821     // We impose an lower limit on the size (so an upper limit on the scale) of
1822     // the rect used to position fixed objects so that they don&#39;t crowd into the
1823     // center of the screen at larger scales.
1824     const LayoutUnit maxContentWidthForZoomThreshold = 1024_lu;
1825     float zoomedOutScale = frameScaleFactor * visibleContentRect.width() / std::min(maxContentWidthForZoomThreshold, totalContentsSize.width());
1826     float constraintThresholdScale = 1.5 * zoomedOutScale;
1827     float maxPostionedObjectsRectScale = std::min(frameScaleFactor, constraintThresholdScale);
1828 
1829     LayoutRect viewportConstrainedObjectsRect = visibleContentRect;
1830 
1831     if (frameScaleFactor &gt; constraintThresholdScale) {
1832         FloatRect contentRect(FloatPoint(), totalContentsSize);
1833         FloatRect viewportRect = visibleContentRect;
1834 
1835         // Scale the rect up from a point that is relative to its position in the viewport.
1836         FloatSize sizeDelta = contentRect.size() - viewportRect.size();
1837 
1838         FloatPoint scaleOrigin;
1839         scaleOrigin.setX(contentRect.x() + sizeDelta.width() &gt; 0 ? contentRect.width() * (viewportRect.x() - contentRect.x()) / sizeDelta.width() : 0);
1840         scaleOrigin.setY(contentRect.y() + sizeDelta.height() &gt; 0 ? contentRect.height() * (viewportRect.y() - contentRect.y()) / sizeDelta.height() : 0);
1841 
1842         AffineTransform rescaleTransform = AffineTransform::translation(scaleOrigin.x(), scaleOrigin.y());
1843         rescaleTransform.scale(frameScaleFactor / maxPostionedObjectsRectScale, frameScaleFactor / maxPostionedObjectsRectScale);
1844         rescaleTransform = CGAffineTransformTranslate(rescaleTransform, -scaleOrigin.x(), -scaleOrigin.y());
1845 
1846         viewportConstrainedObjectsRect = enclosingLayoutRect(rescaleTransform.mapRect(visibleContentRect));
1847     }
1848 
1849     if (scrollBehavior == StickToDocumentBounds) {
1850         LayoutRect documentBounds(LayoutPoint(), totalContentsSize);
1851         viewportConstrainedObjectsRect.intersect(documentBounds);
1852     }
1853 
1854     return viewportConstrainedObjectsRect;
1855 }
1856 
1857 LayoutRect FrameView::viewportConstrainedObjectsRect() const
1858 {
1859     return rectForViewportConstrainedObjects(visibleContentRect(), totalContentsSize(), frame().frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements());
1860 }
1861 #endif
1862 
1863 ScrollPosition FrameView::minimumScrollPosition() const
1864 {
1865     ScrollPosition minimumPosition = ScrollView::minimumScrollPosition();
1866 
1867     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1868         minimumPosition.setY(maximumScrollPosition().y());
1869 
1870     return minimumPosition;
1871 }
1872 
1873 ScrollPosition FrameView::maximumScrollPosition() const
1874 {
1875     ScrollPosition maximumPosition = ScrollView::maximumScrollPosition();
1876 
1877     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1878         maximumPosition.setY(minimumScrollPosition().y());
1879 
1880     return maximumPosition;
1881 }
1882 
1883 ScrollPosition FrameView::unscaledMinimumScrollPosition() const
1884 {
1885     if (RenderView* renderView = this-&gt;renderView()) {
1886         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1887         ScrollPosition minimumPosition = unscaledDocumentRect.location();
1888 
1889         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1890             minimumPosition.setY(unscaledMaximumScrollPosition().y());
1891 
1892         return minimumPosition;
1893     }
1894 
1895     return minimumScrollPosition();
1896 }
1897 
1898 ScrollPosition FrameView::unscaledMaximumScrollPosition() const
1899 {
1900     if (RenderView* renderView = this-&gt;renderView()) {
1901         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1902         unscaledDocumentRect.expand(0, headerHeight() + footerHeight());
1903         ScrollPosition maximumPosition = ScrollPosition(unscaledDocumentRect.maxXMaxYCorner() - visibleSize()).expandedTo({ 0, 0 });
1904         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1905             maximumPosition.setY(unscaledMinimumScrollPosition().y());
1906 
1907         return maximumPosition;
1908     }
1909 
1910     return maximumScrollPosition();
1911 }
1912 
1913 void FrameView::viewportContentsChanged()
1914 {
1915     if (!frame().view()) {
1916         // The frame is being destroyed.
1917         return;
1918     }
1919 
1920     if (auto* page = frame().page())
1921         page-&gt;updateValidationBubbleStateIfNeeded();
1922 
1923     // When the viewport contents changes (scroll, resize, style recalc, layout, ...),
1924     // check if we should resume animated images or unthrottle DOM timers.
1925     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
1926         frameView.resumeVisibleImageAnimations(visibleRect);
1927         frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
1928 
1929         if (auto* renderView = frameView.frame().contentRenderer())
1930             renderView-&gt;updateVisibleViewportRect(visibleRect);
1931     });
<a name="23" id="anc23"></a>














1932 }
1933 
<a name="24" id="anc24"></a><span class="line-modified">1934 IntRect FrameView::viewRectExpandedByContentInsets() const</span>
1935 {
<a name="25" id="anc25"></a><span class="line-modified">1936     FloatRect viewRect;</span>
<span class="line-added">1937     if (delegatesScrolling() &amp;&amp; platformWidget())</span>
<span class="line-added">1938         viewRect = unobscuredContentRect();</span>
<span class="line-added">1939     else</span>
<span class="line-added">1940         viewRect = visualViewportRect();</span>
<span class="line-added">1941 </span>
1942     if (auto* page = frame().page())
<a name="26" id="anc26"></a><span class="line-modified">1943         viewRect.expand(page-&gt;contentInsets());</span>
<span class="line-modified">1944 </span>
<span class="line-added">1945     return IntRect(viewRect);</span>
1946 }
1947 
1948 bool FrameView::fixedElementsLayoutRelativeToFrame() const
1949 {
1950     return frame().settings().fixedElementsLayoutRelativeToFrame();
1951 }
1952 
1953 IntPoint FrameView::lastKnownMousePosition() const
1954 {
1955     return frame().eventHandler().lastKnownMousePosition();
1956 }
1957 
1958 bool FrameView::isHandlingWheelEvent() const
1959 {
1960     return frame().eventHandler().isHandlingWheelEvent();
1961 }
1962 
1963 bool FrameView::shouldSetCursor() const
1964 {
1965     Page* page = frame().page();
1966     return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
1967 }
1968 
1969 #if ENABLE(DARK_MODE_CSS)
<a name="27" id="anc27"></a><span class="line-modified">1970 RenderObject* FrameView::rendererForColorScheme() const</span>
1971 {
1972     auto* document = frame().document();
1973     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
1974     auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
<a name="28" id="anc28"></a><span class="line-modified">1975     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetColorScheme())</span>
1976         return documentElementRenderer;
1977     auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
1978     return bodyElement ? bodyElement-&gt;renderer() : nullptr;
1979 }
1980 #endif
1981 
1982 bool FrameView::useDarkAppearance() const
1983 {
1984 #if ENABLE(DARK_MODE_CSS)
<a name="29" id="anc29"></a><span class="line-modified">1985     if (auto* renderer = rendererForColorScheme())</span>
1986         return renderer-&gt;useDarkAppearance();
1987 #endif
1988     if (auto* document = frame().document())
1989         return document-&gt;useDarkAppearance(nullptr);
1990     return false;
1991 }
1992 
1993 OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
1994 {
1995 #if ENABLE(DARK_MODE_CSS)
<a name="30" id="anc30"></a><span class="line-modified">1996     if (auto* renderer = rendererForColorScheme())</span>
1997         return renderer-&gt;styleColorOptions();
1998 #endif
1999     if (auto* document = frame().document())
2000         return document-&gt;styleColorOptions(nullptr);
2001     return { };
2002 }
2003 
2004 bool FrameView::scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect)
2005 {
2006     if (!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty()) {
2007         frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2008         return true;
2009     }
2010 
2011     bool isCompositedContentLayer = usesCompositedScrolling();
2012 
2013     // Get the rects of the fixed objects visible in the rectToScroll
2014     Region regionToUpdate;
2015     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2016         if (!renderer-&gt;style().hasViewportConstrainedPosition())
2017             continue;
2018         if (renderer-&gt;isComposited())
2019             continue;
2020 
2021         // Fixed items should always have layers.
2022         ASSERT(renderer-&gt;hasLayer());
2023         RenderLayer* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2024 
2025         if (layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForBoundsOutOfView
2026             || layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForNoVisibleContent) {
2027             // Don&#39;t invalidate for invisible fixed layers.
2028             continue;
2029         }
2030 
2031         if (layer-&gt;hasAncestorWithFilterOutsets()) {
2032             // If the fixed layer has a blur/drop-shadow filter applied on at least one of its parents, we cannot
2033             // scroll using the fast path, otherwise the outsets of the filter will be moved around the page.
2034             return false;
2035         }
2036 
2037         // FIXME: use pixel snapping instead of enclosing when ScrollView has finished transitioning from IntRect to Float/LayoutRect.
2038         IntRect updateRect = enclosingIntRect(layer-&gt;repaintRectIncludingNonCompositingDescendants());
2039         updateRect = contentsToRootView(updateRect);
2040         if (!isCompositedContentLayer)
2041             updateRect.intersect(rectToScroll);
2042         if (!updateRect.isEmpty())
2043             regionToUpdate.unite(updateRect);
2044     }
2045 
2046     // 1) scroll
2047     frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2048 
2049     // 2) update the area of fixed objects that has been invalidated
2050     for (auto&amp; updateRect : regionToUpdate.rects()) {
2051         IntRect scrolledRect = updateRect;
2052         scrolledRect.move(scrollDelta);
2053         updateRect.unite(scrolledRect);
2054         if (isCompositedContentLayer) {
2055             updateRect = rootViewToContents(updateRect);
2056             ASSERT(renderView());
2057             renderView()-&gt;layer()-&gt;setBackingNeedsRepaintInRect(updateRect);
2058             continue;
2059         }
2060         updateRect.intersect(rectToScroll);
2061         frame().page()-&gt;chrome().invalidateContentsAndRootView(updateRect);
2062     }
2063 
2064     return true;
2065 }
2066 
2067 void FrameView::scrollContentsSlowPath(const IntRect&amp; updateRect)
2068 {
2069     repaintSlowRepaintObjects();
2070 
2071     if (!usesCompositedScrolling() &amp;&amp; isEnclosedInCompositingLayer()) {
2072         if (RenderWidget* frameRenderer = frame().ownerRenderer()) {
2073             LayoutRect rect(frameRenderer-&gt;borderLeft() + frameRenderer-&gt;paddingLeft(), frameRenderer-&gt;borderTop() + frameRenderer-&gt;paddingTop(),
2074                 visibleWidth(), visibleHeight());
2075             frameRenderer-&gt;repaintRectangle(rect);
2076             return;
2077         }
2078     }
2079 
2080     ScrollView::scrollContentsSlowPath(updateRect);
2081 }
2082 
2083 void FrameView::repaintSlowRepaintObjects()
2084 {
2085     if (!m_slowRepaintObjects)
2086         return;
2087 
2088     // Renderers with fixed backgrounds may be in compositing layers, so we need to explicitly
2089     // repaint them after scrolling.
2090     for (auto&amp; renderer : *m_slowRepaintObjects)
2091         renderer-&gt;repaintSlowRepaintObject();
2092 }
2093 
2094 // Note that this gets called at painting time.
2095 void FrameView::setIsOverlapped(bool isOverlapped)
2096 {
2097     if (isOverlapped == m_isOverlapped)
2098         return;
2099 
2100     m_isOverlapped = isOverlapped;
2101     updateCanBlitOnScrollRecursively();
2102 }
2103 
2104 void FrameView::setContentIsOpaque(bool contentIsOpaque)
2105 {
2106     if (contentIsOpaque == m_contentIsOpaque)
2107         return;
2108 
2109     m_contentIsOpaque = contentIsOpaque;
2110     updateCanBlitOnScrollRecursively();
2111 }
2112 
2113 void FrameView::restoreScrollbar()
2114 {
2115     setScrollbarsSuppressed(false);
2116 }
2117 
2118 bool FrameView::scrollToFragment(const URL&amp; url)
2119 {
2120     String fragmentIdentifier = url.fragmentIdentifier();
2121     if (scrollToAnchor(fragmentIdentifier))
2122         return true;
2123 
2124     // Try again after decoding the ref, based on the document&#39;s encoding.
2125     if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
2126         if (scrollToAnchor(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))
2127             return true;
2128     }
2129 
2130     resetScrollAnchor();
2131     return false;
2132 }
2133 
2134 bool FrameView::scrollToAnchor(const String&amp; fragmentIdentifier)
2135 {
2136     LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
2137 
2138     // If our URL has no ref, then we have no place we need to jump to.
2139     if (fragmentIdentifier.isNull())
2140         return false;
2141 
2142     ASSERT(frame().document());
2143     auto&amp; document = *frame().document();
2144 
2145     if (!document.haveStylesheetsLoaded()) {
2146         document.setGotoAnchorNeededAfterStylesheetsLoad(true);
2147         return false;
2148     }
2149 
2150     document.setGotoAnchorNeededAfterStylesheetsLoad(false);
2151 
2152     Element* anchorElement = document.findAnchor(fragmentIdentifier);
2153 
2154     LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
2155 
2156     // Setting to null will clear the current target.
2157     document.setCSSTarget(anchorElement);
2158 
2159     if (is&lt;SVGDocument&gt;(document)) {
2160         if (fragmentIdentifier.isEmpty())
2161             return false;
2162         if (auto rootElement = SVGDocument::rootElement(document)) {
2163             if (rootElement-&gt;scrollToFragment(fragmentIdentifier))
2164                 return true;
2165             // If SVG failed to scrollToAnchor() and anchorElement is null, no other scrolling will be possible.
2166             if (!anchorElement)
2167                 return false;
2168         }
2169     } else if (!anchorElement &amp;&amp; !(fragmentIdentifier.isEmpty() || equalLettersIgnoringASCIICase(fragmentIdentifier, &quot;top&quot;))) {
2170         // Implement the rule that &quot;&quot; and &quot;top&quot; both mean top of page as in other browsers.
2171         return false;
2172     }
2173 
2174     ContainerNode* scrollPositionAnchor = anchorElement;
2175     if (!scrollPositionAnchor)
2176         scrollPositionAnchor = frame().document();
2177     maintainScrollPositionAtAnchor(scrollPositionAnchor);
2178 
2179     // If the anchor accepts keyboard focus, move focus there to aid users relying on keyboard navigation.
2180     if (anchorElement) {
2181         if (anchorElement-&gt;isFocusable())
2182             document.setFocusedElement(anchorElement);
2183         else {
2184             document.setFocusedElement(nullptr);
2185             document.setFocusNavigationStartingNode(anchorElement);
2186         }
2187     }
2188 
2189     return true;
2190 }
2191 
2192 void FrameView::maintainScrollPositionAtAnchor(ContainerNode* anchorNode)
2193 {
2194     LOG(Scrolling, &quot;FrameView::maintainScrollPositionAtAnchor at %p&quot;, anchorNode);
2195 
2196     m_maintainScrollPositionAnchor = anchorNode;
2197     if (!m_maintainScrollPositionAnchor)
2198         return;
2199     m_shouldScrollToFocusedElement = false;
2200     m_delayedScrollToFocusedElementTimer.stop();
2201 
2202     // We need to update the layout before scrolling, otherwise we could
2203     // really mess things up if an anchor scroll comes at a bad moment.
2204     frame().document()-&gt;updateStyleIfNeeded();
2205     // Only do a layout if changes have occurred that make it necessary.
2206     RenderView* renderView = this-&gt;renderView();
2207     if (renderView &amp;&amp; renderView-&gt;needsLayout())
2208         layoutContext().layout();
2209     else
2210         scrollToAnchor();
2211 }
2212 
2213 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2214 {
2215     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2216 
2217     LayoutRect bounds;
2218     if (RenderElement* renderer = element.renderer())
2219         bounds = renderer-&gt;absoluteAnchorRect();
2220     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2221     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2222     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2223 }
2224 
2225 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
2226 {
2227     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2228 
<a name="31" id="anc31"></a><span class="line-modified">2229     auto oldScrollType = currentScrollType();</span>
<span class="line-added">2230     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added">2231 </span>
2232     m_maintainScrollPositionAnchor = nullptr;
2233     m_shouldScrollToFocusedElement = false;
2234     m_delayedScrollToFocusedElementTimer.stop();
2235     Page* page = frame().page();
2236     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
2237         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
2238     ScrollView::setScrollPosition(scrollPosition);
<a name="32" id="anc32"></a><span class="line-added">2239 </span>
<span class="line-added">2240     setCurrentScrollType(oldScrollType);</span>
2241 }
2242 
2243 void FrameView::resetScrollAnchor()
2244 {
2245     ASSERT(frame().document());
2246     auto&amp; document = *frame().document();
2247 
2248     // If CSS target was set previously, we want to set it to 0, recalc
2249     // and possibly repaint because :target pseudo class may have been
2250     // set (see bug 11321).
2251     document.setCSSTarget(nullptr);
2252 
2253     if (is&lt;SVGDocument&gt;(document)) {
2254         if (auto rootElement = SVGDocument::rootElement(document)) {
2255             // We need to update the layout before resetScrollAnchor(), otherwise we
2256             // could really mess things up if resetting the anchor comes at a bad moment.
2257             document.updateStyleIfNeeded();
2258             rootElement-&gt;resetScrollAnchor();
2259         }
2260     }
2261 }
2262 
2263 void FrameView::scheduleScrollToFocusedElement(SelectionRevealMode selectionRevealMode)
2264 {
2265     if (selectionRevealMode == SelectionRevealMode::DoNotReveal)
2266         return;
2267 
2268     m_selectionRevealModeForFocusedElement = selectionRevealMode;
2269     if (m_shouldScrollToFocusedElement)
2270         return;
2271     m_shouldScrollToFocusedElement = true;
2272     m_delayedScrollToFocusedElementTimer.startOneShot(0_s);
2273 }
2274 
2275 void FrameView::scrollToFocusedElementImmediatelyIfNeeded()
2276 {
2277     if (!m_shouldScrollToFocusedElement)
2278         return;
2279 
2280     m_delayedScrollToFocusedElementTimer.stop();
2281     scrollToFocusedElementInternal();
2282 }
2283 
2284 void FrameView::scrollToFocusedElementTimerFired()
2285 {
2286     auto protectedThis = makeRef(*this);
2287     scrollToFocusedElementInternal();
2288 }
2289 
2290 void FrameView::scrollToFocusedElementInternal()
2291 {
2292     RELEASE_ASSERT(m_shouldScrollToFocusedElement);
2293     auto document = makeRefPtr(frame().document());
2294     if (!document)
2295         return;
2296 
2297     document-&gt;updateLayoutIgnorePendingStylesheets();
2298     if (!m_shouldScrollToFocusedElement)
2299         return; // Updating the layout may have ran scripts.
2300     m_shouldScrollToFocusedElement = false;
2301 
2302     auto focusedElement = makeRefPtr(document-&gt;focusedElement());
2303     if (!focusedElement)
2304         return;
2305     auto updateTarget = focusedElement-&gt;focusAppearanceUpdateTarget();
2306     if (!updateTarget)
2307         return;
2308 
2309     auto* renderer = updateTarget-&gt;renderer();
2310     if (!renderer || renderer-&gt;isWidget())
2311         return;
2312 
2313     bool insideFixed;
2314     LayoutRect absoluteBounds = renderer-&gt;absoluteAnchorRect(&amp;insideFixed);
2315     renderer-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { m_selectionRevealModeForFocusedElement, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::No });
2316 }
2317 
2318 void FrameView::contentsResized()
2319 {
2320     // For non-delegated scrolling, updateTiledBackingAdaptiveSizing() is called via addedOrRemovedScrollbar() which occurs less often.
2321     if (delegatesScrolling())
2322         updateTiledBackingAdaptiveSizing();
2323 }
2324 
2325 void FrameView::delegatesScrollingDidChange()
2326 {
2327     RenderView* renderView = this-&gt;renderView();
2328     if (!renderView)
2329         return;
2330 
2331     RenderLayerCompositor&amp; compositor = renderView-&gt;compositor();
2332     // When we switch to delegatesScrolling mode, we should destroy the scrolling/clipping layers in RenderLayerCompositor.
2333     if (compositor.usesCompositing()) {
2334         ASSERT(compositor.usesCompositing());
2335         compositor.enableCompositingMode(false);
2336         compositor.clearBackingForAllLayers();
2337     }
2338 }
2339 
2340 #if USE(COORDINATED_GRAPHICS)
2341 void FrameView::setFixedVisibleContentRect(const IntRect&amp; visibleContentRect)
2342 {
2343     bool visibleContentSizeDidChange = false;
2344     if (visibleContentRect.size() != this-&gt;fixedVisibleContentRect().size()) {
2345         // When the viewport size changes or the content is scaled, we need to
2346         // reposition the fixed and sticky positioned elements.
2347         setViewportConstrainedObjectsNeedLayout();
2348         visibleContentSizeDidChange = true;
2349     }
2350 
2351     IntPoint oldPosition = scrollPosition();
2352     ScrollView::setFixedVisibleContentRect(visibleContentRect);
2353     IntPoint newPosition = scrollPosition();
2354     if (oldPosition != newPosition) {
2355         updateLayerPositionsAfterScrolling();
2356         if (frame().settings().acceleratedCompositingForFixedPositionEnabled())
2357             updateCompositingLayersAfterScrolling();
2358         scrollAnimator().setCurrentPosition(newPosition);
2359         scrollPositionChanged(oldPosition, newPosition);
2360     }
2361     if (visibleContentSizeDidChange) {
2362         // Update the scroll-bars to calculate new page-step size.
2363         updateScrollbars(scrollPosition());
2364     }
2365     didChangeScrollOffset();
2366 }
2367 #endif
2368 
2369 void FrameView::setViewportConstrainedObjectsNeedLayout()
2370 {
2371     if (!hasViewportConstrainedObjects())
2372         return;
2373 
2374     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2375         renderer-&gt;setNeedsLayout();
2376         if (renderer-&gt;hasLayer()) {
2377             auto* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2378             layer-&gt;setNeedsCompositingGeometryUpdate();
2379         }
2380     }
2381 }
2382 
2383 void FrameView::didChangeScrollOffset()
2384 {
2385     if (auto* page = frame().page())
2386         page-&gt;pageOverlayController().didScrollFrame(frame());
2387     frame().loader().client().didChangeScrollOffset();
2388 }
2389 
2390 void FrameView::scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset)
2391 {
2392     updateLayerPositionsAfterScrolling();
2393     updateCompositingLayersAfterScrolling();
2394     repaintSlowRepaintObjects();
2395     scrollPositionChanged(scrollPositionFromOffset(oldOffset), scrollPositionFromOffset(newOffset));
2396 
2397     if (auto* renderView = this-&gt;renderView()) {
2398         if (renderView-&gt;usesCompositing())
2399             renderView-&gt;compositor().didChangeVisibleRect();
2400     }
2401 }
2402 
2403 // These scroll positions are affected by zooming.
2404 void FrameView::scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition)
2405 {
2406     UNUSED_PARAM(oldPosition);
2407     UNUSED_PARAM(newPosition);
2408 
2409     Page* page = frame().page();
2410     Seconds throttlingDelay = page ? page-&gt;chrome().client().eventThrottlingDelay() : 0_s;
2411 
2412     if (throttlingDelay == 0_s) {
2413         m_delayedScrollEventTimer.stop();
2414         sendScrollEvent();
2415     } else if (!m_delayedScrollEventTimer.isActive())
2416         m_delayedScrollEventTimer.startOneShot(throttlingDelay);
2417 
2418     if (RenderView* renderView = this-&gt;renderView()) {
2419         if (renderView-&gt;usesCompositing())
2420             renderView-&gt;compositor().frameViewDidScroll();
2421     }
2422 
2423     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; scrollPositionChanged from &quot; &lt;&lt; oldPosition &lt;&lt; &quot; to &quot; &lt;&lt; newPosition &lt;&lt; &quot; (scale &quot; &lt;&lt; frameScaleFactor() &lt;&lt; &quot; )&quot;);
2424     updateLayoutViewport();
2425     viewportContentsChanged();
2426 }
2427 
2428 void FrameView::applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp; apply)
2429 {
2430     IntRect windowClipRect = this-&gt;windowClipRect();
2431     auto visibleRect = windowToContents(windowClipRect);
2432     apply(*this, visibleRect);
2433 
2434     // Recursive call for subframes. We cache the current FrameView&#39;s windowClipRect to avoid recomputing it for every subframe.
2435     SetForScope&lt;IntRect*&gt; windowClipRectCache(m_cachedWindowClipRect, &amp;windowClipRect);
2436     for (Frame* childFrame = frame().tree().firstChild(); childFrame; childFrame = childFrame-&gt;tree().nextSibling()) {
2437         if (auto* childView = childFrame-&gt;view())
2438             childView-&gt;applyRecursivelyWithVisibleRect(apply);
2439     }
2440 }
2441 
2442 void FrameView::resumeVisibleImageAnimations(const IntRect&amp; visibleRect)
2443 {
2444     if (visibleRect.isEmpty())
2445         return;
2446 
2447     if (auto* renderView = frame().contentRenderer())
2448         renderView-&gt;resumePausedImageAnimationsIfNeeded(visibleRect);
2449 }
2450 
2451 void FrameView::updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect)
2452 {
2453     if (frame().isMainFrame())
2454         return;
2455 
2456     auto* document = frame().document();
2457     if (!document)
2458         return;
2459 
2460     // We don&#39;t throttle zero-size or display:none frames because those are usually utility frames.
2461     bool shouldThrottle = visibleRect.isEmpty() &amp;&amp; !m_size.isEmpty() &amp;&amp; frame().ownerRenderer();
2462 
2463     if (auto* scriptedAnimationController = document-&gt;scriptedAnimationController()) {
2464         if (shouldThrottle)
2465             scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2466         else
2467             scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2468     }
2469 
2470     document-&gt;setTimerThrottlingEnabled(shouldThrottle);
2471 }
2472 
2473 
2474 void FrameView::resumeVisibleImageAnimationsIncludingSubframes()
2475 {
2476     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
2477         frameView.resumeVisibleImageAnimations(visibleRect);
2478     });
2479 }
2480 
2481 void FrameView::updateLayerPositionsAfterScrolling()
2482 {
2483     // If we&#39;re scrolling as a result of updating the view size after layout, we&#39;ll update widgets and layer positions soon anyway.
2484     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
2485         return;
2486 
2487     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2488         if (RenderView* renderView = this-&gt;renderView()) {
2489             updateWidgetPositions();
2490             renderView-&gt;layer()-&gt;updateLayerPositionsAfterDocumentScroll();
2491         }
2492     }
2493 }
2494 
2495 bool FrameView::shouldUpdateCompositingLayersAfterScrolling() const
2496 {
2497 #if ENABLE(ASYNC_SCROLLING)
2498     // If the scrolling thread is updating the fixed elements, then the FrameView should not update them as well.
2499 
2500     Page* page = frame().page();
2501     if (!page)
2502         return true;
2503 
2504     if (&amp;page-&gt;mainFrame() != m_frame.ptr())
2505         return true;
2506 
2507     ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator();
2508     if (!scrollingCoordinator)
2509         return true;
2510 
2511     if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2512         return true;
2513 
<a name="33" id="anc33"></a><span class="line-modified">2514     if (currentScrollType() == ScrollType::Programmatic)</span>
2515         return true;
2516 
2517     return false;
2518 #endif
2519     return true;
2520 }
2521 
2522 void FrameView::updateCompositingLayersAfterScrolling()
2523 {
2524     ASSERT(layoutContext().layoutPhase() &gt;= FrameViewLayoutContext::LayoutPhase::InPostLayout || layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::OutsideLayout);
2525 
2526     if (!shouldUpdateCompositingLayersAfterScrolling())
2527         return;
2528 
2529     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2530         if (RenderView* renderView = this-&gt;renderView())
2531             renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::OnScroll);
2532     }
2533 }
2534 
2535 bool FrameView::isRubberBandInProgress() const
2536 {
2537     if (scrollbarsSuppressed())
2538         return false;
2539 
2540     // If the scrolling thread updates the scroll position for this FrameView, then we should return
2541     // ScrollingCoordinator::isRubberBandInProgress().
2542     if (Page* page = frame().page()) {
2543         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
2544             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2545                 return scrollingCoordinator-&gt;isRubberBandInProgress();
2546         }
2547     }
2548 
2549     // If the main thread updates the scroll position for this FrameView, we should return
2550     // ScrollAnimator::isRubberBandInProgress().
2551     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
2552         return scrollAnimator-&gt;isRubberBandInProgress();
2553 
2554     return false;
2555 }
2556 
2557 bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position)
2558 {
2559     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
2560 
2561 #if ENABLE(ASYNC_SCROLLING)
2562     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
2563         tiledBacking-&gt;prepopulateRect(FloatRect(position, visibleContentRect().size()));
2564 #endif
2565 
2566 #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
2567     if (Page* page = frame().page()) {
2568         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
2569             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position);
2570     }
2571 #else
2572     UNUSED_PARAM(position);
2573 #endif
2574 
2575     return false;
2576 }
2577 
2578 HostWindow* FrameView::hostWindow() const
2579 {
2580     auto* page = frame().page();
2581     if (!page)
2582         return nullptr;
2583     return &amp;page-&gt;chrome();
2584 }
2585 
2586 void FrameView::addTrackedRepaintRect(const FloatRect&amp; r)
2587 {
2588     if (!m_isTrackingRepaints || r.isEmpty())
2589         return;
2590 
2591     FloatRect repaintRect = r;
2592     repaintRect.moveBy(-scrollPosition());
2593     m_trackedRepaintRects.append(repaintRect);
2594 }
2595 
2596 void FrameView::repaintContentRectangle(const IntRect&amp; r)
2597 {
2598     ASSERT(!frame().ownerElement());
2599 
2600     if (!shouldUpdate())
2601         return;
2602 
2603     ScrollView::repaintContentRectangle(r);
2604 }
2605 
2606 static unsigned countRenderedCharactersInRenderObjectWithThreshold(const RenderElement&amp; renderer, unsigned threshold)
2607 {
2608     unsigned count = 0;
2609     for (const RenderObject* descendant = &amp;renderer; descendant; descendant = descendant-&gt;nextInPreOrder()) {
2610         if (is&lt;RenderText&gt;(*descendant)) {
2611             count += downcast&lt;RenderText&gt;(*descendant).text().length();
2612             if (count &gt;= threshold)
2613                 break;
2614         }
2615     }
2616     return count;
2617 }
2618 
2619 bool FrameView::renderedCharactersExceed(unsigned threshold)
2620 {
2621     if (!frame().contentRenderer())
2622         return false;
2623     return countRenderedCharactersInRenderObjectWithThreshold(*frame().contentRenderer(), threshold) &gt;= threshold;
2624 }
2625 
2626 void FrameView::availableContentSizeChanged(AvailableSizeChangeReason reason)
2627 {
2628     if (Document* document = frame().document()) {
2629         // FIXME: Merge this logic with m_setNeedsLayoutWasDeferred and find a more appropriate
2630         // way of handling potential recursive layouts when the viewport is resized to accomodate
2631         // the content but the content always overflows the viewport. See webkit.org/b/165781.
2632         if (!(layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust &amp;&amp; useFixedLayout()))
2633             document-&gt;updateViewportUnitsOnResize();
2634     }
2635 
2636     updateLayoutViewport();
2637     setNeedsLayoutAfterViewConfigurationChange();
2638     ScrollView::availableContentSizeChanged(reason);
2639 }
2640 
2641 bool FrameView::shouldLayoutAfterContentsResized() const
2642 {
2643     return !useFixedLayout() || useCustomFixedPositionLayoutRect();
2644 }
2645 
2646 void FrameView::updateContentsSize()
2647 {
2648     // We check to make sure the view is attached to a frame() as this method can
2649     // be triggered before the view is attached by Frame::createView(...) setting
2650     // various values such as setScrollBarModes(...) for example.  An ASSERT is
2651     // triggered when a view is layout before being attached to a frame().
2652     if (!frame().view())
2653         return;
2654 
2655 #if PLATFORM(IOS_FAMILY)
2656     if (RenderView* root = m_frame-&gt;contentRenderer()) {
2657         if (useCustomFixedPositionLayoutRect() &amp;&amp; hasViewportConstrainedObjects()) {
2658             setViewportConstrainedObjectsNeedLayout();
2659             // We must eagerly enter compositing mode because fixed position elements
2660             // will not have been made compositing via a preceding style change before
2661             // m_useCustomFixedPositionLayoutRect was true.
2662             root-&gt;compositor().enableCompositingMode();
2663         }
2664     }
2665 #endif
2666 
2667     if (shouldLayoutAfterContentsResized() &amp;&amp; needsLayout())
2668         layoutContext().layout();
2669 
2670     if (RenderView* renderView = this-&gt;renderView()) {
2671         if (renderView-&gt;usesCompositing())
2672             renderView-&gt;compositor().frameViewDidChangeSize();
2673     }
2674 }
2675 
2676 void FrameView::addedOrRemovedScrollbar()
2677 {
2678     if (RenderView* renderView = this-&gt;renderView()) {
2679         if (renderView-&gt;usesCompositing())
2680             renderView-&gt;compositor().frameViewDidAddOrRemoveScrollbars();
2681     }
2682 
2683     updateTiledBackingAdaptiveSizing();
2684 }
2685 
2686 TiledBacking::Scrollability FrameView::computeScrollability() const
2687 {
2688     auto* page = frame().page();
2689 
2690     // Use smaller square tiles if the Window is not active to facilitate app napping.
2691     if (!page || !page-&gt;isWindowActive())
2692         return TiledBacking::HorizontallyScrollable | TiledBacking::VerticallyScrollable;
2693 
2694     bool horizontallyScrollable;
2695     bool verticallyScrollable;
2696     bool clippedByAncestorView = static_cast&lt;bool&gt;(m_viewExposedRect);
2697 
2698 #if PLATFORM(IOS_FAMILY)
2699     if (page)
2700         clippedByAncestorView |= page-&gt;enclosedInScrollableAncestorView();
2701 #endif
2702 
2703     if (delegatesScrolling()) {
2704         IntSize documentSize = contentsSize();
2705         IntSize visibleSize = this-&gt;visibleSize();
2706 
2707         horizontallyScrollable = clippedByAncestorView || documentSize.width() &gt; visibleSize.width();
2708         verticallyScrollable = clippedByAncestorView || documentSize.height() &gt; visibleSize.height();
2709     } else {
2710         horizontallyScrollable = clippedByAncestorView || horizontalScrollbar();
2711         verticallyScrollable = clippedByAncestorView || verticalScrollbar();
2712     }
2713 
2714     TiledBacking::Scrollability scrollability = TiledBacking::NotScrollable;
2715     if (horizontallyScrollable)
2716         scrollability = TiledBacking::HorizontallyScrollable;
2717 
2718     if (verticallyScrollable)
2719         scrollability |= TiledBacking::VerticallyScrollable;
2720 
2721     return scrollability;
2722 }
2723 
2724 void FrameView::updateTiledBackingAdaptiveSizing()
2725 {
2726     auto* tiledBacking = this-&gt;tiledBacking();
2727     if (!tiledBacking)
2728         return;
2729 
2730     tiledBacking-&gt;setScrollability(computeScrollability());
2731 }
2732 
<a name="34" id="anc34"></a><span class="line-modified">2733 // FIXME: This shouldn&#39;t be called from outside; FrameView should call it when the relevant viewports change.</span>
<span class="line-modified">2734 void FrameView::layoutOrVisualViewportChanged()</span>

2735 {
2736     if (!frame().settings().visualViewportAPIEnabled())
2737         return;
2738 
2739     if (auto* window = frame().window())
2740         window-&gt;visualViewport().update();
<a name="35" id="anc35"></a><span class="line-added">2741 </span>
<span class="line-added">2742     if (auto* page = frame().page()) {</span>
<span class="line-added">2743         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())</span>
<span class="line-added">2744             scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);</span>
<span class="line-added">2745     }</span>
2746 }
2747 
<a name="36" id="anc36"></a><span class="line-added">2748 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2749 </span>
2750 void FrameView::unobscuredContentSizeChanged()
2751 {
2752     updateTiledBackingAdaptiveSizing();
2753 }
2754 
2755 #endif
2756 
2757 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2758 {
2759     // We only throttle when constantly receiving new data during the inital page load.
2760     if (!page.progress().isMainLoadProgressing())
2761         return 0;
2762     // Scrolling during page loading disables throttling.
2763     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2764         return 0;
2765     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2766     auto* document = page.mainFrame().document();
2767     if (!document || is&lt;ImageDocument&gt;(*document))
2768         return 0;
2769     return LayerFlushThrottleState::Enabled;
2770 }
2771 
2772 void FrameView::disableLayerFlushThrottlingTemporarilyForInteraction()
2773 {
2774     if (!frame().page())
2775         return;
2776     auto&amp; page = *frame().page();
2777 
2778     LayerFlushThrottleState::Flags flags = LayerFlushThrottleState::UserIsInteracting | determineLayerFlushThrottleState(page);
2779     if (page.chrome().client().adjustLayerFlushThrottling(flags))
2780         return;
2781 
2782     if (RenderView* view = renderView())
2783         view-&gt;compositor().disableLayerFlushThrottlingTemporarilyForInteraction();
2784 }
2785 
2786 void FrameView::loadProgressingStatusChanged()
2787 {
2788     if (!m_isVisuallyNonEmpty &amp;&amp; frame().loader().isComplete())
2789         fireLayoutRelatedMilestonesIfNeeded();
2790     updateLayerFlushThrottling();
2791     adjustTiledBackingCoverage();
2792 }
2793 
2794 void FrameView::updateLayerFlushThrottling()
2795 {
2796     Page* page = frame().page();
2797     if (!page)
2798         return;
2799 
2800     ASSERT(frame().isMainFrame());
2801 
2802     LayerFlushThrottleState::Flags flags = determineLayerFlushThrottleState(*page);
2803 
2804     // See if the client is handling throttling.
2805     if (page-&gt;chrome().client().adjustLayerFlushThrottling(flags))
2806         return;
2807 
2808     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
2809         if (RenderView* renderView = frame-&gt;contentRenderer())
2810             renderView-&gt;compositor().setLayerFlushThrottlingEnabled(flags &amp; LayerFlushThrottleState::Enabled);
2811     }
2812 }
2813 
2814 void FrameView::adjustTiledBackingCoverage()
2815 {
2816     if (!m_speculativeTilingEnabled)
2817         enableSpeculativeTilingIfNeeded();
2818 
2819     RenderView* renderView = this-&gt;renderView();
2820     if (renderView &amp;&amp; renderView-&gt;layer() &amp;&amp; renderView-&gt;layer()-&gt;backing())
2821         renderView-&gt;layer()-&gt;backing()-&gt;adjustTiledBackingCoverage();
2822 #if PLATFORM(IOS_FAMILY)
2823     if (LegacyTileCache* tileCache = legacyTileCache())
2824         tileCache-&gt;setSpeculativeTileCreationEnabled(m_speculativeTilingEnabled);
2825 #endif
2826 }
2827 
2828 static bool shouldEnableSpeculativeTilingDuringLoading(const FrameView&amp; view)
2829 {
2830     Page* page = view.frame().page();
2831     return page &amp;&amp; view.isVisuallyNonEmpty() &amp;&amp; !page-&gt;progress().isMainLoadProgressing();
2832 }
2833 
2834 void FrameView::enableSpeculativeTilingIfNeeded()
2835 {
2836     ASSERT(!m_speculativeTilingEnabled);
2837     if (m_wasScrolledByUser) {
2838         m_speculativeTilingEnabled = true;
2839         return;
2840     }
2841     if (!shouldEnableSpeculativeTilingDuringLoading(*this))
2842         return;
2843 
2844     if (m_speculativeTilingDelayDisabledForTesting) {
2845         speculativeTilingEnableTimerFired();
2846         return;
2847     }
2848 
2849     if (m_speculativeTilingEnableTimer.isActive())
2850         return;
2851     // Delay enabling a bit as load completion may trigger further loading from scripts.
2852     static const Seconds speculativeTilingEnableDelay { 500_ms };
2853     m_speculativeTilingEnableTimer.startOneShot(speculativeTilingEnableDelay);
2854 }
2855 
2856 void FrameView::speculativeTilingEnableTimerFired()
2857 {
2858     if (m_speculativeTilingEnabled)
2859         return;
2860     m_speculativeTilingEnabled = shouldEnableSpeculativeTilingDuringLoading(*this);
2861     adjustTiledBackingCoverage();
2862 }
2863 
2864 void FrameView::show()
2865 {
2866     ScrollView::show();
2867 
2868     if (frame().isMainFrame()) {
2869         // Turn off speculative tiling for a brief moment after a FrameView appears on screen.
2870         // Note that adjustTiledBackingCoverage() kicks the (500ms) timer to re-enable it.
2871         m_speculativeTilingEnabled = false;
2872         m_wasScrolledByUser = false;
2873         adjustTiledBackingCoverage();
2874     }
2875 }
2876 
2877 void FrameView::hide()
2878 {
2879     ScrollView::hide();
2880     adjustTiledBackingCoverage();
2881 }
2882 
2883 bool FrameView::needsLayout() const
2884 {
2885     return layoutContext().needsLayout();
2886 }
2887 
2888 void FrameView::setNeedsLayoutAfterViewConfigurationChange()
2889 {
2890     layoutContext().setNeedsLayoutAfterViewConfigurationChange();
2891 }
2892 
2893 void FrameView::setNeedsCompositingConfigurationUpdate()
2894 {
2895     RenderView* renderView = this-&gt;renderView();
<a name="37" id="anc37"></a><span class="line-modified">2896     if (renderView &amp;&amp; renderView-&gt;usesCompositing()) {</span>
2897         if (auto* rootLayer = renderView-&gt;layer())
2898             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
2899         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2900     }
2901 }
2902 
2903 void FrameView::setNeedsCompositingGeometryUpdate()
2904 {
2905     RenderView* renderView = this-&gt;renderView();
2906     if (renderView-&gt;usesCompositing()) {
2907         if (auto* rootLayer = renderView-&gt;layer())
2908             rootLayer-&gt;setNeedsCompositingGeometryUpdate();
2909         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2910     }
2911 }
2912 
2913 void FrameView::scheduleSelectionUpdate()
2914 {
2915     if (needsLayout())
2916         return;
2917     // FIXME: We should not need to go through the layout process since selection update does not change dimension/geometry.
2918     // However we can&#39;t tell at this point if the tree is stable yet, so let&#39;s just schedule a root only layout for now.
2919     setNeedsLayoutAfterViewConfigurationChange();
2920 }
2921 
2922 bool FrameView::isTransparent() const
2923 {
2924     return m_isTransparent;
2925 }
2926 
2927 void FrameView::setTransparent(bool isTransparent)
2928 {
2929     if (m_isTransparent == isTransparent)
2930         return;
2931 
2932     m_isTransparent = isTransparent;
2933 
2934     // setTransparent can be called in the window between FrameView initialization
2935     // and switching in the new Document; this means that the RenderView that we
2936     // retrieve is actually attached to the previous Document, which is going away,
2937     // and must not update compositing layers.
2938     if (!isViewForDocumentInFrame())
2939         return;
2940 
2941     setNeedsLayoutAfterViewConfigurationChange();
2942     setNeedsCompositingConfigurationUpdate();
2943 }
2944 
2945 bool FrameView::hasOpaqueBackground() const
2946 {
2947     return !m_isTransparent &amp;&amp; m_baseBackgroundColor.isOpaque();
2948 }
2949 
2950 Color FrameView::baseBackgroundColor() const
2951 {
2952     return m_baseBackgroundColor;
2953 }
2954 
2955 void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
2956 {
<a name="38" id="anc38"></a><span class="line-modified">2957     Color newBaseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;</span>
<span class="line-added">2958     if (m_baseBackgroundColor == newBaseBackgroundColor)</span>
<span class="line-added">2959         return;</span>
<span class="line-added">2960 </span>
<span class="line-added">2961     m_baseBackgroundColor = newBaseBackgroundColor;</span>
2962 
2963     if (!isViewForDocumentInFrame())
2964         return;
2965 
2966     recalculateScrollbarOverlayStyle();
2967     setNeedsLayoutAfterViewConfigurationChange();
2968     setNeedsCompositingConfigurationUpdate();
2969 }
2970 
2971 void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
2972 {
<a name="39" id="anc39"></a><span class="line-modified">2973 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
2974     Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
2975 #else
2976     Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
2977 #endif
2978 
2979     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
2980         if (FrameView* view = frame-&gt;view()) {
2981             view-&gt;setTransparent(!baseBackgroundColor.isVisible());
2982             view-&gt;setBaseBackgroundColor(baseBackgroundColor);
2983             if (view-&gt;needsLayout())
2984                 view-&gt;layoutContext().scheduleLayout();
2985         }
2986     }
2987 }
2988 
2989 bool FrameView::hasExtendedBackgroundRectForPainting() const
2990 {
2991     TiledBacking* tiledBacking = this-&gt;tiledBacking();
2992     if (!tiledBacking)
2993         return false;
2994 
2995     return tiledBacking-&gt;hasMargins();
2996 }
2997 
2998 void FrameView::updateExtendBackgroundIfNecessary()
2999 {
3000     ExtendedBackgroundMode mode = calculateExtendedBackgroundMode();
3001     if (mode == ExtendedBackgroundModeNone)
3002         return;
3003 
3004     updateTilesForExtendedBackgroundMode(mode);
3005 }
3006 
3007 FrameView::ExtendedBackgroundMode FrameView::calculateExtendedBackgroundMode() const
3008 {
3009 #if PLATFORM(IOS_FAMILY)
3010     // &lt;rdar://problem/16201373&gt;
3011     return ExtendedBackgroundModeNone;
3012 #else
3013     if (!frame().settings().backgroundShouldExtendBeyondPage())
3014         return ExtendedBackgroundModeNone;
3015 
3016     // Just because Settings::backgroundShouldExtendBeyondPage() is true does not necessarily mean
3017     // that the background rect needs to be extended for painting. Simple backgrounds can be extended
3018     // just with RenderLayerCompositor&#39;s rootExtendedBackgroundColor. More complicated backgrounds,
3019     // such as images, require extending the background rect to continue painting into the extended
3020     // region. This function finds out if it is necessary to extend the background rect for painting.
3021 
3022     if (!frame().isMainFrame())
3023         return ExtendedBackgroundModeNone;
3024 
3025     Document* document = frame().document();
3026     if (!document)
3027         return ExtendedBackgroundModeNone;
3028 
3029     if (!renderView())
3030         return ExtendedBackgroundModeNone;
3031 
3032     auto* rootBackgroundRenderer = renderView()-&gt;rendererForRootBackground();
3033     if (!rootBackgroundRenderer)
3034         return ExtendedBackgroundModeNone;
3035 
3036     if (!rootBackgroundRenderer-&gt;style().hasBackgroundImage())
3037         return ExtendedBackgroundModeNone;
3038 
3039     ExtendedBackgroundMode mode = ExtendedBackgroundModeNone;
3040     if (rootBackgroundRenderer-&gt;style().backgroundRepeatX() == FillRepeat::Repeat)
3041         mode |= ExtendedBackgroundModeHorizontal;
3042     if (rootBackgroundRenderer-&gt;style().backgroundRepeatY() == FillRepeat::Repeat)
3043         mode |= ExtendedBackgroundModeVertical;
3044 
3045     return mode;
3046 #endif
3047 }
3048 
3049 void FrameView::updateTilesForExtendedBackgroundMode(ExtendedBackgroundMode mode)
3050 {
3051     RenderView* renderView = this-&gt;renderView();
3052     if (!renderView)
3053         return;
3054 
3055     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
3056     if (!backing)
3057         return;
3058 
3059     TiledBacking* tiledBacking = backing-&gt;tiledBacking();
3060     if (!tiledBacking)
3061         return;
3062 
3063     ExtendedBackgroundMode existingMode = ExtendedBackgroundModeNone;
3064     if (tiledBacking-&gt;hasVerticalMargins())
3065         existingMode |= ExtendedBackgroundModeVertical;
3066     if (tiledBacking-&gt;hasHorizontalMargins())
3067         existingMode |= ExtendedBackgroundModeHorizontal;
3068 
3069     if (existingMode == mode)
3070         return;
3071 
3072     backing-&gt;setTiledBackingHasMargins(mode &amp; ExtendedBackgroundModeHorizontal, mode &amp; ExtendedBackgroundModeVertical);
3073 }
3074 
3075 IntRect FrameView::extendedBackgroundRectForPainting() const
3076 {
3077     TiledBacking* tiledBacking = this-&gt;tiledBacking();
3078     if (!tiledBacking)
3079         return IntRect();
3080 
3081     RenderView* renderView = this-&gt;renderView();
3082     if (!renderView)
3083         return IntRect();
3084 
3085     LayoutRect extendedRect = renderView-&gt;unextendedBackgroundRect();
3086     if (!tiledBacking-&gt;hasMargins())
3087         return snappedIntRect(extendedRect);
3088 
3089     extendedRect.moveBy(LayoutPoint(-tiledBacking-&gt;leftMarginWidth(), -tiledBacking-&gt;topMarginHeight()));
3090     extendedRect.expand(LayoutSize(tiledBacking-&gt;leftMarginWidth() + tiledBacking-&gt;rightMarginWidth(), tiledBacking-&gt;topMarginHeight() + tiledBacking-&gt;bottomMarginHeight()));
3091     return snappedIntRect(extendedRect);
3092 }
3093 
3094 bool FrameView::shouldUpdateWhileOffscreen() const
3095 {
3096     return m_shouldUpdateWhileOffscreen;
3097 }
3098 
3099 void FrameView::setShouldUpdateWhileOffscreen(bool shouldUpdateWhileOffscreen)
3100 {
3101     m_shouldUpdateWhileOffscreen = shouldUpdateWhileOffscreen;
3102 }
3103 
3104 bool FrameView::shouldUpdate() const
3105 {
3106     if (isOffscreen() &amp;&amp; !shouldUpdateWhileOffscreen())
3107         return false;
3108     return true;
3109 }
3110 
3111 bool FrameView::safeToPropagateScrollToParent() const
3112 {
3113     auto* document = frame().document();
3114     if (!document)
3115         return false;
3116 
3117     auto* parentFrame = frame().tree().parent();
3118     if (!parentFrame)
3119         return false;
3120 
3121     auto* parentDocument = parentFrame-&gt;document();
3122     if (!parentDocument)
3123         return false;
3124 
3125     return document-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin());
3126 }
3127 
3128 void FrameView::scrollToAnchor()
3129 {
3130     RefPtr&lt;ContainerNode&gt; anchorNode = m_maintainScrollPositionAnchor;
3131 
3132     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::scrollToAnchor() &quot; &lt;&lt; anchorNode.get());
3133 
3134     if (!anchorNode)
3135         return;
3136 
3137     if (!anchorNode-&gt;renderer())
3138         return;
3139     m_shouldScrollToFocusedElement = false;
3140     m_delayedScrollToFocusedElementTimer.stop();
3141 
3142     LayoutRect rect;
3143     bool insideFixed = false;
3144     if (anchorNode != frame().document() &amp;&amp; anchorNode-&gt;renderer())
3145         rect = anchorNode-&gt;renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
3146 
3147     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; anchor node rect &quot; &lt;&lt; rect);
3148 
3149     // Scroll nested layers and frames to reveal the anchor.
3150     // Align to the top and to the closest side (this matches other browsers).
3151     if (anchorNode-&gt;renderer()-&gt;style().isHorizontalWritingMode())
3152         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
3153     else if (anchorNode-&gt;renderer()-&gt;style().isFlippedBlocksWritingMode())
3154         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignRightAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3155     else
3156         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignLeftAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3157 
3158     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3159         cache-&gt;handleScrolledToAnchor(anchorNode.get());
3160 
3161     // scrollRectToVisible can call into setScrollPosition(), which resets m_maintainScrollPositionAnchor.
3162     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; restoring anchor node to &quot; &lt;&lt; anchorNode.get());
3163     m_maintainScrollPositionAnchor = anchorNode;
3164     m_shouldScrollToFocusedElement = false;
3165     m_delayedScrollToFocusedElementTimer.stop();
3166 }
3167 
3168 void FrameView::updateEmbeddedObject(RenderEmbeddedObject&amp; embeddedObject)
3169 {
3170     // No need to update if it&#39;s already crashed or known to be missing.
3171     if (embeddedObject.isPluginUnavailable())
3172         return;
3173 
3174     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
3175 
3176     if (embeddedObject.isSnapshottedPlugIn()) {
3177         if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
3178             HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3179             pluginElement.checkSnapshotStatus();
3180         }
3181         return;
3182     }
3183 
3184     auto weakRenderer = makeWeakPtr(embeddedObject);
3185 
3186     // FIXME: This could turn into a real virtual dispatch if we defined
3187     // updateWidget(PluginCreationOption) on HTMLElement.
3188     if (is&lt;HTMLPlugInImageElement&gt;(element)) {
3189         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3190         if (pluginElement.needsCheckForSizeChange()) {
3191             pluginElement.checkSnapshotStatus();
3192             return;
3193         }
3194         if (pluginElement.needsWidgetUpdate())
3195             pluginElement.updateWidget(CreatePlugins::Yes);
3196     } else
3197         ASSERT_NOT_REACHED();
3198 
3199     // It&#39;s possible the renderer was destroyed below updateWidget() since loading a plugin may execute arbitrary JavaScript.
3200     if (!weakRenderer)
3201         return;
3202 
3203     auto ignoreWidgetState = embeddedObject.updateWidgetPosition();
3204     UNUSED_PARAM(ignoreWidgetState);
3205 }
3206 
3207 bool FrameView::updateEmbeddedObjects()
3208 {
3209     if (layoutContext().isLayoutNested() || !m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty())
3210         return true;
3211 
3212     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
3213 
3214     // Insert a marker for where we should stop.
3215     ASSERT(!m_embeddedObjectsToUpdate-&gt;contains(nullptr));
3216     m_embeddedObjectsToUpdate-&gt;add(nullptr);
3217 
3218     while (!m_embeddedObjectsToUpdate-&gt;isEmpty()) {
3219         RenderEmbeddedObject* embeddedObject = m_embeddedObjectsToUpdate-&gt;takeFirst();
3220         if (!embeddedObject)
3221             break;
3222         updateEmbeddedObject(*embeddedObject);
3223     }
3224 
3225     return m_embeddedObjectsToUpdate-&gt;isEmpty();
3226 }
3227 
3228 void FrameView::updateEmbeddedObjectsTimerFired()
3229 {
3230     RefPtr&lt;FrameView&gt; protectedThis(this);
3231     m_updateEmbeddedObjectsTimer.stop();
3232     for (unsigned i = 0; i &lt; maxUpdateEmbeddedObjectsIterations; i++) {
3233         if (updateEmbeddedObjects())
3234             break;
3235     }
3236 }
3237 
3238 void FrameView::flushAnyPendingPostLayoutTasks()
3239 {
3240     layoutContext().flushAsynchronousTasks();
3241     if (m_updateEmbeddedObjectsTimer.isActive())
3242         updateEmbeddedObjectsTimerFired();
3243 }
3244 
3245 void FrameView::queuePostLayoutCallback(Function&lt;void()&gt;&amp;&amp; callback)
3246 {
3247     m_postLayoutCallbackQueue.append(WTFMove(callback));
3248 }
3249 
3250 void FrameView::flushPostLayoutTasksQueue()
3251 {
3252     if (layoutContext().isLayoutNested())
3253         return;
3254 
3255     if (!m_postLayoutCallbackQueue.size())
3256         return;
3257 
3258     Vector&lt;Function&lt;void()&gt;&gt; queue = WTFMove(m_postLayoutCallbackQueue);
3259     for (auto&amp; task : queue)
3260         task();
3261 }
3262 
3263 void FrameView::performPostLayoutTasks()
3264 {
3265     // FIXME: We should not run any JavaScript code in this function.
3266     LOG(Layout, &quot;FrameView %p performPostLayoutTasks&quot;, this);
3267     updateHasReachedSignificantRenderedTextThreshold();
3268     frame().selection().updateAppearanceAfterLayout();
3269 
3270     flushPostLayoutTasksQueue();
3271 
3272     if (!layoutContext().isLayoutNested() &amp;&amp; frame().document()-&gt;documentElement())
3273         fireLayoutRelatedMilestonesIfNeeded();
3274 
3275 #if PLATFORM(IOS_FAMILY)
3276     // Only send layout-related delegate callbacks synchronously for the main frame to
3277     // avoid re-entering layout for the main frame while delivering a layout-related delegate
3278     // callback for a subframe.
3279     if (frame().isMainFrame()) {
3280         if (Page* page = frame().page())
3281             page-&gt;chrome().client().didLayout();
3282     }
3283 #endif
3284 
3285     // FIXME: We should consider adding DidLayout as a LayoutMilestone. That would let us merge this
3286     // with didLayout(LayoutMilestones).
3287     frame().loader().client().dispatchDidLayout();
3288 
3289     updateWidgetPositions();
3290 
3291 #if ENABLE(CSS_SCROLL_SNAP)
3292     updateSnapOffsets();
3293 #endif
3294     m_updateEmbeddedObjectsTimer.startOneShot(0_s);
3295 
3296     if (auto* page = frame().page()) {
3297         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
3298             scrollingCoordinator-&gt;frameViewLayoutUpdated(*this);
3299     }
3300 
3301     if (RenderView* renderView = this-&gt;renderView()) {
3302         if (renderView-&gt;usesCompositing())
3303             renderView-&gt;compositor().frameViewDidLayout();
3304     }
3305 
3306     scrollToAnchor();
3307 
3308     sendResizeEventIfNeeded();
3309 
3310     updateLayoutViewport();
3311     viewportContentsChanged();
3312 
3313     updateScrollSnapState();
3314 
3315     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3316         cache-&gt;performDeferredCacheUpdate();
3317 }
3318 
3319 IntSize FrameView::sizeForResizeEvent() const
3320 {
3321 #if PLATFORM(IOS_FAMILY)
3322     if (m_useCustomSizeForResizeEvent)
3323         return m_customSizeForResizeEvent;
3324 #endif
3325     if (useFixedLayout() &amp;&amp; !fixedLayoutSize().isEmpty() &amp;&amp; delegatesScrolling())
3326         return fixedLayoutSize();
3327     return visibleContentRectIncludingScrollbars().size();
3328 }
3329 
3330 void FrameView::sendResizeEventIfNeeded()
3331 {
3332     if (layoutContext().isInRenderTreeLayout() || needsLayout())
3333         return;
3334 
3335     RenderView* renderView = this-&gt;renderView();
3336     if (!renderView || renderView-&gt;printing())
3337         return;
3338 
3339     if (frame().page() &amp;&amp; frame().page()-&gt;chrome().client().isSVGImageChromeClient())
3340         return;
3341 
3342     IntSize currentSize = sizeForResizeEvent();
3343     float currentZoomFactor = renderView-&gt;style().zoom();
3344 
3345     if (currentSize == m_lastViewportSize &amp;&amp; currentZoomFactor == m_lastZoomFactor)
3346         return;
3347 
3348     m_lastViewportSize = currentSize;
3349     m_lastZoomFactor = currentZoomFactor;
3350 
3351     if (!layoutContext().didFirstLayout())
3352         return;
3353 
3354 #if PLATFORM(IOS_FAMILY)
3355     // Don&#39;t send the resize event if the document is loading. Some pages automatically reload
3356     // when the window is resized; Safari on iOS often resizes the window while setting up its
3357     // viewport. This obviously can cause problems.
3358     if (DocumentLoader* documentLoader = frame().loader().documentLoader()) {
3359         if (documentLoader-&gt;isLoadingInAPISense())
3360             return;
3361     }
3362 #endif
3363 
3364     bool isMainFrame = frame().isMainFrame();
3365     bool canSendResizeEventSynchronously = isMainFrame &amp;&amp; !m_shouldAutoSize;
3366 
3367     LOG(Events, &quot;FrameView %p sendResizeEventIfNeeded sending resize event, size %dx%d (canSendResizeEventSynchronously %d)&quot;, this, currentSize.width(), currentSize.height(), canSendResizeEventSynchronously);
3368 
3369     Ref&lt;Event&gt; resizeEvent = Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No);
3370     if (canSendResizeEventSynchronously)
3371         frame().document()-&gt;dispatchWindowEvent(resizeEvent);
3372     else {
3373         // FIXME: Queueing this event for an unpredictable time in the future seems
3374         // intrinsically racy. By the time this resize event fires, the frame might
3375         // be resized again, so we could end up with two resize events for the same size.
3376         frame().document()-&gt;enqueueWindowEvent(WTFMove(resizeEvent));
3377     }
3378 
3379     if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
3380         if (Page* page = frame().page()) {
3381             if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
3382                 inspectorClient-&gt;didResizeMainFrame(&amp;frame());
3383         }
3384     }
3385 }
3386 
3387 void FrameView::willStartLiveResize()
3388 {
3389     ScrollView::willStartLiveResize();
3390     adjustTiledBackingCoverage();
3391 }
3392 
3393 void FrameView::willEndLiveResize()
3394 {
3395     ScrollView::willEndLiveResize();
3396     adjustTiledBackingCoverage();
3397 }
3398 
3399 void FrameView::autoSizeIfEnabled()
3400 {
3401     if (!m_shouldAutoSize)
3402         return;
3403 
3404     if (m_inAutoSize)
3405         return;
3406 
3407     auto* document = frame().document();
3408     if (!document)
3409         return;
3410 
3411     auto* renderView = document-&gt;renderView();
3412     if (!renderView)
3413         return;
3414 
<a name="40" id="anc40"></a><span class="line-added">3415     auto* firstChild = renderView-&gt;firstChild();</span>
<span class="line-added">3416     if (!firstChild)</span>
<span class="line-added">3417         return;</span>
<span class="line-added">3418 </span>
3419     LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
3420     SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
3421     if (layoutContext().subtreeLayoutRoot())
3422         layoutContext().convertSubtreeLayoutToFullLayout();
<a name="41" id="anc41"></a>















































3423 
<a name="42" id="anc42"></a><span class="line-modified">3424     ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-modified">3425     ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-added">3426     setVerticalScrollbarLock(false);</span>
<span class="line-added">3427     setHorizontalScrollbarLock(false);</span>
<span class="line-added">3428     setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);</span>
3429 
<a name="43" id="anc43"></a><span class="line-modified">3430     ASSERT(is&lt;RenderElement&gt;(*firstChild));</span>
<span class="line-modified">3431     auto&amp; documentRenderer = downcast&lt;RenderElement&gt;(*firstChild);</span>
<span class="line-modified">3432     documentRenderer.mutableStyle().setMaxWidth(Length(m_autoSizeConstraint.width(), Fixed));</span>
<span class="line-modified">3433     resize(m_autoSizeConstraint.width(), m_autoSizeConstraint.height());</span>

3434 
<a name="44" id="anc44"></a>









3435     Ref&lt;FrameView&gt; protectedThis(*this);
<a name="45" id="anc45"></a>
3436     document-&gt;updateStyleIfNeeded();
<a name="46" id="anc46"></a><span class="line-modified">3437     document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">3438     // While the final content size could slightly be different after the next resize/layout (see below), we intentionally save and report</span>
<span class="line-added">3439     // the current value to avoid unstable layout (e.g. content &quot;height: 100%&quot;).</span>
<span class="line-added">3440     // See also webkit.org/b/173561</span>
3441     m_autoSizeContentSize = contentsSize();
<a name="47" id="anc47"></a>





3442 
<a name="48" id="anc48"></a><span class="line-modified">3443     auto finalWidth = std::max(m_autoSizeConstraint.width(), m_autoSizeContentSize.width());</span>
<span class="line-added">3444     auto finalHeight = m_autoSizeFixedMinimumHeight ? std::max(m_autoSizeFixedMinimumHeight, m_autoSizeContentSize.height()) : m_autoSizeContentSize.height();</span>
<span class="line-added">3445     resize(finalWidth, finalHeight);</span>
<span class="line-added">3446     document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">3447     if (auto* page = frame().page())</span>
<span class="line-added">3448         page-&gt;chrome().client().intrinsicContentsSizeChanged(m_autoSizeContentSize);</span>
<span class="line-added">3449     m_didRunAutosize = true;</span>
3450 }
3451 
3452 void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
3453 {
3454     if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
3455         return;
3456 
3457     m_autoSizeFixedMinimumHeight = fixedMinimumHeight;
3458 
3459     setNeedsLayoutAfterViewConfigurationChange();
3460 }
3461 
3462 RenderElement* FrameView::viewportRenderer() const
3463 {
3464     if (m_viewportRendererType == ViewportRendererType::None)
3465         return nullptr;
3466 
3467     auto* document = frame().document();
3468     if (!document)
3469         return nullptr;
3470 
3471     if (m_viewportRendererType == ViewportRendererType::Document) {
3472         auto* documentElement = document-&gt;documentElement();
3473         if (!documentElement)
3474             return nullptr;
3475         return documentElement-&gt;renderer();
3476     }
3477 
3478     if (m_viewportRendererType == ViewportRendererType::Body) {
3479         auto* body = document-&gt;body();
3480         if (!body)
3481             return nullptr;
3482         return body-&gt;renderer();
3483     }
3484 
3485     ASSERT_NOT_REACHED();
3486     return nullptr;
3487 }
3488 
3489 void FrameView::updateOverflowStatus(bool horizontalOverflow, bool verticalOverflow)
3490 {
3491     auto* viewportRenderer = this-&gt;viewportRenderer();
3492     if (!viewportRenderer)
3493         return;
3494 
3495     if (m_overflowStatusDirty) {
3496         m_horizontalOverflow = horizontalOverflow;
3497         m_verticalOverflow = verticalOverflow;
3498         m_overflowStatusDirty = false;
3499         return;
3500     }
3501 
3502     bool horizontalOverflowChanged = (m_horizontalOverflow != horizontalOverflow);
3503     bool verticalOverflowChanged = (m_verticalOverflow != verticalOverflow);
3504 
3505     if (horizontalOverflowChanged || verticalOverflowChanged) {
3506         m_horizontalOverflow = horizontalOverflow;
3507         m_verticalOverflow = verticalOverflow;
3508 
3509         Ref&lt;OverflowEvent&gt; overflowEvent = OverflowEvent::create(horizontalOverflowChanged, horizontalOverflow,
3510             verticalOverflowChanged, verticalOverflow);
3511         overflowEvent-&gt;setTarget(viewportRenderer-&gt;element());
3512 
3513         frame().document()-&gt;enqueueOverflowEvent(WTFMove(overflowEvent));
3514     }
3515 }
3516 
3517 const Pagination&amp; FrameView::pagination() const
3518 {
3519     if (m_pagination != Pagination())
3520         return m_pagination;
3521 
3522     if (frame().isMainFrame()) {
3523         if (Page* page = frame().page())
3524             return page-&gt;pagination();
3525     }
3526 
3527     return m_pagination;
3528 }
3529 
3530 void FrameView::setPagination(const Pagination&amp; pagination)
3531 {
3532     if (m_pagination == pagination)
3533         return;
3534 
3535     m_pagination = pagination;
3536 
3537     frame().document()-&gt;styleScope().didChangeStyleSheetEnvironment();
3538 }
3539 
3540 IntRect FrameView::windowClipRect() const
3541 {
3542     ASSERT(frame().view() == this);
3543 
3544     if (m_cachedWindowClipRect)
3545         return *m_cachedWindowClipRect;
3546 
3547     if (paintsEntireContents())
3548         return contentsToWindow(IntRect(IntPoint(), totalContentsSize()));
3549 
3550     // Set our clip rect to be our contents.
3551     IntRect clipRect = contentsToWindow(visibleContentRect(LegacyIOSDocumentVisibleRect));
3552 
3553     if (!frame().ownerElement())
3554         return clipRect;
3555 
3556     // Take our owner element and get its clip rect.
3557     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
3558     if (FrameView* parentView = ownerElement-&gt;document().view())
3559         clipRect.intersect(parentView-&gt;windowClipRectForFrameOwner(ownerElement, true));
3560     return clipRect;
3561 }
3562 
3563 IntRect FrameView::windowClipRectForFrameOwner(const HTMLFrameOwnerElement* ownerElement, bool clipToLayerContents) const
3564 {
3565     // The renderer can sometimes be null when style=&quot;display:none&quot; interacts
3566     // with external content and plugins.
3567     if (!ownerElement-&gt;renderer())
3568         return windowClipRect();
3569 
3570     // If we have no layer, just return our window clip rect.
3571     const RenderLayer* enclosingLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
3572     if (!enclosingLayer)
3573         return windowClipRect();
3574 
3575     // Apply the clip from the layer.
3576     IntRect clipRect;
3577     if (clipToLayerContents)
3578         clipRect = snappedIntRect(enclosingLayer-&gt;childrenClipRect());
3579     else
3580         clipRect = snappedIntRect(enclosingLayer-&gt;selfClipRect());
3581     clipRect = contentsToWindow(clipRect);
3582     return intersection(clipRect, windowClipRect());
3583 }
3584 
3585 bool FrameView::isActive() const
3586 {
3587     Page* page = frame().page();
3588     return page &amp;&amp; page-&gt;focusController().isActive();
3589 }
3590 
3591 bool FrameView::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
3592 {
3593     Page* page = frame().page();
3594     return page &amp;&amp; page-&gt;settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
3595 }
3596 
3597 void FrameView::scrollTo(const ScrollPosition&amp; newPosition)
3598 {
3599     IntPoint oldPosition = scrollPosition();
3600     ScrollView::scrollTo(newPosition);
3601     if (oldPosition != scrollPosition())
3602         scrollPositionChanged(oldPosition, scrollPosition());
3603 
3604     didChangeScrollOffset();
3605 }
3606 
3607 float FrameView::adjustScrollStepForFixedContent(float step, ScrollbarOrientation orientation, ScrollGranularity granularity)
3608 {
3609     if (granularity != ScrollByPage || orientation == HorizontalScrollbar)
3610         return step;
3611 
3612     TrackedRendererListHashSet* positionedObjects = nullptr;
3613     if (RenderView* root = frame().contentRenderer()) {
3614         if (!root-&gt;hasPositionedObjects())
3615             return step;
3616         positionedObjects = root-&gt;positionedObjects();
3617     }
3618 
3619     FloatRect unobscuredContentRect = this-&gt;unobscuredContentRect();
3620     float topObscuredArea = 0;
3621     float bottomObscuredArea = 0;
3622     for (const auto&amp; positionedObject : *positionedObjects) {
3623         const RenderStyle&amp; style = positionedObject-&gt;style();
3624         if (style.position() != PositionType::Fixed || style.visibility() == Visibility::Hidden || !style.opacity())
3625             continue;
3626 
3627         FloatQuad contentQuad = positionedObject-&gt;absoluteContentQuad();
3628         if (!contentQuad.isRectilinear())
3629             continue;
3630 
3631         FloatRect contentBoundingBox = contentQuad.boundingBox();
3632         FloatRect fixedRectInView = intersection(unobscuredContentRect, contentBoundingBox);
3633 
3634         if (fixedRectInView.width() &lt; unobscuredContentRect.width())
3635             continue;
3636 
3637         if (fixedRectInView.y() == unobscuredContentRect.y())
3638             topObscuredArea = std::max(topObscuredArea, fixedRectInView.height());
3639         else if (fixedRectInView.maxY() == unobscuredContentRect.maxY())
3640             bottomObscuredArea = std::max(bottomObscuredArea, fixedRectInView.height());
3641     }
3642 
3643     return Scrollbar::pageStep(unobscuredContentRect.height(), unobscuredContentRect.height() - topObscuredArea - bottomObscuredArea);
3644 }
3645 
3646 void FrameView::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3647 {
3648     // Add in our offset within the FrameView.
3649     IntRect dirtyRect = rect;
3650     dirtyRect.moveBy(scrollbar.location());
3651     invalidateRect(dirtyRect);
3652 }
3653 
3654 float FrameView::visibleContentScaleFactor() const
3655 {
3656     if (!frame().isMainFrame() || !frame().settings().delegatesPageScaling())
3657         return 1;
3658 
3659     Page* page = frame().page();
3660     if (!page)
3661         return 1;
3662 
3663     return page-&gt;pageScaleFactor();
3664 }
3665 
3666 void FrameView::setVisibleScrollerThumbRect(const IntRect&amp; scrollerThumb)
3667 {
3668     if (!frame().isMainFrame())
3669         return;
3670 
3671     if (Page* page = frame().page())
3672         page-&gt;chrome().client().notifyScrollerThumbIsVisibleInRect(scrollerThumb);
3673 }
3674 
3675 ScrollableArea* FrameView::enclosingScrollableArea() const
3676 {
3677     // FIXME: Walk up the frame tree and look for a scrollable parent frame or RenderLayer.
3678     return nullptr;
3679 }
3680 
3681 IntRect FrameView::scrollableAreaBoundingBox(bool*) const
3682 {
3683     RenderWidget* ownerRenderer = frame().ownerRenderer();
3684     if (!ownerRenderer)
3685         return frameRect();
3686 
3687     return ownerRenderer-&gt;absoluteContentQuad().enclosingBoundingBox();
3688 }
3689 
3690 bool FrameView::isScrollable(Scrollability definitionOfScrollable)
3691 {
3692     // Check for:
3693     // 1) If there an actual overflow.
3694     // 2) display:none or visibility:hidden set to self or inherited.
3695     // 3) overflow{-x,-y}: hidden;
3696     // 4) scrolling: no;
3697     if (!didFirstLayout())
3698         return false;
3699 
3700     bool requiresActualOverflowToBeConsideredScrollable = !frame().isMainFrame() || definitionOfScrollable != Scrollability::ScrollableOrRubberbandable;
3701 #if !ENABLE(RUBBER_BANDING)
3702     requiresActualOverflowToBeConsideredScrollable = true;
3703 #endif
3704 
3705     // Covers #1
3706     if (requiresActualOverflowToBeConsideredScrollable) {
3707         IntSize totalContentsSize = this-&gt;totalContentsSize();
3708         IntSize visibleContentSize = visibleContentRect(LegacyIOSDocumentVisibleRect).size();
3709         if (totalContentsSize.height() &lt;= visibleContentSize.height() &amp;&amp; totalContentsSize.width() &lt;= visibleContentSize.width())
3710             return false;
3711     }
3712 
3713     // Covers #2.
3714     HTMLFrameOwnerElement* owner = frame().ownerElement();
3715     if (owner &amp;&amp; (!owner-&gt;renderer() || !owner-&gt;renderer()-&gt;visibleToHitTesting()))
3716         return false;
3717 
3718     // Cover #3 and #4.
3719     ScrollbarMode horizontalMode;
3720     ScrollbarMode verticalMode;
3721     calculateScrollbarModesForLayout(horizontalMode, verticalMode, RulesFromWebContentOnly);
3722     if (horizontalMode == ScrollbarAlwaysOff &amp;&amp; verticalMode == ScrollbarAlwaysOff)
3723         return false;
3724 
3725     return true;
3726 }
3727 
3728 bool FrameView::isScrollableOrRubberbandable()
3729 {
3730     return isScrollable(Scrollability::ScrollableOrRubberbandable);
3731 }
3732 
3733 bool FrameView::hasScrollableOrRubberbandableAncestor()
3734 {
3735     if (frame().isMainFrame())
3736         return isScrollableOrRubberbandable();
3737 
3738     for (FrameView* parent = this-&gt;parentFrameView(); parent; parent = parent-&gt;parentFrameView()) {
3739         Scrollability frameScrollability = parent-&gt;frame().isMainFrame() ? Scrollability::ScrollableOrRubberbandable : Scrollability::Scrollable;
3740         if (parent-&gt;isScrollable(frameScrollability))
3741             return true;
3742     }
3743 
3744     return false;
3745 }
3746 
3747 void FrameView::updateScrollableAreaSet()
3748 {
3749     // That ensures that only inner frames are cached.
3750     FrameView* parentFrameView = this-&gt;parentFrameView();
3751     if (!parentFrameView)
3752         return;
3753 
3754     if (!isScrollable()) {
3755         parentFrameView-&gt;removeScrollableArea(this);
3756         return;
3757     }
3758 
3759     parentFrameView-&gt;addScrollableArea(this);
3760 }
3761 
3762 bool FrameView::shouldSuspendScrollAnimations() const
3763 {
3764     return frame().loader().state() != FrameStateComplete;
3765 }
3766 
3767 void FrameView::scrollbarStyleChanged(ScrollbarStyle newStyle, bool forceUpdate)
3768 {
3769     if (!frame().isMainFrame())
3770         return;
3771 
3772     if (Page* page = frame().page())
3773         page-&gt;chrome().client().recommendedScrollbarStyleDidChange(newStyle);
3774 
3775     ScrollView::scrollbarStyleChanged(newStyle, forceUpdate);
3776 }
3777 
3778 void FrameView::notifyPageThatContentAreaWillPaint() const
3779 {
3780     Page* page = frame().page();
3781     if (!page)
3782         return;
3783 
3784     contentAreaWillPaint();
3785 
3786     if (!m_scrollableAreas)
3787         return;
3788 
3789     for (auto&amp; scrollableArea : *m_scrollableAreas)
3790         scrollableArea-&gt;contentAreaWillPaint();
3791 }
3792 
3793 bool FrameView::scrollAnimatorEnabled() const
3794 {
3795 #if ENABLE(SMOOTH_SCROLLING)
3796     if (Page* page = frame().page())
3797         return page-&gt;settings().scrollAnimatorEnabled();
3798 #endif
3799 
3800     return false;
3801 }
3802 
3803 void FrameView::updateScrollCorner()
3804 {
3805     RenderElement* renderer = nullptr;
3806     std::unique_ptr&lt;RenderStyle&gt; cornerStyle;
3807     IntRect cornerRect = scrollCornerRect();
3808 
3809     if (!cornerRect.isEmpty()) {
3810         // Try the &lt;body&gt; element first as a scroll corner source.
3811         Document* doc = frame().document();
3812         Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
3813         if (body &amp;&amp; body-&gt;renderer()) {
3814             renderer = body-&gt;renderer();
3815             cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3816         }
3817 
3818         if (!cornerStyle) {
3819             // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
3820             Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
3821             if (docElement &amp;&amp; docElement-&gt;renderer()) {
3822                 renderer = docElement-&gt;renderer();
3823                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3824             }
3825         }
3826 
3827         if (!cornerStyle) {
3828             // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
3829             if (RenderWidget* renderer = frame().ownerRenderer())
3830                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3831         }
3832     }
3833 
3834     if (!cornerStyle)
3835         m_scrollCorner = nullptr;
3836     else {
3837         if (!m_scrollCorner) {
3838             m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer-&gt;document(), WTFMove(*cornerStyle));
3839             m_scrollCorner-&gt;initializeStyle();
3840         } else
3841             m_scrollCorner-&gt;setStyle(WTFMove(*cornerStyle));
3842         invalidateScrollCorner(cornerRect);
3843     }
3844 }
3845 
3846 void FrameView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
3847 {
3848     if (context.invalidatingControlTints()) {
3849         updateScrollCorner();
3850         return;
3851     }
3852 
3853     if (m_scrollCorner) {
3854         if (frame().isMainFrame())
3855             context.fillRect(cornerRect, baseBackgroundColor());
3856         m_scrollCorner-&gt;paintIntoRect(context, cornerRect.location(), cornerRect);
3857         return;
3858     }
3859 
3860 #if PLATFORM(MAC)
3861     // Keep this in sync with ScrollAnimatorMac&#39;s effectiveAppearanceForScrollerImp:.
3862     LocalDefaultSystemAppearance localAppearance(useDarkAppearanceForScrollbars());
3863 #endif
3864 
3865     ScrollView::paintScrollCorner(context, cornerRect);
3866 }
3867 
3868 void FrameView::paintScrollbar(GraphicsContext&amp; context, Scrollbar&amp; bar, const IntRect&amp; rect)
3869 {
3870     if (bar.isCustomScrollbar() &amp;&amp; frame().isMainFrame()) {
3871         IntRect toFill = bar.frameRect();
3872         toFill.intersect(rect);
3873         context.fillRect(toFill, baseBackgroundColor());
3874     }
3875 
3876     ScrollView::paintScrollbar(context, bar, rect);
3877 }
3878 
3879 Color FrameView::documentBackgroundColor() const
3880 {
3881     // &lt;https://bugs.webkit.org/show_bug.cgi?id=59540&gt; We blend the background color of
3882     // the document and the body against the base background color of the frame view.
3883     // Background images are unfortunately impractical to include.
3884 
3885     // Return invalid Color objects whenever there is insufficient information.
3886     if (!frame().document())
3887         return Color();
3888 
3889     auto* htmlElement = frame().document()-&gt;documentElement();
3890     auto* bodyElement = frame().document()-&gt;bodyOrFrameset();
3891 
3892     // Start with invalid colors.
3893     Color htmlBackgroundColor;
3894     Color bodyBackgroundColor;
3895     if (htmlElement &amp;&amp; htmlElement-&gt;renderer())
3896         htmlBackgroundColor = htmlElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3897     if (bodyElement &amp;&amp; bodyElement-&gt;renderer())
3898         bodyBackgroundColor = bodyElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3899 
3900     if (!bodyBackgroundColor.isValid()) {
3901         if (!htmlBackgroundColor.isValid())
3902             return Color();
3903         return baseBackgroundColor().blend(htmlBackgroundColor);
3904     }
3905 
3906     if (!htmlBackgroundColor.isValid())
3907         return baseBackgroundColor().blend(bodyBackgroundColor);
3908 
3909     // We take the aggregate of the base background color
3910     // the &lt;html&gt; background color, and the &lt;body&gt;
3911     // background color to find the document color. The
3912     // addition of the base background color is not
3913     // technically part of the document background, but it
3914     // otherwise poses problems when the aggregate is not
3915     // fully opaque.
3916     return baseBackgroundColor().blend(htmlBackgroundColor).blend(bodyBackgroundColor);
3917 }
3918 
3919 bool FrameView::hasCustomScrollbars() const
3920 {
3921     for (auto&amp; widget : children()) {
3922         if (is&lt;FrameView&gt;(widget)) {
3923             if (downcast&lt;FrameView&gt;(widget.get()).hasCustomScrollbars())
3924                 return true;
3925         } else if (is&lt;Scrollbar&gt;(widget)) {
3926             if (downcast&lt;Scrollbar&gt;(widget.get()).isCustomScrollbar())
3927                 return true;
3928         }
3929     }
3930     return false;
3931 }
3932 
3933 FrameView* FrameView::parentFrameView() const
3934 {
3935     if (!parent())
3936         return nullptr;
3937     auto* parentFrame = frame().tree().parent();
3938     if (!parentFrame)
3939         return nullptr;
3940     return parentFrame-&gt;view();
3941 }
3942 
3943 bool FrameView::isInChildFrameWithFrameFlattening() const
3944 {
3945     if (!frameFlatteningEnabled())
3946         return false;
3947 
3948     if (!parent())
3949         return false;
3950 
3951     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
3952     if (!ownerElement)
3953         return false;
3954 
3955     if (!ownerElement-&gt;renderWidget())
3956         return false;
3957 
3958     // Frame flattening applies when the owner element is either in a frameset or
3959     // an iframe with flattening parameters.
3960     if (is&lt;HTMLIFrameElement&gt;(*ownerElement))
3961         return downcast&lt;RenderIFrame&gt;(*ownerElement-&gt;renderWidget()).flattenFrame();
3962 
3963     if (is&lt;HTMLFrameElement&gt;(*ownerElement))
3964         return true;
3965 
3966     return false;
3967 }
3968 
3969 void FrameView::updateControlTints()
3970 {
3971     // This is called when control tints are changed from aqua/graphite to clear and vice versa.
3972     // We do a &quot;fake&quot; paint, and when the theme gets a paint call, it can then do an invalidate.
3973     // This is only done if the theme supports control tinting. It&#39;s up to the theme and platform
3974     // to define when controls get the tint and to call this function when that changes.
3975 
3976     // Optimize the common case where we bring a window to the front while it&#39;s still empty.
3977     if (frame().document()-&gt;url().isEmpty())
3978         return;
3979 
3980     // As noted above, this is a &quot;fake&quot; paint, so we should pause counting relevant repainted objects.
3981     Page* page = frame().page();
3982     bool isCurrentlyCountingRelevantRepaintedObject = false;
3983     if (page) {
3984         isCurrentlyCountingRelevantRepaintedObject = page-&gt;isCountingRelevantRepaintedObjects();
3985         page-&gt;setIsCountingRelevantRepaintedObjects(false);
3986     }
3987 
3988     RenderView* renderView = this-&gt;renderView();
3989     if ((renderView &amp;&amp; renderView-&gt;theme().supportsControlTints()) || hasCustomScrollbars())
3990         invalidateControlTints();
3991 
3992     if (page)
3993         page-&gt;setIsCountingRelevantRepaintedObjects(isCurrentlyCountingRelevantRepaintedObject);
3994 }
3995 
3996 void FrameView::traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons paintInvalidationReasons)
3997 {
3998     if (needsLayout())
3999         layoutContext().layout();
4000 
4001     GraphicsContext context(paintInvalidationReasons);
4002     if (platformWidget()) {
4003         // FIXME: consult paintsEntireContents().
4004         paintContents(context, visibleContentRect(LegacyIOSDocumentVisibleRect));
4005     } else
4006         paint(context, frameRect());
4007 }
4008 
4009 bool FrameView::wasScrolledByUser() const
4010 {
4011     return m_wasScrolledByUser;
4012 }
4013 
4014 void FrameView::setWasScrolledByUser(bool wasScrolledByUser)
4015 {
4016     LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
4017 
4018     m_shouldScrollToFocusedElement = false;
4019     m_delayedScrollToFocusedElementTimer.stop();
<a name="49" id="anc49"></a><span class="line-modified">4020     if (currentScrollType() == ScrollType::Programmatic)</span>
4021         return;
4022     m_maintainScrollPositionAnchor = nullptr;
4023     if (m_wasScrolledByUser == wasScrolledByUser)
4024         return;
4025     m_wasScrolledByUser = wasScrolledByUser;
4026     if (frame().isMainFrame())
4027         updateLayerFlushThrottling();
4028     adjustTiledBackingCoverage();
4029 }
4030 
4031 void FrameView::willPaintContents(GraphicsContext&amp; context, const IntRect&amp;, PaintingState&amp; paintingState)
4032 {
4033     Document* document = frame().document();
4034 
4035     if (!context.paintingDisabled())
4036         InspectorInstrumentation::willPaint(*renderView());
4037 
4038     paintingState.isTopLevelPainter = !sCurrentPaintTimeStamp;
4039 
4040     if (paintingState.isTopLevelPainter)
4041         sCurrentPaintTimeStamp = MonotonicTime::now();
4042 
4043     paintingState.paintBehavior = m_paintBehavior;
4044 
4045     if (FrameView* parentView = parentFrameView()) {
4046         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::FlattenCompositingLayers)
4047             m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4048 
4049         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::Snapshotting)
4050             m_paintBehavior.add(PaintBehavior::Snapshotting);
4051 
4052         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::TileFirstPaint)
4053             m_paintBehavior.add(PaintBehavior::TileFirstPaint);
4054     }
4055 
4056     if (document-&gt;printing()) {
4057         m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4058         m_paintBehavior.add(PaintBehavior::Snapshotting);
4059     }
4060 
4061     paintingState.isFlatteningPaintOfRootFrame = (m_paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) &amp;&amp; !frame().ownerElement();
4062     if (paintingState.isFlatteningPaintOfRootFrame)
4063         notifyWidgetsInAllFrames(WillPaintFlattened);
4064 
4065     ASSERT(!m_isPainting);
4066     m_isPainting = true;
4067 }
4068 
4069 void FrameView::didPaintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, PaintingState&amp; paintingState)
4070 {
4071     m_isPainting = false;
4072 
4073     if (paintingState.isFlatteningPaintOfRootFrame)
4074         notifyWidgetsInAllFrames(DidPaintFlattened);
4075 
4076     m_paintBehavior = paintingState.paintBehavior;
4077     m_lastPaintTime = MonotonicTime::now();
4078 
<a name="50" id="anc50"></a>


4079     if (paintingState.isTopLevelPainter)
4080         sCurrentPaintTimeStamp = MonotonicTime();
4081 
4082     if (!context.paintingDisabled()) {
4083         InspectorInstrumentation::didPaint(*renderView(), dirtyRect);
4084         // FIXME: should probably not fire milestones for snapshot painting. https://bugs.webkit.org/show_bug.cgi?id=117623
4085         firePaintRelatedMilestonesIfNeeded();
4086     }
4087 }
4088 
4089 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4090 {
4091 #ifndef NDEBUG
4092     bool fillWithWarningColor;
4093     if (frame().document()-&gt;printing())
4094         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4095     else if (frame().ownerElement())
4096         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4097     else if (isTransparent())
4098         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
4099     else if (m_paintBehavior &amp; PaintBehavior::SelectionOnly)
4100         fillWithWarningColor = false; // Selections are transparent, don&#39;t fill with red.
4101     else if (m_nodeToDraw)
4102         fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
4103     else
4104         fillWithWarningColor = true;
4105 
4106     if (fillWithWarningColor)
4107         context.fillRect(dirtyRect, Color(255, 64, 255));
4108 #endif
4109 
4110     RenderView* renderView = this-&gt;renderView();
4111     if (!renderView) {
4112         LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
4113         return;
4114     }
4115 
4116     if (!layoutContext().inPaintableState())
4117         return;
4118 
4119     ASSERT(!needsLayout());
4120     if (needsLayout()) {
4121         RELEASE_LOG_IF_ALLOWED(&quot;FrameView::paintContents() - not painting because render tree needs layout (is main frame %d)&quot;, frame().isMainFrame());
4122         return;
4123     }
4124 
4125     PaintingState paintingState;
4126     willPaintContents(context, dirtyRect, paintingState);
4127 
4128     // m_nodeToDraw is used to draw only one element (and its descendants)
4129     RenderObject* renderer = m_nodeToDraw ? m_nodeToDraw-&gt;renderer() : nullptr;
4130     RenderLayer* rootLayer = renderView-&gt;layer();
4131 
4132 #ifndef NDEBUG
4133     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;rootLayer-&gt;renderer());
4134 #endif
4135 
4136     // To work around http://webkit.org/b/135106, ensure that the paint root isn&#39;t an inline with culled line boxes.
4137     // FIXME: This can cause additional content to be included in the snapshot, so remove this once that bug is fixed.
4138     while (is&lt;RenderInline&gt;(renderer) &amp;&amp; !downcast&lt;RenderInline&gt;(*renderer).firstLineBox())
4139         renderer = renderer-&gt;parent();
4140 
4141     rootLayer-&gt;paint(context, dirtyRect, LayoutSize(), m_paintBehavior, renderer, { }, securityOriginPaintPolicy == SecurityOriginPaintPolicy::AnyOrigin ? RenderLayer::SecurityOriginPaintPolicy::AnyOrigin : RenderLayer::SecurityOriginPaintPolicy::AccessibleOriginOnly);
4142     if (rootLayer-&gt;containsDirtyOverlayScrollbars())
4143         rootLayer-&gt;paintOverlayScrollbars(context, dirtyRect, m_paintBehavior, renderer);
4144 
4145     didPaintContents(context, dirtyRect, paintingState);
4146 }
4147 
4148 void FrameView::setPaintBehavior(OptionSet&lt;PaintBehavior&gt; behavior)
4149 {
4150     m_paintBehavior = behavior;
4151 }
4152 
4153 OptionSet&lt;PaintBehavior&gt; FrameView::paintBehavior() const
4154 {
4155     return m_paintBehavior;
4156 }
4157 
4158 bool FrameView::isPainting() const
4159 {
4160     return m_isPainting;
4161 }
4162 
4163 // FIXME: change this to use the subtreePaint terminology.
4164 void FrameView::setNodeToDraw(Node* node)
4165 {
4166     m_nodeToDraw = node;
4167 }
4168 
4169 void FrameView::paintContentsForSnapshot(GraphicsContext&amp; context, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot coordinateSpace)
4170 {
4171     updateLayoutAndStyleIfNeededRecursive();
4172 
4173     // Cache paint behavior and set a new behavior appropriate for snapshots.
4174     auto oldBehavior = paintBehavior();
4175     setPaintBehavior(oldBehavior | PaintBehavior::FlattenCompositingLayers | PaintBehavior::Snapshotting);
4176 
4177     // If the snapshot should exclude selection, then we&#39;ll clear the current selection
4178     // in the render tree only. This will allow us to restore the selection from the DOM
4179     // after we paint the snapshot.
4180     if (shouldPaintSelection == ExcludeSelection) {
4181         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
4182             if (auto* renderView = frame-&gt;contentRenderer())
4183                 renderView-&gt;selection().clear();
4184         }
4185     }
4186 
4187     if (coordinateSpace == DocumentCoordinates)
4188         paintContents(context, imageRect);
4189     else {
4190         // A snapshot in ViewCoordinates will include a scrollbar, and the snapshot will contain
4191         // whatever content the document is currently scrolled to.
4192         paint(context, imageRect);
4193     }
4194 
4195     // Restore selection.
4196     if (shouldPaintSelection == ExcludeSelection) {
4197         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr()))
4198             frame-&gt;selection().updateAppearance();
4199     }
4200 
4201     // Restore cached paint behavior.
4202     setPaintBehavior(oldBehavior);
4203 }
4204 
4205 void FrameView::paintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect)
4206 {
4207     if (context.paintingDisabled())
4208         return;
4209 
4210     if (frame().document()-&gt;printing())
4211         return;
4212 
4213     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);
4214 }
4215 
4216 void FrameView::updateLayoutAndStyleIfNeededRecursive()
4217 {
4218     // Style updating, render tree creation, and layout needs to be done multiple times
4219     // for more than one reason. But one reason is that when an &lt;object&gt; element determines
4220     // what it needs to load a subframe, a second pass is needed. That requires update
4221     // passes equal to the number of levels of DOM nesting. That is why this number is large.
4222     // There are test cases where we have roughly 10 levels of DOM nesting, so this needs to
4223     // be greater than that. We have a limit to avoid the possibility of an infinite loop.
4224     // Typical calls will run the loop 2 times (once to do work, once to detect no further work
4225     // is needed).
4226     // FIXME: We should find an approach that does not require a loop at all.
4227     const unsigned maxUpdatePasses = 25;
4228 
4229     // Style updates can trigger script, which can cause this FrameView to be destroyed.
4230     Ref&lt;FrameView&gt; protectedThis(*this);
4231 
4232     AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());
4233 
4234     using DescendantsDeque = Deque&lt;Ref&lt;FrameView&gt;, 16&gt;;
4235     auto nextRenderedDescendant = [this] (DescendantsDeque&amp; descendantsDeque) -&gt; RefPtr&lt;FrameView&gt; {
4236         if (descendantsDeque.isEmpty())
4237             descendantsDeque.append(*this);
4238         else {
4239             // Append renderered children after processing the parent, in case the processing
4240             // affects the set of rendered children.
4241             auto previousView = descendantsDeque.takeFirst();
4242             for (auto* frame = previousView-&gt;frame().tree().firstRenderedChild(); frame; frame = frame-&gt;tree().nextRenderedSibling()) {
4243                 if (auto* view = frame-&gt;view())
4244                     descendantsDeque.append(*view);
4245             }
4246             if (descendantsDeque.isEmpty())
4247                 return nullptr;
4248         }
4249         return descendantsDeque.first().ptr();
4250     };
4251 
4252     for (unsigned i = 0; i &lt; maxUpdatePasses; ++i) {
4253         bool didWork = false;
4254         DescendantsDeque deque;
4255         while (auto view = nextRenderedDescendant(deque)) {
4256             if (view-&gt;frame().document()-&gt;updateStyleIfNeeded())
4257                 didWork = true;
4258             if (view-&gt;needsLayout()) {
4259                 view-&gt;layoutContext().layout();
4260                 didWork = true;
4261             }
4262         }
4263         if (!didWork)
4264             break;
4265     }
4266 
4267 #if !ASSERT_DISABLED
4268     auto needsStyleRecalc = [&amp;] {
4269         DescendantsDeque deque;
4270         while (auto view = nextRenderedDescendant(deque)) {
4271             auto* document = view-&gt;frame().document();
4272             if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
4273                 return true;
4274         }
4275         return false;
4276     };
4277 
4278     auto needsLayout = [&amp;] {
4279         DescendantsDeque deque;
4280         while (auto view = nextRenderedDescendant(deque)) {
4281             if (view-&gt;needsLayout())
4282                 return true;
4283         }
4284         return false;
4285     };
4286 #endif
4287 
4288     ASSERT(!needsStyleRecalc());
4289     ASSERT(!needsLayout());
4290 }
4291 
4292 void FrameView::incrementVisuallyNonEmptyCharacterCount(const String&amp; inlineText)
4293 {
4294     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold &amp;&amp; m_hasReachedSignificantRenderedTextThreshold)
4295         return;
4296 
4297     auto nonWhitespaceLength = [](auto&amp; inlineText) {
4298         auto length = inlineText.length();
4299         for (unsigned i = 0; i &lt; inlineText.length(); ++i) {
4300             if (isNotHTMLSpace(inlineText[i]))
4301                 continue;
4302             --length;
4303         }
4304         return length;
4305     };
4306     m_visuallyNonEmptyCharacterCount += nonWhitespaceLength(inlineText);
4307     ++m_textRendererCountForVisuallyNonEmptyCharacters;
4308 }
4309 
4310 static bool elementOverflowRectIsLargerThanThreshold(const Element&amp; element)
4311 {
4312     // Require the document to grow a bit.
4313     // Using a value of 48 allows the header on Google&#39;s search page to render immediately before search results populate later.
4314     static const int documentHeightThreshold = 48;
4315     if (auto* elementRenderBox = element.renderBox())
4316         return snappedIntRect(elementRenderBox-&gt;layoutOverflowRect()).height() &gt;= documentHeightThreshold;
4317 
4318     return false;
4319 }
4320 
4321 void FrameView::updateHasReachedSignificantRenderedTextThreshold()
4322 {
4323     if (m_hasReachedSignificantRenderedTextThreshold)
4324         return;
4325 
4326     auto* page = frame().page();
4327     if (!page || !page-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText))
4328         return;
4329 
4330     auto* document = frame().document();
4331     if (!document)
4332         return;
4333 
4334     document-&gt;updateMainArticleElementAfterLayout();
4335     auto hasMainArticleElement = document-&gt;hasMainArticleElement();
4336     auto characterThreshold = hasMainArticleElement ? mainArticleSignificantRenderedTextCharacterThreshold : defaultSignificantRenderedTextCharacterThreshold;
4337     if (m_visuallyNonEmptyCharacterCount &lt; characterThreshold)
4338         return;
4339 
4340     auto meanLength = hasMainArticleElement ? mainArticleSignificantRenderedTextMeanLength : defaultSignificantRenderedTextMeanLength;
4341     if (!m_textRendererCountForVisuallyNonEmptyCharacters || m_visuallyNonEmptyCharacterCount / static_cast&lt;float&gt;(m_textRendererCountForVisuallyNonEmptyCharacters) &lt; meanLength)
4342         return;
4343 
4344     m_hasReachedSignificantRenderedTextThreshold = true;
4345 }
4346 
4347 bool FrameView::qualifiesAsSignificantRenderedText() const
4348 {
4349     ASSERT(!m_renderedSignificantAmountOfText);
4350     auto* document = frame().document();
4351     if (!document || document-&gt;styleScope().hasPendingSheetsBeforeBody())
4352         return false;
4353 
4354     auto* documentElement = document-&gt;documentElement();
4355     if (!documentElement || !elementOverflowRectIsLargerThanThreshold(*documentElement))
4356         return false;
4357 
4358     return m_hasReachedSignificantRenderedTextThreshold;
4359 }
4360 
4361 bool FrameView::qualifiesAsVisuallyNonEmpty() const
4362 {
4363     // No content yet.
4364     Element* documentElement = frame().document()-&gt;documentElement();
4365     if (!documentElement || !documentElement-&gt;renderer())
4366         return false;
4367 
4368     // FIXME: We should also ignore renderers with non-final style.
4369     if (frame().document()-&gt;styleScope().hasPendingSheetsBeforeBody())
4370         return false;
4371 
4372     auto finishedParsingMainDocument = frame().loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; (frame().document()-&gt;readyState() == Document::Interactive || frame().document()-&gt;readyState() == Document::Complete);
4373     // Ensure that we always fire visually non-empty milestone eventually.
4374     if (finishedParsingMainDocument &amp;&amp; frame().loader().isComplete())
4375         return true;
4376 
4377     auto isVisible = [](const Element* element) {
4378         if (!element || !element-&gt;renderer())
4379             return false;
4380         if (!element-&gt;renderer()-&gt;opacity())
4381             return false;
4382         return element-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
4383     };
4384 
4385     if (!isVisible(documentElement))
4386         return false;
4387 
4388     if (!isVisible(frame().document()-&gt;body()))
4389         return false;
4390 
4391     if (!elementOverflowRectIsLargerThanThreshold(*documentElement))
4392         return false;
4393 
4394     // The first few hundred characters rarely contain the interesting content of the page.
4395     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold)
4396         return true;
4397 
4398     // Use a threshold value to prevent very small amounts of visible content from triggering didFirstVisuallyNonEmptyLayout
4399     if (m_visuallyNonEmptyPixelCount &gt; visualPixelThreshold)
4400         return true;
4401 
4402     auto isMoreContentExpected = [&amp;]() {
4403         ASSERT(finishedParsingMainDocument);
4404         // Pending css/font loading means we should wait a little longer. Classic non-async, non-defer scripts are all processed by now.
4405         auto* documentLoader = frame().loader().documentLoader();
4406         if (!documentLoader)
4407             return false;
4408 
4409         auto&amp; resourceLoader = documentLoader-&gt;cachedResourceLoader();
4410         if (!resourceLoader.requestCount())
4411             return false;
4412 
4413         auto&amp; resources = resourceLoader.allCachedResources();
4414         for (auto&amp; resource : resources) {
4415             if (resource.value-&gt;isLoaded())
4416                 continue;
4417             if (resource.value-&gt;type() == CachedResource::Type::CSSStyleSheet || resource.value-&gt;type() == CachedResource::Type::FontResource)
4418                 return true;
4419         }
4420         return false;
4421     };
4422 
4423     // Finished parsing the main document and we still don&#39;t yet have enough content. Check if we might be getting some more.
4424     if (finishedParsingMainDocument)
4425         return !isMoreContentExpected();
4426 
4427     return false;
4428 }
4429 
4430 bool FrameView::isViewForDocumentInFrame() const
4431 {
4432     RenderView* renderView = this-&gt;renderView();
4433     if (!renderView)
4434         return false;
4435 
4436     return &amp;renderView-&gt;frameView() == this;
4437 }
4438 
<a name="51" id="anc51"></a><span class="line-modified">4439 void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; viewSize)</span>
4440 {
<a name="52" id="anc52"></a><span class="line-modified">4441     ASSERT(!enable || !viewSize.isEmpty());</span>
<span class="line-modified">4442     if (m_shouldAutoSize == enable &amp;&amp; m_autoSizeConstraint == viewSize)</span>



4443         return;
4444 
4445     m_shouldAutoSize = enable;
<a name="53" id="anc53"></a><span class="line-modified">4446     m_autoSizeConstraint = viewSize;</span>
<span class="line-modified">4447     m_autoSizeContentSize = contentsSize();</span>
4448     m_didRunAutosize = false;
4449 
4450     setNeedsLayoutAfterViewConfigurationChange();
4451     layoutContext().scheduleLayout();
4452     if (m_shouldAutoSize) {
<a name="54" id="anc54"></a><span class="line-modified">4453         overrideViewportSizeForCSSViewportUnits({ m_autoSizeConstraint.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });</span>
4454         return;
4455     }
4456 
4457     clearViewportSizeOverrideForCSSViewportUnits();
4458     // Since autosize mode forces the scrollbar mode, change them to being auto.
4459     setVerticalScrollbarLock(false);
4460     setHorizontalScrollbarLock(false);
4461     setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
4462 }
4463 
4464 void FrameView::forceLayout(bool allowSubtreeLayout)
4465 {
4466     if (!allowSubtreeLayout &amp;&amp; layoutContext().subtreeLayoutRoot())
4467         layoutContext().convertSubtreeLayoutToFullLayout();
4468     layoutContext().layout();
4469 }
4470 
4471 void FrameView::forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot shouldAdjustViewSize)
4472 {
4473     if (!renderView())
4474         return;
4475 
4476     Ref&lt;FrameView&gt; protectedThis(*this);
4477     auto&amp; renderView = *this-&gt;renderView();
4478 
4479     // Dumping externalRepresentation(frame().renderer()).ascii() is a good trick to see
4480     // the state of things before and after the layout
4481     float pageLogicalWidth = renderView.style().isHorizontalWritingMode() ? pageSize.width() : pageSize.height();
4482     float pageLogicalHeight = renderView.style().isHorizontalWritingMode() ? pageSize.height() : pageSize.width();
4483 
4484     renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4485     renderView.setNeedsLayoutAndPrefWidthsRecalc();
4486     forceLayout();
4487     if (hasOneRef())
4488         return;
4489 
4490     // If we don&#39;t fit in the given page width, we&#39;ll lay out again. If we don&#39;t fit in the
4491     // page width when shrunk, we will lay out at maximum shrink and clip extra content.
4492     // FIXME: We are assuming a shrink-to-fit printing implementation. A cropping
4493     // implementation should not do this!
4494     bool horizontalWritingMode = renderView.style().isHorizontalWritingMode();
4495     const LayoutRect&amp; documentRect = renderView.documentRect();
4496     LayoutUnit docLogicalWidth = horizontalWritingMode ? documentRect.width() : documentRect.height();
4497     if (docLogicalWidth &gt; pageLogicalWidth) {
4498         int expectedPageWidth = std::min&lt;float&gt;(documentRect.width(), pageSize.width() * maximumShrinkFactor);
4499         int expectedPageHeight = std::min&lt;float&gt;(documentRect.height(), pageSize.height() * maximumShrinkFactor);
4500         FloatSize maxPageSize = frame().resizePageRectsKeepingRatio(FloatSize(originalPageSize.width(), originalPageSize.height()), FloatSize(expectedPageWidth, expectedPageHeight));
4501         pageLogicalWidth = horizontalWritingMode ? maxPageSize.width() : maxPageSize.height();
4502         pageLogicalHeight = horizontalWritingMode ? maxPageSize.height() : maxPageSize.width();
4503 
4504         renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4505         renderView.setNeedsLayoutAndPrefWidthsRecalc();
4506         forceLayout();
4507         if (hasOneRef())
4508             return;
4509 
4510         const LayoutRect&amp; updatedDocumentRect = renderView.documentRect();
4511         LayoutUnit docLogicalHeight = horizontalWritingMode ? updatedDocumentRect.height() : updatedDocumentRect.width();
4512         LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
4513         LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
4514         LayoutUnit clippedLogicalLeft;
4515         if (!renderView.style().isLeftToRightDirection())
4516             clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
<a name="55" id="anc55"></a><span class="line-modified">4517         LayoutRect overflow { clippedLogicalLeft, docLogicalTop, LayoutUnit(pageLogicalWidth), docLogicalHeight };</span>
4518 
4519         if (!horizontalWritingMode)
4520             overflow = overflow.transposedRect();
4521         renderView.clearLayoutOverflow();
4522         renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
4523     }
4524 
4525     if (shouldAdjustViewSize)
4526         adjustViewSize();
4527 }
4528 
4529 void FrameView::adjustPageHeightDeprecated(float *newBottom, float oldTop, float oldBottom, float /*bottomLimit*/)
4530 {
4531     RenderView* renderView = this-&gt;renderView();
4532     if (!renderView) {
4533         *newBottom = oldBottom;
4534         return;
4535 
4536     }
4537     // Use a context with painting disabled.
4538     GraphicsContext context(GraphicsContext::PaintInvalidationReasons::None);
4539     renderView-&gt;setTruncatedAt(static_cast&lt;int&gt;(floorf(oldBottom)));
4540     IntRect dirtyRect(0, static_cast&lt;int&gt;(floorf(oldTop)), renderView-&gt;layoutOverflowRect().maxX(), static_cast&lt;int&gt;(ceilf(oldBottom - oldTop)));
4541     renderView-&gt;setPrintRect(dirtyRect);
4542     renderView-&gt;layer()-&gt;paint(context, dirtyRect);
4543     *newBottom = renderView-&gt;bestTruncatedAt();
4544     if (!*newBottom)
4545         *newBottom = oldBottom;
4546     renderView-&gt;setPrintRect(IntRect());
4547 }
4548 
4549 IntRect FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntRect&amp; rendererRect) const
4550 {
4551     IntRect rect = snappedIntRect(enclosingLayoutRect(renderer-&gt;localToAbsoluteQuad(FloatRect(rendererRect)).boundingBox()));
4552 
4553     return contentsToView(rect);
4554 }
4555 
4556 IntRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntRect&amp; viewRect) const
4557 {
4558     IntRect rect = viewToContents(viewRect);
4559 
4560     // FIXME: we don&#39;t have a way to map an absolute rect down to a local quad, so just
4561     // move the rect for now.
4562     rect.setLocation(roundedIntPoint(renderer-&gt;absoluteToLocal(rect.location(), UseTransforms)));
4563     return rect;
4564 }
4565 
4566 FloatRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const FloatRect&amp; viewRect) const
4567 {
4568     FloatRect rect = viewToContents(viewRect);
4569 
4570     return (renderer-&gt;absoluteToLocalQuad(rect)).boundingBox();
4571 }
4572 
4573 IntPoint FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntPoint&amp; rendererPoint) const
4574 {
4575     IntPoint point = roundedIntPoint(renderer-&gt;localToAbsolute(rendererPoint, UseTransforms));
4576 
4577     return contentsToView(point);
4578 }
4579 
4580 IntPoint FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntPoint&amp; viewPoint) const
4581 {
4582     IntPoint point = viewPoint;
4583 
4584     // Convert from FrameView coords into page (&quot;absolute&quot;) coordinates.
4585     if (!delegatesScrolling())
4586         point = viewToContents(point);
4587 
4588     return roundedIntPoint(renderer-&gt;absoluteToLocal(point, UseTransforms));
4589 }
4590 
4591 IntRect FrameView::convertToContainingView(const IntRect&amp; localRect) const
4592 {
4593     if (const ScrollView* parentScrollView = parent()) {
4594         if (is&lt;FrameView&gt;(*parentScrollView)) {
4595             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4596             // Get our renderer in the parent view
4597             RenderWidget* renderer = frame().ownerRenderer();
4598             if (!renderer)
4599                 return localRect;
4600 
4601             auto rect = localRect;
4602             rect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4603             return parentView.convertFromRendererToContainingView(renderer, rect);
4604         }
4605 
4606         return Widget::convertToContainingView(localRect);
4607     }
4608 
4609     return localRect;
4610 }
4611 
4612 IntRect FrameView::convertFromContainingView(const IntRect&amp; parentRect) const
4613 {
4614     if (const ScrollView* parentScrollView = parent()) {
4615         if (is&lt;FrameView&gt;(*parentScrollView)) {
4616             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4617 
4618             // Get our renderer in the parent view
4619             RenderWidget* renderer = frame().ownerRenderer();
4620             if (!renderer)
4621                 return parentRect;
4622 
4623             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4624             rect.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4625             return rect;
4626         }
4627 
4628         return Widget::convertFromContainingView(parentRect);
4629     }
4630 
4631     return parentRect;
4632 }
4633 
4634 FloatRect FrameView::convertFromContainingView(const FloatRect&amp; parentRect) const
4635 {
4636     if (const ScrollView* parentScrollView = parent()) {
4637         if (is&lt;FrameView&gt;(*parentScrollView)) {
4638             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4639 
4640             // Get our renderer in the parent view
4641             RenderWidget* renderer = frame().ownerRenderer();
4642             if (!renderer)
4643                 return parentRect;
4644 
4645             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4646             rect.moveBy(-renderer-&gt;contentBoxLocation());
4647             return rect;
4648         }
4649 
4650         return Widget::convertFromContainingView(parentRect);
4651     }
4652 
4653     return parentRect;
4654 }
4655 
4656 IntPoint FrameView::convertToContainingView(const IntPoint&amp; localPoint) const
4657 {
4658     if (const ScrollView* parentScrollView = parent()) {
4659         if (is&lt;FrameView&gt;(*parentScrollView)) {
4660             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4661 
4662             // Get our renderer in the parent view
4663             RenderWidget* renderer = frame().ownerRenderer();
4664             if (!renderer)
4665                 return localPoint;
4666 
4667             auto point = localPoint;
4668             point.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4669             return parentView.convertFromRendererToContainingView(renderer, point);
4670         }
4671 
4672         return Widget::convertToContainingView(localPoint);
4673     }
4674 
4675     return localPoint;
4676 }
4677 
4678 IntPoint FrameView::convertFromContainingView(const IntPoint&amp; parentPoint) const
4679 {
4680     if (const ScrollView* parentScrollView = parent()) {
4681         if (is&lt;FrameView&gt;(*parentScrollView)) {
4682             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4683 
4684             // Get our renderer in the parent view
4685             RenderWidget* renderer = frame().ownerRenderer();
4686             if (!renderer)
4687                 return parentPoint;
4688 
4689             auto point = parentView.convertFromContainingViewToRenderer(renderer, parentPoint);
4690             point.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4691             return point;
4692         }
4693 
4694         return Widget::convertFromContainingView(parentPoint);
4695     }
4696 
4697     return parentPoint;
4698 }
4699 
4700 float FrameView::documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4701 {
4702     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4703     return effectiveZoom.valueOr(frame().pageZoomFactor()) * frame().frameScaleFactor();
4704 }
4705 
4706 float FrameView::absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4707 {
4708     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4709     return 1 / documentToAbsoluteScaleFactor(effectiveZoom);
4710 }
4711 
4712 FloatRect FrameView::absoluteToDocumentRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4713 {
4714     rect.scale(absoluteToDocumentScaleFactor(effectiveZoom));
4715     return rect;
4716 }
4717 
4718 FloatPoint FrameView::absoluteToDocumentPoint(FloatPoint p, Optional&lt;float&gt; effectiveZoom) const
4719 {
4720     return p.scaled(absoluteToDocumentScaleFactor(effectiveZoom));
4721 }
4722 
4723 FloatRect FrameView::absoluteToClientRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4724 {
4725     return documentToClientRect(absoluteToDocumentRect(rect, effectiveZoom));
4726 }
4727 
4728 FloatSize FrameView::documentToClientOffset() const
4729 {
4730     FloatSize clientOrigin = -toFloatSize(visibleContentRect().location());
4731 
4732     // Layout and visual viewports are affected by page zoom, so we need to factor that out.
4733     return clientOrigin.scaled(1 / (frame().pageZoomFactor() * frame().frameScaleFactor()));
4734 }
4735 
4736 FloatRect FrameView::documentToClientRect(FloatRect rect) const
4737 {
4738     rect.move(documentToClientOffset());
4739     return rect;
4740 }
4741 
4742 FloatPoint FrameView::documentToClientPoint(FloatPoint p) const
4743 {
4744     p.move(documentToClientOffset());
4745     return p;
4746 }
4747 
4748 FloatRect FrameView::clientToDocumentRect(FloatRect rect) const
4749 {
4750     rect.move(-documentToClientOffset());
4751     return rect;
4752 }
4753 
4754 FloatPoint FrameView::clientToDocumentPoint(FloatPoint point) const
4755 {
4756     point.move(-documentToClientOffset());
4757     return point;
4758 }
4759 
<a name="56" id="anc56"></a><span class="line-added">4760 FloatPoint FrameView::absoluteToLayoutViewportPoint(FloatPoint p) const</span>
<span class="line-added">4761 {</span>
<span class="line-added">4762     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">4763     p.scale(1 / frame().frameScaleFactor());</span>
<span class="line-added">4764     p.moveBy(-layoutViewportRect().location());</span>
<span class="line-added">4765     return p;</span>
<span class="line-added">4766 }</span>
<span class="line-added">4767 </span>
4768 FloatPoint FrameView::layoutViewportToAbsolutePoint(FloatPoint p) const
4769 {
4770     ASSERT(frame().settings().visualViewportEnabled());
4771     p.moveBy(layoutViewportRect().location());
4772     return p.scaled(frame().frameScaleFactor());
4773 }
4774 
<a name="57" id="anc57"></a><span class="line-added">4775 FloatRect FrameView::layoutViewportToAbsoluteRect(FloatRect rect) const</span>
<span class="line-added">4776 {</span>
<span class="line-added">4777     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">4778     rect.moveBy(layoutViewportRect().location());</span>
<span class="line-added">4779     rect.scale(frame().frameScaleFactor());</span>
<span class="line-added">4780     return rect;</span>
<span class="line-added">4781 }</span>
<span class="line-added">4782 </span>
<span class="line-added">4783 FloatRect FrameView::absoluteToLayoutViewportRect(FloatRect rect) const</span>
<span class="line-added">4784 {</span>
<span class="line-added">4785     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">4786     rect.scale(1 / frame().frameScaleFactor());</span>
<span class="line-added">4787     rect.moveBy(-layoutViewportRect().location());</span>
<span class="line-added">4788     return rect;</span>
<span class="line-added">4789 }</span>
<span class="line-added">4790 </span>
4791 FloatRect FrameView::clientToLayoutViewportRect(FloatRect rect) const
4792 {
4793     ASSERT(frame().settings().visualViewportEnabled());
4794     rect.scale(frame().pageZoomFactor());
4795     return rect;
4796 }
4797 
4798 FloatPoint FrameView::clientToLayoutViewportPoint(FloatPoint p) const
4799 {
4800     ASSERT(frame().settings().visualViewportEnabled());
4801     return p.scaled(frame().pageZoomFactor());
4802 }
4803 
4804 void FrameView::setTracksRepaints(bool trackRepaints)
4805 {
4806     if (trackRepaints == m_isTrackingRepaints)
4807         return;
4808 
4809     // Force layout to flush out any pending repaints.
4810     if (trackRepaints) {
4811         if (frame().document())
4812             frame().document()-&gt;updateLayout();
4813     }
4814 
4815     for (Frame* frame = &amp;m_frame-&gt;tree().top(); frame; frame = frame-&gt;tree().traverseNext()) {
4816         if (RenderView* renderView = frame-&gt;contentRenderer())
4817             renderView-&gt;compositor().setTracksRepaints(trackRepaints);
4818     }
4819 
4820     resetTrackedRepaints();
4821     m_isTrackingRepaints = trackRepaints;
4822 }
4823 
4824 void FrameView::resetTrackedRepaints()
4825 {
4826     m_trackedRepaintRects.clear();
4827     if (RenderView* renderView = this-&gt;renderView())
4828         renderView-&gt;compositor().resetTrackedRepaintRects();
4829 }
4830 
4831 String FrameView::trackedRepaintRectsAsText() const
4832 {
4833     Frame&amp; frame = this-&gt;frame();
4834     Ref&lt;Frame&gt; protector(frame);
4835 
4836     if (auto* document = frame.document())
4837         document-&gt;updateLayout();
4838 
4839     TextStream ts;
4840     if (!m_trackedRepaintRects.isEmpty()) {
4841         ts &lt;&lt; &quot;(repaint rects\n&quot;;
4842         for (auto&amp; rect : m_trackedRepaintRects)
4843             ts &lt;&lt; &quot;  (rect &quot; &lt;&lt; LayoutUnit(rect.x()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.y()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.width()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.height()) &lt;&lt; &quot;)\n&quot;;
4844         ts &lt;&lt; &quot;)\n&quot;;
4845     }
4846     return ts.release();
4847 }
4848 
4849 bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
4850 {
4851     if (!m_scrollableAreas)
<a name="58" id="anc58"></a><span class="line-modified">4852         m_scrollableAreas = makeUnique&lt;ScrollableAreaSet&gt;();</span>
4853 
4854     if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
4855         scrollableAreaSetChanged();
4856         return true;
4857     }
4858 
4859     return false;
4860 }
4861 
4862 bool FrameView::removeScrollableArea(ScrollableArea* scrollableArea)
4863 {
4864     if (m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;remove(scrollableArea)) {
4865         scrollableAreaSetChanged();
4866         return true;
4867     }
4868     return false;
4869 }
4870 
4871 bool FrameView::containsScrollableArea(ScrollableArea* scrollableArea) const
4872 {
4873     return m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;contains(scrollableArea);
4874 }
4875 
4876 void FrameView::scrollableAreaSetChanged()
4877 {
4878     if (auto* page = frame().page()) {
4879         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4880             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*this);
4881     }
4882 }
4883 
4884 void FrameView::sendScrollEvent()
4885 {
4886     frame().eventHandler().sendScrollEvent();
4887     frame().eventHandler().dispatchFakeMouseMoveEventSoon();
4888 }
4889 
4890 void FrameView::addChild(Widget&amp; widget)
4891 {
4892     if (is&lt;FrameView&gt;(widget)) {
4893         auto&amp; childFrameView = downcast&lt;FrameView&gt;(widget);
4894         if (childFrameView.isScrollable())
4895             addScrollableArea(&amp;childFrameView);
4896     }
4897 
4898     ScrollView::addChild(widget);
4899 }
4900 
4901 void FrameView::removeChild(Widget&amp; widget)
4902 {
4903     if (is&lt;FrameView&gt;(widget))
4904         removeScrollableArea(&amp;downcast&lt;FrameView&gt;(widget));
4905 
4906     ScrollView::removeChild(widget);
4907 }
4908 
4909 bool FrameView::wheelEvent(const PlatformWheelEvent&amp; wheelEvent)
4910 {
4911     // Note that to allow for rubber-band over-scroll behavior, even non-scrollable views
4912     // should handle wheel events.
4913 #if !ENABLE(RUBBER_BANDING)
4914     if (!isScrollable())
4915         return false;
4916 #endif
4917 
4918     if (delegatesScrolling()) {
4919         ScrollPosition oldPosition = scrollPosition();
4920         ScrollPosition newPosition = oldPosition - IntSize(wheelEvent.deltaX(), wheelEvent.deltaY());
4921         if (oldPosition != newPosition) {
4922             ScrollView::scrollTo(newPosition);
4923             scrollPositionChanged(oldPosition, scrollPosition());
4924             didChangeScrollOffset();
4925         }
4926         return true;
4927     }
4928 
4929     // We don&#39;t allow mouse wheeling to happen in a ScrollView that has had its scrollbars explicitly disabled.
4930     if (!canHaveScrollbars())
4931         return false;
4932 
4933     if (platformWidget())
4934         return false;
4935 
4936 #if ENABLE(ASYNC_SCROLLING)
4937     if (Page* page = frame().page()) {
4938         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
4939             if (scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this))
4940                 return scrollingCoordinator-&gt;handleWheelEvent(*this, wheelEvent) != ScrollingEventResult::DidNotHandleEvent;
4941         }
4942     }
4943 #endif
4944 
4945     return ScrollableArea::handleWheelEvent(wheelEvent);
4946 }
4947 
4948 
4949 bool FrameView::isVerticalDocument() const
4950 {
4951     RenderView* renderView = this-&gt;renderView();
4952     if (!renderView)
4953         return true;
4954 
4955     return renderView-&gt;style().isHorizontalWritingMode();
4956 }
4957 
4958 bool FrameView::isFlippedDocument() const
4959 {
4960     RenderView* renderView = this-&gt;renderView();
4961     if (!renderView)
4962         return false;
4963 
4964     return renderView-&gt;style().isFlippedBlocksWritingMode();
4965 }
4966 
4967 void FrameView::notifyWidgetsInAllFrames(WidgetNotification notification)
4968 {
4969     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
4970         if (FrameView* view = frame-&gt;view())
4971             view-&gt;notifyWidgets(notification);
4972     }
4973 }
4974 
4975 AXObjectCache* FrameView::axObjectCache() const
4976 {
4977     if (frame().document())
4978         return frame().document()-&gt;existingAXObjectCache();
4979     return nullptr;
4980 }
4981 
4982 #if PLATFORM(IOS_FAMILY)
4983 bool FrameView::useCustomFixedPositionLayoutRect() const
4984 {
4985     return !frame().settings().visualViewportEnabled() &amp;&amp; m_useCustomFixedPositionLayoutRect;
4986 }
4987 
4988 void FrameView::setCustomFixedPositionLayoutRect(const IntRect&amp; rect)
4989 {
4990     if (m_useCustomFixedPositionLayoutRect &amp;&amp; m_customFixedPositionLayoutRect == rect)
4991         return;
4992     m_useCustomFixedPositionLayoutRect = true;
4993     m_customFixedPositionLayoutRect = rect;
4994     updateContentsSize();
4995 }
4996 
4997 bool FrameView::updateFixedPositionLayoutRect()
4998 {
4999     if (!m_useCustomFixedPositionLayoutRect)
5000         return false;
5001 
5002     IntRect newRect;
5003     Page* page = frame().page();
5004     if (!page || !page-&gt;chrome().client().fetchCustomFixedPositionLayoutRect(newRect))
5005         return false;
5006 
5007     if (newRect != m_customFixedPositionLayoutRect) {
5008         m_customFixedPositionLayoutRect = newRect;
5009         setViewportConstrainedObjectsNeedLayout();
5010         return true;
5011     }
5012     return false;
5013 }
5014 
5015 void FrameView::setCustomSizeForResizeEvent(IntSize customSize)
5016 {
5017     m_useCustomSizeForResizeEvent = true;
5018     m_customSizeForResizeEvent = customSize;
5019     sendResizeEventIfNeeded();
5020 }
5021 
<a name="59" id="anc59"></a><span class="line-modified">5022 void FrameView::setScrollVelocity(const VelocityData&amp; velocityData)</span>
5023 {
5024     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
<a name="60" id="anc60"></a><span class="line-modified">5025         tiledBacking-&gt;setVelocity(velocityData);</span>
5026 }
5027 #endif // PLATFORM(IOS_FAMILY)
5028 
5029 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5030 {
5031     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5032         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5033 }
5034 
5035 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5036 {
5037     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5038     Page* page = frame().page();
5039     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
5040         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
5041     if (AXObjectCache* cache = axObjectCache())
5042         cache-&gt;handleScrollbarUpdate(this);
5043 }
5044 
5045 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5046 {
5047     ScrollableArea::willRemoveScrollbar(scrollbar, orientation);
5048     if (AXObjectCache* cache = axObjectCache()) {
5049         cache-&gt;remove(scrollbar);
5050         cache-&gt;handleScrollbarUpdate(this);
5051     }
5052 }
5053 
5054 void FrameView::addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
5055 {
5056     m_milestonesPendingPaint.add(milestones);
5057 }
5058 
5059 void FrameView::fireLayoutRelatedMilestonesIfNeeded()
5060 {
5061     OptionSet&lt;LayoutMilestone&gt; requestedMilestones;
5062     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5063     Page* page = frame().page();
5064     if (page)
5065         requestedMilestones = page-&gt;requestedLayoutMilestones();
5066 
5067     if (m_firstLayoutCallbackPending) {
5068         m_firstLayoutCallbackPending = false;
5069         frame().loader().didFirstLayout();
5070         if (requestedMilestones &amp; DidFirstLayout)
5071             milestonesAchieved.add(DidFirstLayout);
5072         if (frame().isMainFrame())
5073             page-&gt;startCountingRelevantRepaintedObjects();
5074     }
5075 
5076     if (!m_isVisuallyNonEmpty &amp;&amp; qualifiesAsVisuallyNonEmpty()) {
5077         m_isVisuallyNonEmpty = true;
5078         addPaintPendingMilestones(DidFirstMeaningfulPaint);
5079         if (requestedMilestones &amp; DidFirstVisuallyNonEmptyLayout)
5080             milestonesAchieved.add(DidFirstVisuallyNonEmptyLayout);
5081     }
5082 
5083     if (!m_renderedSignificantAmountOfText &amp;&amp; qualifiesAsSignificantRenderedText()) {
5084         m_renderedSignificantAmountOfText = true;
5085         if (requestedMilestones &amp; DidRenderSignificantAmountOfText)
5086             milestonesAchieved.add(DidRenderSignificantAmountOfText);
5087     }
5088 
5089     if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
5090         if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
5091             RELEASE_LOG_IF_ALLOWED(&quot;fireLayoutRelatedMilestonesIfNeeded() - firing first visually non-empty layout milestone on the main frame&quot;);
5092         frame().loader().didReachLayoutMilestone(milestonesAchieved);
5093     }
5094 }
5095 
5096 void FrameView::firePaintRelatedMilestonesIfNeeded()
5097 {
5098     Page* page = frame().page();
5099     if (!page)
5100         return;
5101 
5102     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5103 
5104     // Make sure the pending paint milestones have actually been requested before we send them.
5105     if (m_milestonesPendingPaint &amp; DidFirstFlushForHeaderLayer) {
5106         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstFlushForHeaderLayer)
5107             milestonesAchieved.add(DidFirstFlushForHeaderLayer);
5108     }
5109 
5110     if (m_milestonesPendingPaint &amp; DidFirstPaintAfterSuppressedIncrementalRendering) {
5111         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstPaintAfterSuppressedIncrementalRendering)
5112             milestonesAchieved.add(DidFirstPaintAfterSuppressedIncrementalRendering);
5113     }
5114 
5115     if (m_milestonesPendingPaint &amp; DidFirstMeaningfulPaint) {
5116         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstMeaningfulPaint)
5117             milestonesAchieved.add(DidFirstMeaningfulPaint);
5118     }
5119 
5120     m_milestonesPendingPaint = { };
5121 
5122     if (milestonesAchieved)
5123         page-&gt;mainFrame().loader().didReachLayoutMilestone(milestonesAchieved);
5124 }
5125 
5126 void FrameView::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowed)
5127 {
5128     if (m_visualUpdatesAllowedByClient == visualUpdatesAllowed)
5129         return;
5130 
5131     m_visualUpdatesAllowedByClient = visualUpdatesAllowed;
5132 
5133     frame().document()-&gt;setVisualUpdatesAllowedByClient(visualUpdatesAllowed);
5134 }
5135 
5136 void FrameView::setScrollPinningBehavior(ScrollPinningBehavior pinning)
5137 {
5138     m_scrollPinningBehavior = pinning;
5139 
5140     if (Page* page = frame().page()) {
5141         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
5142             scrollingCoordinator-&gt;setScrollPinningBehavior(pinning);
5143     }
5144 
5145     updateScrollbars(scrollPosition());
5146 }
5147 
5148 ScrollBehaviorForFixedElements FrameView::scrollBehaviorForFixedElements() const
5149 {
5150     return frame().settings().backgroundShouldExtendBeyondPage() ? StickToViewportBounds : StickToDocumentBounds;
5151 }
5152 
5153 RenderView* FrameView::renderView() const
5154 {
5155     return frame().contentRenderer();
5156 }
5157 
5158 int FrameView::mapFromLayoutToCSSUnits(LayoutUnit value) const
5159 {
5160     return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
5161 }
5162 
5163 LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
5164 {
<a name="61" id="anc61"></a><span class="line-modified">5165     return LayoutUnit(value * frame().pageZoomFactor() * frame().frameScaleFactor());</span>
5166 }
5167 
5168 void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
5169 {
5170     ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
5171     m_widgetsInRenderTree.add(&amp;widget);
5172 }
5173 
5174 void FrameView::willRemoveWidgetFromRenderTree(Widget&amp; widget)
5175 {
5176     ASSERT(m_widgetsInRenderTree.contains(&amp;widget));
5177     m_widgetsInRenderTree.remove(&amp;widget);
5178 }
5179 
5180 static Vector&lt;RefPtr&lt;Widget&gt;&gt; collectAndProtectWidgets(const HashSet&lt;Widget*&gt;&amp; set)
5181 {
5182     return copyToVectorOf&lt;RefPtr&lt;Widget&gt;&gt;(set);
5183 }
5184 
5185 void FrameView::updateWidgetPositions()
5186 {
5187     m_updateWidgetPositionsTimer.stop();
5188     // updateWidgetPosition() can possibly cause layout to be re-entered (via plug-ins running
5189     // scripts in response to NPP_SetWindow, for example), so we need to keep the Widgets
5190     // alive during enumeration.
5191     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree)) {
5192         if (auto* renderer = RenderWidget::find(*widget)) {
5193             auto ignoreWidgetState = renderer-&gt;updateWidgetPosition();
5194             UNUSED_PARAM(ignoreWidgetState);
5195         }
5196     }
5197 }
5198 
5199 void FrameView::scheduleUpdateWidgetPositions()
5200 {
5201     if (!m_updateWidgetPositionsTimer.isActive())
5202         m_updateWidgetPositionsTimer.startOneShot(0_s);
5203 }
5204 
5205 void FrameView::updateWidgetPositionsTimerFired()
5206 {
5207     updateWidgetPositions();
5208 }
5209 
5210 void FrameView::notifyWidgets(WidgetNotification notification)
5211 {
5212     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree))
5213         widget-&gt;notifyWidget(notification);
5214 }
5215 
5216 void FrameView::setViewExposedRect(Optional&lt;FloatRect&gt; viewExposedRect)
5217 {
5218     if (m_viewExposedRect == viewExposedRect)
5219         return;
5220 
5221     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; setViewExposedRect &quot; &lt;&lt; (viewExposedRect ? viewExposedRect.value() : FloatRect()));
5222 
5223     bool hasRectChanged = !m_viewExposedRect == !viewExposedRect;
5224     m_viewExposedRect = viewExposedRect;
5225 
5226     // FIXME: We should support clipping to the exposed rect for subframes as well.
5227     if (!frame().isMainFrame())
5228         return;
5229 
5230     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
5231         if (hasRectChanged)
5232             updateTiledBackingAdaptiveSizing();
5233         adjustTiledBackingCoverage();
5234         tiledBacking-&gt;setTiledScrollingIndicatorPosition(m_viewExposedRect ? m_viewExposedRect.value().location() : FloatPoint());
5235     }
5236 
5237     if (auto* view = renderView())
5238         view-&gt;compositor().scheduleLayerFlush(false /* canThrottle */);
5239 
5240     if (auto* page = frame().page())
5241         page-&gt;pageOverlayController().didChangeViewExposedRect();
5242 }
5243 
5244 void FrameView::clearViewportSizeOverrideForCSSViewportUnits()
5245 {
5246     if (!m_overrideViewportSize)
5247         return;
5248 
5249     m_overrideViewportSize = WTF::nullopt;
5250     if (auto* document = frame().document())
5251         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5252 }
5253 
5254 void FrameView::setViewportSizeForCSSViewportUnits(IntSize size)
5255 {
5256     overrideViewportSizeForCSSViewportUnits({ size.width(), size.height() });
5257 }
5258 
5259 void FrameView::overrideViewportSizeForCSSViewportUnits(OverrideViewportSize size)
5260 {
5261     if (m_overrideViewportSize &amp;&amp; *m_overrideViewportSize == size)
5262         return;
5263 
5264     m_overrideViewportSize = size;
5265 
5266     if (auto* document = frame().document())
5267         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5268 }
5269 
5270 IntSize FrameView::viewportSizeForCSSViewportUnits() const
5271 {
5272     OverrideViewportSize viewportSize;
5273 
5274     if (m_overrideViewportSize) {
5275         viewportSize = *m_overrideViewportSize;
5276         // auto-size overrides the width only, so we can&#39;t always bail out early here.
5277         if (viewportSize.width &amp;&amp; viewportSize.height)
5278             return { *viewportSize.width, *viewportSize.height };
5279     }
5280 
5281     if (useFixedLayout()) {
5282         auto fixedLayoutSize = this-&gt;fixedLayoutSize();
5283         viewportSize.width = viewportSize.width.valueOr(fixedLayoutSize.width());
5284         viewportSize.height = viewportSize.height.valueOr(fixedLayoutSize.height());
5285         return { *viewportSize.width, *viewportSize.height };
5286     }
5287 
5288     // FIXME: the value returned should take into account the value of the overflow
5289     // property on the root element.
5290     auto visibleContentSizeIncludingScrollbars = visibleContentRectIncludingScrollbars().size();
5291     viewportSize.width = viewportSize.width.valueOr(visibleContentSizeIncludingScrollbars.width());
5292     viewportSize.height = viewportSize.height.valueOr(visibleContentSizeIncludingScrollbars.height());
5293     return { *viewportSize.width, *viewportSize.height };
5294 }
5295 
5296 bool FrameView::shouldPlaceBlockDirectionScrollbarOnLeft() const
5297 {
5298     return renderView() &amp;&amp; renderView()-&gt;shouldPlaceBlockDirectionScrollbarOnLeft();
5299 }
5300 
5301 } // namespace WebCore
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>