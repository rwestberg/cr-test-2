<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;WHLSLAST.h&quot;
 33 #include &quot;WHLSLEntryPointScaffolding.h&quot;
 34 #include &quot;WHLSLInferTypes.h&quot;
 35 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 36 #include &quot;WHLSLProgram.h&quot;
 37 #include &quot;WHLSLTypeNamer.h&quot;
 38 #include &quot;WHLSLVisitor.h&quot;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/SetForScope.h&gt;
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
 51 {
 52     if (functionDeclaration.entryPointType())
 53         return;
 54 
 55     auto iterator = functionMapping.find(&amp;functionDeclaration);
 56     ASSERT(iterator != functionMapping.end());
 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {
 59         if (i)
 60             stringBuilder.append(&quot;, &quot;);
 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));
 62     }
 63     stringBuilder.append(&quot;);\n&quot;);
 64 }
 65 
 66 class FunctionDefinitionWriter : public Visitor {
 67 public:
 68     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)
 69         : m_stringBuilder(stringBuilder)
 70         , m_intrinsics(intrinsics)
 71         , m_typeNamer(typeNamer)
 72         , m_functionMapping(functionMapping)
 73         , m_layout(layout)
 74     {
 75     }
 76 
 77     virtual ~FunctionDefinitionWriter() = default;
 78 
 79     void visit(AST::NativeFunctionDeclaration&amp;) override;
 80     void visit(AST::FunctionDefinition&amp;) override;
 81 
 82 protected:
 83     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;
 84 
 85     void visit(AST::FunctionDeclaration&amp;) override;
 86     void visit(AST::Statement&amp;) override;
 87     void visit(AST::Block&amp;) override;
 88     void visit(AST::Break&amp;) override;
 89     void visit(AST::Continue&amp;) override;
 90     void visit(AST::DoWhileLoop&amp;) override;
 91     void visit(AST::EffectfulExpressionStatement&amp;) override;
 92     void visit(AST::Fallthrough&amp;) override;
 93     void visit(AST::ForLoop&amp;) override;
 94     void visit(AST::IfStatement&amp;) override;
 95     void visit(AST::Return&amp;) override;
 96     void visit(AST::SwitchStatement&amp;) override;
 97     void visit(AST::SwitchCase&amp;) override;
 98     void visit(AST::VariableDeclarationsStatement&amp;) override;
 99     void visit(AST::WhileLoop&amp;) override;
100     void visit(AST::IntegerLiteral&amp;) override;
101     void visit(AST::UnsignedIntegerLiteral&amp;) override;
102     void visit(AST::FloatLiteral&amp;) override;
103     void visit(AST::NullLiteral&amp;) override;
104     void visit(AST::BooleanLiteral&amp;) override;
105     void visit(AST::EnumerationMemberLiteral&amp;) override;
106     void visit(AST::Expression&amp;) override;
107     void visit(AST::DotExpression&amp;) override;
108     void visit(AST::GlobalVariableReference&amp;) override;
109     void visit(AST::IndexExpression&amp;) override;
110     void visit(AST::PropertyAccessExpression&amp;) override;
111     void visit(AST::VariableDeclaration&amp;) override;
112     void visit(AST::AssignmentExpression&amp;) override;
113     void visit(AST::CallExpression&amp;) override;
114     void visit(AST::CommaExpression&amp;) override;
115     void visit(AST::DereferenceExpression&amp;) override;
116     void visit(AST::LogicalExpression&amp;) override;
117     void visit(AST::LogicalNotExpression&amp;) override;
118     void visit(AST::MakeArrayReferenceExpression&amp;) override;
119     void visit(AST::MakePointerExpression&amp;) override;
120     void visit(AST::ReadModifyWriteExpression&amp;) override;
121     void visit(AST::TernaryExpression&amp;) override;
122     void visit(AST::VariableReference&amp;) override;
123 
124     enum class LoopConditionLocation {
125         BeforeBody,
126         AfterBody
127     };
128     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);
129 
130     void emitConstantExpressionString(AST::ConstantExpression&amp;);
131 
132     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }
133 
134     enum class Nullability : uint8_t {
135         NotNull,
136         CanBeNull
137     };
138 
139     struct StackItem {
140         MangledVariableName value;
141         MangledVariableName leftValue;
142         Nullability valueNullability;
143         Nullability leftValueNullability;
144         std::function&lt;MangledVariableName()&gt; generateLeftValue;
145     };
146 
147     struct StackValue {
148         MangledVariableName value;
149         Nullability nullability;
150     };
151 
152     // This is the important data flow step where we can take the nullability of an lvalue
153     // and transfer it into the nullability of an rvalue. This is conveyed in MakePointerExpression
154     // and DereferenceExpression. MakePointerExpression will try to produce rvalues which are
155     // non-null, and DereferenceExpression will take a non-null rvalue and try to produce
156     // a non-null lvalue.
157     void appendRightValueWithNullability(AST::Expression&amp;, MangledVariableName value, Nullability nullability)
158     {
159         m_stack.append({ WTFMove(value), { }, nullability, Nullability::CanBeNull, { } });
160     }
161 
162     void appendRightValue(AST::Expression&amp; expression, MangledVariableName value)
163     {
164         appendRightValueWithNullability(expression, WTFMove(value), Nullability::CanBeNull);
165     }
166 
167     void appendLeftValue(AST::Expression&amp; expression, MangledVariableName value, MangledVariableName leftValue, Nullability nullability, std::function&lt;MangledVariableName()&gt; generateLeftValue = { })
168     {
169         ASSERT_UNUSED(expression, expression.typeAnnotation().leftAddressSpace());
170         ASSERT(leftValue || generateLeftValue);
171         m_stack.append({ WTFMove(value), WTFMove(leftValue), Nullability::CanBeNull, nullability, WTFMove(generateLeftValue) });
172     }
173 
174     MangledVariableName takeLastValue()
175     {
176         return m_stack.takeLast().value;
177     }
178 
179     StackValue takeLastValueAndNullability()
180     {
181         auto last = m_stack.takeLast();
182         return { last.value, last.valueNullability };
183     }
184 
185     StackValue takeLastLeftValue()
186     {
187         auto last = m_stack.takeLast();
188         if (!last.leftValue)
189             last.leftValue = last.generateLeftValue();
190         return { last.leftValue, last.leftValueNullability };
191     }
192 
193     enum class BreakContext {
194         Loop,
195         Switch
196     };
197 
198     Optional&lt;BreakContext&gt; m_currentBreakContext;
199 
200     StringBuilder&amp; m_stringBuilder;
201     Intrinsics&amp; m_intrinsics;
202     TypeNamer&amp; m_typeNamer;
203     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;
204     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;
205 
206     Vector&lt;StackItem&gt; m_stack;
207     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;
208     Layout&amp; m_layout;
209     unsigned m_variableCount { 0 };
210     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;
211     Indentation&lt;4&gt; m_indent { 0 };
212 };
213 
214 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)
215 {
216     // We inline native function calls.
217 }
218 
219 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)
220 {
221     auto iterator = m_functionMapping.find(&amp;functionDefinition);
222     ASSERT(iterator != m_functionMapping.end());
223     if (functionDefinition.entryPointType()) {
224         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);
225         if (!entryPointScaffolding)
226             return;
227         m_entryPointScaffolding = WTFMove(entryPointScaffolding);
228 
229         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);
230         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);
231         m_stringBuilder.append(m_indent, &quot;{\n&quot;);
232         {
233             IndentationScope scope(m_indent);
234 
235             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);
236 
237             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
238                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);
239                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
240             }
241             checkErrorAndVisit(functionDefinition.block());
242             ASSERT(m_stack.isEmpty());
243         }
244         m_stringBuilder.append(&quot;}\n\n&quot;);
245 
246         m_entryPointScaffolding = nullptr;
247     } else {
248         ASSERT(m_entryPointScaffolding == nullptr);
249         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
250         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
251             auto&amp; parameter = functionDefinition.parameters()[i];
252             if (i)
253                 m_stringBuilder.append(&quot;, &quot;);
254             auto parameterName = generateNextVariableName();
255             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);
256             ASSERT_UNUSED(addResult, addResult.isNewEntry);
257             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);
258         }
259         m_stringBuilder.append(&quot;)\n&quot;);
260         checkErrorAndVisit(functionDefinition.block());
261         ASSERT(m_stack.isEmpty());
262         m_stringBuilder.append(&#39;\n&#39;);
263     }
264 }
265 
266 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)
267 {
268     ASSERT_NOT_REACHED();
269 }
270 
271 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)
272 {
273     Visitor::visit(statement);
274 }
275 
276 void FunctionDefinitionWriter::visit(AST::Block&amp; block)
277 {
278     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
279     {
280         IndentationScope scope(m_indent);
281         for (auto&amp; statement : block.statements())
282             checkErrorAndVisit(statement);
283     }
284     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
285 }
286 
287 void FunctionDefinitionWriter::visit(AST::Break&amp;)
288 {
289     ASSERT(m_currentBreakContext);
290     switch (*m_currentBreakContext) {
291     case BreakContext::Switch:
292         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
293         break;
294     case BreakContext::Loop:
295         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
296         m_stringBuilder.append(
297             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,
298             m_indent, &quot;break;\n&quot;
299         );
300         break;
301     }
302 }
303 
304 void FunctionDefinitionWriter::visit(AST::Continue&amp;)
305 {
306     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
307     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
308 }
309 
310 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
311 {
312     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
313     takeLastValue(); // The statement is already effectful, so we don&#39;t need to do anything with the result.
314 }
315 
316 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)
317 {
318     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.
319 }
320 
321 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)
322 {
323     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());
324 
325     m_stringBuilder.append(
326         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,
327         m_indent, &quot;while (true) {\n&quot;
328     );
329     {
330         IndentationScope whileScope(m_indent);
331 
332         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {
333             checkErrorAndVisit(*conditionExpression);
334             m_stringBuilder.append(
335                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,
336                 m_indent, &quot;    break;\n&quot;);
337         }
338 
339         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);
340         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);
341 
342         {
343             IndentationScope doScope(m_indent);
344             checkErrorAndVisit(body);
345         }
346         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);
347 
348         m_stringBuilder.append(
349             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,
350             m_indent, &quot;    break;\n&quot;);
351 
352         if (increment) {
353             checkErrorAndVisit(*increment);
354             // Expression results get pushed to m_stack. We don&#39;t use the result
355             // of increment, so we dispense of that now.
356             takeLastValue();
357         }
358 
359         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {
360             checkErrorAndVisit(*conditionExpression);
361             m_stringBuilder.append(
362                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,
363                 m_indent, &quot;    break;\n&quot;);
364         }
365     }
366 
367     m_stringBuilder.append(m_indent, &quot;} \n&quot;);
368 }
369 
370 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)
371 {
372     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());
373 }
374 
375 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)
376 {
377     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());
378 }
379 
380 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)
381 {
382     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
383     {
384         IndentationScope scope(m_indent);
385         checkErrorAndVisit(forLoop.initialization());
386         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());
387     }
388     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
389 }
390 
391 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)
392 {
393     checkErrorAndVisit(ifStatement.conditional());
394     m_stringBuilder.append(m_indent, &quot;if (&quot;, takeLastValue(), &quot;) {\n&quot;);
395     {
396         IndentationScope ifScope(m_indent);
397         checkErrorAndVisit(ifStatement.body());
398     }
399     if (ifStatement.elseBody()) {
400         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);
401         {
402             IndentationScope elseScope(m_indent);
403             checkErrorAndVisit(*ifStatement.elseBody());
404         }
405     }
406     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
407 }
408 
409 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)
410 {
411     if (returnStatement.value()) {
412         checkErrorAndVisit(*returnStatement.value());
413 
414         if (m_entryPointScaffolding) {
415             auto variableName = generateNextVariableName();
416             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, takeLastValue(), variableName, m_indent);
417             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);
418         } else
419             m_stringBuilder.append(m_indent, &quot;return &quot;, takeLastValue(), &quot;;\n&quot;);
420     } else
421         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);
422 }
423 
424 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)
425 {
426     checkErrorAndVisit(switchStatement.value());
427 
428     m_stringBuilder.append(m_indent, &quot;switch (&quot;, takeLastValue(), &quot;) {&quot;);
429     {
430         IndentationScope switchScope(m_indent);
431         for (auto&amp; switchCase : switchStatement.switchCases())
432             checkErrorAndVisit(switchCase);
433     }
434     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
435 }
436 
437 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)
438 {
439     if (switchCase.value()) {
440         m_stringBuilder.append(m_indent, &quot;case &quot;);
441         emitConstantExpressionString(*switchCase.value());
442         m_stringBuilder.append(&quot;:\n&quot;);
443     } else
444         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);
445     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);
446     checkErrorAndVisit(switchCase.block());
447     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.
448 }
449 
450 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
451 {
452     Visitor::visit(variableDeclarationsStatement);
453 }
454 
455 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)
456 {
457     auto variableName = generateNextVariableName();
458     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());
459     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;);
460     appendRightValue(integerLiteral, variableName);
461 }
462 
463 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
464 {
465     auto variableName = generateNextVariableName();
466     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());
467     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;);
468     appendRightValue(unsignedIntegerLiteral, variableName);
469 }
470 
471 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)
472 {
473     auto variableName = generateNextVariableName();
474     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());
475     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;);
476     appendRightValue(floatLiteral, variableName);
477 }
478 
479 void FunctionDefinitionWriter::visit(AST::NullLiteral&amp; nullLiteral)
480 {
481     auto&amp; unifyNode = nullLiteral.resolvedType().unifyNode();
482     auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
483     bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);
484 
485     auto variableName = generateNextVariableName();
486     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;);
487     if (isArrayReferenceType)
488         m_stringBuilder.append(&quot;{ nullptr, 0 };\n&quot;);
489     else
490         m_stringBuilder.append(&quot;nullptr;\n&quot;);
491     appendRightValue(nullLiteral, variableName);
492 }
493 
494 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)
495 {
496     auto variableName = generateNextVariableName();
497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());
498     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;);
499     appendRightValue(booleanLiteral, variableName);
500 }
501 
502 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
503 {
504     ASSERT(enumerationMemberLiteral.enumerationDefinition());
505     ASSERT(enumerationMemberLiteral.enumerationDefinition());
506     auto variableName = generateNextVariableName();
507     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());
508     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;);
509     appendRightValue(enumerationMemberLiteral, variableName);
510 }
511 
512 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)
513 {
514     Visitor::visit(expression);
515 }
516 
517 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)
518 {
519     // This should be lowered already.
520     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().
521     notImplemented();
522     appendRightValue(dotExpression, generateNextVariableName());
523 }
524 
525 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)
526 {
527     auto valueName = generateNextVariableName();
528     MangledTypeName mangledTypeName = m_typeNamer.mangledNameForType(globalVariableReference.resolvedType());
529 
530     checkErrorAndVisit(globalVariableReference.base());
531     MangledVariableName structVariable = takeLastValue();
532 
533     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());
534 
535     m_stringBuilder.append(
536         m_indent, mangledTypeName, &#39; &#39;, valueName, &quot; = &quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);
537 
538     appendLeftValue(globalVariableReference, valueName, { }, Nullability::NotNull,
539         [this, mangledTypeName, structVariable, mangledFieldName] {
540             auto pointerName = generateNextVariableName();
541             m_stringBuilder.append(
542                 m_indent, &quot;thread &quot;, mangledTypeName, &quot;* &quot;, pointerName, &quot; = &amp;&quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);
543             return pointerName;
544         });
545 }
546 
547 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)
548 {
549     // This should be lowered already.
550     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().
551     notImplemented();
552     appendRightValue(indexExpression, generateNextVariableName());
553 }
554 
555 void FunctionDefinitionWriter::visit(AST::PropertyAccessExpression&amp; propertyAccessExpression)
556 {
557     // This should be lowered already.
558     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().
559     notImplemented();
560     appendRightValue(propertyAccessExpression, generateNextVariableName());
561 }
562 
563 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)
564 {
565     ASSERT(variableDeclaration.type());
566     auto variableName = generateNextVariableName();
567     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);
568     ASSERT_UNUSED(addResult, addResult.isNewEntry);
569     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.
570     if (variableDeclaration.initializer()) {
571         checkErrorAndVisit(*variableDeclaration.initializer());
572         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, takeLastValue(), &quot;;\n&quot;);
573     } else
574         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);
575 }
576 
577 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)
578 {
579     checkErrorAndVisit(assignmentExpression.left());
580     auto [pointerName, nullability] = takeLastLeftValue();
581     checkErrorAndVisit(assignmentExpression.right());
582     auto [rightName, rightNullability] = takeLastValueAndNullability();
583 
584     if (nullability == Nullability::CanBeNull)
585         m_stringBuilder.append(
586             m_indent, &quot;if (&quot;, pointerName, &quot;)\n&quot;,
587             m_indent, &quot;    *&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);
588     else
589         m_stringBuilder.append(m_indent, &quot;*&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);
590     appendRightValueWithNullability(assignmentExpression, rightName, rightNullability);
591 }
592 
593 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)
594 {
595     Vector&lt;MangledVariableName&gt; argumentNames;
596     for (auto&amp; argument : callExpression.arguments()) {
597         checkErrorAndVisit(argument);
598         argumentNames.append(takeLastValue());
599     }
600 
601     bool isVoid = matches(callExpression.resolvedType(), m_intrinsics.voidType());
602     MangledVariableName returnName;
603     if (!isVoid) {
604         returnName = generateNextVariableName();
605         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(callExpression.resolvedType()), &#39; &#39;, returnName, &quot;;\n&quot;);
606     }
607 
608     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {
609         auto generateNextVariableName = [this]() -&gt; MangledVariableName {
610             return this-&gt;generateNextVariableName();
611         };
612 
613         m_stringBuilder.append(&#39;\n&#39;);
614         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), returnName, argumentNames, m_intrinsics, m_typeNamer, WTFMove(generateNextVariableName), m_indent);
615         m_stringBuilder.append(&#39;\n&#39;);
616     } else {
617         m_stringBuilder.append(m_indent);
618 
619         auto iterator = m_functionMapping.find(&amp;callExpression.function());
620         ASSERT(iterator != m_functionMapping.end());
621         if (!isVoid)
622             m_stringBuilder.append(returnName, &quot; = &quot;);
623         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);
624         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {
625             if (i)
626                 m_stringBuilder.append(&quot;, &quot;);
627             m_stringBuilder.append(argumentNames[i]);
628         }
629         m_stringBuilder.append(&quot;);\n&quot;);
630     }
631 
632     appendRightValue(callExpression, returnName);
633 }
634 
635 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)
636 {
637     Optional&lt;MangledVariableName&gt; result;
638     for (auto&amp; expression : commaExpression.list()) {
639         checkErrorAndVisit(expression);
640         result = takeLastValue();
641     }
642     ASSERT(result);
643     appendRightValue(commaExpression, *result);
644 }
645 
646 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)
647 {
648     checkErrorAndVisit(dereferenceExpression.pointer());
649     auto [inputPointer, nullability] = takeLastValueAndNullability();
650     auto resultValue = generateNextVariableName();
651     auto resultType = m_typeNamer.mangledNameForType(dereferenceExpression.resolvedType());
652 
653     if (nullability == Nullability::CanBeNull) {
654         m_stringBuilder.append(
655             m_indent, resultType , &#39; &#39;, resultValue, &quot; = &quot;, inputPointer, &quot; ? &quot;, &#39;*&#39;, inputPointer, &quot; : &quot;, resultType, &quot;{ };\n&quot;);
656     } else
657         m_stringBuilder.append(m_indent, resultValue, &quot; = *&quot;, inputPointer, &quot;;\n&quot;);
658 
659     appendLeftValue(dereferenceExpression, resultValue, inputPointer, nullability);
660 }
661 
662 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)
663 {
664     checkErrorAndVisit(logicalExpression.left());
665     auto left = takeLastValue();
666     checkErrorAndVisit(logicalExpression.right());
667     auto right = takeLastValue();
668     auto variableName = generateNextVariableName();
669 
670     m_stringBuilder.append(
671         m_indent, m_typeNamer.mangledNameForType(logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left);
672     switch (logicalExpression.type()) {
673     case AST::LogicalExpression::Type::And:
674         m_stringBuilder.append(&quot; &amp;&amp; &quot;);
675         break;
676     default:
677         ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);
678         m_stringBuilder.append(&quot; || &quot;);
679         break;
680     }
681     m_stringBuilder.append(right, &quot;;\n&quot;);
682     appendRightValue(logicalExpression, variableName);
683 }
684 
685 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
686 {
687     checkErrorAndVisit(logicalNotExpression.operand());
688     auto operand = takeLastValue();
689     auto variableName = generateNextVariableName();
690 
691     m_stringBuilder.append(
692         m_indent, m_typeNamer.mangledNameForType(logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;);
693     appendRightValue(logicalNotExpression, variableName);
694 }
695 
696 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
697 {
698     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());
699     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.
700     // https://bugs.webkit.org/show_bug.cgi?id=198838
701     auto variableName = generateNextVariableName();
702 
703     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());
704     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
705         auto ptrValue = takeLastValue();
706         m_stringBuilder.append(
707             m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, ptrValue, &quot; ? &quot;, mangledTypeName, &quot;{ &quot;, ptrValue, &quot;, 1 } : &quot;, mangledTypeName, &quot;{ nullptr, 0 };\n&quot;);
708     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
709         auto lValue = takeLastLeftValue().value;
710         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());
711         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;-&gt;data(), &quot;, arrayType.numElements(), &quot; };\n&quot;);
712     } else {
713         auto lValue = takeLastLeftValue().value;
714         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;);
715     }
716     appendRightValue(makeArrayReferenceExpression, variableName);
717 }
718 
719 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)
720 {
721     checkErrorAndVisit(makePointerExpression.leftValue());
722     auto [pointer, nullability] = takeLastLeftValue();
723     auto variableName = generateNextVariableName();
724     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, pointer, &quot;;\n&quot;);
725     appendRightValueWithNullability(makePointerExpression, variableName, nullability);
726 }
727 
728 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp;)
729 {
730     // This should be lowered already.
731     ASSERT_NOT_REACHED();
732 }
733 
734 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)
735 {
736     checkErrorAndVisit(ternaryExpression.predicate());
737     auto check = takeLastValue();
738     checkErrorAndVisit(ternaryExpression.bodyExpression());
739     auto body = takeLastValue();
740     checkErrorAndVisit(ternaryExpression.elseExpression());
741     auto elseBody = takeLastValue();
742 
743     auto variableName = generateNextVariableName();
744     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, check, &quot; ? &quot;, body, &quot; : &quot;, elseBody, &quot;;\n&quot;);
745     appendRightValue(ternaryExpression, variableName);
746 }
747 
748 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)
749 {
750     ASSERT(variableReference.variable());
751     auto iterator = m_variableMapping.find(variableReference.variable());
752     ASSERT(iterator != m_variableMapping.end());
753 
754     MangledVariableName variableName = iterator-&gt;value;
755 
756     appendLeftValue(variableReference, variableName, { }, Nullability::NotNull,
757         [this, &amp;variableReference, variableName] {
758             auto pointerName = generateNextVariableName();
759             m_stringBuilder.append(m_indent, &quot;thread &quot;, m_typeNamer.mangledNameForType(variableReference.resolvedType()), &quot;* &quot;, pointerName, &quot; = &amp;&quot;, variableName, &quot;;\n&quot;);
760             return pointerName;
761         });
762 }
763 
764 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)
765 {
766     constantExpression.visit(WTF::makeVisitor(
767         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {
768             m_stringBuilder.append(integerLiteral.value());
769         },
770         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
771             m_stringBuilder.append(unsignedIntegerLiteral.value());
772         },
773         [&amp;](AST::FloatLiteral&amp; floatLiteral) {
774             m_stringBuilder.append(floatLiteral.value());
775         },
776         [&amp;](AST::NullLiteral&amp;) {
777             m_stringBuilder.append(&quot;nullptr&quot;);
778         },
779         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
780             if (booleanLiteral.value())
781                 m_stringBuilder.append(&quot;true&quot;);
782             else
783                 m_stringBuilder.append(&quot;false&quot;);
784         },
785         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
786             ASSERT(enumerationMemberLiteral.enumerationDefinition());
787             ASSERT(enumerationMemberLiteral.enumerationDefinition());
788             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));
789         }
790     ));
791 }
792 
793 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {
794 public:
795     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
796         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
797         , m_matchedSemantics(WTFMove(matchedSemantics))
798     {
799     }
800 
801 private:
802     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
803 
804     MatchedRenderSemantics m_matchedSemantics;
805 };
806 
807 std::unique_ptr&lt;EntryPointScaffolding&gt; RenderFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
808 {
809     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
810         return this-&gt;generateNextVariableName();
811     };
812     if (&amp;functionDefinition == m_matchedSemantics.vertexShader)
813         return makeUnique&lt;VertexEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.vertexShaderEntryPointItems, m_matchedSemantics.vertexShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedVertexAttributes);
814     if (&amp;functionDefinition == m_matchedSemantics.fragmentShader)
815         return makeUnique&lt;FragmentEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.fragmentShaderEntryPointItems, m_matchedSemantics.fragmentShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedColorAttachments);
816     return nullptr;
817 }
818 
819 class ComputeFunctionDefinitionWriter final : public FunctionDefinitionWriter {
820 public:
821     ComputeFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
822         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
823         , m_matchedSemantics(WTFMove(matchedSemantics))
824     {
825     }
826 
827 private:
828     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
829 
830     MatchedComputeSemantics m_matchedSemantics;
831 };
832 
833 std::unique_ptr&lt;EntryPointScaffolding&gt; ComputeFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
834 {
835     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
836         return this-&gt;generateNextVariableName();
837     };
838     if (&amp;functionDefinition == m_matchedSemantics.shader)
839         return makeUnique&lt;ComputeEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.entryPointItems, m_matchedSemantics.resourceMap, m_layout, WTFMove(generateNextVariableName));
840     return nullptr;
841 }
842 
843 static HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; generateMetalFunctionsMapping(Program&amp; program)
844 {
845     unsigned numFunctions = 0;
846     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; functionMapping;
847     for (auto&amp; functionDefinition : program.functionDefinitions()) {
848         auto addResult = functionMapping.add(&amp;functionDefinition, MangledFunctionName { numFunctions++ });
849         ASSERT_UNUSED(addResult, addResult.isNewEntry);
850     }
851 
852     return functionMapping;
853 }
854 
855 static void emitSharedMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, const HashSet&lt;AST::FunctionDeclaration*&gt;&amp; reachableFunctions, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
856 {
857     for (auto&amp; functionDefinition : program.functionDefinitions()) {
858         if (!functionDefinition-&gt;entryPointType() &amp;&amp; reachableFunctions.contains(&amp;functionDefinition))
859             declareFunction(stringBuilder, functionDefinition, typeNamer, functionMapping);
860     }
861 
862     stringBuilder.append(&#39;\n&#39;);
863 }
864 
865 class ReachableFunctionsGatherer final : public Visitor {
866 public:
867     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override
868     {
869         auto result = m_reachableFunctions.add(&amp;functionDeclaration);
870         if (result.isNewEntry)
871             Visitor::visit(functionDeclaration);
872     }
873 
874     void visit(AST::CallExpression&amp; callExpression) override
875     {
876         Visitor::visit(callExpression);
877         if (is&lt;AST::FunctionDefinition&gt;(callExpression.function()))
878             checkErrorAndVisit(downcast&lt;AST::FunctionDefinition&gt;(callExpression.function()));
879         else
880             checkErrorAndVisit(downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()));
881     }
882 
883     HashSet&lt;AST::FunctionDeclaration*&gt; takeReachableFunctions() { return WTFMove(m_reachableFunctions); }
884 
885 private:
886     HashSet&lt;AST::FunctionDeclaration*&gt; m_reachableFunctions;
887 };
888 
889 RenderMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
890 {
891     auto&amp; vertexShaderEntryPoint = *matchedSemantics.vertexShader;
892     auto* fragmentShaderEntryPoint = matchedSemantics.fragmentShader;
893 
894     ReachableFunctionsGatherer reachableFunctionsGatherer;
895     reachableFunctionsGatherer.Visitor::visit(vertexShaderEntryPoint);
896     if (fragmentShaderEntryPoint)
897         reachableFunctionsGatherer.Visitor::visit(*fragmentShaderEntryPoint);
898     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
899 
900     auto functionMapping = generateMetalFunctionsMapping(program);
901 
902     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
903 
904     RenderFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
905     for (auto&amp; functionDefinition : program.functionDefinitions()) {
906         if (reachableFunctions.contains(&amp;functionDefinition))
907             functionDefinitionWriter.visit(functionDefinition);
908     }
909 
910     return { functionMapping.get(&amp;vertexShaderEntryPoint), fragmentShaderEntryPoint ? functionMapping.get(fragmentShaderEntryPoint) : MangledFunctionName { 0 } };
911 }
912 
913 ComputeMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
914 {
915     auto&amp; entryPoint = *matchedSemantics.shader;
916 
917     ReachableFunctionsGatherer reachableFunctionsGatherer;
918     reachableFunctionsGatherer.Visitor::visit(entryPoint);
919     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
920 
921     auto functionMapping = generateMetalFunctionsMapping(program);
922     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
923 
924     ComputeFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
925     for (auto&amp; functionDefinition : program.functionDefinitions()) {
926         if (reachableFunctions.contains(&amp;functionDefinition))
927             functionDefinitionWriter.visit(functionDefinition);
928     }
929 
930     return { functionMapping.get(&amp;entryPoint) };
931 }
932 
933 } // namespace Metal
934 
935 } // namespace WHLSL
936 
937 } // namespace WebCore
938 
939 #endif
    </pre>
  </body>
</html>