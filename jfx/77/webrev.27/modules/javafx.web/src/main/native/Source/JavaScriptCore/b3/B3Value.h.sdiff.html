<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Value.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3Value.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3ValueInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Value.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;B3Bank.h&quot;
 31 #include &quot;B3Effects.h&quot;
 32 #include &quot;B3FrequentedBlock.h&quot;
 33 #include &quot;B3Kind.h&quot;
 34 #include &quot;B3Origin.h&quot;
 35 #include &quot;B3SparseCollection.h&quot;
 36 #include &quot;B3Type.h&quot;
 37 #include &quot;B3ValueKey.h&quot;
 38 #include &quot;B3Width.h&quot;
 39 #include &lt;wtf/CommaPrinter.h&gt;
 40 #include &lt;wtf/FastMalloc.h&gt;
<span class="line-modified"> 41 #include &lt;wtf/Noncopyable.h&gt;</span>
 42 #include &lt;wtf/StdLibExtras.h&gt;
 43 #include &lt;wtf/TriState.h&gt;
 44 
 45 namespace JSC { namespace B3 {
 46 
 47 class BasicBlock;
 48 class CheckValue;
 49 class InsertionSet;
 50 class PhiChildren;
 51 class Procedure;
 52 
 53 class JS_EXPORT_PRIVATE Value {
 54     WTF_MAKE_FAST_ALLOCATED;
 55 public:
<span class="line-removed"> 56     typedef Vector&lt;Value*, 3&gt; AdjacencyList;</span>
<span class="line-removed"> 57 </span>
 58     static const char* const dumpPrefix;
 59 
 60     static bool accepts(Kind) { return true; }
 61 
 62     virtual ~Value();
 63 
 64     unsigned index() const { return m_index; }
 65 
 66     // Note that the kind is immutable, except for replacing values with:
 67     // Identity, Nop, Oops, Jump, and Phi. See below for replaceWithXXX() methods.
 68     Kind kind() const { return m_kind; }
 69 
 70     Opcode opcode() const { return kind().opcode(); }
 71 
 72     // Note that the kind is meant to be immutable. Do this when you know that this is safe. It&#39;s not
 73     // usually safe.
 74     void setKindUnsafely(Kind kind) { m_kind = kind; }
 75     void setOpcodeUnsafely(Opcode opcode) { m_kind.setOpcode(opcode); }
 76 
 77     // It&#39;s good practice to mirror Kind methods here, so you can say value-&gt;isBlah()
 78     // instead of value-&gt;kind().isBlah().
 79     bool isChill() const { return kind().isChill(); }
 80     bool traps() const { return kind().traps(); }
 81 
 82     Origin origin() const { return m_origin; }
 83     void setOrigin(Origin origin) { m_origin = origin; }
 84 
<span class="line-removed"> 85     Value*&amp; child(unsigned index) { return m_children[index]; }</span>
<span class="line-removed"> 86     Value* child(unsigned index) const { return m_children[index]; }</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88     Value*&amp; lastChild() { return m_children.last(); }</span>
<span class="line-removed"> 89     Value* lastChild() const { return m_children.last(); }</span>
<span class="line-removed"> 90 </span>
<span class="line-removed"> 91     unsigned numChildren() const { return m_children.size(); }</span>
<span class="line-removed"> 92 </span>
 93     Type type() const { return m_type; }
 94     void setType(Type type) { m_type = type; }
 95 
 96     // This is useful when lowering. Note that this is only valid for non-void values.
 97     Bank resultBank() const { return bankForType(type()); }
 98     Width resultWidth() const { return widthForType(type()); }
 99 
<span class="line-modified">100     AdjacencyList&amp; children() { return m_children; }</span>
<span class="line-modified">101     const AdjacencyList&amp; children() const { return m_children; }</span>

















































102 
103     // If you want to replace all uses of this value with a different value, then replace this
104     // value with Identity. Then do a pass of performSubstitution() on all of the values that use
105     // this one. Usually we do all of this in one pass in pre-order, which ensures that the
106     // X-&gt;replaceWithIdentity() calls happen before the performSubstitution() calls on X&#39;s users.
107     void replaceWithIdentity(Value*);
108 
109     // It&#39;s often necessary to kill a value. It&#39;s tempting to replace the value with Nop or to
110     // just remove it. But unless you are sure that the value is Void, you will probably still
111     // have other values that use this one. Sure, you may kill those later, or you might not. This
112     // method lets you kill a value safely. It will replace Void values with Nop and non-Void
113     // values with Identities on bottom constants. For this reason, this takes a callback that is
114     // responsible for creating bottoms. There&#39;s a utility for this, see B3BottomProvider.h. You
115     // can also access that utility using replaceWithBottom(InsertionSet&amp;, size_t).
116     //
117     // You&#39;re guaranteed that bottom is zero.
118     template&lt;typename BottomProvider&gt;
119     void replaceWithBottom(const BottomProvider&amp;);
120 
121     void replaceWithBottom(InsertionSet&amp;, size_t index);
</pre>
<hr />
<pre>
278     // called with the signature:
279     //
280     //     (Value*) -&gt; WalkStatus
281     enum WalkStatus {
282         Continue,
283         IgnoreChildren,
284         Stop
285     };
286     template&lt;typename Functor&gt;
287     void walk(const Functor&amp; functor, PhiChildren* = nullptr);
288 
289     // B3 purposefully only represents signed 32-bit offsets because that&#39;s what x86 can encode, and
290     // ARM64 cannot encode anything bigger. The IsLegalOffset type trait is then used on B3 Value
291     // methods to prevent implicit conversions by C++ from invalid offset types: these cause compilation
292     // to fail, instead of causing implementation-defined behavior (which often turns to exploit).
293     // OffsetType isn&#39;t sufficient to determine offset validity! Each Value opcode further has an
294     // isLegalOffset runtime method used to determine value legality at runtime. This is exposed to users
295     // of B3 to force them to reason about the target&#39;s offset.
296     typedef int32_t OffsetType;
297     template&lt;typename Int&gt;
<span class="line-modified">298     struct IsLegalOffset : std::conjunction&lt;</span>
<span class="line-modified">299         typename std::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type,</span>
<span class="line-modified">300         typename std::enable_if&lt;std::is_signed&lt;Int&gt;::value&gt;::type,</span>
<span class="line-modified">301         typename std::enable_if&lt;sizeof(Int) &lt;= sizeof(OffsetType)&gt;::type</span>
<span class="line-modified">302     &gt; { };</span>
<span class="line-removed">303 </span>
304 
305 protected:
<span class="line-modified">306     virtual Value* cloneImpl() const;</span>



307 
308     virtual void dumpChildren(CommaPrinter&amp;, PrintStream&amp;) const;
309     virtual void dumpMeta(CommaPrinter&amp;, PrintStream&amp;) const;
310 







































































































































311 private:


































312     friend class Procedure;
313     friend class SparseCollection&lt;Value&gt;;
314 































315     // Checks that this kind is valid for use with B3::Value.
<span class="line-modified">316     ALWAYS_INLINE static void checkKind(Kind kind, unsigned numArgs)</span>
317     {
318         switch (kind.opcode()) {
319         case FramePointer:
320         case Nop:
321         case Phi:
322         case Jump:
323         case Oops:
324         case EntrySwitch:
325             if (UNLIKELY(numArgs))
326                 badKind(kind, numArgs);
<span class="line-modified">327             break;</span>
328         case Return:
329             if (UNLIKELY(numArgs &gt; 1))
330                 badKind(kind, numArgs);
<span class="line-modified">331             break;</span>
332         case Identity:
333         case Opaque:
334         case Neg:
335         case Clz:
336         case Abs:
337         case Ceil:
338         case Floor:
339         case Sqrt:
340         case SExt8:
341         case SExt16:
342         case Trunc:
343         case SExt32:
344         case ZExt32:
345         case FloatToDouble:
346         case IToD:
347         case DoubleToFloat:
348         case IToF:
349         case BitwiseCast:
350         case Branch:
351         case Depend:
352             if (UNLIKELY(numArgs != 1))
353                 badKind(kind, numArgs);
<span class="line-modified">354             break;</span>
355         case Add:
356         case Sub:
357         case Mul:
358         case Div:
359         case UDiv:
360         case Mod:
361         case UMod:
362         case BitAnd:
363         case BitOr:
364         case BitXor:
365         case Shl:
366         case SShr:
367         case ZShr:
368         case RotR:
369         case RotL:
370         case Equal:
371         case NotEqual:
372         case LessThan:
373         case GreaterThan:
374         case LessEqual:
375         case GreaterEqual:
376         case Above:
377         case Below:
378         case AboveEqual:
379         case BelowEqual:
380         case EqualOrUnordered:
381             if (UNLIKELY(numArgs != 2))
382                 badKind(kind, numArgs);
<span class="line-modified">383             break;</span>
384         case Select:
385             if (UNLIKELY(numArgs != 3))
386                 badKind(kind, numArgs);
<span class="line-modified">387             break;</span>
388         default:
389             badKind(kind, numArgs);
390             break;
391         }

392     }
393 
394 protected:
395     enum CheckedOpcodeTag { CheckedOpcode };
396 
<span class="line-removed">397     Value(const Value&amp;) = default;</span>
<span class="line-removed">398     Value&amp; operator=(const Value&amp;) = default;</span>
<span class="line-removed">399 </span>
400     // Instantiate values via Procedure.
401     // This form requires specifying the type explicitly:
402     template&lt;typename... Arguments&gt;
<span class="line-modified">403     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin, Value* firstChild, Arguments... arguments)</span>
404         : m_kind(kind)
405         , m_type(type)

406         , m_origin(origin)
<span class="line-removed">407         , m_children{ firstChild, arguments... }</span>
408     {

409     }
410     // This form is for specifying the type explicitly when the opcode has no children:
<span class="line-modified">411     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin)</span>
412         : m_kind(kind)
413         , m_type(type)

414         , m_origin(origin)
415     {
<span class="line-modified">416     }</span>
<span class="line-removed">417     // This form is for those opcodes that can infer their type from the opcode and first child:</span>
<span class="line-removed">418     template&lt;typename... Arguments&gt;</span>
<span class="line-removed">419     explicit Value(CheckedOpcodeTag, Kind kind, Origin origin, Value* firstChild)</span>
<span class="line-removed">420         : m_kind(kind)</span>
<span class="line-removed">421         , m_type(typeFor(kind, firstChild))</span>
<span class="line-removed">422         , m_origin(origin)</span>
<span class="line-removed">423         , m_children{ firstChild }</span>
<span class="line-removed">424     {</span>
<span class="line-removed">425     }</span>
<span class="line-removed">426     // This form is for those opcodes that can infer their type from the opcode and first and second child:</span>
<span class="line-removed">427     template&lt;typename... Arguments&gt;</span>
<span class="line-removed">428     explicit Value(CheckedOpcodeTag, Kind kind, Origin origin, Value* firstChild, Value* secondChild, Arguments... arguments)</span>
<span class="line-removed">429         : m_kind(kind)</span>
<span class="line-removed">430         , m_type(typeFor(kind, firstChild, secondChild))</span>
<span class="line-removed">431         , m_origin(origin)</span>
<span class="line-removed">432         , m_children{ firstChild, secondChild, arguments... }</span>
<span class="line-removed">433     {</span>
434     }
435     // This form is for those opcodes that can infer their type from the opcode alone, and that don&#39;t
436     // take any arguments:
<span class="line-modified">437     explicit Value(CheckedOpcodeTag, Kind kind, Origin origin)</span>
438         : m_kind(kind)
439         , m_type(typeFor(kind, nullptr))

440         , m_origin(origin)
441     {

442     }
<span class="line-modified">443     // Use this form for varargs.</span>
<span class="line-modified">444     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin, const AdjacencyList&amp; children)</span>
445         : m_kind(kind)
<span class="line-modified">446         , m_type(type)</span>

447         , m_origin(origin)
<span class="line-removed">448         , m_children(children)</span>
449     {

450     }
<span class="line-modified">451     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin, AdjacencyList&amp;&amp; children)</span>


452         : m_kind(kind)
<span class="line-modified">453         , m_type(type)</span>

454         , m_origin(origin)
<span class="line-removed">455         , m_children(WTFMove(children))</span>
456     {

457     }
458 
459     // This is the constructor you end up actually calling, if you&#39;re instantiating Value
460     // directly.
<span class="line-modified">461     template&lt;typename... Arguments&gt;</span>
<span class="line-modified">462         explicit Value(Kind kind, Type type, Origin origin)</span>
<span class="line-removed">463         : Value(CheckedOpcode, kind, type, origin)</span>
<span class="line-removed">464     {</span>
<span class="line-removed">465         checkKind(kind, 0);</span>
<span class="line-removed">466     }</span>
<span class="line-removed">467     template&lt;typename... Arguments&gt;</span>
<span class="line-removed">468         explicit Value(Kind kind, Type type, Origin origin, Value* firstChild, Arguments&amp;&amp;... arguments)</span>
<span class="line-removed">469         : Value(CheckedOpcode, kind, type, origin, firstChild, std::forward&lt;Arguments&gt;(arguments)...)</span>
<span class="line-removed">470     {</span>
<span class="line-removed">471         checkKind(kind, 1 + sizeof...(arguments));</span>
<span class="line-removed">472     }</span>
<span class="line-removed">473     template&lt;typename... Arguments&gt;</span>
<span class="line-removed">474         explicit Value(Kind kind, Type type, Origin origin, const AdjacencyList&amp; children)</span>
<span class="line-removed">475         : Value(CheckedOpcode, kind, type, origin, children)</span>
476     {
<span class="line-modified">477         checkKind(kind, children.size());</span>
478     }

479     template&lt;typename... Arguments&gt;
<span class="line-modified">480         explicit Value(Kind kind, Type type, Origin origin, AdjacencyList&amp;&amp; children)</span>
<span class="line-modified">481         : Value(CheckedOpcode, kind, type, origin, WTFMove(children))</span>
482     {
<span class="line-removed">483         checkKind(kind, m_children.size());</span>
484     }
485     template&lt;typename... Arguments&gt;
<span class="line-modified">486         explicit Value(Kind kind, Origin origin, Arguments&amp;&amp;... arguments)</span>
<span class="line-modified">487         : Value(CheckedOpcode, kind, origin, std::forward&lt;Arguments&gt;(arguments)...)</span>
488     {
<span class="line-removed">489         checkKind(kind, sizeof...(arguments));</span>
490     }
491 
492 private:
493     friend class CheckValue; // CheckValue::convertToAdd() modifies m_kind.
494 
495     static Type typeFor(Kind, Value* firstChild, Value* secondChild = nullptr);
496 
<span class="line-modified">497     // This group of fields is arranged to fit in 64 bits.</span>
498 protected:
499     unsigned m_index { UINT_MAX };
500 private:
501     Kind m_kind;
502     Type m_type;
<span class="line-modified">503 </span>


504     Origin m_origin;
<span class="line-removed">505     AdjacencyList m_children;</span>
506 
507     NO_RETURN_DUE_TO_CRASH static void badKind(Kind, unsigned);
508 
509 public:
510     BasicBlock* owner { nullptr }; // computed by Procedure::resetValueOwners().
511 };
512 
513 class DeepValueDump {
514 public:
515     DeepValueDump(const Procedure* proc, const Value* value)
516         : m_proc(proc)
517         , m_value(value)
518     {
519     }
520 
<span class="line-modified">521     void dump(PrintStream&amp; out) const</span>
<span class="line-removed">522     {</span>
<span class="line-removed">523         if (m_value)</span>
<span class="line-removed">524             m_value-&gt;deepDump(m_proc, out);</span>
<span class="line-removed">525         else</span>
<span class="line-removed">526             out.print(&quot;&lt;null&gt;&quot;);</span>
<span class="line-removed">527     }</span>
528 
529 private:
530     const Procedure* m_proc;
531     const Value* m_value;
532 };
533 
534 inline DeepValueDump deepDump(const Procedure&amp; proc, const Value* value)
535 {
536     return DeepValueDump(&amp;proc, value);
537 }
538 inline DeepValueDump deepDump(const Value* value)
539 {
540     return DeepValueDump(nullptr, value);
541 }
542 














































































































543 } } // namespace JSC::B3
544 
545 #endif // ENABLE(B3_JIT)
</pre>
</td>
<td>
<hr />
<pre>
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;B3Bank.h&quot;
 31 #include &quot;B3Effects.h&quot;
 32 #include &quot;B3FrequentedBlock.h&quot;
 33 #include &quot;B3Kind.h&quot;
 34 #include &quot;B3Origin.h&quot;
 35 #include &quot;B3SparseCollection.h&quot;
 36 #include &quot;B3Type.h&quot;
 37 #include &quot;B3ValueKey.h&quot;
 38 #include &quot;B3Width.h&quot;
 39 #include &lt;wtf/CommaPrinter.h&gt;
 40 #include &lt;wtf/FastMalloc.h&gt;
<span class="line-modified"> 41 #include &lt;wtf/IteratorRange.h&gt;</span>
 42 #include &lt;wtf/StdLibExtras.h&gt;
 43 #include &lt;wtf/TriState.h&gt;
 44 
 45 namespace JSC { namespace B3 {
 46 
 47 class BasicBlock;
 48 class CheckValue;
 49 class InsertionSet;
 50 class PhiChildren;
 51 class Procedure;
 52 
 53 class JS_EXPORT_PRIVATE Value {
 54     WTF_MAKE_FAST_ALLOCATED;
 55 public:


 56     static const char* const dumpPrefix;
 57 
 58     static bool accepts(Kind) { return true; }
 59 
 60     virtual ~Value();
 61 
 62     unsigned index() const { return m_index; }
 63 
 64     // Note that the kind is immutable, except for replacing values with:
 65     // Identity, Nop, Oops, Jump, and Phi. See below for replaceWithXXX() methods.
 66     Kind kind() const { return m_kind; }
 67 
 68     Opcode opcode() const { return kind().opcode(); }
 69 
 70     // Note that the kind is meant to be immutable. Do this when you know that this is safe. It&#39;s not
 71     // usually safe.
 72     void setKindUnsafely(Kind kind) { m_kind = kind; }
 73     void setOpcodeUnsafely(Opcode opcode) { m_kind.setOpcode(opcode); }
 74 
 75     // It&#39;s good practice to mirror Kind methods here, so you can say value-&gt;isBlah()
 76     // instead of value-&gt;kind().isBlah().
 77     bool isChill() const { return kind().isChill(); }
 78     bool traps() const { return kind().traps(); }
 79 
 80     Origin origin() const { return m_origin; }
 81     void setOrigin(Origin origin) { m_origin = origin; }
 82 








 83     Type type() const { return m_type; }
 84     void setType(Type type) { m_type = type; }
 85 
 86     // This is useful when lowering. Note that this is only valid for non-void values.
 87     Bank resultBank() const { return bankForType(type()); }
 88     Width resultWidth() const { return widthForType(type()); }
 89 
<span class="line-modified"> 90     unsigned numChildren() const</span>
<span class="line-modified"> 91     {</span>
<span class="line-added"> 92         if (m_numChildren == VarArgs)</span>
<span class="line-added"> 93             return childrenVector().size();</span>
<span class="line-added"> 94         return m_numChildren;</span>
<span class="line-added"> 95     }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     Value*&amp; child(unsigned index)</span>
<span class="line-added"> 98     {</span>
<span class="line-added"> 99         ASSERT(index &lt; numChildren());</span>
<span class="line-added">100         return m_numChildren == VarArgs ? childrenVector()[index] : childrenArray()[index];</span>
<span class="line-added">101     }</span>
<span class="line-added">102     Value* child(unsigned index) const</span>
<span class="line-added">103     {</span>
<span class="line-added">104         ASSERT(index &lt; numChildren());</span>
<span class="line-added">105         return m_numChildren == VarArgs ? childrenVector()[index] : childrenArray()[index];</span>
<span class="line-added">106     }</span>
<span class="line-added">107 </span>
<span class="line-added">108     Value*&amp; lastChild()</span>
<span class="line-added">109     {</span>
<span class="line-added">110         if (m_numChildren == VarArgs)</span>
<span class="line-added">111             return childrenVector().last();</span>
<span class="line-added">112         ASSERT(m_numChildren &gt;= 1);</span>
<span class="line-added">113         return childrenArray()[m_numChildren - 1];</span>
<span class="line-added">114     }</span>
<span class="line-added">115     Value* lastChild() const</span>
<span class="line-added">116     {</span>
<span class="line-added">117         if (m_numChildren == VarArgs)</span>
<span class="line-added">118             return childrenVector().last();</span>
<span class="line-added">119         ASSERT(m_numChildren &gt;= 1);</span>
<span class="line-added">120         return childrenArray()[m_numChildren - 1];</span>
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     WTF::IteratorRange&lt;Value**&gt; children()</span>
<span class="line-added">124     {</span>
<span class="line-added">125         if (m_numChildren == VarArgs) {</span>
<span class="line-added">126             Vector&lt;Value*, 3&gt;&amp; vec = childrenVector();</span>
<span class="line-added">127             return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end());</span>
<span class="line-added">128         }</span>
<span class="line-added">129         Value** buffer = childrenArray();</span>
<span class="line-added">130         return {buffer, buffer + m_numChildren };</span>
<span class="line-added">131     }</span>
<span class="line-added">132     WTF::IteratorRange&lt;Value* const*&gt; children() const</span>
<span class="line-added">133     {</span>
<span class="line-added">134         if (m_numChildren == VarArgs) {</span>
<span class="line-added">135             const Vector&lt;Value*, 3&gt;&amp; vec = childrenVector();</span>
<span class="line-added">136             return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end());</span>
<span class="line-added">137         }</span>
<span class="line-added">138         Value* const* buffer = childrenArray();</span>
<span class="line-added">139         return {buffer, buffer + m_numChildren };</span>
<span class="line-added">140     }</span>
141 
142     // If you want to replace all uses of this value with a different value, then replace this
143     // value with Identity. Then do a pass of performSubstitution() on all of the values that use
144     // this one. Usually we do all of this in one pass in pre-order, which ensures that the
145     // X-&gt;replaceWithIdentity() calls happen before the performSubstitution() calls on X&#39;s users.
146     void replaceWithIdentity(Value*);
147 
148     // It&#39;s often necessary to kill a value. It&#39;s tempting to replace the value with Nop or to
149     // just remove it. But unless you are sure that the value is Void, you will probably still
150     // have other values that use this one. Sure, you may kill those later, or you might not. This
151     // method lets you kill a value safely. It will replace Void values with Nop and non-Void
152     // values with Identities on bottom constants. For this reason, this takes a callback that is
153     // responsible for creating bottoms. There&#39;s a utility for this, see B3BottomProvider.h. You
154     // can also access that utility using replaceWithBottom(InsertionSet&amp;, size_t).
155     //
156     // You&#39;re guaranteed that bottom is zero.
157     template&lt;typename BottomProvider&gt;
158     void replaceWithBottom(const BottomProvider&amp;);
159 
160     void replaceWithBottom(InsertionSet&amp;, size_t index);
</pre>
<hr />
<pre>
317     // called with the signature:
318     //
319     //     (Value*) -&gt; WalkStatus
320     enum WalkStatus {
321         Continue,
322         IgnoreChildren,
323         Stop
324     };
325     template&lt;typename Functor&gt;
326     void walk(const Functor&amp; functor, PhiChildren* = nullptr);
327 
328     // B3 purposefully only represents signed 32-bit offsets because that&#39;s what x86 can encode, and
329     // ARM64 cannot encode anything bigger. The IsLegalOffset type trait is then used on B3 Value
330     // methods to prevent implicit conversions by C++ from invalid offset types: these cause compilation
331     // to fail, instead of causing implementation-defined behavior (which often turns to exploit).
332     // OffsetType isn&#39;t sufficient to determine offset validity! Each Value opcode further has an
333     // isLegalOffset runtime method used to determine value legality at runtime. This is exposed to users
334     // of B3 to force them to reason about the target&#39;s offset.
335     typedef int32_t OffsetType;
336     template&lt;typename Int&gt;
<span class="line-modified">337     struct IsLegalOffset {</span>
<span class="line-modified">338         static constexpr bool value = std::is_integral&lt;Int&gt;::value</span>
<span class="line-modified">339             &amp;&amp; std::is_signed&lt;Int&gt;::value</span>
<span class="line-modified">340             &amp;&amp; sizeof(Int) &lt;= sizeof(OffsetType);</span>
<span class="line-modified">341     };</span>

342 
343 protected:
<span class="line-modified">344     Value* cloneImpl() const;</span>
<span class="line-added">345 </span>
<span class="line-added">346     void replaceWith(Kind, Type, BasicBlock*);</span>
<span class="line-added">347     void replaceWith(Kind, Type, BasicBlock*, Value*);</span>
348 
349     virtual void dumpChildren(CommaPrinter&amp;, PrintStream&amp;) const;
350     virtual void dumpMeta(CommaPrinter&amp;, PrintStream&amp;) const;
351 
<span class="line-added">352     // The specific value of VarArgs does not matter, but the value of the others is assumed to match their meaning.</span>
<span class="line-added">353     enum NumChildren : uint8_t { Zero = 0, One = 1, Two = 2, Three = 3, VarArgs = 4};</span>
<span class="line-added">354 </span>
<span class="line-added">355     char* childrenAlloc() { return bitwise_cast&lt;char*&gt;(this) + adjacencyListOffset(); }</span>
<span class="line-added">356     const char* childrenAlloc() const { return bitwise_cast&lt;const char*&gt;(this) + adjacencyListOffset(); }</span>
<span class="line-added">357     Vector&lt;Value*, 3&gt;&amp; childrenVector()</span>
<span class="line-added">358     {</span>
<span class="line-added">359         ASSERT(m_numChildren == VarArgs);</span>
<span class="line-added">360         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt;*&gt;(childrenAlloc());</span>
<span class="line-added">361     }</span>
<span class="line-added">362     const Vector&lt;Value*, 3&gt;&amp; childrenVector() const</span>
<span class="line-added">363     {</span>
<span class="line-added">364         ASSERT(m_numChildren == VarArgs);</span>
<span class="line-added">365         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt; const*&gt;(childrenAlloc());</span>
<span class="line-added">366     }</span>
<span class="line-added">367     Value** childrenArray()</span>
<span class="line-added">368     {</span>
<span class="line-added">369         ASSERT(m_numChildren != VarArgs);</span>
<span class="line-added">370         return bitwise_cast&lt;Value**&gt;(childrenAlloc());</span>
<span class="line-added">371     }</span>
<span class="line-added">372     Value* const* childrenArray() const</span>
<span class="line-added">373     {</span>
<span class="line-added">374         ASSERT(m_numChildren != VarArgs);</span>
<span class="line-added">375         return bitwise_cast&lt;Value* const*&gt;(childrenAlloc());</span>
<span class="line-added">376     }</span>
<span class="line-added">377 </span>
<span class="line-added">378     template&lt;typename... Arguments&gt;</span>
<span class="line-added">379     static Opcode opcodeFromConstructor(Kind kind, Arguments...) { return kind.opcode(); }</span>
<span class="line-added">380     ALWAYS_INLINE static size_t adjacencyListSpace(Kind kind)</span>
<span class="line-added">381     {</span>
<span class="line-added">382         switch (kind.opcode()) {</span>
<span class="line-added">383         case FramePointer:</span>
<span class="line-added">384         case Nop:</span>
<span class="line-added">385         case Phi:</span>
<span class="line-added">386         case Jump:</span>
<span class="line-added">387         case Oops:</span>
<span class="line-added">388         case EntrySwitch:</span>
<span class="line-added">389         case ArgumentReg:</span>
<span class="line-added">390         case Const32:</span>
<span class="line-added">391         case Const64:</span>
<span class="line-added">392         case ConstFloat:</span>
<span class="line-added">393         case ConstDouble:</span>
<span class="line-added">394         case Fence:</span>
<span class="line-added">395         case SlotBase:</span>
<span class="line-added">396         case Get:</span>
<span class="line-added">397             return 0;</span>
<span class="line-added">398         case Return:</span>
<span class="line-added">399         case Identity:</span>
<span class="line-added">400         case Opaque:</span>
<span class="line-added">401         case Neg:</span>
<span class="line-added">402         case Clz:</span>
<span class="line-added">403         case Abs:</span>
<span class="line-added">404         case Ceil:</span>
<span class="line-added">405         case Floor:</span>
<span class="line-added">406         case Sqrt:</span>
<span class="line-added">407         case SExt8:</span>
<span class="line-added">408         case SExt16:</span>
<span class="line-added">409         case Trunc:</span>
<span class="line-added">410         case SExt32:</span>
<span class="line-added">411         case ZExt32:</span>
<span class="line-added">412         case FloatToDouble:</span>
<span class="line-added">413         case IToD:</span>
<span class="line-added">414         case DoubleToFloat:</span>
<span class="line-added">415         case IToF:</span>
<span class="line-added">416         case BitwiseCast:</span>
<span class="line-added">417         case Branch:</span>
<span class="line-added">418         case Depend:</span>
<span class="line-added">419         case Load8Z:</span>
<span class="line-added">420         case Load8S:</span>
<span class="line-added">421         case Load16Z:</span>
<span class="line-added">422         case Load16S:</span>
<span class="line-added">423         case Load:</span>
<span class="line-added">424         case Switch:</span>
<span class="line-added">425         case Upsilon:</span>
<span class="line-added">426         case Extract:</span>
<span class="line-added">427         case Set:</span>
<span class="line-added">428         case WasmAddress:</span>
<span class="line-added">429         case WasmBoundsCheck:</span>
<span class="line-added">430             return sizeof(Value*);</span>
<span class="line-added">431         case Add:</span>
<span class="line-added">432         case Sub:</span>
<span class="line-added">433         case Mul:</span>
<span class="line-added">434         case Div:</span>
<span class="line-added">435         case UDiv:</span>
<span class="line-added">436         case Mod:</span>
<span class="line-added">437         case UMod:</span>
<span class="line-added">438         case BitAnd:</span>
<span class="line-added">439         case BitOr:</span>
<span class="line-added">440         case BitXor:</span>
<span class="line-added">441         case Shl:</span>
<span class="line-added">442         case SShr:</span>
<span class="line-added">443         case ZShr:</span>
<span class="line-added">444         case RotR:</span>
<span class="line-added">445         case RotL:</span>
<span class="line-added">446         case Equal:</span>
<span class="line-added">447         case NotEqual:</span>
<span class="line-added">448         case LessThan:</span>
<span class="line-added">449         case GreaterThan:</span>
<span class="line-added">450         case LessEqual:</span>
<span class="line-added">451         case GreaterEqual:</span>
<span class="line-added">452         case Above:</span>
<span class="line-added">453         case Below:</span>
<span class="line-added">454         case AboveEqual:</span>
<span class="line-added">455         case BelowEqual:</span>
<span class="line-added">456         case EqualOrUnordered:</span>
<span class="line-added">457         case AtomicXchgAdd:</span>
<span class="line-added">458         case AtomicXchgAnd:</span>
<span class="line-added">459         case AtomicXchgOr:</span>
<span class="line-added">460         case AtomicXchgSub:</span>
<span class="line-added">461         case AtomicXchgXor:</span>
<span class="line-added">462         case AtomicXchg:</span>
<span class="line-added">463         case Store8:</span>
<span class="line-added">464         case Store16:</span>
<span class="line-added">465         case Store:</span>
<span class="line-added">466             return 2 * sizeof(Value*);</span>
<span class="line-added">467         case Select:</span>
<span class="line-added">468         case AtomicWeakCAS:</span>
<span class="line-added">469         case AtomicStrongCAS:</span>
<span class="line-added">470             return 3 * sizeof(Value*);</span>
<span class="line-added">471         case CCall:</span>
<span class="line-added">472         case Check:</span>
<span class="line-added">473         case CheckAdd:</span>
<span class="line-added">474         case CheckSub:</span>
<span class="line-added">475         case CheckMul:</span>
<span class="line-added">476         case Patchpoint:</span>
<span class="line-added">477             return sizeof(Vector&lt;Value*, 3&gt;);</span>
<span class="line-added">478 #ifdef NDEBUG</span>
<span class="line-added">479         default:</span>
<span class="line-added">480             break;</span>
<span class="line-added">481 #endif</span>
<span class="line-added">482         }</span>
<span class="line-added">483         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">484         return 0;</span>
<span class="line-added">485     }</span>
<span class="line-added">486 </span>
487 private:
<span class="line-added">488     static char* allocateSpace(Opcode opcode, size_t size)</span>
<span class="line-added">489     {</span>
<span class="line-added">490         size_t adjacencyListSpace = Value::adjacencyListSpace(opcode);</span>
<span class="line-added">491         // We must allocate enough space that replaceWithIdentity can work without buffer overflow.</span>
<span class="line-added">492         size_t allocIdentitySize = sizeof(Value) + sizeof(Value*);</span>
<span class="line-added">493         size_t allocSize = std::max(size + adjacencyListSpace, allocIdentitySize);</span>
<span class="line-added">494         return static_cast&lt;char*&gt;(WTF::fastMalloc(allocSize));</span>
<span class="line-added">495     }</span>
<span class="line-added">496 </span>
<span class="line-added">497 protected:</span>
<span class="line-added">498     template&lt;typename ValueType, typename... Arguments&gt;</span>
<span class="line-added">499     static ValueType* allocate(Arguments... arguments)</span>
<span class="line-added">500     {</span>
<span class="line-added">501         char* alloc = allocateSpace(ValueType::opcodeFromConstructor(arguments...), sizeof(ValueType));</span>
<span class="line-added">502         return new (alloc) ValueType(arguments...);</span>
<span class="line-added">503     }</span>
<span class="line-added">504     template&lt;typename ValueType&gt;</span>
<span class="line-added">505     static ValueType* allocate(const ValueType&amp; valueToClone)</span>
<span class="line-added">506     {</span>
<span class="line-added">507         char* alloc = allocateSpace(valueToClone.opcode(), sizeof(ValueType));</span>
<span class="line-added">508         ValueType* result = new (alloc) ValueType(valueToClone);</span>
<span class="line-added">509         result-&gt;buildAdjacencyList(sizeof(ValueType), valueToClone);</span>
<span class="line-added">510         return result;</span>
<span class="line-added">511     }</span>
<span class="line-added">512 </span>
<span class="line-added">513     // Protected so it will only be called from allocate above, possibly through the subclasses&#39;copy constructors</span>
<span class="line-added">514     Value(const Value&amp;) = default;</span>
<span class="line-added">515 </span>
<span class="line-added">516     Value(Value&amp;&amp;) = delete;</span>
<span class="line-added">517     Value&amp; operator=(const Value&amp;) = delete;</span>
<span class="line-added">518     Value&amp; operator=(Value&amp;&amp;) = delete;</span>
<span class="line-added">519 </span>
<span class="line-added">520     size_t adjacencyListOffset() const;</span>
<span class="line-added">521 </span>
522     friend class Procedure;
523     friend class SparseCollection&lt;Value&gt;;
524 
<span class="line-added">525 private:</span>
<span class="line-added">526     template&lt;typename... Arguments&gt;</span>
<span class="line-added">527     void buildAdjacencyList(NumChildren numChildren, Arguments... arguments)</span>
<span class="line-added">528     {</span>
<span class="line-added">529         if (numChildren == VarArgs) {</span>
<span class="line-added">530             new (childrenAlloc()) Vector&lt;Value*, 3&gt; { arguments... };</span>
<span class="line-added">531             return;</span>
<span class="line-added">532         }</span>
<span class="line-added">533         ASSERT(numChildren == sizeof...(arguments));</span>
<span class="line-added">534         new (childrenAlloc()) Value*[sizeof...(arguments)] { arguments... };</span>
<span class="line-added">535     }</span>
<span class="line-added">536     void buildAdjacencyList(size_t offset, const Value&amp; valueToClone)</span>
<span class="line-added">537     {</span>
<span class="line-added">538         switch (valueToClone.m_numChildren) {</span>
<span class="line-added">539         case VarArgs:</span>
<span class="line-added">540             new (bitwise_cast&lt;char*&gt;(this) + offset) Vector&lt;Value*, 3&gt; (valueToClone.childrenVector());</span>
<span class="line-added">541             break;</span>
<span class="line-added">542         case Three:</span>
<span class="line-added">543             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[2] = valueToClone.childrenArray()[2];</span>
<span class="line-added">544             FALLTHROUGH;</span>
<span class="line-added">545         case Two:</span>
<span class="line-added">546             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[1] = valueToClone.childrenArray()[1];</span>
<span class="line-added">547             FALLTHROUGH;</span>
<span class="line-added">548         case One:</span>
<span class="line-added">549             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[0] = valueToClone.childrenArray()[0];</span>
<span class="line-added">550             break;</span>
<span class="line-added">551         case Zero:</span>
<span class="line-added">552             break;</span>
<span class="line-added">553         }</span>
<span class="line-added">554     }</span>
<span class="line-added">555 </span>
556     // Checks that this kind is valid for use with B3::Value.
<span class="line-modified">557     ALWAYS_INLINE static NumChildren numChildrenForKind(Kind kind, unsigned numArgs)</span>
558     {
559         switch (kind.opcode()) {
560         case FramePointer:
561         case Nop:
562         case Phi:
563         case Jump:
564         case Oops:
565         case EntrySwitch:
566             if (UNLIKELY(numArgs))
567                 badKind(kind, numArgs);
<span class="line-modified">568             return Zero;</span>
569         case Return:
570             if (UNLIKELY(numArgs &gt; 1))
571                 badKind(kind, numArgs);
<span class="line-modified">572             return numArgs ? One : Zero;</span>
573         case Identity:
574         case Opaque:
575         case Neg:
576         case Clz:
577         case Abs:
578         case Ceil:
579         case Floor:
580         case Sqrt:
581         case SExt8:
582         case SExt16:
583         case Trunc:
584         case SExt32:
585         case ZExt32:
586         case FloatToDouble:
587         case IToD:
588         case DoubleToFloat:
589         case IToF:
590         case BitwiseCast:
591         case Branch:
592         case Depend:
593             if (UNLIKELY(numArgs != 1))
594                 badKind(kind, numArgs);
<span class="line-modified">595             return One;</span>
596         case Add:
597         case Sub:
598         case Mul:
599         case Div:
600         case UDiv:
601         case Mod:
602         case UMod:
603         case BitAnd:
604         case BitOr:
605         case BitXor:
606         case Shl:
607         case SShr:
608         case ZShr:
609         case RotR:
610         case RotL:
611         case Equal:
612         case NotEqual:
613         case LessThan:
614         case GreaterThan:
615         case LessEqual:
616         case GreaterEqual:
617         case Above:
618         case Below:
619         case AboveEqual:
620         case BelowEqual:
621         case EqualOrUnordered:
622             if (UNLIKELY(numArgs != 2))
623                 badKind(kind, numArgs);
<span class="line-modified">624             return Two;</span>
625         case Select:
626             if (UNLIKELY(numArgs != 3))
627                 badKind(kind, numArgs);
<span class="line-modified">628             return Three;</span>
629         default:
630             badKind(kind, numArgs);
631             break;
632         }
<span class="line-added">633         return VarArgs;</span>
634     }
635 
636 protected:
637     enum CheckedOpcodeTag { CheckedOpcode };
638 



639     // Instantiate values via Procedure.
640     // This form requires specifying the type explicitly:
641     template&lt;typename... Arguments&gt;
<span class="line-modified">642     explicit Value(CheckedOpcodeTag, Kind kind, Type type, NumChildren numChildren, Origin origin, Value* firstChild, Arguments... arguments)</span>
643         : m_kind(kind)
644         , m_type(type)
<span class="line-added">645         , m_numChildren(numChildren)</span>
646         , m_origin(origin)

647     {
<span class="line-added">648         buildAdjacencyList(numChildren, firstChild, arguments...);</span>
649     }
650     // This form is for specifying the type explicitly when the opcode has no children:
<span class="line-modified">651     explicit Value(CheckedOpcodeTag, Kind kind, Type type, NumChildren numChildren, Origin origin)</span>
652         : m_kind(kind)
653         , m_type(type)
<span class="line-added">654         , m_numChildren(numChildren)</span>
655         , m_origin(origin)
656     {
<span class="line-modified">657         buildAdjacencyList(numChildren);</span>

















658     }
659     // This form is for those opcodes that can infer their type from the opcode alone, and that don&#39;t
660     // take any arguments:
<span class="line-modified">661     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin)</span>
662         : m_kind(kind)
663         , m_type(typeFor(kind, nullptr))
<span class="line-added">664         , m_numChildren(numChildren)</span>
665         , m_origin(origin)
666     {
<span class="line-added">667         buildAdjacencyList(numChildren);</span>
668     }
<span class="line-modified">669     // This form is for those opcodes that can infer their type from the opcode and first child:</span>
<span class="line-modified">670     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin, Value* firstChild)</span>
671         : m_kind(kind)
<span class="line-modified">672         , m_type(typeFor(kind, firstChild))</span>
<span class="line-added">673         , m_numChildren(numChildren)</span>
674         , m_origin(origin)

675     {
<span class="line-added">676         buildAdjacencyList(numChildren, firstChild);</span>
677     }
<span class="line-modified">678     // This form is for those opcodes that can infer their type from the opcode and first and second child:</span>
<span class="line-added">679     template&lt;typename... Arguments&gt;</span>
<span class="line-added">680     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin, Value* firstChild, Value* secondChild, Arguments... arguments)</span>
681         : m_kind(kind)
<span class="line-modified">682         , m_type(typeFor(kind, firstChild, secondChild))</span>
<span class="line-added">683         , m_numChildren(numChildren)</span>
684         , m_origin(origin)

685     {
<span class="line-added">686         buildAdjacencyList(numChildren, firstChild, secondChild, arguments...);</span>
687     }
688 
689     // This is the constructor you end up actually calling, if you&#39;re instantiating Value
690     // directly.
<span class="line-modified">691     explicit Value(Kind kind, Type type, Origin origin)</span>
<span class="line-modified">692         : Value(CheckedOpcode, kind, type, Zero, origin)</span>













693     {
<span class="line-modified">694         RELEASE_ASSERT(numChildrenForKind(kind, 0) == Zero);</span>
695     }
<span class="line-added">696     // We explicitly convert the extra arguments to Value* (they may be pointers to some subclasses of Value) to limit template explosion</span>
697     template&lt;typename... Arguments&gt;
<span class="line-modified">698     explicit Value(Kind kind, Origin origin, Arguments... arguments)</span>
<span class="line-modified">699         : Value(CheckedOpcode, kind, numChildrenForKind(kind, sizeof...(arguments)), origin, static_cast&lt;Value*&gt;(arguments)...)</span>
700     {

701     }
702     template&lt;typename... Arguments&gt;
<span class="line-modified">703     explicit Value(Kind kind, Type type, Origin origin, Value* firstChild, Arguments... arguments)</span>
<span class="line-modified">704         : Value(CheckedOpcode, kind, type, numChildrenForKind(kind, 1 + sizeof...(arguments)), origin, firstChild, static_cast&lt;Value*&gt;(arguments)...)</span>
705     {

706     }
707 
708 private:
709     friend class CheckValue; // CheckValue::convertToAdd() modifies m_kind.
710 
711     static Type typeFor(Kind, Value* firstChild, Value* secondChild = nullptr);
712 
<span class="line-modified">713     // m_index to m_numChildren are arranged to fit in 64 bits.</span>
714 protected:
715     unsigned m_index { UINT_MAX };
716 private:
717     Kind m_kind;
718     Type m_type;
<span class="line-modified">719 protected:</span>
<span class="line-added">720     NumChildren m_numChildren;</span>
<span class="line-added">721 private:</span>
722     Origin m_origin;

723 
724     NO_RETURN_DUE_TO_CRASH static void badKind(Kind, unsigned);
725 
726 public:
727     BasicBlock* owner { nullptr }; // computed by Procedure::resetValueOwners().
728 };
729 
730 class DeepValueDump {
731 public:
732     DeepValueDump(const Procedure* proc, const Value* value)
733         : m_proc(proc)
734         , m_value(value)
735     {
736     }
737 
<span class="line-modified">738     void dump(PrintStream&amp; out) const;</span>






739 
740 private:
741     const Procedure* m_proc;
742     const Value* m_value;
743 };
744 
745 inline DeepValueDump deepDump(const Procedure&amp; proc, const Value* value)
746 {
747     return DeepValueDump(&amp;proc, value);
748 }
749 inline DeepValueDump deepDump(const Value* value)
750 {
751     return DeepValueDump(nullptr, value);
752 }
753 
<span class="line-added">754 // The following macros are designed for subclasses of B3::Value to use.</span>
<span class="line-added">755 // They are never required for correctness, but can improve the performance of child/lastChild/numChildren/children methods,</span>
<span class="line-added">756 // for users that already know the specific subclass of Value they are manipulating.</span>
<span class="line-added">757 // The first set is to be used when you know something about the number of children of all values of a class, including its subclasses:</span>
<span class="line-added">758 // - B3_SPECIALIZE_VALUE_FOR_NO_CHILDREN: always 0 children (e.g. Const32Value)</span>
<span class="line-added">759 // - B3_SPECIALIZE_VALUE_FOR_FIXED_CHILDREN(n): always n children, with n in {1, 2, 3} (e.g. UpsilonValue, with n = 1)</span>
<span class="line-added">760 // - B3_SPECIALIZE_VALUE_FOR_NON_VARARGS_CHILDREN: different numbers of children, but never a variable number at runtime (e.g. MemoryValue, that can have between 1 and 3 children)</span>
<span class="line-added">761 // - B3_SPECIALIZE_VALUE_FOR_VARARGS_CHILDREN: always a varargs (e.g. CCallValue)</span>
<span class="line-added">762 // The second set is only to be used by classes that we know are not further subclassed by anyone adding fields,</span>
<span class="line-added">763 // as they hardcode the offset of the children array/vector (which is equal to the size of the object).</span>
<span class="line-added">764 // - B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_FIXED_CHILDREN</span>
<span class="line-added">765 // - B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_VARARGS_CHILDREN</span>
<span class="line-added">766 #define B3_SPECIALIZE_VALUE_FOR_NO_CHILDREN \</span>
<span class="line-added">767     unsigned numChildren() const { return 0; } \</span>
<span class="line-added">768     WTF::IteratorRange&lt;Value**&gt; children() { return {nullptr, nullptr}; } \</span>
<span class="line-added">769     WTF::IteratorRange&lt;Value* const*&gt; children() const { return { nullptr, nullptr}; }</span>
<span class="line-added">770 </span>
<span class="line-added">771 #define B3_SPECIALIZE_VALUE_FOR_FIXED_CHILDREN(n) \</span>
<span class="line-added">772 public: \</span>
<span class="line-added">773     unsigned numChildren() const { return n; } \</span>
<span class="line-added">774     Value*&amp; child(unsigned index) \</span>
<span class="line-added">775     { \</span>
<span class="line-added">776         ASSERT(index &lt;= n); \</span>
<span class="line-added">777         return childrenArray()[index]; \</span>
<span class="line-added">778     } \</span>
<span class="line-added">779     Value* child(unsigned index) const \</span>
<span class="line-added">780     { \</span>
<span class="line-added">781         ASSERT(index &lt;= n); \</span>
<span class="line-added">782         return childrenArray()[index]; \</span>
<span class="line-added">783     } \</span>
<span class="line-added">784     Value*&amp; lastChild() \</span>
<span class="line-added">785     { \</span>
<span class="line-added">786         return childrenArray()[n - 1]; \</span>
<span class="line-added">787     } \</span>
<span class="line-added">788     Value* lastChild() const \</span>
<span class="line-added">789     { \</span>
<span class="line-added">790         return childrenArray()[n - 1]; \</span>
<span class="line-added">791     } \</span>
<span class="line-added">792     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="line-added">793     { \</span>
<span class="line-added">794         Value** buffer = childrenArray(); \</span>
<span class="line-added">795         return {buffer, buffer + n }; \</span>
<span class="line-added">796     } \</span>
<span class="line-added">797     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="line-added">798     { \</span>
<span class="line-added">799         Value* const* buffer = childrenArray(); \</span>
<span class="line-added">800         return {buffer, buffer + n }; \</span>
<span class="line-added">801     } \</span>
<span class="line-added">802 </span>
<span class="line-added">803 #define B3_SPECIALIZE_VALUE_FOR_NON_VARARGS_CHILDREN \</span>
<span class="line-added">804 public: \</span>
<span class="line-added">805     unsigned numChildren() const { return m_numChildren; } \</span>
<span class="line-added">806     Value*&amp; child(unsigned index) { return childrenArray()[index]; } \</span>
<span class="line-added">807     Value* child(unsigned index) const { return childrenArray()[index]; } \</span>
<span class="line-added">808     Value*&amp; lastChild() { return childrenArray()[numChildren() - 1]; } \</span>
<span class="line-added">809     Value* lastChild() const { return childrenArray()[numChildren() - 1]; } \</span>
<span class="line-added">810     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="line-added">811     { \</span>
<span class="line-added">812         Value** buffer = childrenArray(); \</span>
<span class="line-added">813         return {buffer, buffer + numChildren() }; \</span>
<span class="line-added">814     } \</span>
<span class="line-added">815     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="line-added">816     { \</span>
<span class="line-added">817         Value* const* buffer = childrenArray(); \</span>
<span class="line-added">818         return {buffer, buffer + numChildren() }; \</span>
<span class="line-added">819     } \</span>
<span class="line-added">820 </span>
<span class="line-added">821 #define B3_SPECIALIZE_VALUE_FOR_VARARGS_CHILDREN \</span>
<span class="line-added">822 public: \</span>
<span class="line-added">823     unsigned numChildren() const { return childrenVector().size(); } \</span>
<span class="line-added">824     Value*&amp; child(unsigned index) { return childrenVector()[index]; } \</span>
<span class="line-added">825     Value* child(unsigned index) const { return childrenVector()[index]; } \</span>
<span class="line-added">826     Value*&amp; lastChild() { return childrenVector().last(); } \</span>
<span class="line-added">827     Value* lastChild() const { return childrenVector().last(); } \</span>
<span class="line-added">828     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="line-added">829     { \</span>
<span class="line-added">830         Vector&lt;Value*, 3&gt;&amp; vec = childrenVector(); \</span>
<span class="line-added">831         return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end()); \</span>
<span class="line-added">832     } \</span>
<span class="line-added">833     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="line-added">834     { \</span>
<span class="line-added">835         const Vector&lt;Value*, 3&gt;&amp; vec = childrenVector(); \</span>
<span class="line-added">836         return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end()); \</span>
<span class="line-added">837     } \</span>
<span class="line-added">838 </span>
<span class="line-added">839 // Only use this for classes with no subclass that add new fields (as it uses sizeof(*this))</span>
<span class="line-added">840 // Also there is no point in applying this to classes with no children, as they don&#39;t have a children array to access.</span>
<span class="line-added">841 #define B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_FIXED_CHILDREN \</span>
<span class="line-added">842 private: \</span>
<span class="line-added">843     Value** childrenArray() \</span>
<span class="line-added">844     { \</span>
<span class="line-added">845         return bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">846     } \</span>
<span class="line-added">847     Value* const* childrenArray() const \</span>
<span class="line-added">848     { \</span>
<span class="line-added">849         return bitwise_cast&lt;Value* const*&gt;(bitwise_cast&lt;char const*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">850     }</span>
<span class="line-added">851 </span>
<span class="line-added">852 // Only use this for classes with no subclass that add new fields (as it uses sizeof(*this))</span>
<span class="line-added">853 #define B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_VARARGS_CHILDREN \</span>
<span class="line-added">854 private: \</span>
<span class="line-added">855     Vector&lt;Value*, 3&gt;&amp; childrenVector() \</span>
<span class="line-added">856     { \</span>
<span class="line-added">857         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">858     } \</span>
<span class="line-added">859     const Vector&lt;Value*, 3&gt;&amp; childrenVector() const \</span>
<span class="line-added">860     { \</span>
<span class="line-added">861         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt; const*&gt;(bitwise_cast&lt;char const*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">862     } \</span>
<span class="line-added">863 </span>
864 } } // namespace JSC::B3
865 
866 #endif // ENABLE(B3_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="B3Value.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3ValueInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>