<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxyConstructor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2017 Apple Inc. All Rights Reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All Rights Reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,19 ***</span>
      if (!target.isObject()) {
          throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);
          return;
      }
      if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
<span class="line-modified">!         if (targetAsProxy-&gt;handler().isNull()) {</span>
<span class="line-modified">!             throwTypeError(exec, scope, &quot;If a Proxy&#39;s handler is another Proxy object, the other Proxy should not have been revoked&quot;_s);</span>
              return;
          }
      }
      if (!handler.isObject()) {
          throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);
          return;
      }
  
      JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
  
      CallData ignoredCallData;
      m_isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
<span class="line-new-header">--- 89,25 ---</span>
      if (!target.isObject()) {
          throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);
          return;
      }
      if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
<span class="line-modified">!         if (targetAsProxy-&gt;isRevoked()) {</span>
<span class="line-modified">!             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
              return;
          }
      }
      if (!handler.isObject()) {
          throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);
          return;
      }
<span class="line-added">+     if (ProxyObject* handlerAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, handler)) {</span>
<span class="line-added">+         if (handlerAsProxy-&gt;isRevoked()) {</span>
<span class="line-added">+             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
  
      CallData ignoredCallData;
      m_isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,11 ***</span>
  
          return jsUndefined();
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return performDefaultGet();</span>
  
      JSValue handlerValue = proxyObject-&gt;handler();
      if (handlerValue.isNull())
          return throwTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
  
<span class="line-new-header">--- 147,11 ---</span>
  
          return jsUndefined();
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return jsUndefined();</span>
  
      JSValue handlerValue = proxyObject-&gt;handler();
      if (handlerValue.isNull())
          return throwTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,18 ***</span>
      if (getHandler.isUndefined())
          return performDefaultGet();
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
      arguments.append(receiver);
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, getHandler, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor)) {</span>
          if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
              if (!sameValue(exec, descriptor.value(), trapResult))
                  return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);
          } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
              if (!trapResult.isUndefined())
<span class="line-new-header">--- 164,20 ---</span>
      if (getHandler.isUndefined())
          return performDefaultGet();
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
      arguments.append(receiver);
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, getHandler, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
<span class="line-added">+     EXCEPTION_ASSERT(!scope.exception() || !result);</span>
<span class="line-added">+     if (result) {</span>
          if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
              if (!sameValue(exec, descriptor.value(), trapResult))
                  return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);
          } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
              if (!trapResult.isUndefined())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,11 ***</span>
      auto performDefaultGetOwnProperty = [&amp;] {
          return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
<span class="line-new-header">--- 218,11 ---</span>
      auto performDefaultGetOwnProperty = [&amp;] {
          return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return false;</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,11 ***</span>
      if (getOwnPropertyDescriptorMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
<span class="line-new-header">--- 236,11 ---</span>
      if (getOwnPropertyDescriptorMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,10 ***</span>
<span class="line-new-header">--- 291,14 ---</span>
      if (!trapResultAsDescriptor.configurable()) {
          if (!isTargetPropertyDescriptorDefined || targetPropertyDescriptor.configurable()) {
              throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable when the &#39;target&#39; doesn&#39;t have it as an own property or if it is a configurable own property on &#39;target&#39;&quot;_s);
              return false;
          }
<span class="line-added">+         if (trapResultAsDescriptor.writablePresent() &amp;&amp; !trapResultAsDescriptor.writable() &amp;&amp; targetPropertyDescriptor.writable()) {</span>
<span class="line-added">+             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable and non-writable when the target&#39;s property is writable&quot;_s);</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
      }
  
      if (trapResultAsDescriptor.isAccessorDescriptor()) {
          GetterSetter* getterSetter = trapResultAsDescriptor.slowGetterSetter(exec);
          RETURN_IF_EXCEPTION(scope, false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,11 ***</span>
      auto performDefaultHasProperty = [&amp;] {
          return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performDefaultHasProperty());</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
<span class="line-new-header">--- 327,11 ---</span>
      auto performDefaultHasProperty = [&amp;] {
          return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return false;</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,11 ***</span>
      if (hasMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultHasProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, hasMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
      bool trapResultAsBool = trapResult.toBoolean(exec);
<span class="line-new-header">--- 345,11 ---</span>
      if (hasMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultHasProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, hasMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
      bool trapResultAsBool = trapResult.toBoolean(exec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,17 ***</span>
      return thisObject-&gt;getOwnPropertySlotCommon(exec, propertyName, slot);
  }
  
  bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     Identifier ident = Identifier::from(exec, propertyName);</span>
      return thisObject-&gt;getOwnPropertySlotCommon(exec, ident.impl(), slot);
  }
  
  template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified">! bool ProxyObject::performPut(ExecState* exec, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut)</span>
  {
      NO_TAIL_CALLS();
  
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-new-header">--- 411,18 ---</span>
      return thisObject-&gt;getOwnPropertySlotCommon(exec, propertyName, slot);
  }
  
  bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)
  {
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     Identifier ident = Identifier::from(vm, propertyName);</span>
      return thisObject-&gt;getOwnPropertySlotCommon(exec, ident.impl(), slot);
  }
  
  template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified">! bool ProxyObject::performPut(ExecState* exec, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut, bool shouldThrow)</span>
  {
      NO_TAIL_CALLS();
  
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 417,11 ***</span>
          throwStackOverflowError(exec, scope);
          return false;
      }
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performDefaultPut());</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
<span class="line-new-header">--- 430,11 ---</span>
          throwStackOverflowError(exec, scope);
          return false;
      }
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return false;</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,20 ***</span>
      if (setMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultPut());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
      arguments.append(putValue);
      arguments.append(thisValue);
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, setMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
      bool trapResultAsBool = trapResult.toBoolean(exec);
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     if (!trapResultAsBool)</span>
          return false;
  
      PropertyDescriptor descriptor;
      bool hasProperty = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-new-header">--- 449,23 ---</span>
      if (setMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultPut());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
      arguments.append(putValue);
      arguments.append(thisValue);
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, setMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
      bool trapResultAsBool = trapResult.toBoolean(exec);
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     if (!trapResultAsBool) {</span>
<span class="line-added">+         if (shouldThrow)</span>
<span class="line-added">+             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;set&#39; trap returned falsy value for property &#39;&quot;, String(propertyName.uid()), &quot;&#39;&quot;));</span>
          return false;
<span class="line-added">+     }</span>
  
      PropertyDescriptor descriptor;
      bool hasProperty = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,26 ***</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
          return target-&gt;methodTable(vm)-&gt;put(target, exec, propertyName, value, slot);
      };
<span class="line-modified">!     return thisObject-&gt;performPut(exec, value, slot.thisValue(), propertyName, performDefaultPut);</span>
  }
  
  bool ProxyObject::putByIndexCommon(ExecState* exec, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Identifier ident = Identifier::from(exec, propertyName);</span>
      RETURN_IF_EXCEPTION(scope, false);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = this-&gt;target();
          bool isStrictMode = shouldThrow;
          PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
          return target-&gt;methodTable(vm)-&gt;put(target, exec, ident.impl(), putValue, slot);
      };
<span class="line-modified">!     RELEASE_AND_RETURN(scope, performPut(exec, putValue, thisValue, ident.impl(), performDefaultPut));</span>
  }
  
  bool ProxyObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-new-header">--- 490,26 ---</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
          return target-&gt;methodTable(vm)-&gt;put(target, exec, propertyName, value, slot);
      };
<span class="line-modified">!     return thisObject-&gt;performPut(exec, value, slot.thisValue(), propertyName, performDefaultPut, slot.isStrictMode());</span>
  }
  
  bool ProxyObject::putByIndexCommon(ExecState* exec, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Identifier ident = Identifier::from(vm, propertyName);</span>
      RETURN_IF_EXCEPTION(scope, false);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = this-&gt;target();
          bool isStrictMode = shouldThrow;
          PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
          return target-&gt;methodTable(vm)-&gt;put(target, exec, ident.impl(), putValue, slot);
      };
<span class="line-modified">!     RELEASE_AND_RETURN(scope, performPut(exec, putValue, thisValue, ident.impl(), performDefaultPut, shouldThrow));</span>
  }
  
  bool ProxyObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 567,11 ***</span>
          return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue constructMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be constructible&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSObject* target = proxy-&gt;target();
      if (constructMethod.isUndefined()) {
          ConstructData constructData;
          ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
<span class="line-new-header">--- 583,11 ---</span>
          return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue constructMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSObject* target = proxy-&gt;target();
      if (constructMethod.isUndefined()) {
          ConstructData constructData;
          ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 617,11 ***</span>
          throwStackOverflowError(exec, scope);
          return false;
      }
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performDefaultDelete());</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
<span class="line-new-header">--- 633,11 ---</span>
          throwStackOverflowError(exec, scope);
          return false;
      }
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return false;</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 636,11 ***</span>
      if (deletePropertyMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultDelete());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, deletePropertyMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
      bool trapResultAsBool = trapResult.toBoolean(exec);
<span class="line-new-header">--- 652,11 ---</span>
      if (deletePropertyMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultDelete());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, deletePropertyMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
      bool trapResultAsBool = trapResult.toBoolean(exec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 648,15 ***</span>
  
      if (!trapResultAsBool)
          return false;
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor)) {</span>
          if (!descriptor.configurable()) {
              throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);
              return false;
          }
      }
  
      RETURN_IF_EXCEPTION(scope, false);
  
      return true;
<span class="line-new-header">--- 664,23 ---</span>
  
      if (!trapResultAsBool)
          return false;
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
<span class="line-added">+     EXCEPTION_ASSERT(!scope.exception() || !result);</span>
<span class="line-added">+     if (result) {</span>
          if (!descriptor.configurable()) {
              throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);
              return false;
          }
<span class="line-added">+         bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         if (!targetIsExtensible) {</span>
<span class="line-added">+             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target has property and is not extensible&quot;_s);</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
      }
  
      RETURN_IF_EXCEPTION(scope, false);
  
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,15 ***</span>
      return thisObject-&gt;performDelete(exec, propertyName, performDefaultDelete);
  }
  
  bool ProxyObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified">!     Identifier ident = Identifier::from(exec, propertyName);</span>
      auto performDefaultDelete = [&amp;] () -&gt; bool {
          JSObject* target = thisObject-&gt;target();
<span class="line-modified">!         return target-&gt;methodTable(exec-&gt;vm())-&gt;deletePropertyByIndex(target, exec, propertyName);</span>
      };
      return thisObject-&gt;performDelete(exec, ident.impl(), performDefaultDelete);
  }
  
  bool ProxyObject::performPreventExtensions(ExecState* exec)
<span class="line-new-header">--- 696,16 ---</span>
      return thisObject-&gt;performDelete(exec, propertyName, performDefaultDelete);
  }
  
  bool ProxyObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)
  {
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified">!     Identifier ident = Identifier::from(vm, propertyName);</span>
      auto performDefaultDelete = [&amp;] () -&gt; bool {
          JSObject* target = thisObject-&gt;target();
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;deletePropertyByIndex(target, exec, propertyName);</span>
      };
      return thisObject-&gt;performDelete(exec, ident.impl(), performDefaultDelete);
  }
  
  bool ProxyObject::performPreventExtensions(ExecState* exec)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 808,11 ***</span>
      auto performDefaultDefineOwnProperty = [&amp;] {
          RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, exec, propertyName, descriptor, shouldThrow));
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return performDefaultDefineOwnProperty();</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
<span class="line-new-header">--- 833,11 ---</span>
      auto performDefaultDefineOwnProperty = [&amp;] {
          RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, exec, propertyName, descriptor, shouldThrow));
      };
  
      if (propertyName.isPrivateName())
<span class="line-modified">!         return false;</span>
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
          throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 830,11 ***</span>
      JSObject* descriptorObject = constructObjectFromPropertyDescriptor(exec, descriptor);
      RETURN_IF_EXCEPTION(scope, false);
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
      arguments.append(descriptorObject);
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, definePropertyMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-new-header">--- 855,11 ---</span>
      JSObject* descriptorObject = constructObjectFromPropertyDescriptor(exec, descriptor);
      RETURN_IF_EXCEPTION(scope, false);
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
      arguments.append(descriptorObject);
      ASSERT(!arguments.hasOverflowed());
      JSValue trapResult = call(exec, definePropertyMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, false);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,21 ***</span>
      }
      if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
          throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);
          return false;
      }
  
      return true;
  }
  
  bool ProxyObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
      return thisObject-&gt;performDefineOwnProperty(exec, propertyName, descriptor, shouldThrow);
  }
  
<span class="line-modified">! void ProxyObject::performGetOwnPropertyNames(ExecState* exec, PropertyNameArray&amp; trapResult, EnumerationMode enumerationMode)</span>
  {
      NO_TAIL_CALLS();
  
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-new-header">--- 902,27 ---</span>
      }
      if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
          throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);
          return false;
      }
<span class="line-added">+     if (targetDescriptor.isDataDescriptor() &amp;&amp; !targetDescriptor.configurable() &amp;&amp; targetDescriptor.writable()) {</span>
<span class="line-added">+         if (descriptor.writablePresent() &amp;&amp; !descriptor.writable()) {</span>
<span class="line-added">+             throwTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-writable input descriptor when the target&#39;s property is non-configurable and writable&quot;_s);</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      return true;
  }
  
  bool ProxyObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
      return thisObject-&gt;performDefineOwnProperty(exec, propertyName, descriptor, shouldThrow);
  }
  
<span class="line-modified">! void ProxyObject::performGetOwnPropertyNames(ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode enumerationMode)</span>
  {
      NO_TAIL_CALLS();
  
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 911,59 ***</span>
      JSValue ownKeysMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
      RETURN_IF_EXCEPTION(scope, void());
      JSObject* target = this-&gt;target();
      if (ownKeysMethod.isUndefined()) {
          scope.release();
<span class="line-modified">!         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, trapResult, enumerationMode);</span>
          return;
      }
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
      JSValue arrayLikeObject = call(exec, ownKeysMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     PropertyNameMode propertyNameMode = trapResult.propertyNameMode();</span>
<span class="line-removed">-     RuntimeTypeMask resultFilter = 0;</span>
<span class="line-removed">-     switch (propertyNameMode) {</span>
<span class="line-removed">-     case PropertyNameMode::Symbols:</span>
<span class="line-removed">-         resultFilter = TypeSymbol;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case PropertyNameMode::Strings:</span>
<span class="line-removed">-         resultFilter = TypeString;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case PropertyNameMode::StringsAndSymbols:</span>
<span class="line-removed">-         resultFilter = TypeSymbol | TypeString;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ASSERT(resultFilter);</span>
<span class="line-removed">-     RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;</span>
      HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;
  
<span class="line-modified">!     auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {</span>
<span class="line-modified">!         static const bool doExitEarly = true;</span>
<span class="line-modified">!         static const bool dontExitEarly = false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (!(type &amp; resultFilter))</span>
<span class="line-modified">!             return dontExitEarly;</span>
  
<span class="line-modified">!         Identifier ident = value.toPropertyKey(exec);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, doExitEarly);</span>
  
<span class="line-modified">!         uncheckedResultKeys.add(ident.impl());</span>
<span class="line-modified">!         trapResult.addUnchecked(ident.impl());</span>
<span class="line-modified">!         return dontExitEarly;</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     createListFromArrayLike(exec, arrayLikeObject, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, void());</span>
  
      bool targetIsExensible = target-&gt;isExtensible(exec);
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     PropertyNameArray targetKeys(&amp;vm, propertyNameMode, trapResult.privateSymbolMode());</span>
      target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, targetKeys, enumerationMode);
      RETURN_IF_EXCEPTION(scope, void());
      Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
      Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
      for (const Identifier&amp; ident : targetKeys) {
<span class="line-new-header">--- 942,75 ---</span>
      JSValue ownKeysMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
      RETURN_IF_EXCEPTION(scope, void());
      JSObject* target = this-&gt;target();
      if (ownKeysMethod.isUndefined()) {
          scope.release();
<span class="line-modified">!         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, propertyNames, enumerationMode);</span>
          return;
      }
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
      JSValue arrayLikeObject = call(exec, ownKeysMethod, callType, callData, handler, arguments);
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     PropertyNameArray trapResult(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
      HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;
<span class="line-added">+     {</span>
<span class="line-added">+         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;&gt; seenKeys;</span>
  
<span class="line-modified">!         RuntimeTypeMask resultFilter = 0;</span>
<span class="line-modified">!         switch (propertyNames.propertyNameMode()) {</span>
<span class="line-modified">!         case PropertyNameMode::Symbols:</span>
<span class="line-modified">!             resultFilter = TypeSymbol;</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case PropertyNameMode::Strings:</span>
<span class="line-added">+             resultFilter = TypeString;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case PropertyNameMode::StringsAndSymbols:</span>
<span class="line-added">+             resultFilter = TypeSymbol | TypeString;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         ASSERT(resultFilter);</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {</span>
<span class="line-added">+             static const bool doExitEarly = true;</span>
<span class="line-added">+             static const bool dontExitEarly = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             Identifier ident = value.toPropertyKey(exec);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, doExitEarly);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // If trapResult contains any duplicate entries, throw a TypeError exception.</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // Per spec[1], filtering by type should occur _after_ [[OwnPropertyKeys]], so duplicates</span>
<span class="line-added">+             // are tracked in a separate hashtable from uncheckedResultKeys (which only contain the</span>
<span class="line-added">+             // keys filtered by type).</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // [1] Per https://tc39.github.io/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeysmust not contain any duplicate names&quot;_s);</span>
<span class="line-added">+             if (!seenKeys.add(ident.impl()).isNewEntry) {</span>
<span class="line-added">+                 throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; trap result must not contain any duplicate names&quot;_s);</span>
<span class="line-added">+                 return doExitEarly;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (!(type &amp; resultFilter))</span>
<span class="line-modified">!                 return dontExitEarly;</span>
  
<span class="line-modified">!             uncheckedResultKeys.add(ident.impl());</span>
<span class="line-modified">!             trapResult.add(ident.impl());</span>
<span class="line-modified">!             return dontExitEarly;</span>
<span class="line-modified">!         };</span>
  
<span class="line-modified">!         RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;</span>
<span class="line-modified">!         createListFromArrayLike(exec, arrayLikeObject, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an object&quot;_s, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">+     }</span>
  
      bool targetIsExensible = target-&gt;isExtensible(exec);
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     PropertyNameArray targetKeys(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
      target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, targetKeys, enumerationMode);
      RETURN_IF_EXCEPTION(scope, void());
      Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
      Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
      for (const Identifier&amp; ident : targetKeys) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 991,23 ***</span>
              throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));
              return;
          }
      }
  
<span class="line-modified">!     if (targetIsExensible)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     for (UniquedStringImpl* impl : targetConfigurableKeys) {</span>
<span class="line-modified">!         if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {</span>
<span class="line-removed">-             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
              return;
          }
      }
  
<span class="line-modified">!     if (uncheckedResultKeys.size()) {</span>
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>
<span class="line-modified">!         return;</span>
      }
  }
  
  void ProxyObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)
  {
<span class="line-new-header">--- 1038,39 ---</span>
              throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));
              return;
          }
      }
  
<span class="line-modified">!     if (!targetIsExensible) {</span>
<span class="line-modified">!         for (UniquedStringImpl* impl : targetConfigurableKeys) {</span>
<span class="line-added">+             if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {</span>
<span class="line-added">+                 throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (uncheckedResultKeys.size()) {</span>
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>
              return;
          }
      }
  
<span class="line-modified">!     if (!enumerationMode.includeDontEnumProperties()) {</span>
<span class="line-modified">!         // Filtering DontEnum properties is observable in proxies and must occur following the invariant checks above.</span>
<span class="line-modified">!         for (auto propertyName : trapResult) {</span>
<span class="line-added">+             PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);</span>
<span class="line-added">+             auto result = getOwnPropertySlotCommon(exec, propertyName, slot);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">+             if (!result)</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             if (slot.attributes() &amp; PropertyAttribute::DontEnum)</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             propertyNames.add(propertyName.impl());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         for (auto propertyName : trapResult)</span>
<span class="line-added">+             propertyNames.add(propertyName.impl());</span>
      }
  }
  
  void ProxyObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)
  {
</pre>
<center><a href="ProxyConstructor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>