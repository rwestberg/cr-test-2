<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARMv7Assembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010 University of Szeged
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM_THUMB2)
  30 
  31 #include &quot;AssemblerBuffer.h&quot;
  32 #include &quot;AssemblerCommon.h&quot;
  33 #include &lt;limits.h&gt;
  34 #include &lt;wtf/Assertions.h&gt;
  35 #include &lt;wtf/Vector.h&gt;
  36 #include &lt;stdint.h&gt;
  37 
  38 namespace JSC {
  39 
  40 namespace ARMRegisters {
  41 
  42     typedef enum : int8_t {
  43         r0,
  44         r1,
  45         r2,
  46         r3,
  47         r4,
  48         r5,
  49         r6,
  50         r7,
  51         r8,
  52         r9,
  53         r10,
  54         r11,
  55         r12,
  56         r13,
  57         r14,
  58         r15,
  59 
  60         fp = r7,   // frame pointer
  61         sb = r9,   // static base
  62         sl = r10,  // stack limit
  63         ip = r12,
  64         sp = r13,
  65         lr = r14,
  66         pc = r15,
  67         InvalidGPRReg = -1,
  68     } RegisterID;
  69 
  70     typedef enum : int8_t {
  71         apsr,
  72         fpscr
  73     } SPRegisterID;
  74 
  75     typedef enum : int8_t {
  76         s0,
  77         s1,
  78         s2,
  79         s3,
  80         s4,
  81         s5,
  82         s6,
  83         s7,
  84         s8,
  85         s9,
  86         s10,
  87         s11,
  88         s12,
  89         s13,
  90         s14,
  91         s15,
  92         s16,
  93         s17,
  94         s18,
  95         s19,
  96         s20,
  97         s21,
  98         s22,
  99         s23,
 100         s24,
 101         s25,
 102         s26,
 103         s27,
 104         s28,
 105         s29,
 106         s30,
 107         s31,
 108     } FPSingleRegisterID;
 109 
 110     typedef enum : int8_t {
 111         d0,
 112         d1,
 113         d2,
 114         d3,
 115         d4,
 116         d5,
 117         d6,
 118         d7,
 119         d8,
 120         d9,
 121         d10,
 122         d11,
 123         d12,
 124         d13,
 125         d14,
 126         d15,
 127 #if CPU(ARM_NEON) || CPU(ARM_VFP_V3_D32)
 128         d16,
 129         d17,
 130         d18,
 131         d19,
 132         d20,
 133         d21,
 134         d22,
 135         d23,
 136         d24,
 137         d25,
 138         d26,
 139         d27,
 140         d28,
 141         d29,
 142         d30,
 143         d31,
 144 #endif // CPU(ARM_NEON) || CPU(ARM_VFP_V3_D32)
 145         InvalidFPRReg = -1,
 146     } FPDoubleRegisterID;
 147 
 148 #if CPU(ARM_NEON)
 149     typedef enum : int8_t {
 150         q0,
 151         q1,
 152         q2,
 153         q3,
 154         q4,
 155         q5,
 156         q6,
 157         q7,
 158         q8,
 159         q9,
 160         q10,
 161         q11,
 162         q12,
 163         q13,
 164         q14,
 165         q15,
 166     } FPQuadRegisterID;
 167 #endif // CPU(ARM_NEON)
 168 
 169     inline FPSingleRegisterID asSingle(FPDoubleRegisterID reg)
 170     {
 171         ASSERT(reg &lt; d16);
 172         return (FPSingleRegisterID)(reg &lt;&lt; 1);
 173     }
 174 
 175     inline FPSingleRegisterID asSingleUpper(FPDoubleRegisterID reg)
 176     {
 177         ASSERT(reg &lt; d16);
 178         return (FPSingleRegisterID)((reg &lt;&lt; 1) + 1);
 179     }
 180 
 181     inline FPDoubleRegisterID asDouble(FPSingleRegisterID reg)
 182     {
 183         ASSERT(!(reg &amp; 1));
 184         return (FPDoubleRegisterID)(reg &gt;&gt; 1);
 185     }
 186 
 187 } // namespace ARMRegisters
 188 
 189 class ARMv7Assembler;
 190 class ARMThumbImmediate {
 191     friend class ARMv7Assembler;
 192 
 193     typedef uint8_t ThumbImmediateType;
 194     static const ThumbImmediateType TypeInvalid = 0;
 195     static const ThumbImmediateType TypeEncoded = 1;
 196     static const ThumbImmediateType TypeUInt16 = 2;
 197 
 198     typedef union {
 199         int16_t asInt;
 200         struct {
 201             unsigned imm8 : 8;
 202             unsigned imm3 : 3;
 203             unsigned i    : 1;
 204             unsigned imm4 : 4;
 205         };
 206         // If this is an encoded immediate, then it may describe a shift, or a pattern.
 207         struct {
 208             unsigned shiftValue7 : 7;
 209             unsigned shiftAmount : 5;
 210         };
 211         struct {
 212             unsigned immediate   : 8;
 213             unsigned pattern     : 4;
 214         };
 215     } ThumbImmediateValue;
 216 
 217     // byte0 contains least significant bit; not using an array to make client code endian agnostic.
 218     typedef union {
 219         int32_t asInt;
 220         struct {
 221             uint8_t byte0;
 222             uint8_t byte1;
 223             uint8_t byte2;
 224             uint8_t byte3;
 225         };
 226     } PatternBytes;
 227 
 228     ALWAYS_INLINE static void countLeadingZerosPartial(uint32_t&amp; value, int32_t&amp; zeros, const int N)
 229     {
 230         if (value &amp; ~((1 &lt;&lt; N) - 1)) /* check for any of the top N bits (of 2N bits) are set */
 231             value &gt;&gt;= N;             /* if any were set, lose the bottom N */
 232         else                         /* if none of the top N bits are set, */
 233             zeros += N;              /* then we have identified N leading zeros */
 234     }
 235 
 236     static int32_t countLeadingZeros(uint32_t value)
 237     {
 238         if (!value)
 239             return 32;
 240 
 241         int32_t zeros = 0;
 242         countLeadingZerosPartial(value, zeros, 16);
 243         countLeadingZerosPartial(value, zeros, 8);
 244         countLeadingZerosPartial(value, zeros, 4);
 245         countLeadingZerosPartial(value, zeros, 2);
 246         countLeadingZerosPartial(value, zeros, 1);
 247         return zeros;
 248     }
 249 
 250     ARMThumbImmediate()
 251         : m_type(TypeInvalid)
 252     {
 253         m_value.asInt = 0;
 254     }
 255 
 256     ARMThumbImmediate(ThumbImmediateType type, ThumbImmediateValue value)
 257         : m_type(type)
 258         , m_value(value)
 259     {
 260     }
 261 
 262     ARMThumbImmediate(ThumbImmediateType type, uint16_t value)
 263         : m_type(TypeUInt16)
 264     {
 265         // Make sure this constructor is only reached with type TypeUInt16;
 266         // this extra parameter makes the code a little clearer by making it
 267         // explicit at call sites which type is being constructed
 268         ASSERT_UNUSED(type, type == TypeUInt16);
 269 
 270         m_value.asInt = value;
 271     }
 272 
 273 public:
 274     static ARMThumbImmediate makeEncodedImm(uint32_t value)
 275     {
 276         ThumbImmediateValue encoding;
 277         encoding.asInt = 0;
 278 
 279         // okay, these are easy.
 280         if (value &lt; 256) {
 281             encoding.immediate = value;
 282             encoding.pattern = 0;
 283             return ARMThumbImmediate(TypeEncoded, encoding);
 284         }
 285 
 286         int32_t leadingZeros = countLeadingZeros(value);
 287         // if there were 24 or more leading zeros, then we&#39;d have hit the (value &lt; 256) case.
 288         ASSERT(leadingZeros &lt; 24);
 289 
 290         // Given a number with bit fields Z:B:C, where count(Z)+count(B)+count(C) == 32,
 291         // Z are the bits known zero, B is the 8-bit immediate, C are the bits to check for
 292         // zero.  count(B) == 8, so the count of bits to be checked is 24 - count(Z).
 293         int32_t rightShiftAmount = 24 - leadingZeros;
 294         if (value == ((value &gt;&gt; rightShiftAmount) &lt;&lt; rightShiftAmount)) {
 295             // Shift the value down to the low byte position.  The assign to
 296             // shiftValue7 drops the implicit top bit.
 297             encoding.shiftValue7 = value &gt;&gt; rightShiftAmount;
 298             // The endoded shift amount is the magnitude of a right rotate.
 299             encoding.shiftAmount = 8 + leadingZeros;
 300             return ARMThumbImmediate(TypeEncoded, encoding);
 301         }
 302 
 303         PatternBytes bytes;
 304         bytes.asInt = value;
 305 
 306         if ((bytes.byte0 == bytes.byte1) &amp;&amp; (bytes.byte0 == bytes.byte2) &amp;&amp; (bytes.byte0 == bytes.byte3)) {
 307             encoding.immediate = bytes.byte0;
 308             encoding.pattern = 3;
 309             return ARMThumbImmediate(TypeEncoded, encoding);
 310         }
 311 
 312         if ((bytes.byte0 == bytes.byte2) &amp;&amp; !(bytes.byte1 | bytes.byte3)) {
 313             encoding.immediate = bytes.byte0;
 314             encoding.pattern = 1;
 315             return ARMThumbImmediate(TypeEncoded, encoding);
 316         }
 317 
 318         if ((bytes.byte1 == bytes.byte3) &amp;&amp; !(bytes.byte0 | bytes.byte2)) {
 319             encoding.immediate = bytes.byte1;
 320             encoding.pattern = 2;
 321             return ARMThumbImmediate(TypeEncoded, encoding);
 322         }
 323 
 324         return ARMThumbImmediate();
 325     }
 326 
 327     static ARMThumbImmediate makeUInt12(int32_t value)
 328     {
 329         return (!(value &amp; 0xfffff000))
 330             ? ARMThumbImmediate(TypeUInt16, (uint16_t)value)
 331             : ARMThumbImmediate();
 332     }
 333 
 334     static ARMThumbImmediate makeUInt12OrEncodedImm(int32_t value)
 335     {
 336         // If this is not a 12-bit unsigned it, try making an encoded immediate.
 337         return (!(value &amp; 0xfffff000))
 338             ? ARMThumbImmediate(TypeUInt16, (uint16_t)value)
 339             : makeEncodedImm(value);
 340     }
 341 
 342     // The &#39;make&#39; methods, above, return a !isValid() value if the argument
 343     // cannot be represented as the requested type.  This methods  is called
 344     // &#39;get&#39; since the argument can always be represented.
 345     static ARMThumbImmediate makeUInt16(uint16_t value)
 346     {
 347         return ARMThumbImmediate(TypeUInt16, value);
 348     }
 349 
 350     bool isValid()
 351     {
 352         return m_type != TypeInvalid;
 353     }
 354 
 355     uint16_t asUInt16() const { return m_value.asInt; }
 356 
 357     // These methods rely on the format of encoded byte values.
 358     bool isUInt3() { return !(m_value.asInt &amp; 0xfff8); }
 359     bool isUInt4() { return !(m_value.asInt &amp; 0xfff0); }
 360     bool isUInt5() { return !(m_value.asInt &amp; 0xffe0); }
 361     bool isUInt6() { return !(m_value.asInt &amp; 0xffc0); }
 362     bool isUInt7() { return !(m_value.asInt &amp; 0xff80); }
 363     bool isUInt8() { return !(m_value.asInt &amp; 0xff00); }
 364     bool isUInt9() { return (m_type == TypeUInt16) &amp;&amp; !(m_value.asInt &amp; 0xfe00); }
 365     bool isUInt10() { return (m_type == TypeUInt16) &amp;&amp; !(m_value.asInt &amp; 0xfc00); }
 366     bool isUInt12() { return (m_type == TypeUInt16) &amp;&amp; !(m_value.asInt &amp; 0xf000); }
 367     bool isUInt16() { return m_type == TypeUInt16; }
 368     uint8_t getUInt3() { ASSERT(isUInt3()); return m_value.asInt; }
 369     uint8_t getUInt4() { ASSERT(isUInt4()); return m_value.asInt; }
 370     uint8_t getUInt5() { ASSERT(isUInt5()); return m_value.asInt; }
 371     uint8_t getUInt6() { ASSERT(isUInt6()); return m_value.asInt; }
 372     uint8_t getUInt7() { ASSERT(isUInt7()); return m_value.asInt; }
 373     uint8_t getUInt8() { ASSERT(isUInt8()); return m_value.asInt; }
 374     uint16_t getUInt9() { ASSERT(isUInt9()); return m_value.asInt; }
 375     uint16_t getUInt10() { ASSERT(isUInt10()); return m_value.asInt; }
 376     uint16_t getUInt12() { ASSERT(isUInt12()); return m_value.asInt; }
 377     uint16_t getUInt16() { ASSERT(isUInt16()); return m_value.asInt; }
 378 
 379     bool isEncodedImm() { return m_type == TypeEncoded; }
 380 
 381 private:
 382     ThumbImmediateType m_type;
 383     ThumbImmediateValue m_value;
 384 };
 385 
 386 typedef enum {
 387     SRType_LSL,
 388     SRType_LSR,
 389     SRType_ASR,
 390     SRType_ROR,
 391 
 392     SRType_RRX = SRType_ROR
 393 } ARMShiftType;
 394 
 395 class ShiftTypeAndAmount {
 396     friend class ARMv7Assembler;
 397 
 398 public:
 399     ShiftTypeAndAmount()
 400     {
 401         m_u.type = (ARMShiftType)0;
 402         m_u.amount = 0;
 403     }
 404 
 405     ShiftTypeAndAmount(ARMShiftType type, unsigned amount)
 406     {
 407         m_u.type = type;
 408         m_u.amount = amount &amp; 31;
 409     }
 410 
 411     unsigned lo4() { return m_u.lo4; }
 412     unsigned hi4() { return m_u.hi4; }
 413 
 414 private:
 415     union {
 416         struct {
 417             unsigned lo4 : 4;
 418             unsigned hi4 : 4;
 419         };
 420         struct {
 421             unsigned type   : 2;
 422             unsigned amount : 6;
 423         };
 424     } m_u;
 425 };
 426 
 427 class ARMv7Assembler {
 428 public:
 429     typedef ARMRegisters::RegisterID RegisterID;
 430     typedef ARMRegisters::FPSingleRegisterID FPSingleRegisterID;
 431     typedef ARMRegisters::FPDoubleRegisterID FPDoubleRegisterID;
 432 #if CPU(ARM_NEON)
 433     typedef ARMRegisters::FPQuadRegisterID FPQuadRegisterID;
 434 #endif
 435     typedef ARMRegisters::SPRegisterID SPRegisterID;
 436     typedef FPDoubleRegisterID FPRegisterID;
 437 
 438     static constexpr RegisterID firstRegister() { return ARMRegisters::r0; }
 439     static constexpr RegisterID lastRegister() { return ARMRegisters::r15; }
 440     static constexpr unsigned numberOfRegisters() { return lastRegister() - firstRegister() + 1; }
 441 
 442     static constexpr SPRegisterID firstSPRegister() { return ARMRegisters::apsr; }
 443     static constexpr SPRegisterID lastSPRegister() { return ARMRegisters::fpscr; }
 444     static constexpr unsigned numberOfSPRegisters() { return lastSPRegister() - firstSPRegister() + 1; }
 445 
 446     static constexpr FPRegisterID firstFPRegister() { return ARMRegisters::d0; }
 447 #if CPU(ARM_NEON) || CPU(ARM_VFP_V3_D32)
 448     static constexpr FPRegisterID lastFPRegister() { return ARMRegisters::d31; }
 449 #else
 450     static constexpr FPRegisterID lastFPRegister() { return ARMRegisters::d15; }
 451 #endif
 452     static constexpr unsigned numberOfFPRegisters() { return lastFPRegister() - firstFPRegister() + 1; }
 453 
 454     static const char* gprName(RegisterID id)
 455     {
 456         ASSERT(id &gt;= firstRegister() &amp;&amp; id &lt;= lastRegister());
 457         static const char* const nameForRegister[numberOfRegisters()] = {
 458             &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;,
 459             &quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;, &quot;fp&quot;,
 460             &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;,
 461             &quot;ip&quot;, &quot;sp&quot;, &quot;lr&quot;, &quot;pc&quot;
 462         };
 463         return nameForRegister[id];
 464     }
 465 
 466     static const char* sprName(SPRegisterID id)
 467     {
 468         ASSERT(id &gt;= firstSPRegister() &amp;&amp; id &lt;= lastSPRegister());
 469         static const char* const nameForRegister[numberOfSPRegisters()] = {
 470             &quot;apsr&quot;, &quot;fpscr&quot;
 471         };
 472         return nameForRegister[id];
 473     }
 474 
 475     static const char* fprName(FPRegisterID id)
 476     {
 477         ASSERT(id &gt;= firstFPRegister() &amp;&amp; id &lt;= lastFPRegister());
 478         static const char* const nameForRegister[numberOfFPRegisters()] = {
 479             &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;,
 480             &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;,
 481             &quot;d8&quot;, &quot;d9&quot;, &quot;d10&quot;, &quot;d11&quot;,
 482             &quot;d12&quot;, &quot;d13&quot;, &quot;d14&quot;, &quot;d15&quot;,
 483 #if CPU(ARM_NEON) || CPU(ARM_VFP_V3_D32)
 484             &quot;d16&quot;, &quot;d17&quot;, &quot;d18&quot;, &quot;d19&quot;,
 485             &quot;d20&quot;, &quot;d21&quot;, &quot;d22&quot;, &quot;d23&quot;,
 486             &quot;d24&quot;, &quot;d25&quot;, &quot;d26&quot;, &quot;d27&quot;,
 487             &quot;d28&quot;, &quot;d29&quot;, &quot;d30&quot;, &quot;d31&quot;
 488 #endif // CPU(ARM_NEON) || CPU(ARM_VFP_V3_D32)
 489         };
 490         return nameForRegister[id];
 491     }
 492 
 493     // (HS, LO, HI, LS) -&gt; (AE, B, A, BE)
 494     // (VS, VC) -&gt; (O, NO)
 495     typedef enum {
 496         ConditionEQ, // Zero / Equal.
 497         ConditionNE, // Non-zero / Not equal.
 498         ConditionHS, ConditionCS = ConditionHS, // Unsigned higher or same.
 499         ConditionLO, ConditionCC = ConditionLO, // Unsigned lower.
 500         ConditionMI, // Negative.
 501         ConditionPL, // Positive or zero.
 502         ConditionVS, // Overflowed.
 503         ConditionVC, // Not overflowed.
 504         ConditionHI, // Unsigned higher.
 505         ConditionLS, // Unsigned lower or same.
 506         ConditionGE, // Signed greater than or equal.
 507         ConditionLT, // Signed less than.
 508         ConditionGT, // Signed greater than.
 509         ConditionLE, // Signed less than or equal.
 510         ConditionAL, // Unconditional / Always execute.
 511         ConditionInvalid
 512     } Condition;
 513 
 514 #define JUMP_ENUM_WITH_SIZE(index, value) (((value) &lt;&lt; 3) | (index))
 515 #define JUMP_ENUM_SIZE(jump) ((jump) &gt;&gt; 3)
 516     enum JumpType { JumpFixed = JUMP_ENUM_WITH_SIZE(0, 0),
 517                     JumpNoCondition = JUMP_ENUM_WITH_SIZE(1, 5 * sizeof(uint16_t)),
 518                     JumpCondition = JUMP_ENUM_WITH_SIZE(2, 6 * sizeof(uint16_t)),
 519                     JumpNoConditionFixedSize = JUMP_ENUM_WITH_SIZE(3, 5 * sizeof(uint16_t)),
 520                     JumpConditionFixedSize = JUMP_ENUM_WITH_SIZE(4, 6 * sizeof(uint16_t))
 521     };
 522     enum JumpLinkType {
 523         LinkInvalid = JUMP_ENUM_WITH_SIZE(0, 0),
 524         LinkJumpT1 = JUMP_ENUM_WITH_SIZE(1, sizeof(uint16_t)),
 525         LinkJumpT2 = JUMP_ENUM_WITH_SIZE(2, sizeof(uint16_t)),
 526         LinkJumpT3 = JUMP_ENUM_WITH_SIZE(3, 2 * sizeof(uint16_t)),
 527         LinkJumpT4 = JUMP_ENUM_WITH_SIZE(4, 2 * sizeof(uint16_t)),
 528         LinkConditionalJumpT4 = JUMP_ENUM_WITH_SIZE(5, 3 * sizeof(uint16_t)),
 529         LinkBX = JUMP_ENUM_WITH_SIZE(6, 5 * sizeof(uint16_t)),
 530         LinkConditionalBX = JUMP_ENUM_WITH_SIZE(7, 6 * sizeof(uint16_t))
 531     };
 532 
 533     class LinkRecord {
 534     public:
 535         LinkRecord(intptr_t from, intptr_t to, JumpType type, Condition condition)
 536         {
 537             data.realTypes.m_from = from;
 538             data.realTypes.m_to = to;
 539             data.realTypes.m_type = type;
 540             data.realTypes.m_linkType = LinkInvalid;
 541             data.realTypes.m_condition = condition;
 542         }
 543         void operator=(const LinkRecord&amp; other)
 544         {
 545             data.copyTypes.content[0] = other.data.copyTypes.content[0];
 546             data.copyTypes.content[1] = other.data.copyTypes.content[1];
 547             data.copyTypes.content[2] = other.data.copyTypes.content[2];
 548         }
 549         intptr_t from() const { return data.realTypes.m_from; }
 550         void setFrom(intptr_t from) { data.realTypes.m_from = from; }
 551         intptr_t to() const { return data.realTypes.m_to; }
 552         JumpType type() const { return data.realTypes.m_type; }
 553         JumpLinkType linkType() const { return data.realTypes.m_linkType; }
 554         void setLinkType(JumpLinkType linkType) { ASSERT(data.realTypes.m_linkType == LinkInvalid); data.realTypes.m_linkType = linkType; }
 555         Condition condition() const { return data.realTypes.m_condition; }
 556     private:
 557         union {
 558             struct RealTypes {
 559                 intptr_t m_from : 31;
 560                 intptr_t m_to : 31;
 561                 JumpType m_type : 8;
 562                 JumpLinkType m_linkType : 8;
 563                 Condition m_condition : 16;
 564             } realTypes;
 565             struct CopyTypes {
 566                 uint32_t content[3];
 567             } copyTypes;
 568             COMPILE_ASSERT(sizeof(RealTypes) == sizeof(CopyTypes), LinkRecordCopyStructSizeEqualsRealStruct);
 569         } data;
 570     };
 571 
 572     ARMv7Assembler()
 573         : m_indexOfLastWatchpoint(INT_MIN)
 574         , m_indexOfTailOfLastWatchpoint(INT_MIN)
 575     {
 576     }
 577 
 578     AssemblerBuffer&amp; buffer() { return m_formatter.m_buffer; }
 579 
 580 private:
 581 
 582     // ARMv7, Appx-A.6.3
 583     static bool BadReg(RegisterID reg)
 584     {
 585         return (reg == ARMRegisters::sp) || (reg == ARMRegisters::pc);
 586     }
 587 
 588     uint32_t singleRegisterMask(FPSingleRegisterID rdNum, int highBitsShift, int lowBitShift)
 589     {
 590         uint32_t rdMask = (rdNum &gt;&gt; 1) &lt;&lt; highBitsShift;
 591         if (rdNum &amp; 1)
 592             rdMask |= 1 &lt;&lt; lowBitShift;
 593         return rdMask;
 594     }
 595 
 596     uint32_t doubleRegisterMask(FPDoubleRegisterID rdNum, int highBitShift, int lowBitsShift)
 597     {
 598         uint32_t rdMask = (rdNum &amp; 0xf) &lt;&lt; lowBitsShift;
 599         if (rdNum &amp; 16)
 600             rdMask |= 1 &lt;&lt; highBitShift;
 601         return rdMask;
 602     }
 603 
 604     typedef enum {
 605         OP_ADD_reg_T1       = 0x1800,
 606         OP_SUB_reg_T1       = 0x1A00,
 607         OP_ADD_imm_T1       = 0x1C00,
 608         OP_SUB_imm_T1       = 0x1E00,
 609         OP_MOV_imm_T1       = 0x2000,
 610         OP_CMP_imm_T1       = 0x2800,
 611         OP_ADD_imm_T2       = 0x3000,
 612         OP_SUB_imm_T2       = 0x3800,
 613         OP_AND_reg_T1       = 0x4000,
 614         OP_EOR_reg_T1       = 0x4040,
 615         OP_TST_reg_T1       = 0x4200,
 616         OP_RSB_imm_T1       = 0x4240,
 617         OP_CMP_reg_T1       = 0x4280,
 618         OP_ORR_reg_T1       = 0x4300,
 619         OP_MVN_reg_T1       = 0x43C0,
 620         OP_ADD_reg_T2       = 0x4400,
 621         OP_MOV_reg_T1       = 0x4600,
 622         OP_BLX              = 0x4700,
 623         OP_BX               = 0x4700,
 624         OP_STR_reg_T1       = 0x5000,
 625         OP_STRH_reg_T1      = 0x5200,
 626         OP_STRB_reg_T1      = 0x5400,
 627         OP_LDRSB_reg_T1     = 0x5600,
 628         OP_LDR_reg_T1       = 0x5800,
 629         OP_LDRH_reg_T1      = 0x5A00,
 630         OP_LDRB_reg_T1      = 0x5C00,
 631         OP_LDRSH_reg_T1     = 0x5E00,
 632         OP_STR_imm_T1       = 0x6000,
 633         OP_LDR_imm_T1       = 0x6800,
 634         OP_STRB_imm_T1      = 0x7000,
 635         OP_LDRB_imm_T1      = 0x7800,
 636         OP_STRH_imm_T1      = 0x8000,
 637         OP_LDRH_imm_T1      = 0x8800,
 638         OP_STR_imm_T2       = 0x9000,
 639         OP_LDR_imm_T2       = 0x9800,
 640         OP_ADD_SP_imm_T1    = 0xA800,
 641         OP_ADD_SP_imm_T2    = 0xB000,
 642         OP_SUB_SP_imm_T1    = 0xB080,
 643         OP_PUSH_T1          = 0xB400,
 644         OP_POP_T1           = 0xBC00,
 645         OP_BKPT             = 0xBE00,
 646         OP_IT               = 0xBF00,
 647         OP_NOP_T1           = 0xBF00,
 648     } OpcodeID;
 649 
 650     typedef enum {
 651         OP_B_T1         = 0xD000,
 652         OP_B_T2         = 0xE000,
 653         OP_POP_T2       = 0xE8BD,
 654         OP_PUSH_T2      = 0xE92D,
 655         OP_AND_reg_T2   = 0xEA00,
 656         OP_TST_reg_T2   = 0xEA10,
 657         OP_ORR_reg_T2   = 0xEA40,
 658         OP_ORR_S_reg_T2 = 0xEA50,
 659         OP_ASR_imm_T1   = 0xEA4F,
 660         OP_LSL_imm_T1   = 0xEA4F,
 661         OP_LSR_imm_T1   = 0xEA4F,
 662         OP_ROR_imm_T1   = 0xEA4F,
 663         OP_MVN_reg_T2   = 0xEA6F,
 664         OP_EOR_reg_T2   = 0xEA80,
 665         OP_ADD_reg_T3   = 0xEB00,
 666         OP_ADD_S_reg_T3 = 0xEB10,
 667         OP_SUB_reg_T2   = 0xEBA0,
 668         OP_SUB_S_reg_T2 = 0xEBB0,
 669         OP_CMP_reg_T2   = 0xEBB0,
 670         OP_VMOV_CtoD    = 0xEC00,
 671         OP_VMOV_DtoC    = 0xEC10,
 672         OP_FSTS         = 0xED00,
 673         OP_VSTR         = 0xED00,
 674         OP_FLDS         = 0xED10,
 675         OP_VLDR         = 0xED10,
 676         OP_VMOV_CtoS    = 0xEE00,
 677         OP_VMOV_StoC    = 0xEE10,
 678         OP_VMUL_T2      = 0xEE20,
 679         OP_VADD_T2      = 0xEE30,
 680         OP_VSUB_T2      = 0xEE30,
 681         OP_VDIV         = 0xEE80,
 682         OP_VABS_T2      = 0xEEB0,
 683         OP_VCMP         = 0xEEB0,
 684         OP_VCVT_FPIVFP  = 0xEEB0,
 685         OP_VMOV_T2      = 0xEEB0,
 686         OP_VMOV_IMM_T2  = 0xEEB0,
 687         OP_VMRS         = 0xEEB0,
 688         OP_VNEG_T2      = 0xEEB0,
 689         OP_VSQRT_T1     = 0xEEB0,
 690         OP_VCVTSD_T1    = 0xEEB0,
 691         OP_VCVTDS_T1    = 0xEEB0,
 692         OP_B_T3a        = 0xF000,
 693         OP_B_T4a        = 0xF000,
 694         OP_AND_imm_T1   = 0xF000,
 695         OP_TST_imm      = 0xF010,
 696         OP_ORR_imm_T1   = 0xF040,
 697         OP_MOV_imm_T2   = 0xF040,
 698         OP_MVN_imm      = 0xF060,
 699         OP_EOR_imm_T1   = 0xF080,
 700         OP_ADD_imm_T3   = 0xF100,
 701         OP_ADD_S_imm_T3 = 0xF110,
 702         OP_CMN_imm      = 0xF110,
 703         OP_ADC_imm      = 0xF140,
 704         OP_SUB_imm_T3   = 0xF1A0,
 705         OP_SUB_S_imm_T3 = 0xF1B0,
 706         OP_CMP_imm_T2   = 0xF1B0,
 707         OP_RSB_imm_T2   = 0xF1C0,
 708         OP_RSB_S_imm_T2 = 0xF1D0,
 709         OP_ADD_imm_T4   = 0xF200,
 710         OP_MOV_imm_T3   = 0xF240,
 711         OP_SUB_imm_T4   = 0xF2A0,
 712         OP_MOVT         = 0xF2C0,
 713         OP_UBFX_T1      = 0xF3C0,
 714         OP_NOP_T2a      = 0xF3AF,
 715         OP_DMB_T1a      = 0xF3BF,
 716         OP_STRB_imm_T3  = 0xF800,
 717         OP_STRB_reg_T2  = 0xF800,
 718         OP_LDRB_imm_T3  = 0xF810,
 719         OP_LDRB_reg_T2  = 0xF810,
 720         OP_STRH_imm_T3  = 0xF820,
 721         OP_STRH_reg_T2  = 0xF820,
 722         OP_LDRH_reg_T2  = 0xF830,
 723         OP_LDRH_imm_T3  = 0xF830,
 724         OP_STR_imm_T4   = 0xF840,
 725         OP_STR_reg_T2   = 0xF840,
 726         OP_LDR_imm_T4   = 0xF850,
 727         OP_LDR_reg_T2   = 0xF850,
 728         OP_STRB_imm_T2  = 0xF880,
 729         OP_LDRB_imm_T2  = 0xF890,
 730         OP_STRH_imm_T2  = 0xF8A0,
 731         OP_LDRH_imm_T2  = 0xF8B0,
 732         OP_STR_imm_T3   = 0xF8C0,
 733         OP_LDR_imm_T3   = 0xF8D0,
 734         OP_LDRSB_reg_T2 = 0xF910,
 735         OP_LDRSH_reg_T2 = 0xF930,
 736         OP_LSL_reg_T2   = 0xFA00,
 737         OP_LSR_reg_T2   = 0xFA20,
 738         OP_ASR_reg_T2   = 0xFA40,
 739         OP_ROR_reg_T2   = 0xFA60,
 740         OP_CLZ          = 0xFAB0,
 741         OP_SMULL_T1     = 0xFB80,
 742 #if HAVE(ARM_IDIV_INSTRUCTIONS)
 743         OP_SDIV_T1      = 0xFB90,
 744         OP_UDIV_T1      = 0xFBB0,
 745 #endif
 746         OP_MRS_T1       = 0xF3EF,
 747     } OpcodeID1;
 748 
 749     typedef enum {
 750         OP_VADD_T2b      = 0x0A00,
 751         OP_VDIVb         = 0x0A00,
 752         OP_FLDSb         = 0x0A00,
 753         OP_VLDRb         = 0x0A00,
 754         OP_VMOV_IMM_T2b  = 0x0A00,
 755         OP_VMOV_T2b      = 0x0A40,
 756         OP_VMUL_T2b      = 0x0A00,
 757         OP_FSTSb         = 0x0A00,
 758         OP_VSTRb         = 0x0A00,
 759         OP_VMOV_StoCb    = 0x0A10,
 760         OP_VMOV_CtoSb    = 0x0A10,
 761         OP_VMOV_DtoCb    = 0x0A10,
 762         OP_VMOV_CtoDb    = 0x0A10,
 763         OP_VMRSb         = 0x0A10,
 764         OP_VABS_T2b      = 0x0A40,
 765         OP_VCMPb         = 0x0A40,
 766         OP_VCVT_FPIVFPb  = 0x0A40,
 767         OP_VNEG_T2b      = 0x0A40,
 768         OP_VSUB_T2b      = 0x0A40,
 769         OP_VSQRT_T1b     = 0x0A40,
 770         OP_VCVTSD_T1b    = 0x0A40,
 771         OP_VCVTDS_T1b    = 0x0A40,
 772         OP_NOP_T2b       = 0x8000,
 773         OP_DMB_SY_T1b    = 0x8F5F,
 774         OP_DMB_ISHST_T1b = 0x8F5A,
 775         OP_B_T3b         = 0x8000,
 776         OP_B_T4b         = 0x9000,
 777     } OpcodeID2;
 778 
 779     struct FourFours {
 780         FourFours(unsigned f3, unsigned f2, unsigned f1, unsigned f0)
 781         {
 782             m_u.f0 = f0;
 783             m_u.f1 = f1;
 784             m_u.f2 = f2;
 785             m_u.f3 = f3;
 786         }
 787 
 788         union {
 789             unsigned value;
 790             struct {
 791                 unsigned f0 : 4;
 792                 unsigned f1 : 4;
 793                 unsigned f2 : 4;
 794                 unsigned f3 : 4;
 795             };
 796         } m_u;
 797     };
 798 
 799     class ARMInstructionFormatter;
 800 
 801     // false means else!
 802     static bool ifThenElseConditionBit(Condition condition, bool isIf)
 803     {
 804         return isIf ? (condition &amp; 1) : !(condition &amp; 1);
 805     }
 806     static uint8_t ifThenElse(Condition condition, bool inst2if, bool inst3if, bool inst4if)
 807     {
 808         int mask = (ifThenElseConditionBit(condition, inst2if) &lt;&lt; 3)
 809             | (ifThenElseConditionBit(condition, inst3if) &lt;&lt; 2)
 810             | (ifThenElseConditionBit(condition, inst4if) &lt;&lt; 1)
 811             | 1;
 812         ASSERT((condition != ConditionAL) || !(mask &amp; (mask - 1)));
 813         return (condition &lt;&lt; 4) | mask;
 814     }
 815     static uint8_t ifThenElse(Condition condition, bool inst2if, bool inst3if)
 816     {
 817         int mask = (ifThenElseConditionBit(condition, inst2if) &lt;&lt; 3)
 818             | (ifThenElseConditionBit(condition, inst3if) &lt;&lt; 2)
 819             | 2;
 820         ASSERT((condition != ConditionAL) || !(mask &amp; (mask - 1)));
 821         return (condition &lt;&lt; 4) | mask;
 822     }
 823     static uint8_t ifThenElse(Condition condition, bool inst2if)
 824     {
 825         int mask = (ifThenElseConditionBit(condition, inst2if) &lt;&lt; 3)
 826             | 4;
 827         ASSERT((condition != ConditionAL) || !(mask &amp; (mask - 1)));
 828         return (condition &lt;&lt; 4) | mask;
 829     }
 830 
 831     static uint8_t ifThenElse(Condition condition)
 832     {
 833         int mask = 8;
 834         return (condition &lt;&lt; 4) | mask;
 835     }
 836 
 837 public:
 838 
 839     void adc(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
 840     {
 841         // Rd can only be SP if Rn is also SP.
 842         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
 843         ASSERT(rd != ARMRegisters::pc);
 844         ASSERT(rn != ARMRegisters::pc);
 845         ASSERT(imm.isEncodedImm());
 846 
 847         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ADC_imm, rn, rd, imm);
 848     }
 849 
 850     void add(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
 851     {
 852         // Rd can only be SP if Rn is also SP.
 853         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
 854         ASSERT(rd != ARMRegisters::pc);
 855         ASSERT(rn != ARMRegisters::pc);
 856         ASSERT(imm.isValid());
 857 
 858         if (rn == ARMRegisters::sp &amp;&amp; imm.isUInt16()) {
 859             ASSERT(!(imm.getUInt16() &amp; 3));
 860             if (!(rd &amp; 8) &amp;&amp; imm.isUInt10()) {
 861                 m_formatter.oneWordOp5Reg3Imm8(OP_ADD_SP_imm_T1, rd, static_cast&lt;uint8_t&gt;(imm.getUInt10() &gt;&gt; 2));
 862                 return;
 863             } else if ((rd == ARMRegisters::sp) &amp;&amp; imm.isUInt9()) {
 864                 m_formatter.oneWordOp9Imm7(OP_ADD_SP_imm_T2, static_cast&lt;uint8_t&gt;(imm.getUInt9() &gt;&gt; 2));
 865                 return;
 866             }
 867         } else if (!((rd | rn) &amp; 8)) {
 868             if (imm.isUInt3()) {
 869                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
 870                 return;
 871             } else if ((rd == rn) &amp;&amp; imm.isUInt8()) {
 872                 m_formatter.oneWordOp5Reg3Imm8(OP_ADD_imm_T2, rd, imm.getUInt8());
 873                 return;
 874             }
 875         }
 876 
 877         if (imm.isEncodedImm())
 878             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ADD_imm_T3, rn, rd, imm);
 879         else {
 880             ASSERT(imm.isUInt12());
 881             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ADD_imm_T4, rn, rd, imm);
 882         }
 883     }
 884 
 885     ALWAYS_INLINE void add(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
 886     {
 887         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
 888         ASSERT(rd != ARMRegisters::pc);
 889         ASSERT(rn != ARMRegisters::pc);
 890         ASSERT(!BadReg(rm));
 891         m_formatter.twoWordOp12Reg4FourFours(OP_ADD_reg_T3, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
 892     }
 893 
 894     // NOTE: In an IT block, add doesn&#39;t modify the flags register.
 895     ALWAYS_INLINE void add(RegisterID rd, RegisterID rn, RegisterID rm)
 896     {
 897         if (rd == ARMRegisters::sp) {
 898             mov(rd, rn);
 899             rn = rd;
 900         }
 901 
 902         if (rd == rn)
 903             m_formatter.oneWordOp8RegReg143(OP_ADD_reg_T2, rm, rd);
 904         else if (rd == rm)
 905             m_formatter.oneWordOp8RegReg143(OP_ADD_reg_T2, rn, rd);
 906         else if (!((rd | rn | rm) &amp; 8))
 907             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_reg_T1, rm, rn, rd);
 908         else
 909             add(rd, rn, rm, ShiftTypeAndAmount());
 910     }
 911 
 912     // Not allowed in an IT (if then) block.
 913     ALWAYS_INLINE void add_S(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
 914     {
 915         // Rd can only be SP if Rn is also SP.
 916         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
 917         ASSERT(rd != ARMRegisters::pc);
 918         ASSERT(rn != ARMRegisters::pc);
 919         ASSERT(imm.isEncodedImm());
 920 
 921         if (!((rd | rn) &amp; 8)) {
 922             if (imm.isUInt3()) {
 923                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
 924                 return;
 925             } else if ((rd == rn) &amp;&amp; imm.isUInt8()) {
 926                 m_formatter.oneWordOp5Reg3Imm8(OP_ADD_imm_T2, rd, imm.getUInt8());
 927                 return;
 928             }
 929         }
 930 
 931         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ADD_S_imm_T3, rn, rd, imm);
 932     }
 933 
 934     // Not allowed in an IT (if then) block?
 935     ALWAYS_INLINE void add_S(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
 936     {
 937         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
 938         ASSERT(rd != ARMRegisters::pc);
 939         ASSERT(rn != ARMRegisters::pc);
 940         ASSERT(!BadReg(rm));
 941         m_formatter.twoWordOp12Reg4FourFours(OP_ADD_S_reg_T3, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
 942     }
 943 
 944     // Not allowed in an IT (if then) block.
 945     ALWAYS_INLINE void add_S(RegisterID rd, RegisterID rn, RegisterID rm)
 946     {
 947         if (!((rd | rn | rm) &amp; 8))
 948             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_reg_T1, rm, rn, rd);
 949         else
 950             add_S(rd, rn, rm, ShiftTypeAndAmount());
 951     }
 952 
 953     ALWAYS_INLINE void ARM_and(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
 954     {
 955         ASSERT(!BadReg(rd));
 956         ASSERT(!BadReg(rn));
 957         ASSERT(imm.isEncodedImm());
 958         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_AND_imm_T1, rn, rd, imm);
 959     }
 960 
 961     ALWAYS_INLINE void ARM_and(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
 962     {
 963         ASSERT(!BadReg(rd));
 964         ASSERT(!BadReg(rn));
 965         ASSERT(!BadReg(rm));
 966         m_formatter.twoWordOp12Reg4FourFours(OP_AND_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
 967     }
 968 
 969     ALWAYS_INLINE void ARM_and(RegisterID rd, RegisterID rn, RegisterID rm)
 970     {
 971         if ((rd == rn) &amp;&amp; !((rd | rm) &amp; 8))
 972             m_formatter.oneWordOp10Reg3Reg3(OP_AND_reg_T1, rm, rd);
 973         else if ((rd == rm) &amp;&amp; !((rd | rn) &amp; 8))
 974             m_formatter.oneWordOp10Reg3Reg3(OP_AND_reg_T1, rn, rd);
 975         else
 976             ARM_and(rd, rn, rm, ShiftTypeAndAmount());
 977     }
 978 
 979     ALWAYS_INLINE void asr(RegisterID rd, RegisterID rm, int32_t shiftAmount)
 980     {
 981         ASSERT(!BadReg(rd));
 982         ASSERT(!BadReg(rm));
 983         ShiftTypeAndAmount shift(SRType_ASR, shiftAmount);
 984         m_formatter.twoWordOp16FourFours(OP_ASR_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
 985     }
 986 
 987     ALWAYS_INLINE void asr(RegisterID rd, RegisterID rn, RegisterID rm)
 988     {
 989         ASSERT(!BadReg(rd));
 990         ASSERT(!BadReg(rn));
 991         ASSERT(!BadReg(rm));
 992         m_formatter.twoWordOp12Reg4FourFours(OP_ASR_reg_T2, rn, FourFours(0xf, rd, 0, rm));
 993     }
 994 
 995     // Only allowed in IT (if then) block if last instruction.
 996     ALWAYS_INLINE AssemblerLabel b()
 997     {
 998         m_formatter.twoWordOp16Op16(OP_B_T4a, OP_B_T4b);
 999         return m_formatter.label();
1000     }
1001 
1002     // Only allowed in IT (if then) block if last instruction.
1003     ALWAYS_INLINE AssemblerLabel blx(RegisterID rm)
1004     {
1005         ASSERT(rm != ARMRegisters::pc);
1006         m_formatter.oneWordOp8RegReg143(OP_BLX, rm, (RegisterID)8);
1007         return m_formatter.label();
1008     }
1009 
1010     // Only allowed in IT (if then) block if last instruction.
1011     ALWAYS_INLINE AssemblerLabel bx(RegisterID rm)
1012     {
1013         m_formatter.oneWordOp8RegReg143(OP_BX, rm, (RegisterID)0);
1014         return m_formatter.label();
1015     }
1016 
1017     void bkpt(uint8_t imm = 0)
1018     {
1019         m_formatter.oneWordOp8Imm8(OP_BKPT, imm);
1020     }
1021 
1022     static bool isBkpt(void* address)
1023     {
1024         unsigned short expected = OP_BKPT;
1025         unsigned short immediateMask = 0xff;
1026         unsigned short candidateInstruction = *reinterpret_cast&lt;unsigned short*&gt;(address);
1027         return (candidateInstruction &amp; ~immediateMask) == expected;
1028     }
1029 
1030     ALWAYS_INLINE void clz(RegisterID rd, RegisterID rm)
1031     {
1032         ASSERT(!BadReg(rd));
1033         ASSERT(!BadReg(rm));
1034         m_formatter.twoWordOp12Reg4FourFours(OP_CLZ, rm, FourFours(0xf, rd, 8, rm));
1035     }
1036 
1037     ALWAYS_INLINE void cmn(RegisterID rn, ARMThumbImmediate imm)
1038     {
1039         ASSERT(rn != ARMRegisters::pc);
1040         ASSERT(imm.isEncodedImm());
1041 
1042         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_CMN_imm, rn, (RegisterID)0xf, imm);
1043     }
1044 
1045     ALWAYS_INLINE void cmp(RegisterID rn, ARMThumbImmediate imm)
1046     {
1047         ASSERT(rn != ARMRegisters::pc);
1048         ASSERT(imm.isEncodedImm());
1049 
1050         if (!(rn &amp; 8) &amp;&amp; imm.isUInt8())
1051             m_formatter.oneWordOp5Reg3Imm8(OP_CMP_imm_T1, rn, imm.getUInt8());
1052         else
1053             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_CMP_imm_T2, rn, (RegisterID)0xf, imm);
1054     }
1055 
1056     ALWAYS_INLINE void cmp(RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
1057     {
1058         ASSERT(rn != ARMRegisters::pc);
1059         ASSERT(!BadReg(rm));
1060         m_formatter.twoWordOp12Reg4FourFours(OP_CMP_reg_T2, rn, FourFours(shift.hi4(), 0xf, shift.lo4(), rm));
1061     }
1062 
1063     ALWAYS_INLINE void cmp(RegisterID rn, RegisterID rm)
1064     {
1065         if ((rn | rm) &amp; 8)
1066             cmp(rn, rm, ShiftTypeAndAmount());
1067         else
1068             m_formatter.oneWordOp10Reg3Reg3(OP_CMP_reg_T1, rm, rn);
1069     }
1070 
1071     // xor is not spelled with an &#39;e&#39;. :-(
1072     ALWAYS_INLINE void eor(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
1073     {
1074         ASSERT(!BadReg(rd));
1075         ASSERT(!BadReg(rn));
1076         ASSERT(imm.isEncodedImm());
1077         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_EOR_imm_T1, rn, rd, imm);
1078     }
1079 
1080     // xor is not spelled with an &#39;e&#39;. :-(
1081     ALWAYS_INLINE void eor(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
1082     {
1083         ASSERT(!BadReg(rd));
1084         ASSERT(!BadReg(rn));
1085         ASSERT(!BadReg(rm));
1086         m_formatter.twoWordOp12Reg4FourFours(OP_EOR_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1087     }
1088 
1089     // xor is not spelled with an &#39;e&#39;. :-(
1090     void eor(RegisterID rd, RegisterID rn, RegisterID rm)
1091     {
1092         if ((rd == rn) &amp;&amp; !((rd | rm) &amp; 8))
1093             m_formatter.oneWordOp10Reg3Reg3(OP_EOR_reg_T1, rm, rd);
1094         else if ((rd == rm) &amp;&amp; !((rd | rn) &amp; 8))
1095             m_formatter.oneWordOp10Reg3Reg3(OP_EOR_reg_T1, rn, rd);
1096         else
1097             eor(rd, rn, rm, ShiftTypeAndAmount());
1098     }
1099 
1100     ALWAYS_INLINE void it(Condition cond)
1101     {
1102         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond));
1103     }
1104 
1105     ALWAYS_INLINE void it(Condition cond, bool inst2if)
1106     {
1107         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond, inst2if));
1108     }
1109 
1110     ALWAYS_INLINE void it(Condition cond, bool inst2if, bool inst3if)
1111     {
1112         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond, inst2if, inst3if));
1113     }
1114 
1115     ALWAYS_INLINE void it(Condition cond, bool inst2if, bool inst3if, bool inst4if)
1116     {
1117         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond, inst2if, inst3if, inst4if));
1118     }
1119 
1120     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1121     ALWAYS_INLINE void ldr(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
1122     {
1123         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
1124         ASSERT(imm.isUInt12());
1125 
1126         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt7())
1127             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDR_imm_T1, imm.getUInt7() &gt;&gt; 2, rn, rt);
1128         else if ((rn == ARMRegisters::sp) &amp;&amp; !(rt &amp; 8) &amp;&amp; imm.isUInt10())
1129             m_formatter.oneWordOp5Reg3Imm8(OP_LDR_imm_T2, rt, static_cast&lt;uint8_t&gt;(imm.getUInt10() &gt;&gt; 2));
1130         else
1131             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T3, rn, rt, imm.getUInt12());
1132     }
1133 
1134     ALWAYS_INLINE void ldrWide8BitImmediate(RegisterID rt, RegisterID rn, uint8_t immediate)
1135     {
1136         ASSERT(rn != ARMRegisters::pc);
1137         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T3, rn, rt, immediate);
1138     }
1139 
1140     ALWAYS_INLINE void ldrCompact(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
1141     {
1142         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
1143         ASSERT(imm.isUInt7());
1144         ASSERT(!((rt | rn) &amp; 8));
1145         m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDR_imm_T1, imm.getUInt7() &gt;&gt; 2, rn, rt);
1146     }
1147 
1148     // If index is set, this is a regular offset or a pre-indexed load;
1149     // if index is not set then is is a post-index load.
1150     //
1151     // If wback is set rn is updated - this is a pre or post index load,
1152     // if wback is not set this is a regular offset memory access.
1153     //
1154     // (-255 &lt;= offset &lt;= 255)
1155     // _reg = REG[rn]
1156     // _tmp = _reg + offset
1157     // MEM[index ? _tmp : _reg] = REG[rt]
1158     // if (wback) REG[rn] = _tmp
1159     ALWAYS_INLINE void ldr(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
1160     {
1161         ASSERT(rt != ARMRegisters::pc);
1162         ASSERT(rn != ARMRegisters::pc);
1163         ASSERT(index || wback);
1164         ASSERT(!wback | (rt != rn));
1165 
1166         bool add = true;
1167         if (offset &lt; 0) {
1168             add = false;
1169             offset = -offset;
1170         }
1171         ASSERT((offset &amp; ~0xff) == 0);
1172 
1173         offset |= (wback &lt;&lt; 8);
1174         offset |= (add   &lt;&lt; 9);
1175         offset |= (index &lt;&lt; 10);
1176         offset |= (1 &lt;&lt; 11);
1177 
1178         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T4, rn, rt, offset);
1179     }
1180 
1181     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1182     ALWAYS_INLINE void ldr(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1183     {
1184         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
1185         ASSERT(!BadReg(rm));
1186         ASSERT(shift &lt;= 3);
1187 
1188         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1189             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDR_reg_T1, rm, rn, rt);
1190         else
1191             m_formatter.twoWordOp12Reg4FourFours(OP_LDR_reg_T2, rn, FourFours(rt, 0, shift, rm));
1192     }
1193 
1194     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1195     ALWAYS_INLINE void ldrh(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
1196     {
1197         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
1198         ASSERT(imm.isUInt12());
1199         ASSERT(!(imm.getUInt12() &amp; 1));
1200 
1201         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt6())
1202             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDRH_imm_T1, imm.getUInt6() &gt;&gt; 1, rn, rt);
1203         else
1204             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRH_imm_T2, rn, rt, imm.getUInt12());
1205     }
1206 
1207     // If index is set, this is a regular offset or a pre-indexed load;
1208     // if index is not set then is is a post-index load.
1209     //
1210     // If wback is set rn is updated - this is a pre or post index load,
1211     // if wback is not set this is a regular offset memory access.
1212     //
1213     // (-255 &lt;= offset &lt;= 255)
1214     // _reg = REG[rn]
1215     // _tmp = _reg + offset
1216     // MEM[index ? _tmp : _reg] = REG[rt]
1217     // if (wback) REG[rn] = _tmp
1218     ALWAYS_INLINE void ldrh(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
1219     {
1220         ASSERT(rt != ARMRegisters::pc);
1221         ASSERT(rn != ARMRegisters::pc);
1222         ASSERT(index || wback);
1223         ASSERT(!wback | (rt != rn));
1224 
1225         bool add = true;
1226         if (offset &lt; 0) {
1227             add = false;
1228             offset = -offset;
1229         }
1230         ASSERT((offset &amp; ~0xff) == 0);
1231 
1232         offset |= (wback &lt;&lt; 8);
1233         offset |= (add   &lt;&lt; 9);
1234         offset |= (index &lt;&lt; 10);
1235         offset |= (1 &lt;&lt; 11);
1236 
1237         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRH_imm_T3, rn, rt, offset);
1238     }
1239 
1240     ALWAYS_INLINE void ldrh(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1241     {
1242         ASSERT(!BadReg(rt));   // Memory hint
1243         ASSERT(rn != ARMRegisters::pc); // LDRH (literal)
1244         ASSERT(!BadReg(rm));
1245         ASSERT(shift &lt;= 3);
1246 
1247         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1248             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDRH_reg_T1, rm, rn, rt);
1249         else
1250             m_formatter.twoWordOp12Reg4FourFours(OP_LDRH_reg_T2, rn, FourFours(rt, 0, shift, rm));
1251     }
1252 
1253     void ldrb(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
1254     {
1255         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
1256         ASSERT(imm.isUInt12());
1257 
1258         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt5())
1259             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDRB_imm_T1, imm.getUInt5(), rn, rt);
1260         else
1261             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRB_imm_T2, rn, rt, imm.getUInt12());
1262     }
1263 
1264     void ldrb(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
1265     {
1266         ASSERT(rt != ARMRegisters::pc);
1267         ASSERT(rn != ARMRegisters::pc);
1268         ASSERT(index || wback);
1269         ASSERT(!wback | (rt != rn));
1270 
1271         bool add = true;
1272         if (offset &lt; 0) {
1273             add = false;
1274             offset = -offset;
1275         }
1276 
1277         ASSERT(!(offset &amp; ~0xff));
1278 
1279         offset |= (wback &lt;&lt; 8);
1280         offset |= (add   &lt;&lt; 9);
1281         offset |= (index &lt;&lt; 10);
1282         offset |= (1 &lt;&lt; 11);
1283 
1284         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRB_imm_T3, rn, rt, offset);
1285     }
1286 
1287     ALWAYS_INLINE void ldrb(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1288     {
1289         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
1290         ASSERT(!BadReg(rm));
1291         ASSERT(shift &lt;= 3);
1292 
1293         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1294             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDRB_reg_T1, rm, rn, rt);
1295         else
1296             m_formatter.twoWordOp12Reg4FourFours(OP_LDRB_reg_T2, rn, FourFours(rt, 0, shift, rm));
1297     }
1298 
1299     void ldrsb(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1300     {
1301         ASSERT(rn != ARMRegisters::pc);
1302         ASSERT(!BadReg(rm));
1303         ASSERT(shift &lt;= 3);
1304 
1305         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1306             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDRSB_reg_T1, rm, rn, rt);
1307         else
1308             m_formatter.twoWordOp12Reg4FourFours(OP_LDRSB_reg_T2, rn, FourFours(rt, 0, shift, rm));
1309     }
1310 
1311     void ldrsh(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1312     {
1313         ASSERT(rn != ARMRegisters::pc);
1314         ASSERT(!BadReg(rm));
1315         ASSERT(shift &lt;= 3);
1316 
1317         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1318             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDRSH_reg_T1, rm, rn, rt);
1319         else
1320             m_formatter.twoWordOp12Reg4FourFours(OP_LDRSH_reg_T2, rn, FourFours(rt, 0, shift, rm));
1321     }
1322 
1323     void lsl(RegisterID rd, RegisterID rm, int32_t shiftAmount)
1324     {
1325         ASSERT(!BadReg(rd));
1326         ASSERT(!BadReg(rm));
1327         ShiftTypeAndAmount shift(SRType_LSL, shiftAmount);
1328         m_formatter.twoWordOp16FourFours(OP_LSL_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1329     }
1330 
1331     ALWAYS_INLINE void lsl(RegisterID rd, RegisterID rn, RegisterID rm)
1332     {
1333         ASSERT(!BadReg(rd));
1334         ASSERT(!BadReg(rn));
1335         ASSERT(!BadReg(rm));
1336         m_formatter.twoWordOp12Reg4FourFours(OP_LSL_reg_T2, rn, FourFours(0xf, rd, 0, rm));
1337     }
1338 
1339     ALWAYS_INLINE void lsr(RegisterID rd, RegisterID rm, int32_t shiftAmount)
1340     {
1341         ASSERT(!BadReg(rd));
1342         ASSERT(!BadReg(rm));
1343         ShiftTypeAndAmount shift(SRType_LSR, shiftAmount);
1344         m_formatter.twoWordOp16FourFours(OP_LSR_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1345     }
1346 
1347     ALWAYS_INLINE void lsr(RegisterID rd, RegisterID rn, RegisterID rm)
1348     {
1349         ASSERT(!BadReg(rd));
1350         ASSERT(!BadReg(rn));
1351         ASSERT(!BadReg(rm));
1352         m_formatter.twoWordOp12Reg4FourFours(OP_LSR_reg_T2, rn, FourFours(0xf, rd, 0, rm));
1353     }
1354 
1355     ALWAYS_INLINE void movT3(RegisterID rd, ARMThumbImmediate imm)
1356     {
1357         ASSERT(imm.isValid());
1358         ASSERT(!imm.isEncodedImm());
1359         ASSERT(!BadReg(rd));
1360 
1361         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MOV_imm_T3, imm.m_value.imm4, rd, imm);
1362     }
1363 
1364 #if OS(LINUX)
1365     static void revertJumpTo_movT3movtcmpT2(void* instructionStart, RegisterID left, RegisterID right, uintptr_t imm)
1366     {
1367         uint16_t* address = static_cast&lt;uint16_t*&gt;(instructionStart);
1368         ARMThumbImmediate lo16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(imm));
1369         ARMThumbImmediate hi16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(imm &gt;&gt; 16));
1370         uint16_t instruction[] = {
1371             twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOV_imm_T3, lo16),
1372             twoWordOp5i6Imm4Reg4EncodedImmSecond(right, lo16),
1373             twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOVT, hi16),
1374             twoWordOp5i6Imm4Reg4EncodedImmSecond(right, hi16),
1375             static_cast&lt;uint16_t&gt;(OP_CMP_reg_T2 | left)
1376         };
1377         performJITMemcpy(address, instruction, sizeof(uint16_t) * 5);
1378         cacheFlush(address, sizeof(uint16_t) * 5);
1379     }
1380 #else
1381     static void revertJumpTo_movT3(void* instructionStart, RegisterID rd, ARMThumbImmediate imm)
1382     {
1383         ASSERT(imm.isValid());
1384         ASSERT(!imm.isEncodedImm());
1385         ASSERT(!BadReg(rd));
1386 
1387         uint16_t* address = static_cast&lt;uint16_t*&gt;(instructionStart);
1388         uint16_t instruction[] = {
1389             twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOV_imm_T3, imm),
1390             twoWordOp5i6Imm4Reg4EncodedImmSecond(rd, imm)
1391         };
1392         performJITMemcpy(address, instruction, sizeof(uint16_t) * 2);
1393         cacheFlush(address, sizeof(uint16_t) * 2);
1394     }
1395 #endif
1396 
1397     ALWAYS_INLINE void mov(RegisterID rd, ARMThumbImmediate imm)
1398     {
1399         ASSERT(imm.isValid());
1400         ASSERT(!BadReg(rd));
1401 
1402         if ((rd &lt; 8) &amp;&amp; imm.isUInt8())
1403             m_formatter.oneWordOp5Reg3Imm8(OP_MOV_imm_T1, rd, imm.getUInt8());
1404         else if (imm.isEncodedImm())
1405             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MOV_imm_T2, 0xf, rd, imm);
1406         else
1407             movT3(rd, imm);
1408     }
1409 
1410     ALWAYS_INLINE void mov(RegisterID rd, RegisterID rm)
1411     {
1412         m_formatter.oneWordOp8RegReg143(OP_MOV_reg_T1, rm, rd);
1413     }
1414 
1415     ALWAYS_INLINE void movt(RegisterID rd, ARMThumbImmediate imm)
1416     {
1417         ASSERT(imm.isUInt16());
1418         ASSERT(!BadReg(rd));
1419         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MOVT, imm.m_value.imm4, rd, imm);
1420     }
1421 
1422     ALWAYS_INLINE void mvn(RegisterID rd, ARMThumbImmediate imm)
1423     {
1424         ASSERT(imm.isEncodedImm());
1425         ASSERT(!BadReg(rd));
1426 
1427         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MVN_imm, 0xf, rd, imm);
1428     }
1429 
1430     ALWAYS_INLINE void mvn(RegisterID rd, RegisterID rm, ShiftTypeAndAmount shift)
1431     {
1432         ASSERT(!BadReg(rd));
1433         ASSERT(!BadReg(rm));
1434         m_formatter.twoWordOp16FourFours(OP_MVN_reg_T2, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1435     }
1436 
1437     ALWAYS_INLINE void mvn(RegisterID rd, RegisterID rm)
1438     {
1439         if (!((rd | rm) &amp; 8))
1440             m_formatter.oneWordOp10Reg3Reg3(OP_MVN_reg_T1, rm, rd);
1441         else
1442             mvn(rd, rm, ShiftTypeAndAmount());
1443     }
1444 
1445     ALWAYS_INLINE void mrs(RegisterID rd, SPRegisterID specReg)
1446     {
1447         ASSERT(specReg == ARMRegisters::apsr);
1448         ASSERT(!BadReg(rd));
1449         unsigned short specialRegisterBit = (specReg == ARMRegisters::apsr) ? 0 : (1 &lt;&lt; 4);
1450         OpcodeID1 mrsOp = static_cast&lt;OpcodeID1&gt;(OP_MRS_T1 | specialRegisterBit);
1451         m_formatter.twoWordOp16FourFours(mrsOp, FourFours(0x8, rd, 0, 0));
1452     }
1453 
1454     ALWAYS_INLINE void neg(RegisterID rd, RegisterID rm)
1455     {
1456         ARMThumbImmediate zero = ARMThumbImmediate::makeUInt12(0);
1457         sub(rd, zero, rm);
1458     }
1459 
1460     ALWAYS_INLINE void orr(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
1461     {
1462         ASSERT(!BadReg(rd));
1463         ASSERT(!BadReg(rn));
1464         ASSERT(imm.isEncodedImm());
1465         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ORR_imm_T1, rn, rd, imm);
1466     }
1467 
1468     ALWAYS_INLINE void orr(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
1469     {
1470         ASSERT(!BadReg(rd));
1471         ASSERT(!BadReg(rn));
1472         ASSERT(!BadReg(rm));
1473         m_formatter.twoWordOp12Reg4FourFours(OP_ORR_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1474     }
1475 
1476     void orr(RegisterID rd, RegisterID rn, RegisterID rm)
1477     {
1478         if ((rd == rn) &amp;&amp; !((rd | rm) &amp; 8))
1479             m_formatter.oneWordOp10Reg3Reg3(OP_ORR_reg_T1, rm, rd);
1480         else if ((rd == rm) &amp;&amp; !((rd | rn) &amp; 8))
1481             m_formatter.oneWordOp10Reg3Reg3(OP_ORR_reg_T1, rn, rd);
1482         else
1483             orr(rd, rn, rm, ShiftTypeAndAmount());
1484     }
1485 
1486     ALWAYS_INLINE void orr_S(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
1487     {
1488         ASSERT(!BadReg(rd));
1489         ASSERT(!BadReg(rn));
1490         ASSERT(!BadReg(rm));
1491         m_formatter.twoWordOp12Reg4FourFours(OP_ORR_S_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1492     }
1493 
1494     void orr_S(RegisterID rd, RegisterID rn, RegisterID rm)
1495     {
1496         if ((rd == rn) &amp;&amp; !((rd | rm) &amp; 8))
1497             m_formatter.oneWordOp10Reg3Reg3(OP_ORR_reg_T1, rm, rd);
1498         else if ((rd == rm) &amp;&amp; !((rd | rn) &amp; 8))
1499             m_formatter.oneWordOp10Reg3Reg3(OP_ORR_reg_T1, rn, rd);
1500         else
1501             orr_S(rd, rn, rm, ShiftTypeAndAmount());
1502     }
1503 
1504     ALWAYS_INLINE void ror(RegisterID rd, RegisterID rm, int32_t shiftAmount)
1505     {
1506         ASSERT(!BadReg(rd));
1507         ASSERT(!BadReg(rm));
1508         ShiftTypeAndAmount shift(SRType_ROR, shiftAmount);
1509         m_formatter.twoWordOp16FourFours(OP_ROR_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1510     }
1511 
1512     ALWAYS_INLINE void ror(RegisterID rd, RegisterID rn, RegisterID rm)
1513     {
1514         ASSERT(!BadReg(rd));
1515         ASSERT(!BadReg(rn));
1516         ASSERT(!BadReg(rm));
1517         m_formatter.twoWordOp12Reg4FourFours(OP_ROR_reg_T2, rn, FourFours(0xf, rd, 0, rm));
1518     }
1519 
1520     ALWAYS_INLINE void pop(RegisterID dest)
1521     {
1522         if (dest &lt; ARMRegisters::r8)
1523             m_formatter.oneWordOp7Imm9(OP_POP_T1, 1 &lt;&lt; dest);
1524         else {
1525             // Load postindexed with writeback.
1526             ldr(dest, ARMRegisters::sp, sizeof(void*), false, true);
1527         }
1528     }
1529 
1530     ALWAYS_INLINE void pop(uint32_t registerList)
1531     {
1532         ASSERT(WTF::bitCount(registerList) &gt; 1);
1533         ASSERT(!((1 &lt;&lt; ARMRegisters::pc) &amp; registerList) || !((1 &lt;&lt; ARMRegisters::lr) &amp; registerList));
1534         ASSERT(!((1 &lt;&lt; ARMRegisters::sp) &amp; registerList));
1535         m_formatter.twoWordOp16Imm16(OP_POP_T2, registerList);
1536     }
1537 
1538     ALWAYS_INLINE void push(RegisterID src)
1539     {
1540         if (src &lt; ARMRegisters::r8)
1541             m_formatter.oneWordOp7Imm9(OP_PUSH_T1, 1 &lt;&lt; src);
1542         else if (src == ARMRegisters::lr)
1543             m_formatter.oneWordOp7Imm9(OP_PUSH_T1, 0x100);
1544         else {
1545             // Store preindexed with writeback.
1546             str(src, ARMRegisters::sp, -sizeof(void*), true, true);
1547         }
1548     }
1549 
1550     ALWAYS_INLINE void push(uint32_t registerList)
1551     {
1552         ASSERT(WTF::bitCount(registerList) &gt; 1);
1553         ASSERT(!((1 &lt;&lt; ARMRegisters::pc) &amp; registerList));
1554         ASSERT(!((1 &lt;&lt; ARMRegisters::sp) &amp; registerList));
1555         m_formatter.twoWordOp16Imm16(OP_PUSH_T2, registerList);
1556     }
1557 
1558 #if HAVE(ARM_IDIV_INSTRUCTIONS)
1559     template&lt;int datasize&gt;
1560     ALWAYS_INLINE void sdiv(RegisterID rd, RegisterID rn, RegisterID rm)
1561     {
1562         static_assert(datasize == 32, &quot;sdiv datasize must be 32 for armv7s&quot;);
1563         ASSERT(!BadReg(rd));
1564         ASSERT(!BadReg(rn));
1565         ASSERT(!BadReg(rm));
1566         m_formatter.twoWordOp12Reg4FourFours(OP_SDIV_T1, rn, FourFours(0xf, rd, 0xf, rm));
1567     }
1568 #endif
1569 
1570     ALWAYS_INLINE void smull(RegisterID rdLo, RegisterID rdHi, RegisterID rn, RegisterID rm)
1571     {
1572         ASSERT(!BadReg(rdLo));
1573         ASSERT(!BadReg(rdHi));
1574         ASSERT(!BadReg(rn));
1575         ASSERT(!BadReg(rm));
1576         ASSERT(rdLo != rdHi);
1577         m_formatter.twoWordOp12Reg4FourFours(OP_SMULL_T1, rn, FourFours(rdLo, rdHi, 0, rm));
1578     }
1579 
1580     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1581     ALWAYS_INLINE void str(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
1582     {
1583         ASSERT(rt != ARMRegisters::pc);
1584         ASSERT(rn != ARMRegisters::pc);
1585         ASSERT(imm.isUInt12());
1586 
1587         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt7())
1588             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_STR_imm_T1, imm.getUInt7() &gt;&gt; 2, rn, rt);
1589         else if ((rn == ARMRegisters::sp) &amp;&amp; !(rt &amp; 8) &amp;&amp; imm.isUInt10())
1590             m_formatter.oneWordOp5Reg3Imm8(OP_STR_imm_T2, rt, static_cast&lt;uint8_t&gt;(imm.getUInt10() &gt;&gt; 2));
1591         else
1592             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STR_imm_T3, rn, rt, imm.getUInt12());
1593     }
1594 
1595     // If index is set, this is a regular offset or a pre-indexed store;
1596     // if index is not set then is is a post-index store.
1597     //
1598     // If wback is set rn is updated - this is a pre or post index store,
1599     // if wback is not set this is a regular offset memory access.
1600     //
1601     // (-255 &lt;= offset &lt;= 255)
1602     // _reg = REG[rn]
1603     // _tmp = _reg + offset
1604     // MEM[index ? _tmp : _reg] = REG[rt]
1605     // if (wback) REG[rn] = _tmp
1606     ALWAYS_INLINE void str(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
1607     {
1608         ASSERT(rt != ARMRegisters::pc);
1609         ASSERT(rn != ARMRegisters::pc);
1610         ASSERT(index || wback);
1611         ASSERT(!wback | (rt != rn));
1612 
1613         bool add = true;
1614         if (offset &lt; 0) {
1615             add = false;
1616             offset = -offset;
1617         }
1618         ASSERT((offset &amp; ~0xff) == 0);
1619 
1620         offset |= (wback &lt;&lt; 8);
1621         offset |= (add   &lt;&lt; 9);
1622         offset |= (index &lt;&lt; 10);
1623         offset |= (1 &lt;&lt; 11);
1624 
1625         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STR_imm_T4, rn, rt, offset);
1626     }
1627 
1628     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1629     ALWAYS_INLINE void str(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1630     {
1631         ASSERT(rn != ARMRegisters::pc);
1632         ASSERT(!BadReg(rm));
1633         ASSERT(shift &lt;= 3);
1634 
1635         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1636             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_STR_reg_T1, rm, rn, rt);
1637         else
1638             m_formatter.twoWordOp12Reg4FourFours(OP_STR_reg_T2, rn, FourFours(rt, 0, shift, rm));
1639     }
1640 
1641     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1642     ALWAYS_INLINE void strb(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
1643     {
1644         ASSERT(rt != ARMRegisters::pc);
1645         ASSERT(rn != ARMRegisters::pc);
1646         ASSERT(imm.isUInt12());
1647 
1648         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt7())
1649             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_STRB_imm_T1, imm.getUInt7() &gt;&gt; 2, rn, rt);
1650         else
1651             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STRB_imm_T2, rn, rt, imm.getUInt12());
1652     }
1653 
1654     // If index is set, this is a regular offset or a pre-indexed store;
1655     // if index is not set then is is a post-index store.
1656     //
1657     // If wback is set rn is updated - this is a pre or post index store,
1658     // if wback is not set this is a regular offset memory access.
1659     //
1660     // (-255 &lt;= offset &lt;= 255)
1661     // _reg = REG[rn]
1662     // _tmp = _reg + offset
1663     // MEM[index ? _tmp : _reg] = REG[rt]
1664     // if (wback) REG[rn] = _tmp
1665     ALWAYS_INLINE void strb(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
1666     {
1667         ASSERT(rt != ARMRegisters::pc);
1668         ASSERT(rn != ARMRegisters::pc);
1669         ASSERT(index || wback);
1670         ASSERT(!wback | (rt != rn));
1671 
1672         bool add = true;
1673         if (offset &lt; 0) {
1674             add = false;
1675             offset = -offset;
1676         }
1677         ASSERT((offset &amp; ~0xff) == 0);
1678 
1679         offset |= (wback &lt;&lt; 8);
1680         offset |= (add   &lt;&lt; 9);
1681         offset |= (index &lt;&lt; 10);
1682         offset |= (1 &lt;&lt; 11);
1683 
1684         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STRB_imm_T3, rn, rt, offset);
1685     }
1686 
1687     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1688     ALWAYS_INLINE void strb(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1689     {
1690         ASSERT(rn != ARMRegisters::pc);
1691         ASSERT(!BadReg(rm));
1692         ASSERT(shift &lt;= 3);
1693 
1694         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1695             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_STRB_reg_T1, rm, rn, rt);
1696         else
1697             m_formatter.twoWordOp12Reg4FourFours(OP_STRB_reg_T2, rn, FourFours(rt, 0, shift, rm));
1698     }
1699 
1700     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1701     ALWAYS_INLINE void strh(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
1702     {
1703         ASSERT(rt != ARMRegisters::pc);
1704         ASSERT(rn != ARMRegisters::pc);
1705         ASSERT(imm.isUInt12());
1706 
1707         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt6())
1708             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_STRH_imm_T1, imm.getUInt6() &gt;&gt; 1, rn, rt);
1709         else
1710             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STRH_imm_T2, rn, rt, imm.getUInt12());
1711     }
1712 
1713     // If index is set, this is a regular offset or a pre-indexed store;
1714     // if index is not set then is is a post-index store.
1715     //
1716     // If wback is set rn is updated - this is a pre or post index store,
1717     // if wback is not set this is a regular offset memory access.
1718     //
1719     // (-255 &lt;= offset &lt;= 255)
1720     // _reg = REG[rn]
1721     // _tmp = _reg + offset
1722     // MEM[index ? _tmp : _reg] = REG[rt]
1723     // if (wback) REG[rn] = _tmp
1724     ALWAYS_INLINE void strh(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
1725     {
1726         ASSERT(rt != ARMRegisters::pc);
1727         ASSERT(rn != ARMRegisters::pc);
1728         ASSERT(index || wback);
1729         ASSERT(!wback | (rt != rn));
1730 
1731         bool add = true;
1732         if (offset &lt; 0) {
1733             add = false;
1734             offset = -offset;
1735         }
1736         ASSERT(!(offset &amp; ~0xff));
1737 
1738         offset |= (wback &lt;&lt; 8);
1739         offset |= (add   &lt;&lt; 9);
1740         offset |= (index &lt;&lt; 10);
1741         offset |= (1 &lt;&lt; 11);
1742 
1743         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STRH_imm_T3, rn, rt, offset);
1744     }
1745 
1746     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
1747     ALWAYS_INLINE void strh(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
1748     {
1749         ASSERT(rn != ARMRegisters::pc);
1750         ASSERT(!BadReg(rm));
1751         ASSERT(shift &lt;= 3);
1752 
1753         if (!shift &amp;&amp; !((rt | rn | rm) &amp; 8))
1754             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_STRH_reg_T1, rm, rn, rt);
1755         else
1756             m_formatter.twoWordOp12Reg4FourFours(OP_STRH_reg_T2, rn, FourFours(rt, 0, shift, rm));
1757     }
1758 
1759     ALWAYS_INLINE void sub(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
1760     {
1761         // Rd can only be SP if Rn is also SP.
1762         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
1763         ASSERT(rd != ARMRegisters::pc);
1764         ASSERT(rn != ARMRegisters::pc);
1765         ASSERT(imm.isValid());
1766 
1767         if ((rn == ARMRegisters::sp) &amp;&amp; (rd == ARMRegisters::sp) &amp;&amp; imm.isUInt9()) {
1768             ASSERT(!(imm.getUInt16() &amp; 3));
1769             m_formatter.oneWordOp9Imm7(OP_SUB_SP_imm_T1, static_cast&lt;uint8_t&gt;(imm.getUInt9() &gt;&gt; 2));
1770             return;
1771         } else if (!((rd | rn) &amp; 8)) {
1772             if (imm.isUInt3()) {
1773                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
1774                 return;
1775             } else if ((rd == rn) &amp;&amp; imm.isUInt8()) {
1776                 m_formatter.oneWordOp5Reg3Imm8(OP_SUB_imm_T2, rd, imm.getUInt8());
1777                 return;
1778             }
1779         }
1780 
1781         if (imm.isEncodedImm())
1782             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_SUB_imm_T3, rn, rd, imm);
1783         else {
1784             ASSERT(imm.isUInt12());
1785             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_SUB_imm_T4, rn, rd, imm);
1786         }
1787     }
1788 
1789     ALWAYS_INLINE void sub(RegisterID rd, ARMThumbImmediate imm, RegisterID rn)
1790     {
1791         ASSERT(rd != ARMRegisters::pc);
1792         ASSERT(rn != ARMRegisters::pc);
1793         ASSERT(imm.isValid());
1794         ASSERT(imm.isUInt12());
1795 
1796         if (!((rd | rn) &amp; 8) &amp;&amp; !imm.getUInt12())
1797             m_formatter.oneWordOp10Reg3Reg3(OP_RSB_imm_T1, rn, rd);
1798         else
1799             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_RSB_imm_T2, rn, rd, imm);
1800     }
1801 
1802     ALWAYS_INLINE void sub(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
1803     {
1804         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
1805         ASSERT(rd != ARMRegisters::pc);
1806         ASSERT(rn != ARMRegisters::pc);
1807         ASSERT(!BadReg(rm));
1808         m_formatter.twoWordOp12Reg4FourFours(OP_SUB_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1809     }
1810 
1811     // NOTE: In an IT block, add doesn&#39;t modify the flags register.
1812     ALWAYS_INLINE void sub(RegisterID rd, RegisterID rn, RegisterID rm)
1813     {
1814         if (!((rd | rn | rm) &amp; 8))
1815             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_reg_T1, rm, rn, rd);
1816         else
1817             sub(rd, rn, rm, ShiftTypeAndAmount());
1818     }
1819 
1820     // Not allowed in an IT (if then) block.
1821     void sub_S(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
1822     {
1823         // Rd can only be SP if Rn is also SP.
1824         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
1825         ASSERT(rd != ARMRegisters::pc);
1826         ASSERT(rn != ARMRegisters::pc);
1827         ASSERT(imm.isValid());
1828 
1829         if ((rn == ARMRegisters::sp) &amp;&amp; (rd == ARMRegisters::sp) &amp;&amp; imm.isUInt9()) {
1830             ASSERT(!(imm.getUInt16() &amp; 3));
1831             m_formatter.oneWordOp9Imm7(OP_SUB_SP_imm_T1, static_cast&lt;uint8_t&gt;(imm.getUInt9() &gt;&gt; 2));
1832             return;
1833         } else if (!((rd | rn) &amp; 8)) {
1834             if (imm.isUInt3()) {
1835                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
1836                 return;
1837             } else if ((rd == rn) &amp;&amp; imm.isUInt8()) {
1838                 m_formatter.oneWordOp5Reg3Imm8(OP_SUB_imm_T2, rd, imm.getUInt8());
1839                 return;
1840             }
1841         }
1842 
1843         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_SUB_S_imm_T3, rn, rd, imm);
1844     }
1845 
1846     ALWAYS_INLINE void sub_S(RegisterID rd, ARMThumbImmediate imm, RegisterID rn)
1847     {
1848         ASSERT(rd != ARMRegisters::pc);
1849         ASSERT(rn != ARMRegisters::pc);
1850         ASSERT(imm.isValid());
1851         ASSERT(imm.isUInt12());
1852 
1853         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_RSB_S_imm_T2, rn, rd, imm);
1854     }
1855 
1856     // Not allowed in an IT (if then) block?
1857     ALWAYS_INLINE void sub_S(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
1858     {
1859         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
1860         ASSERT(rd != ARMRegisters::pc);
1861         ASSERT(rn != ARMRegisters::pc);
1862         ASSERT(!BadReg(rm));
1863         m_formatter.twoWordOp12Reg4FourFours(OP_SUB_S_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
1864     }
1865 
1866     // Not allowed in an IT (if then) block.
1867     ALWAYS_INLINE void sub_S(RegisterID rd, RegisterID rn, RegisterID rm)
1868     {
1869         if (!((rd | rn | rm) &amp; 8))
1870             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_reg_T1, rm, rn, rd);
1871         else
1872             sub_S(rd, rn, rm, ShiftTypeAndAmount());
1873     }
1874 
1875     ALWAYS_INLINE void tst(RegisterID rn, ARMThumbImmediate imm)
1876     {
1877         ASSERT(!BadReg(rn));
1878         ASSERT(imm.isEncodedImm());
1879 
1880         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_TST_imm, rn, (RegisterID)0xf, imm);
1881     }
1882 
1883     ALWAYS_INLINE void tst(RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
1884     {
1885         ASSERT(!BadReg(rn));
1886         ASSERT(!BadReg(rm));
1887         m_formatter.twoWordOp12Reg4FourFours(OP_TST_reg_T2, rn, FourFours(shift.hi4(), 0xf, shift.lo4(), rm));
1888     }
1889 
1890     ALWAYS_INLINE void tst(RegisterID rn, RegisterID rm)
1891     {
1892         if ((rn | rm) &amp; 8)
1893             tst(rn, rm, ShiftTypeAndAmount());
1894         else
1895             m_formatter.oneWordOp10Reg3Reg3(OP_TST_reg_T1, rm, rn);
1896     }
1897 
1898     ALWAYS_INLINE void ubfx(RegisterID rd, RegisterID rn, unsigned lsb, unsigned width)
1899     {
1900         ASSERT(lsb &lt; 32);
1901         ASSERT((width &gt;= 1) &amp;&amp; (width &lt;= 32));
1902         ASSERT((lsb + width) &lt;= 32);
1903         m_formatter.twoWordOp12Reg40Imm3Reg4Imm20Imm5(OP_UBFX_T1, rd, rn, (lsb &amp; 0x1c) &lt;&lt; 10, (lsb &amp; 0x3) &lt;&lt; 6, (width - 1) &amp; 0x1f);
1904     }
1905 
1906 #if HAVE(ARM_IDIV_INSTRUCTIONS)
1907     ALWAYS_INLINE void udiv(RegisterID rd, RegisterID rn, RegisterID rm)
1908     {
1909         ASSERT(!BadReg(rd));
1910         ASSERT(!BadReg(rn));
1911         ASSERT(!BadReg(rm));
1912         m_formatter.twoWordOp12Reg4FourFours(OP_UDIV_T1, rn, FourFours(0xf, rd, 0xf, rm));
1913     }
1914 #endif
1915 
1916     void vadd(FPDoubleRegisterID rd, FPDoubleRegisterID rn, FPDoubleRegisterID rm)
1917     {
1918         m_formatter.vfpOp(OP_VADD_T2, OP_VADD_T2b, true, rn, rd, rm);
1919     }
1920 
1921     void vcmp(FPDoubleRegisterID rd, FPDoubleRegisterID rm)
1922     {
1923         m_formatter.vfpOp(OP_VCMP, OP_VCMPb, true, VFPOperand(4), rd, rm);
1924     }
1925 
1926     void vcmpz(FPDoubleRegisterID rd)
1927     {
1928         m_formatter.vfpOp(OP_VCMP, OP_VCMPb, true, VFPOperand(5), rd, VFPOperand(0));
1929     }
1930 
1931     void vcvt_signedToFloatingPoint(FPDoubleRegisterID rd, FPSingleRegisterID rm)
1932     {
1933         // boolean values are 64bit (toInt, unsigned, roundZero)
1934         m_formatter.vfpOp(OP_VCVT_FPIVFP, OP_VCVT_FPIVFPb, true, vcvtOp(false, false, false), rd, rm);
1935     }
1936 
1937     void vcvt_floatingPointToSigned(FPSingleRegisterID rd, FPDoubleRegisterID rm)
1938     {
1939         // boolean values are 64bit (toInt, unsigned, roundZero)
1940         m_formatter.vfpOp(OP_VCVT_FPIVFP, OP_VCVT_FPIVFPb, true, vcvtOp(true, false, true), rd, rm);
1941     }
1942 
1943     void vcvt_floatingPointToUnsigned(FPSingleRegisterID rd, FPDoubleRegisterID rm)
1944     {
1945         // boolean values are 64bit (toInt, unsigned, roundZero)
1946         m_formatter.vfpOp(OP_VCVT_FPIVFP, OP_VCVT_FPIVFPb, true, vcvtOp(true, true, true), rd, rm);
1947     }
1948 
1949     void vdiv(FPDoubleRegisterID rd, FPDoubleRegisterID rn, FPDoubleRegisterID rm)
1950     {
1951         m_formatter.vfpOp(OP_VDIV, OP_VDIVb, true, rn, rd, rm);
1952     }
1953 
1954     void vldr(FPDoubleRegisterID rd, RegisterID rn, int32_t imm)
1955     {
1956         m_formatter.vfpMemOp(OP_VLDR, OP_VLDRb, true, rn, rd, imm);
1957     }
1958 
1959     void flds(FPSingleRegisterID rd, RegisterID rn, int32_t imm)
1960     {
1961         m_formatter.vfpMemOp(OP_FLDS, OP_FLDSb, false, rn, rd, imm);
1962     }
1963 
1964     void vmov(RegisterID rd, FPSingleRegisterID rn)
1965     {
1966         ASSERT(!BadReg(rd));
1967         m_formatter.vfpOp(OP_VMOV_StoC, OP_VMOV_StoCb, false, rn, rd, VFPOperand(0));
1968     }
1969 
1970     void vmov(FPSingleRegisterID rd, RegisterID rn)
1971     {
1972         ASSERT(!BadReg(rn));
1973         m_formatter.vfpOp(OP_VMOV_CtoS, OP_VMOV_CtoSb, false, rd, rn, VFPOperand(0));
1974     }
1975 
1976     void vmov(RegisterID rd1, RegisterID rd2, FPDoubleRegisterID rn)
1977     {
1978         ASSERT(!BadReg(rd1));
1979         ASSERT(!BadReg(rd2));
1980         m_formatter.vfpOp(OP_VMOV_DtoC, OP_VMOV_DtoCb, true, rd2, VFPOperand(rd1 | 16), rn);
1981     }
1982 
1983     void vmov(FPDoubleRegisterID rd, RegisterID rn1, RegisterID rn2)
1984     {
1985         ASSERT(!BadReg(rn1));
1986         ASSERT(!BadReg(rn2));
1987         m_formatter.vfpOp(OP_VMOV_CtoD, OP_VMOV_CtoDb, true, rn2, VFPOperand(rn1 | 16), rd);
1988     }
1989 
1990     void vmov(FPDoubleRegisterID rd, FPDoubleRegisterID rn)
1991     {
1992         m_formatter.vfpOp(OP_VMOV_T2, OP_VMOV_T2b, true, VFPOperand(0), rd, rn);
1993     }
1994 
1995     void vmrs(RegisterID reg = ARMRegisters::pc)
1996     {
1997         ASSERT(reg != ARMRegisters::sp);
1998         m_formatter.vfpOp(OP_VMRS, OP_VMRSb, false, VFPOperand(1), VFPOperand(0x10 | reg), VFPOperand(0));
1999     }
2000 
2001     void vmul(FPDoubleRegisterID rd, FPDoubleRegisterID rn, FPDoubleRegisterID rm)
2002     {
2003         m_formatter.vfpOp(OP_VMUL_T2, OP_VMUL_T2b, true, rn, rd, rm);
2004     }
2005 
2006     void vstr(FPDoubleRegisterID rd, RegisterID rn, int32_t imm)
2007     {
2008         m_formatter.vfpMemOp(OP_VSTR, OP_VSTRb, true, rn, rd, imm);
2009     }
2010 
2011     void fsts(FPSingleRegisterID rd, RegisterID rn, int32_t imm)
2012     {
2013         m_formatter.vfpMemOp(OP_FSTS, OP_FSTSb, false, rn, rd, imm);
2014     }
2015 
2016     void vsub(FPDoubleRegisterID rd, FPDoubleRegisterID rn, FPDoubleRegisterID rm)
2017     {
2018         m_formatter.vfpOp(OP_VSUB_T2, OP_VSUB_T2b, true, rn, rd, rm);
2019     }
2020 
2021     void vabs(FPDoubleRegisterID rd, FPDoubleRegisterID rm)
2022     {
2023         m_formatter.vfpOp(OP_VABS_T2, OP_VABS_T2b, true, VFPOperand(16), rd, rm);
2024     }
2025 
2026     void vneg(FPDoubleRegisterID rd, FPDoubleRegisterID rm)
2027     {
2028         m_formatter.vfpOp(OP_VNEG_T2, OP_VNEG_T2b, true, VFPOperand(1), rd, rm);
2029     }
2030 
2031     void vsqrt(FPDoubleRegisterID rd, FPDoubleRegisterID rm)
2032     {
2033         m_formatter.vfpOp(OP_VSQRT_T1, OP_VSQRT_T1b, true, VFPOperand(17), rd, rm);
2034     }
2035 
2036     void vcvtds(FPDoubleRegisterID rd, FPSingleRegisterID rm)
2037     {
2038         m_formatter.vfpOp(OP_VCVTDS_T1, OP_VCVTDS_T1b, false, VFPOperand(23), rd, rm);
2039     }
2040 
2041     void vcvtsd(FPSingleRegisterID rd, FPDoubleRegisterID rm)
2042     {
2043         m_formatter.vfpOp(OP_VCVTSD_T1, OP_VCVTSD_T1b, true, VFPOperand(23), rd, rm);
2044     }
2045 
2046     void nop()
2047     {
2048         m_formatter.oneWordOp8Imm8(OP_NOP_T1, 0);
2049     }
2050 
2051     void nopw()
2052     {
2053         m_formatter.twoWordOp16Op16(OP_NOP_T2a, OP_NOP_T2b);
2054     }
2055 
2056     static constexpr int16_t nopPseudo16()
2057     {
2058         return OP_NOP_T1;
2059     }
2060 
2061     static constexpr int32_t nopPseudo32()
2062     {
2063         return OP_NOP_T2a | (OP_NOP_T2b &lt;&lt; 16);
2064     }
2065 
2066     template &lt;typename CopyFunction&gt;
2067     static void fillNops(void* base, size_t size, CopyFunction copy)
2068     {
2069         RELEASE_ASSERT(!(size % sizeof(int16_t)));
2070 
2071         char* ptr = static_cast&lt;char*&gt;(base);
2072         const size_t num32s = size / sizeof(int32_t);
2073         for (size_t i = 0; i &lt; num32s; i++) {
2074             const int32_t insn = nopPseudo32();
2075             copy(ptr, &amp;insn, sizeof(int32_t));
2076             ptr += sizeof(int32_t);
2077         }
2078 
2079         const size_t num16s = (size % sizeof(int32_t)) / sizeof(int16_t);
2080         ASSERT(num16s == 0 || num16s == 1);
2081         ASSERT(num16s * sizeof(int16_t) + num32s * sizeof(int32_t) == size);
2082         if (num16s) {
2083             const int16_t insn = nopPseudo16();
2084             copy(ptr, &amp;insn, sizeof(int16_t));
2085         }
2086     }
2087 
2088     void dmbSY()
2089     {
2090         m_formatter.twoWordOp16Op16(OP_DMB_T1a, OP_DMB_SY_T1b);
2091     }
2092 
2093     void dmbISHST()
2094     {
2095         m_formatter.twoWordOp16Op16(OP_DMB_T1a, OP_DMB_ISHST_T1b);
2096     }
2097 
2098     AssemblerLabel labelIgnoringWatchpoints()
2099     {
2100         return m_formatter.label();
2101     }
2102 
2103     AssemblerLabel labelForWatchpoint()
2104     {
2105         AssemblerLabel result = m_formatter.label();
2106         if (static_cast&lt;int&gt;(result.m_offset) != m_indexOfLastWatchpoint)
2107             result = label();
2108         m_indexOfLastWatchpoint = result.m_offset;
2109         m_indexOfTailOfLastWatchpoint = result.m_offset + maxJumpReplacementSize();
2110         return result;
2111     }
2112 
2113     AssemblerLabel label()
2114     {
2115         AssemblerLabel result = m_formatter.label();
2116         while (UNLIKELY(static_cast&lt;int&gt;(result.m_offset) &lt; m_indexOfTailOfLastWatchpoint)) {
2117             if (UNLIKELY(static_cast&lt;int&gt;(result.m_offset) + 4 &lt;= m_indexOfTailOfLastWatchpoint))
2118                 nopw();
2119             else
2120                 nop();
2121             result = m_formatter.label();
2122         }
2123         return result;
2124     }
2125 
2126     AssemblerLabel align(int alignment)
2127     {
2128         while (!m_formatter.isAligned(alignment))
2129             bkpt();
2130 
2131         return label();
2132     }
2133 
2134     static void* getRelocatedAddress(void* code, AssemblerLabel label)
2135     {
2136         ASSERT(label.isSet());
2137         return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;ptrdiff_t&gt;(code) + label.m_offset);
2138     }
2139 
2140     static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
2141     {
2142         return b.m_offset - a.m_offset;
2143     }
2144 
2145     static int jumpSizeDelta(JumpType jumpType, JumpLinkType jumpLinkType) { return JUMP_ENUM_SIZE(jumpType) - JUMP_ENUM_SIZE(jumpLinkType); }
2146 
2147     // Assembler admin methods:
2148 
2149     static ALWAYS_INLINE bool linkRecordSourceComparator(const LinkRecord&amp; a, const LinkRecord&amp; b)
2150     {
2151         return a.from() &lt; b.from();
2152     }
2153 
2154     static bool canCompact(JumpType jumpType)
2155     {
2156         // The following cannot be compacted:
2157         //   JumpFixed: represents custom jump sequence
2158         //   JumpNoConditionFixedSize: represents unconditional jump that must remain a fixed size
2159         //   JumpConditionFixedSize: represents conditional jump that must remain a fixed size
2160         return (jumpType == JumpNoCondition) || (jumpType == JumpCondition);
2161     }
2162 
2163     static JumpLinkType computeJumpType(JumpType jumpType, const uint8_t* from, const uint8_t* to)
2164     {
2165         if (jumpType == JumpFixed)
2166             return LinkInvalid;
2167 
2168         // for patchable jump we must leave space for the longest code sequence
2169         if (jumpType == JumpNoConditionFixedSize)
2170             return LinkBX;
2171         if (jumpType == JumpConditionFixedSize)
2172             return LinkConditionalBX;
2173 
2174         const int paddingSize = JUMP_ENUM_SIZE(jumpType);
2175 
2176         if (jumpType == JumpCondition) {
2177             // 2-byte conditional T1
2178             const uint16_t* jumpT1Location = reinterpret_cast_ptr&lt;const uint16_t*&gt;(from - (paddingSize - JUMP_ENUM_SIZE(LinkJumpT1)));
2179             if (canBeJumpT1(jumpT1Location, to))
2180                 return LinkJumpT1;
2181             // 4-byte conditional T3
2182             const uint16_t* jumpT3Location = reinterpret_cast_ptr&lt;const uint16_t*&gt;(from - (paddingSize - JUMP_ENUM_SIZE(LinkJumpT3)));
2183             if (canBeJumpT3(jumpT3Location, to))
2184                 return LinkJumpT3;
2185             // 4-byte conditional T4 with IT
2186             const uint16_t* conditionalJumpT4Location =
2187             reinterpret_cast_ptr&lt;const uint16_t*&gt;(from - (paddingSize - JUMP_ENUM_SIZE(LinkConditionalJumpT4)));
2188             if (canBeJumpT4(conditionalJumpT4Location, to))
2189                 return LinkConditionalJumpT4;
2190         } else {
2191             // 2-byte unconditional T2
2192             const uint16_t* jumpT2Location = reinterpret_cast_ptr&lt;const uint16_t*&gt;(from - (paddingSize - JUMP_ENUM_SIZE(LinkJumpT2)));
2193             if (canBeJumpT2(jumpT2Location, to))
2194                 return LinkJumpT2;
2195             // 4-byte unconditional T4
2196             const uint16_t* jumpT4Location = reinterpret_cast_ptr&lt;const uint16_t*&gt;(from - (paddingSize - JUMP_ENUM_SIZE(LinkJumpT4)));
2197             if (canBeJumpT4(jumpT4Location, to))
2198                 return LinkJumpT4;
2199             // use long jump sequence
2200             return LinkBX;
2201         }
2202 
2203         ASSERT(jumpType == JumpCondition);
2204         return LinkConditionalBX;
2205     }
2206 
2207     static JumpLinkType computeJumpType(LinkRecord&amp; record, const uint8_t* from, const uint8_t* to)
2208     {
2209         JumpLinkType linkType = computeJumpType(record.type(), from, to);
2210         record.setLinkType(linkType);
2211         return linkType;
2212     }
2213 
2214     Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt;&amp; jumpsToLink()
2215     {
2216         std::sort(m_jumpsToLink.begin(), m_jumpsToLink.end(), linkRecordSourceComparator);
2217         return m_jumpsToLink;
2218     }
2219 
2220     typedef void* (*CopyFunction)(void*, const void*, size_t);
2221 
2222     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to, CopyFunction copy)
2223     {
2224         const uint16_t* fromInstruction = reinterpret_cast_ptr&lt;const uint16_t*&gt;(fromInstruction8);
2225         switch (record.linkType()) {
2226         case LinkJumpT1:
2227             linkJumpT1(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);
2228             break;
2229         case LinkJumpT2:
2230             linkJumpT2(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);
2231             break;
2232         case LinkJumpT3:
2233             linkJumpT3(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);
2234             break;
2235         case LinkJumpT4:
2236             linkJumpT4(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);
2237             break;
2238         case LinkConditionalJumpT4:
2239             linkConditionalJumpT4(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);
2240             break;
2241         case LinkConditionalBX:
2242             linkConditionalBX(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);
2243             break;
2244         case LinkBX:
2245             linkBX(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);
2246             break;
2247         default:
2248             RELEASE_ASSERT_NOT_REACHED();
2249             break;
2250         }
2251     }
2252 
2253     size_t codeSize() const { return m_formatter.codeSize(); }
2254 
2255     static unsigned getCallReturnOffset(AssemblerLabel call)
2256     {
2257         ASSERT(call.isSet());
2258         return call.m_offset;
2259     }
2260 
2261     // Linking &amp; patching:
2262     //
2263     // &#39;link&#39; and &#39;patch&#39; methods are for use on unprotected code - such as the code
2264     // within the AssemblerBuffer, and code being patched by the patch buffer.  Once
2265     // code has been finalized it is (platform support permitting) within a non-
2266     // writable region of memory; to modify the code in an execute-only execuable
2267     // pool the &#39;repatch&#39; and &#39;relink&#39; methods should be used.
2268 
2269     void linkJump(AssemblerLabel from, AssemblerLabel to, JumpType type, Condition condition)
2270     {
2271         ASSERT(to.isSet());
2272         ASSERT(from.isSet());
2273         m_jumpsToLink.append(LinkRecord(from.m_offset, to.m_offset, type, condition));
2274     }
2275 
2276     static void linkJump(void* code, AssemblerLabel from, void* to)
2277     {
2278         ASSERT(from.isSet());
2279 
2280         uint16_t* location = reinterpret_cast&lt;uint16_t*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
2281         linkJumpAbsolute(location, location, to);
2282     }
2283 
2284     static void linkCall(void* code, AssemblerLabel from, void* to)
2285     {
2286         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(code) &amp; 1));
2287         ASSERT(from.isSet());
2288 
2289         setPointer(reinterpret_cast&lt;uint16_t*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset) - 1, to, false);
2290     }
2291 
2292     static void linkPointer(void* code, AssemblerLabel where, void* value)
2293     {
2294         setPointer(reinterpret_cast&lt;char*&gt;(code) + where.m_offset, value, false);
2295     }
2296 
2297     // The static relink and replace methods can use can use |from| for both
2298     // the write and executable address for call and jump patching
2299     // as they&#39;re modifying existing (linked) code, so the address being
2300     // provided is correct for relative address computation.
2301     static void relinkJump(void* from, void* to)
2302     {
2303         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 1));
2304         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 1));
2305 
2306         linkJumpAbsolute(reinterpret_cast&lt;uint16_t*&gt;(from), reinterpret_cast&lt;uint16_t*&gt;(from), to);
2307 
2308         cacheFlush(reinterpret_cast&lt;uint16_t*&gt;(from) - 5, 5 * sizeof(uint16_t));
2309     }
2310 
2311     static void relinkJumpToNop(void* from)
2312     {
2313         relinkJump(from, from);
2314     }
2315 
2316     static void relinkCall(void* from, void* to)
2317     {
2318         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 1));
2319 
2320         setPointer(reinterpret_cast&lt;uint16_t*&gt;(from) - 1, to, true);
2321     }
2322 
2323     static void* readCallTarget(void* from)
2324     {
2325         return readPointer(reinterpret_cast&lt;uint16_t*&gt;(from) - 1);
2326     }
2327 
2328     static void repatchInt32(void* where, int32_t value)
2329     {
2330         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(where) &amp; 1));
2331 
2332         setInt32(where, value, true);
2333     }
2334 
2335     static void repatchCompact(void* where, int32_t offset)
2336     {
2337         ASSERT(offset &gt;= -255 &amp;&amp; offset &lt;= 255);
2338 
2339         bool add = true;
2340         if (offset &lt; 0) {
2341             add = false;
2342             offset = -offset;
2343         }
2344 
2345         offset |= (add &lt;&lt; 9);
2346         offset |= (1 &lt;&lt; 10);
2347         offset |= (1 &lt;&lt; 11);
2348 
2349         uint16_t* location = reinterpret_cast&lt;uint16_t*&gt;(where);
2350         uint16_t instruction = location[1] &amp; ~((1 &lt;&lt; 12) - 1);
2351         instruction |= offset;
2352         performJITMemcpy(location + 1, &amp;instruction, sizeof(uint16_t));
2353         cacheFlush(location, sizeof(uint16_t) * 2);
2354     }
2355 
2356     static void repatchPointer(void* where, void* value)
2357     {
2358         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(where) &amp; 1));
2359 
2360         setPointer(where, value, true);
2361     }
2362 
2363     static void* readPointer(void* where)
2364     {
2365         return reinterpret_cast&lt;void*&gt;(readInt32(where));
2366     }
2367 
2368     static void replaceWithJump(void* instructionStart, void* to)
2369     {
2370         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(instructionStart) &amp; 1));
2371         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(to) &amp; 1));
2372 
2373 #if OS(LINUX)
2374         if (canBeJumpT4(reinterpret_cast&lt;uint16_t*&gt;(instructionStart), to)) {
2375             uint16_t* ptr = reinterpret_cast&lt;uint16_t*&gt;(instructionStart) + 2;
2376             linkJumpT4(ptr, ptr, to);
2377             cacheFlush(ptr - 2, sizeof(uint16_t) * 2);
2378         } else {
2379             uint16_t* ptr = reinterpret_cast&lt;uint16_t*&gt;(instructionStart) + 5;
2380             linkBX(ptr, ptr, to);
2381             cacheFlush(ptr - 5, sizeof(uint16_t) * 5);
2382         }
2383 #else
2384         uint16_t* ptr = reinterpret_cast&lt;uint16_t*&gt;(instructionStart) + 2;
2385         linkJumpT4(ptr, ptr, to);
2386         cacheFlush(ptr - 2, sizeof(uint16_t) * 2);
2387 #endif
2388     }
2389 
2390     static ptrdiff_t maxJumpReplacementSize()
2391     {
2392 #if OS(LINUX)
2393         return 10;
2394 #else
2395         return 4;
2396 #endif
2397     }
2398 
2399     static constexpr ptrdiff_t patchableJumpSize()
2400     {
2401         return 10;
2402     }
2403 
2404     static void replaceWithLoad(void* instructionStart)
2405     {
2406         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(instructionStart) &amp; 1));
2407         uint16_t* ptr = reinterpret_cast&lt;uint16_t*&gt;(instructionStart);
2408         switch (ptr[0] &amp; 0xFFF0) {
2409         case OP_LDR_imm_T3:
2410             break;
2411         case OP_ADD_imm_T3: {
2412             ASSERT(!(ptr[1] &amp; 0xF000));
2413             uint16_t instructions[2];
2414             instructions[0] = ptr[0] &amp; 0x000F;
2415             instructions[0] |= OP_LDR_imm_T3;
2416             instructions[1] = ptr[1] | (ptr[1] &amp; 0x0F00) &lt;&lt; 4;
2417             instructions[1] &amp;= 0xF0FF;
2418             performJITMemcpy(ptr, instructions, sizeof(uint16_t) * 2);
2419             cacheFlush(ptr, sizeof(uint16_t) * 2);
2420             break;
2421         }
2422         default:
2423             RELEASE_ASSERT_NOT_REACHED();
2424         }
2425     }
2426 
2427     static void replaceWithAddressComputation(void* instructionStart)
2428     {
2429         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(instructionStart) &amp; 1));
2430         uint16_t* ptr = reinterpret_cast&lt;uint16_t*&gt;(instructionStart);
2431         switch (ptr[0] &amp; 0xFFF0) {
2432         case OP_LDR_imm_T3: {
2433             ASSERT(!(ptr[1] &amp; 0x0F00));
2434             uint16_t instructions[2];
2435             instructions[0] = ptr[0] &amp; 0x000F;
2436             instructions[0] |= OP_ADD_imm_T3;
2437             instructions[1] = ptr[1] | (ptr[1] &amp; 0xF000) &gt;&gt; 4;
2438             instructions[1] &amp;= 0x0FFF;
2439             performJITMemcpy(ptr, instructions, sizeof(uint16_t) * 2);
2440             cacheFlush(ptr, sizeof(uint16_t) * 2);
2441             break;
2442         }
2443         case OP_ADD_imm_T3:
2444             break;
2445         default:
2446             RELEASE_ASSERT_NOT_REACHED();
2447         }
2448     }
2449 
2450     unsigned debugOffset() { return m_formatter.debugOffset(); }
2451 
2452 #if OS(LINUX)
2453     static inline void linuxPageFlush(uintptr_t begin, uintptr_t end)
2454     {
2455         asm volatile(
2456             &quot;push    {r7}\n&quot;
2457             &quot;mov     r0, %0\n&quot;
2458             &quot;mov     r1, %1\n&quot;
2459             &quot;movw    r7, #0x2\n&quot;
2460             &quot;movt    r7, #0xf\n&quot;
2461             &quot;movs    r2, #0x0\n&quot;
2462             &quot;svc     0x0\n&quot;
2463             &quot;pop     {r7}\n&quot;
2464             :
2465             : &quot;r&quot; (begin), &quot;r&quot; (end)
2466             : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;);
2467     }
2468 #endif
2469 
2470     static void cacheFlush(void* code, size_t size)
2471     {
2472 #if OS(IOS_FAMILY)
2473         sys_cache_control(kCacheFunctionPrepareForExecution, code, size);
2474 #elif OS(LINUX)
2475         size_t page = pageSize();
2476         uintptr_t current = reinterpret_cast&lt;uintptr_t&gt;(code);
2477         uintptr_t end = current + size;
2478         uintptr_t firstPageEnd = (current &amp; ~(page - 1)) + page;
2479 
2480         if (end &lt;= firstPageEnd) {
2481             linuxPageFlush(current, end);
2482             return;
2483         }
2484 
2485         linuxPageFlush(current, firstPageEnd);
2486 
2487         for (current = firstPageEnd; current + page &lt; end; current += page)
2488             linuxPageFlush(current, current + page);
2489 
2490         linuxPageFlush(current, end);
2491 #else
2492 #error &quot;The cacheFlush support is missing on this platform.&quot;
2493 #endif
2494     }
2495 
2496 private:
2497     // VFP operations commonly take one or more 5-bit operands, typically representing a
2498     // floating point register number.  This will commonly be encoded in the instruction
2499     // in two parts, with one single bit field, and one 4-bit field.  In the case of
2500     // double precision operands the high bit of the register number will be encoded
2501     // separately, and for single precision operands the high bit of the register number
2502     // will be encoded individually.
2503     // VFPOperand encapsulates a 5-bit VFP operand, with bits 0..3 containing the 4-bit
2504     // field to be encoded together in the instruction (the low 4-bits of a double
2505     // register number, or the high 4-bits of a single register number), and bit 4
2506     // contains the bit value to be encoded individually.
2507     struct VFPOperand {
2508         explicit VFPOperand(uint32_t value)
2509             : m_value(value)
2510         {
2511             ASSERT(!(m_value &amp; ~0x1f));
2512         }
2513 
2514         VFPOperand(FPDoubleRegisterID reg)
2515             : m_value(reg)
2516         {
2517         }
2518 
2519         VFPOperand(RegisterID reg)
2520             : m_value(reg)
2521         {
2522         }
2523 
2524         VFPOperand(FPSingleRegisterID reg)
2525             : m_value(((reg &amp; 1) &lt;&lt; 4) | (reg &gt;&gt; 1)) // rotate the lowest bit of &#39;reg&#39; to the top.
2526         {
2527         }
2528 
2529         uint32_t bits1()
2530         {
2531             return m_value &gt;&gt; 4;
2532         }
2533 
2534         uint32_t bits4()
2535         {
2536             return m_value &amp; 0xf;
2537         }
2538 
2539         uint32_t m_value;
2540     };
2541 
2542     VFPOperand vcvtOp(bool toInteger, bool isUnsigned, bool isRoundZero)
2543     {
2544         // Cannot specify rounding when converting to float.
2545         ASSERT(toInteger || !isRoundZero);
2546 
2547         uint32_t op = 0x8;
2548         if (toInteger) {
2549             // opc2 indicates both toInteger &amp; isUnsigned.
2550             op |= isUnsigned ? 0x4 : 0x5;
2551             // &#39;op&#39; field in instruction is isRoundZero
2552             if (isRoundZero)
2553                 op |= 0x10;
2554         } else {
2555             ASSERT(!isRoundZero);
2556             // &#39;op&#39; field in instruction is isUnsigned
2557             if (!isUnsigned)
2558                 op |= 0x10;
2559         }
2560         return VFPOperand(op);
2561     }
2562 
2563     static void setInt32(void* code, uint32_t value, bool flush)
2564     {
2565         uint16_t* location = reinterpret_cast&lt;uint16_t*&gt;(code);
2566         ASSERT(isMOV_imm_T3(location - 4) &amp;&amp; isMOVT(location - 2));
2567 
2568         ARMThumbImmediate lo16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(value));
2569         ARMThumbImmediate hi16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(value &gt;&gt; 16));
2570         uint16_t instructions[4];
2571         instructions[0] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOV_imm_T3, lo16);
2572         instructions[1] = twoWordOp5i6Imm4Reg4EncodedImmSecond((location[-3] &gt;&gt; 8) &amp; 0xf, lo16);
2573         instructions[2] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOVT, hi16);
2574         instructions[3] = twoWordOp5i6Imm4Reg4EncodedImmSecond((location[-1] &gt;&gt; 8) &amp; 0xf, hi16);
2575 
2576         performJITMemcpy(location - 4, instructions, 4 * sizeof(uint16_t));
2577         if (flush)
2578             cacheFlush(location - 4, 4 * sizeof(uint16_t));
2579     }
2580 
2581     static int32_t readInt32(void* code)
2582     {
2583         uint16_t* location = reinterpret_cast&lt;uint16_t*&gt;(code);
2584         ASSERT(isMOV_imm_T3(location - 4) &amp;&amp; isMOVT(location - 2));
2585 
2586         ARMThumbImmediate lo16;
2587         ARMThumbImmediate hi16;
2588         decodeTwoWordOp5i6Imm4Reg4EncodedImmFirst(lo16, location[-4]);
2589         decodeTwoWordOp5i6Imm4Reg4EncodedImmSecond(lo16, location[-3]);
2590         decodeTwoWordOp5i6Imm4Reg4EncodedImmFirst(hi16, location[-2]);
2591         decodeTwoWordOp5i6Imm4Reg4EncodedImmSecond(hi16, location[-1]);
2592         uint32_t result = hi16.asUInt16();
2593         result &lt;&lt;= 16;
2594         result |= lo16.asUInt16();
2595         return static_cast&lt;int32_t&gt;(result);
2596     }
2597 
2598     static void setUInt7ForLoad(void* code, ARMThumbImmediate imm)
2599     {
2600         // Requires us to have planted a LDR_imm_T1
2601         ASSERT(imm.isValid());
2602         ASSERT(imm.isUInt7());
2603         uint16_t* location = reinterpret_cast&lt;uint16_t*&gt;(code);
2604         uint16_t instruction;
2605         instruction = location[0] &amp; ~((static_cast&lt;uint16_t&gt;(0x7f) &gt;&gt; 2) &lt;&lt; 6);
2606         instruction |= (imm.getUInt7() &gt;&gt; 2) &lt;&lt; 6;
2607         performJITMemcpy(location, &amp;instruction, sizeof(uint16_t));
2608         cacheFlush(location, sizeof(uint16_t));
2609     }
2610 
2611     static void setPointer(void* code, void* value, bool flush)
2612     {
2613         setInt32(code, reinterpret_cast&lt;uint32_t&gt;(value), flush);
2614     }
2615 
2616     static bool isB(const void* address)
2617     {
2618         const uint16_t* instruction = static_cast&lt;const uint16_t*&gt;(address);
2619         return ((instruction[0] &amp; 0xf800) == OP_B_T4a) &amp;&amp; ((instruction[1] &amp; 0xd000) == OP_B_T4b);
2620     }
2621 
2622     static bool isBX(const void* address)
2623     {
2624         const uint16_t* instruction = static_cast&lt;const uint16_t*&gt;(address);
2625         return (instruction[0] &amp; 0xff87) == OP_BX;
2626     }
2627 
2628     static bool isMOV_imm_T3(const void* address)
2629     {
2630         const uint16_t* instruction = static_cast&lt;const uint16_t*&gt;(address);
2631         return ((instruction[0] &amp; 0xFBF0) == OP_MOV_imm_T3) &amp;&amp; ((instruction[1] &amp; 0x8000) == 0);
2632     }
2633 
2634     static bool isMOVT(const void* address)
2635     {
2636         const uint16_t* instruction = static_cast&lt;const uint16_t*&gt;(address);
2637         return ((instruction[0] &amp; 0xFBF0) == OP_MOVT) &amp;&amp; ((instruction[1] &amp; 0x8000) == 0);
2638     }
2639 
2640     static bool isNOP_T1(const void* address)
2641     {
2642         const uint16_t* instruction = static_cast&lt;const uint16_t*&gt;(address);
2643         return instruction[0] == OP_NOP_T1;
2644     }
2645 
2646     static bool isNOP_T2(const void* address)
2647     {
2648         const uint16_t* instruction = static_cast&lt;const uint16_t*&gt;(address);
2649         return (instruction[0] == OP_NOP_T2a) &amp;&amp; (instruction[1] == OP_NOP_T2b);
2650     }
2651 
2652     static bool canBeJumpT1(const uint16_t* instruction, const void* target)
2653     {
2654         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2655         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2656 
2657         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2658         // It does not appear to be documented in the ARM ARM (big surprise), but
2659         // for OP_B_T1 the branch displacement encoded in the instruction is 2
2660         // less than the actual displacement.
2661         relative -= 2;
2662         return ((relative &lt;&lt; 23) &gt;&gt; 23) == relative;
2663     }
2664 
2665     static bool canBeJumpT2(const uint16_t* instruction, const void* target)
2666     {
2667         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2668         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2669 
2670         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2671         // It does not appear to be documented in the ARM ARM (big surprise), but
2672         // for OP_B_T2 the branch displacement encoded in the instruction is 2
2673         // less than the actual displacement.
2674         relative -= 2;
2675         return ((relative &lt;&lt; 20) &gt;&gt; 20) == relative;
2676     }
2677 
2678     static bool canBeJumpT3(const uint16_t* instruction, const void* target)
2679     {
2680         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2681         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2682 
2683         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2684         return ((relative &lt;&lt; 11) &gt;&gt; 11) == relative;
2685     }
2686 
2687     static bool canBeJumpT4(const uint16_t* instruction, const void* target)
2688     {
2689         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2690         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2691 
2692         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2693         return ((relative &lt;&lt; 7) &gt;&gt; 7) == relative;
2694     }
2695 
2696     static void linkJumpT1(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)
2697     {
2698         // FIMXE: this should be up in the MacroAssembler layer. :-(
2699         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2700         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2701         ASSERT(canBeJumpT1(instruction, target));
2702 
2703         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2704         // It does not appear to be documented in the ARM ARM (big surprise), but
2705         // for OP_B_T1 the branch displacement encoded in the instruction is 2
2706         // less than the actual displacement.
2707         relative -= 2;
2708 
2709         // All branch offsets should be an even distance.
2710         ASSERT(!(relative &amp; 1));
2711         uint16_t newInstruction = OP_B_T1 | ((cond &amp; 0xf) &lt;&lt; 8) | ((relative &amp; 0x1fe) &gt;&gt; 1);
2712         copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
2713     }
2714 
2715     static void linkJumpT2(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)
2716     {
2717         // FIMXE: this should be up in the MacroAssembler layer. :-(
2718         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2719         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2720         ASSERT(canBeJumpT2(instruction, target));
2721 
2722         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2723         // It does not appear to be documented in the ARM ARM (big surprise), but
2724         // for OP_B_T2 the branch displacement encoded in the instruction is 2
2725         // less than the actual displacement.
2726         relative -= 2;
2727 
2728         // All branch offsets should be an even distance.
2729         ASSERT(!(relative &amp; 1));
2730         uint16_t newInstruction = OP_B_T2 | ((relative &amp; 0xffe) &gt;&gt; 1);
2731         copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
2732     }
2733 
2734     static void linkJumpT3(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)
2735     {
2736         // FIMXE: this should be up in the MacroAssembler layer. :-(
2737         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2738         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2739         ASSERT(canBeJumpT3(instruction, target));
2740 
2741         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2742 
2743         // All branch offsets should be an even distance.
2744         ASSERT(!(relative &amp; 1));
2745         uint16_t instructions[2];
2746         instructions[0] = OP_B_T3a | ((relative &amp; 0x100000) &gt;&gt; 10) | ((cond &amp; 0xf) &lt;&lt; 6) | ((relative &amp; 0x3f000) &gt;&gt; 12);
2747         instructions[1] = OP_B_T3b | ((relative &amp; 0x80000) &gt;&gt; 8) | ((relative &amp; 0x40000) &gt;&gt; 5) | ((relative &amp; 0xffe) &gt;&gt; 1);
2748         copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
2749     }
2750 
2751     static void linkJumpT4(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)
2752     {
2753         // FIMXE: this should be up in the MacroAssembler layer. :-(
2754         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2755         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2756         ASSERT(canBeJumpT4(instruction, target));
2757 
2758         intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
2759         // ARM encoding for the top two bits below the sign bit is &#39;peculiar&#39;.
2760         if (relative &gt;= 0)
2761             relative ^= 0xC00000;
2762 
2763         // All branch offsets should be an even distance.
2764         ASSERT(!(relative &amp; 1));
2765         uint16_t instructions[2];
2766         instructions[0] = OP_B_T4a | ((relative &amp; 0x1000000) &gt;&gt; 14) | ((relative &amp; 0x3ff000) &gt;&gt; 12);
2767         instructions[1] = OP_B_T4b | ((relative &amp; 0x800000) &gt;&gt; 10) | ((relative &amp; 0x400000) &gt;&gt; 11) | ((relative &amp; 0xffe) &gt;&gt; 1);
2768         copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
2769     }
2770 
2771     static void linkConditionalJumpT4(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)
2772     {
2773         // FIMXE: this should be up in the MacroAssembler layer. :-(
2774         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2775         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2776 
2777         uint16_t newInstruction = ifThenElse(cond) | OP_IT;
2778         copy(writeTarget - 3, &amp;newInstruction, sizeof(uint16_t));
2779         linkJumpT4(writeTarget, instruction, target, copy);
2780     }
2781 
2782     static void linkBX(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)
2783     {
2784         // FIMXE: this should be up in the MacroAssembler layer. :-(
2785         ASSERT_UNUSED(instruction, !(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2786         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(writeTarget) &amp; 1));
2787         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2788 
2789         const uint16_t JUMP_TEMPORARY_REGISTER = ARMRegisters::ip;
2790         ARMThumbImmediate lo16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(reinterpret_cast&lt;uint32_t&gt;(target) + 1));
2791         ARMThumbImmediate hi16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(reinterpret_cast&lt;uint32_t&gt;(target) &gt;&gt; 16));
2792         uint16_t instructions[5];
2793         instructions[0] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOV_imm_T3, lo16);
2794         instructions[1] = twoWordOp5i6Imm4Reg4EncodedImmSecond(JUMP_TEMPORARY_REGISTER, lo16);
2795         instructions[2] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOVT, hi16);
2796         instructions[3] = twoWordOp5i6Imm4Reg4EncodedImmSecond(JUMP_TEMPORARY_REGISTER, hi16);
2797         instructions[4] = OP_BX | (JUMP_TEMPORARY_REGISTER &lt;&lt; 3);
2798 
2799         copy(writeTarget - 5, instructions, 5 * sizeof(uint16_t));
2800     }
2801 
2802     static void linkConditionalBX(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)
2803     {
2804         // FIMXE: this should be up in the MacroAssembler layer. :-(
2805         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2806         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2807 
2808         linkBX(writeTarget, instruction, target);
2809         uint16_t newInstruction = ifThenElse(cond, true, true) | OP_IT;
2810         copy(writeTarget - 6, &amp;newInstruction, sizeof(uint16_t));
2811     }
2812 
2813     static void linkJumpAbsolute(uint16_t* writeTarget, const uint16_t* instruction, void* target)
2814     {
2815         // FIMXE: this should be up in the MacroAssembler layer. :-(
2816         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
2817         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
2818 
2819         ASSERT((isMOV_imm_T3(instruction - 5) &amp;&amp; isMOVT(instruction - 3) &amp;&amp; isBX(instruction - 1))
2820                || (isNOP_T1(instruction - 5) &amp;&amp; isNOP_T2(instruction - 4) &amp;&amp; isB(instruction - 2)));
2821 
2822         if (canBeJumpT4(instruction, target)) {
2823             // There may be a better way to fix this, but right now put the NOPs first, since in the
2824             // case of an conditional branch this will be coming after an ITTT predicating *three*
2825             // instructions!  Looking backwards to modify the ITTT to an IT is not easy, due to
2826             // variable wdith encoding - the previous instruction might *look* like an ITTT but
2827             // actually be the second half of a 2-word op.
2828             uint16_t instructions[3];
2829             instructions[0] = OP_NOP_T1;
2830             instructions[1] = OP_NOP_T2a;
2831             instructions[2] = OP_NOP_T2b;
2832             performJITMemcpy(writeTarget - 5, instructions, 3 * sizeof(uint16_t));
2833             linkJumpT4(writeTarget, instruction, target);
2834         } else {
2835             const uint16_t JUMP_TEMPORARY_REGISTER = ARMRegisters::ip;
2836             ARMThumbImmediate lo16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(reinterpret_cast&lt;uint32_t&gt;(target) + 1));
2837             ARMThumbImmediate hi16 = ARMThumbImmediate::makeUInt16(static_cast&lt;uint16_t&gt;(reinterpret_cast&lt;uint32_t&gt;(target) &gt;&gt; 16));
2838 
2839             uint16_t instructions[5];
2840             instructions[0] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOV_imm_T3, lo16);
2841             instructions[1] = twoWordOp5i6Imm4Reg4EncodedImmSecond(JUMP_TEMPORARY_REGISTER, lo16);
2842             instructions[2] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOVT, hi16);
2843             instructions[3] = twoWordOp5i6Imm4Reg4EncodedImmSecond(JUMP_TEMPORARY_REGISTER, hi16);
2844             instructions[4] = OP_BX | (JUMP_TEMPORARY_REGISTER &lt;&lt; 3);
2845             performJITMemcpy(writeTarget - 5, instructions, 5 * sizeof(uint16_t));
2846         }
2847     }
2848 
2849     static uint16_t twoWordOp5i6Imm4Reg4EncodedImmFirst(uint16_t op, ARMThumbImmediate imm)
2850     {
2851         return op | (imm.m_value.i &lt;&lt; 10) | imm.m_value.imm4;
2852     }
2853 
2854     static void decodeTwoWordOp5i6Imm4Reg4EncodedImmFirst(ARMThumbImmediate&amp; result, uint16_t value)
2855     {
2856         result.m_value.i = (value &gt;&gt; 10) &amp; 1;
2857         result.m_value.imm4 = value &amp; 15;
2858     }
2859 
2860     static uint16_t twoWordOp5i6Imm4Reg4EncodedImmSecond(uint16_t rd, ARMThumbImmediate imm)
2861     {
2862         return (imm.m_value.imm3 &lt;&lt; 12) | (rd &lt;&lt; 8) | imm.m_value.imm8;
2863     }
2864 
2865     static void decodeTwoWordOp5i6Imm4Reg4EncodedImmSecond(ARMThumbImmediate&amp; result, uint16_t value)
2866     {
2867         result.m_value.imm3 = (value &gt;&gt; 12) &amp; 7;
2868         result.m_value.imm8 = value &amp; 255;
2869     }
2870 
2871     class ARMInstructionFormatter {
2872     public:
2873         ALWAYS_INLINE void oneWordOp5Reg3Imm8(OpcodeID op, RegisterID rd, uint8_t imm)
2874         {
2875             m_buffer.putShort(op | (rd &lt;&lt; 8) | imm);
2876         }
2877 
2878         ALWAYS_INLINE void oneWordOp5Imm5Reg3Reg3(OpcodeID op, uint8_t imm, RegisterID reg1, RegisterID reg2)
2879         {
2880             m_buffer.putShort(op | (imm &lt;&lt; 6) | (reg1 &lt;&lt; 3) | reg2);
2881         }
2882 
2883         ALWAYS_INLINE void oneWordOp7Reg3Reg3Reg3(OpcodeID op, RegisterID reg1, RegisterID reg2, RegisterID reg3)
2884         {
2885             m_buffer.putShort(op | (reg1 &lt;&lt; 6) | (reg2 &lt;&lt; 3) | reg3);
2886         }
2887 
2888         ALWAYS_INLINE void oneWordOp7Imm9(OpcodeID op, uint16_t imm)
2889         {
2890             m_buffer.putShort(op | imm);
2891         }
2892 
2893         ALWAYS_INLINE void oneWordOp8Imm8(OpcodeID op, uint8_t imm)
2894         {
2895             m_buffer.putShort(op | imm);
2896         }
2897 
2898         ALWAYS_INLINE void oneWordOp8RegReg143(OpcodeID op, RegisterID reg1, RegisterID reg2)
2899         {
2900             m_buffer.putShort(op | ((reg2 &amp; 8) &lt;&lt; 4) | (reg1 &lt;&lt; 3) | (reg2 &amp; 7));
2901         }
2902 
2903         ALWAYS_INLINE void oneWordOp9Imm7(OpcodeID op, uint8_t imm)
2904         {
2905             m_buffer.putShort(op | imm);
2906         }
2907 
2908         ALWAYS_INLINE void oneWordOp10Reg3Reg3(OpcodeID op, RegisterID reg1, RegisterID reg2)
2909         {
2910             m_buffer.putShort(op | (reg1 &lt;&lt; 3) | reg2);
2911         }
2912 
2913         ALWAYS_INLINE void twoWordOp12Reg4FourFours(OpcodeID1 op, RegisterID reg, FourFours ff)
2914         {
2915             m_buffer.putShort(op | reg);
2916             m_buffer.putShort(ff.m_u.value);
2917         }
2918 
2919         ALWAYS_INLINE void twoWordOp16FourFours(OpcodeID1 op, FourFours ff)
2920         {
2921             m_buffer.putShort(op);
2922             m_buffer.putShort(ff.m_u.value);
2923         }
2924 
2925         ALWAYS_INLINE void twoWordOp16Op16(OpcodeID1 op1, OpcodeID2 op2)
2926         {
2927             m_buffer.putShort(op1);
2928             m_buffer.putShort(op2);
2929         }
2930 
2931         ALWAYS_INLINE void twoWordOp16Imm16(OpcodeID1 op1, uint16_t imm)
2932         {
2933             m_buffer.putShort(op1);
2934             m_buffer.putShort(imm);
2935         }
2936 
2937         ALWAYS_INLINE void twoWordOp5i6Imm4Reg4EncodedImm(OpcodeID1 op, int imm4, RegisterID rd, ARMThumbImmediate imm)
2938         {
2939             ARMThumbImmediate newImm = imm;
2940             newImm.m_value.imm4 = imm4;
2941 
2942             m_buffer.putShort(ARMv7Assembler::twoWordOp5i6Imm4Reg4EncodedImmFirst(op, newImm));
2943             m_buffer.putShort(ARMv7Assembler::twoWordOp5i6Imm4Reg4EncodedImmSecond(rd, newImm));
2944         }
2945 
2946         ALWAYS_INLINE void twoWordOp12Reg4Reg4Imm12(OpcodeID1 op, RegisterID reg1, RegisterID reg2, uint16_t imm)
2947         {
2948             m_buffer.putShort(op | reg1);
2949             m_buffer.putShort((reg2 &lt;&lt; 12) | imm);
2950         }
2951 
2952         ALWAYS_INLINE void twoWordOp12Reg40Imm3Reg4Imm20Imm5(OpcodeID1 op, RegisterID reg1, RegisterID reg2, uint16_t imm1, uint16_t imm2, uint16_t imm3)
2953         {
2954             m_buffer.putShort(op | reg1);
2955             m_buffer.putShort((imm1 &lt;&lt; 12) | (reg2 &lt;&lt; 8) | (imm2 &lt;&lt; 6) | imm3);
2956         }
2957 
2958         // Formats up instructions of the pattern:
2959         //    111111111B11aaaa:bbbb222SA2C2cccc
2960         // Where 1s in the pattern come from op1, 2s in the pattern come from op2, S is the provided size bit.
2961         // Operands provide 5 bit values of the form Aaaaa, Bbbbb, Ccccc.
2962         ALWAYS_INLINE void vfpOp(OpcodeID1 op1, OpcodeID2 op2, bool size, VFPOperand a, VFPOperand b, VFPOperand c)
2963         {
2964             ASSERT(!(op1 &amp; 0x004f));
2965             ASSERT(!(op2 &amp; 0xf1af));
2966             m_buffer.putShort(op1 | b.bits1() &lt;&lt; 6 | a.bits4());
2967             m_buffer.putShort(op2 | b.bits4() &lt;&lt; 12 | size &lt;&lt; 8 | a.bits1() &lt;&lt; 7 | c.bits1() &lt;&lt; 5 | c.bits4());
2968         }
2969 
2970         // Arm vfp addresses can be offset by a 9-bit ones-comp immediate, left shifted by 2.
2971         // (i.e. +/-(0..255) 32-bit words)
2972         ALWAYS_INLINE void vfpMemOp(OpcodeID1 op1, OpcodeID2 op2, bool size, RegisterID rn, VFPOperand rd, int32_t imm)
2973         {
2974             bool up = true;
2975             if (imm &lt; 0) {
2976                 imm = -imm;
2977                 up = false;
2978             }
2979 
2980             uint32_t offset = imm;
2981             ASSERT(!(offset &amp; ~0x3fc));
2982             offset &gt;&gt;= 2;
2983 
2984             m_buffer.putShort(op1 | (up &lt;&lt; 7) | rd.bits1() &lt;&lt; 6 | rn);
2985             m_buffer.putShort(op2 | rd.bits4() &lt;&lt; 12 | size &lt;&lt; 8 | offset);
2986         }
2987 
2988         // Administrative methods:
2989 
2990         size_t codeSize() const { return m_buffer.codeSize(); }
2991         AssemblerLabel label() const { return m_buffer.label(); }
2992         bool isAligned(int alignment) const { return m_buffer.isAligned(alignment); }
2993         void* data() const { return m_buffer.data(); }
2994 
2995         unsigned debugOffset() { return m_buffer.debugOffset(); }
2996 
2997         AssemblerBuffer m_buffer;
2998     } m_formatter;
2999 
3000     Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt; m_jumpsToLink;
3001     int m_indexOfLastWatchpoint;
3002     int m_indexOfTailOfLastWatchpoint;
3003 };
3004 
3005 } // namespace JSC
3006 
3007 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM_THUMB2)
    </pre>
  </body>
</html>