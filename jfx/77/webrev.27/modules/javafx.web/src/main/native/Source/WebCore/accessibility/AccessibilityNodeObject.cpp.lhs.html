<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2 * Copyright (C) 2012, Google Inc. All rights reserved.
   3 *
   4 * Redistribution and use in source and binary forms, with or without
   5 * modification, are permitted provided that the following conditions
   6 * are met:
   7 *
   8 * 1.  Redistributions of source code must retain the above copyright
   9 *     notice, this list of conditions and the following disclaimer.
  10 * 2.  Redistributions in binary form must reproduce the above copyright
  11 *     notice, this list of conditions and the following disclaimer in the
  12 *     documentation and/or other materials provided with the distribution.
  13 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14 *     its contributors may be used to endorse or promote products derived
  15 *     from this software without specific prior written permission.
  16 *
  17 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27 */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityNodeObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityImageMapLink.h&quot;
  34 #include &quot;AccessibilityList.h&quot;
  35 #include &quot;AccessibilityListBox.h&quot;
  36 #include &quot;AccessibilitySpinButton.h&quot;
  37 #include &quot;AccessibilityTable.h&quot;
  38 #include &quot;Editing.h&quot;
  39 #include &quot;ElementIterator.h&quot;
  40 #include &quot;EventNames.h&quot;
  41 #include &quot;FloatRect.h&quot;
  42 #include &quot;Frame.h&quot;
  43 #include &quot;FrameLoader.h&quot;
  44 #include &quot;FrameSelection.h&quot;
  45 #include &quot;FrameView.h&quot;
  46 #include &quot;HTMLCanvasElement.h&quot;
  47 #include &quot;HTMLDetailsElement.h&quot;
  48 #include &quot;HTMLFieldSetElement.h&quot;
  49 #include &quot;HTMLFormElement.h&quot;
  50 #include &quot;HTMLImageElement.h&quot;
  51 #include &quot;HTMLInputElement.h&quot;
  52 #include &quot;HTMLLabelElement.h&quot;
  53 #include &quot;HTMLLegendElement.h&quot;
  54 #include &quot;HTMLNames.h&quot;
  55 #include &quot;HTMLParserIdioms.h&quot;
  56 #include &quot;HTMLSelectElement.h&quot;
  57 #include &quot;HTMLTextAreaElement.h&quot;
  58 #include &quot;HTMLTextFormControlElement.h&quot;
  59 #include &quot;LabelableElement.h&quot;
  60 #include &quot;LocalizedStrings.h&quot;
  61 #include &quot;MathMLElement.h&quot;
  62 #include &quot;MathMLNames.h&quot;
  63 #include &quot;NodeList.h&quot;
  64 #include &quot;NodeTraversal.h&quot;
  65 #include &quot;ProgressTracker.h&quot;
  66 #include &quot;RenderImage.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;SVGElement.h&quot;
  69 #include &quot;Text.h&quot;
  70 #include &quot;TextControlInnerElements.h&quot;
  71 #include &quot;UserGestureIndicator.h&quot;
  72 #include &quot;VisibleUnits.h&quot;
  73 #include &quot;Widget.h&quot;
  74 #include &lt;wtf/StdLibExtras.h&gt;
  75 #include &lt;wtf/text/StringBuilder.h&gt;
  76 #include &lt;wtf/unicode/CharacterNames.h&gt;
  77 
  78 namespace WebCore {
  79 
  80 using namespace HTMLNames;
  81 
  82 static String accessibleNameForNode(Node* node, Node* labelledbyNode = nullptr);
  83 
  84 AccessibilityNodeObject::AccessibilityNodeObject(Node* node)
  85     : AccessibilityObject()
  86     , m_node(node)
  87 {
  88 }
  89 
  90 AccessibilityNodeObject::~AccessibilityNodeObject()
  91 {
  92     ASSERT(isDetached());
  93 }
  94 
  95 void AccessibilityNodeObject::init()
  96 {
  97 #ifndef NDEBUG
  98     ASSERT(!m_initialized);
  99     m_initialized = true;
 100 #endif
 101     m_role = determineAccessibilityRole();
 102 }
 103 
 104 Ref&lt;AccessibilityNodeObject&gt; AccessibilityNodeObject::create(Node* node)
 105 {
 106     return adoptRef(*new AccessibilityNodeObject(node));
 107 }
 108 
 109 void AccessibilityNodeObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
 110 {
 111     // AccessibilityObject calls clearChildren.
 112     AccessibilityObject::detach(detachmentType, cache);
 113     m_node = nullptr;
 114 }
 115 
 116 void AccessibilityNodeObject::childrenChanged()
 117 {
 118     // This method is meant as a quick way of marking a portion of the accessibility tree dirty.
 119     if (!node() &amp;&amp; !renderer())
 120         return;
 121 
 122     AXObjectCache* cache = axObjectCache();
 123     if (!cache)
 124         return;
 125     cache-&gt;postNotification(this, document(), AXObjectCache::AXChildrenChanged);
 126 
 127     // Should make the sub tree dirty so that everything below will be updated correctly.
 128     this-&gt;setNeedsToUpdateSubtree();
 129     bool shouldStopUpdatingParent = false;
 130 
 131     // Go up the accessibility parent chain, but only if the element already exists. This method is
 132     // called during render layouts, minimal work should be done.
 133     // If AX elements are created now, they could interrogate the render tree while it&#39;s in a funky state.
 134     // At the same time, process ARIA live region changes.
 135     for (AccessibilityObject* parent = this; parent; parent = parent-&gt;parentObjectIfExists()) {
 136         if (!shouldStopUpdatingParent)
 137             parent-&gt;setNeedsToUpdateChildren();
 138 
 139 
 140         // These notifications always need to be sent because screenreaders are reliant on them to perform.
 141         // In other words, they need to be sent even when the screen reader has not accessed this live region since the last update.
 142 
 143         // If this element supports ARIA live regions, then notify the AT of changes.
 144         // Sometimes this function can be called many times within a short period of time, leading to posting too many AXLiveRegionChanged
 145         // notifications. To fix this, we used a timer to make sure we only post one notification for the children changes within a pre-defined
 146         // time interval.
 147         if (parent-&gt;supportsLiveRegion())
 148             cache-&gt;postLiveRegionChangeNotification(parent);
 149 
 150         // If this element is an ARIA text control, notify the AT of changes.
 151         if (parent-&gt;isNonNativeTextControl()) {
 152             cache-&gt;postNotification(parent, parent-&gt;document(), AXObjectCache::AXValueChanged);
 153 
 154             // Do not let the parent that&#39;s above the editable ancestor update its children
 155             // since we already notify the AT of changes.
 156             shouldStopUpdatingParent = true;
 157         }
 158     }
 159 }
 160 
 161 void AccessibilityNodeObject::updateAccessibilityRole()
 162 {
 163     bool ignoredStatus = accessibilityIsIgnored();
 164     m_role = determineAccessibilityRole();
 165 
 166     // The AX hierarchy only needs to be updated if the ignored status of an element has changed.
 167     if (ignoredStatus != accessibilityIsIgnored())
 168         childrenChanged();
 169 }
 170 
 171 AccessibilityObject* AccessibilityNodeObject::firstChild() const
 172 {
 173     if (!node())
 174         return nullptr;
 175 
 176     Node* firstChild = node()-&gt;firstChild();
 177 
 178     if (!firstChild)
 179         return nullptr;
 180 
<a name="1" id="anc1"></a><span class="line-modified"> 181     return axObjectCache()-&gt;getOrCreate(firstChild);</span>

 182 }
 183 
 184 AccessibilityObject* AccessibilityNodeObject::lastChild() const
 185 {
 186     if (!node())
 187         return nullptr;
 188 
 189     Node* lastChild = node()-&gt;lastChild();
 190     if (!lastChild)
 191         return nullptr;
 192 
<a name="2" id="anc2"></a><span class="line-modified"> 193     return axObjectCache()-&gt;getOrCreate(lastChild);</span>

 194 }
 195 
 196 AccessibilityObject* AccessibilityNodeObject::previousSibling() const
 197 {
 198     if (!node())
 199         return nullptr;
 200 
 201     Node* previousSibling = node()-&gt;previousSibling();
 202     if (!previousSibling)
 203         return nullptr;
 204 
<a name="3" id="anc3"></a><span class="line-modified"> 205     return axObjectCache()-&gt;getOrCreate(previousSibling);</span>

 206 }
 207 
 208 AccessibilityObject* AccessibilityNodeObject::nextSibling() const
 209 {
 210     if (!node())
 211         return nullptr;
 212 
 213     Node* nextSibling = node()-&gt;nextSibling();
 214     if (!nextSibling)
 215         return nullptr;
 216 
<a name="4" id="anc4"></a><span class="line-modified"> 217     return axObjectCache()-&gt;getOrCreate(nextSibling);</span>

 218 }
 219 
 220 AccessibilityObject* AccessibilityNodeObject::parentObjectIfExists() const
 221 {
 222     return parentObject();
 223 }
 224 
 225 AccessibilityObject* AccessibilityNodeObject::parentObject() const
 226 {
 227     if (!node())
 228         return nullptr;
 229 
 230     Node* parentObj = node()-&gt;parentNode();
 231     if (!parentObj)
 232         return nullptr;
 233 
 234     if (AXObjectCache* cache = axObjectCache())
 235         return cache-&gt;getOrCreate(parentObj);
 236 
 237     return nullptr;
 238 }
 239 
 240 LayoutRect AccessibilityNodeObject::elementRect() const
 241 {
 242     return boundingBoxRect();
 243 }
 244 
 245 LayoutRect AccessibilityNodeObject::boundingBoxRect() const
 246 {
 247     // AccessibilityNodeObjects have no mechanism yet to return a size or position.
 248     // For now, let&#39;s return the position of the ancestor that does have a position,
 249     // and make it the width of that parent, and about the height of a line of text, so that it&#39;s clear the object is a child of the parent.
 250 
 251     LayoutRect boundingBox;
 252 
 253     for (AccessibilityObject* positionProvider = parentObject(); positionProvider; positionProvider = positionProvider-&gt;parentObject()) {
 254         if (positionProvider-&gt;isAccessibilityRenderObject()) {
 255             LayoutRect parentRect = positionProvider-&gt;elementRect();
 256             boundingBox.setSize(LayoutSize(parentRect.width(), LayoutUnit(std::min(10.0f, parentRect.height().toFloat()))));
 257             boundingBox.setLocation(parentRect.location());
 258             break;
 259         }
 260     }
 261 
 262     return boundingBox;
 263 }
 264 
 265 void AccessibilityNodeObject::setNode(Node* node)
 266 {
 267     m_node = node;
 268 }
 269 
 270 Document* AccessibilityNodeObject::document() const
 271 {
 272     if (!node())
 273         return nullptr;
 274     return &amp;node()-&gt;document();
 275 }
 276 
 277 AccessibilityRole AccessibilityNodeObject::determineAccessibilityRole()
 278 {
 279     if (!node())
 280         return AccessibilityRole::Unknown;
 281 
 282     if ((m_ariaRole = determineAriaRoleAttribute()) != AccessibilityRole::Unknown)
 283         return m_ariaRole;
 284 
 285     if (node()-&gt;isLink())
 286         return AccessibilityRole::WebCoreLink;
 287     if (node()-&gt;isTextNode())
 288         return AccessibilityRole::StaticText;
 289     if (node()-&gt;hasTagName(buttonTag))
 290         return buttonRoleType();
 291     if (is&lt;HTMLInputElement&gt;(*node())) {
 292         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node());
 293         if (input.isCheckbox())
 294             return AccessibilityRole::CheckBox;
 295         if (input.isRadioButton())
 296             return AccessibilityRole::RadioButton;
 297         if (input.isTextButton())
 298             return buttonRoleType();
 299         if (input.isRangeControl())
 300             return AccessibilityRole::Slider;
 301         if (input.isInputTypeHidden())
 302             return AccessibilityRole::Ignored;
 303         if (input.isSearchField())
 304             return AccessibilityRole::SearchField;
 305 #if ENABLE(INPUT_TYPE_COLOR)
 306         if (input.isColorControl())
 307             return AccessibilityRole::ColorWell;
 308 #endif
 309         return AccessibilityRole::TextField;
 310     }
 311     if (node()-&gt;hasTagName(selectTag)) {
 312         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*node());
 313         return selectElement.multiple() ? AccessibilityRole::ListBox : AccessibilityRole::PopUpButton;
 314     }
 315     if (is&lt;HTMLTextAreaElement&gt;(*node()))
 316         return AccessibilityRole::TextArea;
 317     if (headingLevel())
 318         return AccessibilityRole::Heading;
 319     if (node()-&gt;hasTagName(blockquoteTag))
 320         return AccessibilityRole::Blockquote;
 321     if (node()-&gt;hasTagName(divTag))
 322         return AccessibilityRole::Div;
 323     if (node()-&gt;hasTagName(pTag))
 324         return AccessibilityRole::Paragraph;
 325     if (is&lt;HTMLLabelElement&gt;(*node()))
 326         return AccessibilityRole::Label;
 327     if (is&lt;Element&gt;(*node()) &amp;&amp; downcast&lt;Element&gt;(*node()).isFocusable())
 328         return AccessibilityRole::Group;
 329 
 330     return AccessibilityRole::Unknown;
 331 }
 332 
 333 void AccessibilityNodeObject::addChildren()
 334 {
 335     // If the need to add more children in addition to existing children arises,
 336     // childrenChanged should have been called, leaving the object with no children.
 337     ASSERT(!m_haveChildren);
 338 
 339     if (!m_node)
 340         return;
 341 
 342     m_haveChildren = true;
 343 
 344     // The only time we add children from the DOM tree to a node with a renderer is when it&#39;s a canvas.
 345     if (renderer() &amp;&amp; !m_node-&gt;hasTagName(canvasTag))
 346         return;
 347 
<a name="5" id="anc5"></a>



 348     for (Node* child = m_node-&gt;firstChild(); child; child = child-&gt;nextSibling())
<a name="6" id="anc6"></a><span class="line-modified"> 349         addChild(axObjectCache()-&gt;getOrCreate(child));</span>
 350 
 351     m_subtreeDirty = false;
 352 }
 353 
 354 bool AccessibilityNodeObject::canHaveChildren() const
 355 {
 356     // If this is an AccessibilityRenderObject, then it&#39;s okay if this object
 357     // doesn&#39;t have a node - there are some renderers that don&#39;t have associated
 358     // nodes, like scroll areas and css-generated text.
 359     if (!node() &amp;&amp; !isAccessibilityRenderObject())
 360         return false;
 361 
 362     // When &lt;noscript&gt; is not being used (its renderer() == 0), ignore its children.
 363     if (node() &amp;&amp; !renderer() &amp;&amp; node()-&gt;hasTagName(noscriptTag))
 364         return false;
 365 
 366     // Elements that should not have children
 367     switch (roleValue()) {
 368     case AccessibilityRole::Image:
 369     case AccessibilityRole::Button:
 370     case AccessibilityRole::PopUpButton:
 371     case AccessibilityRole::CheckBox:
 372     case AccessibilityRole::RadioButton:
 373     case AccessibilityRole::Tab:
 374     case AccessibilityRole::ToggleButton:
 375     case AccessibilityRole::StaticText:
 376     case AccessibilityRole::ListBoxOption:
 377     case AccessibilityRole::ScrollBar:
 378     case AccessibilityRole::ProgressIndicator:
 379     case AccessibilityRole::Switch:
 380     case AccessibilityRole::MenuItemCheckbox:
 381     case AccessibilityRole::MenuItemRadio:
 382     case AccessibilityRole::Splitter:
<a name="7" id="anc7"></a>
 383         return false;
 384     case AccessibilityRole::DocumentMath:
 385 #if ENABLE(MATHML)
 386         return node()-&gt;isMathMLElement();
 387 #endif
 388         return false;
 389     default:
 390         return true;
 391     }
 392 }
 393 
 394 bool AccessibilityNodeObject::computeAccessibilityIsIgnored() const
 395 {
 396 #ifndef NDEBUG
 397     // Double-check that an AccessibilityObject is never accessed before
 398     // it&#39;s been initialized.
 399     ASSERT(m_initialized);
 400 #endif
 401 
 402     // Handle non-rendered text that is exposed through aria-hidden=false.
 403     if (m_node &amp;&amp; m_node-&gt;isTextNode() &amp;&amp; !renderer()) {
 404         // Fallback content in iframe nodes should be ignored.
 405         if (m_node-&gt;parentNode() &amp;&amp; m_node-&gt;parentNode()-&gt;hasTagName(iframeTag) &amp;&amp; m_node-&gt;parentNode()-&gt;renderer())
 406             return true;
 407 
 408         // Whitespace only text elements should be ignored when they have no renderer.
 409         String string = stringValue().stripWhiteSpace().simplifyWhiteSpace();
 410         if (!string.length())
 411             return true;
 412     }
 413 
 414     AccessibilityObjectInclusion decision = defaultObjectInclusion();
 415     if (decision == AccessibilityObjectInclusion::IncludeObject)
 416         return false;
 417     if (decision == AccessibilityObjectInclusion::IgnoreObject)
 418         return true;
 419     // If this element is within a parent that cannot have children, it should not be exposed.
 420     if (isDescendantOfBarrenParent())
 421         return true;
 422 
 423     if (roleValue() == AccessibilityRole::Ignored)
 424         return true;
 425 
 426     return m_role == AccessibilityRole::Unknown;
 427 }
 428 
 429 bool AccessibilityNodeObject::canvasHasFallbackContent() const
 430 {
 431     Node* node = this-&gt;node();
 432     if (!is&lt;HTMLCanvasElement&gt;(node))
 433         return false;
 434     HTMLCanvasElement&amp; canvasElement = downcast&lt;HTMLCanvasElement&gt;(*node);
 435     // If it has any children that are elements, we&#39;ll assume it might be fallback
 436     // content. If it has no children or its only children are not elements
 437     // (e.g. just text nodes), it doesn&#39;t have fallback content.
 438     return childrenOfType&lt;Element&gt;(canvasElement).first();
 439 }
 440 
 441 bool AccessibilityNodeObject::isImageButton() const
 442 {
 443     return isNativeImage() &amp;&amp; isButton();
 444 }
 445 
 446 bool AccessibilityNodeObject::isNativeTextControl() const
 447 {
 448     Node* node = this-&gt;node();
 449     if (!node)
 450         return false;
 451 
 452     if (is&lt;HTMLTextAreaElement&gt;(*node))
 453         return true;
 454 
 455     if (is&lt;HTMLInputElement&gt;(*node)) {
 456         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 457         return input.isText() || input.isNumberField();
 458     }
 459 
 460     return false;
 461 }
 462 
 463 bool AccessibilityNodeObject::isSearchField() const
 464 {
 465     Node* node = this-&gt;node();
 466     if (!node)
 467         return false;
 468 
 469     if (roleValue() == AccessibilityRole::SearchField)
 470         return true;
 471 
 472     if (!is&lt;HTMLInputElement&gt;(*node))
 473         return false;
 474 
 475     auto&amp; inputElement = downcast&lt;HTMLInputElement&gt;(*node);
 476 
 477     // Some websites don&#39;t label their search fields as such. However, they will
 478     // use the word &quot;search&quot; in either the form or input type. This won&#39;t catch every case,
 479     // but it will catch google.com for example.
 480 
 481     // Check the node name of the input type, sometimes it&#39;s &quot;search&quot;.
<a name="8" id="anc8"></a><span class="line-modified"> 482     const AtomicString&amp; nameAttribute = getAttribute(nameAttr);</span>
 483     if (nameAttribute.containsIgnoringASCIICase(&quot;search&quot;))
 484         return true;
 485 
 486     // Check the form action and the name, which will sometimes be &quot;search&quot;.
 487     auto* form = inputElement.form();
 488     if (form &amp;&amp; (form-&gt;name().containsIgnoringASCIICase(&quot;search&quot;) || form-&gt;action().containsIgnoringASCIICase(&quot;search&quot;)))
 489         return true;
 490 
 491     return false;
 492 }
 493 
 494 bool AccessibilityNodeObject::isNativeImage() const
 495 {
 496     Node* node = this-&gt;node();
 497     if (!node)
 498         return false;
 499 
 500     if (is&lt;HTMLImageElement&gt;(*node))
 501         return true;
 502 
 503     if (node-&gt;hasTagName(appletTag) || node-&gt;hasTagName(embedTag) || node-&gt;hasTagName(objectTag))
 504         return true;
 505 
 506     if (is&lt;HTMLInputElement&gt;(*node)) {
 507         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 508         return input.isImageButton();
 509     }
 510 
 511     return false;
 512 }
 513 
 514 bool AccessibilityNodeObject::isImage() const
 515 {
 516     return roleValue() == AccessibilityRole::Image;
 517 }
 518 
 519 bool AccessibilityNodeObject::isPasswordField() const
 520 {
 521     auto* node = this-&gt;node();
 522     if (!is&lt;HTMLInputElement&gt;(node))
 523         return false;
 524 
 525     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
 526         return false;
 527 
 528     return downcast&lt;HTMLInputElement&gt;(*node).isPasswordField();
 529 }
 530 
 531 AccessibilityObject* AccessibilityNodeObject::passwordFieldOrContainingPasswordField()
 532 {
 533     Node* node = this-&gt;node();
 534     if (!node)
 535         return nullptr;
 536 
 537     if (is&lt;HTMLInputElement&gt;(*node) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*node).isPasswordField())
 538         return this;
 539 
 540     auto* element = node-&gt;shadowHost();
 541     if (!is&lt;HTMLInputElement&gt;(element))
 542         return nullptr;
 543 
 544     if (auto* cache = axObjectCache())
 545         return cache-&gt;getOrCreate(element);
 546 
 547     return nullptr;
 548 }
 549 
 550 bool AccessibilityNodeObject::isInputImage() const
 551 {
 552     Node* node = this-&gt;node();
 553     if (is&lt;HTMLInputElement&gt;(node) &amp;&amp; roleValue() == AccessibilityRole::Button) {
 554         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 555         return input.isImageButton();
 556     }
 557 
 558     return false;
 559 }
 560 
 561 bool AccessibilityNodeObject::isProgressIndicator() const
 562 {
<a name="9" id="anc9"></a><span class="line-modified"> 563     return roleValue() == AccessibilityRole::ProgressIndicator;</span>
 564 }
 565 
 566 bool AccessibilityNodeObject::isSlider() const
 567 {
 568     return roleValue() == AccessibilityRole::Slider;
 569 }
 570 
 571 bool AccessibilityNodeObject::isMenuRelated() const
 572 {
 573     switch (roleValue()) {
 574     case AccessibilityRole::Menu:
 575     case AccessibilityRole::MenuBar:
 576     case AccessibilityRole::MenuButton:
 577     case AccessibilityRole::MenuItem:
 578     case AccessibilityRole::MenuItemCheckbox:
 579     case AccessibilityRole::MenuItemRadio:
 580         return true;
 581     default:
 582         return false;
 583     }
 584 }
 585 
 586 bool AccessibilityNodeObject::isMenu() const
 587 {
 588     return roleValue() == AccessibilityRole::Menu;
 589 }
 590 
 591 bool AccessibilityNodeObject::isMenuBar() const
 592 {
 593     return roleValue() == AccessibilityRole::MenuBar;
 594 }
 595 
 596 bool AccessibilityNodeObject::isMenuButton() const
 597 {
 598     return roleValue() == AccessibilityRole::MenuButton;
 599 }
 600 
 601 bool AccessibilityNodeObject::isMenuItem() const
 602 {
 603     switch (roleValue()) {
 604     case AccessibilityRole::MenuItem:
 605     case AccessibilityRole::MenuItemRadio:
 606     case AccessibilityRole::MenuItemCheckbox:
 607         return true;
 608     default:
 609         return false;
 610     }
 611 }
 612 
 613 bool AccessibilityNodeObject::isNativeCheckboxOrRadio() const
 614 {
 615     Node* node = this-&gt;node();
 616     if (!is&lt;HTMLInputElement&gt;(node))
 617         return false;
 618 
 619     auto&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 620     return input.isCheckbox() || input.isRadioButton();
 621 }
 622 
 623 bool AccessibilityNodeObject::isEnabled() const
 624 {
 625     // ARIA says that the disabled status applies to the current element and all descendant elements.
 626     for (AccessibilityObject* object = const_cast&lt;AccessibilityNodeObject*&gt;(this); object; object = object-&gt;parentObject()) {
<a name="10" id="anc10"></a><span class="line-modified"> 627         const AtomicString&amp; disabledStatus = object-&gt;getAttribute(aria_disabledAttr);</span>
 628         if (equalLettersIgnoringASCIICase(disabledStatus, &quot;true&quot;))
 629             return false;
 630         if (equalLettersIgnoringASCIICase(disabledStatus, &quot;false&quot;))
 631             break;
 632     }
 633 
 634     if (roleValue() == AccessibilityRole::HorizontalRule)
 635         return false;
 636 
 637     Node* node = this-&gt;node();
 638     if (!is&lt;Element&gt;(node))
 639         return true;
 640 
 641     return !downcast&lt;Element&gt;(*node).isDisabledFormControl();
 642 }
 643 
 644 bool AccessibilityNodeObject::isIndeterminate() const
 645 {
 646     return equalLettersIgnoringASCIICase(getAttribute(indeterminateAttr), &quot;true&quot;);
 647 }
 648 
 649 bool AccessibilityNodeObject::isPressed() const
 650 {
 651     if (!isButton())
 652         return false;
 653 
 654     Node* node = this-&gt;node();
 655     if (!node)
 656         return false;
 657 
 658     // If this is an toggle button, check the aria-pressed attribute rather than node()-&gt;active()
 659     if (isToggleButton())
 660         return equalLettersIgnoringASCIICase(getAttribute(aria_pressedAttr), &quot;true&quot;);
 661 
 662     if (!is&lt;Element&gt;(*node))
 663         return false;
 664     return downcast&lt;Element&gt;(*node).active();
 665 }
 666 
 667 bool AccessibilityNodeObject::isChecked() const
 668 {
 669     Node* node = this-&gt;node();
 670     if (!node)
 671         return false;
 672 
 673     // First test for native checkedness semantics
 674     if (is&lt;HTMLInputElement&gt;(*node))
 675         return downcast&lt;HTMLInputElement&gt;(*node).shouldAppearChecked();
 676 
 677     // Else, if this is an ARIA checkbox or radio, respect the aria-checked attribute
 678     bool validRole = false;
 679     switch (ariaRoleAttribute()) {
 680     case AccessibilityRole::RadioButton:
 681     case AccessibilityRole::CheckBox:
 682     case AccessibilityRole::MenuItem:
 683     case AccessibilityRole::MenuItemCheckbox:
 684     case AccessibilityRole::MenuItemRadio:
 685     case AccessibilityRole::Switch:
 686         validRole = true;
 687         break;
 688     default:
 689         break;
 690     }
 691 
 692     if (validRole &amp;&amp; equalLettersIgnoringASCIICase(getAttribute(aria_checkedAttr), &quot;true&quot;))
 693         return true;
 694 
 695     return false;
 696 }
 697 
 698 bool AccessibilityNodeObject::isHovered() const
 699 {
 700     Node* node = this-&gt;node();
 701     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hovered();
 702 }
 703 
 704 bool AccessibilityNodeObject::isMultiSelectable() const
 705 {
<a name="11" id="anc11"></a><span class="line-modified"> 706     const AtomicString&amp; ariaMultiSelectable = getAttribute(aria_multiselectableAttr);</span>
 707     if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;true&quot;))
 708         return true;
 709     if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;false&quot;))
 710         return false;
 711 
 712     return node() &amp;&amp; node()-&gt;hasTagName(selectTag) &amp;&amp; downcast&lt;HTMLSelectElement&gt;(*node()).multiple();
 713 }
 714 
 715 bool AccessibilityNodeObject::isRequired() const
 716 {
 717     // Explicit aria-required values should trump native required attributes.
<a name="12" id="anc12"></a><span class="line-modified"> 718     const AtomicString&amp; requiredValue = getAttribute(aria_requiredAttr);</span>
 719     if (equalLettersIgnoringASCIICase(requiredValue, &quot;true&quot;))
 720         return true;
 721     if (equalLettersIgnoringASCIICase(requiredValue, &quot;false&quot;))
 722         return false;
 723 
 724     Node* n = this-&gt;node();
 725     if (is&lt;HTMLFormControlElement&gt;(n))
 726         return downcast&lt;HTMLFormControlElement&gt;(*n).isRequired();
 727 
 728     return false;
 729 }
 730 
 731 bool AccessibilityNodeObject::supportsRequiredAttribute() const
 732 {
 733     switch (roleValue()) {
 734     case AccessibilityRole::Button:
 735         return isFileUploadButton();
 736     case AccessibilityRole::Cell:
 737     case AccessibilityRole::ColumnHeader:
 738     case AccessibilityRole::CheckBox:
 739     case AccessibilityRole::ComboBox:
 740     case AccessibilityRole::Grid:
 741     case AccessibilityRole::GridCell:
 742     case AccessibilityRole::Incrementor:
 743     case AccessibilityRole::ListBox:
 744     case AccessibilityRole::PopUpButton:
 745     case AccessibilityRole::RadioButton:
 746     case AccessibilityRole::RadioGroup:
 747     case AccessibilityRole::RowHeader:
 748     case AccessibilityRole::Slider:
 749     case AccessibilityRole::SpinButton:
 750     case AccessibilityRole::TableHeaderContainer:
 751     case AccessibilityRole::TextArea:
 752     case AccessibilityRole::TextField:
 753     case AccessibilityRole::ToggleButton:
 754         return true;
 755     default:
 756         return false;
 757     }
 758 }
 759 
 760 int AccessibilityNodeObject::headingLevel() const
 761 {
 762     // headings can be in block flow and non-block flow
 763     Node* node = this-&gt;node();
 764     if (!node)
 765         return false;
 766 
 767     if (isHeading()) {
 768         int ariaLevel = getAttribute(aria_levelAttr).toInt();
 769         if (ariaLevel &gt; 0)
 770             return ariaLevel;
 771     }
 772 
 773     if (node-&gt;hasTagName(h1Tag))
 774         return 1;
 775 
 776     if (node-&gt;hasTagName(h2Tag))
 777         return 2;
 778 
 779     if (node-&gt;hasTagName(h3Tag))
 780         return 3;
 781 
 782     if (node-&gt;hasTagName(h4Tag))
 783         return 4;
 784 
 785     if (node-&gt;hasTagName(h5Tag))
 786         return 5;
 787 
 788     if (node-&gt;hasTagName(h6Tag))
 789         return 6;
 790 
 791     // The implicit value of aria-level is 2 for the heading role.
 792     // https://www.w3.org/TR/wai-aria-1.1/#heading
 793     if (ariaRoleAttribute() == AccessibilityRole::Heading)
 794         return 2;
 795 
 796     return 0;
 797 }
 798 
 799 String AccessibilityNodeObject::valueDescription() const
 800 {
 801     if (!isRangeControl())
 802         return String();
 803 
 804     return getAttribute(aria_valuetextAttr).string();
 805 }
 806 
 807 float AccessibilityNodeObject::valueForRange() const
 808 {
 809     if (is&lt;HTMLInputElement&gt;(node())) {
 810         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node());
 811         if (input.isRangeControl())
 812             return input.valueAsNumber();
 813     }
 814 
 815     if (!isRangeControl())
 816         return 0.0f;
 817 
 818     // In ARIA 1.1, the implicit value for aria-valuenow on a spin button is 0.
 819     // For other roles, it is half way between aria-valuemin and aria-valuemax.
 820     auto&amp; value = getAttribute(aria_valuenowAttr);
 821     if (!value.isEmpty())
 822         return value.toFloat();
 823 
 824     return isSpinButton() ? 0 : (minValueForRange() + maxValueForRange()) / 2;
 825 }
 826 
 827 float AccessibilityNodeObject::maxValueForRange() const
 828 {
 829     if (is&lt;HTMLInputElement&gt;(node())) {
 830         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node());
 831         if (input.isRangeControl())
 832             return input.maximum();
 833     }
 834 
 835     if (!isRangeControl())
 836         return 0.0f;
 837 
 838     auto&amp; value = getAttribute(aria_valuemaxAttr);
 839     if (!value.isEmpty())
 840         return value.toFloat();
 841 
 842     // In ARIA 1.1, the implicit value for aria-valuemax on a spin button
 843     // is that there is no maximum value. For other roles, it is 100.
 844     return isSpinButton() ? std::numeric_limits&lt;float&gt;::max() : 100.0f;
 845 }
 846 
 847 float AccessibilityNodeObject::minValueForRange() const
 848 {
 849     if (is&lt;HTMLInputElement&gt;(node())) {
 850         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node());
 851         if (input.isRangeControl())
 852             return input.minimum();
 853     }
 854 
 855     if (!isRangeControl())
 856         return 0.0f;
 857 
 858     auto&amp; value = getAttribute(aria_valueminAttr);
 859     if (!value.isEmpty())
 860         return value.toFloat();
 861 
 862     // In ARIA 1.1, the implicit value for aria-valuemin on a spin button
 863     // is that there is no minimum value. For other roles, it is 0.
 864     return isSpinButton() ? -std::numeric_limits&lt;float&gt;::max() : 0.0f;
 865 }
 866 
 867 float AccessibilityNodeObject::stepValueForRange() const
 868 {
 869     return getAttribute(stepAttr).toFloat();
 870 }
 871 
 872 bool AccessibilityNodeObject::isHeading() const
 873 {
 874     return roleValue() == AccessibilityRole::Heading;
 875 }
 876 
 877 bool AccessibilityNodeObject::isLink() const
 878 {
 879     return roleValue() == AccessibilityRole::WebCoreLink;
 880 }
 881 
 882 bool AccessibilityNodeObject::isControl() const
 883 {
 884     Node* node = this-&gt;node();
 885     if (!node)
 886         return false;
 887 
<a name="13" id="anc13"></a><span class="line-modified"> 888     return is&lt;HTMLFormControlElement&gt;(*node) || AccessibilityObject::isARIAControl(ariaRoleAttribute());</span>
 889 }
 890 
 891 bool AccessibilityNodeObject::isFieldset() const
 892 {
 893     Node* node = this-&gt;node();
 894     if (!node)
 895         return false;
 896 
 897     return node-&gt;hasTagName(fieldsetTag);
 898 }
 899 
 900 bool AccessibilityNodeObject::isGroup() const
 901 {
 902     AccessibilityRole role = roleValue();
 903     return role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup || role == AccessibilityRole::ApplicationGroup || role == AccessibilityRole::ApplicationTextGroup;
 904 }
 905 
 906 AccessibilityObject* AccessibilityNodeObject::selectedRadioButton()
 907 {
 908     if (!isRadioGroup())
 909         return nullptr;
 910 
 911     // Find the child radio button that is selected (ie. the intValue == 1).
 912     for (const auto&amp; child : children()) {
 913         if (child-&gt;roleValue() == AccessibilityRole::RadioButton &amp;&amp; child-&gt;checkboxOrRadioValue() == AccessibilityButtonState::On)
 914             return child.get();
 915     }
 916     return nullptr;
 917 }
 918 
 919 AccessibilityObject* AccessibilityNodeObject::selectedTabItem()
 920 {
 921     if (!isTabList())
 922         return nullptr;
 923 
 924     // FIXME: Is this valid? ARIA tab items support aria-selected; not aria-checked.
 925     // Find the child tab item that is selected (ie. the intValue == 1).
 926     AccessibilityObject::AccessibilityChildrenVector tabs;
 927     tabChildren(tabs);
 928 
 929     for (const auto&amp; child : children()) {
 930         if (child-&gt;isTabItem() &amp;&amp; (child-&gt;isChecked() || child-&gt;isSelected()))
 931             return child.get();
 932     }
 933     return nullptr;
 934 }
 935 
 936 AccessibilityButtonState AccessibilityNodeObject::checkboxOrRadioValue() const
 937 {
 938     if (isNativeCheckboxOrRadio())
 939         return isIndeterminate() ? AccessibilityButtonState::Mixed : isChecked() ? AccessibilityButtonState::On : AccessibilityButtonState::Off;
 940 
 941     return AccessibilityObject::checkboxOrRadioValue();
 942 }
 943 
 944 Element* AccessibilityNodeObject::anchorElement() const
 945 {
 946     Node* node = this-&gt;node();
 947     if (!node)
 948         return nullptr;
 949 
 950     AXObjectCache* cache = axObjectCache();
<a name="14" id="anc14"></a>

 951 
 952     // search up the DOM tree for an anchor element
 953     // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
 954     for ( ; node; node = node-&gt;parentNode()) {
 955         if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
 956             return downcast&lt;Element&gt;(node);
 957     }
 958 
 959     return nullptr;
 960 }
 961 
 962 static bool isNodeActionElement(Node* node)
 963 {
 964     if (is&lt;HTMLInputElement&gt;(*node)) {
 965         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 966         if (!input.isDisabledFormControl() &amp;&amp; (input.isRadioButton() || input.isCheckbox() || input.isTextButton() || input.isFileUpload() || input.isImageButton()))
 967             return true;
 968     } else if (node-&gt;hasTagName(buttonTag) || node-&gt;hasTagName(selectTag))
 969         return true;
 970 
 971     return false;
 972 }
 973 
 974 static Element* nativeActionElement(Node* start)
 975 {
 976     if (!start)
 977         return nullptr;
 978 
 979     // Do a deep-dive to see if any nodes should be used as the action element.
 980     // We have to look at Nodes, since this method should only be called on objects that do not have children (like buttons).
 981     // It solves the problem when authors put role=&quot;button&quot; on a group and leave the actual button inside the group.
 982 
 983     for (Node* child = start-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
 984         if (isNodeActionElement(child))
 985             return downcast&lt;Element&gt;(child);
 986 
 987         if (Element* subChild = nativeActionElement(child))
 988             return subChild;
 989     }
 990     return nullptr;
 991 }
 992 
 993 Element* AccessibilityNodeObject::actionElement() const
 994 {
 995     Node* node = this-&gt;node();
 996     if (!node)
 997         return nullptr;
 998 
 999     if (isNodeActionElement(node))
1000         return downcast&lt;Element&gt;(node);
1001 
1002     if (AccessibilityObject::isARIAInput(ariaRoleAttribute()))
1003         return downcast&lt;Element&gt;(node);
1004 
1005     switch (roleValue()) {
1006     case AccessibilityRole::Button:
1007     case AccessibilityRole::PopUpButton:
1008     case AccessibilityRole::ToggleButton:
1009     case AccessibilityRole::Tab:
1010     case AccessibilityRole::MenuItem:
1011     case AccessibilityRole::MenuItemCheckbox:
1012     case AccessibilityRole::MenuItemRadio:
1013     case AccessibilityRole::ListItem:
1014         // Check if the author is hiding the real control element inside the ARIA element.
1015         if (Element* nativeElement = nativeActionElement(node))
1016             return nativeElement;
1017         return downcast&lt;Element&gt;(node);
1018     default:
1019         break;
1020     }
1021 
1022     Element* elt = anchorElement();
1023     if (!elt)
1024         elt = mouseButtonListener();
1025     return elt;
1026 }
1027 
1028 Element* AccessibilityNodeObject::mouseButtonListener(MouseButtonListenerResultFilter filter) const
1029 {
1030     Node* node = this-&gt;node();
1031     if (!node)
1032         return nullptr;
1033 
1034     // check if our parent is a mouse button listener
1035     // FIXME: Do the continuation search like anchorElement does
1036     for (auto&amp; element : elementLineage(is&lt;Element&gt;(*node) ? downcast&lt;Element&gt;(node) : node-&gt;parentElement())) {
1037         // If we&#39;ve reached the body and this is not a control element, do not expose press action for this element unless filter is IncludeBodyElement.
1038         // It can cause false positives, where every piece of text is labeled as accepting press actions.
1039         if (element.hasTagName(bodyTag) &amp;&amp; isStaticText() &amp;&amp; filter == ExcludeBodyElement)
1040             break;
1041 
1042         if (element.hasEventListeners(eventNames().clickEvent) || element.hasEventListeners(eventNames().mousedownEvent) || element.hasEventListeners(eventNames().mouseupEvent))
1043             return &amp;element;
1044     }
1045 
1046     return nullptr;
1047 }
1048 
1049 bool AccessibilityNodeObject::isDescendantOfBarrenParent() const
1050 {
1051     if (!m_isIgnoredFromParentData.isNull())
1052         return m_isIgnoredFromParentData.isDescendantOfBarrenParent;
1053 
1054     for (AccessibilityObject* object = parentObject(); object; object = object-&gt;parentObject()) {
1055         if (!object-&gt;canHaveChildren())
1056             return true;
1057     }
1058 
1059     return false;
1060 }
1061 
1062 void AccessibilityNodeObject::alterSliderValue(bool increase)
1063 {
1064     if (roleValue() != AccessibilityRole::Slider)
1065         return;
1066 
1067     auto element = this-&gt;element();
1068     if (!element || element-&gt;isDisabledFormControl())
1069         return;
1070 
1071     if (!getAttribute(stepAttr).isEmpty())
1072         changeValueByStep(increase);
1073     else
1074         changeValueByPercent(increase ? 5 : -5);
1075 }
1076 
1077 void AccessibilityNodeObject::increment()
1078 {
<a name="15" id="anc15"></a><span class="line-removed">1079     if (dispatchAccessibilityEventWithType(AccessibilityEventType::Increment))</span>
<span class="line-removed">1080         return;</span>
1081     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1082     alterSliderValue(true);
1083 }
1084 
1085 void AccessibilityNodeObject::decrement()
1086 {
<a name="16" id="anc16"></a><span class="line-removed">1087     if (dispatchAccessibilityEventWithType(AccessibilityEventType::Decrement))</span>
<span class="line-removed">1088         return;</span>
1089     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1090     alterSliderValue(false);
1091 }
1092 
1093 void AccessibilityNodeObject::changeValueByStep(bool increase)
1094 {
1095     float step = stepValueForRange();
1096     float value = valueForRange();
1097 
1098     value += increase ? step : -step;
1099 
<a name="17" id="anc17"></a><span class="line-modified">1100     setValue(String::number(value));</span>
1101 
<a name="18" id="anc18"></a><span class="line-modified">1102     axObjectCache()-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>


1103 }
1104 
1105 void AccessibilityNodeObject::changeValueByPercent(float percentChange)
1106 {
1107     float range = maxValueForRange() - minValueForRange();
1108     float step = range * (percentChange / 100);
1109     float value = valueForRange();
1110 
1111     // Make sure the specified percent will cause a change of one integer step or larger.
<a name="19" id="anc19"></a><span class="line-modified">1112     if (fabs(step) &lt; 1)</span>
<span class="line-modified">1113         step = fabs(percentChange) * (1 / percentChange);</span>
1114 
1115     value += step;
<a name="20" id="anc20"></a><span class="line-modified">1116     setValue(String::number(value));</span>
1117 
<a name="21" id="anc21"></a><span class="line-modified">1118     axObjectCache()-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>


1119 }
1120 
1121 bool AccessibilityNodeObject::isGenericFocusableElement() const
1122 {
1123     if (!canSetFocusAttribute())
1124         return false;
1125 
1126     // If it&#39;s a control, it&#39;s not generic.
1127     if (isControl())
1128         return false;
1129 
1130     AccessibilityRole role = roleValue();
1131     if (role == AccessibilityRole::Video || role == AccessibilityRole::Audio)
1132         return false;
1133 
1134     // If it has an aria role, it&#39;s not generic.
1135     if (m_ariaRole != AccessibilityRole::Unknown)
1136         return false;
1137 
1138     // If the content editable attribute is set on this element, that&#39;s the reason
1139     // it&#39;s focusable, and existing logic should handle this case already - so it&#39;s not a
1140     // generic focusable element.
1141 
1142     if (hasContentEditableAttributeSet())
1143         return false;
1144 
1145     // The web area and body element are both focusable, but existing logic handles these
1146     // cases already, so we don&#39;t need to include them here.
1147     if (role == AccessibilityRole::WebArea)
1148         return false;
1149     if (node() &amp;&amp; node()-&gt;hasTagName(bodyTag))
1150         return false;
1151 
1152     // An SVG root is focusable by default, but it&#39;s probably not interactive, so don&#39;t
1153     // include it. It can still be made accessible by giving it an ARIA role.
1154     if (role == AccessibilityRole::SVGRoot)
1155         return false;
1156 
1157     return true;
1158 }
1159 
1160 HTMLLabelElement* AccessibilityNodeObject::labelForElement(Element* element) const
1161 {
1162     if (!is&lt;HTMLElement&gt;(*element) || !downcast&lt;HTMLElement&gt;(*element).isLabelable())
1163         return nullptr;
1164 
<a name="22" id="anc22"></a><span class="line-modified">1165     const AtomicString&amp; id = element-&gt;getIdAttribute();</span>
1166     if (!id.isEmpty()) {
1167         if (HTMLLabelElement* label = element-&gt;treeScope().labelElementForId(id))
1168             return label;
1169     }
1170 
1171     return ancestorsOfType&lt;HTMLLabelElement&gt;(*element).first();
1172 }
1173 
1174 String AccessibilityNodeObject::ariaAccessibilityDescription() const
1175 {
1176     String ariaLabeledBy = ariaLabeledByAttribute();
1177     if (!ariaLabeledBy.isEmpty())
1178         return ariaLabeledBy;
1179 
<a name="23" id="anc23"></a><span class="line-modified">1180     const AtomicString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
1181     if (!ariaLabel.isEmpty())
1182         return ariaLabel;
1183 
1184     return String();
1185 }
1186 
1187 static Element* siblingWithAriaRole(Node* node, const char* role)
1188 {
1189     // FIXME: Either we should add a null check here or change the function to take a reference instead of a pointer.
1190     ContainerNode* parent = node-&gt;parentNode();
1191     if (!parent)
1192         return nullptr;
1193 
1194     for (auto&amp; sibling : childrenOfType&lt;Element&gt;(*parent)) {
1195         // FIXME: Should skip sibling that is the same as the node.
1196         if (equalIgnoringASCIICase(sibling.attributeWithoutSynchronization(roleAttr), role))
1197             return &amp;sibling;
1198     }
1199 
1200     return nullptr;
1201 }
1202 
1203 Element* AccessibilityNodeObject::menuElementForMenuButton() const
1204 {
1205     if (ariaRoleAttribute() != AccessibilityRole::MenuButton)
1206         return nullptr;
1207 
1208     return siblingWithAriaRole(node(), &quot;menu&quot;);
1209 }
1210 
1211 AccessibilityObject* AccessibilityNodeObject::menuForMenuButton() const
1212 {
1213     if (AXObjectCache* cache = axObjectCache())
1214         return cache-&gt;getOrCreate(menuElementForMenuButton());
1215     return nullptr;
1216 }
1217 
1218 Element* AccessibilityNodeObject::menuItemElementForMenu() const
1219 {
1220     if (ariaRoleAttribute() != AccessibilityRole::Menu)
1221         return nullptr;
1222 
1223     return siblingWithAriaRole(node(), &quot;menuitem&quot;);
1224 }
1225 
1226 AccessibilityObject* AccessibilityNodeObject::menuButtonForMenu() const
1227 {
1228     AXObjectCache* cache = axObjectCache();
1229     if (!cache)
1230         return nullptr;
1231 
1232     Element* menuItem = menuItemElementForMenu();
1233 
1234     if (menuItem) {
1235         // ARIA just has generic menu items. AppKit needs to know if this is a top level items like MenuBarButton or MenuBarItem
1236         AccessibilityObject* menuItemAX = cache-&gt;getOrCreate(menuItem);
1237         if (menuItemAX &amp;&amp; menuItemAX-&gt;isMenuButton())
1238             return menuItemAX;
1239     }
1240     return nullptr;
1241 }
1242 
1243 AccessibilityObject* AccessibilityNodeObject::captionForFigure() const
1244 {
1245     if (!isFigureElement())
1246         return nullptr;
1247 
1248     AXObjectCache* cache = axObjectCache();
1249     if (!cache)
1250         return nullptr;
1251 
1252     Node* node = this-&gt;node();
1253     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
1254         if (child-&gt;hasTagName(figcaptionTag))
1255             return cache-&gt;getOrCreate(child);
1256     }
1257     return nullptr;
1258 }
1259 
1260 bool AccessibilityNodeObject::usesAltTagForTextComputation() const
1261 {
1262     return isImage() || isInputImage() || isNativeImage() || isCanvas() || (node() &amp;&amp; node()-&gt;hasTagName(imgTag));
1263 }
1264 
1265 bool AccessibilityNodeObject::isLabelable() const
1266 {
1267     Node* node = this-&gt;node();
1268     if (!node)
1269         return false;
1270 
1271     return is&lt;HTMLInputElement&gt;(*node) || AccessibilityObject::isARIAInput(ariaRoleAttribute()) || isControl() || isProgressIndicator() || isMeter();
1272 }
1273 
1274 String AccessibilityNodeObject::textForLabelElement(Element* element) const
1275 {
1276     String result = String();
1277     if (!is&lt;HTMLLabelElement&gt;(*element))
1278         return result;
1279 
<a name="24" id="anc24"></a>



1280     HTMLLabelElement* label = downcast&lt;HTMLLabelElement&gt;(element);
1281     // Check to see if there&#39;s aria-labelledby attribute on the label element.
<a name="25" id="anc25"></a><span class="line-modified">1282     if (AccessibilityObject* labelObject = axObjectCache()-&gt;getOrCreate(label))</span>
1283         result = labelObject-&gt;ariaLabeledByAttribute();
1284 
1285     return !result.isEmpty() ? result : accessibleNameForNode(label);
1286 }
1287 
1288 void AccessibilityNodeObject::titleElementText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1289 {
1290     Node* node = this-&gt;node();
1291     if (!node)
1292         return;
1293 
1294     if (isLabelable()) {
1295         if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node))) {
1296             String innerText = textForLabelElement(label);
1297 
<a name="26" id="anc26"></a>
1298             // Only use the &lt;label&gt; text if there&#39;s no ARIA override.
<a name="27" id="anc27"></a><span class="line-modified">1299             if (!innerText.isEmpty() &amp;&amp; !ariaAccessibilityDescription())</span>
<span class="line-modified">1300                 textOrder.append(AccessibilityText(innerText, isMeter() ? AccessibilityTextSource::Alternative : AccessibilityTextSource::LabelByElement, axObjectCache()-&gt;getOrCreate(label)));</span>
1301             return;
1302         }
1303     }
1304 
1305     AccessibilityObject* titleUIElement = this-&gt;titleUIElement();
1306     if (titleUIElement)
1307         textOrder.append(AccessibilityText(String(), AccessibilityTextSource::LabelByElement, titleUIElement));
1308 }
1309 
1310 void AccessibilityNodeObject::alternativeText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1311 {
1312     if (isWebArea()) {
1313         String webAreaText = alternativeTextForWebArea();
1314         if (!webAreaText.isEmpty())
1315             textOrder.append(AccessibilityText(webAreaText, AccessibilityTextSource::Alternative));
1316         return;
1317     }
1318 
1319     ariaLabeledByText(textOrder);
1320 
<a name="28" id="anc28"></a><span class="line-modified">1321     const AtomicString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
1322     if (!ariaLabel.isEmpty())
1323         textOrder.append(AccessibilityText(ariaLabel, AccessibilityTextSource::Alternative));
1324 
1325     if (usesAltTagForTextComputation()) {
1326         if (is&lt;RenderImage&gt;(renderer())) {
1327             String renderAltText = downcast&lt;RenderImage&gt;(*renderer()).altText();
1328 
1329             // RenderImage will return title as a fallback from altText, but we don&#39;t want title here because we consider that in helpText.
1330             if (!renderAltText.isEmpty() &amp;&amp; renderAltText != getAttribute(titleAttr)) {
1331                 textOrder.append(AccessibilityText(renderAltText, AccessibilityTextSource::Alternative));
1332                 return;
1333             }
1334         }
1335         // Images should use alt as long as the attribute is present, even if empty.
1336         // Otherwise, it should fallback to other methods, like the title attribute.
<a name="29" id="anc29"></a><span class="line-modified">1337         const AtomicString&amp; alt = getAttribute(altAttr);</span>
1338         if (!alt.isEmpty())
1339             textOrder.append(AccessibilityText(alt, AccessibilityTextSource::Alternative));
1340     }
1341 
1342     Node* node = this-&gt;node();
1343     if (!node)
1344         return;
1345 
<a name="30" id="anc30"></a>
1346     // The fieldset element derives its alternative text from the first associated legend element if one is available.
<a name="31" id="anc31"></a><span class="line-modified">1347     if (is&lt;HTMLFieldSetElement&gt;(*node)) {</span>
<span class="line-modified">1348         AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(downcast&lt;HTMLFieldSetElement&gt;(*node).legend());</span>
1349         if (object &amp;&amp; !object-&gt;isHidden())
1350             textOrder.append(AccessibilityText(accessibleNameForNode(object-&gt;node()), AccessibilityTextSource::Alternative));
1351     }
1352 
1353     // The figure element derives its alternative text from the first associated figcaption element if one is available.
1354     if (isFigureElement()) {
1355         AccessibilityObject* captionForFigure = this-&gt;captionForFigure();
1356         if (captionForFigure &amp;&amp; !captionForFigure-&gt;isHidden())
1357             textOrder.append(AccessibilityText(accessibleNameForNode(captionForFigure-&gt;node()), AccessibilityTextSource::Alternative));
1358     }
1359 
1360     // Tree items missing a label are labeled by all child elements.
1361     if (isTreeItem() &amp;&amp; ariaLabel.isEmpty() &amp;&amp; ariaLabeledByAttribute().isEmpty())
1362         textOrder.append(AccessibilityText(accessibleNameForNode(node), AccessibilityTextSource::Alternative));
1363 
1364 #if ENABLE(MATHML)
1365     if (node-&gt;isMathMLElement())
1366         textOrder.append(AccessibilityText(getAttribute(MathMLNames::alttextAttr), AccessibilityTextSource::Alternative));
1367 #endif
1368 }
1369 
1370 void AccessibilityNodeObject::visibleText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1371 {
1372     Node* node = this-&gt;node();
1373     if (!node)
1374         return;
1375 
1376     bool isInputTag = is&lt;HTMLInputElement&gt;(*node);
1377     if (isInputTag) {
1378         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
1379         if (input.isTextButton()) {
1380             textOrder.append(AccessibilityText(input.valueWithDefault(), AccessibilityTextSource::Visible));
1381             return;
1382         }
1383     }
1384 
1385     // If this node isn&#39;t rendered, there&#39;s no inner text we can extract from a select element.
1386     if (!isAccessibilityRenderObject() &amp;&amp; node-&gt;hasTagName(selectTag))
1387         return;
1388 
1389     bool useTextUnderElement = false;
1390 
1391     switch (roleValue()) {
1392     case AccessibilityRole::PopUpButton:
1393         // Native popup buttons should not use their button children&#39;s text as a title. That value is retrieved through stringValue().
1394         if (node-&gt;hasTagName(selectTag))
1395             break;
1396         FALLTHROUGH;
1397     case AccessibilityRole::Button:
1398     case AccessibilityRole::ToggleButton:
1399     case AccessibilityRole::CheckBox:
1400     case AccessibilityRole::ListBoxOption:
1401     // MacOS does not expect native &lt;li&gt; elements to expose label information, it only expects leaf node elements to do that.
1402 #if !PLATFORM(COCOA)
1403     case AccessibilityRole::ListItem:
1404 #endif
1405     case AccessibilityRole::MenuButton:
1406     case AccessibilityRole::MenuItem:
1407     case AccessibilityRole::MenuItemCheckbox:
1408     case AccessibilityRole::MenuItemRadio:
1409     case AccessibilityRole::RadioButton:
1410     case AccessibilityRole::Switch:
1411     case AccessibilityRole::Tab:
1412         useTextUnderElement = true;
1413         break;
1414     default:
1415         break;
1416     }
1417 
1418     // If it&#39;s focusable but it&#39;s not content editable or a known control type, then it will appear to
1419     // the user as a single atomic object, so we should use its text as the default title.
1420     if (isHeading() || isLink())
1421         useTextUnderElement = true;
1422 
1423     if (isOutput())
1424         useTextUnderElement = true;
1425 
1426     if (useTextUnderElement) {
1427         AccessibilityTextUnderElementMode mode;
1428 
1429         // Headings often include links as direct children. Those links need to be included in text under element.
1430         if (isHeading())
1431             mode.includeFocusableContent = true;
1432 
1433         String text = textUnderElement(mode);
1434         if (!text.isEmpty())
1435             textOrder.append(AccessibilityText(text, AccessibilityTextSource::Children));
1436     }
1437 }
1438 
1439 void AccessibilityNodeObject::helpText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1440 {
<a name="32" id="anc32"></a><span class="line-modified">1441     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
1442     if (!ariaHelp.isEmpty())
1443         textOrder.append(AccessibilityText(ariaHelp, AccessibilityTextSource::Help));
1444 
1445     String describedBy = ariaDescribedByAttribute();
1446     if (!describedBy.isEmpty())
1447         textOrder.append(AccessibilityText(describedBy, AccessibilityTextSource::Summary));
1448     else if (isControl()) {
1449         // For controls, use their fieldset parent&#39;s described-by text if available.
1450         auto matchFunc = [] (const AccessibilityObject&amp; object) {
1451             return object.isFieldset() &amp;&amp; !object.ariaDescribedByAttribute().isEmpty();
1452         };
1453         if (const auto* parent = AccessibilityObject::matchedParent(*this, false, WTFMove(matchFunc)))
1454             textOrder.append(AccessibilityText(parent-&gt;ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
1455     }
1456 
1457     // Summary attribute used as help text on tables.
<a name="33" id="anc33"></a><span class="line-modified">1458     const AtomicString&amp; summary = getAttribute(summaryAttr);</span>
1459     if (!summary.isEmpty())
1460         textOrder.append(AccessibilityText(summary, AccessibilityTextSource::Summary));
1461 
1462     // The title attribute should be used as help text unless it is already being used as descriptive text.
1463     // However, when the title attribute is the only text alternative provided, it may be exposed as the
1464     // descriptive text. This is problematic in the case of meters because the HTML spec suggests authors
1465     // can expose units through this attribute. Therefore, if the element is a meter, change its source
1466     // type to AccessibilityTextSource::Help.
<a name="34" id="anc34"></a><span class="line-modified">1467     const AtomicString&amp; title = getAttribute(titleAttr);</span>
1468     if (!title.isEmpty()) {
1469         if (!isMeter() &amp;&amp; !roleIgnoresTitle())
1470             textOrder.append(AccessibilityText(title, AccessibilityTextSource::TitleTag));
1471         else
1472             textOrder.append(AccessibilityText(title, AccessibilityTextSource::Help));
1473     }
1474 }
1475 
<a name="35" id="anc35"></a><span class="line-modified">1476 void AccessibilityNodeObject::accessibilityText(Vector&lt;AccessibilityText&gt;&amp; textOrder)</span>
1477 {
1478     titleElementText(textOrder);
1479     alternativeText(textOrder);
1480     visibleText(textOrder);
1481     helpText(textOrder);
1482 
1483     String placeholder = placeholderValue();
1484     if (!placeholder.isEmpty())
1485         textOrder.append(AccessibilityText(placeholder, AccessibilityTextSource::Placeholder));
1486 }
1487 
1488 void AccessibilityNodeObject::ariaLabeledByText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1489 {
1490     String ariaLabeledBy = ariaLabeledByAttribute();
1491     if (!ariaLabeledBy.isEmpty()) {
<a name="36" id="anc36"></a>



1492         Vector&lt;Element*&gt; elements;
1493         ariaLabeledByElements(elements);
1494 
1495         Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; axElements;
1496         for (const auto&amp; element : elements)
<a name="37" id="anc37"></a><span class="line-modified">1497             axElements.append(axObjectCache()-&gt;getOrCreate(element));</span>
1498 
1499         textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, WTFMove(axElements)));
1500     }
1501 }
1502 
1503 String AccessibilityNodeObject::alternativeTextForWebArea() const
1504 {
1505     // The WebArea description should follow this order:
1506     //     aria-label on the &lt;html&gt;
1507     //     title on the &lt;html&gt;
1508     //     &lt;title&gt; inside the &lt;head&gt; (of it was set through JS)
1509     //     name on the &lt;html&gt;
1510     // For iframes:
1511     //     aria-label on the &lt;iframe&gt;
1512     //     title on the &lt;iframe&gt;
1513     //     name on the &lt;iframe&gt;
1514 
1515     Document* document = this-&gt;document();
1516     if (!document)
1517         return String();
1518 
1519     // Check if the HTML element has an aria-label for the webpage.
1520     if (Element* documentElement = document-&gt;documentElement()) {
<a name="38" id="anc38"></a><span class="line-modified">1521         const AtomicString&amp; ariaLabel = documentElement-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
1522         if (!ariaLabel.isEmpty())
1523             return ariaLabel;
1524     }
1525 
1526     if (auto* owner = document-&gt;ownerElement()) {
1527         if (owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag)) {
<a name="39" id="anc39"></a><span class="line-modified">1528             const AtomicString&amp; title = owner-&gt;attributeWithoutSynchronization(titleAttr);</span>
1529             if (!title.isEmpty())
1530                 return title;
1531         }
1532         return owner-&gt;getNameAttribute();
1533     }
1534 
1535     String documentTitle = document-&gt;title();
1536     if (!documentTitle.isEmpty())
1537         return documentTitle;
1538 
1539     if (auto* body = document-&gt;bodyOrFrameset())
1540         return body-&gt;getNameAttribute();
1541 
1542     return String();
1543 }
1544 
1545 String AccessibilityNodeObject::accessibilityDescription() const
1546 {
1547     // Static text should not have a description, it should only have a stringValue.
1548     if (roleValue() == AccessibilityRole::StaticText)
1549         return String();
1550 
1551     String ariaDescription = ariaAccessibilityDescription();
1552     if (!ariaDescription.isEmpty())
1553         return ariaDescription;
1554 
1555     if (usesAltTagForTextComputation()) {
1556         // Images should use alt as long as the attribute is present, even if empty.
1557         // Otherwise, it should fallback to other methods, like the title attribute.
<a name="40" id="anc40"></a><span class="line-modified">1558         const AtomicString&amp; alt = getAttribute(altAttr);</span>
1559         if (!alt.isNull())
1560             return alt;
1561     }
1562 
1563 #if ENABLE(MATHML)
1564     if (is&lt;MathMLElement&gt;(m_node))
1565         return getAttribute(MathMLNames::alttextAttr);
1566 #endif
1567 
1568     // An element&#39;s descriptive text is comprised of title() (what&#39;s visible on the screen) and accessibilityDescription() (other descriptive text).
1569     // Both are used to generate what a screen reader speaks.
1570     // If this point is reached (i.e. there&#39;s no accessibilityDescription) and there&#39;s no title(), we should fallback to using the title attribute.
1571     // The title attribute is normally used as help text (because it is a tooltip), but if there is nothing else available, this should be used (according to ARIA).
1572     // https://bugs.webkit.org/show_bug.cgi?id=170475: An exception is when the element is semantically unimportant. In those cases, title text should remain as help text.
1573     if (title().isEmpty() &amp;&amp; !roleIgnoresTitle())
1574         return getAttribute(titleAttr);
1575 
1576     return String();
1577 }
1578 
1579 // Returns whether the role was not intended to play a semantically meaningful part of the
1580 // accessibility hierarchy. This applies to generic groups like &lt;div&gt;&#39;s with no role value set.
1581 bool AccessibilityNodeObject::roleIgnoresTitle() const
1582 {
1583     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
1584         return false;
1585 
1586     switch (roleValue()) {
1587     case AccessibilityRole::Div:
1588     case AccessibilityRole::Unknown:
1589         return true;
1590     default:
1591         return false;
1592     }
1593 }
1594 
1595 String AccessibilityNodeObject::helpText() const
1596 {
1597     Node* node = this-&gt;node();
1598     if (!node)
1599         return String();
1600 
<a name="41" id="anc41"></a><span class="line-modified">1601     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
1602     if (!ariaHelp.isEmpty())
1603         return ariaHelp;
1604 
1605     String describedBy = ariaDescribedByAttribute();
1606     if (!describedBy.isEmpty())
1607         return describedBy;
1608 
1609     String description = accessibilityDescription();
1610     for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
1611         if (is&lt;HTMLElement&gt;(*ancestor)) {
1612             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor);
<a name="42" id="anc42"></a><span class="line-modified">1613             const AtomicString&amp; summary = element.getAttribute(summaryAttr);</span>
1614             if (!summary.isEmpty())
1615                 return summary;
1616 
1617             // The title attribute should be used as help text unless it is already being used as descriptive text.
<a name="43" id="anc43"></a><span class="line-modified">1618             const AtomicString&amp; title = element.getAttribute(titleAttr);</span>
1619             if (!title.isEmpty() &amp;&amp; description != title)
1620                 return title;
1621         }
1622 
<a name="44" id="anc44"></a>



1623         // Only take help text from an ancestor element if its a group or an unknown role. If help was
1624         // added to those kinds of elements, it is likely it was meant for a child element.
<a name="45" id="anc45"></a><span class="line-modified">1625         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(ancestor)) {</span>
1626             if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
1627                 break;
1628         }
1629     }
1630 
1631     return String();
1632 }
1633 
1634 unsigned AccessibilityNodeObject::hierarchicalLevel() const
1635 {
1636     Node* node = this-&gt;node();
1637     if (!is&lt;Element&gt;(node))
1638         return 0;
1639     Element&amp; element = downcast&lt;Element&gt;(*node);
<a name="46" id="anc46"></a><span class="line-modified">1640     const AtomicString&amp; ariaLevel = element.attributeWithoutSynchronization(aria_levelAttr);</span>
1641     if (!ariaLevel.isEmpty())
1642         return ariaLevel.toInt();
1643 
1644     // Only tree item will calculate its level through the DOM currently.
1645     if (roleValue() != AccessibilityRole::TreeItem)
1646         return 0;
1647 
1648     // Hierarchy leveling starts at 1, to match the aria-level spec.
1649     // We measure tree hierarchy by the number of groups that the item is within.
1650     unsigned level = 1;
1651     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1652         AccessibilityRole parentRole = parent-&gt;ariaRoleAttribute();
1653         if (parentRole == AccessibilityRole::ApplicationGroup)
1654             level++;
1655         else if (parentRole == AccessibilityRole::Tree)
1656             break;
1657     }
1658 
1659     return level;
1660 }
1661 
1662 void AccessibilityNodeObject::setIsExpanded(bool expand)
1663 {
1664     if (is&lt;HTMLDetailsElement&gt;(node())) {
1665         auto&amp; details = downcast&lt;HTMLDetailsElement&gt;(*node());
1666         if (expand != details.isOpen())
1667             details.toggleOpen();
1668     }
1669 }
1670 
1671 // When building the textUnderElement for an object, determine whether or not
1672 // we should include the inner text of this given descendant object or skip it.
1673 static bool shouldUseAccessibilityObjectInnerText(AccessibilityObject* obj, AccessibilityTextUnderElementMode mode)
1674 {
1675     // Do not use any heuristic if we are explicitly asking to include all the children.
1676     if (mode.childrenInclusion == AccessibilityTextUnderElementMode::TextUnderElementModeIncludeAllChildren)
1677         return true;
1678 
1679     // Consider this hypothetical example:
1680     // &lt;div tabindex=0&gt;
1681     //   &lt;h2&gt;
1682     //     Table of contents
1683     //   &lt;/h2&gt;
1684     //   &lt;a href=&quot;#start&quot;&gt;Jump to start of book&lt;/a&gt;
1685     //   &lt;ul&gt;
1686     //     &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;Chapter 1&lt;/a&gt;&lt;/li&gt;
1687     //     &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;Chapter 2&lt;/a&gt;&lt;/li&gt;
1688     //   &lt;/ul&gt;
1689     // &lt;/div&gt;
1690     //
1691     // The goal is to return a reasonable title for the outer container div, because
1692     // it&#39;s focusable - but without making its title be the full inner text, which is
1693     // quite long. As a heuristic, skip links, controls, and elements that are usually
1694     // containers with lots of children.
1695 
1696     // ARIA states that certain elements are not allowed to expose their children content for name calculation.
1697     if (mode.childrenInclusion == AccessibilityTextUnderElementMode::TextUnderElementModeIncludeNameFromContentsChildren
1698         &amp;&amp; !obj-&gt;accessibleNameDerivesFromContent())
1699         return false;
1700 
1701     if (equalLettersIgnoringASCIICase(obj-&gt;getAttribute(aria_hiddenAttr), &quot;true&quot;))
1702         return false;
1703 
1704     // If something doesn&#39;t expose any children, then we can always take the inner text content.
1705     // This is what we want when someone puts an &lt;a&gt; inside a &lt;button&gt; for example.
1706     if (obj-&gt;isDescendantOfBarrenParent())
1707         return true;
1708 
1709     // Skip focusable children, so we don&#39;t include the text of links and controls.
1710     if (obj-&gt;canSetFocusAttribute() &amp;&amp; !mode.includeFocusableContent)
1711         return false;
1712 
1713     // Skip big container elements like lists, tables, etc.
1714     if (is&lt;AccessibilityList&gt;(*obj))
1715         return false;
1716 
1717     if (is&lt;AccessibilityTable&gt;(*obj) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*obj).isExposableThroughAccessibility())
1718         return false;
1719 
1720     if (obj-&gt;isTree() || obj-&gt;isCanvas())
1721         return false;
1722 
1723     return true;
1724 }
1725 
1726 static bool shouldAddSpaceBeforeAppendingNextElement(StringBuilder&amp; builder, const String&amp; childText)
1727 {
1728     if (!builder.length() || !childText.length())
1729         return false;
1730 
1731     // We don&#39;t need to add an additional space before or after a line break.
1732     return !(isHTMLLineBreak(childText[0]) || isHTMLLineBreak(builder[builder.length() - 1]));
1733 }
1734 
1735 static void appendNameToStringBuilder(StringBuilder&amp; builder, const String&amp; text)
1736 {
1737     if (shouldAddSpaceBeforeAppendingNextElement(builder, text))
1738         builder.append(&#39; &#39;);
1739     builder.append(text);
1740 }
1741 
1742 String AccessibilityNodeObject::textUnderElement(AccessibilityTextUnderElementMode mode) const
1743 {
1744     Node* node = this-&gt;node();
1745     if (is&lt;Text&gt;(node))
1746         return downcast&lt;Text&gt;(*node).wholeText();
1747 
1748     bool isAriaVisible = AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
1749         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;false&quot;);
1750     }) != nullptr;
1751 
1752     // The Accname specification states that if the current node is hidden, and not directly
1753     // referenced by aria-labelledby or aria-describedby, and is not a host language text
1754     // alternative, the empty string should be returned.
1755     if (isDOMHidden() &amp;&amp; !isAriaVisible &amp;&amp; !is&lt;HTMLLabelElement&gt;(node) &amp;&amp; (node &amp;&amp; !ancestorsOfType&lt;HTMLCanvasElement&gt;(*node).first())) {
1756         AccessibilityObject::AccessibilityChildrenVector labelFor;
1757         AccessibilityObject::AccessibilityChildrenVector descriptionFor;
1758         ariaLabelledByReferencingElements(labelFor);
1759         ariaDescribedByReferencingElements(descriptionFor);
1760         if (!labelFor.size() &amp;&amp; !descriptionFor.size())
1761             return String();
1762     }
1763 
1764     StringBuilder builder;
1765     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
1766         if (mode.ignoredChildNode &amp;&amp; child-&gt;node() == mode.ignoredChildNode)
1767             continue;
1768 
1769         bool shouldDeriveNameFromAuthor = (mode.childrenInclusion == AccessibilityTextUnderElementMode::TextUnderElementModeIncludeNameFromContentsChildren &amp;&amp; !child-&gt;accessibleNameDerivesFromContent());
1770         if (shouldDeriveNameFromAuthor) {
1771             appendNameToStringBuilder(builder, accessibleNameForNode(child-&gt;node()));
1772             continue;
1773         }
1774 
1775         if (!shouldUseAccessibilityObjectInnerText(child, mode))
1776             continue;
1777 
1778         if (is&lt;AccessibilityNodeObject&gt;(*child)) {
1779             // We should ignore the child if it&#39;s labeled by this node.
1780             // This could happen when this node labels multiple child nodes and we didn&#39;t
1781             // skip in the above ignoredChildNode check.
1782             Vector&lt;Element*&gt; labeledByElements;
1783             downcast&lt;AccessibilityNodeObject&gt;(*child).ariaLabeledByElements(labeledByElements);
1784             if (labeledByElements.contains(node))
1785                 continue;
1786 
1787             Vector&lt;AccessibilityText&gt; textOrder;
1788             downcast&lt;AccessibilityNodeObject&gt;(*child).alternativeText(textOrder);
1789             if (textOrder.size() &gt; 0 &amp;&amp; textOrder[0].text.length()) {
1790                 appendNameToStringBuilder(builder, textOrder[0].text);
1791                 continue;
1792             }
1793         }
1794 
1795         String childText = child-&gt;textUnderElement(mode);
1796         if (childText.length())
1797             appendNameToStringBuilder(builder, childText);
1798     }
1799 
1800     return builder.toString().stripWhiteSpace().simplifyWhiteSpace(isHTMLSpaceButNotLineBreak);
1801 }
1802 
1803 String AccessibilityNodeObject::title() const
1804 {
1805     Node* node = this-&gt;node();
1806     if (!node)
1807         return String();
1808 
1809     bool isInputTag = is&lt;HTMLInputElement&gt;(*node);
1810     if (isInputTag) {
1811         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
1812         if (input.isTextButton())
1813             return input.valueWithDefault();
1814     }
1815 
1816     if (isLabelable()) {
1817         HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node));
1818         // Use the label text as the title if 1) the title element is NOT an exposed element and 2) there&#39;s no ARIA override.
1819         if (label &amp;&amp; !exposesTitleUIElement() &amp;&amp; !ariaAccessibilityDescription().length())
1820             return textForLabelElement(label);
1821     }
1822 
1823     // If this node isn&#39;t rendered, there&#39;s no inner text we can extract from a select element.
1824     if (!isAccessibilityRenderObject() &amp;&amp; node-&gt;hasTagName(selectTag))
1825         return String();
1826 
1827     switch (roleValue()) {
1828     case AccessibilityRole::PopUpButton:
1829         // Native popup buttons should not use their button children&#39;s text as a title. That value is retrieved through stringValue().
1830         if (node-&gt;hasTagName(selectTag))
1831             return String();
1832         FALLTHROUGH;
1833     case AccessibilityRole::Button:
1834     case AccessibilityRole::ToggleButton:
1835     case AccessibilityRole::CheckBox:
1836     case AccessibilityRole::ListBoxOption:
1837     case AccessibilityRole::ListItem:
1838     case AccessibilityRole::MenuButton:
1839     case AccessibilityRole::MenuItem:
1840     case AccessibilityRole::MenuItemCheckbox:
1841     case AccessibilityRole::MenuItemRadio:
1842     case AccessibilityRole::RadioButton:
1843     case AccessibilityRole::Switch:
1844     case AccessibilityRole::Tab:
1845         return textUnderElement();
1846     // SVGRoots should not use the text under itself as a title. That could include the text of objects like &lt;text&gt;.
1847     case AccessibilityRole::SVGRoot:
1848         return String();
1849     default:
1850         break;
1851     }
1852 
1853     if (isLink())
1854         return textUnderElement();
1855     if (isHeading())
1856         return textUnderElement(AccessibilityTextUnderElementMode(AccessibilityTextUnderElementMode::TextUnderElementModeSkipIgnoredChildren, true));
1857 
1858     return String();
1859 }
1860 
1861 String AccessibilityNodeObject::text() const
1862 {
1863     // If this is a user defined static text, use the accessible name computation.
1864     if (isARIAStaticText()) {
1865         Vector&lt;AccessibilityText&gt; textOrder;
1866         alternativeText(textOrder);
1867         if (textOrder.size() &gt; 0 &amp;&amp; textOrder[0].text.length())
1868             return textOrder[0].text;
1869     }
1870 
1871     if (!isTextControl())
1872         return String();
1873 
1874     Node* node = this-&gt;node();
1875     if (!node)
1876         return String();
1877 
1878     if (isNativeTextControl() &amp;&amp; is&lt;HTMLTextFormControlElement&gt;(*node))
1879         return downcast&lt;HTMLTextFormControlElement&gt;(*node).value();
1880 
1881     if (!node-&gt;isElementNode())
1882         return String();
1883 
1884     return downcast&lt;Element&gt;(node)-&gt;innerText();
1885 }
1886 
1887 String AccessibilityNodeObject::stringValue() const
1888 {
1889     Node* node = this-&gt;node();
1890     if (!node)
1891         return String();
1892 
1893     if (isARIAStaticText()) {
1894         String staticText = text();
1895         if (!staticText.length())
1896             staticText = textUnderElement();
1897         return staticText;
1898     }
1899 
1900     if (node-&gt;isTextNode())
1901         return textUnderElement();
1902 
1903     if (node-&gt;hasTagName(selectTag)) {
1904         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*node);
1905         int selectedIndex = selectElement.selectedIndex();
1906         const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
1907         if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
<a name="47" id="anc47"></a><span class="line-modified">1908             const AtomicString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
1909             if (!overriddenDescription.isNull())
1910                 return overriddenDescription;
1911         }
1912         if (!selectElement.multiple())
1913             return selectElement.value();
1914         return String();
1915     }
1916 
1917     if (isTextControl())
1918         return text();
1919 
1920     // FIXME: We might need to implement a value here for more types
1921     // FIXME: It would be better not to advertise a value at all for the types for which we don&#39;t implement one;
1922     // this would require subclassing or making accessibilityAttributeNames do something other than return a
1923     // single static array.
1924     return String();
1925 }
1926 
1927 void AccessibilityNodeObject::colorValue(int&amp; r, int&amp; g, int&amp; b) const
1928 {
1929     r = 0;
1930     g = 0;
1931     b = 0;
1932 
1933 #if ENABLE(INPUT_TYPE_COLOR)
1934     if (!isColorWell())
1935         return;
1936 
1937     if (!is&lt;HTMLInputElement&gt;(node()))
1938         return;
1939 
1940     auto color = downcast&lt;HTMLInputElement&gt;(*node()).valueAsColor();
1941     r = color.red();
1942     g = color.green();
1943     b = color.blue();
1944 #endif
1945 }
1946 
1947 // This function implements the ARIA accessible name as described by the Mozilla
1948 // ARIA Implementer&#39;s Guide.
1949 static String accessibleNameForNode(Node* node, Node* labelledbyNode)
1950 {
1951     ASSERT(node);
1952     if (!is&lt;Element&gt;(node))
1953         return String();
1954 
1955     Element&amp; element = downcast&lt;Element&gt;(*node);
<a name="48" id="anc48"></a><span class="line-modified">1956     const AtomicString&amp; ariaLabel = element.attributeWithoutSynchronization(aria_labelAttr);</span>
1957     if (!ariaLabel.isEmpty())
1958         return ariaLabel;
1959 
<a name="49" id="anc49"></a><span class="line-modified">1960     const AtomicString&amp; alt = element.attributeWithoutSynchronization(altAttr);</span>
1961     if (!alt.isEmpty())
1962         return alt;
1963 
1964     // If the node can be turned into an AX object, we can use standard name computation rules.
1965     // If however, the node cannot (because there&#39;s no renderer e.g.) fallback to using the basic text underneath.
1966     AccessibilityObject* axObject = node-&gt;document().axObjectCache()-&gt;getOrCreate(node);
1967     if (axObject) {
1968         String valueDescription = axObject-&gt;valueDescription();
1969         if (!valueDescription.isEmpty())
1970             return valueDescription;
1971 
1972         // The Accname specification states that if the name is being calculated for a combobox
1973         // or listbox inside a labeling element, return the text alternative of the chosen option.
1974         AccessibilityObject::AccessibilityChildrenVector children;
1975         if (axObject-&gt;isListBox())
1976             axObject-&gt;selectedChildren(children);
1977         else if (axObject-&gt;isComboBox()) {
1978             for (const auto&amp; child : axObject-&gt;children()) {
1979                 if (child-&gt;isListBox()) {
1980                     child-&gt;selectedChildren(children);
1981                     break;
1982                 }
1983             }
1984         }
1985 
1986         StringBuilder builder;
1987         String childText;
1988         for (const auto&amp; child : children)
1989             appendNameToStringBuilder(builder, accessibleNameForNode(child-&gt;node()));
1990 
1991         childText = builder.toString();
1992         if (!childText.isEmpty())
1993             return childText;
1994     }
1995 
1996     if (is&lt;HTMLInputElement&gt;(*node))
1997         return downcast&lt;HTMLInputElement&gt;(*node).value();
1998 
1999     String text;
2000     if (axObject) {
2001         if (axObject-&gt;accessibleNameDerivesFromContent())
2002             text = axObject-&gt;textUnderElement(AccessibilityTextUnderElementMode(AccessibilityTextUnderElementMode::TextUnderElementModeIncludeNameFromContentsChildren, true, labelledbyNode));
2003     } else
2004         text = element.innerText().simplifyWhiteSpace();
2005 
2006     if (!text.isEmpty())
2007         return text;
2008 
<a name="50" id="anc50"></a><span class="line-modified">2009     const AtomicString&amp; title = element.attributeWithoutSynchronization(titleAttr);</span>
2010     if (!title.isEmpty())
2011         return title;
2012 
2013     return String();
2014 }
2015 
2016 String AccessibilityNodeObject::accessibilityDescriptionForChildren() const
2017 {
2018     Node* node = this-&gt;node();
2019     if (!node)
2020         return String();
2021 
2022     AXObjectCache* cache = axObjectCache();
2023     if (!cache)
2024         return String();
2025 
2026     StringBuilder builder;
2027     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
2028         if (!is&lt;Element&gt;(child))
2029             continue;
2030 
2031         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(child)) {
2032             String description = axObject-&gt;ariaLabeledByAttribute();
2033             if (description.isEmpty())
2034                 description = accessibleNameForNode(child);
2035             appendNameToStringBuilder(builder, description);
2036         }
2037     }
2038 
2039     return builder.toString();
2040 }
2041 
2042 String AccessibilityNodeObject::accessibilityDescriptionForElements(Vector&lt;Element*&gt; &amp;elements) const
2043 {
2044     StringBuilder builder;
2045     unsigned size = elements.size();
2046     for (unsigned i = 0; i &lt; size; ++i)
2047         appendNameToStringBuilder(builder, accessibleNameForNode(elements[i], node()));
2048     return builder.toString();
2049 }
2050 
2051 String AccessibilityNodeObject::ariaDescribedByAttribute() const
2052 {
2053     Vector&lt;Element*&gt; elements;
2054     elementsFromAttribute(elements, aria_describedbyAttr);
2055 
2056     return accessibilityDescriptionForElements(elements);
2057 }
2058 
2059 void AccessibilityNodeObject::ariaLabeledByElements(Vector&lt;Element*&gt;&amp; elements) const
2060 {
2061     elementsFromAttribute(elements, aria_labelledbyAttr);
2062     if (!elements.size())
2063         elementsFromAttribute(elements, aria_labeledbyAttr);
2064 }
2065 
2066 
2067 String AccessibilityNodeObject::ariaLabeledByAttribute() const
2068 {
2069     Vector&lt;Element*&gt; elements;
2070     ariaLabeledByElements(elements);
2071 
2072     return accessibilityDescriptionForElements(elements);
2073 }
2074 
2075 bool AccessibilityNodeObject::hasAttributesRequiredForInclusion() const
2076 {
2077     if (AccessibilityObject::hasAttributesRequiredForInclusion())
2078         return true;
2079 
2080     // Avoid calculating the actual description here, which is expensive.
2081     // This means there might be more accessible elements in the tree if the labelledBy points to invalid elements, but that shouldn&#39;t cause any real problems.
2082     if (getAttribute(aria_labelledbyAttr).length() || getAttribute(aria_labeledbyAttr).length() || getAttribute(aria_labelAttr).length())
2083         return true;
2084 
2085     return false;
2086 }
2087 
2088 bool AccessibilityNodeObject::canSetFocusAttribute() const
2089 {
2090     Node* node = this-&gt;node();
2091     if (!node)
2092         return false;
2093 
2094     if (isWebArea())
2095         return true;
2096 
2097     // NOTE: It would be more accurate to ask the document whether setFocusedElement() would
2098     // do anything. For example, setFocusedElement() will do nothing if the current focused
2099     // node will not relinquish the focus.
2100     if (!is&lt;Element&gt;(node))
2101         return false;
2102 
2103     Element&amp; element = downcast&lt;Element&gt;(*node);
2104 
2105     if (element.isDisabledFormControl())
2106         return false;
2107 
2108     return element.supportsFocus();
2109 }
2110 
2111 bool AccessibilityNodeObject::canSetValueAttribute() const
2112 {
2113     Node* node = this-&gt;node();
2114     if (!node)
2115         return false;
2116 
2117     // The host-language readonly attribute trumps aria-readonly.
2118     if (is&lt;HTMLTextAreaElement&gt;(*node))
2119         return !downcast&lt;HTMLTextAreaElement&gt;(*node).isReadOnly();
2120     if (is&lt;HTMLInputElement&gt;(*node)) {
2121         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
2122         if (input.isTextField())
2123             return !input.isReadOnly();
2124     }
2125 
2126     String readOnly = readOnlyValue();
2127     if (!readOnly.isEmpty())
2128         return readOnly == &quot;true&quot; ? false : true;
2129 
2130     if (isNonNativeTextControl())
2131         return true;
2132 
2133     if (isMeter())
2134         return false;
2135 
2136     if (isProgressIndicator() || isSlider() || isScrollbar())
2137         return true;
2138 
<a name="51" id="anc51"></a><span class="line-modified">2139 #if PLATFORM(GTK)</span>
2140     // In ATK, input types which support aria-readonly are treated as having a
2141     // settable value if the user can modify the widget&#39;s value or its state.
2142     if (supportsReadOnly())
2143         return true;
2144 
2145     if (isRadioButton()) {
2146         auto radioGroup = radioGroupAncestor();
2147         return radioGroup ? radioGroup-&gt;readOnlyValue() != &quot;true&quot; : true;
2148     }
2149 #endif
2150 
2151     if (isWebArea()) {
2152         Document* document = this-&gt;document();
2153         if (!document)
2154             return false;
2155 
2156         if (HTMLElement* body = document-&gt;bodyOrFrameset()) {
2157             if (body-&gt;hasEditableStyle())
2158                 return true;
2159         }
2160 
2161         return document-&gt;hasEditableStyle();
2162     }
2163 
2164     return node-&gt;hasEditableStyle();
2165 }
2166 
2167 AccessibilityRole AccessibilityNodeObject::determineAriaRoleAttribute() const
2168 {
<a name="52" id="anc52"></a><span class="line-modified">2169     const AtomicString&amp; ariaRole = getAttribute(roleAttr);</span>
2170     if (ariaRole.isNull() || ariaRole.isEmpty())
2171         return AccessibilityRole::Unknown;
2172 
2173     AccessibilityRole role = ariaRoleToWebCoreRole(ariaRole);
2174 
2175     // ARIA states if an item can get focus, it should not be presentational.
2176     if (role == AccessibilityRole::Presentational &amp;&amp; canSetFocusAttribute())
2177         return AccessibilityRole::Unknown;
2178 
2179     if (role == AccessibilityRole::Button)
2180         role = buttonRoleType();
2181 
2182     if (role == AccessibilityRole::TextArea &amp;&amp; !ariaIsMultiline())
2183         role = AccessibilityRole::TextField;
2184 
2185     role = remapAriaRoleDueToParent(role);
2186 
2187     // Presentational roles are invalidated by the presence of ARIA attributes.
2188     if (role == AccessibilityRole::Presentational &amp;&amp; supportsARIAAttributes())
2189         role = AccessibilityRole::Unknown;
2190 
2191     // The ARIA spec states, &quot;Authors must give each element with role region a brief label that
2192     // describes the purpose of the content in the region.&quot; The Core AAM states, &quot;Special case:
2193     // if the region does not have an accessible name, do not expose the element as a landmark.
2194     // Use the native host language role of the element instead.&quot;
2195     if (role == AccessibilityRole::LandmarkRegion &amp;&amp; !hasAttribute(aria_labelAttr) &amp;&amp; !hasAttribute(aria_labelledbyAttr))
2196         role = AccessibilityRole::Unknown;
2197 
2198     if (static_cast&lt;int&gt;(role))
2199         return role;
2200 
2201     return AccessibilityRole::Unknown;
2202 }
2203 
2204 AccessibilityRole AccessibilityNodeObject::ariaRoleAttribute() const
2205 {
2206     return m_ariaRole;
2207 }
2208 
2209 AccessibilityRole AccessibilityNodeObject::remapAriaRoleDueToParent(AccessibilityRole role) const
2210 {
2211     // Some objects change their role based on their parent.
2212     // However, asking for the unignoredParent calls accessibilityIsIgnored(), which can trigger a loop.
2213     // While inside the call stack of creating an element, we need to avoid accessibilityIsIgnored().
2214     // https://bugs.webkit.org/show_bug.cgi?id=65174
2215 
2216     if (role != AccessibilityRole::ListBoxOption &amp;&amp; role != AccessibilityRole::MenuItem)
2217         return role;
2218 
2219     for (AccessibilityObject* parent = parentObject(); parent &amp;&amp; !parent-&gt;accessibilityIsIgnored(); parent = parent-&gt;parentObject()) {
2220         AccessibilityRole parentAriaRole = parent-&gt;ariaRoleAttribute();
2221 
2222         // Selects and listboxes both have options as child roles, but they map to different roles within WebCore.
2223         if (role == AccessibilityRole::ListBoxOption &amp;&amp; parentAriaRole == AccessibilityRole::Menu)
2224             return AccessibilityRole::MenuItem;
2225         // An aria &quot;menuitem&quot; may map to MenuButton or MenuItem depending on its parent.
2226         if (role == AccessibilityRole::MenuItem &amp;&amp; parentAriaRole == AccessibilityRole::ApplicationGroup)
2227             return AccessibilityRole::MenuButton;
2228 
2229         // If the parent had a different role, then we don&#39;t need to continue searching up the chain.
2230         if (parentAriaRole != AccessibilityRole::Unknown)
2231             break;
2232     }
2233 
2234     return role;
2235 }
2236 
2237 bool AccessibilityNodeObject::canSetSelectedAttribute() const
2238 {
2239     // Elements that can be selected
2240     switch (roleValue()) {
2241     case AccessibilityRole::Cell:
2242     case AccessibilityRole::GridCell:
2243     case AccessibilityRole::RowHeader:
2244     case AccessibilityRole::Row:
2245     case AccessibilityRole::TabList:
2246     case AccessibilityRole::Tab:
2247     case AccessibilityRole::TreeGrid:
2248     case AccessibilityRole::TreeItem:
2249     case AccessibilityRole::Tree:
2250     case AccessibilityRole::MenuItemCheckbox:
2251     case AccessibilityRole::MenuItemRadio:
2252     case AccessibilityRole::MenuItem:
2253         return isEnabled();
2254     default:
2255         return false;
2256     }
2257 }
2258 
2259 } // namespace WebCore
<a name="53" id="anc53"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="53" type="hidden" />
</body>
</html>