<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorCSSAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorCanvasAgent.h&quot;
 28 

 29 #include &quot;CanvasRenderingContext.h&quot;
 30 #include &quot;CanvasRenderingContext2D.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Element.h&quot;
 33 #include &quot;Frame.h&quot;

 34 #include &quot;ImageBitmapRenderingContext.h&quot;
 35 #include &quot;InspectorDOMAgent.h&quot;
 36 #include &quot;InstrumentingAgents.h&quot;
 37 #include &quot;JSCanvasRenderingContext2D.h&quot;
 38 #include &quot;JSExecState.h&quot;
 39 #include &quot;JSImageBitmapRenderingContext.h&quot;

 40 #include &quot;OffscreenCanvas.h&quot;
 41 #include &quot;ScriptState.h&quot;
 42 #include &quot;StringAdaptors.h&quot;
 43 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 44 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 45 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 46 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
 47 #include &lt;JavaScriptCore/JSCInlines.h&gt;


 48 
 49 #if ENABLE(WEBGL)
 50 #include &quot;JSWebGLRenderingContext.h&quot;
 51 #include &quot;WebGLProgram.h&quot;
 52 #include &quot;WebGLShader.h&quot;
 53 #endif
 54 
 55 #if ENABLE(WEBGL2)
 56 #include &quot;JSWebGL2RenderingContext.h&quot;
 57 #endif
 58 
<span class="line-modified"> 59 #if ENABLE(WEBMETAL)</span>
<span class="line-modified"> 60 #include &quot;JSWebMetalRenderingContext.h&quot;</span>
 61 #endif
 62 
<span class="line-removed"> 63 </span>
 64 namespace WebCore {
 65 
 66 using namespace Inspector;
 67 
<span class="line-modified"> 68 InspectorCanvasAgent::InspectorCanvasAgent(WebAgentContext&amp; context)</span>
 69     : InspectorAgentBase(&quot;Canvas&quot;_s, context)
<span class="line-modified"> 70     , m_frontendDispatcher(std::make_unique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))</span>
 71     , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
 72     , m_injectedScriptManager(context.injectedScriptManager)

 73     , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)
<span class="line-removed"> 74     , m_canvasRecordingTimer(*this, &amp;InspectorCanvasAgent::canvasRecordingTimerFired)</span>
 75 {
 76 }
 77 


 78 void InspectorCanvasAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 79 {
 80 }
 81 
 82 void InspectorCanvasAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 83 {
 84     ErrorString ignored;
 85     disable(ignored);
 86 }
 87 
 88 void InspectorCanvasAgent::discardAgent()
 89 {
 90     clearCanvasData();
 91 }
 92 
 93 void InspectorCanvasAgent::enable(ErrorString&amp;)
 94 {
<span class="line-modified"> 95     if (m_enabled)</span>
 96         return;
 97 
<span class="line-modified"> 98     m_recordingAutoCaptureFrameCount = WTF::nullopt;</span>
 99 
<span class="line-modified">100     m_enabled = true;</span>


101 
<span class="line-modified">102     const bool captureBacktrace = false;</span>
<span class="line-modified">103     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-modified">104         m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
105 
<span class="line-modified">106 #if ENABLE(WEBGL)</span>
<span class="line-modified">107         if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-modified">108             WebGLRenderingContextBase&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
<span class="line-modified">109             if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {</span>
<span class="line-modified">110                 for (const String&amp; extension : *extensions) {</span>
<span class="line-modified">111                     if (contextWebGL.extensionIsEnabled(extension))</span>
<span class="line-modified">112                         m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);</span>
<span class="line-modified">113                 }</span>
<span class="line-modified">114             }</span>

115         }
<span class="line-removed">116 #endif</span>
117     }
118 
119 #if ENABLE(WEBGL)
<span class="line-modified">120     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {</span>
<span class="line-modified">121         auto&amp; inspectorCanvas = inspectorProgram-&gt;canvas();</span>
<span class="line-modified">122         m_frontendDispatcher-&gt;programCreated(inspectorCanvas.identifier(), inspectorProgram-&gt;identifier());</span>



123     }
124 #endif
125 }
126 
127 void InspectorCanvasAgent::disable(ErrorString&amp;)
128 {
<span class="line-modified">129     if (!m_enabled)</span>
<span class="line-removed">130         return;</span>
<span class="line-removed">131 </span>
<span class="line-removed">132     if (m_canvasDestroyedTimer.isActive())</span>
<span class="line-removed">133         m_canvasDestroyedTimer.stop();</span>
<span class="line-removed">134 </span>
<span class="line-removed">135     m_removedCanvasIdentifiers.clear();</span>
136 
<span class="line-modified">137     if (m_canvasRecordingTimer.isActive())</span>
<span class="line-removed">138         m_canvasRecordingTimer.stop();</span>
<span class="line-removed">139 </span>
<span class="line-removed">140     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())</span>
<span class="line-removed">141         inspectorCanvas-&gt;resetRecordingData();</span>
142 
143     m_recordingAutoCaptureFrameCount = WTF::nullopt;
<span class="line-removed">144 </span>
<span class="line-removed">145     m_enabled = false;</span>
146 }
147 
148 void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
149 {
<span class="line-modified">150     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
151     if (!inspectorCanvas)
152         return;
153 
154     auto* node = inspectorCanvas-&gt;canvasElement();
155     if (!node) {
<span class="line-modified">156         errorString = &quot;No node for canvas&quot;_s;</span>
157         return;
158     }
159 
160     int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;node-&gt;document());
161     if (!documentNodeId) {
<span class="line-modified">162         errorString = &quot;Document has not been requested&quot;_s;</span>
163         return;
164     }
165 
166     *nodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, node);
167 }
168 
169 void InspectorCanvasAgent::requestContent(ErrorString&amp; errorString, const String&amp; canvasId, String* content)
170 {
<span class="line-modified">171     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
172     if (!inspectorCanvas)
173         return;
174 
<span class="line-modified">175     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations</span>
<span class="line-removed">176 </span>
<span class="line-removed">177     if (auto* node = inspectorCanvas-&gt;canvasElement()) {</span>
<span class="line-removed">178         if (is&lt;CanvasRenderingContext2D&gt;(inspectorCanvas-&gt;context()) || is&lt;ImageBitmapRenderingContext&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-removed">179             auto result = node-&gt;toDataURL(&quot;image/png&quot;_s);</span>
<span class="line-removed">180             if (result.hasException()) {</span>
<span class="line-removed">181                 errorString = result.releaseException().releaseMessage();</span>
<span class="line-removed">182                 return;</span>
<span class="line-removed">183             }</span>
<span class="line-removed">184             *content = result.releaseReturnValue().string;</span>
<span class="line-removed">185             return;</span>
<span class="line-removed">186         }</span>
<span class="line-removed">187 </span>
<span class="line-removed">188 #if ENABLE(WEBGL)</span>
<span class="line-removed">189         if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-removed">190             WebGLRenderingContextBase&amp; contextWebGLBase = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
<span class="line-removed">191 </span>
<span class="line-removed">192             contextWebGLBase.setPreventBufferClearForInspector(true);</span>
<span class="line-removed">193             auto result = node-&gt;toDataURL(&quot;image/png&quot;_s);</span>
<span class="line-removed">194             contextWebGLBase.setPreventBufferClearForInspector(false);</span>
<span class="line-removed">195 </span>
<span class="line-removed">196             if (result.hasException()) {</span>
<span class="line-removed">197                 errorString = result.releaseException().releaseMessage();</span>
<span class="line-removed">198                 return;</span>
<span class="line-removed">199             }</span>
<span class="line-removed">200             *content = result.releaseReturnValue().string;</span>
<span class="line-removed">201             return;</span>
<span class="line-removed">202         }</span>
<span class="line-removed">203 #endif</span>
<span class="line-removed">204     }</span>
<span class="line-removed">205 </span>
<span class="line-removed">206     // FIXME: &lt;https://webkit.org/b/173621&gt; Web Inspector: Support getting the content of WebMetal context;</span>
<span class="line-removed">207     errorString = &quot;Unsupported canvas context type&quot;_s;</span>
208 }
209 
210 void InspectorCanvasAgent::requestCSSCanvasClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
211 {
<span class="line-modified">212     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
213     if (!inspectorCanvas)
214         return;
215 
216     result = JSON::ArrayOf&lt;int&gt;::create();
217     for (auto* client : inspectorCanvas-&gt;context().canvasBase().cssCanvasClients()) {
218         if (int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;client-&gt;document()))
219             result-&gt;addItem(m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, client));
220     }
221 }
222 
223 static JSC::JSValue contextAsScriptValue(JSC::ExecState&amp; state, CanvasRenderingContext&amp; context)
224 {
225     JSC::JSLockHolder lock(&amp;state);
226 
227     if (is&lt;CanvasRenderingContext2D&gt;(context))
228         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;CanvasRenderingContext2D&gt;(context));
229 #if ENABLE(WEBGL)
230     if (is&lt;WebGLRenderingContext&gt;(context))
231         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGLRenderingContext&gt;(context));
232 #endif
233 #if ENABLE(WEBGL2)
234     if (is&lt;WebGL2RenderingContext&gt;(context))
235         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGL2RenderingContext&gt;(context));
236 #endif
<span class="line-modified">237 #if ENABLE(WEBMETAL)</span>
<span class="line-modified">238     if (is&lt;WebMetalRenderingContext&gt;(context))</span>
<span class="line-modified">239         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebMetalRenderingContext&gt;(context));</span>
240 #endif
241     if (is&lt;ImageBitmapRenderingContext&gt;(context))
242         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;ImageBitmapRenderingContext&gt;(context));
243 
244     return { };
245 }
246 
247 void InspectorCanvasAgent::resolveCanvasContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
248 {
<span class="line-modified">249     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
250     if (!inspectorCanvas)
251         return;
252 
253     auto&amp; state = *inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()-&gt;execState();
254     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
255     ASSERT(!injectedScript.hasNoValue());
256 
257     JSC::JSValue value = contextAsScriptValue(state, inspectorCanvas-&gt;context());
258     if (!value) {
259         ASSERT_NOT_REACHED();
<span class="line-modified">260         errorString = &quot;Unknown context type&quot;_s;</span>
261         return;
262     }
263 
264     String objectGroupName = objectGroup ? *objectGroup : String();
265     result = injectedScript.wrapObject(value, objectGroupName);
266 }
267 
268 void InspectorCanvasAgent::setRecordingAutoCaptureFrameCount(ErrorString&amp;, int count)
269 {
270     if (count &gt; 0)
271         m_recordingAutoCaptureFrameCount = count;
272     else
273         m_recordingAutoCaptureFrameCount = WTF::nullopt;
274 }
275 
276 void InspectorCanvasAgent::startRecording(ErrorString&amp; errorString, const String&amp; canvasId, const int* frameCount, const int* memoryLimit)
277 {
<span class="line-modified">278     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
279     if (!inspectorCanvas)
280         return;
281 
282     if (inspectorCanvas-&gt;context().callTracingActive()) {
283         errorString = &quot;Already recording canvas&quot;_s;
284         return;
285     }
286 
287     RecordingOptions recordingOptions;
288     if (frameCount)
289         recordingOptions.frameCount = *frameCount;
290     if (memoryLimit)
291         recordingOptions.memoryLimit = *memoryLimit;
292     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Frontend, WTFMove(recordingOptions));
293 }
294 
295 void InspectorCanvasAgent::stopRecording(ErrorString&amp; errorString, const String&amp; canvasId)
296 {
<span class="line-modified">297     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
298     if (!inspectorCanvas)
299         return;
300 
301     if (!inspectorCanvas-&gt;context().callTracingActive()) {
<span class="line-modified">302         errorString = &quot;No active recording for canvas&quot;_s;</span>
303         return;
304     }
305 
306     didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
307 }
308 
309 void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, String* content)
310 {
311 #if ENABLE(WEBGL)
<span class="line-modified">312     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
313     if (!inspectorProgram)
314         return;
315 
316     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
317     if (!shader) {
<span class="line-modified">318         errorString = &quot;No shader for given type.&quot;_s;</span>
319         return;
320     }
321 
322     *content = shader-&gt;getSource();
323 #else
324     UNUSED_PARAM(programId);
325     UNUSED_PARAM(shaderType);
326     UNUSED_PARAM(content);
<span class="line-modified">327     errorString = &quot;WebGL is not supported.&quot;_s;</span>
328 #endif
329 }
330 
331 void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, const String&amp; source)
332 {
333 #if ENABLE(WEBGL)
<span class="line-modified">334     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
335     if (!inspectorProgram)
336         return;
337 
338     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
339     if (!shader) {
<span class="line-modified">340         errorString = &quot;No shader for given type.&quot;_s;</span>
341         return;
342     }
343 
344     WebGLRenderingContextBase&amp; contextWebGL = inspectorProgram-&gt;context();
345     contextWebGL.shaderSource(shader, source);
346     contextWebGL.compileShader(shader);
347 
348     if (!shader-&gt;isValid()) {
<span class="line-modified">349         errorString = &quot;Shader compilation failed.&quot;_s;</span>
350         return;
351     }
352 
353     contextWebGL.linkProgramWithoutInvalidatingAttribLocations(&amp;inspectorProgram-&gt;program());
354 #else
355     UNUSED_PARAM(programId);
356     UNUSED_PARAM(shaderType);
357     UNUSED_PARAM(source);
<span class="line-modified">358     errorString = &quot;WebGL is not supported.&quot;_s;</span>
359 #endif
360 }
361 
362 void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
363 {
364 #if ENABLE(WEBGL)
<span class="line-modified">365     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
366     if (!inspectorProgram)
367         return;
368 
369     inspectorProgram-&gt;setDisabled(disabled);
370 #else
371     UNUSED_PARAM(programId);
372     UNUSED_PARAM(disabled);
<span class="line-modified">373     errorString = &quot;WebGL is not supported.&quot;_s;</span>
374 #endif
375 }
376 
377 void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
378 {
379 #if ENABLE(WEBGL)
<span class="line-modified">380     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
381     if (!inspectorProgram)
382         return;
383 
384     inspectorProgram-&gt;setHighlighted(highlighted);
385 #else
386     UNUSED_PARAM(programId);
387     UNUSED_PARAM(highlighted);
<span class="line-modified">388     errorString = &quot;WebGL is not supported.&quot;_s;</span>
389 #endif
390 }
391 
392 void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
393 {
394     if (frame.isMainFrame()) {
395         clearCanvasData();
396         return;
397     }
398 
399     Vector&lt;InspectorCanvas*&gt; inspectorCanvases;
400     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
401         if (auto* canvasElement = inspectorCanvas-&gt;canvasElement()) {
402             if (canvasElement-&gt;document().frame() == &amp;frame)
403                 inspectorCanvases.append(inspectorCanvas.get());
404         }
405     }
406 
407     for (auto* inspectorCanvas : inspectorCanvases) {
<span class="line-removed">408         inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);</span>
<span class="line-removed">409 </span>
410         String identifier = unbindCanvas(*inspectorCanvas);
<span class="line-modified">411         if (m_enabled)</span>
<span class="line-removed">412             m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
413     }
414 }
415 
416 void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
417 {
418     auto* context = canvasBase.renderingContext();
419     if (!context) {
420         ASSERT_NOT_REACHED();
421         return;
422     }
423 
<span class="line-modified">424     auto* inspectorCanvas = findInspectorCanvas(*context);</span>
425     ASSERT(inspectorCanvas);
426     if (!inspectorCanvas)
427         return;
428 
429     m_frontendDispatcher-&gt;cssCanvasClientNodesChanged(inspectorCanvas-&gt;identifier());
430 }
431 
432 void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext&amp; context)
433 {
434     if (findInspectorCanvas(context)) {
435         ASSERT_NOT_REACHED();
436         return;
437     }
438 
<span class="line-modified">439     context.canvasBase().addObserver(*this);</span>
<span class="line-removed">440 </span>
<span class="line-removed">441     auto inspectorCanvas = InspectorCanvas::create(context);</span>
<span class="line-removed">442     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());</span>
<span class="line-removed">443 </span>
<span class="line-removed">444     if (!m_enabled)</span>
<span class="line-removed">445         return;</span>
<span class="line-removed">446 </span>
<span class="line-removed">447     const bool captureBacktrace = true;</span>
<span class="line-removed">448     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
449 
450     if (m_recordingAutoCaptureFrameCount) {
451         RecordingOptions recordingOptions;
452         recordingOptions.frameCount = m_recordingAutoCaptureFrameCount.value();
<span class="line-modified">453         startRecording(inspectorCanvas.get(), Inspector::Protocol::Recording::Initiator::AutoCapture, WTFMove(recordingOptions));</span>
454     }
455 }
456 
457 void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
458 {
<span class="line-modified">459     auto* inspectorCanvas = findInspectorCanvas(context);</span>
460     ASSERT(inspectorCanvas);
461     if (!inspectorCanvas)
462         return;
463 
464     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
465 
466     if (auto* node = inspectorCanvas-&gt;canvasElement())
467         m_frontendDispatcher-&gt;canvasMemoryChanged(inspectorCanvas-&gt;identifier(), node-&gt;memoryCost());
468 }
469 
<span class="line-modified">470 void InspectorCanvasAgent::recordCanvasAction(CanvasRenderingContext&amp; canvasRenderingContext, const String&amp; name, Vector&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
471 {
<span class="line-modified">472     auto* inspectorCanvas = findInspectorCanvas(canvasRenderingContext);</span>
473     ASSERT(inspectorCanvas);
474     if (!inspectorCanvas)
475         return;
476 
477     ASSERT(canvasRenderingContext.callTracingActive());
478     if (!canvasRenderingContext.callTracingActive())
479         return;
480 
<span class="line-modified">481     inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));</span>









482 
<span class="line-modified">483     if (!m_canvasRecordingTimer.isActive())</span>
<span class="line-modified">484         m_canvasRecordingTimer.startOneShot(0_s);</span>





485 
486     if (!inspectorCanvas-&gt;hasBufferSpace())
487         didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
488 }
489 














490 void InspectorCanvasAgent::canvasDestroyed(CanvasBase&amp; canvasBase)
491 {
492     auto* context = canvasBase.renderingContext();
<span class="line-removed">493     ASSERT(context);</span>
494     if (!context)
495         return;
496 
<span class="line-modified">497     auto* inspectorCanvas = findInspectorCanvas(*context);</span>
498     ASSERT(inspectorCanvas);
499     if (!inspectorCanvas)
500         return;
501 
502     String identifier = unbindCanvas(*inspectorCanvas);
<span class="line-removed">503     if (!m_enabled)</span>
<span class="line-removed">504         return;</span>
505 
506     // WebCore::CanvasObserver::canvasDestroyed is called in response to the GC destroying the CanvasBase.
507     // Due to the single-process model used in WebKit1, the event must be dispatched from a timer to prevent
508     // the frontend from making JS allocations while the GC is still active.
509     m_removedCanvasIdentifiers.append(identifier);
510 
511     if (!m_canvasDestroyedTimer.isActive())
512         m_canvasDestroyedTimer.startOneShot(0_s);
513 }
514 
515 void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
516 {
<span class="line-modified">517     auto* inspectorCanvas = findInspectorCanvas(context);</span>
518     ASSERT(inspectorCanvas);
519     if (!inspectorCanvas)
520         return;
521 
522     if (!inspectorCanvas-&gt;context().callTracingActive())
523         return;
524 
525     if (!inspectorCanvas-&gt;hasRecordingData()) {
526         if (forceDispatch) {
527             m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
<span class="line-removed">528 </span>
529             inspectorCanvas-&gt;resetRecordingData();
530         }
531         return;
532     }
533 
534     if (forceDispatch)
535         inspectorCanvas-&gt;markCurrentFrameIncomplete();
536 
537     inspectorCanvas-&gt;finalizeFrame();
538     if (inspectorCanvas-&gt;currentFrameHasData())
539         m_frontendDispatcher-&gt;recordingProgress(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseFrames(), inspectorCanvas-&gt;bufferUsed());
540 
541     if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
542         return;
543 
<span class="line-modified">544     // FIXME: &lt;https://webkit.org/b/176008&gt; Web Inspector: Record actions performed on WebGL2RenderingContext</span>
<span class="line-removed">545 </span>
<span class="line-removed">546     Inspector::Protocol::Recording::Type type;</span>
<span class="line-removed">547     if (is&lt;CanvasRenderingContext2D&gt;(inspectorCanvas-&gt;context()))</span>
<span class="line-removed">548         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-removed">549     else if (is&lt;ImageBitmapRenderingContext&gt;(inspectorCanvas-&gt;context()))</span>
<span class="line-removed">550         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;</span>
<span class="line-removed">551 #if ENABLE(WEBGL)</span>
<span class="line-removed">552     else if (is&lt;WebGLRenderingContext&gt;(inspectorCanvas-&gt;context()))</span>
<span class="line-removed">553         type = Inspector::Protocol::Recording::Type::CanvasWebGL;</span>
<span class="line-removed">554 #endif</span>
<span class="line-removed">555     else {</span>
<span class="line-removed">556         ASSERT_NOT_REACHED();</span>
<span class="line-removed">557         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-removed">558     }</span>
<span class="line-removed">559 </span>
<span class="line-removed">560     auto recording = Inspector::Protocol::Recording::Recording::create()</span>
<span class="line-removed">561         .setVersion(Inspector::Protocol::Recording::VERSION)</span>
<span class="line-removed">562         .setType(type)</span>
<span class="line-removed">563         .setInitialState(inspectorCanvas-&gt;releaseInitialState())</span>
<span class="line-removed">564         .setData(inspectorCanvas-&gt;releaseData())</span>
<span class="line-removed">565         .release();</span>
<span class="line-removed">566 </span>
<span class="line-removed">567     const String&amp; name = inspectorCanvas-&gt;recordingName();</span>
<span class="line-removed">568     if (!name.isEmpty())</span>
<span class="line-removed">569         recording-&gt;setName(name);</span>
<span class="line-removed">570 </span>
<span class="line-removed">571     m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), WTFMove(recording));</span>
<span class="line-removed">572 </span>
<span class="line-removed">573     inspectorCanvas-&gt;resetRecordingData();</span>
574 }
575 
576 void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::ExecState&amp; exec, JSC::JSObject* options)
577 {
<span class="line-modified">578     auto* inspectorCanvas = findInspectorCanvas(context);</span>
579     ASSERT(inspectorCanvas);
580     if (!inspectorCanvas)
581         return;
582 
583     RecordingOptions recordingOptions;
584     if (options) {
<span class="line-modified">585         if (JSC::JSValue optionSingleFrame = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;singleFrame&quot;)))</span>

586             recordingOptions.frameCount = optionSingleFrame.toBoolean(&amp;exec) ? 1 : 0;
<span class="line-modified">587         if (JSC::JSValue optionFrameCount = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;frameCount&quot;)))</span>
588             recordingOptions.frameCount = optionFrameCount.toNumber(&amp;exec);
<span class="line-modified">589         if (JSC::JSValue optionMemoryLimit = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;memoryLimit&quot;)))</span>
590             recordingOptions.memoryLimit = optionMemoryLimit.toNumber(&amp;exec);
<span class="line-modified">591         if (JSC::JSValue optionName = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;name&quot;)))</span>
592             recordingOptions.name = optionName.toWTFString(&amp;exec);
593     }
594     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
595 }
596 
597 #if ENABLE(WEBGL)
598 void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
599 {
<span class="line-modified">600     auto* inspectorCanvas = findInspectorCanvas(context);</span>
601     ASSERT(inspectorCanvas);
602     if (!inspectorCanvas)
603         return;
604 
605     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
606 }
607 
608 void InspectorCanvasAgent::didCreateProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)
609 {
<span class="line-modified">610     auto* inspectorCanvas = findInspectorCanvas(context);</span>
611     ASSERT(inspectorCanvas);
612     if (!inspectorCanvas)
613         return;
614 
615     auto inspectorProgram = InspectorShaderProgram::create(program, *inspectorCanvas);
616     String programIdentifier = inspectorProgram-&gt;identifier();
617     m_identifierToInspectorProgram.set(programIdentifier, WTFMove(inspectorProgram));
<span class="line-modified">618 </span>
<span class="line-removed">619     if (m_enabled)</span>
<span class="line-removed">620         m_frontendDispatcher-&gt;programCreated(inspectorCanvas-&gt;identifier(), programIdentifier);</span>
621 }
622 
623 void InspectorCanvasAgent::willDeleteProgram(WebGLProgram&amp; program)
624 {
<span class="line-modified">625     auto* inspectorProgram = findInspectorProgram(program);</span>
626     if (!inspectorProgram)
627         return;
628 
629     String identifier = unbindProgram(*inspectorProgram);
<span class="line-modified">630     if (m_enabled)</span>
<span class="line-removed">631         m_frontendDispatcher-&gt;programDeleted(identifier);</span>
632 }
633 
634 bool InspectorCanvasAgent::isShaderProgramDisabled(WebGLProgram&amp; program)
635 {
<span class="line-modified">636     auto* inspectorProgram = findInspectorProgram(program);</span>

637     if (!inspectorProgram)
638         return false;
639 
640     return inspectorProgram-&gt;disabled();
641 }
642 
643 bool InspectorCanvasAgent::isShaderProgramHighlighted(WebGLProgram&amp; program)
644 {
<span class="line-modified">645     auto* inspectorProgram = findInspectorProgram(program);</span>

646     if (!inspectorProgram)
647         return false;
648 
649     return inspectorProgram-&gt;highlighted();
650 }
651 #endif
652 
653 void InspectorCanvasAgent::startRecording(InspectorCanvas&amp; inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&amp;&amp; recordingOptions)
654 {
655     auto&amp; canvasRenderingContext = inspectorCanvas.context();
656 
657     if (!is&lt;CanvasRenderingContext2D&gt;(canvasRenderingContext)
658 #if ENABLE(WEBGL)
659         &amp;&amp; !is&lt;WebGLRenderingContext&gt;(canvasRenderingContext)



660 #endif
661         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(canvasRenderingContext))
662         return;
663 
664     if (canvasRenderingContext.callTracingActive())
665         return;
666 
667     inspectorCanvas.resetRecordingData();
668     if (recordingOptions.frameCount)
669         inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
670     if (recordingOptions.memoryLimit)
671         inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
672     if (recordingOptions.name)
673         inspectorCanvas.setRecordingName(recordingOptions.name.value());
674     canvasRenderingContext.setCallTracingActive(true);
675 
676     m_frontendDispatcher-&gt;recordingStarted(inspectorCanvas.identifier(), initiator);
677 }
678 
679 void InspectorCanvasAgent::canvasDestroyedTimerFired()
680 {
681     if (!m_removedCanvasIdentifiers.size())
682         return;
683 
<span class="line-modified">684     if (m_enabled) {</span>
<span class="line-modified">685         for (auto&amp; identifier : m_removedCanvasIdentifiers)</span>
<span class="line-removed">686             m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
<span class="line-removed">687     }</span>
688 
689     m_removedCanvasIdentifiers.clear();
690 }
691 
<span class="line-removed">692 void InspectorCanvasAgent::canvasRecordingTimerFired()</span>
<span class="line-removed">693 {</span>
<span class="line-removed">694     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-removed">695         if (!inspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-removed">696             continue;</span>
<span class="line-removed">697 </span>
<span class="line-removed">698         didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context());</span>
<span class="line-removed">699     }</span>
<span class="line-removed">700 }</span>
<span class="line-removed">701 </span>
702 void InspectorCanvasAgent::clearCanvasData()
703 {
704     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())
705         inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);
706 
707     m_identifierToInspectorCanvas.clear();
<span class="line-removed">708     m_removedCanvasIdentifiers.clear();</span>
709 #if ENABLE(WEBGL)
710     m_identifierToInspectorProgram.clear();

711 #endif
712 
<span class="line-removed">713     if (m_canvasRecordingTimer.isActive())</span>
<span class="line-removed">714         m_canvasRecordingTimer.stop();</span>
<span class="line-removed">715 </span>
716     if (m_canvasDestroyedTimer.isActive())
717         m_canvasDestroyedTimer.stop();
718 }
719 
























720 String InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)
721 {
722 #if ENABLE(WEBGL)
723     Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
724     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
725         if (&amp;inspectorProgram-&gt;canvas() == &amp;inspectorCanvas)
726             programsToRemove.append(inspectorProgram.get());
727     }
728 
729     for (auto* inspectorProgram : programsToRemove)
730         unbindProgram(*inspectorProgram);
731 #endif
732 


733     String identifier = inspectorCanvas.identifier();
734     m_identifierToInspectorCanvas.remove(identifier);
735 
736     return identifier;
737 }
738 
<span class="line-modified">739 InspectorCanvas* InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; identifier)</span>
740 {
<span class="line-modified">741     RefPtr&lt;InspectorCanvas&gt; inspectorCanvas = m_identifierToInspectorCanvas.get(identifier);</span>
742     if (!inspectorCanvas) {
<span class="line-modified">743         errorString = &quot;No canvas for given identifier.&quot;_s;</span>
744         return nullptr;
745     }
<span class="line-modified">746 </span>
<span class="line-removed">747     return inspectorCanvas.get();</span>
748 }
749 
<span class="line-modified">750 InspectorCanvas* InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)</span>
751 {
752     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
753         if (&amp;inspectorCanvas-&gt;context() == &amp;context)
<span class="line-modified">754             return inspectorCanvas.get();</span>
755     }
<span class="line-removed">756 </span>
757     return nullptr;
758 }
759 
760 #if ENABLE(WEBGL)
761 String InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)
762 {
763     String identifier = inspectorProgram.identifier();
764     m_identifierToInspectorProgram.remove(identifier);
765 
766     return identifier;
767 }
768 
<span class="line-modified">769 InspectorShaderProgram* InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; identifier)</span>
770 {
<span class="line-modified">771     RefPtr&lt;InspectorShaderProgram&gt; inspectorProgram = m_identifierToInspectorProgram.get(identifier);</span>
772     if (!inspectorProgram) {
<span class="line-modified">773         errorString = &quot;No shader program for given identifier.&quot;_s;</span>
774         return nullptr;
775     }
<span class="line-modified">776 </span>
<span class="line-removed">777     return inspectorProgram.get();</span>
778 }
779 
<span class="line-modified">780 InspectorShaderProgram* InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)</span>
781 {
782     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
783         if (&amp;inspectorProgram-&gt;program() == &amp;program)
<span class="line-modified">784             return inspectorProgram.get();</span>
785     }
<span class="line-removed">786 </span>
787     return nullptr;
788 }
789 #endif
790 
791 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorCanvasAgent.h&quot;
 28 
<span class="line-added"> 29 #include &quot;ActiveDOMCallbackMicrotask.h&quot;</span>
 30 #include &quot;CanvasRenderingContext.h&quot;
 31 #include &quot;CanvasRenderingContext2D.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;Element.h&quot;
 34 #include &quot;Frame.h&quot;
<span class="line-added"> 35 #include &quot;HTMLCanvasElement.h&quot;</span>
 36 #include &quot;ImageBitmapRenderingContext.h&quot;
 37 #include &quot;InspectorDOMAgent.h&quot;
 38 #include &quot;InstrumentingAgents.h&quot;
 39 #include &quot;JSCanvasRenderingContext2D.h&quot;
 40 #include &quot;JSExecState.h&quot;
 41 #include &quot;JSImageBitmapRenderingContext.h&quot;
<span class="line-added"> 42 #include &quot;Microtasks.h&quot;</span>
 43 #include &quot;OffscreenCanvas.h&quot;
 44 #include &quot;ScriptState.h&quot;
 45 #include &quot;StringAdaptors.h&quot;
 46 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 47 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 48 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 49 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
 50 #include &lt;JavaScriptCore/JSCInlines.h&gt;
<span class="line-added"> 51 #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added"> 52 #include &lt;wtf/Lock.h&gt;</span>
 53 
 54 #if ENABLE(WEBGL)
 55 #include &quot;JSWebGLRenderingContext.h&quot;
 56 #include &quot;WebGLProgram.h&quot;
 57 #include &quot;WebGLShader.h&quot;
 58 #endif
 59 
 60 #if ENABLE(WEBGL2)
 61 #include &quot;JSWebGL2RenderingContext.h&quot;
 62 #endif
 63 
<span class="line-modified"> 64 #if ENABLE(WEBGPU)</span>
<span class="line-modified"> 65 #include &quot;JSGPUCanvasContext.h&quot;</span>
 66 #endif
 67 

 68 namespace WebCore {
 69 
 70 using namespace Inspector;
 71 
<span class="line-modified"> 72 InspectorCanvasAgent::InspectorCanvasAgent(PageAgentContext&amp; context)</span>
 73     : InspectorAgentBase(&quot;Canvas&quot;_s, context)
<span class="line-modified"> 74     , m_frontendDispatcher(makeUnique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))</span>
 75     , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
 76     , m_injectedScriptManager(context.injectedScriptManager)
<span class="line-added"> 77     , m_inspectedPage(context.inspectedPage)</span>
 78     , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)

 79 {
 80 }
 81 
<span class="line-added"> 82 InspectorCanvasAgent::~InspectorCanvasAgent() = default;</span>
<span class="line-added"> 83 </span>
 84 void InspectorCanvasAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 85 {
 86 }
 87 
 88 void InspectorCanvasAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 89 {
 90     ErrorString ignored;
 91     disable(ignored);
 92 }
 93 
 94 void InspectorCanvasAgent::discardAgent()
 95 {
 96     clearCanvasData();
 97 }
 98 
 99 void InspectorCanvasAgent::enable(ErrorString&amp;)
100 {
<span class="line-modified">101     if (m_instrumentingAgents.inspectorCanvasAgent() == this)</span>
102         return;
103 
<span class="line-modified">104     m_instrumentingAgents.setInspectorCanvasAgent(this);</span>
105 
<span class="line-modified">106     const auto canvasExistsInCurrentPage = [&amp;] (CanvasRenderingContext* canvasRenderingContext) {</span>
<span class="line-added">107         if (!canvasRenderingContext)</span>
<span class="line-added">108             return false;</span>
109 
<span class="line-modified">110         auto* scriptExecutionContext = canvasRenderingContext-&gt;canvasBase().scriptExecutionContext();</span>
<span class="line-modified">111         if (!is&lt;Document&gt;(scriptExecutionContext))</span>
<span class="line-modified">112             return false;</span>
113 
<span class="line-modified">114         // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets</span>
<span class="line-modified">115         auto* document = downcast&lt;Document&gt;(scriptExecutionContext);</span>
<span class="line-modified">116         return document-&gt;page() == &amp;m_inspectedPage;</span>
<span class="line-modified">117     };</span>
<span class="line-modified">118 </span>
<span class="line-modified">119     {</span>
<span class="line-modified">120         LockHolder lock(CanvasRenderingContext::instancesMutex());</span>
<span class="line-modified">121         for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-modified">122             if (canvasExistsInCurrentPage(canvasRenderingContext))</span>
<span class="line-added">123                 bindCanvas(*canvasRenderingContext, false);</span>
124         }

125     }
126 
127 #if ENABLE(WEBGL)
<span class="line-modified">128     {</span>
<span class="line-modified">129         LockHolder lock(WebGLProgram::instancesMutex());</span>
<span class="line-modified">130         for (auto&amp; entry : WebGLProgram::instances(lock)) {</span>
<span class="line-added">131             if (canvasExistsInCurrentPage(entry.value))</span>
<span class="line-added">132                 didCreateProgram(*entry.value, *entry.key);</span>
<span class="line-added">133         }</span>
134     }
135 #endif
136 }
137 
138 void InspectorCanvasAgent::disable(ErrorString&amp;)
139 {
<span class="line-modified">140     m_instrumentingAgents.setInspectorCanvasAgent(nullptr);</span>






141 
<span class="line-modified">142     clearCanvasData();</span>




143 
144     m_recordingAutoCaptureFrameCount = WTF::nullopt;


145 }
146 
147 void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
148 {
<span class="line-modified">149     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
150     if (!inspectorCanvas)
151         return;
152 
153     auto* node = inspectorCanvas-&gt;canvasElement();
154     if (!node) {
<span class="line-modified">155         errorString = &quot;Missing element of canvas for given canvasId&quot;_s;</span>
156         return;
157     }
158 
159     int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;node-&gt;document());
160     if (!documentNodeId) {
<span class="line-modified">161         errorString = &quot;Document must have been requested&quot;_s;</span>
162         return;
163     }
164 
165     *nodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, node);
166 }
167 
168 void InspectorCanvasAgent::requestContent(ErrorString&amp; errorString, const String&amp; canvasId, String* content)
169 {
<span class="line-modified">170     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
171     if (!inspectorCanvas)
172         return;
173 
<span class="line-modified">174     *content = inspectorCanvas-&gt;getCanvasContentAsDataURL(errorString);</span>
































175 }
176 
177 void InspectorCanvasAgent::requestCSSCanvasClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
178 {
<span class="line-modified">179     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
180     if (!inspectorCanvas)
181         return;
182 
183     result = JSON::ArrayOf&lt;int&gt;::create();
184     for (auto* client : inspectorCanvas-&gt;context().canvasBase().cssCanvasClients()) {
185         if (int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;client-&gt;document()))
186             result-&gt;addItem(m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, client));
187     }
188 }
189 
190 static JSC::JSValue contextAsScriptValue(JSC::ExecState&amp; state, CanvasRenderingContext&amp; context)
191 {
192     JSC::JSLockHolder lock(&amp;state);
193 
194     if (is&lt;CanvasRenderingContext2D&gt;(context))
195         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;CanvasRenderingContext2D&gt;(context));
196 #if ENABLE(WEBGL)
197     if (is&lt;WebGLRenderingContext&gt;(context))
198         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGLRenderingContext&gt;(context));
199 #endif
200 #if ENABLE(WEBGL2)
201     if (is&lt;WebGL2RenderingContext&gt;(context))
202         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGL2RenderingContext&gt;(context));
203 #endif
<span class="line-modified">204 #if ENABLE(WEBGPU)</span>
<span class="line-modified">205     if (is&lt;GPUCanvasContext&gt;(context))</span>
<span class="line-modified">206         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;GPUCanvasContext&gt;(context));</span>
207 #endif
208     if (is&lt;ImageBitmapRenderingContext&gt;(context))
209         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;ImageBitmapRenderingContext&gt;(context));
210 
211     return { };
212 }
213 
214 void InspectorCanvasAgent::resolveCanvasContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
215 {
<span class="line-modified">216     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
217     if (!inspectorCanvas)
218         return;
219 
220     auto&amp; state = *inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()-&gt;execState();
221     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
222     ASSERT(!injectedScript.hasNoValue());
223 
224     JSC::JSValue value = contextAsScriptValue(state, inspectorCanvas-&gt;context());
225     if (!value) {
226         ASSERT_NOT_REACHED();
<span class="line-modified">227         errorString = &quot;Internal error: unknown context of canvas for given canvasId&quot;_s;</span>
228         return;
229     }
230 
231     String objectGroupName = objectGroup ? *objectGroup : String();
232     result = injectedScript.wrapObject(value, objectGroupName);
233 }
234 
235 void InspectorCanvasAgent::setRecordingAutoCaptureFrameCount(ErrorString&amp;, int count)
236 {
237     if (count &gt; 0)
238         m_recordingAutoCaptureFrameCount = count;
239     else
240         m_recordingAutoCaptureFrameCount = WTF::nullopt;
241 }
242 
243 void InspectorCanvasAgent::startRecording(ErrorString&amp; errorString, const String&amp; canvasId, const int* frameCount, const int* memoryLimit)
244 {
<span class="line-modified">245     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
246     if (!inspectorCanvas)
247         return;
248 
249     if (inspectorCanvas-&gt;context().callTracingActive()) {
250         errorString = &quot;Already recording canvas&quot;_s;
251         return;
252     }
253 
254     RecordingOptions recordingOptions;
255     if (frameCount)
256         recordingOptions.frameCount = *frameCount;
257     if (memoryLimit)
258         recordingOptions.memoryLimit = *memoryLimit;
259     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Frontend, WTFMove(recordingOptions));
260 }
261 
262 void InspectorCanvasAgent::stopRecording(ErrorString&amp; errorString, const String&amp; canvasId)
263 {
<span class="line-modified">264     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
265     if (!inspectorCanvas)
266         return;
267 
268     if (!inspectorCanvas-&gt;context().callTracingActive()) {
<span class="line-modified">269         errorString = &quot;Not recording canvas&quot;_s;</span>
270         return;
271     }
272 
273     didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
274 }
275 
276 void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, String* content)
277 {
278 #if ENABLE(WEBGL)
<span class="line-modified">279     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
280     if (!inspectorProgram)
281         return;
282 
283     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
284     if (!shader) {
<span class="line-modified">285         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
286         return;
287     }
288 
289     *content = shader-&gt;getSource();
290 #else
291     UNUSED_PARAM(programId);
292     UNUSED_PARAM(shaderType);
293     UNUSED_PARAM(content);
<span class="line-modified">294     errorString = &quot;Not supported&quot;_s;</span>
295 #endif
296 }
297 
298 void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, const String&amp; source)
299 {
300 #if ENABLE(WEBGL)
<span class="line-modified">301     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
302     if (!inspectorProgram)
303         return;
304 
305     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
306     if (!shader) {
<span class="line-modified">307         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
308         return;
309     }
310 
311     WebGLRenderingContextBase&amp; contextWebGL = inspectorProgram-&gt;context();
312     contextWebGL.shaderSource(shader, source);
313     contextWebGL.compileShader(shader);
314 
315     if (!shader-&gt;isValid()) {
<span class="line-modified">316         errorString = &quot;Failed to update shader&quot;_s;</span>
317         return;
318     }
319 
320     contextWebGL.linkProgramWithoutInvalidatingAttribLocations(&amp;inspectorProgram-&gt;program());
321 #else
322     UNUSED_PARAM(programId);
323     UNUSED_PARAM(shaderType);
324     UNUSED_PARAM(source);
<span class="line-modified">325     errorString = &quot;Not supported&quot;_s;</span>
326 #endif
327 }
328 
329 void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
330 {
331 #if ENABLE(WEBGL)
<span class="line-modified">332     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
333     if (!inspectorProgram)
334         return;
335 
336     inspectorProgram-&gt;setDisabled(disabled);
337 #else
338     UNUSED_PARAM(programId);
339     UNUSED_PARAM(disabled);
<span class="line-modified">340     errorString = &quot;Not supported&quot;_s;</span>
341 #endif
342 }
343 
344 void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
345 {
346 #if ENABLE(WEBGL)
<span class="line-modified">347     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
348     if (!inspectorProgram)
349         return;
350 
351     inspectorProgram-&gt;setHighlighted(highlighted);
352 #else
353     UNUSED_PARAM(programId);
354     UNUSED_PARAM(highlighted);
<span class="line-modified">355     errorString = &quot;Not supported&quot;_s;</span>
356 #endif
357 }
358 
359 void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
360 {
361     if (frame.isMainFrame()) {
362         clearCanvasData();
363         return;
364     }
365 
366     Vector&lt;InspectorCanvas*&gt; inspectorCanvases;
367     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
368         if (auto* canvasElement = inspectorCanvas-&gt;canvasElement()) {
369             if (canvasElement-&gt;document().frame() == &amp;frame)
370                 inspectorCanvases.append(inspectorCanvas.get());
371         }
372     }
373 
374     for (auto* inspectorCanvas : inspectorCanvases) {


375         String identifier = unbindCanvas(*inspectorCanvas);
<span class="line-modified">376         m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>

377     }
378 }
379 
380 void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
381 {
382     auto* context = canvasBase.renderingContext();
383     if (!context) {
384         ASSERT_NOT_REACHED();
385         return;
386     }
387 
<span class="line-modified">388     auto inspectorCanvas = findInspectorCanvas(*context);</span>
389     ASSERT(inspectorCanvas);
390     if (!inspectorCanvas)
391         return;
392 
393     m_frontendDispatcher-&gt;cssCanvasClientNodesChanged(inspectorCanvas-&gt;identifier());
394 }
395 
396 void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext&amp; context)
397 {
398     if (findInspectorCanvas(context)) {
399         ASSERT_NOT_REACHED();
400         return;
401     }
402 
<span class="line-modified">403     auto&amp; inspectorCanvas = bindCanvas(context, true);</span>









404 
405     if (m_recordingAutoCaptureFrameCount) {
406         RecordingOptions recordingOptions;
407         recordingOptions.frameCount = m_recordingAutoCaptureFrameCount.value();
<span class="line-modified">408         startRecording(inspectorCanvas, Inspector::Protocol::Recording::Initiator::AutoCapture, WTFMove(recordingOptions));</span>
409     }
410 }
411 
412 void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
413 {
<span class="line-modified">414     auto inspectorCanvas = findInspectorCanvas(context);</span>
415     ASSERT(inspectorCanvas);
416     if (!inspectorCanvas)
417         return;
418 
419     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
420 
421     if (auto* node = inspectorCanvas-&gt;canvasElement())
422         m_frontendDispatcher-&gt;canvasMemoryChanged(inspectorCanvas-&gt;identifier(), node-&gt;memoryCost());
423 }
424 
<span class="line-modified">425 void InspectorCanvasAgent::recordCanvasAction(CanvasRenderingContext&amp; canvasRenderingContext, const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
426 {
<span class="line-modified">427     auto inspectorCanvas = findInspectorCanvas(canvasRenderingContext);</span>
428     ASSERT(inspectorCanvas);
429     if (!inspectorCanvas)
430         return;
431 
432     ASSERT(canvasRenderingContext.callTracingActive());
433     if (!canvasRenderingContext.callTracingActive())
434         return;
435 
<span class="line-modified">436     // Only enqueue a microtask for the first action of each frame. Any subsequent actions will be</span>
<span class="line-added">437     // covered by the initial microtask until the next frame.</span>
<span class="line-added">438     if (!inspectorCanvas-&gt;currentFrameHasData()) {</span>
<span class="line-added">439         if (auto* scriptExecutionContext = inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()) {</span>
<span class="line-added">440             auto&amp; queue = MicrotaskQueue::mainThreadQueue();</span>
<span class="line-added">441             queue.append(makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(queue, *scriptExecutionContext, [&amp;, protectedInspectorCanvas = inspectorCanvas.copyRef()] {</span>
<span class="line-added">442                 if (auto* canvasElement = protectedInspectorCanvas-&gt;canvasElement()) {</span>
<span class="line-added">443                     if (canvasElement-&gt;isDescendantOf(canvasElement-&gt;document()))</span>
<span class="line-added">444                         return;</span>
<span class="line-added">445                 }</span>
446 
<span class="line-modified">447                 if (protectedInspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-modified">448                     didFinishRecordingCanvasFrame(protectedInspectorCanvas-&gt;context());</span>
<span class="line-added">449             }));</span>
<span class="line-added">450         }</span>
<span class="line-added">451     }</span>
<span class="line-added">452 </span>
<span class="line-added">453     inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));</span>
454 
455     if (!inspectorCanvas-&gt;hasBufferSpace())
456         didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
457 }
458 
<span class="line-added">459 void InspectorCanvasAgent::canvasChanged(CanvasBase&amp; canvasBase, const FloatRect&amp;)</span>
<span class="line-added">460 {</span>
<span class="line-added">461     auto* context = canvasBase.renderingContext();</span>
<span class="line-added">462     if (!context)</span>
<span class="line-added">463         return;</span>
<span class="line-added">464 </span>
<span class="line-added">465     auto inspectorCanvas = findInspectorCanvas(*context);</span>
<span class="line-added">466     ASSERT(inspectorCanvas);</span>
<span class="line-added">467     if (!inspectorCanvas)</span>
<span class="line-added">468         return;</span>
<span class="line-added">469 </span>
<span class="line-added">470     inspectorCanvas-&gt;canvasChanged();</span>
<span class="line-added">471 }</span>
<span class="line-added">472 </span>
473 void InspectorCanvasAgent::canvasDestroyed(CanvasBase&amp; canvasBase)
474 {
475     auto* context = canvasBase.renderingContext();

476     if (!context)
477         return;
478 
<span class="line-modified">479     auto inspectorCanvas = findInspectorCanvas(*context);</span>
480     ASSERT(inspectorCanvas);
481     if (!inspectorCanvas)
482         return;
483 
484     String identifier = unbindCanvas(*inspectorCanvas);


485 
486     // WebCore::CanvasObserver::canvasDestroyed is called in response to the GC destroying the CanvasBase.
487     // Due to the single-process model used in WebKit1, the event must be dispatched from a timer to prevent
488     // the frontend from making JS allocations while the GC is still active.
489     m_removedCanvasIdentifiers.append(identifier);
490 
491     if (!m_canvasDestroyedTimer.isActive())
492         m_canvasDestroyedTimer.startOneShot(0_s);
493 }
494 
495 void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
496 {
<span class="line-modified">497     auto inspectorCanvas = findInspectorCanvas(context);</span>
498     ASSERT(inspectorCanvas);
499     if (!inspectorCanvas)
500         return;
501 
502     if (!inspectorCanvas-&gt;context().callTracingActive())
503         return;
504 
505     if (!inspectorCanvas-&gt;hasRecordingData()) {
506         if (forceDispatch) {
507             m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);

508             inspectorCanvas-&gt;resetRecordingData();
509         }
510         return;
511     }
512 
513     if (forceDispatch)
514         inspectorCanvas-&gt;markCurrentFrameIncomplete();
515 
516     inspectorCanvas-&gt;finalizeFrame();
517     if (inspectorCanvas-&gt;currentFrameHasData())
518         m_frontendDispatcher-&gt;recordingProgress(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseFrames(), inspectorCanvas-&gt;bufferUsed());
519 
520     if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
521         return;
522 
<span class="line-modified">523     m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseObjectForRecording());</span>





























524 }
525 
526 void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::ExecState&amp; exec, JSC::JSObject* options)
527 {
<span class="line-modified">528     auto inspectorCanvas = findInspectorCanvas(context);</span>
529     ASSERT(inspectorCanvas);
530     if (!inspectorCanvas)
531         return;
532 
533     RecordingOptions recordingOptions;
534     if (options) {
<span class="line-modified">535         JSC::VM&amp; vm = exec.vm();</span>
<span class="line-added">536         if (JSC::JSValue optionSingleFrame = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;singleFrame&quot;)))</span>
537             recordingOptions.frameCount = optionSingleFrame.toBoolean(&amp;exec) ? 1 : 0;
<span class="line-modified">538         if (JSC::JSValue optionFrameCount = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;frameCount&quot;)))</span>
539             recordingOptions.frameCount = optionFrameCount.toNumber(&amp;exec);
<span class="line-modified">540         if (JSC::JSValue optionMemoryLimit = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;memoryLimit&quot;)))</span>
541             recordingOptions.memoryLimit = optionMemoryLimit.toNumber(&amp;exec);
<span class="line-modified">542         if (JSC::JSValue optionName = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;name&quot;)))</span>
543             recordingOptions.name = optionName.toWTFString(&amp;exec);
544     }
545     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
546 }
547 
548 #if ENABLE(WEBGL)
549 void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
550 {
<span class="line-modified">551     auto inspectorCanvas = findInspectorCanvas(context);</span>
552     ASSERT(inspectorCanvas);
553     if (!inspectorCanvas)
554         return;
555 
556     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
557 }
558 
559 void InspectorCanvasAgent::didCreateProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)
560 {
<span class="line-modified">561     auto inspectorCanvas = findInspectorCanvas(context);</span>
562     ASSERT(inspectorCanvas);
563     if (!inspectorCanvas)
564         return;
565 
566     auto inspectorProgram = InspectorShaderProgram::create(program, *inspectorCanvas);
567     String programIdentifier = inspectorProgram-&gt;identifier();
568     m_identifierToInspectorProgram.set(programIdentifier, WTFMove(inspectorProgram));
<span class="line-modified">569     m_frontendDispatcher-&gt;programCreated(inspectorCanvas-&gt;identifier(), programIdentifier);</span>


570 }
571 
572 void InspectorCanvasAgent::willDeleteProgram(WebGLProgram&amp; program)
573 {
<span class="line-modified">574     auto inspectorProgram = findInspectorProgram(program);</span>
575     if (!inspectorProgram)
576         return;
577 
578     String identifier = unbindProgram(*inspectorProgram);
<span class="line-modified">579     m_frontendDispatcher-&gt;programDeleted(identifier);</span>

580 }
581 
582 bool InspectorCanvasAgent::isShaderProgramDisabled(WebGLProgram&amp; program)
583 {
<span class="line-modified">584     auto inspectorProgram = findInspectorProgram(program);</span>
<span class="line-added">585     ASSERT(inspectorProgram);</span>
586     if (!inspectorProgram)
587         return false;
588 
589     return inspectorProgram-&gt;disabled();
590 }
591 
592 bool InspectorCanvasAgent::isShaderProgramHighlighted(WebGLProgram&amp; program)
593 {
<span class="line-modified">594     auto inspectorProgram = findInspectorProgram(program);</span>
<span class="line-added">595     ASSERT(inspectorProgram);</span>
596     if (!inspectorProgram)
597         return false;
598 
599     return inspectorProgram-&gt;highlighted();
600 }
601 #endif
602 
603 void InspectorCanvasAgent::startRecording(InspectorCanvas&amp; inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&amp;&amp; recordingOptions)
604 {
605     auto&amp; canvasRenderingContext = inspectorCanvas.context();
606 
607     if (!is&lt;CanvasRenderingContext2D&gt;(canvasRenderingContext)
608 #if ENABLE(WEBGL)
609         &amp;&amp; !is&lt;WebGLRenderingContext&gt;(canvasRenderingContext)
<span class="line-added">610 #endif</span>
<span class="line-added">611 #if ENABLE(WEBGL2)</span>
<span class="line-added">612         &amp;&amp; !is&lt;WebGL2RenderingContext&gt;(canvasRenderingContext)</span>
613 #endif
614         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(canvasRenderingContext))
615         return;
616 
617     if (canvasRenderingContext.callTracingActive())
618         return;
619 
620     inspectorCanvas.resetRecordingData();
621     if (recordingOptions.frameCount)
622         inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
623     if (recordingOptions.memoryLimit)
624         inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
625     if (recordingOptions.name)
626         inspectorCanvas.setRecordingName(recordingOptions.name.value());
627     canvasRenderingContext.setCallTracingActive(true);
628 
629     m_frontendDispatcher-&gt;recordingStarted(inspectorCanvas.identifier(), initiator);
630 }
631 
632 void InspectorCanvasAgent::canvasDestroyedTimerFired()
633 {
634     if (!m_removedCanvasIdentifiers.size())
635         return;
636 
<span class="line-modified">637     for (auto&amp; identifier : m_removedCanvasIdentifiers)</span>
<span class="line-modified">638         m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>


639 
640     m_removedCanvasIdentifiers.clear();
641 }
642 










643 void InspectorCanvasAgent::clearCanvasData()
644 {
645     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())
646         inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);
647 
648     m_identifierToInspectorCanvas.clear();

649 #if ENABLE(WEBGL)
650     m_identifierToInspectorProgram.clear();
<span class="line-added">651     m_removedCanvasIdentifiers.clear();</span>
652 #endif
653 



654     if (m_canvasDestroyedTimer.isActive())
655         m_canvasDestroyedTimer.stop();
656 }
657 
<span class="line-added">658 InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(CanvasRenderingContext&amp; context, bool captureBacktrace)</span>
<span class="line-added">659 {</span>
<span class="line-added">660     auto inspectorCanvas = InspectorCanvas::create(context);</span>
<span class="line-added">661     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());</span>
<span class="line-added">662 </span>
<span class="line-added">663     inspectorCanvas-&gt;context().canvasBase().addObserver(*this);</span>
<span class="line-added">664 </span>
<span class="line-added">665     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
<span class="line-added">666 </span>
<span class="line-added">667 #if ENABLE(WEBGL)</span>
<span class="line-added">668     if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-added">669         WebGLRenderingContextBase&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
<span class="line-added">670         if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {</span>
<span class="line-added">671             for (const String&amp; extension : *extensions) {</span>
<span class="line-added">672                 if (contextWebGL.extensionIsEnabled(extension))</span>
<span class="line-added">673                     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);</span>
<span class="line-added">674             }</span>
<span class="line-added">675         }</span>
<span class="line-added">676     }</span>
<span class="line-added">677 #endif</span>
<span class="line-added">678 </span>
<span class="line-added">679     return inspectorCanvas;</span>
<span class="line-added">680 }</span>
<span class="line-added">681 </span>
682 String InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)
683 {
684 #if ENABLE(WEBGL)
685     Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
686     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
687         if (&amp;inspectorProgram-&gt;canvas() == &amp;inspectorCanvas)
688             programsToRemove.append(inspectorProgram.get());
689     }
690 
691     for (auto* inspectorProgram : programsToRemove)
692         unbindProgram(*inspectorProgram);
693 #endif
694 
<span class="line-added">695     inspectorCanvas.context().canvasBase().removeObserver(*this);</span>
<span class="line-added">696 </span>
697     String identifier = inspectorCanvas.identifier();
698     m_identifierToInspectorCanvas.remove(identifier);
699 
700     return identifier;
701 }
702 
<span class="line-modified">703 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; canvasId)</span>
704 {
<span class="line-modified">705     auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);</span>
706     if (!inspectorCanvas) {
<span class="line-modified">707         errorString = &quot;Missing canvas for given canvasId&quot;_s;</span>
708         return nullptr;
709     }
<span class="line-modified">710     return inspectorCanvas;</span>

711 }
712 
<span class="line-modified">713 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)</span>
714 {
715     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
716         if (&amp;inspectorCanvas-&gt;context() == &amp;context)
<span class="line-modified">717             return inspectorCanvas;</span>
718     }

719     return nullptr;
720 }
721 
722 #if ENABLE(WEBGL)
723 String InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)
724 {
725     String identifier = inspectorProgram.identifier();
726     m_identifierToInspectorProgram.remove(identifier);
727 
728     return identifier;
729 }
730 
<span class="line-modified">731 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; programId)</span>
732 {
<span class="line-modified">733     auto inspectorProgram = m_identifierToInspectorProgram.get(programId);</span>
734     if (!inspectorProgram) {
<span class="line-modified">735         errorString = &quot;Missing program for given programId&quot;_s;</span>
736         return nullptr;
737     }
<span class="line-modified">738     return inspectorProgram;</span>

739 }
740 
<span class="line-modified">741 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)</span>
742 {
743     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
744         if (&amp;inspectorProgram-&gt;program() == &amp;program)
<span class="line-modified">745             return inspectorProgram;</span>
746     }

747     return nullptr;
748 }
749 #endif
750 
751 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorCSSAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>