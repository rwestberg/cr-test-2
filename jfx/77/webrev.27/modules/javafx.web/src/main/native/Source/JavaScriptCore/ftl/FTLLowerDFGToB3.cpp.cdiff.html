<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLLink.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 44,10 ***</span>
<span class="line-new-header">--- 44,11 ---</span>
  #include &quot;DFGAbstractInterpreterInlines.h&quot;
  #include &quot;DFGCapabilities.h&quot;
  #include &quot;DFGDoesGC.h&quot;
  #include &quot;DFGDominators.h&quot;
  #include &quot;DFGInPlaceAbstractState.h&quot;
<span class="line-added">+ #include &quot;DFGLivenessAnalysisPhase.h&quot;</span>
  #include &quot;DFGMayExit.h&quot;
  #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  #include &quot;DFGOSRExitFuzz.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;FTLAbstractHeapRepository.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,10 ***</span>
<span class="line-new-header">--- 81,11 ---</span>
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSMap.h&quot;
  #include &quot;OperandsInlines.h&quot;
<span class="line-added">+ #include &quot;ProbeContext.h&quot;</span>
  #include &quot;RegExpObject.h&quot;
  #include &quot;ScopedArguments.h&quot;
  #include &quot;ScopedArgumentsTable.h&quot;
  #include &quot;ScratchRegisterAllocator.h&quot;
  #include &quot;SetupVarargsFrame.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,10 ***</span>
<span class="line-new-header">--- 155,33 ---</span>
          , m_availabilityCalculator(m_graph)
          , m_state(state.graph)
          , m_interpreter(state.graph, m_state)
          , m_indexMaskingMode(Options::enableSpectreMitigations() ?  IndexMaskingEnabled : IndexMaskingDisabled)
      {
<span class="line-added">+         if (Options::validateAbstractInterpreterState()) {</span>
<span class="line-added">+             performLivenessAnalysis(m_graph);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // We only use node liveness here, not combined liveness, as we only track</span>
<span class="line-added">+             // AI state for live nodes.</span>
<span class="line-added">+             for (DFG::BasicBlock* block : m_graph.blocksInNaturalOrder()) {</span>
<span class="line-added">+                 NodeSet live;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 for (NodeFlowProjection node : block-&gt;ssa-&gt;liveAtTail) {</span>
<span class="line-added">+                     if (node.kind() == NodeFlowProjection::Primary)</span>
<span class="line-added">+                         live.addVoid(node.node());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 for (unsigned i = block-&gt;size(); i--; ) {</span>
<span class="line-added">+                     Node* node = block-&gt;at(i);</span>
<span class="line-added">+                     live.remove(node);</span>
<span class="line-added">+                     m_graph.doToChildren(node, [&amp;] (Edge child) {</span>
<span class="line-added">+                         live.addVoid(child.node());</span>
<span class="line-added">+                     });</span>
<span class="line-added">+                     m_liveInToNode.add(node, live);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
      }
  
      void lower()
      {
          State* state = &amp;m_ftlState;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 472,10 ***</span>
<span class="line-new-header">--- 497,12 ---</span>
                  dataLog(&quot;Bailing because CFA didn&#39;t reach.\n&quot;);
              crash(m_highBlock, nullptr);
              return;
          }
  
<span class="line-added">+         m_aiCheckedNodes.clear();</span>
<span class="line-added">+ </span>
          m_availabilityCalculator.beginBlock(m_highBlock);
  
          m_state.reset();
          m_state.beginBasicBlock(m_highBlock);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 506,10 ***</span>
<span class="line-new-header">--- 533,137 ---</span>
                  target-&gt;cfaHasVisited = false;
              }
          }
      }
  
<span class="line-added">+     void validateAIState(Node* node)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!m_graphDump) {</span>
<span class="line-added">+             StringPrintStream out;</span>
<span class="line-added">+             m_graph.dump(out);</span>
<span class="line-added">+             m_graphDump = out.toString();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (node-&gt;op()) {</span>
<span class="line-added">+         case MovHint:</span>
<span class="line-added">+         case ZombieHint:</span>
<span class="line-added">+         case JSConstant:</span>
<span class="line-added">+         case LazyJSConstant:</span>
<span class="line-added">+         case DoubleConstant:</span>
<span class="line-added">+         case Int52Constant:</span>
<span class="line-added">+         case GetStack:</span>
<span class="line-added">+         case PutStack:</span>
<span class="line-added">+         case KillStack:</span>
<span class="line-added">+         case ExitOK:</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Before we execute node.</span>
<span class="line-added">+         NodeSet&amp; live = m_liveInToNode.find(node)-&gt;value;</span>
<span class="line-added">+         unsigned highParentIndex = node-&gt;index();</span>
<span class="line-added">+         {</span>
<span class="line-added">+             uint64_t hash = WTF::intHash(highParentIndex);</span>
<span class="line-added">+             if (hash &gt;= static_cast&lt;uint64_t&gt;((static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max()) + 1) * Options::validateAbstractInterpreterStateProbability()))</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (Node* node : live) {</span>
<span class="line-added">+             if (node-&gt;isPhantomAllocation())</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (node-&gt;op() == CheckInBounds)</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             AbstractValue value = m_interpreter.forNode(node);</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 auto iter = m_aiCheckedNodes.find(node);</span>
<span class="line-added">+                 if (iter != m_aiCheckedNodes.end()) {</span>
<span class="line-added">+                     AbstractValue checkedValue = iter-&gt;value;</span>
<span class="line-added">+                     if (checkedValue == value) {</span>
<span class="line-added">+                         if (!(value.m_type &amp; SpecCell))</span>
<span class="line-added">+                             continue;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 m_aiCheckedNodes.set(node, value);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             FlushFormat flushFormat;</span>
<span class="line-added">+             LValue input;</span>
<span class="line-added">+             if (node-&gt;hasJSResult()) {</span>
<span class="line-added">+                 input = lowJSValue(Edge(node, UntypedUse));</span>
<span class="line-added">+                 flushFormat = FlushedJSValue;</span>
<span class="line-added">+             } else if (node-&gt;hasDoubleResult()) {</span>
<span class="line-added">+                 input = lowDouble(Edge(node, DoubleRepUse));</span>
<span class="line-added">+                 flushFormat = FlushedDouble;</span>
<span class="line-added">+             } else if (node-&gt;hasInt52Result()) {</span>
<span class="line-added">+                 input = strictInt52ToJSValue(lowStrictInt52(Edge(node, Int52RepUse)));</span>
<span class="line-added">+                 flushFormat = FlushedInt52;</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             unsigned highChildIndex = node-&gt;index();</span>
<span class="line-added">+ </span>
<span class="line-added">+             String graphDump = m_graphDump;</span>
<span class="line-added">+ </span>
<span class="line-added">+             PatchpointValue* patchpoint = m_out.patchpoint(Void);</span>
<span class="line-added">+             patchpoint-&gt;effects = Effects::none();</span>
<span class="line-added">+             patchpoint-&gt;effects.writesLocalState = true;</span>
<span class="line-added">+             patchpoint-&gt;appendSomeRegister(input);</span>
<span class="line-added">+             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+                 GPRReg reg = InvalidGPRReg;</span>
<span class="line-added">+                 FPRReg fpReg = InvalidFPRReg;</span>
<span class="line-added">+                 if (flushFormat == FlushedDouble)</span>
<span class="line-added">+                     fpReg = params[0].fpr();</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     reg = params[0].gpr();</span>
<span class="line-added">+                 jit.probe([=] (Probe::Context&amp; context) {</span>
<span class="line-added">+                     JSValue input;</span>
<span class="line-added">+                     double doubleInput;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     auto dumpAndCrash = [&amp;] {</span>
<span class="line-added">+                         dataLogLn(&quot;Validation failed at node: @&quot;, highParentIndex);</span>
<span class="line-added">+                         dataLogLn(&quot;Failed validating live value: @&quot;, highChildIndex);</span>
<span class="line-added">+                         dataLogLn();</span>
<span class="line-added">+                         dataLogLn(&quot;Expected AI value = &quot;, value);</span>
<span class="line-added">+                         if (flushFormat != FlushedDouble)</span>
<span class="line-added">+                             dataLogLn(&quot;Unexpected value = &quot;, input);</span>
<span class="line-added">+                         else</span>
<span class="line-added">+                             dataLogLn(&quot;Unexpected double value = &quot;, doubleInput);</span>
<span class="line-added">+                         dataLogLn();</span>
<span class="line-added">+                         dataLogLn(graphDump);</span>
<span class="line-added">+                         CRASH();</span>
<span class="line-added">+                     };</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (flushFormat == FlushedDouble) {</span>
<span class="line-added">+                         doubleInput = context.fpr(fpReg);</span>
<span class="line-added">+                         SpeculatedType type;</span>
<span class="line-added">+                         if (!std::isnan(doubleInput))</span>
<span class="line-added">+                             type = speculationFromValue(jsDoubleNumber(doubleInput));</span>
<span class="line-added">+                         else if (isImpureNaN(doubleInput))</span>
<span class="line-added">+                             type = SpecDoubleImpureNaN;</span>
<span class="line-added">+                         else</span>
<span class="line-added">+                             type = SpecDoublePureNaN;</span>
<span class="line-added">+ </span>
<span class="line-added">+                         if (!value.couldBeType(type))</span>
<span class="line-added">+                             dumpAndCrash();</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         input = JSValue::decode(context.gpr(reg));</span>
<span class="line-added">+                         if (flushFormat == FlushedInt52) {</span>
<span class="line-added">+                             RELEASE_ASSERT(input.isAnyInt());</span>
<span class="line-added">+                             input = jsDoubleNumber(input.asAnyInt());</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         if (!value.validateOSREntryValue(input, flushFormat))</span>
<span class="line-added">+                             dumpAndCrash();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 });</span>
<span class="line-added">+             });</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      bool compileNode(unsigned nodeIndex)
      {
          if (!m_state.isValid()) {
              safelyInvalidateAfterTermination();
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,15 ***</span>
          m_out.setOrigin(m_node);
  
          if (verboseCompilationEnabled())
              dataLog(&quot;Lowering &quot;, m_node, &quot;\n&quot;);
  
<span class="line-removed">-         m_availableRecoveries.shrink(0);</span>
<span class="line-removed">- </span>
          m_interpreter.startExecuting();
          m_interpreter.executeKnownEdgeTypes(m_node);
  
          if (validateDFGDoesGC) {
              bool expectDoesGC = doesGC(m_graph, m_node);
              m_out.store(m_out.constBool(expectDoesGC), m_out.absolute(vm().heap.addressOfExpectDoesGC()));
          }
  
<span class="line-new-header">--- 674,16 ---</span>
          m_out.setOrigin(m_node);
  
          if (verboseCompilationEnabled())
              dataLog(&quot;Lowering &quot;, m_node, &quot;\n&quot;);
  
          m_interpreter.startExecuting();
          m_interpreter.executeKnownEdgeTypes(m_node);
  
<span class="line-added">+         if (Options::validateAbstractInterpreterState())</span>
<span class="line-added">+             validateAIState(m_node);</span>
<span class="line-added">+ </span>
          if (validateDFGDoesGC) {
              bool expectDoesGC = doesGC(m_graph, m_node);
              m_out.store(m_out.constBool(expectDoesGC), m_out.absolute(vm().heap.addressOfExpectDoesGC()));
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,20 ***</span>
<span class="line-new-header">--- 778,26 ---</span>
              compileValueDiv();
              break;
          case ArithDiv:
              compileArithDiv();
              break;
<span class="line-added">+         case ValueMod:</span>
<span class="line-added">+             compileValueMod();</span>
<span class="line-added">+             break;</span>
          case ArithMod:
              compileArithMod();
              break;
          case ArithMin:
          case ArithMax:
              compileArithMinOrMax();
              break;
          case ArithAbs:
              compileArithAbs();
              break;
<span class="line-added">+         case ValuePow:</span>
<span class="line-added">+             compileValuePow();</span>
<span class="line-added">+             break;</span>
          case ArithPow:
              compileArithPow();
              break;
          case ArithRandom:
              compileArithRandom();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 663,10 ***</span>
<span class="line-new-header">--- 824,13 ---</span>
              compileArithNegate();
              break;
          case ArithUnary:
              compileArithUnary();
              break;
<span class="line-added">+         case ValueBitNot:</span>
<span class="line-added">+             compileValueBitNot();</span>
<span class="line-added">+             break;</span>
          case ArithBitNot:
              compileArithBitNot();
              break;
          case ValueBitAnd:
              compileValueBitAnd();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,12 ***</span>
              compileValueBitXor();
              break;
          case BitRShift:
              compileBitRShift();
              break;
<span class="line-modified">!         case BitLShift:</span>
<span class="line-modified">!             compileBitLShift();</span>
              break;
          case BitURShift:
              compileBitURShift();
              break;
          case UInt32ToNumber:
<span class="line-new-header">--- 851,15 ---</span>
              compileValueBitXor();
              break;
          case BitRShift:
              compileBitRShift();
              break;
<span class="line-modified">!         case ArithBitLShift:</span>
<span class="line-modified">!             compileArithBitLShift();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case ValueBitLShift:</span>
<span class="line-added">+             compileValueBitLShift();</span>
              break;
          case BitURShift:
              compileBitURShift();
              break;
          case UInt32ToNumber:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1772,13 ***</span>
          case FlushedInt52:
              setInt52(m_out.load64(addressFor(data-&gt;machineLocal)));
              break;
          default:
              if (isInt32Speculation(value.m_type))
<span class="line-modified">!             setInt32(m_out.load32(payloadFor(data-&gt;machineLocal)));</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             setJSValue(m_out.load64(addressFor(data-&gt;machineLocal)));</span>
              break;
          }
      }
  
      void compilePutStack()
<span class="line-new-header">--- 1939,13 ---</span>
          case FlushedInt52:
              setInt52(m_out.load64(addressFor(data-&gt;machineLocal)));
              break;
          default:
              if (isInt32Speculation(value.m_type))
<span class="line-modified">!                 setInt32(m_out.load32(payloadFor(data-&gt;machineLocal)));</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!                 setJSValue(m_out.load64(addressFor(data-&gt;machineLocal)));</span>
              break;
          }
      }
  
      void compilePutStack()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1905,15 ***</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
          auto repatchingFunction = operationValueAddOptimize;
          auto nonRepatchingFunction = operationValueAdd;
<span class="line-modified">!         compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      void compileValueSub()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
<span class="line-new-header">--- 2072,15 ---</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationValueAddOptimize;
          auto nonRepatchingFunction = operationValueAdd;
<span class="line-modified">!         compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      void compileValueSub()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1924,15 ***</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
          auto repatchingFunction = operationValueSubOptimize;
          auto nonRepatchingFunction = operationValueSub;
<span class="line-modified">!         compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      void compileValueMul()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
<span class="line-new-header">--- 2091,15 ---</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationValueSubOptimize;
          auto nonRepatchingFunction = operationValueSub;
<span class="line-modified">!         compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      void compileValueMul()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1943,20 ***</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
          auto repatchingFunction = operationValueMulOptimize;
          auto nonRepatchingFunction = operationValueMul;
<span class="line-modified">!         compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileUnaryMathIC(ArithProfile* arithProfile, const Instruction* instruction, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue operand = lowJSValue(node-&gt;child1());
  
<span class="line-new-header">--- 2110,20 ---</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationValueMulOptimize;
          auto nonRepatchingFunction = operationValueMul;
<span class="line-modified">!         compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileUnaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue operand = lowJSValue(node-&gt;child1());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1978,11 ***</span>
  #if ENABLE(MATH_IC_STATS)
                  auto inlineStart = jit.label();
  #endif
  
                  Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified">!                 JITUnaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile, instruction);</span>
                  mathIC-&gt;m_generator = Generator(JSValueRegs(params[0].gpr()), JSValueRegs(params[1].gpr()), params.gpScratch(0));
  
                  bool shouldEmitProfiling = false;
                  bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
  
<span class="line-new-header">--- 2145,11 ---</span>
  #if ENABLE(MATH_IC_STATS)
                  auto inlineStart = jit.label();
  #endif
  
                  Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified">!                 JITUnaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);</span>
                  mathIC-&gt;m_generator = Generator(JSValueRegs(params[0].gpr()), JSValueRegs(params[1].gpr()), params.gpScratch(0));
  
                  bool shouldEmitProfiling = false;
                  bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2038,11 ***</span>
          setJSValue(patchpoint);
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileBinaryMathIC(ArithProfile* arithProfile, const Instruction* instruction, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
<span class="line-new-header">--- 2205,11 ---</span>
          setJSValue(patchpoint);
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileBinaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2072,11 ***</span>
  #if ENABLE(MATH_IC_STATS)
                  auto inlineStart = jit.label();
  #endif
  
                  Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified">!                 JITBinaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile, instruction);</span>
                  mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
                      JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.fpScratch(0),
                      params.fpScratch(1), params.gpScratch(0), InvalidFPRReg);
  
                  bool shouldEmitProfiling = false;
<span class="line-new-header">--- 2239,11 ---</span>
  #if ENABLE(MATH_IC_STATS)
                  auto inlineStart = jit.label();
  #endif
  
                  Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
<span class="line-modified">!                 JITBinaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);</span>
                  mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
                      JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.fpScratch(0),
                      params.fpScratch(1), params.gpScratch(0), InvalidFPRReg);
  
                  bool shouldEmitProfiling = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2171,12 ***</span>
              setInt32(result);
              break;
          }
  
          case Int52RepUse: {
<span class="line-modified">!             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecInt52Only)</span>
<span class="line-modified">!                 &amp;&amp; !abstractValue(m_node-&gt;child2()).couldBeType(SpecInt52Only)) {</span>
                  Int52Kind kind;
                  LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
                  LValue right = lowInt52(m_node-&gt;child2(), kind);
                  setInt52(isSub ? m_out.sub(left, right) : m_out.add(left, right), kind);
                  break;
<span class="line-new-header">--- 2338,12 ---</span>
              setInt32(result);
              break;
          }
  
          case Int52RepUse: {
<span class="line-modified">!             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified">!                 &amp;&amp; !abstractValue(m_node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
                  Int52Kind kind;
                  LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
                  LValue right = lowInt52(m_node-&gt;child2(), kind);
                  setInt52(isSub ? m_out.sub(left, right) : m_out.add(left, right), kind);
                  break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2204,15 ***</span>
                  DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
                  break;
              }
  
              CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!             ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!             const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
              auto repatchingFunction = operationValueSubOptimize;
              auto nonRepatchingFunction = operationValueSub;
<span class="line-modified">!             compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
              break;
          }
  
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
<span class="line-new-header">--- 2371,15 ---</span>
                  DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
                  break;
              }
  
              CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!             unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!             ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
              auto repatchingFunction = operationValueSubOptimize;
              auto nonRepatchingFunction = operationValueSub;
<span class="line-modified">!             compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
              break;
          }
  
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2382,10 ***</span>
<span class="line-new-header">--- 2549,28 ---</span>
              DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
              break;
          }
      }
  
<span class="line-added">+     void compileValueMod()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added">+             LValue left = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added">+             LValue right = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added">+ </span>
<span class="line-added">+             LValue result = vmCall(pointerType(), m_out.operation(operationModBigInt), m_callFrame, left, right);</span>
<span class="line-added">+             setJSValue(result);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         DFG_ASSERT(m_graph, m_node, m_node-&gt;binaryUseKind() == UntypedUse, m_node-&gt;binaryUseKind());</span>
<span class="line-added">+         LValue left = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added">+         LValue right = lowJSValue(m_node-&gt;child2());</span>
<span class="line-added">+         LValue result = vmCall(Int64, m_out.operation(operationValueMod), m_callFrame, left, right);</span>
<span class="line-added">+         setJSValue(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileArithMod()
      {
          switch (m_node-&gt;binaryUseKind()) {
          case Int32Use: {
              LValue numerator = lowInt32(m_node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2537,10 ***</span>
<span class="line-new-header">--- 2722,27 ---</span>
          LValue argument = lowJSValue(m_node-&gt;child1());
          LValue result = vmCall(Double, m_out.operation(DFG::arithUnaryOperation(m_node-&gt;arithUnaryType())), m_callFrame, argument);
          setDouble(result);
      }
  
<span class="line-added">+     void compileValuePow()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added">+             LValue base = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added">+             LValue exponent = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added">+ </span>
<span class="line-added">+             LValue result = vmCall(pointerType(), m_out.operation(operationPowBigInt), m_callFrame, base, exponent);</span>
<span class="line-added">+             setJSValue(result);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         LValue base = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added">+         LValue exponent = lowJSValue(m_node-&gt;child2());</span>
<span class="line-added">+         LValue result = vmCall(Int64, m_out.operation(operationValuePow), m_callFrame, base, exponent);</span>
<span class="line-added">+         setJSValue(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileArithPow()
      {
          if (m_node-&gt;child2().useKind() == Int32Use)
              setDouble(m_out.doublePowi(lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
          else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2836,15 ***</span>
  
      void compileValueNegate()
      {
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(m_node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(m_node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
          auto repatchingFunction = operationArithNegateOptimize;
          auto nonRepatchingFunction = operationArithNegate;
<span class="line-modified">!         compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, instruction, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      void compileArithNegate()
      {
          switch (m_node-&gt;child1().useKind()) {
<span class="line-new-header">--- 3038,15 ---</span>
  
      void compileValueNegate()
      {
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationArithNegateOptimize;
          auto nonRepatchingFunction = operationArithNegate;
<span class="line-modified">!         compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);</span>
      }
  
      void compileArithNegate()
      {
          switch (m_node-&gt;child1().useKind()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2866,11 ***</span>
              setInt32(result);
              break;
          }
  
          case Int52RepUse: {
<span class="line-modified">!             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecInt52Only)) {</span>
                  Int52Kind kind;
                  LValue value = lowWhicheverInt52(m_node-&gt;child1(), kind);
                  LValue result = m_out.neg(value);
                  if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
                      speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
<span class="line-new-header">--- 3068,11 ---</span>
              setInt32(result);
              break;
          }
  
          case Int52RepUse: {
<span class="line-modified">!             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {</span>
                  Int52Kind kind;
                  LValue value = lowWhicheverInt52(m_node-&gt;child1(), kind);
                  LValue result = m_out.neg(value);
                  if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
                      speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2896,19 ***</span>
              DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
              break;
          }
      }
  
<span class="line-modified">!     void compileArithBitNot()</span>
      {
<span class="line-modified">!         if (m_node-&gt;child1().useKind() == UntypedUse) {</span>
<span class="line-modified">!             LValue operand = lowJSValue(m_node-&gt;child1());</span>
<span class="line-modified">!             LValue result = vmCall(Int64, m_out.operation(operationValueBitNot), m_callFrame, operand);</span>
              setJSValue(result);
              return;
          }
  
          setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
      }
  
      void compileValueBitAnd()
      {
<span class="line-new-header">--- 3098,26 ---</span>
              DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
              break;
          }
      }
  
<span class="line-modified">!     void compileValueBitNot()</span>
      {
<span class="line-modified">!         if (m_node-&gt;child1().useKind() == BigIntUse) {</span>
<span class="line-modified">!             LValue operand = lowBigInt(m_node-&gt;child1());</span>
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationBitNotBigInt), m_callFrame, operand);</span>
              setJSValue(result);
              return;
          }
  
<span class="line-added">+         LValue operand = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added">+         LValue result = vmCall(Int64, m_out.operation(operationValueBitNot), m_callFrame, operand);</span>
<span class="line-added">+         setJSValue(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileArithBitNot()</span>
<span class="line-added">+     {</span>
          setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
      }
  
      void compileValueBitAnd()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2976,21 ***</span>
          setInt32(m_out.aShr(
              lowInt32(m_node-&gt;child1()),
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
<span class="line-modified">!     void compileBitLShift()</span>
      {
<span class="line-removed">-         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {</span>
<span class="line-removed">-             emitBinaryBitOpSnippet&lt;JITLeftShiftGenerator&gt;(operationValueBitLShift);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
          setInt32(m_out.shl(
              lowInt32(m_node-&gt;child1()),
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
      void compileBitURShift()
      {
          if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
              emitRightShiftSnippet(JITRightShiftGenerator::UnsignedShift);
              return;
<span class="line-new-header">--- 3185,32 ---</span>
          setInt32(m_out.aShr(
              lowInt32(m_node-&gt;child1()),
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
<span class="line-modified">!     void compileArithBitLShift()</span>
      {
          setInt32(m_out.shl(
              lowInt32(m_node-&gt;child1()),
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
<span class="line-added">+     void compileValueBitLShift()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added">+             LValue left = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added">+             LValue right = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added">+ </span>
<span class="line-added">+             LValue result = vmCall(pointerType(), m_out.operation(operationBitLShiftBigInt), m_callFrame, left, right);</span>
<span class="line-added">+             setJSValue(result);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));</span>
<span class="line-added">+         emitBinaryBitOpSnippet&lt;JITLeftShiftGenerator&gt;(operationValueBitLShift);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileBitURShift()
      {
          if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
              emitRightShiftSnippet(JITRightShiftGenerator::UnsignedShift);
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3675,11 ***</span>
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, isTypedView(m_node-&gt;arrayMode().typedArrayType()), m_node-&gt;arrayMode().typedArrayType());
          LValue vector = m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector);
<span class="line-modified">!         setStorage(caged(Gigacage::Primitive, vector));</span>
      }
  
      void compileCheckArray()
      {
          Edge edge = m_node-&gt;child1();
<span class="line-new-header">--- 3895,11 ---</span>
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, isTypedView(m_node-&gt;arrayMode().typedArrayType()), m_node-&gt;arrayMode().typedArrayType());
          LValue vector = m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector);
<span class="line-modified">!         setStorage(caged(Gigacage::Primitive, vector, cell));</span>
      }
  
      void compileCheckArray()
      {
          Edge edge = m_node-&gt;child1();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3719,18 ***</span>
          ValueFromBlock nullVectorOut = m_out.anchor(vector);
          m_out.branch(vector, unsure(notNull), unsure(continuation));
  
          m_out.appendTo(notNull, continuation);
  
<span class="line-modified">!         LValue butterflyPtr = caged(Gigacage::JSValue, m_out.loadPtr(basePtr, m_heaps.JSObject_butterfly));</span>
          LValue arrayBufferPtr = m_out.loadPtr(butterflyPtr, m_heaps.Butterfly_arrayBuffer);
  
<span class="line-modified">!         LValue vectorPtr = caged(Gigacage::Primitive, vector);</span>
  
          // FIXME: This needs caging.
          // https://bugs.webkit.org/show_bug.cgi?id=175515
          LValue dataPtr = m_out.loadPtr(arrayBufferPtr, m_heaps.ArrayBuffer_data);
  
          ValueFromBlock wastefulOut = m_out.anchor(m_out.sub(vectorPtr, dataPtr));
  
          m_out.jump(continuation);
          m_out.appendTo(continuation, lastNext);
<span class="line-new-header">--- 3939,19 ---</span>
          ValueFromBlock nullVectorOut = m_out.anchor(vector);
          m_out.branch(vector, unsure(notNull), unsure(continuation));
  
          m_out.appendTo(notNull, continuation);
  
<span class="line-modified">!         LValue butterflyPtr = caged(Gigacage::JSValue, m_out.loadPtr(basePtr, m_heaps.JSObject_butterfly), basePtr);</span>
          LValue arrayBufferPtr = m_out.loadPtr(butterflyPtr, m_heaps.Butterfly_arrayBuffer);
  
<span class="line-modified">!         LValue vectorPtr = caged(Gigacage::Primitive, vector, basePtr);</span>
  
          // FIXME: This needs caging.
          // https://bugs.webkit.org/show_bug.cgi?id=175515
          LValue dataPtr = m_out.loadPtr(arrayBufferPtr, m_heaps.ArrayBuffer_data);
<span class="line-added">+         dataPtr = removeArrayPtrTag(dataPtr);</span>
  
          ValueFromBlock wastefulOut = m_out.anchor(m_out.sub(vectorPtr, dataPtr));
  
          m_out.jump(continuation);
          m_out.appendTo(continuation, lastNext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4238,11 ***</span>
          }
      }
  
      void compileGetMyArgumentByVal()
      {
<span class="line-modified">!         InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
  
          LValue originalIndex = lowInt32(m_node-&gt;child2());
  
          LValue numberOfArgsIncludingThis;
          if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
<span class="line-new-header">--- 4459,11 ---</span>
          }
      }
  
      void compileGetMyArgumentByVal()
      {
<span class="line-modified">!         InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
  
          LValue originalIndex = lowInt32(m_node-&gt;child2());
  
          LValue numberOfArgsIncludingThis;
          if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4403,11 ***</span>
                      m_out.store64(value, elementPointer);
                      break;
                  }
  
                  contiguousPutByValOutOfBounds(
<span class="line-modified">!                     codeBlock()-&gt;isStrictMode()</span>
                          ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
                          : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
                      base, storage, index, value, continuation);
  
                  m_out.store64(value, elementPointer);
<span class="line-new-header">--- 4624,11 ---</span>
                      m_out.store64(value, elementPointer);
                      break;
                  }
  
                  contiguousPutByValOutOfBounds(
<span class="line-modified">!                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)</span>
                          ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
                          : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
                      base, storage, index, value, continuation);
  
                  m_out.store64(value, elementPointer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4429,11 ***</span>
                      m_out.storeDouble(value, elementPointer);
                      break;
                  }
  
                  contiguousPutByValOutOfBounds(
<span class="line-modified">!                     codeBlock()-&gt;isStrictMode()</span>
                          ? (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
                          : (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
                      base, storage, index, value, continuation);
  
                  m_out.storeDouble(value, elementPointer);
<span class="line-new-header">--- 4650,11 ---</span>
                      m_out.storeDouble(value, elementPointer);
                      break;
                  }
  
                  contiguousPutByValOutOfBounds(
<span class="line-modified">!                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)</span>
                          ? (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
                          : (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
                      base, storage, index, value, continuation);
  
                  m_out.storeDouble(value, elementPointer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4469,11 ***</span>
              }
  
              LValue isOutOfBounds = m_out.aboveOrEqual(
                  index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength));
  
<span class="line-modified">!             auto slowPathFunction = codeBlock()-&gt;isStrictMode()</span>
                  ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
                  : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict);
              if (!arrayMode.isOutOfBounds()) {
                  speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
                  isOutOfBounds = m_out.booleanFalse;
<span class="line-new-header">--- 4690,11 ---</span>
              }
  
              LValue isOutOfBounds = m_out.aboveOrEqual(
                  index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength));
  
<span class="line-modified">!             auto slowPathFunction = m_graph.isStrictModeFor(m_node-&gt;origin.semantic)</span>
                  ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
                  : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict);
              if (!arrayMode.isOutOfBounds()) {
                  speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
                  isOutOfBounds = m_out.booleanFalse;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4672,18 ***</span>
              if (elementCount == 1) {
                  LValue value;
                  Output::StoreType storeType;
  
                  Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
                  if (m_node-&gt;arrayMode().type() != Array::Double) {
                      value = lowJSValue(element, ManualOperandSpeculation);
<span class="line-removed">-                     if (m_node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed">-                         DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecInt32Only));</span>
                      storeType = Output::Store64;
                  } else {
                      value = lowDouble(element);
<span class="line-removed">-                     DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecDoubleReal));</span>
                      storeType = Output::StoreDouble;
                  }
  
                  LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
  
<span class="line-new-header">--- 4893,16 ---</span>
              if (elementCount == 1) {
                  LValue value;
                  Output::StoreType storeType;
  
                  Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
<span class="line-added">+                 speculate(element);</span>
                  if (m_node-&gt;arrayMode().type() != Array::Double) {
                      value = lowJSValue(element, ManualOperandSpeculation);
                      storeType = Output::Store64;
                  } else {
                      value = lowDouble(element);
                      storeType = Output::StoreDouble;
                  }
  
                  LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4718,10 ***</span>
<span class="line-new-header">--- 4937,15 ---</span>
                  m_out.appendTo(continuation, lastNext);
                  setJSValue(m_out.phi(Int64, fastResult, slowResult));
                  return;
              }
  
<span class="line-added">+             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added">+                 Edge element = m_graph.varArgChild(m_node, elementIndex + elementOffset);</span>
<span class="line-added">+                 speculate(element);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
              LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
  
              LBasicBlock fastPath = m_out.newBlock();
              LBasicBlock slowPath = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4754,16 ***</span>
  
                  LValue value;
                  Output::StoreType storeType;
                  if (m_node-&gt;arrayMode().type() != Array::Double) {
                      value = lowJSValue(element, ManualOperandSpeculation);
<span class="line-removed">-                     if (m_node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed">-                         DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecInt32Only));</span>
                      storeType = Output::Store64;
                  } else {
                      value = lowDouble(element);
<span class="line-removed">-                     DFG_ASSERT(m_graph, m_node, !m_interpreter.needsTypeCheck(element, SpecDoubleReal));</span>
                      storeType = Output::StoreDouble;
                  }
  
                  m_out.store(value, m_out.baseIndex(heap, buffer, m_out.constInt32(elementIndex), jsNumber(elementIndex)), storeType);
              }
<span class="line-new-header">--- 4978,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5236,11 ***</span>
          LValue scope = lowCell(m_node-&gt;child1());
          SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
          RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
          JSValue initializationValue = m_node-&gt;initializationValueForActivation();
          ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
<span class="line-modified">!         if (table-&gt;singletonScope()-&gt;isStillValid()) {</span>
              LValue callResult = vmCall(
                  Int64,
                  m_out.operation(operationCreateActivationDirect), m_callFrame, weakStructure(structure),
                  scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
              setJSValue(callResult);
<span class="line-new-header">--- 5457,11 ---</span>
          LValue scope = lowCell(m_node-&gt;child1());
          SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
          RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
          JSValue initializationValue = m_node-&gt;initializationValueForActivation();
          ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
<span class="line-modified">!         if (table-&gt;singleton().isStillValid()) {</span>
              LValue callResult = vmCall(
                  Int64,
                  m_out.operation(operationCreateActivationDirect), m_callFrame, weakStructure(structure),
                  scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
              setJSValue(callResult);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5297,11 ***</span>
          bool isAsyncGeneratorFunction =  m_node-&gt;op() == NewAsyncGeneratorFunction;
  
          LValue scope = lowCell(m_node-&gt;child1());
  
          FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
<span class="line-modified">!         if (executable-&gt;singletonFunction()-&gt;isStillValid()) {</span>
              LValue callResult =
                  isGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
                  isAsyncFunction ? vmCall(Int64, m_out.operation(operationNewAsyncFunction), m_callFrame, scope, weakPointer(executable)) :
                  isAsyncGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewAsyncGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
                  vmCall(Int64, m_out.operation(operationNewFunction), m_callFrame, scope, weakPointer(executable));
<span class="line-new-header">--- 5518,11 ---</span>
          bool isAsyncGeneratorFunction =  m_node-&gt;op() == NewAsyncGeneratorFunction;
  
          LValue scope = lowCell(m_node-&gt;child1());
  
          FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
<span class="line-modified">!         if (executable-&gt;singleton().isStillValid()) {</span>
              LValue callResult =
                  isGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
                  isAsyncFunction ? vmCall(Int64, m_out.operation(operationNewAsyncFunction), m_callFrame, scope, weakPointer(executable)) :
                  isAsyncGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewAsyncGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
                  vmCall(Int64, m_out.operation(operationNewFunction), m_callFrame, scope, weakPointer(executable));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5342,20 ***</span>
          // must be young.
          m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
          m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executable);
          m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.JSFunction_rareData);
  
<span class="line-modified">!         mutatorFence();</span>
  
          ValueFromBlock fastResult = m_out.anchor(fastObject);
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
  
          Vector&lt;LValue&gt; slowPathArguments;
          slowPathArguments.append(scope);
<span class="line-removed">-         VM&amp; vm = this-&gt;vm();</span>
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
                  if (isGeneratorFunction)
                      operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
<span class="line-new-header">--- 5563,36 ---</span>
          // must be young.
          m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
          m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executable);
          m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.JSFunction_rareData);
  
<span class="line-modified">!         VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">+         if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="line-added">+             mutatorFence();</span>
<span class="line-added">+             Allocator allocator = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-added">+             LValue rareData = allocateCell(m_out.constIntPtr(allocator.localAllocator()), vm.functionRareDataStructure.get(), slowPath);</span>
<span class="line-added">+             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocator);</span>
<span class="line-added">+             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_structure);</span>
<span class="line-added">+             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_prototype);</span>
<span class="line-added">+             m_out.storePtr(m_out.intPtrOne, rareData, m_heaps.FunctionRareData_objectAllocationProfileWatchpoint);</span>
<span class="line-added">+             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);</span>
<span class="line-added">+             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_boundFunctionStructure);</span>
<span class="line-added">+             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocationProfileClearingWatchpoint);</span>
<span class="line-added">+             m_out.store32As8(m_out.int32One, rareData, m_heaps.FunctionRareData_hasReifiedName);</span>
<span class="line-added">+             m_out.store32As8(m_out.int32Zero, rareData, m_heaps.FunctionRareData_hasReifiedLength);</span>
<span class="line-added">+             mutatorFence();</span>
<span class="line-added">+             m_out.storePtr(rareData, fastObject, m_heaps.JSFunction_rareData);</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             mutatorFence();</span>
  
          ValueFromBlock fastResult = m_out.anchor(fastObject);
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
  
          Vector&lt;LValue&gt; slowPathArguments;
          slowPathArguments.append(scope);
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
                  if (isGeneratorFunction)
                      operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5818,11 ***</span>
                  if (bitVector-&gt;get(i)) {
                      Edge use = m_graph.varArgChild(m_node, i);
                      CheckValue* lengthCheck = nullptr;
                      if (use-&gt;op() == PhantomSpread) {
                          if (use-&gt;child1()-&gt;op() == PhantomCreateRest) {
<span class="line-modified">!                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
                              unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
                              LValue spreadLength = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
                                  return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
                              }).iterator-&gt;value;
                              lengthCheck = m_out.speculateAdd(length, spreadLength);
<span class="line-new-header">--- 6055,11 ---</span>
                  if (bitVector-&gt;get(i)) {
                      Edge use = m_graph.varArgChild(m_node, i);
                      CheckValue* lengthCheck = nullptr;
                      if (use-&gt;op() == PhantomSpread) {
                          if (use-&gt;child1()-&gt;op() == PhantomCreateRest) {
<span class="line-modified">!                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
                              unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
                              LValue spreadLength = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
                                  return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
                              }).iterator-&gt;value;
                              lengthCheck = m_out.speculateAdd(length, spreadLength);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5862,11 ***</span>
                                  m_out.store64(m_out.constInt64(value), m_out.baseIndex(heap, storage, index, JSValue(), (Checked&lt;int32_t&gt;(sizeof(JSValue)) * i).unsafeGet()));
                              }
                              index = m_out.add(index, m_out.constIntPtr(array-&gt;length()));
                          } else {
                              RELEASE_ASSERT(use-&gt;child1()-&gt;op() == PhantomCreateRest);
<span class="line-modified">!                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
                              unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
  
                              LValue length = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
                              LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
  
<span class="line-new-header">--- 6099,11 ---</span>
                                  m_out.store64(m_out.constInt64(value), m_out.baseIndex(heap, storage, index, JSValue(), (Checked&lt;int32_t&gt;(sizeof(JSValue)) * i).unsafeGet()));
                              }
                              index = m_out.add(index, m_out.constIntPtr(array-&gt;length()));
                          } else {
                              RELEASE_ASSERT(use-&gt;child1()-&gt;op() == PhantomCreateRest);
<span class="line-modified">!                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
                              unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
  
                              LValue length = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
                              LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6054,11 ***</span>
              LBasicBlock loopBody = m_out.newBlock();
              LBasicBlock slowAllocation = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
              LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopHeader);
  
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
              unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
              LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
              LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
              static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
              LValue size = m_out.add(
<span class="line-new-header">--- 6291,11 ---</span>
              LBasicBlock loopBody = m_out.newBlock();
              LBasicBlock slowAllocation = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
              LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopHeader);
  
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
              unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
              LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
              LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
              static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
              LValue size = m_out.add(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6280,10 ***</span>
<span class="line-new-header">--- 6517,24 ---</span>
                  m_out.int32Zero,
                  m_out.castToInt32(m_out.lShr(byteSize, m_out.constIntPtr(3))),
                  m_out.int64Zero,
                  m_heaps.typedArrayProperties);
  
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 LValue sizePtr = m_out.zeroExtPtr(size);</span>
<span class="line-added">+                 PatchpointValue* authenticate = m_out.patchpoint(pointerType());</span>
<span class="line-added">+                 authenticate-&gt;appendSomeRegister(storage);</span>
<span class="line-added">+                 authenticate-&gt;append(sizePtr, B3::ValueRep(B3::ValueRep::SomeLateRegister));</span>
<span class="line-added">+                 authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+                     jit.move(params[1].gpr(), params[0].gpr());</span>
<span class="line-added">+                     jit.tagArrayPtr(params[2].gpr(), params[0].gpr());</span>
<span class="line-added">+                 });</span>
<span class="line-added">+                 storage = authenticate;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
              ValueFromBlock haveStorage = m_out.anchor(storage);
  
              LValue fastResultValue =
                  allocateObject&lt;JSArrayBufferView&gt;(structure, m_out.intPtrZero, slowCase);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6539,30 ***</span>
          } else {
              kids[2] = 0;
              numKids = 2;
          }
  
          LBasicBlock slowPath = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
  
          LValue result = allocateCell(
              m_out.constIntPtr(allocator.localAllocator()), vm().stringStructure.get(), slowPath);
  
<span class="line-modified">!         m_out.storePtr(m_out.bitOr(kids[0], m_out.constIntPtr(JSString::isRopeInPointer)), result, m_heaps.JSRopeString_fiber0);</span>
<span class="line-modified">! </span>
<span class="line-removed">-         m_out.store32(m_out.castToInt32(kids[1]), result, m_heaps.JSRopeString_fiber1Lower);</span>
<span class="line-removed">-         m_out.store32As16(m_out.castToInt32(m_out.lShr(kids[1], m_out.constInt32(32))), result, m_heaps.JSRopeString_fiber1Upper);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (numKids == 3) {</span>
<span class="line-removed">-             m_out.store32(m_out.castToInt32(kids[2]), result, m_heaps.JSRopeString_fiber2Lower);</span>
<span class="line-removed">-             m_out.store32As16(m_out.castToInt32(m_out.lShr(kids[2], m_out.constInt32(32))), result, m_heaps.JSRopeString_fiber2Upper);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             m_out.store32(m_out.int32Zero, result, m_heaps.JSRopeString_fiber2Lower);</span>
<span class="line-removed">-             m_out.store32As16(m_out.int32Zero, result, m_heaps.JSRopeString_fiber2Upper);</span>
<span class="line-removed">-         }</span>
  
          auto getFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child) {
              if (JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
                  return FlagsAndLength {
                      m_out.constInt32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0),
<span class="line-new-header">--- 6790,21 ---</span>
          } else {
              kids[2] = 0;
              numKids = 2;
          }
  
<span class="line-added">+         LBasicBlock emptyCase = m_out.newBlock();</span>
          LBasicBlock slowPath = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
  
          LValue result = allocateCell(
              m_out.constIntPtr(allocator.localAllocator()), vm().stringStructure.get(), slowPath);
  
<span class="line-modified">!         // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.</span>
<span class="line-modified">!         m_out.storePtr(m_out.constIntPtr(JSString::isRopeInPointer), result, m_heaps.JSRopeString_fiber0);</span>
  
          auto getFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child) {
              if (JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
                  return FlagsAndLength {
                      m_out.constInt32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6575,11 ***</span>
              LBasicBlock notRopeCase = m_out.newBlock();
  
              m_out.branch(isRopeString(child, edge), unsure(ropeCase), unsure(notRopeCase));
  
              LBasicBlock lastNext = m_out.appendTo(ropeCase, notRopeCase);
<span class="line-modified">!             ValueFromBlock flagsForRope = m_out.anchor(m_out.load16ZeroExt32(child, m_heaps.JSRopeString_flags));</span>
              ValueFromBlock lengthForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_length));
              m_out.jump(continuation);
  
              m_out.appendTo(notRopeCase, continuation);
              LValue stringImpl = m_out.loadPtr(child, m_heaps.JSString_value);
<span class="line-new-header">--- 6817,11 ---</span>
              LBasicBlock notRopeCase = m_out.newBlock();
  
              m_out.branch(isRopeString(child, edge), unsure(ropeCase), unsure(notRopeCase));
  
              LBasicBlock lastNext = m_out.appendTo(ropeCase, notRopeCase);
<span class="line-modified">!             ValueFromBlock flagsForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_flags));</span>
              ValueFromBlock lengthForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_length));
              m_out.jump(continuation);
  
              m_out.appendTo(notRopeCase, continuation);
              LValue stringImpl = m_out.loadPtr(child, m_heaps.JSString_value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6598,26 ***</span>
          for (unsigned i = 1; i &lt; numKids; ++i) {
              auto mergeFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child, FlagsAndLength previousFlagsAndLength) {
                  FlagsAndLength flagsAndLength = getFlagsAndLength(edge, child);
                  LValue flags = m_out.bitAnd(previousFlagsAndLength.flags, flagsAndLength.flags);
                  CheckValue* lengthCheck = m_out.speculateAdd(previousFlagsAndLength.length, flagsAndLength.length);
<span class="line-modified">!             blessSpeculation(lengthCheck, Uncountable, noValue(), nullptr, m_origin);</span>
                  return FlagsAndLength {
                      flags,
                      lengthCheck
                  };
              };
              flagsAndLength = mergeFlagsAndLength(edges[i], kids[i], flagsAndLength);
          }
<span class="line-modified">!         m_out.store32As16(flagsAndLength.flags, result, m_heaps.JSRopeString_flags);</span>
<span class="line-modified">!         m_out.store32(flagsAndLength.length, result, m_heaps.JSRopeString_length);</span>
  
          mutatorFence();
<span class="line-modified">!         ValueFromBlock fastResult = m_out.anchor(m_out.select(m_out.isZero32(flagsAndLength.length), weakPointer(jsEmptyString(&amp;m_graph.m_vm)), result));</span>
          m_out.jump(continuation);
  
<span class="line-modified">!         LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);</span>
          LValue slowResultValue;
          VM&amp; vm = this-&gt;vm();
          switch (numKids) {
          case 2:
              slowResultValue = lazySlowPath(
<span class="line-new-header">--- 6840,41 ---</span>
          for (unsigned i = 1; i &lt; numKids; ++i) {
              auto mergeFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child, FlagsAndLength previousFlagsAndLength) {
                  FlagsAndLength flagsAndLength = getFlagsAndLength(edge, child);
                  LValue flags = m_out.bitAnd(previousFlagsAndLength.flags, flagsAndLength.flags);
                  CheckValue* lengthCheck = m_out.speculateAdd(previousFlagsAndLength.length, flagsAndLength.length);
<span class="line-modified">!                 blessSpeculation(lengthCheck, Uncountable, noValue(), nullptr, m_origin);</span>
                  return FlagsAndLength {
                      flags,
                      lengthCheck
                  };
              };
              flagsAndLength = mergeFlagsAndLength(edges[i], kids[i], flagsAndLength);
          }
<span class="line-modified">! </span>
<span class="line-modified">!         m_out.storePtr(</span>
<span class="line-added">+             m_out.bitOr(</span>
<span class="line-added">+                 m_out.bitOr(kids[0], m_out.constIntPtr(JSString::isRopeInPointer)),</span>
<span class="line-added">+                 m_out.bitAnd(m_out.constIntPtr(JSRopeString::is8BitInPointer), m_out.zeroExtPtr(flagsAndLength.flags))),</span>
<span class="line-added">+             result, m_heaps.JSRopeString_fiber0);</span>
<span class="line-added">+         m_out.storePtr(</span>
<span class="line-added">+             m_out.bitOr(m_out.zeroExtPtr(flagsAndLength.length), m_out.shl(kids[1], m_out.constInt32(32))),</span>
<span class="line-added">+             result, m_heaps.JSRopeString_fiber1);</span>
<span class="line-added">+         if (numKids == 2)</span>
<span class="line-added">+             m_out.storePtr(m_out.lShr(kids[1], m_out.constInt32(32)), result, m_heaps.JSRopeString_fiber2);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             m_out.storePtr(m_out.bitOr(m_out.lShr(kids[1], m_out.constInt32(32)), m_out.shl(kids[2], m_out.constInt32(16))), result, m_heaps.JSRopeString_fiber2);</span>
  
          mutatorFence();
<span class="line-modified">!         ValueFromBlock fastResult = m_out.anchor(result);</span>
<span class="line-added">+         m_out.branch(m_out.isZero32(flagsAndLength.length), rarely(emptyCase), usually(continuation));</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.appendTo(emptyCase, slowPath);</span>
<span class="line-added">+         ValueFromBlock emptyResult = m_out.anchor(weakPointer(jsEmptyString(m_graph.m_vm)));</span>
          m_out.jump(continuation);
  
<span class="line-modified">!         m_out.appendTo(slowPath, continuation);</span>
          LValue slowResultValue;
          VM&amp; vm = this-&gt;vm();
          switch (numKids) {
          case 2:
              slowResultValue = lazySlowPath(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6641,11 ***</span>
          }
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
<span class="line-modified">!         setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
      }
  
      void compileStringCharAt()
      {
          LValue base = lowString(m_graph.child(m_node, 0));
<span class="line-new-header">--- 6898,11 ---</span>
          }
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
<span class="line-modified">!         setJSValue(m_out.phi(Int64, fastResult, emptyResult, slowResult));</span>
      }
  
      void compileStringCharAt()
      {
          LValue base = lowString(m_graph.child(m_node, 0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6719,24 ***</span>
          if (m_node-&gt;arrayMode().isInBounds()) {
              speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
              results.append(m_out.anchor(m_out.intPtrZero));
          } else {
              JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
  
<span class="line-removed">-             bool prototypeChainIsSane = false;</span>
              if (globalObject-&gt;stringPrototypeChainIsSane()) {
                  // FIXME: This could be captured using a Speculation mode that means
                  // &quot;out-of-bounds loads return a trivial value&quot;, something like
                  // SaneChainOutOfBounds.
                  // https://bugs.webkit.org/show_bug.cgi?id=144668
  
<span class="line-modified">!                 m_graph.registerAndWatchStructureTransition(globalObject-&gt;stringPrototype()-&gt;structure(vm()));</span>
<span class="line-modified">!                 m_graph.registerAndWatchStructureTransition(globalObject-&gt;objectPrototype()-&gt;structure(vm()));</span>
  
<span class="line-removed">-                 prototypeChainIsSane = globalObject-&gt;stringPrototypeChainIsSane();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (prototypeChainIsSane) {</span>
                  LBasicBlock negativeIndex = m_out.newBlock();
  
                  results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
                  m_out.branch(
                      m_out.lessThan(index, m_out.int32Zero),
<span class="line-new-header">--- 6976,23 ---</span>
          if (m_node-&gt;arrayMode().isInBounds()) {
              speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
              results.append(m_out.anchor(m_out.intPtrZero));
          } else {
              JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<span class="line-added">+             Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm());</span>
<span class="line-added">+             Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());</span>
<span class="line-added">+             WTF::loadLoadFence();</span>
  
              if (globalObject-&gt;stringPrototypeChainIsSane()) {
                  // FIXME: This could be captured using a Speculation mode that means
                  // &quot;out-of-bounds loads return a trivial value&quot;, something like
                  // SaneChainOutOfBounds.
                  // https://bugs.webkit.org/show_bug.cgi?id=144668
  
<span class="line-modified">!                 m_graph.registerAndWatchStructureTransition(stringPrototypeStructure);</span>
<span class="line-modified">!                 m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);</span>
  
                  LBasicBlock negativeIndex = m_out.newBlock();
  
                  results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
                  m_out.branch(
                      m_out.lessThan(index, m_out.int32Zero),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6820,11 ***</span>
          LBasicBlock smallIntCase = m_out.newBlock();
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          m_out.branch(
<span class="line-modified">!             m_out.aboveOrEqual(value, m_out.constInt32(maxSingleCharacterString)),</span>
              rarely(slowCase), usually(smallIntCase));
  
          LBasicBlock lastNext = m_out.appendTo(smallIntCase, slowCase);
  
          LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
<span class="line-new-header">--- 7076,11 ---</span>
          LBasicBlock smallIntCase = m_out.newBlock();
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          m_out.branch(
<span class="line-modified">!             m_out.above(value, m_out.constInt32(maxSingleCharacterString)),</span>
              rarely(slowCase), usually(smallIntCase));
  
          LBasicBlock lastNext = m_out.appendTo(smallIntCase, slowCase);
  
          LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7631,11 ***</span>
  
          patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          VM* vm = &amp;this-&gt;vm();
          patchpoint-&gt;setGenerator(
<span class="line-new-header">--- 7887,11 ---</span>
  
          patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          VM* vm = &amp;this-&gt;vm();
          patchpoint-&gt;setGenerator(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7750,11 ***</span>
          }
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          if (!isTail) {
              patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!             patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
          }
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
<span class="line-new-header">--- 8006,11 ---</span>
          }
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          if (!isTail) {
              patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!             patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
          }
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8044,11 ***</span>
                  staticArgumentCount += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
                  return;
              }
  
              RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
              unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
              LValue length = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
                  return m_out.zeroExtPtr(this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));
              }).iterator-&gt;value;
              patchpointArguments.append(length);
<span class="line-new-header">--- 8300,11 ---</span>
                  staticArgumentCount += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
                  return;
              }
  
              RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
              unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
              LValue length = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
                  return m_out.zeroExtPtr(this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));
              }).iterator-&gt;value;
              patchpointArguments.append(length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8071,11 ***</span>
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
  
          patchpoint-&gt;numGPScratchRegisters = 0;
  
          // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
          unsigned minimumJSCallAreaSize =
<span class="line-new-header">--- 8327,11 ---</span>
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
  
          patchpoint-&gt;numGPScratchRegisters = 0;
  
          // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
          unsigned minimumJSCallAreaSize =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8207,11 ***</span>
                              jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(array-&gt;length())), scratchGPR2);
                              return;
                          }
  
                          RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!                         InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
  
                          unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
  
                          B3::ValueRep numArgumentsToCopy = params[paramsOffset + (index++)];
                          getValueFromRep(numArgumentsToCopy, scratchGPR3);
<span class="line-new-header">--- 8463,11 ---</span>
                              jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(array-&gt;length())), scratchGPR2);
                              return;
                          }
  
                          RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!                         InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
  
                          unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
  
                          B3::ValueRep numArgumentsToCopy = params[paramsOffset + (index++)];
                          getValueFromRep(numArgumentsToCopy, scratchGPR3);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8373,11 ***</span>
          patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
  
          // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
          unsigned minimumJSCallAreaSize =
              sizeof(CallerFrameAndPC) +
              WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
<span class="line-new-header">--- 8629,11 ---</span>
          patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
  
          // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
          unsigned minimumJSCallAreaSize =
              sizeof(CallerFrameAndPC) +
              WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8487,13 ***</span>
                      jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
  
                      CCallHelpers::JumpList slowCase;
                      InlineCallFrame* inlineCallFrame;
                      if (node-&gt;child3())
<span class="line-modified">!                         inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame;</span>
                      else
<span class="line-modified">!                         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;</span>
  
                      // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
                      emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
  
                      CCallHelpers::Jump done = jit.jump();
<span class="line-new-header">--- 8743,13 ---</span>
                      jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
  
                      CCallHelpers::JumpList slowCase;
                      InlineCallFrame* inlineCallFrame;
                      if (node-&gt;child3())
<span class="line-modified">!                         inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();</span>
                      else
<span class="line-modified">!                         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
  
                      // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
                      emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
  
                      CCallHelpers::Jump done = jit.jump();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8630,11 ***</span>
  
          patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);</span>
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          VM&amp; vm = this-&gt;vm();
          patchpoint-&gt;setGenerator(
<span class="line-new-header">--- 8886,11 ---</span>
  
          patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };</span>
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          VM&amp; vm = this-&gt;vm();
          patchpoint-&gt;setGenerator(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8733,13 ***</span>
          }
  
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
          InlineCallFrame* inlineCallFrame;
          if (m_node-&gt;child1())
<span class="line-modified">!             inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
          else
<span class="line-modified">!             inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame;</span>
  
          LValue length = nullptr;
          LValue lengthIncludingThis = nullptr;
          ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
          if (argumentsLength.isKnown) {
<span class="line-new-header">--- 8989,13 ---</span>
          }
  
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
          InlineCallFrame* inlineCallFrame;
          if (m_node-&gt;child1())
<span class="line-modified">!             inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
          else
<span class="line-modified">!             inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();</span>
  
          LValue length = nullptr;
          LValue lengthIncludingThis = nullptr;
          ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
          if (argumentsLength.isKnown) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8882,11 ***</span>
                  numberOfStaticArguments += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
                  return;
              }
  
              ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
              unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
              spreadLengths.append(cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
                  return this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
              }).iterator-&gt;value);
          });
<span class="line-new-header">--- 9138,11 ---</span>
                  numberOfStaticArguments += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
                  return;
              }
  
              ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
              unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
              spreadLengths.append(cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
                  return this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
              }).iterator-&gt;value);
          });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8933,11 ***</span>
                  }
                  return m_out.add(m_out.constIntPtr(array-&gt;length()), storeIndex);
              }
  
              RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame;</span>
  
              LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, target-&gt;numberOfArgumentsToSkip());
              LValue spreadLength = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
  
              LBasicBlock loop = m_out.newBlock();
<span class="line-new-header">--- 9189,11 ---</span>
                  }
                  return m_out.add(m_out.constIntPtr(array-&gt;length()), storeIndex);
              }
  
              RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
<span class="line-modified">!             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
  
              LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, target-&gt;numberOfArgumentsToSkip());
              LValue spreadLength = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
  
              LBasicBlock loop = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9284,11 ***</span>
          case CPURdtscIntrinsic: {
              PatchpointValue* patchpoint = m_out.patchpoint(Int32);
              patchpoint-&gt;effects = Effects::forCall();
              patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::edx });
              // The low 32-bits of rdtsc go into rax.
<span class="line-modified">!             patchpoint-&gt;resultConstraint = ValueRep::reg(X86Registers::eax);</span>
              patchpoint-&gt;setGenerator( [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
                  jit.rdtsc();
              });
              setJSValue(boxInt32(patchpoint));
              break;
<span class="line-new-header">--- 9540,11 ---</span>
          case CPURdtscIntrinsic: {
              PatchpointValue* patchpoint = m_out.patchpoint(Int32);
              patchpoint-&gt;effects = Effects::forCall();
              patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::edx });
              // The low 32-bits of rdtsc go into rax.
<span class="line-modified">!             patchpoint-&gt;resultConstraints = { ValueRep::reg(X86Registers::eax) };</span>
              patchpoint-&gt;setGenerator( [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
                  jit.rdtsc();
              });
              setJSValue(boxInt32(patchpoint));
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9658,23 ***</span>
          m_out.appendTo(isNumberCase, notInt32NumberCase);
          m_out.branch(isInt32(key), unsure(continuation), unsure(notInt32NumberCase));
  
          m_out.appendTo(notInt32NumberCase, notNaNCase);
          LValue doubleValue = unboxDouble(key);
          m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue), unsure(continuation), unsure(notNaNCase));
  
          m_out.appendTo(notNaNCase, convertibleCase);
          LValue integerValue = m_out.doubleToInt(doubleValue);
          LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
          m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, integerValueConvertedToDouble), unsure(continuation), unsure(convertibleCase));
  
          m_out.appendTo(convertibleCase, continuation);
<span class="line-modified">!         ValueFromBlock slowResult = m_out.anchor(boxInt32(integerValue));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
<span class="line-modified">!         setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
      }
  
      void compileGetMapBucket()
      {
          LBasicBlock loopStart = m_out.newBlock();
<span class="line-new-header">--- 9914,25 ---</span>
          m_out.appendTo(isNumberCase, notInt32NumberCase);
          m_out.branch(isInt32(key), unsure(continuation), unsure(notInt32NumberCase));
  
          m_out.appendTo(notInt32NumberCase, notNaNCase);
          LValue doubleValue = unboxDouble(key);
<span class="line-added">+         ValueFromBlock normalizedNaNResult = m_out.anchor(m_out.constInt64(JSValue::encode(jsNaN())));</span>
          m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue), unsure(continuation), unsure(notNaNCase));
  
          m_out.appendTo(notNaNCase, convertibleCase);
          LValue integerValue = m_out.doubleToInt(doubleValue);
          LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
<span class="line-added">+         ValueFromBlock doubleResult = m_out.anchor(key);</span>
          m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, integerValueConvertedToDouble), unsure(continuation), unsure(convertibleCase));
  
          m_out.appendTo(convertibleCase, continuation);
<span class="line-modified">!         ValueFromBlock boxedIntResult = m_out.anchor(boxInt32(integerValue));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
<span class="line-modified">!         setJSValue(m_out.phi(Int64, fastResult, normalizedNaNResult, doubleResult, boxedIntResult));</span>
      }
  
      void compileGetMapBucket()
      {
          LBasicBlock loopStart = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10213,21 ***</span>
          LValue uniquedStringImpl;
          LValue keyAsValue = nullptr;
          switch (m_node-&gt;child2().useKind()) {
          case StringUse: {
              LBasicBlock isNonEmptyString = m_out.newBlock();
<span class="line-modified">!             LBasicBlock isAtomicString = m_out.newBlock();</span>
  
              keyAsValue = lowString(m_node-&gt;child2());
              m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
  
<span class="line-modified">!             lastNext = m_out.appendTo(isNonEmptyString, isAtomicString);</span>
              uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
<span class="line-modified">!             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtomic()));</span>
<span class="line-modified">!             m_out.branch(isNotAtomic, rarely(slowCase), usually(isAtomicString));</span>
  
<span class="line-modified">!             m_out.appendTo(isAtomicString, slowCase);</span>
              break;
          }
          case SymbolUse: {
              keyAsValue = lowSymbol(m_node-&gt;child2());
              uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl);
<span class="line-new-header">--- 10471,21 ---</span>
          LValue uniquedStringImpl;
          LValue keyAsValue = nullptr;
          switch (m_node-&gt;child2().useKind()) {
          case StringUse: {
              LBasicBlock isNonEmptyString = m_out.newBlock();
<span class="line-modified">!             LBasicBlock isAtomString = m_out.newBlock();</span>
  
              keyAsValue = lowString(m_node-&gt;child2());
              m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
  
<span class="line-modified">!             lastNext = m_out.appendTo(isNonEmptyString, isAtomString);</span>
              uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
<span class="line-modified">!             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));</span>
<span class="line-modified">!             m_out.branch(isNotAtomic, rarely(slowCase), usually(isAtomString));</span>
  
<span class="line-modified">!             m_out.appendTo(isAtomString, slowCase);</span>
              break;
          }
          case SymbolUse: {
              keyAsValue = lowSymbol(m_node-&gt;child2());
              uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10252,11 ***</span>
              m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
  
              m_out.appendTo(isNonEmptyString, notStringCase);
              LValue implFromString = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
              ValueFromBlock stringResult = m_out.anchor(implFromString);
<span class="line-modified">!             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(implFromString, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtomic()));</span>
              m_out.branch(isNotAtomic, rarely(slowCase), usually(hasUniquedStringImpl));
  
              m_out.appendTo(notStringCase, isSymbolCase);
              m_out.branch(isSymbol(keyAsValue), unsure(isSymbolCase), unsure(slowCase));
  
<span class="line-new-header">--- 10510,11 ---</span>
              m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
  
              m_out.appendTo(isNonEmptyString, notStringCase);
              LValue implFromString = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
              ValueFromBlock stringResult = m_out.anchor(implFromString);
<span class="line-modified">!             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(implFromString, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));</span>
              m_out.branch(isNotAtomic, rarely(slowCase), usually(hasUniquedStringImpl));
  
              m_out.appendTo(notStringCase, isSymbolCase);
              m_out.branch(isSymbol(keyAsValue), unsure(isSymbolCase), unsure(slowCase));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10272,11 ***</span>
              RELEASE_ASSERT_NOT_REACHED();
          }
  
          ASSERT(keyAsValue);
  
<span class="line-modified">!         // Note that we don&#39;t test if the hash is zero here. AtomicStringImpl&#39;s can&#39;t have a zero</span>
          // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
          // ever load the result from the cache if the cache entry matches what we are querying for.
          // So we either get super lucky and use zero for the hash and somehow collide with the entity
          // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
          // slow path anyways.
<span class="line-new-header">--- 10530,11 ---</span>
              RELEASE_ASSERT_NOT_REACHED();
          }
  
          ASSERT(keyAsValue);
  
<span class="line-modified">!         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero</span>
          // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
          // ever load the result from the cache if the cache entry matches what we are querying for.
          // So we either get super lucky and use zero for the hash and somehow collide with the entity
          // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
          // slow path anyways.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10392,11 ***</span>
          patchpoint-&gt;appendSomeRegister(value);
          patchpoint-&gt;appendSomeRegister(prototype);
          patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
          patchpoint-&gt;numGPScratchRegisters = 2;
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
  
<span class="line-new-header">--- 10650,11 ---</span>
          patchpoint-&gt;appendSomeRegister(value);
          patchpoint-&gt;appendSomeRegister(prototype);
          patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
          patchpoint-&gt;numGPScratchRegisters = 2;
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11085,11 ***</span>
          for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)
              values.append(lowJSValue(m_graph.varArgChild(m_node, 2 + i)));
  
          LValue scope = lowCell(m_graph.varArgChild(m_node, 1));
          SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
<span class="line-removed">-         ASSERT(table == m_graph.varArgChild(m_node, 0)-&gt;castConstant&lt;SymbolTable*&gt;(vm()));</span>
          RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
  
          LBasicBlock slowPath = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
<span class="line-new-header">--- 11343,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11273,22 ***</span>
      void compileNewRegexp()
      {
          FrozenValue* regexp = m_node-&gt;cellOperand();
          LValue lastIndex = lowJSValue(m_node-&gt;child1());
          ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
<span class="line-removed">-         ASSERT(m_node-&gt;castOperand&lt;RegExp*&gt;()-&gt;isValid());</span>
  
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
  
          auto structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;regExpStructure());
          LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
<span class="line-modified">!         m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExp);</span>
          m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
<span class="line-removed">-         m_out.store32As8(m_out.constInt32(true), m_out.address(fastResultValue, m_heaps.RegExpObject_lastIndexIsWritable));</span>
          mutatorFence();
          ValueFromBlock fastResult = m_out.anchor(fastResultValue);
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
<span class="line-new-header">--- 11530,20 ---</span>
      void compileNewRegexp()
      {
          FrozenValue* regexp = m_node-&gt;cellOperand();
          LValue lastIndex = lowJSValue(m_node-&gt;child1());
          ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
  
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
  
          auto structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;regExpStructure());
          LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
<span class="line-modified">!         m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag);</span>
          m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
          mutatorFence();
          ValueFromBlock fastResult = m_out.anchor(fastResultValue);
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11370,11 ***</span>
              LValue regExp = lowRegExpObject(m_node-&gt;child1());
              LValue value = lowJSValue(m_node-&gt;child2());
  
              speculate(
                  ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">!                 m_out.isZero32(m_out.load8ZeroExt32(regExp, m_heaps.RegExpObject_lastIndexIsWritable)));</span>
  
              m_out.store64(value, regExp, m_heaps.RegExpObject_lastIndex);
              return;
          }
  
<span class="line-new-header">--- 11625,13 ---</span>
              LValue regExp = lowRegExpObject(m_node-&gt;child1());
              LValue value = lowJSValue(m_node-&gt;child2());
  
              speculate(
                  ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">!                 m_out.testNonZeroPtr(</span>
<span class="line-added">+                     m_out.loadPtr(regExp, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag),</span>
<span class="line-added">+                     m_out.constIntPtr(RegExpObject::lastIndexIsNotWritableFlag)));</span>
  
              m_out.store64(value, regExp, m_heaps.RegExpObject_lastIndex);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11467,16 ***</span>
          return length;
      }
  
      ArgumentsLength getArgumentsLength()
      {
<span class="line-modified">!         return getArgumentsLength(m_node-&gt;origin.semantic.inlineCallFrame);</span>
      }
  
      LValue getCurrentCallee()
      {
<span class="line-modified">!         if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame) {</span>
              if (frame-&gt;isClosureCall)
                  return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
              return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
          }
          return m_out.loadPtr(addressFor(CallFrameSlot::callee));
<span class="line-new-header">--- 11724,16 ---</span>
          return length;
      }
  
      ArgumentsLength getArgumentsLength()
      {
<span class="line-modified">!         return getArgumentsLength(m_node-&gt;origin.semantic.inlineCallFrame());</span>
      }
  
      LValue getCurrentCallee()
      {
<span class="line-modified">!         if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame()) {</span>
              if (frame-&gt;isClosureCall)
                  return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
              return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
          }
          return m_out.loadPtr(addressFor(CallFrameSlot::callee));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11488,11 ***</span>
          return addressFor(start).value();
      }
  
      LValue getArgumentsStart()
      {
<span class="line-modified">!         return getArgumentsStart(m_node-&gt;origin.semantic.inlineCallFrame);</span>
      }
  
      template&lt;typename Functor&gt;
      void checkStructure(
          LValue structureDiscriminant, const FormattedValue&amp; formattedValue, ExitKind exitKind,
<span class="line-new-header">--- 11745,11 ---</span>
          return addressFor(start).value();
      }
  
      LValue getArgumentsStart()
      {
<span class="line-modified">!         return getArgumentsStart(m_node-&gt;origin.semantic.inlineCallFrame());</span>
      }
  
      template&lt;typename Functor&gt;
      void checkStructure(
          LValue structureDiscriminant, const FormattedValue&amp; formattedValue, ExitKind exitKind,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12022,11 ***</span>
          m_out.branch(m_out.lessThanOrEqual(span, m_out.int32Zero), unsure(emptyCase), unsure(notEmptyCase));
  
          Vector&lt;ValueFromBlock, 5&gt; results;
  
          m_out.appendTo(emptyCase, notEmptyCase);
<span class="line-modified">!         results.append(m_out.anchor(weakPointer(jsEmptyString(&amp;vm()))));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(notEmptyCase, oneCharCase);
          m_out.branch(m_out.equal(span, m_out.int32One), unsure(oneCharCase), unsure(slowCase));
  
<span class="line-new-header">--- 12279,11 ---</span>
          m_out.branch(m_out.lessThanOrEqual(span, m_out.int32Zero), unsure(emptyCase), unsure(notEmptyCase));
  
          Vector&lt;ValueFromBlock, 5&gt; results;
  
          m_out.appendTo(emptyCase, notEmptyCase);
<span class="line-modified">!         results.append(m_out.anchor(weakPointer(jsEmptyString(vm()))));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(notEmptyCase, oneCharCase);
          m_out.branch(m_out.equal(span, m_out.int32One), unsure(oneCharCase), unsure(slowCase));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12191,11 ***</span>
      }
  
      void compilePutDynamicVar()
      {
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(Void, m_out.operation(operationPutDynamicVar),</span>
              m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
      }
  
      void compileUnreachable()
      {
<span class="line-new-header">--- 12448,11 ---</span>
      }
  
      void compilePutDynamicVar()
      {
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict),</span>
              m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
      }
  
      void compileUnreachable()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12320,20 ***</span>
              ++index;
          });
  
          unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
          LValue result;
<span class="line-modified">!         assertIsTaggedWith(reinterpret_cast&lt;void*&gt;(signature-&gt;unsafeFunction), CFunctionPtrTag);</span>
          switch (argumentCountIncludingThis) {
          case 1:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0]);</span>
              break;
          case 2:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0], operands[1]);</span>
              break;
          case 3:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(signature-&gt;unsafeFunction)), m_callFrame, operands[0], operands[1], operands[2]);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
<span class="line-new-header">--- 12577,20 ---</span>
              ++index;
          });
  
          unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
          LValue result;
<span class="line-modified">!         auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);</span>
          switch (argumentCountIncludingThis) {
          case 1:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get())), m_callFrame, operands[0]);</span>
              break;
          case 2:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get())), m_callFrame, operands[0], operands[1]);</span>
              break;
          case 3:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get())), m_callFrame, operands[0], operands[1], operands[2]);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12374,11 ***</span>
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
          patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
  
          State* state = &amp;m_ftlState;
          Node* node = m_node;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
<span class="line-new-header">--- 12631,11 ---</span>
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
          patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
  
          State* state = &amp;m_ftlState;
          Node* node = m_node;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12490,11 ***</span>
          LValue indexToCheck = m_out.zeroExtPtr(index);
          if (data.byteSize &gt; 1)
              indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
          speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
  
<span class="line-modified">!         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector));</span>
  
          TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
  
          if (m_node-&gt;op() == DataViewGetInt) {
              switch (data.byteSize) {
<span class="line-new-header">--- 12747,11 ---</span>
          LValue indexToCheck = m_out.zeroExtPtr(index);
          if (data.byteSize &gt; 1)
              indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
          speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
  
<span class="line-modified">!         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);</span>
  
          TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
  
          if (m_node-&gt;op() == DataViewGetInt) {
              switch (data.byteSize) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12649,11 ***</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
  
<span class="line-modified">!         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector));</span>
          TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
  
          if (data.isFloatingPoint) {
              if (data.byteSize == 4) {
                  valueToStore = m_out.doubleToFloat(valueToStore);
<span class="line-new-header">--- 12906,11 ---</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
  
<span class="line-modified">!         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);</span>
          TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
  
          if (data.isFloatingPoint) {
              if (data.byteSize == 4) {
                  valueToStore = m_out.doubleToFloat(valueToStore);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12980,11 ***</span>
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 2;
          if (scratchFPRUsage == NeedScratchFPR)
              patchpoint-&gt;numFPScratchRegisters++;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-new-header">--- 13237,11 ---</span>
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 2;
          if (scratchFPRUsage == NeedScratchFPR)
              patchpoint-&gt;numFPScratchRegisters++;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13043,11 ***</span>
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-new-header">--- 13300,11 ---</span>
          patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13099,11 ***</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-new-header">--- 13356,11 ---</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13180,11 ***</span>
          if (actualAllocator.isConstant())
              patchpoint-&gt;numGPScratchRegisters++;
          else
              patchpoint-&gt;appendSomeRegisterWithClobber(allocator);
          patchpoint-&gt;numGPScratchRegisters++;
<span class="line-modified">!         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;</span>
  
          m_out.appendSuccessor(usually(continuation));
          m_out.appendSuccessor(rarely(slowPath));
  
          patchpoint-&gt;setGenerator(
<span class="line-new-header">--- 13437,11 ---</span>
          if (actualAllocator.isConstant())
              patchpoint-&gt;numGPScratchRegisters++;
          else
              patchpoint-&gt;appendSomeRegisterWithClobber(allocator);
          patchpoint-&gt;numGPScratchRegisters++;
<span class="line-modified">!         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };</span>
  
          m_out.appendSuccessor(usually(continuation));
          m_out.appendSuccessor(rarely(slowPath));
  
          patchpoint-&gt;setGenerator(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13620,11 ***</span>
              return m_out.logicalNot(
                  equalNullOrUndefined(
                      edge, CellCaseSpeculatesObject, SpeculateNullOrUndefined,
                      ManualOperandSpeculation));
          case StringUse:
<span class="line-modified">!             return m_out.notEqual(lowString(edge), weakPointer(jsEmptyString(&amp;m_graph.m_vm)));</span>
          case StringOrOtherUse: {
              LValue value = lowJSValue(edge, ManualOperandSpeculation);
  
              LBasicBlock cellCase = m_out.newBlock();
              LBasicBlock notCellCase = m_out.newBlock();
<span class="line-new-header">--- 13877,11 ---</span>
              return m_out.logicalNot(
                  equalNullOrUndefined(
                      edge, CellCaseSpeculatesObject, SpeculateNullOrUndefined,
                      ManualOperandSpeculation));
          case StringUse:
<span class="line-modified">!             return m_out.notEqual(lowString(edge), weakPointer(jsEmptyString(m_graph.m_vm)));</span>
          case StringOrOtherUse: {
              LValue value = lowJSValue(edge, ManualOperandSpeculation);
  
              LBasicBlock cellCase = m_out.newBlock();
              LBasicBlock notCellCase = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13632,11 ***</span>
  
              m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
  
              LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
              FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
<span class="line-modified">!             ValueFromBlock stringResult = m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(&amp;m_graph.m_vm))));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(notCellCase, continuation);
              FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
              ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
<span class="line-new-header">--- 13889,11 ---</span>
  
              m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
  
              LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
              FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
<span class="line-modified">!             ValueFromBlock stringResult = m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm))));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(notCellCase, continuation);
              FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
              ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13689,11 ***</span>
              m_out.branch(
                  isBigInt(value, provenType(edge) &amp; (SpecCell - SpecString)),
                  unsure(bigIntCase), unsure(notStringOrBigIntCase));
  
              m_out.appendTo(stringCase, bigIntCase);
<span class="line-modified">!             results.append(m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(&amp;m_graph.m_vm)))));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(bigIntCase, notStringOrBigIntCase);
              LValue nonZeroBigInt = m_out.notZero32(
                  m_out.load32NonNegative(value, m_heaps.JSBigInt_length));
<span class="line-new-header">--- 13946,11 ---</span>
              m_out.branch(
                  isBigInt(value, provenType(edge) &amp; (SpecCell - SpecString)),
                  unsure(bigIntCase), unsure(notStringOrBigIntCase));
  
              m_out.appendTo(stringCase, bigIntCase);
<span class="line-modified">!             results.append(m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm)))));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(bigIntCase, notStringOrBigIntCase);
              LValue nonZeroBigInt = m_out.notZero32(
                  m_out.load32NonNegative(value, m_heaps.JSBigInt_length));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13897,29 ***</span>
              m_out.jump(performStore);
              m_out.appendTo(performStore, lastNext);
          }
      }
  
<span class="line-modified">!     LValue caged(Gigacage::Kind kind, LValue ptr)</span>
      {
  #if GIGACAGE_ENABLED
          if (!Gigacage::isEnabled(kind))
<span class="line-modified">!             return ptr;</span>
  
          if (kind == Gigacage::Primitive &amp;&amp; Gigacage::canPrimitiveGigacageBeDisabled()) {
              if (vm().primitiveGigacageEnabled().isStillValid())
                  m_graph.watchpoints().addLazily(vm().primitiveGigacageEnabled());
              else
<span class="line-modified">!                 return ptr;</span>
          }
  
          LValue basePtr = m_out.constIntPtr(Gigacage::basePtr(kind));
          LValue mask = m_out.constIntPtr(Gigacage::mask(kind));
  
          LValue masked = m_out.bitAnd(ptr, mask);
          LValue result = m_out.add(masked, basePtr);
  
          // Make sure that B3 doesn&#39;t try to do smart reassociation of these pointer bits.
          // FIXME: In an ideal world, B3 would not do harmful reassociations, and if it did, it would be able
          // to undo them during constant hoisting and regalloc. As it stands, if you remove this then Octane
          // gets 1.6% slower and Kraken gets 5% slower. It&#39;s all because the basePtr, which is a constant,
          // gets reassociated out of the add above and into the address arithmetic. This disables hoisting of
<span class="line-new-header">--- 14154,87 ---</span>
              m_out.jump(performStore);
              m_out.appendTo(performStore, lastNext);
          }
      }
  
<span class="line-modified">!     LValue untagArrayPtr(LValue ptr, LValue size)</span>
      {
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+         PatchpointValue* authenticate = m_out.patchpoint(pointerType());</span>
<span class="line-added">+         authenticate-&gt;appendSomeRegister(ptr);</span>
<span class="line-added">+         authenticate-&gt;append(size, B3::ValueRep(B3::ValueRep::SomeLateRegister));</span>
<span class="line-added">+         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+             jit.move(params[1].gpr(), params[0].gpr());</span>
<span class="line-added">+             jit.untagArrayPtr(params[2].gpr(), params[0].gpr());</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return authenticate;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+         UNUSED_PARAM(size);</span>
<span class="line-added">+         return ptr;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     LValue removeArrayPtrTag(LValue ptr)</span>
<span class="line-added">+     {</span>
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+         PatchpointValue* authenticate = m_out.patchpoint(pointerType());</span>
<span class="line-added">+         authenticate-&gt;appendSomeRegister(ptr);</span>
<span class="line-added">+         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+             jit.move(params[1].gpr(), params[0].gpr());</span>
<span class="line-added">+             jit.removeArrayPtrTag(params[0].gpr());</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return authenticate;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         return ptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     LValue caged(Gigacage::Kind kind, LValue ptr, LValue base)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         auto doUntagArrayPtr = [&amp;](LValue taggedPtr) {</span>
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+             if (kind == Gigacage::Primitive) {</span>
<span class="line-added">+                 LValue size = m_out.load32(base, m_heaps.JSArrayBufferView_length);</span>
<span class="line-added">+                 return untagArrayPtr(taggedPtr, size);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return ptr;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+             UNUSED_PARAM(taggedPtr);</span>
<span class="line-added">+             return ptr;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
  #if GIGACAGE_ENABLED
          if (!Gigacage::isEnabled(kind))
<span class="line-modified">!             return doUntagArrayPtr(ptr);</span>
  
          if (kind == Gigacage::Primitive &amp;&amp; Gigacage::canPrimitiveGigacageBeDisabled()) {
              if (vm().primitiveGigacageEnabled().isStillValid())
                  m_graph.watchpoints().addLazily(vm().primitiveGigacageEnabled());
              else
<span class="line-modified">!                 return doUntagArrayPtr(ptr);</span>
          }
  
          LValue basePtr = m_out.constIntPtr(Gigacage::basePtr(kind));
          LValue mask = m_out.constIntPtr(Gigacage::mask(kind));
  
          LValue masked = m_out.bitAnd(ptr, mask);
          LValue result = m_out.add(masked, basePtr);
  
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+         if (kind == Gigacage::Primitive) {</span>
<span class="line-added">+             PatchpointValue* merge = m_out.patchpoint(pointerType());</span>
<span class="line-added">+             merge-&gt;append(result, B3::ValueRep(B3::ValueRep::SomeLateRegister));</span>
<span class="line-added">+             merge-&gt;appendSomeRegister(ptr);</span>
<span class="line-added">+             merge-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+                 jit.move(params[2].gpr(), params[0].gpr());</span>
<span class="line-added">+                 jit.bitFieldInsert64(params[1].gpr(), 0, 64 - MacroAssembler::numberOfPACBits, params[0].gpr());</span>
<span class="line-added">+             });</span>
<span class="line-added">+ </span>
<span class="line-added">+             result = doUntagArrayPtr(merge);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif // CPU(ARM64E)</span>
<span class="line-added">+ </span>
          // Make sure that B3 doesn&#39;t try to do smart reassociation of these pointer bits.
          // FIXME: In an ideal world, B3 would not do harmful reassociations, and if it did, it would be able
          // to undo them during constant hoisting and regalloc. As it stands, if you remove this then Octane
          // gets 1.6% slower and Kraken gets 5% slower. It&#39;s all because the basePtr, which is a constant,
          // gets reassociated out of the add above and into the address arithmetic. This disables hoisting of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13928,14 ***</span>
          // then teach it reassociation. So, Add(Add(a, b), const) where a is loop-invariant while b isn&#39;t
          // will turn into Add(Add(a, const), b) by the constant hoister. We would have to teach B3 to do this
          // and possibly other smart things if we want to be able to remove this opaque.
          // https://bugs.webkit.org/show_bug.cgi?id=175493
          return m_out.opaque(result);
<span class="line-removed">- #else</span>
<span class="line-removed">-         UNUSED_PARAM(kind);</span>
<span class="line-removed">-         return ptr;</span>
  #endif
      }
  
      void buildSwitch(SwitchData* data, LType type, LValue switchValue)
      {
          ASSERT(type == pointerType() || type == Int32);
<span class="line-new-header">--- 14243,15 ---</span>
          // then teach it reassociation. So, Add(Add(a, b), const) where a is loop-invariant while b isn&#39;t
          // will turn into Add(Add(a, const), b) by the constant hoister. We would have to teach B3 to do this
          // and possibly other smart things if we want to be able to remove this opaque.
          // https://bugs.webkit.org/show_bug.cgi?id=175493
          return m_out.opaque(result);
  #endif
<span class="line-added">+ </span>
<span class="line-added">+         UNUSED_PARAM(kind);</span>
<span class="line-added">+         UNUSED_PARAM(base);</span>
<span class="line-added">+         return doUntagArrayPtr(ptr);</span>
      }
  
      void buildSwitch(SwitchData* data, LType type, LValue switchValue)
      {
          ASSERT(type == pointerType() || type == Int32);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14473,11 ***</span>
                  Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
              setInt32(result);
              return;
          }
  
<span class="line-modified">!         if (m_node-&gt;shouldSpeculateAnyInt()) {</span>
              setStrictInt52(m_out.zeroExt(result, Int64));
              return;
          }
  
          setDouble(m_out.unsignedToDouble(result));
<span class="line-new-header">--- 14789,11 ---</span>
                  Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
              setInt32(result);
              return;
          }
  
<span class="line-modified">!         if (m_node-&gt;shouldSpeculateInt52()) {</span>
              setStrictInt52(m_out.zeroExt(result, Int64));
              return;
          }
  
          setDouble(m_out.unsignedToDouble(result));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14773,11 ***</span>
                          jit.addLinkTask(
                              [=] (LinkBuffer&amp; linkBuffer) {
                                  linkBuffer.link(generatorJump,
                                      CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(lazySlowPathGenerationThunkGenerator).code()));
  
<span class="line-modified">!                                 std::unique_ptr&lt;LazySlowPath&gt; lazySlowPath = std::make_unique&lt;LazySlowPath&gt;();</span>
  
                                  auto linkedPatchableJump = CodeLocationJump&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump));
  
                                  CodeLocationLabel&lt;JSInternalPtrTag&gt; linkedDone = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(done);
  
<span class="line-new-header">--- 15089,11 ---</span>
                          jit.addLinkTask(
                              [=] (LinkBuffer&amp; linkBuffer) {
                                  linkBuffer.link(generatorJump,
                                      CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(lazySlowPathGenerationThunkGenerator).code()));
  
<span class="line-modified">!                                 std::unique_ptr&lt;LazySlowPath&gt; lazySlowPath = makeUnique&lt;LazySlowPath&gt;();</span>
  
                                  auto linkedPatchableJump = CodeLocationJump&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump));
  
                                  CodeLocationLabel&lt;JSInternalPtrTag&gt; linkedDone = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(done);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15173,11 ***</span>
              LValue result = boxBoolean(value.value());
              setJSValue(edge.node(), result);
              return result;
          }
  
<span class="line-modified">!         DFG_CRASH(m_graph, m_node, &quot;Value not defined&quot;);</span>
          return 0;
      }
  
      LValue lowNotCell(Edge edge)
      {
<span class="line-new-header">--- 15489,11 ---</span>
              LValue result = boxBoolean(value.value());
              setJSValue(edge.node(), result);
              return result;
          }
  
<span class="line-modified">!         DFG_CRASH(m_graph, m_node, makeString(&quot;Value not defined: &quot;, String::number(edge.node()-&gt;index())).ascii().data());</span>
          return 0;
      }
  
      LValue lowNotCell(Edge edge)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15695,10 ***</span>
<span class="line-new-header">--- 16011,15 ---</span>
                  return m_out.booleanFalse;
              if (JSValue value = provenValue(edge)) {
                  if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
                      return m_out.booleanFalse;
              }
<span class="line-added">+             String value = edge-&gt;tryGetString(m_graph);</span>
<span class="line-added">+             if (!value.isNull()) {</span>
<span class="line-added">+                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.</span>
<span class="line-added">+                 return m_out.booleanFalse;</span>
<span class="line-added">+             }</span>
          }
  
          return m_out.testNonZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15709,10 ***</span>
<span class="line-new-header">--- 16030,15 ---</span>
                  return m_out.booleanTrue;
              if (JSValue value = provenValue(edge)) {
                  if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
                      return m_out.booleanTrue;
              }
<span class="line-added">+             String value = edge-&gt;tryGetString(m_graph);</span>
<span class="line-added">+             if (!value.isNull()) {</span>
<span class="line-added">+                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.</span>
<span class="line-added">+                 return m_out.booleanTrue;</span>
<span class="line-added">+             }</span>
          }
  
          return m_out.testIsZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16116,11 ***</span>
          speculate(BadType, jsValueValue(string), edge.node(), isRopeString(string));
          speculate(
              BadType, jsValueValue(string), edge.node(),
              m_out.testIsZero32(
                  m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
<span class="line-modified">!                 m_out.constInt32(StringImpl::flagIsAtomic())));</span>
          m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
      }
  
      void speculateStringIdent(Edge edge)
      {
<span class="line-new-header">--- 16442,11 ---</span>
          speculate(BadType, jsValueValue(string), edge.node(), isRopeString(string));
          speculate(
              BadType, jsValueValue(string), edge.node(),
              m_out.testIsZero32(
                  m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
<span class="line-modified">!                 m_out.constInt32(StringImpl::flagIsAtom())));</span>
          m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
      }
  
      void speculateStringIdent(Edge edge)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16333,10 ***</span>
<span class="line-new-header">--- 16659,13 ---</span>
          m_out.branch(m_out.equal(mode, m_out.constInt32(WastefulTypedArray)),
              unsure(isWasteful), unsure(continuation));
  
          LBasicBlock lastNext = m_out.appendTo(isWasteful, continuation);
          LValue vector = m_out.loadPtr(base, m_heaps.JSArrayBufferView_vector);
<span class="line-added">+         // FIXME: We could probably make this a mask.</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=197701</span>
<span class="line-added">+         vector = removeArrayPtrTag(vector);</span>
          speculate(Uncountable, jsValueValue(vector), m_node, m_out.isZero64(vector));
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16527,11 ***</span>
              // This case arises when you have a situation like this:
              // foo makes a call to bar, bar is inlined in foo. bar makes a call
              // to baz and baz is inlined in bar. And then baz makes a tail-call to jaz,
              // and jaz is inlined in baz. We want the callframe for jaz to appear to
              // have caller be bar.
<span class="line-modified">!             codeOrigin = *codeOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls();</span>
          }
  
          return codeOrigin;
      }
  
<span class="line-new-header">--- 16856,11 ---</span>
              // This case arises when you have a situation like this:
              // foo makes a call to bar, bar is inlined in foo. bar makes a call
              // to baz and baz is inlined in bar. And then baz makes a tail-call to jaz,
              // and jaz is inlined in baz. We want the callframe for jaz to appear to
              // have caller be bar.
<span class="line-modified">!             codeOrigin = *codeOrigin.inlineCallFrame()-&gt;getCallerSkippingTailCalls();</span>
          }
  
          return codeOrigin;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16568,15 ***</span>
          HandlerInfo* exceptionHandler;
          bool willCatchException = m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler);
          if (!willCatchException)
              return PatchpointExceptionHandle::defaultHandle(m_ftlState);
  
<span class="line-modified">!         if (verboseCompilationEnabled()) {</span>
<span class="line-removed">-             dataLog(&quot;    Patchpoint exception OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap(), &quot;\n&quot;);</span>
<span class="line-removed">-             if (!m_availableRecoveries.isEmpty())</span>
<span class="line-removed">-                 dataLog(&quot;        Available recoveries: &quot;, listDump(m_availableRecoveries), &quot;\n&quot;);</span>
<span class="line-removed">-         }</span>
  
          bool exitOK = true;
          NodeOrigin origin = m_origin.withForExitAndExitOK(opCatchOrigin, exitOK);
  
          OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(noValue(), nullptr);
<span class="line-new-header">--- 16897,11 ---</span>
          HandlerInfo* exceptionHandler;
          bool willCatchException = m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler);
          if (!willCatchException)
              return PatchpointExceptionHandle::defaultHandle(m_ftlState);
  
<span class="line-modified">!         dataLogLnIf(verboseCompilationEnabled(), &quot;    Patchpoint exception OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());</span>
  
          bool exitOK = true;
          NodeOrigin origin = m_origin.withForExitAndExitOK(opCatchOrigin, exitOK);
  
          OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(noValue(), nullptr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16626,15 ***</span>
  
      void appendOSRExit(
          ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition,
          NodeOrigin origin, bool isExceptionHandler = false)
      {
<span class="line-modified">!         if (verboseCompilationEnabled()) {</span>
<span class="line-removed">-             dataLog(&quot;    OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap(), &quot;\n&quot;);</span>
<span class="line-removed">-             if (!m_availableRecoveries.isEmpty())</span>
<span class="line-removed">-                 dataLog(&quot;        Available recoveries: &quot;, listDump(m_availableRecoveries), &quot;\n&quot;);</span>
<span class="line-removed">-         }</span>
  
          DFG_ASSERT(m_graph, m_node, origin.exitOK);
  
          if (!isExceptionHandler
              &amp;&amp; Options::useOSRExitFuzz()
<span class="line-new-header">--- 16951,11 ---</span>
  
      void appendOSRExit(
          ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition,
          NodeOrigin origin, bool isExceptionHandler = false)
      {
<span class="line-modified">!         dataLogLnIf(verboseCompilationEnabled(), &quot;    OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());</span>
  
          DFG_ASSERT(m_graph, m_node, origin.exitOK);
  
          if (!isExceptionHandler
              &amp;&amp; Options::useOSRExitFuzz()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16824,22 ***</span>
                      return ExitValue::materializeNewObject(map.get(node));
                  break;
              }
          }
  
<span class="line-removed">-         for (unsigned i = 0; i &lt; m_availableRecoveries.size(); ++i) {</span>
<span class="line-removed">-             AvailableRecovery recovery = m_availableRecoveries[i];</span>
<span class="line-removed">-             if (recovery.node() != node)</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             ExitValue result = ExitValue::recovery(</span>
<span class="line-removed">-                 recovery.opcode(), arguments.size(), arguments.size() + 1,</span>
<span class="line-removed">-                 recovery.format());</span>
<span class="line-removed">-             arguments.append(recovery.left());</span>
<span class="line-removed">-             arguments.append(recovery.right());</span>
<span class="line-removed">-             return result;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          LoweredNodeValue value = m_int32Values.get(node);
          if (isValid(value))
              return exitArgument(arguments, DataFormatInt32, value.value());
  
          value = m_int52Values.get(node);
<span class="line-new-header">--- 17145,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16902,22 ***</span>
  
          // Doubles and Int52 have been converted by ValueRep()
          DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
      }
  
<span class="line-removed">-     void addAvailableRecovery(</span>
<span class="line-removed">-         Node* node, RecoveryOpcode opcode, LValue left, LValue right, DataFormat format)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         m_availableRecoveries.append(AvailableRecovery(node, opcode, left, right, format));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void addAvailableRecovery(</span>
<span class="line-removed">-         Edge edge, RecoveryOpcode opcode, LValue left, LValue right, DataFormat format)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         addAvailableRecovery(edge.node(), opcode, left, right, format);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      void setInt32(Node* node, LValue value)
      {
          m_int32Values.set(node, LoweredNodeValue(value, m_highBlock));
      }
      void setInt52(Node* node, LValue value)
<span class="line-new-header">--- 17211,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17004,10 ***</span>
<span class="line-new-header">--- 17301,11 ---</span>
      void keepAlive(LValue value)
      {
          PatchpointValue* patchpoint = m_out.patchpoint(Void);
          patchpoint-&gt;effects = Effects::none();
          patchpoint-&gt;effects.writesLocalState = true;
<span class="line-added">+         patchpoint-&gt;effects.reads = HeapRange::top();</span>
          patchpoint-&gt;append(value, ValueRep::ColdAny);
          patchpoint-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
      }
  
      void addWeakReference(JSCell* target)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17183,12 ***</span>
  
      HashMap&lt;Node*, LValue&gt; m_phis;
  
      LocalOSRAvailabilityCalculator m_availabilityCalculator;
  
<span class="line-removed">-     Vector&lt;AvailableRecovery, 3&gt; m_availableRecoveries;</span>
<span class="line-removed">- </span>
      InPlaceAbstractState m_state;
      AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
      DFG::BasicBlock* m_highBlock;
      DFG::BasicBlock* m_nextHighBlock;
      LBasicBlock m_nextLowBlock;
<span class="line-new-header">--- 17481,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17198,10 ***</span>
<span class="line-new-header">--- 17494,15 ---</span>
      IndexMaskingMode m_indexMaskingMode;
  
      NodeOrigin m_origin;
      unsigned m_nodeIndex;
      Node* m_node;
<span class="line-added">+ </span>
<span class="line-added">+     // These are used for validating AI state.</span>
<span class="line-added">+     HashMap&lt;Node*, NodeSet&gt; m_liveInToNode;</span>
<span class="line-added">+     HashMap&lt;Node*, AbstractValue&gt; m_aiCheckedNodes;</span>
<span class="line-added">+     String m_graphDump;</span>
  };
  
  } // anonymous namespace
  
  void lowerDFGToB3(State&amp; state)
</pre>
<center><a href="FTLLink.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>