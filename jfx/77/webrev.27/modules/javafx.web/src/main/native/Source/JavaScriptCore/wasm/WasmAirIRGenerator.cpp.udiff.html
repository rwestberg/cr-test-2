<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmAirIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../tools/VMInspector.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmAirIRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -38,20 +38,25 @@</span>
  #include &quot;B3CheckValue.h&quot;
  #include &quot;B3PatchpointSpecial.h&quot;
  #include &quot;B3Procedure.h&quot;
  #include &quot;B3ProcedureInlines.h&quot;
  #include &quot;BinarySwitch.h&quot;
<span class="udiff-line-added">+ #include &quot;DisallowMacroScratchRegisterUsage.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JSCInlines.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JSWebAssemblyInstance.h&quot;</span>
  #include &quot;ScratchRegisterAllocator.h&quot;
  #include &quot;VirtualRegister.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
  #include &quot;WasmContextInlines.h&quot;
  #include &quot;WasmExceptionType.h&quot;
  #include &quot;WasmFunctionParser.h&quot;
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmOMGPlan.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmOSREntryData.h&quot;</span>
  #include &quot;WasmOpcodeOrigin.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmOperations.h&quot;</span>
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmThunks.h&quot;
  #include &lt;limits&gt;
  #include &lt;wtf/Box.h&gt;
  #include &lt;wtf/Optional.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -198,14 +203,16 @@</span>
      };
  
      using ExpressionType = TypedTmp;
      using ControlType = ControlData;
      using ExpressionList = Vector&lt;ExpressionType, 1&gt;;
<span class="udiff-line-added">+     using Stack = ExpressionList;</span>
      using ResultList = ControlData::ResultList;
      using ControlEntry = FunctionParser&lt;AirIRGenerator&gt;::ControlEntry;
  
      static ExpressionType emptyExpression() { return { }; };
<span class="udiff-line-added">+     Stack createStack() { return Stack(); }</span>
  
      using ErrorType = String;
      using UnexpectedResult = Unexpected&lt;ErrorType&gt;;
      using Result = Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt;;
      using PartialResult = Expected&lt;void, ErrorType&gt;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -227,10 +234,21 @@</span>
      PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
      PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
      ExpressionType addConstant(Type, uint64_t);
      ExpressionType addConstant(BasicBlock*, Type, uint64_t);
  
<span class="udiff-line-added">+     // References</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Tables</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType&amp; index, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType&amp; index, ExpressionType&amp; value);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count);</span>
<span class="udiff-line-added">+ </span>
      // Locals
      PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
  
      // Globals
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -251,32 +269,32 @@</span>
      PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
  
      // Control flow
      ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);
      ControlData WARN_UNUSED_RETURN addBlock(Type signature);
<span class="udiff-line-modified-removed">-     ControlData WARN_UNUSED_RETURN addLoop(Type signature);</span>
<span class="udiff-line-modified-added">+     ControlData WARN_UNUSED_RETURN addLoop(Type signature, const Stack&amp;, uint32_t loopIndex);</span>
      PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const ExpressionList&amp;);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);</span>
      PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
  
      PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues);
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const ExpressionList&amp; returnValues);</span>
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const ExpressionList&amp; expressionStack);</span>
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, ExpressionList&amp; expressionStack);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);</span>
      PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);
  
      // Calls
      PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addCallIndirect(const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addUnreachable();
  
      PartialResult addShift(Type, B3::Air::Opcode, ExpressionType value, ExpressionType shift, ExpressionType&amp; result);
      PartialResult addIntegerSub(B3::Air::Opcode, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);
      PartialResult addFloatingPointAbs(B3::Air::Opcode, ExpressionType value, ExpressionType&amp; result);
      PartialResult addFloatingPointBinOp(Type, B3::Air::Opcode, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);
  
<span class="udiff-line-modified-removed">-     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const ExpressionList* expressionStack);</span>
<span class="udiff-line-modified-added">+     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack);</span>
      void setParser(FunctionParser&lt;AirIRGenerator&gt;* parser) { m_parser = parser; };
  
      static Vector&lt;Tmp&gt; toTmpVector(const Vector&lt;TypedTmp&gt;&amp; vector)
      {
          Vector&lt;Tmp&gt; result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -294,10 +312,15 @@</span>
              m_freeGPs.append(tmp);
          else
              m_freeFPs.append(tmp);
      }
  
<span class="udiff-line-added">+     const Bag&lt;B3::PatchpointValue*&gt;&amp; patchpoints() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         return m_patchpoints;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  private:
      ALWAYS_INLINE void validateInst(Inst&amp; inst)
      {
          if (!ASSERT_DISABLED) {
              if (!inst.isValidForm()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -348,20 +371,26 @@</span>
          return m_code.newTmp(bank);
      }
  
      TypedTmp g32() { return { newTmp(B3::GP), Type::I32 }; }
      TypedTmp g64() { return { newTmp(B3::GP), Type::I64 }; }
<span class="udiff-line-added">+     TypedTmp gAnyref() { return { newTmp(B3::GP), Type::Anyref }; }</span>
<span class="udiff-line-added">+     TypedTmp gFuncref() { return { newTmp(B3::GP), Type::Funcref }; }</span>
      TypedTmp f32() { return { newTmp(B3::FP), Type::F32 }; }
      TypedTmp f64() { return { newTmp(B3::FP), Type::F64 }; }
  
      TypedTmp tmpForType(Type type)
      {
          switch (type) {
          case Type::I32:
              return g32();
          case Type::I64:
              return g64();
<span class="udiff-line-added">+         case Type::Funcref:</span>
<span class="udiff-line-added">+             return gFuncref();</span>
<span class="udiff-line-added">+         case Type::Anyref:</span>
<span class="udiff-line-added">+             return gAnyref();</span>
          case Type::F32:
              return f32();
          case Type::F64:
              return f64();
          case Type::Void:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -371,11 +400,14 @@</span>
          }
      }
  
      B3::PatchpointValue* addPatchpoint(B3::Type type)
      {
<span class="udiff-line-modified-removed">-         return m_proc.add&lt;B3::PatchpointValue&gt;(type, B3::Origin());</span>
<span class="udiff-line-modified-added">+         auto* result = m_proc.add&lt;B3::PatchpointValue&gt;(type, B3::Origin());</span>
<span class="udiff-line-added">+         if (UNLIKELY(shouldDumpIRAtEachPhase(B3::AirMode)))</span>
<span class="udiff-line-added">+             m_patchpoints.add(result);</span>
<span class="udiff-line-added">+         return result;</span>
      }
  
      template &lt;typename ...Args&gt;
      void emitPatchpoint(B3::PatchpointValue* patch, Tmp result, Args... theArgs)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -395,20 +427,20 @@</span>
  
      template &lt;size_t inlineSize&gt;
      void emitPatchpoint(BasicBlock* basicBlock, B3::PatchpointValue* patch, Tmp result, Vector&lt;ConstrainedTmp, inlineSize&gt;&amp;&amp; args)
      {
          if (!m_patchpointSpecial)
<span class="udiff-line-modified-removed">-             m_patchpointSpecial = static_cast&lt;B3::PatchpointSpecial*&gt;(m_code.addSpecial(std::make_unique&lt;B3::PatchpointSpecial&gt;()));</span>
<span class="udiff-line-modified-added">+             m_patchpointSpecial = static_cast&lt;B3::PatchpointSpecial*&gt;(m_code.addSpecial(makeUnique&lt;B3::PatchpointSpecial&gt;()));</span>
  
          Inst inst(Patch, patch, Arg::special(m_patchpointSpecial));
          Inst resultMov;
          if (result) {
              ASSERT(patch-&gt;type() != B3::Void);
<span class="udiff-line-modified-removed">-             switch (patch-&gt;resultConstraint.kind()) {</span>
<span class="udiff-line-modified-added">+             switch (patch-&gt;resultConstraints[0].kind()) {</span>
              case B3::ValueRep::Register:
<span class="udiff-line-modified-removed">-                 inst.args.append(Tmp(patch-&gt;resultConstraint.reg()));</span>
<span class="udiff-line-modified-removed">-                 resultMov = Inst(result.isGP() ? Move : MoveDouble, nullptr, Tmp(patch-&gt;resultConstraint.reg()), result);</span>
<span class="udiff-line-modified-added">+                 inst.args.append(Tmp(patch-&gt;resultConstraints[0].reg()));</span>
<span class="udiff-line-modified-added">+                 resultMov = Inst(result.isGP() ? Move : MoveDouble, nullptr, Tmp(patch-&gt;resultConstraints[0].reg()), result);</span>
                  break;
              case B3::ValueRep::SomeRegister:
                  inst.args.append(result);
                  break;
              default:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -423,10 +455,11 @@</span>
              // backed by Values.
              // https://bugs.webkit.org/show_bug.cgi?id=194040
              B3::Value* dummyValue = m_proc.addConstant(B3::Origin(), tmp.tmp.isGP() ? B3::Int64 : B3::Double, 0);
              patch-&gt;append(dummyValue, tmp.rep);
              switch (tmp.rep.kind()) {
<span class="udiff-line-added">+             case B3::ValueRep::ColdAny: // B3::Value propagates ColdAny information and later Air will allocate appropriate stack.</span>
              case B3::ValueRep::SomeRegister:
                  inst.args.append(tmp.tmp);
                  break;
              case B3::ValueRep::Register:
                  patch-&gt;earlyClobbered().clear(tmp.rep.reg());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -442,12 +475,12 @@</span>
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
          }
  
<span class="udiff-line-modified-removed">-         if (patch-&gt;resultConstraint.isReg())</span>
<span class="udiff-line-modified-removed">-             patch-&gt;lateClobbered().clear(patch-&gt;resultConstraint.reg());</span>
<span class="udiff-line-modified-added">+         if (patch-&gt;resultConstraints[0].isReg())</span>
<span class="udiff-line-modified-added">+             patch-&gt;lateClobbered().clear(patch-&gt;resultConstraints[0].reg());</span>
          for (unsigned i = patch-&gt;numGPScratchRegisters; i--;)
              inst.args.append(g64().tmp());
          for (unsigned i = patch-&gt;numFPScratchRegisters; i--;)
              inst.args.append(f64().tmp());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -465,11 +498,11 @@</span>
          // We fail along the truthy edge of &#39;branch&#39;.
          Inst branch = makeBranch();
  
          // FIXME: Make a hashmap of these.
          B3::CheckSpecial::Key key(branch);
<span class="udiff-line-modified-removed">-         B3::CheckSpecial* special = static_cast&lt;B3::CheckSpecial*&gt;(m_code.addSpecial(std::make_unique&lt;B3::CheckSpecial&gt;(key)));</span>
<span class="udiff-line-modified-added">+         B3::CheckSpecial* special = static_cast&lt;B3::CheckSpecial*&gt;(m_code.addSpecial(makeUnique&lt;B3::CheckSpecial&gt;(key)));</span>
  
          // FIXME: Remove the need for dummy values
          // https://bugs.webkit.org/show_bug.cgi?id=194040
          B3::Value* dummyPredicate = m_proc.addConstant(B3::Origin(), B3::Int32, 42);
          B3::CheckValue* checkValue = m_proc.add&lt;B3::CheckValue&gt;(B3::Check, B3::Origin(), dummyPredicate);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -493,10 +526,12 @@</span>
              switch (result.type()) {
              case Type::I32:
                  resultType = B3::Int32;
                  break;
              case Type::I64:
<span class="udiff-line-added">+             case Type::Anyref:</span>
<span class="udiff-line-added">+             case Type::Funcref:</span>
                  resultType = B3::Int64;
                  break;
              case Type::F32:
                  resultType = B3::Float;
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -522,11 +557,11 @@</span>
          B3::Value* origin = m_proc.add&lt;B3::CCallValue&gt;(resultType, B3::Origin(), B3::Effects::none(), dummyFunc, makeDummyValue(theArgs)...);
  
          Inst inst(CCall, origin);
  
          Tmp callee = g64();
<span class="udiff-line-modified-removed">-         append(Move, Arg::immPtr(tagCFunctionPtr&lt;void*&gt;(func, B3CCallPtrTag)), callee);</span>
<span class="udiff-line-modified-added">+         append(block, Move, Arg::immPtr(tagCFunctionPtr&lt;void*&gt;(func, B3CCallPtrTag)), callee);</span>
          inst.args.append(callee);
  
          if (result)
              inst.args.append(result.tmp());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -540,10 +575,12 @@</span>
      {
          switch (type) {
          case Type::I32:
              return Move32;
          case Type::I64:
<span class="udiff-line-added">+         case Type::Anyref:</span>
<span class="udiff-line-added">+         case Type::Funcref:</span>
              return Move;
          case Type::F32:
              return MoveFloat;
          case Type::F64:
              return MoveDouble;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -552,41 +589,55 @@</span>
          }
      }
  
      void emitThrowException(CCallHelpers&amp;, ExceptionType);
  
<span class="udiff-line-modified-removed">-     void emitTierUpCheck(uint32_t decrementCount, B3::Origin);</span>
<span class="udiff-line-modified-added">+     void emitEntryTierUpCheck(int32_t incrementCount, B3::Origin);</span>
<span class="udiff-line-added">+     void emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp;, uint32_t, uint32_t, B3::Origin);</span>
  
<span class="udiff-line-added">+     void emitWriteBarrierForJSWrapper();</span>
      ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
      ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
      void emitStoreOp(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
  
      void unify(const ExpressionType&amp; dst, const ExpressionType&amp; source);
<span class="udiff-line-modified-removed">-     void unifyValuesWithBlock(const ExpressionList&amp; resultStack, const ResultList&amp; stack);</span>
<span class="udiff-line-modified-added">+     void unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; stack);</span>
  
      template &lt;typename IntType&gt;
      void emitChecksForModOrDiv(bool isSignedDiv, ExpressionType left, ExpressionType right);
  
      template &lt;typename IntType&gt;
      void emitModOrDiv(bool isDiv, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);
  
<span class="udiff-line-added">+     enum class MinOrMax { Min, Max };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     PartialResult addFloatingPointMinOrMax(Type, MinOrMax, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+ </span>
      int32_t WARN_UNUSED_RETURN fixupPointerPlusOffset(ExpressionType&amp;, uint32_t);
  
      void restoreWasmContextInstance(BasicBlock*, TypedTmp);
      enum class RestoreCachedStackLimit { No, Yes };
      void restoreWebAssemblyGlobalState(RestoreCachedStackLimit, const MemoryInformation&amp;, TypedTmp instance, BasicBlock*);
  
      B3::Origin origin();
  
<span class="udiff-line-added">+     uint32_t outerLoopIndex() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_outerLoops.isEmpty())</span>
<span class="udiff-line-added">+             return UINT32_MAX;</span>
<span class="udiff-line-added">+         return m_outerLoops.last();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      FunctionParser&lt;AirIRGenerator&gt;* m_parser { nullptr };
      const ModuleInformation&amp; m_info;
      const MemoryMode m_mode { MemoryMode::BoundsChecking };
      const unsigned m_functionIndex { UINT_MAX };
<span class="udiff-line-modified-removed">-     const TierUpCount* m_tierUp { nullptr };</span>
<span class="udiff-line-modified-added">+     TierUpCount* m_tierUp { nullptr };</span>
  
      B3::Procedure&amp; m_proc;
      Code&amp; m_code;
<span class="udiff-line-added">+     Vector&lt;uint32_t&gt; m_outerLoops;</span>
      BasicBlock* m_currentBlock { nullptr };
      BasicBlock* m_rootBlock { nullptr };
      Vector&lt;TypedTmp&gt; m_locals;
      Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; m_unlinkedWasmToWasmCalls; // List each call site and the function index whose address it should be patched with.
      GPRReg m_memoryBaseGPR { InvalidGPRReg };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -595,19 +646,23 @@</span>
      bool m_makesCalls { false };
  
      Vector&lt;Tmp, 8&gt; m_freeGPs;
      Vector&lt;Tmp, 8&gt; m_freeFPs;
  
<span class="udiff-line-added">+     // This is only filled if we are dumping IR.</span>
<span class="udiff-line-added">+     Bag&lt;B3::PatchpointValue*&gt; m_patchpoints;</span>
<span class="udiff-line-added">+ </span>
      TypedTmp m_instanceValue; // Always use the accessor below to ensure the instance value is materialized when used.
      bool m_usesInstanceValue { false };
      TypedTmp instanceValue()
      {
          m_usesInstanceValue = true;
          return m_instanceValue;
      }
  
      uint32_t m_maxNumJSCallArguments { 0 };
<span class="udiff-line-added">+     unsigned m_numImportFunctions;</span>
  
      B3::PatchpointSpecial* m_patchpointSpecial { nullptr };
  };
  
  // Memory accesses in WebAssembly have unsigned 32-bit offsets, whereas they have signed 32-bit offsets in B3.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -659,10 +714,11 @@</span>
      , m_functionIndex(functionIndex)
      , m_tierUp(tierUp)
      , m_proc(procedure)
      , m_code(m_proc.code())
      , m_unlinkedWasmToWasmCalls(unlinkedWasmToWasmCalls)
<span class="udiff-line-added">+     , m_numImportFunctions(info.importFunctionCount())</span>
  {
      m_currentBlock = m_code.addBlock();
      m_rootBlock = m_currentBlock;
  
      // FIXME we don&#39;t really need to pin registers here if there&#39;s no memory. It makes wasm -&gt; wasm thunks simpler for now. https://bugs.webkit.org/show_bug.cgi?id=166623
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -674,14 +730,12 @@</span>
      m_wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
      if (!Context::useFastTLS())
          m_code.pinRegister(m_wasmContextInstanceGPR);
  
      if (mode != MemoryMode::Signaling) {
<span class="udiff-line-modified-removed">-         ASSERT(!pinnedRegs.sizeRegisters[0].sizeOffset);</span>
<span class="udiff-line-modified-removed">-         m_memorySizeGPR = pinnedRegs.sizeRegisters[0].sizeRegister;</span>
<span class="udiff-line-removed">-         for (const PinnedSizeRegisterInfo&amp; regInfo : pinnedRegs.sizeRegisters)</span>
<span class="udiff-line-removed">-             m_code.pinRegister(regInfo.sizeRegister);</span>
<span class="udiff-line-modified-added">+         m_memorySizeGPR = pinnedRegs.sizeRegister;</span>
<span class="udiff-line-modified-added">+         m_code.pinRegister(m_memorySizeGPR);</span>
      }
  
      if (throwWasmException)
          Thunks::singleton().setThrowWasmException(throwWasmException);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -781,10 +835,12 @@</span>
          switch (signature.argument(i)) {
          case Type::I32:
              append(Move32, arg, m_locals[i]);
              break;
          case Type::I64:
<span class="udiff-line-added">+         case Type::Anyref:</span>
<span class="udiff-line-added">+         case Type::Funcref:</span>
              append(Move, arg, m_locals[i]);
              break;
          case Type::F32:
              append(MoveFloat, arg, m_locals[i]);
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -794,11 +850,11 @@</span>
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      });
  
<span class="udiff-line-modified-removed">-     emitTierUpCheck(TierUpCount::functionEntryDecrement(), B3::Origin());</span>
<span class="udiff-line-modified-added">+     emitEntryTierUpCheck(TierUpCount::functionEntryIncrement(), B3::Origin());</span>
  }
  
  void AirIRGenerator::restoreWebAssemblyGlobalState(RestoreCachedStackLimit restoreCachedStackLimit, const MemoryInformation&amp; memory, TypedTmp instance, BasicBlock* block)
  {
      restoreWasmContextInstance(block, instance);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -817,29 +873,31 @@</span>
  
      if (!!memory) {
          const PinnedRegisterInfo* pinnedRegs = &amp;PinnedRegisterInfo::get();
          RegisterSet clobbers;
          clobbers.set(pinnedRegs-&gt;baseMemoryPointer);
<span class="udiff-line-modified-removed">-         for (auto info : pinnedRegs-&gt;sizeRegisters)</span>
<span class="udiff-line-modified-removed">-             clobbers.set(info.sizeRegister);</span>
<span class="udiff-line-modified-added">+         clobbers.set(pinnedRegs-&gt;sizeRegister);</span>
<span class="udiff-line-modified-added">+         if (!isARM64())</span>
<span class="udiff-line-added">+             clobbers.set(RegisterSet::macroScratchRegisters());</span>
  
          auto* patchpoint = addPatchpoint(B3::Void);
          B3::Effects effects = B3::Effects::none();
          effects.writesPinned = true;
          effects.reads = B3::HeapRange::top();
          patchpoint-&gt;effects = effects;
          patchpoint-&gt;clobber(clobbers);
<span class="udiff-line-added">+         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
  
          patchpoint-&gt;setGenerator([pinnedRegs] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
<span class="udiff-line-added">+             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
              GPRReg baseMemory = pinnedRegs-&gt;baseMemoryPointer;
<span class="udiff-line-modified-removed">-             const auto&amp; sizeRegs = pinnedRegs-&gt;sizeRegisters;</span>
<span class="udiff-line-modified-removed">-             ASSERT(sizeRegs.size() &gt;= 1);</span>
<span class="udiff-line-modified-removed">-             ASSERT(!sizeRegs[0].sizeOffset); // The following code assumes we start at 0, and calculates subsequent size registers relative to 0.</span>
<span class="udiff-line-removed">-             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemorySize()), sizeRegs[0].sizeRegister);</span>
<span class="udiff-line-modified-added">+             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs-&gt;sizeRegister;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemorySize()), pinnedRegs-&gt;sizeRegister);</span>
              jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemory()), baseMemory);
<span class="udiff-line-modified-removed">-             for (unsigned i = 1; i &lt; sizeRegs.size(); ++i)</span>
<span class="udiff-line-modified-removed">-                 jit.add64(CCallHelpers::TrustedImm32(-sizeRegs[i].sizeOffset), sizeRegs[0].sizeRegister, sizeRegs[i].sizeRegister);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs-&gt;sizeRegister, scratchOrSize);</span>
          });
  
          emitPatchpoint(block, patchpoint, Tmp(), instance);
      }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -854,19 +912,23 @@</span>
      });
  }
  
  auto AirIRGenerator::addLocal(Type type, uint32_t count) -&gt; PartialResult
  {
<span class="udiff-line-modified-removed">-     Checked&lt;uint32_t, RecordOverflow&gt; totalBytesChecked = count;</span>
<span class="udiff-line-modified-removed">-     totalBytesChecked += m_locals.size();</span>
<span class="udiff-line-modified-removed">-     uint32_t totalBytes;</span>
<span class="udiff-line-modified-removed">-     WASM_COMPILE_FAIL_IF((totalBytesChecked.safeGet(totalBytes) == CheckedState::DidOverflow) || !m_locals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; locals&quot;);</span>
<span class="udiff-line-modified-added">+     size_t newSize = m_locals.size() + count;</span>
<span class="udiff-line-modified-added">+     ASSERT(!(CheckedUint32(count) + m_locals.size()).hasOverflowed());</span>
<span class="udiff-line-modified-added">+     ASSERT(newSize &lt;= maxFunctionLocals);</span>
<span class="udiff-line-modified-added">+     WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(newSize), &quot;can&#39;t allocate memory for &quot;, newSize, &quot; locals&quot;);</span>
  
      for (uint32_t i = 0; i &lt; count; ++i) {
          auto local = tmpForType(type);
          m_locals.uncheckedAppend(local);
          switch (type) {
<span class="udiff-line-added">+         case Type::Anyref:</span>
<span class="udiff-line-added">+         case Type::Funcref:</span>
<span class="udiff-line-added">+             append(Move, Arg::imm(JSValue::encode(jsNull())), local);</span>
<span class="udiff-line-added">+             break;</span>
          case Type::I32:
          case Type::I64: {
              append(Xor64, local, local);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -894,10 +956,12 @@</span>
  {
      auto result = tmpForType(type);
      switch (type) {
      case Type::I32:
      case Type::I64:
<span class="udiff-line-added">+     case Type::Anyref:</span>
<span class="udiff-line-added">+     case Type::Funcref:</span>
          append(block, Move, Arg::bigImm(value), result);
          break;
      case Type::F32:
      case Type::F64: {
          auto tmp = g64();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -917,10 +981,115 @@</span>
  {
      RELEASE_ASSERT(m_locals.size() == signature.argumentCount()); // We handle arguments in the prologue
      return { };
  }
  
<span class="udiff-line-added">+ auto AirIRGenerator::addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(value.tmp());</span>
<span class="udiff-line-added">+     result = tmpForType(Type::I32);</span>
<span class="udiff-line-added">+     auto tmp = g64();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     append(Move, Arg::bigImm(JSValue::encode(jsNull())), tmp);</span>
<span class="udiff-line-added">+     append(Compare64, Arg::relCond(MacroAssembler::Equal), value, tmp, result);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto AirIRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+     result = tmpForType(Type::Funcref);</span>
<span class="udiff-line-added">+     emitCCall(&amp;doWasmRefFunc, result, instanceValue(), addConstant(Type::I32, index));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto AirIRGenerator::addTableGet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+     ASSERT(index.tmp());</span>
<span class="udiff-line-added">+     ASSERT(index.type() == Type::I32);</span>
<span class="udiff-line-added">+     result = tmpForType(m_info.tables[tableIndex].wasmType());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitCCall(&amp;getWasmTableElement, result, instanceValue(), addConstant(Type::I32, tableIndex), index);</span>
<span class="udiff-line-added">+     emitCheck([&amp;] {</span>
<span class="udiff-line-added">+         return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), result, result);</span>
<span class="udiff-line-added">+     }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+         this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto AirIRGenerator::addTableSet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; value) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+     ASSERT(index.tmp());</span>
<span class="udiff-line-added">+     ASSERT(index.type() == Type::I32);</span>
<span class="udiff-line-added">+     ASSERT(value.tmp());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto shouldThrow = g32();</span>
<span class="udiff-line-added">+     emitCCall(&amp;setWasmTableElement, shouldThrow, instanceValue(), addConstant(Type::I32, tableIndex), index, value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitCheck([&amp;] {</span>
<span class="udiff-line-added">+         return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), shouldThrow, shouldThrow);</span>
<span class="udiff-line-added">+     }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+         this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto AirIRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+     result = tmpForType(Type::I32);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int32_t (*doSize)(Instance*, unsigned) = [] (Instance* instance, unsigned tableIndex) -&gt; int32_t {</span>
<span class="udiff-line-added">+         return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitCCall(doSize, result, instanceValue(), addConstant(Type::I32, tableIndex));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto AirIRGenerator::addTableGrow(unsigned tableIndex, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(fill.tmp());</span>
<span class="udiff-line-added">+     ASSERT(isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()));</span>
<span class="udiff-line-added">+     ASSERT(delta.tmp());</span>
<span class="udiff-line-added">+     ASSERT(delta.type() == Type::I32);</span>
<span class="udiff-line-added">+     result = tmpForType(Type::I32);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitCCall(&amp;doWasmTableGrow, result, instanceValue(), addConstant(Type::I32, tableIndex), fill, delta);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto AirIRGenerator::addTableFill(unsigned tableIndex, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(fill.tmp());</span>
<span class="udiff-line-added">+     ASSERT(isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()));</span>
<span class="udiff-line-added">+     ASSERT(offset.tmp());</span>
<span class="udiff-line-added">+     ASSERT(offset.type() == Type::I32);</span>
<span class="udiff-line-added">+     ASSERT(count.tmp());</span>
<span class="udiff-line-added">+     ASSERT(count.type() == Type::I32);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto result = tmpForType(Type::I32);</span>
<span class="udiff-line-added">+     emitCCall(&amp;doWasmTableFill, result, instanceValue(), addConstant(Type::I32, tableIndex), offset, fill, count);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitCheck([&amp;] {</span>
<span class="udiff-line-added">+         return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), result, result);</span>
<span class="udiff-line-added">+     }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+         this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  auto AirIRGenerator::getLocal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
      ASSERT(m_locals[index].tmp());
      result = tmpForType(m_locals[index].type());
      append(moveOpForValueType(m_locals[index].type()), m_locals[index].tmp(), result);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1033,13 +1202,64 @@</span>
          append(Move, Arg::bigImm(offset), temp2);
          append(Add64, temp2, temp, temp);
          append(moveOpForValueType(type), value, Arg::addr(temp));
      }
  
<span class="udiff-line-added">+     if (isSubtype(type, Anyref))</span>
<span class="udiff-line-added">+         emitWriteBarrierForJSWrapper();</span>
<span class="udiff-line-added">+ </span>
      return { };
  }
  
<span class="udiff-line-added">+ inline void AirIRGenerator::emitWriteBarrierForJSWrapper()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto cell = g64();</span>
<span class="udiff-line-added">+     auto vm = g64();</span>
<span class="udiff-line-added">+     auto cellState = g32();</span>
<span class="udiff-line-added">+     auto threshold = g32();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BasicBlock* fenceCheckPath = m_code.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* fencePath = m_code.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* doSlowPath = m_code.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* continuation = m_code.addBlock();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     append(Move, Arg::addr(instanceValue(), Instance::offsetOfOwner()), cell);</span>
<span class="udiff-line-added">+     append(Move, Arg::addr(cell, JSWebAssemblyInstance::offsetOfVM()), vm);</span>
<span class="udiff-line-added">+     append(Load8, Arg::addr(cell, JSCell::cellStateOffset()), cellState);</span>
<span class="udiff-line-added">+     append(Move32, Arg::addr(vm, VM::offsetOfHeapBarrierThreshold()), threshold);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     append(Branch32, Arg::relCond(MacroAssembler::Above), cellState, threshold);</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;setSuccessors(continuation, fenceCheckPath);</span>
<span class="udiff-line-added">+     m_currentBlock = fenceCheckPath;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     append(Load8, Arg::addr(vm, VM::offsetOfHeapMutatorShouldBeFenced()), threshold);</span>
<span class="udiff-line-added">+     append(BranchTest32, Arg::resCond(MacroAssembler::Zero), threshold, threshold);</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;setSuccessors(doSlowPath, fencePath);</span>
<span class="udiff-line-added">+     m_currentBlock = fencePath;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* doFence = addPatchpoint(B3::Void);</span>
<span class="udiff-line-added">+     doFence-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+         jit.memoryFence();</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+     emitPatchpoint(doFence, Tmp());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     append(Load8, Arg::addr(cell, JSCell::cellStateOffset()), cellState);</span>
<span class="udiff-line-added">+     append(Branch32, Arg::relCond(MacroAssembler::Above), cellState, Arg::imm(blackThreshold));</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;setSuccessors(continuation, doSlowPath);</span>
<span class="udiff-line-added">+     m_currentBlock = doSlowPath;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void (*writeBarrier)(JSWebAssemblyInstance*, VM*) = [] (JSWebAssemblyInstance* cell, VM* vm) -&gt; void {</span>
<span class="udiff-line-added">+         ASSERT(cell);</span>
<span class="udiff-line-added">+         ASSERT(vm);</span>
<span class="udiff-line-added">+         vm-&gt;heap.writeBarrierSlowPath(cell);</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+     emitCCall(writeBarrier, TypedTmp(), cell, vm);</span>
<span class="udiff-line-added">+     append(Jump);</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-added">+     m_currentBlock = continuation;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline AirIRGenerator::ExpressionType AirIRGenerator::emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOperation)
  {
      ASSERT(m_memoryBaseGPR);
  
      auto result = g64();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1381,38 +1601,33 @@</span>
      m_currentBlock = continuation;
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- void AirIRGenerator::emitTierUpCheck(uint32_t decrementCount, B3::Origin origin)</span>
<span class="udiff-line-modified-added">+ void AirIRGenerator::emitEntryTierUpCheck(int32_t incrementCount, B3::Origin origin)</span>
  {
      UNUSED_PARAM(origin);
  
      if (!m_tierUp)
          return;
  
      auto countdownPtr = g64();
<span class="udiff-line-removed">-     auto oldCountdown = g64();</span>
<span class="udiff-line-removed">-     auto newCountdown = g64();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(Move, Arg::bigImm(reinterpret_cast&lt;uint64_t&gt;(m_tierUp)), countdownPtr);</span>
<span class="udiff-line-removed">-     append(Move32, Arg::addr(countdownPtr), oldCountdown);</span>
  
<span class="udiff-line-modified-removed">-     RELEASE_ASSERT(Arg::isValidImmForm(decrementCount));</span>
<span class="udiff-line-removed">-     append(Move32, oldCountdown, newCountdown);</span>
<span class="udiff-line-removed">-     append(Sub32, Arg::imm(decrementCount), newCountdown);</span>
<span class="udiff-line-removed">-     append(Move32, newCountdown, Arg::addr(countdownPtr));</span>
<span class="udiff-line-modified-added">+     append(Move, Arg::bigImm(reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter)), countdownPtr);</span>
  
      auto* patch = addPatchpoint(B3::Void);
      B3::Effects effects = B3::Effects::none();
      effects.reads = B3::HeapRange::top();
      effects.writes = B3::HeapRange::top();
      patch-&gt;effects = effects;
<span class="udiff-line-added">+     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
  
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
<span class="udiff-line-modified-removed">-         MacroAssembler::Jump tierUp = jit.branch32(MacroAssembler::Above, params[0].gpr(), params[1].gpr());</span>
<span class="udiff-line-modified-removed">-         MacroAssembler::Label tierUpResume = jit.label();</span>
<span class="udiff-line-modified-added">+         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="udiff-line-added">+         CCallHelpers::Label tierUpResume = jit.label();</span>
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              tierUp.link(&amp;jit);
  
              const unsigned extraPaddingBytes = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1425,29 +1640,98 @@</span>
  
              ScratchRegisterAllocator::restoreRegistersFromStackForCall(jit, registersToSpill, RegisterSet(), numberOfStackBytesUsedForRegisterPreservation, extraPaddingBytes);
              jit.jump(tierUpResume);
  
              jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-                 MacroAssembler::repatchNearCall(linkBuffer.locationOfNearCall&lt;NoPtrTag&gt;(call), CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(triggerOMGTierUpThunkGenerator).code()));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+                 MacroAssembler::repatchNearCall(linkBuffer.locationOfNearCall&lt;NoPtrTag&gt;(call), CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(triggerOMGEntryTierUpThunkGenerator).code()));</span>
              });
          });
      });
  
<span class="udiff-line-modified-removed">-     emitPatchpoint(patch, Tmp(), newCountdown, oldCountdown);</span>
<span class="udiff-line-modified-added">+     emitPatchpoint(patch, Tmp(), countdownPtr);</span>
  }
  
<span class="udiff-line-modified-removed">- AirIRGenerator::ControlData AirIRGenerator::addLoop(Type signature)</span>
<span class="udiff-line-modified-added">+ void AirIRGenerator::emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp; expressionStack, uint32_t loopIndex, uint32_t outerLoopIndex, B3::Origin origin)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     UNUSED_PARAM(origin);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!m_tierUp)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);</span>
<span class="udiff-line-added">+     m_tierUp-&gt;osrEntryTriggers().append(TierUpCount::TriggerReason::DontTrigger);</span>
<span class="udiff-line-added">+     m_tierUp-&gt;outerLoops().append(outerLoopIndex);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto countdownPtr = g64();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     append(Move, Arg::bigImm(reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter)), countdownPtr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* patch = addPatchpoint(B3::Void);</span>
<span class="udiff-line-added">+     B3::Effects effects = B3::Effects::none();</span>
<span class="udiff-line-added">+     effects.reads = B3::HeapRange::top();</span>
<span class="udiff-line-added">+     effects.writes = B3::HeapRange::top();</span>
<span class="udiff-line-added">+     effects.exitsSideways = true;</span>
<span class="udiff-line-added">+     patch-&gt;effects = effects;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
<span class="udiff-line-added">+     RegisterSet clobberLate;</span>
<span class="udiff-line-added">+     clobberLate.add(GPRInfo::argumentGPR0);</span>
<span class="udiff-line-added">+     patch-&gt;clobberLate(clobberLate);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Vector&lt;ConstrainedTmp&gt; patchArgs;</span>
<span class="udiff-line-added">+     patchArgs.append(countdownPtr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Vector&lt;B3::Type&gt; types;</span>
<span class="udiff-line-added">+     for (auto&amp; local : m_locals) {</span>
<span class="udiff-line-added">+         patchArgs.append(ConstrainedTmp(local, B3::ValueRep::ColdAny));</span>
<span class="udiff-line-added">+         types.append(toB3Type(local.type()));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     for (auto&amp; expression : expressionStack) {</span>
<span class="udiff-line-added">+         patchArgs.append(ConstrainedTmp(expression, B3::ValueRep::ColdAny));</span>
<span class="udiff-line-added">+         types.append(toB3Type(expression.type()));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     TierUpCount::TriggerReason* forceEntryTrigger = &amp;(m_tierUp-&gt;osrEntryTriggers().last());</span>
<span class="udiff-line-added">+     static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);</span>
<span class="udiff-line-added">+     static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);</span>
<span class="udiff-line-added">+     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
<span class="udiff-line-added">+         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="udiff-line-added">+         CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));</span>
<span class="udiff-line-added">+         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="udiff-line-added">+         MacroAssembler::Label tierUpResume = jit.label();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);</span>
<span class="udiff-line-added">+         for (unsigned index = 0; index &lt; types.size(); ++index)</span>
<span class="udiff-line-added">+             osrEntryData.values().constructAndAppend(params[index + 1], types[index]);</span>
<span class="udiff-line-added">+         OSREntryData* osrEntryDataPtr = &amp;osrEntryData;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         params.addLatePath([=] (CCallHelpers&amp; jit) {</span>
<span class="udiff-line-added">+             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="udiff-line-added">+             forceOSREntry.link(&amp;jit);</span>
<span class="udiff-line-added">+             tierUp.link(&amp;jit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             jit.probe(triggerOSREntryNow, osrEntryDataPtr);</span>
<span class="udiff-line-added">+             jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);</span>
<span class="udiff-line-added">+             jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitPatchpoint(patch, Tmp(), WTFMove(patchArgs));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ AirIRGenerator::ControlData AirIRGenerator::addLoop(Type signature, const Stack&amp; expressionStack, uint32_t loopIndex)</span>
  {
      BasicBlock* body = m_code.addBlock();
      BasicBlock* continuation = m_code.addBlock();
  
      append(Jump);
      m_currentBlock-&gt;setSuccessors(body);
  
<span class="udiff-line-added">+     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="udiff-line-added">+     m_outerLoops.append(loopIndex);</span>
      m_currentBlock = body;
<span class="udiff-line-modified-removed">-     emitTierUpCheck(TierUpCount::loopDecrement(), origin());</span>
<span class="udiff-line-modified-added">+     emitLoopTierUpCheck(TierUpCount::loopIncrement(), expressionStack, loopIndex, outerLoopIndex, origin());</span>
  
      return ControlData(origin(), signature, tmpForType(signature), BlockType::Loop, continuation, body);
  }
  
  AirIRGenerator::ControlData AirIRGenerator::addTopLevel(Type signature)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1473,11 +1757,11 @@</span>
      m_currentBlock = taken;
      result = ControlData(origin(), signature, tmpForType(signature), BlockType::If, continuation, notTaken);
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto AirIRGenerator::addElse(ControlData&amp; data, const ExpressionList&amp; currentStack) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto AirIRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult</span>
  {
      unifyValuesWithBlock(currentStack, data.result);
      append(Jump);
      m_currentBlock-&gt;setSuccessors(data.continuation);
      return addElseToUnreachable(data);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1501,10 +1785,12 @@</span>
          case Type::I32:
              append(Move32, returnValues[0], returnValueGPR);
              append(Ret32, returnValueGPR);
              break;
          case Type::I64:
<span class="udiff-line-added">+         case Type::Anyref:</span>
<span class="udiff-line-added">+         case Type::Funcref:</span>
              append(Move, returnValues[0], returnValueGPR);
              append(Ret64, returnValueGPR);
              break;
          case Type::F32:
              append(MoveFloat, returnValues[0], returnValueFPR);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1522,11 +1808,11 @@</span>
      return { };
  }
  
  // NOTE: All branches in Wasm are on 32-bit ints
  
<span class="udiff-line-modified-removed">- auto AirIRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const ExpressionList&amp; returnValues) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto AirIRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult</span>
  {
      unifyValuesWithBlock(returnValues, data.resultForBranch());
  
      BasicBlock* target = data.targetBlockForBranch();
      if (condition) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1540,11 +1826,11 @@</span>
      }
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto AirIRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const ExpressionList&amp; expressionStack) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto AirIRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult</span>
  {
      auto&amp; successors = m_currentBlock-&gt;successors();
      ASSERT(successors.isEmpty());
      for (const auto&amp; target : targets) {
          unifyValuesWithBlock(expressionStack, target-&gt;resultForBranch());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1603,11 +1889,11 @@</span>
      emitPatchpoint(patchpoint, TypedTmp(), condition);
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto AirIRGenerator::endBlock(ControlEntry&amp; entry, ExpressionList&amp; expressionStack) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto AirIRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult</span>
  {
      ControlData&amp; data = entry.controlData;
  
      unifyValuesWithBlock(expressionStack, data.result);
      append(Jump);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1625,10 +1911,13 @@</span>
      if (data.type() == BlockType::If) {
          append(data.special, Jump);
          data.special-&gt;setSuccessors(m_currentBlock);
      }
  
<span class="udiff-line-added">+     if (data.type() == BlockType::Loop)</span>
<span class="udiff-line-added">+         m_outerLoops.removeLast();</span>
<span class="udiff-line-added">+ </span>
      for (const auto&amp; result : data.result)
          entry.enclosedExpressionStack.append(result);
  
      // TopLevel does not have any code after this so we need to make sure we emit a return here.
      if (data.type() == BlockType::TopLevel)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1753,14 +2042,16 @@</span>
      }
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto AirIRGenerator::addCallIndirect(const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto AirIRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ExpressionType calleeIndex = args.takeLast();
      ASSERT(signature.argumentCount() == args.size());
<span class="udiff-line-added">+     ASSERT(m_info.tableCount() &gt; tableIndex);</span>
<span class="udiff-line-added">+     ASSERT(m_info.tables[tableIndex].type() == TableElementType::Funcref);</span>
  
      m_makesCalls = true;
      // Note: call indirect can call either WebAssemblyFunction or WebAssemblyWrapperFunction. Because
      // WebAssemblyWrapperFunction is like calling into the embedder, we conservatively assume all call indirects
      // can be to the embedder for our stack check calculation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1771,18 +2062,22 @@</span>
  
      ExpressionType callableFunctionBuffer = g64();
      ExpressionType instancesBuffer = g64();
      ExpressionType callableFunctionBufferLength = g64();
      {
<span class="udiff-line-modified-removed">-         RELEASE_ASSERT(Arg::isValidAddrForm(Instance::offsetOfTable(), B3::Width64));</span>
<span class="udiff-line-modified-removed">-         RELEASE_ASSERT(Arg::isValidAddrForm(Table::offsetOfFunctions(), B3::Width64));</span>
<span class="udiff-line-modified-removed">-         RELEASE_ASSERT(Arg::isValidAddrForm(Table::offsetOfInstances(), B3::Width64));</span>
<span class="udiff-line-modified-removed">-         RELEASE_ASSERT(Arg::isValidAddrForm(Table::offsetOfLength(), B3::Width64));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         append(Move, Arg::addr(instanceValue(), Instance::offsetOfTable()), callableFunctionBufferLength);</span>
<span class="udiff-line-modified-removed">-         append(Move, Arg::addr(callableFunctionBufferLength, Table::offsetOfFunctions()), callableFunctionBuffer);</span>
<span class="udiff-line-modified-removed">-         append(Move, Arg::addr(callableFunctionBufferLength, Table::offsetOfInstances()), instancesBuffer);</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(Arg::isValidAddrForm(FuncRefTable::offsetOfFunctions(), B3::Width64));</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(Arg::isValidAddrForm(FuncRefTable::offsetOfInstances(), B3::Width64));</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(Arg::isValidAddrForm(FuncRefTable::offsetOfLength(), B3::Width64));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (UNLIKELY(!Arg::isValidAddrForm(Instance::offsetOfTablePtr(m_numImportFunctions, tableIndex), B3::Width64))) {</span>
<span class="udiff-line-modified-added">+             append(Move, Arg::bigImm(Instance::offsetOfTablePtr(m_numImportFunctions, tableIndex)), callableFunctionBufferLength);</span>
<span class="udiff-line-modified-added">+             append(Add64, instanceValue(), callableFunctionBufferLength);</span>
<span class="udiff-line-modified-added">+             append(Move, Arg::addr(callableFunctionBufferLength), callableFunctionBufferLength);</span>
<span class="udiff-line-added">+         } else</span>
<span class="udiff-line-added">+             append(Move, Arg::addr(instanceValue(), Instance::offsetOfTablePtr(m_numImportFunctions, tableIndex)), callableFunctionBufferLength);</span>
<span class="udiff-line-added">+         append(Move, Arg::addr(callableFunctionBufferLength, FuncRefTable::offsetOfFunctions()), callableFunctionBuffer);</span>
<span class="udiff-line-added">+         append(Move, Arg::addr(callableFunctionBufferLength, FuncRefTable::offsetOfInstances()), instancesBuffer);</span>
          append(Move32, Arg::addr(callableFunctionBufferLength, Table::offsetOfLength()), callableFunctionBufferLength);
      }
  
      append(Move32, calleeIndex, calleeIndex);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1844,29 +2139,31 @@</span>
          patchpoint-&gt;effects.writesPinned = true;
          // We pessimistically assume we&#39;re calling something with BoundsChecking memory.
          // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
          patchpoint-&gt;clobber(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="udiff-line-added">+         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
<span class="udiff-line-added">+ </span>
          patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              GPRReg newContextInstance = params[0].gpr();
              GPRReg oldContextInstance = params[1].gpr();
              const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
<span class="udiff-line-removed">-             const auto&amp; sizeRegs = pinnedRegs.sizeRegisters;</span>
              GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
              ASSERT(newContextInstance != baseMemory);
              jit.loadPtr(CCallHelpers::Address(oldContextInstance, Instance::offsetOfCachedStackLimit()), baseMemory);
              jit.storePtr(baseMemory, CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedStackLimit()));
              jit.storeWasmContextInstance(newContextInstance);
<span class="udiff-line-removed">-             ASSERT(sizeRegs[0].sizeRegister != baseMemory);</span>
              // FIXME: We should support more than one memory size register
              //   see: https://bugs.webkit.org/show_bug.cgi?id=162952
<span class="udiff-line-modified-removed">-             ASSERT(sizeRegs.size() == 1);</span>
<span class="udiff-line-modified-removed">-             ASSERT(sizeRegs[0].sizeRegister != newContextInstance);</span>
<span class="udiff-line-modified-removed">-             ASSERT(!sizeRegs[0].sizeOffset);</span>
<span class="udiff-line-modified-removed">-             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemorySize()), sizeRegs[0].sizeRegister); // Memory size.</span>
<span class="udiff-line-modified-added">+             ASSERT(pinnedRegs.sizeRegister != newContextInstance);</span>
<span class="udiff-line-modified-added">+             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs.sizeRegister;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister); // Memory size.</span>
              jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemory()), baseMemory); // Memory::void*.
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs.sizeRegister, scratchOrSize);</span>
          });
  
          emitPatchpoint(doContextSwitch, patchpoint, Tmp(), newContextInstance, instanceValue());
          append(doContextSwitch, Jump);
          doContextSwitch-&gt;setSuccessors(continuation);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1908,23 +2205,23 @@</span>
      return { };
  }
  
  void AirIRGenerator::unify(const ExpressionType&amp; dst, const ExpressionType&amp; source)
  {
<span class="udiff-line-modified-removed">-     ASSERT(dst.type() == source.type());</span>
<span class="udiff-line-modified-added">+     ASSERT(isSubtype(source.type(), dst.type()));</span>
      append(moveOpForValueType(dst.type()), source, dst);
  }
  
<span class="udiff-line-modified-removed">- void AirIRGenerator::unifyValuesWithBlock(const ExpressionList&amp; resultStack, const ResultList&amp; result)</span>
<span class="udiff-line-modified-added">+ void AirIRGenerator::unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; result)</span>
  {
      ASSERT(result.size() &lt;= resultStack.size());
  
      for (size_t i = 0; i &lt; result.size(); ++i)
          unify(result[result.size() - 1 - i], resultStack[resultStack.size() - 1 - i]);
  }
  
<span class="udiff-line-modified-removed">- void AirIRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp;, const ExpressionList*)</span>
<span class="udiff-line-modified-added">+ void AirIRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp;, const Stack*)</span>
  {
  }
  
  auto AirIRGenerator::origin() -&gt; B3::Origin
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1932,14 +2229,14 @@</span>
      return B3::Origin();
  }
  
  Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileAir(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, uint32_t functionIndex, TierUpCount* tierUp, ThrowWasmException throwWasmException)
  {
<span class="udiff-line-modified-removed">-     auto result = std::make_unique&lt;InternalFunction&gt;();</span>
<span class="udiff-line-modified-added">+     auto result = makeUnique&lt;InternalFunction&gt;();</span>
  
<span class="udiff-line-modified-removed">-     compilationContext.embedderEntrypointJIT = std::make_unique&lt;CCallHelpers&gt;();</span>
<span class="udiff-line-modified-removed">-     compilationContext.wasmEntrypointJIT = std::make_unique&lt;CCallHelpers&gt;();</span>
<span class="udiff-line-modified-added">+     compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
<span class="udiff-line-modified-added">+     compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
  
      B3::Procedure procedure;
      Code&amp; code = procedure.code();
  
      procedure.setOriginPrinter([] (PrintStream&amp; out, B3::Origin origin) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1951,11 +2248,11 @@</span>
      // StackmapGenerationParams::unavailableRegisters(). In exchange for this concession, we
      // don&#39;t strictly need to run Air::reportUsedRegisters(), which saves a bit of CPU time at
      // optLevel=1.
      procedure.setNeedsUsedRegisters(false);
  
<span class="udiff-line-modified-removed">-     procedure.setOptLevel(Options::webAssemblyBBQOptimizationLevel());</span>
<span class="udiff-line-modified-added">+     procedure.setOptLevel(Options::webAssemblyBBQAirOptimizationLevel());</span>
  
      AirIRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, mode, functionIndex, tierUp, throwWasmException, signature);
      FunctionParser&lt;AirIRGenerator&gt; parser(irGenerator, functionStart, functionLength, signature, info);
      WASM_FAIL_IF_HELPER_FAILS(parser.parse());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1964,17 +2261,23 @@</span>
          for (size_t i = 0; i &lt; block-&gt;numSuccessors(); ++i)
              block-&gt;successorBlock(i)-&gt;addPredecessor(block);
      }
  
      {
<span class="udiff-line-added">+         if (UNLIKELY(shouldDumpIRAtEachPhase(B3::AirMode))) {</span>
<span class="udiff-line-added">+             dataLogLn(&quot;Generated patchpoints&quot;);</span>
<span class="udiff-line-added">+             for (B3::PatchpointValue** patch : irGenerator.patchpoints())</span>
<span class="udiff-line-added">+                 dataLogLn(deepDump(procedure, *patch));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          B3::Air::prepareForGeneration(code);
          B3::Air::generate(code, *compilationContext.wasmEntrypointJIT);
          compilationContext.wasmEntrypointByproducts = procedure.releaseByproducts();
          result-&gt;entrypoint.calleeSaveRegisters = code.calleeSaveRegisterAtOffsetList();
      }
  
<span class="udiff-line-modified-removed">-     return WTFMove(result);</span>
<span class="udiff-line-modified-added">+     return result;</span>
  }
  
  template &lt;typename IntType&gt;
  void AirIRGenerator::emitChecksForModOrDiv(bool isSignedDiv, ExpressionType left, ExpressionType right)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2741,35 +3044,11 @@</span>
      return { };
  }
  
  template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F32Min&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="udiff-line-modified-removed">-     result = f32();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     BasicBlock* isEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* notEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* greaterThanOrEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* continuation = m_code.addBlock();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(m_currentBlock, BranchFloat, Arg::doubleCond(MacroAssembler::DoubleEqual), arg0, arg1);</span>
<span class="udiff-line-removed">-     m_currentBlock-&gt;setSuccessors(isEqual, notEqual);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(isEqual, OrFloat, arg0, arg1, result);</span>
<span class="udiff-line-removed">-     append(isEqual, Jump);</span>
<span class="udiff-line-removed">-     isEqual-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(notEqual, MoveFloat, arg0, result);</span>
<span class="udiff-line-removed">-     append(notEqual, BranchFloat, Arg::doubleCond(MacroAssembler::DoubleLessThan), arg0, arg1);</span>
<span class="udiff-line-removed">-     notEqual-&gt;setSuccessors(continuation, greaterThanOrEqual);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(greaterThanOrEqual, MoveFloat, arg1, result);</span>
<span class="udiff-line-removed">-     append(greaterThanOrEqual, Jump);</span>
<span class="udiff-line-removed">-     greaterThanOrEqual-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_currentBlock = continuation;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return { };</span>
<span class="udiff-line-modified-added">+     return addFloatingPointMinOrMax(F32, MinOrMax::Min, arg0, arg1, result);</span>
  }
  
  template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F64Ne&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult
  {
      result = g32();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2782,39 +3061,64 @@</span>
      result = g32();
      append(CompareDouble, Arg::doubleCond(MacroAssembler::DoubleLessThan), arg0, arg1, result);
      return { };
  }
  
<span class="udiff-line-modified-removed">- template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F32Max&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto AirIRGenerator::addFloatingPointMinOrMax(Type floatType, MinOrMax minOrMax, ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
<span class="udiff-line-modified-removed">-     result = f32();</span>
<span class="udiff-line-modified-added">+     ASSERT(floatType == F32 || floatType == F64);</span>
<span class="udiff-line-added">+     result = tmpForType(floatType);</span>
  
      BasicBlock* isEqual = m_code.addBlock();
      BasicBlock* notEqual = m_code.addBlock();
<span class="udiff-line-modified-removed">-     BasicBlock* lessThan = m_code.addBlock();</span>
<span class="udiff-line-modified-added">+     BasicBlock* isLessThan = m_code.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* notLessThan = m_code.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* isGreaterThan = m_code.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* isNaN = m_code.addBlock();</span>
      BasicBlock* continuation = m_code.addBlock();
  
<span class="udiff-line-modified-removed">-     append(m_currentBlock, BranchFloat, Arg::doubleCond(MacroAssembler::DoubleEqual), arg0, arg1);</span>
<span class="udiff-line-modified-added">+     auto branchOp = floatType == F32 ? BranchFloat : BranchDouble;</span>
<span class="udiff-line-added">+     append(m_currentBlock, branchOp, Arg::doubleCond(MacroAssembler::DoubleEqual), arg0, arg1);</span>
      m_currentBlock-&gt;setSuccessors(isEqual, notEqual);
  
<span class="udiff-line-modified-removed">-     append(isEqual, AndFloat, arg0, arg1, result);</span>
<span class="udiff-line-modified-added">+     append(notEqual, branchOp, Arg::doubleCond(MacroAssembler::DoubleLessThan), arg0, arg1);</span>
<span class="udiff-line-added">+     notEqual-&gt;setSuccessors(isLessThan, notLessThan);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     append(notLessThan, branchOp, Arg::doubleCond(MacroAssembler::DoubleGreaterThan), arg0, arg1);</span>
<span class="udiff-line-added">+     notLessThan-&gt;setSuccessors(isGreaterThan, isNaN);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto andOp = floatType == F32 ? AndFloat : AndDouble;</span>
<span class="udiff-line-added">+     auto orOp = floatType == F32 ? OrFloat : OrDouble;</span>
<span class="udiff-line-added">+     append(isEqual, minOrMax == MinOrMax::Max ? andOp : orOp, arg0, arg1, result);</span>
      append(isEqual, Jump);
      isEqual-&gt;setSuccessors(continuation);
  
<span class="udiff-line-modified-removed">-     append(notEqual, MoveFloat, arg0, result);</span>
<span class="udiff-line-modified-removed">-     append(notEqual, BranchFloat, Arg::doubleCond(MacroAssembler::DoubleLessThan), arg0, arg1);</span>
<span class="udiff-line-modified-removed">-     notEqual-&gt;setSuccessors(lessThan, continuation);</span>
<span class="udiff-line-modified-added">+     auto isLessThanResult = minOrMax == MinOrMax::Max ? arg1 : arg0;</span>
<span class="udiff-line-modified-added">+     append(isLessThan, moveOpForValueType(floatType), isLessThanResult, result);</span>
<span class="udiff-line-modified-added">+     append(isLessThan, Jump);</span>
<span class="udiff-line-added">+     isLessThan-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto isGreaterThanResult = minOrMax == MinOrMax::Max ? arg0 : arg1;</span>
<span class="udiff-line-added">+     append(isGreaterThan, moveOpForValueType(floatType), isGreaterThanResult, result);</span>
<span class="udiff-line-added">+     append(isGreaterThan, Jump);</span>
<span class="udiff-line-added">+     isGreaterThan-&gt;setSuccessors(continuation);</span>
  
<span class="udiff-line-modified-removed">-     append(lessThan, MoveFloat, arg1, result);</span>
<span class="udiff-line-modified-removed">-     append(lessThan, Jump);</span>
<span class="udiff-line-modified-removed">-     lessThan-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-modified-added">+     auto addOp = floatType == F32 ? AddFloat : AddDouble;</span>
<span class="udiff-line-modified-added">+     append(isNaN, addOp, arg0, arg1, result);</span>
<span class="udiff-line-modified-added">+     append(isNaN, Jump);</span>
<span class="udiff-line-added">+     isNaN-&gt;setSuccessors(continuation);</span>
  
      m_currentBlock = continuation;
  
      return { };
  }
  
<span class="udiff-line-added">+ template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F32Max&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return addFloatingPointMinOrMax(F32, MinOrMax::Max, arg0, arg1, result);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F64Mul&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult
  {
      return addFloatingPointBinOp(Type::F64, MulDouble, arg0, arg1, result);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3168,35 +3472,11 @@</span>
      return addFloatingPointAbs(AbsFloat, arg0, result);
  }
  
  template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F64Min&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="udiff-line-modified-removed">-     result = f64();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     BasicBlock* isEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* notEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* greaterThanOrEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* continuation = m_code.addBlock();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(m_currentBlock, BranchDouble, Arg::doubleCond(MacroAssembler::DoubleEqual), arg0, arg1);</span>
<span class="udiff-line-removed">-     m_currentBlock-&gt;setSuccessors(isEqual, notEqual);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(isEqual, OrDouble, arg0, arg1, result);</span>
<span class="udiff-line-removed">-     append(isEqual, Jump);</span>
<span class="udiff-line-removed">-     isEqual-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(notEqual, MoveDouble, arg0, result);</span>
<span class="udiff-line-removed">-     append(notEqual, BranchDouble, Arg::doubleCond(MacroAssembler::DoubleLessThan), arg0, arg1);</span>
<span class="udiff-line-removed">-     notEqual-&gt;setSuccessors(continuation, greaterThanOrEqual);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(greaterThanOrEqual, MoveDouble, arg1, result);</span>
<span class="udiff-line-removed">-     append(greaterThanOrEqual, Jump);</span>
<span class="udiff-line-removed">-     greaterThanOrEqual-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_currentBlock = continuation;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return { };</span>
<span class="udiff-line-modified-added">+     return addFloatingPointMinOrMax(F64, MinOrMax::Min, arg0, arg1, result);</span>
  }
  
  template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F32Mul&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult
  {
      result = f32();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3464,35 +3744,11 @@</span>
      return { };
  }
  
  template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::F64Max&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="udiff-line-modified-removed">-     result = f64();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     BasicBlock* isEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* notEqual = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* lessThan = m_code.addBlock();</span>
<span class="udiff-line-removed">-     BasicBlock* continuation = m_code.addBlock();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(m_currentBlock, BranchDouble, Arg::doubleCond(MacroAssembler::DoubleEqual), arg0, arg1);</span>
<span class="udiff-line-removed">-     m_currentBlock-&gt;setSuccessors(isEqual, notEqual);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(isEqual, AndDouble, arg0, arg1, result);</span>
<span class="udiff-line-removed">-     append(isEqual, Jump);</span>
<span class="udiff-line-removed">-     isEqual-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(notEqual, MoveDouble, arg0, result);</span>
<span class="udiff-line-removed">-     append(notEqual, BranchDouble, Arg::doubleCond(MacroAssembler::DoubleLessThan), arg0, arg1);</span>
<span class="udiff-line-removed">-     notEqual-&gt;setSuccessors(lessThan, continuation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     append(lessThan, MoveDouble, arg1, result);</span>
<span class="udiff-line-removed">-     append(lessThan, Jump);</span>
<span class="udiff-line-removed">-     lessThan-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_currentBlock = continuation;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return { };</span>
<span class="udiff-line-modified-added">+     return addFloatingPointMinOrMax(F64, MinOrMax::Max, arg0, arg1, result);</span>
  }
  
  template&lt;&gt; auto AirIRGenerator::addOp&lt;OpType::I64LeU&gt;(ExpressionType arg0, ExpressionType arg1, ExpressionType&amp; result) -&gt; PartialResult
  {
      result = g32();
</pre>
<center><a href="../tools/VMInspector.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>