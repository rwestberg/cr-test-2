<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
   3  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;InspectorNetworkAgent.h&quot;
  34 
  35 #include &quot;CachedCSSStyleSheet.h&quot;
  36 #include &quot;CachedRawResource.h&quot;
  37 #include &quot;CachedResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;CachedResourceRequestInitiators.h&quot;
  40 #include &quot;CachedScript.h&quot;
  41 #include &quot;CertificateInfo.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;DocumentLoader.h&quot;
  44 #include &quot;DocumentThreadableLoader.h&quot;
  45 #include &quot;Frame.h&quot;
  46 #include &quot;FrameLoader.h&quot;
  47 #include &quot;HTTPHeaderMap.h&quot;
  48 #include &quot;HTTPHeaderNames.h&quot;
  49 #include &quot;InspectorDOMAgent.h&quot;
  50 #include &quot;InspectorTimelineAgent.h&quot;
  51 #include &quot;InstrumentingAgents.h&quot;
  52 #include &quot;JSExecState.h&quot;
  53 #include &quot;JSWebSocket.h&quot;
  54 #include &quot;LoaderStrategy.h&quot;
  55 #include &quot;MIMETypeRegistry.h&quot;
  56 #include &quot;MemoryCache.h&quot;
  57 #include &quot;NetworkResourcesData.h&quot;
  58 #include &quot;Page.h&quot;
  59 #include &quot;PlatformStrategies.h&quot;
  60 #include &quot;ProgressTracker.h&quot;
  61 #include &quot;ResourceError.h&quot;
  62 #include &quot;ResourceLoader.h&quot;
  63 #include &quot;ResourceRequest.h&quot;
  64 #include &quot;ResourceResponse.h&quot;
  65 #include &quot;RuntimeEnabledFeatures.h&quot;
  66 #include &quot;ScriptState.h&quot;
  67 #include &quot;ScriptableDocumentParser.h&quot;
  68 #include &quot;SubresourceLoader.h&quot;
  69 #include &quot;TextResourceDecoder.h&quot;
  70 #include &quot;ThreadableLoaderClient.h&quot;
  71 #include &lt;wtf/URL.h&gt;
  72 #include &quot;WebSocket.h&quot;
  73 #include &quot;WebSocketChannel.h&quot;
  74 #include &quot;WebSocketFrame.h&quot;
  75 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  76 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  77 #include &lt;JavaScriptCore/InjectedScript.h&gt;
  78 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
  79 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  80 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  81 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  82 #include &lt;wtf/JSONValues.h&gt;
  83 #include &lt;wtf/Lock.h&gt;
  84 #include &lt;wtf/RefPtr.h&gt;
  85 #include &lt;wtf/Stopwatch.h&gt;
  86 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
  87 #include &lt;wtf/text/Base64.h&gt;
  88 #include &lt;wtf/text/StringBuilder.h&gt;
  89 
  90 typedef Inspector::NetworkBackendDispatcherHandler::LoadResourceCallback LoadResourceCallback;
  91 
  92 namespace WebCore {
  93 
  94 using namespace Inspector;
  95 
  96 namespace {
  97 
  98 class InspectorThreadableLoaderClient final : public ThreadableLoaderClient {
  99     WTF_MAKE_NONCOPYABLE(InspectorThreadableLoaderClient);
 100 public:
 101     InspectorThreadableLoaderClient(RefPtr&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 102         : m_callback(WTFMove(callback))
 103     {
 104     }
 105 
 106     virtual ~InspectorThreadableLoaderClient() = default;
 107 
 108     void didReceiveResponse(unsigned long, const ResourceResponse&amp; response) override
 109     {
 110         m_mimeType = response.mimeType();
 111         m_statusCode = response.httpStatusCode();
 112 
 113         // FIXME: This assumes text only responses. We should support non-text responses as well.
 114         TextEncoding textEncoding(response.textEncodingName());
 115         bool useDetector = false;
 116         if (!textEncoding.isValid()) {
 117             textEncoding = UTF8Encoding();
 118             useDetector = true;
 119         }
 120 
 121         m_decoder = TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncoding, useDetector);
 122     }
 123 
 124     void didReceiveData(const char* data, int dataLength) override
 125     {
 126         if (!dataLength)
 127             return;
 128 
 129         if (dataLength == -1)
 130             dataLength = strlen(data);
 131 
 132         m_responseText.append(m_decoder-&gt;decode(data, dataLength));
 133     }
 134 
 135     void didFinishLoading(unsigned long) override
 136     {
 137         if (m_decoder)
 138             m_responseText.append(m_decoder-&gt;flush());
 139 
 140         m_callback-&gt;sendSuccess(m_responseText.toString(), m_mimeType, m_statusCode);
 141         dispose();
 142     }
 143 
 144     void didFail(const ResourceError&amp; error) override
 145     {
 146         m_callback-&gt;sendFailure(error.isAccessControl() ? &quot;Loading resource for inspector failed access control check&quot;_s : &quot;Loading resource for inspector failed&quot;_s);
 147         dispose();
 148     }
 149 
 150     void setLoader(RefPtr&lt;ThreadableLoader&gt;&amp;&amp; loader)
 151     {
 152         m_loader = WTFMove(loader);
 153     }
 154 
 155 private:
 156     void dispose()
 157     {
 158         m_loader = nullptr;
 159         delete this;
 160     }
 161 
 162     RefPtr&lt;LoadResourceCallback&gt; m_callback;
 163     RefPtr&lt;ThreadableLoader&gt; m_loader;
 164     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
 165     String m_mimeType;
 166     StringBuilder m_responseText;
 167     int m_statusCode;
 168 };
 169 
 170 } // namespace
 171 
 172 InspectorNetworkAgent::InspectorNetworkAgent(WebAgentContext&amp; context)
 173     : InspectorAgentBase(&quot;Network&quot;_s, context)
 174     , m_frontendDispatcher(std::make_unique&lt;Inspector::NetworkFrontendDispatcher&gt;(context.frontendRouter))
 175     , m_backendDispatcher(Inspector::NetworkBackendDispatcher::create(context.backendDispatcher, this))
 176     , m_injectedScriptManager(context.injectedScriptManager)
 177     , m_resourcesData(std::make_unique&lt;NetworkResourcesData&gt;())
 178 {
 179 }
 180 
 181 void InspectorNetworkAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 182 {
 183 }
 184 
 185 void InspectorNetworkAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 186 {
 187     ErrorString unused;
 188     disable(unused);
 189 }
 190 
 191 static Ref&lt;JSON::Object&gt; buildObjectForHeaders(const HTTPHeaderMap&amp; headers)
 192 {
 193     Ref&lt;JSON::Object&gt; headersObject = JSON::Object::create();
 194 
 195     for (const auto&amp; header : headers)
 196         headersObject-&gt;setString(header.key, header.value);
 197     return headersObject;
 198 }
 199 
 200 Ref&lt;Inspector::Protocol::Network::ResourceTiming&gt; InspectorNetworkAgent::buildObjectForTiming(const NetworkLoadMetrics&amp; timing, ResourceLoader&amp; resourceLoader)
 201 {
 202     auto&amp; loadTiming = resourceLoader.loadTiming();
 203 
 204     auto elapsedTimeSince = [&amp;] (const MonotonicTime&amp; time) {
 205         return m_environment.executionStopwatch()-&gt;elapsedTimeSince(time).seconds();
 206     };
 207 
 208     return Inspector::Protocol::Network::ResourceTiming::create()
 209         .setStartTime(elapsedTimeSince(loadTiming.startTime()))
 210         .setRedirectStart(elapsedTimeSince(loadTiming.redirectStart()))
 211         .setRedirectEnd(elapsedTimeSince(loadTiming.redirectEnd()))
 212         .setFetchStart(elapsedTimeSince(loadTiming.fetchStart()))
 213         .setDomainLookupStart(timing.domainLookupStart.milliseconds())
 214         .setDomainLookupEnd(timing.domainLookupEnd.milliseconds())
 215         .setConnectStart(timing.connectStart.milliseconds())
 216         .setConnectEnd(timing.connectEnd.milliseconds())
 217         .setSecureConnectionStart(timing.secureConnectionStart.milliseconds())
 218         .setRequestStart(timing.requestStart.milliseconds())
 219         .setResponseStart(timing.responseStart.milliseconds())
 220         .setResponseEnd(timing.responseEnd.milliseconds())
 221         .release();
 222 }
 223 
 224 static Inspector::Protocol::Network::Metrics::Priority toProtocol(NetworkLoadPriority priority)
 225 {
 226     switch (priority) {
 227     case NetworkLoadPriority::Low:
 228         return Inspector::Protocol::Network::Metrics::Priority::Low;
 229     case NetworkLoadPriority::Medium:
 230         return Inspector::Protocol::Network::Metrics::Priority::Medium;
 231     case NetworkLoadPriority::High:
 232         return Inspector::Protocol::Network::Metrics::Priority::High;
 233     case NetworkLoadPriority::Unknown:
 234         break;
 235     }
 236 
 237     ASSERT_NOT_REACHED();
 238     return Inspector::Protocol::Network::Metrics::Priority::Medium;
 239 }
 240 
 241 Ref&lt;Inspector::Protocol::Network::Metrics&gt; InspectorNetworkAgent::buildObjectForMetrics(const NetworkLoadMetrics&amp; networkLoadMetrics)
 242 {
 243     auto metrics = Inspector::Protocol::Network::Metrics::create().release();
 244 
 245     if (!networkLoadMetrics.protocol.isNull())
 246         metrics-&gt;setProtocol(networkLoadMetrics.protocol);
 247     if (networkLoadMetrics.priority != NetworkLoadPriority::Unknown)
 248         metrics-&gt;setPriority(toProtocol(networkLoadMetrics.priority));
 249     if (!networkLoadMetrics.remoteAddress.isNull())
 250         metrics-&gt;setRemoteAddress(networkLoadMetrics.remoteAddress);
 251     if (!networkLoadMetrics.connectionIdentifier.isNull())
 252         metrics-&gt;setConnectionIdentifier(networkLoadMetrics.connectionIdentifier);
 253     if (!networkLoadMetrics.requestHeaders.isEmpty())
 254         metrics-&gt;setRequestHeaders(buildObjectForHeaders(networkLoadMetrics.requestHeaders));
 255 
 256     if (networkLoadMetrics.requestHeaderBytesSent != std::numeric_limits&lt;uint32_t&gt;::max())
 257         metrics-&gt;setRequestHeaderBytesSent(networkLoadMetrics.requestHeaderBytesSent);
 258     if (networkLoadMetrics.requestBodyBytesSent != std::numeric_limits&lt;uint64_t&gt;::max())
 259         metrics-&gt;setRequestBodyBytesSent(networkLoadMetrics.requestBodyBytesSent);
 260     if (networkLoadMetrics.responseHeaderBytesReceived != std::numeric_limits&lt;uint32_t&gt;::max())
 261         metrics-&gt;setResponseHeaderBytesReceived(networkLoadMetrics.responseHeaderBytesReceived);
 262     if (networkLoadMetrics.responseBodyBytesReceived != std::numeric_limits&lt;uint64_t&gt;::max())
 263         metrics-&gt;setResponseBodyBytesReceived(networkLoadMetrics.responseBodyBytesReceived);
 264     if (networkLoadMetrics.responseBodyDecodedSize != std::numeric_limits&lt;uint64_t&gt;::max())
 265         metrics-&gt;setResponseBodyDecodedSize(networkLoadMetrics.responseBodyDecodedSize);
 266 
 267     auto connectionPayload = Inspector::Protocol::Security::Connection::create()
 268         .release();
 269 
 270     if (!networkLoadMetrics.tlsProtocol.isEmpty())
 271         connectionPayload-&gt;setProtocol(networkLoadMetrics.tlsProtocol);
 272 
 273     if (!networkLoadMetrics.tlsCipher.isEmpty())
 274         connectionPayload-&gt;setCipher(networkLoadMetrics.tlsCipher);
 275 
 276     metrics-&gt;setSecurityConnection(WTFMove(connectionPayload));
 277 
 278     return metrics;
 279 }
 280 
 281 static Ref&lt;Inspector::Protocol::Network::Request&gt; buildObjectForResourceRequest(const ResourceRequest&amp; request)
 282 {
 283     auto requestObject = Inspector::Protocol::Network::Request::create()
 284         .setUrl(request.url().string())
 285         .setMethod(request.httpMethod())
 286         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 287         .release();
 288     if (request.httpBody() &amp;&amp; !request.httpBody()-&gt;isEmpty()) {
 289         auto bytes = request.httpBody()-&gt;flatten();
 290         requestObject-&gt;setPostData(String::fromUTF8WithLatin1Fallback(bytes.data(), bytes.size()));
 291     }
 292     return requestObject;
 293 }
 294 
 295 static Inspector::Protocol::Network::Response::Source responseSource(ResourceResponse::Source source)
 296 {
 297     switch (source) {
 298     case ResourceResponse::Source::ApplicationCache:
 299         // FIXME: Add support for ApplicationCache in inspector.
 300     case ResourceResponse::Source::Unknown:
 301         return Inspector::Protocol::Network::Response::Source::Unknown;
 302     case ResourceResponse::Source::Network:
 303         return Inspector::Protocol::Network::Response::Source::Network;
 304     case ResourceResponse::Source::MemoryCache:
 305     case ResourceResponse::Source::MemoryCacheAfterValidation:
 306         return Inspector::Protocol::Network::Response::Source::MemoryCache;
 307     case ResourceResponse::Source::DiskCache:
 308     case ResourceResponse::Source::DiskCacheAfterValidation:
 309         return Inspector::Protocol::Network::Response::Source::DiskCache;
 310     case ResourceResponse::Source::ServiceWorker:
 311         return Inspector::Protocol::Network::Response::Source::ServiceWorker;
 312     }
 313 
 314     ASSERT_NOT_REACHED();
 315     return Inspector::Protocol::Network::Response::Source::Unknown;
 316 }
 317 
 318 RefPtr&lt;Inspector::Protocol::Network::Response&gt; InspectorNetworkAgent::buildObjectForResourceResponse(const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 319 {
 320     if (response.isNull())
 321         return nullptr;
 322 
 323     Ref&lt;JSON::Object&gt; headers = buildObjectForHeaders(response.httpHeaderFields());
 324 
 325     auto responseObject = Inspector::Protocol::Network::Response::create()
 326         .setUrl(response.url().string())
 327         .setStatus(response.httpStatusCode())
 328         .setStatusText(response.httpStatusText())
 329         .setHeaders(WTFMove(headers))
 330         .setMimeType(response.mimeType())
 331         .setSource(responseSource(response.source()))
 332         .release();
 333 
 334     if (resourceLoader)
 335         responseObject-&gt;setTiming(buildObjectForTiming(response.deprecatedNetworkLoadMetrics(), *resourceLoader));
 336 
 337     if (auto&amp; certificateInfo = response.certificateInfo()) {
 338         auto securityPayload = Inspector::Protocol::Security::Security::create()
 339             .release();
 340 
 341         if (auto certificateSummaryInfo = certificateInfo.value().summaryInfo()) {
 342             auto certificatePayload = Inspector::Protocol::Security::Certificate::create()
 343                 .release();
 344 
 345             certificatePayload-&gt;setSubject(certificateSummaryInfo.value().subject);
 346 
 347             if (auto validFrom = certificateSummaryInfo.value().validFrom)
 348                 certificatePayload-&gt;setValidFrom(validFrom.seconds());
 349 
 350             if (auto validUntil = certificateSummaryInfo.value().validUntil)
 351                 certificatePayload-&gt;setValidUntil(validUntil.seconds());
 352 
 353             auto dnsNamesPayload = JSON::ArrayOf&lt;String&gt;::create();
 354             for (auto&amp; dnsName : certificateSummaryInfo.value().dnsNames)
 355                 dnsNamesPayload-&gt;addItem(dnsName);
 356             if (dnsNamesPayload-&gt;length())
 357                 certificatePayload-&gt;setDnsNames(WTFMove(dnsNamesPayload));
 358 
 359             auto ipAddressesPayload = JSON::ArrayOf&lt;String&gt;::create();
 360             for (auto&amp; ipAddress : certificateSummaryInfo.value().ipAddresses)
 361                 ipAddressesPayload-&gt;addItem(ipAddress);
 362             if (ipAddressesPayload-&gt;length())
 363                 certificatePayload-&gt;setDnsNames(WTFMove(ipAddressesPayload));
 364 
 365             securityPayload-&gt;setCertificate(WTFMove(certificatePayload));
 366         }
 367 
 368         responseObject-&gt;setSecurity(WTFMove(securityPayload));
 369     }
 370 
 371     return WTFMove(responseObject);
 372 }
 373 
 374 Ref&lt;Inspector::Protocol::Network::CachedResource&gt; InspectorNetworkAgent::buildObjectForCachedResource(CachedResource* cachedResource)
 375 {
 376     auto resourceObject = Inspector::Protocol::Network::CachedResource::create()
 377         .setUrl(cachedResource-&gt;url())
 378         .setType(InspectorPageAgent::cachedResourceTypeJSON(*cachedResource))
 379         .setBodySize(cachedResource-&gt;encodedSize())
 380         .release();
 381 
 382     auto resourceResponse = buildObjectForResourceResponse(cachedResource-&gt;response(), cachedResource-&gt;loader());
 383     resourceObject-&gt;setResponse(WTFMove(resourceResponse));
 384 
 385     String sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(cachedResource);
 386     if (!sourceMappingURL.isEmpty())
 387         resourceObject-&gt;setSourceMapURL(sourceMappingURL);
 388 
 389     return resourceObject;
 390 }
 391 
 392 InspectorNetworkAgent::~InspectorNetworkAgent()
 393 {
 394     if (m_enabled) {
 395         ErrorString unused;
 396         disable(unused);
 397     }
 398     ASSERT(!m_instrumentingAgents.inspectorNetworkAgent());
 399 }
 400 
 401 double InspectorNetworkAgent::timestamp()
 402 {
 403     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 404 }
 405 
 406 void InspectorNetworkAgent::willSendRequest(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse, InspectorPageAgent::ResourceType type)
 407 {
 408     if (request.hiddenFromInspector()) {
 409         m_hiddenRequestIdentifiers.add(identifier);
 410         return;
 411     }
 412 
 413     double sendTimestamp = timestamp();
 414     WallTime walltime = WallTime::now();
 415 
 416     String requestId = IdentifiersFactory::requestId(identifier);
 417     String frameId = frameIdentifier(loader);
 418     String loaderId = loaderIdentifier(loader);
 419     String targetId = request.initiatorIdentifier();
 420 
 421     if (type == InspectorPageAgent::OtherResource) {
 422         if (m_loadingXHRSynchronously)
 423             type = InspectorPageAgent::XHRResource;
 424         else if (loader &amp;&amp; equalIgnoringFragmentIdentifier(request.url(), loader-&gt;url()) &amp;&amp; !loader-&gt;isCommitted())
 425             type = InspectorPageAgent::DocumentResource;
 426         else if (loader) {
 427             for (auto&amp; linkIcon : loader-&gt;linkIcons()) {
 428                 if (equalIgnoringFragmentIdentifier(request.url(), linkIcon.url)) {
 429                     type = InspectorPageAgent::ImageResource;
 430                     break;
 431                 }
 432             }
 433         }
 434     }
 435 
 436     m_resourcesData-&gt;resourceCreated(requestId, loaderId, type);
 437 
 438     for (auto&amp; entry : m_extraRequestHeaders)
 439         request.setHTTPHeaderField(entry.key, entry.value);
 440 
 441     auto protocolResourceType = InspectorPageAgent::resourceTypeJSON(type);
 442 
 443     Document* document = loader &amp;&amp; loader-&gt;frame() ? loader-&gt;frame()-&gt;document() : nullptr;
 444     auto initiatorObject = buildInitiatorObject(document, request);
 445 
 446     String url = loader ? loader-&gt;url().string() : request.url();
 447     m_frontendDispatcher-&gt;requestWillBeSent(requestId, frameId, loaderId, url, buildObjectForResourceRequest(request), sendTimestamp, walltime.secondsSinceEpoch().seconds(), initiatorObject, buildObjectForResourceResponse(redirectResponse, nullptr), type != InspectorPageAgent::OtherResource ? &amp;protocolResourceType : nullptr, targetId.isEmpty() ? nullptr : &amp;targetId);
 448 }
 449 
 450 static InspectorPageAgent::ResourceType resourceTypeForCachedResource(CachedResource* resource)
 451 {
 452     if (resource)
 453         return InspectorPageAgent::inspectorResourceType(*resource);
 454     return InspectorPageAgent::OtherResource;
 455 }
 456 
 457 static InspectorPageAgent::ResourceType resourceTypeForLoadType(InspectorInstrumentation::LoadType loadType)
 458 {
 459     switch (loadType) {
 460     case InspectorInstrumentation::LoadType::Ping:
 461         return InspectorPageAgent::PingResource;
 462     case InspectorInstrumentation::LoadType::Beacon:
 463         return InspectorPageAgent::BeaconResource;
 464     }
 465 
 466     ASSERT_NOT_REACHED();
 467     return InspectorPageAgent::OtherResource;
 468 }
 469 
 470 void InspectorNetworkAgent::willSendRequest(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse)
 471 {
 472     auto* cachedResource = loader ? InspectorPageAgent::cachedResource(loader-&gt;frame(), request.url()) : nullptr;
 473     willSendRequest(identifier, loader, request, redirectResponse, resourceTypeForCachedResource(cachedResource));
 474 }
 475 
 476 void InspectorNetworkAgent::willSendRequestOfType(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, InspectorInstrumentation::LoadType loadType)
 477 {
 478     willSendRequest(identifier, loader, request, ResourceResponse(), resourceTypeForLoadType(loadType));
 479 }
 480 
 481 void InspectorNetworkAgent::didReceiveResponse(unsigned long identifier, DocumentLoader* loader, const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 482 {
 483     if (m_hiddenRequestIdentifiers.contains(identifier))
 484         return;
 485 
 486     String requestId = IdentifiersFactory::requestId(identifier);
 487 
 488     Optional&lt;ResourceResponse&gt; realResponse;
 489     if (platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 490         callOnMainThreadAndWait([&amp;] {
 491             // We do not need to isolate response since it comes straight from IPC, but we might want to isolate it for extra safety.
 492             auto response = platformStrategies()-&gt;loaderStrategy()-&gt;responseFromResourceLoadIdentifier(identifier);
 493             if (!response.isNull())
 494                 realResponse = WTFMove(response);
 495         });
 496     }
 497 
 498     RefPtr&lt;Inspector::Protocol::Network::Response&gt; resourceResponse = buildObjectForResourceResponse(realResponse ? *realResponse : response, resourceLoader);
 499 
 500     bool isNotModified = response.httpStatusCode() == 304;
 501 
 502     CachedResource* cachedResource = nullptr;
 503     if (is&lt;SubresourceLoader&gt;(resourceLoader) &amp;&amp; !isNotModified)
 504         cachedResource = downcast&lt;SubresourceLoader&gt;(resourceLoader)-&gt;cachedResource();
 505     if (!cachedResource &amp;&amp; loader)
 506         cachedResource = InspectorPageAgent::cachedResource(loader-&gt;frame(), response.url());
 507 
 508     if (cachedResource) {
 509         // Use mime type from cached resource in case the one in response is empty.
 510         if (resourceResponse &amp;&amp; response.mimeType().isEmpty())
 511             resourceResponse-&gt;setString(Inspector::Protocol::Network::Response::MimeType, cachedResource-&gt;response().mimeType());
 512         m_resourcesData-&gt;addCachedResource(requestId, cachedResource);
 513     }
 514 
 515     InspectorPageAgent::ResourceType type = m_resourcesData-&gt;resourceType(requestId);
 516     InspectorPageAgent::ResourceType newType = cachedResource ? InspectorPageAgent::inspectorResourceType(*cachedResource) : type;
 517 
 518     // FIXME: XHRResource is returned for CachedResource::Type::RawResource, it should be OtherResource unless it truly is an XHR.
 519     // RawResource is used for loading worker scripts, and those should stay as ScriptResource and not change to XHRResource.
 520     if (type != newType &amp;&amp; newType != InspectorPageAgent::XHRResource &amp;&amp; newType != InspectorPageAgent::OtherResource)
 521         type = newType;
 522 
 523     String frameId = frameIdentifier(loader);
 524     String loaderId = loaderIdentifier(loader);
 525 
 526     m_resourcesData-&gt;responseReceived(requestId, frameId, response, type, shouldForceBufferingNetworkResourceData());
 527 
 528     m_frontendDispatcher-&gt;responseReceived(requestId, frameId, loaderId, timestamp(), InspectorPageAgent::resourceTypeJSON(type), resourceResponse);
 529 
 530     // If we revalidated the resource and got Not modified, send content length following didReceiveResponse
 531     // as there will be no calls to didReceiveData from the network stack.
 532     if (isNotModified &amp;&amp; cachedResource &amp;&amp; cachedResource-&gt;encodedSize())
 533         didReceiveData(identifier, nullptr, cachedResource-&gt;encodedSize(), 0);
 534 }
 535 
 536 void InspectorNetworkAgent::didReceiveData(unsigned long identifier, const char* data, int dataLength, int encodedDataLength)
 537 {
 538     if (m_hiddenRequestIdentifiers.contains(identifier))
 539         return;
 540 
 541     String requestId = IdentifiersFactory::requestId(identifier);
 542 
 543     if (data) {
 544         NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;maybeAddResourceData(requestId, data, dataLength);
 545 
 546         // For a synchronous XHR, if we didn&#39;t add data then we can apply it here as base64 encoded content.
 547         // Often the data is text and we would have a decoder, but for non-text we won&#39;t have a decoder.
 548         // Sync XHRs may not have a cached resource, while non-sync XHRs usually transfer data over on completion.
 549         if (m_loadingXHRSynchronously &amp;&amp; resourceData &amp;&amp; !resourceData-&gt;hasBufferedData() &amp;&amp; !resourceData-&gt;cachedResource())
 550             m_resourcesData-&gt;setResourceContent(requestId, base64Encode(data, dataLength), true);
 551     }
 552 
 553     m_frontendDispatcher-&gt;dataReceived(requestId, timestamp(), dataLength, encodedDataLength);
 554 }
 555 
 556 void InspectorNetworkAgent::didFinishLoading(unsigned long identifier, DocumentLoader* loader, const NetworkLoadMetrics&amp; networkLoadMetrics, ResourceLoader* resourceLoader)
 557 {
 558     if (m_hiddenRequestIdentifiers.remove(identifier))
 559         return;
 560 
 561     double elapsedFinishTime;
 562     if (resourceLoader &amp;&amp; networkLoadMetrics.isComplete()) {
 563         MonotonicTime fetchStart = resourceLoader-&gt;loadTiming().fetchStart();
 564         Seconds fetchStartInInspector = m_environment.executionStopwatch()-&gt;elapsedTimeSince(fetchStart);
 565         elapsedFinishTime = (fetchStartInInspector + networkLoadMetrics.responseEnd).seconds();
 566     } else
 567         elapsedFinishTime = timestamp();
 568 
 569     String requestId = IdentifiersFactory::requestId(identifier);
 570     if (loader &amp;&amp; m_resourcesData-&gt;resourceType(requestId) == InspectorPageAgent::DocumentResource)
 571         m_resourcesData-&gt;addResourceSharedBuffer(requestId, loader-&gt;frameLoader()-&gt;documentLoader()-&gt;mainResourceData(), loader-&gt;frame()-&gt;document()-&gt;encoding());
 572 
 573     m_resourcesData-&gt;maybeDecodeDataToContent(requestId);
 574 
 575     String sourceMappingURL;
 576     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 577     if (resourceData &amp;&amp; resourceData-&gt;cachedResource())
 578         sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(resourceData-&gt;cachedResource());
 579 
 580     Optional&lt;NetworkLoadMetrics&gt; realMetrics;
 581     if (platformStrategies()-&gt;loaderStrategy()-&gt;shouldPerformSecurityChecks() &amp;&amp; !networkLoadMetrics.isComplete()) {
 582         callOnMainThreadAndWait([&amp;] {
 583             realMetrics = platformStrategies()-&gt;loaderStrategy()-&gt;networkMetricsFromResourceLoadIdentifier(identifier).isolatedCopy();
 584         });
 585     }
 586     RefPtr&lt;Inspector::Protocol::Network::Metrics&gt; metrics = buildObjectForMetrics(realMetrics ? *realMetrics : networkLoadMetrics);
 587 
 588     m_frontendDispatcher-&gt;loadingFinished(requestId, elapsedFinishTime, !sourceMappingURL.isEmpty() ? &amp;sourceMappingURL : nullptr, metrics);
 589 }
 590 
 591 void InspectorNetworkAgent::didFailLoading(unsigned long identifier, DocumentLoader* loader, const ResourceError&amp; error)
 592 {
 593     if (m_hiddenRequestIdentifiers.remove(identifier))
 594         return;
 595 
 596     String requestId = IdentifiersFactory::requestId(identifier);
 597 
 598     if (loader &amp;&amp; m_resourcesData-&gt;resourceType(requestId) == InspectorPageAgent::DocumentResource) {
 599         Frame* frame = loader-&gt;frame();
 600         if (frame &amp;&amp; frame-&gt;loader().documentLoader() &amp;&amp; frame-&gt;document()) {
 601             m_resourcesData-&gt;addResourceSharedBuffer(requestId,
 602                 frame-&gt;loader().documentLoader()-&gt;mainResourceData(),
 603                 frame-&gt;document()-&gt;encoding());
 604         }
 605     }
 606 
 607     bool canceled = error.isCancellation();
 608     m_frontendDispatcher-&gt;loadingFailed(requestId, timestamp(), error.localizedDescription(), canceled ? &amp;canceled : nullptr);
 609 }
 610 
 611 void InspectorNetworkAgent::didLoadResourceFromMemoryCache(DocumentLoader* loader, CachedResource&amp; resource)
 612 {
 613     ASSERT(loader);
 614     if (!loader)
 615         return;
 616 
 617     unsigned long identifier = loader-&gt;frame()-&gt;page()-&gt;progress().createUniqueIdentifier();
 618     String requestId = IdentifiersFactory::requestId(identifier);
 619     String loaderId = loaderIdentifier(loader);
 620     String frameId = frameIdentifier(loader);
 621 
 622     m_resourcesData-&gt;resourceCreated(requestId, loaderId, resource);
 623 
 624     auto initiatorObject = buildInitiatorObject(loader-&gt;frame() ? loader-&gt;frame()-&gt;document() : nullptr, resource.resourceRequest());
 625 
 626     // FIXME: It would be ideal to generate the Network.Response with the MemoryCache source
 627     // instead of whatever ResourceResponse::Source the CachedResources&#39;s response has.
 628     // The frontend already knows for certain that this was served from the memory cache.
 629 
 630     m_frontendDispatcher-&gt;requestServedFromMemoryCache(requestId, frameId, loaderId, loader-&gt;url().string(), timestamp(), initiatorObject, buildObjectForCachedResource(&amp;resource));
 631 }
 632 
 633 void InspectorNetworkAgent::setInitialScriptContent(unsigned long identifier, const String&amp; sourceString)
 634 {
 635     m_resourcesData-&gt;setResourceContent(IdentifiersFactory::requestId(identifier), sourceString);
 636 }
 637 
 638 void InspectorNetworkAgent::didReceiveScriptResponse(unsigned long identifier)
 639 {
 640     m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::ScriptResource);
 641 }
 642 
 643 void InspectorNetworkAgent::didReceiveThreadableLoaderResponse(unsigned long identifier, DocumentThreadableLoader&amp; documentThreadableLoader)
 644 {
 645     String initiator = documentThreadableLoader.options().initiator;
 646     if (initiator == cachedResourceRequestInitiators().fetch)
 647         m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::FetchResource);
 648     else if (initiator == cachedResourceRequestInitiators().xmlhttprequest)
 649         m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::XHRResource);
 650 }
 651 
 652 void InspectorNetworkAgent::willLoadXHRSynchronously()
 653 {
 654     m_loadingXHRSynchronously = true;
 655 }
 656 
 657 void InspectorNetworkAgent::didLoadXHRSynchronously()
 658 {
 659     m_loadingXHRSynchronously = false;
 660 }
 661 
 662 void InspectorNetworkAgent::willDestroyCachedResource(CachedResource&amp; cachedResource)
 663 {
 664     Vector&lt;String&gt; requestIds = m_resourcesData-&gt;removeCachedResource(&amp;cachedResource);
 665     if (!requestIds.size())
 666         return;
 667 
 668     String content;
 669     bool base64Encoded;
 670     if (!InspectorNetworkAgent::cachedResourceContent(cachedResource, &amp;content, &amp;base64Encoded))
 671         return;
 672 
 673     for (auto&amp; id : requestIds)
 674         m_resourcesData-&gt;setResourceContent(id, content, base64Encoded);
 675 }
 676 
 677 void InspectorNetworkAgent::willRecalculateStyle()
 678 {
 679     m_isRecalculatingStyle = true;
 680 }
 681 
 682 void InspectorNetworkAgent::didRecalculateStyle()
 683 {
 684     m_isRecalculatingStyle = false;
 685     m_styleRecalculationInitiator = nullptr;
 686 }
 687 
 688 void InspectorNetworkAgent::didScheduleStyleRecalculation(Document&amp; document)
 689 {
 690     if (!m_styleRecalculationInitiator)
 691         m_styleRecalculationInitiator = buildInitiatorObject(&amp;document);
 692 }
 693 
 694 RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; InspectorNetworkAgent::buildInitiatorObject(Document* document, Optional&lt;const ResourceRequest&amp;&gt; resourceRequest)
 695 {
 696     // FIXME: Worker support.
 697     if (!isMainThread()) {
 698         return Inspector::Protocol::Network::Initiator::create()
 699             .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 700             .release();
 701     }
 702 
 703     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; initiatorObject;
 704 
 705     Ref&lt;ScriptCallStack&gt; stackTrace = createScriptCallStack(JSExecState::currentState());
 706     if (stackTrace-&gt;size() &gt; 0) {
 707         initiatorObject = Inspector::Protocol::Network::Initiator::create()
 708             .setType(Inspector::Protocol::Network::Initiator::Type::Script)
 709             .release();
 710         initiatorObject-&gt;setStackTrace(stackTrace-&gt;buildInspectorArray());
 711     } else if (document &amp;&amp; document-&gt;scriptableDocumentParser()) {
 712         initiatorObject = Inspector::Protocol::Network::Initiator::create()
 713             .setType(Inspector::Protocol::Network::Initiator::Type::Parser)
 714             .release();
 715         initiatorObject-&gt;setUrl(document-&gt;url().string());
 716         initiatorObject-&gt;setLineNumber(document-&gt;scriptableDocumentParser()-&gt;textPosition().m_line.oneBasedInt());
 717     }
 718 
 719     auto domAgent = m_instrumentingAgents.inspectorDOMAgent();
 720     if (domAgent &amp;&amp; resourceRequest) {
 721         if (auto inspectorInitiatorNodeIdentifier = resourceRequest-&gt;inspectorInitiatorNodeIdentifier()) {
 722             if (!initiatorObject) {
 723                 initiatorObject = Inspector::Protocol::Network::Initiator::create()
 724                     .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 725                     .release();
 726             }
 727 
 728             initiatorObject-&gt;setNodeId(*inspectorInitiatorNodeIdentifier);
 729         }
 730     }
 731 
 732     if (initiatorObject)
 733         return initiatorObject;
 734 
 735     if (m_isRecalculatingStyle &amp;&amp; m_styleRecalculationInitiator)
 736         return m_styleRecalculationInitiator;
 737 
 738     return Inspector::Protocol::Network::Initiator::create()
 739         .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 740         .release();
 741 }
 742 
 743 void InspectorNetworkAgent::didCreateWebSocket(unsigned long identifier, const URL&amp; requestURL)
 744 {
 745     m_frontendDispatcher-&gt;webSocketCreated(IdentifiersFactory::requestId(identifier), requestURL.string());
 746 }
 747 
 748 void InspectorNetworkAgent::willSendWebSocketHandshakeRequest(unsigned long identifier, const ResourceRequest&amp; request)
 749 {
 750     auto requestObject = Inspector::Protocol::Network::WebSocketRequest::create()
 751         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 752         .release();
 753     m_frontendDispatcher-&gt;webSocketWillSendHandshakeRequest(IdentifiersFactory::requestId(identifier), timestamp(), WallTime::now().secondsSinceEpoch().seconds(), WTFMove(requestObject));
 754 }
 755 
 756 void InspectorNetworkAgent::didReceiveWebSocketHandshakeResponse(unsigned long identifier, const ResourceResponse&amp; response)
 757 {
 758     auto responseObject = Inspector::Protocol::Network::WebSocketResponse::create()
 759         .setStatus(response.httpStatusCode())
 760         .setStatusText(response.httpStatusText())
 761         .setHeaders(buildObjectForHeaders(response.httpHeaderFields()))
 762         .release();
 763     m_frontendDispatcher-&gt;webSocketHandshakeResponseReceived(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(responseObject));
 764 }
 765 
 766 void InspectorNetworkAgent::didCloseWebSocket(unsigned long identifier)
 767 {
 768     m_frontendDispatcher-&gt;webSocketClosed(IdentifiersFactory::requestId(identifier), timestamp());
 769 }
 770 
 771 void InspectorNetworkAgent::didReceiveWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp; frame)
 772 {
 773     auto frameObject = Inspector::Protocol::Network::WebSocketFrame::create()
 774         .setOpcode(frame.opCode)
 775         .setMask(frame.masked)
 776         .setPayloadData(String::fromUTF8WithLatin1Fallback(frame.payload, frame.payloadLength))
 777         .setPayloadLength(frame.payloadLength)
 778         .release();
 779     m_frontendDispatcher-&gt;webSocketFrameReceived(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(frameObject));
 780 }
 781 
 782 void InspectorNetworkAgent::didSendWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp; frame)
 783 {
 784     auto frameObject = Inspector::Protocol::Network::WebSocketFrame::create()
 785         .setOpcode(frame.opCode)
 786         .setMask(frame.masked)
 787         .setPayloadData(String::fromUTF8WithLatin1Fallback(frame.payload, frame.payloadLength))
 788         .setPayloadLength(frame.payloadLength)
 789         .release();
 790     m_frontendDispatcher-&gt;webSocketFrameSent(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(frameObject));
 791 }
 792 
 793 void InspectorNetworkAgent::didReceiveWebSocketFrameError(unsigned long identifier, const String&amp; errorMessage)
 794 {
 795     m_frontendDispatcher-&gt;webSocketFrameError(IdentifiersFactory::requestId(identifier), timestamp(), errorMessage);
 796 }
 797 
 798 void InspectorNetworkAgent::enable(ErrorString&amp;)
 799 {
 800     enable();
 801 }
 802 
 803 void InspectorNetworkAgent::enable()
 804 {
 805     m_enabled = true;
 806     m_instrumentingAgents.setInspectorNetworkAgent(this);
 807 
 808     {
 809         LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 810 
 811         for (WebSocket* webSocket : activeWebSockets(lock)) {
 812             ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 813             WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 814 
 815             unsigned identifier = channel-&gt;identifier();
 816             didCreateWebSocket(identifier, webSocket-&gt;url());
 817             willSendWebSocketHandshakeRequest(identifier, channel-&gt;clientHandshakeRequest());
 818 
 819             if (channel-&gt;handshakeMode() == WebSocketHandshake::Connected)
 820                 didReceiveWebSocketHandshakeResponse(identifier, channel-&gt;serverHandshakeResponse());
 821 
 822             if (webSocket-&gt;readyState() == WebSocket::CLOSED)
 823                 didCloseWebSocket(identifier);
 824         }
 825     }
 826 }
 827 
 828 void InspectorNetworkAgent::disable(ErrorString&amp;)
 829 {
 830     m_enabled = false;
 831     m_instrumentingAgents.setInspectorNetworkAgent(nullptr);
 832     m_resourcesData-&gt;clear();
 833     m_extraRequestHeaders.clear();
 834 
 835     setResourceCachingDisabled(false);
 836 }
 837 
 838 void InspectorNetworkAgent::setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers)
 839 {
 840     for (auto&amp; entry : headers) {
 841         String stringValue;
 842         if (entry.value-&gt;asString(stringValue))
 843             m_extraRequestHeaders.set(entry.key, stringValue);
 844     }
 845 }
 846 
 847 void InspectorNetworkAgent::getResponseBody(ErrorString&amp; errorString, const String&amp; requestId, String* content, bool* base64Encoded)
 848 {
 849     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 850     if (!resourceData) {
 851         errorString = &quot;No resource with given identifier found&quot;_s;
 852         return;
 853     }
 854 
 855     if (resourceData-&gt;hasContent()) {
 856         *base64Encoded = resourceData-&gt;base64Encoded();
 857         *content = resourceData-&gt;content();
 858         return;
 859     }
 860 
 861     if (resourceData-&gt;isContentEvicted()) {
 862         errorString = &quot;Request content was evicted from inspector cache&quot;_s;
 863         return;
 864     }
 865 
 866     if (resourceData-&gt;buffer() &amp;&amp; !resourceData-&gt;textEncodingName().isNull()) {
 867         *base64Encoded = false;
 868         if (InspectorPageAgent::sharedBufferContent(resourceData-&gt;buffer(), resourceData-&gt;textEncodingName(), *base64Encoded, content))
 869             return;
 870     }
 871 
 872     if (resourceData-&gt;cachedResource()) {
 873         if (InspectorNetworkAgent::cachedResourceContent(*resourceData-&gt;cachedResource(), content, base64Encoded))
 874             return;
 875     }
 876 
 877     errorString = &quot;No data found for resource with given identifier&quot;_s;
 878 }
 879 
 880 void InspectorNetworkAgent::setResourceCachingDisabled(ErrorString&amp;, bool disabled)
 881 {
 882     setResourceCachingDisabled(disabled);
 883 }
 884 
 885 void InspectorNetworkAgent::loadResource(const String&amp; frameId, const String&amp; urlString, Ref&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 886 {
 887     ErrorString error;
 888     auto* context = scriptExecutionContext(error, frameId);
 889     if (!context) {
 890         callback-&gt;sendFailure(error);
 891         return;
 892     }
 893 
 894     URL url = context-&gt;completeURL(urlString);
 895     ResourceRequest request(url);
 896     request.setHTTPMethod(&quot;GET&quot;_s);
 897     request.setHiddenFromInspector(true);
 898 
 899     ThreadableLoaderOptions options;
 900     options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks; // So we remove this from m_hiddenRequestIdentifiers on completion.
 901     options.defersLoadingPolicy = DefersLoadingPolicy::DisallowDefersLoading; // So the request is never deferred.
 902     options.mode = FetchOptions::Mode::NoCors;
 903     options.credentials = FetchOptions::Credentials::SameOrigin;
 904     options.contentSecurityPolicyEnforcement = ContentSecurityPolicyEnforcement::DoNotEnforce;
 905 
 906     // InspectorThreadableLoaderClient deletes itself when the load completes or fails.
 907     InspectorThreadableLoaderClient* inspectorThreadableLoaderClient = new InspectorThreadableLoaderClient(callback.copyRef());
 908     auto loader = ThreadableLoader::create(*context, *inspectorThreadableLoaderClient, WTFMove(request), options);
 909     if (!loader) {
 910         callback-&gt;sendFailure(&quot;Could not load requested resource.&quot;_s);
 911         return;
 912     }
 913 
 914     // If the load already completed, inspectorThreadableLoaderClient will have been deleted and we will have already called the callback.
 915     if (!callback-&gt;isActive())
 916         return;
 917 
 918     inspectorThreadableLoaderClient-&gt;setLoader(WTFMove(loader));
 919 }
 920 
 921 void InspectorNetworkAgent::getSerializedCertificate(ErrorString&amp; errorString, const String&amp; requestId, String* serializedCertificate)
 922 {
 923     auto* resourceData = m_resourcesData-&gt;data(requestId);
 924     if (!resourceData) {
 925         errorString = &quot;No resource with given identifier found&quot;_s;
 926         return;
 927     }
 928 
 929     auto&amp; certificate = resourceData-&gt;certificateInfo();
 930     if (!certificate || certificate.value().isEmpty()) {
 931         errorString = &quot;No certificate for resource&quot;_s;
 932         return;
 933     }
 934 
 935     WTF::Persistence::Encoder encoder;
 936     encoder &lt;&lt; certificate.value();
 937     *serializedCertificate = base64Encode(encoder.buffer(), encoder.bufferSize());
 938 }
 939 
 940 WebSocket* InspectorNetworkAgent::webSocketForRequestId(const String&amp; requestId)
 941 {
 942     LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 943 
 944     for (WebSocket* webSocket : activeWebSockets(lock)) {
 945         ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 946         WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 947         if (IdentifiersFactory::requestId(channel-&gt;identifier()) == requestId)
 948             return webSocket;
 949     }
 950 
 951     return nullptr;
 952 }
 953 
 954 static JSC::JSValue webSocketAsScriptValue(JSC::ExecState&amp; state, WebSocket* webSocket)
 955 {
 956     JSC::JSLockHolder lock(&amp;state);
 957     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), webSocket);
 958 }
 959 
 960 void InspectorNetworkAgent::resolveWebSocket(ErrorString&amp; errorString, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
 961 {
 962     WebSocket* webSocket = webSocketForRequestId(requestId);
 963     if (!webSocket) {
 964         errorString = &quot;WebSocket not found&quot;_s;
 965         return;
 966     }
 967 
 968     // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s and worker&#39;s WebSockets
 969     if (!is&lt;Document&gt;(webSocket-&gt;scriptExecutionContext()))
 970         return;
 971 
 972     auto* document = downcast&lt;Document&gt;(webSocket-&gt;scriptExecutionContext());
 973     auto* frame = document-&gt;frame();
 974     if (!frame) {
 975         errorString = &quot;WebSocket belongs to document without a frame&quot;_s;
 976         return;
 977     }
 978 
 979     auto&amp; state = *mainWorldExecState(frame);
 980     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
 981     ASSERT(!injectedScript.hasNoValue());
 982 
 983     String objectGroupName = objectGroup ? *objectGroup : String();
 984     result = injectedScript.wrapObject(webSocketAsScriptValue(state, webSocket), objectGroupName);
 985 }
 986 
 987 bool InspectorNetworkAgent::shouldTreatAsText(const String&amp; mimeType)
 988 {
 989     return startsWithLettersIgnoringASCIICase(mimeType, &quot;text/&quot;)
 990         || MIMETypeRegistry::isSupportedJavaScriptMIMEType(mimeType)
 991         || MIMETypeRegistry::isSupportedJSONMIMEType(mimeType)
 992         || MIMETypeRegistry::isXMLMIMEType(mimeType)
 993         || MIMETypeRegistry::isTextMediaPlaylistMIMEType(mimeType);
 994 }
 995 
 996 Ref&lt;TextResourceDecoder&gt; InspectorNetworkAgent::createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName)
 997 {
 998     if (!textEncodingName.isEmpty())
 999         return TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncodingName);
1000 
1001     if (MIMETypeRegistry::isTextMIMEType(mimeType))
1002         return TextResourceDecoder::create(mimeType, &quot;UTF-8&quot;);
1003     if (MIMETypeRegistry::isXMLMIMEType(mimeType)) {
1004         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;_s);
1005         decoder-&gt;useLenientXMLDecoding();
1006         return decoder;
1007     }
1008 
1009     return TextResourceDecoder::create(&quot;text/plain&quot;_s, &quot;UTF-8&quot;);
1010 }
1011 
1012 Optional&lt;String&gt; InspectorNetworkAgent::textContentForCachedResource(CachedResource&amp; cachedResource)
1013 {
1014     if (!InspectorNetworkAgent::shouldTreatAsText(cachedResource.mimeType()))
1015         return WTF::nullopt;
1016 
1017     String result;
1018     bool base64Encoded;
1019     if (InspectorNetworkAgent::cachedResourceContent(cachedResource, &amp;result, &amp;base64Encoded)) {
1020         ASSERT(!base64Encoded);
1021         return result;
1022     }
1023 
1024     return WTF::nullopt;
1025 }
1026 
1027 bool InspectorNetworkAgent::cachedResourceContent(CachedResource&amp; resource, String* result, bool* base64Encoded)
1028 {
1029     ASSERT(result);
1030     ASSERT(base64Encoded);
1031 
1032     if (!resource.encodedSize()) {
1033         *base64Encoded = false;
1034         *result = String();
1035         return true;
1036     }
1037 
1038     switch (resource.type()) {
1039     case CachedResource::Type::CSSStyleSheet:
1040         *base64Encoded = false;
1041         *result = downcast&lt;CachedCSSStyleSheet&gt;(resource).sheetText();
1042         // The above can return a null String if the MIME type is invalid.
1043         return !result-&gt;isNull();
1044     case CachedResource::Type::Script:
1045         *base64Encoded = false;
1046         *result = downcast&lt;CachedScript&gt;(resource).script().toString();
1047         return true;
1048     default:
1049         auto* buffer = resource.resourceBuffer();
1050         if (!buffer)
1051             return false;
1052 
1053         if (InspectorNetworkAgent::shouldTreatAsText(resource.mimeType())) {
1054             auto decoder = InspectorNetworkAgent::createTextDecoder(resource.mimeType(), resource.response().textEncodingName());
1055             *base64Encoded = false;
1056             *result = decoder-&gt;decodeAndFlush(buffer-&gt;data(), buffer-&gt;size());
1057             return true;
1058         }
1059 
1060         *base64Encoded = true;
1061         *result = base64Encode(buffer-&gt;data(), buffer-&gt;size());
1062         return true;
1063     }
1064 }
1065 
1066 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; requestId, const String&amp; frameId, const String&amp; url, int matchesCount)
1067 {
1068     auto searchResult = Inspector::Protocol::Page::SearchResult::create()
1069         .setUrl(url)
1070         .setFrameId(frameId)
1071         .setMatchesCount(matchesCount)
1072         .release();
1073     searchResult-&gt;setRequestId(requestId);
1074     return searchResult;
1075 }
1076 
1077 static Optional&lt;String&gt; textContentForResourceData(const NetworkResourcesData::ResourceData&amp; resourceData)
1078 {
1079     if (resourceData.hasContent() &amp;&amp; !resourceData.base64Encoded())
1080         return resourceData.content();
1081 
1082     if (resourceData.cachedResource())
1083         return InspectorNetworkAgent::textContentForCachedResource(*resourceData.cachedResource());
1084 
1085     return WTF::nullopt;
1086 }
1087 
1088 void InspectorNetworkAgent::searchOtherRequests(const JSC::Yarr::RegularExpression&amp; regex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
1089 {
1090     Vector&lt;NetworkResourcesData::ResourceData*&gt; resources = m_resourcesData-&gt;resources();
1091     for (auto* resourceData : resources) {
1092         if (auto textContent = textContentForResourceData(*resourceData)) {
1093             int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, resourceData-&gt;content());
1094             if (matchesCount)
1095                 result-&gt;addItem(buildObjectForSearchResult(resourceData-&gt;requestId(), resourceData-&gt;frameId(), resourceData-&gt;url(), matchesCount));
1096         }
1097     }
1098 }
1099 
1100 void InspectorNetworkAgent::searchInRequest(ErrorString&amp; errorString, const String&amp; requestId, const String&amp; query, bool caseSensitive, bool isRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
1101 {
1102     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
1103     if (!resourceData) {
1104         errorString = &quot;No resource with given identifier found&quot;_s;
1105         return;
1106     }
1107 
1108     if (!resourceData-&gt;hasContent()) {
1109         errorString = &quot;No resource content&quot;_s;
1110         return;
1111     }
1112 
1113     results = ContentSearchUtilities::searchInTextByLines(resourceData-&gt;content(), query, caseSensitive, isRegex);
1114 }
1115 
1116 void InspectorNetworkAgent::mainFrameNavigated(DocumentLoader&amp; loader)
1117 {
1118     m_resourcesData-&gt;clear(loaderIdentifier(&amp;loader));
1119 }
1120 
1121 } // namespace WebCore
    </pre>
  </body>
</html>