<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerBacking.h&quot;
  29 
  30 #include &quot;BitmapImage.h&quot;
  31 #include &quot;CSSAnimationController.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CachedImage.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;DocumentTimeline.h&quot;

  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameView.h&quot;
  39 #include &quot;GraphicsContext.h&quot;
  40 #include &quot;GraphicsLayer.h&quot;
  41 #include &quot;HTMLBodyElement.h&quot;
  42 #include &quot;HTMLCanvasElement.h&quot;
  43 #include &quot;HTMLIFrameElement.h&quot;
  44 #include &quot;HTMLMediaElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLPlugInElement.h&quot;
  47 #include &quot;InspectorInstrumentation.h&quot;
  48 #include &quot;KeyframeList.h&quot;

  49 #include &quot;Logging.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PerformanceLoggingClient.h&quot;
  52 #include &quot;PluginViewBase.h&quot;
  53 #include &quot;ProgressTracker.h&quot;
  54 #include &quot;RenderFragmentContainer.h&quot;
  55 #include &quot;RenderFragmentedFlow.h&quot;
  56 #include &quot;RenderHTMLCanvas.h&quot;
  57 #include &quot;RenderIFrame.h&quot;
  58 #include &quot;RenderImage.h&quot;
  59 #include &quot;RenderLayerCompositor.h&quot;
  60 #include &quot;RenderEmbeddedObject.h&quot;
  61 #include &quot;RenderMedia.h&quot;
  62 #include &quot;RenderVideo.h&quot;
  63 #include &quot;RenderView.h&quot;
  64 #include &quot;RuntimeEnabledFeatures.h&quot;
  65 #include &quot;ScrollingCoordinator.h&quot;
  66 #include &quot;Settings.h&quot;
  67 #include &quot;StyleResolver.h&quot;
  68 #include &quot;TiledBacking.h&quot;
</pre>
<hr />
<pre>
 220     }
 221 
 222     createPrimaryGraphicsLayer();
 223 #if ENABLE(FULLSCREEN_API)
 224     setRequiresBackgroundLayer(layer.renderer().isRenderFullScreen());
 225 #endif
 226 
 227     if (auto* tiledBacking = this-&gt;tiledBacking()) {
 228         tiledBacking-&gt;setIsInWindow(renderer().page().isInWindow());
 229 
 230         if (m_isFrameLayerWithTiledBacking) {
 231             tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(renderer().settings().scrollingPerformanceLoggingEnabled());
 232             adjustTiledBackingCoverage();
 233         }
 234     }
 235 }
 236 
 237 RenderLayerBacking::~RenderLayerBacking()
 238 {
 239     // Note that m_owningLayer-&gt;backing() is null here.
<span class="line-modified"> 240     updateAncestorClippingLayer(false);</span>
 241     updateChildClippingStrategy(false);
 242     updateDescendantClippingLayer(false);
 243     updateOverflowControlsLayers(false, false, false);
 244     updateForegroundLayer(false);
 245     updateBackgroundLayer(false);
 246     updateMaskingLayer(false, false);
 247     updateScrollingLayers(false);
 248 
 249     ASSERT(!m_viewportConstrainedNodeID);
 250     ASSERT(!m_scrollingNodeID);
 251     ASSERT(!m_frameHostingNodeID);

 252 
 253     destroyGraphicsLayers();
 254 }
 255 
 256 void RenderLayerBacking::willBeDestroyed()
 257 {
 258     ASSERT(m_owningLayer.backing() == this);
 259     compositor().removeFromScrollCoordinatedLayers(m_owningLayer);


 260 }
 261 
 262 void RenderLayerBacking::willDestroyLayer(const GraphicsLayer* layer)
 263 {
 264     if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
 265         compositor().layerTiledBackingUsageChanged(layer, false);
 266 }
 267 






















































 268 Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
 269 {
 270     auto* graphicsLayerFactory = renderer().page().chrome().client().graphicsLayerFactory();
 271 
 272     auto graphicsLayer = GraphicsLayer::create(graphicsLayerFactory, *this, layerType);
 273 
 274     graphicsLayer-&gt;setName(name);
 275 
 276 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 277     graphicsLayer-&gt;setAcceleratesDrawing(compositor().acceleratedDrawingEnabled());
 278     graphicsLayer-&gt;setUsesDisplayListDrawing(compositor().displayListDrawingEnabled());
 279 #endif
 280 
 281     return graphicsLayer;
 282 }
 283 
 284 void RenderLayerBacking::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
 285 {
 286     // Note that this only affects the primary layer.
 287     if (usesDisplayListDrawing == m_graphicsLayer-&gt;usesDisplayListDrawing())
</pre>
<hr />
<pre>
 300 void RenderLayerBacking::setIsTrackingDisplayListReplay(bool isTrackingReplay)
 301 {
 302     m_graphicsLayer-&gt;setIsTrackingDisplayListReplay(isTrackingReplay);
 303 }
 304 
 305 String RenderLayerBacking::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
 306 {
 307     return m_graphicsLayer-&gt;replayDisplayListAsText(flags);
 308 }
 309 
 310 void RenderLayerBacking::tiledBackingUsageChanged(const GraphicsLayer* layer, bool usingTiledBacking)
 311 {
 312     compositor().layerTiledBackingUsageChanged(layer, usingTiledBacking);
 313 }
 314 
 315 TiledBacking* RenderLayerBacking::tiledBacking() const
 316 {
 317     return m_graphicsLayer-&gt;tiledBacking();
 318 }
 319 
<span class="line-modified"> 320 static TiledBacking::TileCoverage computePageTiledBackingCoverage(RenderLayerBacking* backing)</span>
 321 {
<span class="line-removed"> 322     // FIXME: When we use TiledBacking for overflow, this should look at RenderView scrollability.</span>
<span class="line-removed"> 323     auto&amp; frameView = backing-&gt;owningLayer().renderer().view().frameView();</span>
<span class="line-removed"> 324 </span>
 325     // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.
<span class="line-modified"> 326     if (!backing-&gt;owningLayer().page().isVisible())</span>
 327         return TiledBacking::CoverageForVisibleArea;
 328 


 329     TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;
 330     bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();
 331     if (frameView.speculativeTilingEnabled() &amp;&amp; !useMinimalTilesDuringLiveResize) {
 332         bool clipsToExposedRect = static_cast&lt;bool&gt;(frameView.viewExposedRect());
 333         if (frameView.horizontalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 334             tileCoverage |= TiledBacking::CoverageForHorizontalScrolling;
 335 
 336         if (frameView.verticalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 337             tileCoverage |= TiledBacking::CoverageForVerticalScrolling;
 338     }
 339     return tileCoverage;
 340 }
 341 




















 342 void RenderLayerBacking::adjustTiledBackingCoverage()
 343 {
<span class="line-modified"> 344     if (!m_isFrameLayerWithTiledBacking)</span>
<span class="line-modified"> 345         return;</span>



 346 
<span class="line-modified"> 347     TiledBacking::TileCoverage tileCoverage = computePageTiledBackingCoverage(this);</span>
<span class="line-modified"> 348     tiledBacking()-&gt;setTileCoverage(tileCoverage);</span>




 349 }
 350 
 351 void RenderLayerBacking::setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom)
 352 {
 353     if (!m_isFrameLayerWithTiledBacking)
 354         return;
 355 
 356     tiledBacking()-&gt;setHasMargins(hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnLeftAndRight, hasExtendedBackgroundOnLeftAndRight);
 357 }
 358 
 359 void RenderLayerBacking::updateDebugIndicators(bool showBorder, bool showRepaintCounter)
 360 {
 361     m_graphicsLayer-&gt;setShowDebugBorder(showBorder);
 362     m_graphicsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 363 
<span class="line-modified"> 364     if (m_ancestorClippingLayer)</span>
<span class="line-modified"> 365         m_ancestorClippingLayer-&gt;setShowDebugBorder(showBorder);</span>


 366 
 367     if (m_foregroundLayer) {
 368         m_foregroundLayer-&gt;setShowDebugBorder(showBorder);
 369         m_foregroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 370     }
 371 
 372     if (m_contentsContainmentLayer)
 373         m_contentsContainmentLayer-&gt;setShowDebugBorder(showBorder);
 374 
 375     if (m_backgroundLayer) {
 376         m_backgroundLayer-&gt;setShowDebugBorder(showBorder);
 377         m_backgroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 378     }
 379 
 380     if (m_maskLayer) {
 381         m_maskLayer-&gt;setShowDebugBorder(showBorder);
 382         m_maskLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 383     }
 384 
 385     if (m_layerForHorizontalScrollbar)
</pre>
<hr />
<pre>
 459     if (m_isMainFrameRenderViewLayer &amp;&amp; IOSApplication::isDumpRenderTree()) {
 460         // In iOS WebKit1 the main frame&#39;s RenderView layer is always transparent. We lie that it is opaque so that
 461         // internals.layerTreeAsText() tests succeed.
 462         ASSERT_UNUSED(layer, !layer.contentsOpaque());
 463         return true;
 464     }
 465     return false;
 466 }
 467 #endif
 468 
 469 void RenderLayerBacking::destroyGraphicsLayers()
 470 {
 471     if (m_graphicsLayer) {
 472         m_graphicsLayer-&gt;setMaskLayer(nullptr);
 473         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 474         willDestroyLayer(m_graphicsLayer.get());
 475     }
 476 
 477     GraphicsLayer::clear(m_maskLayer);
 478 
<span class="line-modified"> 479     GraphicsLayer::unparentAndClear(m_ancestorClippingLayer);</span>




 480     GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
 481     GraphicsLayer::unparentAndClear(m_foregroundLayer);
 482     GraphicsLayer::unparentAndClear(m_backgroundLayer);
 483     GraphicsLayer::unparentAndClear(m_childContainmentLayer);
 484     GraphicsLayer::unparentAndClear(m_childClippingMaskLayer);
 485     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
 486     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
 487     GraphicsLayer::unparentAndClear(m_graphicsLayer);
 488 }
 489 
 490 void RenderLayerBacking::updateOpacity(const RenderStyle&amp; style)
 491 {
 492     m_graphicsLayer-&gt;setOpacity(compositingOpacity(style.opacity()));
 493 }
 494 
 495 void RenderLayerBacking::updateTransform(const RenderStyle&amp; style)
 496 {
 497     // FIXME: This could use m_owningLayer.transform(), but that currently has transform-origin
 498     // baked into it, and we don&#39;t want that.
 499     TransformationMatrix t;
 500     if (m_owningLayer.hasTransform()) {
 501         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 502         style.applyTransform(t, snapRectToDevicePixels(renderBox.borderBoxRect(), deviceScaleFactor()), RenderStyle::ExcludeTransformOrigin);
 503         makeMatrixRenderable(t, compositor().canRender3DTransforms());
 504     }
 505 
 506     if (m_contentsContainmentLayer) {
 507         m_contentsContainmentLayer-&gt;setTransform(t);
<span class="line-modified"> 508         m_graphicsLayer-&gt;setTransform(TransformationMatrix());</span>
 509     } else
 510         m_graphicsLayer-&gt;setTransform(t);
 511 }
 512 
 513 void RenderLayerBacking::updateFilters(const RenderStyle&amp; style)
 514 {
 515     m_canCompositeFilters = m_graphicsLayer-&gt;setFilters(style.filter());
 516 }
 517 
 518 #if ENABLE(FILTERS_LEVEL_2)
 519 void RenderLayerBacking::updateBackdropFilters(const RenderStyle&amp; style)
 520 {
 521     m_canCompositeBackdropFilters = m_graphicsLayer-&gt;setBackdropFilters(style.backdropFilter());
 522 }
 523 
 524 void RenderLayerBacking::updateBackdropFiltersGeometry()
 525 {
 526     if (!m_canCompositeBackdropFilters)
 527         return;
 528 
 529     if (!is&lt;RenderBox&gt;(renderer()))
 530         return;
 531 
 532     auto&amp; renderer = downcast&lt;RenderBox&gt;(this-&gt;renderer());
 533     LayoutRect boxRect = renderer.borderBoxRect();
 534     if (renderer.hasClip())
 535         boxRect.intersect(renderer.clipRect(LayoutPoint(), nullptr));
<span class="line-modified"> 536     boxRect.move(contentOffsetInCompostingLayer());</span>
 537 
 538     FloatRoundedRect backdropFiltersRect;
 539     if (renderer.style().hasBorderRadius() &amp;&amp; !renderer.hasClip())
 540         backdropFiltersRect = renderer.style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 541     else
 542         backdropFiltersRect = FloatRoundedRect(snapRectToDevicePixels(boxRect, deviceScaleFactor()));
 543 
 544     m_graphicsLayer-&gt;setBackdropFiltersRect(backdropFiltersRect);
 545 }
 546 #endif
 547 
 548 #if ENABLE(CSS_COMPOSITING)
 549 void RenderLayerBacking::updateBlendMode(const RenderStyle&amp; style)
 550 {
<span class="line-modified"> 551     // FIXME: where is the blend mode updated when m_ancestorClippingLayers come and go?</span>
<span class="line-modified"> 552     if (m_ancestorClippingLayer) {</span>
<span class="line-modified"> 553         m_ancestorClippingLayer-&gt;setBlendMode(style.blendMode());</span>
 554         m_graphicsLayer-&gt;setBlendMode(BlendMode::Normal);
 555     } else
 556         m_graphicsLayer-&gt;setBlendMode(style.blendMode());
 557 }
 558 #endif
 559 
 560 void RenderLayerBacking::updateCustomAppearance(const RenderStyle&amp; style)
 561 {
 562     ControlPart appearance = style.appearance();
 563     if (appearance == MediaControlsLightBarBackgroundPart)
 564         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::LightBackdrop);
 565     else if (appearance == MediaControlsDarkBarBackgroundPart)
 566         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::DarkBackdrop);
 567     else
 568         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::None);
 569 }
 570 
 571 static bool layerOrAncestorIsTransformedOrUsingCompositedScrolling(RenderLayer&amp; layer)
 572 {
 573     for (auto* curr = &amp;layer; curr; curr = curr-&gt;parent()) {
</pre>
<hr />
<pre>
 587 #endif
 588 
 589     if (m_isFrameLayerWithTiledBacking)
 590         return false;
 591 
 592     if (layerOrAncestorIsTransformedOrUsingCompositedScrolling(m_owningLayer))
 593         return false;
 594 
 595     return true;
 596 }
 597 
 598 static bool hasNonZeroTransformOrigin(const RenderObject&amp; renderer)
 599 {
 600     const RenderStyle&amp; style = renderer.style();
 601     return (style.transformOriginX().type() == Fixed &amp;&amp; style.transformOriginX().value())
 602         || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
 603 }
 604 
 605 bool RenderLayerBacking::updateCompositedBounds()
 606 {
<span class="line-modified"> 607     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, LayoutSize(), RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);</span>
 608     // Clip to the size of the document or enclosing overflow-scroll layer.
 609     // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
 610     // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
 611     if (shouldClipCompositedBounds()) {
 612         auto&amp; view = renderer().view();
 613         auto* rootLayer = view.layer();
 614 
 615         LayoutRect clippingBounds;
 616         if (renderer().isFixedPositioned() &amp;&amp; renderer().container() == &amp;view)
 617             clippingBounds = view.frameView().rectForFixedPositionLayout();
 618         else
 619             clippingBounds = view.unscaledDocumentRect();
 620 
 621         if (&amp;m_owningLayer != rootLayer)
 622             clippingBounds.intersect(m_owningLayer.backgroundClipRect(RenderLayer::ClipRectsContext(rootLayer, AbsoluteClipRects)).rect()); // FIXME: Incorrect for CSS regions.
 623 
 624         LayoutPoint delta = m_owningLayer.convertToLayerCoords(rootLayer, LayoutPoint(), RenderLayer::AdjustForColumns);
 625         clippingBounds.move(-delta.x(), -delta.y());
 626 
 627         layerBounds.intersect(clippingBounds);
 628     }
 629 











 630     // If the element has a transform-origin that has fixed lengths, and the renderer has zero size,
 631     // then we need to ensure that the compositing layer has non-zero size so that we can apply
 632     // the transform-origin via the GraphicsLayer anchorPoint (which is expressed as a fractional value).
 633     if (layerBounds.isEmpty() &amp;&amp; (hasNonZeroTransformOrigin(renderer()) || renderer().style().hasPerspective())) {
 634         layerBounds.setWidth(1);
 635         layerBounds.setHeight(1);
 636         m_artificiallyInflatedBounds = true;
 637     } else
 638         m_artificiallyInflatedBounds = false;
 639 
 640     return setCompositedBounds(layerBounds);
 641 }
 642 































 643 void RenderLayerBacking::updateAfterWidgetResize()
 644 {
 645     if (!is&lt;RenderWidget&gt;(renderer()))
 646         return;
 647 
 648     if (auto* innerCompositor = RenderLayerCompositor::frameContentsCompositor(downcast&lt;RenderWidget&gt;(renderer()))) {
 649         innerCompositor-&gt;frameViewDidChangeSize();
 650         innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
 651     }
 652 }
 653 
<span class="line-modified"> 654 void RenderLayerBacking::updateAfterLayout(bool needsFullRepaint)</span>
 655 {
 656     LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
 657 
 658     // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
 659     // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
 660     // take overflow into account.
 661     if (updateCompositedBounds()) {
 662         m_owningLayer.setNeedsCompositingGeometryUpdate();
 663         // This layer&#39;s geometry affects those of its children.
 664         m_owningLayer.setChildrenNeedCompositingGeometryUpdate();



 665     }
 666 
 667     if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
 668         setContentsNeedDisplay();
 669 }
 670 
 671 // This can only update things that don&#39;t require up-to-date layout.
 672 void RenderLayerBacking::updateConfigurationAfterStyleChange()
 673 {
 674     updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath());
 675 
 676     if (m_owningLayer.hasReflection()) {
 677         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 678             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 679             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 680         }
 681     } else
 682         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 683 
 684     // FIXME: do we care if opacity is animating?
</pre>
<hr />
<pre>
 704     bool layerConfigChanged = false;
 705     auto&amp; compositor = this-&gt;compositor();
 706 
 707     setBackgroundLayerPaintsFixedRootBackground(compositor.needsFixedRootBackgroundLayer(m_owningLayer));
 708 
 709     if (updateBackgroundLayer(m_backgroundLayerPaintsFixedRootBackground || m_requiresBackgroundLayer))
 710         layerConfigChanged = true;
 711 
 712     if (updateForegroundLayer(compositor.needsContentsCompositingLayer(m_owningLayer)))
 713         layerConfigChanged = true;
 714 
 715     bool needsDescendantsClippingLayer = false;
 716     bool usesCompositedScrolling = m_owningLayer.hasCompositedScrollableOverflow();
 717 
 718     if (usesCompositedScrolling) {
 719         // If it&#39;s scrollable, it has to be a box.
 720         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 721         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 722         needsDescendantsClippingLayer = contentsClippingRect.isRounded();
 723     } else
<span class="line-modified"> 724         needsDescendantsClippingLayer = compositor.clipsCompositingDescendants(m_owningLayer);</span>
 725 
 726     if (updateScrollingLayers(usesCompositedScrolling))
 727         layerConfigChanged = true;
 728 
 729     if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
 730         layerConfigChanged = true;
 731 
<span class="line-modified"> 732     // clippedByAncestor() does a tree walk.</span>
<span class="line-modified"> 733     if (updateAncestorClippingLayer(compositor.clippedByAncestor(m_owningLayer)))</span>
 734         layerConfigChanged = true;
 735 
 736     if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
 737         layerConfigChanged = true;
 738 
 739     if (layerConfigChanged)
 740         updateInternalHierarchy();
 741 
 742     if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
 743         if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
 744             m_graphicsLayer-&gt;addChild(*flatteningLayer);
 745     }
 746 
<span class="line-modified"> 747     updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath());</span>

 748 
 749     updateChildClippingStrategy(needsDescendantsClippingLayer);
 750 
 751     if (m_owningLayer.hasReflection()) {
 752         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 753             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 754             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 755         }
 756     } else
 757         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 758 
 759     PaintedContentsInfo contentsInfo(*this);
 760 
 761     // Requires layout.
 762     if (!m_owningLayer.isRenderViewLayer()) {
 763         bool didUpdateContentsRect = false;
 764         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
 765     } else
 766         updateRootLayerConfiguration();
 767 
</pre>
<hr />
<pre>
 772     if (is&lt;RenderEmbeddedObject&gt;(renderer()) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer()).allowsAcceleratedCompositing()) {
 773         auto* pluginViewBase = downcast&lt;PluginViewBase&gt;(downcast&lt;RenderWidget&gt;(renderer()).widget());
 774 #if PLATFORM(IOS_FAMILY)
 775         if (pluginViewBase &amp;&amp; !m_graphicsLayer-&gt;contentsLayerForMedia()) {
 776             pluginViewBase-&gt;detachPluginLayer();
 777             pluginViewBase-&gt;attachPluginLayer();
 778         }
 779 #else
 780         if (!pluginViewBase-&gt;shouldNotAddLayer())
 781             m_graphicsLayer-&gt;setContentsToPlatformLayer(pluginViewBase-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Plugin);
 782 #endif
 783     }
 784 #if ENABLE(VIDEO)
 785     else if (is&lt;RenderVideo&gt;(renderer()) &amp;&amp; downcast&lt;RenderVideo&gt;(renderer()).shouldDisplayVideo()) {
 786         auto* mediaElement = downcast&lt;HTMLMediaElement&gt;(renderer().element());
 787         m_graphicsLayer-&gt;setContentsToPlatformLayer(mediaElement-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Media);
 788         // Requires layout.
 789         resetContentsRect();
 790     }
 791 #endif
<span class="line-modified"> 792 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)</span>
 793     else if (renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
 794         const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
 795         if (auto* context = canvas-&gt;renderingContext())
 796             m_graphicsLayer-&gt;setContentsToPlatformLayer(context-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Canvas);
 797 
 798         layerConfigChanged = true;
 799     }
 800 #endif
 801     if (is&lt;RenderWidget&gt;(renderer()) &amp;&amp; compositor.parentFrameContentLayers(downcast&lt;RenderWidget&gt;(renderer()))) {
 802         m_owningLayer.setNeedsCompositingGeometryUpdate();
 803         layerConfigChanged = true;
 804     }
 805 
 806     if (is&lt;RenderImage&gt;(renderer()) &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage()) {
 807         auto element = renderer().element();
 808         if (is&lt;HTMLImageElement&gt;(element)) {
 809             m_graphicsLayer-&gt;setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType::EditableImage, downcast&lt;HTMLImageElement&gt;(element)-&gt;editableImageViewID());
 810             layerConfigChanged = true;
 811         }
 812     }
 813 



 814     return layerConfigChanged;
 815 }
 816 
 817 static LayoutRect clipBox(RenderBox&amp; renderer)
 818 {
 819     LayoutRect result = LayoutRect::infiniteRect();
 820     if (renderer.hasOverflowClip())
 821         result = renderer.overflowClipRect(LayoutPoint(), 0); // FIXME: Incorrect for CSS regions.
 822 
 823     if (renderer.hasClip())
 824         result.intersect(renderer.clipRect(LayoutPoint(), 0)); // FIXME: Incorrect for CSS regions.
 825 
 826     return result;
 827 }
 828 
 829 static bool subpixelOffsetFromRendererChanged(const LayoutSize&amp; oldSubpixelOffsetFromRenderer, const LayoutSize&amp; newSubpixelOffsetFromRenderer, float deviceScaleFactor)
 830 {
 831     FloatSize previous = snapSizeToDevicePixel(oldSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 832     FloatSize current = snapSizeToDevicePixel(newSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 833     return previous != current;
</pre>
<hr />
<pre>
 853     OffsetFromRenderer offsetFromRenderer;
 854     offsetFromRenderer.m_subpixelOffset = LayoutSize(subpixelForLayerPainting(toLayoutPoint(offset), deviceScaleFactor));
 855     offsetFromRenderer.m_devicePixelOffset = offset - offsetFromRenderer.m_subpixelOffset;
 856     return offsetFromRenderer;
 857 }
 858 
 859 struct SnappedRectInfo {
 860     LayoutRect m_snappedRect;
 861     LayoutSize m_snapDelta;
 862 };
 863 
 864 static SnappedRectInfo snappedGraphicsLayer(const LayoutSize&amp; offset, const LayoutSize&amp; size, float deviceScaleFactor)
 865 {
 866     SnappedRectInfo snappedGraphicsLayer;
 867     LayoutRect graphicsLayerRect = LayoutRect(toLayoutPoint(offset), size);
 868     snappedGraphicsLayer.m_snappedRect = LayoutRect(snapRectToDevicePixels(graphicsLayerRect, deviceScaleFactor));
 869     snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
 870     return snappedGraphicsLayer;
 871 }
 872 
<span class="line-modified"> 873 static LayoutSize computeOffsetFromAncestorGraphicsLayer(RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)</span>
 874 {
 875     if (!compositedAncestor)
 876         return toLayoutSize(location);
 877 
 878     // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
 879     // could be stale when a dynamic composited state change triggers a pre-order updateGeometry() traversal.
 880     LayoutSize ancestorSubpixelOffsetFromRenderer = compositedAncestor-&gt;backing()-&gt;subpixelOffsetFromRenderer();
 881     LayoutRect ancestorCompositedBounds = compositedAncestor-&gt;backing()-&gt;compositedBounds();
 882     LayoutSize floored = toLayoutSize(LayoutPoint(floorPointToDevicePixels(ancestorCompositedBounds.location() - ancestorSubpixelOffsetFromRenderer, deviceScaleFactor)));
 883     LayoutSize ancestorRendererOffsetFromAncestorGraphicsLayer = -(floored + ancestorSubpixelOffsetFromRenderer);
 884     return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
 885 }
 886 
 887 class ComputedOffsets {
 888 public:
 889     ComputedOffsets(const RenderLayer&amp; renderLayer, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)
 890         : m_renderLayer(renderLayer)
 891         , m_location(localRect.location())
 892         , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
 893         , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
</pre>
<hr />
<pre>
 917             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(compositedAncestor, m_location, RenderLayer::AdjustForColumns);
 918             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);
 919         }
 920         return m_fromAncestorGraphicsLayer.value();
 921     }
 922 
 923     Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
 924     Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
 925     Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
 926 
 927     const RenderLayer&amp; m_renderLayer;
 928     // Location is relative to the renderer.
 929     const LayoutPoint m_location;
 930     const LayoutSize m_parentGraphicsLayerOffset;
 931     const LayoutSize m_primaryGraphicsLayerOffset;
 932     float m_deviceScaleFactor;
 933 };
 934 
 935 LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const
 936 {
<span class="line-modified"> 937     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, LayoutRect());</span>
 938     return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
 939         deviceScaleFactor()));
 940 }
 941 
 942 // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
<span class="line-modified"> 943 LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(RenderLayer* compositedAncestor, LayoutSize&amp; ancestorClippingLayerOffset) const</span>
 944 {
 945     if (!compositedAncestor || !compositedAncestor-&gt;backing())
 946         return renderer().view().documentRect();
 947 
 948     auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
 949     LayoutRect parentGraphicsLayerRect;
 950     if (m_owningLayer.isInsideFragmentedFlow()) {
 951         // FIXME: flows/columns need work.
 952         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
 953         ancestorCompositedBounds.setLocation(LayoutPoint());
 954         parentGraphicsLayerRect = ancestorCompositedBounds;
 955     }
 956 
 957     if (ancestorBackingLayer-&gt;hasClippingLayer()) {
 958         // If the compositing ancestor has a layer to clip children, we parent in that, and therefore position relative to it.
 959         LayoutRect clippingBox = clipBox(downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer()));
 960         LayoutSize clippingBoxOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clippingBox.location(), deviceScaleFactor());
 961         parentGraphicsLayerRect = snappedGraphicsLayer(clippingBoxOffset, clippingBox.size(), deviceScaleFactor()).m_snappedRect;
 962     }
 963 
 964     if (compositedAncestor-&gt;hasCompositedScrollableOverflow()) {
 965         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
 966         auto&amp; renderBox = downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer());
 967         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();
 968         ScrollOffset scrollOffset = compositedAncestor-&gt;scrollOffset();
 969         parentGraphicsLayerRect = LayoutRect((paddingBoxIncludingScrollbar.location() - toLayoutSize(ancestorCompositedBounds.location()) - toLayoutSize(scrollOffset)), paddingBoxIncludingScrollbar.size());
 970     }
 971 
<span class="line-removed"> 972     if (m_ancestorClippingLayer) {</span>
<span class="line-removed"> 973         // Call calculateRects to get the backgroundRect which is what is used to clip the contents of this</span>
<span class="line-removed"> 974         // layer. Note that we call it with temporaryClipRects = true because normally when computing clip rects</span>
<span class="line-removed"> 975         // for a compositing layer, rootLayer is the layer itself.</span>
<span class="line-removed"> 976         ShouldRespectOverflowClip shouldRespectOverflowClip = compositedAncestor-&gt;isolatesCompositedBlending() ? RespectOverflowClip : IgnoreOverflowClip;</span>
<span class="line-removed"> 977         RenderLayer::ClipRectsContext clipRectsContext(compositedAncestor, TemporaryClipRects, IgnoreOverlayScrollbarSize, shouldRespectOverflowClip);</span>
<span class="line-removed"> 978         LayoutRect parentClipRect = m_owningLayer.backgroundClipRect(clipRectsContext).rect(); // FIXME: Incorrect for CSS regions.</span>
<span class="line-removed"> 979         ASSERT(!parentClipRect.isInfinite());</span>
<span class="line-removed"> 980         LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, parentClipRect.location(), deviceScaleFactor());</span>
<span class="line-removed"> 981         LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, parentClipRect.size(), deviceScaleFactor()).m_snappedRect;</span>
<span class="line-removed"> 982         // The primary layer is then parented in, and positioned relative to this clipping layer.</span>
<span class="line-removed"> 983         ancestorClippingLayerOffset = snappedClippingLayerRect.location() - parentGraphicsLayerRect.location();</span>
<span class="line-removed"> 984         parentGraphicsLayerRect = snappedClippingLayerRect;</span>
<span class="line-removed"> 985     }</span>
 986     return parentGraphicsLayerRect;
 987 }
 988 
 989 void RenderLayerBacking::updateGeometry()
 990 {
 991     ASSERT(!m_owningLayer.normalFlowListDirty());
 992     ASSERT(!m_owningLayer.zOrderListsDirty());
 993     ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
 994     ASSERT(!renderer().view().needsLayout());
 995 
 996     const RenderStyle&amp; style = renderer().style();
 997 
 998     bool isRunningAcceleratedTransformAnimation = false;
<span class="line-removed"> 999     bool isRunningAcceleratedOpacityAnimation = false;</span>
1000     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1001         if (auto* timeline = renderer().documentTimeline()) {</span>
1002             isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<span class="line-modified">1003             isRunningAcceleratedOpacityAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyOpacity);</span>
<span class="line-removed">1004         }</span>
<span class="line-removed">1005     } else {</span>
1006         isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<span class="line-removed">1007         isRunningAcceleratedOpacityAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyOpacity);</span>
<span class="line-removed">1008     }</span>
<span class="line-removed">1009 </span>
<span class="line-removed">1010     // Set transform property, if it is not animating. We have to do this here because the transform</span>
<span class="line-removed">1011     // is affected by the layer dimensions.</span>
<span class="line-removed">1012     if (!isRunningAcceleratedTransformAnimation)</span>
<span class="line-removed">1013         updateTransform(style);</span>
<span class="line-removed">1014 </span>
<span class="line-removed">1015     // Set opacity, if it is not animating.</span>
<span class="line-removed">1016     if (!isRunningAcceleratedOpacityAnimation)</span>
<span class="line-removed">1017         updateOpacity(style);</span>
1018 


1019     updateFilters(style);
1020 #if ENABLE(FILTERS_LEVEL_2)
1021     updateBackdropFilters(style);
1022 #endif
1023 #if ENABLE(CSS_COMPOSITING)
1024     updateBlendMode(style);
1025 #endif
1026 
<span class="line-removed">1027     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959</span>
<span class="line-removed">1028     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();</span>
<span class="line-removed">1029     m_graphicsLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-removed">1030     m_graphicsLayer-&gt;setBackfaceVisibility(style.backfaceVisibility() == BackfaceVisibility::Visible);</span>
<span class="line-removed">1031 </span>
1032     auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();
<span class="line-modified">1033     LayoutSize ancestorClippingLayerOffset;</span>
<span class="line-modified">1034     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor, ancestorClippingLayerOffset);</span>



























1035     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);
1036 
1037     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);


1038     m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
<span class="line-modified">1039     m_graphicsLayer-&gt;setPosition(primaryGraphicsLayerRect.location());</span>
<span class="line-modified">1040     m_graphicsLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>










1041 
1042     auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
1043         LayoutRect animatedBounds;
1044         if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
1045             return FloatRect(animatedBounds);
1046         return { };
1047     };
1048     m_graphicsLayer-&gt;setAnimationExtent(computeAnimationExtent());


1049 
<span class="line-modified">1050     ComputedOffsets rendererOffset(m_owningLayer, LayoutRect(), parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-modified">1051     if (m_ancestorClippingLayer) {</span>
<span class="line-removed">1052         // Clipping layer is parented in the ancestor layer.</span>
<span class="line-removed">1053         m_ancestorClippingLayer-&gt;setPosition(toLayoutPoint(ancestorClippingLayerOffset));</span>
<span class="line-removed">1054         m_ancestorClippingLayer-&gt;setSize(parentGraphicsLayerRect.size());</span>
<span class="line-removed">1055         m_ancestorClippingLayer-&gt;setOffsetFromRenderer(-rendererOffset.fromParentGraphicsLayer());</span>
<span class="line-removed">1056     }</span>
<span class="line-removed">1057 </span>
<span class="line-removed">1058     if (m_contentsContainmentLayer) {</span>
<span class="line-removed">1059         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-removed">1060         m_contentsContainmentLayer-&gt;setPosition(primaryGraphicsLayerRect.location());</span>
<span class="line-removed">1061         m_graphicsLayer-&gt;setPosition(FloatPoint());</span>
<span class="line-removed">1062         // Use the same size as m_graphicsLayer so transforms behave correctly.</span>
<span class="line-removed">1063         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>
<span class="line-removed">1064     }</span>
1065 
1066     // Compute renderer offset from primary graphics layer. Note that primaryGraphicsLayerRect is in parentGraphicsLayer&#39;s coordinate system which is not necessarily
1067     // the same as the ancestor graphics layer.
1068     OffsetFromRenderer primaryGraphicsLayerOffsetFromRenderer;
1069     LayoutSize oldSubpixelOffsetFromRenderer = m_subpixelOffsetFromRenderer;
1070     primaryGraphicsLayerOffsetFromRenderer = computeOffsetFromRenderer(-rendererOffset.fromPrimaryGraphicsLayer(), deviceScaleFactor());
1071     m_subpixelOffsetFromRenderer = primaryGraphicsLayerOffsetFromRenderer.m_subpixelOffset;

1072 
1073     if (primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset != m_graphicsLayer-&gt;offsetFromRenderer()) {
1074         m_graphicsLayer-&gt;setOffsetFromRenderer(primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset);
1075         positionOverflowControlsLayers();
1076     }
1077 
<span class="line-removed">1078     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {</span>
<span class="line-removed">1079         // For non-root layers, background is always painted by the primary graphics layer.</span>
<span class="line-removed">1080         ASSERT(!m_backgroundLayer);</span>
<span class="line-removed">1081         // Subpixel offset from graphics layer or size changed.</span>
<span class="line-removed">1082         bool hadSubpixelRounding = !m_subpixelOffsetFromRenderer.isZero() || compositedBounds().size() != primaryGraphicsLayerRect.size();</span>
<span class="line-removed">1083         m_graphicsLayer-&gt;setContentsOpaque(!hadSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));</span>
<span class="line-removed">1084     }</span>
<span class="line-removed">1085 </span>
1086     // If we have a layer that clips children, position it.
1087     LayoutRect clippingBox;
1088     if (auto* clipLayer = clippingLayer()) {
1089         // clipLayer is the m_childContainmentLayer.
1090         clippingBox = clipBox(downcast&lt;RenderBox&gt;(renderer()));
1091         // Clipping layer is parented in the primary graphics layer.
1092         LayoutSize clipBoxOffsetFromGraphicsLayer = toLayoutSize(clippingBox.location()) + rendererOffset.fromPrimaryGraphicsLayer();
1093         SnappedRectInfo snappedClippingGraphicsLayer = snappedGraphicsLayer(clipBoxOffsetFromGraphicsLayer, clippingBox.size(), deviceScaleFactor());
1094         clipLayer-&gt;setPosition(snappedClippingGraphicsLayer.m_snappedRect.location());
1095         clipLayer-&gt;setSize(snappedClippingGraphicsLayer.m_snappedRect.size());
1096         clipLayer-&gt;setOffsetFromRenderer(toLayoutSize(clippingBox.location() - snappedClippingGraphicsLayer.m_snapDelta));
1097 







1098         if (m_childClippingMaskLayer &amp;&amp; !m_scrollContainerLayer) {
1099             m_childClippingMaskLayer-&gt;setSize(clipLayer-&gt;size());
1100             m_childClippingMaskLayer-&gt;setPosition(FloatPoint());
1101             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(clipLayer-&gt;offsetFromRenderer());
1102         }
1103     }
1104 
1105     if (m_maskLayer)
1106         updateMaskingLayerGeometry();
1107 
1108     if (renderer().hasTransformRelatedProperty()) {
1109         // Update properties that depend on layer dimensions.
1110         FloatPoint3D transformOrigin = computeTransformOriginForPainting(downcast&lt;RenderBox&gt;(renderer()).borderBoxRect());
1111         FloatPoint layerOffset = roundPointToDevicePixels(toLayoutPoint(rendererOffset.fromParentGraphicsLayer()), deviceScaleFactor());
1112         // Compute the anchor point, which is in the center of the renderer box unless transform-origin is set.
1113         FloatPoint3D anchor(
1114             primaryGraphicsLayerRect.width() ? ((layerOffset.x() - primaryGraphicsLayerRect.x()) + transformOrigin.x()) / primaryGraphicsLayerRect.width() : 0.5,
1115             primaryGraphicsLayerRect.height() ? ((layerOffset.y() - primaryGraphicsLayerRect.y())+ transformOrigin.y()) / primaryGraphicsLayerRect.height() : 0.5,
1116             transformOrigin.z());
1117 
</pre>
<hr />
<pre>
1125             TransformationMatrix t = owningLayer().perspectiveTransform();
1126 
1127             if (clipLayer) {
1128                 clipLayer-&gt;setChildrenTransform(t);
1129                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1130             }
1131             else
1132                 m_graphicsLayer-&gt;setChildrenTransform(t);
1133         } else {
1134             if (clipLayer)
1135                 clipLayer-&gt;setChildrenTransform(TransformationMatrix());
1136             else
1137                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1138         }
1139     } else {
1140         m_graphicsLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1141         if (m_contentsContainmentLayer)
1142             m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1143     }
1144 
<span class="line-removed">1145     if (m_foregroundLayer) {</span>
<span class="line-removed">1146         FloatPoint foregroundPosition;</span>
<span class="line-removed">1147         FloatSize foregroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-removed">1148         FloatSize foregroundOffset = m_graphicsLayer-&gt;offsetFromRenderer();</span>
<span class="line-removed">1149         if (hasClippingLayer()) {</span>
<span class="line-removed">1150             // If we have a clipping layer (which clips descendants), then the foreground layer is a child of it,</span>
<span class="line-removed">1151             // so that it gets correctly sorted with children. In that case, position relative to the clipping layer.</span>
<span class="line-removed">1152             foregroundSize = FloatSize(clippingBox.size());</span>
<span class="line-removed">1153             foregroundOffset = toFloatSize(clippingBox.location());</span>
<span class="line-removed">1154         }</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156         m_foregroundLayer-&gt;setPosition(foregroundPosition);</span>
<span class="line-removed">1157         m_foregroundLayer-&gt;setSize(foregroundSize);</span>
<span class="line-removed">1158         m_foregroundLayer-&gt;setOffsetFromRenderer(foregroundOffset);</span>
<span class="line-removed">1159     }</span>
<span class="line-removed">1160 </span>
<span class="line-removed">1161     if (m_backgroundLayer) {</span>
<span class="line-removed">1162         FloatPoint backgroundPosition;</span>
<span class="line-removed">1163         FloatSize backgroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-removed">1164         if (backgroundLayerPaintsFixedRootBackground()) {</span>
<span class="line-removed">1165             const FrameView&amp; frameView = renderer().view().frameView();</span>
<span class="line-removed">1166             backgroundPosition = frameView.scrollPositionForFixedPosition();</span>
<span class="line-removed">1167             backgroundSize = frameView.layoutSize();</span>
<span class="line-removed">1168         } else {</span>
<span class="line-removed">1169             auto boundingBox = renderer().objectBoundingBox();</span>
<span class="line-removed">1170             backgroundPosition = boundingBox.location();</span>
<span class="line-removed">1171             backgroundSize = boundingBox.size();</span>
<span class="line-removed">1172         }</span>
<span class="line-removed">1173         m_backgroundLayer-&gt;setPosition(backgroundPosition);</span>
<span class="line-removed">1174         m_backgroundLayer-&gt;setSize(backgroundSize);</span>
<span class="line-removed">1175         m_backgroundLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());</span>
<span class="line-removed">1176     }</span>
<span class="line-removed">1177 </span>
1178     if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
1179         auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
1180         reflectionBacking-&gt;updateGeometry();
1181 
1182         // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
1183         // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
1184         FloatRect layerBounds = this-&gt;compositedBounds();
1185         FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
1186         reflectionBacking-&gt;graphicsLayer()-&gt;setReplicatedLayerPosition(FloatPoint(layerBounds.location() - reflectionLayerBounds.location()));
1187     }
1188 
1189     if (m_scrollContainerLayer) {
1190         ASSERT(m_scrolledContentsLayer);
1191         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
<span class="line-modified">1192         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();</span>
1193         LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
1194 
1195         // FIXME: need to do some pixel snapping here.
<span class="line-modified">1196         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBoxIncludingScrollbar.location() - parentLayerBounds.location()));</span>
1197         m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
1198 
1199         ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
1200         updateScrollOffset(scrollOffset);
<span class="line-removed">1201 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1202         m_scrolledContentsLayer-&gt;setPosition({ }); // FIXME: necessary?</span>
<span class="line-removed">1203 #endif</span>
1204 
1205         FloatSize oldScrollingLayerOffset = m_scrollContainerLayer-&gt;offsetFromRenderer();
<span class="line-modified">1206         m_scrollContainerLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBoxIncludingScrollbar.location()));</span>
1207 
1208         if (m_childClippingMaskLayer) {
1209             m_childClippingMaskLayer-&gt;setPosition(m_scrollContainerLayer-&gt;position());
1210             m_childClippingMaskLayer-&gt;setSize(m_scrollContainerLayer-&gt;size());
<span class="line-modified">1211             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBoxIncludingScrollbar.location()));</span>
1212         }
1213 
1214         bool paddingBoxOffsetChanged = oldScrollingLayerOffset != m_scrollContainerLayer-&gt;offsetFromRenderer();
1215 
1216         IntSize scrollSize(m_owningLayer.scrollWidth(), m_owningLayer.scrollHeight());
1217         if (scrollSize != m_scrolledContentsLayer-&gt;size() || paddingBoxOffsetChanged)
1218             m_scrolledContentsLayer-&gt;setNeedsDisplay();
1219 
1220         m_scrolledContentsLayer-&gt;setSize(scrollSize);
1221         m_scrolledContentsLayer-&gt;setScrollOffset(scrollOffset, GraphicsLayer::DontSetNeedsDisplay);
<span class="line-modified">1222         m_scrolledContentsLayer-&gt;setOffsetFromRenderer(toLayoutSize(paddingBoxIncludingScrollbar.location()), GraphicsLayer::DontSetNeedsDisplay);</span>


























1223 
<span class="line-modified">1224         if (m_foregroundLayer) {</span>
<span class="line-modified">1225             m_foregroundLayer-&gt;setSize(m_scrolledContentsLayer-&gt;size());</span>
<span class="line-modified">1226             m_foregroundLayer-&gt;setOffsetFromRenderer(m_scrolledContentsLayer-&gt;offsetFromRenderer() - toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()));</span>








1227         }



1228     }
1229 
1230     // If this layer was created just for clipping or to apply perspective, it doesn&#39;t need its own backing store.
1231     LayoutRect ancestorCompositedBounds = compositedAncestor ? compositedAncestor-&gt;backing()-&gt;compositedBounds() : LayoutRect();
1232     setRequiresOwnBackingStore(compositor().requiresOwnBackingStore(m_owningLayer, compositedAncestor,
1233         LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()), ancestorCompositedBounds));
1234 #if ENABLE(FILTERS_LEVEL_2)
1235     updateBackdropFiltersGeometry();
1236 #endif
1237     updateAfterWidgetResize();
1238 
1239     if (subpixelOffsetFromRendererChanged(oldSubpixelOffsetFromRenderer, m_subpixelOffsetFromRenderer, deviceScaleFactor()) &amp;&amp; canIssueSetNeedsDisplay())
1240         setContentsNeedDisplay();
1241 }
1242 
1243 void RenderLayerBacking::setLocationOfScrolledContents(ScrollOffset scrollOffset, ScrollingLayerPositionAction setOrSync)
1244 {
<span class="line-removed">1245 #if PLATFORM(IOS_FAMILY)</span>
1246     if (setOrSync == ScrollingLayerPositionAction::Sync)
1247         m_scrollContainerLayer-&gt;syncBoundsOrigin(scrollOffset);
1248     else
1249         m_scrollContainerLayer-&gt;setBoundsOrigin(scrollOffset);
<span class="line-removed">1250 #else</span>
<span class="line-removed">1251     if (setOrSync == ScrollingLayerPositionAction::Sync)</span>
<span class="line-removed">1252         m_scrolledContentsLayer-&gt;syncPosition(-scrollOffset);</span>
<span class="line-removed">1253     else</span>
<span class="line-removed">1254         m_scrolledContentsLayer-&gt;setPosition(-scrollOffset);</span>
<span class="line-removed">1255 #endif</span>
1256 }
1257 
1258 void RenderLayerBacking::updateScrollOffset(ScrollOffset scrollOffset)
1259 {
<span class="line-modified">1260     if (m_owningLayer.isInUserScroll()) {</span>
1261         // If scrolling is happening externally, we don&#39;t want to touch the layer bounds origin here because that will cause jitter.
1262         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Sync);
1263         m_owningLayer.setRequiresScrollPositionReconciliation(true);
1264     } else {
1265         // Note that we implement the contents offset via the bounds origin on this layer, rather than a position on the sublayer.
1266         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Set);
1267         m_owningLayer.setRequiresScrollPositionReconciliation(false);
1268     }


1269 }
1270 
1271 void RenderLayerBacking::updateAfterDescendants()
1272 {
1273     // FIXME: this potentially duplicates work we did in updateConfiguration().
1274     PaintedContentsInfo contentsInfo(*this);
1275     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText() &amp;&amp; FontCascade::isSubpixelAntialiasingAvailable());
1276 
1277     if (!m_owningLayer.isRenderViewLayer()) {
1278         bool didUpdateContentsRect = false;
1279         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
1280         if (!didUpdateContentsRect &amp;&amp; m_graphicsLayer-&gt;usesContentsLayer())
1281             resetContentsRect();
1282     }
1283 
1284     updateDrawsContent(contentsInfo);
1285 






1286     m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
1287     if (m_scrollContainerLayer) {
1288         m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
1289         m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
1290     }
1291 }
1292 
1293 // FIXME: Avoid repaints when clip path changes.
1294 void RenderLayerBacking::updateMaskingLayerGeometry()
1295 {
1296     m_maskLayer-&gt;setSize(m_graphicsLayer-&gt;size());
1297     m_maskLayer-&gt;setPosition(FloatPoint());
1298     m_maskLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());
1299 
1300     if (!m_maskLayer-&gt;drawsContent()) {
1301         if (renderer().hasClipPath()) {
1302             ASSERT(renderer().style().clipPath()-&gt;type() != ClipPathOperation::Reference);
1303 
1304             WindRule windRule;
1305             // FIXME: Use correct reference box for inlines: https://bugs.webkit.org/show_bug.cgi?id=129047
</pre>
<hr />
<pre>
1316             m_maskLayer-&gt;setShapeLayerWindRule(windRule);
1317         }
1318     }
1319 }
1320 
1321 void RenderLayerBacking::updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
1322 {
1323     if (!m_owningLayer.hasVisibleContent())
1324         return;
1325 
1326     // The order of operations here matters, since the last valid type of contents needs
1327     // to also update the contentsRect.
1328     updateDirectlyCompositedBackgroundColor(contentsInfo, didUpdateContentsRect);
1329     updateDirectlyCompositedBackgroundImage(contentsInfo, didUpdateContentsRect);
1330 }
1331 
1332 void RenderLayerBacking::updateInternalHierarchy()
1333 {
1334     // m_foregroundLayer has to be inserted in the correct order with child layers,
1335     // so it&#39;s not inserted here.
<span class="line-modified">1336     if (m_ancestorClippingLayer)</span>
<span class="line-modified">1337         m_ancestorClippingLayer-&gt;removeAllChildren();</span>











1338 
1339     if (m_contentsContainmentLayer) {
1340         m_contentsContainmentLayer-&gt;removeAllChildren();
<span class="line-modified">1341         if (m_ancestorClippingLayer)</span>
<span class="line-modified">1342             m_ancestorClippingLayer-&gt;addChild(*m_contentsContainmentLayer);</span>
1343     }
1344 
1345     if (m_backgroundLayer)
1346         m_contentsContainmentLayer-&gt;addChild(*m_backgroundLayer);
1347 
1348     if (m_contentsContainmentLayer)
1349         m_contentsContainmentLayer-&gt;addChild(*m_graphicsLayer);
<span class="line-modified">1350     else if (m_ancestorClippingLayer)</span>
<span class="line-modified">1351         m_ancestorClippingLayer-&gt;addChild(*m_graphicsLayer);</span>
1352 
1353     if (m_childContainmentLayer)
1354         m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
1355 
1356     if (m_scrollContainerLayer) {
1357         auto* superlayer = m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
1358         superlayer-&gt;addChild(*m_scrollContainerLayer);
1359     }
1360 
1361     // The clip for child layers does not include space for overflow controls, so they exist as
1362     // siblings of the clipping layer if we have one. Normal children of this layer are set as
1363     // children of the clipping layer.
1364     if (m_layerForHorizontalScrollbar)
1365         m_graphicsLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
1366 
1367     if (m_layerForVerticalScrollbar)
1368         m_graphicsLayer-&gt;addChild(*m_layerForVerticalScrollbar);
1369 
1370     if (m_layerForScrollCorner)
1371         m_graphicsLayer-&gt;addChild(*m_layerForScrollCorner);
1372 }
1373 
1374 void RenderLayerBacking::resetContentsRect()
1375 {
1376     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
1377 
1378     if (is&lt;RenderBox&gt;(renderer())) {
1379         LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<span class="line-modified">1380         boxRect.move(contentOffsetInCompostingLayer());</span>
1381         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
1382         m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
1383     }
1384 
1385     m_graphicsLayer-&gt;setContentsTileSize(IntSize());
1386     m_graphicsLayer-&gt;setContentsTilePhase(IntSize());
1387 }
1388 
1389 void RenderLayerBacking::updateDrawsContent()
1390 {
1391     PaintedContentsInfo contentsInfo(*this);
1392     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText());
1393 
1394     updateDrawsContent(contentsInfo);
1395 }
1396 
1397 void RenderLayerBacking::updateDrawsContent(PaintedContentsInfo&amp; contentsInfo)
1398 {
1399     if (m_scrollContainerLayer) {
1400         // We don&#39;t have to consider overflow controls, because we know that the scrollbars are drawn elsewhere.
1401         // m_graphicsLayer only needs backing store if the non-scrolling parts (background, outlines, borders, shadows etc) need to paint.
1402         // m_scrollContainerLayer never has backing store.
1403         // m_scrolledContentsLayer only needs backing store if the scrolled contents need to paint.
1404         bool hasNonScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasVisibleBoxDecorationsOrBackground();
1405         m_graphicsLayer-&gt;setDrawsContent(hasNonScrollingPaintedContent);
1406 
<span class="line-modified">1407         bool hasScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; (renderer().hasBackground() || contentsInfo.paintsContent());</span>
1408         m_scrolledContentsLayer-&gt;setDrawsContent(hasScrollingPaintedContent);
1409         return;
1410     }
1411 
1412     bool hasPaintedContent = containsPaintedContent(contentsInfo);
1413 
1414     m_paintsSubpixelAntialiasedText = renderer().settings().subpixelAntialiasedLayerTextEnabled() &amp;&amp; contentsInfo.paintsSubpixelAntialiasedText();
1415 
1416     // FIXME: we could refine this to only allocate backing for one of these layers if possible.
1417     m_graphicsLayer-&gt;setDrawsContent(hasPaintedContent);
1418     if (m_foregroundLayer) {
1419         m_foregroundLayer-&gt;setDrawsContent(hasPaintedContent);
1420         m_foregroundLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1421         // The text content is painted into the foreground layer.
1422         // FIXME: this ignores SVG background images which may contain text.
1423         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(false);
1424     } else
1425         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1426 
1427     if (m_backgroundLayer)
1428         m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
1429 }
1430 
































































1431 // Return true if the layer changed.
<span class="line-modified">1432 bool RenderLayerBacking::updateAncestorClippingLayer(bool needsAncestorClip)</span>
1433 {
1434     bool layersChanged = false;
1435 
1436     if (needsAncestorClip) {
<span class="line-modified">1437         if (!m_ancestorClippingLayer) {</span>
<span class="line-modified">1438             m_ancestorClippingLayer = createGraphicsLayer(&quot;ancestor clipping&quot;);</span>
<span class="line-modified">1439             m_ancestorClippingLayer-&gt;setMasksToBounds(true);</span>









1440             layersChanged = true;
1441         }
<span class="line-modified">1442     } else if (hasAncestorClippingLayer()) {</span>
<span class="line-modified">1443         willDestroyLayer(m_ancestorClippingLayer.get());</span>
<span class="line-modified">1444         GraphicsLayer::unparentAndClear(m_ancestorClippingLayer);</span>


1445         layersChanged = true;
1446     }
1447 
1448     return layersChanged;
1449 }
1450 
1451 // Return true if the layer changed.
1452 bool RenderLayerBacking::updateDescendantClippingLayer(bool needsDescendantClip)
1453 {
1454     bool layersChanged = false;
1455 
1456     if (needsDescendantClip) {
1457         if (!m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking) {
1458             m_childContainmentLayer = createGraphicsLayer(&quot;child clipping&quot;);
1459             m_childContainmentLayer-&gt;setMasksToBounds(true);
1460             layersChanged = true;
1461         }
1462     } else if (hasClippingLayer()) {
1463         willDestroyLayer(m_childContainmentLayer.get());
1464         GraphicsLayer::unparentAndClear(m_childContainmentLayer);
</pre>
<hr />
<pre>
1500 bool RenderLayerBacking::requiresVerticalScrollbarLayer() const
1501 {
1502     if (!m_owningLayer.hasOverlayScrollbars())
1503         return false;
1504     return m_owningLayer.verticalScrollbar();
1505 }
1506 
1507 bool RenderLayerBacking::requiresScrollCornerLayer() const
1508 {
1509     if (!m_owningLayer.hasOverlayScrollbars())
1510         return false;
1511     return !m_owningLayer.scrollCornerAndResizerRect().isEmpty();
1512 }
1513 
1514 bool RenderLayerBacking::updateOverflowControlsLayers(bool needsHorizontalScrollbarLayer, bool needsVerticalScrollbarLayer, bool needsScrollCornerLayer)
1515 {
1516     bool horizontalScrollbarLayerChanged = false;
1517     if (needsHorizontalScrollbarLayer) {
1518         if (!m_layerForHorizontalScrollbar) {
1519             m_layerForHorizontalScrollbar = createGraphicsLayer(&quot;horizontal scrollbar&quot;);
<span class="line-modified">1520             m_layerForHorizontalScrollbar-&gt;setCanDetachBackingStore(false);</span>
1521             horizontalScrollbarLayerChanged = true;
1522         }
1523     } else if (m_layerForHorizontalScrollbar) {
1524         willDestroyLayer(m_layerForHorizontalScrollbar.get());
1525         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
1526         horizontalScrollbarLayerChanged = true;
1527     }
1528 
1529     bool verticalScrollbarLayerChanged = false;
1530     if (needsVerticalScrollbarLayer) {
1531         if (!m_layerForVerticalScrollbar) {
1532             m_layerForVerticalScrollbar = createGraphicsLayer(&quot;vertical scrollbar&quot;);
<span class="line-modified">1533             m_layerForVerticalScrollbar-&gt;setCanDetachBackingStore(false);</span>
1534             verticalScrollbarLayerChanged = true;
1535         }
1536     } else if (m_layerForVerticalScrollbar) {
1537         willDestroyLayer(m_layerForVerticalScrollbar.get());
1538         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
1539         verticalScrollbarLayerChanged = true;
1540     }
1541 
1542     bool scrollCornerLayerChanged = false;
1543     if (needsScrollCornerLayer) {
1544         if (!m_layerForScrollCorner) {
1545             m_layerForScrollCorner = createGraphicsLayer(&quot;scroll corner&quot;);
<span class="line-modified">1546             m_layerForScrollCorner-&gt;setCanDetachBackingStore(false);</span>
1547             scrollCornerLayerChanged = true;
1548         }
1549     } else if (m_layerForScrollCorner) {
1550         willDestroyLayer(m_layerForScrollCorner.get());
1551         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
1552         scrollCornerLayerChanged = true;
1553     }
1554 
1555     if (auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator()) {
1556         if (horizontalScrollbarLayerChanged)
1557             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, HorizontalScrollbar);
1558         if (verticalScrollbarLayerChanged)
1559             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, VerticalScrollbar);
1560     }
1561 
1562     return horizontalScrollbarLayerChanged || verticalScrollbarLayerChanged || scrollCornerLayerChanged;
1563 }
1564 
1565 void RenderLayerBacking::positionOverflowControlsLayers()
1566 {
</pre>
<hr />
<pre>
1593         }
1594         layer-&gt;setDrawsContent(m_owningLayer.verticalScrollbar() &amp;&amp; !layer-&gt;usesContentsLayer());
1595     }
1596 
1597     if (auto* layer = layerForScrollCorner()) {
1598         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
1599         layer-&gt;setPosition(scrollCornerAndResizer.location() - offsetFromRenderer);
1600         layer-&gt;setSize(scrollCornerAndResizer.size());
1601         layer-&gt;setDrawsContent(!scrollCornerAndResizer.isEmpty());
1602     }
1603 }
1604 
1605 bool RenderLayerBacking::updateForegroundLayer(bool needsForegroundLayer)
1606 {
1607     bool layerChanged = false;
1608     if (needsForegroundLayer) {
1609         if (!m_foregroundLayer) {
1610             String layerName = m_owningLayer.name() + &quot; (foreground)&quot;;
1611             m_foregroundLayer = createGraphicsLayer(layerName);
1612             m_foregroundLayer-&gt;setDrawsContent(true);
<span class="line-removed">1613             m_foregroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintForeground);</span>
1614             layerChanged = true;
1615         }
1616     } else if (m_foregroundLayer) {
1617         willDestroyLayer(m_foregroundLayer.get());
1618         GraphicsLayer::unparentAndClear(m_foregroundLayer);
1619         layerChanged = true;
1620     }
1621 
<span class="line-removed">1622     if (layerChanged) {</span>
<span class="line-removed">1623         m_graphicsLayer-&gt;setNeedsDisplay();</span>
<span class="line-removed">1624         m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
<span class="line-removed">1625     }</span>
<span class="line-removed">1626 </span>
1627     return layerChanged;
1628 }
1629 
1630 bool RenderLayerBacking::updateBackgroundLayer(bool needsBackgroundLayer)
1631 {
1632     bool layerChanged = false;
1633     if (needsBackgroundLayer) {
1634         if (!m_backgroundLayer) {
1635             String layerName = m_owningLayer.name() + &quot; (background)&quot;;
1636             m_backgroundLayer = createGraphicsLayer(layerName);
1637             m_backgroundLayer-&gt;setDrawsContent(true);
1638             m_backgroundLayer-&gt;setAnchorPoint(FloatPoint3D());
<span class="line-removed">1639             m_backgroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintBackground);</span>
1640             layerChanged = true;
1641         }
1642 
1643         if (!m_contentsContainmentLayer) {
1644             String layerName = m_owningLayer.name() + &quot; (contents containment)&quot;;
1645             m_contentsContainmentLayer = createGraphicsLayer(layerName);
1646             m_contentsContainmentLayer-&gt;setAppliesPageScale(true);
1647             m_graphicsLayer-&gt;setAppliesPageScale(false);
1648             layerChanged = true;
1649         }
1650     } else {
1651         if (m_backgroundLayer) {
1652             willDestroyLayer(m_backgroundLayer.get());
1653             GraphicsLayer::unparentAndClear(m_backgroundLayer);
1654             layerChanged = true;
1655         }
1656         if (m_contentsContainmentLayer) {
1657             willDestroyLayer(m_contentsContainmentLayer.get());
1658             GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
1659             layerChanged = true;
1660             m_graphicsLayer-&gt;setAppliesPageScale(true);
1661         }
1662     }
1663 
<span class="line-removed">1664     if (layerChanged)</span>
<span class="line-removed">1665         m_graphicsLayer-&gt;setNeedsDisplay();</span>
<span class="line-removed">1666 </span>
1667     return layerChanged;
1668 }
1669 
1670 // Masking layer is used for masks or clip-path.
<span class="line-modified">1671 void RenderLayerBacking::updateMaskingLayer(bool hasMask, bool hasClipPath)</span>
1672 {
1673     bool layerChanged = false;
1674     if (hasMask || hasClipPath) {
<span class="line-modified">1675         GraphicsLayerPaintingPhase maskPhases = 0;</span>
1676         if (hasMask)
<span class="line-modified">1677             maskPhases = GraphicsLayerPaintMask;</span>
1678 
1679         if (hasClipPath) {
1680             // If we have a mask, we need to paint the combined clip-path and mask into the mask layer.
1681             if (hasMask || renderer().style().clipPath()-&gt;type() == ClipPathOperation::Reference || !GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape))
<span class="line-modified">1682                 maskPhases |= GraphicsLayerPaintClipPath;</span>
1683         }
1684 
<span class="line-modified">1685         bool paintsContent = maskPhases;</span>
1686         GraphicsLayer::Type requiredLayerType = paintsContent ? GraphicsLayer::Type::Normal : GraphicsLayer::Type::Shape;
1687         if (m_maskLayer &amp;&amp; m_maskLayer-&gt;type() != requiredLayerType) {
1688             m_graphicsLayer-&gt;setMaskLayer(nullptr);
1689             willDestroyLayer(m_maskLayer.get());
1690             GraphicsLayer::clear(m_maskLayer);
1691         }
1692 
1693         if (!m_maskLayer) {
1694             m_maskLayer = createGraphicsLayer(&quot;mask&quot;, requiredLayerType);
1695             m_maskLayer-&gt;setDrawsContent(paintsContent);
1696             m_maskLayer-&gt;setPaintingPhase(maskPhases);
1697             layerChanged = true;
1698             m_graphicsLayer-&gt;setMaskLayer(m_maskLayer.copyRef());
1699             // We need a geometry update to size the new mask layer.
1700             m_owningLayer.setNeedsCompositingGeometryUpdate();
1701         }
1702     } else if (m_maskLayer) {
1703         m_graphicsLayer-&gt;setMaskLayer(nullptr);
1704         willDestroyLayer(m_maskLayer.get());
1705         GraphicsLayer::clear(m_maskLayer);
1706         layerChanged = true;
1707     }
1708 
<span class="line-modified">1709     if (layerChanged)</span>
<span class="line-removed">1710         m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
1711 }
1712 
1713 void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
1714 {
1715     if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
1716         if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {

1717             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<span class="line-removed">1718             boxRect.move(contentOffsetInCompostingLayer());</span>
1719             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">1720             if (clippingLayer()-&gt;setMasksToBoundsRect(contentsClippingRect)) {</span>
<span class="line-modified">1721                 clippingLayer()-&gt;setMaskLayer(nullptr);</span>


1722                 GraphicsLayer::clear(m_childClippingMaskLayer);
1723                 return;
1724             }
1725 
1726             if (!m_childClippingMaskLayer) {
1727                 m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
1728                 m_childClippingMaskLayer-&gt;setDrawsContent(true);
<span class="line-modified">1729                 m_childClippingMaskLayer-&gt;setPaintingPhase(GraphicsLayerPaintChildClippingMask);</span>
1730                 clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
1731             }
1732         }
1733     } else {
1734         if (m_childClippingMaskLayer) {
1735             if (hasClippingLayer())
1736                 clippingLayer()-&gt;setMaskLayer(nullptr);
1737             GraphicsLayer::clear(m_childClippingMaskLayer);
1738         } else
1739             if (hasClippingLayer())
<span class="line-modified">1740                 clippingLayer()-&gt;setMasksToBoundsRect(FloatRoundedRect(FloatRect(FloatPoint(), clippingLayer()-&gt;size())));</span>
1741     }
1742 }
1743 
1744 bool RenderLayerBacking::updateScrollingLayers(bool needsScrollingLayers)
1745 {
1746     if (needsScrollingLayers == !!m_scrollContainerLayer)
1747         return false;
1748 
1749     if (!m_scrollContainerLayer) {
<span class="line-modified">1750         // Outer layer which corresponds with the scroll view.</span>
1751         m_scrollContainerLayer = createGraphicsLayer(&quot;scroll container&quot;, GraphicsLayer::Type::ScrollContainer);

1752         m_scrollContainerLayer-&gt;setDrawsContent(false);
1753         m_scrollContainerLayer-&gt;setMasksToBounds(true);
1754 
1755         // Inner layer which renders the content that scrolls.
<span class="line-modified">1756         m_scrolledContentsLayer = createGraphicsLayer(&quot;scrolled contents&quot;);</span>
1757         m_scrolledContentsLayer-&gt;setDrawsContent(true);
1758         m_scrolledContentsLayer-&gt;setAnchorPoint({ });
<span class="line-removed">1759 </span>
<span class="line-removed">1760         GraphicsLayerPaintingPhase paintPhase = GraphicsLayerPaintOverflowContents | GraphicsLayerPaintCompositedScroll;</span>
<span class="line-removed">1761         if (!m_foregroundLayer)</span>
<span class="line-removed">1762             paintPhase |= GraphicsLayerPaintForeground;</span>
<span class="line-removed">1763         m_scrolledContentsLayer-&gt;setPaintingPhase(paintPhase);</span>
1764         m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
1765     } else {
1766         compositor().willRemoveScrollingLayerWithBacking(m_owningLayer, *this);
1767 
1768         willDestroyLayer(m_scrollContainerLayer.get());
1769         willDestroyLayer(m_scrolledContentsLayer.get());
1770 
1771         GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
1772         GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
1773     }
1774 
<span class="line-removed">1775     m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
<span class="line-removed">1776     m_graphicsLayer-&gt;setNeedsDisplay(); // Because painting phases changed.</span>
<span class="line-removed">1777 </span>
1778     if (m_scrollContainerLayer)
1779         compositor().didAddScrollingLayer(m_owningLayer);
1780 
1781     return true;
1782 }
1783 
<span class="line-removed">1784 OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerBacking::coordinatedScrollingRoles() const</span>
<span class="line-removed">1785 {</span>
<span class="line-removed">1786     auto&amp; compositor = this-&gt;compositor();</span>
<span class="line-removed">1787 </span>
<span class="line-removed">1788     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;</span>
<span class="line-removed">1789     if (compositor.isViewportConstrainedFixedOrStickyLayer(m_owningLayer))</span>
<span class="line-removed">1790         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);</span>
<span class="line-removed">1791 </span>
<span class="line-removed">1792     if (compositor.useCoordinatedScrollingForLayer(m_owningLayer))</span>
<span class="line-removed">1793         coordinationRoles.add(ScrollCoordinationRole::Scrolling);</span>
<span class="line-removed">1794 </span>
<span class="line-removed">1795     if (compositor.isLayerForIFrameWithScrollCoordinatedContents(m_owningLayer))</span>
<span class="line-removed">1796         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);</span>
<span class="line-removed">1797 </span>
<span class="line-removed">1798     return coordinationRoles;</span>
<span class="line-removed">1799 }</span>
<span class="line-removed">1800 </span>
1801 void RenderLayerBacking::detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt; roles)
1802 {
<span class="line-modified">1803     if (!m_scrollingNodeID &amp;&amp; !m_frameHostingNodeID &amp;&amp; !m_viewportConstrainedNodeID)</span>
1804         return;
1805 
1806     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
1807     if (!scrollingCoordinator)
1808         return;
1809 
1810     if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_scrollingNodeID) {
<span class="line-modified">1811         LOG(Compositing, &quot;Detaching Scrolling node %&quot; PRIu64, m_scrollingNodeID);</span>
1812         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_scrollingNodeID);
1813         m_scrollingNodeID = 0;
1814     }
1815 
<span class="line-modified">1816     if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_frameHostingNodeID) {</span>
<span class="line-modified">1817         LOG(Compositing, &quot;Detaching FrameHosting node %&quot; PRIu64, m_frameHostingNodeID);</span>





1818         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_frameHostingNodeID);
1819         m_frameHostingNodeID = 0;
1820     }
1821 
1822     if (roles.contains(ScrollCoordinationRole::ViewportConstrained) &amp;&amp; m_viewportConstrainedNodeID) {
<span class="line-modified">1823         LOG(Compositing, &quot;Detaching ViewportConstrained node %&quot; PRIu64, m_viewportConstrainedNodeID);</span>
1824         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_viewportConstrainedNodeID);
1825         m_viewportConstrainedNodeID = 0;
1826     }
<span class="line-removed">1827 }</span>
1828 
<span class="line-modified">1829 void RenderLayerBacking::setIsScrollCoordinatedWithViewportConstrainedRole(bool viewportCoordinated)</span>
<span class="line-modified">1830 {</span>
<span class="line-modified">1831     m_graphicsLayer-&gt;setIsViewportConstrained(viewportCoordinated);</span>


1832 }
1833 
<span class="line-modified">1834 GraphicsLayerPaintingPhase RenderLayerBacking::paintingPhaseForPrimaryLayer() const</span>
1835 {
<span class="line-modified">1836     unsigned phase = 0;</span>
<span class="line-modified">1837     if (!m_backgroundLayer)</span>
<span class="line-removed">1838         phase |= GraphicsLayerPaintBackground;</span>
<span class="line-removed">1839     if (!m_foregroundLayer)</span>
<span class="line-removed">1840         phase |= GraphicsLayerPaintForeground;</span>
1841 
<span class="line-modified">1842     if (m_scrolledContentsLayer) {</span>
<span class="line-modified">1843         phase &amp;= ~GraphicsLayerPaintForeground;</span>
<span class="line-modified">1844         phase |= GraphicsLayerPaintCompositedScroll;</span>






1845     }
1846 
<span class="line-modified">1847     return static_cast&lt;GraphicsLayerPaintingPhase&gt;(phase);</span>
1848 }
1849 
1850 float RenderLayerBacking::compositingOpacity(float rendererOpacity) const
1851 {
1852     float finalOpacity = rendererOpacity;
1853 
1854     for (auto* curr = m_owningLayer.parent(); curr; curr = curr-&gt;parent()) {
1855         // We only care about parents that are stacking contexts.
1856         // Recall that opacity creates stacking context.
<span class="line-modified">1857         if (!curr-&gt;isStackingContext())</span>
1858             continue;
1859 
1860         // If we found a compositing layer, we want to compute opacity
1861         // relative to it. So we can break here.
1862         if (curr-&gt;isComposited())
1863             break;
1864 
1865         finalOpacity *= curr-&gt;renderer().opacity();
1866     }
1867 
1868     return finalOpacity;
1869 }
1870 
1871 // FIXME: Code is duplicated in RenderLayer. Also, we should probably not consider filters a box decoration here.
1872 static inline bool hasVisibleBoxDecorations(const RenderStyle&amp; style)
1873 {
1874     return style.hasVisibleBorder() || style.hasBorderRadius() || style.hasOutline() || style.hasAppearance() || style.boxShadow() || style.hasFilter();
1875 }
1876 
1877 static bool canDirectlyCompositeBackgroundBackgroundImage(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
1998     if (!m_isFrameLayerWithTiledBacking)
1999         return;
2000 
2001     Color backgroundColor;
2002     bool viewIsTransparent = compositor().viewHasTransparentBackground(&amp;backgroundColor);
2003 
2004     if (m_backgroundLayerPaintsFixedRootBackground &amp;&amp; m_backgroundLayer) {
2005         if (m_isMainFrameRenderViewLayer) {
2006             m_backgroundLayer-&gt;setBackgroundColor(backgroundColor);
2007             m_backgroundLayer-&gt;setContentsOpaque(!viewIsTransparent);
2008         }
2009 
2010         m_graphicsLayer-&gt;setBackgroundColor(Color());
2011         m_graphicsLayer-&gt;setContentsOpaque(false);
2012     } else if (m_isMainFrameRenderViewLayer) {
2013         m_graphicsLayer-&gt;setBackgroundColor(backgroundColor);
2014         m_graphicsLayer-&gt;setContentsOpaque(!viewIsTransparent);
2015     }
2016 }
2017 

































2018 static bool supportsDirectlyCompositedBoxDecorations(const RenderLayerModelObject&amp; renderer)
2019 {
2020     if (!GraphicsLayer::supportsBackgroundColorContent())
2021         return false;
2022 
2023     const RenderStyle&amp; style = renderer.style();
2024     if (renderer.hasClip())
2025         return false;
2026 
2027     if (hasPaintedBoxDecorationsOrBackgroundImage(style))
2028         return false;
2029 
2030     // FIXME: We can&#39;t create a directly composited background if this
2031     // layer will have children that intersect with the background layer.
2032     // A better solution might be to introduce a flattening layer if
2033     // we do direct box decoration composition.
2034     // https://bugs.webkit.org/show_bug.cgi?id=119461
2035     if (hasPerspectiveOrPreserves3D(style))
2036         return false;
2037 
</pre>
<hr />
<pre>
2085     auto&amp; element = downcast&lt;RenderEmbeddedObject&gt;(renderer).frameOwnerElement();
2086     if (!is&lt;HTMLPlugInElement&gt;(element))
2087         return false;
2088 
2089     return downcast&lt;HTMLPlugInElement&gt;(element).isRestartedPlugin();
2090 }
2091 
2092 static bool isCompositedPlugin(RenderObject&amp; renderer)
2093 {
2094     return is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing();
2095 }
2096 
2097 // A &quot;simple container layer&quot; is a RenderLayer which has no visible content to render.
2098 // It may have no children, or all its children may be themselves composited.
2099 // This is a useful optimization, because it allows us to avoid allocating backing store.
2100 bool RenderLayerBacking::isSimpleContainerCompositingLayer(PaintedContentsInfo&amp; contentsInfo) const
2101 {
2102     if (m_owningLayer.isRenderViewLayer())
2103         return false;
2104 



2105     if (renderer().isRenderReplaced() &amp;&amp; (!isCompositedPlugin(renderer()) || isRestartedPlugin(renderer())))
2106         return false;
2107 
2108     if (renderer().isTextControl())
2109         return false;
2110 
2111     if (contentsInfo.paintsBoxDecorations() || contentsInfo.paintsContent())
2112         return false;
2113 
2114     if (renderer().style().backgroundClip() == FillBox::Text)
2115         return false;
2116 
2117     if (renderer().isDocumentElementRenderer() &amp;&amp; m_owningLayer.isolatesCompositedBlending())
2118         return false;
2119 
2120     return true;
2121 }
2122 
2123 // Returning true stops the traversal.
2124 enum class LayerTraversal { Continue, Stop };
</pre>
<hr />
<pre>
2222 // that require painting. Direct compositing saves backing store.
2223 bool RenderLayerBacking::isDirectlyCompositedImage() const
2224 {
2225     if (!is&lt;RenderImage&gt;(renderer()) || m_owningLayer.hasVisibleBoxDecorationsOrBackground() || m_owningLayer.paintsWithFilters() || renderer().hasClip())
2226         return false;
2227 
2228 #if ENABLE(VIDEO)
2229     if (is&lt;RenderMedia&gt;(renderer()))
2230         return false;
2231 #endif
2232 
2233     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2234     if (auto* cachedImage = imageRenderer.cachedImage()) {
2235         if (!cachedImage-&gt;hasImage())
2236             return false;
2237 
2238         auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2239         if (!is&lt;BitmapImage&gt;(image))
2240             return false;
2241 
<span class="line-modified">2242         if (downcast&lt;BitmapImage&gt;(*image).orientationForCurrentFrame() != DefaultImageOrientation)</span>
2243             return false;
2244 
2245 #if (PLATFORM(GTK) || PLATFORM(WPE))
2246         // GTK and WPE ports don&#39;t support rounded rect clipping at TextureMapper level, so they cannot
2247         // directly composite images that have border-radius propery. Draw them as non directly composited
2248         // content instead. See https://bugs.webkit.org/show_bug.cgi?id=174157.
2249         if (imageRenderer.style().hasBorderRadius())
2250             return false;
2251 #endif
2252 
2253         return m_graphicsLayer-&gt;shouldDirectlyCompositeImage(image);
2254     }
2255 
2256     return false;
2257 }
2258 
2259 void RenderLayerBacking::contentChanged(ContentChangeType changeType)
2260 {
2261     PaintedContentsInfo contentsInfo(*this);
2262     if ((changeType == ImageChanged) &amp;&amp; contentsInfo.isDirectlyCompositedImage()) {
2263         updateImageContents(contentsInfo);
2264         return;
2265     }
2266 





2267     if ((changeType == BackgroundImageChanged) &amp;&amp; canDirectlyCompositeBackgroundBackgroundImage(renderer().style()))
2268         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2269 
2270     if ((changeType == MaskImageChanged) &amp;&amp; m_maskLayer)
2271         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2272 
<span class="line-modified">2273 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)</span>
2274     if ((changeType == CanvasChanged || changeType == CanvasPixelsChanged) &amp;&amp; renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {



2275         m_graphicsLayer-&gt;setContentsNeedsDisplay();
2276         return;
2277     }
2278 #endif
2279 }
2280 
2281 void RenderLayerBacking::updateImageContents(PaintedContentsInfo&amp; contentsInfo)
2282 {
2283     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2284 
2285     auto* cachedImage = imageRenderer.cachedImage();
2286     if (!cachedImage)
2287         return;
2288 
2289     auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2290     if (!image)
2291         return;
2292 
2293     // We have to wait until the image is fully loaded before setting it on the layer.
2294     if (!cachedImage-&gt;isLoaded())
2295         return;
2296 
2297     // This is a no-op if the layer doesn&#39;t have an inner layer for the image.
2298     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
2299 
2300     LayoutRect boxRect(LayoutPoint(), imageRenderer.size());
<span class="line-modified">2301     boxRect.move(contentOffsetInCompostingLayer());</span>
2302     FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
2303     m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
2304 
2305     m_graphicsLayer-&gt;setContentsToImage(image);
2306 
2307     updateDrawsContent(contentsInfo);
2308 
2309     // Image animation is &quot;lazy&quot;, in that it automatically stops unless someone is drawing
2310     // the image. So we have to kick the animation each time; this has the downside that the
2311     // image will keep animating, even if its layer is not visible.
2312     image-&gt;startAnimation();
2313 }
2314 
2315 FloatPoint3D RenderLayerBacking::computeTransformOriginForPainting(const LayoutRect&amp; borderBox) const
2316 {
2317     const RenderStyle&amp; style = renderer().style();
2318     float deviceScaleFactor = this-&gt;deviceScaleFactor();
2319 
2320     FloatPoint3D origin;
2321     origin.setX(roundToDevicePixel(floatValueForLength(style.transformOriginX(), borderBox.width()), deviceScaleFactor));
2322     origin.setY(roundToDevicePixel(floatValueForLength(style.transformOriginY(), borderBox.height()), deviceScaleFactor));
2323     origin.setZ(style.transformOriginZ());
2324 
2325     return origin;
2326 }
2327 
2328 // Return the offset from the top-left of this compositing layer at which the renderer&#39;s contents are painted.
<span class="line-modified">2329 LayoutSize RenderLayerBacking::contentOffsetInCompostingLayer() const</span>
2330 {
2331     return LayoutSize(-m_compositedBounds.x() + m_compositedBoundsOffsetFromGraphicsLayer.width(), -m_compositedBounds.y() + m_compositedBoundsOffsetFromGraphicsLayer.height());
2332 }
2333 
2334 LayoutRect RenderLayerBacking::contentsBox() const
2335 {
2336     if (!is&lt;RenderBox&gt;(renderer()))
2337         return LayoutRect();
2338 
2339     auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
2340     LayoutRect contentsRect;
2341 #if ENABLE(VIDEO)
2342     if (is&lt;RenderVideo&gt;(renderBox))
2343         contentsRect = downcast&lt;RenderVideo&gt;(renderBox).videoBox();
2344     else
2345 #endif
2346     if (is&lt;RenderReplaced&gt;(renderBox)) {
2347         RenderReplaced&amp; renderReplaced = downcast&lt;RenderReplaced&gt;(renderBox);
2348         contentsRect = renderReplaced.replacedContentRect();
2349     } else
2350         contentsRect = renderBox.contentBoxRect();
2351 
<span class="line-modified">2352     contentsRect.move(contentOffsetInCompostingLayer());</span>
2353     return contentsRect;
2354 }
2355 
2356 static LayoutRect backgroundRectForBox(const RenderBox&amp; box)
2357 {
2358     switch (box.style().backgroundClip()) {
2359     case FillBox::Border:
2360         return box.borderBoxRect();
2361     case FillBox::Padding:
2362         return box.paddingBoxRect();
2363     case FillBox::Content:
2364         return box.contentBoxRect();
2365     default:
2366         break;
2367     }
2368 
2369     ASSERT_NOT_REACHED();
2370     return LayoutRect();
2371 }
2372 
2373 FloatRect RenderLayerBacking::backgroundBoxForSimpleContainerPainting() const
2374 {
2375     if (!is&lt;RenderBox&gt;(renderer()))
2376         return FloatRect();
2377 
2378     LayoutRect backgroundBox = backgroundRectForBox(downcast&lt;RenderBox&gt;(renderer()));
<span class="line-modified">2379     backgroundBox.move(contentOffsetInCompostingLayer());</span>
2380     return snapRectToDevicePixels(backgroundBox, deviceScaleFactor());
2381 }
2382 
2383 GraphicsLayer* RenderLayerBacking::parentForSublayers() const
2384 {
2385     if (m_scrolledContentsLayer)
2386         return m_scrolledContentsLayer.get();
2387 
2388     return m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
2389 }
2390 
2391 GraphicsLayer* RenderLayerBacking::childForSuperlayers() const
2392 {
<span class="line-modified">2393     if (m_ancestorClippingLayer)</span>
<span class="line-modified">2394         return m_ancestorClippingLayer.get();</span>
2395 
2396     if (m_contentsContainmentLayer)
2397         return m_contentsContainmentLayer.get();
2398 
2399     return m_graphicsLayer.get();
2400 }
2401 
2402 bool RenderLayerBacking::paintsIntoWindow() const
2403 {
2404 #if USE(COORDINATED_GRAPHICS)
2405         return false;
2406 #endif
2407 
2408     if (m_isFrameLayerWithTiledBacking)
2409         return false;
2410 
2411     if (m_owningLayer.isRenderViewLayer()) {
2412 #if PLATFORM(IOS_FAMILY) || USE(COORDINATED_GRAPHICS)
2413         if (compositor().inForcedCompositingMode())
2414             return false;
</pre>
<hr />
<pre>
2426         return;
2427 
2428     m_requiresOwnBackingStore = requiresOwnBacking;
2429 
2430     // This affects the answer to paintsIntoCompositedAncestor(), which in turn affects
2431     // cached clip rects, so when it changes we have to clear clip rects on descendants.
2432     m_owningLayer.clearClipRectsIncludingDescendants(PaintingClipRects);
2433     m_owningLayer.computeRepaintRectsIncludingDescendants();
2434 
2435     compositor().repaintInCompositedAncestor(m_owningLayer, compositedBounds());
2436 }
2437 
2438 void RenderLayerBacking::setContentsNeedDisplay(GraphicsLayer::ShouldClipToLayer shouldClip)
2439 {
2440     ASSERT(!paintsIntoCompositedAncestor());
2441 
2442     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2443     if (!m_owningLayer.isRenderViewLayer())
2444         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2445 


2446     auto&amp; frameView = renderer().view().frameView();
2447     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2448         frameView.addTrackedRepaintRect(owningLayer().absoluteBoundingBoxForPainting());
2449 
2450     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2451         // By default, setNeedsDisplay will clip to the size of the GraphicsLayer, which does not include margin tiles.
2452         // So if the TiledBacking has a margin that needs to be invalidated, we need to send in a rect to setNeedsDisplayInRect
2453         // that is large enough to include the margin. TiledBacking::bounds() includes the margin.
2454         auto* tiledBacking = this-&gt;tiledBacking();
2455         FloatRect rectToRepaint = tiledBacking ? tiledBacking-&gt;bounds() : FloatRect(FloatPoint(0, 0), m_graphicsLayer-&gt;size());
2456         m_graphicsLayer-&gt;setNeedsDisplayInRect(rectToRepaint, shouldClip);
2457     }
2458 
2459     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent())
2460         m_foregroundLayer-&gt;setNeedsDisplay();
2461 
2462     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent())
2463         m_backgroundLayer-&gt;setNeedsDisplay();
2464 
2465     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent())
2466         m_maskLayer-&gt;setNeedsDisplay();
2467 
2468     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent())
2469         m_childClippingMaskLayer-&gt;setNeedsDisplay();
2470 
2471     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent())
2472         m_scrolledContentsLayer-&gt;setNeedsDisplay();
2473 }
2474 
2475 // r is in the coordinate space of the layer&#39;s render object
2476 void RenderLayerBacking::setContentsNeedDisplayInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
2477 {
2478     ASSERT(!paintsIntoCompositedAncestor());
2479 
2480     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2481     if (!m_owningLayer.isRenderViewLayer())
2482         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2483 


2484     FloatRect pixelSnappedRectForPainting = snapRectToDevicePixels(r, deviceScaleFactor());
2485     auto&amp; frameView = renderer().view().frameView();
2486     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2487         frameView.addTrackedRepaintRect(pixelSnappedRectForPainting);
2488 
2489     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2490         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2491         layerDirtyRect.move(-m_graphicsLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2492         m_graphicsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2493     }
2494 
2495     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent()) {
2496         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2497         layerDirtyRect.move(-m_foregroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2498         m_foregroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2499     }
2500 
2501     // FIXME: need to split out repaints for the background.
2502     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent()) {
2503         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2504         layerDirtyRect.move(-m_backgroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2505         m_backgroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2506     }
2507 
2508     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent()) {
2509         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2510         layerDirtyRect.move(-m_maskLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2511         m_maskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2512     }
2513 
2514     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent()) {
2515         FloatRect layerDirtyRect = r;
2516         layerDirtyRect.move(-m_childClippingMaskLayer-&gt;offsetFromRenderer());
2517         m_childClippingMaskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect);
2518     }
2519 
2520     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
2521         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2522         layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);
<span class="line-removed">2523 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">2524         // Account for the fact that RenderLayerBacking::updateGeometry() bakes scrollOffset into offsetFromRenderer on iOS,</span>
<span class="line-removed">2525         // but the repaint rect is computed without taking the scroll position into account (see shouldApplyClipAndScrollPositionForRepaint()).</span>
<span class="line-removed">2526         layerDirtyRect.moveBy(-m_owningLayer.scrollPosition());</span>
<span class="line-removed">2527 #endif</span>
2528         m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2529     }
2530 }
2531 
2532 void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
2533     const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">2534     OptionSet&lt;PaintBehavior&gt; paintBehavior, GraphicsLayerPaintingPhase paintingPhase)</span>
2535 {
<span class="line-modified">2536     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; paintingPhase != GraphicsLayerPaintChildClippingMask) {</span>
2537 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
2538         // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
2539         // when pages are restored from the PageCache.
2540         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in PageCache
2541         ASSERT_NOT_REACHED();
2542 #endif
2543         return;
2544     }
2545 
2546     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;
<span class="line-modified">2547     if (paintingPhase &amp; GraphicsLayerPaintBackground)</span>
2548         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
<span class="line-modified">2549     if (paintingPhase &amp; GraphicsLayerPaintForeground)</span>
2550         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
<span class="line-modified">2551     if (paintingPhase &amp; GraphicsLayerPaintMask)</span>
2552         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
<span class="line-modified">2553     if (paintingPhase &amp; GraphicsLayerPaintClipPath)</span>
2554         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
<span class="line-modified">2555     if (paintingPhase &amp; GraphicsLayerPaintChildClippingMask)</span>
2556         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
<span class="line-modified">2557     if (paintingPhase &amp; GraphicsLayerPaintOverflowContents)</span>
2558         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
<span class="line-modified">2559     if (paintingPhase &amp; GraphicsLayerPaintCompositedScroll)</span>
2560         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
2561 
2562     if (graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)
2563         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
2564     else if (compositor().fixedRootBackgroundLayer())
2565         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);
2566 
2567 #ifndef NDEBUG
2568     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
2569 #endif
2570 
<span class="line-modified">2571     FrameView::PaintingState paintingState;</span>
<span class="line-modified">2572     if (m_owningLayer.isRenderViewLayer())</span>
<span class="line-removed">2573         renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
2574 
<span class="line-modified">2575     // FIXME: GraphicsLayers need a way to split for RenderFragmentContainers.</span>
<span class="line-modified">2576     RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);</span>
<span class="line-modified">2577     m_owningLayer.paintLayerContents(context, paintingInfo, paintFlags);</span>
2578 
<span class="line-modified">2579     if (m_owningLayer.containsDirtyOverlayScrollbars())</span>
<span class="line-removed">2580         m_owningLayer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);</span>
2581 
<span class="line-modified">2582     if (m_owningLayer.isRenderViewLayer())</span>
<span class="line-modified">2583         renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>






























2584 
2585     compositor().didPaintBacking(this);


















































2586 
<span class="line-modified">2587     ASSERT(!m_owningLayer.m_usedTransparency);</span>



































































2588 }
2589 
2590 // Up-call from compositing layer drawing callback.
<span class="line-modified">2591 void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, GraphicsLayerPaintingPhase paintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
2592 {
2593 #ifndef NDEBUG
2594     renderer().page().setIsPainting(true);
2595 #endif
2596 
2597 #if PLATFORM(MAC)
2598     LocalDefaultSystemAppearance localAppearance(renderer().useDarkAppearance());
2599 #endif
2600 
2601     // The dirtyRect is in the coords of the painting root.
2602     FloatRect adjustedClipRect = clip;
2603     adjustedClipRect.move(m_subpixelOffsetFromRenderer);
2604     IntRect dirtyRect = enclosingIntRect(adjustedClipRect);
2605 
2606     if (!graphicsLayer-&gt;repaintCount())
2607         layerPaintBehavior |= GraphicsLayerPaintFirstTilePaint;
2608 
2609     if (graphicsLayer == m_graphicsLayer.get()
2610         || graphicsLayer == m_foregroundLayer.get()
2611         || graphicsLayer == m_backgroundLayer.get()
2612         || graphicsLayer == m_maskLayer.get()
2613         || graphicsLayer == m_childClippingMaskLayer.get()
2614         || graphicsLayer == m_scrolledContentsLayer.get()) {
<span class="line-removed">2615         InspectorInstrumentation::willPaint(renderer());</span>
2616 
<span class="line-modified">2617         if (!(paintingPhase &amp; GraphicsLayerPaintOverflowContents))</span>
2618             dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
2619 
2620         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
2621         OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
2622         if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
2623             behavior.add(PaintBehavior::Snapshotting);
2624 
2625         if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
2626             behavior.add(PaintBehavior::TileFirstPaint);
2627 
2628         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);
2629 
<span class="line-modified">2630         InspectorInstrumentation::didPaint(renderer(), dirtyRect);</span>


2631     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
2632         paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
2633     } else if (graphicsLayer == layerForVerticalScrollbar()) {
2634         paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
2635     } else if (graphicsLayer == layerForScrollCorner()) {
2636         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
<span class="line-modified">2637         context.save();</span>
2638         context.translate(-scrollCornerAndResizer.location());
2639         LayoutRect transformedClip = LayoutRect(clip);
2640         transformedClip.moveBy(scrollCornerAndResizer.location());
2641         m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
2642         m_owningLayer.paintResizer(context, IntPoint(), transformedClip);
<span class="line-removed">2643         context.restore();</span>
2644     }
2645 #ifndef NDEBUG
2646     renderer().page().setIsPainting(false);
2647 #endif
2648 }
2649 
2650 float RenderLayerBacking::pageScaleFactor() const
2651 {
2652     return compositor().pageScaleFactor();
2653 }
2654 
2655 float RenderLayerBacking::zoomedOutPageScaleFactor() const
2656 {
2657     return compositor().zoomedOutPageScaleFactor();
2658 }
2659 
2660 float RenderLayerBacking::deviceScaleFactor() const
2661 {
2662     return compositor().deviceScaleFactor();
2663 }
</pre>
<hr />
<pre>
2741 }
2742 
2743 bool RenderLayerBacking::useGiantTiles() const
2744 {
2745     return renderer().settings().useGiantTiles();
2746 }
2747 
2748 void RenderLayerBacking::logFilledVisibleFreshTile(unsigned blankPixelCount)
2749 {
2750     if (auto* loggingClient = renderer().page().performanceLoggingClient())
2751         loggingClient-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::FilledTile, MonotonicTime::now(), blankPixelCount);
2752 }
2753 
2754 #ifndef NDEBUG
2755 void RenderLayerBacking::verifyNotPainting()
2756 {
2757     ASSERT(!renderer().page().isPainting());
2758 }
2759 #endif
2760 
<span class="line-modified">2761 bool RenderLayerBacking::startAnimation(double timeOffset, const Animation* anim, const KeyframeList&amp; keyframes)</span>
2762 {
2763     bool hasOpacity = keyframes.containsProperty(CSSPropertyOpacity);
2764     bool hasTransform = renderer().isBox() &amp;&amp; keyframes.containsProperty(CSSPropertyTransform);
2765     bool hasFilter = keyframes.containsProperty(CSSPropertyFilter);
2766 
2767     bool hasBackdropFilter = false;
2768 #if ENABLE(FILTERS_LEVEL_2)
2769     hasBackdropFilter = keyframes.containsProperty(CSSPropertyWebkitBackdropFilter);
2770 #endif
2771 
2772     if (!hasOpacity &amp;&amp; !hasTransform &amp;&amp; !hasFilter &amp;&amp; !hasBackdropFilter)
2773         return false;
2774 
2775     KeyframeValueList transformVector(AnimatedPropertyTransform);
2776     KeyframeValueList opacityVector(AnimatedPropertyOpacity);
2777     KeyframeValueList filterVector(AnimatedPropertyFilter);
2778 #if ENABLE(FILTERS_LEVEL_2)
2779     KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
2780 #endif
2781 
2782     size_t numKeyframes = keyframes.size();
2783     for (size_t i = 0; i &lt; numKeyframes; ++i) {
2784         const KeyframeValue&amp; currentKeyframe = keyframes[i];
2785         const RenderStyle* keyframeStyle = currentKeyframe.style();
2786         double key = currentKeyframe.key();
2787 
2788         if (!keyframeStyle)
2789             continue;
2790 
2791         auto* tf = currentKeyframe.timingFunction();
2792 
2793         bool isFirstOrLastKeyframe = key == 0 || key == 1;
2794         if ((hasTransform &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyTransform))
<span class="line-modified">2795             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(key, keyframeStyle-&gt;transform(), tf));</span>
2796 
2797         if ((hasOpacity &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyOpacity))
<span class="line-modified">2798             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(key, keyframeStyle-&gt;opacity(), tf));</span>
2799 
2800         if ((hasFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyFilter))
<span class="line-modified">2801             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;filter(), tf));</span>
2802 
2803 #if ENABLE(FILTERS_LEVEL_2)
2804         if ((hasBackdropFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyWebkitBackdropFilter))
<span class="line-modified">2805             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;backdropFilter(), tf));</span>
2806 #endif
2807     }
2808 
2809     if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
2810         return false;
2811 
2812     bool didAnimate = false;
2813 
<span class="line-modified">2814     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), anim, keyframes.animationName(), timeOffset))</span>
2815         didAnimate = true;
2816 
<span class="line-modified">2817     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
2818         didAnimate = true;
2819 
<span class="line-modified">2820     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
2821         didAnimate = true;
2822 
2823 #if ENABLE(FILTERS_LEVEL_2)
<span class="line-modified">2824     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
2825         didAnimate = true;
2826 #endif
2827 
2828     if (didAnimate)
2829         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
2830 
2831     return didAnimate;
2832 }
2833 
2834 void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
2835 {
2836     m_graphicsLayer-&gt;pauseAnimation(animationName, timeOffset);
2837 }
2838 
2839 void RenderLayerBacking::animationSeeked(double timeOffset, const String&amp; animationName)
2840 {
2841     m_graphicsLayer-&gt;seekAnimation(animationName, timeOffset);
2842 }
2843 
2844 void RenderLayerBacking::animationFinished(const String&amp; animationName)
2845 {
2846     m_graphicsLayer-&gt;removeAnimation(animationName);
2847     m_owningLayer.setNeedsPostLayoutCompositingUpdate();
2848 }
2849 
2850 bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
2851 {
2852     bool didAnimate = false;
2853 
2854     ASSERT(property != CSSPropertyInvalid);
2855 
2856     if (property == CSSPropertyOpacity) {
2857         const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
2858         if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
2859             KeyframeValueList opacityVector(AnimatedPropertyOpacity);
<span class="line-modified">2860             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));</span>
<span class="line-modified">2861             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));</span>
2862             // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
2863             if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
2864                 // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
2865                 updateOpacity(*toStyle);
2866                 didAnimate = true;
2867             }
2868         }
2869     }
2870 
2871     if (property == CSSPropertyTransform &amp;&amp; m_owningLayer.hasTransform()) {
2872         const Animation* transformAnim = toStyle-&gt;transitionForProperty(CSSPropertyTransform);
2873         if (transformAnim &amp;&amp; !transformAnim-&gt;isEmptyOrZeroDuration()) {
2874             KeyframeValueList transformVector(AnimatedPropertyTransform);
<span class="line-modified">2875             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(0, fromStyle-&gt;transform()));</span>
<span class="line-modified">2876             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(1, toStyle-&gt;transform()));</span>
2877             if (m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), transformAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyTransform), timeOffset)) {
2878                 // To ensure that the correct transform is visible when the animation ends, also set the final transform.
2879                 updateTransform(*toStyle);
2880                 didAnimate = true;
2881             }
2882         }
2883     }
2884 
2885     if (property == CSSPropertyFilter &amp;&amp; m_owningLayer.hasFilter()) {
2886         const Animation* filterAnim = toStyle-&gt;transitionForProperty(CSSPropertyFilter);
2887         if (filterAnim &amp;&amp; !filterAnim-&gt;isEmptyOrZeroDuration()) {
2888             KeyframeValueList filterVector(AnimatedPropertyFilter);
<span class="line-modified">2889             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;filter()));</span>
<span class="line-modified">2890             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;filter()));</span>
2891             if (m_graphicsLayer-&gt;addAnimation(filterVector, FloatSize(), filterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyFilter), timeOffset)) {
2892                 // To ensure that the correct filter is visible when the animation ends, also set the final filter.
2893                 updateFilters(*toStyle);
2894                 didAnimate = true;
2895             }
2896         }
2897     }
2898 
2899 #if ENABLE(FILTERS_LEVEL_2)
2900     if (property == CSSPropertyWebkitBackdropFilter &amp;&amp; m_owningLayer.hasBackdropFilter()) {
2901         const Animation* backdropFilterAnim = toStyle-&gt;transitionForProperty(CSSPropertyWebkitBackdropFilter);
2902         if (backdropFilterAnim &amp;&amp; !backdropFilterAnim-&gt;isEmptyOrZeroDuration()) {
2903             KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
<span class="line-modified">2904             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;backdropFilter()));</span>
<span class="line-modified">2905             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;backdropFilter()));</span>
2906             if (m_graphicsLayer-&gt;addAnimation(backdropFilterVector, FloatSize(), backdropFilterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyWebkitBackdropFilter), timeOffset)) {
2907                 // To ensure that the correct backdrop filter is visible when the animation ends, also set the final backdrop filter.
2908                 updateBackdropFilters(*toStyle);
2909                 didAnimate = true;
2910             }
2911         }
2912     }
2913 #endif
2914 
2915     if (didAnimate)
2916         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
2917 
2918     return didAnimate;
2919 }
2920 
2921 void RenderLayerBacking::transitionPaused(double timeOffset, CSSPropertyID property)
2922 {
2923     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
2924     if (animatedProperty != AnimatedPropertyInvalid)
2925         m_graphicsLayer-&gt;pauseAnimation(GraphicsLayer::animationNameForTransition(animatedProperty), timeOffset);
</pre>
<hr />
<pre>
3039         break;
3040     }
3041     return AnimatedPropertyInvalid;
3042 }
3043 
3044 CompositingLayerType RenderLayerBacking::compositingLayerType() const
3045 {
3046     if (m_graphicsLayer-&gt;usesContentsLayer())
3047         return MediaCompositingLayer;
3048 
3049     if (m_graphicsLayer-&gt;drawsContent())
3050         return m_graphicsLayer-&gt;tiledBacking() ? TiledCompositingLayer : NormalCompositingLayer;
3051 
3052     return ContainerCompositingLayer;
3053 }
3054 
3055 double RenderLayerBacking::backingStoreMemoryEstimate() const
3056 {
3057     double backingMemory;
3058 
<span class="line-modified">3059     // m_ancestorClippingLayer, m_contentsContainmentLayer and m_childContainmentLayer are just used for masking or containment, so have no backing.</span>
3060     backingMemory = m_graphicsLayer-&gt;backingStoreMemoryEstimate();
3061     if (m_foregroundLayer)
3062         backingMemory += m_foregroundLayer-&gt;backingStoreMemoryEstimate();
3063     if (m_backgroundLayer)
3064         backingMemory += m_backgroundLayer-&gt;backingStoreMemoryEstimate();
3065     if (m_maskLayer)
3066         backingMemory += m_maskLayer-&gt;backingStoreMemoryEstimate();
3067     if (m_childClippingMaskLayer)
3068         backingMemory += m_childClippingMaskLayer-&gt;backingStoreMemoryEstimate();
3069 
3070     if (m_scrolledContentsLayer)
3071         backingMemory += m_scrolledContentsLayer-&gt;backingStoreMemoryEstimate();
3072 
3073     if (m_layerForHorizontalScrollbar)
3074         backingMemory += m_layerForHorizontalScrollbar-&gt;backingStoreMemoryEstimate();
3075 
3076     if (m_layerForVerticalScrollbar)
3077         backingMemory += m_layerForVerticalScrollbar-&gt;backingStoreMemoryEstimate();
3078 
3079     if (m_layerForScrollCorner)
</pre>
<hr />
<pre>
3081 
3082     return backingMemory;
3083 }
3084 
3085 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayerBacking&amp; backing)
3086 {
3087     ts &lt;&lt; &quot;RenderLayerBacking &quot; &lt;&lt; &amp;backing &lt;&lt; &quot; bounds &quot; &lt;&lt; backing.compositedBounds();
3088 
3089     if (backing.isFrameLayerWithTiledBacking())
3090         ts &lt;&lt; &quot; frame layer tiled backing&quot;;
3091     if (backing.paintsIntoWindow())
3092         ts &lt;&lt; &quot; paintsIntoWindow&quot;;
3093     if (backing.paintsIntoCompositedAncestor())
3094         ts &lt;&lt; &quot; paintsIntoCompositedAncestor&quot;;
3095 
3096     ts &lt;&lt; &quot; primary layer ID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID();
3097     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
3098         ts &lt;&lt; &quot; viewport constrained scrolling node &quot; &lt;&lt; nodeID;
3099     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
3100         ts &lt;&lt; &quot; scrolling node &quot; &lt;&lt; nodeID;




3101     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
3102         ts &lt;&lt; &quot; frame hosting node &quot; &lt;&lt; nodeID;


3103     return ts;
3104 }
3105 
3106 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerBacking.h&quot;
  29 
  30 #include &quot;BitmapImage.h&quot;
  31 #include &quot;CSSAnimationController.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CachedImage.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;DocumentTimeline.h&quot;
<span class="line-added">  37 #include &quot;EventRegion.h&quot;</span>
  38 #include &quot;Frame.h&quot;
  39 #include &quot;FrameView.h&quot;
  40 #include &quot;GraphicsContext.h&quot;
  41 #include &quot;GraphicsLayer.h&quot;
  42 #include &quot;HTMLBodyElement.h&quot;
  43 #include &quot;HTMLCanvasElement.h&quot;
  44 #include &quot;HTMLIFrameElement.h&quot;
  45 #include &quot;HTMLMediaElement.h&quot;
  46 #include &quot;HTMLNames.h&quot;
  47 #include &quot;HTMLPlugInElement.h&quot;
  48 #include &quot;InspectorInstrumentation.h&quot;
  49 #include &quot;KeyframeList.h&quot;
<span class="line-added">  50 #include &quot;LayerAncestorClippingStack.h&quot;</span>
  51 #include &quot;Logging.h&quot;
  52 #include &quot;Page.h&quot;
  53 #include &quot;PerformanceLoggingClient.h&quot;
  54 #include &quot;PluginViewBase.h&quot;
  55 #include &quot;ProgressTracker.h&quot;
  56 #include &quot;RenderFragmentContainer.h&quot;
  57 #include &quot;RenderFragmentedFlow.h&quot;
  58 #include &quot;RenderHTMLCanvas.h&quot;
  59 #include &quot;RenderIFrame.h&quot;
  60 #include &quot;RenderImage.h&quot;
  61 #include &quot;RenderLayerCompositor.h&quot;
  62 #include &quot;RenderEmbeddedObject.h&quot;
  63 #include &quot;RenderMedia.h&quot;
  64 #include &quot;RenderVideo.h&quot;
  65 #include &quot;RenderView.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;ScrollingCoordinator.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;StyleResolver.h&quot;
  70 #include &quot;TiledBacking.h&quot;
</pre>
<hr />
<pre>
 222     }
 223 
 224     createPrimaryGraphicsLayer();
 225 #if ENABLE(FULLSCREEN_API)
 226     setRequiresBackgroundLayer(layer.renderer().isRenderFullScreen());
 227 #endif
 228 
 229     if (auto* tiledBacking = this-&gt;tiledBacking()) {
 230         tiledBacking-&gt;setIsInWindow(renderer().page().isInWindow());
 231 
 232         if (m_isFrameLayerWithTiledBacking) {
 233             tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(renderer().settings().scrollingPerformanceLoggingEnabled());
 234             adjustTiledBackingCoverage();
 235         }
 236     }
 237 }
 238 
 239 RenderLayerBacking::~RenderLayerBacking()
 240 {
 241     // Note that m_owningLayer-&gt;backing() is null here.
<span class="line-modified"> 242     updateAncestorClipping(false, nullptr);</span>
 243     updateChildClippingStrategy(false);
 244     updateDescendantClippingLayer(false);
 245     updateOverflowControlsLayers(false, false, false);
 246     updateForegroundLayer(false);
 247     updateBackgroundLayer(false);
 248     updateMaskingLayer(false, false);
 249     updateScrollingLayers(false);
 250 
 251     ASSERT(!m_viewportConstrainedNodeID);
 252     ASSERT(!m_scrollingNodeID);
 253     ASSERT(!m_frameHostingNodeID);
<span class="line-added"> 254     ASSERT(!m_positioningNodeID);</span>
 255 
 256     destroyGraphicsLayers();
 257 }
 258 
 259 void RenderLayerBacking::willBeDestroyed()
 260 {
 261     ASSERT(m_owningLayer.backing() == this);
 262     compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
<span class="line-added"> 263 </span>
<span class="line-added"> 264     clearBackingSharingLayers();</span>
 265 }
 266 
 267 void RenderLayerBacking::willDestroyLayer(const GraphicsLayer* layer)
 268 {
 269     if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
 270         compositor().layerTiledBackingUsageChanged(layer, false);
 271 }
 272 
<span class="line-added"> 273 static void clearBackingSharingLayerProviders(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; sharingLayers)</span>
<span class="line-added"> 274 {</span>
<span class="line-added"> 275     for (auto&amp; layerWeakPtr : sharingLayers) {</span>
<span class="line-added"> 276         if (!layerWeakPtr)</span>
<span class="line-added"> 277             continue;</span>
<span class="line-added"> 278         layerWeakPtr-&gt;setBackingProviderLayer(nullptr);</span>
<span class="line-added"> 279     }</span>
<span class="line-added"> 280 }</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282 void RenderLayerBacking::setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp; sharingLayers)</span>
<span class="line-added"> 283 {</span>
<span class="line-added"> 284     bool sharingLayersChanged = m_backingSharingLayers != sharingLayers;</span>
<span class="line-added"> 285     if (sharingLayersChanged) {</span>
<span class="line-added"> 286         // For layers that used to share and no longer do, and are not composited, recompute repaint rects.</span>
<span class="line-added"> 287         for (auto&amp; oldSharingLayer : m_backingSharingLayers) {</span>
<span class="line-added"> 288             // Layers that go from shared to composited have their repaint rects recomputed in RenderLayerCompositor::updateBacking().</span>
<span class="line-added"> 289             // FIXME: Two O(n^2) traversals in this funtion. Probably OK because sharing lists are usually small, but still.</span>
<span class="line-added"> 290             if (!sharingLayers.contains(oldSharingLayer) &amp;&amp; !oldSharingLayer-&gt;isComposited())</span>
<span class="line-added"> 291                 oldSharingLayer-&gt;computeRepaintRectsIncludingDescendants();</span>
<span class="line-added"> 292         }</span>
<span class="line-added"> 293     }</span>
<span class="line-added"> 294 </span>
<span class="line-added"> 295     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297     if (sharingLayers != m_backingSharingLayers)</span>
<span class="line-added"> 298         setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300     auto oldSharingLayers = WTFMove(m_backingSharingLayers);</span>
<span class="line-added"> 301     m_backingSharingLayers = WTFMove(sharingLayers);</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303     for (auto&amp; layerWeakPtr : m_backingSharingLayers)</span>
<span class="line-added"> 304         layerWeakPtr-&gt;setBackingProviderLayer(&amp;m_owningLayer);</span>
<span class="line-added"> 305 </span>
<span class="line-added"> 306     if (sharingLayersChanged) {</span>
<span class="line-added"> 307         // For layers that are newly sharing, recompute repaint rects.</span>
<span class="line-added"> 308         for (auto&amp; currentSharingLayer : m_backingSharingLayers) {</span>
<span class="line-added"> 309             if (!oldSharingLayers.contains(currentSharingLayer))</span>
<span class="line-added"> 310                 currentSharingLayer-&gt;computeRepaintRectsIncludingDescendants();</span>
<span class="line-added"> 311         }</span>
<span class="line-added"> 312     }</span>
<span class="line-added"> 313 }</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315 void RenderLayerBacking::removeBackingSharingLayer(RenderLayer&amp; layer)</span>
<span class="line-added"> 316 {</span>
<span class="line-added"> 317     layer.setBackingProviderLayer(nullptr);</span>
<span class="line-added"> 318     m_backingSharingLayers.removeAll(&amp;layer);</span>
<span class="line-added"> 319 }</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321 void RenderLayerBacking::clearBackingSharingLayers()</span>
<span class="line-added"> 322 {</span>
<span class="line-added"> 323     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
<span class="line-added"> 324     m_backingSharingLayers.clear();</span>
<span class="line-added"> 325 }</span>
<span class="line-added"> 326 </span>
 327 Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
 328 {
 329     auto* graphicsLayerFactory = renderer().page().chrome().client().graphicsLayerFactory();
 330 
 331     auto graphicsLayer = GraphicsLayer::create(graphicsLayerFactory, *this, layerType);
 332 
 333     graphicsLayer-&gt;setName(name);
 334 
 335 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 336     graphicsLayer-&gt;setAcceleratesDrawing(compositor().acceleratedDrawingEnabled());
 337     graphicsLayer-&gt;setUsesDisplayListDrawing(compositor().displayListDrawingEnabled());
 338 #endif
 339 
 340     return graphicsLayer;
 341 }
 342 
 343 void RenderLayerBacking::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
 344 {
 345     // Note that this only affects the primary layer.
 346     if (usesDisplayListDrawing == m_graphicsLayer-&gt;usesDisplayListDrawing())
</pre>
<hr />
<pre>
 359 void RenderLayerBacking::setIsTrackingDisplayListReplay(bool isTrackingReplay)
 360 {
 361     m_graphicsLayer-&gt;setIsTrackingDisplayListReplay(isTrackingReplay);
 362 }
 363 
 364 String RenderLayerBacking::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
 365 {
 366     return m_graphicsLayer-&gt;replayDisplayListAsText(flags);
 367 }
 368 
 369 void RenderLayerBacking::tiledBackingUsageChanged(const GraphicsLayer* layer, bool usingTiledBacking)
 370 {
 371     compositor().layerTiledBackingUsageChanged(layer, usingTiledBacking);
 372 }
 373 
 374 TiledBacking* RenderLayerBacking::tiledBacking() const
 375 {
 376     return m_graphicsLayer-&gt;tiledBacking();
 377 }
 378 
<span class="line-modified"> 379 static TiledBacking::TileCoverage computePageTiledBackingCoverage(const RenderLayer&amp; layer)</span>
 380 {



 381     // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.
<span class="line-modified"> 382     if (!layer.page().isVisible())</span>
 383         return TiledBacking::CoverageForVisibleArea;
 384 
<span class="line-added"> 385     auto&amp; frameView = layer.renderer().view().frameView();</span>
<span class="line-added"> 386 </span>
 387     TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;
 388     bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();
 389     if (frameView.speculativeTilingEnabled() &amp;&amp; !useMinimalTilesDuringLiveResize) {
 390         bool clipsToExposedRect = static_cast&lt;bool&gt;(frameView.viewExposedRect());
 391         if (frameView.horizontalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 392             tileCoverage |= TiledBacking::CoverageForHorizontalScrolling;
 393 
 394         if (frameView.verticalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 395             tileCoverage |= TiledBacking::CoverageForVerticalScrolling;
 396     }
 397     return tileCoverage;
 398 }
 399 
<span class="line-added"> 400 static TiledBacking::TileCoverage computeOverflowTiledBackingCoverage(const RenderLayer&amp; layer)</span>
<span class="line-added"> 401 {</span>
<span class="line-added"> 402     // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.</span>
<span class="line-added"> 403     if (!layer.page().isVisible())</span>
<span class="line-added"> 404         return TiledBacking::CoverageForVisibleArea;</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406     auto&amp; frameView = layer.renderer().view().frameView();</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408     TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;</span>
<span class="line-added"> 409     bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();</span>
<span class="line-added"> 410     if (!useMinimalTilesDuringLiveResize) {</span>
<span class="line-added"> 411         if (layer.hasScrollableHorizontalOverflow())</span>
<span class="line-added"> 412             tileCoverage |= TiledBacking::CoverageForHorizontalScrolling;</span>
<span class="line-added"> 413 </span>
<span class="line-added"> 414         if (layer.hasScrollableVerticalOverflow())</span>
<span class="line-added"> 415             tileCoverage |= TiledBacking::CoverageForVerticalScrolling;</span>
<span class="line-added"> 416     }</span>
<span class="line-added"> 417     return tileCoverage;</span>
<span class="line-added"> 418 }</span>
<span class="line-added"> 419 </span>
 420 void RenderLayerBacking::adjustTiledBackingCoverage()
 421 {
<span class="line-modified"> 422     if (m_isFrameLayerWithTiledBacking) {</span>
<span class="line-modified"> 423         auto tileCoverage = computePageTiledBackingCoverage(m_owningLayer);</span>
<span class="line-added"> 424         if (auto* tiledBacking = this-&gt;tiledBacking())</span>
<span class="line-added"> 425             tiledBacking-&gt;setTileCoverage(tileCoverage);</span>
<span class="line-added"> 426     }</span>
 427 
<span class="line-modified"> 428     if (m_owningLayer.hasCompositedScrollableOverflow() &amp;&amp; m_scrolledContentsLayer) {</span>
<span class="line-modified"> 429         if (auto* tiledBacking = m_scrolledContentsLayer-&gt;tiledBacking()) {</span>
<span class="line-added"> 430             auto tileCoverage = computeOverflowTiledBackingCoverage(m_owningLayer);</span>
<span class="line-added"> 431             tiledBacking-&gt;setTileCoverage(tileCoverage);</span>
<span class="line-added"> 432         }</span>
<span class="line-added"> 433     }</span>
 434 }
 435 
 436 void RenderLayerBacking::setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom)
 437 {
 438     if (!m_isFrameLayerWithTiledBacking)
 439         return;
 440 
 441     tiledBacking()-&gt;setHasMargins(hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnLeftAndRight, hasExtendedBackgroundOnLeftAndRight);
 442 }
 443 
 444 void RenderLayerBacking::updateDebugIndicators(bool showBorder, bool showRepaintCounter)
 445 {
 446     m_graphicsLayer-&gt;setShowDebugBorder(showBorder);
 447     m_graphicsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 448 
<span class="line-modified"> 449     if (m_ancestorClippingStack) {</span>
<span class="line-modified"> 450         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())</span>
<span class="line-added"> 451             entry.clippingLayer-&gt;setShowDebugBorder(showBorder);</span>
<span class="line-added"> 452     }</span>
 453 
 454     if (m_foregroundLayer) {
 455         m_foregroundLayer-&gt;setShowDebugBorder(showBorder);
 456         m_foregroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 457     }
 458 
 459     if (m_contentsContainmentLayer)
 460         m_contentsContainmentLayer-&gt;setShowDebugBorder(showBorder);
 461 
 462     if (m_backgroundLayer) {
 463         m_backgroundLayer-&gt;setShowDebugBorder(showBorder);
 464         m_backgroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 465     }
 466 
 467     if (m_maskLayer) {
 468         m_maskLayer-&gt;setShowDebugBorder(showBorder);
 469         m_maskLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 470     }
 471 
 472     if (m_layerForHorizontalScrollbar)
</pre>
<hr />
<pre>
 546     if (m_isMainFrameRenderViewLayer &amp;&amp; IOSApplication::isDumpRenderTree()) {
 547         // In iOS WebKit1 the main frame&#39;s RenderView layer is always transparent. We lie that it is opaque so that
 548         // internals.layerTreeAsText() tests succeed.
 549         ASSERT_UNUSED(layer, !layer.contentsOpaque());
 550         return true;
 551     }
 552     return false;
 553 }
 554 #endif
 555 
 556 void RenderLayerBacking::destroyGraphicsLayers()
 557 {
 558     if (m_graphicsLayer) {
 559         m_graphicsLayer-&gt;setMaskLayer(nullptr);
 560         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 561         willDestroyLayer(m_graphicsLayer.get());
 562     }
 563 
 564     GraphicsLayer::clear(m_maskLayer);
 565 
<span class="line-modified"> 566     if (m_ancestorClippingStack) {</span>
<span class="line-added"> 567         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())</span>
<span class="line-added"> 568             GraphicsLayer::unparentAndClear(entry.clippingLayer);</span>
<span class="line-added"> 569     }</span>
<span class="line-added"> 570 </span>
 571     GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
 572     GraphicsLayer::unparentAndClear(m_foregroundLayer);
 573     GraphicsLayer::unparentAndClear(m_backgroundLayer);
 574     GraphicsLayer::unparentAndClear(m_childContainmentLayer);
 575     GraphicsLayer::unparentAndClear(m_childClippingMaskLayer);
 576     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
 577     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
 578     GraphicsLayer::unparentAndClear(m_graphicsLayer);
 579 }
 580 
 581 void RenderLayerBacking::updateOpacity(const RenderStyle&amp; style)
 582 {
 583     m_graphicsLayer-&gt;setOpacity(compositingOpacity(style.opacity()));
 584 }
 585 
 586 void RenderLayerBacking::updateTransform(const RenderStyle&amp; style)
 587 {
 588     // FIXME: This could use m_owningLayer.transform(), but that currently has transform-origin
 589     // baked into it, and we don&#39;t want that.
 590     TransformationMatrix t;
 591     if (m_owningLayer.hasTransform()) {
 592         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 593         style.applyTransform(t, snapRectToDevicePixels(renderBox.borderBoxRect(), deviceScaleFactor()), RenderStyle::ExcludeTransformOrigin);
 594         makeMatrixRenderable(t, compositor().canRender3DTransforms());
 595     }
 596 
 597     if (m_contentsContainmentLayer) {
 598         m_contentsContainmentLayer-&gt;setTransform(t);
<span class="line-modified"> 599         m_graphicsLayer-&gt;setTransform({ });</span>
 600     } else
 601         m_graphicsLayer-&gt;setTransform(t);
 602 }
 603 
 604 void RenderLayerBacking::updateFilters(const RenderStyle&amp; style)
 605 {
 606     m_canCompositeFilters = m_graphicsLayer-&gt;setFilters(style.filter());
 607 }
 608 
 609 #if ENABLE(FILTERS_LEVEL_2)
 610 void RenderLayerBacking::updateBackdropFilters(const RenderStyle&amp; style)
 611 {
 612     m_canCompositeBackdropFilters = m_graphicsLayer-&gt;setBackdropFilters(style.backdropFilter());
 613 }
 614 
 615 void RenderLayerBacking::updateBackdropFiltersGeometry()
 616 {
 617     if (!m_canCompositeBackdropFilters)
 618         return;
 619 
 620     if (!is&lt;RenderBox&gt;(renderer()))
 621         return;
 622 
 623     auto&amp; renderer = downcast&lt;RenderBox&gt;(this-&gt;renderer());
 624     LayoutRect boxRect = renderer.borderBoxRect();
 625     if (renderer.hasClip())
 626         boxRect.intersect(renderer.clipRect(LayoutPoint(), nullptr));
<span class="line-modified"> 627     boxRect.move(contentOffsetInCompositingLayer());</span>
 628 
 629     FloatRoundedRect backdropFiltersRect;
 630     if (renderer.style().hasBorderRadius() &amp;&amp; !renderer.hasClip())
 631         backdropFiltersRect = renderer.style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 632     else
 633         backdropFiltersRect = FloatRoundedRect(snapRectToDevicePixels(boxRect, deviceScaleFactor()));
 634 
 635     m_graphicsLayer-&gt;setBackdropFiltersRect(backdropFiltersRect);
 636 }
 637 #endif
 638 
 639 #if ENABLE(CSS_COMPOSITING)
 640 void RenderLayerBacking::updateBlendMode(const RenderStyle&amp; style)
 641 {
<span class="line-modified"> 642     // FIXME: where is the blend mode updated when m_ancestorClippingStacks come and go?</span>
<span class="line-modified"> 643     if (m_ancestorClippingStack) {</span>
<span class="line-modified"> 644         m_ancestorClippingStack-&gt;stack().first().clippingLayer-&gt;setBlendMode(style.blendMode());</span>
 645         m_graphicsLayer-&gt;setBlendMode(BlendMode::Normal);
 646     } else
 647         m_graphicsLayer-&gt;setBlendMode(style.blendMode());
 648 }
 649 #endif
 650 
 651 void RenderLayerBacking::updateCustomAppearance(const RenderStyle&amp; style)
 652 {
 653     ControlPart appearance = style.appearance();
 654     if (appearance == MediaControlsLightBarBackgroundPart)
 655         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::LightBackdrop);
 656     else if (appearance == MediaControlsDarkBarBackgroundPart)
 657         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::DarkBackdrop);
 658     else
 659         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::None);
 660 }
 661 
 662 static bool layerOrAncestorIsTransformedOrUsingCompositedScrolling(RenderLayer&amp; layer)
 663 {
 664     for (auto* curr = &amp;layer; curr; curr = curr-&gt;parent()) {
</pre>
<hr />
<pre>
 678 #endif
 679 
 680     if (m_isFrameLayerWithTiledBacking)
 681         return false;
 682 
 683     if (layerOrAncestorIsTransformedOrUsingCompositedScrolling(m_owningLayer))
 684         return false;
 685 
 686     return true;
 687 }
 688 
 689 static bool hasNonZeroTransformOrigin(const RenderObject&amp; renderer)
 690 {
 691     const RenderStyle&amp; style = renderer.style();
 692     return (style.transformOriginX().type() == Fixed &amp;&amp; style.transformOriginX().value())
 693         || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
 694 }
 695 
 696 bool RenderLayerBacking::updateCompositedBounds()
 697 {
<span class="line-modified"> 698     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, { }, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);</span>
 699     // Clip to the size of the document or enclosing overflow-scroll layer.
 700     // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
 701     // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
 702     if (shouldClipCompositedBounds()) {
 703         auto&amp; view = renderer().view();
 704         auto* rootLayer = view.layer();
 705 
 706         LayoutRect clippingBounds;
 707         if (renderer().isFixedPositioned() &amp;&amp; renderer().container() == &amp;view)
 708             clippingBounds = view.frameView().rectForFixedPositionLayout();
 709         else
 710             clippingBounds = view.unscaledDocumentRect();
 711 
 712         if (&amp;m_owningLayer != rootLayer)
 713             clippingBounds.intersect(m_owningLayer.backgroundClipRect(RenderLayer::ClipRectsContext(rootLayer, AbsoluteClipRects)).rect()); // FIXME: Incorrect for CSS regions.
 714 
 715         LayoutPoint delta = m_owningLayer.convertToLayerCoords(rootLayer, LayoutPoint(), RenderLayer::AdjustForColumns);
 716         clippingBounds.move(-delta.x(), -delta.y());
 717 
 718         layerBounds.intersect(clippingBounds);
 719     }
 720 
<span class="line-added"> 721     // If the backing provider has overflow:clip, we know all sharing layers are affected by the clip because they are containing-block descendants.</span>
<span class="line-added"> 722     if (!renderer().hasOverflowClip()) {</span>
<span class="line-added"> 723         for (auto&amp; layerWeakPtr : m_backingSharingLayers) {</span>
<span class="line-added"> 724             auto* boundsRootLayer = &amp;m_owningLayer;</span>
<span class="line-added"> 725             ASSERT(layerWeakPtr-&gt;isDescendantOf(m_owningLayer));</span>
<span class="line-added"> 726             auto offset = layerWeakPtr-&gt;offsetFromAncestor(&amp;m_owningLayer);</span>
<span class="line-added"> 727             auto bounds = layerWeakPtr-&gt;calculateLayerBounds(boundsRootLayer, offset, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);</span>
<span class="line-added"> 728             layerBounds.unite(bounds);</span>
<span class="line-added"> 729         }</span>
<span class="line-added"> 730     }</span>
<span class="line-added"> 731 </span>
 732     // If the element has a transform-origin that has fixed lengths, and the renderer has zero size,
 733     // then we need to ensure that the compositing layer has non-zero size so that we can apply
 734     // the transform-origin via the GraphicsLayer anchorPoint (which is expressed as a fractional value).
 735     if (layerBounds.isEmpty() &amp;&amp; (hasNonZeroTransformOrigin(renderer()) || renderer().style().hasPerspective())) {
 736         layerBounds.setWidth(1);
 737         layerBounds.setHeight(1);
 738         m_artificiallyInflatedBounds = true;
 739     } else
 740         m_artificiallyInflatedBounds = false;
 741 
 742     return setCompositedBounds(layerBounds);
 743 }
 744 
<span class="line-added"> 745 void RenderLayerBacking::updateAllowsBackingStoreDetaching(const LayoutRect&amp; absoluteBounds)</span>
<span class="line-added"> 746 {</span>
<span class="line-added"> 747     auto setAllowsBackingStoreDetaching = [&amp;](bool allowDetaching) {</span>
<span class="line-added"> 748         m_graphicsLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added"> 749         if (m_foregroundLayer)</span>
<span class="line-added"> 750             m_foregroundLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added"> 751         if (m_backgroundLayer)</span>
<span class="line-added"> 752             m_backgroundLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added"> 753         if (m_scrolledContentsLayer)</span>
<span class="line-added"> 754             m_scrolledContentsLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added"> 755     };</span>
<span class="line-added"> 756 </span>
<span class="line-added"> 757     if (!m_owningLayer.behavesAsFixed()) {</span>
<span class="line-added"> 758         setAllowsBackingStoreDetaching(true);</span>
<span class="line-added"> 759         return;</span>
<span class="line-added"> 760     }</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762     // We&#39;ll allow detaching if the layer is outside the layout viewport. Fixed layers inside</span>
<span class="line-added"> 763     // the layout viewport can be revealed by async scrolling, so we want to pin their backing store.</span>
<span class="line-added"> 764     FrameView&amp; frameView = renderer().view().frameView();</span>
<span class="line-added"> 765     LayoutRect fixedLayoutRect;</span>
<span class="line-added"> 766     if (frameView.useFixedLayout())</span>
<span class="line-added"> 767         fixedLayoutRect = renderer().view().unscaledDocumentRect();</span>
<span class="line-added"> 768     else</span>
<span class="line-added"> 769         fixedLayoutRect = frameView.rectForFixedPositionLayout();</span>
<span class="line-added"> 770 </span>
<span class="line-added"> 771     bool allowDetaching = !fixedLayoutRect.intersects(absoluteBounds);</span>
<span class="line-added"> 772     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerBacking (layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot;) updateAllowsBackingStoreDetaching - absoluteBounds &quot; &lt;&lt; absoluteBounds &lt;&lt; &quot; layoutViewportRect &quot; &lt;&lt; fixedLayoutRect &lt;&lt; &quot;, allowDetaching &quot; &lt;&lt; allowDetaching);</span>
<span class="line-added"> 773     setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added"> 774 }</span>
<span class="line-added"> 775 </span>
 776 void RenderLayerBacking::updateAfterWidgetResize()
 777 {
 778     if (!is&lt;RenderWidget&gt;(renderer()))
 779         return;
 780 
 781     if (auto* innerCompositor = RenderLayerCompositor::frameContentsCompositor(downcast&lt;RenderWidget&gt;(renderer()))) {
 782         innerCompositor-&gt;frameViewDidChangeSize();
 783         innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
 784     }
 785 }
 786 
<span class="line-modified"> 787 void RenderLayerBacking::updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint)</span>
 788 {
 789     LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
 790 
 791     // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
 792     // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
 793     // take overflow into account.
 794     if (updateCompositedBounds()) {
 795         m_owningLayer.setNeedsCompositingGeometryUpdate();
 796         // This layer&#39;s geometry affects those of its children.
 797         m_owningLayer.setChildrenNeedCompositingGeometryUpdate();
<span class="line-added"> 798     } else if (needsClippingUpdate) {</span>
<span class="line-added"> 799         m_owningLayer.setNeedsCompositingConfigurationUpdate();</span>
<span class="line-added"> 800         m_owningLayer.setNeedsCompositingGeometryUpdate();</span>
 801     }
 802 
 803     if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
 804         setContentsNeedDisplay();
 805 }
 806 
 807 // This can only update things that don&#39;t require up-to-date layout.
 808 void RenderLayerBacking::updateConfigurationAfterStyleChange()
 809 {
 810     updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath());
 811 
 812     if (m_owningLayer.hasReflection()) {
 813         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 814             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 815             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 816         }
 817     } else
 818         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 819 
 820     // FIXME: do we care if opacity is animating?
</pre>
<hr />
<pre>
 840     bool layerConfigChanged = false;
 841     auto&amp; compositor = this-&gt;compositor();
 842 
 843     setBackgroundLayerPaintsFixedRootBackground(compositor.needsFixedRootBackgroundLayer(m_owningLayer));
 844 
 845     if (updateBackgroundLayer(m_backgroundLayerPaintsFixedRootBackground || m_requiresBackgroundLayer))
 846         layerConfigChanged = true;
 847 
 848     if (updateForegroundLayer(compositor.needsContentsCompositingLayer(m_owningLayer)))
 849         layerConfigChanged = true;
 850 
 851     bool needsDescendantsClippingLayer = false;
 852     bool usesCompositedScrolling = m_owningLayer.hasCompositedScrollableOverflow();
 853 
 854     if (usesCompositedScrolling) {
 855         // If it&#39;s scrollable, it has to be a box.
 856         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 857         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 858         needsDescendantsClippingLayer = contentsClippingRect.isRounded();
 859     } else
<span class="line-modified"> 860         needsDescendantsClippingLayer = RenderLayerCompositor::clipsCompositingDescendants(m_owningLayer);</span>
 861 
 862     if (updateScrollingLayers(usesCompositedScrolling))
 863         layerConfigChanged = true;
 864 
 865     if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
 866         layerConfigChanged = true;
 867 
<span class="line-modified"> 868     auto* compositingAncestor = m_owningLayer.ancestorCompositingLayer();</span>
<span class="line-modified"> 869     if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))</span>
 870         layerConfigChanged = true;
 871 
 872     if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
 873         layerConfigChanged = true;
 874 
 875     if (layerConfigChanged)
 876         updateInternalHierarchy();
 877 
 878     if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
 879         if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
 880             m_graphicsLayer-&gt;addChild(*flatteningLayer);
 881     }
 882 
<span class="line-modified"> 883     if (updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath()))</span>
<span class="line-added"> 884         layerConfigChanged = true;</span>
 885 
 886     updateChildClippingStrategy(needsDescendantsClippingLayer);
 887 
 888     if (m_owningLayer.hasReflection()) {
 889         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 890             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 891             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 892         }
 893     } else
 894         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 895 
 896     PaintedContentsInfo contentsInfo(*this);
 897 
 898     // Requires layout.
 899     if (!m_owningLayer.isRenderViewLayer()) {
 900         bool didUpdateContentsRect = false;
 901         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
 902     } else
 903         updateRootLayerConfiguration();
 904 
</pre>
<hr />
<pre>
 909     if (is&lt;RenderEmbeddedObject&gt;(renderer()) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer()).allowsAcceleratedCompositing()) {
 910         auto* pluginViewBase = downcast&lt;PluginViewBase&gt;(downcast&lt;RenderWidget&gt;(renderer()).widget());
 911 #if PLATFORM(IOS_FAMILY)
 912         if (pluginViewBase &amp;&amp; !m_graphicsLayer-&gt;contentsLayerForMedia()) {
 913             pluginViewBase-&gt;detachPluginLayer();
 914             pluginViewBase-&gt;attachPluginLayer();
 915         }
 916 #else
 917         if (!pluginViewBase-&gt;shouldNotAddLayer())
 918             m_graphicsLayer-&gt;setContentsToPlatformLayer(pluginViewBase-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Plugin);
 919 #endif
 920     }
 921 #if ENABLE(VIDEO)
 922     else if (is&lt;RenderVideo&gt;(renderer()) &amp;&amp; downcast&lt;RenderVideo&gt;(renderer()).shouldDisplayVideo()) {
 923         auto* mediaElement = downcast&lt;HTMLMediaElement&gt;(renderer().element());
 924         m_graphicsLayer-&gt;setContentsToPlatformLayer(mediaElement-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Media);
 925         // Requires layout.
 926         resetContentsRect();
 927     }
 928 #endif
<span class="line-modified"> 929 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS) || ENABLE(WEBGPU)</span>
 930     else if (renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
 931         const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
 932         if (auto* context = canvas-&gt;renderingContext())
 933             m_graphicsLayer-&gt;setContentsToPlatformLayer(context-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Canvas);
 934 
 935         layerConfigChanged = true;
 936     }
 937 #endif
 938     if (is&lt;RenderWidget&gt;(renderer()) &amp;&amp; compositor.parentFrameContentLayers(downcast&lt;RenderWidget&gt;(renderer()))) {
 939         m_owningLayer.setNeedsCompositingGeometryUpdate();
 940         layerConfigChanged = true;
 941     }
 942 
 943     if (is&lt;RenderImage&gt;(renderer()) &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage()) {
 944         auto element = renderer().element();
 945         if (is&lt;HTMLImageElement&gt;(element)) {
 946             m_graphicsLayer-&gt;setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType::EditableImage, downcast&lt;HTMLImageElement&gt;(element)-&gt;editableImageViewID());
 947             layerConfigChanged = true;
 948         }
 949     }
 950 
<span class="line-added"> 951     if (layerConfigChanged)</span>
<span class="line-added"> 952         updatePaintingPhases();</span>
<span class="line-added"> 953 </span>
 954     return layerConfigChanged;
 955 }
 956 
 957 static LayoutRect clipBox(RenderBox&amp; renderer)
 958 {
 959     LayoutRect result = LayoutRect::infiniteRect();
 960     if (renderer.hasOverflowClip())
 961         result = renderer.overflowClipRect(LayoutPoint(), 0); // FIXME: Incorrect for CSS regions.
 962 
 963     if (renderer.hasClip())
 964         result.intersect(renderer.clipRect(LayoutPoint(), 0)); // FIXME: Incorrect for CSS regions.
 965 
 966     return result;
 967 }
 968 
 969 static bool subpixelOffsetFromRendererChanged(const LayoutSize&amp; oldSubpixelOffsetFromRenderer, const LayoutSize&amp; newSubpixelOffsetFromRenderer, float deviceScaleFactor)
 970 {
 971     FloatSize previous = snapSizeToDevicePixel(oldSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 972     FloatSize current = snapSizeToDevicePixel(newSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 973     return previous != current;
</pre>
<hr />
<pre>
 993     OffsetFromRenderer offsetFromRenderer;
 994     offsetFromRenderer.m_subpixelOffset = LayoutSize(subpixelForLayerPainting(toLayoutPoint(offset), deviceScaleFactor));
 995     offsetFromRenderer.m_devicePixelOffset = offset - offsetFromRenderer.m_subpixelOffset;
 996     return offsetFromRenderer;
 997 }
 998 
 999 struct SnappedRectInfo {
1000     LayoutRect m_snappedRect;
1001     LayoutSize m_snapDelta;
1002 };
1003 
1004 static SnappedRectInfo snappedGraphicsLayer(const LayoutSize&amp; offset, const LayoutSize&amp; size, float deviceScaleFactor)
1005 {
1006     SnappedRectInfo snappedGraphicsLayer;
1007     LayoutRect graphicsLayerRect = LayoutRect(toLayoutPoint(offset), size);
1008     snappedGraphicsLayer.m_snappedRect = LayoutRect(snapRectToDevicePixels(graphicsLayerRect, deviceScaleFactor));
1009     snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
1010     return snappedGraphicsLayer;
1011 }
1012 
<span class="line-modified">1013 static LayoutSize computeOffsetFromAncestorGraphicsLayer(const RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)</span>
1014 {
1015     if (!compositedAncestor)
1016         return toLayoutSize(location);
1017 
1018     // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
1019     // could be stale when a dynamic composited state change triggers a pre-order updateGeometry() traversal.
1020     LayoutSize ancestorSubpixelOffsetFromRenderer = compositedAncestor-&gt;backing()-&gt;subpixelOffsetFromRenderer();
1021     LayoutRect ancestorCompositedBounds = compositedAncestor-&gt;backing()-&gt;compositedBounds();
1022     LayoutSize floored = toLayoutSize(LayoutPoint(floorPointToDevicePixels(ancestorCompositedBounds.location() - ancestorSubpixelOffsetFromRenderer, deviceScaleFactor)));
1023     LayoutSize ancestorRendererOffsetFromAncestorGraphicsLayer = -(floored + ancestorSubpixelOffsetFromRenderer);
1024     return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
1025 }
1026 
1027 class ComputedOffsets {
1028 public:
1029     ComputedOffsets(const RenderLayer&amp; renderLayer, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)
1030         : m_renderLayer(renderLayer)
1031         , m_location(localRect.location())
1032         , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
1033         , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
</pre>
<hr />
<pre>
1057             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(compositedAncestor, m_location, RenderLayer::AdjustForColumns);
1058             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);
1059         }
1060         return m_fromAncestorGraphicsLayer.value();
1061     }
1062 
1063     Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
1064     Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
1065     Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
1066 
1067     const RenderLayer&amp; m_renderLayer;
1068     // Location is relative to the renderer.
1069     const LayoutPoint m_location;
1070     const LayoutSize m_parentGraphicsLayerOffset;
1071     const LayoutSize m_primaryGraphicsLayerOffset;
1072     float m_deviceScaleFactor;
1073 };
1074 
1075 LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const
1076 {
<span class="line-modified">1077     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, { });</span>
1078     return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
1079         deviceScaleFactor()));
1080 }
1081 
1082 // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
<span class="line-modified">1083 LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const</span>
1084 {
1085     if (!compositedAncestor || !compositedAncestor-&gt;backing())
1086         return renderer().view().documentRect();
1087 
1088     auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
1089     LayoutRect parentGraphicsLayerRect;
1090     if (m_owningLayer.isInsideFragmentedFlow()) {
1091         // FIXME: flows/columns need work.
1092         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1093         ancestorCompositedBounds.setLocation(LayoutPoint());
1094         parentGraphicsLayerRect = ancestorCompositedBounds;
1095     }
1096 
1097     if (ancestorBackingLayer-&gt;hasClippingLayer()) {
1098         // If the compositing ancestor has a layer to clip children, we parent in that, and therefore position relative to it.
1099         LayoutRect clippingBox = clipBox(downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer()));
1100         LayoutSize clippingBoxOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clippingBox.location(), deviceScaleFactor());
1101         parentGraphicsLayerRect = snappedGraphicsLayer(clippingBoxOffset, clippingBox.size(), deviceScaleFactor()).m_snappedRect;
1102     }
1103 
1104     if (compositedAncestor-&gt;hasCompositedScrollableOverflow()) {
1105         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1106         auto&amp; renderBox = downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer());
1107         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();
1108         ScrollOffset scrollOffset = compositedAncestor-&gt;scrollOffset();
1109         parentGraphicsLayerRect = LayoutRect((paddingBoxIncludingScrollbar.location() - toLayoutSize(ancestorCompositedBounds.location()) - toLayoutSize(scrollOffset)), paddingBoxIncludingScrollbar.size());
1110     }
1111 














1112     return parentGraphicsLayerRect;
1113 }
1114 
1115 void RenderLayerBacking::updateGeometry()
1116 {
1117     ASSERT(!m_owningLayer.normalFlowListDirty());
1118     ASSERT(!m_owningLayer.zOrderListsDirty());
1119     ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
1120     ASSERT(!renderer().view().needsLayout());
1121 
1122     const RenderStyle&amp; style = renderer().style();
1123 
1124     bool isRunningAcceleratedTransformAnimation = false;

1125     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1126         if (auto* timeline = renderer().documentTimeline())</span>
1127             isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<span class="line-modified">1128     } else</span>


1129         isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);











1130 
<span class="line-added">1131     updateTransform(style);</span>
<span class="line-added">1132     updateOpacity(style);</span>
1133     updateFilters(style);
1134 #if ENABLE(FILTERS_LEVEL_2)
1135     updateBackdropFilters(style);
1136 #endif
1137 #if ENABLE(CSS_COMPOSITING)
1138     updateBlendMode(style);
1139 #endif
1140 





1141     auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();
<span class="line-modified">1142     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);</span>
<span class="line-modified">1143 </span>
<span class="line-added">1144     if (m_ancestorClippingStack) {</span>
<span class="line-added">1145         // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.</span>
<span class="line-added">1146         auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));</span>
<span class="line-added">1147         LayoutRect lastClipLayerRect = parentGraphicsLayerRect;</span>
<span class="line-added">1148 </span>
<span class="line-added">1149         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {</span>
<span class="line-added">1150             auto clipRect = entry.clipData.clipRect;</span>
<span class="line-added">1151             LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clipRect.location() + offsetFromCompositedAncestor, deviceScaleFactor());</span>
<span class="line-added">1152             LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, clipRect.size(), deviceScaleFactor()).m_snappedRect;</span>
<span class="line-added">1153 </span>
<span class="line-added">1154             entry.clippingLayer-&gt;setPosition(toLayoutPoint(snappedClippingLayerRect.location() - lastClipLayerRect.location()));</span>
<span class="line-added">1155             lastClipLayerRect = snappedClippingLayerRect;</span>
<span class="line-added">1156 </span>
<span class="line-added">1157             entry.clippingLayer-&gt;setSize(snappedClippingLayerRect.size());</span>
<span class="line-added">1158 </span>
<span class="line-added">1159             if (entry.clipData.isOverflowScroll) {</span>
<span class="line-added">1160                 ScrollOffset scrollOffset = entry.clipData.clippingLayer-&gt;scrollOffset();</span>
<span class="line-added">1161 </span>
<span class="line-added">1162                 entry.clippingLayer-&gt;setBoundsOrigin(scrollOffset);</span>
<span class="line-added">1163                 lastClipLayerRect.moveBy(-scrollOffset);</span>
<span class="line-added">1164             } else</span>
<span class="line-added">1165                 entry.clippingLayer-&gt;setBoundsOrigin({ });</span>
<span class="line-added">1166         }</span>
<span class="line-added">1167 </span>
<span class="line-added">1168         parentGraphicsLayerRect = lastClipLayerRect;</span>
<span class="line-added">1169     }</span>
<span class="line-added">1170 </span>
1171     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);
1172 
1173     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);
<span class="line-added">1174     ComputedOffsets rendererOffset(m_owningLayer, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-added">1175 </span>
1176     m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
<span class="line-modified">1177 </span>
<span class="line-modified">1178     auto primaryLayerPosition = primaryGraphicsLayerRect.location();</span>
<span class="line-added">1179 </span>
<span class="line-added">1180     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959</span>
<span class="line-added">1181     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();</span>
<span class="line-added">1182     if (m_contentsContainmentLayer) {</span>
<span class="line-added">1183         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-added">1184         m_contentsContainmentLayer-&gt;setPosition(primaryLayerPosition);</span>
<span class="line-added">1185         primaryLayerPosition = { };</span>
<span class="line-added">1186         // Use the same size as m_graphicsLayer so transforms behave correctly.</span>
<span class="line-added">1187         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>
<span class="line-added">1188     }</span>
1189 
1190     auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
1191         LayoutRect animatedBounds;
1192         if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
1193             return FloatRect(animatedBounds);
1194         return { };
1195     };
1196     m_graphicsLayer-&gt;setAnimationExtent(computeAnimationExtent());
<span class="line-added">1197     m_graphicsLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-added">1198     m_graphicsLayer-&gt;setBackfaceVisibility(style.backfaceVisibility() == BackfaceVisibility::Visible);</span>
1199 
<span class="line-modified">1200     m_graphicsLayer-&gt;setPosition(primaryLayerPosition);</span>
<span class="line-modified">1201     m_graphicsLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>













1202 
1203     // Compute renderer offset from primary graphics layer. Note that primaryGraphicsLayerRect is in parentGraphicsLayer&#39;s coordinate system which is not necessarily
1204     // the same as the ancestor graphics layer.
1205     OffsetFromRenderer primaryGraphicsLayerOffsetFromRenderer;
1206     LayoutSize oldSubpixelOffsetFromRenderer = m_subpixelOffsetFromRenderer;
1207     primaryGraphicsLayerOffsetFromRenderer = computeOffsetFromRenderer(-rendererOffset.fromPrimaryGraphicsLayer(), deviceScaleFactor());
1208     m_subpixelOffsetFromRenderer = primaryGraphicsLayerOffsetFromRenderer.m_subpixelOffset;
<span class="line-added">1209     m_hasSubpixelRounding = !m_subpixelOffsetFromRenderer.isZero() || compositedBounds().size() != primaryGraphicsLayerRect.size();</span>
1210 
1211     if (primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset != m_graphicsLayer-&gt;offsetFromRenderer()) {
1212         m_graphicsLayer-&gt;setOffsetFromRenderer(primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset);
1213         positionOverflowControlsLayers();
1214     }
1215 








1216     // If we have a layer that clips children, position it.
1217     LayoutRect clippingBox;
1218     if (auto* clipLayer = clippingLayer()) {
1219         // clipLayer is the m_childContainmentLayer.
1220         clippingBox = clipBox(downcast&lt;RenderBox&gt;(renderer()));
1221         // Clipping layer is parented in the primary graphics layer.
1222         LayoutSize clipBoxOffsetFromGraphicsLayer = toLayoutSize(clippingBox.location()) + rendererOffset.fromPrimaryGraphicsLayer();
1223         SnappedRectInfo snappedClippingGraphicsLayer = snappedGraphicsLayer(clipBoxOffsetFromGraphicsLayer, clippingBox.size(), deviceScaleFactor());
1224         clipLayer-&gt;setPosition(snappedClippingGraphicsLayer.m_snappedRect.location());
1225         clipLayer-&gt;setSize(snappedClippingGraphicsLayer.m_snappedRect.size());
1226         clipLayer-&gt;setOffsetFromRenderer(toLayoutSize(clippingBox.location() - snappedClippingGraphicsLayer.m_snapDelta));
1227 
<span class="line-added">1228         if ((renderer().style().clipPath() || renderer().style().hasBorderRadius()) &amp;&amp; !m_childClippingMaskLayer) {</span>
<span class="line-added">1229             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());</span>
<span class="line-added">1230             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());</span>
<span class="line-added">1231             contentsClippingRect.move(LayoutSize(-clipLayer-&gt;offsetFromRenderer()));</span>
<span class="line-added">1232             clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect);</span>
<span class="line-added">1233         }</span>
<span class="line-added">1234 </span>
1235         if (m_childClippingMaskLayer &amp;&amp; !m_scrollContainerLayer) {
1236             m_childClippingMaskLayer-&gt;setSize(clipLayer-&gt;size());
1237             m_childClippingMaskLayer-&gt;setPosition(FloatPoint());
1238             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(clipLayer-&gt;offsetFromRenderer());
1239         }
1240     }
1241 
1242     if (m_maskLayer)
1243         updateMaskingLayerGeometry();
1244 
1245     if (renderer().hasTransformRelatedProperty()) {
1246         // Update properties that depend on layer dimensions.
1247         FloatPoint3D transformOrigin = computeTransformOriginForPainting(downcast&lt;RenderBox&gt;(renderer()).borderBoxRect());
1248         FloatPoint layerOffset = roundPointToDevicePixels(toLayoutPoint(rendererOffset.fromParentGraphicsLayer()), deviceScaleFactor());
1249         // Compute the anchor point, which is in the center of the renderer box unless transform-origin is set.
1250         FloatPoint3D anchor(
1251             primaryGraphicsLayerRect.width() ? ((layerOffset.x() - primaryGraphicsLayerRect.x()) + transformOrigin.x()) / primaryGraphicsLayerRect.width() : 0.5,
1252             primaryGraphicsLayerRect.height() ? ((layerOffset.y() - primaryGraphicsLayerRect.y())+ transformOrigin.y()) / primaryGraphicsLayerRect.height() : 0.5,
1253             transformOrigin.z());
1254 
</pre>
<hr />
<pre>
1262             TransformationMatrix t = owningLayer().perspectiveTransform();
1263 
1264             if (clipLayer) {
1265                 clipLayer-&gt;setChildrenTransform(t);
1266                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1267             }
1268             else
1269                 m_graphicsLayer-&gt;setChildrenTransform(t);
1270         } else {
1271             if (clipLayer)
1272                 clipLayer-&gt;setChildrenTransform(TransformationMatrix());
1273             else
1274                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1275         }
1276     } else {
1277         m_graphicsLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1278         if (m_contentsContainmentLayer)
1279             m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1280     }
1281 

































1282     if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
1283         auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
1284         reflectionBacking-&gt;updateGeometry();
1285 
1286         // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
1287         // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
1288         FloatRect layerBounds = this-&gt;compositedBounds();
1289         FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
1290         reflectionBacking-&gt;graphicsLayer()-&gt;setReplicatedLayerPosition(FloatPoint(layerBounds.location() - reflectionLayerBounds.location()));
1291     }
1292 
1293     if (m_scrollContainerLayer) {
1294         ASSERT(m_scrolledContentsLayer);
1295         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
<span class="line-modified">1296         LayoutRect paddingBox = renderBox.paddingBoxRect();</span>
1297         LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
1298 
1299         // FIXME: need to do some pixel snapping here.
<span class="line-modified">1300         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBox.location() - parentLayerBounds.location()));</span>
1301         m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
1302 
1303         ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
1304         updateScrollOffset(scrollOffset);



1305 
1306         FloatSize oldScrollingLayerOffset = m_scrollContainerLayer-&gt;offsetFromRenderer();
<span class="line-modified">1307         m_scrollContainerLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBox.location()));</span>
1308 
1309         if (m_childClippingMaskLayer) {
1310             m_childClippingMaskLayer-&gt;setPosition(m_scrollContainerLayer-&gt;position());
1311             m_childClippingMaskLayer-&gt;setSize(m_scrollContainerLayer-&gt;size());
<span class="line-modified">1312             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBox.location()));</span>
1313         }
1314 
1315         bool paddingBoxOffsetChanged = oldScrollingLayerOffset != m_scrollContainerLayer-&gt;offsetFromRenderer();
1316 
1317         IntSize scrollSize(m_owningLayer.scrollWidth(), m_owningLayer.scrollHeight());
1318         if (scrollSize != m_scrolledContentsLayer-&gt;size() || paddingBoxOffsetChanged)
1319             m_scrolledContentsLayer-&gt;setNeedsDisplay();
1320 
1321         m_scrolledContentsLayer-&gt;setSize(scrollSize);
1322         m_scrolledContentsLayer-&gt;setScrollOffset(scrollOffset, GraphicsLayer::DontSetNeedsDisplay);
<span class="line-modified">1323         m_scrolledContentsLayer-&gt;setOffsetFromRenderer(toLayoutSize(paddingBox.location()), GraphicsLayer::DontSetNeedsDisplay);</span>
<span class="line-added">1324 </span>
<span class="line-added">1325         adjustTiledBackingCoverage();</span>
<span class="line-added">1326     }</span>
<span class="line-added">1327 </span>
<span class="line-added">1328     if (m_foregroundLayer) {</span>
<span class="line-added">1329         FloatSize foregroundSize;</span>
<span class="line-added">1330         FloatSize foregroundOffset;</span>
<span class="line-added">1331         GraphicsLayer::ShouldSetNeedsDisplay needsDisplayOnOffsetChange = GraphicsLayer::SetNeedsDisplay;</span>
<span class="line-added">1332         if (m_scrolledContentsLayer) {</span>
<span class="line-added">1333             foregroundSize = m_scrolledContentsLayer-&gt;size();</span>
<span class="line-added">1334             foregroundOffset = m_scrolledContentsLayer-&gt;offsetFromRenderer() - toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset());</span>
<span class="line-added">1335             needsDisplayOnOffsetChange = GraphicsLayer::DontSetNeedsDisplay;</span>
<span class="line-added">1336         } else if (hasClippingLayer()) {</span>
<span class="line-added">1337             // If we have a clipping layer (which clips descendants), then the foreground layer is a child of it,</span>
<span class="line-added">1338             // so that it gets correctly sorted with children. In that case, position relative to the clipping layer.</span>
<span class="line-added">1339             foregroundSize = FloatSize(clippingBox.size());</span>
<span class="line-added">1340             foregroundOffset = toFloatSize(clippingBox.location());</span>
<span class="line-added">1341         } else {</span>
<span class="line-added">1342             foregroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-added">1343             foregroundOffset = m_graphicsLayer-&gt;offsetFromRenderer();</span>
<span class="line-added">1344         }</span>
<span class="line-added">1345 </span>
<span class="line-added">1346         m_foregroundLayer-&gt;setPosition({ });</span>
<span class="line-added">1347         m_foregroundLayer-&gt;setSize(foregroundSize);</span>
<span class="line-added">1348         m_foregroundLayer-&gt;setOffsetFromRenderer(foregroundOffset, needsDisplayOnOffsetChange);</span>
<span class="line-added">1349     }</span>
1350 
<span class="line-modified">1351     if (m_backgroundLayer) {</span>
<span class="line-modified">1352         FloatPoint backgroundPosition;</span>
<span class="line-modified">1353         FloatSize backgroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-added">1354         if (backgroundLayerPaintsFixedRootBackground()) {</span>
<span class="line-added">1355             const FrameView&amp; frameView = renderer().view().frameView();</span>
<span class="line-added">1356             backgroundPosition = frameView.scrollPositionForFixedPosition();</span>
<span class="line-added">1357             backgroundSize = frameView.layoutSize();</span>
<span class="line-added">1358         } else {</span>
<span class="line-added">1359             auto boundingBox = renderer().objectBoundingBox();</span>
<span class="line-added">1360             backgroundPosition = boundingBox.location();</span>
<span class="line-added">1361             backgroundSize = boundingBox.size();</span>
1362         }
<span class="line-added">1363         m_backgroundLayer-&gt;setPosition(backgroundPosition);</span>
<span class="line-added">1364         m_backgroundLayer-&gt;setSize(backgroundSize);</span>
<span class="line-added">1365         m_backgroundLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());</span>
1366     }
1367 
1368     // If this layer was created just for clipping or to apply perspective, it doesn&#39;t need its own backing store.
1369     LayoutRect ancestorCompositedBounds = compositedAncestor ? compositedAncestor-&gt;backing()-&gt;compositedBounds() : LayoutRect();
1370     setRequiresOwnBackingStore(compositor().requiresOwnBackingStore(m_owningLayer, compositedAncestor,
1371         LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()), ancestorCompositedBounds));
1372 #if ENABLE(FILTERS_LEVEL_2)
1373     updateBackdropFiltersGeometry();
1374 #endif
1375     updateAfterWidgetResize();
1376 
1377     if (subpixelOffsetFromRendererChanged(oldSubpixelOffsetFromRenderer, m_subpixelOffsetFromRenderer, deviceScaleFactor()) &amp;&amp; canIssueSetNeedsDisplay())
1378         setContentsNeedDisplay();
1379 }
1380 
1381 void RenderLayerBacking::setLocationOfScrolledContents(ScrollOffset scrollOffset, ScrollingLayerPositionAction setOrSync)
1382 {

1383     if (setOrSync == ScrollingLayerPositionAction::Sync)
1384         m_scrollContainerLayer-&gt;syncBoundsOrigin(scrollOffset);
1385     else
1386         m_scrollContainerLayer-&gt;setBoundsOrigin(scrollOffset);






1387 }
1388 
1389 void RenderLayerBacking::updateScrollOffset(ScrollOffset scrollOffset)
1390 {
<span class="line-modified">1391     if (m_owningLayer.currentScrollType() == ScrollType::User) {</span>
1392         // If scrolling is happening externally, we don&#39;t want to touch the layer bounds origin here because that will cause jitter.
1393         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Sync);
1394         m_owningLayer.setRequiresScrollPositionReconciliation(true);
1395     } else {
1396         // Note that we implement the contents offset via the bounds origin on this layer, rather than a position on the sublayer.
1397         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Set);
1398         m_owningLayer.setRequiresScrollPositionReconciliation(false);
1399     }
<span class="line-added">1400 </span>
<span class="line-added">1401     ASSERT(m_scrolledContentsLayer-&gt;position().isZero());</span>
1402 }
1403 
1404 void RenderLayerBacking::updateAfterDescendants()
1405 {
1406     // FIXME: this potentially duplicates work we did in updateConfiguration().
1407     PaintedContentsInfo contentsInfo(*this);
1408     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText() &amp;&amp; FontCascade::isSubpixelAntialiasingAvailable());
1409 
1410     if (!m_owningLayer.isRenderViewLayer()) {
1411         bool didUpdateContentsRect = false;
1412         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
1413         if (!didUpdateContentsRect &amp;&amp; m_graphicsLayer-&gt;usesContentsLayer())
1414             resetContentsRect();
1415     }
1416 
1417     updateDrawsContent(contentsInfo);
1418 
<span class="line-added">1419     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {</span>
<span class="line-added">1420         // For non-root layers, background is always painted by the primary graphics layer.</span>
<span class="line-added">1421         ASSERT(!m_backgroundLayer);</span>
<span class="line-added">1422         m_graphicsLayer-&gt;setContentsOpaque(!m_hasSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));</span>
<span class="line-added">1423     }</span>
<span class="line-added">1424 </span>
1425     m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
1426     if (m_scrollContainerLayer) {
1427         m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
1428         m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
1429     }
1430 }
1431 
1432 // FIXME: Avoid repaints when clip path changes.
1433 void RenderLayerBacking::updateMaskingLayerGeometry()
1434 {
1435     m_maskLayer-&gt;setSize(m_graphicsLayer-&gt;size());
1436     m_maskLayer-&gt;setPosition(FloatPoint());
1437     m_maskLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());
1438 
1439     if (!m_maskLayer-&gt;drawsContent()) {
1440         if (renderer().hasClipPath()) {
1441             ASSERT(renderer().style().clipPath()-&gt;type() != ClipPathOperation::Reference);
1442 
1443             WindRule windRule;
1444             // FIXME: Use correct reference box for inlines: https://bugs.webkit.org/show_bug.cgi?id=129047
</pre>
<hr />
<pre>
1455             m_maskLayer-&gt;setShapeLayerWindRule(windRule);
1456         }
1457     }
1458 }
1459 
1460 void RenderLayerBacking::updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
1461 {
1462     if (!m_owningLayer.hasVisibleContent())
1463         return;
1464 
1465     // The order of operations here matters, since the last valid type of contents needs
1466     // to also update the contentsRect.
1467     updateDirectlyCompositedBackgroundColor(contentsInfo, didUpdateContentsRect);
1468     updateDirectlyCompositedBackgroundImage(contentsInfo, didUpdateContentsRect);
1469 }
1470 
1471 void RenderLayerBacking::updateInternalHierarchy()
1472 {
1473     // m_foregroundLayer has to be inserted in the correct order with child layers,
1474     // so it&#39;s not inserted here.
<span class="line-modified">1475     GraphicsLayer* lastClippingLayer = nullptr;</span>
<span class="line-modified">1476     if (m_ancestorClippingStack) {</span>
<span class="line-added">1477         auto&amp; clippingStack = m_ancestorClippingStack-&gt;stack();</span>
<span class="line-added">1478         for (unsigned i = 0; i &lt; clippingStack.size() - 1; ++i) {</span>
<span class="line-added">1479             auto&amp; entry = clippingStack.at(i);</span>
<span class="line-added">1480             Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; children;</span>
<span class="line-added">1481             children.append(*clippingStack.at(i + 1).clippingLayer);</span>
<span class="line-added">1482             entry.clippingLayer-&gt;setChildren(WTFMove(children));</span>
<span class="line-added">1483         }</span>
<span class="line-added">1484 </span>
<span class="line-added">1485         lastClippingLayer = clippingStack.last().clippingLayer.get();</span>
<span class="line-added">1486         lastClippingLayer-&gt;removeAllChildren();</span>
<span class="line-added">1487     }</span>
1488 
1489     if (m_contentsContainmentLayer) {
1490         m_contentsContainmentLayer-&gt;removeAllChildren();
<span class="line-modified">1491         if (lastClippingLayer)</span>
<span class="line-modified">1492             lastClippingLayer-&gt;addChild(*m_contentsContainmentLayer);</span>
1493     }
1494 
1495     if (m_backgroundLayer)
1496         m_contentsContainmentLayer-&gt;addChild(*m_backgroundLayer);
1497 
1498     if (m_contentsContainmentLayer)
1499         m_contentsContainmentLayer-&gt;addChild(*m_graphicsLayer);
<span class="line-modified">1500     else if (lastClippingLayer)</span>
<span class="line-modified">1501         lastClippingLayer-&gt;addChild(*m_graphicsLayer);</span>
1502 
1503     if (m_childContainmentLayer)
1504         m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
1505 
1506     if (m_scrollContainerLayer) {
1507         auto* superlayer = m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
1508         superlayer-&gt;addChild(*m_scrollContainerLayer);
1509     }
1510 
1511     // The clip for child layers does not include space for overflow controls, so they exist as
1512     // siblings of the clipping layer if we have one. Normal children of this layer are set as
1513     // children of the clipping layer.
1514     if (m_layerForHorizontalScrollbar)
1515         m_graphicsLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
1516 
1517     if (m_layerForVerticalScrollbar)
1518         m_graphicsLayer-&gt;addChild(*m_layerForVerticalScrollbar);
1519 
1520     if (m_layerForScrollCorner)
1521         m_graphicsLayer-&gt;addChild(*m_layerForScrollCorner);
1522 }
1523 
1524 void RenderLayerBacking::resetContentsRect()
1525 {
1526     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
1527 
1528     if (is&lt;RenderBox&gt;(renderer())) {
1529         LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<span class="line-modified">1530         boxRect.move(contentOffsetInCompositingLayer());</span>
1531         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
1532         m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
1533     }
1534 
1535     m_graphicsLayer-&gt;setContentsTileSize(IntSize());
1536     m_graphicsLayer-&gt;setContentsTilePhase(IntSize());
1537 }
1538 
1539 void RenderLayerBacking::updateDrawsContent()
1540 {
1541     PaintedContentsInfo contentsInfo(*this);
1542     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText());
1543 
1544     updateDrawsContent(contentsInfo);
1545 }
1546 
1547 void RenderLayerBacking::updateDrawsContent(PaintedContentsInfo&amp; contentsInfo)
1548 {
1549     if (m_scrollContainerLayer) {
1550         // We don&#39;t have to consider overflow controls, because we know that the scrollbars are drawn elsewhere.
1551         // m_graphicsLayer only needs backing store if the non-scrolling parts (background, outlines, borders, shadows etc) need to paint.
1552         // m_scrollContainerLayer never has backing store.
1553         // m_scrolledContentsLayer only needs backing store if the scrolled contents need to paint.
1554         bool hasNonScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasVisibleBoxDecorationsOrBackground();
1555         m_graphicsLayer-&gt;setDrawsContent(hasNonScrollingPaintedContent);
1556 
<span class="line-modified">1557         bool hasScrollingPaintedContent = hasBackingSharingLayers() || (m_owningLayer.hasVisibleContent() &amp;&amp; (renderer().hasBackground() || contentsInfo.paintsContent()));</span>
1558         m_scrolledContentsLayer-&gt;setDrawsContent(hasScrollingPaintedContent);
1559         return;
1560     }
1561 
1562     bool hasPaintedContent = containsPaintedContent(contentsInfo);
1563 
1564     m_paintsSubpixelAntialiasedText = renderer().settings().subpixelAntialiasedLayerTextEnabled() &amp;&amp; contentsInfo.paintsSubpixelAntialiasedText();
1565 
1566     // FIXME: we could refine this to only allocate backing for one of these layers if possible.
1567     m_graphicsLayer-&gt;setDrawsContent(hasPaintedContent);
1568     if (m_foregroundLayer) {
1569         m_foregroundLayer-&gt;setDrawsContent(hasPaintedContent);
1570         m_foregroundLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1571         // The text content is painted into the foreground layer.
1572         // FIXME: this ignores SVG background images which may contain text.
1573         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(false);
1574     } else
1575         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1576 
1577     if (m_backgroundLayer)
1578         m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
1579 }
1580 
<span class="line-added">1581 void RenderLayerBacking::updateEventRegion()</span>
<span class="line-added">1582 {</span>
<span class="line-added">1583 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">1584     if (paintsIntoCompositedAncestor())</span>
<span class="line-added">1585         return;</span>
<span class="line-added">1586 </span>
<span class="line-added">1587     bool hasTouchActionElements = false;</span>
<span class="line-added">1588 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">1589     hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();</span>
<span class="line-added">1590 #endif</span>
<span class="line-added">1591     if (m_owningLayer.isRenderViewLayer() &amp;&amp; !hasTouchActionElements)</span>
<span class="line-added">1592         return;</span>
<span class="line-added">1593 </span>
<span class="line-added">1594     GraphicsContext nullContext(nullptr);</span>
<span class="line-added">1595     RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, compositedBounds(), { }, LayoutSize());</span>
<span class="line-added">1596 </span>
<span class="line-added">1597     EventRegion eventRegion;</span>
<span class="line-added">1598     auto eventRegionContext = eventRegion.makeContext();</span>
<span class="line-added">1599     paintingInfo.eventRegionContext = &amp;eventRegionContext;</span>
<span class="line-added">1600 </span>
<span class="line-added">1601     auto paintFlags = RenderLayer::paintLayerPaintingCompositingAllPhasesFlags() | RenderLayer::PaintLayerCollectingEventRegion;</span>
<span class="line-added">1602     m_owningLayer.paintLayerContents(nullContext, paintingInfo, paintFlags);</span>
<span class="line-added">1603 </span>
<span class="line-added">1604     for (auto&amp; layer : m_backingSharingLayers)</span>
<span class="line-added">1605         layer-&gt;paintLayerWithEffects(nullContext, paintingInfo, paintFlags);</span>
<span class="line-added">1606 </span>
<span class="line-added">1607     GraphicsLayer&amp; layerForEventRegion = m_scrolledContentsLayer ? *m_scrolledContentsLayer : *m_graphicsLayer;</span>
<span class="line-added">1608 </span>
<span class="line-added">1609     auto layerOffset = toIntSize(layerForEventRegion.scrollOffset()) - roundedIntSize(layerForEventRegion.offsetFromRenderer());</span>
<span class="line-added">1610     eventRegion.translate(layerOffset);</span>
<span class="line-added">1611 </span>
<span class="line-added">1612     layerForEventRegion.setEventRegion(WTFMove(eventRegion));</span>
<span class="line-added">1613 #endif</span>
<span class="line-added">1614 }</span>
<span class="line-added">1615 </span>
<span class="line-added">1616 bool RenderLayerBacking::updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp; clippingData)</span>
<span class="line-added">1617 {</span>
<span class="line-added">1618     if (!m_ancestorClippingStack &amp;&amp; clippingData.isEmpty())</span>
<span class="line-added">1619         return false;</span>
<span class="line-added">1620 </span>
<span class="line-added">1621     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();</span>
<span class="line-added">1622 </span>
<span class="line-added">1623     if (m_ancestorClippingStack &amp;&amp; clippingData.isEmpty()) {</span>
<span class="line-added">1624         m_ancestorClippingStack-&gt;clear(scrollingCoordinator);</span>
<span class="line-added">1625         m_ancestorClippingStack = nullptr;</span>
<span class="line-added">1626         return true;</span>
<span class="line-added">1627     }</span>
<span class="line-added">1628 </span>
<span class="line-added">1629     if (!m_ancestorClippingStack) {</span>
<span class="line-added">1630         m_ancestorClippingStack = makeUnique&lt;LayerAncestorClippingStack&gt;(WTFMove(clippingData));</span>
<span class="line-added">1631         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);</span>
<span class="line-added">1632         return true;</span>
<span class="line-added">1633     }</span>
<span class="line-added">1634 </span>
<span class="line-added">1635     if (m_ancestorClippingStack-&gt;equalToClipData(clippingData)) {</span>
<span class="line-added">1636         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);</span>
<span class="line-added">1637         return false;</span>
<span class="line-added">1638     }</span>
<span class="line-added">1639 </span>
<span class="line-added">1640     m_ancestorClippingStack-&gt;updateWithClipData(scrollingCoordinator, WTFMove(clippingData));</span>
<span class="line-added">1641     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);</span>
<span class="line-added">1642     return true;</span>
<span class="line-added">1643 }</span>
<span class="line-added">1644 </span>
1645 // Return true if the layer changed.
<span class="line-modified">1646 bool RenderLayerBacking::updateAncestorClipping(bool needsAncestorClip, const RenderLayer* compositingAncestor)</span>
1647 {
1648     bool layersChanged = false;
1649 
1650     if (needsAncestorClip) {
<span class="line-modified">1651         if (compositor().updateAncestorClippingStack(m_owningLayer, compositingAncestor)) {</span>
<span class="line-modified">1652             // Make any layers we don&#39;t have.</span>
<span class="line-modified">1653             if (m_ancestorClippingStack) {</span>
<span class="line-added">1654                 for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {</span>
<span class="line-added">1655                     if (!entry.clippingLayer) {</span>
<span class="line-added">1656                         entry.clippingLayer = createGraphicsLayer(entry.clipData.isOverflowScroll ? &quot;clip for scroller&quot; : &quot;ancestor clipping&quot;);</span>
<span class="line-added">1657                         entry.clippingLayer-&gt;setMasksToBounds(true);</span>
<span class="line-added">1658                         entry.clippingLayer-&gt;setPaintingPhase({ });</span>
<span class="line-added">1659                     }</span>
<span class="line-added">1660                 }</span>
<span class="line-added">1661             }</span>
<span class="line-added">1662 </span>
1663             layersChanged = true;
1664         }
<span class="line-modified">1665     } else if (m_ancestorClippingStack) {</span>
<span class="line-modified">1666         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())</span>
<span class="line-modified">1667             GraphicsLayer::unparentAndClear(entry.clippingLayer);</span>
<span class="line-added">1668 </span>
<span class="line-added">1669         m_ancestorClippingStack = nullptr;</span>
1670         layersChanged = true;
1671     }
1672 
1673     return layersChanged;
1674 }
1675 
1676 // Return true if the layer changed.
1677 bool RenderLayerBacking::updateDescendantClippingLayer(bool needsDescendantClip)
1678 {
1679     bool layersChanged = false;
1680 
1681     if (needsDescendantClip) {
1682         if (!m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking) {
1683             m_childContainmentLayer = createGraphicsLayer(&quot;child clipping&quot;);
1684             m_childContainmentLayer-&gt;setMasksToBounds(true);
1685             layersChanged = true;
1686         }
1687     } else if (hasClippingLayer()) {
1688         willDestroyLayer(m_childContainmentLayer.get());
1689         GraphicsLayer::unparentAndClear(m_childContainmentLayer);
</pre>
<hr />
<pre>
1725 bool RenderLayerBacking::requiresVerticalScrollbarLayer() const
1726 {
1727     if (!m_owningLayer.hasOverlayScrollbars())
1728         return false;
1729     return m_owningLayer.verticalScrollbar();
1730 }
1731 
1732 bool RenderLayerBacking::requiresScrollCornerLayer() const
1733 {
1734     if (!m_owningLayer.hasOverlayScrollbars())
1735         return false;
1736     return !m_owningLayer.scrollCornerAndResizerRect().isEmpty();
1737 }
1738 
1739 bool RenderLayerBacking::updateOverflowControlsLayers(bool needsHorizontalScrollbarLayer, bool needsVerticalScrollbarLayer, bool needsScrollCornerLayer)
1740 {
1741     bool horizontalScrollbarLayerChanged = false;
1742     if (needsHorizontalScrollbarLayer) {
1743         if (!m_layerForHorizontalScrollbar) {
1744             m_layerForHorizontalScrollbar = createGraphicsLayer(&quot;horizontal scrollbar&quot;);
<span class="line-modified">1745             m_layerForHorizontalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
1746             horizontalScrollbarLayerChanged = true;
1747         }
1748     } else if (m_layerForHorizontalScrollbar) {
1749         willDestroyLayer(m_layerForHorizontalScrollbar.get());
1750         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
1751         horizontalScrollbarLayerChanged = true;
1752     }
1753 
1754     bool verticalScrollbarLayerChanged = false;
1755     if (needsVerticalScrollbarLayer) {
1756         if (!m_layerForVerticalScrollbar) {
1757             m_layerForVerticalScrollbar = createGraphicsLayer(&quot;vertical scrollbar&quot;);
<span class="line-modified">1758             m_layerForVerticalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
1759             verticalScrollbarLayerChanged = true;
1760         }
1761     } else if (m_layerForVerticalScrollbar) {
1762         willDestroyLayer(m_layerForVerticalScrollbar.get());
1763         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
1764         verticalScrollbarLayerChanged = true;
1765     }
1766 
1767     bool scrollCornerLayerChanged = false;
1768     if (needsScrollCornerLayer) {
1769         if (!m_layerForScrollCorner) {
1770             m_layerForScrollCorner = createGraphicsLayer(&quot;scroll corner&quot;);
<span class="line-modified">1771             m_layerForScrollCorner-&gt;setAllowsBackingStoreDetaching(false);</span>
1772             scrollCornerLayerChanged = true;
1773         }
1774     } else if (m_layerForScrollCorner) {
1775         willDestroyLayer(m_layerForScrollCorner.get());
1776         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
1777         scrollCornerLayerChanged = true;
1778     }
1779 
1780     if (auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator()) {
1781         if (horizontalScrollbarLayerChanged)
1782             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, HorizontalScrollbar);
1783         if (verticalScrollbarLayerChanged)
1784             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, VerticalScrollbar);
1785     }
1786 
1787     return horizontalScrollbarLayerChanged || verticalScrollbarLayerChanged || scrollCornerLayerChanged;
1788 }
1789 
1790 void RenderLayerBacking::positionOverflowControlsLayers()
1791 {
</pre>
<hr />
<pre>
1818         }
1819         layer-&gt;setDrawsContent(m_owningLayer.verticalScrollbar() &amp;&amp; !layer-&gt;usesContentsLayer());
1820     }
1821 
1822     if (auto* layer = layerForScrollCorner()) {
1823         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
1824         layer-&gt;setPosition(scrollCornerAndResizer.location() - offsetFromRenderer);
1825         layer-&gt;setSize(scrollCornerAndResizer.size());
1826         layer-&gt;setDrawsContent(!scrollCornerAndResizer.isEmpty());
1827     }
1828 }
1829 
1830 bool RenderLayerBacking::updateForegroundLayer(bool needsForegroundLayer)
1831 {
1832     bool layerChanged = false;
1833     if (needsForegroundLayer) {
1834         if (!m_foregroundLayer) {
1835             String layerName = m_owningLayer.name() + &quot; (foreground)&quot;;
1836             m_foregroundLayer = createGraphicsLayer(layerName);
1837             m_foregroundLayer-&gt;setDrawsContent(true);

1838             layerChanged = true;
1839         }
1840     } else if (m_foregroundLayer) {
1841         willDestroyLayer(m_foregroundLayer.get());
1842         GraphicsLayer::unparentAndClear(m_foregroundLayer);
1843         layerChanged = true;
1844     }
1845 





1846     return layerChanged;
1847 }
1848 
1849 bool RenderLayerBacking::updateBackgroundLayer(bool needsBackgroundLayer)
1850 {
1851     bool layerChanged = false;
1852     if (needsBackgroundLayer) {
1853         if (!m_backgroundLayer) {
1854             String layerName = m_owningLayer.name() + &quot; (background)&quot;;
1855             m_backgroundLayer = createGraphicsLayer(layerName);
1856             m_backgroundLayer-&gt;setDrawsContent(true);
1857             m_backgroundLayer-&gt;setAnchorPoint(FloatPoint3D());

1858             layerChanged = true;
1859         }
1860 
1861         if (!m_contentsContainmentLayer) {
1862             String layerName = m_owningLayer.name() + &quot; (contents containment)&quot;;
1863             m_contentsContainmentLayer = createGraphicsLayer(layerName);
1864             m_contentsContainmentLayer-&gt;setAppliesPageScale(true);
1865             m_graphicsLayer-&gt;setAppliesPageScale(false);
1866             layerChanged = true;
1867         }
1868     } else {
1869         if (m_backgroundLayer) {
1870             willDestroyLayer(m_backgroundLayer.get());
1871             GraphicsLayer::unparentAndClear(m_backgroundLayer);
1872             layerChanged = true;
1873         }
1874         if (m_contentsContainmentLayer) {
1875             willDestroyLayer(m_contentsContainmentLayer.get());
1876             GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
1877             layerChanged = true;
1878             m_graphicsLayer-&gt;setAppliesPageScale(true);
1879         }
1880     }
1881 



1882     return layerChanged;
1883 }
1884 
1885 // Masking layer is used for masks or clip-path.
<span class="line-modified">1886 bool RenderLayerBacking::updateMaskingLayer(bool hasMask, bool hasClipPath)</span>
1887 {
1888     bool layerChanged = false;
1889     if (hasMask || hasClipPath) {
<span class="line-modified">1890         OptionSet&lt;GraphicsLayerPaintingPhase&gt; maskPhases;</span>
1891         if (hasMask)
<span class="line-modified">1892             maskPhases = GraphicsLayerPaintingPhase::Mask;</span>
1893 
1894         if (hasClipPath) {
1895             // If we have a mask, we need to paint the combined clip-path and mask into the mask layer.
1896             if (hasMask || renderer().style().clipPath()-&gt;type() == ClipPathOperation::Reference || !GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape))
<span class="line-modified">1897                 maskPhases.add(GraphicsLayerPaintingPhase::ClipPath);</span>
1898         }
1899 
<span class="line-modified">1900         bool paintsContent = !maskPhases.isEmpty();</span>
1901         GraphicsLayer::Type requiredLayerType = paintsContent ? GraphicsLayer::Type::Normal : GraphicsLayer::Type::Shape;
1902         if (m_maskLayer &amp;&amp; m_maskLayer-&gt;type() != requiredLayerType) {
1903             m_graphicsLayer-&gt;setMaskLayer(nullptr);
1904             willDestroyLayer(m_maskLayer.get());
1905             GraphicsLayer::clear(m_maskLayer);
1906         }
1907 
1908         if (!m_maskLayer) {
1909             m_maskLayer = createGraphicsLayer(&quot;mask&quot;, requiredLayerType);
1910             m_maskLayer-&gt;setDrawsContent(paintsContent);
1911             m_maskLayer-&gt;setPaintingPhase(maskPhases);
1912             layerChanged = true;
1913             m_graphicsLayer-&gt;setMaskLayer(m_maskLayer.copyRef());
1914             // We need a geometry update to size the new mask layer.
1915             m_owningLayer.setNeedsCompositingGeometryUpdate();
1916         }
1917     } else if (m_maskLayer) {
1918         m_graphicsLayer-&gt;setMaskLayer(nullptr);
1919         willDestroyLayer(m_maskLayer.get());
1920         GraphicsLayer::clear(m_maskLayer);
1921         layerChanged = true;
1922     }
1923 
<span class="line-modified">1924     return layerChanged;</span>

1925 }
1926 
1927 void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
1928 {
1929     if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
1930         if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
<span class="line-added">1931             auto* clipLayer = clippingLayer();</span>
1932             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());

1933             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">1934             contentsClippingRect.move(LayoutSize(clipLayer-&gt;offsetFromRenderer()));</span>
<span class="line-modified">1935             // Note that we have to set this rounded rect again during the geometry update (clipLayer-&gt;offsetFromRenderer() may be stale here).</span>
<span class="line-added">1936             if (clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect)) {</span>
<span class="line-added">1937                 clipLayer-&gt;setMaskLayer(nullptr);</span>
1938                 GraphicsLayer::clear(m_childClippingMaskLayer);
1939                 return;
1940             }
1941 
1942             if (!m_childClippingMaskLayer) {
1943                 m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
1944                 m_childClippingMaskLayer-&gt;setDrawsContent(true);
<span class="line-modified">1945                 m_childClippingMaskLayer-&gt;setPaintingPhase({ GraphicsLayerPaintingPhase::ChildClippingMask });</span>
1946                 clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
1947             }
1948         }
1949     } else {
1950         if (m_childClippingMaskLayer) {
1951             if (hasClippingLayer())
1952                 clippingLayer()-&gt;setMaskLayer(nullptr);
1953             GraphicsLayer::clear(m_childClippingMaskLayer);
1954         } else
1955             if (hasClippingLayer())
<span class="line-modified">1956                 clippingLayer()-&gt;setMasksToBoundsRect(FloatRoundedRect(FloatRect({ }, clippingLayer()-&gt;size())));</span>
1957     }
1958 }
1959 
1960 bool RenderLayerBacking::updateScrollingLayers(bool needsScrollingLayers)
1961 {
1962     if (needsScrollingLayers == !!m_scrollContainerLayer)
1963         return false;
1964 
1965     if (!m_scrollContainerLayer) {
<span class="line-modified">1966         // Outer layer which corresponds with the scroll view. This never paints content.</span>
1967         m_scrollContainerLayer = createGraphicsLayer(&quot;scroll container&quot;, GraphicsLayer::Type::ScrollContainer);
<span class="line-added">1968         m_scrollContainerLayer-&gt;setPaintingPhase({ });</span>
1969         m_scrollContainerLayer-&gt;setDrawsContent(false);
1970         m_scrollContainerLayer-&gt;setMasksToBounds(true);
1971 
1972         // Inner layer which renders the content that scrolls.
<span class="line-modified">1973         m_scrolledContentsLayer = createGraphicsLayer(&quot;scrolled contents&quot;, GraphicsLayer::Type::ScrolledContents);</span>
1974         m_scrolledContentsLayer-&gt;setDrawsContent(true);
1975         m_scrolledContentsLayer-&gt;setAnchorPoint({ });





1976         m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
1977     } else {
1978         compositor().willRemoveScrollingLayerWithBacking(m_owningLayer, *this);
1979 
1980         willDestroyLayer(m_scrollContainerLayer.get());
1981         willDestroyLayer(m_scrolledContentsLayer.get());
1982 
1983         GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
1984         GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
1985     }
1986 



1987     if (m_scrollContainerLayer)
1988         compositor().didAddScrollingLayer(m_owningLayer);
1989 
1990     return true;
1991 }
1992 

















1993 void RenderLayerBacking::detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt; roles)
1994 {
<span class="line-modified">1995     if (!m_scrollingNodeID &amp;&amp; !m_ancestorClippingStack &amp;&amp; !m_frameHostingNodeID &amp;&amp; !m_viewportConstrainedNodeID &amp;&amp; !m_positioningNodeID)</span>
1996         return;
1997 
1998     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
1999     if (!scrollingCoordinator)
2000         return;
2001 
2002     if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_scrollingNodeID) {
<span class="line-modified">2003         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching Scrolling node &quot; &lt;&lt; m_scrollingNodeID);</span>
2004         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_scrollingNodeID);
2005         m_scrollingNodeID = 0;
2006     }
2007 
<span class="line-modified">2008     if (roles.contains(ScrollCoordinationRole::ScrollingProxy) &amp;&amp; m_ancestorClippingStack) {</span>
<span class="line-modified">2009         m_ancestorClippingStack-&gt;detachFromScrollingCoordinator(*scrollingCoordinator);</span>
<span class="line-added">2010         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching nodes in ancestor clipping stack&quot;);</span>
<span class="line-added">2011     }</span>
<span class="line-added">2012 </span>
<span class="line-added">2013     if (roles.contains(ScrollCoordinationRole::FrameHosting) &amp;&amp; m_frameHostingNodeID) {</span>
<span class="line-added">2014         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching FrameHosting node &quot; &lt;&lt; m_frameHostingNodeID);</span>
2015         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_frameHostingNodeID);
2016         m_frameHostingNodeID = 0;
2017     }
2018 
2019     if (roles.contains(ScrollCoordinationRole::ViewportConstrained) &amp;&amp; m_viewportConstrainedNodeID) {
<span class="line-modified">2020         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching ViewportConstrained node &quot; &lt;&lt; m_viewportConstrainedNodeID);</span>
2021         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_viewportConstrainedNodeID);
2022         m_viewportConstrainedNodeID = 0;
2023     }

2024 
<span class="line-modified">2025     if (roles.contains(ScrollCoordinationRole::Positioning) &amp;&amp; m_positioningNodeID) {</span>
<span class="line-modified">2026         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching Positioned node &quot; &lt;&lt; m_positioningNodeID);</span>
<span class="line-modified">2027         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_positioningNodeID);</span>
<span class="line-added">2028         m_positioningNodeID = 0;</span>
<span class="line-added">2029     }</span>
2030 }
2031 
<span class="line-modified">2032 ScrollingNodeID RenderLayerBacking::scrollingNodeIDForChildren() const</span>
2033 {
<span class="line-modified">2034     if (m_frameHostingNodeID)</span>
<span class="line-modified">2035         return m_frameHostingNodeID;</span>



2036 
<span class="line-modified">2037     if (m_scrollingNodeID)</span>
<span class="line-modified">2038         return m_scrollingNodeID;</span>
<span class="line-modified">2039 </span>
<span class="line-added">2040     if (m_viewportConstrainedNodeID)</span>
<span class="line-added">2041         return m_viewportConstrainedNodeID;</span>
<span class="line-added">2042 </span>
<span class="line-added">2043     if (m_ancestorClippingStack) {</span>
<span class="line-added">2044         if (auto lastOverflowScrollProxyNode = m_ancestorClippingStack-&gt;lastOverflowScrollProxyNodeID())</span>
<span class="line-added">2045             return lastOverflowScrollProxyNode;</span>
2046     }
2047 
<span class="line-modified">2048     return m_positioningNodeID;</span>
2049 }
2050 
2051 float RenderLayerBacking::compositingOpacity(float rendererOpacity) const
2052 {
2053     float finalOpacity = rendererOpacity;
2054 
2055     for (auto* curr = m_owningLayer.parent(); curr; curr = curr-&gt;parent()) {
2056         // We only care about parents that are stacking contexts.
2057         // Recall that opacity creates stacking context.
<span class="line-modified">2058         if (!curr-&gt;isCSSStackingContext())</span>
2059             continue;
2060 
2061         // If we found a compositing layer, we want to compute opacity
2062         // relative to it. So we can break here.
2063         if (curr-&gt;isComposited())
2064             break;
2065 
2066         finalOpacity *= curr-&gt;renderer().opacity();
2067     }
2068 
2069     return finalOpacity;
2070 }
2071 
2072 // FIXME: Code is duplicated in RenderLayer. Also, we should probably not consider filters a box decoration here.
2073 static inline bool hasVisibleBoxDecorations(const RenderStyle&amp; style)
2074 {
2075     return style.hasVisibleBorder() || style.hasBorderRadius() || style.hasOutline() || style.hasAppearance() || style.boxShadow() || style.hasFilter();
2076 }
2077 
2078 static bool canDirectlyCompositeBackgroundBackgroundImage(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
2199     if (!m_isFrameLayerWithTiledBacking)
2200         return;
2201 
2202     Color backgroundColor;
2203     bool viewIsTransparent = compositor().viewHasTransparentBackground(&amp;backgroundColor);
2204 
2205     if (m_backgroundLayerPaintsFixedRootBackground &amp;&amp; m_backgroundLayer) {
2206         if (m_isMainFrameRenderViewLayer) {
2207             m_backgroundLayer-&gt;setBackgroundColor(backgroundColor);
2208             m_backgroundLayer-&gt;setContentsOpaque(!viewIsTransparent);
2209         }
2210 
2211         m_graphicsLayer-&gt;setBackgroundColor(Color());
2212         m_graphicsLayer-&gt;setContentsOpaque(false);
2213     } else if (m_isMainFrameRenderViewLayer) {
2214         m_graphicsLayer-&gt;setBackgroundColor(backgroundColor);
2215         m_graphicsLayer-&gt;setContentsOpaque(!viewIsTransparent);
2216     }
2217 }
2218 
<span class="line-added">2219 void RenderLayerBacking::updatePaintingPhases()</span>
<span class="line-added">2220 {</span>
<span class="line-added">2221     // Phases for m_childClippingMaskLayer and m_maskLayer are set elsewhere.</span>
<span class="line-added">2222     OptionSet&lt;GraphicsLayerPaintingPhase&gt; primaryLayerPhases = { GraphicsLayerPaintingPhase::Background, GraphicsLayerPaintingPhase::Foreground };</span>
<span class="line-added">2223 </span>
<span class="line-added">2224     if (m_foregroundLayer) {</span>
<span class="line-added">2225         OptionSet&lt;GraphicsLayerPaintingPhase&gt; foregroundLayerPhases { GraphicsLayerPaintingPhase::Foreground };</span>
<span class="line-added">2226 </span>
<span class="line-added">2227         if (m_scrolledContentsLayer)</span>
<span class="line-added">2228             foregroundLayerPhases.add(GraphicsLayerPaintingPhase::OverflowContents);</span>
<span class="line-added">2229 </span>
<span class="line-added">2230         m_foregroundLayer-&gt;setPaintingPhase(foregroundLayerPhases);</span>
<span class="line-added">2231         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Foreground);</span>
<span class="line-added">2232     }</span>
<span class="line-added">2233 </span>
<span class="line-added">2234     if (m_backgroundLayer) {</span>
<span class="line-added">2235         m_backgroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintingPhase::Background);</span>
<span class="line-added">2236         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Background);</span>
<span class="line-added">2237     }</span>
<span class="line-added">2238 </span>
<span class="line-added">2239     if (m_scrolledContentsLayer) {</span>
<span class="line-added">2240         OptionSet&lt;GraphicsLayerPaintingPhase&gt; scrolledContentLayerPhases = { GraphicsLayerPaintingPhase::OverflowContents, GraphicsLayerPaintingPhase::CompositedScroll };</span>
<span class="line-added">2241         if (!m_foregroundLayer)</span>
<span class="line-added">2242             scrolledContentLayerPhases.add(GraphicsLayerPaintingPhase::Foreground);</span>
<span class="line-added">2243         m_scrolledContentsLayer-&gt;setPaintingPhase(scrolledContentLayerPhases);</span>
<span class="line-added">2244 </span>
<span class="line-added">2245         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Foreground);</span>
<span class="line-added">2246         primaryLayerPhases.add(GraphicsLayerPaintingPhase::CompositedScroll);</span>
<span class="line-added">2247     }</span>
<span class="line-added">2248 </span>
<span class="line-added">2249     m_graphicsLayer-&gt;setPaintingPhase(primaryLayerPhases);</span>
<span class="line-added">2250 }</span>
<span class="line-added">2251 </span>
2252 static bool supportsDirectlyCompositedBoxDecorations(const RenderLayerModelObject&amp; renderer)
2253 {
2254     if (!GraphicsLayer::supportsBackgroundColorContent())
2255         return false;
2256 
2257     const RenderStyle&amp; style = renderer.style();
2258     if (renderer.hasClip())
2259         return false;
2260 
2261     if (hasPaintedBoxDecorationsOrBackgroundImage(style))
2262         return false;
2263 
2264     // FIXME: We can&#39;t create a directly composited background if this
2265     // layer will have children that intersect with the background layer.
2266     // A better solution might be to introduce a flattening layer if
2267     // we do direct box decoration composition.
2268     // https://bugs.webkit.org/show_bug.cgi?id=119461
2269     if (hasPerspectiveOrPreserves3D(style))
2270         return false;
2271 
</pre>
<hr />
<pre>
2319     auto&amp; element = downcast&lt;RenderEmbeddedObject&gt;(renderer).frameOwnerElement();
2320     if (!is&lt;HTMLPlugInElement&gt;(element))
2321         return false;
2322 
2323     return downcast&lt;HTMLPlugInElement&gt;(element).isRestartedPlugin();
2324 }
2325 
2326 static bool isCompositedPlugin(RenderObject&amp; renderer)
2327 {
2328     return is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing();
2329 }
2330 
2331 // A &quot;simple container layer&quot; is a RenderLayer which has no visible content to render.
2332 // It may have no children, or all its children may be themselves composited.
2333 // This is a useful optimization, because it allows us to avoid allocating backing store.
2334 bool RenderLayerBacking::isSimpleContainerCompositingLayer(PaintedContentsInfo&amp; contentsInfo) const
2335 {
2336     if (m_owningLayer.isRenderViewLayer())
2337         return false;
2338 
<span class="line-added">2339     if (hasBackingSharingLayers())</span>
<span class="line-added">2340         return false;</span>
<span class="line-added">2341 </span>
2342     if (renderer().isRenderReplaced() &amp;&amp; (!isCompositedPlugin(renderer()) || isRestartedPlugin(renderer())))
2343         return false;
2344 
2345     if (renderer().isTextControl())
2346         return false;
2347 
2348     if (contentsInfo.paintsBoxDecorations() || contentsInfo.paintsContent())
2349         return false;
2350 
2351     if (renderer().style().backgroundClip() == FillBox::Text)
2352         return false;
2353 
2354     if (renderer().isDocumentElementRenderer() &amp;&amp; m_owningLayer.isolatesCompositedBlending())
2355         return false;
2356 
2357     return true;
2358 }
2359 
2360 // Returning true stops the traversal.
2361 enum class LayerTraversal { Continue, Stop };
</pre>
<hr />
<pre>
2459 // that require painting. Direct compositing saves backing store.
2460 bool RenderLayerBacking::isDirectlyCompositedImage() const
2461 {
2462     if (!is&lt;RenderImage&gt;(renderer()) || m_owningLayer.hasVisibleBoxDecorationsOrBackground() || m_owningLayer.paintsWithFilters() || renderer().hasClip())
2463         return false;
2464 
2465 #if ENABLE(VIDEO)
2466     if (is&lt;RenderMedia&gt;(renderer()))
2467         return false;
2468 #endif
2469 
2470     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2471     if (auto* cachedImage = imageRenderer.cachedImage()) {
2472         if (!cachedImage-&gt;hasImage())
2473             return false;
2474 
2475         auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2476         if (!is&lt;BitmapImage&gt;(image))
2477             return false;
2478 
<span class="line-modified">2479         if (downcast&lt;BitmapImage&gt;(*image).orientationForCurrentFrame() != ImageOrientation::None)</span>
2480             return false;
2481 
2482 #if (PLATFORM(GTK) || PLATFORM(WPE))
2483         // GTK and WPE ports don&#39;t support rounded rect clipping at TextureMapper level, so they cannot
2484         // directly composite images that have border-radius propery. Draw them as non directly composited
2485         // content instead. See https://bugs.webkit.org/show_bug.cgi?id=174157.
2486         if (imageRenderer.style().hasBorderRadius())
2487             return false;
2488 #endif
2489 
2490         return m_graphicsLayer-&gt;shouldDirectlyCompositeImage(image);
2491     }
2492 
2493     return false;
2494 }
2495 
2496 void RenderLayerBacking::contentChanged(ContentChangeType changeType)
2497 {
2498     PaintedContentsInfo contentsInfo(*this);
2499     if ((changeType == ImageChanged) &amp;&amp; contentsInfo.isDirectlyCompositedImage()) {
2500         updateImageContents(contentsInfo);
2501         return;
2502     }
2503 
<span class="line-added">2504     if (changeType == VideoChanged) {</span>
<span class="line-added">2505         compositor().scheduleCompositingLayerUpdate();</span>
<span class="line-added">2506         return;</span>
<span class="line-added">2507     }</span>
<span class="line-added">2508 </span>
2509     if ((changeType == BackgroundImageChanged) &amp;&amp; canDirectlyCompositeBackgroundBackgroundImage(renderer().style()))
2510         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2511 
2512     if ((changeType == MaskImageChanged) &amp;&amp; m_maskLayer)
2513         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2514 
<span class="line-modified">2515 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS) || ENABLE(WEBGPU)</span>
2516     if ((changeType == CanvasChanged || changeType == CanvasPixelsChanged) &amp;&amp; renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
<span class="line-added">2517         if (changeType == CanvasChanged)</span>
<span class="line-added">2518             compositor().scheduleCompositingLayerUpdate();</span>
<span class="line-added">2519 </span>
2520         m_graphicsLayer-&gt;setContentsNeedsDisplay();
2521         return;
2522     }
2523 #endif
2524 }
2525 
2526 void RenderLayerBacking::updateImageContents(PaintedContentsInfo&amp; contentsInfo)
2527 {
2528     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2529 
2530     auto* cachedImage = imageRenderer.cachedImage();
2531     if (!cachedImage)
2532         return;
2533 
2534     auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2535     if (!image)
2536         return;
2537 
2538     // We have to wait until the image is fully loaded before setting it on the layer.
2539     if (!cachedImage-&gt;isLoaded())
2540         return;
2541 
2542     // This is a no-op if the layer doesn&#39;t have an inner layer for the image.
2543     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
2544 
2545     LayoutRect boxRect(LayoutPoint(), imageRenderer.size());
<span class="line-modified">2546     boxRect.move(contentOffsetInCompositingLayer());</span>
2547     FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
2548     m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
2549 
2550     m_graphicsLayer-&gt;setContentsToImage(image);
2551 
2552     updateDrawsContent(contentsInfo);
2553 
2554     // Image animation is &quot;lazy&quot;, in that it automatically stops unless someone is drawing
2555     // the image. So we have to kick the animation each time; this has the downside that the
2556     // image will keep animating, even if its layer is not visible.
2557     image-&gt;startAnimation();
2558 }
2559 
2560 FloatPoint3D RenderLayerBacking::computeTransformOriginForPainting(const LayoutRect&amp; borderBox) const
2561 {
2562     const RenderStyle&amp; style = renderer().style();
2563     float deviceScaleFactor = this-&gt;deviceScaleFactor();
2564 
2565     FloatPoint3D origin;
2566     origin.setX(roundToDevicePixel(floatValueForLength(style.transformOriginX(), borderBox.width()), deviceScaleFactor));
2567     origin.setY(roundToDevicePixel(floatValueForLength(style.transformOriginY(), borderBox.height()), deviceScaleFactor));
2568     origin.setZ(style.transformOriginZ());
2569 
2570     return origin;
2571 }
2572 
2573 // Return the offset from the top-left of this compositing layer at which the renderer&#39;s contents are painted.
<span class="line-modified">2574 LayoutSize RenderLayerBacking::contentOffsetInCompositingLayer() const</span>
2575 {
2576     return LayoutSize(-m_compositedBounds.x() + m_compositedBoundsOffsetFromGraphicsLayer.width(), -m_compositedBounds.y() + m_compositedBoundsOffsetFromGraphicsLayer.height());
2577 }
2578 
2579 LayoutRect RenderLayerBacking::contentsBox() const
2580 {
2581     if (!is&lt;RenderBox&gt;(renderer()))
2582         return LayoutRect();
2583 
2584     auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
2585     LayoutRect contentsRect;
2586 #if ENABLE(VIDEO)
2587     if (is&lt;RenderVideo&gt;(renderBox))
2588         contentsRect = downcast&lt;RenderVideo&gt;(renderBox).videoBox();
2589     else
2590 #endif
2591     if (is&lt;RenderReplaced&gt;(renderBox)) {
2592         RenderReplaced&amp; renderReplaced = downcast&lt;RenderReplaced&gt;(renderBox);
2593         contentsRect = renderReplaced.replacedContentRect();
2594     } else
2595         contentsRect = renderBox.contentBoxRect();
2596 
<span class="line-modified">2597     contentsRect.move(contentOffsetInCompositingLayer());</span>
2598     return contentsRect;
2599 }
2600 
2601 static LayoutRect backgroundRectForBox(const RenderBox&amp; box)
2602 {
2603     switch (box.style().backgroundClip()) {
2604     case FillBox::Border:
2605         return box.borderBoxRect();
2606     case FillBox::Padding:
2607         return box.paddingBoxRect();
2608     case FillBox::Content:
2609         return box.contentBoxRect();
2610     default:
2611         break;
2612     }
2613 
2614     ASSERT_NOT_REACHED();
2615     return LayoutRect();
2616 }
2617 
2618 FloatRect RenderLayerBacking::backgroundBoxForSimpleContainerPainting() const
2619 {
2620     if (!is&lt;RenderBox&gt;(renderer()))
2621         return FloatRect();
2622 
2623     LayoutRect backgroundBox = backgroundRectForBox(downcast&lt;RenderBox&gt;(renderer()));
<span class="line-modified">2624     backgroundBox.move(contentOffsetInCompositingLayer());</span>
2625     return snapRectToDevicePixels(backgroundBox, deviceScaleFactor());
2626 }
2627 
2628 GraphicsLayer* RenderLayerBacking::parentForSublayers() const
2629 {
2630     if (m_scrolledContentsLayer)
2631         return m_scrolledContentsLayer.get();
2632 
2633     return m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
2634 }
2635 
2636 GraphicsLayer* RenderLayerBacking::childForSuperlayers() const
2637 {
<span class="line-modified">2638     if (m_ancestorClippingStack)</span>
<span class="line-modified">2639         return m_ancestorClippingStack-&gt;firstClippingLayer();</span>
2640 
2641     if (m_contentsContainmentLayer)
2642         return m_contentsContainmentLayer.get();
2643 
2644     return m_graphicsLayer.get();
2645 }
2646 
2647 bool RenderLayerBacking::paintsIntoWindow() const
2648 {
2649 #if USE(COORDINATED_GRAPHICS)
2650         return false;
2651 #endif
2652 
2653     if (m_isFrameLayerWithTiledBacking)
2654         return false;
2655 
2656     if (m_owningLayer.isRenderViewLayer()) {
2657 #if PLATFORM(IOS_FAMILY) || USE(COORDINATED_GRAPHICS)
2658         if (compositor().inForcedCompositingMode())
2659             return false;
</pre>
<hr />
<pre>
2671         return;
2672 
2673     m_requiresOwnBackingStore = requiresOwnBacking;
2674 
2675     // This affects the answer to paintsIntoCompositedAncestor(), which in turn affects
2676     // cached clip rects, so when it changes we have to clear clip rects on descendants.
2677     m_owningLayer.clearClipRectsIncludingDescendants(PaintingClipRects);
2678     m_owningLayer.computeRepaintRectsIncludingDescendants();
2679 
2680     compositor().repaintInCompositedAncestor(m_owningLayer, compositedBounds());
2681 }
2682 
2683 void RenderLayerBacking::setContentsNeedDisplay(GraphicsLayer::ShouldClipToLayer shouldClip)
2684 {
2685     ASSERT(!paintsIntoCompositedAncestor());
2686 
2687     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2688     if (!m_owningLayer.isRenderViewLayer())
2689         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2690 
<span class="line-added">2691     m_owningLayer.invalidateEventRegion();</span>
<span class="line-added">2692 </span>
2693     auto&amp; frameView = renderer().view().frameView();
2694     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2695         frameView.addTrackedRepaintRect(owningLayer().absoluteBoundingBoxForPainting());
2696 
2697     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2698         // By default, setNeedsDisplay will clip to the size of the GraphicsLayer, which does not include margin tiles.
2699         // So if the TiledBacking has a margin that needs to be invalidated, we need to send in a rect to setNeedsDisplayInRect
2700         // that is large enough to include the margin. TiledBacking::bounds() includes the margin.
2701         auto* tiledBacking = this-&gt;tiledBacking();
2702         FloatRect rectToRepaint = tiledBacking ? tiledBacking-&gt;bounds() : FloatRect(FloatPoint(0, 0), m_graphicsLayer-&gt;size());
2703         m_graphicsLayer-&gt;setNeedsDisplayInRect(rectToRepaint, shouldClip);
2704     }
2705 
2706     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent())
2707         m_foregroundLayer-&gt;setNeedsDisplay();
2708 
2709     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent())
2710         m_backgroundLayer-&gt;setNeedsDisplay();
2711 
2712     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent())
2713         m_maskLayer-&gt;setNeedsDisplay();
2714 
2715     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent())
2716         m_childClippingMaskLayer-&gt;setNeedsDisplay();
2717 
2718     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent())
2719         m_scrolledContentsLayer-&gt;setNeedsDisplay();
2720 }
2721 
2722 // r is in the coordinate space of the layer&#39;s render object
2723 void RenderLayerBacking::setContentsNeedDisplayInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
2724 {
2725     ASSERT(!paintsIntoCompositedAncestor());
2726 
2727     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2728     if (!m_owningLayer.isRenderViewLayer())
2729         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2730 
<span class="line-added">2731     m_owningLayer.invalidateEventRegion();</span>
<span class="line-added">2732 </span>
2733     FloatRect pixelSnappedRectForPainting = snapRectToDevicePixels(r, deviceScaleFactor());
2734     auto&amp; frameView = renderer().view().frameView();
2735     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2736         frameView.addTrackedRepaintRect(pixelSnappedRectForPainting);
2737 
2738     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2739         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2740         layerDirtyRect.move(-m_graphicsLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2741         m_graphicsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2742     }
2743 
2744     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent()) {
2745         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2746         layerDirtyRect.move(-m_foregroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2747         m_foregroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2748     }
2749 
2750     // FIXME: need to split out repaints for the background.
2751     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent()) {
2752         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2753         layerDirtyRect.move(-m_backgroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2754         m_backgroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2755     }
2756 
2757     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent()) {
2758         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2759         layerDirtyRect.move(-m_maskLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2760         m_maskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2761     }
2762 
2763     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent()) {
2764         FloatRect layerDirtyRect = r;
2765         layerDirtyRect.move(-m_childClippingMaskLayer-&gt;offsetFromRenderer());
2766         m_childClippingMaskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect);
2767     }
2768 
2769     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
2770         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2771         layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);





2772         m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2773     }
2774 }
2775 
2776 void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
2777     const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">2778     OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase)</span>
2779 {
<span class="line-modified">2780     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; paintingPhase != OptionSet&lt;GraphicsLayerPaintingPhase&gt;(GraphicsLayerPaintingPhase::ChildClippingMask)) {</span>
2781 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
2782         // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
2783         // when pages are restored from the PageCache.
2784         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in PageCache
2785         ASSERT_NOT_REACHED();
2786 #endif
2787         return;
2788     }
2789 
2790     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;
<span class="line-modified">2791     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))</span>
2792         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
<span class="line-modified">2793     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))</span>
2794         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
<span class="line-modified">2795     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))</span>
2796         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
<span class="line-modified">2797     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))</span>
2798         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
<span class="line-modified">2799     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))</span>
2800         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
<span class="line-modified">2801     if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
2802         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
<span class="line-modified">2803     if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))</span>
2804         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
2805 
2806     if (graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)
2807         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
2808     else if (compositor().fixedRootBackgroundLayer())
2809         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);
2810 
2811 #ifndef NDEBUG
2812     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
2813 #endif
2814 
<span class="line-modified">2815     auto paintOneLayer = [&amp;](RenderLayer&amp; layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags) {</span>
<span class="line-modified">2816         InspectorInstrumentation::willPaint(layer.renderer());</span>

2817 
<span class="line-modified">2818         FrameView::PaintingState paintingState;</span>
<span class="line-modified">2819         if (layer.isRenderViewLayer())</span>
<span class="line-modified">2820             renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
2821 
<span class="line-modified">2822         RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);</span>

2823 
<span class="line-modified">2824         if (&amp;layer == &amp;m_owningLayer) {</span>
<span class="line-modified">2825             layer.paintLayerContents(context, paintingInfo, paintFlags);</span>
<span class="line-added">2826 </span>
<span class="line-added">2827             if (layer.containsDirtyOverlayScrollbars())</span>
<span class="line-added">2828                 layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);</span>
<span class="line-added">2829         } else</span>
<span class="line-added">2830             layer.paintLayerWithEffects(context, paintingInfo, paintFlags);</span>
<span class="line-added">2831 </span>
<span class="line-added">2832         if (layer.isRenderViewLayer())</span>
<span class="line-added">2833             renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>
<span class="line-added">2834 </span>
<span class="line-added">2835         ASSERT(!m_owningLayer.m_usedTransparency);</span>
<span class="line-added">2836 </span>
<span class="line-added">2837         InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);</span>
<span class="line-added">2838     };</span>
<span class="line-added">2839 </span>
<span class="line-added">2840     paintOneLayer(m_owningLayer, paintFlags);</span>
<span class="line-added">2841 </span>
<span class="line-added">2842     // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.</span>
<span class="line-added">2843     GraphicsLayer* destinationForSharingLayers = m_scrolledContentsLayer ? m_scrolledContentsLayer.get() : m_graphicsLayer.get();</span>
<span class="line-added">2844 </span>
<span class="line-added">2845     if (graphicsLayer == destinationForSharingLayers) {</span>
<span class="line-added">2846         OptionSet&lt;RenderLayer::PaintLayerFlag&gt; sharingLayerPaintFlags = {</span>
<span class="line-added">2847             RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,</span>
<span class="line-added">2848             RenderLayer::PaintLayerPaintingCompositingForegroundPhase };</span>
<span class="line-added">2849 </span>
<span class="line-added">2850         if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
<span class="line-added">2851             sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);</span>
<span class="line-added">2852 </span>
<span class="line-added">2853         for (auto&amp; layerWeakPtr : m_backingSharingLayers)</span>
<span class="line-added">2854             paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);</span>
<span class="line-added">2855     }</span>
2856 
2857     compositor().didPaintBacking(this);
<span class="line-added">2858 }</span>
<span class="line-added">2859 </span>
<span class="line-added">2860 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">2861 static RefPtr&lt;Pattern&gt; patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext&amp; destContext)</span>
<span class="line-added">2862 {</span>
<span class="line-added">2863     auto toIndex = [](TouchAction touchAction) -&gt; unsigned {</span>
<span class="line-added">2864         switch (touchAction) {</span>
<span class="line-added">2865         case TouchAction::None:</span>
<span class="line-added">2866             return 1;</span>
<span class="line-added">2867         case TouchAction::Manipulation:</span>
<span class="line-added">2868             return 2;</span>
<span class="line-added">2869         case TouchAction::PanX:</span>
<span class="line-added">2870             return 3;</span>
<span class="line-added">2871         case TouchAction::PanY:</span>
<span class="line-added">2872             return 4;</span>
<span class="line-added">2873         case TouchAction::PinchZoom:</span>
<span class="line-added">2874             return 5;</span>
<span class="line-added">2875         case TouchAction::Auto:</span>
<span class="line-added">2876             break;</span>
<span class="line-added">2877         }</span>
<span class="line-added">2878         return 0;</span>
<span class="line-added">2879     };</span>
<span class="line-added">2880 </span>
<span class="line-added">2881     struct TouchActionAndRGB {</span>
<span class="line-added">2882         TouchAction action;</span>
<span class="line-added">2883         ASCIILiteral name;</span>
<span class="line-added">2884         FloatSize phase;</span>
<span class="line-added">2885     };</span>
<span class="line-added">2886     static const TouchActionAndRGB actionsAndColors[] = {</span>
<span class="line-added">2887         { TouchAction::Auto, &quot;auto&quot;_s, { } },</span>
<span class="line-added">2888         { TouchAction::None, &quot;none&quot;_s, { } },</span>
<span class="line-added">2889         { TouchAction::Manipulation, &quot;manip&quot;_s, { } },</span>
<span class="line-added">2890         { TouchAction::PanX, &quot;pan-x&quot;_s, { } },</span>
<span class="line-added">2891         { TouchAction::PanY, &quot;pan-y&quot;_s, { 0, 9 } },</span>
<span class="line-added">2892         { TouchAction::PinchZoom, &quot;p-z&quot;_s, { 16, 4.5 } },</span>
<span class="line-added">2893     };</span>
<span class="line-added">2894 </span>
<span class="line-added">2895     auto actionIndex = toIndex(touchAction);</span>
<span class="line-added">2896     if (!actionIndex || actionIndex &gt;= ARRAY_SIZE(actionsAndColors))</span>
<span class="line-added">2897         return nullptr;</span>
<span class="line-added">2898 </span>
<span class="line-added">2899     const FloatSize tileSize { 32, 18 };</span>
<span class="line-added">2900 </span>
<span class="line-added">2901     auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpaceSRGB, destContext);</span>
<span class="line-added">2902     if (!imageBuffer)</span>
<span class="line-added">2903         return nullptr;</span>
<span class="line-added">2904 </span>
<span class="line-added">2905     const auto&amp; touchActionData = actionsAndColors[actionIndex];</span>
<span class="line-added">2906     {</span>
<span class="line-added">2907         GraphicsContext&amp; imageContext = imageBuffer-&gt;context();</span>
2908 
<span class="line-modified">2909         FontCascadeDescription fontDescription;</span>
<span class="line-added">2910         fontDescription.setOneFamily(&quot;Helvetica&quot;);</span>
<span class="line-added">2911         fontDescription.setSpecifiedSize(10);</span>
<span class="line-added">2912         fontDescription.setComputedSize(10);</span>
<span class="line-added">2913         fontDescription.setWeight(FontSelectionValue(500));</span>
<span class="line-added">2914         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added">2915         font.update(nullptr);</span>
<span class="line-added">2916 </span>
<span class="line-added">2917         TextRun textRun = TextRun(touchActionData.name);</span>
<span class="line-added">2918         imageContext.setFillColor(Color(0, 0, 0, 128));</span>
<span class="line-added">2919 </span>
<span class="line-added">2920         constexpr float textGap = 4;</span>
<span class="line-added">2921         constexpr float yOffset = 12;</span>
<span class="line-added">2922         imageContext.drawText(font, textRun, { textGap, yOffset }, 0);</span>
<span class="line-added">2923     }</span>
<span class="line-added">2924 </span>
<span class="line-added">2925     auto tileImage = ImageBuffer::sinkIntoImage(WTFMove(imageBuffer));</span>
<span class="line-added">2926     auto fillPattern = Pattern::create(tileImage.releaseNonNull(), true, true);</span>
<span class="line-added">2927     AffineTransform patternOffsetTransform;</span>
<span class="line-added">2928     patternOffsetTransform.translate(contentOffset + touchActionData.phase);</span>
<span class="line-added">2929     patternOffsetTransform.scale(1 / destContext.scaleFactor());</span>
<span class="line-added">2930     fillPattern-&gt;setPatternSpaceTransform(patternOffsetTransform);</span>
<span class="line-added">2931 </span>
<span class="line-added">2932     return fillPattern;</span>
<span class="line-added">2933 }</span>
<span class="line-added">2934 #endif // ENABLE(POINTER_EVENTS)</span>
<span class="line-added">2935 </span>
<span class="line-added">2936 void RenderLayerBacking::paintDebugOverlays(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context)</span>
<span class="line-added">2937 {</span>
<span class="line-added">2938     if (graphicsLayer-&gt;eventRegion().isEmpty())</span>
<span class="line-added">2939         return;</span>
<span class="line-added">2940 </span>
<span class="line-added">2941     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added">2942 </span>
<span class="line-added">2943     // The region is offset by contentOffsetInCompositingLayer() so undo that.</span>
<span class="line-added">2944     auto contentOffset = roundedIntSize(contentOffsetInCompositingLayer());</span>
<span class="line-added">2945     context.translate(-contentOffset);</span>
<span class="line-added">2946 </span>
<span class="line-added">2947     // The interactive part.</span>
<span class="line-added">2948     auto&amp; eventRegion = graphicsLayer-&gt;eventRegion();</span>
<span class="line-added">2949     Color regionColor(0, 0, 0, 5);</span>
<span class="line-added">2950     context.setFillColor(regionColor);</span>
<span class="line-added">2951     for (auto rect : eventRegion.region().rects())</span>
<span class="line-added">2952         context.fillRect(rect);</span>
<span class="line-added">2953 </span>
<span class="line-added">2954 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">2955     const TouchAction touchActionList[] = {</span>
<span class="line-added">2956         TouchAction::None,</span>
<span class="line-added">2957         TouchAction::Manipulation,</span>
<span class="line-added">2958         TouchAction::PanX,</span>
<span class="line-added">2959         TouchAction::PanY,</span>
<span class="line-added">2960         TouchAction::PinchZoom,</span>
<span class="line-added">2961     };</span>
<span class="line-added">2962 </span>
<span class="line-added">2963     for (auto action : touchActionList) {</span>
<span class="line-added">2964         auto* actionRegion = graphicsLayer-&gt;eventRegion().regionForTouchAction(action);</span>
<span class="line-added">2965         if (!actionRegion)</span>
<span class="line-added">2966             continue;</span>
<span class="line-added">2967 </span>
<span class="line-added">2968         auto fillPattern = patternForTouchAction(action, contentOffsetInCompositingLayer(), context);</span>
<span class="line-added">2969         if (!fillPattern)</span>
<span class="line-added">2970             continue;</span>
<span class="line-added">2971 </span>
<span class="line-added">2972         context.setFillPattern(fillPattern.releaseNonNull());</span>
<span class="line-added">2973         for (auto rect : actionRegion-&gt;rects())</span>
<span class="line-added">2974             context.fillRect(rect);</span>
<span class="line-added">2975     }</span>
<span class="line-added">2976 #endif // ENABLE(POINTER_EVENTS)</span>
2977 }
2978 
2979 // Up-call from compositing layer drawing callback.
<span class="line-modified">2980 void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
2981 {
2982 #ifndef NDEBUG
2983     renderer().page().setIsPainting(true);
2984 #endif
2985 
2986 #if PLATFORM(MAC)
2987     LocalDefaultSystemAppearance localAppearance(renderer().useDarkAppearance());
2988 #endif
2989 
2990     // The dirtyRect is in the coords of the painting root.
2991     FloatRect adjustedClipRect = clip;
2992     adjustedClipRect.move(m_subpixelOffsetFromRenderer);
2993     IntRect dirtyRect = enclosingIntRect(adjustedClipRect);
2994 
2995     if (!graphicsLayer-&gt;repaintCount())
2996         layerPaintBehavior |= GraphicsLayerPaintFirstTilePaint;
2997 
2998     if (graphicsLayer == m_graphicsLayer.get()
2999         || graphicsLayer == m_foregroundLayer.get()
3000         || graphicsLayer == m_backgroundLayer.get()
3001         || graphicsLayer == m_maskLayer.get()
3002         || graphicsLayer == m_childClippingMaskLayer.get()
3003         || graphicsLayer == m_scrolledContentsLayer.get()) {

3004 
<span class="line-modified">3005         if (!paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
3006             dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
3007 
3008         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
3009         OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
3010         if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
3011             behavior.add(PaintBehavior::Snapshotting);
3012 
3013         if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
3014             behavior.add(PaintBehavior::TileFirstPaint);
3015 
3016         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);
3017 
<span class="line-modified">3018         if (renderer().settings().visibleDebugOverlayRegions() &amp; NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.</span>
<span class="line-added">3019             paintDebugOverlays(graphicsLayer, context);</span>
<span class="line-added">3020 </span>
3021     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
3022         paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
3023     } else if (graphicsLayer == layerForVerticalScrollbar()) {
3024         paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
3025     } else if (graphicsLayer == layerForScrollCorner()) {
3026         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
<span class="line-modified">3027         GraphicsContextStateSaver stateSaver(context);</span>
3028         context.translate(-scrollCornerAndResizer.location());
3029         LayoutRect transformedClip = LayoutRect(clip);
3030         transformedClip.moveBy(scrollCornerAndResizer.location());
3031         m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
3032         m_owningLayer.paintResizer(context, IntPoint(), transformedClip);

3033     }
3034 #ifndef NDEBUG
3035     renderer().page().setIsPainting(false);
3036 #endif
3037 }
3038 
3039 float RenderLayerBacking::pageScaleFactor() const
3040 {
3041     return compositor().pageScaleFactor();
3042 }
3043 
3044 float RenderLayerBacking::zoomedOutPageScaleFactor() const
3045 {
3046     return compositor().zoomedOutPageScaleFactor();
3047 }
3048 
3049 float RenderLayerBacking::deviceScaleFactor() const
3050 {
3051     return compositor().deviceScaleFactor();
3052 }
</pre>
<hr />
<pre>
3130 }
3131 
3132 bool RenderLayerBacking::useGiantTiles() const
3133 {
3134     return renderer().settings().useGiantTiles();
3135 }
3136 
3137 void RenderLayerBacking::logFilledVisibleFreshTile(unsigned blankPixelCount)
3138 {
3139     if (auto* loggingClient = renderer().page().performanceLoggingClient())
3140         loggingClient-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::FilledTile, MonotonicTime::now(), blankPixelCount);
3141 }
3142 
3143 #ifndef NDEBUG
3144 void RenderLayerBacking::verifyNotPainting()
3145 {
3146     ASSERT(!renderer().page().isPainting());
3147 }
3148 #endif
3149 
<span class="line-modified">3150 bool RenderLayerBacking::startAnimation(double timeOffset, const Animation&amp; animation, const KeyframeList&amp; keyframes)</span>
3151 {
3152     bool hasOpacity = keyframes.containsProperty(CSSPropertyOpacity);
3153     bool hasTransform = renderer().isBox() &amp;&amp; keyframes.containsProperty(CSSPropertyTransform);
3154     bool hasFilter = keyframes.containsProperty(CSSPropertyFilter);
3155 
3156     bool hasBackdropFilter = false;
3157 #if ENABLE(FILTERS_LEVEL_2)
3158     hasBackdropFilter = keyframes.containsProperty(CSSPropertyWebkitBackdropFilter);
3159 #endif
3160 
3161     if (!hasOpacity &amp;&amp; !hasTransform &amp;&amp; !hasFilter &amp;&amp; !hasBackdropFilter)
3162         return false;
3163 
3164     KeyframeValueList transformVector(AnimatedPropertyTransform);
3165     KeyframeValueList opacityVector(AnimatedPropertyOpacity);
3166     KeyframeValueList filterVector(AnimatedPropertyFilter);
3167 #if ENABLE(FILTERS_LEVEL_2)
3168     KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
3169 #endif
3170 
3171     size_t numKeyframes = keyframes.size();
3172     for (size_t i = 0; i &lt; numKeyframes; ++i) {
3173         const KeyframeValue&amp; currentKeyframe = keyframes[i];
3174         const RenderStyle* keyframeStyle = currentKeyframe.style();
3175         double key = currentKeyframe.key();
3176 
3177         if (!keyframeStyle)
3178             continue;
3179 
3180         auto* tf = currentKeyframe.timingFunction();
3181 
3182         bool isFirstOrLastKeyframe = key == 0 || key == 1;
3183         if ((hasTransform &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyTransform))
<span class="line-modified">3184             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(key, keyframeStyle-&gt;transform(), tf));</span>
3185 
3186         if ((hasOpacity &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyOpacity))
<span class="line-modified">3187             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(key, keyframeStyle-&gt;opacity(), tf));</span>
3188 
3189         if ((hasFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyFilter))
<span class="line-modified">3190             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;filter(), tf));</span>
3191 
3192 #if ENABLE(FILTERS_LEVEL_2)
3193         if ((hasBackdropFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyWebkitBackdropFilter))
<span class="line-modified">3194             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;backdropFilter(), tf));</span>
3195 #endif
3196     }
3197 
3198     if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
3199         return false;
3200 
3201     bool didAnimate = false;
3202 
<span class="line-modified">3203     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), &amp;animation, keyframes.animationName(), timeOffset))</span>
3204         didAnimate = true;
3205 
<span class="line-modified">3206     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))</span>
3207         didAnimate = true;
3208 
<span class="line-modified">3209     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))</span>
3210         didAnimate = true;
3211 
3212 #if ENABLE(FILTERS_LEVEL_2)
<span class="line-modified">3213     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))</span>
3214         didAnimate = true;
3215 #endif
3216 
3217     if (didAnimate)
3218         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3219 
3220     return didAnimate;
3221 }
3222 
3223 void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
3224 {
3225     m_graphicsLayer-&gt;pauseAnimation(animationName, timeOffset);
3226 }
3227 
3228 void RenderLayerBacking::animationSeeked(double timeOffset, const String&amp; animationName)
3229 {
3230     m_graphicsLayer-&gt;seekAnimation(animationName, timeOffset);
3231 }
3232 
3233 void RenderLayerBacking::animationFinished(const String&amp; animationName)
3234 {
3235     m_graphicsLayer-&gt;removeAnimation(animationName);
3236     m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3237 }
3238 
3239 bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
3240 {
3241     bool didAnimate = false;
3242 
3243     ASSERT(property != CSSPropertyInvalid);
3244 
3245     if (property == CSSPropertyOpacity) {
3246         const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
3247         if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
3248             KeyframeValueList opacityVector(AnimatedPropertyOpacity);
<span class="line-modified">3249             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));</span>
<span class="line-modified">3250             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));</span>
3251             // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
3252             if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
3253                 // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
3254                 updateOpacity(*toStyle);
3255                 didAnimate = true;
3256             }
3257         }
3258     }
3259 
3260     if (property == CSSPropertyTransform &amp;&amp; m_owningLayer.hasTransform()) {
3261         const Animation* transformAnim = toStyle-&gt;transitionForProperty(CSSPropertyTransform);
3262         if (transformAnim &amp;&amp; !transformAnim-&gt;isEmptyOrZeroDuration()) {
3263             KeyframeValueList transformVector(AnimatedPropertyTransform);
<span class="line-modified">3264             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(0, fromStyle-&gt;transform()));</span>
<span class="line-modified">3265             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(1, toStyle-&gt;transform()));</span>
3266             if (m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), transformAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyTransform), timeOffset)) {
3267                 // To ensure that the correct transform is visible when the animation ends, also set the final transform.
3268                 updateTransform(*toStyle);
3269                 didAnimate = true;
3270             }
3271         }
3272     }
3273 
3274     if (property == CSSPropertyFilter &amp;&amp; m_owningLayer.hasFilter()) {
3275         const Animation* filterAnim = toStyle-&gt;transitionForProperty(CSSPropertyFilter);
3276         if (filterAnim &amp;&amp; !filterAnim-&gt;isEmptyOrZeroDuration()) {
3277             KeyframeValueList filterVector(AnimatedPropertyFilter);
<span class="line-modified">3278             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;filter()));</span>
<span class="line-modified">3279             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;filter()));</span>
3280             if (m_graphicsLayer-&gt;addAnimation(filterVector, FloatSize(), filterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyFilter), timeOffset)) {
3281                 // To ensure that the correct filter is visible when the animation ends, also set the final filter.
3282                 updateFilters(*toStyle);
3283                 didAnimate = true;
3284             }
3285         }
3286     }
3287 
3288 #if ENABLE(FILTERS_LEVEL_2)
3289     if (property == CSSPropertyWebkitBackdropFilter &amp;&amp; m_owningLayer.hasBackdropFilter()) {
3290         const Animation* backdropFilterAnim = toStyle-&gt;transitionForProperty(CSSPropertyWebkitBackdropFilter);
3291         if (backdropFilterAnim &amp;&amp; !backdropFilterAnim-&gt;isEmptyOrZeroDuration()) {
3292             KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
<span class="line-modified">3293             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;backdropFilter()));</span>
<span class="line-modified">3294             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;backdropFilter()));</span>
3295             if (m_graphicsLayer-&gt;addAnimation(backdropFilterVector, FloatSize(), backdropFilterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyWebkitBackdropFilter), timeOffset)) {
3296                 // To ensure that the correct backdrop filter is visible when the animation ends, also set the final backdrop filter.
3297                 updateBackdropFilters(*toStyle);
3298                 didAnimate = true;
3299             }
3300         }
3301     }
3302 #endif
3303 
3304     if (didAnimate)
3305         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3306 
3307     return didAnimate;
3308 }
3309 
3310 void RenderLayerBacking::transitionPaused(double timeOffset, CSSPropertyID property)
3311 {
3312     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
3313     if (animatedProperty != AnimatedPropertyInvalid)
3314         m_graphicsLayer-&gt;pauseAnimation(GraphicsLayer::animationNameForTransition(animatedProperty), timeOffset);
</pre>
<hr />
<pre>
3428         break;
3429     }
3430     return AnimatedPropertyInvalid;
3431 }
3432 
3433 CompositingLayerType RenderLayerBacking::compositingLayerType() const
3434 {
3435     if (m_graphicsLayer-&gt;usesContentsLayer())
3436         return MediaCompositingLayer;
3437 
3438     if (m_graphicsLayer-&gt;drawsContent())
3439         return m_graphicsLayer-&gt;tiledBacking() ? TiledCompositingLayer : NormalCompositingLayer;
3440 
3441     return ContainerCompositingLayer;
3442 }
3443 
3444 double RenderLayerBacking::backingStoreMemoryEstimate() const
3445 {
3446     double backingMemory;
3447 
<span class="line-modified">3448     // Layers in m_ancestorClippingStack, m_contentsContainmentLayer and m_childContainmentLayer are just used for masking or containment, so have no backing.</span>
3449     backingMemory = m_graphicsLayer-&gt;backingStoreMemoryEstimate();
3450     if (m_foregroundLayer)
3451         backingMemory += m_foregroundLayer-&gt;backingStoreMemoryEstimate();
3452     if (m_backgroundLayer)
3453         backingMemory += m_backgroundLayer-&gt;backingStoreMemoryEstimate();
3454     if (m_maskLayer)
3455         backingMemory += m_maskLayer-&gt;backingStoreMemoryEstimate();
3456     if (m_childClippingMaskLayer)
3457         backingMemory += m_childClippingMaskLayer-&gt;backingStoreMemoryEstimate();
3458 
3459     if (m_scrolledContentsLayer)
3460         backingMemory += m_scrolledContentsLayer-&gt;backingStoreMemoryEstimate();
3461 
3462     if (m_layerForHorizontalScrollbar)
3463         backingMemory += m_layerForHorizontalScrollbar-&gt;backingStoreMemoryEstimate();
3464 
3465     if (m_layerForVerticalScrollbar)
3466         backingMemory += m_layerForVerticalScrollbar-&gt;backingStoreMemoryEstimate();
3467 
3468     if (m_layerForScrollCorner)
</pre>
<hr />
<pre>
3470 
3471     return backingMemory;
3472 }
3473 
3474 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayerBacking&amp; backing)
3475 {
3476     ts &lt;&lt; &quot;RenderLayerBacking &quot; &lt;&lt; &amp;backing &lt;&lt; &quot; bounds &quot; &lt;&lt; backing.compositedBounds();
3477 
3478     if (backing.isFrameLayerWithTiledBacking())
3479         ts &lt;&lt; &quot; frame layer tiled backing&quot;;
3480     if (backing.paintsIntoWindow())
3481         ts &lt;&lt; &quot; paintsIntoWindow&quot;;
3482     if (backing.paintsIntoCompositedAncestor())
3483         ts &lt;&lt; &quot; paintsIntoCompositedAncestor&quot;;
3484 
3485     ts &lt;&lt; &quot; primary layer ID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID();
3486     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
3487         ts &lt;&lt; &quot; viewport constrained scrolling node &quot; &lt;&lt; nodeID;
3488     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
3489         ts &lt;&lt; &quot; scrolling node &quot; &lt;&lt; nodeID;
<span class="line-added">3490 </span>
<span class="line-added">3491     if (backing.ancestorClippingStack())</span>
<span class="line-added">3492         ts &lt;&lt; &quot; ancestor clip stack &quot; &lt;&lt; *backing.ancestorClippingStack();</span>
<span class="line-added">3493 </span>
3494     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
3495         ts &lt;&lt; &quot; frame hosting node &quot; &lt;&lt; nodeID;
<span class="line-added">3496     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Positioning))</span>
<span class="line-added">3497         ts &lt;&lt; &quot; positioning node &quot; &lt;&lt; nodeID;</span>
3498     return ts;
3499 }
3500 
3501 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>